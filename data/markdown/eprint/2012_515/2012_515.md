# Semantically-Secure Functional Encryption: Possibility Results, Impossibility Results and the Quest for a General Definition

Mihir Bellare<sup>1</sup> Adam O'Neill<sup>2</sup>

August 2012

#### Abstract

This paper explains that SS1-secure functional encryption (FE) as defined by Boneh, Sahai and Waters implicitly incorporates security under key-revealing selective opening attacks (SOA-K). This connection helps intuitively explain their impossibility results and also allows us to prove stronger ones. To fill this gap and move us closer to the (laudable) goal of a general and achievable notion of FE security, we seek and provide two "sans SOA-K" definitions of FE security that we call SS2 and SS3. We prove various possibility results about these definitions. We view our work as a first step towards the challenging goal of a general, meaningful and achievable notion of FE security.

<sup>1</sup> Department of Computer Science & Engineering, University of California San Diego, 9500 Gilman Drive, La Jolla, California 92093, USA. Email: mihir@cs.ucsd.edu. URL: http://www.cs.ucsd.edu/users/mihir. Supported in part by NSF grants CNS-0627779 and CCF-0915675.

<sup>2</sup> Department of Computer Computer Science, Boston University, 111 Cummington St., Boston, MA 02215. Email: amoneill@bu.edu. URL: http://cs-people.bu.edu/amoneill. Supported in part by NSF grants 0546614, 0831281, 1012910, and 1012798.

### <span id="page-1-0"></span>1 Introduction

BACKGROUND. Functional encryption (FE) was introduced by Boneh, Sahai and Waters (BSW) [14]. A FE-scheme for a functionality  $\mathcal{F}$ :  $\mathbb{N} \times \{0,1\}^* \times \{0,1\}^* \to \{0,1\}^* \cup \{\bot\}$  is a tuple of algorithms  $\mathsf{FE} = (\mathsf{Setup}, \mathsf{KDer}, \mathsf{Enc}, \mathsf{Dec})$ . An authority lets  $(pk, sk) \leftarrow \mathsf{s} \, \mathsf{Setup}(\lambda)$ , where  $\lambda$  is the security parameter, and publishes pk. Anyone may now encrypt an input x via  $c \leftarrow \mathsf{s} \, \mathsf{Enc}(pk, x)$ . A user may provide the authority with a functionality index a and receive a secret key  $sk_a \leftarrow \mathsf{s} \, \mathsf{KDer}(sk, a)$ . If the user now applies the decryption algorithm to  $sk_a$  and any encryption c of x, the result  $\mathsf{Dec}(sk_a, c)$  will equal  $\mathcal{F}(\lambda, a, x)$ . Security requires that the user learns nothing more.

The intent was to generalize and unify many forms of encryption including IBE (Identity-based encryption) [32, 13], ABE (Attribute-based encryption) [31, 20] and PE (Predicate encryption) [22]. An existing form **E** of encryption would correspond to a functionality  $\mathcal{F}_{\mathbf{e}}$ . IBE for example corresponds to the functionality  $\mathcal{F}_{\text{ibe}}$  which regards a as an identity and parses x as a pair (a', m) consisting of another identity a' and a message m, returning m if a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and a = a' and

BSW [14] sought a general definition of security that applied to an arbitrary functionality. They first provide an indistinguishability-based one (IND). It had the attractive feature of coinciding, for the IBE and PE functionalities, with the existing definitions of these notions from the literature. But both BSW [14] and O'Neill [29] point to inherent deficiencies of IND when it comes to capturing security of general functionalities. The "main" definition of BSW was accordingly a simulation-based semantic-security one that we call SS1. We may now speak of the SS1-security of an FE scheme FE for any functionality  $\mathcal{F}$ .

The FE framework is elegant and the goals are laudable. A proliferating number of notions of encryption are now put under a single umbrella, seen as special cases of a single primitive. Ad hoc, notion-specific security definitions need not be given. One only has to specify the functionality and SS1 security would return a suitable definition.

IMPOSSIBILITY OF SS1 IN THE NPROM. However, having introduced SS1, BSW [14] claim that it can't be achieved in the standard model, even for IBE, which is the most basic functionality in this area. This is a strong and disappointing claim. Before we delve into its implications, we take a closer look at it. We point out that BSW don't actually prove this. What they prove is that SS1-secure IBE cannot be achieved in the NPROM (Non-Programmable Random Oracle Model). At a first glance, this only sounds like a stronger claim. Every standard model scheme is a NPROM scheme and every standard-model adversary is a NPROM one, so if NPROM achievability is ruled out, isn't standard model achievability ruled out as well? The answer is no. BSW [14] establish their claim by providing an adversary for which they prove that there is no simulator. But their adversary makes calls to the RO, and this is exploited crucially in the proof of non-existence of a simulator. Their proof does not rule out the existence of a simulator for adversaries that do not call the RO, meaning for standard-model adversaries, and thus it does not rule out standard-model achievability of SS1, even for IBE.

This gives a ray of hope. Perhaps SS1-security can be achieved in the standard model after all. This would be interesting even for IBE and certainly beyond. This hope is fueled by a look at the technique underlying the negative result of BSW [14]. It is not a priori clear how to extend this technique to rule out simulators for standard-model adversaries.

A NEW IMPOSSIBILITY RESULT FOR SS1. We fill the gap by showing that SS1-secure IBE is not achievable even in the standard model. The result is actually more general, ruling out SS1-security for *any non-trivial functionality*, IBE being covered as a special case. Non-triviality essentially means the functionality is not a constant function. The only assumption made is the existence of collision-resistant hash functions.

Our result exploits the recent technique of Bellare, Dowsley, Waters and Yilek (BDWY) [5], used to prove the impossibility of SOA-secure commitment, in combination with techniques from Nielsen's

<span id="page-2-1"></span>proof of impossibility of non-committing encryption (NCE) [\[26\]](#page-21-4). We are able to present a standard model adversary for which we can prove that there is no simulator.

Taking a closer look, our result, as is the case with those of Nielsen and BSW, is actually a trade-off. It shows that SS1-security requires long keys, this meaning that the total number of bits in messages securely encrypted must be bounded by the length of a secret key. However, it does this in the standard model.

An explanation. This paper offers an explanation for this anamoly that seeds further contributions in a natural way. We contend that SS1 does not capture "plain" FE security. Instead, it captures FE security in the presence of key-revealing selective-opening attacks (SOA-Ks). These are attacks where the adversary may adaptively corrupt some users and obtain their decryption keys without restrictions. [1](#page-2-0) The revealing fact is that, if we were to write down a definition of SOA-K-security for IBE, what emanates is exactly SS1-secure IBE. We now have a natural explanation of why SS1 is subject to such broad unachievability and also why SS1-secure IBE is not the same as the classical IND-secure IBE from [\[13\]](#page-21-1). Namely, the former incorporates SOA-K security and the latter does not.

Why is SOA-K-security part of SS1? BSW [\[14\]](#page-21-0) did not throw it in "on purpose." (Their work has no explicit recognition of the fact that their definition incorporates security against SOA-K. They do however comment on the relation to NCE and [\[26\]](#page-21-4), which is only a step removed.) Rather, the natural approach to defining semantic security for a general functionality, which is the one followed by BSW [\[14\]](#page-21-0), leads to the inadvertent incorporation of SOA-K security.

While it is usually easier to define "plain" security than security against SOA-K, with FE, it seems to be the opposite. It is not clear how to define semantically-secure FE in a way that "decouples" basic and SOA-K security. This, in our view, is rather interesting.

SS2 and SS3. As indicated above, we believe that unifying different existing forms of encryption under a general definition for FE is a highly worthwhile goal. SS1 has not achieved this, capturing instead the SOA-K-secure versions of these goals and thence being subject to strong impossibility results. We move towards the just-stated goal with two new notions that we call SS2 and SS3. Definining "sans SOA-K" FE security in forms of varying strength, they are able to meet many of the broad goals in this domain and open the door to further efforts.

Our main result about SS2 is that it is equivalent to IND for all functionalities. This equivalence has its plusses and its minuses. Let us begin with the former. IND-secure IBE as per [\[13\]](#page-21-1) is a well established definition, targeted in thousands of papers and proven to work for applications, and INDsecure PE as per [\[22\]](#page-21-3) is also accepted. The SS2=IND equivalence provides a semantic-security based backing for this IND definition which has so far been absent. Conceptually, it mirrors in the FE setting the classic equivalence between semantic-security and indistinguishability in the PKE setting [\[18\]](#page-21-5) that is a cornerstone of our understanding of, and faith in, these definitions. More pragmatically, it immediately yields possibility results for semantically-secure FE which were absent under SS1. This is because INDsecure IBE is well-known to be achievable in the standard model [\[11,](#page-21-6) [36,](#page-22-3) [34\]](#page-22-4), and various possibility results for ABE and PE are known as well [\[20,](#page-21-2) [30,](#page-22-5) [22,](#page-21-3) [27,](#page-22-6) [33,](#page-22-7) [23,](#page-21-7) [2,](#page-20-1) [25,](#page-21-8) [24,](#page-21-9) [28\]](#page-22-8).

We believe this is progress towards bringing semantically-secure FE closer. But, while the equivalence of SS2 with IND is a plus for common functionalities like ABE, PE and IBE, it is a minus when looking further, for we already know that IND is not a good definition of FE security in general [\[29\]](#page-22-2). Thus, we would like another definition to complement SS2. We suggest SS3, a strengthening of SS2. We believe SS3 is a good candidate for a general definition of FE for arbitrary functionalties. One reason is that it does not appear to have the drawbacks of IND for beyond-PE functionalities. (BSW [\[14\]](#page-21-0) and O'Neill [\[29\]](#page-22-2) present IND-secure FE schemes that are intuitively insecure. However, their schemes will correctly be

<span id="page-2-0"></span><sup>1</sup> In the standard formulation of IBE, the adversary has a key-derivation oracle via which it may obtain decryption keys for identities of its choice, but use of the oracle is restricted to identities not underlying challenge ciphertexts. An SOA-K results when there are many challenge ciphertexts and this restriction is dropped. This is exactly what happens in SS1-secure FE. The interesting thing is that in the context of semantic security for general FE it is not clear how to make appropriate restrictions to exclude the SOA-K. We will elaborate in a bit.

<span id="page-3-0"></span>SS3-insecure.) Another reason is that our impossibility result for SS1 does not extend to SS3. (So in particular, SS3-secure IBE is not ruled out.)

In support of SS3 we show that it is equivalent to IND for "re-sampleable" functionalities. Unfortunately, re-sampleable functionalities does not seem to include common functionalities of interest such as IBE. Indeed, we have not been able to either prove or disprove the equivalence of SS3 with IND for PE functionalities. We suggest that IBE and PE schemes may be directly proven to meet SS3 and leave this as an interesting subject for future work. We note that recent independent and concurrent results of Agrawal et al. [\[3\]](#page-20-2) (discussed further below) imply that there exists a functionality that cannot meet SS3. However, this situation is very different from that of SS1, for which we show that no non-trivial functionality can meet it. Indeed, we expect that there do exist IBE and PE schemes that meet SS3.

A closer look. Recall that in IBE, the adversary is given a key-derivation oracle, allowing it to obtain a secret key for any identity of its choice. This does not by itself constitute a SOA-K because the adversary is not allowed to call this oracle for the identities underlying challenge ciphertexts. In the SS1 definition, the adversary also gets a key-derivation oracle to obtain a secret key for any functionality index a of its choice. But there seems no simple or natural way to make a rule disallowing querying this oracle on "challenge" ciphertexts because there is no general way to "match" indexes with ciphertexts. Indeed, any key allows the adversary to learn, in principle, something from all challenge ciphertexts and we can hardly disallow all queries. Instead, SS1 allows unrestricted key-derivation queries and gives a compensating ability to the simulator. But now it incorporates SOA-K and is thus rarely achievable.

Roughly, the idea for SS2 is to run in parallel to the real game a "shadow" game where the inputs are independently generated as per the adversary-provided distributions. Key-derivation queries remain unrestricted. But at the end of the game, we check that the revealed keys don't "differentiate" the real and shadow games. We disallow adversaries who create such differentiation. In essence, this means that we require that the functionality take predictable values on the challenge messages when evaluated with the adversary's key derivation queries. One can compare this to the IND definition where the adversary is required to make key derivation queries that take the same value on the (known) challenge messages, so the adversary knows these values. Our definition may be written quite modularly relative to SS1, by adding appropriate boxed statements and checks in the games for the latter.

Our SS3 definition strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. As such, we believe the SS3 definition is an essentially as-strong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of "unpredictable functionalities" used for our impossibility result in Section [4](#page-8-0) and the fact that the latter crucially uses the adversary's ability to make "adaptive" key-derivation queriesâ€”i.e., depending on a challenge ciphertext. In essence, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.

Standard-model possibility of SS1. Returning to SS1, the negative results discussed above imply that we will need long keys, but we do not know that this is sufficient. There exists only one positive result, and this is in the PROM. Namely, BSW [\[14\]](#page-21-0) provide a long-key, SS1-secure FE scheme for any functionality F where the space of functionality indexes on which F is non-trivial has polynomial size. We extend their result to the standard model. We do this by (again) exploiting the SOA-K connection. Namely we establish the same conclusion as BSW but assuming only the existence of a SOA-K-secure PKE scheme, which we know exists in the standard model because we are allowing keys to be long [\[15,](#page-21-10) [16\]](#page-21-11).

Summary of contributions. We make a connection between selective-opening attacks (SOA-K) and FE by observing the implicit presence of the former in SS1, an observation that seeds all the further contributions of this paper, summarized as follows. (1) We show impossibility of SS1-secure FE in the standard model by exploiting techniques underlying negative results for SOA-K [\[5\]](#page-20-0). (2) We present the SS2 definition for sans-SOA-K FE and prove it equivalent to IND for all functionalties, thus obtaining a slew of possibility results for SS2 via known possibility results for IBE and PE. (3) We present the stronger <span id="page-4-0"></span>SS3 definition to function as a potential target for functionalites beyond PE and prove a possibility result for it. (4) We extend the only known positive result for a general functionality, namely one from BSW [\[14\]](#page-21-0) for the case that the the set of indexes on which the functionality is non-trivial has polynomial size, from the PROM (Programmable Random Oracle Model) to the standard model, by using as starting point a SOA-K-secure PKE scheme with large keys, which exists in the standard model [\[15,](#page-21-10) [16\]](#page-21-11).

Discussion and Related work. The observation underlying BSW's impossibility proof is that SS1 secure IBE must achieve something similar to NCE. O'Neill [\[29\]](#page-22-2) had the same intuitive observation but did not take it to a result or proof. Our work can be viewed as taking this intuition further to say that SS1-secure IBE must be exactly SOA-K-secure IBE, and similarly for other functionalities.

The difference between NCE and SOA-K is subtle but important, and under-recognized by the community. For example, some works say (for the PKE case) that SOA-K security is impossible with short keys, citing [\[26\]](#page-21-4). But, in ruling out NCE, the latter does not rule out SOA-K-security because there are potentially non-NCE ways to achieve SOA-K-security. Our techniques, however, rule out SOA-K-secure PKE with short keys. Although we have known an impossibility result for NCE for a decade, one for SOA-K has only emerged now.

SOAs have so far mainly been considered in the public-key setting. The adversary gets a number of challenge ciphertexts, "opens" a subset of them, and aims to discover something about the messages underlying the rest. There are two kinds of SOAs. In a coin-revealing SOA (SOA-C) the ciphertexts are encrypted under a single public key and opening reveals the coins. Achieving security is challenging but has been done [\[6,](#page-20-3) [17,](#page-21-12) [21\]](#page-21-13). SOA-C-security was also considered and achieved for IBE [\[9\]](#page-21-14). SOA-C is not relevant to our present concerns. In a key-revealing SOA (SOA-K) for PKE, the ciphertexts are encrypted under different public keys and opening reveals the corresponding decryption keys. But SOA-K has not been defined or considered for IBE, let alone for FE. We claim SS1 is, implicitly, defining SOA-K secure FE.

O'Neill [\[29\]](#page-22-2) considers non-adaptive adversaries (meaning ones that don't make any key-derivation queries after seeing the challenge ciphertexts). He provides a non-adaptive version of SS1 and shows it equivalent to a non-adaptive version of IND for preimage sampleable functionalities. Most PE functionalities considered in the literature have this property.

Independently, a recent breakthrough work of Gorbunov, Vaikuntanathan and Wee [\[19\]](#page-21-15) shows that FE for all polynomial-time functionalities can be achieved, subject to the caveat that the adversary in the security experiment make up to q key-derivation queries, where q is fixed ahead of time. Interestingly, they make crucial use of the brute force scheme in their construction, instantiating it with a specific non-committing encryption scheme. (Since the construction only needs to be non-committing wrt. the receiver's secret key and not the sender's randomness, they use a simple construction from [\[16\]](#page-21-11).) Our result on the brute force scheme generalizes theirs as well as BSW's. Another recent breakthrough work of Waters [\[35\]](#page-22-9) contructs public-index PE for regular languages. We believe this recent progress on FE constructions for broader classes of functionalities underscores the importance of our efforts on the definitional front.

Also, interesting works on definitions of FE have emerged on eprint concurrently and independently of our work, namely Agrawal, Gorbunov, Vaikuntanathan and Wee (AGVW) [\[3\]](#page-20-2) and Barbosa and Farshim (BF) [\[4\]](#page-20-4). AGVW present impossibility results for a wPRF based functionality for notions weaker than SS1. As discussed above, their results apply to SS3 and show that SS3 will not be met by all functionalities. They also propose a variant of SS1 that allows an unbounded simulator they call USIM. Interestingly, while they claim BSW's proof also applies to rule out USIM, this impossibility result inherits the same weaknesses we point out above for the basic impossibility result of BSW. Moreover, our improved impossibility result for SS1 assumes collision-resistant hash functions so does not to rule out USIM (because an unbounded simulator can break collision-resistance). Thus, to the best of our knowledge, whether USIM can be achieved is still open. On the other hand BF point to weaknesses in the BSW definition having to do with "set-up" security. Our definition of SS1 and its variants do not appear to inherit these weaknesses because the simulator is not allowed to choose the auxilliary input. (See the body of the <span id="page-5-0"></span>paper for further explanation.) BF also propose variants of the definition that seem similar in spirit to our SS3 and show various possibility and impossibility results about them. We have not yet had a chance to do a detailed comparison to our results.

#### 2 Notation and conventions

If A is an algorithm then  $y \leftarrow A(x_1, \ldots, x_n; r)$  means we run A on inputs  $x_1, \ldots, x_n$  and coins r and denote the output by y. By  $y \leftarrow A(x_1, \ldots, x_n)$  we denote the operation of picking r at random and letting  $y \leftarrow A(x_1, \ldots, x_n; r)$ . By  $[A(x_1, \ldots, x_n)]$  we denote the set of all y that have positive probability of being output by A on inputs  $x_1, \ldots, x_n$ . Unless otherwise indicated, an algorithm may be randomized. "PT" stands for "polynomial time." The security parameter is denoted  $\lambda \in \mathbb{N}$  and whenever  $\lambda$  is input to an algorithm it is understood that it is encoded in unary.

If s is a string then |s| denotes its length, s[i] denotes its ith bit, and  $s[i \dots j]$  denotes the substring consisting of its ith through jth bits. If  $\mathbf{x}$  is a vector then  $|\mathbf{x}|$  denotes the number of its components,  $\mathbf{x}[i]$  denotes its ith component, and  $\mathbf{x}[i \dots j]$  denotes the subvector consisting of its ith through jth components. We write  $\mathsf{El}(\mathbf{x})$  to mean  $\{\mathbf{x}[i]:1\leq i\leq |\mathbf{x}|\}$ . If f is a function and  $\mathbf{x}$  is a vector then  $f(x_1,\dots,x_{i-1},\mathbf{x},x_{i+1},\dots,x_n)$  denotes the vector whose i-th component is  $f(x_1,\dots,x_{i-1},\mathbf{x}[i],x_{i+1},\dots,x_n)$  for  $1\leq i\leq |\mathbf{x}|$ . A predicate is a function with boolean output.

Games. We use the language of code-based game-playing [8]. A game has an Initialize procedure, procedures to respond to adversary oracle queries, and a Finalize procedure. A game G is executed with an adversary A and security parameter  $\lambda$  as follows. A is given input  $\lambda$  and can then call game procedures. Its first oracle query must be Initialize( $\lambda$ ) and its last oracle query must be to Finalize, and it must make exactly one query to each of these oracles. In between it can query the other procedures as oracles as it wishes. The output of Finalize, denoted  $G^A(\lambda)$ , is called the output of the game. Let  $A^G(\lambda)$  denote the output of the adversary and  $T(G,A,\lambda)$  denote  $Pr[G^A(\lambda)]$  outputs true.

STANDARD PRIMITIVES. In Appendix A we recall the standard notions of public-key encryption and collision-resistant hashing.

## 3 Functional Encryption and its Security

Functionalities and FE schemes. A functionality  $\mathcal{F}: \mathbb{N} \times \{0,1\}^* \times \{0,1\}^* \to \{0,1\}^* \cup \{\bot\}$  is a deterministic PT algorithm. The first input is the security parameter. The second input is called the index and the third input is called the payload. A functional encryption (FE) scheme is a tuple of algorithms  $\mathsf{FE} = (\mathsf{Setup}, \mathsf{KDer}, \mathsf{Enc}, \mathsf{Dec})$ . The setup algorithm  $\mathsf{Setup}$  on input  $\lambda$  returns a key-pair (pk, sk), the master public and secret keys. The key-derivation algorithm  $\mathsf{KDer}$  on inputs sk, a returns a secret key dk for a. The encryption algorithm  $\mathsf{Enc}$  on inputs pk, x returns a ciphertext c. The deterministic decryption algorithm  $\mathsf{Dec}$  on inputs dk, c returns a string y. We say that an  $\mathsf{FE}$  scheme  $\mathsf{FE} = (\mathsf{Setup}, \mathsf{KDer}, \mathsf{Enc}, \mathsf{Dec})$  is  $\mathcal{F}$ -correct, or simply an  $\mathcal{F}$ - $\mathsf{FE}$  scheme, if  $\mathsf{Dec}(dk, \mathsf{Enc}(pk, x; r)) = \mathcal{F}(\lambda, a, x)$  for all  $\lambda, a, x, r$  satisfying  $\mathcal{F}(\lambda, a, x) \neq \bot$ , all  $(pk, sk) \in [\mathsf{Setup}(\lambda)]$  and all  $dk \in [\mathsf{KDer}(sk, a)]$ . We stress that correctness makes no requirements when  $\mathcal{F}(\lambda, a, x) = \bot$ . (We do not mandate that  $\mathsf{Dec}(dk, \mathsf{Enc}(pk, x; r)) = \mathcal{F}(\lambda, a, x)$  in this case, but we do not disallow it either.)

SYNTAX AND CORRECTNESS IN BSW. The range of a functionality in the formal definition of BSW [14] does not include  $\bot$ , and correctness asks that  $\mathsf{Dec}(dk,\mathsf{Enc}(pk,x;r)) = \mathcal{F}(\lambda,a,x)$  for all  $\lambda,a,x,r$ , all  $(pk,sk) \in [\mathsf{Setup}(\lambda)]$  and all  $dk \in [\mathsf{KDer}(sk,a)]$ . However, specific functionalites given in BSW (such as that for IBE,  $\mathcal{F}^{\mathsf{P},\mathsf{p}}_{\mathrm{ibe}}$  in our notation) do return  $\bot$ . So it would appear that the formal syntax ought to be amended to add  $\bot$  to the range of  $\mathcal{F}$ . Once this is done, the correctness condition of BSW must be revisited. If left unchanged, it would be asking that  $\mathsf{Dec}(dk,\mathsf{Enc}(pk,x;r)) = \mathcal{F}(\lambda,a,x)$  even when  $\mathcal{F}(\lambda,a,x) = \bot$ . This, however, would be incorrect. Attacks from [1] show that BB-style IBE schemes [10],

<span id="page-6-1"></span>including the BB IBE scheme [10] and Waters's IBE scheme [36], fail to meet this correctness condition relative to  $\mathcal{F}^{\mathsf{P},\mathsf{p}}_{\mathrm{ibe}}$ . It was not clear to us exactly what BSW intended but we expect they did intend for existing IBE schemes to meet the correctness condition, and accordingly we have relaxed it to only hold when  $\mathcal{F}(\lambda,a,x)\neq \bot$ .

PARTICULAR FUNCTIONALITIES. The most important special case of FE in the literature is predicate encryption (PE). We say that  $\mathcal{F}$  is a predicate encryption functionality if there is a predicate  $\mathcal{P}$  such that  $\mathcal{F}$  is  $\mathcal{P}$ -induced. This means that for all  $\lambda$ , all  $a \neq \varepsilon$  and all (a',m) we have  $\mathcal{F}(\lambda,a,(a',m)) = m$  if  $\mathcal{P}(\lambda,a,a')$  = true and  $\bot$  otherwise. (We also require that  $\mathcal{F}(\lambda,a,x)$  returns  $\bot$  if x is not a pair. Note that no requirement is made on  $\mathcal{F}(\lambda,\varepsilon,(a',m))$ , so a single predicate could induce many different functionalities which vary in what is revealed under  $a = \varepsilon$ .) We call m the message. The IBE predicate  $\mathcal{P}_{\text{ibe}}$  is defined by  $\mathcal{P}_{\text{ibe}}(\lambda,a,a') = (a=a')$ , and we say that  $\mathcal{F}$  is an IBE functionality if it is  $\mathcal{P}_{\text{ibe}}$ -induced. (So, again, there may be many different IBE functionalities.) Within the class of PE functionalities, we distinguish whether the index, the message, or both are to be kept private, with corresponding IBE functionalities as canonical examples:

- Public index, private message: We say that  $\mathcal{F}$  is a  $(\mathsf{P},\mathsf{p})$ -PE functionality if  $\mathcal{F}(\lambda,\varepsilon,(a',m))=(a',|m|)$ . Called PE with public index in the literature. The canonical example is the IBE functionality  $\mathcal{F}^{\mathsf{P},\mathsf{p}}_{\mathrm{ibe}}$  which sets  $\mathcal{F}^{\mathsf{P},\mathsf{p}}_{\mathrm{ibe}}(\lambda,\varepsilon,(a',m))=(a',|m|)$ , corresponding to IBE that hides the message but not necessarily the identity.
- Private index, private message: We say that  $\mathcal{F}$  is a (p,p)-PE functionality if  $\mathcal{F}(\lambda,\varepsilon,(a',m))=|m|$ . Called PE with private index in the literature. The canonical example is the IBE functionality  $\mathcal{F}_{ibe}^{p,p}$  which sets  $\mathcal{F}_{ibe}^{p,p}(\lambda,\varepsilon,(a',m))=|m|$ , corresponding to IBE that hides both the message and the identity (i.e. is anonymous).
- Private index, public message: We say that  $\mathcal{F}$  is a (p, P)-PE functionality if  $\mathcal{F}(\lambda, \varepsilon, (a', m)) = m$ . Called predicate-only PE in the literature. The canonical example is the IBE functionality  $\mathcal{F}_{ibe}^{p,P}$  which sets  $\mathcal{F}_{ibe}^{p,P}(\lambda, \varepsilon, (a', m)) = m$ , corresponding to IBE that hides the identity but not necessarily the message. PEKS [12] is a (p, P)-PE functionality that additionally satisfies robustness [1].

We don't discuss (P, P)-PE because it reveals everything and is uninteresting.

SS1 DEFINITION. The following definition is adapted from [14]. Let  $\mathsf{FE} = (\mathsf{Setup}, \mathsf{KDer}, \mathsf{Enc}, \mathsf{Dec})$  be an  $\mathcal{F}\text{-FE}$  scheme. The definition uses games  $\mathsf{RSS1}_{\mathsf{FE},\mathcal{F},Z,D,R}$  and  $\mathsf{ISS1}_{\mathcal{F},Z,D,R}$  of Figure 1. We provide some intuition for these games below. We say that  $\mathsf{FE}$  is  $\mathsf{SS1}\text{-}\mathsf{secure}$  if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A, there is a PT simulator S such that

$$\mathbf{Adv}^{\mathrm{ss1}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \ = \ T(\mathrm{RSS1}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) - T(\mathrm{ISS1}_{\mathcal{F},Z,D,R},S,\cdot)$$

is negligible. We note that the auxiliary input will be used in our impossibility result in Section 4 (where it contains a key for a collision-resistant hash function). Although we omit to do this for simplicity because it does not affect our results, it can also be given as an additional argument to a functionality itself. For example, in the case of the inner-product functionality introduced in [22] it can then contain the modulus N of unknown factorization.

Intuitive overview of the definition. To gain some intuition for the games, let us first look at the "real world" game with the adversary. It has access to two main oracles, an encryption oracle Enc and key-derivation oracle Kd. The former takes input  $\alpha$ , which describes a message-space from which to sample, and outputs the encryption of a sampled message x. The latter takes as input a functionality index a and returns a corresponding secret key. Note that the game records the queries made to these oracles, in order, and provides this as input to the relation R. Now let us look at the "ideal world" game

<span id="page-6-0"></span>The difficulty is that correctness is required for all x, a and thus when x = (a', m) with  $a' \neq a$ , it is required that  $\mathsf{Dec}(dk, \mathsf{Enc}(pk, (a', m); r)) = \bot$  when  $dk \in [\mathsf{KDer}(sk, a)]$ . This is a form of robustness as defined in [1] and, as indicated there, often useful, but it is not a standard requirement for IBE schemes and most don't meet it.

```
PROC INITIALIZE(\lambda):
PROC INITIALIZE(\lambda):
                                                                                                                                   PROC INITIALIZE(\lambda):
                                                              i, j \leftarrow 0 \; ; \; St \leftarrow \varepsilon
                                                                                                                                   (pk, sk) \leftarrow \$ \operatorname{\mathsf{Setup}}(\lambda) \; ; \; i, j \leftarrow 0
(pk, sk) \leftarrow s Setup(\lambda)
                                                              z \leftarrow s Z(\lambda)
z \leftarrow s Z(\lambda)
                                                                                                                                  Return pk
                                                              Return z
i, j \leftarrow 0; St \leftarrow \varepsilon
                                                                                                                                  PROC LR(x_0, x_1)
Return (pk, z)
                                                              PROC Msg(\alpha):
                                                                                                                                  i \leftarrow i + 1; (\mathbf{x}_0[i], \mathbf{x}_1[i]) \leftarrow (x_0, x_1)
                                                              i \leftarrow i + 1
PROC ENC(\alpha):
                                                                                                                                  \mathbf{c}[i] \leftarrow \$ \operatorname{Enc}(pk, x_b)
                                                              \mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
i \leftarrow i+1
                                                                                                                                  Return \mathbf{c}[i]
                                                              (St, \mathbf{x}[i]) \leftarrow D(St, \alpha)
\mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
                                                                                                                                  PROC KD(a):
                                                              Return \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i])
(St, \mathbf{x}[i]) \leftarrow s D(St, \alpha)
                                                                                                                                  j \leftarrow j + 1; \mathbf{a}[j] \leftarrow a
\mathbf{c}[i] \leftarrow \$ \mathsf{Enc}(pk, \mathbf{x}[i])
                                                              PROC OP(a):
                                                                                                                                  dk \leftarrow s \mathsf{KDer}(sk, a)
Return (\mathbf{c}[i], \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i]))
                                                              i \leftarrow i + 1
                                                                                                                                  Return dk
                                                              \mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
PROC KD(a):
                                                                                                                                  PROC FINALIZE(b'):
                                                              Return \varepsilon
i \leftarrow i + 1
                                                                                                                                  \mathbf{a}[j+1] \leftarrow \varepsilon
\mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
                                                              PROC F(a, s):
                                                                                                                                  For j' = 1, ..., j + 1 do
dk \leftarrow * \mathsf{KDer}(sk, a)
                                                              If a \in \mathsf{El}(\mathbf{a}) and 1 \le s \le i then
                                                                                                                                         If \mathcal{F}(\lambda, \mathbf{a}[j'], \mathbf{x}_0) \neq \mathcal{F}(\lambda, \mathbf{a}[j'], \mathbf{x}_1) then
Return dk
                                                                     Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
                                                                                                                                                return false
                                                              Else return \perp
PROC FINALIZE(w):
                                                                                                                                  Return (b'=1)
Return R(\lambda, z, \mathbf{x}, \mathbf{q}, \mathbf{t}, St, w)
                                                             PROC FINALIZE(w):
                                                             Return R(\lambda, z, \mathbf{x}, \mathbf{q}, \mathbf{t}, St, w)
```

<span id="page-7-0"></span>Figure 1: Left: "Real world" game  $RSS1_{\mathsf{FE},\mathcal{F},Z,D,R}$  for the SS1 definition. Middle: "Ideal world" game  $ISS1_{\mathcal{F},Z,D,R}$  for the SS1 definition. Right: game  $IND_{\mathsf{FE},\mathcal{F},b}$  for the IND definition.

with the simulator. The simulator has access to not two but three main oracles, a message sampling oracle Msg, an operation oracle OP, and a functionality oracle F. The first on input  $\alpha$ , which again describes a message-space from which to sample, samples a message x but simply returns  $\mathcal{F}(\lambda, \varepsilon, x)$ . (We follow BSW [14] in using the value under index  $\varepsilon$  to describe what information about the message is publicly computable from a ciphertext.) The second records that an input functionality index a is "legal to be used" by the last oracle. The last oracle takes such an index a and a position s to return  $\mathcal{F}(\lambda, a, x_s)$  where  $x_s$  is the sth sampled message by Msg. Intuitively, OP queries of the simulator correspond to KD queries of the adversary, and indeed they are input to the relation R in the analogous manner. F queries can always be made "for free" by the simulator (they are not input to R).

DISCUSSION OF SS1. We have discussed SS1 as being the BSW [14] definition, which it is in spirit, but there are some differences in detail. BSW indicate that there are several dimensions of choice. They choose to formalize a non-adaptive version with blackbox simulators, saying that variants may be formalized similarly. We have chosen to formalize the variant with adaptive security and non-blackbox simulation. BSW give pk as input to the relation and we do not, but this choice does not matter. However, a novelty of our definition is the introduction of auxiliary inputs. Besides what is noted above in their regard, we note that our use of auxiliary inputs rescues our definitions from the weaknesses of the BSW definition pointed out in BF [4]. The issue raised by the latter arises with a functionality, such as inner-product PE [22], that depends on a parameter, such as a hard-to-factor modulus, that must be generated in a setup phase. Under BSW [14] and O'Neill [29], this would have to be done by the Setup algorithm of the FE scheme and the modulus would be part of pk. The problem raised by BF [4] then occurs because the simulator can pick pk. We, however, do not give pk as input to  $\mathcal{F}$  and would capture setup-based functionalities by having the setup done by the auxiliary input generator algorithm Z, so that the modulus, in our example, would be part of the output z of this algorithm. However, the simulator is not allowed to pick z, and thus the attack of BF [4] would not appear to apply.

IND DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  $\mathcal{F}$ -FE scheme. The definition uses game

```
PROC INITIALIZE(\lambda):
                                                                  z \leftarrow s Z(\lambda)
z \leftarrow s Z(\lambda)
                                                                  Return z
i, j \leftarrow 0; St \leftarrow \varepsilon; St \leftarrow St
Return (pk, z)
                                                                                                                                             PROC FINALIZE(w):
PROC ENC(\alpha):
                                                                  \mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
                                                                                                                                              \mathbf{q}[j+1]
i \leftarrow i + 1
                                                                  (St, \mathbf{x}[i]) \leftarrow *D(St, \alpha)
                                                                                                                                              For j' = 1, ..., j + 1 do
\mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
                                                                                                                                                     If \mathbf{t}[i'] = \mathsf{kd} then
(St, \mathbf{x}[i]) \leftarrow D(St, \alpha)
                                                                                                                                                             If \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}) \neq \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}') then
(St', \mathbf{x}'[i]) \leftarrow s D(St', \alpha)
                                                                                                                                                                     bad \leftarrow true
                                                                  PROC OP(a):
\mathbf{c}[i] \leftarrow \operatorname{sEnc}(pk, \mathbf{x}[i])
                                                                  i \leftarrow i + 1
                                                                                                                                             Return R(\lambda, z, \mathbf{x}, \mathbf{q}, \mathbf{t}, St, w)
Return (\mathbf{c}[i], \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i]))
                                                                  \mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
PROC KD(a):
                                                                  Return \varepsilon
i \leftarrow i + 1
                                                                  PROC F(a, s):
\mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
                                                                  If a \in \mathsf{El}(\mathbf{a}) and 1 \le s \le i then
dk \leftarrow \text{\$} \mathsf{KDer}(sk, a)
                                                                          Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
Return dk
```

<span id="page-8-1"></span>Figure 2: Left: "Real world" game  $RSS2_{\mathsf{FE},\mathcal{F},Z,D,R}$  for the SS2 definition. Middle: "Ideal world" game  $ISS2_{\mathcal{F},Z,D,R}$  for the SS2 definition. Right: FINALIZE procedure, common to the two games.

 $IND_{\mathsf{FE},\mathcal{F},b}$  of Figure 1 for  $b \in \{0,1\}$ . We say that  $\mathsf{FE}$  is IND-secure if for every adversary B,

$$\mathbf{Adv}^{\mathrm{ind}}_{\mathsf{FE},\mathcal{F},B}(\cdot) \ = \ T(\mathrm{IND}_{\mathsf{FE},\mathcal{F},1},B,\cdot) - T(\mathrm{IND}_{\mathsf{FE},\mathcal{F},0},B,\cdot)$$

is negligible.

ROBUSTNESS. Robustness, introduced for IBE and PKE in [1], seems important more generally for FE, particularly for predicate-only predicate encryption. To explain the issue, recall that correctness was mute in the case that  $\mathcal{F}(\lambda, a, x) = \bot$ , meaning in this case no requirement was put on the output of  $\mathsf{Dec}(dk, \mathsf{Enc}(pk, x))$  when  $dk \in [\mathsf{KDer}(sk, a)]$ . Roughly, robustness asks that  $\mathsf{Dec}(dk, \mathsf{Enc}(pk, x)) = \bot$  in this case. In the case of PEKS this is important to avoid false positives in the testing.

The reason it is not quite so simple is that asking for the above condition globally and unconditionally seems to yield something that is hard to achieve. Instead, one can ask for various computational relaxations in the style of [1]. To exemplify, here is one that is very strong but attractive due to its simplicity: procedure Initialize( $\lambda$ ) of game ROB<sub>FE,F</sub> lets  $(pk, sk) \leftarrow s$  Setup( $\lambda$ ) and returns both keys, meaning the adversary gets sk. Finalize(a, x) returns  $((\mathcal{F}(\lambda, a, x) = \bot) \land (\mathsf{Dec}(\mathsf{KDer}(sk, a), \mathsf{Enc}(pk, x)) \neq \bot)$ .

## <span id="page-8-0"></span>4 Impossibility Results

We show that the SS1 notion is *impossible* to achieve in the *standard model*, so long as the functionality is reasonably likely to take more than one possible value on a challenge message. This result only assumes the existence of a collision-resistant hash function.

Following [14] we also consider a relaxation of the SS1 notion where vectors  $\mathbf{a}$ ,  $\boldsymbol{\alpha}$  are replaced by unordered sets, thus giving the simulator more power (since it can make its queries in a different order than the adversary). We obtain a similar but more restrictive impossibility result in this case. Here we present the ordered case. The unordered one is in Appendix B.

UNPREDICTABLE FUNCTIONALITIES. In the ordered case our result applies to any unpredictable functionality. Let  $\mathcal{F}$  be a functionality,  $\mathcal{A} = \{a_{\lambda}\}_{{\lambda} \in \mathbb{N}}$  be a family of functionality indices (strings), and  $\mathcal{X} = \{X_{\lambda}\}_{{\lambda} \in \mathbb{N}}$  be a family of payload distributions. We say that  $\mathcal{F}$  is  $p(\cdot)$ -unpredictable wrt.  $\mathcal{A}, \mathcal{X}$  if for

```
PROC INITIALIZE(\lambda):
z \leftarrow s Z(\lambda)
                                                                Return z
i, j \leftarrow 0; St \leftarrow \varepsilon; St' \leftarrow \varepsilon
                                                                PROC Msg(\alpha):
Return (pk, z)
PROC ENC(\alpha):
                                                                \mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
i \leftarrow i + 1
                                                                (St, \mathbf{x}[i]) \leftarrow D(St, \alpha)
\mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
                                                                (St', \mathbf{x}'[i]) \leftarrow *D(St', \alpha)
(St, \mathbf{x}[i]) \leftarrow s D(St, \alpha)
                                                                Return \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i])
(St', \mathbf{x}'[i]) \leftarrow s D(St', \alpha)
                                                                PROC OP(a):
\mathbf{c}[i] \leftarrow \$ \operatorname{Enc}(pk, \mathbf{x}[i])
                                                                i \leftarrow i + 1
Return (\mathbf{c}[i], \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i]))
                                                                \mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
PROC KD(a):
                                                                Return \varepsilon
i \leftarrow i + 1
                                                                PROC F(a, s):
\mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
                                                                If a \in \mathsf{El}(\mathbf{a}) and 1 \le s \le i then
dk \leftarrow s \mathsf{KDer}(sk, a)
                                                                        Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
Return dk
                                                                Else return \perp
```

PROC FINALIZE(w)

```
|\mathbf{q}[i+1] \leftarrow \varepsilon \; ; \; \mathbf{t}[i+1] \leftarrow \mathsf{kd}
For i' = 1, ..., i + 1 and j' = i' + 1, ..., i + 1 do
       If \mathbf{t}[i'] = \mathsf{enc} \ \land \ \mathbf{t}[j'] = \mathsf{kd} \ \mathsf{then}
               If \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}[i']) \neq \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}'[i']) then
                       bad â† true
```

Return  $R(\lambda, z, \mathbf{x}, \mathbf{q}, \mathbf{t}, St, w)$

<span id="page-9-1"></span>Figure 3: Left: "Real world" game  $RSS3_{FE,\mathcal{F},Z,D,R}$  for the SS3 definition. Middle: "Ideal world" game ISS3<sub> $\mathcal{F},Z,D,R$ </sub> for the SS3 definition. Right: FINALIZE procedure, common to the two games.

all  $\lambda \in \mathbb{N}$  and all  $y \in \{0,1\}^* \cup \{\bot\}$ ,  $\Pr[x \leftarrow X_\lambda : y = \mathcal{F}(\lambda, a_\lambda, x)] \leq 1 - 1/p(\lambda)$ . For example, the functionality  $\mathcal{F}^{\mathsf{P},\mathsf{p}}_{\mathsf{bit-ibe}}$  for a one-bit IBE scheme, which parses x as (a',b), and returns b if a = a' and  $\perp$  otherwise, is a 2-unpredictable function wrt.  $\mathcal{A}, \mathcal{X}$  where, for all  $\lambda \in \mathbb{N}$ , we let  $a_{\lambda}$  be a fixed but arbitrary identity and  $\mathcal{X}_{\lambda}$  return  $(a_{\lambda}, d)$  where the message  $d \in \{0, 1\}$  is random. As another example, the functionality  $\mathcal{F}_{\text{peks}}^{\mathsf{p},\mathsf{P}}$  for a PEKS scheme, which returns 1 if a=x and  $\perp$  otherwise, is a 2-unpredictable function wrt.  $\mathcal{A}, \mathcal{X}$  where for all  $\lambda \in \mathbb{N}$ , we again let  $a_{\lambda}$  be fixed but arbitrary keyword and  $\mathcal{X}_{\lambda}$  return a random keyword  $x \in \{a_{\lambda}, a'_{\lambda}\}$  for some also fixed but arbitrary  $a'_{\lambda} \neq a_{\lambda}$ . Indeed, unpredictability with respect to some family of input distributions and functionality indices is a minimal requirement for a functionality to be interesting; otherwise, it is trivial to build an FE scheme for it because anyone can decrypt correctly without even using the ciphertext. In this sense, our result below rules out an SS1-secure FE scheme for any non-trivial functionality.

SECRET-KEY LENGTH. we say that an FE scheme FE = (Setup, KDer, Enc, Dec) has secret-key length  $\ell(\cdot)$ if  $|dk| < \ell(\lambda) = \mathcal{F}(\lambda, a, x)$  for all  $\lambda, a, x, r$ , all  $(pk, sk) \in [\mathsf{Setup}(\lambda)]$ , and all  $dk \in [\mathsf{KDer}(sk, a)]$ . Note that every FE scheme must have some polynomial  $\ell(\cdot)$  secret-key length in order to be efficient.

<span id="page-9-0"></span>**Theorem 4.1** Let  $p(\cdot) > 1$  be a polynomial. Suppose  $\mathcal{F}$  is a  $p(\cdot)$ -unpredictable functionality wrt.  $\mathcal{A} = \mathbf{1}$  $\{a_{\lambda}\}_{{\lambda}\in\mathbb{N}}, \mathcal{X}=\{X_{\lambda}\}_{{\lambda}\in\mathbb{N}},$  Furthermore, suppose that for every  ${\lambda}\in N$ ,  $\mathcal{F}({\lambda},{\varepsilon},x)$  is the same for all  $x \in [X_{\lambda}]$ . Let  $\mathcal{H} = (K, H)$  be a collision-resistant hash function. Then there does not exist an SS1-secure  $\mathcal{F}$ -FE scheme. More precisely, suppose FE is a  $\mathcal{F}$ -FE scheme with secret-key length  $\ell(\cdot)$ . Then for any function  $\mu(\cdot)$  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation R, and CR-adversary C such that for every simulator S

$$\mathbf{Adv}^{\mathrm{ss}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \geq 1 - \sqrt{\mathbf{Adv}^{\mathrm{col}}_{\mathcal{H},C}(\cdot) + 1/\mu(\cdot)}$$

Adversary A makes  $p(\cdot)(\ell(\cdot) + \log \mu(\cdot))$  encryption queries and two key-derivation queries.

To compare, BSW [14] ruled out SS1-secure IBE against adversaries with access to a non-programmable random oracle, so our result improves theirs in two respects: to applies to any non-trivial functionality and standard-model adversaries. It also reveals a trade-off between secret-key length and the total number of bits encrypted. Namely, when the difference is even one bit (i.e., the total number of bits encrypted is one

```
Alg R(\lambda, \mathbf{x}, \mathbf{a}, \boldsymbol{\alpha}, St, w):
Alg A(pk, hk):
                                                   (pk, \mathbf{c}, h, f, sk_h, sk_a) \leftarrow w
For i = 1, \ldots, n(\lambda) do:
                                                  If h \neq H(hk, pk||\mathbf{c}) then return false
      \mathbf{c}[i] \leftarrow s \operatorname{Enc}(\lambda)
                                                  If |sk_h| \neq \ell or |sk_a| \neq \ell then return false
h \leftarrow H(hk, pk || \mathbf{c})
                                                   If |\alpha| \neq n \lor \alpha \neq (\lambda, \ldots, \lambda) then return false
sk_h \leftarrow s KD(h)
                                                  If |\mathbf{a}| \neq 2 \lor \mathbf{a}[1] \neq h \lor \mathbf{a}[2] \neq a_{\lambda} then return false
sk_a \leftarrow s KD(a_\lambda)
                                                   If Dec(sk_a, \mathbf{c}) \neq \mathcal{F}(\lambda, a_\lambda, \mathbf{x}) then return false
w \leftarrow (pk, \mathbf{c}, h, f, sk_h, sk_a)
                                                  Return true
Return w
```

<span id="page-10-0"></span>Figure 4: Algorithms A and R for proof of Theorem 4.1.

```
Alg S_2(\overline{St}):
                                                                                                                                                Adversary C(\lambda):
Alg S_1(\lambda):
                                                                                                                                                hk \leftarrow \text{sInitialize}(\lambda)
i \leftarrow 0
z \leftarrow \text{$"s$ Initialize}(\lambda)
                                                                           For i = 1, \dots, n(\lambda) do \mathbf{x}[i] \leftarrow X_{\lambda}
                                                                                                                                               Run S_1 on \lambda,
                                                                                                                                                      replying to Initialize with hk
Run S(z):
                                                                           Run S at state St:
                                                                                                                                                Let \overline{St} be the output of S_1
On message-query \alpha do:
                                                                           On message-query \alpha do:
                                                                                                                                               w^1, w^2 \leftarrow S_2(\overline{St})
     i \leftarrow i + 1; Return \overline{\varepsilon}
                                                                                 i \leftarrow i + 1; Return \overline{\varepsilon}
                                                                                                                                               \begin{array}{l} (pk^1, \mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1) \leftarrow w^1 \\ (pk^2, \mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2) \leftarrow w^2 \end{array}
On op-query a do:
                                                                           On op-query a do:
     Halt computation of S_1 with state St
                                                                                 A \leftarrow A \cup \{a\}; Return \varepsilon
\overline{St} \leftarrow St || i ; \text{ Return } \overline{St}
                                                                           On F-query (a, s) do:
                                                                                                                                                Return (pk^1||\mathbf{c}^1, pk^2||\mathbf{c}^2)
                                                                                 If 1 \le s \le i and a \in A do:
                                                                                 Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
                                                                                 Else return \perp
                                                                          Let w be the output of S; Return w
```

<span id="page-10-2"></span>Figure 5: Algorithms  $S_1, S_2$  and C for proof of Theorem 4.1.

more than the secret-key length) our adversary's advantage is non-negligible. We also note that, while for technical reasons we require  $\mathcal{F}(\lambda, \varepsilon, x)$  to take the same value on every possible challenge payload x, this is not a major restriction in practice since typically  $\mathcal{F}(\lambda, \varepsilon, x) = |x|$ ; then we are just requiring as usual that possible challenge messages have the same length.

<span id="page-10-1"></span>The proof combines and extends ideas of [14] and [5]. As in [5] will make use of a version of the Reset Lemma of [7].

**Lemma 4.2** Let  $P_1, P_2$  be algorithms, the second with boolean output. The single-execution acceptance probability  $\mathbf{AP}_1(P_1, P_2, \lambda)$  is defined as the probability that  $d = \mathsf{true}$  in the single execution experiment  $\overline{St} \leftarrow \$ P_1(\lambda)$ ;  $d \leftarrow \$ P_2(\overline{St})$ . The double-execution acceptance probability  $\mathbf{AP}_2(P_1, P_2, \lambda)$  is defined as the probability that  $d_1 = d_2 = \mathsf{true}$  in the double execution experiment  $\overline{St} \leftarrow \$ P_1(\lambda)$ ;  $d_0, d_1 \leftarrow \$ P_2(\overline{St})$ . Then  $\mathbf{AP}_1(P_1, P_2, \lambda) \leq \sqrt{\mathbf{AP}_2(P_1, P_2, \lambda)}$  for all  $\lambda \in \mathbb{N}$ .

**Proof of Theorem 4.1:** For  $\lambda \in \mathbb{N}$  denote by  $\overline{\varepsilon}_{\lambda}$  the value such that  $\mathcal{F}(\lambda, \varepsilon, x) = \overline{\varepsilon}_{\lambda}$  for all  $x \in [X_{\lambda}]$ . Let  $n(\cdot) = p(\cdot)(\ell(\cdot) + \log \mu(\cdot))$ . Define Z on input  $\lambda$  to return  $hk \leftarrow K(\lambda)$ . Define message sampler D on inputs St,  $\alpha$  to (ignore St and) return  $x \leftarrow X(\alpha)$ . Define adversary A and relation R as in Figure 4.

By construction  $\Pr\left[\mathrm{RSS}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\cdot)\right] = 1$ . Let S be any simulator. Wlog assume that it makes no F-query preceding its first Op-query (the response to such a query would be  $\bot$ ). Furthermore, parsing the output of S as  $(pk, \mathbf{c}, h, f, sk_h, sk_a, hk) \leftarrow w$ , we assume it holds that  $h = H(hk, pk||\mathbf{c})$ ,  $|sk_h| = |sk_a| = \ell$ ,  $|\alpha| = n$ ,  $\alpha = (\lambda, \ldots, \lambda)$ ,  $|\mathbf{a}| = 2$ ,  $\mathbf{a}[1] = h$ , and  $\mathbf{a}[2] = a_{\lambda}$ , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write execution of S in Game ISS1 as a composition of two algorithms  $S_1, S_2$  as in Figure 5.

Namely,  $S_1$  runs S up to the point that it makes its first OP query, and  $S_2$  runs S following this OP query. It also samples  $\mathbf{x}$  all at once instead of defining its individual components when responding to

each message query, but this is equivalent and makes the analysis more transparent. Below we justify the following sequence of inequalities, for C, Y defined below:

$$\Pr\left[\text{ISS1}_{\mathcal{F},Z,D,R}^{S}(\cdot)\right] = \mathbf{AP}_{1}(S_{1}, S_{2}, \lambda) \leq \sqrt{\mathbf{AP}_{2}(S_{1}, S_{2}, \lambda)} \leq \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + \Pr\left[\mathcal{F}(\lambda, a_{\lambda}, \mathbf{x}) \in Y\right]}$$

$$\leq \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + 2^{\ell}(1 - 1/p)^{n}} < \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + 2^{\ell}2^{-(\ell + \log \mu(\lambda))}}$$

$$= \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + 1/\mu(\lambda)}.$$

Above, the first inequality is by construction and the second is by Lemma 4.2. For the third, consider the CR-adversary C against  $\mathcal{H}$  also defined in Figure 5. Note that C simply mimics the double execution experiment with  $S_1, S_2$ . Let us also denote the two outputs of  $S_2$  in that experiment as  $w^1 = (pk^1, \mathbf{c}^1, h^1, f^1, sk_h^1, sk_a^1)$  and  $w^2 = (pk^2, \mathbf{c}^2, h^2, f^2, sk_h^2, sk_a^2)$ . Now, unless C finds a collision we have  $\mathbf{c}^1 = \mathbf{c}^2$ , denote by  $\mathbf{c}^*$  this common value. Then define the set  $Y := \{y \in \{0,1\}^* : \exists s \in \{0,1\}^\ell \text{ s.t. Dec}(s,\mathbf{c}^*) = y\}$ . If it is not the case that  $\mathcal{F}(\lambda,a_\lambda,\mathbf{x}) \in Y$  when  $\mathbf{x}$  is sampled by  $S_2$  then the relation R must reject, as no  $sk_a^2$  will satisfy  $\mathrm{Dec}(sk_a^2,\mathbf{c}) = \mathcal{F}(\lambda,a_\lambda,\mathbf{x})$  (recall we assume  $|sk_a^2| = \ell$  here as otherwise R rejects), justifying the third inequality above. The fourth equality above uses the unpredictability of  $\mathcal{F}$  and a union bound. For the fifth we substitute  $n(\lambda) = p(\lambda)(\ell(\lambda) + \log(\mu(\lambda)))$  and use the inequality  $(1 - 1/x)^x \le 1/e < 1/2$  for any real number  $x \ge 1$  (here e is Euler's constant).

## <span id="page-11-2"></span>5 Equivalence for Restricted Definitions of Semantic Security

Motivated by the impossibility results of Section 4, take up the direction of providing variants of the SS definition that are *achievable*.

### 5.1 SS2 and its Equivalence to IND for All Functionalities

We start by providing our SS2 definition that we show is *equivalent* to IND, thus demonstrating that the IND definition targeted in the literature is indeed equivalent to some form of semantic security.

SS2 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  $\mathcal{F}$ -FE scheme. The definition uses games  $\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R}$  and  $\mathrm{ISS2}_{\mathcal{F},Z,D,R}$  of Figure 2, with the boxed code indicating the differences from the corresponding games in Figure 1, i.e., removing the boxed code recovers the SS1 games. Let D be a message sampler and A an adversary. We say that (D,A) is SS2-valid with failure probability  $\nu(\cdot)$  if  $\mathrm{Pr}\left[\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\cdot)\right] \leq \nu(\cdot)$ . When  $\nu(\cdot)$  is negligible we say (D,A) is SS2-valid. (Note that this probability does not depend on the relation R, so it can be anything.) We say that FE is SS2-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is SS2-valid, and every PT relation R, there is a PT simulator S such that

$$\mathbf{Adv}^{\mathrm{ss2}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \ = \ T(\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) - T(\mathrm{ISS2}_{\mathcal{F},Z,D,R},S,\cdot)$$

is negligible. Intuitively, the definition mandates that an adversary only make key-derivation queries for functions under which any possible challenge message takes the same value. For example, for IBE this corresponds to mandating that any key-derivation query made by the adversary never makes a key-derivation query for a key that decrypts a challenge ciphertext (or decrypts it to a predictable value), which is a natural restriction. The following theorem follows from the claims below.

**Theorem 5.1** Let  $\mathcal{F}$  be a functionality and let FE = (Setup, KDer, Enc, Dec) be an  $\mathcal{F}$ -FE scheme. Then FE is SS2-secure if and only if it is IND-secure.

<span id="page-11-0"></span>Claim 5.2 (SS2  $\Rightarrow$  IND) Let B be an IND-adversary. Then there is a message sampler D, relation R, and adversary A such that for every simulator S

<span id="page-11-1"></span>
$$\mathbf{Adv}^{\mathrm{ind}}_{\mathsf{FE},\mathcal{F},B}(\cdot) \leq 2 \cdot \mathbf{Adv}^{\mathrm{ss2}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot)$$
 (1)

```
Alg R(1^k, \mathbf{x}, \mathbf{a}, \boldsymbol{\alpha}, St, w):
Alg D(St, \alpha):
                                                   Alg A(pk):
If St = \varepsilon then St \leftarrow \$\{0, 1\}
                                                                                                                        \mathbf{x}_0 \| \mathbf{x}_1 \leftarrow \boldsymbol{\alpha}
                                                   Run B(pk):
                                                                                                                        \mathbf{a}[|\mathbf{a}|+1] \leftarrow \varepsilon
x_0 || x_1 \leftarrow \alpha
                                                         On left-or-right query (x_0, x_1):
Return (St, x_{St})
                                                                                                                        For j = 1, ..., |\mathbf{a}| + 1 do
                                                               c \leftarrow s \operatorname{Enc}(x_0 || x_1)
                                                                                                                               If \mathcal{F}(1^k, \mathbf{a}[j], \mathbf{x}_0) \neq \mathcal{F}(1^k, \mathbf{a}[j], \mathbf{x}_1)
                                                               Return c
                                                                                                                                     then return false
                                                          On query key-derivation query a:
                                                                                                                        Return (\mathbf{x} = \mathbf{x}_w)
                                                               dk \leftarrow s KD(a)
                                                               Return dk
                                                   Let b' be the output of A
                                                   Return b'
```

<span id="page-12-0"></span>Figure 6: Algorithms for proof of Claim 5.2.

Furthermore, (D, A) is SS2-valid and the running-time of D, R, A is that of B.

**Proof:** Define the message sampler D, adversary A, and relation R as in Figure 6. Then by construction  $T(\text{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) = T(\text{IND}_{\mathsf{FE},\mathcal{F}},B,\cdot)$ . Moreover, we claim that for every simulator S we have  $T(\text{ISS2}_{\mathcal{F},Z,D,R,S},\cdot) \leq 1/2$ . This is because we can assume wlog that S's queries are such that  $\mathcal{F}(1^k,a,\mathbf{x}_0) = \mathcal{F}(1^k,a,\mathbf{x}_1)$  for all  $\mathsf{El}(a) \in \mathbf{a} \cup \varepsilon$  (since otherwise R returns false), so S gets no information about the bit b. Subtracting, we get

$$\mathbf{Adv}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}^{\mathrm{ss2}}(\cdot) = T(\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) - T(\mathrm{ISS2}_{\mathcal{F},Z,D,R},S,\cdot) \ge T(\mathrm{IND}_{\mathsf{FE},\mathcal{F}},B,\cdot) - 1/2$$
$$= 1/2 \cdot \mathbf{Adv}_{\mathsf{FE},\mathcal{F},B}^{\mathrm{ind}}(\cdot)$$

which implies Equation (1). To complete the proof we note that (D, A) is SS2-valid because we may assume wlog that B's queries are such that  $\mathcal{F}(1^k, a, \mathbf{x}_0) = \mathcal{F}(1^k, a, \mathbf{x}_1)$  for all  $a \in \mathsf{El}(\mathbf{a}) \cup \varepsilon$  (otherwise its advantage can only go down).

<span id="page-12-1"></span>Claim 5.3 (IND  $\Rightarrow$  SS2) Let D be a message sampler, A be an SS2-adversary, and R be a relation such that (D,A) is SS2-valid with failure probability  $\nu(\cdot)$ . Then there is a simulator S and an IND-adversary B such that

$$\mathbf{Adv}^{\mathrm{ss2}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \ \leq \ \mathbf{Adv}^{\mathrm{ind}}_{\mathsf{FE},\mathcal{F},B}(\cdot) + 2\nu(\cdot) \ .$$

The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus twice that of D.

**Proof:** Define S and B as in Figure 7. Without affecting the output of the game, we may have the Finalize procedure of Game  $\text{IND}_{\mathsf{FE},\mathcal{F},0}^B(\cdot)$  set a flag bad when the "return false" statement is executed. Then, viewing Games  $\text{IND}_{\mathsf{FE},\mathcal{F},0}^B(\cdot)$  and  $\text{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\cdot)$  as executed over a common finite space of coins, we have that in the language of [8] they are identical-until-bad. Therefore, by the Fundamental Lemma of [8]

$$T(\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) \leq T(\mathrm{IND}_{\mathsf{FE},\mathcal{F},1},B,\cdot) + \Pr\left[\,\mathrm{RSS2}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\cdot) \text{ sets bad}\,\right]\,.$$

By an analogous argument

$$T(\mathrm{ISS2}_{\mathcal{F},Z,D,R},S,\cdot) \geq T(\mathrm{IND}_{\mathsf{FE},\mathcal{F},0},B,\cdot) - \Pr\left[\,\mathrm{ISS2}_{\mathsf{FE},\mathcal{F},Z,D,R}^S(\cdot) \text{ sets bad}\,\right]\,.$$

Subtracting yields Equation (5.3).

It is worth pointing out in the proof of the second claim above that the constructed simulator S needs not ever query its oracles. This is because we are guaranteed that, since (D, A) is SS2-valid, the "dummy" messages sampled independently from the challenge ones have the same value under any function queried by A to its key-derivation oracle.

```
Alg S(1^k):
                                                      Alg B(pk):
St \leftarrow \varepsilon
                                                      i, j \leftarrow 0
(pk, sk) \leftarrow s \mathsf{Setup}(1^k)
                                                       St_0, St_1 \leftarrow \varepsilon
                                                      Run A(pk):
Run A(pk):
                                                            On encryption query \alpha:
     On encryption query \alpha:
           y \leftarrow s \operatorname{Msg}(\alpha)
                                                                  i \leftarrow i + 1; \alpha[i] \leftarrow \alpha
           (St, x) \leftarrow D(St, \alpha)
                                                                  (St_0, \mathbf{x}_0[i]) \leftarrow D(St_0, \alpha)
                                                                  (St_1, \mathbf{x}_1[i]) \leftarrow s D(St_1, \alpha)
           c \leftarrow s \operatorname{Enc}(pk, x)
           Return (c, y)
                                                                  Return LR(\mathbf{x}_0[i], \mathbf{x}_1[i])
                                                            On key-derivation query a:
     On key-derivation query a:
                                                                  j \leftarrow j + 1; \mathbf{a}[j] \leftarrow a
           dk \leftarrow s \mathsf{KDer}(sk, a)
           Return dk
                                                                  dk \leftarrow \$ KD(a)
                                                                 Return dk
Let w be the output of A
                                                      Let w be the output of A
Return w
                                                      Return R(1^k, \mathbf{x}_1, \mathbf{a}, \boldsymbol{\alpha}, St_1, w)
```

<span id="page-13-0"></span>Figure 7: Algorithms for proof of Claim 5.3.

### 5.2 SS3 and its Equivalence to IND for Resampleable Functionalities

The SS2 definition is not as strong as one would like because for some functionalities IND (which we showed equivalent to SS2) is a "bad" definition. To address this we now introduce the SS3 definition, which strengthens SS2 by dropping the restriction put by SS2 on key-derivation queries made by an adversary before seeing a challenge ciphertext. Indeed, we believe the SS3 definition is an essentially asstrong-as-possible security definition for FE subject to the constraint that it be achievable without any unnatural restrictions on the adversary or message space. To see why, note the definition of "unpredictable functionalities" used for our impossibility result in Section 4 and the fact that the latter crucially uses the adversary's ability to make "adaptive" key-derivation queriesâ€”i.e., depending on a challenge ciphertext. In some sense, the SS3 definition demands that the functionality restricted to the adversary's adaptive key derivation queries be predictable wrt. the message space.

SS3 DEFINITION. Let FE = (Setup, KDer, Enc, Dec) be an  $\mathcal{F}$ -FE scheme. The definition uses games  $\mathrm{RSS3_{FE}}, \mathcal{F}, \mathcal{Z}, \mathcal{D}, \mathcal{R}$  and  $\mathrm{ISS3_{\mathcal{F}}}, \mathcal{Z}, \mathcal{D}, \mathcal{R}$  of Figure 3, with the boxed code indicating the differences from the corresponding games in Figure 2, i.e., the games differ from SS2 only in the Finalize procedure. Let D be a message sampler and A an adversary. We say that (D,A) is SS3-valid with failure probability  $\nu(\cdot)$  if  $\Pr\left[\mathrm{RSS3_{FE}^{A}}, \mathcal{F}, \mathcal{Z}, \mathcal{D}, \mathcal{R}(\cdot) \text{ sets bad}\right] \leq \nu(\cdot)$ . When  $\nu(\cdot)$  is negligible we say (D,A) is SS3-valid. (Note that this probability does not depend on the relation R, so it can be arbitrary.) We say that FE is SS3-secure if for every PT auxiliary input generator Z, every message sampler D and PT adversary A such that (D,A) is valid, and every PT relation R, there is a PT simulator S such that

$$\mathbf{Adv}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}^{\mathrm{ss3}}(\cdot) \ = \ T(\mathrm{RSS3}_{\mathsf{FE},\mathcal{F},Z,D,R},A,\cdot) - T(\mathrm{ISS3}_{\mathcal{F},Z,D,R},S,\cdot)$$

is negligible.

RESAMPLEABILITY. Let  $\mathcal{F}$  be a functionality,  $\overline{D}$ , D be algorithms. For an adversary B we let

$$\mathbf{Adv}^{\mathrm{rs}}_{\overline{D},D,\mathcal{F},B}(\cdot) \ = \ T(\mathrm{Rsmp}_{\overline{D},D,\mathcal{F},1},B,\cdot) - T(\mathrm{Rsmp}_{\overline{D},D,\mathcal{F},0},B,\cdot)$$

where the game is in Figure 10. Furthermore, let  $\mathbf{Adv}_{\overline{D},D,\mathcal{F}}^{\mathrm{rs}}(\cdot) = \max_{B} \{\mathbf{Adv}_{\overline{D},D,\mathcal{F},B}^{\mathrm{rs}}(\cdot)\}$  where the maximum is over all PT B making one challenge query.

We say that an algorithm  $\overline{D}$  is a  $\mu(\cdot)$ -accurate resampler for  $\mathcal F$  relative to algorithm D if  $\mathbf{Adv}^{\mathrm{rs}}_{\overline{D},D,\mathcal F}(\cdot) \leq \mu(\cdot)$ . We say that  $\mathcal F$  is  $\mu(\cdot)$ -accurately reampleable if for all PPT D there exists a PPT  $\overline{D}$  such that  $\overline{D}$  is a  $\mu(\cdot)$ -accurate resampler for  $\mathcal F$  relative to D. When  $\mu(\cdot)$  is negligible we say that  $\mathcal F$  is accurately resampleable.

THE EQUIVALENCE. The following says that the SS3 notion is equivalent to IND for any accurately

<span id="page-14-1"></span>resampleable functionality  $\mathcal{F}$ .

**Theorem 5.4** Let  $\mathcal{F}$  be an accurately resampleable functionality and let FE = (Setup, KDer, Enc, Dec) be an  $\mathcal{F}$ -FE scheme. Then FE is SS3-secure if and only if it is IND-secure.

<span id="page-14-0"></span>Since SS3 is clearly stronger than SS2, it is immediate from Claim 5.2 that SS3 implies IND. Below we show the converse, which proves the theorem.

Claim 5.5 (IND  $\Rightarrow$  SS3) Let D be a message sampler, A be an SS2-adversary making at most  $q_e$  encryption queries, and R be a relation such that (D,A) is SS3-valid with failure probability  $\nu(\cdot)$ . Suppose  $\mathcal{F}$  is  $\mu(\cdot)$ -accurately resampleable, and let  $\overline{D}$  denote the corresponding  $\mu(\cdot)$ -accurate resampler. Then there is a simulator S and an IND-adversary B such that

$$\mathbf{Adv}^{\mathrm{ss3}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \ \leq \ \mathbf{Adv}^{\mathrm{ind}}_{\mathsf{FE},\mathcal{F},B}(\cdot) + 2\nu(\cdot) + 2q_e\mu(\cdot) \ .$$

The running-time of S is that of D, R, A and the running-time of B is at most twice that of R, A plus the time for  $q_e$  executions of  $\overline{D}$ .

#### **Proof:**

Define S and B as in Figure 9. Furthermore, define hybrid games RSS3-H1<sub>FE, $\mathcal{F}$ , $\mathcal{Z}$ , $\mathcal{D}$ , $\mathcal{R}$  and RSS3-H2<sub>FE, $\mathcal{F}$ , $\mathcal{Z}$ , $\mathcal{D}$ , $\mathcal{R}$  as in Figure 8. Below we justify the following sequence of inequalities:</sub></sub>

$$\begin{split} T(\mathrm{RSS3_{FE},}_{\mathcal{F},Z,D,R},A,\cdot) & \leq & T(\mathrm{RSS3-H1_{FE},}_{\mathcal{F},Z,D,R},A,\cdot) + \Pr\left[\mathrm{RSS3_{FE},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}_1\right] \\ & \leq & T(\mathrm{RSS3-H2_{FE},}_{\mathcal{F},Z,D,R},A,\cdot) + \Pr\left[\mathrm{RSS3-H1_{FE}^{A},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}_2\right] \\ & & + \Pr\left[\mathrm{RSS3_{FE},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}_1\right] \\ & = & T(\mathrm{IND_{FE},}_{\mathcal{F},1},B,\cdot) + \Pr\left[\mathrm{RSS3-H1_{FE}^{A},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}\right] \\ & & + \Pr\left[\mathrm{RSS3_{FE},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}_1\right] \\ & \leq & T(\mathrm{IND_{FE},}_{\mathcal{F},1},B,\cdot) + \Pr\left[\mathrm{RSS3-H1_{FE}^{A},}_{\mathcal{F},Z,D,R}(\cdot) \text{ sets bad}_2\right] + \nu(\cdot) \\ & \leq & T(\mathrm{IND_{FE},}_{\mathcal{F},1},B,\cdot) + q_e(\cdot)\mu(\cdot) + \nu(\cdot) \;. \end{split}$$

Above, the first two inequalities are by the Fundamental Lemma of [8] (by a slight abuse of notation we identify bad in RSS3<sub>FE, $\mathcal{F}$ ,Z,D,R with bad<sub>1</sub> in RSS3-H1<sub>FE, $\mathcal{F}$ ,Z,D,R, and third equality is by construction. The fourth uses the assumption that (D,A) is SS3-valid with failure probability  $\nu(\cdot)$ .</sub></sub>

Finally, the last inequality follows by considering a run of Games  $\operatorname{Rsmp}_{\overline{D},D,\mathcal{F},b}^{B^*}(\lambda)$  for  $b \in \{0,1\}$  and  $B^*$  given in Figure 9, and of Game RSS3- $\operatorname{H1}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\lambda)$  over some fixed coin sequence drawn from a common finite set of coins, but not including the coins used to draw  $i^*$  in RSS3- $\operatorname{H1}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\lambda)$ . Suppose bad is set by the latter for the *first* time (i.e., changed from false to true) on the q-th query to ENC made by A when executed by RSS3- $\operatorname{H1}_{\mathsf{FE},\mathcal{F},Z,D,R}$  using these coins. Then with probability  $1/q_e$  in the execution of  $\operatorname{Rsmp}_{\overline{D},D,\mathcal{F},b}^{B^*}(\lambda)$  it will be the case that  $i^*=q$ . In this case  $\operatorname{Rsmp}_{\overline{D},D,\mathcal{F},b}^{B^*}(\cdot)$  outputs 1 just when b=1. Using the assumption that  $\mathcal{F}$  is  $\mu(\cdot)$ -accurately resampleable and re-arranging yields the last inequality above.

A symmetric sequence of inequalities to the above yields

$$T(\mathrm{ISS2}_{\mathcal{F},Z,D,R},S,\cdot) \quad \geq \quad T(\mathrm{IND}_{\mathsf{FE},\mathcal{F},0},B,\cdot) - \nu(\cdot) - q_e\mu(\cdot) \; .$$

Re-arranging and subtracting yields Equation (5.5).

```
PROC INITIALIZE(\lambda):
(pk, sk) \leftarrow \$ \mathsf{Setup}(\lambda)
i, j \leftarrow 0; St \leftarrow \varepsilon; Return (pk, z)
PROC ENC(\alpha):
                                                                                               PROC FINALIZE(w):
                                                                                               \overline{\mathbf{q}[i+1]} \leftarrow \varepsilon \; ; \; \mathbf{t}[i+1] \leftarrow \mathsf{kd}
\mathbf{q}[i] \leftarrow \alpha \; ; \; \mathbf{t}[i] \leftarrow \mathsf{enc}
                                                                                               For i' = 1, ..., i + 1 and j' = i' + 1, ..., i + 1 do
(St, \mathbf{x}[i]) \leftarrow D(St, \alpha)
                                                                                                      If \mathbf{t}[i'] = \text{enc } \wedge \mathbf{t}[j'] = \text{kd then}
For j' = 1 to j do:
                                                                                                              If \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}[i']) \neq \mathcal{F}(\lambda, \mathbf{q}[j'], \mathbf{x}'[i']) then
       \mathbf{f}[j'] \leftarrow \mathrm{F}(\mathbf{a}[j'], i)
                                                                                                                      \mathsf{bad}_1 \leftarrow \mathsf{true}; Return false
       (St, \mathbf{x}[i]) \leftarrow s D(\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
                                                                                               If bad_2 = true then
If \mathsf{Test}(\lambda, \mathbf{x}[i], \mathbf{a}, \mathbf{f}) = 0 then \mathsf{bad}_2 \leftarrow \mathsf{true}
                                                                                                             Return false
\mathbf{c}[i] \leftarrow \mathbf{s} \, \mathsf{Enc}(pk, \mathbf{x}[i])
                                                                                               Else return R(\lambda, z, \mathbf{x}, \mathbf{q}, \mathbf{t}, St, w)
Return (\mathbf{c}[i], \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i]))
PROC KD(a):
\mathbf{q}[i] \leftarrow a \; ; \; \mathbf{t}[i] \leftarrow \mathsf{kd}
dk \leftarrow s \mathsf{KDer}(sk, a)
Return dk
```

<span id="page-15-0"></span>Figure 8: Hybrid games RSS3-H2<sub>FE, $\mathcal{F}$ ,Z,D,R and RSS3-H2<sub>FE, $\mathcal{F}$ ,Z,D,R for the proof of Claim 5.5. The latter includes the boxed code while in the former it is removed.</sub></sub>

### 5.3 Resampleability of Some Functionalities

We show resampleability of the following type of functionality.

FUNCTIONALITIES WITH POLYNOMIAL-SIZE RANGE. Let  $\mathcal{F}$  be a functionality. We say that  $\mathcal{F}$  has polynomial-size range if there is a polynomial  $w(\cdot)$  such that  $\mathcal{F}(\lambda, \mathbf{a}, x) \in F_{\lambda}$  for all  $\lambda \in \mathbb{N}$ ,  $x \in \{0, 1\}^*$  and  $\mathbf{a} \in (\{0, 1\}^*)^*$  where  $F_{\lambda} = \{\mathbf{f}_1, \mathbf{f}_2, \dots, \mathbf{f}_{w(\cdot)}\}$ .

EXAMPLES AND DISCUSSION. An example of a functionality with polynomial-size range is PEKS [12] with a polynomial number of keywords. Although as shown by [12] this can be constructed from any IND-CPA public-key encryption scheme, the construction is inefficient for large polynomials, and more efficient constructions may be of interest to practitioners. These would be SS3 secure by our results.

We compare our notion of resampleability to that of preimage sampleability defined by O'Neill [29]. Our notion of resampleability appears to be much more restrictive, in the sense that showing it requires sampling a preimage that lies in the message space of the adversary rather than an arbitrary preimage. Since in general we cannot hope to "reverse engineer" the adversary's message space, it is unclear what we can do with it besides sample it in a black-box way. Indeed, the proof of our result does this and does not exploit any properties of the functionality itself as in [29], who showed that most functionalities considered in the literature have preimage sampleability. On the other hand, we show how to achieve a much stronger security definition than [29] who considered only non-adaptive security, meaning the adversary makes no key-derivation queries after seeing the challenge ciphertext.

<span id="page-15-2"></span>**Proposition 5.6** Let  $\mathcal{F}$  be a functionality with polynomial-size range. Then  $\mathcal{F}$  is accurately resampleable. More precisely, for any PPT D there is a PPT  $\overline{D}$  such that for every  $\lambda \in \mathbb{N}$

$$\mathbf{Adv}_{\overline{D},D,\mathcal{F}}^{\mathrm{rs}}(\lambda) \leq \frac{1}{2^{\lambda}}$$
.

Furthermore, the running-time of  $\overline{D}$  is that for at most  $\lambda w(\lambda)$  executions of D.

<span id="page-15-1"></span>The proof will use the following mathematical lemma.

```
Alg B^*(\lambda):
Alg S(1^k):
                                                                  Alg B(pk):
                                                                                                                                             i, j \leftarrow 0
i, j \leftarrow 0
                                                                 i, j \leftarrow 0
                                                                                                                                             St \leftarrow \varepsilon
St \leftarrow \varepsilon
                                                                 St_0, St_1 \leftarrow \varepsilon
                                                                                                                                             (pk, sk) \leftarrow s \mathsf{Setup}(\lambda)
(pk, sk) \leftarrow s \mathsf{Setup}(1^k)
                                                                 Run A(pk):
                                                                                                                                             Run A(pk):
Run A(pk):
                                                                        On encryption query \alpha:
                                                                                                                                                   On encryption query \alpha:
      On encryption query \alpha:
                                                                              i \leftarrow i + 1 ; \alpha[i] \leftarrow \alpha
                                                                                                                                                          i \leftarrow i + 1 ; \alpha[i] \leftarrow \alpha
            i \leftarrow i + 1 ; \alpha[i] \leftarrow \alpha
                                                                               (St_0, \mathbf{x}_0[i]) \leftarrow D(St_0, \alpha)
                                                                                                                                                          For j' = 1 to j do:
            For j' = 1 to j do:
                                                                              For j' = 1 to j do:
                                                                                                                                                                \mathbf{f}[j'] \leftarrow \mathrm{F}(\mathbf{a}[j'], i)
                                                                                     \mathbf{f}[j'] \leftarrow \mathcal{F}(\lambda, \mathbf{a}[j'], \mathbf{x}_0[i])
                   \mathbf{f}[j'] \leftarrow \mathrm{F}(\mathbf{a}[j'], i)
                                                                                                                                                          If i = i^* then
            (St, x) \leftarrow \overline{D}(\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
                                                                               (St_1, \mathbf{x}_1[i]) \leftarrow \overline{D}(\lambda, St_1, \alpha, \mathbf{a}, \mathbf{f})
                                                                                                                                                                (St, x) \leftarrow s \text{ CHALLENGE}(St, \alpha, \mathbf{a})
                                                                              Return LR(\mathbf{x}_0[i], \mathbf{x}_1[i])
            c \leftarrow s \operatorname{Enc}(pk, x)
                                                                                                                                                                Halt execution of A
            Return c, y
                                                                        On key-derivation query a:
                                                                                                                                                          (St, x) \leftarrow s \overline{D}(\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
      On key-derivation query a:
                                                                              j \leftarrow j + 1; \mathbf{a}[j] \leftarrow a
                                                                                                                                                          c \leftarrow \operatorname{sEnc}(pk, x)
            j \leftarrow j + 1; \mathbf{a}[j] \leftarrow a
                                                                              Return KD(a)
                                                                                                                                                          Return c, y
            OP(a)
                                                                 Let w be the output of A
                                                                                                                                                   On key-derivation query a:
                                                                 Return R(1^k, \mathbf{x}_1, \mathbf{a}, \boldsymbol{\alpha}, St, w)
            Return \mathsf{KDer}(sk, a)
                                                                                                                                                          j \leftarrow j + 1; \mathbf{a}[j] \leftarrow a
Let w be the output of A
                                                                                                                                                          Return \mathsf{KDer}(sk, a)
Return R(1^k, \mathbf{x}, \mathbf{a}, \boldsymbol{\alpha}, St, w)
                                                                                                                                            Return \mathsf{Test}(\lambda, x, \mathbf{a}, \mathbf{f})
```

<span id="page-16-0"></span>Figure 9: Algorithms for proof of Claim 5.5.

**Lemma 5.7** Fix integers  $n, k \ge 1$ . For  $\mathbf{x} \in \mathbb{R}^n$  define the function  $f(\mathbf{x}) = \sum_{i=1}^n x_i (1 - x_i)^k$ . Subject to constraints  $\sum_{i=1}^n x_i = 1$  and  $0 \le x_i \le 1$  for all  $1 \le i \le n$ ,  $f(\cdot)$  is maximum at  $x_1 = \ldots = x_n = 1/n$ .

**Proof:** (Of Lemma 5.7) We use a change of variables: let  $y_i = (1 - x_i)$  for all  $1 \le i \le n$ . Then we equivalently seek to maximize

$$f'(\mathbf{y}) = \sum_{i=1}^{n} (1 - y_i) y_i^k$$

subject to  $\sum_{i=1}^{n} y_i = n-1$  and  $0 \le y_i \le 1$  for all  $1 \le i \le n$ . Now use Lagrange multipliers: we seek a constant  $\lambda$  such that

<span id="page-16-1"></span>
$$\nabla f' = \lambda \nabla g \tag{2}$$

where  $g(\mathbf{x}) = \sum_{i=1}^{n} y_i$ . Fix any  $1 \le i \le n$ . Since

$$\frac{\partial f'}{\partial y_i} = 1 - (k+1)y_i^k$$
 and  $\frac{\partial g}{\partial y_i} = 1$

by Equation (2) we have

<span id="page-16-2"></span>
$$1 - (k+1)y_i^k = \lambda \implies y_i = \left(\frac{1-\lambda}{k+1}\right)^{1/k} . \tag{3}$$

Using the constraint  $\sum_{i=1}^{n} y_i = n-1$  we have

$$n\left(\frac{1-\lambda}{k+1}\right)^{1/k} = n-1 \implies \lambda = 1 - (k+1)\left(1 - \frac{1}{n}\right)^k.$$

Substituting this into Equation (3) we get  $y_i = 1 - 1/n$  and so  $x_i = -(y_i - 1) = 1/n$  as desired. Note that this must be a maximum (rather than minimum) since f vanishes when  $x_i = 1$  for some i.

We now prove the proposition.

**Proof:** (Of Proposition 5.6) Given any D, define the corresponding resampler  $\overline{D}$  as follows:

$$\begin{split} \mathbf{Alg} \ \overline{D}(\lambda, St, \alpha, \mathbf{a}, \mathbf{f}) \colon \\ \text{For } i &= 1 \text{ to } \lambda w(\lambda) \text{ do: } \\ x' &\leftarrow \mbox{\$} D(St, \alpha) \\ \text{If } \mathsf{Test}(\lambda, x', \mathbf{a}, \mathbf{f}) = 1 \text{ then return } x' \end{split}$$
 Return  $\bot$

<span id="page-17-0"></span>We need to show that for any B

$$\mathbf{Adv}^{\mathrm{rs}}_{\overline{D},D,\mathcal{F},B}(\cdot) \leq \frac{1}{2^{\lambda}}$$
.

To this end define game RsmpD,D,<sup>F</sup> to pick a bit b at random and run the first experiment if b = 1 and the second if b = 0; also, have it set bad to true if D ever returns âŠ¥. Define Rsmp-HD,D,<sup>F</sup> to be like the former but return ResampleD(Î», St, Î±, a,f) if bad is set. Then using a standard conditioning argument and the Fundamental Lemma [\[8\]](#page-21-16):

$$\begin{split} \frac{1}{2} + \frac{1}{2}\mathbf{A}\mathbf{d}\mathbf{v}^{\mathrm{rs}}_{\overline{D},D,\mathcal{F},B}(\cdot) &= T(\mathrm{Rsmp}_{\overline{D},D,\mathcal{F}},B,\cdot) \\ &\leq T(\mathrm{Rsmp-H}_{\overline{D},D,\mathcal{F}},B,\cdot) + \Pr\left[\,\mathrm{Rsmp}_{\overline{D},D,\mathcal{F}}^B(\cdot) \text{ sets bad}\,\right] \\ &= \frac{1}{2} + \Pr\left[\,\mathrm{Rsmp}_{\overline{D},D,\mathcal{F}}^B(\cdot) \text{ sets bad}\,\right] \,. \end{split}$$

Finally, we claim

$$\Pr\left[\,\mathrm{Rsmp}_{\overline{D},D,\mathcal{F}}^B(\cdot)\,\,\mathrm{sets}\,\,\mathrm{bad}\,\right]\,\,\leq\,\,\frac{1}{2^\lambda}\,\,.$$

To see this, fix any inputs Î», St, Î±, a,f and for all 1 â‰¤ i â‰¤ w(Î») let

$$p_i = \Pr[\mathcal{F}(\lambda, \mathbf{a}, x) = \mathbf{f}_i : x \leftarrow \$D(St, \alpha)].$$

Then

$$\Pr\left[\overline{D}(\lambda, St, \alpha, \mathbf{a}, \mathbf{f}) \text{ outputs } \bot\right] = \sum_{i} p_{i} \cdot (1 - p_{i})^{\lambda w(\lambda)}$$

$$\leq \sum_{i} \frac{1}{w(\lambda)} \cdot \left(1 - \frac{1}{w(\lambda)}\right)^{\lambda \cdot w(\lambda)}$$

$$\leq \frac{1}{2^{\lambda}}.$$

The second line above is justified by Lemma [5.7.](#page-15-1) The third line uses the inequality (1âˆ’1/x) <sup>x</sup> â‰¤ 1/e < 1/2 for any real number x â‰¥ 1 (here e is Euler's constant).

### 6 Brute-Force Construction Revisited

We now revisit the "brute-force" scheme defined by BSW [\[14\]](#page-21-0), which provides a way to construct FE for any functionality with a polynomially-sized index space.

Let F be a functionality. We say that F has polynomially-sized index space if F(Î», a, x) = âŠ¥ if a /âˆˆ A<sup>Î»</sup> where A<sup>Î»</sup> = {Îµ, a1, a2, . . . , ap(Î»)} for a polynomial p(Â·). Let (G, E, D) be a PKE scheme. Then we define a the brute-force FE scheme for F as follows:

```
PROC INITIALIZE(\lambda):
                                                                                     Alg Resample<sub>D</sub>(\lambda, St, \alpha, \mathbf{a}, \mathbf{f}):
                                                                                     If CS_D(\lambda, St, \alpha, \mathbf{a}, \mathbf{f}) = \emptyset then return \perp
Return \lambda
                                                                                     w \leftarrow s \mathsf{CS}_D(\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
PROC CHALLENGE(St, \alpha, \mathbf{a}):
                                                                                     x' \leftarrow D(St, \alpha; w)
x \leftarrow s D(St, \alpha)
                                                                                     Return x'
\mathbf{f} \leftarrow (\mathcal{F}(\lambda, \mathbf{a}, x), \mathcal{F}(\lambda, \varepsilon, x))
                                                                                     Alg Test(\lambda, x, \mathbf{a}, \mathbf{f}):
If b = 1 then x' \leftarrow \overline{D}(\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
                                                                                     \mathbf{f}' \leftarrow (\mathcal{F}(\lambda, \mathbf{a}, x), \mathcal{F}(\lambda, \varepsilon, x))
Else x' \leftarrow s Resample (\lambda, St, \alpha, \mathbf{a}, \mathbf{f})
                                                                                     Return (\mathbf{f} = \mathbf{f}')
Return x'
\frac{\text{PROC FINALIZE}(b')}{\text{Return } (b'=1)}:
                                                                                     Set CS_D(\lambda, St, \alpha, \mathbf{a}, \mathbf{f}) := \{w : Test(\lambda, D(St, \alpha; w), \mathbf{a}, \mathbf{f}) = true\}
```

Figure 10: Left: Game Resamp $_{\overline{D},D,\mathcal{F},b}$  for the resampleability definition. Right: Associated algorithms and definitions used by the game's procedures.

```
\frac{\text{SETUP}(\lambda)}{\text{For } i = 1, \dots, p(\lambda) \text{ do}} \\ (\mathbf{pk}[i], \mathbf{sk}[i]) \leftarrow \mathcal{G}(\lambda) \\ \text{Return } (\mathbf{pk}, \mathbf{sk}) \\ \overline{\text{For } i = 1, \dots, p(\lambda) \text{ do}} \\ \frac{\text{KDER}(sk, a)}{\text{For } i = 1, \dots, p(\lambda) \text{ do}} \\ \text{If } a_i = a \text{ then return } (i, \mathbf{sk}[i]) \\ \hline \\ \frac{\text{ENC}(\mathbf{pk}, m)}{\text{For } i = 1, \dots, p(\lambda) \text{ do}} \\ \overline{\text{C}[i]} \leftarrow \mathcal{E}(\mathbf{pk}[i], \mathcal{F}(\lambda, a_i, m)) \\ \overline{\text{Return } \mathbf{c}} \\ \overline{\text{DEC}((i, \mathbf{sk}[i]), \mathbf{c}))} \\ \overline{\text{If } (\mathbf{sk}[i] = \varepsilon) \text{ then return } |m|} \\ \overline{\text{Return } \mathcal{D}(\mathbf{sk}[i], \mathbf{c}[i])}
```

BSW [14] show that this construction is IND-secure (and hence, by our results in Section 5, SS2-secure) provided that the underlying PKE scheme is semantically secure. Moreover, they show a slightly decorated construction which is SS1-secure in the random oracle model. What we show is that it suffices for the underlying PKE scheme to be secure against *key-revealing SOAs* (SOA-K) for this FE scheme to be SS1-secure. In fact, for their result BSW implicitly use the non-committing (which implies SOA-K) PKE scheme of Nielsen [26] in the random oracle model as the underlying PKE scheme, so our result is a generalization of theirs. In particular, it allows us to obtain instantiations in the standard model by (necessarily) allowing long keys, meaning longer than the total number of bits encrypted; SOA-K secure PKE is known to exist in this setting [15, 16].

The intuition is that opening a particular  $\mathcal{F}(\lambda, a_i, m)$  is equivalent to giving away  $\mathbf{sk}[i]$ . Therefore, it should be the case that if some  $\mathcal{F}$  values for a particular set  $I = \{a_{j_1}, a_{j_2}, \dots, a_{j_{|I|}}\} \subseteq \mathcal{A}$  of indices are revealed, it is equivalent to opening up  $\mathbf{sk}[j_1], \mathbf{sk}[j_2], \dots, \mathbf{sk}[j_{|I|}]$  and should therefore, by SOA security, not make it any easier to obtain decryptions under any other secret key, i.e. to evaluate  $\mathcal{F}$  on any other index.

SOA-K DEFINITION. To formalize our result we will need an explicit notion of SOA-K security, as described in BDWY [5]. Here we need to extend the BDWY definition to allow the adversary and simulator to ask for encryptions and secret keys adaptively (as in our SS notions for FE) rather than asking for an initial vector of ciphertexts and then afterwards a subset of the secret keys in one shot.

Let  $\Pi$  be a PKE scheme. The definition uses games  $\mathrm{RSOAK}_{\Pi,Z,D,R,n}$  and  $\mathrm{SSOAK}_{\Pi,Z,D,R,n}$  of Figure 11. We say that  $\Pi$  is SOAK-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R, every PT adversary A, and every polynomial  $n(\cdot)$  there is a PT simulator S such that

$$\mathbf{Adv}^{\mathrm{soa-k}}_{\Pi,A,S,Z,D,R,n}(\cdot) \ = \ \Pr\left[ \, \mathrm{RSOAK}^{A}_{\Pi,Z,D,R,n}(\cdot) \, \right] - \Pr\left[ \, \mathrm{SSOAK}^{S}_{\Pi,Z,D,R,n}(\cdot) \, \right]$$

<span id="page-18-1"></span>is negligible.

**Theorem 6.1** Let  $\Pi = (\mathcal{G}, \mathcal{E}, \mathcal{D})$  be a SOA-K secure PKE scheme. Then the corresponding brute-force FE scheme for any functionality  $\mathcal{F}$  with a polynomially-sized index space is SS1-secure.

```
Initialize(\lambda)
i', j \leftarrow 0
St \leftarrow \varepsilon
                                                                                                                                                                                   CORRUPT(i)
                                                               Corrupt(i)
For j' = 1, \ldots, n(\lambda) do
                                                                                                                               i', j \leftarrow 0
                                                                                                                                                                                   j \leftarrow j + 1
       (\mathbf{pk}[j'], \mathbf{sk}[j']) \leftarrow \mathcal{G}(\lambda)
                                                                                                                               z \leftarrow *Z(\lambda)
z \leftarrow s Z(\lambda)
                                                              \mathbf{i}[j] \leftarrow i
                                                                                                                               St \leftarrow \varepsilon
                                                                                                                                                                                  \mathbf{i}[j] \leftarrow i
                                                                                                                                                                                  For j'=1,\ldots,i' do
                                                              For j' = 1, \ldots, i' do
                                                                                                                               Return z
Return (\mathbf{pk}, z)
                                                                     \mathbf{m}[j'] \leftarrow \mathbf{x}[j'][i]
                                                                                                                                                                                         \mathbf{m}[j'] \leftarrow \mathbf{x}[j'][i]
Enc(\alpha)
                                                                                                                               Msg(\alpha)
                                                              Return (\mathbf{m}, \mathbf{sk}[i])
                                                                                                                                                                                  Return m
(St, \mathbf{m}) \leftarrow s D(St, \alpha)
                                                                                                                               (St, \mathbf{m}) \leftarrow s D(St, \alpha)
                                                                                                                                                                                  FINALIZE(w)
i' \leftarrow i' + 1
                                                                                                                              i' \leftarrow i' + 1
                                                              Return R(\lambda, z, \mathbf{x}, \mathbf{i}, \boldsymbol{\alpha}, St, w)
                                                                                                                                                                                  Return R(\lambda, z, \mathbf{x}, \mathbf{i}, \boldsymbol{\alpha}, St, w)
\alpha[i'] \leftarrow \alpha \; ; \; \mathbf{x}[i'] \leftarrow \mathbf{m}
                                                                                                                              \alpha[i'] \leftarrow \alpha \; ; \; \mathbf{x}[i'] \leftarrow \mathbf{m}
For j' = 1, \ldots, n(\lambda) do
      \mathbf{c}[j'] \leftarrow \mathcal{E}(\mathbf{pk}[j'], \mathbf{m}[j'])
Return c
```

<span id="page-19-0"></span>Figure 11: Left: "Real world" game  $RSOAK_{\Pi,Z,D,R,n}$  for the SOA-K definition. Right: "Ideal world" game  $SSOAK_{\Pi,Z,D,R,n}$  for the SOA-K definition.

```
Alg A'(\lambda):
Alg R'(\lambda, z, \mathbf{x}', \mathbf{i}, \boldsymbol{\alpha}, St, w):
                                                          Alg D'(St, \alpha):
                                                                                                    (\mathbf{pk}, z) \leftarrow \$ Initialize(\lambda)
For j' = 1, \ldots, |\mathbf{x}'|
                                                          x \leftarrow D(St, \alpha)
                                                                                                    Run A on input \lambda:
     \mathbf{x}[j'] \leftarrow \mathbf{x}'[j'][p(\lambda) + 1]
                                                          For i = 1, \ldots, p(\lambda) do
                                                                                                          On initialize query \lambda return (\mathbf{pk}, z)
                                                                \mathbf{m}[i] \leftarrow \mathcal{F}(\lambda, a_i, x)
For j' = 1, ..., |\mathbf{i}|
                                                                                                          On encryption query \alpha
     Let i be such that a_i = \mathbf{i}[j']
                                                          \mathbf{m}[p(\lambda) + 1] \leftarrow x
                                                                                                                \mathbf{c} \leftarrow \mathbf{s} \operatorname{Enc}(\alpha)
      \mathbf{a}[j'] \leftarrow a_i
                                                          Return m
                                                                                                                Return (\mathbf{c}[1 \dots p(\lambda)], msglen(\mathbf{c}[p(\lambda) + 1]))
Return R(\lambda, z, \mathbf{x}, \mathbf{a}, \boldsymbol{\alpha}, St, w)
                                                                                                          On key-derivation query a
                                                                                                                Let i be such that a_i = a
                                                                                                                Return CORRUPT(i)
                                                                                                    Let w be the output of A
```

<span id="page-19-1"></span>Figure 12: Algorithms for proof of security of brute-force scheme.

**Proof of Theorem 6.1:** Denote by  $A_{\lambda} = \{\varepsilon, a_1, a_2, \dots, a_{p(\lambda)}\}$  the family of sets satisfying the definition of polynomially-sized index space for  $\mathcal{F}$ . Let Z be an auxiliary input generator, D be a message sampler, R be a relation, and A be a SS1 adversary. Consider the auxiliary input generator Z' = Z, and then the relation R', message sampler D' and SOA-K adversary A' defined as in Figure 12.

Above, for a ciphertext c,  $\mathsf{msglen}(c)$  returns the length of the decryption of c (which we assume is efficiently computable from a ciphertext, or else that D always outputs messages of some known length). Also note that we set  $n(\cdot) = p(\cdot) + 1$  in the SOAK games; this allows A' to pass the length of the "actual" payload x to A and similarly A' to pass the "actual" payload vector  $\mathbf{x}$  to A. Since A is SOA-K secure, we know that there exists a PT simulator A' such that

$$\mathbf{Adv}^{\text{soa-k}}_{\Pi,A',S',Z',D',R'}(\cdot) = \Pr\left[ \, \text{RSOAK}^{A'}_{\Pi,Z',D',R'}(\cdot) \, \right] - \Pr\left[ \, \text{SSOAK}^{S'}_{\Pi,Z',D',R'}(\cdot) \, \right]$$

is negligible. Now we use S' to construct S, a simulator for the ISS game, in a similar way we adapted A to get A':

```
Alg S(\lambda):

z \leftarrow s Initialize(\lambda)

Run S' on input \lambda:

i' \leftarrow 0

On initialize query \lambda return z

On message query \alpha:

i' \leftarrow i' + 1; Msg(\alpha)

Return \varepsilon

On corrupt query i:

OP(a_i)

For j = 1, \ldots, i'

\mathbf{x}[j] \leftarrow F(a_i, j)

Return \mathbf{x}

Let w be the output of S'

Return w
```

By construction, we now have

$$\begin{split} & \Pr \left[ \, \mathrm{RSOAK}_{\Pi,Z',D',R',p+1}^{A'}(\cdot) \, \right] = \Pr \left[ \, \mathrm{RSS}_{\mathsf{FE},\mathcal{F},Z,D,R}^{A}(\cdot) \, \right] \\ & \Pr \left[ \, \mathrm{SSOAK}_{\Pi,Z',D',R',p+1}^{S'}(\cdot) \, \right] = \Pr \left[ \, \mathrm{ISS}_{\mathsf{FE},\mathcal{F},Z,D,R}^{S}(\cdot) \, \right] \end{split}$$

Therefore,

$$\begin{split} \mathbf{Adv}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}^{\mathsf{ss1}}(\cdot) &= \Pr\left[ \, \mathsf{RSS}_{\mathsf{FE},\mathcal{F},Z,D,R}^{A}(\cdot) \, \right] - \Pr\left[ \, \mathsf{ISS}_{\mathsf{FE},\mathcal{F},Z,D,R}^{S}(\cdot) \, \right] \\ &= \Pr\left[ \, \mathsf{RSOAK}_{\Pi,Z',D',R'}^{A'}(\cdot) \, \right] - \Pr\left[ \, \mathsf{SSOAK}_{\Pi,Z',D',R',p+1}^{S'}(\cdot) \, \right] \\ &= \mathbf{Adv}_{\Pi,A',S',Z',D',R',p+1}^{\mathsf{soa-k}}(\cdot) \end{split}$$

which is negligible by assumption.

#### <span id="page-20-5"></span>References

- [1] M. Abdalla, M. Bellare, and G. Neven. Robust encryption. In D. Micciancio, editor, *TCC 2010*, volume 5978 of *LNCS*, pages 480â€“497. Springer, Feb. 2010. 5, 6, 8
- <span id="page-20-1"></span>[2] S. Agrawal, D. M. Freeman, and V. Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In D. H. Lee and X. Wang, editors, *ASIACRYPT 2011*, volume 7073 of *LNCS*, pages 21â€“40. Springer, Dec. 2011. 2
- <span id="page-20-2"></span>[3] S. Agrawal, S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption: New perspectives and lower bound. Cryptology ePrint Archive, Report 2012/468, 2012. http://eprint.iacr.org/. 3, 4
- <span id="page-20-4"></span>[4] M. Barbosa and P. Farshim. Semantically secure functional encryption revisited. Cryptology ePrint Archive, Report 2012/474, 2012. http://eprint.iacr.org/. 4, 7
- <span id="page-20-0"></span>[5] M. Bellare, R. Dowsley, B. Waters, and S. Yilek. Standard security does not imply security against selective-opening. In D. Pointcheval, editor, *EUROCRYPT 2012*, LNCS. Springer, 2012. 1, 3, 10, 18
- <span id="page-20-3"></span>[6] M. Bellare, D. Hofheinz, and S. Yilek. Possibility and impossibility results for encryption and commitment secure under selective opening. In A. Joux, editor, EUROCRYPT 2009, volume 5479 of LNCS, pages 1â€“35. Springer, Apr. 2009. 4
- <span id="page-20-6"></span>[7] M. Bellare and A. Palacio. GQ and Schnorr identification schemes: Proofs of security against impersonation under active and concurrent attacks. In M. Yung, editor, *CRYPTO 2002*, volume 2442 of *LNCS*, pages 162â€“177. Springer, Aug. 2002. 10

- <span id="page-21-16"></span>[8] M. Bellare and P. Rogaway. The security of triple encryption and a framework for code-based gameplaying proofs. In S. Vaudenay, editor, EUROCRYPT 2006, volume 4004 of LNCS, pages 409â€“426. Springer, May / June 2006. [5,](#page-5-0) [12,](#page-12-2) [14,](#page-14-1) [17](#page-17-0)
- <span id="page-21-17"></span><span id="page-21-14"></span>[9] M. Bellare, B. Waters, and S. Yilek. Identity-based encryption secure against selective opening attack. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 235â€“252. Springer, Mar. 2011. [4](#page-4-0)
- [10] D. Boneh and X. Boyen. Efficient selective-ID secure identity based encryption without random oracles. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 223â€“238. Springer, May 2004. [5,](#page-5-0) [6](#page-6-1)
- <span id="page-21-6"></span>[11] D. Boneh and X. Boyen. Secure identity based encryption without random oracles. In M. Franklin, editor, CRYPTO 2004, volume 3152 of LNCS, pages 443â€“459. Springer, Aug. 2004. [2](#page-2-1)
- <span id="page-21-18"></span>[12] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In C. Cachin and J. Camenisch, editors, EUROCRYPT 2004, volume 3027 of LNCS, pages 506â€“522. Springer, May 2004. [6,](#page-6-1) [15](#page-15-3)
- <span id="page-21-1"></span>[13] D. Boneh and M. K. Franklin. Identity based encryption from the Weil pairing. SIAM Journal on Computing, 32(3):586â€“615, 2003. [1,](#page-1-0) [2](#page-2-1)
- <span id="page-21-0"></span>[14] D. Boneh, A. Sahai, and B. Waters. Functional encryption: Definitions and challenges. In Y. Ishai, editor, TCC 2011, volume 6597 of LNCS, pages 253â€“273. Springer, Mar. 2011. [1,](#page-1-0) [2,](#page-2-1) [3,](#page-3-0) [4,](#page-4-0) [5,](#page-5-0) [6,](#page-6-1) [7,](#page-7-1) [8,](#page-8-2) [9,](#page-9-2) [10,](#page-10-3) [17,](#page-17-0) [18](#page-18-2)
- <span id="page-21-10"></span>[15] R. Canetti, U. Feige, O. Goldreich, and M. Naor. Adaptively secure multi-party computation. In 28th ACM STOC, pages 639â€“648. ACM Press, May 1996. [3,](#page-3-0) [4,](#page-4-0) [18](#page-18-2)
- <span id="page-21-11"></span>[16] I. DamgËšard and J. B. Nielsen. Improved non-committing encryption schemes based on a general complexity assumption. In M. Bellare, editor, CRYPTO 2000, volume 1880 of LNCS, pages 432â€“450. Springer, Aug. 2000. [3,](#page-3-0) [4,](#page-4-0) [18](#page-18-2)
- <span id="page-21-12"></span>[17] S. Fehr, D. Hofheinz, E. Kiltz, and H. Wee. Encryption schemes secure against chosen-ciphertext selective opening attacks. In H. Gilbert, editor, EUROCRYPT 2010, volume 6110 of LNCS, pages 381â€“402. Springer, May 2010. [4](#page-4-0)
- <span id="page-21-5"></span>[18] S. Goldwasser and S. Micali. Probabilistic encryption. Journal of Computer and System Sciences, 28(2):270â€“ 299, 1984. [2](#page-2-1)
- <span id="page-21-15"></span>[19] S. Gorbunov, V. Vaikuntanathan, and H. Wee. Functional encryption with bounded collusions via multi-party computation. In CRYPTO, pages 162â€“179, 2012. [4](#page-4-0)
- <span id="page-21-2"></span>[20] V. Goyal, O. Pandey, A. Sahai, and B. Waters. Attribute-based encryption for fine-grained access control of encrypted data. In A. Juels, R. N. Wright, and S. Vimercati, editors, ACM CCS 06, pages 89â€“98. ACM Press, Oct. / Nov. 2006. Available as Cryptology ePrint Archive Report 2006/309. [1,](#page-1-0) [2](#page-2-1)
- <span id="page-21-13"></span>[21] B. Hemenway, B. Libert, R. Ostrovsky, and D. Vergnaud. Lossy encryption: Constructions from general assumptions and efficient selective opening chosen ciphertext security. In D. H. Lee and X. Wang, editors, ASIACRYPT 2011, volume 7073 of LNCS, pages 70â€“88. Springer, Dec. 2011. [4](#page-4-0)
- <span id="page-21-3"></span>[22] J. Katz, A. Sahai, and B. Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In N. P. Smart, editor, EUROCRYPT 2008, volume 4965 of LNCS, pages 146â€“162. Springer, Apr. 2008. [1,](#page-1-0) [2,](#page-2-1) [6,](#page-6-1) [7,](#page-7-1) [23](#page-23-0)
- <span id="page-21-7"></span>[23] A. B. Lewko, T. Okamoto, A. Sahai, K. Takashima, and B. Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In H. Gilbert, editor, EURO-CRYPT 2010, volume 6110 of LNCS, pages 62â€“91. Springer, May 2010. [2](#page-2-1)
- <span id="page-21-9"></span>[24] A. B. Lewko and B. Waters. Decentralizing attribute-based encryption. In K. G. Paterson, editor, EURO-CRYPT 2011, volume 6632 of LNCS, pages 568â€“588. Springer, May 2011. [2](#page-2-1)
- <span id="page-21-8"></span>[25] A. B. Lewko and B. Waters. Unbounded HIBE and attribute-based encryption. In K. G. Paterson, editor, EUROCRYPT 2011, volume 6632 of LNCS, pages 547â€“567. Springer, May 2011. [2](#page-2-1)
- <span id="page-21-4"></span>[26] J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In M. Yung, editor, CRYPTO 2002, volume 2442 of LNCS, pages 111â€“126. Springer, Aug. 2002. [2,](#page-2-1) [4,](#page-4-0) [18](#page-18-2)

- <span id="page-22-8"></span><span id="page-22-6"></span>[27] T. Okamoto and K. Takashima. Hierarchical predicate encryption for inner-products. In M. Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 214â€“231. Springer, Dec. 2009. [2](#page-2-1)
- [28] T. Okamoto and K. Takashima. Efficient attribute-based signatures for non-monotone predicates in the standard model. In D. Catalano, N. Fazio, R. Gennaro, and A. Nicolosi, editors, PKC 2011, volume 6571 of LNCS, pages 35â€“52. Springer, Mar. 2011. [2](#page-2-1)
- <span id="page-22-2"></span>[29] A. O'Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. <http://eprint.iacr.org/>. [1,](#page-1-0) [2,](#page-2-1) [4,](#page-4-0) [7,](#page-7-1) [15](#page-15-3)
- <span id="page-22-5"></span>[30] R. Ostrovsky, A. Sahai, and B. Waters. Attribute-based encryption with non-monotonic access structures. In P. Ning, S. D. C. di Vimercati, and P. F. Syverson, editors, ACM CCS 07, pages 195â€“203. ACM Press, Oct. 2007. [2](#page-2-1)
- <span id="page-22-1"></span>[31] A. Sahai and B. R. Waters. Fuzzy identity-based encryption. In R. Cramer, editor, EUROCRYPT 2005, volume 3494 of LNCS, pages 457â€“473. Springer, May 2005. [1](#page-1-0)
- <span id="page-22-0"></span>[32] A. Shamir. Identity-based cryptosystems and signature schemes. In G. R. Blakley and D. Chaum, editors, CRYPTO'84, volume 196 of LNCS, pages 47â€“53. Springer, Aug. 1985. [1](#page-1-0)
- <span id="page-22-7"></span>[33] E. Shen, E. Shi, and B. Waters. Predicate privacy in encryption systems. In O. Reingold, editor, TCC 2009, volume 5444 of LNCS, pages 457â€“473. Springer, Mar. 2009. [2](#page-2-1)
- <span id="page-22-4"></span>[34] B. Waters. Dual system encryption: Realizing fully secure IBE and HIBE under simple assumptions. In S. Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 619â€“636. Springer, Aug. 2009. [2](#page-2-1)
- <span id="page-22-9"></span><span id="page-22-3"></span>[35] B. Waters. Functional encryption for regular languages. In CRYPTO, pages 218â€“235, 2012. [4](#page-4-0)
- [36] B. R. Waters. Efficient identity-based encryption without random oracles. In R. Cramer, editor, EURO-CRYPT 2005, volume 3494 of LNCS, pages 114â€“127. Springer, May 2005. [2,](#page-2-1) [6](#page-6-1)

## <span id="page-22-10"></span>A Standard Primitives

Public-key encryption schemes. An public-key encryption scheme Î  = (G, E, D) is specified by three PT algorithms. Via (pk,sk)â†\$ G(Î») the key-generation algorithm G generates a public key and matching secret key. Via câ†\$ E(pk, m) the encryption algorithm E takes pk and message m and returns a ciphertext c âˆˆ {0, 1} <sup>âˆ—</sup> âˆª {âŠ¥}. Via m â† D(sk, c), the deterministic decryption algorithm V returns a message m. We require that D(sk, E(pk, m)) = m for all Î» âˆˆ N, all (pk,sk) âˆˆ [G(Î»)], and all m âˆˆ {0, 1} âˆ—

Hash Functions. A hash function H = (K, H) is a tuple of PT algorithms. Via hk â†\$ K(Î») the key-generation algorithm K produces a key hk. Via y â† H(hk, x) the deterministic hashing algorithm H produces the hash of a string x under key hk. Collision-resistance is defined via game CR<sup>Î“</sup> whose Initialize(Î») procedure returns hk â†\$ K(Î») and whose Finalize procedure on input (x, xâ€² ) returns (x 6= x â€² ) âˆ§ (H(hk, x) = H(hk, xâ€² )). There are no other procedures. The advantage of an adversary C is defined by Advcol <sup>H</sup>,C(Î») = Pr -CR<sup>C</sup> <sup>H</sup>(Î») . We say that H is collision-resistant (CR) if Advcol <sup>H</sup>,C(Â·) is negligible for every PT C.

### <span id="page-22-11"></span>B The Unordered Case

Unordered SS1. We start by formalizing the definition. Let FE = (Setup,KDer, Enc, Dec) be a F-FE scheme. The definition uses games RSS1-UFE,F,Z,D,R and ISS1-UF,Z,D,R of Figure [13.](#page-23-1) ("U" for unordered.) We say that FE is SS1-U-secure if for every auxiliary input generator Z, every PT message sampler D, every PT relation R and every PT adversary A there is a PT simulator S such that

$$\mathbf{Adv}^{\text{ss-u}}_{\mathsf{FE},\mathcal{F},A,S,Z,D,R}(\cdot) \ = \ \Pr\left[ \ \mathrm{RSS1-U}^{A}_{\mathsf{FE},\mathcal{F},Z,D,R}(\cdot) \ \right] - \Pr\left[ \ \mathrm{ISS1-U}^{S}_{\mathcal{F},Z,D,R}(\cdot) \ \right]$$

is negligible.

```
PROC INITIALIZE(\lambda):
                                                                                i, j \leftarrow 0 : St \leftarrow \varepsilon
(pk, sk) \leftarrow \$ \mathsf{Setup}(\lambda)
                                                                                z \leftarrow s Z(\lambda) : A \leftarrow \emptyset
z \leftarrow s Z(\lambda)
                                                                                Return z
i, j \leftarrow 0; St \leftarrow \varepsilon
                                                                               \frac{\text{PROC MSG}(\alpha):}{Q_{\alpha} \leftarrow Q_{\alpha} \cup \{\alpha\}}
Return (pk, z)
PROC ENC(\alpha):
                                                                                (St, \mathbf{x}[i]) \leftarrow s D(St, \alpha)
\overline{Q_{\alpha} \leftarrow Q_{\alpha} \cup \{\alpha\}}
                                                                                Return \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i])
 (St, \mathbf{x}[i]) \leftarrow D(St, \alpha)
                                                                                PROC OP(a):
\mathbf{c}[i] \leftarrow \mathbf{s} \, \mathsf{Enc}(pk, \mathbf{x}[i])
                                                                                Q_a \leftarrow Q_a \cup \{a\}
Return (\mathbf{c}[i], \mathcal{F}(\lambda, \varepsilon, \mathbf{x}[i]))
                                                                                Return \varepsilon
PROC KD(a):
                                                                                PROC F(a, s):
Q_a \leftarrow Q_a \cup \{a\}
                                                                                If a \in \mathsf{El}(\mathbf{a}) and 1 \le s \le i then
dk \leftarrow s \mathsf{KDer}(sk, a)
                                                                                        Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
Return dk
                                                                                Else return \perp
\frac{\text{PROC FINALIZE}(w):}{\text{Return } R(\lambda, z, \mathbf{x}, Q_a, Q_\alpha, St, w)} \; \left| \; \frac{\text{PROC FINALIZE}(w):}{\text{Return } R(\lambda, z, \mathbf{x}, Q_a, Q_\alpha, St, w)} \right|
```

<span id="page-23-1"></span>Figure 13: Left: "Real world" game RSS1-U<sub>FE, $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}$ , $\mathcal{F}</sub>$

IDENTITY-EMBEDDABLE PE. In the unordered case our result applies to what we call *identity-embeddable* predicate encryption schemes. Intuitively, these are predicate encryption schemes whose decryption policy embeds an identity matrix. Let  $\mathcal{F}$  be a predicate encryption functionality for predicate  $\mathcal{P}$ . We say that  $\mathcal{F}$  is  $n(\cdot)$ -identity embeddable if there are  $\{(a_{1,\lambda},\ldots,a_{n(\lambda),\lambda})\}_{\lambda\in\mathbb{N}}$  and  $\{(w_{1,\lambda},\ldots,w_{n(\lambda),\lambda})\}_{\lambda\in\mathbb{N}}$  such that for all  $\lambda\in\mathbb{N}$  and all  $1\leq i,j\leq n(\lambda)$ ,  $\mathcal{P}(\lambda,a_i,w_j)=1$  if i=j and  $\perp$  otherwise.

Note that the decryption policy described by an identity matrix is exactly that of IBE. Thus, any PE functionality that "contains" the functionality for an IBE scheme with n identities is n-identity embeddable. PE functionalities considered in the literature typically satisfy this requirement. For example, the inner-product functionality over  $\mathbb{Z}_N$  introduced by [22] was shown to implement IBE by restricting a to the form (id,1) and w to the form (-1,id') for id, id'  $\in \mathbb{Z}_N$ . Thus any inner-product functionality with vectors of dimension 2 is |N|-identity embeddable. Note that in [22] |N| is exponential in  $\lambda$ , whereas for our application we just need it to be polynomial in  $\lambda$  (namely, the output length of a collision-resistant hash function).

<span id="page-23-2"></span>**Theorem B.1** Let  $\mathcal{F}$  be a predicate encryption functionality for predicate  $\mathcal{P}$ . Let  $\mathcal{H} = (K, H)$  be a collision-resistant hash function with output length  $\ell_{\mathcal{H}}(\cdot)$ . Suppose that for every  $\lambda \in N$ ,  $\mathcal{F}(\lambda, \varepsilon, x)$  is the same for all  $x \in [X_{\lambda}]$ . Furthermore, suppose that  $\mathcal{F}$  is  $2\ell_{\mathcal{H}}(\cdot)$ -identity embeddable. Then there does not exist an SS1-U-secure  $\mathcal{F}$ -FE scheme. More precisely, suppose FE is a  $\mathcal{F}$ -FE scheme with secret-key length  $\ell_{sk}(\cdot)$ . Then for any function  $\mu(\cdot)$  there exists a PT auxiliary input generator Z, message sampler D, PT adversary A, PT relation B, and B CR-adversary B such that for every simulator B

$$\mathbf{Adv}^{\mathrm{ss}}_{\mathsf{FE},\mathcal{F},A,S,D,R}(\cdot) \ \leq \ 1 - \sqrt{\mathbf{Adv}^{\mathrm{col}}_{\mathcal{H},C}(\cdot) + 1/\mu(\cdot)} \ .$$

Adversary A makes  $\ell_{sk}(\cdot) + \log \mu(\cdot)$  encryption queries and  $\ell_{\mathcal{H}}(\cdot)$  key-derivation queries.

We remark that our theorem and proof treat the case of (P,p), (p,p), and (p,P) PE functionalities in a unified way. However, in the case of (P,p)-PE the condition in the theorem that  $\mathcal{F}$  be  $2\ell_{\mathcal{H}}(\cdot)$ -identity embeddable can be improved to  $\ell_{\mathcal{H}}(\cdot)$ -identity embeddable. We also stress that, unlike Theorem 4.1, our result here does not apply to any "non-trivial" functionality but only those of a certain form. Better understanding the nature of the gap between the two results or closing it remains an interesting open problem. It is also interesting to note that our result here uses an adversary that makes  $\ell_{\mathcal{H}}(\cdot)$  keyderivation queries as opposed to the constant 2 of Theorem 4.1. It would be interesting to know if this is

tight, meaning whether SS1-U can be achieved against adversaries making some small bounded number of key derivation queries.

**Proof of Theorem B.1:** Denote by  $\{(a_{1,\lambda},\ldots,a_{2\ell_{\mathcal{H}}(\lambda),\lambda})\}_{\lambda\in\mathbb{N}}$  and  $\{(w_{1,\lambda},\ldots,w_{2\ell_{\mathcal{H}}(\lambda),\lambda})\}_{\lambda\in\mathbb{N}}$  the values that satisfy  $2\ell_{\mathcal{H}}(\lambda)$ -identity embeddability for  $\mathcal{F}$ . For  $\lambda\in\mathbb{N}$  denote by  $\overline{\varepsilon}_{\lambda}$  the value such that  $\mathcal{F}(\lambda,\varepsilon,x)=\overline{\varepsilon}_{\lambda}$  for all  $x\in[X_{\lambda}]$ . Let  $n(\cdot):=\ell(\cdot)+\log\mu(\cdot)$ . Define auxiliary input generator Z on input  $\lambda$  to return  $hk\leftarrow sK(\lambda)$ . For  $\lambda\in\mathbb{N}$  denote by  $M_{\lambda}$  a distribution on messages for FE so that if FE is private message then  $M_{\lambda}=\{0,1\}$  and otherwise is trivial. Then define message sampler D on input  $St,\alpha$  to set  $St\leftarrow 1$  if  $St=\varepsilon$  and  $St\leftarrow St+1$  otherwise, and to return  $(St,(w_{2(\lfloor St/n\rfloor+1)-b,\lambda},m))$  where  $b\leftarrow s\{0,1\}$  and  $m\leftarrow sM$ . Define adversary A and relation R as follows:

```
Alg R(\lambda, \mathbf{x}, Q_a, Q_\alpha, St, w):
Alg A(pk, hk):
                                                            (pk, hk, \mathbf{c}, h, \mathbf{sk}) \leftarrow w
For i = 1, ..., \ell_{\mathcal{H}}(\lambda) n(\lambda) do:
                                                            If h \neq H(hk, pk||\mathbf{c}) then return false
      \mathbf{c}[i] \leftarrow \$ \operatorname{Enc}(\lambda)
                                                            If |\mathbf{sk}| \neq \ell_{\mathcal{H}}(\lambda) then return false
h \leftarrow H(hk, pk || \mathbf{c})
                                                            For i = 1, \ldots, \ell_{\mathcal{H}}(\lambda) do:
For i = 1 to \ell_{\mathcal{H}}(\lambda) do:
                                                                  If |\mathbf{sk}[i]| \neq \ell_{sk}(\lambda) then return false
      \mathbf{sk}[i] \leftarrow \$ \operatorname{KD}(a_{2i-h[i]})
                                                            If Q_a \neq \{a_{2i-h[i],\lambda} : 1 \leq i \leq \ell_{\mathcal{H}}(\lambda)\} then return false
w \leftarrow (pk, \mathbf{c}, h, \mathbf{sk})
                                                            If \mathbf{x} \neq \ell_{\mathcal{H}}(\lambda) n(\lambda) \vee Q_{\alpha} \neq \{\lambda\} then return false
Return w
                                                            For i = 1, \ldots, \ell_{\mathcal{H}}(\lambda) do:
                                                                  If Dec(\mathbf{sk}[i], \mathbf{c}[i \dots i + n - 1]) \neq \mathcal{F}(\lambda, a_{2i-h[i]}, \mathbf{x}[i \dots i + n - 1])
                                                                          Then return false
                                                            Return true
```

By construction  $\Pr\left[\text{RSS1-U}_{\mathsf{FE},\mathcal{F},Z,D,R}^A(\cdot)\right] = 1$ . Let S be any simulator. Furthermore, parsing the output of S as  $(pk,\mathbf{c},h,\mathbf{sk}) \leftarrow w$ , we assume it holds that  $h = H(hk,pk\|\mathbf{c}), |\mathbf{sk}| = \ell_{\mathcal{H}}(\lambda)$  and  $|\mathbf{sk}[i]| = \ell_{sk}(\lambda)$  for  $1 \leq i \leq \ell_{\mathcal{H}}(\lambda), \ Q_a = \{a_{2n-h[i],\lambda} : 1 \leq i \leq \ell_{\mathcal{H}}\}$ , and  $|\alpha| = \ell_{\mathcal{H}}(\lambda)n(\lambda)$  and  $Q_\alpha = \{\lambda\}$ , since otherwise the relation R returns false. Towards applying Lemma 4.2, we write the execution of S in the ISS-U game as a composition of two algorithms  $S_1, S_2$  as follows:

```
\begin{array}{l} \mathbf{Alg} \ S_2(\overline{St}) \colon \\ St\|i\|j\|\mathbf{x}\| \|A\|a^* \leftarrow \overline{St} \end{array}
Alg S_1(\lambda):
i \leftarrow 0; z \leftarrow \text{$} Initialize(\lambda)
                                                                                         Let i^* be such that a^* \in \{a_{2i^*,\lambda}, a_{2i^*-1,\lambda}\}
Run S(z):
                                                                                         For q = 1, \ldots, n do:
On message-query \alpha do:
                                                                                                b \leftarrow \$ \{0,1\} ; m \leftarrow \$ M_{\lambda}
      i \leftarrow i + 1
      b \mathop{\leftarrow} \mathop{\$} \left\{ 0,1 \right\} \; ; \; m \mathop{\longleftarrow} \mathop{\$} M_{\lambda}
                                                                                               \mathbf{x}[i^* \cdot n + q - 1] \leftarrow (w_{2i^* - b, \lambda}, m)
      \mathbf{x}[i] \leftarrow (w_{2(|i/n|+1)-b,\lambda}, m)
                                                                                         Run S at state St:
      Return \overline{\varepsilon}
                                                                                         On message-query \alpha do:
                                                                                               i \leftarrow i + 1
On op-query a do:
      j \leftarrow j + 1 ; A \leftarrow A \cup \{a\}
                                                                                                If i \notin \{i^* \cdot n, \dots, i^* \cdot n + n - 1\} do:
                                                                                                      b \leftarrow \$ \{0,1\} ; m \leftarrow \$ M_{\lambda}
      If j = \ell_{\mathcal{H}}(\lambda) then
            a^* \leftarrow a
                                                                                                      \mathbf{x}[i] \leftarrow (w_{2|\alpha/n|-b,\lambda}, m)
            Halt computation of S_1 with state St
                                                                                                Return \overline{\varepsilon}
      Else return \varepsilon
                                                                                          On F-query (a, s) do:
On F-query (a, s) do:
                                                                                                If 1 \le s \le i and a \in \mathsf{El}(\mathbf{a}) do:
      If 1 \le s \le i and a \in A do:
                                                                                                Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
      Return \mathcal{F}(\lambda, a, \mathbf{x}[s])
                                                                                                Else return \perp
                                                                                         Let w be the output of S
      Else return \perp
\overline{St} \leftarrow St \|i\|j\|\mathbf{x}\|A\|a^*
                                                                                         Return w
Return \overline{St}
```

Namely,  $S_1$  runs S up to the point that it makes its *last* OP query (namely the  $\ell_{\mathcal{H}}(\lambda)$ -th one), and  $S_2$  runs S following this OP query. Below we justify the following sequence of inequalities:

$$\Pr\left[\text{ISS1-U}_{\mathcal{F},Z,D,R}^{S}(\cdot)\right] = \mathbf{AP}_{1}(P_{1}, P_{2}, \lambda)$$

$$\leq \sqrt{\mathbf{AP}_{2}(S_{1}, S_{2}, \lambda)}$$

$$\leq \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + \Pr\left[\mathcal{F}(\lambda, a_{\lambda}, \mathbf{x}) \in Y\right]}$$

$$\leq \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + 2^{\ell}(1/2)^{n}}$$

$$= \sqrt{\mathbf{Adv}_{\mathcal{H},C}^{\text{col}}(\lambda) + 1/\mu(\lambda)}$$

Above, the first line is by construction; note that while  $S_2$  chooses  $\mathbf{x}^*$  and hence some components of  $\mathbf{x}$  differently than S, this is equivalent due to the 2n-identity embeddability of  $\mathcal{F}$  and is only used to make the analysis more transparent. The second is by Lemma 4.2. For the third, we can define C analogously to the proof of Theorem 4.1 (namely, C simply mimics the double execution experiment with  $S_1, S_2$ ). Let us denote the two outputs of  $S_2$  in that experiment as  $w^1 = (pk^1, \mathbf{c}^1, h^1, \mathbf{sk}^1)$  and  $w^2 = (pk^2, \mathbf{c}^2, h^2, \mathbf{sk}^2)$ . Now, unless C finds a collision we have  $\mathbf{c}^1 = \mathbf{c}^2$ , denote by  $\mathbf{c}^*$  this common value. Then define the set  $Y := \{y \in \{0,1\}^* : \exists s \in \{0,1\}^\ell \text{ s.t. } \operatorname{Dec}(s, \mathbf{c}^*[i^*n \dots i^*n + n - 1]) = y\}$ . If it is not the case that  $\mathcal{F}(\lambda, a_{i^*,\lambda}, \mathbf{x}[i^*n \dots i^*n + n - 1]) \in Y$  when  $\mathbf{x}[i^*n \dots i^*n + n - 1]$  is (re-)sampled by  $S_2$  then the relation R must reject, as no  $\mathbf{sk}^2$  will satisfy  $\operatorname{Dec}(\mathbf{sk}^2[i^*], \mathbf{c}^*[i^*n \dots i^*n + n - 1]) = \mathcal{F}(\lambda, a_{i^*n - h[i^*]}, \mathbf{x}[i^*n \dots i^*n + n - 1])$ , justifying the third line above. To see the fourth line, fix  $s \in \{0,1\}^\ell$  and denote  $\operatorname{Dec}(s, \mathbf{c}^*[i^*n \dots i^*n + n - 1])$  by  $\mathbf{x}^*$ . As  $\mathbf{x}[i^* \cdot n]$  is defined as  $(w_{2\lfloor\alpha/n\rfloor - b,\lambda}, m)$  for random  $b \in \{0,1\}$  and  $m \in M_\lambda$ ,  $\mathbf{x}[i^*n \dots i^*n + n - 1]$ , which are sampled independently. Taking a union bound over all possible  $s \in \{0,1\}^\ell$  yields the fourth line. Finally, for the fifth line above we just substitute  $n(\lambda) = \ell(\lambda) + \log(\mu(\lambda))$ .