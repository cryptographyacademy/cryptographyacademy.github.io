# <span id="page-0-0"></span>Somewhere Statistical Soundness, Post-Quantum Security and SNARGs

Yael Tauman Kalai<sup>∗</sup> Microsoft Research

Vinod Vaikuntanathan† MIT

Rachel Yun Zhang‡ MIT

August 19, 2021

#### Abstract

The main conceptual contribution of this paper is a unification of two leading paradigms for constructing succinct argument systems, namely Kilian's protocol and the BMW (Biehl-Meyer-Wetzel) heuristic. We define the notion of a multi-extractable somewhere statistically binding (meSSB) hash family, an extension of the notion of somewhere statistically binding hash functions (Hubacek and Wichs, ITCS 2015), and construct it from LWE. We show that when instantiating Kilian's protocol with a meSSB hash family, the first two messages are simply an instantiation of the BMW heuristic. Therefore, if we also instantiate it with a PCP for which the BMW heuristic is sound, e.g., a computational non-signaling PCP, then the first two messages of the Kilian protocol is a sound instantiation of the BMW heuristic.

This leads us to two technical results. First, we show how to efficiently convert any succinct non-interactive argument (SNARG) for BatchNP into a SNARG for any language that has a computational non-signaling PCP. Put together with the recent and independent result of Choudhuri, Jain and Jin (Eprint 2021/808) which constructs a SNARG for BatchNP from LWE, we get a SNARG for any language that has a computational non-signaling PCP, including any language in P, but also any language in NTISP (non-deterministic bounded space), from LWE.

Second, we introduce the notion of a somewhere statistically sound (SSS) interactive argument, which is a hybrid between a statistically sound proof and a computationally sound proof (a.k.a. an argument), and

- prove that Kilian's protocol, instantiated as above, is an SSS argument;
- show that the soundness of SSS arguments can be proved in a straight-line manner, implying that they are also post-quantum sound if the underlying assumption is post-quantum secure; and
- conjecture that constant-round SSS arguments can be soundly converted into noninteractive arguments via the Fiat-Shamir transformation.

<sup>∗</sup>E-mail:yael@microsoft.com

<sup>†</sup>E-mail:vinodv@csail.mit.edu

<sup>‡</sup>E-mail:rachelyz@mit.edu

## Contents

| 1 | Introduction                                        |                                                                                       | 1  |
|---|-----------------------------------------------------|---------------------------------------------------------------------------------------|----|
|   | 1.1                                                 | Multi-Extractable Somewhere Statistically Binding (meSSB) Hash Families<br>           | 2  |
|   | 1.2                                                 | Somewhere Statistically Sound (SSS) Interactive Arguments<br>                         | 3  |
|   |                                                     | 1.2.1<br>SSS, Straight-Line Soundness and Post-Quantum Security<br>                   | 5  |
|   |                                                     | 1.2.2<br>SSS<br>and Fiat-Shamir Friendliness<br>                                      | 5  |
|   |                                                     | 1.2.3<br>Instantiating an<br>SSS<br>version of Kilian<br>                             | 6  |
|   | 1.3                                                 | SNARGs: from<br>BatchNP<br>to<br>P<br>and Beyond<br>                                  | 7  |
| 2 | Preliminaries<br>8                                  |                                                                                       |    |
|   | 2.1                                                 | Straight-Line Reductions<br>                                                          | 9  |
|   | 2.2                                                 | Probabilistically Checkable Proofs (PCP)<br>                                          | 9  |
|   | 2.3                                                 | Hash Function Families with Local Opening<br>                                         | 11 |
|   | 2.4                                                 | Kilian's Protocol.<br>                                                                | 12 |
|   | 2.5                                                 | The<br>BMW<br>Heuristic.<br>                                                          | 12 |
| 3 | Somewhere Statistically Binding Hash Functions      |                                                                                       | 13 |
|   | 3.1                                                 | Extractable Somewhere Statistically Binding (eSSB) Hash Functions<br>                 | 14 |
|   | 3.2                                                 | Multi-Extractable<br>SSB<br>(meSSB) Hash Functions<br>                                | 15 |
|   | 3.3                                                 | The<br>BMW<br>Protocol with<br>meSSB<br>Hash Families<br>                             | 17 |
| 4 | Somewhere Statistically Sound Interactive Arguments |                                                                                       | 19 |
|   | 4.1                                                 | Defining<br>SSS<br>Arguments<br>                                                      | 19 |
|   | 4.2                                                 | SSS<br>implies Straight-Line Soundness<br>                                            | 20 |
|   | 4.3                                                 | SSS<br>implies Post-Quantum Soundness<br>                                             | 20 |
| 5 |                                                     | Kilian's Protocol is Somewhere Statistically Sound                                    | 21 |
| 6 |                                                     | SNARG for Languages with Non-Signaling<br>PCPs                                        | 24 |
|   | 6.1                                                 | BatchNP<br>                                                                           | 24 |
|   |                                                     | 6.1.1<br>SNARGs for<br>BatchNP<br>                                                    | 24 |
|   | 6.2                                                 | SNARG for Languages with a Non-Signaling<br>PCP<br>                                   | 25 |
|   |                                                     | 6.2.1<br>SNARGs for<br>L<br>from SNARGs for<br>BatchNP<br>with Succinct Instances<br> | 26 |
|   |                                                     | L<br>6.2.2<br>SNARGs for<br>from SNARGs for<br>BatchNP<br>with Low Depth Verifier<br> | 30 |
| A |                                                     | Proof of Theorem<br>3.6                                                               | 39 |

## <span id="page-2-0"></span>1 Introduction

In the past decade, there has been a significant effort to construct efficiently verifiable, succinct, and non-interactive argument systems (also called SNARGs).[1](#page-2-1) In our work, we propose two paths towards obtaining SNARGs for P as well as for certain sub-classes of NP. Our approaches are motivated by Kilian's celebrated work [\[Kil92\]](#page-39-0) that converts any PCP into an interactive argument using a tree hash [\[Mer87\]](#page-39-1).

Recall that in Kilian's protocol, the prover tree-commits to a PCP using a hash key generated by the verifier and sends the resulting commitment to the verifier. The verifier then samples a PCP query at random and sends it to the prover. The prover must then send back answers to the PCP queries along with verification paths for each answer w.r.t. the previously sent commitment.

We take a somewhat anachronistic view and see Kilian's four-message, public-coin interactive argument as a natural interpolation of the two-message, privately verifiable Biehl-Meyer-Wetzel (BMW) heuristic.

Recall that the BMW heuristic takes any PCP and any (computationally secure) single-sever PIR scheme, and uses them to construct a two-message succinct argument where the verifier sends each PCP query to the prover as a PIR query, and the prover runs the PIR protocol with the database being the PCP proof string, and responds accordingly (see Section [2.5](#page-13-1) for more details). The BMW heuristic is not known to be sound in general [\[DLN](#page-38-0)+04, [DHRW16\]](#page-37-0); however, it is known to be computationally sound if it is instantiated with a PCP with a special property known as computational non-signaling [\[KRR13,](#page-39-2) [BHK17\]](#page-36-0). We note that not all NP languages have such a (computational non-signaling) PCP, and such a PCP was constructed only for P [\[KRR14,](#page-39-3) [BHK17\]](#page-36-0) and some sub-classes of NP such as NTISP [\[BKK](#page-37-1)+18].[2](#page-2-2) We refer to such PCPs for which the BMW heuristic is computationally sound as BMW-compatible. Note that the BMW heuristic results in a privately verifiable protocol since the verifier needs to run the PIR decoding algorithm on the prover's message, in a sense decrypting it using a private key.

Constructing two-message publicly verifiable succinct arguments, which in turn give us SNARGs in the common reference string model, appears to be a significantly harder challenge. Indeed, the only construction we have of SNARGs under a post-quantum assumption is restricted to bounded depth computations [\[JKKZ20\]](#page-39-4). One attempt to constructing a SNARG for all of P was recently made in [\[KPY19\]](#page-39-5), which showed how to convert the BMW heuristic to a publicly verifiable one by relying on a primitive called zero-testable encryption [\[PR17\]](#page-39-6). In addition, they gave a construction of this primitive under a complexity assumption on groups with bilinear maps. This left open the problem of relying on more standard and ideally post-quantum secure assumptions, a problem which we tackle in this work.

<span id="page-2-2"></span><span id="page-2-1"></span><sup>1</sup>An argument system is a computationally sound proof system.

<sup>2</sup>The class NTISP(t, s) consists of all the languages that are decidable by a non-deterministic Turing machine running in time t and space s. The computational non-signaling PCP constructed in [\[BKK](#page-37-1)<sup>+</sup>18] has query complexity s · polylog(t) and as a result the communication complexity of the BMW heuristic grows with s · polylog(t).

#### <span id="page-3-2"></span><span id="page-3-0"></span>1.1 Multi-Extractable Somewhere Statistically Binding (meSSB) Hash Families

As a starting point, consider instantiating Kilian's protocol with a somewhere statistically binding (SSB) hash function [\[HW15\]](#page-38-1) in place of a generic tree hash. Recall that an SSB hash family is a hash family H where each hash key hk is associated with an index i ∈ [L], where L is the length of the input, such that Hash(hk, x) is statistically binding on x<sup>i</sup> , and importantly, the key hk hides the index i. In this work we consider extractable SSB (eSSB) hash families, which are SSB hash families with the additional property that one can extract x<sup>i</sup> from the hash value Hash(hk, x) given a trapdoor td that is generated together with hk (see Section [2.3,](#page-12-0) Definition [3.1\)](#page-15-1).

We observe that an eSSB hash family is essentially a (computational) single-server PIR scheme, where the query corresponding to index i is the hash key hk associated with the index i, the database answer corresponding to database x simply runs Hash(hk, x), and given the trapdoor td corresponding to hk one can indeed extract x<sup>i</sup> from Hash(hk, x), without revealing the secret index i. Armed with this observation, we note that if we instantiate Kilian's protocol with an eSSB hash family, the first two messages are quite similar to the BMW heuristic, the difference being that the BMW heuristic uses many PIR queries (as many as the number of PCP queries), whereas an eSSB families support a single PIR query.

To remedy this, we consider the notion of a multi-extractable SSB (meSSB) hash family, where each key hk is associated with several indices i1, . . . , i` ∈ [N], and is generated with trapdoors td1, . . . ,td` , such that one can extract xi<sup>1</sup> , . . . , xi` from Hash(hk, x). Importantly, since in the BMW heuristic each query is generated using fresh randomness, to match this heuristic, we need to require that for every i ∈ [`], the index i remains hidden, even given the key hk and all the trapdoors {tdj}j∈[`]\{i} . We note that if we instantiate Kilian's protocol with a meSSB hash family then the first two messages are precisely the BMW heuristic! This observation is the first conceptual contribution of this work.

This instantiation of Kilian's protocol with a meSSB hash family can alternatively be thought of as a way of converting the BMW protocol to a publicly verifiable one, albeit at the cost of adding two rounds. In this instantiation, we execute the BMW heuristic, but the verifier never decrypts the PIR answers. Instead, we view the PIR answers as a commitment to the PCP, and we add two messages, where the verifier sends PCP queries in the clear, and the prover decommits to the answers. These additional messages are in lieu of the verifier decrypting the PIR answers by himself.

Starting with this observation, we proceed to offer two paths to convert Kilian's protocol into a SNARG.

The Fiat-Shamir Paradigm. The first approach, which we elaborate on in Section [1.2,](#page-4-0) considers applying the Fiat-Shamir paradigm to Kilian's protocol when instantiated with a meSSB hash family and with a BMW-compatible PCP. [3](#page-3-1) At first it may seem that this approach is doomed to fail, in light of the recent negative result of [\[BBH](#page-36-1)+19], which shows that the Fiat-Shamir paradigm is not sound when applied to Kilian's protocol. However, we argue that this specific instantiation of Kilian's protocol has a special property, which we refer to as somewhere statistical soundness (SSS), that allows it to evade this specific negative result. We conjecture that SSS protocols are

<span id="page-3-1"></span><sup>3</sup>We note that such a PCP may not always exist, but is known to exist for P and some sub-classes of NP.

<span id="page-4-1"></span>Fiat-Shamir friendly, meaning that for any SSS protocol there is some choice of hash function using which the application of the Fiat-Shamir paradigm to the protocol is sound. Additionally, we argue that SSS protocols are of independent interest. In particular, we prove that every SSS protocol has a straight-line soundness proof and as a result is post-quantum sound (assuming the underlying assumption is post-quantum secure). We elaborate on this in Section [1.2.](#page-4-0)

Using SNARGs for BatchNP. The second approach we consider is to use a SNARG for BatchNP to convert the first two messages in the above instantiation of Kilian's protocol for a language L into a SNARG for L. A similar result was shown independently by [\[CJJ21\]](#page-37-2). We elaborate on this in Section [1.3.](#page-8-0)

### <span id="page-4-0"></span>1.2 Somewhere Statistically Sound (SSS) Interactive Arguments

One noteworthy property of our instantiation of Kilian's protocol is that due to the soundness of the BMW heuristic, with high probability a cheating prover is statistically committed to incorrect answers on the particular locations specified by the meSSB hash function. Thus, if the verifier's PCP query points to exactly the locations that are statistically bound by the meSSB hash function, the verifier is guaranteed to reject no matter what the final message of the prover is. We call this somewhere statistical soundness (SSS), in analogy with somewhere statistical binding.

We can extend this to multi-round protocols just as well, however we focus on 4-round protocols where, without loss of generality, we assume that the first message is sent by the verifier. Formally, an interactive argument (P, V) is said to be SSS if for every legal first message β1, there exists a third message β<sup>2</sup> = T(β1) sent by the verifier such that the following two properties hold:

- For every poly-size deterministic cheating prover P ∗ , conditioned on the first three messages being (β1,P ∗ (β1), T(β1)) the remaining protocol is statistically sound with overwhelming probability over β1. Namely, for any x /∈ L and any (deterministic) poly-size P ∗ , with overwhelming probability, any (even all powerful) cheating prover cannot convince the verifier to accept x /∈ L except with negligible probability, conditioned on the first three messages being (β1,P ∗ (β1), T(β1)).
- The pair (β1, T(β1)) is computationally indistinguishable from a random pair (β1, β2) of the verifier's first two messages. We emphasize that this in particular implies that the function T has to be computationally inefficient.

We study the implications of SSS protocols. As we argue below, SSS interactive arguments are of great interest for several reasons.

1. First, we prove that such protocols are post-quantum sound, if the assumption that they rely on is post-quantum secure. We note that in general, interactive protocols that are proven classically secure under post-quantum assumptions are not post-quantum secure. This is because the proof of security often relies on the rewinding technique, which is not generally applicable in the quantum setting due to the fact that quantum states are not clonable [\[Wat09,](#page-40-1) [Unr12\]](#page-40-2). We show that SSS arguments have a straight-line proof of soundness (i.e., without <span id="page-5-2"></span>rewinding the cheating prover), and are thus immediately post-quantum sound. We elaborate on this in Section [1.2.1.](#page-6-0)

- 2. Second, we prove that Kilian's protocol, instantiated with a meSSB hash family (for which constructions based on the LWE assumption exist) and a BMW-compatible PCP, is SSS. We elaborate on this in Section [1.2.3.](#page-7-0) Combined with (1), this provides a rather simple proof of post-quantum soundness of Kilian's protocol, comprehensible to a "quantum dummy." [4](#page-5-0)
  - We note that we have constructions of BMW-compatible PCPs only for deterministic languages and for specific classes of non-deterministics languages such as NTISP, and thus our instantiation of Kilian's protocol is post-quantum sound for only such classes. Proving that the classical Kilian protocol [\[Kil92\]](#page-39-0) is post-quantum sound for all of NP was a grand challenge, and was only very recently resolved by Chiesa, Ma, Spooner and Zhandry [\[CMSZ21\]](#page-37-3) using highly non-trivial quantum techniques.[5](#page-5-1)
- 3. Finally, we conjecture that any SSS interactive argument is Fiat-Shamir friendly; meaning that for any SSS interactive argument (P, V) there exists a hash family H such that applying the Fiat-Shamir paradigm w.r.t. H to (P, V) results with a sound non-interactive argument. We elaborate on this (and define the Fiat-Shamir paradigm) in Section [1.2.2.](#page-6-1) We mention that prior to this work, the only interactive argument that was proven to be Fiat-Shamir friendly, in the work of Canetti et al. [\[CSW20\]](#page-37-4), is indeed an SSS argument and was used to construct a (non-succinct) UC NIZK for NP with an adaptive soundness guarantees.

We emphasize that we do not prove that any SSS interactive argument is Fiat-Shamir friendly, only conjecture it. We believe that it is a promising path for obtaining SNARGs based on a standard post-quantum assumption. In particular, we propose constructing an SSS interactive argument for all of NP as a great open problem. We note that it is easier than constructing a (non-adaptive) SNARG for NP, since any such SNARG is in particular SSS (with two additional arbitrary rounds that are ignored by the verdict function). Constructing a nonadaptive SNARG for NP has been a major open problem, and constructing a succinct SSS protocol can be seen as a stepping stone for achieving this goal.

Note that since we prove that our instantiation of Kilian's protocol is SSS, and since we conjecture that any SSS protocol is Fiat-Shamir friendly, as a special case we conjecture that our instantiation of Kilian's protocol (with a meSSB hash family and a BMW-compatible PCP) is Fiat-Shamir friendly.

This is in contrast with the recent work [\[BBH](#page-36-1)+19] that showed that in general, Kilian's protocol is not Fiat-Shamir friendly. We remark that it was already suggested in [\[BBH](#page-36-1)+19] to use an SSB hash family as one step to evade their impossibility result. We suggest to use a meSSB hash family combined with a BMW-compatible PCP. If sound, this would yield a SNARG for all of P (and some sub-classes of NP, as described above).

<span id="page-5-1"></span><span id="page-5-0"></span><sup>4</sup> <https://simons.berkeley.edu/events/quantum-lectures-crypto-dummies>

<sup>5</sup>We mention that it is not clear how to simplify their proof for the subclasses of NP as above, without using a meSSB hash family (rather using an arbitrary collapse binding hash family), since our simple post-quantum proof strongly relies on the fact that the first two messages are a sound instantiation of the BMW heuristic.

#### <span id="page-6-0"></span>1.2.1 SSS, Straight-Line Soundness and Post-Quantum Security

In a nutshell, the reason that any SSS protocol is post-quantum sound is due to the fact that it has straight-line soundness, meaning that any (even quantum) successful cheating prover can be used in a black box and straight-line manner (without rewinding) to break some complexity assumption.

Theorem 1.1 (Informal). Any SSS interactive argument has a straight-line soundness proof.

Loosely speaking, we prove this theorem as follows. Fix any SSS interactive argument (P, V) for a language L. We construct a (uniform) PPT black-box reduction R, that takes as input a pair (β1, β2), and distinguishes between the case that β<sup>2</sup> = T(β1) and the case that β<sup>2</sup> is chosen at random, given black-box and straight-line access to any (even quantum) cheating prover P ∗ .

The reduction R works as follows: It runs the cheating prover with β1, and then upon receiving α<sup>1</sup> = P ∗ (β1), it sends P ∗ the challenge β2. The reduction then continues emulating the honest verifier until the end of the protocol. If the transcript is accepting, then R outputs 1 (indicating that β<sup>2</sup> is random), and otherwise it outputs 0. By the assumption that P ∗ is convincing with non-negligible probability, if β<sup>1</sup> and β<sup>2</sup> are random then the transcript is accepting with nonnegligible probability. On the other hand, by the SSS property, if β<sup>2</sup> = T(β1), then the transcript is accepted with only negligible probability. Thus, the reduction R outputs 1 with probability that is non-negligibly larger in the case that β<sup>2</sup> is random, as desired.

We note that any interactive argument that has a straight-line soundness proof is immediately post-quantum sound, assuming that the underlying assumption is post-quantum secure. This is the case since the analysis above extends readily to the quantum setting. As mentioned above, this is in contrast to the standard analysis which uses rewinding, and hence often fails in the post-quantum setting.

Claim 1.2 (Informal). Any SSS interactive argument where both SSS properties are straightline reducible from an assumption A is also post-quantum sound if assumption A holds w.r.t. quantum adversaries.

A formal proof of this Claim appears in Section [4.2](#page-21-0) (Theorem [4.4\)](#page-21-2). This property makes SSS arguments particularly appealing, given the major effort by the community to make cryptographic protocols post-quantum secure.

### <span id="page-6-1"></span>1.2.2 SSS and Fiat-Shamir Friendliness

Another reason why SSS arguments are of interest is that we believe (and conjecture) that such protocols are "Fiat-Shamir friendly." Recall that the Fiat-Shamir paradigm converts an interactive proof (P, V) for a language L to a non-interactive argument (P 0 , V 0 ) for L in the CRS model. The CRS consists of randomly chosen hash functions h1, . . . , h` from a hash family H, where ` is the number of rounds in the protocol (P, V). To compute a non-interactive proof for x ∈ L, the non-interactive prover P 0 (x) generates a transcript corresponding to (P, V)(x), denoted by (α1, β1, . . . , α` , β`), by emulating P(x) and replacing each verifier message β<sup>i</sup> by β<sup>i</sup> = hi(α1, β1, . . . , αi−1, βi−1, αi). The verifier V 0 (x) accepts if and only if V(x) accepts this transcript and β<sup>i</sup> = hi(α1, β1, . . . , αi−1, βi−1, αi) for every i ∈ [`].

<span id="page-7-2"></span>This paradigm has been extremely influential in practice, and its soundness has been extensively studied. For statistically sound proofs, this paradigm is believed to be sound, at least under strong computational assumptions [\[KRR17,](#page-39-7) [CCRR18,](#page-37-5) [HL18,](#page-38-2) [CCH](#page-37-6)+19]. Moreover, for some protocols such as the Goldwasser-Kalai-Rothblum protocol [\[GKR08\]](#page-38-3) and several zero-knowledge protocols for NP such as Blum's Hamiltonicity protocol [\[Blu86\]](#page-37-7) and the GMW 3-coloring protocol [\[GMW91\]](#page-38-4), this paradigm is provably sound under the polynomial or sub-exponential hardness of learning with errors (LWE) [\[CCH](#page-37-6)+19, [PS19,](#page-40-3) [JKKZ21,](#page-39-8) [HLR21\]](#page-38-5), which are standard assumptions.

On the other hand, for computationally sound proofs (known as arguments) the situation is quite grim. There are (contrived) examples of interactive arguments for which the resulting noninteractive argument obtained by applying the Fiat-Shamir paradigm is not sound, no matter which hash family is used [\[Bar01,](#page-36-2) [GK05\]](#page-38-6). Moreover, recently it was shown that the Fiat-Shamir paradigm is not sound when applied to the celebrated Kilian's protocol [\[BBH](#page-36-1)+19].

As a natural interpolation between statistically sound proofs and computationally sound arguments, it is natural to ask whether the hybrid class of all (constant round) SSS interactive arguments is Fiat-Shamir friendly.

Conjecture 1.3. Any constant round SSS interactive argument (P, V) is Fiat-Shamir friendly.

We note that all known negative results for the Fiat-Shamir paradigm [\[Bar01,](#page-36-2) [GK03,](#page-38-7) [BBH](#page-36-1)+19] are for arguments that are not SSS. In particular, these interactive arguments are constructed by adding an additional accepting clause, such that if the prover can predict the verifier's next message then he can easily convince the verifier to accept this alternative clause (even false statements). This does not harm soundness in the interactive setting since the interactive prover cannot predict the verifier's next message and hence cannot use this additional clause. On the other hand, when Fiat-Shamir is applied, the prover can, by definition, use the description of the hash function to predict the verifier's next message, harming the soundness of the non-interactive protocol and thus demonstrating the insecurity of the Fiat-Shamir paradigm.

Crucially, we emphasize that this additional clause makes the resulting argument not SSS, since this additional clause inherently does not have statistical soundness. This is the case because the witness for this additional clause (which is the Fiat-Shamir hash function) can be larger than the communication complexity, and hence to verify this clause we must use a succinct argument. Importantly, we note that even if this clause is SSS the entire protocol is not, since this clause is executed after the first two messages.

We note that Bartusek et al. [\[BBH](#page-36-1)+19] give an instantiation of Kilian's protocol for the trivial (empty) language for which applying the Fiat-Shamir paradigm provably results in a sound protocol. Their instantiation employs an eSSB hash function and a particular PCP for the empty language, and the protocol is in fact SSS. Indeed, our conjecture is a stronger statement, namely that the notion of meSSB is sufficient to apply Fiat-Shamir soundly, assuming the PCP in use makes the BMW heuristic sound.

#### <span id="page-7-0"></span>1.2.3 Instantiating an SSS version of Kilian

<span id="page-7-1"></span>We show that Kilian's protocol instantiated with a meSSB hash family, and a BMW-compatible PCP, is an SSS argument. In particular, we obtain the following corollary.

<span id="page-8-2"></span>Theorem 1.4 (Informal). Kilian's protocol is SSS, and thus has post-quantum soundness, if we use a BMW-compatible PCP and if the prover commits to this PCP using a post-quantum meSSB hash function.

Hubáček and Wichs [\[HW15\]](#page-38-1) constructed an eSSB hash family assuming the hardness of LWE. This hash family is post-quantum secure assuming the post-quantum hardness of LWE. We note that any eSSB hash family can be easily extended to a meSSB hash family.

Moreover, (adaptive) BMW-compatible PCPs are known for all deterministic languages [\[BHK17\]](#page-36-0) and languages in NTISP [\[BKK](#page-37-1)+18]. For deterministic languages the (adaptive) soundness relies on the polynomial hardness of the underlying PIR scheme, whereas for languages in NTISP the (adaptive) soundness relies on the sub-exponential hardness of the underlying PIR scheme.[6](#page-8-1) The query complexity for languages in DTIME(t) is polylog(t), and for languages in NTISP(t, s) it is s · polylog(t). These results, together with Theorem [1.4,](#page-7-1) imply the following corollary.

Corollary 1.5 (Informal). There exists an instantiation of Kilian's protocol that is SSS, and thus post-quantum sound, for all deterministic computations assuming the polynomial postquantum hardness of LWE, and for all languages in NTISP assuming the sub-exponential post-quantum hardness of LWE. For DTIME(t) languages the communication complexity grows with polylog(t), and for languages in NTISP(t, s) the communication complexity grows with s · polylog(t).

As mentioned above, we conjecture that this instantiation is Fiat-Shamir friendly, and leave the proof (or refutation) of this conjecture as an important open problem.

### <span id="page-8-0"></span>1.3 SNARGs: from BatchNP to P and Beyond

This view of the first two messages of Kilian's protocol as an instantiation of the BMW heuristic leads us to our final contribution: an alternative pathway to getting a SNARG for any language that has a BMW-compatible PCP. Specifically, we show a reduction from constructing a SNARG for the class of all languages that have a BMW-compatible PCP to the simpler goal of constructing a SNARG for BatchNP.

The starting point is the two-round preamble where the verifier sends the prover the description of a meSSB hash function, and the prover replies with a multi-extractable commitment to a BMWcompatible PCP. The key observation is that the remainder of the protocol can be a proof of the following BatchNP statement (which can be communicated in the first two rounds as well): for every possible query set Q generated by the PCP verifier, there are values of π<sup>Q</sup> as well as openings o<sup>Q</sup> such that (a) (πQ, oQ) constitutes a valid opening; and (b) the PCP verifier accepts (Q, πQ).

We argue that this 2-message protocol is sound: If the instance being proven is false, then by the soundness of the BMW-heuristic the answers that are committed to by the meSSB hash function are rejecting, and hence by the meSSB binding property, the resulting BatchNP statement is false. Therefore, it seems that all we need to instantiate this approach is a SNARG for BatchNP.

<span id="page-8-1"></span><sup>6</sup>We mention that the difference stems from the fact that for the non-deterministic languages we can only construct PCPs that have sub-exponential non-signaling (adaptive) soundness, whereas deterministic languages have polynomial non-signaling (adaptive) soundness.

<span id="page-9-2"></span>There are several issues that come up in making this idea work. First, if the PCP has negligible soundness error, then the number of possible query sets generated by the verifier is superpolynomially large, meaning that the (honest) prover runtime is super-polynomial. Fortunately, all known PCP constructions (including the ones from [\[KRR14,](#page-39-3) [BHK17,](#page-36-0) [BK18\]](#page-36-3)) have the property that each query set can be partitioned into a set of "tests," where the queries in each test and their corresponding answers can be verified on their own, and importantly, the number of possible tests is polynomial.[7](#page-9-1) Therefore, our BatchNP statement should rather be that for every test ζ there are values of π<sup>ζ</sup> as well as openings o<sup>ζ</sup> such that (a) (π<sup>ζ</sup> , o<sup>ζ</sup> ) constitutes a valid opening; and (b) the PCP verifier accepts (ζ, π<sup>ζ</sup> ). Note that this BatchNP statement is polynomially large.

Secondly, even though we ensured that the number of instances in the BatchNP statement is polynomial, this polynomial, denoted by N, is at least as large as the runtime of the underlying computation. Note that even though the proof length scales only poly-logarithmically with N, the verifier runtime scales at least linearly with N since the verifier needs to at least read the entire statement. To solve this, we observe that in our case, the BatchNP statement actually has a succinct description. Thus, if there are succinct, easy to verify, proofs for succinctly specified BatchNP statements, we are back in business. We note that even if this is not the case, if the verifier's verdict function can be computed by a circuit that has depth only polylog(N) (but size poly(N)), then again we are in business since we can use the SNARG for bounded depth computations (from sub-exponential LWE) [\[JKKZ20\]](#page-39-4), and delegate this computation back to the prover.

Third and finally, note that the BatchNP proof system must have adaptive soundness since the prover gets to choose the BatchNP statement, in particular the hash value, after he receives the CRS/first message of the BatchNP proof. Since the hash value is small in size, this can be easily handled by complexity leveraging. We therefore only require non-adaptive soundness with appropriate security. We elaborate on this in Section [6.](#page-25-0)

Concurrent Work. In a concurrent and independent work, Choudhuri, Jain and Jin [\[CJJ21\]](#page-37-2) construct SNARGs for BatchNP from LWE. Thus, using their result together with our reduction from Section [1.3,](#page-8-0) we obtain a SNARG for any language that has a BMW-compatible PCP, from the LWE assumption. In particular, as we elaborate on in Section [6,](#page-25-0) we obtain a SNARG for any language in DTIME(t) or in NTISP(t, s) with communication complexity polylog(t) or polylog(s, log t), respectively, from the sub-exponential hardness of LWE. We note that [\[CJJ21\]](#page-37-2) also showed how to use their SNARG for BatchNP to construct a SNARG for P as well as for RAM computations.

## <span id="page-9-0"></span>2 Preliminaries

<span id="page-9-3"></span>Definition 2.1. Two distribution ensembles {Ak}k∈<sup>N</sup> and {Bk}k∈<sup>N</sup> are said to be Ωindistinguishable if for every poly(Ω)-size distinguisher D there exists a negligible function µ such that for every k ∈ N,

$$|\Pr_{a \leftarrow A_k}[\mathcal{D}(a) = 1] - \Pr_{b \leftarrow B_k}[\mathcal{D}(b) = 1]| \le \mu(\Omega(k)).$$

<span id="page-9-1"></span><sup>7</sup>For example, the tests in the PCP of [\[BFLS91\]](#page-36-4) (and in the PCP of [\[KRR14,](#page-39-3) [BKK](#page-37-1)<sup>+</sup>18]) are either low-degree tests or consistency tests.

#### <span id="page-10-5"></span><span id="page-10-0"></span>2.1 Straight-Line Reductions

In this section, we define the notion of straight-line soundness, and more generally straight-line reductions.

<span id="page-10-4"></span>**Definition 2.2.** (Straight-Line Reductions) We say that an interactive argument  $(\mathcal{P}, \mathcal{V})(1^{\kappa})$  for a language  $\mathcal{L} = \{\mathcal{L}_n\}_{n \in \mathbb{N}}$  is (adaptively)  $\theta = \theta(\kappa)$ -straight-line sound if there is a PPT black box reduction  $\mathcal{R}$  and a non-interactive  $\theta$ -decisional complexity assumption [GK16], such that  $\mathcal{R}$ , given oracle access to any cheating prover  $\mathcal{P}^*$  that breaks (adaptive) soundness with probability  $1/\text{poly}(\theta)$ , interacts with  $\mathcal{P}^*$  once (without rewinding) by sending  $\mathcal{P}^*$  a single message for each round, and using the transcript obtained, breaks the assumption.

More generally, we say that a primitive is  $\theta = \theta(\kappa)$ -straight-line secure (or  $\theta$ -secure via a straight-line reduction, or its security proof is  $\theta$ -straight line) if there is a PPT black box reduction  $\mathcal R$  and a non-interactive  $\theta$ -decisional complexity assumption such that  $\mathcal R$ , given oracle access to any size-poly( $\theta$ ) adversary  $\mathcal A$  that breaks the security of the primitive with probability  $1/\text{poly}(\theta)$ , interacts with  $\mathcal A$  once (without rewinding) and, using the transcript obtained, breaks the assumption.

**Definition 2.3** ([GK16]). An assumption is a  $\theta$ -decisional complexity assumption if it is associated with two probabilistic polynomial-time distributions  $(\mathcal{D}_0, \mathcal{D}_1)$ , such that for any  $\operatorname{poly}(\theta)$ -size algorithm  $\mathcal{A}$  there exists a negligible function  $\mu$  such that for any  $\kappa \in \mathbb{N}$ ,

$$\left| \Pr_{x \leftarrow \mathcal{D}_0(1^{\kappa})} [\mathcal{A}(x) = 1] - \Pr_{x \leftarrow \mathcal{D}_1(1^{\kappa})} [\mathcal{A}(x) = 1] \right| \le \mu(\theta(\kappa)).$$

## <span id="page-10-1"></span>2.2 Probabilistically Checkable Proofs (PCP)

We first recall the definition of a probabilistically checkable proof (PCP). A PCP for an NP language  $\mathcal L$  is a (deterministic) function  $\Pi$  that takes as input a witness w for a statement  $x \in L$ , and converts it into a proof  $\pi = \Pi(x,w)$  which can be verified by a randomized verifier that reads only a few of its bits.

**Definition 2.4** (PCP). A probabilistically checkable proof (PCP) for a language  $\mathcal{L}$  is a triple of algorithms  $(\Pi, \mathcal{Q}_{\mathsf{PCP}}, \mathcal{V}_{\mathsf{PCP}})$  with the following syntax:

- It is a deterministic algorithm that takes as input an instance  $x \in \mathcal{L}$  (and possibly some additional information, such as a witness), and outputs a proof string  $\pi$ . We will denote the length of the PCP by  $L = |\pi|$ .
- $Q_{PCP}$  is a probabilistic query generation algorithm which takes as input a security parameter  $1^{\kappa}$ , and generates a set of queries  $q_1, \ldots, q_{\ell} \in [L]$ .
- $V_{PCP}$  is a deterministic polynomial-time verification algorithm that takes as input an instance x, a set of queries  $(q_1, \ldots, q_\ell)$  and a corresponding set of answers  $(a_1, \ldots, a_\ell)$ , and outputs 0 (reject) or 1 (accept).

<span id="page-10-2"></span><sup>&</sup>lt;sup>8</sup>We focus on decisional assumptions for simplicity, and because our reductions are from decisional assumptions.

<span id="page-10-3"></span><sup>&</sup>lt;sup>9</sup>It will be clear what the  $\theta$ -decisional complexity assumption is in each context.

<span id="page-11-2"></span>We require the following properties to hold:

1. (Perfect) Completeness: For every x ∈ L,

$$\Pr[\mathcal{V}_{\mathsf{PCP}}(x, (q_1, \dots, q_\ell), (\pi_{q_1}, \dots, \pi_{q_\ell})) = 1] = 1$$
,

where π = Π(x), and where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ).

2. Soundness: For every x /∈ L, and for every (possibly malicious) string π <sup>∗</sup> ∈ {0, 1} ∗ ,

$$\Pr[\mathcal{V}_{\mathsf{PCP}}(x, (q_1, \dots, q_\ell), (\pi_{q_1}^*, \dots, \pi_{q_\ell}^*)) = 1] \le 2^{-\kappa} ,$$

where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ).

We will be interested in PCP's with an additional property, that each query set Q = (q1, . . . , q`) ∈ QPCP can be partitioned into several tests, such that the verifier's checks are simply the conjunction of checking each test. This property holds for all PCP's known to the authors.

<span id="page-11-0"></span>Definition 2.5. We say that a PCP (Π, QPCP, VPCP) is verified via tests if there is some algorithm UPCP such that each query set Q = (q1, . . . , q`) ∈ QPCP(1<sup>κ</sup> ) can be partitioned into θ tests ζ1∪· · ·∪ζθ, where for every j ∈ [θ] there exists a set of indices I<sup>j</sup> ⊆ [`] such that ζ<sup>j</sup> = Q|I<sup>j</sup> , and the PCP verifier accepts a set of answers A = (a1, . . . , a`) if and only if UPCP(x, Q|I<sup>j</sup> , A|I<sup>j</sup> ) = 1 for every j ∈ [θ].

Remark 2.6. We also consider a stronger notion of PCP soundness known as non-signaling soundness, and more specifically computational non-signaling soundness. The precise definition (given in Appendix [A\)](#page-40-0) is not needed in order to understand our result: what is important is that computational non-signaling PCPs are BMW-compatible.

Two remarks are in place. First, two flavors of (computational) non-signaling soundness have been considered in the literature: adaptive and non-adaptive; the latter provides non-adaptive soundness of the BMW heuristic, whereas the former provides adaptive soundness. In this work, we will describe the results with adaptive soundness. Second, there is a parameter Ω associated with the computational non-signaling soundness, such that for every Ω<sup>1</sup> < Ω2, a Ω2-computational non-signaling PCP is also a Ω1-computational non-signaling PCP. Furthermore, each such PCP is associated with a locality parameter `, which for simplicity can be thought of as the query complexity. We refer the reader to Appendix [A](#page-40-0) for the precise definitions.

Adaptive computational non-signaling PCP's have been constructed for several classes of languages. One is the language LU(t) = {LU(t(n))}n∈N, where poly(n) ≤ t(n) ≤ exp(n), such that for any (deterministic) Turing machine M and input x, (M, x) ∈ LU(t) if and only if M on input x outputs 1 within t(|(M, x)|) time steps.

<span id="page-11-1"></span>Theorem 2.7 ([\[KRR14,](#page-39-3) [BHK17\]](#page-36-0)). For any poly(n) ≤ t(n) ≤ exp(n), there exists an adaptive tcomputational non-signaling PCP for LU(t) with locality ` = κ·polylog(t), where the PCP proof has size L(n) = poly(t(n)) and can be generated in time poly(t(n)). Furthermore, QPCP(1<sup>κ</sup> ) <span id="page-12-2"></span>runs in time poly(`), and VPCP, on input (M, x), (q1, . . . , q`), and (a1, . . . , a`), runs in time |(M, x)| · poly(`).

Moreover, this PCP is verified via tests, with a total of poly(t) many possible tests ζ (see Definition [2.5\)](#page-11-0).

Another language with an adaptive computational non-signaling PCP is NLU(t, s), the class of problems that can be solved nondeterministically in time t and space s. That is, (M, x) ∈ NLU(t, s) if M is a non-deterministic Turing machine that, on input x, runs in space s(|(M, x)|) and outputs 1 within t(|(M, x)|) time steps.

<span id="page-12-1"></span>Theorem 2.8 ([\[BKK](#page-37-1)+18]). For poly(n) ≤ t ≤ exp(n) and s = s(n) ≥ log t(n), there is an adaptive 2 s -computational non-signaling PCP for NLU(t, s) with locality ` = κ · poly(s). The PCP proof has size L(n) = poly(t(n)) and can be generated in time t(n). Furthermore, the query generation algorithm runs in time poly(`) and the verifier, on input (M, x),(q1, . . . , q`),(a1, . . . , a`), runs in time |(M, x)| · poly(`).

Moreover, this PCP is verified via tests. There are a total of poly(t) possible tests ζ.

### <span id="page-12-0"></span>2.3 Hash Function Families with Local Opening

In what follows, we assume L ≤ 2 κ .

Definition 2.9 (Hash Family). A hash family is a pair of PPT algorithms (Gen, Hash), where

- Gen(1<sup>κ</sup> , L) takes as input a security parameter κ in unary and an input length L, and outputs a hash key hk ∈ {0, 1} `hk .
- Hash(hk, x) takes as input a hash key hk ∈ {0, 1} `hk and an input x ∈ {0, 1} <sup>L</sup> and outputs an element rt ∈ {0, 1} `hash .

Here, `hk = `hk(κ) = poly(κ) and `hash = `hash(κ) = poly(κ) are parameters associated with the hash family.

Definition 2.10 (Hash Family with Local Opening). A hash family with local opening is a hash family (Gen, Hash), along with two additional PPT algorithms (Open, Verify) with the following syntax:

- Open(hk, x, j) takes as input a hash key hk ∈ {0, 1} `hk , x ∈ {0, 1} <sup>L</sup>, and an index j ∈ [L] and outputs an opening o ∈ {0, 1} `o , where `<sup>o</sup> = `o(κ) = poly(κ).
- Verify(hk,rt, j, u, o) takes as input a hash key hk ∈ {0, 1} `hk , a hash value rt ∈ {0, 1} `hash , an index j ∈ [L], a value u ∈ {0, 1}, and an opening o ∈ {0, 1} `o , and outputs 1 or 0 indicating accept or reject, respectively.

These algorithms should satisfy the property:

• Correctness of Opening: For every x ∈ {0, 1} <sup>L</sup> and j ∈ [L],

$$\Pr[\mathsf{Verify}(\mathsf{hk},\mathsf{Hash}(\mathsf{hk},x),j,x_j,\mathsf{Open}(\mathsf{hk},x,j))=1]=1,$$

where the probability is over hk ← Gen(1<sup>κ</sup> , L).

### <span id="page-13-3"></span><span id="page-13-0"></span>2.4 Kilian's Protocol.

Kilian's transformation uses a hash family with local opening and a PCP scheme to construct a 4-round succinct argument.

For our description of Kilian's protocol, fix any hash family with local opening H = (Gen, Hash, Open, Verify) and a PCP scheme (Π, QPCP, VPCP) for a language L. Denote the length of a PCP proof by L = L(n). Kilian's protocol is given in Figure [1.](#page-13-2)

#### Kilian's Protocol

On input x and security parameter 1 κ , the 4-message protocol (PKilian, VKilian) proceeds as follows.

- First verifier's message: VKilian samples hk ← Gen(1<sup>κ</sup> , L), and sends hk to the prover.
- First prover's meessage: PKilian computes the PCP proof π = Π(x), and its hash value rt = Hash(hk, π). It sends rt to the verifier.
- Second verifier's message: VKilian computes a set of queries (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ), and sends (q1, . . . , q`) to the prover.
- Second prover's message: PKilian computes for every i ∈ [`] the opening o<sup>i</sup> = Open(hk, π, qi), and sends {πq<sup>i</sup> , oi}i∈[`] to the verifier.
- Verdict: VKilian accepts if and only if VPCP(x,(q1, . . . , q`),(πq<sup>1</sup> , . . . , πq` )) = 1 and for every i ∈ [`], Verify(hk,rt, q<sup>i</sup> , πq<sup>i</sup> , oi) = 1.

<span id="page-13-2"></span>Figure 1: Kilian's Protocol (PKilian, VKilian) for a Language L

#### <span id="page-13-1"></span>2.5 The BMW Heuristic.

The BMW heuristic converts a PCP scheme into a 2-message, succinct, privately verifiable argument. It does this by allowing one to query a PCP proof using a private information retrieval (PIR) scheme, which we define below.

Definition 2.11 ([\[CGKS95,](#page-37-8) [KO97\]](#page-39-9)). A 1-server private information retrieval (PIR) scheme is a tuple of PPT algorithms (Query, Answer, Reconstruct) with the following syntax:

- Query(1<sup>κ</sup> , L, q) takes as input a security parameter κ in unary, an input size L, and an index q ∈ [L], and outputs a query qˆ along with a trapdoor td.
- Answer(ˆq, x) takes as input a query qˆ and a database x ∈ {0, 1} <sup>L</sup>, and outputs an answer aˆ.
- Reconstruct(td, aˆ) takes as input a trapdoor td and an answer aˆ, and outputs a plaintext a.

These algorithms should satisfy the following properties:

<span id="page-14-2"></span>• Correctness: For every  $\kappa, L \in \mathbb{N}$  and  $q \in [L]$ ,

$$\Pr[\mathsf{Reconstruct}(\mathsf{td}, \mathsf{Answer}(\hat{q}, x)) = x_q] = 1,$$

where the probability is over  $(\hat{q}, \mathsf{td}) \leftarrow \mathsf{Query}(1^{\kappa}, q, L)$ .

• S-Privacy: For any  $poly(S(\kappa))$ -size adversary  $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$  there exists a negligible function  $\mu$  such that for every  $\kappa, L \in \mathbb{N}$ ,

$$\Pr\left[b=b' \middle| \begin{array}{c} q_0,q_1,\mathsf{state} \leftarrow \mathcal{A}_1(1^\kappa,L) \\ b \xleftarrow{\$} \{0,1\} \\ (\hat{q},\mathsf{td}) \leftarrow \mathsf{Query}(1^\kappa,L,q_b) \\ b' \leftarrow \mathcal{A}_2(\hat{q},\mathsf{state}) \end{array} \right] = \frac{1}{2} + \mu(S(\kappa)).$$

Kushilevitz and Ostrovsky [KO97] constructed the first sublinear-communication single-server PIR scheme and was followed up by several other works [GR05, Lip05, BV11, DGI+19].

**Theorem 2.12** ([BV11, DGI<sup>+</sup>19]). For any function  $S: \mathbb{N} \to \mathbb{N}$ , there exists a S-private 1-server PIR scheme with  $\operatorname{polylog}(L)$  query complexity for length-L databases, under the S-hardness of the LWE, Quadratic Residuosity, or DDH assumptions. Moreover, these schemes are S-straight-line secure (see Defintion 2.2).

Fix any 1-server PIR scheme (Query, Answer, Reconstruct) and any PCP scheme ( $\Pi$ ,  $Q_{PCP}$ ,  $V_{PCP}$ ) for a language  $\mathcal{L}$ . The BMW heuristic is a 2-message succinct argument for  $\mathcal{L}$ , defined in Figure 2.

#### The BMW Protocol

On input  $1^{\kappa}$  and x, the 2-message protocol  $(\mathcal{P}_{\mathsf{BMW}}, \mathcal{V}_{\mathsf{BMW}})$  proceeds as follows:

- Verifier:  $\mathcal{V}_{\mathsf{BMW}}$  computes  $(q_1,\ldots,q_\ell) \leftarrow \mathcal{Q}_{\mathsf{PCP}}(1^\kappa)$ . For each  $i \in [\ell]$ , it generates  $(\hat{q}_i,\mathsf{td}_i) \leftarrow \mathsf{Query}(1^\kappa,L,q_i)$ , where L is the length of the PCP. It sends  $\{\hat{q}_i\}_{i\in\ell}$  to the prover.
- Prover:  $\mathcal{P}_{\mathsf{BMW}}$  computes the PCP string  $\pi = \Pi(x)$ , and for each  $i \in [\ell]$ , it computes  $\hat{a}_i = \mathsf{Answer}(\hat{q}_i, \pi)$ . It sends  $\{\hat{a}_i\}_{i \in [\ell]}$  to the verifier.
- Verdict:  $\mathcal{V}_{\mathsf{BMW}}$  computes  $a_i = \mathsf{Reconstruct}(\mathsf{td}_i, \hat{a}_i)$  for each  $i \in [\ell]$ , and accepts if and only if  $V_{\mathsf{PCP}}(x, (q_1, \dots, q_\ell), (a_1, \dots, a_\ell)) = 1$ .

<span id="page-14-1"></span>Figure 2: The BMW Protocol  $(P_{\mathsf{BMW}}, V_{\mathsf{BMW}})$  for  $\mathcal{L}$ 

## <span id="page-14-0"></span>3 Somewhere Statistically Binding Hash Functions

Central to our paper is the notion of somewhere statistically binding (SSB) hash functions, first defined by Hubáček and Wichs [HW15]. These are hash functions with local openings that have an

additional special property: for any index  $i^*$ , one can generate a hash key that guarantees statistical binding for the position  $i^*$ . Namely, even an unbounded adversary cannot open the bit at position  $i^*$  to two different values. Furthermore, the hash key should be index-hiding, namely, it should hide the index  $i^*$  from all polynomial-time adversaries.

We augment this notion in two ways. First, we require that the statistically bound value at position  $i^*$  can be recovered from the hash output using a trapdoor underlying the hash key. It turns out that the Hubáček-Wichs construction of SSB hash functions from homomorphic encryption already satisfies this property. Secondly, we augment the SSB family so that the hash key guarantees statistical binding for a set of positions I simultaneously. Extractability now requires that there are |I| trapdoors, where  $\mathrm{td}_i$  helps us recover the statistically bound value at the  $i^{th}$  position for any  $i \in I$ . Finally, the index-hiding property needs to be augmented to hold even given the other trapdoors. We call the resulting notion a multi-extractable SSB (or meSSB) hash function.

We first present the definition of extractable SSB (eSSB) hash functions in Section 3.1 and that of multi-extractable SSB (meSSB) hash functions in Section 3.2. We also show how to construct meSSB hash functions from any eSSB hash function family in a simple way. Finally, in Section 3.3 and Appendix A, we reprove the soundness of the BMW protocol when instantiated with a meSSB hash function.

### <span id="page-15-0"></span>3.1 Extractable Somewhere Statistically Binding (eSSB) Hash Functions

<span id="page-15-1"></span>**Definition 3.1** (eSSB Hash Family). An  $S=S(\kappa)$ -hiding extractable somewhere statistically binding (eSSB) hash family is a hash family with local opening (Gen, Hash, Open, Verify), with the following changes:

•  $\operatorname{Gen}(1^{\kappa},L,i)$  takes as additional input an index  $i\in[L]$  and outputs a hash key  $\operatorname{hk}\in\{0,1\}^{\ell_{\operatorname{hk}}}$  as well as a trapdoor  $\operatorname{td}\in\{0,1\}^{\ell_{\operatorname{td}}}$ ,

An eSSB hash family also has an additional PPT algorithm Invert.

• Invert(td, rt) takes as input a trapdoor td  $\in \{0,1\}^{\ell_{td}}$  and a hash value rt  $\in \{0,1\}^{\ell_{hash}}$ , and outputs a value  $u \in \{0,1,\bot\}$ .

These algorithms should satisfy the following properties:

• S-Index Hiding: For any poly $(S(\kappa))$ -size adversary  $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$  there exists a negligible function  $\mu$  such that for any  $L \leq 2^{\kappa}$ ,

$$\Pr\left[b=b' \middle| \begin{array}{c} i_0,i_1,\mathsf{state} \leftarrow \mathcal{A}_1(1^\kappa) \\ b \overset{\$}{\leftarrow} \{0,1\} \\ (\mathsf{hk},\mathsf{td}) \leftarrow \mathsf{Gen}(1^\kappa,L,i_b) \\ b' \leftarrow \mathcal{A}_2(\mathsf{hk},\mathsf{state}) \end{array} \right] = \frac{1}{2} + \mu(S(\kappa)).$$

• Correctness of Inversion: For any  $\kappa \in \mathbb{N}$ ,  $L \leq 2^{\kappa}$ , and any  $i \in [L]$  and  $x \in \{0,1\}^{L}$ ,

$$\Pr[\mathsf{Invert}(\mathsf{td},\mathsf{Hash}(\mathsf{hk},x)) = x_i] = 1,$$

where the probability is over  $(hk, td) \leftarrow Gen(1^{\kappa}, L, i)$ .

<span id="page-16-2"></span> $\bullet$  Somewhere Statistically Binding: For any  $\kappa\in\mathbb{N}$ ,  $L\leq 2^{\kappa}$ ,  $i\in[L]$  and  $\mathrm{rt}\in\{0,1\}^{\ell_{\mathsf{hash}}}$ ,

$$\Pr[\exists (u, \mathsf{o}) \quad \textit{s.t.} \quad u \neq \mathsf{Invert}(\mathsf{td}, \mathsf{rt}) \quad \land \quad \mathsf{Verify}(\mathsf{hk}, \mathsf{rt}, i, u, \mathsf{o}) = 1] = 0,$$

where the probability is over  $(hk, td) \leftarrow Gen(1^{\kappa}, L, i)$ .

Remark 3.2. We note that our definition of somewhere statistically binding is different and slightly stronger than the original notion given in [HW15], which states that for any  $\kappa \in \mathbb{N}$ ,  $L \in \mathbb{N}$ ,  $i \in [L]$  and  $\mathsf{rt} \in \{0,1\}^{\ell_{\mathsf{hash}}}$ ,

$$\Pr[\exists \ (u, \mathsf{o}, \mathsf{o'}) \quad \textit{s.t.} \quad u \neq u' \quad \land \quad \mathsf{Verify}(\mathsf{hk}, \mathsf{rt}, i, u, \mathsf{o}) = \mathsf{Verify}(\mathsf{hk}, \mathsf{rt}, i, u', \mathsf{o'}) = 1] = 0,$$

where the probability is over  $hk \leftarrow Gen(1^\kappa, L, i)$ . The difference is that our definition permits "invalid" hash values for which Invert outputs  $\bot$ , and we require that such hash values have no valid openings. The [HW15] definition simply requires that there is at most one valid opening for every hash value. This distinction, however, is not crucial to the rest of our paper.

Hubáček and Wichs constructed SSB hash functions assuming the existence of a leveled homomorphic encryption scheme, and their construction is an extractable SSB hash function as well. We state the formal theorem below.

<span id="page-16-1"></span>Theorem 3.3 ([HW15]). Assuming the sub-exponential hardness of the learning with errors (LWE) problem, there exists a  $2^{\kappa^{\epsilon}}$ -hiding eSSB hash family for some  $\epsilon > 0$ . The  $2^{\kappa^{\epsilon}}$ -hiding is via a  $2^{\kappa^{\epsilon}}$ -straight-line reduction from the  $2^{\kappa^{\epsilon}}$ -hardness of LWE (see Definition 2.2).

## <span id="page-16-0"></span>3.2 Multi-Extractable SSB (meSSB) Hash Functions

**Definition 3.4.** An  $S=S(\kappa)$ -hiding multi-extractable somewhere statistically binding (meSSB) hash family is a hash family with local opening (Gen, Hash, Open, Verify), where

•  $\mathsf{Gen}(1^\kappa, L, \ell, I)$  takes as additional input  $\ell$  locations  $I = (i_1, \dots, i_\ell) \in [L]^\ell$  and outputs a hash key  $\mathsf{hk} \in \{0, 1\}^{\ell_\mathsf{hk}}$  as well as a trapdoor  $\mathsf{td} = (\mathsf{td}_1, \dots, \mathsf{td}_\ell) \in \{0, 1\}^{\ell_\mathsf{\ell} \ell_\mathsf{td}}$ ,

along with an additional PPT algorithm Invert which works as follows.

• Invert $(J, \{\operatorname{td}_j\}_{j\in J}, \operatorname{rt})$  takes as input a subset  $J\subseteq [\ell]$  of indices as well as a partial trapdoor  $\{\operatorname{td}_j\}_{j\in J}$  and a hash value  $\operatorname{rt}\in \{0,1\}^{\ell_{\mathsf{hash}}}$ , and outputs  $u\in \{0,1,\bot\}^{|J|}$ .

When no subset J is provided, Invert(td,rt) takes as input a full trapdoor  $\mathsf{td} \in \{0,1\}^{\ell \cdot \ell_\mathsf{td}}$  and a hash value  $\mathsf{rt} \in \{0,1\}^{\ell_\mathsf{hash}}$  and outputs  $u \in \{0,1,\bot\}^{\ell}$ .

These algorithms should satisfy the following properties:

• S-Index Hiding: For any  $poly(S(\kappa))$ -size adversary  $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$ , there exists a negligible function  $\mu$  such that for any  $L \leq 2^{\kappa}$ ,

$$\Pr\left[b=b' \middle| \begin{matrix} I^0 := (i_1^0,\dots,i_\ell^0), I^1 := (i_1^1,\dots,i_\ell^1), \mathsf{state} \leftarrow \mathcal{A}_1(1^\kappa) \\ b \overset{\$}{\leftarrow} \{0,1\} \\ (\mathsf{hk},\mathsf{td}^b) \leftarrow \mathsf{Gen}(1^\kappa,L,\ell,I^b) \\ b' \leftarrow \mathcal{A}_2(\mathsf{hk},\{\mathsf{td}^b_j\}_{i_j^0=i_j^1},\mathsf{state}) \end{matrix}\right] = \frac{1}{2} + \mu(S(\kappa)).$$

In words, index-hiding requires that even given the trapdoor information for the overlap of the two ordered sets  $I^0=(i^0_1,\ldots,i^0_\ell)$  and  $I^1=(i^1_1,\ldots,i^1_\ell)$ , the adversary still cannot distinguish whether hk is statistically binding on  $I^0$  or  $I^1$ .

• Correctness of Inversion: For any  $\kappa \in \mathbb{N}$ ,  $L \leq 2^{\kappa}$ , and any  $I \in [L]^{\ell}$ ,  $J \subseteq [\ell]$ , and  $x \in \{0,1\}^{L}$ ,

$$\Pr[\mathsf{Invert}(J, \{\mathsf{td}_j\}_{j \in J}, \mathsf{Hash}(\mathsf{hk}, x)) = \{x_{i_j}\}_{j \in J}] = 1,$$

where the probability is over  $(hk, td) \leftarrow Gen(1^{\kappa}, L, \ell, I)$ .

• Somewhere Statistically Binding: For any  $\kappa \in \mathbb{N}$ ,  $L \leq 2^{\kappa}$ ,  $I \in [L]^{\ell}$ ,  $i \in I$  and  $\mathsf{rt} \in \{0,1\}^{\ell_{\mathsf{hash}}}$ ,

$$\Pr[\exists \ (u, \mathsf{o}) \ \textit{s.t.} \ u \neq \mathsf{Invert}((i), \{\mathsf{td}_i\}, \mathsf{rt}) \quad \land \quad \mathsf{Verify}(\mathsf{hk}, \mathsf{rt}, i, u, \mathsf{o}) = 1] = 0,$$

where the probability is over  $(hk, td) \leftarrow Gen(1^{\kappa}, L, \ell, I)$ .

Multi-extractable SSB (meSSB) hash families can be constructed from extractable SSB (eSSB) families by invoking many independent copies. The formal construction is given in Figure 3.

<span id="page-17-0"></span>**Lemma 3.5.** When the number of statistically bound locations  $\ell$  is at most poly(S), the hash family  $\mathcal{H}_{meSSB}$  defined in Figure 3 is an S-hiding multi-extractable SSB hash family. Furthermore, its S-hiding is S-straight line reducible from the S-hiding of the underlying eSSB hash family. It also holds that

 $\ell_{\text{meSSB},\text{hk}} = \ell \cdot \ell_{\text{eSSB},\text{hk}}, \ \ell_{\text{meSSB},\text{hash}} = \ell \cdot \ell_{\text{meSSB},\text{hash}}, \ \ell_{\text{meSSB},\text{td}} = \ell \cdot \ell_{\text{eSSB},\text{td}}, \ and \ \ell_{\text{meSSB},\text{o}} = \ell \cdot \ell_{\text{meSSB},\text{o}}$  where  $\ell_{\text{meSSB},\text{hk}}, \ell_{\text{meSSB},\text{hash}}, \ell_{\text{meSSB},\text{td}}, \ell_{\text{meSSB},\text{o}} \ are \ the \ parameters \ associated \ with \ \mathcal{H}_{\text{meSSB}} \ and$   $\ell_{\text{eSSB},\text{hk}}, \ell_{\text{eSSB},\text{hash}}, \ell_{\text{eSSB},\text{td}}, \ell_{\text{eSSB},\text{o}} \ are \ the \ parameters \ associated \ with \ \mathcal{H}_{\text{eSSB}}.$ 

*Proof.* The correctness of inversion and  $\ell$ -somewhere statistically binding properties follow straightforwardly from the corresponding properties of the underlying eSSB hash family (Definition 3.1), so we focus on the S-index hiding property. In particular, we present a straight-line reduction from the S-hiding of the underlying eSSB hash family to the S-hiding of the meSSB hash family.

Suppose that there were a size-poly(S) algorithm  $\mathcal{A}=(\mathcal{A}_1,\mathcal{A}_2)$  such that for  $(i_1^0,\ldots,i_\ell^0),(i_1^1,\ldots,i_\ell^1)$ , state  $\leftarrow \mathcal{A}_1(1^\kappa)$ ,  $\mathcal{A}_2(\cdot,\text{state})$  can distinguish between  $\text{hk}_{\text{meSSB}}$  generated on index locations  $\{i_j^0\}_{j\in[\ell]}$  and  $\{i_j^1\}_{j\in[\ell]}$  with probability  $\delta(S)$ , where  $\delta$  is a non-negligible function, given partial trapdoor information  $\text{td}_{\text{meSSB}}|_{i^0\cap i^1}$ . Fix  $(i_1^0,\ldots,i_\ell^0),(i_1^1,\ldots,i_\ell^1)$  to be the output of  $\mathcal{A}_1$  for which  $\mathcal{A}_2$  has the greatest distinguishing advantage, which is at least  $\delta(S)$ . By a hybrid argument, there is some index  $j^* \not\in i^0 \cap i^1$  for which  $\mathcal{A}_2(\cdot,\text{state})$  can distinguish between  $\text{hk}_{\text{meSSB}}$  generated on indices  $(i_1^0,\ldots,i_{j^*-1}^0,i_{j^*}^1,i_{j^*+1}^1,\ldots,i_\ell)$  and  $(i_1^0,\ldots,i_{j^*-1}^0,i_{j^*}^0,i_{j^*+1}^1,\ldots,i^\ell)$  with probability  $\geq \delta(S)/\ell$ . Then, to break the S-hiding of the eSSB hash family, an adversary can distinguish between  $\text{hk}_{\text{eSSB}}^*$  generated by  $\text{Gen}_{\text{eSSB}}(1^\kappa,L,i_{j^*}^0)$  and  $\text{Gen}_{\text{eSSB}}(1^\kappa,L,i_{j^*}^1)$  by generating  $(\text{hk}_{\text{eSSB},j},\text{td}_{\text{eSSB},j})$   $\leftarrow \text{Gen}_{\text{eSSB}}(1^\kappa,L,i_j^0)$  for  $j\in[j^*-1]\cup[j^*+1,\ell]$ , where b(j)=1 if  $j>j^*$  and b(j)=0 if  $j<j^*$ . Then, she runs  $\mathcal{A}_2(\cdot,\text{state})$  on the meSSB hash key  $(\text{hk}_{\text{eSSB},1},\ldots,\text{hk}_{\text{eSSB},j^*-1},\text{hk}_{\text{eSSB}}^0,\text{hk}_{\text{eSSB},j^*+1},\ldots,\text{hk}_{\text{eSSB},\ell}^0)$  and outputs  $\mathcal{A}_2(\cdot,\text{state})$ 's output. This has a distinguishing advantage of  $\geq \delta(S)/\ell$ , which is non-negligible in S.

Finally, observe that this reduction is straight-line.

### An meSSB Hash Family

Let HeSSB = (GeneSSB, HasheSSB, OpeneSSB, VerifyeSSB, InverteSSB) be an S-hiding eSSB hash family. The meSSB hash family

$$\mathcal{H}_{\mathsf{meSSB}} = (\mathsf{Gen}_{\mathsf{meSSB}}, \mathsf{Hash}_{\mathsf{meSSB}}, \mathsf{Open}_{\mathsf{meSSB}}, \mathsf{Verify}_{\mathsf{meSSB}}, \mathsf{Invert}_{\mathsf{meSSB}}),$$

is defined as follows:

• GenmeSSB(1<sup>κ</sup> , L, `, I := (i1, . . . , i`)) samples a pair (hkeSSB,j ,tdeSSB,j ) ← GeneSSB(1<sup>κ</sup> , L, i<sup>j</sup> ) for every j ∈ [`]. It outputs hkmeSSB = (hkeSSB,1, . . . , hkeSSB,`) and

$$\mathsf{td}_{\mathsf{meSSB}} = \big((i_1, \mathsf{td}_{\mathsf{eSSB}, 1}), \dots, (i_\ell, \mathsf{td}_{\mathsf{eSSB}, \ell})\big)$$
 .

- HashmeSSB(hkmeSSB, x) takes as input a hash key hkmeSSB = (hkeSSB,1, . . . , hkeSSB,`) and an input x ∈ {0, 1} <sup>L</sup> and outputs rt = (rt1, . . . ,rt`), where rt<sup>j</sup> = HasheSSB(hkeSSB,j , x) for every j ∈ [`].
- OpenmeSSB(hkmeSSB, x, k) takes as input a hash key hkmeSSB = (hkeSSB,1, . . . , hkeSSB,`), x ∈ {0, 1} L, and an index k ∈ [L], and outputs the opening o = (o1, . . . , o`), where o<sup>j</sup> ← OpeneSSB(hkeSSB,j , x, k).
- VerifymeSSB(hkmeSSB,rt, k, u, o) takes as input a hash key hkmeSSB = (hkeSSB,1, . . . , hkeSSB,`), rt = (rt1, . . . ,rt`), k ∈ [L], u ∈ {0, 1}, and an opening o = (o1, . . . , o`), and outputs 1 if and only if VerifyeSSB(hkeSSB,j ,rt<sup>j</sup> , k, u, o<sup>j</sup> ) = 1 ∀j ∈ [`].
- InvertmeSSB(tdmeSSB,rt) takes as input the trapdoor tdmeSSB = (tdeSSB,1, . . . ,tdeSSB,`) and rt = (rt1, . . . ,rt`) and outputs the ` values (InverteSSB(tdeSSB,1,rt1), . . . , InverteSSB(tdeSSB,`,rt`)). InvertmeSSB(J, {tdmeSSB,j}j∈<sup>J</sup> ,rt) proceeds similarly, taking as input J ⊆ [`], the partial trapdoor {tdmeSSB,j}j∈<sup>J</sup> and rt = (rt1, . . . ,rt`) and outputs the |J| values

<span id="page-18-1"></span>
$$\left\{\mathsf{Invert}_{\mathsf{eSSB}}(\mathsf{td}_{\mathsf{eSSB},j},\mathsf{rt}_j)\right\}_{j\in J}\,.$$

Figure 3: The meSSB Hash Family (GenmeSSB, HashmeSSB, OpenmeSSB, VerifymeSSB, InvertmeSSB)

### <span id="page-18-0"></span>3.3 The BMW Protocol with meSSB Hash Families

Recall that the BMW heuristic is a two message succinct argument, where the verifier queries a PCP via a PCP query consisting of ` locations by sending ` parallel independent PIR queries to the prover. The prover computes, under the PIR, the ` answers and sends them back to the verifier. The verifier then reconstructs the ` answers and checks them via the PCP verification algorithm.

We note that a eSSB hash family functions as a PIR scheme, as follows:

- Query(1<sup>κ</sup> , L, q) calls (hkeSSB,tdeSSB) ← GeneSSB(1<sup>κ</sup> , L, q) and outputs (ˆq,td), where qˆ = hkeSSB and td = tdeSSB.
- Answer(ˆq, π) takes as input qˆ = hkeSSB and π ∈ {0, 1} <sup>L</sup> and produces aˆ = rt = HasheSSB(hkeSSB, π).
- Reconstruct(td, aˆ) takes as input td = tdeSSB and aˆ = rt and outputs InverteSSB(tdeSSB,rt).

Thus, we can run the BMW heuristic with eSSB hash functions in place of the PIRs. In fact, the notion of these  $\ell$  parallel eSSB hash functions is captured by our notion of a meSSB hash function, and thus we can run the BMW heuristic with a single meSSB hash function (binding on the  $\ell$  locations of a PCP query) instead of the  $\ell$  parallel PIR queries. Indeed, as we formally state below, the BMW heuristic is sound when instantiated with a meSSB hash family and a computationally non-signaling PCP.

Let  $(Gen_{meSSB}, Hash_{meSSB}, Open_{meSSB}, Verify_{meSSB}, Open_{meSSB})$  be a meSSB hash family. On input  $1^{\kappa}$  and x, the 2 message protocol  $(\mathcal{P}_{BMW}, \mathcal{V}_{BMW})$  proceeds as follows:

- Verifier:  $\mathcal{V}_{\mathsf{BMW}}$  computes  $(q_1,\ldots,q_\ell) \leftarrow \mathcal{Q}_{\mathsf{PCP}}(1^\kappa)$ . He computes  $(\mathsf{hk}_{\mathsf{meSSB}},\mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa,L,(q_1,\ldots,q_\ell))$  and sends  $\mathsf{hk}_{\mathsf{meSSB}}$  to the prover.
- Prover:  $\mathcal{P}_{\mathsf{BMW}}$  computes the PCP string  $\pi = \Pi(x)$ , and sends x and  $\mathsf{rt} \leftarrow \mathsf{Hash}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi)$  to the verifier.
- Verdict:  $\mathcal{V}_{\mathsf{BMW}}$  computes  $(a_1,\ldots,a_\ell) \leftarrow \mathsf{Invert}_{\mathsf{meSSB}}([\ell],\mathsf{td}_{\mathsf{meSSB}},\mathsf{rt})$  and accepts if and only if  $\mathcal{V}_{\mathsf{PCP}}(x,(q_1,\ldots,q_\ell),(a_1,\ldots,a_\ell)) = 1.$

Figure 4: BMW Heuristic with a meSSB Hash Function

<span id="page-19-0"></span>**Theorem 3.6.** Let  $(\Pi, \mathcal{Q}_{\mathsf{nsPCP}}, \mathcal{V}_{\mathsf{nsPCP}})$  be a PCP for a language  $\mathcal{L}$  with adaptive  $\Omega(n)$ -computational non-signaling soundness and locality  $\ell$ . Assume that the meSSB hash family is  $\Omega'$ -hiding, where  $\Omega' = \Omega'(\kappa)$  is such that  $\Omega'(\kappa) = \Omega(n)$  and  $2^{-\kappa} = \operatorname{negl}(\Omega')$ . Then, for any  $\operatorname{poly}(\Omega'(\kappa))$ -size cheating prover  $\mathcal{P}^*$ , there is a negligible function  $\mu$  such that

$$\Pr\left[\mathcal{V}_{\mathsf{BMW}}(x,\mathsf{rt},\mathsf{td}_{\mathsf{meSSB}},(q_1,\ldots,q_\ell))=1 \ \land \ x \notin \mathcal{L}\right] \leq \mu(\Omega'),$$

where  $(x, \mathsf{rt}) \leftarrow \mathcal{P}^*(\mathsf{hk_{meSSB}})$  and where the probability is over  $(q_1, \dots, q_\ell) \leftarrow Q_{\mathsf{PCP}}(1^\kappa)$  and  $(\mathsf{hk_{meSSB}}, \mathsf{td_{meSSB}}) \leftarrow \mathsf{Gen_{meSSB}}(1^k, L, (q_1, \dots, q_\ell))$ . In other words,

$$\Pr \left[ \begin{aligned} \mathcal{V}_{\mathsf{nsPCP}}(x,Q,\mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}},\mathsf{rt})) &= 1 \ \land \ x \notin \mathcal{L} \left| (\mathsf{hk}_{\mathsf{meSSB}},\mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa,L,Q) \atop (x,\mathsf{rt}) \leftarrow \mathcal{P}^*(\mathsf{hk}_{\mathsf{meSSB}}) \right| \\ &= \operatorname{negl}(\Omega'). \end{aligned} \right. \tag{1}$$

Moreover, this is proven via a  $\Omega'$ -straight-line reduction (Definition 2.2).

For the sake of completeness, we prove Theorem 3.6 in Appendix A.

### <span id="page-20-3"></span><span id="page-20-0"></span>4 Somewhere Statistically Sound Interactive Arguments

#### <span id="page-20-1"></span>4.1 Defining SSS Arguments

Let  $\kappa$  denote a security parameter.

**Definition 4.1.** An interactive argument  $(\mathcal{P}, \mathcal{V})(1^{\kappa})$  for a language  $\mathcal{L} = \{\mathcal{L}_n\}_{n \in \mathbb{N}}$  is statistically sound if for every (potentially computationally unbounded) cheating prover  $\mathcal{P}^*$  there exists a negligible function  $\mu$  such that for every  $x \notin \mathcal{L}$ , the soundness error is negligible. That is,

$$\Pr[(\mathcal{P}^*, \mathcal{V})(1^{\kappa}, x) = 1] \le \mu(\kappa).$$

We will sometimes parameterize the soundness error and will call a protocol  $\theta$ -statistically sound if its soundness error is at most  $\theta(\kappa)$ .

<span id="page-20-2"></span>**Definition 4.2.** An interactive argument  $(\mathcal{P}, \mathcal{V})(1^{\kappa})$  for a language  $\mathcal{L} = \{\mathcal{L}_n\}_{n \in \mathbb{N}}$  is  $\theta = \theta(\kappa)$ somewhere statistically sound (SSS) with respect to a  $\theta$ -decisional complexity assumption A if
for every first verifier message  $\beta_1$ , there exists a second verifier message  $T(\beta_1)$  such that:

• (Adaptive)  $\theta$ -Somewhere Statistically Soundness: For every  $poly(\theta)$ -size (cheating) prover  $\mathcal{P}^*$  that generates an instance x, conditioned on the first three messages being  $(\beta_1, \mathcal{P}^*(\beta_1), T(\beta_1))$ , the remaining protocol is  $\theta$ -statistically sound with overwhelming probability  $1 - \text{negl}(\theta)$  over  $\beta_1$ , assuming A.

Moreover, this condition holds in a  $\theta$ -straight-line manner; i.e., there is a black box reduction  $\mathcal{R}$  such that  $\mathcal{R}$ , given oracle access to a cheating prover  $\mathcal{P}^*$  that gives x for which the protocol beginning with  $(\beta_1, \mathcal{P}^*(\beta_1), T(\beta_1))$  is not  $\theta$ -statistically sound with overwhelming probability  $1 - \operatorname{negl}(\theta)$ , simulates the protocol with the prover by sending a message for every round once (without rewinding), where the messages for the first two verifier rounds are  $\beta_1$  and  $T(\beta_1)$ , and uses the resulting transcript and instance to break the underlying assumption A.

•  $\theta$ -Computational Indistinguishability: For any  $poly(\theta)$ -size distinguisher  $\mathcal{D}$ ,

$$\left| \Pr_{\beta_1} [\mathcal{D}(\beta_1, T(\beta_1)) = 1] - \Pr_{\beta_1, \beta_2} [\mathcal{D}(\beta_1, \beta_2) = 1] \right| \le \operatorname{negl}(\theta).$$

Furthermore, this indistinguishability is  $\theta$ -straight line, with respect to assumption A.

We remark that this is a strong definition: our cheating prover proceeds in two stages, a stage-1  $\mathcal{P}_1^*$  which is computationally bounded and produces the instance and the second message; and a stage-2  $\mathcal{P}_2^*$  who produces the rest of the transcript, and has no computational limitations. How could one possibly use a cheating prover  $(\mathcal{P}_1^*, \mathcal{P}_2^*)$  to break a computational assumption when  $\mathcal{P}_2^*$  is unbounded? While this seems mysterious at first sight, we remark that similar situations arise in other places, e.g., in the proof of the [KRR14] protocol. Indeed, we will use similar ideas in our reduction.

#### <span id="page-21-0"></span>4.2 SSS implies Straight-Line Soundness

<span id="page-21-3"></span>Theorem 4.3. Any θ-SSS interactive argument (P, V) w.r.t. a θ-decisional complexity assumption A is θ-straight-line sound.

Proof. To prove straight-line soundness, we will define a straight-line reduction from the adaptie θ-somewhere statistically sound and θ-computational indistinguishability assumptions to the θsoundness of (P, V). Then, combining with the fact that there is a straight-line reduction from some θ-decisional complexity assumption A to the adaptive θ-somewhere statistically sound and θ-computational indistinguishability properties, we obtain that there is a θ-straight-line reduction from A to the adaptive θ-soundness of (P, V).

Suppose that there is a poly(θ)-size cheating prover P ∗ such that Pr[(P ∗ , V)(1<sup>κ</sup> , x) = 1 : x ← P ∗ (1<sup>κ</sup> )] = δ(θ), where δ is a non-negligible function. Now, given (β1, β2), in which either β<sup>2</sup> = T(β1) or β<sup>2</sup> is random, reduction R simulates an interaction of V with P <sup>∗</sup> using the first two verifier messages β<sup>1</sup> and β2. If the resulting transcript for instance x produced by P ∗ is accepting, R outputs 1. Otherwise, it outputs 0.

Note that

$$\Pr_{\beta_1,\beta_2}[(\mathcal{P}^*,\mathcal{V})(1^\kappa,x)=1:x\leftarrow\mathcal{P}^*(1^\kappa)]=\delta(\theta),$$

so the distinguishing advantage of the reduction is

$$\delta(\theta) - \Pr_{\beta_1}[(\mathcal{P}^*, \mathcal{V})(1^{\kappa}, x) = 1 \mid x \leftarrow \mathcal{P}^*(1^{\kappa}), \beta_2 = T(\beta_1)],$$

which under the θ-somewhere statistically sound assumption is δ(θ) − negl(θ), which is nonnegligible in θ. This means that the θ-somewhere statistically sound and θ-computationally indistinguishability properties cannot simultaneously hold.

### <span id="page-21-1"></span>4.3 SSS implies Post-Quantum Soundness

Finally, we prove that the importance of a θ-straight-line sound argument is that if the underlying θ-decisional complexity assumption is θ-post-quantum secure, then the argument is sound against poly(θ)-size quantum provers, with overwhelming probability in θ.

<span id="page-21-2"></span>Theorem 4.4. Any argument (P, V) that is θ-straight-line sound w.r.t. a θ-decisional complexity assumption A, is also post-quantum sound assuming A holds w.r.t. quantum adversaries.

Proof. Fix any poly(θ)-size cheating quantum prover P ∗ that for infinitely many κ ∈ N, produces a rejecting instance and convinces V of this rejecting instance with probability 1/poly(θ(κ)). By the θ-straight-line soundness, there exists a PPT black-box reduction R that given oracle access to any classical cheating prover P ∗∗ that breaks soundness with probability 1/poly(θ), interacts with P ∗∗ once (without rewinding) by sending P ∗∗ a single message for each round, and using the transcript and instance obtained, breaks assumption A.

We next argue that R successfully breaks A even given oracle access to the quantum adversary P ∗ . This follows from the following observations. First, observe that R interacts with P <sup>∗</sup> using completely classical messages. Secondly, P ∗ can be simulated exactly by an unbounded classical adversary  $\mathcal{P}^{**}$ , which therefore also generates an accepting transcript with probability  $1/\text{poly}(\theta)$ . Finally, since the reduction is straight-line, it cannot distinguish between having oracle access to  $\mathcal{P}^*$  and having oracle access to  $\mathcal{P}^{**}$ . Put together, since the reduction with oracle access to  $\mathcal{P}^{**}$  breaks A, it also breaks A given (non-rewinding) oracle access to  $\mathcal{P}^*$ .

## <span id="page-22-0"></span>5 Kilian's Protocol is Somewhere Statistically Sound

We instantiate Kilian's protocol with two ingredients: an adaptive  $\Omega(n)$ -computational non-signaling PCP  $(\Pi, \mathcal{Q}_{\mathsf{nsPCP}}, \mathcal{V}_{\mathsf{nsPCP}})$  for a language  $\mathcal{L}$ , and a meSSB hash family  $(\mathsf{Gen}_{\mathsf{meSSB}}, \mathsf{Hash}_{\mathsf{meSSB}}, \mathsf{Open}_{\mathsf{meSSB}}, \mathsf{Verify}_{\mathsf{meSSB}}, \mathsf{Invert}_{\mathsf{meSSB}})$ . The resulting protocol is described in Figure 5.

### Kilian's protocol with a non-signaling PCP and an meSSB hash family

Let  $\epsilon \in (0,1)$  be a small constant, and let  $\kappa = \kappa(n) = (\log \Omega(n))^{1/\epsilon}$ . On input x, the 4-message protocol  $(\mathcal{P}_{\mathsf{nsKilian}}, \mathcal{V}_{\mathsf{nsKilian}})$  proceeds as follows.

- First verifier's message:  $\mathcal{V}_{\text{nsKilian}}$  samples  $Q \leftarrow \mathcal{Q}_{\text{nsPCP}}(1^{\kappa})$  and  $(\text{hk}_{\text{meSSB}}, \text{td}_{\text{meSSB}}) \leftarrow \text{Gen}_{\text{meSSB}}(1^{\kappa}, L, Q)$ , and sends  $\text{hk}_{\text{meSSB}}$  to the prover.
- First prover's meessage:  $\mathcal{P}_{\mathsf{nsKilian}}$  computes the PCP proof  $\pi = \Pi(x)$  and its hash value rt =  $\mathsf{Hash}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi)$ . It sends rt to the verifier.
- Second verifier's message:  $\mathcal{V}_{\mathsf{nsKilian}}$  computes a set of queries  $(q_1, \dots, q_\ell) \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^{\kappa})$ , and sends  $(q_1, \dots, q_\ell)$  to the prover.
- Second prover's message:  $\mathcal{P}_{\mathsf{nsKilian}}$  computes for every  $i \in [\ell]$  the opening  $\mathsf{o}_i = \mathsf{Open}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi, q_i)$ , and sends  $\{\pi_{q_i}, \mathsf{o}_i\}_{i \in [\ell]}$  to the verifier.
- Verdict:  $\mathcal{V}_{\mathsf{nsKilian}}$  accepts if and only if  $\mathcal{V}_{\mathsf{nsPCP}}(x, (q_1, \dots, q_\ell), (\pi_{q_1}, \dots, \pi_{q_\ell})) = 1$  and for every  $i \in [\ell]$ ,  $\mathsf{Verify}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt}, q_i, \pi_{q_i}, \mathsf{o}_i) = 1$ .

<span id="page-22-1"></span>Figure 5: The Protocol ( $\mathcal{P}_{nsKilian}, \mathcal{V}_{nsKilian}$ ) for  $\mathcal{L}$ 

With these ingredients, and setting  $\kappa$  to be  $(\log\Omega(n))^{1/\epsilon}$  such that  $2^{\kappa^\epsilon}=\Omega$ , the resulting Kilian's protocol is a  $2^{\kappa^\epsilon}$ -SSS argument assuming the meSSB hash family is  $2^{\kappa^\epsilon}$ -hiding, as we show below. Since  $2^{\kappa^\epsilon}=\Omega(n)$ , in an abuse of notation we say that the protocol is  $\Omega(n)$ -SSS.

<span id="page-22-2"></span>**Lemma 5.1.**  $(\mathcal{P}_{\mathsf{nsKilian}}, \mathcal{V}_{\mathsf{nsKilian}})$  is a  $\Omega$ -SSS interactive argument assuming the meSSB hash family is  $2^{\kappa^{\epsilon}}$ -hiding.

*Proof.* For  $(\mathsf{hk_{meSSB}}, \mathsf{td_{meSSB}}) \leftarrow \mathsf{Gen_{meSSB}}(1^\kappa, L, Q)$ , define  $T(\mathsf{hk_{meSSB}}) = Q$ . We will show that  $(\mathcal{P}_{\mathsf{nsKilian}}, \mathcal{V}_{\mathsf{nsKilian}})$  satisfies the properties in Definition 4.2. We will use the fact that  $2^{\kappa^\epsilon} = 2^{((\log \Omega)^{1/\epsilon})^\epsilon} = \Omega$ . In particular, a  $2^{\kappa^\epsilon}$ -hiding meSSB hash family is in fact  $\Omega(n)$ -hiding.

• Adaptive  $\Omega$ -Somewhere Statistically Sound: The adaptive  $\Omega$ -somewhere statistically

sound property of Definition 4.2<sup>10</sup> follows from the fact that for every  $poly(\Omega)$ -size  $\mathcal{P}^* = (\mathcal{P}_1^*, \mathcal{P}_2^*)$ ,

$$\begin{split} \Pr\left[ \begin{array}{c} x \not\in \mathcal{L} \ \land \ \exists \{a_j, \mathsf{o}_j\}_{j \in [\ell]} \\ \text{s.t. } \mathcal{V}_{\mathsf{nsPCP}}(x, Q, (a_1, \dots, a_\ell)) = 1 \\ \land \ \mathsf{Verify}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt}, q_j, a_j, \mathsf{o}_j) = 1 \ \forall j \in [\ell] \\ \\ \leq \Pr\left[ \begin{array}{c} \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 1 \\ \land \ x \not\in \mathcal{L} \\ \end{array} \right] \begin{pmatrix} \mathsf{o}_{\mathsf{k}} \mathsf{meSSB} \\ \mathsf{meSSB} \end{pmatrix} \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(\mathsf{l}^\kappa, L, Q) \\ (x, \mathsf{rt}, \mathsf{state}) \leftarrow \mathcal{P}_1^*(\mathsf{hk}_{\mathsf{meSSB}}) \\ (\mathsf{kk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(\mathsf{l}^\kappa, L, Q) \\ (x, \mathsf{rt}, \mathsf{state}) \leftarrow \mathcal{P}_1^*(\mathsf{hk}_{\mathsf{meSSB}}) \\ = \mathsf{negl}(\Omega), \end{split}$$

where the last equality follows from Theorem 3.6 and the fact that the meSSB hash family is  $2^{\kappa^{\epsilon}}$ -hiding (which is  $\Omega(n)$ -hiding, as argued above). Furthermore, Corollary 3.6 gives that the reduction from the  $2^{\kappa^{\epsilon}}$ -hiding of the meSSB hash family to the  $\Omega$ -somewhere statistical soundness is  $2^{\kappa^{\epsilon}}$ -straight-line.

• Computational Indistinguishability: In the formatted case, the pair  $(\beta_1, T(\beta_1))$  is a pair  $(\mathsf{hk}_{\mathsf{meSSB}}, Q)$  where  $Q \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa)$  and  $(\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q)$ . Meanwhile, in the random case, the pair  $(\beta_1, \beta_2)$  is a pair  $(\mathsf{hk}'_{\mathsf{meSSB}}, Q)$  where  $Q, Q' \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa)$  and  $(\mathsf{hk}'_{\mathsf{meSSB}}, \mathsf{td}'_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q')$ . The  $\Omega$ -indistinguishability of these two pairs follows from the  $\Omega(n)$ -index hiding property of the meSSB hash family via a  $2^{\kappa^\epsilon}$ -straight-line reduction: The reduction picks  $Q \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa)$  at random. Then, to distinguish between  $\mathsf{hk}_{\mathsf{meSSB}} \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q)$  and  $\mathsf{hk}_{\mathsf{meSSB}} \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q')$  for an independent  $Q' \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa)$ , it feeds the pair  $(Q, \mathsf{hk}_{\mathsf{meSSB}})$  to the distinguisher, and answers according to its response (without needing to use  $\{\mathsf{td}_{\mathsf{meSSB},j}\}_{Q_j=Q_j'}$ ).

It follows from Theorem 4.3 that our instantiation of Kilian's protocol is  $2^{\kappa^{\epsilon}}$ -straight-line sound.

Theorem 5.2. The protocol given in Figure 5 satisfies the following properties:

• Correctness: For any  $x \in \mathcal{L}$  and  $\epsilon > 0$ ,

$$\Pr[(\mathcal{P}_{\mathsf{nsKilian}}, \mathcal{V}_{\mathsf{nsKilian}})(x) = 1] = 1.$$

• Soundness: Assuming that the meSSB hash family is  $2^{\kappa^{\epsilon}}$ -hiding, the argument  $(\mathcal{P}^*_{\mathsf{nsKilian}}, \mathcal{V}^*_{\mathsf{nsKilian}})$  for  $\mathcal{L}$  is  $2^{\kappa^{\epsilon}}$ -straight-line adaptively sound. In particular, for any  $\mathsf{poly}(\Omega(n))$ -size cheating prover  $\mathcal{P}^*_{\mathsf{nsKilian}}$ ,

$$\Pr[(\mathcal{P}^*_{\mathsf{nsKilian}}, \mathcal{V}_{\mathsf{nsKilian}})(1^{\kappa}) = 1] = \operatorname{negl}(\Omega(n)).$$

<span id="page-23-0"></span><sup>&</sup>lt;sup>10</sup>In our case, with overwhelming probability over  $\beta_1$ , conditioned on the first three messages being  $(\beta_1, \mathcal{P}^*(\beta_1), T(\beta_1))$ , the remaining protocol is sound with probability 1.

Proof. Correctness is straightforward, and 2 κ -straight-line soundness follows immediately from Theorem [4.3](#page-21-3) and Lemma [5.1.](#page-22-2)

Recall that the eSSB hash family from Theorem [3.3](#page-16-1) is sub-exponentially straight-line hiding assuming the sub-exponential hardness of LWE. Using this particular eSSB hash family in the construction of the meSSB hash family given in Figure [3](#page-18-1) and using that the resulting meSSB hash family is 2 κ -straight-line reducible from the 2 κ -hiding of the underlying eSSB hash family, we obtain a meSSB hash family that is 2 κ -straight-line reducible from the sub-exponential hardness of LWE. Combining this with the adaptive computational non-signaling PCPs given in Theorems [2.7](#page-11-1) and [2.8,](#page-12-1) we obtain the following corollaries:

Corollary 5.3. For any poly(n) ≤ t ≤ exp(n), assuming the sub-exponential hardness of LWE, there is > 0 such that Kilian's protocol (PnsKilian, VnsKilian), instantiated with the adaptive t-computational non-signaling PCP for LU(t) from Theorem [2.7](#page-11-1) and the meSSB hash family from Figure [5](#page-22-1) with underlying eSSB hash family given in Theorem [3.3,](#page-16-1) is 2 κ -straight-line (adaptive) sound. In particular, assuming the sub-exponential quantum hardness of LWE, this protocol is (adaptive) post-quantum secure against size-poly(t) quantum provers, except with probability negligible in t.

Furthermore, the prover runs in time poly(t), the verifier runs in time n · polylog(t), and the communication complexity is polylog(t).

Proof. It remains to analyze the complexity of the protocol. The complexity claims follow from the following points:

- By Theorem [2.7,](#page-11-1) the size of the PCP proof is poly(t), so PnsKilian can compute the hash and openings in time poly(t).
- The size of a single eSSB hash and opening is poly(κ) = polylog(t), and the number of such eSSB hashes and openings is ` = κ · polylog(t) = polylog(t), for a total communication complexity of polylog(t).
- The verifier can check that all the answers and openings are consistent with rt in time polylog(t). He also runs VnsPCP, which takes time n · poly(`) = n · polylog(t), for a total verifier runtime of n · polylog(t).

Corollary 5.4. For any poly(n) ≤ t ≤ exp(n) and s = s(n) ≥ log t(n), assuming the subexponential hardness of LWE, there is > 0 such that Kilian's protocol (PnsKilian, VnsKilian), instantiated with the adaptive 2 s -computational non-signaling PCP for NLU(t, s) from Theorem [2.8](#page-12-1) and the meSSB hash family from Figure [5](#page-22-1) with underlying eSSB hash family given in Theorem [3.3,](#page-16-1) is 2 κ -straight-line (adaptively) sound. In particular, assuming the subexponential quantum hardness of LWE, this protocol is (adaptive) post-quantum secure against size-poly(2<sup>s</sup> ) (and thus poly(t)) quantum provers, except with probability negligible in 2 s .

Furthermore, the honest prover runs in time poly(t), the verifier runs in time n · poly(s), and the communication complexity is poly(s).

Proof. We analyze the complexity claims.

- By Theorem [2.8,](#page-12-1) the size of the PCP proof is poly(t), so PnsKilian can compute the hash and openings in time poly(t).
- The size of a single eSSB hash and opening is poly(κ) = polylog(2<sup>s</sup> ) = poly(s), and the number of such eSSB hashes and openings is ` = κ · poly(s) = poly(s), for a total communication complexity of poly(s).
- The verifier can check that all the answers and openings are consistent with rt in time poly(s). He also runs VnsPCP, which takes time n · poly(`) = n · poly(s), for a total verifier runtime of n · poly(s).

## <span id="page-25-0"></span>6 SNARG for Languages with Non-Signaling PCPs

In this section, we construct SNARGs for languages with a (computational) non-signaling PCP, assuming the existence of a SNARG for BatchNP. This includes LU(t) for every poly(n) ≤ t ≤ exp(n), and NLU(t, s) for poly(n) ≤ t ≤ exp(n) and s = s(n) ≥ log t(n).

We begin by defining BatchNP and SNARGs for BatchNP.

### <span id="page-25-1"></span>6.1 BatchNP

For an NP relation R with corresponding language L, define

$$\mathsf{R}^{\otimes N} = \{ ((x_1, \dots, x_N), (w_1, \dots, w_N)) : (x_i, w_i) \in \mathsf{R} \ \forall i \in [N] \ \land \ |x_1| = \dots = |x_N| \}$$

and

$$\mathsf{L}^{\otimes N} = \{ (x_1, \dots, x_N) \ : \ x_i \in \mathsf{L} \ \forall i \in [N] \ \land \ |x_1| = \dots = |x_N| \}.$$

The class BatchNP consists of languages L <sup>⊗</sup><sup>N</sup> for L ∈ NP.

#### <span id="page-25-2"></span>6.1.1 SNARGs for BatchNP

Our SNARG for L relies on the existence of a SNARG for BatchNP, which we define below. We will be interested in the case where N is much larger than m, the size of a single instance x<sup>i</sup> . We will consider two definitions. First, we consider a definition where the verifier is super-efficient (runs in time poly(m, log N)). Note that the size of a BatchNP instance is already N · m, so in this case we will consider only BatchNP instances that have succinct descriptions. Second, we will consider a definition where the verifier is efficient (but not necessarily super-efficient), i.e. runs in time poly(m, N), but the communication is succinct (size poly(m, log N)). In this setting, the verifier reads the full instance.

<span id="page-25-3"></span>To define SNARGs for BatchNP where the verifier is super-efficient, we first have to define succinct descriptions.

<span id="page-26-2"></span>**Definition 6.1.** (Succinct Description of a Tuple) A tuple  $S \in (\{0,1\}^m)^N$  of size N has a succinct description if there exists a short string  $\langle S \rangle \in \{0,1\}^{\text{poly}(m,\log N)}$  and a uniform PPT Turing machine B that on input  $\langle S \rangle$  and  $i \in [N]$ , outputs the i'th element of S.

For notation, we let  $B(\langle S \rangle)$  denote the set S, i.e.  $B(\langle S \rangle) = \{B(\langle S \rangle, i)\}_{i \in [N]}$ .

We next define SNARGs for BatchNP, both where the verifier reads the full BatchNP instance and where the instances have succinct descriptions.

<span id="page-26-1"></span>**Definition 6.2.** (SNARG for BatchNP (with Succinct Instances)) A SNARG for a language  $L^{\otimes N} \in BatchNP$  with corresponding relation  $R^{\otimes N}$  (where the instance has a succinct description) is a tuple of PPT algorithms (Setup<sub>L\inftyN</sub>,  $\mathcal{P}_{L\otimes N}$ ,  $\mathcal{V}_{L\otimes N}$ ) with the following syntax:

- Setup<sub>L⊗N</sub> $(1^{\lambda}, 1^m, N)$  takes as input a security parameter  $\lambda$  and NP instance size m in unary, as well as a batch size N (in binary), and outputs a common reference string crs.
- $\mathcal{P}_{\mathsf{L}\otimes N}(\mathsf{crs},X,W)$  takes as input a  $\mathsf{crs}\in\{0,1\}^{\mathrm{poly}(\lambda,m,\log N)}$ , an instance  $X=(x_1,\ldots,x_N)\in\{0,1\}^{N\times m}$ , and a witness  $W=(w_1,\ldots,w_N)$ , and outputs a short proof  $\sigma\in\{0,1\}^{\ell_{\mathsf{L}\otimes N}}$ , where  $\ell_{\mathsf{L}\otimes N}=\mathrm{poly}(\lambda,m,\log N)$ .
- $\mathcal{V}_{\mathsf{L}^{\otimes N}}(\mathsf{crs}, X, \sigma)$  (resp.  $\mathcal{V}_{\mathsf{L}^{\otimes N}}(\mathsf{crs}, \langle X \rangle, \sigma)$ ) takes as input the  $\mathsf{crs} \in \{0, 1\}^{\mathrm{poly}(\lambda, m, \log N)}$ ,  $X = (x_1, \dots, x_N) \in \{0, 1\}^{N \times m}$  (resp. a short description  $\langle X \rangle \in \{0, 1\}^{\mathrm{poly}(\lambda, m, \log N)}$  of the instance X), and  $\sigma \in \{0, 1\}^{\ell_{\mathsf{L}^{\otimes N}}}$ , and outputs 1 or 0 indicating accept or reject.

These algorithms should satisfy the following completeness property: If  $(X, W) \in \mathbb{R}^{\otimes N}$ , then

$$\Pr\left[ \mathcal{V}_{\mathsf{L}^{\otimes N}}(\mathsf{crs}, X, \sigma) = 1 \ \textit{(resp. } \mathcal{V}_{\mathsf{L}^{\otimes N}}(\mathsf{crs}, \langle X \rangle, \sigma) = 1 \right) \middle| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathsf{L}^{\otimes N}}(1^\lambda, 1^m, N) \\ \sigma \leftarrow \mathcal{P}_{\mathsf{L}^{\otimes N}}(\mathsf{crs}, X, W) \end{matrix} \right] = 1.$$

**Definition 6.3** (Σ-Soundness). A SNARG (Setup<sub>L⊗N</sub>,  $\mathcal{P}_{L⊗N}$ ,  $\mathcal{V}_{L⊗N}$ ) for  $\mathsf{L}^{\otimes N} \in \mathsf{BatchNP}$  is said to be Σ-sound if for every cheating prover  $\mathcal{P}_{\mathsf{L}^{\otimes N}}^*$  running in time  $\mathsf{poly}(\Sigma(\lambda, m, N))$ , there exists a negligible function  $\mu$  such that for any  $\lambda, m, N$  and  $X \notin \mathsf{L}^{\otimes N}$  where each instance is of size m,

$$\Pr\left[ \begin{array}{c|c} \mathcal{V}_{\mathsf{L}\otimes N}(\mathsf{crs},X,\sigma) = 1 & \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathsf{L}\otimes N}(1^{\lambda},1^{m},N) \\ (\mathit{resp.}\ \ \mathcal{V}_{\mathsf{L}\otimes N}(\mathsf{crs},\langle X\rangle,\sigma) = 1) & \sigma \leftarrow \mathcal{P}^*_{\mathsf{L}\otimes N}(\mathsf{crs}) \end{array} \right] = \operatorname{negl}(\Sigma(\lambda,m,N)).$$

**Theorem 6.4** ([CJJ21]). Assuming the sub-exponential hardness of LWE, there is some  $\epsilon > 0$  for which there exist  $2^{\lambda^{\epsilon}}$ -sound SNARGs for languages in BatchNP with succinct instances.

### <span id="page-26-0"></span>6.2 SNARG for Languages with a Non-Signaling PCP

Suppose we have an adaptive  $\Omega$ -computational non-signaling PCP  $(\Pi, \mathcal{Q}_{\mathsf{nsPCP}}, \mathcal{V}_{\mathsf{nsPCP}})$  that is verifiable via tests (Definition 2.5) for a language  $\mathcal{L}$ . Let L be the size of the PCP and  $\ell$  be the locality. Let N be the number of possible tests  $\zeta$  (see Theorem 2.7), and let  $\tau$  be the size of each test (where

we pad tests that are not long enough), so that each test ζ can be written as (ζ1, . . . , ζ<sup>τ</sup> ) with ζ<sup>i</sup> ∈ [L]. Let UnsPCP be the Turing machine that checks each test, as in Definition [2.5.](#page-11-0)

At a high level, our SNARG for L works as follows: The honest prover first runs the BMW protocol on an adaptive computational non-signaling PCP with a meSSB hash function to produce a short commitment rt to the entire PCP. She then provides a short proof via the BatchNP SNARG that all possible verifier tests have accepting answers and openings. This final task is precisely a BatchNP statement: the claim that a given verifier test has accepting answers and openings is an NP statement, with witness the answers and openings; now the claim that all possible verifier tests have accepting answers and openings is a BatchNP statement.

We define the BatchNP language we will be concerned with, as well as the succinct description of the instances. Fix an meSSB hash family

$$(\mathsf{Gen}_{\mathsf{meSSB}}, \mathsf{Hash}_{\mathsf{meSSB}}, \mathsf{Open}_{\mathsf{meSSB}}, \mathsf{Verify}_{\mathsf{meSSB}}, \mathsf{Invert}_{\mathsf{meSSB}})$$

(see Construction [3\)](#page-18-1).

Let R be the NP relation where (y, w) ∈ R if

$$1. \ y = (\zeta, x, \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt}) \in [L]^\tau \times \{0,1\}^n \times \{0,1\}^{\ell_{\mathsf{meSSB}}, \mathsf{hk}} \times \{0,1\}^{\ell_{\mathsf{meSSB}}, \mathsf{hash}};$$

$$2. \ w = ((u_1, \dots, u_\tau), (\mathbf{o}_1, \dots, \mathbf{o}_\tau)) \in \{0, 1\}^\tau \times \{0, 1\}^{\tau \cdot \ell_{\mathsf{meSSB,o}}};$$

3. 
$$\mathcal{U}_{\mathsf{nsPCP}}(x,\zeta,(u_1,\ldots,u_{\tau}))=1;$$
 and

$$\text{4. Verify}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}},\mathsf{rt},\zeta_i,u_i,\mathsf{o}_{\mathsf{meSSB},i}) = 1 \ \forall i \in [\tau].$$

Let M be the corresponding language. Notice that the size of an instance is

$$m = \tau \cdot \log L + n + \ell_{\text{meSSB,hk}} + \ell_{\text{meSSB,hash}}. \tag{2}$$

We are interested in the BatchNP language M⊗<sup>N</sup> .

Let B be a poly-time Turing machine that takes as input hY i, which is a succinct description of an element in M⊗<sup>N</sup> , and an index j ∈ [N], and outputs the j'th NP statement defined by hY i. More specifically, hY i = (x, hkmeSSB,rt), and B(hY i, j) = (ζ<sup>j</sup> ,hY i), where ζ<sup>j</sup> is the j'th possible test (enumerating them in some order). We let Y denote the M⊗<sup>N</sup> instance corresponding to hY i.

#### <span id="page-27-0"></span>6.2.1 SNARGs for L from SNARGs for BatchNP with Succinct Instances

We first construct SNARGs for L from SNARGs for BatchNP, assuming that the BatchNP SNARG verifier is super-efficient when the BatchNP instance admits a succinct description. This is indeed the case: our BatchNP instance is determined by the output of the hash on the PCP and thus can be described succinctly.

In what follows, let (SetupM⊗<sup>N</sup> ,PM⊗<sup>N</sup> , VM⊗<sup>N</sup> ) be a SNARG for M⊗<sup>N</sup> with succinct instances, as in Definition [6.2.](#page-26-1)

<span id="page-27-1"></span>Theorem 6.5. The algorithms (SetupL,PL, VL) defined in Figure [6](#page-28-0) satisfy the following properties:

#### SNARG for $\mathcal{L}$ from SNARG for BatchNP with Succinct Instances

For  $\epsilon>0$  and  $\Omega(\cdot)$ , define  $\kappa=(\log\Omega)^{1/\epsilon}$  and let  $\lambda$  be such that  $\Sigma(\lambda,m,N)=2^{\ell_{\mathsf{meSSB},\mathsf{hash}}}$ .

• Setup<sub> $\mathcal{L}$ </sub> $(1^{\kappa}, 1^{\lambda})$  takes as input  $\kappa$  and  $\lambda$  in unary. It samples

$$Q = (q_1, \dots, q_\ell) \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa), \text{ and } (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q) \ .$$

It also samples

$$\operatorname{crs}_{\mathcal{M}^{\otimes N}} \leftarrow \operatorname{Setup}_{\mathcal{M}^{\otimes N}}(1^{\lambda}, 1^{m}, N)$$
,

and outputs  $crs = (hk_{meSSB}, crs_{\mathcal{M}^{\otimes N}}).$ 

•  $\mathcal{P}_{\mathcal{L}}$  takes as input the crs =  $(\mathsf{hk}_{\mathsf{meSSB}},\mathsf{crs}_{\mathcal{M}^{\otimes N}})$  and an instance x. It computes

$$\pi \leftarrow \Pi(x) \text{ and } \mathsf{rt} = \mathsf{Hash}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi)$$
 .

It then computes  $\sigma_{\mathcal{M}^{\otimes N}} \leftarrow \mathcal{P}_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, Y, W)$ , where

$$Y = \{(\zeta_j, x, \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt})\}_{j \in [N]}$$

(i.e.  $\langle Y \rangle = (x, hk_{meSSB}, rt)$ ) and

$$W = \{((\pi_{\zeta_{i,1}}, \dots, \pi_{\zeta_{i,\tau}}), (o_{\zeta_{i,1}}, \dots, o_{\zeta_{i,\tau}}))\}_{i \in [N]},$$

where  $o_q = \mathsf{Open}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi, q)$ . It outputs  $\sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}})$ .

•  $\mathcal{V}_{\mathcal{L}}$  takes as input  $\operatorname{crs} = (\operatorname{hk}_{\operatorname{meSSB}}, \operatorname{crs}_{\mathcal{M}^{\otimes N}})$ , instance x, and  $\sigma = (\operatorname{rt}, \sigma_{\mathcal{M}^{\otimes N}})$ . It runs and outputs the result of  $\mathcal{V}_{\mathcal{M}^{\otimes N}}(\operatorname{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}})$ , where  $\langle Y \rangle = (x, \operatorname{hk}_{\operatorname{meSSB}}, \operatorname{rt})$ .

<span id="page-28-0"></span>Figure 6: SNARG (Setup,  $\mathcal{P}_{\mathcal{L}}, \mathcal{V}_{\mathcal{L}}$ )(x) for  $\mathcal{L}$ 

• Correctness: For every  $x \in \mathcal{L}$ ,

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma) = 1 \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ \sigma \leftarrow \mathcal{P}_{\mathcal{L}}(\mathsf{crs}, x) \end{matrix} \right| = 1.$$

- Soundness: Assuming that
  - the meSSB hash family is  $2^{\kappa^{\epsilon}}$ -hiding,
  - the PCP is adaptive  $n \leq \Omega = \Omega(n)$ -computational non-signaling and is verified via tests, and that there are  $N \leq \text{poly}(\Omega)$  possible tests,
  - the BatchNP SNARG is  $\Sigma$ -sound, such that  $\lambda$  (defined in Figure 6) is  $\leq \Omega$ ,

then for any  $\operatorname{poly}(\Omega)$ -size  $\mathcal{P}^*$ ,

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \\ x, \sigma \leftarrow \mathcal{P}_{\mathcal{L}}(\mathsf{crs}) \end{matrix} \right] = \mathrm{negl}(\Omega).$$

*Proof.* Correctness is straightforward. We now focus on proving soundness.

Suppose for the sake of contradiction that there is a  $\operatorname{poly}(\Omega)$ -size prover  $\mathcal{P}^*$  for which there is non-negligible  $\delta$  such that

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ x, \sigma \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{matrix} \right| = \delta(\Omega).$$

This is equal to

$$\begin{split} \delta(\Omega) &= \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 1 \\ \end{matrix} \right| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ + \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \\ \end{matrix} \right| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \leq \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 1 \\ \land \ x \not\in \mathcal{L} \\ \end{matrix} \right| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \\ + \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \\ \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \\ \end{aligned} \right| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \\ \cdot \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \\ \end{aligned} \right| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \end{aligned} \right].$$

By Theorem 3.6 and the fact that a  $2^{\kappa^{\epsilon}} = 2^{((\log \Omega)^{1/\epsilon})^{\epsilon}}$ -hiding meSSB hash family is  $\Omega(n)$ -hiding, the first term above is  $\operatorname{negl}(\Omega)$ . In the above and what follows, Q denotes the  $\ell$  locations the meSSB hash family are binding on (used to generate  $\operatorname{hk}_{\mathsf{meSSB}}$ ), and  $\operatorname{td}_{\mathsf{meSSB}}$  is the trapdoor generated alongside  $\operatorname{hk}_{\mathsf{meSSB}}$ .

Therefore, the above implies that there exists  $\delta'(\Omega) = \delta(\Omega) - \text{negl}(\Omega)$  such that

$$\begin{split} \delta'(\Omega) &\leq \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \ \middle| \ \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \ \middle| x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \end{aligned} \right] \\ &= \Pr \left[ \begin{array}{c} \mathcal{V}_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}})) = 1 \\ \land \ Y \not\in \mathcal{M}^{\otimes N} \ \middle| \ \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ \land \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \$$

where  $\langle Y \rangle$  denotes  $(x, \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt})$ , and the equality follows from the facts that  $\mathcal{V}_{\mathcal{L}}$  simply runs  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$ , and that  $\mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0$  implies that  $Y \not\in \mathcal{M}^{\otimes N}$ , since there is at least one test  $\zeta \subseteq Q$  for which  $\mathcal{U}_{\mathsf{nsPCP}}(\zeta, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})|_{\mathcal{E}}) = 0$ .

We will use  $\mathcal{P}^*$  to break the  $\Sigma$ -security of the  $\mathcal{M}^{\otimes N}$  SNARG as follows. By an averaging argument, there is some  $\mathsf{hk}^*_{\mathsf{meSSB}}$  for which  $\mathcal{P}^*(\mathsf{crs})$  outputs  $(x,\mathsf{rt},\sigma_{\mathcal{M}^{\otimes N}})$  with  $x \notin \mathcal{L}, Y \notin \mathcal{M}^{\otimes N}$ , and  $\mathcal{V}_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}\langle Y\rangle,\sigma_{\mathcal{M}^{\otimes N}})=1$  with probability  $\geq \delta'(\Omega)$  conditioned on  $\mathsf{crs}=(\mathsf{hk}^*_{\mathsf{meSSB}},\mathsf{crs}_{\mathcal{M}^{\otimes N}})$  for some  $\mathsf{crs}_{\mathcal{M}^{\otimes N}}$ . Furthermore, there is some  $x^*$  and  $\mathsf{rt}^*$  for which, with probability  $\geq \frac{\delta'(\Omega)}{2^{n+\ell_{\mathsf{meSSB}},\mathsf{hash}}}$ , this occurs and the x and x and x are equal to x and x. In particular, for x defined by x are equal to x and x, where x is the probability x, we have that x and x and x and x and x and x and x and x are equal to x.

$$\Pr \begin{bmatrix} \mathcal{V}_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y^* \rangle, \sigma_{\mathcal{M}^{\otimes N}})) = 1 \\ \wedge (x, \mathsf{rt}) = (x^*, \mathsf{rt}^*) \end{bmatrix} \begin{vmatrix} \mathsf{crs}_{\mathcal{M}^{\otimes N}} \leftarrow \mathsf{Setup}_{\mathcal{M}^{\otimes N}}(1^\lambda, 1^m, N) \\ & \mathsf{crs} := (\mathsf{hk}^*_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}) \\ x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{bmatrix} \\ \geq \frac{\delta'(\Omega)}{2^{n + \ell_{\mathsf{meSSB}}, \mathsf{hash}}} \geq \delta''(\Sigma(\lambda, m, N)),$$

where  $\delta''$  is a non-negligible function; such  $\delta''$  exists since we assumed that

$$\Sigma(\lambda, m, N) \geq 2^{\ell_{\mathsf{meSSB}}, \mathsf{hash}} \geq 2^{\mathrm{poly}(\kappa)} = 2^{\mathrm{polylog}(\Omega)} \geq \Omega \geq n.$$

We next construct a cheating prover  $\mathcal{P}^{**}$  for the  $\mathcal{M}^{\otimes N}$  SNARG that breaks the  $\Sigma$ -soundness condition w.r.t.  $Y^* \notin \mathcal{M}^{\otimes N}$ , as follows. The cheating prover  $\mathcal{P}^{**}$  takes as input  $\operatorname{crs}_{\mathcal{M}^{\otimes N}} \leftarrow \operatorname{Setup}_{\mathcal{M}^{\otimes N}}(1^\kappa, 1^m, N)$ , runs  $\mathcal{P}^*$  on inputs  $\operatorname{crs} = (\operatorname{hk}^*_{\mathsf{meSSB}}, \operatorname{crs}_{\mathcal{M}^{\otimes N}})$ , to get x and  $(\operatorname{rt}, \sigma_{\mathcal{M}^{\otimes N}})$ . When the Merkle root rt that  $\mathcal{P}^*$  output is equal to  $\operatorname{rt}^*$  and x is equal to  $x^*$ , he outputs  $\sigma_{\mathcal{M}^{\otimes N}}$ , which fools  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$  with probability non-negligible in  $\Sigma(\lambda, m, n)$ . Furthermore,  $\mathcal{P}^{**}$  runs in time  $\operatorname{poly}(\Omega) \geq \operatorname{poly}(\lambda, m, N)$ , since  $N \leq \operatorname{poly}(\Omega)$  and  $\lambda \leq \Omega$  by assumption. This contradicts the  $\Sigma$ -security of the  $\mathcal{M}^{\otimes N}$  SNARG.

Piecing together the following ingredients:

- a  $2^{\kappa^{\epsilon}}$ -hiding meSSB hash family, which exists for some  $\epsilon > 0$  assuming sub-exponential LWE (by Theorem 3.3 and Theorem 3.5),
- the adaptive t- or  $2^s$ -computational non-signaling PCPs with N = poly(t) tests for  $\mathcal{L}_{\mathcal{U}}(t)$  and  $N\mathcal{L}_{\mathcal{U}}(t,s)$  given in Theorems 2.7 and 2.8, respectively,
- the  $2^{\lambda^\epsilon}$ -secure SNARG for  $\mathcal{M}^{\otimes N}$  given in Theorem 2.8 which exists for some  $\epsilon>0$  assuming sub-exponential LWE, which means we may take  $\lambda=(\ell_{\mathsf{meSSB},\mathsf{hash}})^{1/\epsilon}$  (which equals  $\mathrm{polylog}(t)$  and  $\mathrm{poly}(s)$  in the case of  $\mathcal{L}_{\mathcal{U}}(t)$  and  $\mathrm{N}\mathcal{L}_{\mathcal{U}}(t,s)$ ) to satisfy  $\Sigma(\lambda,m,N)=2^{\lambda^\epsilon}=2^{\ell_{\mathsf{meSSB},\mathsf{hash}}}$ ,

and taking  $\epsilon>0$  to be such that a  $2^{\kappa^\epsilon}$ -hiding meSSB hash family and a  $2^{\lambda^\epsilon}$ -secure SNARG for  $\mathcal{M}^{\otimes N}$  simultaneously exist assuming sub-exponential LWE, we have the following corollaries:

Corollary 6.6. Let t = t(n) be such that  $poly(n) \le t(n) \le exp(n)$ . Then, assuming sub-exponential LWE, there is a non-interactive argument for  $\mathcal{L}_{\mathcal{U}}(t)$  that is adaptively sound except with probability poly(t) against poly(t)-size cheating provers, where the honest prover runs in time poly(t), the verifier runs in time  $poly(n, \log t)$ , and the communication complexity is  $poly(n, \log t)$ .

Proof. The SNARG for  $\mathcal{L}_{\mathcal{U}}(t)$  is precisely that given in Figure 6 with the adaptive t-computational non-signaling PCP for  $\mathcal{L}_{\mathcal{U}}(t)$  such that  $N=\operatorname{poly}(t)$ , which exists by Theorem 2.7, and setting  $\epsilon>0$  such that a  $2^{\kappa^\epsilon}$ -hiding SSB hash family and a  $2^{\kappa^\epsilon}$ -secure  $\mathcal{M}^{\otimes N}$  SNARG exist assuming subexponential LWE. In this protocol, note that the prover first hashes the PCP, which takes time  $\operatorname{poly}(t)$  (Theorem 2.7), and then emulates the prover from the  $\mathcal{M}^{\otimes N}$  SNARG, which definitionally runs in time  $\operatorname{poly}(\lambda, m, N) = \operatorname{poly}(t)$  (Definition 6.2). Note that  $m = \tau \cdot \log L + n + \ell_{\mathsf{meSSB},\mathsf{hk}} + \ell_{\mathsf{meSSB},\mathsf{hash}} = \operatorname{poly}(n, \kappa, \log L) = \operatorname{poly}(n, \log t)$ . The proof string  $\sigma$  thus satisfies  $|\sigma| = |\mathsf{rt}| + |\sigma_{\mathcal{M} \otimes N}| = \operatorname{poly}(\kappa) + \operatorname{poly}(\lambda, m, \log N) = \operatorname{poly}(n, \log t)$ . The verifier simply emulates  $\mathcal{V}_{\mathcal{M} \otimes N}$ , which runs in time  $\operatorname{poly}(\lambda, m, \log N) = \operatorname{poly}(n, \log t)$ .

Corollary 6.7. Let t = t(n) be such that  $poly(n) \le t(n) \le exp(n)$  and let  $s = s(n) \ge log t(n)$ . Assuming sub-exponential LWE, there is a non-interactive argument for  $N\mathcal{L}_{\mathcal{U}}(t,s)$  that is adaptively sound except with probability  $negl(2^s)$  against  $poly(2^s)$ -size cheating provers, where the honest prover runs in time poly(t), the verifier runs in time poly(n,s), and the communication complexity is poly(n,s).

<span id="page-31-2"></span>Proof. The SNARG for NTISP(t,s) is that given in Figure 6, instantiated with an adaptive  $2^s$ -computational non-signaling PCP for NTISP(t,s) with  $N=\operatorname{poly}(t)$  as given in Theorem 2.8, and  $\epsilon>0$  such that a  $2^{\kappa^\epsilon}$ -hiding SSB hash family a  $2^{\kappa^\epsilon}$ -secure  $\mathcal{M}^{\otimes N}$  SNARG exist assuming subexponential LWE. We analyze the runtimes. First, the prover runs in time  $\operatorname{poly}(t)$ , since the PCP generated is of size  $\operatorname{poly}(t)$ , and the SNARG for  $\mathcal{M}^{\otimes N}$  can also be generated in time  $\operatorname{poly}(t)$ . Since  $m=\tau\cdot\log L+n+\ell_{\mathsf{meSSB},\mathsf{hk}}+\ell_{\mathsf{meSSB},\mathsf{hash}})=\operatorname{poly}(n,\kappa,\log L)=\operatorname{poly}(n,s,\log t)=\operatorname{poly}(n,s)$ , the proof string  $\sigma$  satisfies  $|\sigma|=|\mathsf{rt}|+|\sigma_{\mathcal{M}^{\otimes N}}|=\operatorname{poly}(\kappa)+\operatorname{poly}(\lambda,m,\log N)=\operatorname{poly}(n,s,\log t)=\operatorname{poly}(n,s)$ . Finally, the verifier emulates  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$ , which runs in time  $\operatorname{poly}(\lambda,m,\log N)=\operatorname{poly}(n,s,\log t)=\operatorname{poly}(n,s,\log t)$ 

#### <span id="page-31-0"></span>6.2.2 SNARGs for $\mathcal{L}$ from SNARGs for BatchNP with Low Depth Verifier

In this section, we show that the assumption that the BatchNP SNARG verifier is super-efficient and takes as input succinct descriptions of BatchNP instances is not needed: in the case where the BatchNP SNARG verifier takes as input the full instance Y and runs in time polynomial in N, we can simply delegate these verifier checks back to the prover assuming that the checks are computable by a low depth circuit.

For this delegation of the verifier checks, we will use the SNARG for bounded depth computations constructed by [JKKZ21].

<span id="page-31-1"></span>**Theorem 6.8** ([JKKZ21]). (SNARG for Size-S, Depth-D Circuits) Assuming the sub-exponential hardness of LWE, there is some  $\epsilon > 0$  such that for any log-space uniform circuit C of size S and depth D, there are PPT algorithms (Setup<sub>JKKZ</sub>,  $\mathcal{P}_{JKKZ}$ ,  $\mathcal{V}_{JKKZ}$ ) with syntax:

- Setup<sub>JKKZ</sub> $(1^{\eta}, S, 1^{D})$  takes as input a security parameter  $\eta$  in unary, the size S of the circuit in binary, and the depth D of the circuit in unary. It outputs a string crs.
- $\mathcal{P}_{\mathsf{JKKZ}}(\mathsf{crs}, C, x)$  takes as input the  $\mathsf{crs}$ , circuit C of size S and depth D, and input x. She runs in time  $\mathsf{poly}(\eta, S)$  and outputs a proof  $\sigma$  of size  $D \cdot \mathsf{poly}(\eta, \log S)$ .
- $V_{\mathsf{JKKZ}}(\mathsf{crs}, \langle C \rangle, x, \sigma)$  takes as input the  $\mathsf{crs}$ , a  $\log S$  size description of the circuit C, the input x, and a short proof  $\sigma \in \{0,1\}^{D \cdot \mathrm{poly}(\eta, \log S)}$ . He runs in time  $(D + |x|) \cdot \mathrm{poly}(\eta, \log S)$  and outputs either 0 or 1 indicating reject or accept.

These algorithms satisfy the following properties:

• Correctness: For C, x such that C(x) = 1,

$$\Pr\left[\mathcal{V}_{\mathsf{JKKZ}}(\mathsf{crs},\langle C\rangle,x,\sigma) = 1 \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}(1^{\eta},S,1^D) \\ \sigma \leftarrow \mathcal{P}_{\mathsf{JKKZ}}(\mathsf{crs},C,x) \end{matrix} \right] = 1.$$

•  $2^{\eta^{\epsilon}}$ -Soundness: For C, x such that  $C(x) \neq 1$ , for any  $poly(2^{\eta^{\epsilon}})$ -size  $\mathcal{P}^*$ , and for  $\eta \geq polylog(S)$ ,

$$\Pr\left[\mathcal{V}_{\mathsf{JKKZ}}(\mathsf{crs},\langle C\rangle,x,\sigma) = 1 \middle| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}(1^{\eta},S,1^D) \\ \sigma \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{matrix}\right] = \mathrm{negl}(2^{\eta^{\epsilon}}).$$

Fix a SNARG (Setup $_{\mathcal{M}^{\otimes N}}$ ,  $\mathcal{P}_{\mathcal{M}^{\otimes N}}$ ,  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$ ) for  $\mathcal{M}^{\otimes N}$  as in Definition 6.2, where  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$  takes as input the full instance X rather than just a description. Suppose that the circuit  $\mathcal{V}_{\mathcal{M}^{\otimes N}}$  has size  $S = \operatorname{poly}(\lambda, m, N)$  and depth D. Let  $\mathcal{V}'_{\mathcal{M}^{\otimes N}}$  denote the algorithm that takes as input  $(\operatorname{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}})$ , computes  $Y = B(\langle Y \rangle)$ , and then runs  $\mathcal{V}_{\mathcal{M}^{\otimes N}}(\operatorname{crs}_{\mathcal{M}^{\otimes N}}, Y, \sigma_{\mathcal{M}^{\otimes N}})$ . Denote by S(B) and D(B) the size and depth respectively of a circuit computing  $B(\cdot, \cdot)$ , as defined in Definition 6.1. Note that the circuit computing  $\mathcal{V}'_{\mathcal{M}^{\otimes N}}$  has size  $S' = S + N \cdot S(B) = S + N \cdot \operatorname{poly}(m, \log N)$  and depth  $D' = D + D(B) = D + \operatorname{poly}(m, \log N)$ . Let  $(\operatorname{Setup}_{\mathsf{JKKZ}}, \mathcal{P}_{\mathsf{JKKZ}}, \mathcal{V}_{\mathsf{JKKZ}})$  be the SNARG for circuits of size S' and depth D' given in Theorem 6.8.

Our SNARG for  $\mathcal{L}$  is described in Figure 7.

#### SNARG for $\mathcal{L}$ from SNARG for BatchNP

For  $\epsilon > 0$ , define  $\kappa = (\log \Omega)^{1/\epsilon}$  and let  $\lambda$  be such that  $\Sigma(\lambda, m, N) \geq 2^{\ell_{\mathsf{meSSB}}, \mathsf{hash}}$ . Let  $\eta = (\ell_{\mathsf{meSSB}, \mathsf{hash}} + \ell_{\mathcal{M}^{\otimes N}})^{1/\epsilon}$ .

• Setup  $(1^{\kappa}, 1^{\lambda})$  takes as input  $\kappa$  and  $\lambda$  in unary. It samples

$$Q = (q_1, \dots, q_\ell) \leftarrow \mathcal{Q}_{\mathsf{nsPCP}}(1^\kappa), \text{ and } (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, Q).$$

It also samples

$$\operatorname{crs}_{\mathcal{M}^{\otimes N}} \leftarrow \operatorname{\mathsf{Setup}}_{\mathcal{M}^{\otimes N}}(1^{\lambda}, 1^m, N)$$

and

$$\operatorname{crs}_{\mathsf{JKKZ}} \leftarrow \mathsf{Setup}_{\mathsf{JKKZ}}(1^{\eta}, S, 1^{D}),$$

and outputs  $crs = (hk_{meSSB}, crs_{\mathcal{M} \otimes N}, crs_{JKKZ}).$ 

•  $\mathcal{P}_{\mathcal{L}}$  takes as input the crs =  $(hk_{meSSB}, crs_{\mathcal{M}^{\otimes N}}, crs_{JKKZ})$  and an instance x. It computes

$$\pi \leftarrow \Pi(x)$$
 and  $\mathsf{rt} = \mathsf{Hash}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi)$ .

It then computes  $\sigma_{\mathcal{M}^{\otimes N}} \leftarrow \mathcal{P}_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, Y, W)$ , where

$$Y = \{(\zeta_j, x, \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{rt})\}_{j \in [N]}$$

and

$$W = \{((\pi_{\zeta_{j,1}}, \dots, \pi_{\zeta_{j,\tau}}), (\mathsf{o}_{\zeta_{j,1}}, \dots, \mathsf{o}_{\zeta_{j,\tau}}))\}_{j \in [N]} \ ,$$

where  $o_q = \mathsf{Open}_{\mathsf{meSSB}}(\mathsf{hk}_{\mathsf{meSSB}}, \pi, q)$ . Finally, it computes

$$\sigma_{\mathsf{JKKZ}} \leftarrow \mathcal{P}_{\mathsf{JKKZ}}(\mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}'_{\mathcal{M}^{\otimes N}}, (\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}})).$$

It outputs  $\sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}}).$ 

•  $\mathcal{V}_{\mathcal{L}}$  takes as input  $\operatorname{crs} = (\operatorname{hk}_{\operatorname{meSSB}}, \operatorname{crs}_{\mathcal{M} \otimes^N}, \operatorname{crs}_{\operatorname{JKKZ}})$ , instance x, and  $\sigma = (\operatorname{rt}, \sigma_{\mathcal{M} \otimes^N}, \sigma_{\operatorname{JKKZ}})$ . It runs and outputs the result of  $\mathcal{V}_{\operatorname{JKKZ}}(\operatorname{crs}_{\operatorname{JKKZ}}, \langle \mathcal{V}'_{\mathcal{M} \otimes^N} \rangle, (\operatorname{crs}_{\mathcal{M} \otimes^N}, \langle Y \rangle, \sigma_{\mathcal{M} \otimes^N}), \sigma_{\operatorname{JKKZ}})$ , where  $\langle Y \rangle = (x, \operatorname{hk}_{\operatorname{meSSB}}, \operatorname{rt})$ .

<span id="page-32-0"></span>Figure 7: SNARG (Setup,  $\mathcal{P}_{\mathcal{L}}, \mathcal{V}_{\mathcal{L}}$ )(x) for  $\mathcal{L}$ 

<span id="page-33-0"></span>**Theorem 6.9.** The algorithms (Setup<sub>L</sub>,  $\mathcal{P}_{\mathcal{L}}$ ,  $\mathcal{V}_{\mathcal{L}}$ ) defined in Figure 7 satisfy the following properties:

• Correctness: For every  $x \in \mathcal{L}$ ,

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma) = 1 \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ \sigma \leftarrow \mathcal{P}_{\mathcal{L}}(\mathsf{crs}, x) \end{matrix} \right| = 1.$$

- Soundness: Assuming that:
  - the meSSB hash family is  $2^{\kappa^{\epsilon}}$ -hiding,
  - the PCP is adaptive  $n \leq \Omega$ -computational non-signaling and verified via tests, of which there are  $N \leq \operatorname{poly}(\Omega)$ ,
  - the  $\mathcal{M}^{\otimes N}$  SNARG is  $\Sigma$ -sound, such that  $\lambda$  (defined in Figure  $\gamma$ ) is  $\leq \Omega$ ,
  - $-~\mathcal{V}_{\mathcal{M}^{\otimes N}}$  is a log-space uniform circuit of depth D,
  - (Setup $_{\mathsf{JKKZ}}, \mathcal{P}_{\mathsf{JKKZ}}, \mathcal{V}_{\mathsf{JKKZ}})$  has  $2^{\eta^\epsilon}$ -soundness,

then for any  $\operatorname{poly}(\Omega)$ -size  $\mathcal{P}^*$ ,

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \, \middle| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ x, \sigma \leftarrow \mathcal{P}_{\mathcal{L}}(\mathsf{crs}) \end{matrix}\right] = \mathrm{negl}(\Omega).$$

*Proof.* Correctness is straightforward. We focus on proving soundness. Suppose for the sake of contradiction that there is a  $poly(\Omega)$ -size prover  $\mathcal{P}^*$  and a non-negligible  $\delta$  such that

$$\Pr\left[\mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \left| \begin{matrix} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ x, \sigma \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{matrix} \right] = \delta(\Omega).$$

As in the proof of Theorem 6.5, this implies that there is non-negligible  $\delta'$  such that

$$\delta'(\Omega) \leq \Pr\left[ \begin{array}{c|c} \mathcal{V}_{\mathcal{L}}(\mathsf{crs}, x, \sigma)) = 1 \ \land \ x \not\in \mathcal{L} \\ \land \ \mathcal{V}_{\mathsf{nsPCP}}(x, Q, \mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt})) = 0 \end{array} \middle| \begin{array}{c} \mathsf{crs} \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^\kappa, 1^\lambda) \\ x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{array} \right].$$

Using the fact that  $\mathcal{V}_{\mathcal{L}}$  simply runs  $\mathcal{V}_{\mathsf{JKKZ}}$ , and that  $\mathcal{V}_{\mathsf{nsPCP}}(x,Q,\mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}},\mathsf{rt})) = 0$  implies that  $Y \not\in \mathcal{M}^{\otimes N}$ , where  $\langle Y \rangle$  denotes  $(x,\mathsf{hk}_{\mathsf{meSSB}},\mathsf{rt})$ , since there is at least one test  $\zeta \subseteq Q$  for which  $\mathcal{U}_{\mathsf{nsPCP}}(\zeta,\mathsf{Invert}_{\mathsf{meSSB}}(\mathsf{td}_{\mathsf{meSSB}},\mathsf{rt})|_{\mathcal{E}}) = 0$ , we obtain that this is equal to

$$=\Pr\left[ \begin{array}{c} \mathcal{V}_{\mathsf{JKKZ}} \begin{pmatrix} \mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}'_{\mathcal{M}^{\otimes N}}, \\ (\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}), \\ \sigma_{\mathsf{JKKZ}} \end{pmatrix} = 1 \\ & \sigma_{\mathsf{JKKZ}} \end{pmatrix} \right. \\ \left. \begin{array}{c} \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \\ x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \\ \end{pmatrix}.$$

We can split this into whether  $\sigma_{\mathcal{M}^{\otimes N}}$  is an accepting proof for  $Y \in \mathcal{M}^{\otimes N}$ :

$$\leq \Pr \begin{bmatrix} \mathcal{V}_{\mathsf{JKKZ}} \begin{pmatrix} \mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}_{\mathcal{M}^{\otimes N}}', \\ (\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}), \\ \sigma_{\mathsf{JKKZ}} \end{pmatrix} = 1 & \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \\ \times \mathcal{V}_{\mathcal{M}^{\otimes N}}'(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}) = 0 \end{bmatrix} & \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \\ + \Pr \begin{bmatrix} \mathcal{V}_{\mathcal{M}^{\otimes N}}'(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}) = 1 \\ \mathcal{V}_{\mathcal{M}^{\otimes N}}'(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}) = 1 \end{bmatrix} & \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \end{bmatrix} . \tag{3}$$

 $+\Pr\left[ \left. \begin{array}{c} \mathcal{V}'_{\mathcal{M}^{\otimes N}}(\mathsf{crs}_{\mathcal{M}^{\otimes N}}, \langle Y \rangle, \sigma_{\mathcal{M}^{\otimes N}}) = 1 \\ & \wedge Y \not\in \mathcal{M}^{\otimes N} \end{array} \right| \quad \mathsf{crs} = (\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \\ & x, \sigma = (\mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \right].$ 

To get a contradiction we argue that both terms of this sum are negligible in  $\Omega$ . The term (4) is  $negl(\Omega)$  for precisely the same reason as in the proof of Theorem 6.5: we can otherwise break the  $\Sigma$ -soundness of the  $\mathcal{M}^{\otimes N}$  SNARG by finding an accepting proof  $\sigma_{\mathcal{M}^{\otimes N}}$  for some instance  $Y^*=(x^*,\mathsf{hk}^*_{\mathsf{meSSB}},\mathsf{rt}^*_{\mathsf{meSSB}})$  with probability  $\frac{\Delta(\Omega)}{2^{n+\ell_{\mathsf{meSSB}},\mathsf{hash}}}=\Delta'(\Sigma(\lambda,m,N))$ , where  $\Delta$  and  $\Delta'$  are non-negligible functions.

As for the term (3), suppose that it is equal to  $\Delta(\Omega)$ , for some non-negligible  $\Delta$ . By an averaging argument, there is some  $\mathsf{hk}^*_{\mathsf{meSSB}}$  and  $\mathsf{crs}^*_{\mathcal{M}^{\otimes N}}$  for which (3)  $\geq \Delta(\Omega)$ , conditioned on  $\mathsf{crs} =$  $(\mathsf{hk}^*_{\mathsf{meSSB}}, \mathsf{crs}^*_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}).$  Next, conditioning on crs being of the form  $(\mathsf{hk}^*_{\mathsf{meSSB}}, \mathsf{crs}^*_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}}),$  there is some  $x^*, \mathsf{rt}^*, \sigma^*_{\mathcal{M}^{\otimes N}}$  for which, with probability  $\geq \frac{\Delta(\Omega)}{2^{n+\ell_{\mathsf{meSSB}}, \mathsf{hash}+\ell_{\mathcal{M}^{\otimes N}}},$  the conditions of (3) hold and  $\mathcal{P}^*$  outputs x and  $\sigma = (\mathsf{rt}, \sigma_{\mathcal{M} \otimes N}, \sigma_{\mathsf{JKKZ}})$  with  $x = x^*, \mathsf{rt} = \mathsf{rt}^*, \sigma_{\mathcal{M} \otimes N} = \sigma_{\mathcal{M} \otimes N}^*$ . That is, letting  $\langle Y^* \rangle = (x^*, \mathsf{hk}^*_{\mathsf{meSSB}}, \mathsf{rt}^*),$ 

$$\Pr \begin{bmatrix} \mathcal{V}_{\mathsf{JKKZ}} \begin{pmatrix} \mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}'_{\mathsf{M} \otimes N}, \\ (\mathsf{crs}_{\mathsf{M} \otimes N}^*, \langle Y^* \rangle, \sigma_{\mathsf{M} \otimes N}^*), \\ \sigma_{\mathsf{JKKZ}} \end{pmatrix} = 1 \\ \wedge \mathcal{V}'_{\mathsf{M} \otimes N} (\mathsf{crs}_{\mathsf{M} \otimes N}^*, \langle Y^* \rangle, \sigma_{\mathsf{M} \otimes N}^*) = 0 \\ \wedge (x, \mathsf{rt}, \sigma_{\mathsf{M} \otimes N}) = (x^*, \mathsf{rt}^*, \sigma_{\mathsf{M} \otimes N}^*) \end{bmatrix} \\ \operatorname{crs}_{\mathsf{JKKZ}} \leftarrow \mathsf{Setup}_{\mathsf{JKKZ}} (1^{\eta}, S, 1^D) \\ \operatorname{crs} := (\mathsf{hk}_{\mathsf{meSSB}}^*, \mathsf{crs}_{\mathsf{M} \otimes N}^*, \mathsf{crs}_{\mathsf{JKKZ}}) \\ x, \sigma = (\mathsf{rt}, \sigma_{\mathsf{M} \otimes N}, \sigma_{\mathsf{JKKZ}}) \leftarrow \mathcal{P}^*(\mathsf{crs}) \end{bmatrix} \\ \geq \frac{\Delta(\Omega)}{2^{n + \ell_{\mathsf{meSSB}, \mathsf{hash}} + \ell_{\mathsf{M} \otimes N}}, \\ \mathsf{mess}_{\mathsf{M} \otimes \mathsf{M}} (\mathsf{mess}_{\mathsf{M} \otimes \mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) = (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}}) \\ \mathsf{mess}_{\mathsf{M}} (\mathsf{mess}_{\mathsf{M}})$$

where  $\ell_{\mathcal{M}^{\otimes N}} = \text{poly}(\lambda, m, \log N)$  is the length of  $\sigma_{\mathcal{M}^{\otimes N}}$ . Letting  $Z^*$  denote  $(\operatorname{crs}_{\mathcal{M}^{\otimes N}}^*, \langle Y^* \rangle, \sigma_{\mathcal{M}^{\otimes N}}^*)$ , so that  $\mathcal{V}_{\mathcal{M}^{\otimes N}}'(Z^*) = 0$ , this implies that

$$\begin{split} \Pr\left[ \left. \mathcal{V}_{\mathsf{JKKZ}} \left( \mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}_{\mathcal{M}^{\otimes N}}', Z^*, \sigma_{\mathsf{JKKZ}} \right) = 1 \; \right| & \; \mathsf{crs} = \left( \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}} \right) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \right] \\ & \; x, \sigma = \left( \mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}} \right) \leftarrow \mathcal{P}^*(\mathsf{crs}) \right] \\ & \geq \Pr\left[ \left. \mathcal{V}_{\mathsf{JKKZ}} \left( \mathsf{crs}_{\mathsf{JKKZ}}, \mathcal{V}_{\mathcal{M}^{\otimes N}}', Z^*, \sigma_{\mathsf{JKKZ}} \right) = 1 \right| & \; \mathsf{crs} = \left( \mathsf{hk}_{\mathsf{meSSB}}, \mathsf{crs}_{\mathcal{M}^{\otimes N}}, \mathsf{crs}_{\mathsf{JKKZ}} \right) \leftarrow \mathsf{Setup}_{\mathcal{L}}(1^{\kappa}, 1^{\lambda}) \right] \\ & \; \wedge \left( x, \mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}} \right) = \left( x^*, \mathsf{rt}^*, \sigma_{\mathcal{M}^{\otimes N}}^* \right) \right| & \; x, \sigma = \left( \mathsf{rt}, \sigma_{\mathcal{M}^{\otimes N}}, \sigma_{\mathsf{JKKZ}} \right) \leftarrow \mathcal{P}^*(\mathsf{crs}) \right] \\ & \geq \frac{\Delta(\Omega)}{2^{n + \ell_{\mathsf{meSSB},\mathsf{hash}} + \ell_{\mathcal{M}^{\otimes N}}} \\ & = \Delta'(2^{n^{\epsilon}}), \end{split}$$

where ∆<sup>0</sup> is a non-negligible function (it exists because η is defined such that 2 η = 2 `meSSB,hash+`M⊗<sup>N</sup> > Ω ≥ n). This then contradicts the 2 η -soundness of the JKKZ SNARG, as P ∗ (crs, x) outputs σJKKZ for which VJKKZ(crsJKKZ, V 0 <sup>M</sup>⊗<sup>N</sup> , Z<sup>∗</sup> , σJKKZ) = 1 with probability nonnegligible in 2 η .

Assuming sub-exponential LWE, there is some > 0 such that both the following hold: a 2 κ -hiding meSSB hash family exists and (SetupJKKZ,PJKKZ, VJKKZ) has 2 η -soundness. Assuming this, and using the adaptive computational non-signaling PCPs for LU(t) and NLU(t, s) from Theorems [2.7](#page-11-1) and [2.8,](#page-12-1) we get the following corollaries:

<span id="page-35-0"></span>Corollary 6.10. For any poly(n) ≤ t(n) ≤ exp(n), there exists a non-interactive argument for LU(t) that is adaptively sound against poly(t)-size cheating provers, assuming that

- LWE is sub-exponentially hard,
- there is a Σ-sound SNARG for M⊗<sup>N</sup> ,
- the M⊗<sup>N</sup> verifier VM⊗<sup>N</sup> is a log-space uniform circuit of depth D.

The prover runs in time poly(t), the verifier runs in time D · poly(n, λ, log t), and the communication complexity is D · poly(n, λ, log t).

Proof. The non-interactive argument for LU(t) is that given in Figure [6.9,](#page-33-0) with corresponding to the LWE assumption, and an adaptive t-computational non-signaling PCP for LU(t) that is verified via N = poly(t) tests, as given in Theorem [2.7.](#page-11-1)

To analyze the runtimes, we first compute some sizes:

- `meSSB,hash = κ · polylog(t) · poly(κ) = polylog(t),
- `M⊗<sup>N</sup> = poly(λ, m, log N) = poly(n, λ, log t),
- S = poly(t) since VM⊗<sup>N</sup> runs in time S = poly(λ, m, N) = poly(t).

Thus, η = (`meSSB,hash + `M⊗<sup>N</sup> ) <sup>1</sup>/ = poly(n, λ, log t). Now, we analyze the runtimes and complexities.

- The prover has to do three things: compute the PCP π, which takes time poly(t); compute Y and W, and compute σM⊗<sup>N</sup> , which together takes time poly(λ, m, N) = poly(t); and finally compute σJKKZ, which takes time poly(η, S<sup>0</sup> ) = poly(poly(n, log t), S + N · poly(m, log N)) = poly(t). This gives a total prover runtime of poly(t).
- The proof string σ has length |σ| = |rt| + |σM⊗<sup>N</sup> | + |σJKKZ| = poly(κ) + poly(λ, m, log N) + D · poly(η, log S) = D · poly(n, λ, log t).
- The verifier runs VJKKZ, which runs in time (D+|crsM⊗<sup>N</sup> |+|hY i|+|σM⊗<sup>N</sup> |)·poly(η, log S 0 ) = (D + poly(λ, m, log N)) · poly(η, log(S + N · poly(m, log N))) = D · poly(n, λ, log t).

Corollary 6.11. For poly(n) ≤ t ≤ exp(n) and s = s(n) ≥ log t(n), there exists a noninteractive argument for NLU(t, s) that is adaptively sound against poly(2<sup>s</sup> )-size cheating provers with probability 1 − negl(2<sup>s</sup> ), assuming that

- LWE is sub-exponentially hard,
- there is a Σ-sound SNARG for M⊗<sup>N</sup> ,
- the M⊗<sup>N</sup> verifier VM⊗<sup>N</sup> is a log-space uniform circuit of depth D.

The honest prover runs in time poly(t), the verifier runs in time D · poly(n, λ, s), and the communication complexity is D · poly(n, λ, s).

Proof. The non-interactive argument for LU(t) is that given in Figure [7,](#page-32-0) with > 0 corresponding to the LWE assumption and an adaptive 2 s -computational non-signaling PCP that is verified via N = poly(t) tests as given in Theorem [2.8.](#page-12-1) The runtime analysis is analogous to the proof of Corollary [6.10,](#page-35-0) except κ = poly(log 2<sup>s</sup> ) = poly(s), which gives that η = poly(n, λ, s). This gives the claimed runtimes.

Acknowledgements. We thank the anonymous TCC 2021 reviewers for their detailed and insightful comments.

## References

- <span id="page-36-2"></span>[Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In FOCS, pages 106–115, 2001. [6](#page-7-2)
- <span id="page-36-1"></span>[BBH+19] James Bartusek, Liron Bronfman, Justin Holmgren, Fermi Ma, and Ron D. Rothblum. On the (in)security of kilian-based snargs. In Dennis Hofheinz and Alon Rosen, editors, Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II, volume 11892 of Lecture Notes in Computer Science, pages 522–551. Springer, 2019. [2,](#page-3-2) [4,](#page-5-2) [6](#page-7-2)
- <span id="page-36-4"></span>[BFLS91] László Babai, Lance Fortnow, Leonid A. Levin, and Mario Szegedy. Checking computations in polylogarithmic time. In Proceedings of the 23rd Annual ACM Symposium on Theory of Computing, May 5-8, 1991, New Orleans, Louisiana, USA, pages 21–31, 1991. [8](#page-9-2)
- <span id="page-36-0"></span>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai. Non-interactive delegation and batch NP verification from standard computational assumptions. In Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2017, Montreal, QC, Canada, June 19-23, 2017, pages 474–482, 2017. [1,](#page-0-0) [7,](#page-8-2) [8,](#page-9-2) [10,](#page-11-2) [39](#page-40-4)
- <span id="page-36-3"></span>[BK18] Zvika Brakerski and Yael Tauman Kalai. Monotone batch np-delegation with applications to access control. IACR Cryptology ePrint Archive, 2018:375, 2018. [8](#page-9-2)

- <span id="page-37-1"></span>[BKK+18] Saikrishna Badrinarayanan, Yael Tauman Kalai, Dakshita Khurana, Amit Sahai, and Daniel Wichs. Succinct delegation for low-space non-deterministic computation. In Proceedings of the 50th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2018, Los Angeles, CA, USA, June 25-29, 2018, pages 709–721, 2018. [1,](#page-0-0) [7,](#page-8-2) [8,](#page-9-2) [11](#page-12-2)
- <span id="page-37-7"></span>[Blu86] Manuel Blum. How to prove a theorem so no one else can claim it. In Proceedings of the International Congress of Mathematicians, pages 1444–1451, 1986. [6](#page-7-2)
- <span id="page-37-9"></span>[BV11] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. In FOCS, pages 97–106, 2011. [13](#page-14-2)
- <span id="page-37-6"></span>[CCH+19] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26, 2019, pages 1082–1090. ACM, 2019. [6](#page-7-2)
- <span id="page-37-5"></span>[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-shamir and correlation intractability from strong kdm-secure encryption. In Advances in Cryptology - EUROCRYPT 2018 - 37th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part I, pages 91–122, 2018. [6](#page-7-2)
- <span id="page-37-8"></span>[CGKS95] Benny Chor, Oded Goldreich, Eyal Kushilevitz, and Madhu Sudan. Private information retrieval. In 36th Annual Symposium on Foundations of Computer Science, Milwaukee, Wisconsin, USA, 23-25 October 1995, pages 41–50, 1995. [12](#page-13-3)
- <span id="page-37-2"></span>[CJJ21] Arka Rai Choudhuri, Abhishek Jain, and Zhengzhong Jin. SNARGs for P from LWE. IACR Cryptol. ePrint Arch., 2021. [3,](#page-4-1) [8,](#page-9-2) [25](#page-26-2)
- <span id="page-37-3"></span>[CMSZ21] Alessandro Chiesa, Fermi Ma, Nicholas Spooner, and Mark Zhandry. Post-quantum succinct arguments. IACR Cryptol. ePrint Arch., 2021:334, 2021. [4](#page-5-2)
- <span id="page-37-4"></span>[CSW20] Ran Canetti, Pratik Sarkar, and Xiao Wang. Triply adaptive UC NIZK. IACR Cryptol. ePrint Arch., 2020:1212, 2020. [4](#page-5-2)
- <span id="page-37-10"></span>[DGI+19] Nico Döttling, Sanjam Garg, Yuval Ishai, Giulio Malavolta, Tamer Mour, and Rafail Ostrovsky. Trapdoor hash functions and their applications. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019 - 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18-22, 2019, Proceedings, Part III, volume 11694 of Lecture Notes in Computer Science, pages 3–32. Springer, 2019. [13](#page-14-2)
- <span id="page-37-0"></span>[DHRW16] Yevgeniy Dodis, Shai Halevi, Ron D. Rothblum, and Daniel Wichs. Spooky encryption and its applications. In Advances in Cryptology - CRYPTO 2016 - 36th Annual

- International Cryptology Conference, Santa Barbara, CA, USA, August 14-18, 2016, Proceedings, Part III, pages 93–122, 2016. [1](#page-0-0)
- <span id="page-38-0"></span>[DLN+04] Cynthia Dwork, Michael Langberg, Moni Naor, Kobbi Nissim, and Omer Reingold. Succinct proofs for NP and spooky interactions. Unpublished manuscript, 2004. [http:](http://www.cs.bgu.ac.il/~kobbi/papers/spooky_sub_crypto.pdf) [//www.cs.bgu.ac.il/~kobbi/papers/spooky\\_sub\\_crypto.pdf](http://www.cs.bgu.ac.il/~kobbi/papers/spooky_sub_crypto.pdf). [1](#page-0-0)
- <span id="page-38-7"></span>[GK03] Shafi Goldwasser and Yael Tauman Kalai. On the (in)security of the fiat-shamir paradigm. In FOCS, pages 102–, 2003. [6](#page-7-2)
- <span id="page-38-6"></span>[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In Eva Tardos, editor, ´ 46th IEEE Symposium on Foundations of Computer Science (FOCS), pages 553–562. IEEE Computer Society, 2005. [6](#page-7-2)
- <span id="page-38-8"></span>[GK16] Shafi Goldwasser and Yael Tauman Kalai. Cryptographic assumptions: A position paper. In Theory of Cryptography - 13th International Conference, TCC 2016-A, Tel Aviv, Israel, January 10-13, 2016, Proceedings, Part I, pages 505–522, 2016. [9](#page-10-5)
- <span id="page-38-3"></span>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In STOC, pages 113–122, 2008. [6](#page-7-2)
- <span id="page-38-4"></span>[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson. Proofs that yield nothing but their validity, or all languages in np have zero-knowledge proof systems. Journal of the ACM, 38(1):691–729, 1991. [6](#page-7-2)
- <span id="page-38-9"></span>[GR05] Craig Gentry and Zulfikar Ramzan. Single-database private information retrieval with constant communication rate. In Luís Caires, Giuseppe F. Italiano, Luís Monteiro, Catuscia Palamidessi, and Moti Yung, editors, Automata, Languages and Programming, 32nd International Colloquium, ICALP 2005, Lisbon, Portugal, July 11-15, 2005, Proceedings, volume 3580 of Lecture Notes in Computer Science, pages 803– 815. Springer, 2005. [13](#page-14-2)
- <span id="page-38-2"></span>[HL18] Justin Holmgren and Alex Lombardi. Cryptographic hashing from strong one-way functions (or: One-way product functions and their applications). In Mikkel Thorup, editor, 59th IEEE Annual Symposium on Foundations of Computer Science, FOCS 2018, Paris, France, October 7-9, 2018, pages 850–858. IEEE Computer Society, 2018. [6](#page-7-2)
- <span id="page-38-5"></span>[HLR21] Justin Holmgren, Alex Lombardi, and Ron D. Rothblum. Fiat-shamir via listrecoverable codes (or: Parallel repetition of gmw is not zero-knowledge). Cryptology ePrint Archive, Report 2021/286, 2021. <https://eprint.iacr.org/2021/286>. [6](#page-7-2)
- <span id="page-38-1"></span>[HW15] Pavel Hubácek and Daniel Wichs. On the communication complexity of secure function evaluation with long output. In Tim Roughgarden, editor, Proceedings of the 2015 Conference on Innovations in Theoretical Computer Science, ITCS 2015, Rehovot, Israel, January 11-13, 2015, pages 163–172. ACM, 2015. [2,](#page-3-2) [7,](#page-8-2) [13,](#page-14-2) [15](#page-16-2)

- <span id="page-39-4"></span>[JKKZ20] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. Snargs for bounded depth computations and PPAD hardness from sub-exponential LWE. IACR Cryptol. ePrint Arch., 2020:980, 2020. [1,](#page-0-0) [8](#page-9-2)
- <span id="page-39-8"></span>[JKKZ21] Ruta Jawale, Yael Tauman Kalai, Dakshita Khurana, and Rachel Zhang. Snargs for bounded depth computations and PPAD hardness from sub-exponential LWE. 2021. [6,](#page-7-2) [30](#page-31-2)
- <span id="page-39-0"></span>[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In STOC, pages 723–732, 1992. [1,](#page-0-0) [4](#page-5-2)
- <span id="page-39-9"></span>[KO97] Eyal Kushilevitz and Rafail Ostrovsky. Replication is not needed: Single database, computationally-private information retrieval. In FOCS, pages 364–373, 1997. [12,](#page-13-3) [13](#page-14-2)
- <span id="page-39-5"></span>[KPY19] Yael Tauman Kalai, Omer Paneth, and Lisa Yang. How to delegate computations publicly. In Moses Charikar and Edith Cohen, editors, Proceedings of the 51st Annual ACM SIGACT Symposium on Theory of Computing, STOC 2019, Phoenix, AZ, USA, June 23-26, 2019, pages 1115–1124. ACM, 2019. [1](#page-0-0)
- <span id="page-39-2"></span>[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In Symposium on Theory of Computing Conference, STOC'13, Palo Alto, CA, USA, June 1-4, 2013, pages 565–574, 2013. [1,](#page-0-0) [39](#page-40-4)
- <span id="page-39-3"></span>[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. How to delegate computations: the power of no-signaling proofs. In STOC, pages 485–494. ACM, 2014. [1,](#page-0-0) [8,](#page-9-2) [10,](#page-11-2) [19](#page-20-3)
- <span id="page-39-7"></span>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of fiat-shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part II, volume 10402 of Lecture Notes in Computer Science, pages 224–251. Springer, 2017. [6](#page-7-2)
- <span id="page-39-10"></span>[Lip05] Helger Lipmaa. An oblivious transfer protocol with log-squared communication. In Jianying Zhou, Javier López, Robert H. Deng, and Feng Bao, editors, Information Security, 8th International Conference, ISC 2005, Singapore, September 20-23, 2005, Proceedings, volume 3650 of Lecture Notes in Computer Science, pages 314– 328. Springer, 2005. [13](#page-14-2)
- <span id="page-39-1"></span>[Mer87] Ralph C. Merkle. A digital signature based on a conventional encryption function. In CRYPTO, volume 293 of Lecture Notes in Computer Science, pages 369–378. Springer, 1987. [1](#page-0-0)
- <span id="page-39-6"></span>[PR17] Omer Paneth and Guy N. Rothblum. On zero-testable homomorphic encryption and publicly verifiable non-interactive arguments. In Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part II, pages 283–315, 2017. [1](#page-0-0)

- <span id="page-40-4"></span><span id="page-40-3"></span>[PS19] Chris Peikert and Sina Shiehian. Noninteractive zero knowledge for NP from (plain) learning with errors. In Alexandra Boldyreva and Daniele Micciancio, editors, Advances in Cryptology - CRYPTO 2019, Proceedings, Part I, volume 11692 of Lecture Notes in Computer Science, pages 89–114. Springer, 2019. [6](#page-7-2)
- <span id="page-40-2"></span>[Unr12] Dominique Unruh. Quantum proofs of knowledge. In David Pointcheval and Thomas Johansson, editors, Advances in Cryptology - EUROCRYPT 2012 - 31st Annual International Conference on the Theory and Applications of Cryptographic Techniques, Cambridge, UK, April 15-19, 2012. Proceedings, volume 7237 of Lecture Notes in Computer Science, pages 135–152. Springer, 2012. [3](#page-4-1)
- <span id="page-40-1"></span>[Wat09] John Watrous. Zero-knowledge against quantum attacks. SIAM J. Comput., 39(1):25– 58, 2009. [3](#page-4-1)

## <span id="page-40-0"></span>A Proof of Theorem [3.6](#page-19-0)

Theorem [3.6](#page-19-0) shows the adaptive soundness of the BMW heuristic when applied to an adaptive computational non-signaling PCP and a meSSB hash family. The proof is nearly identical to that in [\[KRR13,](#page-39-2) [BHK17\]](#page-36-0) using an (adaptive) computational non-signaling PCP and a private information retrieval (PIR) scheme, and is provided here for completeness.

We first define the notion of an adaptive computational non-signaling PCP. For any ordered set[11](#page-40-5) U = (u1, . . . , u`) and J ⊆ [`], we let U<sup>J</sup> = (u<sup>j</sup> )j∈<sup>J</sup> .

Definition A.1 (Computational Non-Signaling Distributions). A family of distributions {DQ}Q⊂[L],|Q|=` is Ω-computational non-signaling with locality ` if, for any q1, . . . , q` ∈ [L] and q 0 1 , . . . , q<sup>0</sup> ` ∈ [L], letting J = {j ∈ [`] : q<sup>j</sup> = q 0 j }, the following two distributions are Ω-indistinguishable (see Definition [2.1\)](#page-9-3).

- D<sup>J</sup> where D = (d1, . . . , d`) ← D(q1,...,q`) ,
- D<sup>0</sup> <sup>J</sup> where D<sup>0</sup> = (d 0 1 , . . . , d<sup>0</sup> ` ) ← D(<sup>q</sup> 0 1 ,...,q<sup>0</sup> ` )

Definition A.2 (Adaptive Computational Non-Signaling PCP). An adaptive Ω-computational non-signaling PCP with locality ` is a PCP (Π, QPCP, VPCP) where soundness holds against adaptive cheating provers mounting an Ω-non-signaling attack with locality `. That is, for every Ω-computational non-signaling distribution {AS}S⊂[L],|S|≤` with locality `,

$$\Pr\left[\mathcal{V}_{\mathsf{PCP}}(Q, x, A) = 1 \quad \land \quad x \notin \mathcal{L}\right] \le 2^{-\kappa},$$

where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ) and (x, A) = (x, a1, . . . , a`) ← AQ, where Q = (0, q1, . . . , q`). [12](#page-40-6)

Let (GenmeSSB, HashmeSSB, OpenmeSSB, VerifymeSSB, OpenmeSSB) be a meSSB hash family. We restate Theorem [3.6](#page-19-0) below.

<span id="page-40-6"></span><span id="page-40-5"></span><sup>11</sup>The works of [\[KRR13,](#page-39-2) [BHK17\]](#page-36-0) consider unordered sets. The analysis is nearly identical, however.

<sup>12</sup>We add the dummy 0 query because x is chosen adaptively depending on the PCP queries, and we think of it as the answer corresponding to this dummy query.

#### The BMW Protocol

On input x and 1 κ , the 2 message protocol (PBMW, VBMW) proceeds as follows:

• Verifier: VBMW computes PCP queries (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ). He computes

$$(\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^{\kappa}, L, \ell, (q_1, \dots, q_{\ell}))$$

and sends hkmeSSB to the prover.

- Prover: PBMW computes the PCP string π = Π(x), and sends rt ← HashmeSSB(hkmeSSB, π) to the verifier.
- Verdict: VBMW computes (a1, . . . , a`) ← InvertmeSSB([`],tdmeSSB,rt) and accepts if and only if VPCP(x,(q1, . . . , q`),(a1, . . . , a`)) = 1.

Figure 8: BMW Heuristic with a meSSB Hash Function

Theorem A.3 (Theorem [3.6,](#page-19-0) restated). Let (Π, QnsPCP, VnsPCP) be a PCP for a language L with adaptive Ω(n)-computational non-signaling soundness and locality `. Assume that the meSSB hash family is Ω 0 -hiding, where Ω <sup>0</sup> = Ω<sup>0</sup> (κ) is such that Ω 0 (κ) = Ω(n) and 2 <sup>−</sup><sup>κ</sup> = negl(Ω<sup>0</sup> ). Then, for any poly(Ω<sup>0</sup> (κ))-size cheating prover P ∗ there is a negligible function µ such that

$$\Pr\left[\mathcal{V}_{\mathsf{BMW}}(x,\mathsf{rt},\mathsf{td}_{\mathsf{meSSB}},(q_1,\ldots,q_\ell)) = 1 \ \land \ x \notin \mathcal{L}\right] \leq \mu(\Omega'),$$

where (x,rt) = P ∗ (hkmeSSB) and where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ) and (hkmeSSB,tdmeSSB) ← GenmeSSB(1<sup>κ</sup> , L, `,(q1, . . . , q`)). Furthermore, the scheme is Ω 0 -straightline sound.

Proof. Suppose otherwise, that there is a poly(Ω<sup>0</sup> (κ))-size cheating prover P <sup>∗</sup> and a non-negligible function δ such that

$$\Pr\left[\mathcal{V}_{\mathsf{BMW}}(x,\mathsf{rt},\mathsf{td}_{\mathsf{meSSB}},(q_1,\ldots,q_\ell)) = 1 \ \land \ x \notin \mathcal{L}\right] \geq \delta(\Omega'),$$

where (x,rt) = P ∗ (hkmeSSB) and where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ) and (hkmeSSB,tdmeSSB) ← GenmeSSB(1<sup>κ</sup> , L, `,(q1, . . . , q`)).

<span id="page-41-0"></span>We will use P ∗ to construct an adaptive Ω-computational non-signaling strategy {AQ}Q⊂[L],|Q|≤` such that

$$\Pr\left[\mathcal{V}_{\mathsf{PCP}}(Q, x, A) = 1 \quad \land \quad x \notin \mathcal{L}\right] \ge \delta(\Omega'),\tag{5}$$

where the probability is over (q1, . . . , q`) ← QPCP(1<sup>κ</sup> ) and (x, A) = (x, a1, . . . , a`) ← AQ, where Q = (0, q1, . . . , q`). This would contradict the Ω-computational non-signaling soundness of the PCP.

Fix any q1, . . . , q` ∈ [L] and let Q = (0, q1, . . . , q`). The distribution A<sup>Q</sup> is defined as follows:

1. Sample (hkmeSSB,tdmeSSB) ← GenmeSSB(1<sup>κ</sup> , L, `,(q1, . . . , q`)).

- 2. Compute  $(x, rt) = \mathcal{P}^*(\mathsf{hk}_{\mathsf{meSSB}})$ .
- 3. Compute  $A = (a_1, \dots, a_\ell) = \mathsf{Invert}_{\mathsf{meSSB}}([\ell], \mathsf{td}_{\mathsf{meSSB}}, \mathsf{rt}).$
- 4. Output (x, A).

Our contradiction assumption immediately implies that Equation (5) holds. Thus it remains to argue that  $\{A_Q\}$  is a collection of  $\Omega$ -computationally non-signaling distributions.

Fix any  $q_1, \ldots, q_\ell \in [L]$  and  $q'_1, \ldots, q'_\ell \in [L]$ , and let  $J = \{j \in [\ell]: q_j = q'_j\}$ . Let

$$Q = (0, q_1, \dots, q_\ell)$$
 and  $Q' = (0, q'_1, \dots, q'_\ell),$ 

let

$$(x, a_1, \dots, a_\ell) \leftarrow \mathcal{A}_Q$$
 and  $(x', a_1', \dots, a_\ell') \leftarrow \mathcal{A}_{Q'}$ ,

and let

$$A_J = (a_j)_{j \in J}$$
 and  $A'_J = (a'_j)_{j \in J}$ .

We need to prove that the distributions  $(x, A_J)$  and  $(x', A'_J)$  are  $\Omega$ -indistinguishable.

Suppose otherwise, that there exists  $q_1,\ldots,q_\ell\in[L]$ ,  $q'_1,\ldots,q'_\ell\in[L]$  such that the corresponding distributions  $(x,A_J)$  and  $(x',A'_J)$  (as defined above) are not  $\Omega$ -indistinguishable. Namely, there exists a  $\operatorname{poly}(\Omega)$ -size distinguisher D and a non-negligible function  $\epsilon$  such that

$$|\Pr[D(x, A_J) = 1] - \Pr[D(x', A'_J) = 1]| \ge \epsilon(\Omega).$$

We will use this to break the  $\Omega'$ -index hiding of the meSSB hash. An adversary for the  $\Omega'$ -hiding of the meSSB hash picks the two sets of indices  $i^0 = (q_1, \ldots, q_\ell)$  and  $i^1 = (q'_1, \ldots, q'_\ell)$ . Then, given  $\mathsf{hk}_{\mathsf{meSSB}}$  generated by  $(\mathsf{hk}_{\mathsf{meSSB}}, \mathsf{td}_{\mathsf{meSSB}}) \leftarrow \mathsf{Gen}_{\mathsf{meSSB}}(1^\kappa, L, \ell, i^{(b)})$  and trapdoor information  $\mathsf{td}_{\mathsf{meSSB}}|_J$ , does the following:

- 1. Compute  $(x, rt) = \mathcal{P}^*(hk_{meSSB})$ .
- 2. Compute  $A_J'' = \mathsf{Invert}_{\mathsf{meSSB}}(J, \mathsf{td}_{\mathsf{meSSB}}|_J, \mathsf{rt})$ .
- 3. Output  $D(x, A_J'')$ .

Note that the distinguishing advantage of this adversary is the same as the distinguishing advantage of the D, which is  $\epsilon(\Omega)$ . This contradicts the  $\Omega$ -hiding of the meSSB hash family.