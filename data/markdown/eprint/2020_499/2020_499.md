# <span id="page-0-0"></span>Proof-Carrying Data from Accumulation Schemes

## Benedikt Bunz ¨

benedikt@cs.stanford.edu Stanford University

# Pratyush Mishra

pratyush@berkeley.edu UC Berkeley

## Alessandro Chiesa

alexch@berkeley.edu UC Berkeley

## Nicholas Spooner

nick.spooner@berkeley.edu UC Berkeley

May 25, 2020

### Abstract

Recursive proof composition has been shown to lead to powerful primitives such as incrementallyverifiable computation (IVC) and proof-carrying data (PCD). All existing approaches to recursive composition take a succinct non-interactive argument of knowledge (SNARK) and use it to prove a statement about its own verifier. This technique requires that the verifier run in time sublinear in the size of the statement it is checking, a strong requirement that restricts the class of SNARKs from which PCD can be built. This in turn restricts the efficiency and security properties of the resulting scheme.

Bowe, Grigg, and Hopwood (ePrint 2019/1021) outlined a novel approach to recursive composition, and applied it to a particular SNARK construction which does *not* have a sublinear-time verifier. However, they omit details about this approach and do not prove that it satisfies any security property. Nonetheless, schemes based on their ideas have already been implemented in software.

In this work we present a collection of results that establish the theoretical foundations for a generalization of the above approach. We define an *accumulation scheme* for a non-interactive argument, and show that this suffices to construct PCD, even if the argument itself does not have a sublinear-time verifier. Moreover we give constructions of accumulation schemes for SNARKs, which yield PCD schemes with novel efficiency and security features.

Keywords: succinct arguments; proof-carrying data; recursive proof composition

# Contents

| 1 | Introduction                                                     | 3  |
|---|------------------------------------------------------------------|----|
|   | 1.1<br>Our contributions<br>                                     | 3  |
|   | 1.2<br>Related work<br>                                          | 6  |
| 2 | Techniques                                                       | 8  |
|   | 2.1<br>PCD from arguments with accumulation schemes              | 8  |
|   | 2.2<br>Accumulation schemes<br>                                  | 10 |
|   | 2.3<br>Constructing arguments with accumulation schemes          | 11 |
|   | 2.4<br>Accumulation schemes for polynomial commitments<br>       | 12 |
|   |                                                                  |    |
| 3 | Preliminaries                                                    | 16 |
|   | 3.1<br>Non-interactive arguments in the ROM                      | 16 |
|   | 3.2<br>Proof-carrying data<br>                                   | 17 |
|   | 3.3<br>Instantiating the random oracle                           | 18 |
|   | 3.4<br>Post-quantum security<br>                                 | 18 |
|   | 3.5<br>Commitment schemes                                        | 19 |
|   | 3.6<br>Polynomial commitments                                    | 20 |
| 4 | Accumulation schemes                                             | 22 |
|   | 4.1<br>Definition<br>                                            | 22 |
|   | 4.2<br>Accumulation schemes for certain predicates<br>           | 23 |
|   |                                                                  |    |
| 5 | Proof-carrying data from accumulation schemes                    | 24 |
|   | 5.1<br>Construction                                              | 25 |
|   | 5.2<br>Efficiency<br>                                            | 26 |
|   | 5.3<br>Completeness                                              | 27 |
|   | 5.4<br>Knowledge soundness                                       | 27 |
|   | 5.5<br>Zero knowledge                                            | 29 |
|   | 5.6<br>Post-quantum security<br>                                 | 29 |
|   |                                                                  |    |
| 6 | Accumulation schemes for non-interactive arguments               | 31 |
|   | 6.1<br>Construction                                              | 32 |
|   | 6.2<br>Completeness                                              | 32 |
|   | 6.3<br>Soundness                                                 | 33 |
|   | 6.4<br>Zero knowledge                                            | 34 |
| 7 | Accumulating polynomial commitments based on discrete logarithms | 36 |
|   | 7.1<br>Construction                                              | 36 |
|   | 7.2<br>Proof of Theorem 7.1                                      | 37 |
|   |                                                                  |    |
| 8 | Accumulating polynomial commitments based on bilinear groups     | 42 |
|   | 8.1<br>Construction                                              | 42 |
|   | 8.2<br>Proof of Theorem 8.1                                      | 43 |
|   |                                                                  |    |
| A | Construction of PCDL                                             | 48 |
|   | A.1<br>Pedersen commitments<br>                                  | 48 |
|   | A.2<br>Construction                                              | 48 |
|   | A.3<br>Security<br>                                              | 50 |
|   | Acknowledgements                                                 | 52 |
|   | References                                                       | 52 |
|   |                                                                  |    |

# <span id="page-2-0"></span>1 Introduction

*Proof-carrying data* (PCD) [\[CT10\]](#page-52-0) is a cryptographic primitive that enables mutually distrustful parties to perform distributed computations that run indefinitely, while ensuring that every intermediate state of the computation can be succinctly verified. PCD supports computations defined on (possibly infinite) directed acyclic graphs, with messages passed along directed edges. Verification is facilitated by attaching to each message a succinct proof of correctness. This is a generalization of the notion of *incrementally-verifiable computation* (IVC) due to [\[Val08\]](#page-53-0), which can be viewed as PCD for the path graph (i.e., for automata). PCD has found applications in enforcing language semantics [\[CTV13\]](#page-52-1), verifiable MapReduce computations [\[CTV15\]](#page-52-2), image authentication [\[NT16\]](#page-53-1), succinct blockchains [\[Co17;](#page-52-3) [KB20;](#page-52-4) [BMRS20\]](#page-51-2), and others.

Recursive composition. Prior to this work, the only known method for constructing PCD was from *recursive composition* of succinct non-interactive arguments (SNARGs) [\[BCCT13;](#page-51-3) [BCTV14;](#page-51-4) [COS20\]](#page-52-5). This method informally works as follows. A proof that the computation was executed correctly for t steps consists of a proof of the claim "the t-th step of the computation was executed correctly, and there exists a proof that the computation was executed correctly for t − 1 steps". The latter part of the claim is expressed using the SNARG verifier itself. This construction yields secure PCD (with IVC as a special case) provided the SNARG satisfies an adaptive knowledge soundness property (i.e., is a SNARK). The efficiency and security properties of the resulting PCD scheme correspond to those of a single invocation of the SNARK.

Limitations of recursion. Recursion as realized in prior work requires proving a statement that contains a description of the SNARK verifier. In particular, for efficiency, we must ensure that the statement we are proving (essentially) *does not grow* with the number of recursion steps t. For example, if the representation of the verifier were to grow even *linearly* with the statement it is verifying, then the size of the statement to be checked would grow *exponentially* in t. Therefore, prior works have achieved efficiency by focusing on SNARKs which admit sublinear-time verification: either SNARKs for machine computations [\[BCCT13\]](#page-51-3) or preprocessing SNARKs for circuit computations [\[BCTV14;](#page-51-4) [COS20\]](#page-52-5). Requiring sublinear-time verification significantly restricts our choice of SNARK, which limits what we can achieve for PCD.

In addition to the above asymptotic considerations, recursion raises additional considerations concerning concrete efficiency. All SNARK constructions require that statements be encoded as instances of some particular (algebraic) NP-complete problem, and difficulties often arise when encoding the SNARK verifier itself as such an instance. The most well-known example of this is in recursive composition of pairing-based SNARKs, since the verifier performs operations over a finite field that is necessarily different from the field supported "natively" by the NP-complete problem [\[BCTV14\]](#page-51-4). This type of problem also appears when recursing SNARKs whose verifiers make heavy use of cryptographic hash functions [\[COS20\]](#page-52-5).

A new technique. Bowe, Grigg, and Hopwood [\[BGH19\]](#page-51-5) suggest an exciting novel approach to recursive composition that replaces the SNARK verifier in the circuit with a simpler algorithm. This algorithm does not itself verify the previous proof πt−1. Instead, it adds the proof to an *accumulator* for verification at the end. The accumulator must not grow in size. A key contribution of [\[BGH19\]](#page-51-5) is to sketch a mechanism by which this might be achieved for a particular SNARK construction. While they prove this SNARK construction secure, they do not include definitions or proofs of security for their recursive technique. Nonetheless, practitioners have already built software based on these ideas [\[Halo19;](#page-52-6) [Pickles20\]](#page-53-2).

## <span id="page-2-1"></span>1.1 Our contributions

In this work we provide a collection of results that establish the theoretical foundations for the above approach. We introduce the cryptographic object, an *accumulation scheme*, that enables this technique, and prove that it

suffices for constructing PCD. We then provide generic tools for building accumulation schemes, as well as several concrete instantiations. Our framework establishes the security of schemes that are already being used by practitioners, and we believe that it will simplify and facilitate further research in this area.

Accumulation schemes. We introduce the notion of an *accumulation scheme* for a predicate Φ: X → {0, 1}. This formalizes, and generalizes, an idea outlined in [\[BGH19\]](#page-51-5). An accumulation scheme is best understood in the context of the following process. Consider an infinite stream q1, q2, . . . with each q<sup>i</sup> ∈ X. We augment this stream with *accumulators* acc<sup>i</sup> as follows: at time i, the *accumulation prover* receives (q<sup>i</sup> , acci−1) and computes acc<sup>i</sup> ; the *accumulation verifier* receives (q<sup>i</sup> , acci−1, acci) and checks that acci−<sup>1</sup> and q<sup>i</sup> were correctly accumulated into acc<sup>i</sup> (if not, the process ends). Then at any time t, the *decider* can validate acc<sup>t</sup> , which establishes that, for *all* i ∈ [t], Φ(qi) = 1. All three algorithms are stateless. To avoid trivial constructions, we want (i) the accumulation verifier to be more efficient than Φ, and (ii) the size of an accumulator (and hence the running time of the three algorithms) does not grow over time. Accumulation schemes are powerful, as we demonstrate next.

Recursion from accumulation. We say that a SNARK has an accumulation scheme if the predicate corresponding to its verifier has an accumulation scheme (so X is a set of instance-proof pairs). We show that any SNARK having an accumulation scheme where the *accumulation verifier* is sublinear can be used to build a proof-carrying data (PCD) scheme, *even if the SNARK verifier is not itself sublinear*. This broadens the class of SNARKs from which PCD can be built. Similarly to [\[COS20\]](#page-52-5), we show that if the SNARK and accumulation scheme are post-quantum secure, so is the PCD scheme. (Though it remains an open question whether there are non-trivial accumulation schemes for post-quantum SNARKs.)

<span id="page-3-0"></span>Theorem 1 (informal). *There is an efficient transformation that compiles any SNARK with an efficient accumulation scheme into a PCD scheme. If the SNARK and its accumulation scheme are zero knowledge, then the PCD scheme is also zero knowledge. Additionally, if the SNARK and its accumulation scheme are post-quantum secure then the PCD scheme is also post-quantum secure.*

The above theorem holds in the standard model (where all parties have access to a common reference string, but no oracles). Since our construction makes non-black-box use of the accumulation scheme verifier, the theorem does not carry over to the random oracle model (ROM). It remains an intriguing open problem to determine whether or not SNARKs in the ROM imply PCD in the ROM (and if the latter is even possible).

Note that we require a suitable definition of zero knowledge for an accumulation scheme. This is not trivial, and our definition is informed by what is required for Theorem [1](#page-3-0) and what our constructions achieve.

Proof-carrying data is a powerful primitive: it implies IVC and, further assuming collision-resistant hash functions, also efficient SNARKs for machine computations. Hence, Theorem [1](#page-3-0) may be viewed as an extension of the "bootstrapping" theorem of [\[BCCT13\]](#page-51-3) to certain non-succinct-verifier SNARKs.

See Section [2.1](#page-7-1) for a summary of the ideas behind Theorem [1,](#page-3-0) and Section [5](#page-23-0) for technical details.

Accumulation from accumulation. Given the above, a natural question is: where do accumulation schemes for SNARKs come from? In [\[BGH19\]](#page-51-5) it was informally observed that a specific SNARK construction, based on the hardness of the discrete logarithm problem, has an accumulation scheme. To show this, [\[BGH19\]](#page-51-5) first observe that the verifier in the SNARK construction is sublinear *except for* the evaluation of a certain predicate (checking an opening of a polynomial commitment [\[KZG10\]](#page-52-7)), then outline a construction which is essentially an accumulation scheme for that predicate.

We prove that this idea is a special case of a general paradigm for building accumulation schemes for SNARKs.

<span id="page-3-1"></span>Theorem 2 (informal). *There is an efficient transformation that, given a SNARK whose verifier is succinct when given oracle access to a "simpler" predicate, and an accumulation scheme for that predicate, constructs* *an accumulation scheme for the SNARK. Moreover, this transformation preserves zero knowledge and postquantum security of the accumulation scheme.*

The construction underlying Theorem [2](#page-3-1) is black-box. In particular, if both the SNARK and the accumulation scheme for the predicate are secure with respect to an oracle, then the resulting accumulation scheme for the SNARK is secure with respect to that oracle.

See Section [2.3](#page-10-0) for a summary of the ideas behind Theorem [2,](#page-3-1) and Section [6](#page-30-0) for technical details.

Accumulating polynomial commitments. Several works [\[MBKM19;](#page-52-8) [GWC19;](#page-52-9) [CHMMVW20\]](#page-52-10) have constructed SNARKs whose verifiers are succinct relative to a specific predicate: checking the opening of a *polynomial commitment* [\[KZG10\]](#page-52-7). We prove that two natural polynomial commitment schemes possess accumulation schemes in the random oracle model: PCDL, a scheme based on the security of discrete logarithms [\[BCCGP16;](#page-51-6) [BBBPWM18;](#page-51-7) [WTSTW18\]](#page-53-3); and PCAGM, a scheme based on knowledge assumptions in bilinear groups [\[KZG10;](#page-52-7) [CHMMVW20\]](#page-52-10).

<span id="page-4-0"></span>Theorem 3 (informal). *In the random oracle model, there exist (zero knowledge) accumulation schemes for* PCDL *and* PCAGM *that achieve the efficiency outlined in the table below (*n *denotes the number of evaluation proofs, and* d *denotes the degree of committed polynomials).*

| polynomial<br>commitment | assumption | cost to check<br>evaluation proofs | cost to check an<br>accumulation step | cost to check<br>final accumulator | accumulator<br>size |
|--------------------------|------------|------------------------------------|---------------------------------------|------------------------------------|---------------------|
| PCDL                     | DLOG + RO  | Θ(nd) G<br>mults.                  | Θ(n log d) G<br>mults.                | Θ(d) G<br>mults.                   | Θ(log d) G          |
| PCAGM                    | AGM + RO   | Θ(n) pairings                      | Θ(n) G1<br>mults.                     | 1 pairing                          | 2 G1                |

For both schemes the cost of checking that an accumulation step was performed correctly is *much less* than the cost of checking an evaluation proof. We can apply Theorem [2](#page-3-1) to combine either of these accumulation schemes for polynomial commitments with any of the aforementioned predicate-efficient SNARKs, which yields concrete accumulation schemes for these SNARKs with the same efficiency benefits.

We remark that our accumulation scheme for PCDL is a variation of a construction presented in [\[BGH19\]](#page-51-5), and so our result establishes the security of a type of construction used by practitioners.

We sketch the constructions underlying Theorem [3](#page-4-0) in Section [2.4,](#page-11-0) and provide details in Sections [7](#page-35-0) and [8.](#page-41-0) New constructions of PCD. By combining our results, we (heuristically) obtain constructions of PCD that achieve new properties. Namely, starting from either PCDL or PCAGM, we can apply Theorem [2](#page-3-1) to a suitable SNARK to obtain a SNARK with an accumulation scheme in the random oracle model. Then we can instantiate the random oracle, obtaining a SNARK and accumulation scheme with *heuristic* security in the standard (CRS) model, to which we apply Theorem [1](#page-3-0) to obtain a corresponding PCD scheme. Depending on whether we started with PCDL or PCAGM, we get a PCD scheme with different features, as summarized below.

- *From* PCDL*: PCD based on discrete logarithms.* We obtain a PCD scheme in the *uniform reference string* model (i.e., without secret parameters) and small argument sizes. In contrast, prior PCD schemes require structured reference strings [\[BCTV14\]](#page-51-4) or have larger argument sizes [\[COS20\]](#page-52-5). Moreover, our PCD scheme can be efficiently instantiated from any cycle of elliptic curves [\[SS11\]](#page-53-4). In contrast, prior PCD schemes with small argument size use cycles of pairing-friendly elliptic curves [\[BCTV14;](#page-51-4) [CCW19\]](#page-52-11), which are more expensive.
- *From* PCAGM*: lightweight PCD based on bilinear groups.* The recursive statement inside this PCD scheme does not involve checking any pairing computations, because pairings are deferred to a verification that occurs *outside* the recursive statement. In contrast, the recursive statements in prior PCD schemes based on pairing-based SNARKs were more expensive because they checked pairing computations [\[BCTV14\]](#page-51-4).

Note again that our constructions of PCD are *heuristic* as they involve instantiating the random oracle of certain SNARK constructions with an appropriate hash function. This is because Theorem [3](#page-4-0) is proven in the random oracle model, but Theorem [1](#page-3-0) is explicitly *not* (as is the case for all prior IVC/PCD constructions [\[Val08;](#page-53-0) [BCCT13;](#page-51-3) [BCTV14;](#page-51-4) [COS20\]](#page-52-5)). There is evidence that this limitation might be inherent [\[CL20\]](#page-52-12).

Open problem: accumulation in the standard model. All known constructions of accumulation schemes for non-interactive arguments make use of either random oracles (as in our constructions) or knowledge assumptions (e.g., the "trivial" construction from succinct-verifier SNARKs). A natural question, then, is whether there exist constructions of accumulation schemes for non-interactive arguments, or any other interesting predicate, from standard assumptions, or any assumptions which are not known to imply SNARKs. A related question is whether there is a black-box impossibility for accumulation schemes similar to the result for SNARGs of [\[GW11\]](#page-52-13).

## <span id="page-5-0"></span>1.2 Related work

Below we survey prior constructions of IVC/PCD.

PCD from SNARKs. Bitansky, Canetti, Chiesa, and Tromer [\[BCCT13\]](#page-51-3) proved that recursive composition of SNARKs for machine computations implies PCD for constant-depth graphs, and that this in turn implies IVC for polynomial-time machine computations. From the perspective of concrete efficiency, however, one can achieve more efficient recursive composition by using *preprocessing* SNARKs for circuits rather than SNARKs for machines [\[BCTV14;](#page-51-4) [COS20\]](#page-52-5); this observation has led to real-world applications [\[Co17;](#page-52-3) [BMRS20\]](#page-51-2). The features of the PCD scheme obtained from recursion depends on the features of the underlying preprocessing SNARK. Below we summarize the features of the two known constructions.

- *PCD from pairing-based SNARKs.* Ben-Sasson, Chiesa, Tromer, and Virza [\[BCTV14\]](#page-51-4) used pairing-based SNARKs with a special algebraic property to achieve efficient recursive composition with very small argument sizes (linear in the security parameter λ). The use of pairing-based SNARKs has two main downsides. First, they require sampling a *structured reference string* involving secret values ("toxic waste") that, if revealed, compromise security. Second, the verifier performs operations over a finite field that is necessarily different from the field supported "natively" by the statement it is checking. To avoid expensive simulation of field arithmetic, the construction uses *pairing-friendly cycles of elliptic curves*, which severely restricts the choice of field in applications and requires a large base field for security.
- *PCD from IOP-based SNARKs.* Chiesa, Ojha, and Spooner [\[COS20\]](#page-52-5) used a holographic IOP to construct a preprocessing SNARK that is unconditionally secure in the (quantum) random oracle model, which heuristically implies a post-quantum preprocessing SNARK in the *uniform reference string* model (i.e., without toxic waste). They then proved that any post-quantum SNARK leads to a post-quantum PCD scheme via recursive composition. The downside of this construction is that, given known holographic IOPs, the argument size is larger, currently at O(λ 2 log<sup>2</sup> N) bits for circuits of size N.

IVC from homomorphic encryption. Naor, Paneth, and Rothblum [\[NPR19\]](#page-52-14) obtain a notion of IVC by using somewhat homomorphic encryption and an information-theoretic object called an "incremental PCP". The key feature of their scheme is that security holds under falsifiable assumptions.

There are two drawbacks, however, that restrict the use of the notion of IVC that their scheme achieves. First, the computation to be verified must be *deterministic* (this appears necessary for schemes based on falsifiable assumptions given known impossibility results [\[GW11\]](#page-52-13)). Second, and more subtly, completeness holds only in the case where intermediate proofs were honestly generated. This means that the following attack may be possible: an adversary provides an intermediate proof that verifies, but it is impossible for honest parties to generate new proofs for subsequent computations. Our construction of PCD achieves the stronger condition that completeness holds so long as intermediate proofs verify, ruling out this attack.

Both nondeterministic computation and the stronger completeness notion (achieved by all SNARK-based PCD schemes) are necessary for many of the applications of IVC/PCD.

# <span id="page-7-0"></span>2 Techniques

## <span id="page-7-1"></span>2.1 PCD from arguments with accumulation schemes

We summarize the main ideas behind Theorem [1,](#page-3-0) which obtains proof-carrying data (PCD) from any succinct non-interactive argument of knowledge (SNARK) that has an accumulation scheme. For the sake of exposition, in this section we focus on the special case of IVC, which can be viewed as repeated application of a circuit F. Specifically, we wish to check a claim of the form "F T (z0) = z<sup>T</sup> " where F <sup>T</sup> denotes F composed with itself T times.

Prior work: recursion from succinct verification. Recall that in previous approaches to efficient recursive composition [\[BCTV14;](#page-51-4) [COS20\]](#page-52-5), at each step i we prove a claim of the form "z<sup>i</sup> = F(zi−1), and there exists a proof πi−<sup>1</sup> that attests to the correctness of zi−1". This claim is expressed using a circuit R which is the conjunction of F with a circuit representing the SNARK verifier; in particular, the size of the claim is at least the size of the verifier circuit. If the size of the verifier circuit grows linearly (or more) with the size of the claim being checked, then verifying the final proof becomes more costly than the original computation.

For this reason, these works focus on SNARKs with *succinct verification*, where the verifier runs in time *sublinear* in the size of the claim. In this case, the size of the claim essentially *does not grow* with the number of recursive steps, and so checking the final proof costs roughly the same as checking a single step.

Succinct verification is a seemingly paradoxical requirement: the verifier does not even have time to *read* the circuit R. One way to sidestep this issue is *preprocessing*: one designs an algorithm that, at the beginning of the recursion, computes a small cryptographic digest of R, which the recursive verifier can use instead of reading R directly. Because this preprocessing need only be performed once for the given R in an offline phase, it has almost no effect on the performance of each recursive step (in the later online phase).

A new paradigm: IVC from accumulation. Even allowing for preprocessing, succinct verification remains a strong requirement, and there are many SNARKs that are not known to satisfy it (e.g., [\[BCCGP16;](#page-51-6) [BBBPWM18;](#page-51-7) [AHIV17;](#page-51-8) [BCGGHJ17;](#page-51-9) [BCRSVW19\]](#page-51-10)). Bowe, Grigg, and Hopwood [\[BGH19\]](#page-51-5) suggested a further relaxation of succinctness that appears to still suffice for recursive composition: a type of "postprocessing". Their observation is as follows: if a SNARK is such that we can efficiently "defer" the verification of a claim in a way that does not grow in cost with the number of claims to be checked, then we can hope to achieve recursive composition by deferring the verification of all claims to the end.

In the remainder of this section, we will give an overview of the proof of Theorem [1,](#page-3-0) our construction of PCD from SNARKs that have this "post-processing" property. We note that this relaxation of requirements is useful because, as suggested in [\[BGH19\]](#page-51-5), it leads to new constructions of PCD with desirable properties (see discussion at the end of Section [1.1\)](#page-2-1). In fact, some of these efficiency features are already being exploited by practitioners working on recursing SNARKs [\[Halo19;](#page-52-6) [Pickles20\]](#page-53-2).

The specific property we require, which we discuss more formally in the next section, is that the SNARK has an *accumulation scheme*. This is a generalization of the idea described in [\[BGH19\]](#page-51-5). Informally, an accumulation scheme consists of three algorithms: an accumulation prover, an accumulation verifier, and a decider. The accumulation prover is tasked with taking an instance-proof pair (z, π) and a previous accumulator acc, and producing a new accumulator acc? that "includes" the new instance. The accumulation verifier, given ((z, π), acc, acc? ), checks that acc? was computed correctly (i.e., that it accumulates (z, π)) into acc). Finally the decider, given a single accumulator acc, performs a single check that simultaneously ensures that *every* instance-proof pair accumulated in acc verifies.[1](#page-0-0)

<sup>1</sup>We remark that the notion of an accumulation scheme is *distinct* from the notion of a cryptographic accumulator for a set (e.g., an RSA accumulator), which provides a succinct representation of a large set while supporting membership queries.

Given such an accumulation scheme, we can construct IVC as follows. Given a previous instance z<sup>i</sup> , proof πi , and accumulator acc<sup>i</sup> , the IVC prover first accumulates (z<sup>i</sup> , πi) with acc<sup>i</sup> to obtain a new accumulator acci+1. The IVC prover also generates a SNARK proof πi+1 of the claim: "zi+1 = F(zi), and there exist a proof π<sup>i</sup> and an accumulator acc<sup>i</sup> such that the accumulation verifier accepts ((z<sup>i</sup> , πi), acc<sup>i</sup> , acci+1)", expressed as a circuit R. The final IVC proof then consists of (π<sup>T</sup> , acc<sup>T</sup> ). The IVC verifier checks such a proof by running the SNARK verifier on π<sup>T</sup> and the accumulation scheme decider on acc<sup>T</sup> .

Why does this achieve IVC? Throughout the computation we maintain the invariant that if acc<sup>i</sup> is a valid accumulator (according to the decider) and π<sup>i</sup> is a valid proof, then the computation is correct up to the i-th step. Clearly if this holds at time T then the IVC verifier successfully checks the entire computation. Observe that if we were able to prove that "zi+1 = F(zi), π<sup>i</sup> is a valid proof, and acc<sup>i</sup> is a valid accumulator", by applying the invariant we would be able to conclude that the computation is correct up to step i + 1. Unfortunately we are not able to prove this directly, for two reasons: (i) proving that π<sup>i</sup> is a valid proof requires proving a statement about the argument verifier, which may not be sublinear, and (ii) proving that acc<sup>i</sup> is a valid accumulator requires proving a statement about the decider, which may not be sublinear.

Instead of proving this claim directly, we "defer" it by having the prover accumulate (z<sup>i</sup> , πi) into acc<sup>i</sup> to obtain a new accumulator acci+1. The soundness property of the accumulation scheme ensures that if acci+1 is valid and the accumulation verifier accepts ((z<sup>i</sup> , πi), acc<sup>i</sup> , acci+1), then π<sup>i</sup> is a valid proof and acc<sup>i</sup> is a valid accumulator. Thus all that remains to maintain the invariant is for the prover to prove that the accumulation verifier accepts; this is possible provided that the *accumulation verifier* is sublinear.

From sketch to proof. In Section [5,](#page-23-0) we give the formal details of our construction and a proof of correctness. In particular, we show how to construct PCD, a more general primitive than IVC. In the PCD setting, rather than each computation step having a single input z<sup>i</sup> , it receives m inputs from different nodes. Proving correctness hence requires proving that *all* of these inputs were computed correctly. For our construction, this entails checking m proofs and m accumulators. To do this, we extend the definition of an accumulation scheme to allow accumulating multiple instance-proof pairs and multiple "old" accumulators.

We now informally discuss the properties of our PCD construction.

- *Efficiency requirements.* Observe that the statement to be proved includes only the *accumulation verifier*, and so the *only* efficiency requirement for obtaining PCD is that this algorithm run in time sublinear in the size of the circuit R. This implies, in particular, that an accumulator must be of size sublinear in the size of R, and hence must not grow with each accumulation step. The SNARK verifier and the decider algorithm need only be efficient in the usual sense (i.e., polynomial-time). See Section [5.2](#page-25-0) for a detailed analysis.
- *Soundness.* We prove that the PCD scheme is sound provided that the SNARK is knowledge sound (i.e., is an adaptively-secure argument of knowledge) and the accumulation scheme is sound (see Section [2.2](#page-9-0) for more on what this means). We stress that in both cases security should be in the standard (CRS) model, without any random oracles (as in prior PCD constructions). See Section [5.4](#page-26-1) for details.
- *Zero knowledge.* We prove that the PCD scheme is zero knowledge, if the underlying SNARK and accumulation scheme are both zero knowledge (for this part we also formulate a suitable notion of zero knowledge for accumulation schemes as discussed shortly in Section [2.2\)](#page-9-0). See Section [5.5](#page-28-0) for details.
- *Post-quantum security.* We also prove that if both the SNARK and accumulation scheme are *post-quantum* secure, then so is the resulting PCD scheme. Here by post-quantum secure we mean that the relevant security properties continue to hold even against polynomial-size *quantum* circuits, as opposed to just polynomial-size *classical* circuits. See Section [5.6](#page-28-1) for details.

## <span id="page-9-0"></span>2.2 Accumulation schemes

A significant contribution of this work is formulating a general notion of an accumulation scheme. An accumulation scheme for a non-interactive argument as described above is a particular instance of this definition; in subsequent sections we will apply the definition in other settings.

We first give an informal definition that captures the key features of an accumulation scheme. For clarity this is stated for the (minimal) case of a single predicate input q and a single "old" accumulator acc; we later extend this in the natural way to n predicate inputs and m "old" accumulators.

<span id="page-9-1"></span>Definition 2.1 (informal). *An* accumulation scheme *for a predicate* Φ: X → {0, 1} *consists of a triple of algorithms* (P, V, D)*, known as the prover, verifier, and decider, that satisfies the following properties.*

- Completeness: *For all accumulators* acc *and predicate inputs* q ∈ X*, if* D(acc) = 1 *and* Φ(q) = 1*, then for* acc? ← P(acc, q) *it holds that* V(acc, q, acc? ) = 1 *and* D(acc? ) = 1*.*
- Soundness: *For all efficiently-generated accumulators* acc, acc? *and predicate inputs* q ∈ X*, if* D(acc? ) = 1 *and* V(acc, q, acc? ) = 1 *then, with all but negligible probability,* Φ(q) = 1 *and* D(acc) = 1*.*

An accumulation scheme for a SNARK is an accumulation scheme for the predicate induced by the argument verifier; in this case the predicate input q consists of an instance-proof pair (x, π). Note that the completeness requirement does not place any restriction on how the previous accumulator acc is generated; we require that completeness holds for any acc the decider D determines to be valid, and any q for which the predicate Φ holds. This is needed to obtain a similarly strong notion of completeness for PCD, required for applications where accumulation is done by multiple parties that do not trust one another.

Zero knowledge. For our PCD application, the notion of zero knowledge for an accumulation scheme that we use is the following: one can sample a "fake" accumulator that is indistinguishable from a real accumulator acc? , *without knowing anything* about the old accumulator acc and predicate input q that were accumulated in acc? . The existence of the accumulation verifier V complicates matters here: if the adversary knows acc and q, then it is easy to distinguish a real accumulator from a fake one using V. We resolve this issue by modifying Definition [2.1](#page-9-1) to have the accumulation prover P produce a *verification proof* π<sup>V</sup> in addition to the new accumulator acc? . Then V uses π<sup>V</sup> in verifying the accumulator, but π<sup>V</sup> is *not* required for subsequent accumulation. In our application, the simulator then does *not* have to simulate πV. This avoids the problem described: even if the adversary knows acc and q, unless π<sup>V</sup> is correct, V can simply reject, as it would for a "fake" accumulator. Our informal definition is as follows.

Definition 2.2. *An accumulation scheme for* Φ *is* zero knowledge *if there exists an efficient simulator* S *such that for all accumulators* acc *and inputs* q ∈ X *such that* D(acc) = 1 *and* Φ(q) = 1*, the distribution of* acc? *when* (acc? , πV) ← P(acc, q) *is computationally indistinguishable from* acc? ← S(1<sup>λ</sup> )*.*

Predicate specification. The above informal definitions omit many important details; we now highlight some of these. Suppose that, as required for IVC/PCD, we have some fixed circuit R for which we want to accumulate pairs (x<sup>i</sup> , πi), where π<sup>i</sup> is a SNARK proof that there exists w<sup>i</sup> such that R(x<sup>i</sup> , wi) = 1. In this case the predicate corresponding to the verifier depends not only on the pair (x<sup>i</sup> , πi), but also on the circuit R, as well as the public parameters of the argument scheme pp and (often) a random oracle ρ.

Moreover, each of these inputs has different security and efficiency considerations. The security of the SNARK (and the accumulation scheme) can only be guaranteed with high probability over public parameters drawn by the generator algorithm of the SNARK, and over the random oracle. The circuit R may be chosen adversarially, but cannot be part of the input q because it is too large; it must be fixed at the beginning.

These considerations lead us to define an accumulation scheme with respect to both a predicate Φ: U(∗)× ({0, 1} ∗ ) <sup>3</sup> → {0, 1} and a *predicate-specification algorithm* H. We then adapt Definition [2.1](#page-9-1) to hold for the predicate  $\Phi(\rho, \mathsf{pp}_\Phi, \mathsf{i}_\Phi, \cdot)$  where  $\rho$  is a random oracle,  $\mathsf{pp}_\Phi$  is output by  $\mathcal{H}^\rho$ , and  $\mathsf{i}_\Phi$  is chosen adversarially. In our SNARK example,  $\mathcal{H}$  is equal to the SNARK generator,  $\mathsf{i}_\Phi$  is the circuit R, and  $\Phi(\rho, \mathsf{pp}, R, (\mathbb{x}, \pi)) = \mathcal{V}^\rho(\mathsf{pp}, R, \mathbb{x}, \pi)$ . For a more precise description, see Section 4.

**Remark 2.3** (helped verification). We compare accumulation schemes for SNARKs with the notion of "helped verification" [MBKM19]. In a SNARK with helped verification, an untrusted party known as the *helper* can, given n proofs, produce an auxiliary proof that enables checking the n proofs at lower cost than that of checking each proof individually. This batching capability can be viewed as a special case of accumulation, as it applies to n "fresh" proofs only; there is no notion of batching "old" accumulators. It is unclear whether the weaker notion of helped verification alone suffices to construct IVC/PCD schemes.

## <span id="page-10-0"></span>2.3 Constructing arguments with accumulation schemes

A key ingredient in our construction of PCD is a SNARK that has an accumulation scheme (see Section 2.1). Below we summarize the ideas behind Theorem 2, by explaining how to construct accumulation schemes for SNARKs whose verifier is succinct relative to an oracle predicate  $\Phi_{\circ}$  that itself has an accumulation scheme.

**Predicate-efficient SNARKs.** We call a SNARK ARG for *predicate-efficient* with respect to a predicate  $\Phi_{\circ}$  if its verifier  $\mathcal{V}$  operates as follows: (i) run a fast "inner" verifier  $\mathcal{V}_{pe}$  to produce a bit b and query set Q; (ii) accept iff b=1 and for all  $q\in Q$ ,  $\Phi_{\circ}(q)=1$ . In essence,  $\mathcal{V}$  can be viewed as a circuit with "oracle gates" for  $\Phi_{\circ}$ . The aim is for  $\mathcal{V}_{pe}$  to be significantly more efficient than  $\mathcal{V}$ ; that is, the queries to  $\Phi_{\circ}$  capture the "expensive" part of the computation of  $\mathcal{V}$ .

As noted in Section 1.1, one can view recent SNARK constructions [MBKM19; GWC19; CHMMVW20] as being predicate-efficient with respect to a "polynomial commitment" predicate. We discuss how to construct accumulation schemes for these predicates below in Section 2.4.

Accumulation scheme for predicate-efficient SNARKs. Let ARG be a SNARK that is predicate-efficient with respect to a predicate  $\Phi_o$ , and let  $\mathsf{AS}_o$  be an accumulation scheme for  $\Phi_o$ . To check n proofs, instead of directly invoking the SNARK verifier  $\mathcal{V}$ , we can first run  $\mathcal{V}_{\mathsf{pe}}$  n times to generate n query sets for  $\Phi_o$ , and then, instead of invoking  $\Phi_o$  on each of these sets, we can accumulate these queries using  $\mathsf{AS}_o$ . Below we sketch the construction of an accumulation scheme  $\mathsf{AS}_{\mathsf{ARG}}$  for ARG based on this idea.

To accumulate n instance-proof pairs  $[(\mathbf{x}_i, \pi_i)]_{i=1}^n$  starting from an old accumulator acc, the accumulation prover  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{P}$  first invokes the inner verifier  $\mathcal{V}_{\mathsf{pe}}$  on each  $(\mathbf{x}_i, \pi_i)$  to generate a query set  $Q_i$  for  $\Phi_\circ$ , accumulates their union  $Q = \cup_{i=1}^n Q_i$  into acc using  $\mathsf{AS}_\circ.\mathsf{P}$ , and finally outputs the resulting accumulator acc\*. To check that acc\* indeed accumulates  $[(\mathbf{x}_i, \pi_i)]_{i=1}^n$  into acc, the accumulation verifier  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}$  first checks, for each i, whether the inner verifier  $\mathcal{V}_{\mathsf{pe}}$  accepts  $(\mathbf{x}_i, \pi_i)$ , and then invokes  $\mathsf{AS}_\circ.\mathsf{V}$  to check whether acc\* correctly accumulates the query set  $Q = \bigcup_{i=1}^n Q_i$ . Finally, to decide whether acc\* is a valid accumulator, the accumulation scheme decider  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{D}$  simply invokes  $\mathsf{AS}_\circ.\mathsf{D}$ .

From sketch to proof. The foregoing sketch omits details required to construct a scheme that satisfies the "full" definition of accumulation schemes as stated in Section 4. For instance, as noted in Section 2.3, the predicate  $\Phi_{\circ}$  may be be an oracle predicate, and could depend on the public parameters of the SNARK ARG. We handle this by requiring that the accumulation scheme for  $\Phi_{\circ}$  uses the SNARK generator  $\mathcal G$  as its predicate specification algorithm. We also show that zero knowledge and post-quantum security are preserved. See Section 6 for a formal treatment of these issues, along with security proofs.

From predicate-efficient SNARKs to PCD. In order to build an accumulation scheme  $AS_{ARG}$  that suffices for PCD, ARG and  $AS_{\circ}$  must satisfy certain efficiency properties. In particular, when verifying satisfiability

<sup>&</sup>lt;sup>2</sup>This is not precisely the case, because the verifier is required to reject immediately if it ever makes a query q with  $\Phi_{\circ}(q) = 0$ .

for a circuit of size N, the running time of  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}$  must be sublinear in N, which means in turn that the running times of  $\mathcal{V}_{\mathsf{pe}}$  and  $\mathsf{AS}_{\circ}.\mathsf{V}$ , as well as the size of the query set Q, must be sublinear in N. Crucially, however,  $\mathsf{AS}_{\circ}.\mathsf{D}$  need only run in time polynomial in N. For further discussion, see Remark 6.3.

## <span id="page-11-0"></span>2.4 Accumulation schemes for polynomial commitments

As noted in Section 2.3, several SNARK constructions (e.g., [MBKM19; GWC19; CHMMVW20]) are predicate-efficient with respect to an underlying *polynomial commitment*, which means that constructing an accumulation scheme for the latter leads (via Theorem 2) to an accumulation scheme for the whole SNARK.

Informally, a polynomial commitment scheme (PC scheme) is a cryptographic primitive that enables one to produce a commitment C to a polynomial p, and then to prove that this committed polynomial evaluates to a claimed value v at a desired point z. (See Section 3.6 for a definition.) An accumulation scheme for a PC scheme thus accumulates claims of the form "C commits to p such that p(z) = v" for arbitrary polynomials p and evaluation points z.

In this section, we explain the ideas behind Theorem 3, by sketching how to construct (zero knowledge) accumulation schemes for two popular (hiding) polynomial commitment schemes.

- In Section 2.4.1, we sketch our accumulation scheme for PC<sub>DL</sub>, a polynomial commitment scheme derived from [BCCGP16; BBBPWM18; WTSTW18] that is based on the hardness of discrete logarithms.
- In Section 2.4.2, we sketch our accumulation scheme for PC<sub>AGM</sub>, a polynomial commitment scheme based on knowledge assumptions over bilinear groups [KZG10; CHMMVW20].

In each case, the running time of the accumulation verifier will be sublinear in the degree of the polynomial, and the accumulator itself will not grow with the number of accumulation steps. This allows the schemes to be used, in conjunction with a suitable predicate-efficient SNARK, to construct PCD.

We remark that each of our accumulation schemes is proved secure in the random oracle model by invoking a useful lemma about "zero-finding games" for committed polynomials (Lemma 3.3). Security also requires that the random oracle used for an accumulation scheme for a PC scheme is domain-separated from the random oracle used by the PC scheme itself.

### <span id="page-11-1"></span>**2.4.1** Accumulation scheme for $PC_{DL}$

We sketch our accumulation scheme for  $PC_{DL}$ . For univariate polynomials of degree less than d,  $PC_{DL}$  achieves evaluation proofs of size  $O(\lambda \log d)$  in the random oracle model, and assuming the hardness of the discrete logarithm problem in a prime order group  $\mathbb{G}$ . In particular, there are no secret parameters (so-called "toxic waste"). However,  $PC_{DL}$  has poor verification complexity: checking an evaluation proof requires  $\Omega(d)$  scalar multiplications in  $\mathbb{G}$ . Bowe, Grigg, and Hopwood [BGH19] suggested a way to amortize this cost across a batch of n proofs. Below we show that their idea leads to an accumulation scheme for  $PC_{DL}$  with an accumulation verifier that uses only  $O(n \log d)$  scalar multiplications instead of the naive  $\Theta(n \cdot d)$ , and with an accumulator of size  $O(\log d)$  elements in  $\mathbb{G}$ .

Summary of  $\operatorname{PC}_{\operatorname{DL}}$  (see Appendix A for details). The committer and receiver both sample (consistently via the random oracle) a list of group elements  $\{G_0,G_1,\ldots,G_d\}\in\mathbb{G}^{d+1}$  in a group  $\mathbb{G}$  of prime order q (written additively). A commitment to a polynomial  $p(X)=\sum_{i=0}^d a_iX^i\in\mathbb{F}_q^{\leq d}[X]$  is then given by  $C:=\sum_{i=0}^d a_iG_i$ . To prove that the committed polynomial p evaluates to p0 at a given point p1, it suffices to prove that the triple p2 satisfies the following NP statement:

$$\exists a_0,\ldots,a_d \in \mathbb{F} \text{ s.t. } v = \sum_{i=0}^d a_i z^i \text{ and } C = \sum_{i=0}^d a_i G_i$$

This is a special case of an *inner product argument* (IPA), as defined in [BCCGP16], which proves the inner product of two committed vectors. The receiver simply verifies this inner product argument to check the evaluation. The fact that the vector  $(1, z, \ldots, z^d)$  is known to the verifier and has a certain structure is exploited in the accumulation scheme that we describe below.

Accumulation scheme for the IPA. Our accumulation scheme relies on a special structure of the IPA verifier: it generates  $O(\log d)$  challenges using the random oracle, then performs cheap checks requiring  $O(\log d)$  field and group operations, and finally performs an expensive check requiring  $\Omega(d)$  scalar multiplications. This latter check asserts consistency between the challenges and a group element U contained in the proof. Hence, the IPA verifier is succinct barring the expensive check, and so constructing an accumulation scheme for the IPA reduces to the task of constructing an accumulation scheme for the expensive check involving U.

To do this, we rely on an idea of Bowe, Grigg, and Hopwood [BGH19], which itself builds on an observation in [BBBPWM18]. Namely, letting  $(\xi_1,\ldots,\xi_{\log_2 d})$  be the protocol's challenges, U can be viewed as a commitment to the polynomial  $h(X):=\prod_{i=0}^{\log_2(d)-1}(1+\xi_{\log_2(d)-i}X^{2^i})\in \mathbb{F}_q^{\leq d}[X]$ . This polynomial has the special property that it can be evaluated at any point in just  $O(\log d)$  field operations (exponentially smaller than its degree d). This allows transforming the expensive check on U into a check that is amenable to batching: instead of directly checking that U is a commitment to h, one can instead check that the polynomial committed inside U agrees with h at a challenge point z sampled via the random oracle.

We leverage this idea as follows. When accumulating evaluation claims about multiple polynomials  $p_1, \ldots, p_n$ , applying the foregoing transformation results in n checks of the form "check that the polynomial contained in  $U_i$  evaluates to  $h_i(z)$  at the point z". Because these are all claims for the correct evaluation of the polynomials  $h_i$  at the same point z, we can accumulate them via standard homomorphic techniques. We now summarize how we apply this idea to construct our accumulation scheme  $\mathsf{AS} = (\mathsf{P}, \mathsf{V}, \mathsf{D})$  for  $\mathsf{PC}_\mathsf{DL}$ .

Accumulators in our accumulation scheme have the same form as the instances to be accumulated: they are tuples of the form  $(C, z, v, \pi)$  where  $\pi$  is an evaluation proof for the claim "p(z) = v" and p is the polynomial committed in C. For simplicity, below we consider the case of accumulating one old accumulator  $acc = (C_1, z_1, v_1, \pi_1)$  and one instance  $(C_2, z_2, v_2, \pi_2)$  into a new accumulator  $acc^* = (C, z, v, \pi)$ .

Accumulation prover P: compute the new accumulator  $\mathsf{acc}^\star = (C, z, v, \pi)$  from the old accumulator  $\mathsf{acc} = (C_1, z_1, v_1, \pi_1)$  and the instance  $(C_2, z_2, v_2, \pi_2)$  as follows.

- Compute  $U_1, U_2$  from  $\pi_1, \pi_2$  respectively. As described above, these elements can be viewed as commitments to polynomials  $h_1, h_2$  defined by the challenges derived from  $\pi_1, \pi_2$ .
- Use the random oracle  $\rho$  to compute the random challenge  $\alpha:=\rho([(h_1,U_1),(h_2,U_2)]).$
- Compute  $C := U_1 + \alpha U_2$ , which is a polynomial commitment to  $p(X) := h_1(X) + \alpha h_2(X)$ .
- Compute the challenge point  $z := \rho(C, p)$ , where p is uniquely represented via the tuple  $([h_1, h_2], \alpha)$ .
- Construct an evaluation proof  $\pi$  for the claim "p(z) = v". (This step is the only expensive one.)
- Output the new accumulator  $\operatorname{acc}^{\star} := (C, z, v, \pi)$ .

Accumulation verifier V: to check that the new accumulator  $\operatorname{acc}^* = (C, z, v, \pi)$  was correctly generated from the old accumulator  $\operatorname{acc} = (C_1, z_1, v_1, \pi_1)$  and the instance  $(C_2, z_2, v_2, \pi_2)$ , first compute the challenges  $\alpha$  and z from the random oracle as above, and then check that (a)  $(C_1, z_1, v_1, \pi_1)$  and  $(C_2, z_2, v_2, \pi_2)$  pass the cheap checks of the IPA verifier, (b)  $C = U_1 + \alpha U_2$ , and (c)  $h_1(z) + \alpha h_2(z) = v$ .

Decider D: on input the (final) accumulator  $\mathsf{acc}^\star = (C, z, v, \pi)$ , check that  $\pi$  is a valid evaluation proof for the claim that the polynomial committed inside C evaluates to v at the point z.

This construction achieves the efficiency summarized in Theorem 3.

We additionally achieve zero knowledge accumulation for the hiding variant of  $PC_{DL}$  (also described in Appendix A). Informally, the accumulation prover randomizes  $acc^*$  by including a new random polynomial

 $h_0$  in the accumulation step. This ensures that the evaluation claim in acc\* is for a random polynomial, thus hiding all information about the original evaluation claims. To allow the accumulation verifier to check that this randomization was performed correctly, the prover includes  $h_0$  in an auxiliary proof  $\pi_V$ .

In Section 7, we show how to extend the above accumulation scheme to accumulate any number of old accumulators and instances. Our security proof for the resulting accumulation scheme relies on the hardness of zero-finding games (Lemma 3.3), and the security of  $PC_{DL}$ .

### <span id="page-13-0"></span>**2.4.2** Accumulation scheme for PC<sub>AGM</sub>

We sketch our accumulation scheme  $\mathsf{AS} = (\mathsf{P}, \mathsf{V}, \mathsf{D})$  for  $\mathsf{PC}_{\mathsf{AGM}}$ . Checking an evaluation proof in  $\mathsf{PC}_{\mathsf{AGM}}$  requires 1 pairing, and so checking n evaluation proofs requires n pairings. AS improves upon this as follows: the accumulation verifier  $\mathsf{V}$  only performs O(n) scalar multiplications in  $\mathbb{G}_1$  in order to check the accumulation of n evaluation proofs, while the decider  $\mathsf{D}$  performs only a single pairing in order to check the resulting accumulator. This is much cheaper: it reduces the number of pairings from n to 1, and also defers this single pairing to the end of the accumulation (the decider). In particular, when instantiating the PCD construction outlined in Section 2.1 with a  $\mathsf{PC}_{\mathsf{AGM}}$ -based SNARK and our accumulation scheme for  $\mathsf{PC}_{\mathsf{AGM}}$ , we can eliminate  $\mathit{all}$  pairings from the circuit being verified in the PCD construction.

Below we explain how standard techniques for batching pairings using random linear combinations [CHMMVW20] allow us to realize an accumulation scheme for PC<sub>AGM</sub> with these desirable properties.

**Summary of PC**<sub>AGM</sub>. The committer key ck and receiver key rk for a given maximum degree bound D are group elements from a bilinear group  $(\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, G, H, e)$ : ck  $:= \{G, \beta G, \dots, \beta^D G\} \in \mathbb{G}_1^{D+1}$  consists of group elements encoding powers of a random field element  $\beta$ , while rk  $:= (G, H, \beta H) \in \mathbb{G}_1 \times \mathbb{G}_2^2$ .

A commitment to a polynomial  $p \in \mathbb{F}_q^{\leq D}[X]$  is the group element  $C := p(\beta)G \in \mathbb{G}_1$ . To prove that p evaluates to v at a given point  $z \in \mathbb{F}_q$ , the sender computes a "witness polynomial" w(X) := (p(X)-v)/(X-z), and outputs the evaluation proof  $\pi := w(\beta)G \in \mathbb{G}_1$ . The receiver can check this proof by checking the pairing equation  $e(C-vG,H) = e(\pi,\beta H-zH)$ . This pairing equation is the focus of our accumulation scheme below. (This summary omits details about degree enforcement and about hiding.)

**Accumulation scheme.** We construct an accumulation scheme AS = (P, V, D) for  $PC_{AGM}$  by relying on standard techniques for batching pairing equations. Suppose that we wish to simultaneously check the validity of n instances  $[(C_i, z_i, v_i, \pi_i)]_{i=1}^n$ . First, rewrite the pairing check for the i-th instance as follows:

$$e(C_i - v_i G, H) = e(\pi_i, \beta H - z_i H) \iff e(C_i - v_i G + z_i \pi_i, H) = e(\pi_i, \beta H) . \tag{1}$$

After the rewrite, the  $\mathbb{G}_2$  inputs to both pairings do not depend on the claim being checked. This allows batching the pairing checks by taking a random linear combination with respect to a random challenge  $r := \rho([C_i, z_i, v_i, \pi_i]_{i=1}^n)$  computed from the random oracle, resulting in the following combined equation:

<span id="page-13-1"></span>
$$e(\sum_{i=1}^{n} r^{i}(C_{i} - v_{i}G + z_{i}\pi_{i}), H) = e(\sum_{i=1}^{n} r^{i}\pi_{i}, \beta H) .$$
 (2)

We now have a pairing equation involving an "accumulated commitment"  $C^* := \sum_{i=1}^n r^i (C_i - v_i G + z_i \pi_i)$  and an "accumulated proof"  $\pi^* := \sum_{i=1}^n r^i \pi_i$ . This observation leads to the accumulation scheme below.

An accumulator in AS consists of a commitment-proof pair  $(C^\star,\pi^\star)$ , which the decider D validates by checking that  $e(C^\star,H)=e(\pi^\star,\beta H)$ . Moreover, observe that by Eq. (1), checking the validity of a claimed evaluation  $(C,z,v,\pi)$  within PC<sub>AGM</sub> corresponds to checking that the "accumulator"  $(C-vG+z\pi,\pi)$  is accepted by the decider D. Thus we can restrict our discussion to accumulating *accumulators*.

The accumulation prover P, on input a list of old accumulators  $[\operatorname{acc}_i]_{i=1}^n = [(C_i^\star, \pi_i^\star)]_{i=1}^n$ , computes a random challenge  $r := \rho([\operatorname{acc}_i]_{i=1}^n)$ , constructs  $C^\star := \sum_{i=1}^n r^i C_i^\star$  and  $\pi^\star := \sum_{i=1}^n r^i \pi_i^\star$ , and outputs

the new accumulator  $\mathsf{acc}^\star := (C^\star, \pi^\star) \in \mathbb{G}^2_1$ . To check that  $\mathsf{acc}^\star$  accumulates  $[\mathsf{acc}_i]_{i=1}^n$ , the accumulation verifier V simply invokes P and checks that its output matches the claimed new accumulator  $\mathsf{acc}^\star$ .

To achieve zero knowledge accumulation, the accumulation prover randomizes  $acc^*$  by including in it an extra "old" accumulator corresponding to a random polynomial, which statistically hides the accumulated claims. To allow the accumulation verifier to check that this randomization was performed correctly, the prover includes this old accumulator in an auxiliary proof  $\pi_V$ .

This construction achieves the efficiency summarized in Theorem 3.

In Section 8, we show how to extend the above accumulation scheme to account for additional features of PC<sub>AGM</sub> (degree enforcement and hiding). Our security proof for the resulting accumulation scheme relies on the hardness of zero-finding games (Lemma 3.3).

## <span id="page-15-0"></span>3 Preliminaries

**Indexed relations.** An *indexed relation*  $\mathcal{R}$  is a set of triples (i, x, w) where i is the index, x is the instance, and w is the witness; the corresponding *indexed language*  $\mathcal{L}(\mathcal{R})$  is the set of pairs (i, x) for which there exists a witness w such that  $(i, x, w) \in \mathcal{R}$ . For example, the indexed relation of satisfiable boolean circuits consists of triples where i is the description of a boolean circuit, x is a partial assignment to its input wires, and w is an assignment to the remaining wires that makes the circuit to output 0.

**Security parameters.** For simplicity of notation, we assume that all public parameters have length at least  $\lambda$ , so that algorithms which receive such parameters can run in time  $poly(\lambda)$ .

**Random oracles.** We denote by  $\mathcal{U}(\lambda)$  the set of all functions that map  $\{0,1\}^*$  to  $\{0,1\}^{\lambda}$ . We denote by  $\mathcal{U}(*)$  the set  $\bigcup_{\lambda \in \mathbb{N}} \mathcal{U}(\lambda)$ . A *random oracle* with security parameter  $\lambda$  is a function  $\rho \colon \{0,1\}^* \to \{0,1\}^{\lambda}$  sampled uniformly at random from  $\mathcal{U}(\lambda)$ .

## <span id="page-15-1"></span>3.1 Non-interactive arguments in the ROM

A tuple of algorithms ARG =  $(\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  is a (preprocessing) *non-interactive argument* in the random oracle model (ROM) for an indexed relation  $\mathcal{R}$  if the following properties hold.

• Completeness. For every adversary A,

$$\Pr\left[\begin{array}{c|c} (i, \mathbf{x}, \mathbf{w}) \not\in \mathcal{R} & \rho \leftarrow \mathcal{U}(\lambda) \\ \forall & \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \forall & (i, \mathbf{x}, \mathbf{w}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ \mathcal{V}^{\rho}(ivk, \mathbf{x}, \pi) = 1 & (ipk, ivk) \leftarrow \mathcal{I}^{\rho}(\mathsf{pp}, i) \\ \pi \leftarrow \mathcal{P}^{\rho}(ipk, \mathbf{x}, \mathbf{w}) \end{array}\right] = 1 \ .$$

• Soundness. For every polynomial-size adversary  $\tilde{\mathcal{P}}$ ,

$$\Pr\left[\begin{array}{c|c} (i, \mathbf{x}) \not\in \mathcal{L}(\mathcal{R}) & \rho \leftarrow \mathcal{U}(\lambda) \\ \wedge & \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathcal{V}^{\rho}(ivk, \mathbf{x}, \pi) = 1 & (i, \mathbf{x}, \pi) \leftarrow \tilde{\mathcal{P}}^{\rho}(\mathsf{pp}) \\ (ipk, ivk) \leftarrow \mathcal{I}^{\rho}(\mathsf{pp}, i) \end{array}\right] \leq \operatorname{negl}(\lambda) \ .$$

The above formulation of completeness allows (i, x, w) to depend on the random oracle  $\rho$  and public parameters pp, and the above formulation of soundness allows (i, x) to depend on the random oracle  $\rho$  and public parameters pp.

Our PCD construction makes use of the stronger property of *knowledge soundness*, and optionally also the property of (statistical) *zero knowledge*. We define both of these properties below. Note that this definition is stronger the standard definition of knowledge soundness; this is required to prove post-quantum security in Theorem 5.2. This stronger definition is similar to the notion of *witness-extended emulation* [Lin03].

**Knowledge soundness.** We say that  $\mathsf{ARG} = (\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  has *knowledge soundness* if for every polynomial-size adversary  $\tilde{\mathcal{P}}$  and every polynomial-size auxiliary input distribution  $\mathcal{D}$  there exists an efficient extractor  $\mathcal{E}$  such that

$$\Pr\left[\begin{array}{c|c} \forall j \in [\ell], \ \left(\mathcal{V}^{\rho}(\mathrm{ivk}_{j}, \mathbf{x}_{j}, \pi_{j}) = 1 \\ & \downarrow \\ (\mathbf{i}_{j}, \mathbf{x}_{j}, \mathbf{w}_{j}) \in \mathcal{R} \end{array}\right) \quad \begin{array}{c|c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathrm{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ z \leftarrow \mathcal{D}^{\rho}(\mathrm{pp}) \\ (\vec{\mathbf{i}}, \vec{\mathbf{x}}, \vec{\pi}, \mathsf{aux}, \vec{\mathbf{w}}) \leftarrow \mathcal{E}^{\rho}(\mathrm{pp}, z) \\ \forall j \ , \ (\mathrm{ipk}_{j}, \mathrm{ivk}_{j}) \leftarrow \mathcal{I}^{\rho}(\mathrm{pp}, \mathbf{i}_{j}) \end{array}\right] \geq 1 - \mathrm{negl}(\lambda)$$

and, moreover, the following distributions are statistically close (as a function of  $\lambda$ )

$$\left\{ \begin{array}{l} \rho \leftarrow \mathcal{U}(\lambda) \\ (\rho,\mathsf{pp},\vec{\mathtt{i}},\\ \vec{\mathtt{x}},\vec{\pi},\mathsf{aux}) \end{array} \right. \quad \left. \begin{array}{l} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ z \leftarrow \mathcal{D}^{\rho}(\mathsf{pp}) \\ (\vec{\mathtt{i}},\vec{\mathtt{x}},\vec{\pi},\mathsf{aux}) \leftarrow \tilde{\mathcal{P}}^{\rho}(\mathsf{pp},z) \end{array} \right\} \quad \text{and} \quad \left\{ \begin{array}{l} \rho \leftarrow \mathcal{U}(\lambda) \\ (\rho,\mathsf{pp},\vec{\mathtt{i}},\\ \vec{\mathtt{x}},\vec{\pi},\mathsf{aux}) \end{array} \right. \quad \left. \begin{array}{l} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \vec{\mathtt{x}},\vec{\pi},\mathsf{aux} \end{array} \right. \\ \left. \begin{array}{l} z \leftarrow \mathcal{D}^{\rho}(\mathsf{pp}) \\ (\vec{\mathtt{i}},\vec{\mathtt{x}},\vec{\pi},\mathsf{aux},\vec{\mathtt{w}}) \leftarrow \mathcal{E}^{\rho}(\mathsf{pp},z) \end{array} \right\} \ .$$

The above definition is polynomially related to the standard definition of adaptive knowledge soundness, which does not consider a vector of outputs or an auxiliary output by the prover.

**Zero knowledge.** We say that ARG =  $(\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator S such that for every polynomial-size honest adversary A the distributions below are computationally indistinguishable:

$$\left\{ (\rho, \mathsf{pp}, \mathbf{i}, \mathbf{x}, \pi) \middle| \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ (\mathbf{i}, \mathbf{x}, \mathbf{w}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ (\mathbf{ipk}, \mathbf{ivk}) \leftarrow \mathcal{I}^{\rho}(\mathsf{pp}, \mathbf{i}) \\ \pi \leftarrow \mathcal{P}^{\rho}(\mathbf{ipk}, \mathbf{x}, \mathbf{w}) \end{array} \right\} \quad \text{and} \quad \left\{ (\rho[\mu], \mathsf{pp}, \mathbf{i}, \mathbf{x}, \pi) \middle| \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ (\mathsf{pp}, \tau) \leftarrow \mathcal{S}^{\rho}(\mathbf{i}, \mathbf{x}) \\ (\mathbf{i}, \mathbf{x}, \mathbf{w}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ (\pi, \mu) \leftarrow \mathcal{S}^{\rho}(\mathsf{pp}, \mathbf{i}, \mathbf{x}, \tau) \end{array} \right\} \; .$$

Above,  $\rho[\mu]$  is the function that, on input x, equals  $\mu(x)$  if  $\mu$  is defined on x, or  $\rho(x)$  otherwise. This definition uses explicitly-programmable random oracles [BR93]. (Non-interactive zero knowledge with non-programmable random oracles is impossible for non-trivial languages [Pas03; BCS16].)

## <span id="page-16-0"></span>**Proof-carrying data**

A triple of algorithms  $PCD = (\mathbb{G}, \mathbb{I}, \mathbb{P}, \mathbb{V})$  is a (preprocessing) proof-carrying data scheme (PCD scheme) for a class of compliance predicates F if the properties below hold.

<span id="page-16-1"></span>**Definition 3.1.** A transcript T is a directed acyclic graph where each vertex  $u \in V(T)$  is labeled by local data  $z_{\mathsf{loc}}^{(u)}$  and each edge  $e \in E(T)$  is labeled by a message  $z^{(e)} \neq \bot$ . The **output** of a transcript T, denoted o(T), is  $z^{(e)}$  where e = (u, v) is the lexicographically-first edge such that v is a sink.

**Definition 3.2.** A vertex  $u \in V(\mathsf{T})$  is  $\varphi$ -compliant for  $\varphi \in \mathsf{F}$  if for all outgoing edges  $e = (u, v) \in E(\mathsf{T})$ :

- (base case) if u has no incoming edges,  $\varphi(z^{(e)}, z_{\text{loc}}^{(u)}, \bot, ..., \bot)$  accepts; (recursive case) if u has incoming edges  $e_1, ..., e_m$ ,  $\varphi(z^{(e)}, z_{\text{loc}}^{(u)}, z^{(e_1)}, ..., z^{(e_m)})$  accepts. We say that T is  $\varphi$ -compliant if all of its vertices are  $\varphi$ -compliant.

**Completeness.** For every adversary A,

$$\Pr \left[ \begin{array}{c} \left( \varphi \in \mathsf{F} \, \wedge \left( \forall \, i, z_i = \bot \vee \forall \, i, \, \mathbb{V}(\mathsf{ivk}, z_i, \pi_i) = 1 \right) \wedge \\ \varphi(z, z_{\mathsf{loc}}, z_1, \dots, z_m) \; \mathsf{accepts} \, \right) \\ \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad$$

**Knowledge soundness.** We say that  $PCD = (\mathbb{G}, \mathbb{I}, \mathbb{P}, \mathbb{V})$  has knowledge soundness if there exists some polynomial e such that for every polynomial-size adversary  $\tilde{\mathbb{P}}$ , there exists an extractor  $\mathbb{E}$  of size at most  $e(|\tilde{\mathbb{P}}|)$  such that

$$\Pr\left[\begin{array}{c|c} \left(\varphi \in \mathsf{F} \wedge \mathbb{V}(\mathsf{ivk},\mathsf{o}(\mathsf{T}),\pi) = 1\right) & \mathbb{pp} \leftarrow \mathbb{G}(1^\lambda) \\ \Downarrow & \left(\varphi,\pi,\mathsf{T}\right) \leftarrow \mathbb{E}(\mathbb{pp}) \\ \mathsf{T} \ \mathsf{is} \ \varphi\text{-compliant} & \left(\mathsf{ipk},\mathsf{ivk}\right) \leftarrow \mathbb{I}(\mathbb{pp},\varphi) \end{array}\right] \geq 1 - \mathrm{negl}(\lambda) \ \ .$$

and, moreover, the following distributions are statistically close:

$$\left\{(\varphi,\mathsf{o},\pi) \;\middle|\; \begin{array}{c} \mathbb{p}\mathbb{p} \leftarrow \mathbb{G}(1^\lambda) \\ (\varphi,\mathsf{o},\pi) \leftarrow \tilde{\mathbb{P}}(\mathbb{p}\mathbb{p}) \end{array}\right\} \quad \text{and} \quad \left\{(\varphi,\mathsf{o}(\mathsf{T}),\pi) \;\middle|\; \begin{array}{c} \mathbb{p}\mathbb{p} \leftarrow \mathbb{G}(1^\lambda) \\ (\varphi,\pi,\mathsf{T}) \leftarrow \mathbb{E}(\mathbb{p}\mathbb{p}) \end{array}\right\} \;.$$

**Zero knowledge.** We say that  $PCD = (\mathbb{G}, \mathbb{I}, \mathbb{P}, \mathbb{V})$  has (statistical) zero knowledge if there exists a probabilistic polynomial-time simulator  $\mathbb{S}$  such that for every polynomial-size *honest* adversary  $\mathcal{A}$  the distributions below are computationally indistinguishable:

$$\left\{ (\operatorname{pp}, \pi) \left| \begin{array}{c} \operatorname{pp} \leftarrow \operatorname{\mathbb{G}}(1^{\lambda}) \\ (\varphi, z, z_{\mathsf{loc}}, [z_i, \pi_i]_{i=1}^m) \leftarrow \operatorname{\mathcal{A}}(\operatorname{pp}) \\ (\mathsf{ipk}, \mathsf{ivk}) \leftarrow \operatorname{\mathbb{I}}(\operatorname{pp}, \varphi) \\ \pi \leftarrow \operatorname{\mathbb{P}}(\mathsf{ipk}, \varphi, z, z_{\mathsf{loc}}, [z_i, \pi_i]_{i=1}^m) \end{array} \right\} \quad \text{and} \quad \left\{ (\operatorname{pp}, \pi) \left| \begin{array}{c} (\operatorname{pp}, \tau) \leftarrow \operatorname{\mathbb{S}} \\ (\operatorname{pp}, \pi) | & (\varphi, z, z_{\mathsf{loc}}, [z_i, \pi_i]_{i=1}^m) \leftarrow \operatorname{\mathcal{A}}(\operatorname{pp}) \\ \pi \leftarrow \operatorname{\mathbb{S}}(\varphi, z, \tau) \end{array} \right\} \right. .$$

In this case,  $\mathcal{A}$  is honest if it outputs, with probability 1,  $(\varphi, z, z_{\text{loc}}, [z_i, \pi_i]_{i=1}^m)$  such that  $\varphi \in \mathsf{F}$ ,  $\mathbb{V}(\mathsf{ivk}, z_i, \pi_i) = 1$  for all i, and  $\varphi(z, z_{\text{loc}}, z_1, \dots, z_m)$  accepts.

**Efficiency.** The generator  $\mathbb{G}$ , prover  $\mathbb{P}$ , indexer  $\mathbb{I}$  and verifier  $\mathbb{V}$  run in polynomial time. A proof  $\pi$  has size  $\operatorname{poly}(\lambda, |\varphi|)$ ; in particular, it is not permitted to grow with each application of  $\mathbb{P}$ .

## <span id="page-17-0"></span>3.3 Instantiating the random oracle

Almost all of the results in this paper are proved in the *random oracle model*, and so we give definitions which include random oracles. The single exception is our construction of proof-carrying data, in Section 5.1. We do not know how to build PCD schemes which are secure in the random oracle model from any standard assumption. Instead, we show that assuming the existence of a non-interactive argument with security in the standard (CRS) model, we obtain a PCD scheme which is also secure in the standard (CRS) model.

For this reason, the definition of PCD above is stated in the standard model (without oracles). We do not explicitly define non-interactive arguments in the standard model; the definition is easily obtained by removing the random oracle from the definition presented in Section 3.1.

### <span id="page-17-1"></span>3.4 Post-quantum security

The definitions of both non-interactive arguments (in the standard model) and proof-carrying data can be strengthened, in a straightforward way, to express post-quantum security. In particular, we replace "polynomial-size circuit" and "polynomial-time algorithm" with their quantum analogues. Since we do not prove post-quantum security of any construction in the random oracle model, we do not discuss the quantum random oracle model.

### <span id="page-18-0"></span>3.5 Commitment schemes

A commitment scheme  $\mathsf{CM} = (\mathsf{Setup}, \mathsf{Trim}, \mathsf{Commit})$  enables one to create binding commitments to messages.

- CM.Setup, on input a *message format L*, outputs public parameters pp; this specifies a message universe  $\mathcal{M}_{pp}$  and a commitment universe  $\mathcal{C}_{pp}$ .
- CM. Trim, on input public parameters pp and a *trim specification*  $\ell$ , outputs a commitment key ck containing a description of a message space  $\mathcal{M}_{ck} \subseteq \mathcal{M}_{pp}$  (corresponding to  $\ell$ ).
- CM.Commit, on input a commitment key ck, a message  $m \in \mathcal{M}_{ck}$  and randomness  $\omega$ , outputs a commitment  $C \in \mathcal{C}_{pp}$ .

CM is binding if, for every message format L such that  $|L| = \text{poly}(\lambda)$ , and for every efficient adversary A, the following holds.

$$\Pr\left[\begin{array}{c|c} m_1 \in \mathcal{M}_{\mathsf{ck}_1} \,,\, m_2 \in \mathcal{M}_{\mathsf{ck}_2} \,,\, m_1 \neq \, m_2 \\ \land \\ \mathsf{CM.Commit}(\mathsf{ck}_1, m_1; \, \omega_1) = \mathsf{CM.Commit}(\mathsf{ck}_2, m_2; \, \omega_2) \end{array} \right| \begin{array}{c} \mathsf{pp} \leftarrow \mathsf{CM.Setup}^{\rho}(1^{\lambda}, L) \\ ((\ell_1, m_1, \omega_1), (\ell_2, m_2, \omega_2)) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ \mathsf{ck}_1 \leftarrow \mathsf{CM.Trim}^{\rho}(\mathsf{pp}, \ell_1) \\ \mathsf{ck}_2 \leftarrow \mathsf{CM.Trim}^{\rho}(\mathsf{pp}, \ell_2) \end{array} \right] \leq \mathsf{negl}(\lambda) \ .$$

Note that  $m_1 \neq m_2$  is well-defined since  $\mathcal{M}_{\mathsf{ck}_1}, \mathcal{M}_{\mathsf{ck}_2} \subseteq \mathcal{M}_{\mathsf{pp}}$ .

We now give a useful lemma, which bounds the probability that applying the random oracle to a commitment to a polynomial yields a zero of that polynomial. We refer to this as a *zero-finding game*.

<span id="page-18-1"></span>**Lemma 3.3.** Let  $F: \mathbb{N} \to \mathbb{N}$ , and  $\mathsf{CM} = (\mathsf{Setup}, \mathsf{Trim}, \mathsf{Commit})$  be a commitment scheme. Fix a number of variables  $M \in \mathbb{N}$  and maximum degree  $N \in \mathbb{N}$ . Then for every family of (not necessarily efficient) functions  $\{f_{\mathsf{pp}}\}_{\mathsf{pp}}$  and fields  $\{\mathbb{F}_{\mathsf{pp}}\}_{\mathsf{pp}}$  where  $f_{\mathsf{pp}} \colon \mathcal{M}_{\mathsf{pp}} \to \mathbb{F}^{\leq N}_{\mathsf{pp}}[X_1, \dots, X_M]$  and  $|\mathbb{F}_{\mathsf{pp}}| \geq F(\lambda)$ ; for every message format L and efficient t-query oracle algorithm  $\mathcal{A}$ , the following holds.

$$\Pr\left[\begin{array}{c|c} \rho \leftarrow \mathcal{U}(\lambda) \\ p \not \equiv 0 \\ \wedge \\ p(\boldsymbol{z}) = 0 \end{array} \middle| \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ p p \leftarrow \mathsf{CM.Setup}(1^{\lambda}, L) \\ (\ell, \mathfrak{p} \in \mathcal{M}_{\mathsf{ck}}, \omega) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ \mathsf{ck} \leftarrow \mathsf{CM.Trim}(\mathsf{pp}, \ell) \\ C \leftarrow \mathsf{CM.Commit}(\mathsf{ck}, \mathfrak{p}; \omega) \\ \boldsymbol{z} \in \mathbb{F}^{N}_{\mathsf{pp}} \leftarrow \rho(C) \\ p \leftarrow f_{\mathsf{pp}}(\mathfrak{p}) \end{array} \right] \leq \sqrt{(t+1) \cdot \frac{MN}{F(\lambda)}} + \mathrm{negl}(\lambda) \ .$$

If CM is perfectly binding, then the above holds also for computationally-unbounded t-query adversaries A.

*Proof.* Let  $\mathcal{A}$  be an adversary which wins with probability  $\delta$  in the above game; we construct an adversary  $\mathcal{B}$  which breaks the binding of the commitment scheme with probability at least  $\delta^2/(t+1) - \frac{MN}{F(\lambda)}$ .

Note first that we may assume that  $\mathcal{A}$  always queries  $C \leftarrow \mathsf{CM}.\mathsf{Commit}(\mathsf{ck}, \mathfrak{p}; \omega)$  for its output  $(\mathfrak{p}, \omega)$ , by increasing the query bound from t to t+1.

### $\mathcal{B}(\mathsf{pp})$

- 1. Run  $(\ell, \mathfrak{p}, \omega) \leftarrow \mathcal{A}^{\rho}(pp)$ , simulating its queries to  $\rho$ .
- 2. Compute  $\mathsf{ck} \leftarrow \mathsf{CM}.\mathsf{Trim}(\mathsf{pp},\ell)$ .
- 3. Obtain  $C \leftarrow \mathsf{CM}.\mathsf{Commit}(\mathsf{ck}, \mathfrak{p}; \omega)$ .
- 4. Rewind  $\mathcal{A}$  to the query  $\rho(C)$  and run to the end, drawing fresh randomness for this and subsequent oracle queries, to obtain  $(\ell', \mathfrak{p}', \omega')$ .

5. Output  $((\ell, \mathfrak{p}, \omega), (\ell', \mathfrak{p}', \omega'))$ .

Let  $\mathsf{ck}' := \mathsf{CM}.\mathsf{Trim}(\mathsf{pp},\ell'), \ C' := \mathsf{CM}.\mathsf{Commit}(\mathsf{ck}',\mathfrak{p}';\omega'), \ \boldsymbol{z} := \rho(C), \ \boldsymbol{z}' := \rho(C'), \ p := f_{\mathsf{pp}}(\mathfrak{p})$  and  $p' := f_{\mathsf{pp}}(\mathfrak{p}')$ . By the forking lemma, the probability that  $p(\boldsymbol{z}) = p'(\boldsymbol{z}') = 0$  and C = C' is at least  $\delta^2/(t+1)$ ; call this event E. Then

$$\Pr[E] \le \Pr[E \land (p = p')] + \Pr[E \land (p \ne p')] \le MN/F(\lambda) + \Pr[E \land (\mathfrak{p} \ne \mathfrak{p}')].$$

The lemma follows by noting that  $E \wedge (\mathfrak{p} \neq \mathfrak{p}')$  implies that  $\mathcal{B}$  breaks the binding property of CM.

**Remark 3.4.** For Lemma 3.3 to hold, the algorithms of CM *must not* have access to the random oracle  $\rho$  used to generate the challenge point z. The lemma is otherwise black-box with respect to CM, and so CM itself may use other oracles. The lemma continues to hold when  $\mathcal{A}$  has access to these additional oracles. We use this fact later to justify the security of domain separation.

## <span id="page-19-0"></span>3.6 Polynomial commitments

A polynomial commitment scheme is a cryptographic primitive that enables a sender to commit to a polynomial p over a field  $\mathbb F$  and then later prove the correct evaluation of the polynomial at a desired point. In more detail, a polynomial commitment scheme PC is a tuple of algorithms (Setup, Trim, Commit, Open, Check) with the following syntax and properties:

- PC.Setup $^{\rho}(1^{\lambda}, D) \to pp$ . On input a security parameter  $\lambda$  (in unary), and a maximum degree bound  $D \in \mathbb{N}$ , PC.Setup samples public parameters  $pp_{PC}$ . The parameters contain the description of a finite field  $\mathbb{F}$  (which has size that is super-polynomial in  $\lambda$ ).
- PC.Trim $^{\rho}(pp, [d_i]_{i=1}^n) \to (ck, rk)$ . On input public parameters  $pp_{PC}$ , and degree bounds  $[d_i]_{i=1}^n$ , PC.Trim deterministically computes a key pair (ck, rk) that is specialized to  $[d_i]_{i=1}^n$ .
- PC.Commit $^{\rho}(\mathsf{ck}, p, d; \omega) \to C$ . On input ck, a univariate polynomial p over the field  $\mathbb{F}$ , and a degree bound d such that  $\deg(p) \leq d \in [d_i]_{i=1}^n$ , PC.Commit outputs a commitment C to the polynomial p. The randomness  $\omega$  is used if the commitment C is hiding.
- PC.Open $^{\rho}(\mathsf{ck}, p, C, d, z; \omega) \to \pi$ . On input the commitment key ck, a univariate polynomial p over the field  $\mathbb{F}$ , a commitment C to p, a degree bound d, an evaluation point z, and commitment randomness  $\omega$ , PC.Open outputs an evaluation proof  $\pi$ .
- PC.Check $^{\rho}(\mathsf{rk}, C, d, z, v, \pi) \to b$ . On input the receiver key rk, a commitment C, a degree bound d, an evaluation point z, a claimed evaluation v, and an evaluation proof  $\pi$ , PC.Check checks that the degree bound  $d \in [d_i]_{i=1}^n$ , and outputs 1 if  $\pi$  attests that the polynomial p committed in C has degree at most d and evaluates to v at z.

A polynomial commitment scheme PC must be such that (PC.Setup, PC.Trim, PC.Commit) is a (binding) commitment scheme for bounded-degree polynomials over a field. The message format L is equal to the maximum degree bound D; the message universe is the set of polynomials over some field  $\mathbb{F}$  of degree at most D. The trim specification  $\ell$  is equal to the list of degree bounds  $[d_i]_{i=1}^n$ ; the corresponding message space is the set of polynomials over  $\mathbb{F}$  of degree at most  $\max_i d_i$ .

A polynomial commitment scheme must also satisfy the following additional properties.

**Completeness.** For every maximum degree bound  $D = \text{poly}(\lambda) \in \mathbb{N}$  and every adversary  $\mathcal{A}$ ,

$$\Pr\left[\begin{array}{c} d \in [d_i]_{i=1}^n \\ \deg(p) \leq d \leq D \\ \Downarrow \\ \mathsf{PC.Check}^\rho(\mathsf{rk}, C, d, z, v, \pi) = 1 \end{array}\right. \left[\begin{array}{c} \mathsf{pp} \leftarrow \mathsf{PC.Setup}^\rho(1^\lambda, D) \\ ([d_i]_{i=1}^n, p, d, z, \omega) \leftarrow \mathcal{A}^\rho(\mathsf{pp}) \\ (\mathsf{ck}, \mathsf{rk}) \leftarrow \mathsf{PC.Trim}^\rho(\mathsf{pp}, [d_i]_{i=1}^n) \\ C \leftarrow \mathsf{PC.Commit}^\rho(\mathsf{ck}, p, d; \omega) \\ v \leftarrow p(z) \\ \pi \leftarrow \mathsf{PC.Open}^\rho(\mathsf{ck}, p, C, d, z; \omega) \end{array}\right] = 1$$

**Extractability.** For every maximum degree bound  $D = \text{poly}(\lambda) \in \mathbb{N}$  and polynomial-size adversary Athere exists an efficient extractor  $\mathcal{E}$  such that the following holds.

$$\Pr\left[\begin{array}{c|c} \mathsf{PC.Check}^{\rho}(\mathsf{rk},C,d,z,v,\pi) = 1 \\ & \Downarrow \\ C = \mathsf{PC.Commit}^{\rho}(\mathsf{ck},p,d;\omega) \\ & v = p(z) \\ & d \in [d_i]_{i=1}^n \\ & \deg(p) \leq d \leq D \end{array}\right. \left. \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathsf{PC.Setup}^{\rho}(1^{\lambda},D) \\ ([d_i]_{i=1}^n,(C,d,z,v),\pi) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}) \\ (p,\omega) \leftarrow \mathcal{E}^{\rho}(\mathsf{pp}) \\ (\mathsf{ck},\mathsf{rk}) \leftarrow \mathsf{PC.Trim}^{\rho}(\mathsf{pp},[d_i]_{i=1}^n) \end{array} \right] \geq 1 - \operatorname{negl}(\lambda) \ .$$

**Hiding.** There exists a stateful polynomial-time simulator S such that, for every maximum degree bound  $D = \text{poly}(\lambda) \in \mathbb{N}$  and stateful polynomial-size adversary  $\mathcal{A}$ , the output distributions of the following games are statistically close:

Real
$$(1^{\lambda}, D, \mathcal{A})$$
:

1. 
$$\rho \leftarrow \mathcal{U}(\lambda)$$
.

2. 
$$pp \leftarrow PC.Setup^{\rho}(1^{\lambda}, D).$$

3. 
$$(p,d) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp})$$
.

4. 
$$(\mathsf{ck}, \mathsf{rk}) \leftarrow \mathsf{PC}.\mathsf{Trim}^{\rho}(\mathsf{pp}, d)$$
.

5. Sample commitment randomness  $\omega$ .

6. 
$$C \leftarrow \mathsf{PC.Commit}^{\rho}(\mathsf{ck}, p, d; \omega)$$
.

7. 
$$z \leftarrow \mathcal{A}^{\rho}(C)$$
.

8. Sample opening randomness r.

9. 
$$\pi \leftarrow \mathsf{PC.Open}^{\rho}(\mathsf{ck}, p, C, d, z; \omega, r)$$
.

10. Output 
$$(\rho, pp, p, d, C, z, \pi)$$
.

$$\mathsf{Ideal}(1^{\lambda}, D, \mathcal{A})$$
:

1. 
$$\rho \leftarrow \mathcal{U}(\lambda)$$
.

1. 
$$\rho \leftarrow \mathcal{U}(\lambda)$$
.  
2.  $(\mathsf{pp}, \mathsf{trap}) \leftarrow \mathcal{S}.\mathsf{Setup}^{\rho}(1^{\lambda}, D)$ .

3. 
$$(p,d) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp})$$

4. 
$$C \leftarrow \mathcal{S}.\mathsf{Commit}^{\rho}(\mathsf{trap}, d)$$
.

4. 
$$C \leftarrow \mathcal{S}.\mathsf{Com}$$
  
5.  $z \leftarrow \mathcal{A}^{\rho}(C)$ .

6. 
$$(\mu, \pi) \leftarrow \mathcal{S}.\mathsf{Open}^{\rho}(z, p(z)).$$
  
7. Output  $(\rho[\mu], \mathsf{pp}, p, d, C, z, \pi)$ 

7. Output 
$$(\rho[\mu], pp, p, d, C, z, \pi)$$
.

### <span id="page-21-0"></span>4 Accumulation schemes

In Section 4.1 we formally define an accumulation scheme. In Section 4.2 we define accumulation schemes for predicates related to the cryptographic primitives used in this paper.

### <span id="page-21-1"></span>4.1 Definition

Let  $\Phi \colon \mathcal{U}(*) \times (\{0,1\}^*)^3 \to \{0,1\}$  be a predicate (for clarity we write  $\Phi^{\rho}(\mathsf{pp}_{\Phi},\mathsf{i}_{\Phi},\mathsf{q})$  for  $\Phi(\rho,\mathsf{pp}_{\Phi},\mathsf{i}_{\Phi},\mathsf{q})$ ). Let  $\mathcal{H}$  be a randomized algorithm with access to a (random) oracle, which outputs predicate parameters  $\mathsf{pp}_{\Phi}$ .

An **accumulation scheme for**  $(\Phi, \mathcal{H})$  is a tuple of algorithms  $\mathsf{AS} = (G, I, P, V, D)$  all of which have access to the same random oracle  $\rho$ . The algorithms have the following syntax and properties.

**Syntax.** The algorithms comprising AS have the following syntax:

- Generator: On input a security parameter  $\lambda$  (in unary), G samples and outputs public parameters pp.
- *Indexer*: On input public parameters pp, predicate parameters  $pp_{\Phi}$  (generated by  $\mathcal{H}$ ), and a predicate index  $i_{\Phi}$ , I deterministically computes and outputs a triple (apk, avk, dk) consisting of an accumulator proving key apk, an accumulator verification key avk, and a decision key dk.<sup>3</sup>
- Accumulation prover: On input the accumulator proving key apk, inputs  $[q_i]_{i=1}^n$ , and old accumulators  $[\mathsf{acc}_j]_{j=1}^m$ , P outputs a new accumulator acc and a proof  $\pi_V$  for the accumulation verifier.
- Accumulation verifier: On input the accumulator verification key avk, inputs  $[q_i]_{i=1}^n$ , accumulator instances  $[acc_j]_{j=1}^m$ , a new accumulator instance acc, and a proof  $\pi_V$ , V outputs a bit indicating whether a correctly accumulates  $[q_i]_{i=1}^n$  and  $[acc_j]_{i=1}^m$ .
- *Decider:* On input the decision key dk, and an accumulator acc, D outputs a bit indicating whether acc is a valid accumulator.

These algorithms must satisfy two properties, *completeness* and *soundness*, defined below. We additionally define a notion of zero knowledge that we will rely on to achieve zero knowledge PCD (see Section 5).

**Completeness.** For all (unbounded) adversaries A,

$$\Pr\left[\begin{array}{c} \forall j \in [m], \, \mathcal{D}^{\rho}(\mathsf{dk}, \mathsf{acc}_j) = 1 \\ \forall i \in [n], \, \Phi^{\rho}(\mathsf{pp}_{\Phi}, \mathsf{i}_{\Phi}, \mathsf{q}_i) = 1 \\ \\ \mathbb{V}^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \mathsf{acc}, \pi_{\mathcal{V}}) = 1 \\ \\ \mathcal{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \end{array}\right. \quad \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp}_{\Phi} \leftarrow \mathcal{H}^{\rho}(1^{\lambda}) \\ \\ (\mathsf{i}_{\Phi}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\Phi}) \\ \\ (\mathsf{acc}, \pi_{\mathcal{V}}) \leftarrow \mathcal{P}^{\rho}(\mathsf{apk}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m) \end{array}\right] = 1 \ .$$

Note that for m=n=0, the precondition on the left-hand side holds vacuously; this is required for the completeness condition to be non-trivial.

**Soundness.** For every polynomial-size adversary A,

$$\Pr\left[\begin{array}{c} \mathbf{V}^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \mathsf{acc}, \pi_{\mathbf{V}}) = 1 \\ \mathbf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \\ & \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad$$

 $<sup>^3</sup>$ We remark that in some schemes it is important, for the sake of efficiency, for the indexer I to have oracle access to the predicate parameters  $pp_{\Phi}$  and predicate index  $i_{\Phi}$ , rather than reading them in full. All of our constructions and statements extend, in a straightforward way, to this case.

**Zero knowledge.** There exists a polynomial-time simulator S such that for every polynomial-size "honest" adversary A (see below) the following distributions are (statistically/computationally) indistinguishable:

$$\left\{ (\rho, \mathsf{pp}, \mathsf{acc}) \middle| \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow G^{\rho}(1^{\lambda}) \\ \mathsf{pp}_{\Phi} \leftarrow \mathcal{H}^{\rho}(1^{\lambda}) \\ (\mathsf{i}_{\Phi}, [\mathsf{q}_{i}]_{i=1}^{n}, [\mathsf{acc}_{j}]_{j=1}^{m}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\Phi}) \\ (\mathsf{apk}, \mathsf{avk}, \mathsf{dk}) \leftarrow I^{\rho}(\mathsf{pp}, \mathsf{pp}_{\Phi}, \mathsf{i}_{\Phi}) \\ (\mathsf{acc}, \pi_{V}) \leftarrow P^{\rho}(\mathsf{apk}, [\mathsf{q}_{i}]_{i=1}^{n}, [\mathsf{acc}_{j}]_{j=1}^{m}) \end{array} \right\}$$
 and 
$$\left\{ \left( \rho[\mu], \mathsf{pp}, \mathsf{acc} \right) \middle| \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ (\mathsf{pp}, \tau) \leftarrow S^{\rho}(1^{\lambda}) \\ \mathsf{pp}_{\Phi} \leftarrow \mathcal{H}^{\rho}(1^{\lambda}) \\ (\mathsf{i}_{\Phi}, [\mathsf{q}_{i}]_{i=1}^{n}, [\mathsf{acc}_{j}]_{j=1}^{m}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\Phi}) \\ (\mathsf{acc}, \mu) \leftarrow S^{\rho}(\mathsf{pp}_{\Phi}, \tau, \mathsf{i}_{\Phi}) \end{array} \right\} .$$

Here  $\mathcal A$  is *honest* if it outputs, with probability 1, a tuple  $(\mathsf{i}_\Phi,[\mathsf{q}_i]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m)$  such that  $\Phi^\rho(\mathsf{pp}_\Phi,\mathsf{i}_\Phi,\mathsf{q}_i)=1$  and  $\mathrm{D}^\rho(\mathsf{dk},\mathsf{acc}_j)=1$  for all  $i\in[n]$  and  $j\in[m]$ . Note that the simulator  $\mathrm{S}$  is *not* required to simulate the accumulation verifier proof  $\pi_\mathrm{V}$ .

Security in the standard model. The corresponding security definitions in the standard (CRS) model are obtained from the above by removing the random oracle  $\rho$  wherever it appears.

**Post-quantum security.** The post-quantum analogues of the above definitions are obtained by modifying the soundness and zero knowledge guarantees to quantify over polynomial-size *quantum* adversaries  $\mathcal{A}$ ; we also strengthen the zero knowledge guarantee to require quantum computational indistinguishability (although we do not permit S to be quantum). In the random oracle variant of the definitions, we should also allow the adversary superposition access to the random oracle (i.e., require security in the *quantum* random oracle model [BDFLSZ11]). Note, however, that this latter issue is not relevant to the present work: our only result on post-quantum security is Theorem 5.2, which is in the standard (CRS) model.

### <span id="page-22-0"></span>4.2 Accumulation schemes for certain predicates

We conclude by specializing the definition of an accumulation scheme to the case of predicates induced by the verifier in a non-interactive argument (Definition 4.1) and in a polynomial commitment scheme (Definition 4.2).

<span id="page-22-1"></span>**Definition 4.1** (accumulation for ARG). A non-interactive argument system ARG =  $(\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  has an accumulation scheme if the pair  $(\Phi_{\mathcal{V}}, \mathcal{G})$  has an accumulation scheme, where  $\Phi_{\mathcal{V}}$  is defined as follows:

$$\Phi_{\mathcal{V}}^{\rho}(i_{\Phi} = (\mathsf{pp}, i), \mathsf{q} = (\mathsf{x}, \pi)): \\ 1. \ (ipk, ivk) \leftarrow \mathcal{I}^{\rho}(\mathsf{pp}, i). \\ 2. \ \textit{Output } \mathcal{V}^{\rho}(ivk, \mathsf{x}, \pi).$$

<span id="page-22-2"></span>**Definition 4.2** (accumulation for PC). A polynomial commitment scheme PC = (Setup, Trim, Commit, Open, Check) has an accumulation scheme if, for every  $D(\lambda) = \text{poly}(\lambda)$ , the pair  $(\Phi_{PC}, \mathcal{H}_{PC,D})$  defined below has an accumulation scheme.

$$\begin{array}{ll} \Phi^{\rho}_{\mathsf{PC}}(\mathsf{i}_{\Phi} = (\mathsf{pp}_{\mathsf{PC}}, [d_i]_{i=1}^n), q = ((C, d, z, v), \pi)) \colon & \mathcal{H}^{\rho}_{\mathsf{PC}, D}(1^{\lambda}) \colon \\ 1. \ (\mathsf{ck}, \mathsf{rk}) \leftarrow \mathsf{PC}.\mathsf{Trim}^{\rho}(\mathsf{pp}_{\mathsf{PC}}, [d_i]_{i=1}^n). & \textit{Output } \mathsf{pp}_{\mathsf{PC}} \leftarrow \mathsf{PC}.\mathsf{Setup}^{\rho}(1^{\lambda}, D(\lambda)). \\ 2. \ \textit{Output } \mathsf{PC}.\mathsf{Check}^{\rho}(\mathsf{rk}, C, d, z, v, \pi). & \text{Output } \mathsf{pp}_{\mathsf{PC}} \to \mathsf{PC}.\mathsf{Setup}^{\rho}(1^{\lambda}, D(\lambda)). \end{array}$$

# <span id="page-23-0"></span>5 Proof-carrying data from accumulation schemes

We formally restate and then prove Theorem [1,](#page-3-0) which provides a construction of proof-carrying data (PCD) from any SNARK that has an accumulation scheme with certain efficiency properties.

First, we provide some notation for these properties.

Definition 5.1. *Let* AS = (G,I,P, V, D) *be an accumulation scheme for a non-interactive argument (see Section [6\)](#page-30-0). We denote by* V(λ,m,N,k) *the circuit corresponding to the computation of the accumulation verifier* V*, for security parameter* λ*, when checking the accumulation of* m *instance-proof pairs and accumulators, on an index of size at most* N*, where each instance is of size at most* k*.*

*We denote by* v(λ, m, N, k) *the size of the circuit* V(λ,m,N,k) *, by* |avk(λ, m, N)| *the size of the accumulator verification key* avk*, and by* |acc(λ, m, N)| *the size of an accumulator.*

Note that here we have specified that the size of acc is bounded by a function of λ, m, N; in particular, it *may not* depend on the number of instances accumulated.

When we invoke the accumulation verifier in our construction of PCD, an instance will consist of an accumulator verification key, an accumulator, and some additional data of size `. Thus the size of the accumulation verifier circuit used in the scheme is given by

$$\mathsf{v}^*(\lambda, m, N, \ell) := \mathsf{v}(\lambda, m, N, |\mathsf{avk}(\lambda, m, N)| + |\mathsf{acc}(\lambda, m, N)| + \ell) \ .$$

The notion of "sublinear verification" which is important here is that v ∗ is sublinear in N. The following theorem shows that when this is the case, this accumulation scheme can be used to construct PCD.

<span id="page-23-1"></span>Theorem 5.2. *There exists a polynomial-time transformation* T *such that if* ARG = (G, I,P, V) *is a SNARK for circuit satisfiability and* AS *is an accumulation scheme for* ARG *then* PCD = (G,I, P, V) := T(ARG, AS) *is a PCD scheme for constant-depth compliance predicates, provided*

$$\exists\,\epsilon\in(0,1)\ \text{and a polynomial}\ \alpha\ \text{s.t.}\ \mathsf{v}^*(\lambda,m,N,\ell)=O(N^{1-\epsilon}\cdot\alpha(\lambda,m,\ell))\ \ .$$

*Moreover:*

- *If* ARG *and* AS *are secure against quantum adversaries, then* PCD *is secure against quantum adversaries.*
- *If* ARG *and* AS *are (post-quantum) zero knowledge, then* PCD *is (post-quantum) zero knowledge.*
- *If the size of the predicate* ϕ: F (m+2)` → F *is* f = ω(α(λ, m, `) <sup>1</sup>/) *then:*
  - *the cost of running* I *is equal to the cost of running both* I *and* I *on an index of size* f + o(f)*;*
  - *the cost of running* P *is equal to the cost of accumulating* m *instance-proof pairs using* P*, and running* P*, on an index of size* f + o(f) *and instance of size* o(f)*;*
  - *the cost of running* V *is equal to the cost of running both* V *and* D *on an index of size* f + o(f) *and an instance of size* o(f)*.*

This last point gives the conditions for a *sublinear additive* recursive overhead; i.e., when the *additional* cost of proving that ϕ is satisfied recursively is asymptotically smaller than the cost of proving that ϕ is satisfied locally. Note that the smaller the compliance predicate ϕ, the more efficient the accumulation scheme has to be in order to achieve this.

Our PCD construction and its proof of security follow those given in [\[COS20\]](#page-52-5), except for several important differences.

- In [COS20], the circuit on which the SNARK prover is invoked contains the SNARK verifier circuit. In our setting, this is not possible in general since the verifier may not be succinct. Instead, we invoke the SNARK prover on a circuit containing the accumulation verifier circuit.
- The PCD proof consists of both a SNARK proof  $\pi$  and an accumulator acc; verifying the computation requires running the SNARK verifier on  $\pi$  and the accumulation scheme decider on acc.
- Since the security of the accumulation scheme is proved separately to the security of the SNARK itself, we require that the SNARK remain secure with respect to the auxiliary input distribution induced by the public parameters of the accumulation scheme.

The rest of this section is dedicated to proving Theorem 5.2: in Section 5.1 we construct the PCD scheme; in Section 5.2 we prove that accumulation verifiers that are sublinear suffice for PCD; in Section 5.3 we prove completeness; in Section 5.4 we prove knowledge soundness; in Section 5.5 we discuss zero knowledge; and in Section 5.6 we discuss post-quantum security.

Remark 5.3. Theorem 5.2 yields PCD that is secure for constant-depth compliance predicates. The depth restriction is necessary because of the recursive invocation of the extractor: if the extractor has size  $e(n) = n^c$ , then recursively applying the extractor d times (for a depth-d predicate) yields a circuit of size  $n^{c^d}$ , which for  $d = \omega(1)$  is superpolynomial. Under a subexponential knowledge assumption one can increase d to  $o(\log n)$ .

#### <span id="page-24-0"></span>**5.1** Construction

Let ARG =  $(\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  be a non-interactive argument for circuit satisfiability, and let AS = (G, I, P, V, D)be an accumulation scheme for ARG. Below we construct a PCD scheme  $PCD = (\mathbb{G}, \mathbb{I}, \mathbb{P}, \mathbb{V})$ .

Given a compliance predicate  $\varphi \colon \mathbb{F}^{(m+2)\ell} \to \mathbb{F}$ , the circuit that realizes the recursion is as follows.

$$R_{\mathrm{V},\varphi}^{(\lambda,N,k)}\big((\mathsf{avk},z,\mathsf{acc}),(z_{\mathsf{loc}},[z_i,\pi_i,\mathsf{acc}_i]_{i=1}^m,\pi_{\mathrm{V}})\big) \colon$$

- 1. Check that the compliance predicate  $\varphi(z, z_{loc}, z_1, \dots, z_m)$  accepts.
- 2. If there exists  $i \in [m]$  such that  $z_i \neq \bot$ , check that the SNARK accumulation verifier accepts:

$$\mathbf{V}^{(\lambda,m,N,k)}(\mathsf{avk},[(\mathsf{avk},z_i,\mathsf{acc}_i),\pi_i]_{i=1}^m,[\mathsf{acc}_i]_{i=1}^m,\mathsf{acc},\pi_\mathbf{V})=1 \ .$$

3. If the above checks hold, output 1; otherwise, output 0.

Above,  $V^{(\lambda,m,N,k)}$  refers to the circuit representation of V with input size appropriate for security parameter  $\lambda$ , number of instance-proof pairs and accumulators m, index size N, and instance size k.

Next we describe the generator  $\mathbb{G}$ , indexer  $\mathbb{I}$ , prover  $\mathbb{P}$ , and verifier  $\mathbb{V}$  of the PCD scheme.

- $\mathbb{G}(1^{\lambda})$ : Sample pp  $\leftarrow \mathcal{G}(1^{\lambda})$  and pp<sub>AS</sub>  $\leftarrow \mathbb{G}(1^{\lambda})$ , and output  $\mathbb{pp} := (pp, pp_{AS})$ .
- - 1. Compute the integer  $N:=N(\lambda,|\varphi|,m,\ell)$ , where N is defined in Lemma 5.4 below. 2. Construct the circuit  $R:=R_{{\rm V},\varphi}^{(\lambda,N,k)}$  where  $k:=|{\sf avk}(\lambda,N)|+\ell+|{\sf acc}(\lambda,N)|$ .
  - 3. Compute the index key pair  $(ipk, ivk) \leftarrow \mathcal{I}(pp, R)$  for the circuit R for the SNARK.
  - 4. Compute the index key triple (apk, dk, avk)  $\leftarrow$  I(pp<sub>AS</sub>, i<sub> $\Phi$ </sub> = (pp, R)) for the accumulator.
  - 5. Output ipk := (ipk, apk) and ivk := (ivk, dk, avk).
- $\mathbb{P}(\mathsf{ipk}, z, z_{\mathsf{loc}}, [z_i, (\pi_i, \mathsf{acc}_i)]_{i=1}^m)$ :
  - 1. If  $z_i = \bot$  for all  $i \in [m]$  then set  $(\mathsf{acc}, \pi_V) \leftarrow P(\mathsf{apk}, \bot)$ .
  - 2. If  $z_i \neq \bot$  for some  $i \in [m]$  then compute  $(\mathsf{acc}, \pi_V) \leftarrow P(\mathsf{apk}, [(\mathsf{avk}, z_i, \mathsf{acc}_i), \pi_i]_{i=1}^m, [\mathsf{acc}_i]_{i=1}^m)$ .
  - 3. Compute  $\pi \leftarrow \mathcal{P}(\text{ipk}, (\text{avk}, z, \text{acc}), (z_{\text{loc}}, [z_i, \pi_i, \text{acc}_i]_{i=1}^m, \pi_V))$ .

- 4. Output  $(\pi, acc)$ .
- $V(ivk, z, (\pi, acc))$ : Accept if both  $V(ivk, (avk, z, acc), \pi)$  and D(dk, acc) accept.

## <span id="page-25-0"></span>5.2 Efficiency

Denote by f the size of the compliance predicate  $\varphi$  as an R1CS instance. In the above construction, the explicit input consists of the accumulator verification key avk, whose size depends on N and  $\lambda$ , a message z whose size is  $\ell$  (independent of N), and an accumulator acc whose size depends on N and  $\lambda$ . The security parameter  $\lambda$  is independent of N. The circuit  $R_{V,\varphi}^{(\lambda,N,k)}$  on which we wish to invoke V is of size

$$S(\lambda, f, m, \ell, N) = f + S_0(m, \ell) + v^*(\lambda, m, N, \ell)$$
 for some  $S_0(m, \ell) = O(m\ell)$ ,

recalling that  $\mathsf{v}^*(\lambda, m, N, \ell) = \mathsf{v}(\lambda, m, N, |\mathsf{avk}(\lambda, m, N)| + |\mathsf{acc}(\lambda, m, N)| + \ell)$ .

The goal of this section to find the (asymptotically) smallest index size bound function N such that  $S(\lambda, f, m, \ell, N(\lambda, f, m, \ell)) \leq N(\lambda, f, m, \ell)$ . This ensures that the circuit for checking an index of size N is of size at most N, which permits recursion.

<span id="page-25-1"></span>**Lemma 5.4.** Suppose that for every security parameter  $\lambda \in \mathbb{N}$ , arity m, and message size  $\ell \in \mathbb{N}$  the ratio of accumulation verifier circuit size to index size  $\mathsf{v}^*(\lambda, m, N, \ell)/N$  is monotone decreasing in N. Then there exists a size function  $N(\lambda, f, m, \ell)$  such that

$$\forall \lambda, f, m, \ell \in \mathbb{N} \quad S(\lambda, f, m, \ell, N(\lambda, f, m, \ell)) \leq N(\lambda, f, m, \ell)$$
.

Moreover if for some  $\epsilon > 0$  and some increasing function  $\alpha$  it holds that, for all  $N, \lambda, m, \ell$  sufficiently large,

$$\mathsf{v}^*(\lambda, m, N, \ell) \le N^{1-\epsilon} \alpha(\lambda, m, \ell)$$

then, for all  $\lambda, m, \ell$  sufficiently large,

$$N(\lambda, f, m, \ell) \le O(f + \alpha(\lambda, m, \ell)^{1/\epsilon})$$
.

*Proof.* Let  $N_0 := N_0(\lambda, m, \ell)$  be the smallest integer such that  $\mathsf{v}^*(\lambda, m, N_0, \ell)/N_0 < 1/2$ ; this exists because of the monotone decreasing condition. Let  $N(\lambda, f, m, \ell) := \max(N_0(\lambda, m, \ell), 2(f + S_0(m, \ell)))$ . Then for  $N := N(\lambda, f, m, \ell)$  it holds that

$$S(\lambda, f, m, \ell, N) = f + S_0(m, \ell) + N \cdot v^*(\lambda, m, N, \ell)/N < N/2 + N/2 = N$$
.

Clearly  $f+S_0(m,\ell)=O(f)$ . Now suppose that  $\mathbf{v}^*(\lambda,m,N,\ell)\leq N^{1-\epsilon}\alpha(\lambda,m,\ell)$  for all sufficiently large  $N,\lambda,m,\ell$ . Let  $N'(\lambda,m,\ell):=(2\cdot\alpha(\lambda,m,\ell))^{1/\epsilon}$ . Then since  $\alpha$  is increasing, for sufficiently large  $\lambda,m,\ell$ , for  $N':=N'(\lambda,m,\ell)$ ,

$$\mathbf{v}^*(\lambda,m,N',\ell)/N'<\alpha(\lambda,m,\ell)\cdot(2\alpha(\lambda,m,\ell))^{-1}=1/2\ .$$

Hence  $N_0 \leq N' = (2 \cdot \alpha(\lambda, m, \ell))^{1/\epsilon}$ , for sufficiently large  $\lambda, m, \ell$ , and so  $N(\lambda, f, m, \ell) \leq O(f + \alpha(\lambda, m, \ell)^{1/\epsilon})$ .

We can now bound the size of the recursive circuit.

**Corollary 5.5.** For the function N above,  $S(\lambda, f, m, \ell, N) = f + O(f^{1-\epsilon} \cdot \alpha(\lambda, m, \ell) + \alpha(\lambda, m, \ell)^{1/\epsilon}).$ 

*Proof.* Using the expression for S above, and the bound on N,

$$\begin{split} S(\lambda,f,m,\ell,N) &= f + O(m\ell) + \mathsf{v}^*(\lambda,m,N,\ell) \\ &= f + O(N^{1-\epsilon}\alpha(\lambda,m,\ell)) \\ &= f + O(f^{1-\epsilon} \cdot \alpha(\lambda,m,\ell) + \alpha(\lambda,m,\ell)^{1/\epsilon}) \ . \end{split} \qquad \Box$$

In particular if  $f = \omega(\alpha(\lambda, m, \ell)^{1/\epsilon})$  then this is f + o(f), and so the stated efficiency bounds hold.

## <span id="page-26-0"></span>5.3 Completeness

Let  $\mathcal{A}$  be any adversary that causes the completeness condition of PCD to be satisfied with probability p. We construct an adversary  $\mathcal{B}$ , as follows, that causes the completeness condition of AS to be satisfied with probability at most p.

```
\mathcal{B}(\mathsf{pp},\mathsf{pp}_{\mathsf{AS}}):
1. Set \mathtt{pp} := (\mathsf{pp},\mathsf{pp}_{\mathsf{AS}}) and compute (\varphi,z,z_{\mathsf{loc}},[z_i,\pi_i,\mathsf{acc}_i]_{i=1}^m) \leftarrow \mathcal{A}(\mathtt{pp}).
2. Run (\mathsf{apk},\mathsf{dk},\mathsf{avk}) \leftarrow \mathrm{I}(\mathsf{pp}_{\mathsf{AS}},\mathsf{pp},R_{\mathsf{V},\varphi}^{(\lambda,N,k)}).
3. Output (R_{\mathsf{V},\varphi}^{(\lambda,N,k)},[(\mathsf{avk},z_i,\mathsf{acc}_i),\pi_i]_{i=1}^m,[\mathsf{acc}_i]_{i=1}^m).
```

Suppose that  $\mathcal{A}$  outputs  $(\varphi, z, z_{\text{loc}}, [z_i, \pi_i, \operatorname{acc}_i]_{i=1}^m)$  such that the completeness precondition is satisfied, but  $\mathbb{V}(\operatorname{ivk}, z, (\pi, \operatorname{acc})) = 0$ . Then, by construction of  $\mathbb{V}$ , it holds that either  $\mathcal{V}(\operatorname{ivk}, (\operatorname{avk}, z, \operatorname{acc}), \pi) = 0$  or  $\mathrm{D}(\operatorname{dk}, \operatorname{acc}) = 0$ . If  $z_i = \bot$  for all i, then by perfect completeness of ARG both of these algorithms output 1; hence there exists i such that  $z_i \neq \bot$ . Hence it holds that for all i,  $\mathbb{V}(\operatorname{ivk}, z_i, (\pi_i, \operatorname{acc}_i)) = 1$ , whence for all i,  $\mathbb{V}(\operatorname{ivk}, (\operatorname{avk}, z_i, \operatorname{acc}_i), \pi_i) = \Phi_{\mathcal{V}}(\operatorname{pp}, R_{V, \varphi}^{(\lambda, N, k)}, (\operatorname{avk}, z_i, \operatorname{acc}_i), \pi_i) = 1$  and  $\mathrm{D}(\operatorname{dk}, \operatorname{acc}_i) = 1$ .

If  $\mathcal{V}(\text{ivk}, (\text{avk}, z, \text{acc}), \pi) = 0$ , then, by perfect completeness of ARG, we know that  $R_{V,\varphi}^{(\lambda,N,k)}$  rejects  $\left((\text{avk}, z, \text{acc}), (z_{\text{loc}}, [z_i, \pi_i, \text{acc}_i]_{i=1}^m), \pi_V\right)$ , and so  $V(\text{avk}, [(\text{avk}, z_i, \text{acc}_i), \pi_i]_{i=1}^m, [\text{acc}_i]_{i=1}^m, \text{acc}) = 0$ . Otherwise, D(dk, acc) = 0.

Now consider the completeness experiment for AS with adversary  $\mathcal{B}$ . Since pp, pp<sub>AS</sub> are drawn identically to the PCD experiment, the distribution of the output of  $\mathcal{A}$  is identical. Hence in particular it holds that for all i,  $\Phi_{\mathcal{V}}(\mathsf{pp}, R_{\mathcal{V},\varphi}^{(\lambda,N,k)}, (\mathsf{avk}, z_i, \mathsf{acc}_i), \pi_i) = 1$  and  $\mathrm{D}(\mathsf{dk}, \mathsf{acc}_i) = 1$ . By the above, it holds that either  $\mathrm{V}(\mathsf{avk}, [(\mathsf{avk}, z_i, \mathsf{acc}_i), \pi_i]_{i=1}^m, [\mathsf{acc}_i]_{i=1}^m, \mathsf{acc}) = 0$  or  $\mathrm{D}(\mathsf{dk}, \mathsf{acc}) = 0$ , and so  $\mathcal{B}_1, \mathcal{B}_2$  cause the completeness condition for AS to be satisfied with probability at most p.

### <span id="page-26-1"></span>5.4 Knowledge soundness

Since the extracted transcript T will be a tree, we find it convenient to associate the label  $z^{(u,v)}$  of the unique outgoing edge of a node u with the node u itself, so that the node u is labelled with  $(z^{(u)}, z^{(u)}_{\text{loc}})$ . For the purposes of the proof we also associate with each node u a SNARK proof  $\pi^{(u)}$  and an accumulator  $\text{acc}^{(u)}$ , so that the full label for a node is  $(z^{(u)}, z^{(u)}_{\text{loc}}, \pi^{(u)}, \text{acc}^{(u)})$ . It is straightforward to transform such a transcript into one that satisfies Definition 3.1.

Given a malicious prover  $\tilde{\mathbb{P}}$ , we will define an extractor  $\mathbb{E}_{\tilde{\mathbb{P}}}$  that satisfies knowledge soundness. In the process we construct a sequence of extractors  $\mathbb{E}_1,\ldots,\mathbb{E}_d$  for  $d:=d(\varphi)$  (the depth of  $\varphi$ );  $\mathbb{E}_j$  outputs a tree of depth j+1. Let  $\mathbb{E}_0(\mathbb{PP})$  run  $(\varphi,\mathsf{o},\pi,\mathsf{acc})\leftarrow \tilde{\mathbb{P}}(\mathbb{PP})$  and output  $(\varphi,\mathsf{T}_0)$ , where  $\mathsf{T}_0$  is a single node labeled with  $(\mathsf{o},\pi,\mathsf{acc})$ . Let  $l_\mathsf{T}(j)$  denote the vertices of T at depth  $j;l_\mathsf{T}(0):=\emptyset$  and  $l_\mathsf{T}(1)$  is the singleton containing the root.

Now we define the extractor  $\mathbb{E}_j$  inductively for each  $j \in [d]$ . Suppose we have already constructed  $\mathbb{E}_{j-1}$ . We construct a SNARK prover  $\tilde{\mathcal{P}}_j$  as follows:

 $\tilde{\mathcal{P}}_{j}(\mathsf{pp},\mathsf{pp}_{\mathsf{AS}})$ :

- 1. Compute  $(\varphi, \mathsf{T}_{j-1}) \leftarrow \mathbb{E}_{j-1}(\mathsf{pp}, \mathsf{pp}_{\mathsf{AS}})$ .
- 2. For each vertex  $v \in l_{\mathsf{T}_{j-1}}(j)$ , denote its label by  $(z^{(v)}, \pi^{(v)}, \mathsf{acc}^{(v)})$ .
- 3. Run the argument indexer (ipk, ivk)  $\leftarrow \mathcal{I}(\mathsf{pp}, R_{V,\varphi}^{(\lambda,N,k)})$ . Run the accumulator indexer (apk, dk, avk)  $\leftarrow \mathrm{I}(\mathsf{pp}_{\mathsf{AS}}, \mathsf{pp}, R_{V,\varphi}^{(\lambda,N,k)})$ .
- 4. Output

$$(\vec{\mathbf{i}},\vec{\mathbf{x}},\vec{\pi},\mathsf{aux}) := \left(\vec{R},(\mathsf{avk},z^{(v)},\mathsf{acc}^{(v)})_{v \in l_{\mathsf{T}_{j-1}}(j)},(\pi^{(v)})_{v \in l_{\mathsf{T}_{j-1}}(j)},(\varphi,\mathsf{T}_{j-1})\right)$$

where  $\vec{R}$  is the vector  $(R_{V,\varphi}^{(\lambda,N,k)},\dots,R_{V,\varphi}^{(\lambda,N,k)})$  of the appropriate length.

Next let  $\mathcal{E}_{\tilde{\mathcal{P}}_j}$  be the extractor that corresponds to  $\tilde{\mathcal{P}}_j$ , via the knowledge soundness of the non-interactive argument ARG. Finally the extractor  $\mathbb{E}_i$  is defined as follows:

 $\mathbb{E}_{j}(\mathbb{pp} = (\mathsf{pp}, \mathsf{pp}_{\mathsf{AS}}))$ :

- 1. Run the extractor  $(\vec{i}, \vec{x}, \vec{\pi}, \mathsf{aux}, \vec{w}) \leftarrow \mathcal{E}_{\tilde{\mathcal{P}}_i}(\mathsf{pp}, \mathsf{pp}_{\mathsf{AS}})$ .
- 2. Parse the auxiliary output aux as  $(\varphi, \mathsf{T}')$ .
- 3. If T' is not a transcript of depth j, abort.
- 4. Output  $(\varphi, \mathsf{T}_j)$  where  $\mathsf{T}_j$  is the transcript constructed from  $\mathsf{T}'$  by doing the following for each vertex  $v \in l_{\mathsf{T}'}(j)$ :
  - $\bullet$  obtain the local data  $z_{\mathsf{loc}}^{(v)}$  and input messages  $\left(z_i, \pi_i, \mathsf{acc}_i\right)_{i \in [m]}$  from  $\mathbf{w}^{(v)}$ ;
  - append  $z_{loc}^{(v)}$  to the label of v, and if there exists any  $z_i$  with  $z_i \neq \bot$ , attach m children to v where the i-th child is labeled with  $(z_i, \pi_i, acc_i)$ .

The extractor  $\mathbb{E}_{\tilde{\mathbb{P}}}$  runs  $(\varphi, \mathsf{T}_d) \leftarrow \mathbb{E}_d(\mathsf{urs})$  and outputs  $(\varphi, (\pi, \mathsf{acc}), \mathsf{T}_d)$ , where  $(z, z_{\mathsf{loc}}, \pi, \mathsf{acc})$  labels the root node.

We now show that  $\mathbb{E}_{\tilde{\mathbb{P}}}$  has polynomial size and that it outputs a transcript that is  $\varphi$ -compliant.

Size of the extractor.  $\tilde{\mathcal{P}}_j$  is a circuit of size  $|\mathbb{E}_{j-1}| + |\mathrm{I}| + O(2^j)$ , so  $\mathcal{E}_{\tilde{\mathcal{P}}_j}$  is a circuit of size  $e(|\mathbb{E}_{j-1}| + |\mathcal{I}| + O(2^j))$ . Then  $|\mathbb{E}_j| \le e(|\mathbb{E}_{j-1}| + |\mathcal{I}| + c \cdot 2^j)$  for some  $c \in \mathbb{N}$ .

A solution to this recurrence (for  $e(n) \geq n$ ) is  $|\mathbb{E}_j| \leq e^{(j)}(|\tilde{\mathbb{P}}| + j \cdot |\mathcal{I}| + 2c \cdot 2^j)$ , where  $e^{(j)}$  is the function e iterated j times. Hence in particular if  $d(\varphi)$  is a constant,  $\mathbb{E}_{\tilde{\mathbb{P}}}$  is a circuit of polynomial size.

**Correctness of the extractor.** Suppose that  $\tilde{\mathbb{P}}$  causes  $\mathbb{V}$  to accept with probability  $\mu$ . We show by induction that, for all  $j \in \{0, \ldots, d\}$ , the transcript  $\mathsf{T}_j$  output by  $\mathbb{E}_j$  is  $\varphi$ -compliant up to depth j, and that for all  $v \in \mathsf{T}$ , both  $\mathcal{V}(\mathrm{ivk}, (\mathsf{avk}, z^{(v)}, \mathsf{acc}^{(v)}), \pi^{(v)})$  and  $\mathrm{D}(\mathsf{dk}, \mathsf{acc}^{(v)})$  accept, with probability  $\mu - \mathrm{negl}(\lambda)$ .

For j=0 the statement is implied by  $\mathbb V$  accepting with probability  $\mu.$ 

Now suppose that  $\mathsf{T}_{j-1} \leftarrow \mathbb{E}_{j-1}$  is  $\varphi$ -compliant up to depth j-1, and that both  $\mathcal{V}(\mathrm{ivk}, (\mathsf{avk}, z^{(v)}, \mathsf{acc}^{(v)}), \pi^{(v)})$  and  $\mathsf{D}(\mathsf{dk}, \mathsf{acc}^{(v)})$  accept for all  $v \in \mathsf{T}_{j-1}$ , with probability  $\mu - \mathrm{negl}(\lambda)$ .

$$\mathrm{Let}\,(\vec{\mathbf{i}},(\mathsf{avk}_v,z^{(v)},\mathsf{acc}^{(v)})_v,(\pi^{(v)})_v,(\varphi,\mathsf{T}'),\vec{\mathbf{w}}) \leftarrow \mathcal{E}_{\tilde{\mathcal{P}}_j}.$$

By knowledge soundness of ARG, with probability  $\mu - \operatorname{negl}(\lambda)$ :

- for  $v \in l_{\mathsf{T}'}(j)$ , v is labeled with  $(z^{(v)}, \pi^{(v)}, \mathsf{acc}^{(v)})$  and  $\mathsf{avk}_v = \mathsf{avk}$  where  $(\mathsf{apk}, \mathsf{dk}, \mathsf{avk}) \leftarrow \mathsf{I}(\mathsf{pp}_{\mathsf{AS}}, \Phi)$ ,
- for every vertex  $v \in l_{\mathsf{T}'}(j)$ ,  $(R_{\mathsf{V},\varphi}^{(\lambda,N,k)},(\mathsf{avk},z^{(v)},\mathsf{acc}^{(v)}), \mathsf{w}^{(v)}) \in \mathcal{R}_{\mathrm{R1CS}}$ , and

• by induction T' is  $\varphi$ -compliant up to depth j-1 and D(dk,  $acc^{(v)}$ ) accepts for all  $v \in T'$ . Here we use the auxiliary output in the knowledge soundness definition of ARG to ensure consistency between the values  $z^{(v)}$  and T', and to ensure that T' is  $\varphi$ -compliant.

Consider some  $v \in l_{\mathsf{T}'}(j)$ . Since  $(R_{\mathsf{V},\omega}^{(\lambda,N,k)},(\mathsf{avk}_v,z^{(v)},\mathsf{acc}^{(v)}),\mathsf{w}^{(v)}) \in \mathcal{R}_{\mathsf{R1CS}}$ , we obtain from  $\mathsf{w}^{(v)}$ either

- local data  $z_{\mathsf{loc}}$ , input messages  $\left(z_i, \pi_i, \mathsf{acc}_i\right)_{i \in [m]}$  and proof  $\pi_V$  such that  $\varphi(z^{(v)}, z_{\mathsf{loc}}, z_1, \dots, z_m)$  accepts and the accumulation verifier  $V^{(\lambda,N,k)}(avk, [(avk, z_i, acc_i), \pi_i]_{i=1}^m, [acc_i]_{i=1}^m, acc^{(v)}, \pi_V)$  accepts; or
- local data  $z_{\mathsf{loc}}$  such that  $\varphi(z^{(v)}, z_{\mathsf{loc}}, \bot, \dots, \bot)$  accepts.

In both cases we append  $z_{\mathsf{loc}}^{(v)} := z_{\mathsf{loc}}$  to the label of v. In the latter case, v has no children and so is  $\varphi$ -compliant by the base case condition. In the former case we label the children of v with  $(z_i, \pi_i, \mathsf{acc}_i)$ , and so v is  $\varphi$ compliant. Moreover, by the soundness of the accumulation scheme, since  $D(dk, acc^{(v)})$  and the accumulation  $\text{verifier accept, it holds that for all descendants } w, \mathbf{D}(\mathsf{dk},\mathsf{acc}^{(w)}) \text{ accepts and } \Phi_{\mathcal{V}}(\mathsf{pp}, R_{\mathbf{V},\varphi}^{(\acute{\lambda},N,k)}, (\mathsf{avk}, z_{\mathsf{in}}^{(w)}, \mathsf{acc}^{(w)}), \pi_{\mathsf{in}}^{(w)}) = 0$  $\mathcal{V}(\mathrm{ivk},(\mathsf{avk},z_{\mathsf{in}}^{(w)},\mathsf{acc}^{(w)}),\pi_{\mathsf{in}}^{(w)}) \text{ accepts.}$ 

Hence by induction,  $(\varphi, \pi, \mathsf{T}) \leftarrow \mathbb{E}$  has  $\varphi$ -compliant  $\mathsf{T}$ .

Since  $(\varphi, o(T), \pi)$  are "passed up" from  $\tilde{\mathbb{P}}$  via a series of d extractors, the distribution output by  $\mathbb{E}$  is statistically close to the output of  $\overline{\mathbb{P}}$  by the knowledge soundness of ARG.

#### <span id="page-28-0"></span>Zero knowledge **5.5**

The simulator  $\mathbb{S}$  operates as follows.

```
\mathbb{S}(1^{\lambda}):
```

- 1. Generate  $(pp_{AS}, \tau_{AS}) \leftarrow S(1^{\lambda})$ , and  $(pp, \tau) \leftarrow S(1^{\lambda})$ .
- 2. Output (pp = (pp, pp $_{\Delta S}$ ),  $(\tau, \tau_{\Delta S})$ ).

- $$\begin{split} \mathbb{S}(\mathbb{pp} &= (\mathsf{pp}, \mathsf{pp}_{\mathsf{AS}}), \varphi, z, (\tau, \tau_{\mathsf{AS}})) \colon \\ 1. \ \ \mathsf{Compute} \ \mathsf{acc} \leftarrow \mathbb{S}(\mathsf{pp}_{\mathsf{AS}}, \mathsf{pp}, R_{\mathsf{V}, \varphi}^{(\lambda, N, k)}, \tau_{\mathsf{AS}}). \end{split}$$
- 2. Compute  $(\mathsf{apk}, \mathsf{dk}, \mathsf{avk}) \leftarrow \mathrm{I}(\mathsf{pp}_{\mathsf{AS}}, (\mathsf{pp}, R_{\mathsf{V},\varphi}^{(\lambda,N,k)})).$
- 3. Compute  $\pi \leftarrow \mathcal{S}(\mathsf{pp}, R_{V, \varnothing}^{(\lambda, N, k)}, (\mathsf{avk}, z, \mathsf{acc}), \tau)$ .
- 4. Output  $(\pi, acc)$ .

We consider the following sequence of hybrids.

- $\mathbf{H}_0$ : The original experiment.
- $\mathbf{H}_1$ : As  $\mathbf{H}_0$ , but the public parameters pp and proof  $\pi$  are generated by the simulator  $\mathcal{S}$  for ARG.
- $H_2$ : As  $H_1$ , but the public parameters  $pp_{AS}$  and accumulator acc is generated by the simulator S for AS. Observe that if  $\mathbf{H}_0$  and  $\mathbf{H}_2$  are indistinguishable, then  $\mathbb{S}$  witnesses the zero knowledge property for PCD.

Since A is honest (for PCD), by completeness of AS it induces an honest adversary for ARG, whence  $\mathbf{H}_0$ and  $\mathbf{H}_1$  are indistinguishable by the zero knowledge property of ARG. Note that since they are part of the witness, the input and accumulator lists  $[q_i]_{i=1}^n$ ,  $[acc_j]_{j=1}^m$  and verifier proof  $\pi_V$  are not used in  $\mathbf{H}_1$ . Hence, since A induces an honest adversary for AS and the simulated pp is indistinguishable from pp  $\leftarrow \mathcal{G}(1^{\lambda})$ ,  $\mathbf{H}_1, \mathbf{H}_2$  are indistinguishable by the zero knowledge property of AS. This establishes that  $\mathbf{H}_0, \mathbf{H}_2$  are indistinguishable.

### <span id="page-28-1"></span>**Post-quantum security**

We consider post-quantum knowledge soundness and zero knowledge.

**Knowledge soundness.** In the quantum setting,  $\tilde{\mathbb{P}}$  is taken to be a polynomial-size *quantum* circuit; hence also  $\tilde{\mathcal{P}}_j, \mathcal{E}_{\tilde{\mathcal{P}}_j}, \mathbb{E}_j$  are quantum circuits for all j, as is the final extractor  $\mathbb{E}$ . Our definition of knowledge soundness is such that this proof then generalizes immediately to show security against quantum adversaries. In particular, the only difficulty arising from quantum adversaries is that they can generate their own randomness, whereas in the classical case we can force an adversary to behave deterministically by fixing its randomness. This is accounted for by the distributional requirement placed on the extractor of the argument system ARG.

**Zero knowledge.** From the argument in the preceding section it is clear that, by modifying the definitions of zero knowledge as appropriate for the quantum setting, if ARG and AS both achieve post-quantum zero knowledge, then so does PCD.

## <span id="page-30-0"></span>6 Accumulation schemes for non-interactive arguments

We formally restate and then prove Theorem 2, which provides a way to "lift" an accumulation scheme for a predicate into an accumulation scheme for any non-interactive argument whose verifier is succinct when given oracle access to that predicate. Below we define the notion of a predicate-efficient non-interactive argument and then state the theorem that we prove.

<span id="page-30-3"></span>**Definition 6.1.** Let  $\mathsf{ARG} = (\mathcal{G}, \mathcal{I}, \mathcal{P}, \mathcal{V})$  be a non-interactive argument,  $\Phi_\circ \colon \mathcal{U}(*) \times (\{0,1\}^*)^3 \to \{0,1\}$  a predicate, and  $T, \mathsf{t} \colon \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ . We say that  $\mathsf{ARG}$  is  $(T, \mathsf{t})$ -predicate-efficient with respect to  $\Phi_\circ$  if the following conditions hold.

- The index verification key ivk has the form  $(i_o, ivk_{pe})$ .
- The verifier V is equivalent to the following decision procedure, for some oracle algorithm  $V_{pe}$ : compute  $(b, Q_i) \leftarrow V_{pe}^{\rho}(ivk_{pe}, x, \pi)$ ; output 1 if and only if (a) b = 1, and (b) for each  $q \in Q_i$ ,  $\Phi_{\circ}^{\rho}(pp, i_{\circ}, q_i) = 1$ .<sup>4</sup>
- $V_{pe}$  runs in time T(N, k), and the number of queries t to  $\Phi_{\circ}$  equals t(N, k) for indices i of size N and instances x of size k.

The following theorem shows that an accumulation scheme for  $(\Phi_o, \mathcal{G})$  implies an accumulation scheme for  $(\Phi_{\mathcal{V}}, \mathcal{G})$ , where  $\Phi_{\mathcal{V}}$  is as specified in Definition 4.1.

<span id="page-30-2"></span>**Theorem 6.2.** Let ARG be a non-interactive argument that is (T,t)-predicate-efficient with respect to  $\Phi_o$ . If  $(\Phi_o,\mathcal{G})$  has an accumulation scheme  $\mathsf{AS}_o$ , then ARG has an accumulation scheme  $\mathsf{AS}_\mathsf{ARG}$  with the efficiency properties below.

- Generator:  $\mathsf{AS}_{\mathsf{ARG}}.G^{\rho}(1^{\lambda})$  takes time equal to  $\mathsf{AS}_{\circ}.G^{\rho}(1^{\lambda})$ .
- $\bullet \ \ Indexer: AS_{ARG}.I^{\rho}(pp_{AS},pp,i) \ \textit{takes time equal to the time to run} \ AS_{\circ}.I^{\rho}(pp_{AS},i_{\circ}).$
- Accumulation prover:  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{P}^{\rho}(\mathsf{apk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m)$  runs in time  $\sum_{i=1}^n T(N,|\mathbf{x}_i|)$  plus the time taken to run  $\mathsf{AS}_{\circ}.\mathsf{P}^{\rho}(\mathsf{apk}_{\circ},Q,[\mathsf{acc}_j]_{j=1}^m)$ , where  $|Q|=\sum_{i=1}^n\mathsf{t}(N,|\mathbf{x}_i|)$ .
- Accumulation verifier:  $\mathsf{AS}_{\mathsf{ARG}}.V^{\rho}(\mathsf{avk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_V)$  runs in time  $\sum_{i=1}^n T(N,|\mathbf{x}_i|)$  plus the time taken to run  $\mathsf{AS}_{\circ}.V^{\rho}(\mathsf{avk}_{\circ},Q:=\cup_{i=1}^nQ_i,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_V)$ .
- Decider:  $\mathsf{AS}_{\mathsf{ARG}}.\mathrm{D}^{\rho}(\mathsf{dk},\mathsf{acc})$  takes time equal to  $\mathsf{AS}_{\circ}.\mathrm{D}^{\rho}(\mathsf{dk}_{\circ},\mathsf{acc})$ .

Moreover, if AS<sub>o</sub> is post-quantum secure, then so is AS<sub>ARG</sub>, and if AS<sub>o</sub> is zero knowledge, so is AS<sub>ARG</sub>.

The rest of this section is dedicated to proving Theorem 6.2: in Section 6.1 we describe the construction of an accumulation scheme for the argument scheme, from which the stated efficiency properties are clear; in Section 6.2 we argue completeness; in Section 6.3 we argue soundness; in Section 6.4 we argue zero knowledge.

<span id="page-30-1"></span>**Remark 6.3** (efficiency for PCD). We briefly discuss the properties required of ARG and AS $_{\circ}$  so that, applying Theorem 6.2, we obtain an accumulation scheme suitable for the PCD construction in Section 5. Recall that Theorem 5.2 states that a PCD scheme can be obtained from any SNARK for circuit satisfiability with an accumulation scheme whose accumulation verifier runs in time that is sub-linear in the size N of the circuit. Hence ARG must be (T, t)-predicate-efficient for T, t = o(N), and AS $_{\circ}$ .V must run in time o(N). In particular, since it is an input to AS $_{\circ}$ .V, the size of an accumulator acc for AS $_{\circ}$  must be o(N). The number of inputs n and accumulators m are both equal to the arity of the compliance predicate and may be regarded as constant. There is no restriction on the running time of AS $_{\circ}$ .D.

**Remark 6.4.** Definition 6.1 (and hence Theorem 6.2) restricts  $\mathcal{V}$ 's access to  $\Phi_{\circ}$ :  $\mathcal{V}$  must reject if any of its queries to  $\Phi_{\circ}$  are answered with 0. In particular, the queries of  $\mathcal{V}$  to  $\Phi_{\circ}$  are non-adaptive. This is necessary so that the accumulator does not grow with the number of accumulated queries.

<sup>&</sup>lt;sup>4</sup>Here we assume for simplicity that the public parameters for  $\Phi_{\circ}$  are the same as those for  $\mathcal{V}$ .

### <span id="page-31-0"></span>**6.1** Construction

We construct the accumulation scheme  $\mathsf{AS}_{\mathsf{ARG}}$  for  $(\Phi_{\mathcal{V}},\mathcal{H}_{\mathsf{ARG}})$  (specified in Definition 4.1). The efficiency properties stated in Theorem 6.2 follow from the construction below.

**Data structures.** An accumulator acc for  $AS_{ARG}$  is the accumulator for the underlying accumulation scheme  $AS_{\circ}$ .

**Generator.** On input the security parameter  $\lambda$  (in unary),  $\mathsf{AS}_{\mathsf{ARG}}.G$  samples public parameters  $\mathsf{pp} \leftarrow \mathsf{AS}_{\circ}.G^{\rho}(1^{\lambda})$  for the accumulation scheme for  $(\Phi_{\circ}, \mathcal{H}_{\circ})$ , and outputs  $\mathsf{pp}$ .

**Indexer.** On input public parameters ppAS, succinct argument parameters pp and index i, AS<sub>ARG</sub>.I computes index keys  $(ipk, ivk = (i_o, ivk_{pe})) \leftarrow \mathcal{I}(pp, i)$  and accumulation keys  $(apk_o, avk_o, dk_o) \leftarrow AS_o.I^{\rho}(pp, i_o)$ , and outputs the accumulation keys  $(apk, avk, dk) := ((apk_o, ivk_{pe}), (avk_o, ivk_{pe}), dk_o)$ .

**Accumulation prover.** On input the accumulator proving key apk = (apk<sub>o</sub>, ivk<sub>pe</sub>), instance-proof pairs  $[(\mathbf{x}_i, \pi_i)]_{i=1}^n$ , and old accumulators  $[\mathsf{acc}_j]_{j=1}^m$ ,  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{P}$  computes a new accumulator acc and proof  $\pi_V$  as follows: for each  $i \in [n]$ , compute  $(b_i, Q_i) \leftarrow \mathcal{V}^{\rho}_{\mathsf{pe}}(\mathrm{ivk}_{\mathsf{pe}}, \mathbf{x}_i, \pi_i)$ ; then output the new accumulator and proof  $(\mathsf{acc}, \pi_V) \leftarrow \mathsf{AS}_{\circ}.\mathsf{P}^{\rho}(\mathsf{apk}_{\circ}, \cup_{i=1}^n Q_i, [\mathsf{acc}_j]_{i=1}^m)$ .

**Accumulation verifier.** On input the accumulation verification key  $\operatorname{avk} = (\operatorname{avk}_o, \operatorname{ivk}_{\operatorname{pe}})$ , instance-proof pairs  $[(\mathbf{x}_i, \pi_i)]_{i=1}^n$ , old accumulators  $[\operatorname{acc}_j]_{j=1}^m$ , the new accumulator acc, and a proof  $\pi_V$ ,  $\operatorname{AS}_{\operatorname{ARG}}$ . V works as follows. For each  $i \in [n]$ , compute  $(b_i, Q_i) \leftarrow \mathcal{V}_{\operatorname{pe}}^{\operatorname{pe}}(\operatorname{ivk}_{\operatorname{pe}}, \mathbf{x}_i, \pi_i)$ , and check that  $b_i = 1$ , and then accept if the new accumulator is valid, i.e.,  $\operatorname{AS}_o.V^{\operatorname{pe}}(\operatorname{avk}_o, Q := \cup_{i=1}^n Q_i, [\operatorname{acc}_j]_{j=1}^m, \operatorname{acc}, \pi_V) = 1$ .

**Decider.** On input decision key  $dk = dk_o$  and accumulator acc,  $AS_{ARG}$ . D accepts if  $AS_o$ .  $D^{\rho}(dk_o, acc) = 1$ .

## <span id="page-31-1"></span>6.2 Completeness

Let  $\mathcal{A}$  be a (possibly inefficient) adversary that breaks the completeness of the accumulation scheme  $\mathsf{AS}_{\mathsf{ARG}}$  for  $(\Phi_{\mathcal{V}}, \mathcal{G})$  in Section 6.1. That is, the following probability is non-zero:

<span id="page-31-3"></span>
$$\Pr\left[\begin{array}{c} \forall j \in [m], \, \mathsf{AS_{\mathsf{ARG}}}.\mathsf{D}^{\rho}(\mathsf{dk},\mathsf{acc}_j) = 1 \\ \forall i \in [n], \, \Phi^{\rho}_{\mathcal{V}}(\mathsf{pp}, \mathbb{i}, (\mathbb{x}_i, \pi_i)) = 1 \\ \mathsf{AS_{\mathsf{ARG}}}.\mathsf{V}^{\rho}\left( \begin{array}{c} \mathsf{avk} \quad [(\mathbb{x}_i, \pi_i)]_{i=1}^n \quad [\mathsf{acc}_j]_{j=1}^m \\ \mathsf{acc} \quad \pi_{\mathsf{V}} \\ \mathsf{AS_{\mathsf{ARG}}}.\mathsf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \end{array}\right) = 1 \\ \mathsf{AS_{\mathsf{ARG}}}.\mathsf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \\ \left( \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp}_{\mathsf{AS}} \leftarrow \mathsf{AS_{\mathsf{ARG}}}.\mathsf{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda}) \\ \mathsf{p$$

We will use  $\mathcal{A}$  to construct adversary  $\mathcal{B}$  that breaks the completeness of the accumulation scheme  $\mathsf{AS}_\circ$  for  $(\Phi_\circ,\mathcal{G})$ . That is,  $\mathcal{B}$  makes the following probability nonzero:

<span id="page-31-2"></span>
$$\Pr\left[\begin{array}{c} \forall j \in [m], \, \mathsf{AS}_\circ.\mathsf{D}^\rho(\mathsf{pp}_\circ, \mathsf{dk}_\circ, \mathsf{acc}_j) = 1 \\ \forall i \in [n], \, \Phi^\rho_\circ(\mathsf{pp}, \mathsf{i}_\circ, \mathsf{q}_i) = 1 \\ \downarrow \downarrow \\ \mathsf{AS}_\circ.\mathsf{V}^\rho\left(\begin{matrix} \mathsf{avk}_\circ \ \ [\mathsf{q}_i]_{i=1}^n \ \ [\mathsf{acc}_j]_{j=1}^m \\ \mathsf{acc} \ \ \pi_\mathsf{V} \end{matrix}\right) = 1 \\ \mathsf{AS}_\circ.\mathsf{D}^\rho(\mathsf{dk}_\circ, \mathsf{acc}) = 1 \\ \end{array}\right. \quad \left(\begin{matrix} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp}_\circ \leftarrow \mathsf{AS}_\circ.\mathsf{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal{G}^\rho(1^\lambda) \\ \mathsf{pp} \leftarrow \mathcal$$

We define the adversary  $\mathcal{B}$  to operate as follows.

- 1. Compute  $(i, [(\mathbf{x}_i, \pi_i)]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}_{\mathsf{AS}} = \mathsf{pp}_\circ, \mathsf{pp}).$
- 2. Compute  $(ipk, ivk = (i_o, ivk_{pe})) \leftarrow \mathcal{I}^{\rho}(pp, i)$ .
- 3. For each  $i \in [n]$ , compute  $(b_i, Q_i) \leftarrow \mathcal{V}^{\rho}_{\mathsf{pe}}(\mathrm{ivk}_{\mathsf{pe}}, \mathbf{x}_i, \pi_i)$ .
- 4. Set  $Q := \bigcup_{i=1}^n Q_i$  and output  $(i_{\circ}, Q, [acc_j]_{j=1}^m)$ .

By construction, the distribution of  $\rho$ , pp<sub>AS</sub> and pp are identical in both experiments, and hence so is the output of A. It remains to show that for every fixed choice of these variables, the implication in Eq. (4) does not hold. We first use Eq. (3) to argue that the premises of the implication in Eq. (4) are satisfied:

- For each  $j \in [m]$ , we know that  $AS_o.D^{\rho}(dk_o, acc_j) = 1$  because  $AS_{ARG}.D^{\rho}(dk, acc_j) = 1$ , and so the corresponding condition in Eq. (4) is satisfied.
- For each  $i \in [n]$ ,  $\Phi_{\mathcal{V}}^{\rho}(\mathsf{pp}, \mathbb{i}, (\mathbb{x}_i, \pi_i)) = 1$ . This means that  $\mathcal{V}^{\rho}(\mathrm{ivk}, \mathbb{x}_i, \pi_i) = 1$ , which in turn implies that  $\mathcal{V}^{\rho}_{\mathsf{pe}}(\mathrm{ivk}_{\mathsf{pe}}, \mathbf{x}_i, \pi_i) = (1, Q_i)$  and, for each query  $\mathsf{q} \in Q_i$ , the predicate  $\Phi^{\rho}_{\circ}(\mathsf{pp}, \mathsf{i}_{\circ}, \mathsf{q}) = 1$ . Hence, for each  $\mathsf{q} \in Q = \cup_{i=1}^n Q_i, \Phi^{\rho}_{\circ}(\mathsf{pp}, \mathsf{i}_{\circ}, \mathsf{q}) = 1$ .

We are now left to show that at least one of  $\mathsf{AS}_\circ.V^\rho(\mathsf{avk}_\circ, \cup_{i=1}^n Q_i, [\mathsf{acc}_j]_{i=1}^m, \mathsf{acc}, \pi_V)$  or  $\mathsf{AS}_\circ.D^\rho(\mathsf{dk}_\circ, \mathsf{acc})$ rejects. We do this by considering each case.

- By construction,  $AS_o.D^{\rho}(dk_o, acc)$  rejects if and only if  $AS_{ARG}.D^{\rho}(dk, acc)$  rejects.
- By construction,  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}^{\rho}(\mathsf{avk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_\mathsf{V})$  rejects if at least one of the following conditions is satisfied:

  - For some  $i \in [n]$ ,  $\mathcal{V}_{\mathsf{pe}}$  rejects:  $\mathcal{V}^{\rho}_{\mathsf{pe}}(\mathrm{ivk}_{\mathsf{pe}}, \mathbf{x}_i, \pi_i) = (0, Q_i)$ . AS $_{\circ}$ .V rejects: AS $_{\circ}$ .V $^{\rho}(\mathsf{avk}_{\circ}, Q = \cup_{i=1}^{n} Q_i, [\mathsf{acc}_j]_{j=1}^{m}, \mathsf{acc}, \pi_{\mathrm{V}}) = 0$ .

However, because  $\Phi_{\mathcal{V}}^{\rho}(\mathsf{pp}, \mathbf{i}, (\mathbf{x}_i, \pi_i)) = 1$ , we know that  $\mathcal{V}_{\mathsf{pe}}$  accepts. Hence, if  $\mathsf{AS}_{\mathsf{ARG}}$ . V rejects, it must be because AS<sub>o</sub>.V also rejects.

Together, these cases imply that:

<span id="page-32-1"></span>
$$\begin{split} \mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}^{\rho}(\mathsf{avk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_{\mathsf{V}}) &= 0 \quad \vee \quad \mathsf{AS}_{\mathsf{ARG}}.\mathsf{D}^{\rho}(\mathsf{dk},\mathsf{acc}) = 0 \\ & \qquad \qquad \qquad \qquad \qquad \qquad \qquad \qquad \\ \mathsf{AS}_{\circ}.\mathsf{V}^{\rho}(\mathsf{avk}_{\circ},Q,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_{\mathsf{V}}) &= 0 \quad \vee \quad \mathsf{AS}_{\circ}.\mathsf{D}^{\rho}(\mathsf{dk}_{\circ},\mathsf{acc}) = 0 \end{split} .$$

Thus if  $\mathcal{A}$  breaks completeness of the accumulation scheme  $\mathsf{AS}_{\mathsf{ARG}}$  for  $(\Phi_{\mathcal{V}}, \mathcal{H}_{\mathsf{ARG}})$  then  $\mathcal{B}$  breaks completeness of the accumulation scheme  $AS_{\circ}$  for  $(\Phi_{\circ}, \mathcal{H}_{\circ})$  (a contradiction).

#### <span id="page-32-0"></span>**Soundness** 6.3

Let  $\mathcal{A}$  be an efficient adversary that breaks the soundness of the accumulation scheme  $\mathsf{AS}_{\mathsf{ARG}}$  for  $(\Phi_{\mathcal{V}}, \mathcal{G})$ . This means that the following probability is non-negligible:

$$\Pr \begin{bmatrix} \mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}^{\rho} \begin{pmatrix} \mathsf{avk} & [(\mathbf{x}_i, \pi_i)]_{i=1}^n & [\mathsf{acc}_j]_{j=1}^m \\ \mathsf{acc} & \pi_{\mathsf{V}} \end{pmatrix} = 1 \\ \mathsf{AS}_{\mathsf{ARG}}.\mathsf{D}^{\rho} (\mathsf{dk}, \mathsf{acc}) = 1 \\ \forall j \in [n], \ \mathsf{AS}_{\mathsf{ARG}}.\mathsf{D}^{\rho} (\mathsf{dk}, \mathsf{acc}_j) = 1 \\ \forall i \in [n], \ \Phi^{\rho}_{\mathcal{V}} \big( \mathsf{pp}, \mathbf{i}, (\mathbf{x}_i, \pi_i) \big) = 1 \end{bmatrix} = 1 \\ \begin{pmatrix} \mathsf{i} & [(\mathbf{x}_i, \pi_i)]_{i=1}^n & [\mathsf{acc}_j]_{j=1}^m \end{pmatrix} \leftarrow \mathcal{A}^{\rho} (\mathsf{pp}_{\mathsf{AS}}, \mathsf{pp}) \\ \mathsf{acc} & \pi_{\mathsf{V}} \end{pmatrix} . \tag{5}$$

We will use  $\mathcal{A}$  to construct an adversary  $\mathcal{B}$  that breaks the soundness of the accumulation scheme  $\mathsf{AS}_\circ$  for  $(\Phi_\circ,\mathcal{G})$ . That is,  $\mathcal{B}$  makes the following probability non-negligible:

<span id="page-33-1"></span>
$$\Pr\left[\begin{array}{c} \mathsf{AS}_{\circ}.\mathsf{V}^{\rho}(\mathsf{avk}_{\circ},[\mathsf{q}_{i}]_{i=1}^{n},[\mathsf{acc}_{j}]_{j=1}^{m},\mathsf{acc},\pi_{\mathsf{V}}) = 1\\ \mathsf{AS}_{\circ}.\mathsf{D}^{\rho}(\mathsf{dk}_{\circ},\mathsf{acc}) = 1\\ & \qquad \qquad \qquad \downarrow \\ \forall j \in [m],\ \mathsf{AS}_{\circ}.\mathsf{D}^{\rho}(\mathsf{dk}_{\circ},\mathsf{acc}_{j}) = 1\\ & \forall i \in [n],\ \Phi^{\rho}(\mathsf{pp},\mathsf{i}_{\circ},\mathsf{q}_{i}) = 1 \end{array}\right. \qquad \left(\begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda)\\ \mathsf{pp}_{\circ} \leftarrow \mathsf{AS}_{\circ}.\mathsf{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})\\ \mathsf{pp} \leftarrow \mathcal{G}^{\rho}(1^{\lambda})$$

We define the adversary  $\mathcal{B}$  to operate as follows.

```
\mathcal{B}^{\rho}(\mathsf{pp}_{\diamond}, \mathsf{pp}):
1. Compute (\mathfrak{i}, [(\mathfrak{x}_{i}, \pi_{i})]_{i=1}^{n}, [\mathsf{acc}_{j}]_{j=1}^{m}, \mathsf{acc}, \pi_{\mathsf{V}}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}_{\mathsf{AS}} = \mathsf{pp}_{\diamond}, \mathsf{pp}).
2. For each i \in [n], compute (b_{i}, Q_{i}) \leftarrow \mathcal{V}^{\rho}_{\mathsf{pe}}(\mathsf{ivk}_{\mathsf{pe}}, \mathfrak{x}_{i}, \pi_{i}).
3. Set Q := \bigcup_{i=1}^{n} Q_{i} and output (Q, [\mathsf{acc}_{j}]_{j=1}^{m}, \mathsf{i}_{\diamond}, \mathsf{acc}, \pi_{\mathsf{V}}).
```

By construction, the distribution of  $\rho$ , pp<sub>AS</sub>, and pp are identical in both experiments, and hence so is the output of  $\mathcal{A}$ . It remains to show that for every fixed choice of these variables, the implication in Eq. (6) does not hold. We start by using Eq. (5) to argue that the premises of the implication in Eq. (6) are satisfied:

- By construction,  $AS_o.D^{\rho}(dk_o, acc) = AS_{ARG}.D^{\rho}(dk, acc)$ .
- By construction of V, we know that if  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}^{\rho}(\mathsf{avk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_{\mathsf{V}})$  accepts, then  $\mathsf{AS}_{\diamond}.\mathsf{V}^{\rho}(\mathsf{apk}_{\diamond},Q:=\cup_{i=1}^nQ_i,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_{\mathsf{V}})$  also accepts.

We are now left to show that at least one of the following occurs: (a) for some  $j \in [m]$ ,  $\mathsf{AS}_\circ.\mathsf{D}^\rho(\mathsf{dk}_\circ,\mathsf{acc}_j)$  rejects, or (b) for some  $\mathsf{q} \in Q$ ,  $\Phi_\circ^\rho(\mathsf{pp},\mathsf{i}_\circ,\mathsf{q}) = 0$ .

- By construction,  $AS_{ARG}.D^{\rho}(dk, acc_j) = 0$  for some  $j \in [m]$  implies that  $AS_{\circ}.D^{\rho}(dk_{\circ}, acc_j) = 0$ .
- We know that  $\mathsf{AS}_{\mathsf{ARG}}.\mathsf{V}^{\rho}(\mathsf{avk},[(\mathbf{x}_i,\pi_i)]_{i=1}^n,[\mathsf{acc}_j]_{j=1}^m,\mathsf{acc},\pi_{\mathsf{V}})=1.$  Hence, for each  $i\in[n],\mathcal{V}^{\rho}_{\mathsf{pe}}(\mathsf{ivk}_{\mathsf{pe}},\mathbf{x}_i,\pi_i)$  accepts and outputs a query set  $Q_i$ . This in turn implies that if there does exist  $k\in[n]$  such that  $\Phi^{\rho}_{\mathcal{V}}(\mathsf{pp},\dot{\mathbf{i}},(\mathbf{x}_k,\pi_k))$  rejects, then there exists  $\mathsf{q}\in Q_k\subseteq Q$  such that  $\Phi^{\rho}_{\circ}(\mathsf{pp},\dot{\mathbf{i}}_{\circ},\mathsf{q})=0.$

Together, these cases imply that

$$\begin{split} \exists\, j \in [m] \text{ s.t. } \mathsf{AS}_{\mathsf{ARG}}.\mathsf{D}^{\rho}(\mathsf{dk},\mathsf{acc}_j) &= 0 \ \lor \ \exists\, i \in [n] \text{ s.t. } \Phi^{\rho}_{\mathcal{V}}\big(\mathsf{pp}, \mathbf{i}, (\mathbf{x}_i, \pi_i)\big) = 0 \\ & \quad \ \ \, \Downarrow \\ \exists\, j \in [m] \text{ s.t. } \mathsf{AS}_{\circ}.\mathsf{D}^{\rho}(\mathsf{dk}_{\circ}, \mathsf{acc}_j) &= 0 \ \lor \ \exists\, \mathsf{q} \in Q \text{ s.t. } \Phi^{\rho}_{\circ}(\mathsf{pp}, \mathbf{i}_{\circ}, \mathsf{q}) = 0 \end{split}$$

Hence  $\mathcal{B}$  break the soundness of  $AS_{\circ}$  whenever  $\mathcal{A}$  breaks the soundness of  $AS_{ARG}$ .

**Post-quantum security.** Note that the soundness argument applies equally to quantum adversaries A, and so if  $AS_{\circ}$  is post-quantum secure, then so is  $AS_{ARG}$ .

### <span id="page-33-0"></span>6.4 Zero knowledge

We construct the simulator  $S_{\mathsf{ARG}}$  for  $\mathsf{AS}_{\mathsf{ARG}}$  using the simulator  $S_{\circ}$  for  $\mathsf{AS}_{\circ}$ . The first stage of  $S_{\mathsf{ARG}}$  is identical to  $S_{\circ}$ :  $S_{\mathsf{ARG}}(1^{\lambda}) = S_{\circ}(1^{\lambda})$ . The second stage is as follows.

$$\begin{split} & S_{\mathsf{ARG}}(\mathsf{pp},\tau,\dot{\mathtt{i}}) \\ & 1. \ \mathsf{Run} \ (\mathrm{ipk},\mathrm{ivk} = (\mathsf{i}_\circ,\mathrm{ivk}_{\mathsf{pe}})) \leftarrow \mathcal{I}^\rho(\mathsf{pp},\dot{\mathtt{i}}). \end{split}$$

For an "honest" adversary A for ASARG, the adversary B described in Section [6.2](#page-31-1) is an "honest" adversary for AS◦. Moreover, the "view" of S◦ is the same when SARG is interacting with A as when S◦ is interacting directly with B. Hence, the zero knowledge property of AS◦ ensures that the output of SARG is indistinguishable from that in the honest case.

Post-quantum security. We simply observe that this argument also implies that quantum computational indistinguishability is preserved, and continues to hold when A is a quantum circuit.

## <span id="page-35-0"></span>7 Accumulating polynomial commitments based on discrete logarithms

We construct an accumulation scheme for PC<sub>DL</sub>, a polynomial commitment scheme that is inspired from several prior works [BCCGP16; BBBPWM18; WTSTW18], and which we describe in Appendix A.

The scheme  $PC_{DL}$  is secure in the random oracle model assuming hardness of the discrete logarithm problem, and has the attractive feature that evaluation proofs are  $O(\log d)$  elements in  $\mathbb{G}$ , where d is the degree of the committed polynomial. However,  $PC_{DL}$  has the drawback that checking an evaluation proof requires O(d) scalar multiplications in  $\mathbb{G}$ .

Our accumulation scheme for  $PC_{DL}$ , which is based on the batching ideas of [BGH19], enables deferring the expensive check to the decider: the accumulation verifier V only requires  $O(\log d)$  scalar multiplications per accumulation, while the decider D requires O(d) scalar multiplications. Hence, checking n evaluation proofs requires a total of  $O(n \log d + d)$  scalar multiplications, as opposed to  $\Omega(n \cdot d)$  for the naive approach.

<span id="page-35-2"></span>**Theorem 7.1.** If  $PC_{DL}$  described in Appendix A is a polynomial commitment scheme then the tuple AS = (G, I, P, V, D) constructed in Section 7.1 is a zero-knowledge accumulation scheme in the random oracle model for  $PC_{DL}$ . AS achieves the following efficiency:

- Generator:  $G(1^{\lambda})$  runs in time  $O(\lambda)$ .
- Indexer:  $I(pp, i_{\Phi})$  runs in time  $O_{\lambda}(d)$ .
- Accumulation prover: The time of  $P^{\rho}(\mathsf{apk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m)$  is dominated by the time to perform O(n+m+d) scalar multiplications in  $\mathbb{G}$ .
- Accumulator size: The output accumulator is a polynomial commitment consisting of one element in  $\mathbb{G}$  plus an evaluation proof consisting of  $O(\log d)$  elements in  $\mathbb{G}$ .
- Accumulation proof size: The accumulation proof  $\pi_V$  consists of two elements in  $\mathbb{F}_q$  and one element in  $\mathbb{G}$ .
- Accumulation verifier: The time of  $V^{\rho}(avk, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [acc_j]_{j=1}^m, acc)$  is dominated by the time to perform  $O((n+m) \cdot \log d)$  scalar multiplications in  $\mathbb{G}$ .
- Decider: The time of  $D^{\rho}(dk, acc)$  is dominated by the time to perform O(d) scalar multiplications in  $\mathbb{G}$ .

Recall that obtaining an accumulation scheme for a polynomial commitment scheme entails obtaining an accumulation scheme for the pair  $(\Phi_{PC}, \mathcal{H}_{PC,D})$  specified in Definition 4.2.

We remark that Theorem 7.1 considers the special case of accumulating claims about a single degree bound (when the input to PC<sub>DL</sub>.Trim is a singleton). We leave the case of multiple degree bounds to future work (and believe that the degree enforcement techniques in [CHMMVW20] would work in this setting).

### <span id="page-35-1"></span>7.1 Construction

We present our accumulation scheme AS for  $PC_{DL}$ . Recall that the definition of an accumulation scheme requires simultaneous accumulation of previous accumulators and of new instances. In AS below, accumulators and instances are both evaluation proofs for openings of committed polynomials. That is, an accumulator acc and an instance q are both of the form  $((C, d, z, v), \pi)$ . Furthermore, the predicate  $\Phi_{PC}$  (from Definition 4.2) and the accumulation decider D are identical, and so there is no distinction between new instances and previous accumulators. Below, we exploit this to simplify exposition by accumulating only instances.

Our construction below uses algorithms from  $PC_{DL}$  defined in Appendix A. In particular, we use the subroutine  $PC_{DL}$ . Succinct Check (see Figure 2) which is the "succinct" part of  $PC_{DL}$ . Check.

Note that the algorithms of both AS and  $PC_{DL}$  use random oracles. For security, we must ensure that the random oracle used by the algorithms of  $PC_{DL}$  differs from that used by the algorithms of AS. We do so by relying on domain separation: we derive two different random oracles  $\rho_0(\cdot) := \rho(0||\cdot)$  (for  $PC_{DL}$ ) and

 $\rho_1(\cdot) := \rho(1\|\cdot)$  (for AS) from the common random oracle  $\rho$ . Below, as in the rest of the paper, we use [n] to specifically denote the set of integers  $\{1,\ldots,n\}$ . We highlight in blue the parts of the construction that are only necessary to make the accumulator zero-knowledge. If zero-knowledge is not required these parts can be dropped without affecting soundness.

**Generator.** On input a security parameter  $1^{\lambda}$ , the generator G outputs  $1^{\lambda}$ .

**Indexer.** On input the accumulator parameters  $pp_{AS}$ , the  $PC_{DL}$  public parameters  $pp_{PC}$ , and a predicate index  $i_{\Phi} = D$ , the indexer I proceeds as follows. Compute the committer and receiver keys  $(ck_{PC}, rk_{PC}) := PC_{DL}.Trim(pp_{PC}, D)$ . Parse  $ck_{PC}$  as a tuple (ck, H), and ck as  $(\langle group \rangle, hk, S)$ . Additionally, compute the committer key for committing to linear polynomials:  $ck_{PC}^{(1)} := PC_{DL}.Trim(pp_{PC}, 1)$ . Set  $rk := (\langle group \rangle, S, H, D)$ , avk  $:= (rk, ck_{PC}^{(1)})$ , and output the accumulator proving key apk  $:= (ck_{PC}, avk)$ , the accumulator verification key avk, and decision key  $dk := rk_{PC}$ .

Common subroutine. The accumulation prover and verifier share a common subroutine, described below.

```
T^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, \pi_{\mathsf{V}}) \colon
1. Parse avk as (\mathsf{rk}, \mathsf{ck}_{\mathsf{PC}}^{(1)}), and \mathsf{rk} as (\langle \mathsf{group} \rangle = (\mathbb{G}, q, G), S, H, D).
2. For each i \in [n] \colon
(a) Parse \mathsf{q}_i as a tuple ((C_i, d_i, z_i, v_i), \pi_i).
(b) Compute (h_i(X), U_i) \coloneqq \mathsf{PC}_{\mathsf{DL}}.\mathsf{SuccinctCheck}^{\rho_0}(\mathsf{rk}, C_i, z_i, v_i, \pi_i) (see Figure 2).
3. For each i in [n], check that d_i = D. (We accumulate only the degree bound D.)
4. Parse \pi_{\mathsf{V}} as (h_0, U_0, \omega), where h_0(X) = aX + b \in \mathbb{F}_q[X], U_0 \in \mathbb{G}, and \omega \in \mathbb{F}_q.
5. Check that U_0 is a deterministic commitment to h_0 \colon U_0 = \mathsf{PC}_{\mathsf{DL}}.\mathsf{Commit}^{\rho_0}(\mathsf{ck}_{\mathsf{PC}}^{(1)}, h; \omega = \bot).
6. Compute the challenge \alpha \coloneqq \rho_1([h_i, U_i]_{i=0}^n) \in \mathbb{F}_q.
7. Set the polynomial h(X) \coloneqq \sum_{i=0}^n \alpha^i h_i(X) \in \mathbb{F}_q[X].
8. Compute the accumulated commitment C \coloneqq \sum_{i=0}^n \alpha^i U_i.
9. Compute the challenge z \coloneqq \rho_1(C, h) \in \mathbb{F}_q.
10. Randomize C \colon \bar{C} \coloneqq C + \omega S \in \mathbb{G}.
11. Output (\bar{C}, d, z, h(X)).
```

Accumulation prover. On input the accumulator proving key apk =  $(\mathsf{ck}_{\mathsf{PC}}, \mathsf{avk})$ , and new inputs  $[\mathsf{q}_i]_{i=1}^n$ , the accumulation prover P proceeds as follows. Sample a random linear polynomial  $h_0 \in \mathbb{F}_q[X]$  and then compute a deterministic commitment to  $h_0$ :  $U_0 := \mathsf{PC}_\mathsf{DL}.\mathsf{Commit}^{\rho_0}(\mathsf{ck}_\mathsf{PC}, h_0, d; \ \omega = \bot)$ . Sample commitment randomness  $\omega \in \mathbb{F}_q$ , and set  $\pi_V := (h_0, U_0, \omega)$ . Then, compute the tuple  $(C, d, z, h(X)) := T^\rho(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, \pi_V)$ . Compute the evaluation v := h(z), and generate the hiding evaluation proof  $\pi := \mathsf{PC}_\mathsf{DL}.\mathsf{Open}^{\rho_0}(\mathsf{ck}_\mathsf{PC}, h(X), \bar{C}, d, z; \ \omega)$ . Finally, output the accumulator  $\mathsf{acc} = ((\bar{C}, d, z, v), \pi)$  and the accumulation proof  $\pi_V$ .

**Accumulation verifier.** On input the accumulator verification key avk, new inputs  $[q_i]_{i=1}^n$ , and a new accumulator acc  $=((\bar{C},d,z,v),\pi)$ , the accumulation verifier V computes  $(\bar{C}',d',z',h(X)):=T^{\rho}(\text{avk},[q_i]_{i=1}^n,\pi_V)$ , and checks that  $\bar{C}'=\bar{C},d'=d,z'=z$ , and h(z)=v.

**Decider.** On input  $dk = \mathsf{rk}_{\mathsf{PC}}$  and  $\mathsf{acc} = ((\bar{C}, d, z, v), \pi)$ , the decider D outputs  $\mathsf{PC}_{\mathsf{DL}}$ . Check $^{\rho_0}(\mathsf{rk}_{\mathsf{PC}}, C, d, z, v, \pi)$ .

### <span id="page-36-0"></span>7.2 Proof of Theorem 7.1

Recall that when the commitment randomness  $\omega$  is  $\bot$ ,  $PC_{DL}$ . Commit is a *deterministic* function of ck and the committed polynomial. Below we will write "A is a commitment to p" when  $A = PC_{DL}$ . Commit(ck, p;  $\omega =$ 

 $\perp$ ) (and "A is not a commitment to p" when  $A \neq \mathsf{PC}_\mathsf{DL}$ .Commit(ck,  $p; \omega = \perp$ )); the value of ck will be clear from context (and is also equal to rk).

To simplify our proofs below, we note that both instances and accumulators have the same form: they consist of claims about the correct evaluation of a committed polynomial. Note also that both the predicate  $\Phi_{PC}$  and the decider D check the same condition: that the claim of correct evaluation holds. This observation allows us to simplify our definitions of both completeness and soundness to only consider the accumulation of instances, and to omit old accumulators.

**Completeness.** We can consider the following simplified definition of completeness: for all (unbounded) adversaries  $A_1, A_2$ , the following holds:

$$\Pr\left[\begin{array}{c|c} \forall i \in [n], \ \Phi_{\mathsf{PC}}^{\rho}(\mathsf{pp}_{\mathsf{PC}}, \mathsf{i}_{\Phi}, \mathsf{q}_i) = 1 \\ & \Downarrow \\ V^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, \mathsf{acc}, \pi_V) = 1 \\ D^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \end{array}\right. \quad \left(\begin{array}{c|c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow G^{\rho}(1^{\lambda}) \\ \mathsf{pp}_{\mathsf{PC}} \leftarrow \mathcal{H}_{\mathsf{PC},D}^{\rho}(1^{\lambda}) \\ (\mathsf{i}_{\Phi}, [\mathsf{q}_i]_{i=1}^n) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\mathsf{PC}}) \\ (\mathsf{apk}, \mathsf{avk}, \mathsf{dk}) \leftarrow I^{\rho}(\mathsf{pp}, \mathsf{pp}_{\mathsf{PC}}, \mathsf{i}_{\Phi}) \\ (\mathsf{acc}, \pi_V) \leftarrow P^{\rho}(\mathsf{apk}, [\mathsf{q}_i]_{i=1}^n) \end{array}\right] = 1 \ .$$

We prove this directly.

First, since for each  $i \in [n]$  we have  $\Phi_{PC}^{\rho}(\mathsf{pp}_{PC}, \mathsf{i}_{\Phi}, \mathsf{q}_i) = 1$ , we know that  $\mathsf{PC}_{DL}$ . Check $^{\rho_0}(\mathsf{rk}, C_i, d_i, z_i, v_i, \pi_i) = 1$ , where  $\mathsf{q}_i = ((C_i, d_i, z_i, v_i), \pi_i)$ . This in turn means that:

- $PC_{DL}$ .SuccinctCheck $^{\rho_0}(\langle group \rangle, C_i, d_i, z_i, v_i, \pi_i)$  accepts and outputs  $(h_i, U_i)$ ; and that
- $U_i$  is a commitment to the polynomial  $h_i$ .

Next, since the new accumulator acc and the accumulation proof  $\pi_V$  are generated honestly (i.e., (acc =  $((\bar{C}, d, z, v), \pi), \pi_V = (h_0, U_0, \omega)) = P^{\rho}(\mathsf{apk}, [\mathsf{q}_i]_{i=1}^n)$ ), the following statements hold:

- The commitment C equals the linear combination  $\sum_{i=0}^{n} \alpha^{i} U_{i}$ , so C is a commitment to  $h = \sum_{i=0}^{n} \alpha^{i} h_{i}$ , and  $\bar{C}$  is a commitment to h under the randomness  $\omega$  (as each  $U_{i}$  is a commitment to the polynomial  $h_{i}$ , and  $\mathsf{PC}_{\mathsf{DL}}$  is a homomorphic commitment scheme).
- The evaluation of h at z equals v (i.e., v = h(z)).
- $\pi = \mathsf{PC}_{\mathsf{DL}}$ . Open $^{\rho_0}(\mathsf{ck}, h(X), \bar{C}, d, z; \omega)$  is an honestly-generated proof of a true statement.

Together, these points imply that:

- 1. The accumulation verifier accepts. Recall that the accumulation verifier V: (a) runs the same subroutine T that the prover P runs, and checks that the output matches the one in the claimed (honest) accumulator; and (b) checks that v = h(z). Both of these checks pass because the accumulation prover is honest.
- 2. The decider accepts. We know that v = h(z),  $\bar{C}$  is a commitment to h under randomness  $\omega$ , and that  $\pi$  is an honestly-generated proof that  $\bar{C}$  commits to a polynomial which evaluates to v at z. By completeness of  $\mathsf{PC}_\mathsf{DL}$ , D accepts.

We conclude that the accumulation scheme AS constructed in Section 7.1 is complete.

**Soundness.** Similarly to the completeness case, we consider a simplified version of the definition of soundness in Section 4. This simpler definition requires that the following probability is negligible for every

polynomial-size adversary A:

<span id="page-38-0"></span>
$$\Pr\left[\begin{array}{c|c} \mathbf{V}^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, \mathsf{acc}, \pi_{\mathbf{V}}) = 1 & \rho \leftarrow \mathcal{U}(\lambda) \\ \mathbf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 & \mathsf{pp} \leftarrow \mathbf{G}^{\rho}(1^{\lambda}) \\ \wedge & \mathsf{pp}_{\mathsf{PC}} \leftarrow \mathcal{H}^{\rho}_{\mathsf{PC},D}(1^{\lambda}) \\ \exists i \in [n], \, \Phi^{\rho}_{\mathsf{PC}}(\mathsf{pp}_{\mathsf{PC}}, \mathsf{i}_{\Phi}, \mathsf{q}_i) = 0 & (\mathsf{i}_{\Phi}, [\mathsf{q}_i]_{i=1}^n, \mathsf{acc}, \pi_{\mathbf{V}}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\mathsf{PC}}) \\ & (\mathsf{apk}, \mathsf{avk}, \mathsf{dk}) \leftarrow \mathbf{I}^{\rho}(\mathsf{pp}, \mathsf{pp}_{\mathsf{PC}}, \mathsf{i}_{\Phi}) \end{array}\right]. \tag{7}$$

Fix a polynomial-size adversary  $\mathcal{A}$  and degree bound D, and denote by  $\delta$  the above probability for these choices. We will construct an adversary for the zero-finding game in Lemma 3.3 that wins with probability  $\delta/2 - \operatorname{negl}(\lambda)$ , from which it follows that  $\delta$  is negligible (since q is superpolynomial in  $\lambda$ ).

We first describe the commitment schemes  $\mathsf{CM}_1, \mathsf{CM}_2$  used in the zero-finding games. Both schemes have common setup and trimming algorithms, and public parameters pp equal to the public parameters of  $\mathsf{PC}_\mathsf{DL}$  with maximum degree L. The message space  $\mathcal{M}_\mathsf{pp}$  for  $\mathsf{CM}_1$  consists of tuples (p,h), where p and h are univariate polynomials of degree at most L. Note that h is uniquely represented by  $([h_i]_{i=0}^n,\alpha)$ , where each  $h_i$  is a univariate polynomial of degree L, and  $\alpha \in \mathbb{F}_q$ . The message space  $\mathcal{M}_\mathsf{pp}$  for  $\mathsf{CM}_2$  consists of lists of pairs  $[(h_i,U_i)]_{i=0}^n$ , where each  $h_i$  is a univariate polynomial of degree at most L, and each  $U_i$  is a group element.

```
\begin{split} \mathsf{CM}_{j}.\mathsf{Setup}^{\rho_{0}}(1^{\lambda},L) \colon \mathsf{Output}\,\mathsf{pp} &\leftarrow \mathsf{PC}_{\mathsf{DL}}.\mathsf{Setup}^{\rho_{0}}(1^{\lambda},L). \\ \mathsf{CM}_{j}.\mathsf{Trim}^{\rho_{0}}(\mathsf{pp},n,N) \colon \\ 1. \ \mathsf{Compute}\,(\mathsf{ck}_{0},\mathsf{rk}_{0}) &\leftarrow \mathsf{PC}_{\mathsf{DL}}.\mathsf{Trim}^{\rho_{0}}(\mathsf{pp},N). \\ 2. \ \mathsf{Output}\,\mathsf{ck} := (\mathsf{ck}_{0},n). \\ \mathsf{CM}_{1}.\mathsf{Commit}(\mathsf{ck} = (\mathsf{ck}_{0},n), \mathfrak{p} = (p,h);r) \colon \\ 1. \ \mathsf{Commit}\,\mathsf{to}\,p \colon C \leftarrow \mathsf{PC}_{\mathsf{DL}}.\mathsf{Commit}(\mathsf{ck}_{0},p;\,\omega = \bot). \\ 2. \ \mathsf{Output}\,(C,h). \\ \mathsf{CM}_{2}.\mathsf{Commit}(\mathsf{ck},\mathfrak{p} = ([(h_{i},U_{i})]_{i=0}^{n});r) \colon \mathsf{Output}\,\mathfrak{p}. \end{split}
```

Both commitment schemes are binding. It remains to specify the families of functions  $\{f_{pp}^{(1)}\}_{pp}, \{f_{pp}^{(2)}\}_{pp}$  that we use in the respective zero-finding games. We define  $f_{pp}^{(1)}(p,h=([h_i]_{i=0}^n,\alpha)):=p-\sum_{i=0}^n\alpha^ih_i$ , and

```
f_{\mathsf{pp}}^{(2)}(\mathfrak{p} = ([(h_i, U_i)]_{i=0}^n)):
1. Construct the key pair (\mathsf{ck}_0, \mathsf{rk}_0) := \mathsf{PC}_{\mathsf{DL}}.\mathsf{Trim}(\mathsf{pp}_{\mathsf{PC}}, \deg(h_1)).
2. For each i \in \{0, \dots, n\}, construct a \mathsf{PC}_{\mathsf{DL}} commitment to h_i : B_i \leftarrow \mathsf{PC}_{\mathsf{DL}}.\mathsf{Commit}(\mathsf{ck}_0, h_i; \bot).
3. For each i \in \{0, \dots, n\}, compute a_i \in \mathbb{F}_q such that a_i G = U_i - B_i.
4. Output the polynomial a(Z) := \sum_{i=0}^n a_i Z^i.
```

We next describe an adversary  $\mathcal{C}$  against  $\mathsf{PC}_{\mathsf{DL}}$ , which simply runs the soundness experiment for the accumulation scheme and outputs acc as output by  $\mathcal{A}$ . For convenience we also have  $\mathcal{C}$  output  $[\mathsf{q}_i]_{i=1}^n$  and  $\pi_{\mathsf{V}}$ ; this will be ignored by the extractor.

```
 \begin{array}{l} \mathcal{C}^{\rho}(\mathsf{pp}_{\mathsf{PC}}) \colon \\ 1. \ \ \mathsf{Set} \ \mathsf{AS} \ \mathsf{public} \ \mathsf{parameters} \ \mathsf{pp}_{\mathsf{AS}} := 1^{\lambda}. \\ 2. \ \ \mathsf{Compute} \ (\mathsf{i}_{\Phi}, [\mathsf{q}_i]_{i=1}^n, \mathsf{acc}, \pi_{\mathsf{V}}) \leftarrow \mathcal{A}^{\rho}(\mathsf{pp}_{\mathsf{AS}}, \mathsf{pp}_{\mathsf{PC}}). \end{array}
```

```
3. Parse i_{\Phi} as the degree bound N.
```

```
4. Output (N, \text{acc} = ((\bar{C}, d, z, v), \pi); [q_i]_{i=1}^n, \pi_V).
```

We use the extractor  $\mathcal{E}_{\mathcal{C}}$  corresponding to  $\mathcal{C}$  to construct adversaries  $\mathcal{B}_1, \mathcal{B}_2$  for zero-finding games against  $(\mathsf{CM}_1, \{f_\mathsf{pp}^{(1)}\}_\mathsf{pp}), (\mathsf{CM}_2, \{f_\mathsf{pp}^{(2)}\}_\mathsf{pp})$  respectively, with L = D where  $D = \mathsf{poly}(\lambda)$  is the maximum degree parameter as in the soundness experiment for the accumulation scheme.

```
\mathcal{B}_{j}^{\rho}(\mathsf{pp}): \\ 1. \ \mathsf{Compute} \ (N, \mathsf{acc}, [\mathsf{q}_{i}]_{i=1}^{n}, \pi_{\mathsf{V}}) \leftarrow \mathcal{C}^{\rho}(\mathsf{pp}). \\ 2. \ \mathsf{Parse} \ [\mathsf{q}_{i}]_{i=1}^{n} \ \mathsf{as} \ [((C_{i}, d_{i}, z_{i}, v_{i}), \pi_{i})]_{i=1}^{n}, \ \mathsf{and} \ \pi_{\mathsf{V}} \ \mathsf{as} \ (h_{0}, U_{0}, \omega). \\ 3. \ \mathsf{Compute} \ p \leftarrow \mathcal{E}_{\mathcal{C}}^{\rho}(\mathsf{pp}). \\ 4. \ \mathsf{For} \ \mathsf{each} \ i \in [n], \ \mathsf{obtain} \ h_{i} \ \mathsf{and} \ U_{i} \ \mathsf{from} \ \pi_{i}. \\ 5. \ \mathsf{Compute} \ \alpha := \rho_{1}([(h_{i}, U_{i})]_{i=0}^{n}). \\ 6. \ \mathsf{If} \ j = 1, \ \mathsf{output} \ ((n, N), (p, h := ([h_{i}]_{i=0}^{n}, \alpha))). \ \mathsf{If} \ j = 2, \ \mathsf{output} \ ((n, N), ([(h_{i}, U_{i})]_{i=0}^{n})). \\ \end{cases}
```

We show that either  $\mathcal{B}_1$  or  $\mathcal{B}_2$  wins its respective zero-finding game with probability at least  $\delta/2 - \operatorname{negl}(\lambda)$ . Since D accepts with probability  $\delta$ , and by the extraction property of  $\mathsf{PC}_\mathsf{DL}$ , the following holds with probability at least  $\delta - \operatorname{negl}(\lambda)$ :  $\mathcal{E}_\mathcal{C}$  outputs a polynomial p such that  $\bar{C}$  is a commitment to p with randomness  $\omega$  (and so C is a deterministic commitment to p), p(z) = v, and  $\deg(p) \leq d$ ; and, moreover,  $(\mathsf{acc}, [\mathsf{q}_i]_{i=1}^n, \pi_V)$  satisfies the left-hand side of Eq. (7). This latter point implies that, parsing  $\mathsf{q}_i$  as  $((C_i, d_i, z_i, v_i), \pi_i)$  and letting  $(h_i, U_i) := \mathsf{PC}_\mathsf{DL}$ . Succinct  $\mathsf{Check}^{\rho_0}(\mathsf{rk}, C_i, d_i, z_i, v_i, \pi_i)$ :

- Since  $V^{\rho}(\text{avk}, [\mathfrak{q}_i]_{i=1}^n, \text{acc}, \pi_V)$  accepts, the following are true: (a) for each  $i \in [n]$ ,  $PC_{DL}$ . Succinct Check accepts; (b)  $U_0$  is a commitment to  $h_0$ ; and (c) parsing acc as  $((C, d, z, v), \pi)$  and setting  $\alpha := \rho_1([h_i, U_i]_{i=0}^n)$ , we have that  $z = \rho_1(C, [h_i]_{i=0}^n, \alpha)$ ,  $C = \sum_{i=0}^n \alpha^i U_i$ , and  $v = \sum_{i=0}^n \alpha^i h_i(z)$ .
- For some  $i \in [n]$ ,  $\Phi_{PC}^{\rho}(\mathsf{pp}_{PC}, \mathsf{i}_{\Phi}, \mathsf{q}_i) = \mathsf{PC}_{DL}.\mathsf{Check}^{\rho_0}(\mathsf{rk}, (C_i, d_i, z_i, v_i), \pi_i) = 0$ . By construction (see Appendix A.2), this implies that either  $\mathsf{PC}_{DL}.\mathsf{SuccinctCheck}$  rejects, or the group element  $U_i$  is not a commitment to  $h_i$ .

The above tells us that there exists some  $i \in [n]$  such that  $U_i$  is not a commitment to  $h_i$ . In other words, if we define  $B_i := \mathsf{PC}_\mathsf{DL}.\mathsf{Commit}(\mathsf{ck}, h_i)$ , then there exists an  $i \in [n]$  such that  $U_i \neq B_i$ . Letting  $a_i \in \mathbb{F}_q$  be such that  $a_i G = U_i - B_i$ , we deduce that the polynomial  $a(Z) = \sum_{i=0}^n a_i Z^i$  is not identically zero.

There are then two cases.

- 1.  $C \neq \sum_{i=0}^{n} \alpha^{i} B_{i}$ . Then since C is a commitment to p, p(X) h(X) is not identically zero, but p(z) = v = h(z). Hence  $\mathcal{B}_{1}$  wins the zero-finding game against  $(\mathsf{CM}_{1}, \{f_\mathsf{pp}^{(1)}\}_\mathsf{pp})$ .
- 2.  $C = \sum_{i=0}^{n} \alpha^{i} B_{i}$ . Then since  $C = \sum_{i=0}^{n} \alpha^{i} U_{i}$ ,  $\alpha$  is a zero of the polynomial a(Z). Hence  $\mathcal{B}_{2}$  wins the zero-finding game against  $(\mathsf{CM}_{2}, \{f_\mathsf{pp}^{(2)}\}_\mathsf{pp})$ .

Since at least one of these two cases occurs with probability at least  $\delta/2 - \text{negl}(\lambda)$ , the claim follows.

**Zero knowledge.** We show that if  $\mathsf{PC}_{\mathsf{DL}}$  is hiding, then AS is zero knowledge. We do so by constructing an efficient simulator S for AS from the simulator S for  $\mathsf{PC}_{\mathsf{DL}}$ . During the setup phase,  $\mathsf{S}^{\rho}(1^{\lambda})$  outputs  $\mathsf{pp} \leftarrow \mathsf{G}^{\rho}(1^{\lambda})$ . Then, during the proving phase,  $\mathsf{S}^{\rho}(\mathsf{pp},\tau,\mathsf{i}_{\Phi})$ : (a) samples a random polynomial  $s(X) \in \mathbb{F}_q^{\leq d}[X]$  and an evaluation point  $z \in \mathbb{F}_q$ ; (b) computes a simulated commitment for  $s\colon C \leftarrow \mathcal{S}.\mathsf{Commit}^{\rho_0}(\mathsf{trap} := \mathsf{pp},d)$ ; (c) computes a simulated evaluation proof:  $(\mu,\pi) \leftarrow \mathcal{S}.\mathsf{Open}^{\rho_0}(z,v:=s(z))$ ; and (d) outputs  $(\mu,\mathsf{acc} := ((C,d,z,v),\pi))$ . (Note that for  $\mathsf{PC}_{\mathsf{DL}}$ , the simulation trapdoor just equals the  $\mathsf{PC}_{\mathsf{DL}}$  public parameters  $\mathsf{pp}$ .)

First, the hiding property of  $PC_{DL}$  ensures that the programmed random oracle is indistinguishable from an honestly sampled random oracle. Next, the simulated public parameters are identical to the honest ones, and so the output of the setup phase is identically distributed in both cases.

We are left to argue that the accumulators are computationally indistinguishable. First, in both cases, since  $PC_{DL}$  is hiding, then the commitments are indistinguishable. Next, in the honest case, the evaluation point z is the evaluation of the random oracle on input (C,h) where h is unpredictable; hence it is indistinguishable from random. Since  $h_0$  is chosen at random, h(z) is identically distributed to s(z). Finally, because  $PC_{DL}$  is hiding, then the evaluation proofs are indistinguishable. Thus, the simulated accumulator is indistinguishable from the honest accumulator, and so AS is zero knowledge.

Efficiency. We now analyze the efficiency of our accumulation scheme.

- Generator:  $G^{\rho}(1^{\lambda})$  outputs  $1^{\lambda}$ , and hence takes  $O(\lambda)$  time.
- Indexer:  $I^{\rho}(pp, pp_{PC}, i_{\Phi})$  runs  $PC_{DL}$ . Trim and outputs (apk, dk) := (ck, rk), which have size  $O_{\lambda}(d)$ , and also avk, which has size  $O_{\lambda}(1)$ . This takes time  $O_{\lambda}(d)$ .
- Accumulation prover: The time of  $P^{\rho}(\mathsf{apk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m)$  is dominated by running  $\mathsf{PC}_\mathsf{DL}$ . Open, which uses 3d scalar multiplications for each i, for a total of  $3d \cdot n$  scalar multiplications.
- Accumulator size: The accumulator acc consists of an evaluation claim and a proof. The total size is  $2\log_2(d) + 1$  elements in  $\mathbb{G}$  ( $2\log_2(d)$  group elements for the proof and 1 for the commitment) and a constant number of field elements.
- Accumulation proof size: The accumulation proof  $\pi_V$  consists of a linear polynomial  $h_0$  which can be represented in two elements in  $\mathbb{F}_q$ , and a commitment  $U_0$ , which is an element of  $\mathbb{G}$ .
- Accumulation verifier:  $V^{\rho}(\text{avk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\text{acc}_j]_{j=1}^m, \text{acc})$  runs  $PC_{DL}$ . Succinct Check as a subroutine, which requires  $(2\log_2(d)+2)$  scalar multiplications per iteration among n iterations. (Note that h is succinctly represented, and can be evaluated in  $O(\log d)$  field operations).
- Decider:  $D^{\rho}(dk, acc)$  runs  $PC_{DL}$ . Check, which requires uses O(d) scalar multiplications.

## <span id="page-41-0"></span>8 Accumulating polynomial commitments based on bilinear groups

We construct an accumulation scheme for the pairing-based polynomial commitment scheme  $PC_{AGM}$  [KZG10; CHMMVW20]. The main feature of our accumulation scheme is that, while invoking  $PC_{AGM}$ . Check to check n evaluation proofs requires O(n) pairings, verifying an accumulation of these proofs is much cheaper: it requires only O(n) scalar multiplications in  $\mathbb{G}_1$  to run the accumulation scheme verifier V, plus one pairing to run the decider D. In more detail, we prove the following theorem.

<span id="page-41-2"></span>**Theorem 8.1.** The tuple AS = (G, I, P, V, D) constructed in Section 8.1 is a zero knowledge accumulation scheme in the random oracle model for the polynomial commitment scheme  $PC_{AGM}$  described in Fig. 1. AS achieves the following efficiency:

- Generator:  $G^{\rho}(1^{\lambda})$  runs in  $poly(\lambda)$  time.
- Indexer:  $I^{\rho}(pp, i_{\Phi})$  runs in  $poly(\lambda)$  time.
- Accumulation prover: The time of  $P^{\rho}(\mathsf{apk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m)$  is dominated by the time to perform O(n+m) scalar multiplications in  $\mathbb{G}_1$ .
- Accumulator size: The accumulator acc consists of two elements in  $\mathbb{G}_1$ .
- Accumulation proof size: The accumulation proof  $\pi_V$  consists of two elements in  $\mathbb{G}_1$ .
- Accumulation verifier: The time of  $V^{\rho}(avk, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [acc_j]_{j=1}^m, acc, \pi_V)$  is dominated by the time to perform O(n+m) scalar multiplications in  $\mathbb{G}_1$ .
- Decider: The time of  $D^{\rho}(dk, acc)$  is dominated by the time to perform 1 pairing.

We proceed as follows: in Section 8.1 we describe our accumulation scheme; and then in Section 8.2 we prove that it fulfills Theorem 8.1. Recall that obtaining an accumulation scheme for a polynomial commitment scheme involves obtaining an accumulation scheme for the pair  $(\Phi_{PC}, \mathcal{H}_{PC,D})$  specified in Definition 4.2.

Throughout, we highlight in blue the parts of  $PC_{AGM}$  used for the hiding property, and the corresponding parts of our accumulation scheme dealing with these; they can be dropped if no hiding is used for  $PC_{AGM}$ .

### <span id="page-41-1"></span>8.1 Construction

The algorithms of  $PC_{AGM}$  and of AS use random oracles, but for security they have to be distinct. For this we use domain separation: we derive two different random oracles  $\rho_0(\cdot) := \rho(0||\cdot)$  (for  $PC_{AGM}$ ) and  $\rho_1(\cdot) := \rho(1||\cdot)$  (for AS) from the common random oracle  $\rho$  that all algorithms have access to.

**Generator.** On input a security parameter  $\lambda$  (written in unary), G outputs  $1^{\lambda}$ .

**Indexer.** On input the accumulator parameters  $pp_{AS}$ , the  $PC_{AGM}$  public parameters  $pp_{PC}$ , and a predicate index  $i_{\Phi} = [d_i]_{i=1}^n$ , the indexer I computes the receiver key rk the same way as  $PC_{AGM}$ . Trim, and outputs (apk, avk, dk) := (rk, rk, rk).

The accumulation prover and the accumulation verifier both rely on the following common subroutine:

```
Compute \operatorname{Acc}^{\rho}(\operatorname{avk}, [\mathfrak{q}_i]_{i=1}^n, [\operatorname{acc}_j]_{j=1}^m, \pi_{\operatorname{V}}):

1. Parse [\mathfrak{q}_i]_{i=1}^n as [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n.

2. Parse \pi_{\operatorname{V}} as (s\beta G, sG).

3. Obtain the supported degree bounds d from apk = rk.

4. For each i \in [n],

(a) Check that d_i \in d.

(b) Parse the commitment C_i as a tuple (U_i, S_i) \in \mathbb{G}_1^2.
```

- (d) Parse the proof  $\pi_i$  as  $(W_i, \bar{v}_i)$ .
- 5. For each  $j \in [m]$ , parse the j-th old accumulator  $\operatorname{acc}_j$  as a tuple  $(C_i^{\star}, \pi_i^{\star}) \in \mathbb{G}_1^2$ .
- 6. Compute the new accumulation challenge  $r \in \mathbb{F}_q$  as

$$r := \rho_1(\operatorname{rk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\operatorname{acc}_j]_{j=1}^m, \pi_V)$$
.

- 7. Accumulate commitments and proofs as follows:

  - (a) Compute  $C:=\sum_{i=1}^n r^{i-1}((U_i-v_iG)+\xi_i(S_i-v_i\beta^{D-d_i}G)-\bar{v}_i\gamma G+z_iW_i).$ (b) Accumulate old accumulated commitments:  $C^\star:=C+\sum_{j=1}^m r^{n+j-1}C_j^\star+r^{n+m}\cdot s\beta G.$ (c) Accumulate all old and new proofs:  $\pi^\star:=\sum_{i=1}^n r^{i-1}W_i+\sum_{j=1}^m r^{n+j-1}\pi_j^\star+r^{n+m}\cdot sG.$
- 8. Output the new accumulator acc :=  $(C^*, \pi^*)$ .

**Accumulation prover.** On input the accumulator proving key apk, new inputs  $[q_i]_{i=1}^n$ , and old accumulators  $[acc_j]_{j=1}^m$ , P computes a new accumulator acc as follows. Sample a random scalar  $s \in \mathbb{F}_q$ , set the accumulation proof  $\pi_V := (s\beta G, sG)$ , compute the new accumulator acc := ComputeAcc $^{\rho}$ (apk = avk,  $[q_i]_{i=1}^n$ ,  $[acc_j]_{j=1}^m$ ,  $\pi_V$ ), and output  $(acc, \pi_V)$ .

**Accumulation verifier.** On input the accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumulator verification key avk, new instances  $[q_i]_{i=1}^n$ , old accumu lators  $[acc_j]_{j=1}^m$ , and a new accumulator acc, V checks that acc accumulates  $[q_i]_{i=1}^n$  and  $[acc_j]_{j=1}^m$  simply by running the common subroutine ComputeAcc, i.e. by checking that

$$\mathsf{acc} = \mathsf{ComputeAcc}^\rho(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \pi_{\mathsf{V}}) \enspace .$$

**Decider.** On input the decision key dk and an accumulator acc, D checks the validity of acc by parsing acc as a tuple  $(C^*, \pi^*) \in \mathbb{G}_1^2$  and checking that  $e(C^*, H) = e(\pi^*, \beta H)$ .

#### <span id="page-42-0"></span>8.2 **Proof of Theorem 8.1**

Note that in the foregoing construction, one can view the accumulation proof  $\pi_V = (s\beta G, sG)$  as an accumulator because it passes the decider's pairing check:  $e(s\beta G, H) = e(sG, \beta H)$ . We adopt this viewpoint below, and omit explicit discussion of  $\pi_V$  in both the completeness and soundness proofs. This is a valid change because it never weakens the adversary: in the completeness proof, the honest prover simply adds another honest old accumulator to the list sampled by the adversary A, and in the soundness proof the adversary A already samples old accumulators.

**Completeness.** We argue completeness directly. First, we follow [CHMMVW20] and rewrite the pairing equation in PC<sub>AGM</sub>. Check as follows:

$$\begin{split} e(C'-vG-\bar{v}\gamma G,H) &= e(W,\beta H-zH)\\ &= e(W,\beta H) - e(W,zH)\\ &= e(W,\beta H) - e(zW,H)\\ \Longrightarrow e(C'-vG-\bar{v}\gamma G+zW,H) &= e(W,\beta H) \ . \end{split}$$

Now, we want to show that AS.P, when given accepting inputs  $[((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n$  and old accumulators  $[\mathsf{acc}_j]_{j=1}^m$  that are accepted by AS.D, outputs a new accumulator acc such that AS.V successfully verifies that acc is the accumulation of  $[((C_i,d_i,z_i,v_i),\pi_i)]_{i=1}^n$  and  $[\mathsf{acc}_j]_{j=1}^m$ , and that AS.D accepts acc.

First, since for each  $i \in [n]$ ,  $\Phi_{PC}(i_{\Phi}, (C_i, z_i, d_i, v_i), \pi_i) = 1$ , we know that  $e(C'_i - v_i G - \bar{v}_i \gamma G, H) =$  $e(W_i, \beta H - z_i H)$ , which, by the foregoing manipulation, implies that  $e(C' - vG - \bar{v}_i \gamma G + z_i W_i, H) =$  $e(W_i, \beta H)$ . Hence, for any choice of  $r \in \mathbb{F}_q$ , it holds that

<span id="page-42-1"></span>
$$e(\sum_{i=1}^{n} r^{i-1}(C_i' - v_i G - \bar{v}_i \gamma G + zW_i), H) = e(\sum_{i=1}^{n} r^{i-1} W_i, \beta H) .$$
 (8)

Next, since for each  $j \in [m]$ ,  $acc_j$  is accepted by D, we know that  $e(C_j^*, H) = e(\pi_j^*, \beta H)$ . Hence, for any choice of  $r \in \mathbb{F}_q$ , it holds that

<span id="page-43-0"></span>
$$e(\sum_{j=1}^{m} r^{n+j-1} C_j^{\star}, H) = e(\sum_{j=1}^{m} r^{n+j-1} \pi_j^{\star}, \beta H) .$$
 (9)

Adding Equations (8) and (9), we obtain that  $e(C^{\star}, H) = e(\pi^{\star}, \beta H)$ , and hence AS.D(dk, acc =  $(C^{\star}, \pi^{\star})$ ) = 1, as required. Furthermore, V accepts as it just runs the common subroutine P. Hence AS achieves completeness.

**Soundness.** Recall that we must show that the following probability is negligible for all polynomial-size adversaries  $A_1, A_2$ :

<span id="page-43-1"></span>
$$\Pr\left[\begin{array}{c|c} \mathbf{V}^{\rho}(\mathsf{avk}, [\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \mathsf{acc}) = 1 \\ \mathbf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}) = 1 \\ \wedge \\ (\exists j \in [m], \ \mathbf{D}^{\rho}(\mathsf{dk}, \mathsf{acc}_j) = 0 \ \lor \\ \exists i \in [n], \ \Phi_{\mathsf{PC}}^{\rho}(\mathsf{i}_{\Phi}, \mathsf{q}_i, \pi_i) = 0) \end{array}\right] \begin{array}{c} \rho \leftarrow \mathcal{U}(\lambda) \\ \mathsf{pp} \leftarrow \mathbf{G}^{\rho}(\mathbf{1}^{\lambda}) \\ (\mathsf{i}_{\Phi}, \mathsf{aux}) \leftarrow \mathcal{H}_{\mathsf{PC}, D}^{\rho}(\mathsf{pp}) \\ ([\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \mathsf{acc}) \leftarrow \mathcal{A}_2^{\rho}(\mathsf{pp}, \mathsf{i}_{\Phi}, \mathsf{aux}) \\ (\mathsf{apk}, \mathsf{avk}, \mathsf{dk}) \leftarrow \mathbf{I}^{\rho}(\mathsf{pp}, \mathsf{i}_{\Phi}) \end{array}\right]. \tag{10}$$

First, we rewrite the pairing equation check in the decider D as follows:

$$\begin{split} e(C^\star,H) &= e(\pi^\star,\beta H) \\ & \Leftrightarrow \\ e(\sum_i r^{i-1}(C_i'-v_iG-\bar{v}_i\gamma G+z_iW_i),H) + e(\sum_j r^{n+j-1}C_j^\star,H) &= e(\sum_i r^{i-1}W_i,\beta H) + e(\sum_j r_1^{n+j-1}\pi_j^\star,\beta H) \\ & \Leftrightarrow \\ e(\sum_i r^{i-1}(C_i'-v_iG-\bar{v}_i\gamma G+z_iW_i),H) - e(\sum_i r^{i-1}W_i,\beta H) &= e(\sum_j r^{n+j-1}\pi_j^\star,\beta H) - e(\sum_j r^{n+j-1}C_j^\star,H) \end{split}$$

Writing  $\mathbb{G}_T$  operations additively, this is equivalent to:

$$\sum_{i=1}^{n} r^{i-1} (e(C'_i - v_i G - \bar{v}_i \gamma G + z_i W_i, H) - e(W_i, \beta H)) = \sum_{j=1}^{m} r^{n+j-1} (e(\pi_j^{\star}, \beta H) - e(C_j^{\star}, H))$$

We define a function  $s \colon \mathbb{F}_q \to \mathbb{G}_T$ :

$$s(X) := \sum_{i=1}^n X^{i-1}(e(C_i' - v_iG - \overline{v}_i\gamma G + z_iW_i, H) - e(W_i, \beta H)) - \sum_{j=1}^m X^{n+j-1}(e(\pi_j^\star, \beta H) - e(C_j^\star, H)) \enspace,$$

along with an associated polynomial  $\hat{s}(X) = \sum_{i=1}^{m+n} a_i X^{i-1} \in \mathbb{F}_q[X]$ , where  $a_i \in \mathbb{F}_q$  is such that the coefficient of  $X^{i-1}$  in the above expression is equal to  $a_i G_T$  for some fixed generator  $G_T$  of  $\mathbb{G}_T$ . Note that, for all  $r \in \mathbb{F}_q$ ,  $\hat{s}(r) = 0$  if and only if s(r) = 0.

If the pairing equation  $e(C^*, H) = e(\pi^*, \beta H)$  holds, then s(r) = 0, whence  $\hat{s}(r) = 0$ . Furthermore, observe that  $\hat{s}$  is identically zero if and only if:

- For each i in [n], the coefficient of  $X^{i-1}$  is zero. That is, each  $e(C_i'-v_iG-\bar{v}_i\gamma G+z_iW_i,H)-e(\pi_i,\beta H)=0$ , which in turn means that the predicate  $\Phi_{PC}(\mathbf{i}_\Phi,\mathbf{q}_i,\pi_i)$  accepts.
- For each j in [m], the coefficient of  $X^{n+j-1}$  is zero. That is, each  $e(C_j^*, H) e(\pi_j^*, \beta H) = 0$ , which in turn means that the decider  $D(\mathsf{dk}, \mathsf{acc}_j)$  accepts.

Together, this means that the implication in Eq. (10) is equivalent to the condition that  $\hat{s} \not\equiv 0$  but  $\hat{s}(r) = 0$ . To show that this occurs with negligible probability, we define a zero-finding game and apply Lemma 3.3. We define a commitment scheme CM' = (Setup, Commit) and associated family of mapping functions  $\{f_{pp}\}_{pp}$ . The message space  $\mathcal{M}_{pp}$  for CM' is  $\mathbb{G}_1^{n+m}$ .

```
CM'.Setup^{\rho_0}(1^{\lambda}, L = (m, n)):

1. Sample a bilinear group \langle \operatorname{group} \rangle = (\mathbb{G}_1, \mathbb{G}_2, \mathbb{G}_T, q, G, H, e) \leftarrow \operatorname{SampleGrp}^{\rho_0}(1^{\lambda}).

2. Sample \beta, \gamma \in \mathbb{F}_q.

3. Set the public parameters \operatorname{pp} = (\langle \operatorname{group} \rangle, \beta, \gamma, m, n).

4. Output \operatorname{pp}.

CM'.Commit(\operatorname{pp}, \mathfrak{p} \in \mathcal{M}_{\operatorname{pp}}; r): Output \mathfrak{p}.

 f_{\operatorname{pp}}(\mathfrak{p} \in \mathcal{M}_{\operatorname{pp}}) \to p:

1. Parse \mathfrak{p} as (A_1, \ldots A_{n+m}).

2. Let G_T = e(G, H) be a generator of \mathbb{G}_T.

3. Compute a_i \in \mathbb{F}_q such that A_i = a_i G_T.

4. Output the bivariate polynomial \hat{s}(X) := \sum_{i=1}^{n+m} a_i X^{i-1}.
```

Fix a choice of  $D \in \mathbb{N}$  (inside  $\mathcal{H}_{PC,D}$  from Definition 4.2) that maximizes the success probability of the adversary  $\mathcal{A} = (\mathcal{A}_1, \mathcal{A}_2)$ . We use  $\mathcal{A}$  to construct an adversary  $\mathcal{B}$  against Lemma 3.3 for CM' and  $\{f_{pp}\}_{pp}$ :

```
\mathcal{B}^{\rho}(\mathsf{pp}_{\mathsf{CM}'}) \colon \\ 1. \text{ Parse } \mathsf{pp}_{\mathsf{CM}'} \text{ as } (\langle \mathsf{group} \rangle, \beta, \gamma, m, n). \\ 2. \text{ Compute multiples of } G \text{ as follows: } \mathbf{\Sigma} \coloneqq \begin{pmatrix} G & \beta G & \beta^2 G & \dots & \beta^D G \\ \gamma G & \gamma \beta G & \gamma \beta^2 G & \dots & \gamma \beta^D G \end{pmatrix} \in \mathbb{G}_1^{2D+2} \ . \\ 3. \text{ Set } \mathsf{PC}_{\mathsf{AGM}} \text{ public parameters } \mathsf{pp}_{\mathsf{PC}} \coloneqq (\langle \mathsf{group} \rangle, \mathbf{\Sigma}, \beta H). \\ 4. \text{ Set AS public parameters } \mathsf{pp}_{\mathsf{AS}} \coloneqq 1^{\lambda}. \\ 5. \text{ Compute the predicate index } \mathsf{i}_{\Phi} \text{ as follows:} \\ (a) \text{ Compute } (\mathsf{i}, \mathsf{aux}) \leftarrow \mathcal{A}_1^{\rho}(\mathsf{pp}_{\mathsf{PC}}, \mathsf{pp}_{\mathsf{AS}}). \\ (b) \text{ Set } \mathsf{i}_{\Phi} \coloneqq (\mathsf{i}, \mathsf{pp}_{\mathsf{PC}}). \\ 6. \text{ Compute } ([\mathsf{q}_i]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m, \mathsf{acc}) \leftarrow \mathcal{A}_2^{\rho}(\mathsf{pp}_{\mathsf{AS}}, \mathsf{i}_{\Phi}, \mathsf{aux}). \\ 7. \text{ Parse } [\mathsf{q}_i]_{i=1}^n \text{ as } [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, \text{ and } [\mathsf{acc}_j]_{j=1}^m \text{ as } [(C_j^{\star}, \pi_j^{\star})]_{j=1}^m. \\ 8. \text{ For each } i \in [n], \text{ set } A_i \coloneqq e(C_i' - v_i G - \overline{v_i} \gamma G + z_i W_i, H) - e(W_i, \beta H). \\ 9. \text{ For each } j \in [m], \text{ set } A_{n+j} \coloneqq e(\pi_j^{\star}, \beta H) - e(C_j^{\star}, H). \\ 10. \text{ Output } \mathfrak{p} \coloneqq ([A_i]_{i=1}^{n+m}). \\ \end{cases}
```

Notice that if  $\mathcal{A}$  succeeds, then  $f(\mathfrak{p})=\hat{s}\not\equiv 0$ , but  $\hat{s}(r)=0$ . This is exactly the winning condition for Lemma 3.3, and so  $\mathcal{B}$  succeeds whenever  $\mathcal{A}$  does. This means that if  $\mathcal{A}$  succeeds with probability  $\delta$ , then  $\mathcal{B}$  succeeds in the zero-finding game with probability  $\delta$ , and so  $\delta \leq \operatorname{negl}(\lambda)$  (since q is superpolynomial).

**Zero knowledge.** We demonstrate that AS is zero knowledge by constructing an efficient simulator S. During the setup phase,  $S^{\rho}(1^{\lambda})$  computes  $pp \leftarrow G^{\rho}(1^{\lambda})$ , and outputs  $(pp, \tau = \bot)$ . Then, during the proving phase,  $S^{\rho}(pp, \tau, i_{\Phi})$  samples a random scalar  $s \in \mathbb{F}_q$ , sets  $(C^{\star}, \pi^{\star}) := (s\beta G, sG)$ , and outputs the accumulator acc  $:= (C^{\star}, \pi^{\star})$ . Note that the simulator does not program the random oracle. This implies that AS is zero knowledge, because the simulated public parameters are identical to the honest ones, and the accumulators are identically distributed: in both cases, the accumulator consists of a pair of random group elements.

**Efficiency.** We now analyze the efficiency of our accumulation scheme.

- Generator:  $G^{\rho}(1^{\lambda})$  outputs  $1^{\lambda}$ , and hence takes  $poly(\lambda)$  time.
- *Indexer*:  $I^{\rho}(pp, pp_{PC}, i_{\Phi})$  takes time  $poly(\lambda)$ .

- Accumulation prover:  $P^{\rho}(\mathsf{apk}, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [\mathsf{acc}_j]_{j=1}^m)$  invokes the subroutine ComputeAcc, which in turn computes O(1) linear combinations of O(n+m) elements in  $\mathbb{G}_1$ , and so requires time equal to O(n+m) scalar multiplications in  $\mathbb{G}_1$ .
- Accumulator size: The accumulator acc consists of a pair  $(C^*, \pi^*)$  of elements in  $\mathbb{G}_1$ .
- Accumulation proof size: The accumulation proof  $\pi_V$  consists of two elements in  $\mathbb{G}_1$ .
- Accumulation verifier:  $V^{\rho}(avk, [((C_i, d_i, z_i, v_i), \pi_i)]_{i=1}^n, [acc_j]_{j=1}^m, acc, \pi_V)$  simply invokes the common subroutine ComputeAcc, and so runs in the same time as P.
- *Decider*:  $D^{\rho}(dk, acc)$  performs one pairing, and so its running time is as claimed.

<span id="page-46-0"></span>All algorithms below have access to the same random oracle  $\rho_0$ .

**Setup.** On input a security parameter  $\lambda$  (in unary) and a maximum degree D,  $PC_{AGM}$ . Setup samples public parameters  $pp_{PC}$  as follows. Sample a bilinear group  $(\mathbb{G}_1,\mathbb{G}_2,\mathbb{G}_T,q,G,H,e) \leftarrow \mathsf{SampleGrp}^{\rho_0}(1^{\lambda})$ , and then sample a field element  $\beta \in \mathbb{F}_q$ . Compute

$$\boldsymbol{\Sigma} := \left( \begin{array}{cccc} G & \beta G & \beta^2 G & \dots & \beta^D G \\ \gamma G & \gamma \beta G & \gamma \beta^2 G & \dots & \gamma \beta^D G \end{array} \right) \in \mathbb{G}_1^{2D+2} \ .$$

Output  $\mathsf{pp}_\mathsf{PC} := (\langle \mathsf{group} \rangle, \Sigma, \beta H).$ 

**Trim.** Given oracle access to public parameters  $\operatorname{pp}_{\mathsf{PC}}$ , and on input a list of degree bounds  $[d_i]_{i=1}^n$ ,  $\operatorname{PC}_{\mathsf{AGM}}$ . Trim specializes the public parameters  $\operatorname{pp}_{\mathsf{PC}}$  to the degree bounds  $[d_i]_{i=1}^n$  as follows. Compute  $d:=\max_{i\in[n]}(d_1,\ldots,d_n)$ . From the powers  $\Sigma$  in  $\operatorname{pp}_{\mathsf{PC}}$ , select  $\Sigma_{\mathsf{ck}}$  as follows:

$$\boldsymbol{\Sigma}_{\mathsf{ck}} := \left( \begin{array}{cccc} G & \beta G & \dots & \beta^d G & \beta^{D-d} G & \beta^{D-d+1} G & \dots & \beta^D G \\ \gamma G & \gamma \beta G & \dots & \gamma \beta^d G & \end{array} \right) \in \mathbb{G}_1^{3d+3} \ .$$

Select  $\Sigma_{\mathsf{rk}} := \{\beta^{D-d_i}G\}_{i \in [n]}$ . Set the commitment key  $\mathsf{ck} := (\langle \mathsf{group} \rangle, D, \Sigma_{\mathsf{ck}})$  and receiver key  $\mathsf{rk} := (D, \langle \mathsf{group} \rangle, \Sigma_{\mathsf{rk}}, \gamma G, \beta H, [d_i]_{i=1}^n)$ . Output  $(\mathsf{ck}, \mathsf{rk})$ .

**Commit.** On input the commitment key ck, a univariate polynomial p over the field  $\mathbb{F}_q$ , a degree bound d, and commitment randomness  $(\omega,\omega^\star)$ ,  $\mathsf{PC}_{\mathsf{AGM}}$ . Commit computes a commitment to p as follows. Obtain the supported degree bounds  $[d_i]_{i=1}^n$  from ck. If  $\deg(p)>d$  or  $d\not\in [d_i]_{i=1}^n$ , abort. If  $\omega$  and  $\omega^\star$  are not  $\bot$ , then obtain from them random univariate polynomials  $\bar{p}$  and  $\bar{p}^\star$  of degree  $\deg(p)$ ; otherwise, set  $\bar{p}$  and  $\bar{p}^\star$  to be the zero polynomial. Compute an "unshifted" commitment  $U:=p(\beta)G+\bar{p}(\beta)\gamma G$  and a "shifted" commitment  $S:=\beta^{D-d_i}p(\beta)G+\bar{p}^\star(\beta)\gamma G$ . Finally, output C:=(U,S). Note that the U and S can be computed as linear combinations of terms in ck.

**Open.** On input the commitment key ck, a univariate polynomial p over the field  $\mathbb{F}_q$ , a commitment C to p, a degree bound d, an evaluation point z, and commitment randomness  $(\omega, \omega^*)$ ,  $PC_{AGM}$ . Open computes an opening proof  $\pi$  as follows.

Obtain the supported degree bounds  $[d_i]_{i=1}^n$  from ck. If  $\omega$  and  $\omega^\star$  are not  $\bot$ , then obtain from them random univariate polynomials  $\bar{p}$  and  $\bar{p}^\star$  of degree  $\deg(p)$ ; otherwise, set  $\bar{p}$  and  $\bar{p}^\star$  to be the zero polynomial. If  $\deg(p)>d$  or  $d\not\in [d_i]_{i=1}^n$ , abort. Compute the evaluation v:=p(z) and the opening challenge  $\xi:=\rho_0(\mathrm{rk},d,C,z,v)\in\mathbb{F}_q$ . Then, define the polynomial  $p^\star(X):=X^{D-d}p(X)-X^{D-d}p(z)$ , and compute a witness polynomial  $w(X):=\frac{p(X)-p(z)}{X-z}$  for p, and a witness polynomial  $w^\star(X):=X^{D-d}w(X)$  for  $p^\star$ . Combine these into  $w':=w+\xi w^\star$  Compute witness polynomials  $\bar{w}(X):=\frac{\bar{p}(X)-\bar{p}(z)}{X-z}$  for  $\bar{p}$  and  $\bar{w}^\star(X):=\frac{\bar{p}^\star(X)-\bar{p}^\star(z)}{X-z}$  for  $\bar{p}^\star$ . Combine these into  $\bar{w}':=\bar{w}+\xi\bar{w}^\star$ . Compute the evaluation  $\bar{v}:=\bar{w}'(z)$ .

Compute  $W := w'(\beta)G + \bar{w}'(\beta)\gamma G$ , and output the evaluation proof  $\pi := (W, \bar{v})$ .

**Check.** On input the receiver key rk, a commitment C, a degree bound d, an evaluation point z, a claimed evaluation v, a evaluation proof  $\pi$ ,  $PC_{AGM}$ . Check proceeds as follows.

If  $d \notin \mathsf{rk}$ , abort. Parse the commitment C as a tuple  $(U,S) \in \mathbb{G}_1^2$ . Parse the proof  $\pi$  as  $(W,\bar{v}) \in \mathbb{G}_1 \times \mathbb{F}_q$ . Compute the opening challenge  $\xi := \rho_0(\mathsf{rk},C,z,d,v)$ . Compute the combined commitment  $C' := U + \xi S$ , and check the evaluation proof via the equality  $e(C' - vG - v\beta^{D-d}G - \bar{v}\gamma G, H) = e(W,\beta H - zH)$ .

**Figure 1:** The polynomial commitment scheme PC<sub>AGM</sub>. Note that this scheme differs from the one described in [CHMMVW20] in that above PC<sub>AGM</sub>. Check take as input the commitment, and generates an opening challenge by evaluating a random oracle on the commitment, whereas in [CHMMVW20], the opening challenge is provided as an explicit external input.

## <span id="page-47-0"></span>**A** Construction of PC<sub>DL</sub>

We describe  $PC_{DL}$ , a polynomial commitment scheme based on the discrete logarithm problem that is inspired by several prior works [BCCGP16; BBBPWM18; WTSTW18]. This section is organized as follows: in Appendix A.1 we define Pedersen commitments; in Appendix A.2 we provide the construction of  $PC_{DL}$ ; and in Appendix A.3 we discuss the security of  $PC_{DL}$ . Throughout the section we highlight in blue the parts of the construction that are necessary to make the commitment scheme hiding.

### <span id="page-47-1"></span>A.1 Pedersen commitments

The Pedersen commitment scheme [Ped92] is a binding commitment on vectors of field elements that is linearly homomorphic with respect to both the commitment key and the committed elements.

- CM.Setup, on input a security parameter  $\lambda$  (written in unary) and a message format  $L \in \mathbb{N}$ , samples public parameters  $pp = (\langle group \rangle, \Sigma, S)$  where  $\langle group \rangle = (\mathbb{G}, q, G) \leftarrow \mathsf{SampleGrp}^{\rho}(1^{\lambda})$  is a description of a group of prime order, and  $(S, \Sigma = (G_1, \dots, G_L))$  are independent uniformly-sampled generators for  $\mathbb{G}$ .
- CM. Trim, on input public parameters pp and a trim specification  $\ell \in \mathbb{N}$ , selects  $hk := (G_1, \dots, G_\ell) \in \mathbb{G}^\ell$  from  $\Sigma$  and outputs  $ck := (\langle \text{group} \rangle, hk, S)$ . The message space is  $\mathcal{M} := \mathbb{F}_q^\ell$ .
- CM.Commit, on input a commitment key  $\operatorname{ck} = (\langle \operatorname{group} \rangle, \operatorname{hk}, S)$ , a message  $m \in \mathcal{M} = \mathbb{F}_q^\ell$ , and commitment randomness  $\omega \in \mathbb{F}_q$ , computes the commitment C as follows. If  $\omega = \bot$ , set  $\omega := 0$ . Then, compute the commitment  $C := \omega S + \sum_{i=1}^\ell m_i G_i \in \mathbb{G}$ .

The Pedersen commitment scheme is binding provided the discrete logarithm problem is hard for SampleGrp. Observe that for fixed  $\omega$ , the commitment algorithm CM.Commit is a deterministic function of ck and m. Below we use CM.Commit $_{hk}(m)$  to denote the deterministic commitment CM.Commit $_{ck}(m)$ , where  $_{ck} = (\langle \operatorname{group} \rangle, \operatorname{hk}, S)$ .

Notice that CM.Commit satisfies the following bilinearity property: if  $\mathsf{ck} = (\langle \mathsf{group} \rangle, \mathsf{hk}, S)$  and  $\mathsf{ck'} = (\langle \mathsf{group} \rangle, \mathsf{hk'}, S)$  have the same group description and  $|\mathsf{hk}| = |\mathsf{hk'}| = \ell$  then

```
\begin{aligned} \mathsf{Commit}(\mathsf{ck},\vec{a};\ \omega_a) + \mathsf{Commit}(\mathsf{ck},\vec{b};\ \omega_b) &= \mathsf{Commit}(\mathsf{ck},\vec{a}+\vec{b};\ \omega_a+\omega_b) \quad \text{and} \\ \mathsf{CM}.\mathsf{Commit}_{\mathsf{hk}}(\vec{a}) + \mathsf{CM}.\mathsf{Commit}_{\mathsf{hk'}}(\vec{a}) &= \mathsf{CM}.\mathsf{Commit}_{\mathsf{hk}+\mathsf{hk'}}(\vec{a}) \enspace , \end{aligned}
```

where hk + hk' denotes addition in the group  $\mathbb{G}^{\ell}$ . Note that the foregoing bilinearity property implies that  $CM.Commit_{hk}(\vec{a}) = CM.Commit_{x^{-1} \cdot hk}(x \cdot \vec{a})$  for all  $x \in \mathbb{F}_q^*$ .

### <span id="page-47-2"></span>A.2 Construction

In our construction below, all algorithms have oracle access to the same random oracle  $\rho_0$ . We assume without loss of generality that expressions of the form d+1 and D+1 are powers of 2. For a vector  $\vec{a} \in S^n$  for any set S, we use the notation  $\mathbf{l}(\vec{a}) := (a_1, \ldots, a_{n/2})$  and  $\mathbf{r}(\vec{a}) := (a_{n/2+1}, \ldots, a_n)$  to denote the left and right halves of  $\vec{a}$ , respectively.

**Setup.** On input security parameter  $\lambda$  (written in unary) and a maximum supported degree D,  $\mathsf{PC}_\mathsf{DL}$ . Setup samples public parameters  $\mathsf{pp} = (\langle \mathsf{group} \rangle = (\mathbb{G}, q, G), \Sigma, S) \leftarrow \mathsf{CM}.\mathsf{Setup}^{\rho_0}(1^\lambda, D+1)$ , samples a random generator  $H \leftarrow \rho_0(\mathsf{pp})$  in the group  $\mathbb{G}$ , and outputs the public parameters  $\mathsf{pp}_\mathsf{PC} := (\mathsf{pp}, H)$ .

<sup>&</sup>lt;sup>5</sup>In practice, one would sample the generators using the random oracle:  $(S, \Sigma = (G_1, \dots, G_L)) \leftarrow \rho(\langle \mathsf{group} \rangle, L)$ .

**Trim.** Given oracle access to the public parameters  $pp_{PC}$  and a single degree bound d that is at most D,  $PC_{DL}$ . Trim specializes the public parameters for the degree bounds as follows: parse  $pp_{PC}$  as (pp, H), compute  $ck \leftarrow CM$ . Trim(pp, d+1), and output  $(ck_{PC}, rk_{PC}) := ((ck, H), (ck, H))$ . (We note that we consider the case where  $PC_{DL}$ . Trim only receives a single degree bound d rather than a vector of degrees  $[d_i]_{i=1}^n$ . We omit details for this more general case.)

**Commit.** On input the commitment key  $\mathsf{ck}_{\mathsf{PC}} = (\mathsf{ck}, H)$ , a univariate polynomial p over the field  $\mathbb{F}_q$ , a degree bound d, and commitment randomness  $\omega$ ,  $\mathsf{PC}_{\mathsf{DL}}$ . Commit outputs  $C := \mathsf{CM}$ . Commit( $\mathsf{ck}, \vec{c}, \omega$ ), where  $\vec{c} = (c_0, \dots, c_d)$  are the coefficients of p.

**Open.** On input the commitment key  $\operatorname{ck}_{PC} = (\operatorname{ck}, H)$ , a univariate polynomial p(X), a commitment C to p, a degree bound d, an evaluation point z, and commitment randomness  $\omega$ ,  $\operatorname{PC}_{DL}$ . Open computes an evaluation proof  $\pi$  by using (a variant of) the inner product argument in [BCCGP16; BBBPWM18] as follows.

- 1. Compute the evaluation  $v := p(z) \in \mathbb{F}_q$ .
- 2. Sample a random polynomial  $\bar{p} \in \mathbb{F}_q^{\leq d}[X]$  such that  $\bar{p}(z) = 0$ .
- 3. Sample corresponding commitment randomness  $\bar{\omega} \in \mathbb{F}_q$ .
- 4. Compute a hiding commitment to  $\bar{p}$ :  $\bar{C} \leftarrow \mathsf{CM}.\mathsf{Commit}^{\rho_0}(\mathsf{ck}, \bar{p}; \bar{\omega}) \in \mathbb{G}$ .
- 5. Compute the challenge  $\alpha:=\rho(C,z,v,\bar{C})\in\mathbb{F}_q^*$ .
- 6. Compute the polynomial  $p' := p + \alpha \bar{p} = \sum_{i=0}^{d} c_i X^i \in \mathbb{F}_q[X]$ .
- 7. Compute commitment randomness  $\omega' := \omega + \alpha \bar{\omega} \in \mathbb{F}_q$ .
- 8. Compute a non-hiding commitment to  $p': C' := C + \alpha \bar{C} \omega' S \in \mathbb{G}$ .

Compute the 0-th challenge field element  $\xi_0 := \rho_0(C', z, v) \in \mathbb{F}_q$ , and use it to compute the group element  $H' := \xi_0 H \in \mathbb{G}$ . Initialize the following vectors:

$$\vec{c}_0 := (c_0, c_1, \dots, c_d) \in \mathbb{F}_q^{d+1} \quad \text{and} \quad \vec{z}_0 := (1, z, \dots, z^d) \in \mathbb{F}_q^{d+1} \quad \text{and} \quad \vec{G}_0 := (G_0, G_1, \dots, G_d) \in \mathbb{G}^{d+1} \quad .$$

Next, for each  $i \in [\log (d+1)]$ , perform the following steps:

- 1. Setting  $\Sigma_L := \mathbf{l}(\vec{G}_{i-1}) \mid\mid H'$ , compute the left commitment  $L_i := \mathsf{CM.Commit}_{\Sigma_L} \big( \mathbf{r}(\vec{c}_{i-1}) \mid\mid \langle \mathbf{r}(\vec{c}_{i-1}), \mathbf{l}(\vec{z}_{i-1}) \rangle \big)$ .
- 2. Setting  $\Sigma_{\mathbf{R}} := \mathbf{r}(\vec{G}_{i-1}) \mid\mid H'$ , compute the right commitment  $R_i := \mathsf{CM.Commit}_{\Sigma_{\mathbf{R}}} \big( \mathbf{l}(\vec{c}_{i-1}) \mid\mid \langle \mathbf{l}(\vec{c}_{i-1}), \mathbf{r}(\vec{z}_{i-1}) \rangle \big)$ .
- 3. Generate the *i*-th challenge  $\xi_i:=\rho_0(\xi_{i-1},L_i,R_i)\in\mathbb{F}_q.$
- 4. Construct the commitment key for the next round:  $\vec{G}_i := \mathbf{l}(\vec{G}_{i-1}) + \xi_i \cdot \mathbf{r}(\vec{G}_{i-1})$ .
- 5. Construct commitment inputs for the next round:  $\vec{c}_i := \mathbf{l}(\vec{c}_{i-1}) + \vec{\xi_i}^{-1} \cdot \mathbf{r}(\vec{c}_{i-1})$  and  $\vec{z}_i := \mathbf{l}(\vec{z}_{i-1}) + \vec{\xi}_i \cdot \mathbf{r}(\vec{z}_{i-1})$ .

Finally, set  $U := G_{\log{(d+1)}}, c := c_{\log{(d+1)}}$ , and output the evaluation proof  $\pi := (\vec{L}, \vec{R}, U, c, \bar{C}, \omega')$ .

**Check.** On input the receiver key  $\mathsf{rk}_{\mathsf{PC}} = (\mathsf{ck}, H)$ , a commitment C, a degree bound d, an evaluation point z, a claimed evaluation v, and an evaluation proof  $\pi$ ,  $\mathsf{PC}_{\mathsf{DL}}$ . Check verifies the evaluation proof by invoking the verifier of the inner product argument as follows.

- 1. Parse ck as  $(\langle \mathsf{group} \rangle, \mathsf{hk}, S)$ .
- 2. Set  $d' := |\mathsf{hk}| 1$ .
- 3. Set  $\mathsf{rk} := (\langle \mathsf{group} \rangle, S, H, d')$ .
- 4. Check that  $PC_{DL}$ .SuccinctCheck $^{\rho_0}(\mathsf{rk},C,d,z,v,\pi)$  accepts and outputs (h,U). (See Figure 2).
- 5. Check that  $U = \mathsf{CM}.\mathsf{Commit}(\mathsf{ck}, \vec{h})$ , where  $\vec{h}$  is the coefficient vector of the polynomial h.

```
PC<sub>DL</sub>.SuccinctCheck^{\rho_0} (rk, C, d, z, v, \pi):

1. Parse rk as (\langle \text{group} \rangle, S, H, d'), and \pi as (\vec{L}, \vec{R}, U, c, \vec{C}, \omega').

2. Check that d = d'.

3. Compute the challenge \alpha := \rho_0(C, z, v, \vec{C}) \in \mathbb{F}_q^*.

4. Compute the non-hiding commitment C' := C + \alpha \vec{C} - \omega' S \in \mathbb{G}.

5. Compute the 0-th challenge \xi_0 := \rho_0(C', z, v), and set H' := \xi_0 H \in \mathbb{G}.

6. Compute the group element C_0 := C' + vH' \in \mathbb{G}.

7. For each i \in [\log(d+1)]:

(a) Generate the i-th challenge: \xi_i := \rho_0(\xi_{i-1}, L_i, R_i) \in \mathbb{F}_q.

(b) Compute the i-th commitment: C_i := \xi_i^{-1} L_i + C_{i-1} + \xi_i R_i \in \mathbb{G}.

8. Define the univariate polynomial h(X) := \prod_{i=0}^{\log(d+1)-1} (1 + \xi_{\log(d+1)-i} X^{2^i}) \in \mathbb{F}_q[X].

9. Compute the evaluation v' := c \cdot h(z) \in \mathbb{F}_q.

10. Check that C_{\log(d+1)} = \text{CM.Commit}_{\Sigma}(c || v'), where \Sigma = (U || H').
```

Figure 2: The subroutine PC<sub>DL</sub>.SuccinctCheck that is invoked by PC<sub>DL</sub>.Check and by our accumulation scheme.

## <span id="page-49-0"></span>A.3 Security

## A.3.1 Hiding

We construct the following simulator S for  $PC_{DL}$ .

```
S. \mathsf{Setup}^{\rho_0}(1^\lambda, D) \colon \\ 1. \ \mathsf{Compute} \ \mathsf{pp} := \mathsf{PC}_\mathsf{DL}. \mathsf{Setup}^\rho(1^\lambda). \\ 2. \ \mathsf{Output} \ (\mathsf{pp}, \mathsf{trap} := \mathsf{pp}). \\ \\ S. \mathsf{Commit}^{\rho_0}(\mathsf{trap} = \mathsf{pp}, d) \colon \\ 1. \ \mathsf{Compute} \ (\mathsf{ck}, \mathsf{rk}) := \mathsf{PC}. \mathsf{Trim}^{\rho_0}(\mathsf{pp}, d). \\ 2. \ \mathsf{Sample} \ \mathsf{a commitment} \ \mathsf{random ness} \ \bar{\omega} \in \mathbb{F}_q. \\ 4. \ \mathsf{Compute} \ \mathsf{a hiding} \ \mathsf{commitment} \ \mathsf{to} \ \bar{p} \colon \bar{C} \leftarrow \mathsf{CM}. \mathsf{Commit}^{\rho_0}(\mathsf{ck}, \bar{p}; \bar{\omega}). \\ 5. \ \mathsf{Define} \ \mathsf{the} \ \mathsf{programming} \ \mathsf{function} \ \mu(C, z, v, \bar{C}) := \alpha. \\ 6. \ \mathsf{Proceed} \ \mathsf{as in} \ \mathsf{PC}_\mathsf{DL}. \mathsf{Open} \ \mathsf{to} \ \mathsf{compute} \ \mathsf{the} \ \mathsf{evaluation} \ \mathsf{proof} \ \pi. \\ 7. \ \mathsf{Output} \ (\mu, \pi). \\ \end{cases}
```

We now informally argue that the output of  $\mathcal S$  is computationally indistinguishable from that of an honest execution. First, the public parameters are both honestly sampled. Next, the hiding property of CM means that commitments are uniformly random group elements, and are hence identically distributed in both cases. Next, in both cases the inner product argument is performed with respect to a polynomial p' drawn independently and uniformly conditioned on p'(v)=z, and so these are identically distributed. Finally, for any polynomial-time adversary the programmed random oracle  $\rho[\mu]$  is indistinguishable from the honestly sampled random oracle  $\rho$  because  $\mathcal S$  programs it at the point  $(C,z,v,\bar C)$ , which has sufficiently high entropy due to the randomness of  $\bar C$ .

### A.3.2 Extractability

It is conjectured that if the Pedersen commitment scheme is binding, then PC<sub>DL</sub> constructed in Appendix A.2 is a polynomial commitment scheme in the random oracle model (Section 3.6). Below we summarize what is currently known about this conjecture.

Recall that in PCDL, the algorithms PCDL.Open and PCDL.Check are obtained by applying the Fiat–Shamir transformation [\[FS86\]](#page-52-17) to a public-coin "inner-product" argument system. We first discuss the security of this interactive argument, and then discuss the security (in the random oracle model) of the non-interactive argument obtained after applying the Fiat–Shamir transformation.

Security of the interactive argument. A sequence of works [\[BCCGP16;](#page-51-6) [BBBPWM18;](#page-51-7) [WTSTW18;](#page-53-3) [BMMV19\]](#page-51-13) have shown how to construct various inner-product arguments of knowledge from any doublyhomomorphic commitment scheme by explicitly constructing an efficient rewinding extractor. The innerproduct argument used in PCDL is a special case of an inner-product argument in [\[BMMV19\]](#page-51-13), and thus inherits its knowledge soundness guarantees.

Security of the resulting non-interactive argument. It is known from folklore that applying the Fiat– Shamir transformation to a public-coin k-round interactive argument of knowledge with negligible soundness error yields a non-interactive argument of knowledge in the random-oracle model where the extractor E runs in time exponential in k. In more detail, to extract from an adversary that makes t queries to the random oracle, E runs in time t O(k) . In our setting, the inner-product argument has k = O(log d) rounds, which means that if we apply this folklore result, we would obtain an extractor that runs in superpolynomial (but subexponential) time t <sup>O</sup>(log <sup>d</sup>) = 2O(log(λ) 2 ) . It remains an interesting open problem to construct an extractor that runs in polynomial time.

# <span id="page-51-0"></span>Acknowledgements

The authors thank William Lin for pointing out an error in a prior version of the construction of PCDL. This research was supported in part by: the Berkeley Haas Blockchain Initiative and a donation from the Ethereum Foundation. Benedikt Bunz performed part of the work while visiting the Simons Institute for the Theory of ¨ Computing.

# <span id="page-51-1"></span>References

- <span id="page-51-8"></span>[AHIV17] S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam. "Ligero: Lightweight Sublinear Arguments Without a Trusted Setup". In: *Proceedings of the 24th ACM Conference on Computer and Communications Security*. CCS '17. 2017, pp. 2087–2104.
- <span id="page-51-7"></span>[BBBPWM18] B. Bunz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. "Bulletproofs: Short Proofs ¨ for Confidential Transactions and More". In: *Proceedings of the 39th IEEE Symposium on Security and Privacy*. S&P '18. 2018, pp. 315–334.
- <span id="page-51-6"></span>[BCCGP16] J. Bootle, A. Cerulli, P. Chaidos, J. Groth, and C. Petit. "Efficient Zero-Knowledge Arguments for Arithmetic Circuits in the Discrete Log Setting". In: *Proceedings of the 35th Annual International Conference on Theory and Application of Cryptographic Techniques*. EUROCRYPT '16. 2016, pp. 327–357.
- <span id="page-51-3"></span>[BCCT13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. "Recursive Composition and Bootstrapping for SNARKs and Proof-Carrying Data". In: *Proceedings of the 45th ACM Symposium on the Theory of Computing*. STOC '13. 2013, pp. 111–120.
- <span id="page-51-9"></span>[BCGGHJ17] J. Bootle, A. Cerulli, E. Ghadafi, J. Groth, M. Hajiabadi, and S. K. Jakobsen. "Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability". In: *Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security*. ASIACRYPT '17. 2017, pp. 336–365.
- <span id="page-51-10"></span>[BCRSVW19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. "Aurora: Transparent Succinct Arguments for R1CS". In: *Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques*. EUROCRYPT '19. Full version available at <https://eprint.iacr.org/2018/828>. 2019, pp. 103–128.
- <span id="page-51-11"></span>[BCS16] E. Ben-Sasson, A. Chiesa, and N. Spooner. "Interactive Oracle Proofs". In: *Proceedings of the 14th Theory of Cryptography Conference*. TCC '16-B. 2016, pp. 31–60.
- <span id="page-51-4"></span>[BCTV14] E. Ben-Sasson, A. Chiesa, E. Tromer, and M. Virza. "Scalable Zero Knowledge via Cycles of Elliptic Curves". In: *Proceedings of the 34th Annual International Cryptology Conference*. CRYPTO '14. 2014, pp. 276–294.
- <span id="page-51-12"></span>[BDFLSZ11] D. Boneh, O. Dagdelen, M. Fischlin, A. Lehmann, C. Schaffner, and M. Zhandry. "Random Oracles ¨ in a Quantum World". In: *Proceedings of the 17th International Conference on the Theory and Application of Cryptology and Information Security*. ASIACRYPT '11. 2011, pp. 41–69.
- <span id="page-51-5"></span>[BGH19] S. Bowe, J. Grigg, and D. Hopwood. *Halo: Recursive Proof Composition without a Trusted Setup*. Cryptology ePrint Archive, Report 2019/1021. 2019.
- <span id="page-51-13"></span>[BMMV19] B. Bunz, M. Maller, P. Mishra, and N. Vesely. ¨ *Proofs for Inner Pairing Products and Applications*. Cryptology ePrint Archive, Report 2019/1177. 2019.
- <span id="page-51-2"></span>[BMRS20] J. Bonneau, I. Meckler, V. Rao, and E. Shapiro. *Coda: Decentralized Cryptocurrency at Scale*. Cryptology ePrint Archive, Report 2020/352. 2020.

- <span id="page-52-16"></span>[BR93] M. Bellare and P. Rogaway. "Random Oracles Are Practical: A Paradigm for Designing Efficient Protocols". In: *Proceedings of the 1st ACM Conference on Computer and Communications Security*. CCS '93. 1993, pp. 62–73.
- <span id="page-52-11"></span>[CCW19] A. Chiesa, L. Chua, and M. Weidner. "On Cycles of Pairing-Friendly Elliptic Curves". In: *SIAM Journal on Applied Algebra and Geometry* 3.2 (2019), pp. 175–192.
- <span id="page-52-10"></span>[CHMMVW20] A. Chiesa, Y. Hu, M. Maller, P. Mishra, N. Vesely, and N. Ward. "Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS". In: *Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques*. EUROCRYPT '20. 2020.
- <span id="page-52-12"></span>[CL20] A. Chiesa and S. Liu. "On the Impossibility of Probabilistic Proofs in Relativized Worlds". In: *Proceedings of the 11th Innovations in Theoretical Computer Science Conference*. ITCS '20. 2020, 57:1–57:30.
- <span id="page-52-3"></span>[Co17] O(1) Labs. *Coda Cryptocurrency*. <https://codaprotocol.com/>. 2017.
- <span id="page-52-5"></span>[COS20] A. Chiesa, D. Ojha, and N. Spooner. "Fractal: Post-Quantum and Transparent Recursive Proofs from Holography". In: *Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques*. EUROCRYPT '20. 2020.
- <span id="page-52-0"></span>[CT10] A. Chiesa and E. Tromer. "Proof-Carrying Data and Hearsay Arguments from Signature Cards". In: *Proceedings of the 1st Symposium on Innovations in Computer Science*. ICS '10. 2010, pp. 310–331.
- <span id="page-52-1"></span>[CTV13] S. Chong, E. Tromer, and J. A. Vaughan. *Enforcing Language Semantics Using Proof-Carrying Data*. Cryptology ePrint Archive, Report 2013/513. 2013.
- <span id="page-52-2"></span>[CTV15] A. Chiesa, E. Tromer, and M. Virza. "Cluster Computing in Zero Knowledge". In: *Proceedings of the 34th Annual International Conference on Theory and Application of Cryptographic Techniques*. EUROCRYPT '15. 2015, pp. 371–403.
- <span id="page-52-17"></span>[FS86] A. Fiat and A. Shamir. "How to prove yourself: practical solutions to identification and signature problems". In: *Proceedings of the 6th Annual International Cryptology Conference*. CRYPTO '86. 1986, pp. 186–194.
- <span id="page-52-13"></span>[GW11] C. Gentry and D. Wichs. "Separating Succinct Non-Interactive Arguments From All Falsifiable Assumptions". In: *Proceedings of the 43rd Annual ACM Symposium on Theory of Computing*. STOC '11. 2011, pp. 99–108.
- <span id="page-52-9"></span>[GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru. *PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge*. Cryptology ePrint Archive, Report 2019/953. 2019.
- <span id="page-52-6"></span>[Halo19] S. Bowe, J. Grigg, and D. Hopwood. *Halo*. 2019. URL: [https://github.com/ebfull/](https://github.com/ebfull/halo) [halo](https://github.com/ebfull/halo).
- <span id="page-52-4"></span>[KB20] A. Kattis and J. Bonneau. *Proof of Necessary Work: Succinct State Verification with Fairness Guarantees*. Cryptology ePrint Archive, Report 2020/190. 2020.
- <span id="page-52-7"></span>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. "Constant-Size Commitments to Polynomials and Their Applications". In: *Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security*. ASIACRYPT '10. 2010, pp. 177–194.
- <span id="page-52-15"></span>[Lin03] Y. Lindell. "Parallel Coin-Tossing and Constant-Round Secure Two-Party Computation". In: *Journal of Cryptology* 16.3 (2003), pp. 143–184.
- <span id="page-52-8"></span>[MBKM19] M. Maller, S. Bowe, M. Kohlweiss, and S. Meiklejohn. "Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updateable Structured Reference Strings". In: *Proceedings of the 26th ACM Conference on Computer and Communications Security*. CCS '19. 2019.
- <span id="page-52-14"></span>[NPR19] M. Naor, O. Paneth, and G. N. Rothblum. "Incrementally Verifiable Computation via Incremental PCPs". In: *Proceedings of the 17th International Conference on the Theory of Cryptography*. TCC '19. 2019, pp. 552–576.

<span id="page-53-1"></span>

| [NT16] | A. Naveh and E. Tromer. "PhotoProof: Cryptographic Image Authentication for Any Set of Per     |
|--------|------------------------------------------------------------------------------------------------|
|        | missible Transformations". In: Proceedings of the 37th IEEE Symposium on Security and Privacy. |
|        | S&P '16. 2016, pp. 255–271.                                                                    |

- <span id="page-53-5"></span>[Pas03] R. Pass. "On Deniability in the Common Reference String and Random Oracle Model". In: *Proceedings of the 23rd Annual International Cryptology Conference*. CRYPTO '03. 2003, pp. 316– 337.
- <span id="page-53-6"></span>[Ped92] T. P. Pedersen. "Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing". In: *Proceedings of the 11th Annual International Cryptology Conference*. CRYPTO '91. 1992, pp. 129– 140.
- <span id="page-53-2"></span>[Pickles20] O(1) Labs. *Pickles*. URL: <https://github.com/o1-labs/marlin>.
- <span id="page-53-4"></span>[SS11] J. H. Silverman and K. E. Stange. "Amicable Pairs and Aliquot Cycles for Elliptic Curves". In: *Experimental Mathematics* 20.3 (2011), pp. 329–357.
- <span id="page-53-0"></span>[Val08] P. Valiant. "Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency". In: *Proceedings of the 5th Theory of Cryptography Conference*. TCC '08. 2008, pp. 1– 18.
- <span id="page-53-3"></span>[WTSTW18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. "Doubly-Efficient zkSNARKs Without Trusted Setup". In: *Proceedings of the 39th IEEE Symposium on Security and Privacy*. S&P '18. 2018, pp. 926–943.