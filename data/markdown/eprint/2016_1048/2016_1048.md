# <span id="page-0-1"></span>The Bitcoin Backbone Protocol with Chains of Variable Difficulty<sup>∗</sup>

Juan A. Garay† Texas A&M University College Station, TX, USA. garay@cse.tamu.edu

Aggelos Kiayias∗†‡ University of Edinburgh & IOHK, Edinburgh, UK akiayias@inf.ed.ac.uk

Nikos Leonardos National and Kapodistrian University of Athens, Greece nikos.leonardos@gmail.com

August 25, 2019

#### Abstract

Bitcoin's innovative and distributedly maintained blockchain data structure hinges on the adequate degree of difficulty of so-called "proofs of work," which miners have to produce in order for transactions to be inserted. Importantly, these proofs of work have to be hard enough so that miners have an opportunity to unify their views in the presence of an adversary who interferes but has bounded computational power, but easy enough to be solvable regularly and enable the miners to make progress. As such, as the miners' population evolves over time, so should the difficulty of these proofs. Bitcoin provides this adjustment mechanism, with empirical evidence of a constant block generation rate against such population changes.

In this paper we provide the first formal analysis of Bitcoin's target (re)calculation function in the cryptographic setting, i.e., against all possible adversaries aiming to subvert the protocol's properties. We extend the q-bounded synchronous model of the Bitcoin backbone protocol [Eurocrypt 2015], which posed the basic properties of Bitcoin's underlying blockchain data structure and shows how a robust public transaction ledger can be built on top of them, to environments that may introduce or suspend parties in each round.

We provide a set of necessary conditions with respect to the way the population evolves under which the "Bitcoin backbone with chains of variable difficulty" provides a robust transaction ledger in the presence of an actively malicious adversary controlling a fraction of the miners strictly below 50% at each instant of the execution. Our work introduces new analysis techniques and tools to the area of blockchain systems that may prove useful in analyzing other blockchain protocols.

## 1 Introduction

The Bitcoin backbone [\[11\]](#page-24-0) extracts and analyzes the basic properties of Bitcoin's underlying blockchain data structure, such as "common prefix" and "chain quality," which parties ("miners") maintain and try to extend by generating "proofs of work" (POW, aka "cryptographic puzzles" [\[8,](#page-24-1) [22,](#page-25-0) [1,](#page-24-2) [13\]](#page-24-3))[1](#page-0-0) . It is then formally shown in [\[11\]](#page-24-0) how fundamental applications including consensus [\[21,](#page-25-1) [16\]](#page-25-2) and a robust public transaction ledger realizing a decentralized cryptocurrency (e.g., Bitcoin [\[19\]](#page-25-3)) can be built on top of them, assuming that the hashing power of an adversary controlling a fraction of the parties is strictly less than 1/2.

The results in [\[11\]](#page-24-0), however, hold for a static setting, where the protocol is executed by a fixed number of parties (albeit not necessarily known to the participants), and therefore with POWs (and hence blockchains) of fixed difficulty. This is in contrast to the actual deployment of the Bitcoin protocol where a "target (re)calculation" mechanism adjusts the hardness level of POWs as the number of parties varies during the

<sup>∗</sup>An abridged version of this paper was published in Crypto 2017.

<sup>†</sup>Part of this work was done while the authors were visiting the Simons Institute for the Theory of Computing, supported by the Simons Foundation and by the DIMACS/Simons Collaboration in Cryptography through NSF grant #CNS-1523467.

<sup>‡</sup>Research partly supported by ERC project CODAMODA, No. 259152, and Horizon 2020 project PANORAMIX, No. 653497.

<span id="page-0-0"></span><sup>1</sup> In Bitcoin, solving a proof of work essentially amounts to brute-forcing a hash inequality based on SHA-256.

protocol execution. In more detail, in [\[11\]](#page-24-0) the target T that the hash function output must not exceed, is set and hardcoded at the beginning of the protocol, and in such a way that a specific relation to the number of parties running the protocol is satisfied, namely, that a ratio f roughly equal to qnT /2 κ is small, where q is the number of queries to the hash function that each party is allowed per round, n is the number of parties, and κ is the length of the hash function output. Security was only proven when the number of parties is n and the choice of target T is never recalculated, thus leaving as open question the full analysis of the protocol in a setting where, as in the real world, parties change dynamically over time.

In this paper, we abstract for the first time the target recalculation algorithm from the Bitcoin system, and present a generalization and analysis of the Bitcoin backbone protocol with chains of variable difficulty, as produced by an evolving population of parties, thus answering the aforementioned open question.

In this setting, there is a parameter m which determines the length of an "epoch" in number of blocks.[2](#page-1-0) When a party prepares to compute the j-th block of a chain with j mod m = 1, it uses a target calculation algorithm that determines the proper target value to use, based on the party's local view about the total number of parties that are present in the system, as reflected by the rate of blocks that have been created so far and are part of the party's chain. (Each block contains a timestamp of when it was created; in our synchronous setting, timestamps will correspond to the round numbers when blocks are created—see Section [2.](#page-2-0)) To accomodate the evolving population of parties, we extend the model of [\[11\]](#page-24-0) to environments that are free to introduce and suspend parties in each round. In other respects, we follow the model of [\[11\]](#page-24-0), where all parties have the same "hashing power," with each one allowed to pose q queries to the hash function that is modeled as a "random oracle" [\[3\]](#page-24-4). We refer to our setting as the dynamic q-bounded synchronous setting.

In order to give an idea of the issues involved, we note that without a target calculation mechanism, in the dynamic setting the backbone protocol is not secure even if all parties are honest and follow the protocol faithfully. Indeed, it is easy to see that a combination of an environment that increases the number of parties and adversarial network conditions can lead to substantial divergence (a.k.a. "forks") in the chains of the honest parties, leading to the violation of the agreement-type properties that are needed for the applications of the protocol, such as maintaining a robust transaction ledger. The attack is simple: the environment increases the number of parties constantly so that the block production rate per round increases (which is roughly the parameter f mentioned above); then, adversarial network conditions may divide the parties into two sets, A and B, and schedule message delivery so that parties in set A receive blocks produced by parties in A first, and similarly for set B. According to the Bitcoin protocol, parties adopt the block they see first, and thus the two sets will maintain two separate blockchains.

While this specific attack could in principle be thwarted by modifying the Bitcoin backbone (e.g., by randomizing which block a party adopts when they receive in the same round two blocks of the same index in the chain), it certainly would not cope with all possible attacks in the presence of a full-blown adversary and target recalculation mechanism. Indeed, such an attack was shown in [\[2\]](#page-24-5), where by mining "privately" with timestamps in rapid succession, corrupt miners are able to induce artificially high targets in their private chain; even though such chain may grow slower than the main chain, it will still make progress and, via an anti-concentration argument, a sudden adversarial advance that can break agreement amongst honest parties cannot be ruled out.

Given the above, our main goal is to show that the backbone protocol with a Bitcoin-like target recalculation function satisfies the common prefix and chain quality properties, as an intermediate step towards proving that the protocol implements a robust transaction ledger. Expectedly, the class of protocols we will analyze will not preserve its properties for arbitrary ways in which the number of parties may change over time. In order to bound the error in the calibration of the block generation rate that the target recalculation function attempts, we will need some bounds on the way the number of parties may vary. For γ ∈ R <sup>+</sup> and s ∈ N, we will call a sequence (nr)r∈<sup>N</sup> of parties (γ, s)-respecting if it holds that in a sequence of rounds S with |S| ≤ s, maxr∈<sup>S</sup> n<sup>r</sup> ≤ γ · minr∈<sup>S</sup> nr, and will determine for what values of these parameters the

<span id="page-1-0"></span><sup>2</sup> In Bitcoin, m is set to 2016 and roughly corresponds to 2 weeks in real time—assuming the number of parties does not change much.

backbone protocol is secure.

After formally describing blockchains of variable difficulty and the Bitcoin backbone protocol in this setting, at a high level our analysis goes as follows. We first introduce the notion of goodness regarding the approximation that is performed on f in an epoch. In more detail, we call a round r (η, θ)-good, for some parameters η, θ ∈ R <sup>+</sup>, if the value f<sup>r</sup> computed for the actual number of parties and target used in round r by some honest party, falls in the range [ηf, θf], where f is the initial block production rate (note that the first round is always assumed good). Together with "goodness" we introduce the notion of typical executions, in which, informally, for any set S of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations as well as no "bad" event concerning the hash function occurs (such as a collision). Using a martingale bound we demonstrate that almost all polynomially bounded (in κ) executions are typical.

Next, we proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much from its real creation time), and (2) it has a target such that the probability of block production remains near the fixed constant f, i.e., it is "good." Finally, these properties allow us to demonstrate that a typical execution enjoys the common prefix and chain quality properties, which is a stepping stone towards the ultimate goal, that of establishing that the backbone protocol with variable difficulty implements a robust transaction ledger. Specifically, we show the following:

Main result (Informal—see Theorems [5](#page-23-0) and [6\)](#page-29-0). The Bitcoin backbone protocol with chains of variable difficulty, suitably parameterized, satisfies with overwhelming probability in m and κ the properties of (1) persistence—if a transaction tx is confirmed by an honest party, no honest party will ever disagree about the position of tx in the ledger, and (2) liveness—if a transaction tx is broadcast, it will eventually become confirmed by all honest parties.

Remark. Regarding the actual parameterization of the Bitcoin system (that uses epochs of m = 2016 blocks), even though it is consistent with all the constraints of our theorems (cf. Remark [3](#page-13-0) in Section [6.1\)](#page-10-0), it cannot be justified by our martingale analysis. In fact, our probabilistic analysis would require much longer epochs to provide a sufficiently small probability of attack. Tightening the analysis or discovering attacks for parameterizations beyond our security theorems is an interesting open question.

Finally, we note that various extensions to our model are relevant to the Bitcoin system and constitute interesting directions for further research. Importantly, a security analysis in the "rational" setting (see, e.g., [\[9,](#page-24-6) [23,](#page-25-4) [14\]](#page-24-7)), and in the "partially synchronous," or "bounded-delay" network model [\[7,](#page-24-8) [20\]](#page-25-5)[3](#page-2-1) .

## <span id="page-2-0"></span>2 Model and Definitions

We describe our protocols in a model that extends the synchronous communication network model presented in [\[10,](#page-24-9) [11\]](#page-24-0) for the analysis of the Bitcoin backbone protocol in the static setting with a fixed number of parties (which in turn is based on Canetti's formulation of "real world" notion of protocol execution [\[4,](#page-24-10) [5,](#page-24-11) [6\]](#page-24-12) for multi-party protocols) to the dynamic setting with a varying number of parties. In this section we provide a high-level overview of the model, highlighting the differences that are intrinsic to our dynamic setting.

Round structure and protocol execution. As in [\[10\]](#page-24-9), the protocol execution proceeds in rounds with inputs provided by an environment program denoted by Z to parties that execute the protocol Π, and our adversarial model in the network is "adaptive," meaning that the adversary A is allowed to take control of parties on the fly, and "rushing," meaning that in any given round the adversary gets to see all honest players' messages before deciding his strategy. The parties' access to the hash function and their communication mechanism are captured by a joint random oracle / diffusion functionality which reflects Bitcoin's peer

<span id="page-2-1"></span><sup>3</sup> In the latest version of [\[10\]](#page-24-9), we show that in the case of fixed difficulty, the analysis of the Bitcoin backbone in the synchronous model extends with relative ease to partial synchrony. We leave the extension of the variable-difficulty case for future work.

structure. The diffusion functionality, [\[10\]](#page-24-9), allows the order of messages to be controlled by A, i.e., there is no atomicity guarantees in message broadcast [\[12\]](#page-24-13), and, furthermore, the adversary is allowed to spoof the source information on every message (i.e., communication is not authenticated). Still, the adversary cannot change the contents of the messages nor prevent them from being delivered. We will use Diffuse as the message transmission command that captures this "send-to-all" functionality.

The parties that may become active in a protocol execution are encoded as part of a control program C and come from a universe U of parties.

The protocol execution is driven by an environment program Z that interacts with other instances of programs that it spawns at the discretion of the control program C. The pair (Z, C) forms of a system of interactive Turing machines (ITM's) in the sense of [\[5\]](#page-24-11). The execution is with respect to a program Π, an adversary A (which is another ITM) and the universe of parties U. Assuming the control program C allows it, the environment Z can activate a party by writing to its input tape. Note that the environment Z also receives the parties' outputs when they are produced in a standard subroutine-like interaction. Additionally, the control program maintains a flag for each instance of an ITM, (abbreviated as ITI in the terminology of [\[5\]](#page-24-11)), that is called the ready flag and is initially set to false for all parties.

The environment Z, initially is restricted by C to spawn the adversary A. Each time the adversary is activated, it may send one or more messages of the form (Corrupt, Pi) to C and C will mark the corresponding party as corrupted.

Functionalities available to the protocol. The ITI's of protocol Π will have access to a joint ideal functionality capturing the random oracle and the diffusion mechanism which is defined in a similar way as [\[10\]](#page-24-9) and is explained below.

- The random oracle functionality. Given a query with a value x marked for "calculation" for the function H(·) from an honest party P<sup>i</sup> and assuming x has not been queried before, the functionality returns a value y which is selected at random from {0, 1} κ ; furthermore, it stores the pair (x, y) in the table of H(·), in case the same value x is queried in the future. Each honest party P<sup>i</sup> is allowed to ask q queries in each round as determined by the diffusion functionality (see below). On the other hand, each honest party is given unlimited queries for "verification" for the function H(·). The adversary A, on the other hand, is given a bounded number queries in each round as determined by diffusion functionality with a bound that is initialized to 0 and determined as follows: whenever a corrupted party is activated, the party can ask the bound to be increased by q; each time a query is asked by the adversary the bound is decreased by 1. No verification queries are provided to A. Note that the value q is a polynomial function of κ, the security parameter. The functionality can maintain tables for functions other than H(·) but, by convention, the functionality will impose query quotas to function H(·) only.
- The diffusion functionality. This functionality keeps track of rounds in the protocol execution; for this purpose it initially sets a variable round to be 1. It also maintains a Receive() string defined for each party P<sup>i</sup> in U. A party that is activated is allowed to query the functionality and fetch the contents of its personal Receive() string. Moreover, when the functionality receives a message (Diffuse, m) from party P<sup>i</sup> it records the message m. A party P<sup>i</sup> can signal when it is complete for the round by sending a special message (RoundComplete). With respect to the adversary A, the functionality allows it to receive the contents of all contents sent in Diffuse messages for the round and specify the contents of the Receive() string for each party P<sup>i</sup> . The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages m that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes (in this way guaranteeing message delivery). It also flushes any old messages that were diffused in previous rounds and not diffused again. The variable round is then incremented.

The dynamic q-bounded synchronous setting. Consider n = {nr}r∈<sup>N</sup> and t = {tr}r∈<sup>N</sup> two series of

natural numbers. As mentioned, the first instance that is spawned by  $\mathcal{Z}$  is the adversary  $\mathcal{A}$ . Subsequently the environment may spawn (or activate if they are already spawned) parties  $P_i \in \mathcal{U}$ . The control program maintains a counter in each sequence of activations and matches it with the current round that is maintained by the diffusion functionality. Each time an honest party diffuses a message containing the label "ready" the control program C increases the ready counter for the round. In round r, the control program C will enable the adversary  $\mathcal{A}$  to complete the round, only provided that (i) exactly  $n_r$  parties have transmitted ready message, (ii) the number of ("corrupt") parties controlled by  $\mathcal{A}$  should match  $t_r$ .

Parties, when activated, are able to read their input tape INPUT() and communication tape RECEIVE() from the diffusion functionality. Observe that parties are unaware of the set of activated parties. The Bitcoin backbone protocol requires from parties (miners) to calculate a POW. This is modeled in [11] as parties having access to the oracle  $H(\cdot)$ . The fact that (active) parties have limited ability to produce such POWs, is captured as in [11] by the random oracle functionality and the fact that it paces parties to query a limited number of queries per round. The bound, q, is a function of the security parameter  $\kappa$ ; in this sense the parties may be called q-bounded<sup>4</sup>. We refer to the above restrictions on the environment, the parties and the adversary as the dynamic q-bounded synchronous setting.

The term  $\{\text{VIEW}_{\Pi,\mathcal{A},\mathcal{Z}}^{P,\mathbf{t},\mathbf{n}}(z)\}_{z\in\{0,1\}^*}$  denotes the random variable ensemble describing the view of party P after the completion of an execution running protocol  $\Pi$  with environment  $\mathcal{Z}$  and adversary  $\mathcal{A}$ , on input  $z\in\{0,1\}^*$ . We will only consider a "standalone" execution without any auxiliary information and we will thus restrict ourselves to executions with  $z=1^\kappa$ . For this reason we will simply refer to the ensemble by  $\text{VIEW}_{\Pi,\mathcal{A},\mathcal{Z}}^{P,\mathbf{t},\mathbf{n}}$ . The concatenation of the view of all parties ever activated in the execution is denoted by  $\text{VIEW}_{\Pi,\mathcal{A},\mathcal{Z}}^{\mathbf{t},\mathbf{n}}$ .

**Properties of protocols.** In our theorems we will be concerned with *properties* of protocols  $\Pi$  running in the above setting. Such properties will be defined as predicates over the random variable  $\text{VIEW}_{\Pi,\mathcal{A},\mathcal{Z}}^{\mathbf{t},\mathbf{n}}$  by quantifying over all possible adversaries  $\mathcal{A}$  and environments  $\mathcal{Z}$ . Note that all our protocols will only satisfy properties with a small probability of error in  $\kappa$  as well as in a parameter k that is selected from  $\{1,\ldots,\kappa\}$  (with foresight we note that in practice would be able to choose k to be much smaller than  $\kappa$ , e.g., k=6).

The protocol class that we will analyze will not be able to preserve its properties for arbitrary sequences of parties. To restrict the way the sequence  $\mathbf{n}$  is fluctuating we will introduce the following class of sequences.

<span id="page-4-2"></span>**Definition 1.** For  $\gamma \in \mathbb{R}^+$ , we call a sequence  $(n_r)_{r \in \mathbb{N}}$   $(\gamma, s)$ -respecting if for any set S of at most s consecutive rounds,  $\max_{r \in S} n_r \leq \gamma \cdot \min_{r \in S} n_r$ .

Observe that the above definition is fairly general and also can capture exponential growth; e.g., by setting  $\gamma = 2$  and s = 10, it follows that every 10 rounds the number of ready parties may double. Note that this will not lead to an exponential running time overall since the total run time is bounded by a polynomial in  $\kappa$ , (due to the fact that  $(\mathcal{Z}, C)$  is a system of ITM's,  $\mathcal{Z}$  is locally polynomial bounded, C is a polynomial-time program, and thus [5, Proposition 3] applies).

More formally, a protocol  $\Pi$  would satisfy a property Q for a certain class of sequences  $\mathbf{n}, \mathbf{t}$ , provided that for all PPT  $\mathcal{A}$  and locally polynomial bounded  $\mathcal{Z}$ , it holds that  $Q(\text{VIEW}_{\Pi,\mathcal{A},\mathcal{Z}}^{\mathbf{t},\mathbf{n}})$  is true with overwhelming probability of the coins of  $\mathcal{A}, \mathcal{Z}$  and the random oracle functionality.

In this paper, we will be interested in  $(\gamma, s)$ -respecting sequences  $\mathbf{n}$ , sequences  $\mathbf{t}$  suitably restricted by  $\mathbf{n}$ , and protocols  $\Pi$  suitably parameterized given  $\mathbf{n}$ ,  $\mathbf{t}$ .

# <span id="page-4-1"></span>3 Blockchains of Variable Difficulty

We start by introducing blockchain notation; we use similar notation to [10], and expand the notion of blockchain to explicitly include timestamps (in the form of a round indicator). Let  $G(\cdot)$  and  $H(\cdot)$  be

<span id="page-4-0"></span><sup>&</sup>lt;sup>4</sup>In [11] this is referred to as the "flat-model" in terms of computational power, where all parties are assumed equal. In practice, different parties may have different "hashing power"; note that this does not sacrifice generality since one can imagine that real parties are simply clusters of some arbitrary number of flat-model parties.

cryptographic hash functions with output in {0, 1} κ . A block with target T ∈ N is a quadruple of the form B = hr, st, x, ctri where st ∈ {0, 1} κ , x ∈ {0, 1} ∗ , and r, ctr ∈ N are such that they satisfy the predicate validblock<sup>T</sup> q (B) defined as

$$(H(ctr, G(r, st, x)) < T) \land (ctr \le q).$$

The parameter q ∈ N is a bound that in the Bitcoin implementation determines the size of the register ctr; as in [\[10\]](#page-24-9), in our treatment we allow q to be arbitrary, and use it to denote the maximum allowed number of hash queries in a round (cf. Section [2\)](#page-2-0). We do this for convenience and our analysis applies in a straightforward manner to the case that ctr is restricted to the range 0 ≤ ctr < 2 <sup>32</sup> and q is independent of ctr.

A blockchain, or simply a chain is a sequence of blocks. The rightmost block is the head of the chain, denoted head(C). Note that the empty string ε is also a chain; by convention we set head(ε) = ε. A chain C with head(C) = hr, st, x, ctri can be extended to a longer chain by appending a valid block B = hr 0 , st<sup>0</sup> , x<sup>0</sup> , ctr<sup>0</sup> i that satisfies st<sup>0</sup> = H(ctr, G(r, st, x)) and r <sup>0</sup> > r, where r 0 is called the timestamp of block B. In case C = ε, by convention any valid block of the form hr 0 , st<sup>0</sup> , x<sup>0</sup> , ctr<sup>0</sup> i may extend it. In either case we have an extended chain Cnew = CB that satisfies head(Cnew) = B.

The length of a chain len(C) is its number of blocks. Consider a chain C of length ` and any nonnegative integer k. We denote by C dk the chain resulting from "pruning" the k rightmost blocks. Note that for k ≥ len(C), C <sup>d</sup><sup>k</sup> = ε. If C<sup>1</sup> is a prefix of C<sup>2</sup> we write C<sup>1</sup> C2.

Given a chain C of length len(C) = `, we let x<sup>C</sup> denote the vector of ` values that is stored in C and starts with the value of the first block. Similarly, r<sup>C</sup> is the vector that contains the timestamps of the blockchain C.

For a chain of variable difficulty, the target T is recalculated for each block based on the round timestamps of the previous blocks. Specifically, there is a function D : Z <sup>∗</sup> → R which receives an arbitrary vector of round timestamps and produces the next target. The value D(ε) is the initial target of the system. The difficulty of each block is measured in terms of how many times the block is harder to obtain than a block of target T0. In more detail, the difficulty of a block with target T is equal to T0/T; without loss of generality we will adopt the simpler expression 1/T (as T<sup>0</sup> will be a constant across all executions). We will use diff(C) to denote the difficulty of a chain. This is equal to the sum of the difficulties of all the blocks that comprise the chain.

The target calculation function. Intuitively, the target calculation function D(·) aims at maintaining the block production rate constant. It is parameterized by m ∈ N and f ∈ (0, 1); Its goal is that m blocks will be produced every m/f rounds. We will see in Section [6](#page-10-1) that the probability f(T, n) with which n parties produce a new block with target T is approximated by

$$f(T,n) \approx \frac{qTn}{2^{\kappa}}.$$

(Note that T /2 κ is the probability that a single player produces a block in a single query.)

To achieve the above goal Bitcoin tries to keep qT n/2 κ close to f. To that end, Bitcoin waits for m blocks to be produced and based on their difficulty and how fast these blocks were computed it computes the next target. More specifically, say the last m blocks of a chain C are for target T and were produced in ∆ rounds. Consider the case where a number of players

$$n(T, \Delta) = \frac{2^{\kappa} m}{qT\Delta}$$

attempts to produce m blocks of target T; note that it will take them approximately ∆ rounds in expectation. Intuitively, the number of players at the point when m blocks were produced is estimated by n(T, ∆); then the next target T 0 is set so that n(T, ∆) players would need m/f rounds in expectation to produce m blocks of target T 0 . Therefore, it makes sense to set

$$T' = \frac{\Delta}{m/f} \cdot T,$$

because if the number of players is indeed  $n(T, \Delta)$  and remains unchanged, it will take them m/f rounds in expectation to produce m blocks. If the initial estimate of the number parties is  $n_0$ , we will assume  $T_0$  is appropriately set so that  $f \approx qT_0n_0/2^{\kappa}$  and then

$$T' = \frac{n_0}{n(T, \Delta)} \cdot T_0.$$

**Remark 1.** Recall that in the flat q-bounded setting all parties have the same hashing power (q-queries per round). It follows that  $n_0$  represents the estimated initial hashing power while  $n(T, \Delta)$  the estimated hashing power during the last m blocks of the chain C. As a result the new target is equal to the initial target  $T_0$  multiplied by the factor  $n_0/n(T, \Delta)$ , reflecting the change of hashing power in the last m blocks.

Based on the above we give the formal definition of the target (re)calculation function, which is as follows.

<span id="page-6-0"></span>**Definition 2.** For fixed constants  $\kappa, \tau, m, n_0, T_0$ , the target calculation function  $D: \mathbb{Z}^* \to \mathbb{R}$  is defined as

$$D(\varepsilon) = T_0 \quad and \quad D(r_1, \dots, r_v) = \begin{cases} \frac{1}{\tau} \cdot T & \text{if } \frac{n_0}{n(T, \Delta)} \cdot T_0 < \frac{1}{\tau} \cdot T; \\ \tau \cdot T & \text{if } \frac{n_0}{n(T, \Delta)} \cdot T_0 > \tau \cdot T; \\ \frac{n_0}{n(T, \Delta)} \cdot T_0 & \text{otherwise,} \end{cases}$$

where  $n(T, \Delta) = 2^{\kappa} m/qT\Delta$ , with  $\Delta = r_{m'} - r_{m'-m}$ ,  $T = D(r_1, \ldots, r_{m'-1})$ , and  $m' = m \cdot |v/m|$ .

In the definition,  $(r_1, \ldots, r_v)$  corresponds to a chain of v blocks with  $r_i$  the timestamp of the ith block;  $m', \Delta$ , and T correspond to the last block, duration, and target of the last completed epoch, respectively.

<span id="page-6-1"></span>**Remark 2.** A remark is in order about the case  $\frac{n_0}{n(T,\Delta)} \cdot T_0 \notin [\frac{1}{\tau}T, \tau T]$ , since this aspect of the definition is not justified by the discussion preceding Definition 2. At first there may seem to be no reason to introduce such a "dampening filter" in Bitcoin's target recalculation function and one should let the parties to try collectively to approximate the proper target. Interestingly, in the absence of such dampening, an efficient attack is known [2] (against the common-prefix property). As we will see, this dampening is sufficient for us to prove security against all attackers, including those considered in [2] (with foresight, we can say that the attack still holds but it will take exponential time to mount).

# 4 The Bitcoin Backbone Protocol with Variable Difficulty

In this section we give a high-level description of the Bitcoin backbone protocol with chains of variable difficulty; a more detailed description, including the pseudocode of the algorithms, is given in Appendix A. The presentation is based on the description in [11]. We then formulate two desired properties of the blockchain—common prefix and chain quality—for the dynamic setting.

#### 4.1 The Protocol

As in [11], in our description of the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions  $G(\cdot), H(\cdot)$ ), and the way they interpret the chain. These checks and operations are handled by the external functions  $V(\cdot), I(\cdot)$  and  $R(\cdot)$  (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs "on top" of the backbone protocol. The Bitcoin backbone protocol in the dynamic setting comprises three algorithms.

Chain validation. The validate algorithm performs a validation of the structural properties of a given chain C. It is given as input the value q, as well as hash functions  $H(\cdot), G(\cdot)$ . It is parameterized by the

content validation predicate  $V(\cdot)$  as well as by  $D(\cdot)$ , the target calculation function (Section 3). For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter ctr does not exceed q. Furthermore it collects the inputs from all blocks,  $\mathbf{x}_{\mathcal{C}}$ , and tests them via the predicate  $V(\mathbf{x}_{\mathcal{C}})$ . Chains that fail these validation procedure are rejected.

Chain comparison. The objective of the second algorithm, called maxvalid, is to find the "best possible" chain when given a set of chains. The algorithm is straightforward and is parameterized by a  $\max(\cdot)$  function that applies some ordering to the space of blockchains. The most important aspect is the chains' difficulty in which case  $\max(\mathcal{C}_1, \mathcal{C}_2)$  will return the most difficult of the two. In case  $\operatorname{diff}(\mathcal{C}_1) = \operatorname{diff}(\mathcal{C}_2)$ , some other characteristic can be used to break the tie. In our case,  $\max(\cdot, \cdot)$  will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network.

**Proof of work.** The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  $H(\cdot), G(\cdot)$  as well as the parameter q. Moreover, the algorithm calls the target calculation function  $D(\cdot)$  in order to determine the value T that will be used for the proof of work. The procedure, given a chain C and a value C to be inserted in the chain, hashes these values to obtain C and initializes a counter C subsequently, it increments C and checks to see whether C in case a suitable C is found then the algorithm succeeds in solving the POW and extends chain C by one block.

The Bitcoin backbone protocol. The core of the backbone protocol with variable difficulty is similar to that in [11], with several important distinctions. First is the procedure to follow when the parties become active. Parties check the ready flag they possess, which is false if and only if they have been inactive in the previous round. In case the ready flag is false, they diffuse a special message 'Join' to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their Receive() tape broadcast their chains. As before parties, run "indefinitely" (our security analysis will apply when the total running time is polynomial in  $\kappa$ ). The input contribution function  $I(\cdot)$  and the chain reading function  $R(\cdot)$  are applied to the values stored in the chain. Parties check their communication tape Receive() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function  $I(\cdot)$  determines the input to be added in the chain given the party's state st, the current chain c, the contents of the party's input tape INPUT() and communication tape Receive(). The input tape contains two types of symbols, Read and (Insert, value); other inputs are ignored. In case the local chain c is extended the new chain is diffused to the other parties. Finally, in case a Read symbol is present in the communication tape, the protocol applies function  $R(\cdot)$  to its current chain and writes the result onto the output tape Output().

#### <span id="page-7-0"></span>4.2 Properties of the Backbone Protocol with Variable Difficulty

Next, we define the two properties of the backbone protocol that the protocol will establish. They are close variants of the properties in [11], suitably modified for the dynamic q-bounded synchronous setting.

The common prefix property essentially remains the same. It is parameterized by a value  $k \in \mathbb{N}$ , considers an arbitrary environment and adversary, and it holds as long as any two parties' chains are different only in their most recent k blocks. It is actually helpful to define the property between an honest party's chain and another chain that may be adversarial. The definition is as follows.

**Definition 3** (Common-Prefix Property). The common-prefix property  $Q_{\sf cp}$  with parameter  $k \in \mathbb{N}$  states that for any pair of honest players  $P_1$ ,  $P_2$  adopting the chains  $C_1$ ,  $C_2$  at rounds  $r_1 \leq r_2$  respectively in VIEW $_{\Pi,\mathcal{A},\mathcal{Z}}^{\sf t}$ , it holds that  $C_1^{\lceil k} \leq C_2$ .

The second property, called *chain quality*, expresses the number of honest-party contributions that are contained in a sufficiently long and continuous part of a party's chain. Because we consider chains of variable difficulty it is more convenient to think of parties' contributions in terms of the total difficulty they add to the chain as opposed to the number of blocks they add (as done in [11]). The property states that adversarial

parties are bounded in the amount of difficulty they can contribute to any sufficiently long segment of the chain.

**Definition 4** (Chain-Quality Property). The chain quality property  $Q_{cq}$  with parameters  $\mu \in \mathbb{R}$  and  $\ell \in \mathbb{N}$  states that for any honest party P with chain C in  $VIEW_{\Pi,\mathcal{A},\mathcal{Z}}^{\mathbf{t},\mathbf{n}}$ , it holds that for any  $\ell$  consecutive blocks of C with total difficulty d, the honest blocks contribute difficulty at least  $\mu \cdot d$ .

#### <span id="page-8-0"></span>4.3 Application: Robust Transaction Ledger

We now come to the (main) application the Bitcoin backbone protocol was designed to solve. A robust transaction ledger is a protocol maintaining a ledger of transactions organized in the form of a chain C, satisfying the following two properties.

- Persistence: Parameterized by  $k \in \mathbb{N}$  (the "depth" parameter), if an honest party P, maintaining a chain C, reports that a transaction tx is in  $C^{\lceil k}$ , then it holds for every other honest party P' maintaining a chain C' then C' contains tx in exactly the same position.
- Liveness: Parameterized by  $u, k \in \mathbb{N}$  (the "wait time" and "depth" parameters, resp.), if a transaction tx is provided to all honest parties for u consecutive rounds, then it holds that for any player P, maintaining a chain C, tx will be in  $C^{\lceil k \rceil}$ .

We note that, as in [11], Liveness is applicable to either "neutral" transactions (i.e., those that they are never in "conflict" with other transactions in the ledger), or transactions that are produced by an oracle Txgen that produces honestly generated transactions.

## <span id="page-8-1"></span>5 Overview of the Analysis

Our main goal is to show that the backbone protocol satisfies the properties common prefix and chain quality (Section 4.2) in a  $(\gamma, s)$ -respecting environment as an intermediate step towards proving, eventually, that the protocol implements a robust transaction ledger. In this section we present a high-level overview of our approach; the full analysis is then presented in Section 6. To prove the aforementioned properties we first characterize the set of typical executions. Informally, an execution is typical if for any set S of consecutive rounds the successes of the adversary and the honest parties do not deviate too much from their expectations and no bad event occurs with respect to the hash function (which we model as a "random oracle"). Using the martingale bound of Theorem 7 we demonstrate that almost all polynomially bounded executions are typical. We then proceed to show that in a typical execution any chain that an honest party adopts (1) contains timestamps that are approximately accurate (i.e., no adversarial block has a timestamp that differs too much by its real creation time) and (2) has a target such that the probability of block production remains near a fixed constant f. Finally, these properties of a typical execution will bring us to our ultimate goal: to demonstrate that a typical execution enjoys the common prefix and the chain quality properties, and therefore one can build on the blockchain a robust transaction ledger (Section 4.3). Here we highlight the main steps and the novel concepts that we introduce.

"Good" executions. In order to be able to talk quantitavely about typical executions, we first introduce the notion of  $(\eta, \theta)$ -good executions, which expresses how well the parties approximate f. Suppose at round r exactly n parties query the oracle with target T. The probability at least one of them will succeed is

$$f(T,n) = 1 - \left(1 - \frac{T}{2^{\kappa}}\right)^{qn}.$$

For the initial target  $T_0$  and the initial estimate of the number of parties  $n_0$ , we denote  $f_0 = f(T_0, n_0)$ . Looking ahead, the objective of the target recalculation mechanism is to maintain a target T for each party such that  $f(T, n_r) \approx f_0$  for all rounds r. (For succintness, we will drop the subscript and simply refer to it as f.) Now, at a round r of an execution E the honest parties might be querying the random oracle for various targets. We denote by  $T_r^{\min}(E)$  and  $T_r^{\max}(E)$  the minimum and maximum over those targets. We say r is a target-recalculation point of a valid chain  $\mathcal{C}$ , if there is a block with timestamp r and m exactly divides the number of blocks up to (and including) this block. Consider constants  $\eta \in (0,1]$  and  $\theta \in [1,\infty)$  and an execution E:

**Definition 5 (Abridged).** A round r is  $(\eta, \theta)$ -good in E if  $\eta f \leq f(T_r^{\min}(E), n_r)$  and  $f(T_r^{\max}(E), n_r) \leq \theta f$ . An execution E is  $(\eta, \theta)$ -good if every round of E was  $(\eta, \theta)$ -good.

We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. The following bound will be useful because it gives an estimate of the progress the honest parties have made in an  $(\eta, \theta)$ -good execution. We will be interested in the progress coming from uniquely successful rounds, where exactly one honest party computed a POW. Let  $Q_r$  be the random variable equal to the (maximum) difficulty of such rounds (recall a block with target T has difficulty 1/T); 0 otherwise. We refer to  $Q_r$  also as "unique" difficulty. We are able to show the following.

**Proposition 2 (Informal).** If r is an  $(\eta, \theta)$ -good round in an execution E, then  $\mathbf{E}[Q_r(E_{r-1})] \geq (1-\theta f)pn_r$ , where  $Q_r(E_{r-1})$  is the unique difficulty conditioned on the execution so far, and  $p = \frac{q}{2\kappa}$ .

"Per round" arguments regarding relevant random variables are not sufficient, as we need executions with "good" behavior over a sequence of rounds—i.e., variables should be concentrated around their means. It turns out that this is not easy to get, as the probabilities of the experiments performed per round depend on the history (due to target recalculation). To deal with this lack of concentration/variance problem, we introduce the following measure.

Typical executions. Intuitively, the idea that this notion captures is as follows. Note that at each round of a given execution E the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is "reasonable" we declare E typical. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7 (App. C), says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected. A bit more formally, for a given random oracle query in an execution E, the history of the execution just before the query takes place, determines the parameters of the distribution that the outcome of this query follows as a POW (a Bernoulli trial). For the queries performed in a set of rounds S, let V(S) denote the sum of the variances of these trials.

**Definition 8 (Abridged).** An execution E is  $(\epsilon, \eta, \theta)$ -typical if, for any given set S of consecutive rounds such that V(S) is appropriately bounded from above:

- The average unique difficulty is *lower*-bounded by  $\frac{1}{|S|}(\sum_{r\in S} \mathbf{E}[Q_r(E_{r-1})] \epsilon(1-\theta f)p\sum_{r\in S} n_r);$
- the average maximum difficulty is upper-bounded by  $\frac{1}{|S|}(1+\epsilon)p\sum_{r\in S}n_r;$
- the adversary's average difficulty of blocks with "easy" targets is *upper*-bounded by  $\frac{1}{|S|}(1+\epsilon)p\sum_{r\in S}t_r$ , while the *number* of blocks with "hard" targets is bounded below m by a suitable constant; and
- no "bad events" with respect to the hash function occur (e.g., collisions).

The following is one of the main steps in our analysis.

**Proposition 4 (Informal).** Almost all polynomially bounded executions (in  $\kappa$ ) are typical. The probability of an execution not being typical is bounded by  $\exp(-\Omega(\min\{m,\kappa\}) + \ln L)$  where L is the total run-time.

Recall (Remark 2) that the dynamic setting (specifically, the use of target recalculation functions) offers more opportunities for adversarial attacks [2]. The following important intermediate lemma shows that if a

typical execution is good up to a certain point, chains that are privately mined for long periods of time by the adversary will not be adopted by honest parties.

**Lemma 2 (Informal).** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. If  $E_r$  is  $(\eta, \theta)$ -good, then, no honest party adopts at round r+1 a chain that has not been extended by an honest party for at least  $O(\frac{m}{\tau f})$  consecutive rounds.

An easy corollary of the above is that in typical executions, the honest parties' chains cannot contain blocks with timestamps that differ too much from the blocks' actual creation times.

Corollary 1 (Informal). Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. If  $E_{r-1}$  is  $(\eta, \theta)$ -good, then the timestamp of any block in  $E_r$  is at most  $O(\frac{m}{\tau f})$  away from its actual creation time (cf. the notion of accuracy in Definition 6).

Additional important results we obtain regarding  $(\eta, \theta)$ -good executions are that their epochs last about as much as they should (Lemma 3), as well as a "self-correcting" property, which essentially says that if every chain adopted by an honest party is  $(\eta \gamma, \frac{\theta}{\gamma})$ -good in  $E_{r-1}$  (cf. the notion of a good chain in Definition 5), then  $E_r$  is  $(\eta, \theta)$ -good (Corollary 2). The above (together with several smaller intermediate steps that we omit from this high-level overview) allow us to conclude:

**Theorem 1 (Informal).** A typical execution in a  $(\gamma, s)$ -respecting environment is  $O(\frac{m}{\tau f})$ -accurate and  $(\eta, \theta)$ -good.

Common prefix and chain quality. Typical executions give us the two desired low-level properties of the blockchain:

Theorems 2 and 4 (Informal). Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Under the requirements of Table 1 (Section 6.1), common prefix holds for any  $k \ge \theta \gamma m/8\tau$  and chain quality holds for  $\ell = m/16\tau f$  and  $\mu \le 1 - \delta/2$ , where for all  $r, t_r < n_r(1 - \delta)$ .

Robust transaction ledger. Given the above we then prove the properties of the robust transaction ledger:

Theorems 5 and 6 (Informal) Under the requirements of Table 1, the backbone protocol satisfies persistence with parameter  $k = \Theta(m)$  and liveness with wait time  $u = \Omega(m + k)$  for depth k.

We refer to Section 6 for the full analysis of the protocol.

# <span id="page-10-1"></span>6 Full Analysis

In this section we present the full analysis and proofs of the backbone protocol and robust transaction ledger application with chains of variable difficulty. The analysis follows at a high level the roadmap presented in Section 5.

#### <span id="page-10-0"></span>6.1 Additional notation, definitions, and preliminary propositions

Our probability space is over all executions of length at most some polynomial in  $\kappa$ . Formally, the set of elementary outcomes can be defined as a set of strings that encode every variable of every party during each round of a polynomially bounded execution. We won't delve into such formalism and leave the details unspecified. We will denote by  $\mathbf{Pr}$  the probability measure of this space. Define also the random variable  $\mathcal{E}$  taking values on this space and with distribution induced by the random coins of all entities (adversary, environment, parties) and the random oracle.

Suppose at round r exactly n parties query the oracle with target T. The probability at least one of them will succeed is

 $f(T,n) = 1 - \left(1 - \frac{T}{2^{\kappa}}\right)^{qn}.$

For the initial target T<sup>0</sup> and the initial estimate of the number of parties n0, we denote f<sup>0</sup> = f(T0, n0). Looking ahead, the objective of the target recalculation mechanism would be to maintain a target T for each party such that f(T, nr) ≈ f<sup>0</sup> for all rounds r. For this reason, we will drop the subscript from f<sup>0</sup> and simply refer to it as f; to avoid confusion, whenever we refer to the function f(·, ·), we will specify its two operands.

Note that f(T, n) is concave and increasing in n and T. In particular, Fact [2](#page-29-2) applies. The following proposition provides useful bounds on f(T, n). For convenience, define p = q/2 κ .

<span id="page-11-2"></span>Proposition 1. For positive integers κ, q, T, n and f(T, n) defined as above,

$$\frac{pTn}{1+pTn} \leq f(T,n) \leq pTn \leq \frac{f(T,n)}{1-f(T,n)}, \ \ where \ \ p = \frac{q}{2^{\kappa}}.$$

Proof. The bounds can be obtained using the inequalities (1 − x) <sup>α</sup> ≥ 1 − xα, valid for x ≤ 1 and α ≥ 1, and e <sup>−</sup><sup>x</sup> ≤ 1 1+x , valid for x ≥ 0.

At a round r of an execution E the honest parties might be querying the random oracle for various targets. We denote by T min r (E) and T max r (E) the minimum and maximum over those targets. We say r is a target-recalculation point of a valid chain C, if there is a block with timestamp r and m exactly divides the number of blocks up to (and including) this block.

We now define two desirable properties of executions which will be crucial in the analysis. We will show later that most executions have these properties.

<span id="page-11-0"></span>Definition 5. Consider an execution E and constants η ∈ (0, 1] and θ ∈ [1, ∞). A target-recalculation point r in a chain C in E is (η, θ)-good if the new target T satisfies ηf ≤ f(T, nr) ≤ θf. A chain C in E is (η, θ)-good if all its target-recalculation points are (η, θ)-good. A round r is (η, θ)-good in E if ηf ≤ f(T min r (E), nr) and f(T max r (E), nr) ≤ θf. We say that E is (η, θ)-good if every round of E was (η, θ)-good.

For a round r, the following set of chains is of interest. It contains, besides the chains that the honest parties have, those chains that could potentially belong to an honest party.

$$\mathcal{S}_r = \left\{ \mathcal{C} \in E_r \middle| \begin{array}{l} \text{``$\mathcal{C}$ belongs to an honest party" or} \\ \text{``for some chain $\mathcal{C}'$ of an honest party $diff($\mathcal{C}'$)" or} \\ \text{``for some chain $\mathcal{C}'$ of an honest party $diff($\mathcal{C}'$) = $diff($\mathcal{C}'$)" and} \\ \text{head}($\mathcal{C}$) was computed no later than head}($\mathcal{C}'$)" \end{array} \right\},$$

where C ∈ E<sup>r</sup> means that C exists and is valid at round r.

<span id="page-11-1"></span>Definition 6. Consider an execution E. For ∈ [0, ∞), a block created at round r is -accurate if it has a timestamp r 0 such that |r <sup>0</sup> − r| ≤ m/f. We say that E<sup>r</sup> is -accurate if no chain in S<sup>r</sup> contains a block that is not -accurate. We say that E is -accurate if for every round r in the execution, E<sup>r</sup> is -accurate.

Our next step is to define the typical set of executions. To this end we define a few more quantities and random variables.

In an actual execution E the honest parties may be split across different chains with possibly different targets. We are going to study the progress of the honest parties only when their targets lie in a reasonable range. It will turn out that, with high probability, the honest parties always work with reasonable targets. For a round r, a set of consecutive rounds S, and constant η ∈ (0, 1), let

$$T^{(r,\eta)} = \frac{\eta f}{pn_r} \quad \text{and} \quad T^{(S,\eta)} = \min_{r \in S} T^{(r,\eta)}.$$

To expunge the mystery from the definition of T (r,η) , note that in an (η, θ)-good round all honest parties query for target at least T (r,η) . We now define for each round r a real random variable D<sup>r</sup> equal to the maximum difficulty among all blocks with targets at least  $T^{(r,\eta)}$  computed by honest parties at round r. Define also  $Q_r$  to equal  $D_r$  when exactly one block was computed by an honest party and 0 otherwise.

Regarding the adversary, we are going to be interested in periods of time during which he has gathered a number of blocks in the order of m. Given that the targets of blocks are variable themselves, it is appropriate to consider the difficulty acquired by the adversary not in a set of consecutive rounds, but rather in a set of consecutive adversarial queries that may span a number of rounds and are not necessarily a multiple of q.

For a set of consecutive queries indexed by a set J, we define the following value that will act as a threshold for targets of blocks that are attempted by the adversary.

$$T^{(J)} = \frac{\eta(1-\delta)(1-2\epsilon)(1-\theta f)}{32\tau^3\gamma} \cdot \frac{m}{|J|} \cdot 2^{\kappa}.$$

Given the above threshold, for  $j \in J$ , if the adversary computed at his j-th query a block of difficulty at most  $1/T^{(J)}$ , then let the random variable  $A_j^{(J)}$  be equal to the difficulty of this block; otherwise, let  $A_j^{(J)} = 0$ . The above definition suggests that we collect in  $A_j^{(J)}$  the difficulty acquired by the adversary as long as it corresponds to blocks that are not too difficult (i.e., those with targets less than  $T^{(J)}$ ). With foresight we note that this will enable a concentration argument for random variable  $A_j^{(J)}$ . We will usually drop the superscript (J) from A.

Let  $\mathcal{E}_{r-1}$  contain the information of the execution just before round r. In particular, a value  $E_{r-1}$  of  $\mathcal{E}_{r-1}$  determines the targets against which every party will query the oracle at round r, but it does not determine  $D_r$  or  $Q_r$ . If E is a fixed execution (i.e.,  $\mathcal{E} = E$ ), denote by  $D_r(E)$  and  $Q_r(E)$  the value of  $D_r$  and  $Q_r$  in E. If a set of consecutive queries J is considered, then, for  $j \in J$ ,  $A_j^{(J)}(E)$  is defined analogously. In this case we will also write  $\mathcal{E}_j^{(J)}$  for the execution just before the j-th query of the adversary.

With respect to the random variables defined above, the following bound will be useful because it gives an estimate of the progress the honest parties have made in an  $(\eta, \theta)$ -good execution. Note that we are interested in the progress coming from uniquely successful rounds, where exactly one honest party computed a POW. The expected difficulty that will be computed by the  $n_r$  honest parties at round r is  $pn_r$ . However, the easier the POW computation is, the smaller  $\mathbf{E}[Q_r|\mathcal{E}_{r-1}=E_{r-1}]$  will be with respect to this value. Since the execution is  $(\eta, \theta)$ -good, a POW is computed by the honest parties with probability at most  $\theta f$ . This justifies the appearance of  $(1-\theta f)$  in the bound.

<span id="page-12-0"></span>**Proposition 2.** If round r is  $(\eta, \theta)$ -good in E, then  $\mathbf{E}[Q_r | \mathcal{E}_{r-1} = E_{r-1}] \geq (1 - \theta f) pn_r$ .

*Proof.* Let us drop the subscript r for convenience. Suppose the honest parties query for targets  $T_1, T_2, \ldots, T_n$  respectively. We are going to provide a lower bound pretending that honest parties make all q queries (even after a success) and summing over each query the probability that it is the only successful one. We have

$$\mathbf{E}[Q_r | \mathcal{E}_{r-1} = E_{r-1}] \ge \sum_{i \in [n]} q \cdot \frac{1}{T_i} \cdot \frac{T_i}{2^{\kappa}} \left( 1 - \frac{T_i}{2^{\kappa}} \right)^{q-1} \prod_{i \ne j \in [n]} \left[ 1 - f(T_j, 1) \right] \ge \sum_{i \in [n]} p \prod_{j \in [n]} \left[ 1 - f(T_j, 1) \right]$$

$$\ge \sum_{i \in [n]} p \prod_{j \in [n]} \left[ 1 - f(T^{\max}, 1) \right] = \sum_{i \in [n]} p \left[ 1 - f(T^{\max}, n) \right] \ge \sum_{i \in [n]} p \left[ 1 - \theta f \right) p n,$$

where the third inequality holds because f(T, n) is increasing in T.

The properties we have defined will be shown to hold in a  $(\gamma, s)$ -respecting environment, for suitable  $\gamma$  and s. The following simple fact is a consequence of the definition.

<span id="page-12-1"></span>**Fact 1.** In a  $(\gamma, s)$ -respecting environment, for any set S of consecutive rounds with  $|S| \leq s$ , any  $S' \subseteq S$ , and any  $n \in \{n_r : r \in S\}$ ,

$$\frac{1}{\gamma} \cdot n \leq \frac{1}{|S'|} \cdot \sum_{r \in S'} n_r \leq \gamma \cdot n.$$

 $n_r$ : number of honest parties mining in round r.

 $t_r$ : number of activated parties that are corrupted.

 $\delta$ : advantage of honest parties,  $\forall r(t_r/n_r < 1 - \delta)$

 $(\gamma, s)$ : determines how the number of parties fluctuates across rounds, cf. Definition 1.

f: probability at least one honest party succeeds in a round assuming  $n_0$  parties and target  $T_0$  (the protocol's initialization parameters).

 $\tau$ : the dampening filter, see Definition 2.

 $(\eta,\theta):$  lower and upper bound determining the goodness of an execution, cf. Definition 5.

 $\epsilon$ : quality of concentration of random variables in typical executions, cf. Definition 8.

m: the length of an epoch in number of blocks.

L: the total run-time of the system.

<span id="page-13-1"></span>Table 1: System parameters and requirements on them. The parameters are as follows: positive integers s, m, L; positive reals  $f, \gamma, \delta, \epsilon, \tau, \eta, \theta$ , where  $f, \epsilon, \delta \in (0, 1)$ , and  $0 < \eta \le 1 \le \theta$ .

*Proof.* The average of several numbers is bounded by their min and max. Furthermore, the definition of  $(\gamma, s)$ -respecting implies  $\min_{r \in S} n_r \ge \frac{1}{\gamma} \max_{r \in S} n_r \ge \frac{1}{\gamma} n$  and  $\max_{r \in S} n_r \le \gamma \min_{r \in S} \le \gamma n$ . Thus,

$$\frac{1}{\gamma} \cdot n \le \min_{r \in S} n_r \le \min_{r \in S'} n_r \le \frac{1}{|S'|} \cdot \sum_{r \in S'} n_r \le \max_{r \in S'} n_r \le \max_{r \in S} n_r \le \gamma \cdot n.$$

Our analysis involves a number of parameters that are suitably related. Table 1 summarizes them, recalls their definitions and lists all the constraints that they should satisfy.

<span id="page-13-0"></span>Remark 3. We remark that for the actual parameterization of the parameters  $\tau$ , m, f of  $Bitcoin^5$ , i.e.,  $\tau = 4, m = 2016, f = 0.03$ , vis-à-vis the constraints of Table 1, they can be satisfied for  $\delta = 0.99, \eta = 0.268, \theta = 1.995, \epsilon = 2.93 \cdot 10^{-8}$ , for  $\gamma = 1.281$  and  $s = 2.71 \cdot 10^{5}$ . Given that s measures the number of rounds within which a fluctuation of  $\gamma$  may take place, we have that the constraints are satisfiable for a fluctuation of up to 28% every approximately 2 months (considering a round to last 18 seconds).

#### 6.2 Chain-Growth Lemma

We now prove the Chain-growth lemma. This lemma appears already in [11], but it refers to number of blocks instead of difficulty. In [15] the name "chain growth" appears for the first time and the authors explicitly state a chain-growth property.

<span id="page-13-2"></span><sup>&</sup>lt;sup>5</sup>Note that in order to calculate f, we can consider that a round of full interaction lasts 18 seconds; if this is combined with the fact that the target is set for a POW to be discovered approximately every 10 minutes, we have that 18/600 = 0.3 is a good estimate for f.

Informally, this lemma says that honest parties will make as much progress as how many POWs they obtain. Although simple to prove, the chain-growth lemma is very important, because it shows that no matter what the adversary does the honest parties will advance (in terms of accumulated difficulty) by at least the difficulty of the POWs they have acquired.

<span id="page-14-1"></span>**Lemma 1.** Let E be any execution. Suppose that at round u an honest party has a chain of difficulty d. Then, by round  $v \ge u$ , every honest party will have received a chain of difficulty at least

$$d + \sum_{u \le r < v} D_r(E).$$

*Proof.* By induction on v-u. For the basis, v=u and  $d+\sum_{r=u}^{v-1}D_r(E)=d$ . Observe that if at round u an honest party has a chain  $\mathcal{C}$  of difficulty d, then that party broadcast  $\mathcal{C}$  at a round earlier than u. It follows that every honest party will receive  $\mathcal{C}$  by round u.

For the inductive step, note that by the inductive hypothesis every honest party has received a chain of difficulty at least  $d' = d + \sum_{r=u}^{v-1} D_r$  by round v. When  $D_v = 0$  the statement follows directly, so assume  $D_v > 0$ . Since every honest party queried the oracle with a chain of difficulty at least d' at round v, if follows that an honest party successful at round v broadcast a chain of difficulty at least  $d' + D_v = d + \sum_{r=u}^{v} D_r$ .  $\square$

### 6.3 Typical Executions: Definition and Related Proofs

We can now define formally our notion of typical executions. Intuitively, the idea that this definition captures is as follows. Suppose that we examine a certain execution E. Note that at each round of E the parties perform Bernoulli trials with success probabilities possibly affected by the adversary. Given the execution, these trials are determined and we may calculate the expected progress the parties make given the corresponding probabilities. We then compare this value to the actual progress and if the difference is reasonable we declare E typical. Note, however, that considering this difference by itself will not always suffice, because the variance of the process might be too high. Our definition, in view of Theorem 7, says that either the variance is high with respect to the set of rounds we are considering, or the parties have made progress during these rounds as expected.

Beyond the behavior of random variables described above, a typical execution will also be characterized by the absence of a number of bad events about the underlying hash function  $H(\cdot)$  which is used in proofs of work and is modeled as a random oracle. The bad events that are of concern to us are defined as follows (recall that a block's creation time is the round that it has been successfully produced by a query to the random oracle either by the adversary or an honest party).

**Definition 7.** An insertion occurs when, given a chain C with two consecutive blocks B and B', a block  $B^*$  created after B' is such that  $B, B^*, B'$  form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions. A prediction occurs when a block extends one with later creation time.

Given the above we are now ready to specify what is a typical execution.

<span id="page-14-0"></span>**Definition 8** (Typical execution). An execution E is  $(\epsilon, \eta, \theta)$ -typical if the following hold:

(a) If, for any set S of consecutive rounds,  $pT^{(S,\eta)}\sum_{r\in S}n_r\geq \frac{\eta m}{16\tau\gamma}$ , then

$$\sum_{r \in S} Q_r(E) > \sum_{r \in S} \mathbf{E}[Q_r | \mathcal{E}_{r-1} = E_{r-1}] - \epsilon (1 - \theta f) p \sum_{r \in S} n_r$$
and
$$\sum_{r \in S} D_r(E) < (1 + \epsilon) p \sum_{r \in S} n_r.$$

(b) For any set I indexing a set of consecutive queries of the adversary we have

$$\sum_{j \in J} A_j(E) < (1 + \epsilon)2^{-\kappa} |J|$$

and the blocks with targets less than  $\tau T^{(J)}$  that the adversary acquired are less than  $\frac{\eta(1-\epsilon)(1-\theta f)}{32\tau^2\gamma}\cdot m$ .

(c) No insertions, no copies, and no predictions occurred in E.

**Remark 4.** Note that if J indexes the queries of the adversary in a set S of consecutive rounds, then  $|J| = q \sum_{r \in S} t_r$  and the inequality in Definition 8(b) reads  $\sum_{j \in J} A_j(E) < (1+\epsilon)p \sum_{r \in S} t_r$ .

The next proposition simplifies our applications of Definition 8(a).

<span id="page-15-1"></span>**Proposition 3.** Assume E is a typical execution in a  $(\gamma, s)$ -respecting environment. For any set S of consecutive rounds with  $|S| \ge \frac{m}{16\tau f}$ ,

$$\sum_{r \in S} D_r < (1 + \epsilon) p \sum_{r \in S} n_r.$$

If in addition, E is  $(\eta, \theta)$ -good, then

$$\sum_{r \in S} Q_r > (1 - \epsilon)(1 - \theta f)p \sum_{r \in S} n_r$$

and any block computed by an honest party at any round r corresponds to target at least  $T^{(r,\eta)}$ , and so contributes to the random variables  $D_r$  and  $Q_r$  (if the r was uniquely successful).

*Proof.* We first partition S into several parts with size at least  $\frac{m}{16\tau f}$  and at most s. In view of Proposition 2, for both of the inequalities, we only need to verify the 'if' part of Definition 8(a) for each part S' of S. Indeed, by the definition of  $T^{(S',\eta)}$  and Fact 1,  $pT^{(S',\eta)}\sum_{r\in S'}n_r\geq \eta f|S'|/\gamma\geq \frac{\eta m}{16\tau\gamma}$ . The last part, in view of the definition of  $T^{(r,\eta)}$ , is equivalent to r being  $(\eta,\theta)$ -good.

Almost all polynomially bounded executions (in  $\kappa$ ) are typical:

<span id="page-15-0"></span>**Proposition 4.** Assuming the ITM system  $(\mathcal{Z},C)$  runs for L steps, the event " $\mathcal{E}$  is not typical" is bounded by  $\exp(-\Omega(\min\{m,\kappa\}) + \ln L)$ . Specifically, the bound is  $\exp\{-\frac{\eta\epsilon^2(1-2\delta)}{64\tau^3\gamma}m - \ln(2)(\kappa-1) + 4\ln L + 2\ln 2\}$ .

*Proof.* Since the length of the execution, L, is fixed we will prove the stated bound for a fixed set of consecutive rounds S and then apply a union bound over all such sets in the length of the execution. Let k be the size of S and identify it, without loss of generality, with  $[k] = \{1, 2, ..., k\}$ . For part (a), define a sequence of random variables by

$$X_0 = 0; \ X_r = \sum_{i \in [r]} Q_i - \sum_{i \in [r]} \mathbf{E}[Q_i | \mathcal{E}_{i-1}], \ r \in [k].$$

This forms a martingale with respect to the sequence  $\mathcal{E}_0, \mathcal{E}_1, \dots, \mathcal{E}_k$ , because (recalling basic properties of conditional expectation [17]),

$$\mathbf{E}[X_r|\mathcal{E}_{r-1}] = \mathbf{E}[Q_r - \mathbf{E}[Q_r|\mathcal{E}_{r-1}]|\mathcal{E}_{r-1}] + \mathbf{E}[X_{r-1}|\mathcal{E}_{r-1}] = X_{r-1}.$$

Specifically, the above follows from linearity of conditional expectation, and the fact that  $X_{r-1}$  is a deterministic function of  $\mathcal{E}_{r-1}$ .

Now suppose the first inequality of Definition 8(a) fails. The probability of this event is equal to

$$\mathbf{Pr}[X_k \le X_0 - t], \text{ for } t = \epsilon (1 - \theta f) p \sum_{r \in S} n_r.$$

For b and V defined with respect to Theorem 7, we have  $b \leq 1/T^{(S,\eta)}$  and  $V \leq v$ , where  $v = p \sum_{r \in S} n_r/T^{(S,\eta)}$ . To prove the bound on V, note that

$$\operatorname{var}(X_r - X_{r-1}|\mathcal{E}_{r-1}) = \mathbf{E}\left[\left(Q_r - \mathbf{E}[Q_r|\mathcal{E}_{r-1}]\right)^2 \middle| \mathcal{E}_{r-1}\right] = \mathbf{E}[Q_r^2|\mathcal{E}_{r-1}] - \left(\mathbf{E}[Q_r|\mathcal{E}_{r-1}]\right)^2.$$

Thus, it suffices to show  $\mathbf{E}[Q_r^2|\mathcal{E}_{r-1}] \leq pn_r/T^{(r,\eta)} \leq pn_r/T^{(S,\eta)}$ . To this end, suppose that the honest parties at round r were split into  $\ell$  chains with corresponding targets  $T^{(r,\eta)} \leq T_1 \leq T_2 \leq \cdots \leq T_\ell$ . Let also  $\hat{n}_1, \hat{n}_2, \ldots, \hat{n}_\ell$ , with  $\hat{n}_1 + \cdots + \hat{n}_\ell \leq n_r$ , be the corresponding number of parties with each chain. Then, for any  $E_{r-1}$ ,

$$\mathbf{E}[Q_r^2 | \mathcal{E}_{r-1} = E_{r-1})] \le \sum_{i \in [\ell]} \frac{1}{T_i^2} \cdot f(T_i, \hat{n}_i) \cdot \prod_{j \ne i} \left[ 1 - f(T_j, \hat{n}_j) \right] \le \sum_{i \in [\ell]} \frac{p \hat{n}_i}{T_i} \le \frac{p n_r}{T^{(r, \eta)}}.$$

We apply Theorem 7 on  $-X_0, -X_1, \ldots$ , noting that  $V \leq v$  always holds. Recalling Requirement (R2) and that  $pT^{(S,\eta)} \sum_{r \in S} n_r \geq \frac{\eta m}{16\tau\gamma}$ , we obtain

$$\mathbf{Pr}[X_k \le X_0 - t] \le \exp\left\{-\frac{3\epsilon^2 (1 - \theta f)^2 \eta m}{32(3 + \epsilon)\tau\gamma}\right\} \le \exp\left\{-\frac{\epsilon^2 (1 - \delta) \eta m}{32\tau\gamma}\right\}.$$

For the bounds on  $\sum_{r \in S} D_r(E)$  and  $\sum_{j \in J} A_j(E)$  the proof follows the same lines. In particular, replace Q by D and A (in the case of A the martingale will be indexed by J) and note that in these cases the martingale need not be negated.

In more details, regarding the bound on D in part (a), using the same notation as above, we have that

$$\mathbf{E}[D_r | \mathcal{E}_{r-1} = E_{r-1})] = \sum_{i \in [\ell]} \frac{1}{T_i} \cdot f(T_i, \hat{n}_i) \cdot \prod_{j=1}^{i-1} [1 - f(T_j, \hat{n}_j)] \le \sum_{i \in [\ell]} p \hat{n}_i \le p n_r$$

and so

$$\sum_{r \in S} \mathbf{E}[D_r | \mathcal{E}_{r-1}] \le p \sum_{r \in S} n_r.$$

A similar argument provides the bound  $\mathbf{E}[D_r^2|\mathcal{E}_{r-1}=E_{r-1})] \leq pn_r/T^{(r,\eta)}$  from which we can obtain the bound  $V \leq v = p \sum_{r \in S} n_r/T^{(S,\eta)}$ .

We next focus on part (b). Note first that if  $|J| \leq \frac{\eta(1-\delta)(1-2\epsilon)(1-\theta f)}{32\tau^3\gamma} \cdot m$ , then  $T^{(J)} \geq 2^{\kappa}$  and the inequalities hold trivially. First we will show that for the martingale  $X_0, X_1, X_2, \ldots$  with respect to  $\mathcal{E}_0^{(J)}, \mathcal{E}_1^{(J)}, \mathcal{E}_2^{(J)}, \ldots$  that is defined as

$$X_0 = 0; \ X_j = \sum_{i \in [j]} A_i - \sum_{i \in [j]} \mathbf{E}[A_i | \mathcal{E}_{i-1}^{(J)}], \ j \in J,$$

it holds that  $b \leq 1/T^{(J)}$  and  $V \leq v$  for  $v = 2^{-\kappa}|J|/T^{(J)}$ , for the quantities b and V defined as in Theorem 7. Consider an execution prefix  $E_{j-1}^{(J)}$  and the target that is selected by the adversary in its j-th query. Note that we can associate such value to any query of the form (ctr,g) where g = G(r,st,x) by recovering the chain that corresponds to st. If such value is below  $T^{(J)}$ , or is not defined,  $A_j = 0$ . Thus, we have  $\mathbf{E}[A_j|\mathcal{E}_{j-1}^{(J)} = E_{j-1}^{(J)}] \leq 2^{-\kappa}$  and  $\mathbf{E}[A_j^2|\mathcal{E}_{j-1}^{(J)} = E_{j-1}^{(J)}] \leq 2^{-\kappa}/T^{(J)}$ , obtaining

$$\sum_{j\in J} \mathbf{E}[A_j|\mathcal{E}_{j-1}^{(J)}] \le 2^{-\kappa}|J| \quad \text{and} \quad V \le v.$$

We now have the following by setting  $t = \epsilon 2^{-\kappa} |J|$ .

$$\mathbf{Pr}\Big[\sum_{j\in J} A_j \ge (1+\epsilon)2^{-\kappa}|J|\Big] = \mathbf{Pr}\Big[\sum_{j\in J} A_j \ge t + 2^{-\kappa}|J|\Big] \le \mathbf{Pr}\Big[\sum_{j\in J} A_j \ge t + \sum_{j\in J} \mathbf{E}[A_j|\mathcal{E}_{j-1}^{(J)}]\Big]$$

$$= \mathbf{Pr}\Big[\sum_{j\in J} (A_j - \mathbf{E}[A_j|\mathcal{E}_{j-1}^{(J)}]) \ge t\Big] \le \exp\Big\{-\frac{t^2}{2v + 2bt/3}\Big\} \le \exp\Big\{-\frac{3\epsilon^2 2^{-\kappa}|J|T^{(J)}}{(6+2\epsilon)}\Big\}$$

$$\le \exp\Big\{-\frac{3\eta\epsilon^2 (1-\delta)(1-\theta f)(1-2\epsilon)m}{64(3+\epsilon)\tau^3\gamma}\Big\} \le \exp\Big\{-\frac{\eta\epsilon^2 (1-2\delta)m}{64\tau^3\gamma}\Big\}.$$

To verify the inequalities in the last line, recall  $T^{(J)} = \frac{\eta(1-\delta)(1-2\epsilon)(1-\theta f)}{32\tau^3\gamma} \cdot \frac{m}{|J|} \cdot 2^{\kappa}$  and Requirement (R2).

Regarding the second part of (b), in order to bound the number of blocks of target less than  $\tau T^{(J)}$  the adversary can acquire, define a Boolean random variable  $Z_j$ , for each  $j \in J$  as follows. If the corresponding target is less than  $\tau T^{(J)}$  and the query was successful, then  $Z_j = 1$ , otherwise  $Z_j = 0$ . We can then define a martingale as in part (a), by letting k = |J| and replacing Q with Z. We have  $b \leq 1$  and  $V \leq 2^{-\kappa} \tau T^{(J)}$ . Since

$$\sum_{j \in [|J|]} \mathbf{E}[Z_j | \mathcal{E}_{j-1}^{(J)}] \le 2^{-\kappa} \tau T^{(J)} |J| = \frac{\eta (1 - 2\epsilon) (1 - \theta f)}{32\tau^2 \gamma} \cdot m$$

and  $(1+\epsilon)(1-2\epsilon) < (1-\epsilon)$ , for  $t = \epsilon \cdot \frac{\eta(1-2\epsilon)(1-\theta f)}{32\tau^2\gamma} \cdot m$  we have (using Requirement (R2) to simplify in the last step)

$$\mathbf{Pr}\bigg[\sum_{j\in[|J|]} Z_j \geq \frac{\eta(1-\epsilon)(1-\theta f)}{32\tau^2\gamma} \cdot m\bigg] \leq \mathbf{Pr}[X_k \geq X_0 + t] \leq \exp\Big\{-\frac{\eta\epsilon^2(1-\delta/2)m}{32\tau^2\gamma}\Big\}.$$

For part (c) and  $i \in \{0, 1, 2, 3\}$ , let  $B_i = \langle r_i, st_i, x_i, ctr_i \rangle$  and  $g_i = G(r_i, st_i, x_i)$ . If a block extends two distinct blocks, then a collision has occurred. To see this, suppose block  $B_3$  extents two distinct blocks  $B_1$  and  $B_2$ . Then  $st_3 = H(ctr_1, g_1) = H(ctr_2, g_2)$ ; implying a collision either in H or in G, since  $B_1$  and  $B_2$  are distinct.

The existence of an insertion or a copy implies a collision as well. Suppose the adversary inserts a block  $B_2$  among two existing blocks  $B_1$  and  $B_3$ . Then,  $B_3$  extends both  $B_1$  and  $B_2$  and since  $B_2$  extends  $B_1$ ,  $r_1 < r_2$  and the blocks are distinct. Similarly, if  $B_3$  is a copy of  $B_1$  (i.e.,  $B_3 = B_1$ ), then there exist two distinct blocks  $B_2$  and  $B_0$  that are both extended by the same block. To see this, note that either  $B_0$  and  $B_2$  are the ones that  $B_1$  and  $B_3$  extend, or if these are not distinct, then  $B_2$  is a copy of  $B_0$  and so on. Eventually, two distinct blocks will be reached, since  $B_1$  and  $B_3$  are assumed to be on different chains. If the total running time of the system of ITM's is L then it holds that there are at most L queries posed to G, H. It follows that the probability of a collision occurring is  $\binom{L}{2} 2^{-\kappa+1} \leq 2^{-\kappa+1+2\log L}$ .

Finally, note that, for polynomially many rounds in  $\kappa$ , the probability that a guessed block occurs is exponentially small in  $\kappa$ .

#### 6.4 Typical Executions are Good and Accurate

<span id="page-17-0"></span>**Lemma 2.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. If  $E_r$  is  $(\eta, \theta)$ -good, then  $S_{r+1}$  contains no chain that has not been extended by an honest party for at least  $\frac{m}{16\tau f}$  consecutive rounds.

*Proof.* Suppose—towards a contradiction— $C \in S_{r+1}$  and has not been extended by an honest party for at least  $\frac{m}{16\tau f}$  rounds. Without loss of generality we may assume that r+1 is the first such round.

Let  $r^* \leq r$  denote the greatest timestamp among the blocks of  $\mathcal{C}$  computed by honest parties (let  $r^* = 0$  if none exists). Define  $S = \{r^* + 1, \ldots, r\}$  and note that, by our assumption for  $\mathcal{C}$ ,  $|S| \geq \frac{m}{16\tau f}$ . Let  $J = \{1, \ldots, q \sum_{r \in S} t_r\}$  be the index-set of the adversarial queries during the rounds in S. Suppose that the blocks of  $\mathcal{C}$  with timestamps in S span k epochs with corresponding targets  $T_1, \ldots, T_k$ . For  $i \in [k]$  let  $m_i$  be the number of blocks with target  $T_i$  and set  $M = m_1 + \cdots + m_k$ .

Our plan is to contradict the assumption that  $C \in S_{r+1}$ , by showing that the honest parties have accumulated more difficulty than the adversary. To be precise, note that the blocks C has gained in S sum to  $\sum_{i \in [k]} \frac{m_i}{T_i}$  difficulty. On the other hand, by the Chain-Growth Lemma 1, all the honest parties have advanced during the rounds in S by  $\sum_{r \in S} D_r(E) \ge \sum_{r \in S} Q_r(E)$ . Since  $|S| \ge \frac{m}{16\tau f}$ , Proposition 3 implies that  $\sum_{r \in S} Q_r(E)$  is greater than  $(1 - \epsilon)(1 - \theta f)p\sum_{r \in S} n_r$ . Therefore, to obtain a contradiction, it suffices to show that

<span id="page-18-2"></span>
$$\sum_{i \in [k]} \frac{m_i}{T_i} \le (1 - \epsilon)(1 - \theta f)p \sum_{r \in S} n_r. \tag{1}$$

We proceed by considering cases on M.

First, suppose  $M \geq 2M'$ , where  $M' = \frac{\eta(1-\epsilon)(1-\theta f)}{32\tau^2\gamma} \cdot m$  (see Definition 8(b)). Partition the part of  $\mathcal{C}$  with these M blocks into  $\ell$  parts, so that each part has the following properties: (1) it contains at most one target-calculation point, and (2) it contains at least M' blocks with the same target. Note that such a partition exists because  $M \geq 2M'$  and M' < m. For  $i \in [\ell]$ , let  $j_i \in J$  be the index of the query during which the last block of the i-th part was computed. Set  $J_i = \{j_{i-1} + 1, \ldots, j_i\}$ , with  $j_0 = 0$ . Note that Definition 8(c) implies  $j_{i-1} < j_i$ , and this is a partition of J. Recalling Definition 8(b), the sum of the difficulties of all the blocks in the i-th part is at most  $\sum_{j \in J_i} A_j(E)$ . This holds because for one of the targets more than M' blocks have been computed in  $J_i$  and so is at least  $\tau T^{(J_i)}$  and targets with at most one calculation point between them can differ by a factor at most  $\tau$ . Thus,

$$\sum_{i \in [k]} \frac{m_i}{T_i} \le \sum_{\substack{i \in [\ell] \\ j \in J_i}} A_j(E) < \sum_{i \in [\ell]} (1+\epsilon) 2^{-\kappa} |J_i| = (1+\epsilon) p \sum_{r \in S} t_r \le (1+\epsilon) (1-\delta) p \sum_{r \in S} n_r,$$

where in the last step we used Requirement (R0). Requirement (R1) implies  $(1+\epsilon)(1-\delta) \le (1-\epsilon)(1-\theta f)$ ; thus, Equation (1) holds concluding the case  $M \ge 2M'$ .

Otherwise,  $k \leq 2$  and  $m_1 + m_2 < 2M'$ . Let S' consist of the first  $\frac{m}{16\tau f}$  rounds of S. We are going to argue that in this case Equation (1) holds even for S' in the place of S. Since we are in a  $(\gamma, s)$ -respecting environment, by Fact 1,  $\gamma \sum_{r \in S'} n_r \geq n_{r^*} |S'|$ . Furthermore, since  $r^*$  is  $(\eta, \theta)$ -good,  $T_1 \geq T^{(r^*, \eta)} = \eta f/pn_{r^*}$ . Recalling also that  $T_2 \geq T_1/\tau$ , we have  $\frac{m_1}{T_1} + \frac{m_2}{T_2} \leq \frac{m_1 + \tau m_2}{T_1}$ , which in turn is at most

$$\frac{\tau M}{T^{(r^*,\eta)}} < \frac{2\tau M'pn_{r^*}}{\eta f} \leq \frac{2\tau \gamma M'p\sum_{r\in S'}n_r}{\eta f|S'|} \leq \frac{32\tau^2\gamma M'p\sum_{r\in S}n_r}{\eta m}$$

and, after substituting M', Equation (1) holds concluding this case and the proof.

<span id="page-18-0"></span>Corollary 1. Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. If  $E_{r-1}$  is  $(\eta, \theta)$ -good, then  $E_r$  is  $\frac{m}{16\tau f}$ -accurate.

Proof. Suppose—towards a contradiction—that, for some  $r^* \leq r$ ,  $C \in \mathcal{S}_{r^*}$  contains a block which is not  $\frac{m}{16\tau f}$ -accurate and let  $u \leq r^* \leq r$  be the timestamp of this block and v its creation time. If  $u - v > \frac{m}{16\tau f}$ , then every honest party would consider C to be invalid during rounds  $v, v + 1, \ldots, u$ . If  $v - u > \frac{m}{16\tau f}$ , then in order for C to be valid it should not contain any honest block with timestamp in  $u, u + 1, \ldots, v$ . (Note that we are using Definition 8(c) here as a block could be inserted later.) In either case,  $C \in \mathcal{S}_{r^*}$ , but has not been extended by an honest party for at least  $\frac{m}{16\tau f}$  rounds. Since  $E_{r^*-1}$  is  $(\eta, \theta)$ -good, the statement follows from Lemma 2.

<span id="page-18-1"></span>**Lemma 3.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment and  $r^*$  an  $(\eta \gamma, \frac{\theta}{\gamma})$ -good target-recalculation point of a valid chain C. For  $r > r^* + \frac{\tau m}{f}$ , assume  $E_{r-1}$  is  $(\eta, \theta)$ -good. Then, either the duration  $\Delta$  of the epoch of C starting at  $r^*$  satisfies

$$\frac{m}{\tau f} \leq \Delta \leq \frac{\tau m}{f},$$

or  $C \notin S_u$  for each  $u \in \{r^* + \frac{\tau m}{f}, \dots, r\}$ .

*Proof.* Let T be the target of the epoch in question.

For the upper bound, assume  $\Delta > \frac{\tau m}{f}$ . We show first that in the rounds  $S = \{r^* + \frac{m}{16\tau f}, \dots, r^* + \frac{\tau m}{f} - \frac{m}{16\tau f}\}$  the honest parties have acquired more than  $\frac{m}{T}$  difficulty. Note that the rounds of S are  $(\eta, \theta)$ -good as they come before r. Thus, by Proposition 3, the difficulty acquired in S by the honest parties is at least

$$(1 - \epsilon)(1 - \theta f)p \sum_{r \in S} n_r \ge (1 - \epsilon)(1 - \theta f)p \cdot \frac{|S|n_{r^*}}{\gamma} \ge (1 - \epsilon)(1 - \theta f)|S| \frac{\eta f}{T} > \frac{m}{T}.$$

For the first inequality, we used Fact 1. For the second, recall that  $r^*$  is  $(\eta \gamma, \theta/\gamma)$ -good and so  $pTn_{r^*} \ge f(T, n_{r^*}) \ge \eta \gamma f$ . For the last inequality observe that  $|S| = \frac{m}{f}(\tau - 1/8\tau)$  and thus follows from Requirement (R3).

Next, we observe that chain  $\mathcal{C}$  either has a block within the epoch in question that is computed by an honest party in a round within the period  $[r^*, r^* + \frac{m}{16\tau f})$ , or by Lemma 2,  $\mathcal{C} \notin \mathcal{S}_u$  for each  $u \in \{r^* + \frac{m}{16\tau f}, \ldots, r\} \supseteq \{r^* + \frac{\tau m}{f}, \ldots, r\}$ . Assuming the first happens, it follows that by round  $r^* + \frac{\tau m}{f} - \frac{m}{16\tau f}$  the honest parties' chains have advanced by an amount of difficulty which exceeds the total difficulty of the epoch in question. This means that no honest party will extend  $\mathcal{C}$  during the rounds  $\{r^* + \frac{\tau m}{f} - \frac{m}{16\tau f} + 1, \ldots, \Delta\}$ . Since it is assumed  $\Delta > r^* + \frac{\tau m}{f}$ , Lemma 2 can then be applied to imply that  $\mathcal{C} \notin \mathcal{S}_u$  for  $u \in \{r^* + \frac{\tau m}{f}, \ldots, r\}$ .

For the lower bound, we assume  $\Delta < \frac{m}{\tau f}$  and that  $\mathcal{C} \in \mathcal{S}_u$  for some  $u \in \{r^* + \Delta + 1, \dots, r\}$ , and seek a contradiction. Clearly, the honest parties contributed only during the set of rounds  $S = \{r^*, \dots, r^* + \Delta\}$ . The adversary, by Lemma 2, may have contributed only during  $S' = \{r^* - \frac{m}{16\tau f}, \dots, r^* + \Delta + \frac{m}{16\tau f}\}$ . Let J be the set of queries available to the adversary during the rounds in S'. We show that in a typical execution the honest parties together with the adversary cannot acquire difficulty  $\frac{m}{T}$  in the rounds in the sets S and S' respectively. With respect to the honest parties, Proposition 3 applies. Regarding the adversary, assume first  $T \geq T^{(J)}$  (it is not hard to verify that the case  $T < T^{(J)}$  leads to a more favorable bound). It follows that the total difficulty contributed to the epoch is at most

$$(1+\epsilon)p\left(\sum_{r\in S}n_r + \sum_{r\in S'}t_r\right) \le (1+\epsilon)p\gamma n_{r^*}(|S|+|S'|) < (1+\epsilon)p\gamma n_{r^*} \cdot \frac{17m}{8\tau f}.$$

The first inequality follows from Fact 1 using  $t_r < (1 - \delta)n_r$ . For the second substitute the upper bounds on the sizes of S and S'. Next, note that  $r^*$  is an  $(\eta\gamma,\theta/\gamma)$ -good recalculation point and so  $f(T,n_{r^*}) \leq \theta f/\gamma$ . By Proposition 1,  $pTn_{r^*} < f(T,n_{r^*})/(1-f(T,n_{r^*})) \leq (\theta f/\gamma)/(1-\theta f/\gamma)$ . It follows that the last displayed quantity is at most  $\frac{17(1+\epsilon)\theta}{8\tau(\gamma-\theta f)} \cdot \frac{m}{T}$  and recalling Requirement (R4) this less than  $\frac{m}{T}$  as desired.

<span id="page-19-0"></span>**Proposition 5.** Assume E is a typical execution in a  $(\gamma, s)$ -respecting environment. Let r be a round such that  $E_{r-1}$  is  $(\eta, \theta)$ -good, S a set of consecutive rounds in  $E_r$  with  $|S| \ge \frac{m}{32\tau^2 f}$ , and S the set of adversarial queries during the rounds in S. Then, the adversary during the rounds in S has contributed at most  $\sum_{j \in J} A_j$  difficulty to  $\bigcup_{v \le r} S_r$ .

*Proof.* Without loss of generality, we will assume in this proof that  $t_r = (1 - \delta)n_r$  for each  $r \in S$ . Furthermore, we assume  $|S| \leq \frac{\tau m}{f}$ . If this is not the case, then we can partition S to parts of appropriate sizes and apply the arguments that follow to each sum. The statement will follow upon summing over all parts.

By Lemma 2, for any block B in  $S_v$  for some  $v \leq r$ , there is a block B' in the same chain and computed at most  $\frac{m}{16\tau f}$  rounds earlier than it by an honest party. Let u be the round the honest party computed B and T its target. Note that since E is  $(\eta, \theta)$ -good,  $T \geq T^{(u,\eta)} = \frac{\eta f}{pn_u}$ . By Lemma 3, there is at most one recalculation point between B and B', and so the target of B is at least  $T/\tau$ . We need to show that  $T/\tau \geq T^{(J)}$ . This implies all difficulty contributed by the adversary is accounted for in  $\sum_{j\in J} A_j$  and by Definition 8 we are done.

Using Fact 1 and the lower-bound on |S|.

$$2^{-\kappa}|J| = (1-\delta)p \sum_{r \in S} n_r \ge (1-\delta)p \cdot \frac{|S|n_u}{\gamma} \ge (1-\delta)p \cdot \frac{mn_u}{32\tau^3 f\gamma}.$$

Recalling the definition of  $T^{(J)}$  and using this bound,

$$T^{(J)} = \frac{\eta(1-\delta)(1-2\epsilon)(1-\theta f)}{32\tau^3\gamma} \cdot \frac{m}{|J|} \cdot 2^{\kappa} \le \frac{\eta f(1-2\epsilon)(1-\theta f)}{\tau p n_u} < \frac{T^{(u,\eta)}}{\tau} \le \frac{T}{\tau},$$

as desired.

<span id="page-20-0"></span>**Lemma 4.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment and assume  $E_{r-1}$  is  $(\eta, \theta)$ -good. If  $C \in S_r$ , then C is  $(\eta \gamma, \theta/\gamma)$ -good in  $E_r$ .

*Proof.* Note that it is our assumption that every chain is  $(\eta \gamma, \theta/\gamma)$ -good at the first round. Therefore, to prove the statement, it suffices to show that if a chain is  $(\eta \gamma, \theta/\gamma)$ -good at a recalculation point  $r^*$ , then it will also be  $(\eta \gamma, \theta/\gamma)$ -good at then next recalculation point  $r^* + \Delta$ .

Let  $r^*$  and  $r^* + \Delta \leq r$  be two consecutive target-calculation points of a chain  $\mathcal{C}$  and T the target of the corresponding epoch. By Lemma 3 and Definition 2 of the target-recalculation function, the new target will be

$$T' = \frac{\Delta}{m/f} \cdot T,$$

where  $\Delta$  is the duration of the epoch.

We wish to show that

$$\eta \gamma f \le f(T', n_{r^* + \Delta}) \le \theta f / \gamma.$$

To this end, let  $S = \{r^*, \dots, r^* + \Delta\}$ ,  $S' = \{\max\{0, r^* - \frac{m}{16\tau f}\}, \dots, \min\{r^* + \Delta + \frac{m}{16\tau f}, r\}\}$ , and let J index the queries available to the adversary in S'. Note that, by Corollary 1, every block in the epoch was computed either by an honest party during a round in S or by the adversary during a round in S'.

Suppose—towards a contradiction—that  $f(T', n_{r^*+\Delta}) < \eta \gamma f$ . Using the definition of f(T, n), this implies  $qn_{r^*+\Delta} \ln(1 - \frac{T'}{2^{\kappa}}) > \ln(1 - \eta \gamma f)$ . Applying the inequality  $-\frac{x}{1-x} < \ln(1-x) < -x$ , valid for  $x \in (0, 1)$ , substituting the expression for T' above and rearranging, we obtain

$$\frac{m}{T} > \frac{1 - \eta \gamma f}{\eta \gamma} \cdot p \Delta n_{r^* + \Delta}.$$

By Propositions 3 and 5 it follows that

$$\frac{m}{T} \le 2(1+\epsilon)p \sum_{r \in S'} n_r \le 2(1+\epsilon)p \cdot \frac{\Delta + \frac{m}{8\tau f}}{|S'|} \cdot \sum_{r \in S'} n_r.$$

By Lemma 3,  $\Delta \geq \frac{m}{\tau f}$ . Thus,  $\frac{\Delta + \frac{m}{8\tau f}}{\Delta} \leq \frac{9}{8}$ . Using this, Requirement (R5), and combining the inequalities on  $\frac{m}{T}$ ,

$$\gamma n_{r^* + \Delta} < \frac{9(1+\epsilon)\eta\gamma^2}{4(1-\eta\gamma f)} \cdot \frac{1}{|S'|} \sum_{r \in S'} n_r \le \frac{1}{|S'|} \sum_{r \in S'} n_r,$$

contradicting Fact 1.

For the upper bound, assume  $f(T', n_{r^*+\Delta}) > \theta f/\gamma$ , which (see Proposition 1) implies

$$\frac{m}{T} < \frac{\gamma}{\theta} \cdot p\Delta n_{r^* + \Delta}.$$

Set  $S = \{r^* + \frac{m}{16\tau f}, \dots, r^* + \Delta - \frac{m}{16\tau f}\}$ . Since an honest party posses  $\mathcal C$  at round r, it follows by Lemma 2 that there is a block computed by an honest party in  $\mathcal C$  during  $\{r^*, \dots, r^* + \frac{m}{16\tau f} - 1\}$  and one during  $\{r^* + \Delta - \frac{m}{16\tau f} + 1, \dots, r^* + \Delta\}$ . By the Chain-Growth Lemma 1, it follows that the honest parties computed less than  $\frac{m}{T}$  difficulty during S. In particular,

$$\frac{m}{T} > (1 - \epsilon)(1 - \theta f)p \sum_{r \in S} n_r \ge (1 - \epsilon)(1 - \theta f)p \cdot \frac{\Delta - \frac{m}{8\tau f}}{|S|} \cdot \sum_{r \in S} n_r.$$

By Lemma 3,  $\Delta \geq \frac{m}{\tau f}$ . Thus,  $\frac{\Delta - \frac{m}{8\tau f}}{\Delta} \geq \frac{7}{8}$ . Using this, Requirement (R6), and combining the inequalities on  $\frac{m}{T}$ ,

$$\frac{n_{r^*+\Delta}}{\gamma} > \frac{7\theta}{8\gamma^2} (1 - \epsilon)(1 - \theta f) \cdot \frac{1}{|S|} \sum_{r \in S} n_r \ge \frac{1}{|S|} \sum_{r \in S} n_r,$$

contradicting Fact 1.  $\Box$

<span id="page-21-0"></span>Corollary 2. Let E be a typical execution in a  $(\gamma, s)$ -respecting environment and  $E_{r-1}$  be  $(\eta, \theta)$ -good. If every chain in  $S_{r-1}$  is  $(\eta \gamma, \frac{\theta}{\gamma})$ -good, then  $E_r$  is  $(\eta, \theta)$ -good.

Proof. We use notations and definitions of Lemma 3. Let  $C \in \mathcal{S}_r$  and let  $r^*$  be its last recalculation point in  $E_{r-1}$ . Let T be the target after  $r^*$  and T' the one at r. We need to show that  $f(T', n_r) \in [\eta f, \theta f]$ . Note that if r is a recalculation point, this follows by Lemma 4. Otherwise, T' = T and  $\eta \gamma \leq f(T, n_{r^*}) \leq \theta f/\gamma$ . Using Lemma 3,  $r - r^* \leq \Delta \leq \frac{\tau m}{f}$ . Thus,  $\frac{1}{\gamma} n_{r^*} \leq n_r \leq \gamma n_{r^*}$ . By Fact 2 we have  $f(T, n_r) \leq f(T, \gamma n_{r^*}) \leq \gamma f(T, n_{r^*}) \leq \theta f$  and  $f(T, n_r) \geq f(T, \frac{1}{\gamma} n_{r^*}) \geq \frac{1}{\gamma} f(T, n_{r^*}) \geq \eta f$ .

<span id="page-21-3"></span>Corollary 3. Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Then every round is  $(\eta, \theta)$ -good in E.

*Proof.* For the sake of contradiction, let r be the smallest round of E that is not  $(\eta, \theta)$ -good. This means that there is a chain  $\mathcal{C}$  and an honest party that possesses this chain in round r and the corresponding target T is such that  $f(T, n_r) \notin [\eta f, \theta f]$ . Note that  $E_{r-1}$  is  $(\eta, \theta)$ -good, and so, by Corollary 1,  $E_r$  is  $\frac{m}{16\tau f}$ -accurate. Let  $r^* < r$  be the last  $(\eta \gamma, \theta/\gamma)$ -good recalculation point of  $\mathcal{C}$  (let  $r^*$  be 0 in case there is no such point).

First suppose that there is another recalculation point  $r' \in (r^*, r]$ . By the definition of  $r^*$ , r' is not  $(\eta \gamma, \theta/\gamma)$ -good. However, the assumptions of Lemma 4 hold, implying that  $\mathcal{C}$  is  $(\eta \gamma, \theta/\gamma)$ -good. We have reached a contradiction.

We may now assume that there is no recalculation point in  $(r^*, r]$  and so the points  $r^*$  and r correspond to the same target T with  $\eta \gamma \leq f(T, n_{r^*}) \leq \theta f/\gamma$ . Note that since  $r^*$  is an  $(\eta \gamma, \theta/\gamma)$ -good recalculation point and  $E_{r-1}$  is  $(\eta, \theta)$ -good, we have  $r - r^* \leq \frac{\tau m}{f}$ . This follows from Lemma 3, because  $\mathcal{C}$  belongs to an honest party at round r. Thus,  $\frac{1}{\gamma}n_{r^*} \leq n_r \leq \gamma n_{r^*}$ , and so (by Fact 2)  $f(T, n_r) \leq f(T, \gamma n_{r^*}) \leq \gamma f(T, n_{r^*}) \leq \theta f$  and  $f(T, n_r) \geq f(T, \frac{1}{\gamma}n_{r^*}) \geq \frac{1}{\gamma}f(T, n_{r^*}) \geq \eta f$ .

<span id="page-21-1"></span>**Theorem 1.** A typical execution in a  $(\gamma, s)$ -respecting environment is  $\frac{m}{16\tau f}$ -accurate and  $(\eta, \theta)$ -good.

*Proof.* This follows from Corollaries 3 and 1.

### 6.5 Common Prefix and Chain Quality

<span id="page-21-4"></span>**Proposition 6.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Any  $\frac{\theta \gamma m}{8\tau}$  consecutive blocks in an epoch of a chain  $C \in \mathcal{S}_r$  have been computed in at least  $\frac{m}{16\tau f}$  rounds.

*Proof.* Suppose—towards a contradiction—that the blocks of  $\mathcal{C}$  where computed during the rounds in  $S^*$ , for some  $S^*$  such that  $|S^*| < \frac{m}{16\tau f}$ . Consider an S such that  $S^* \subseteq S$  and  $|S| = \frac{m}{16\tau f}$  and the property that a block of target T in  $\mathcal{C}$  was computed by an honest party in some round  $v \in S$ . Such an S exists by Lemmas 2 and 3. By Propositions 3 and 5, the number of blocks of target T computed in S is at most

$$(1+\epsilon)(2-\delta)pT\sum_{u\in S}n_u\leq (1+\epsilon)(2-\delta)pT\gamma n_v|S|\leq \frac{(1+\epsilon)(2-\delta)\gamma|S|\theta f}{1-\theta f}\leq \frac{\theta\gamma m}{8\tau}.$$

For the first inequality we used Fact 1, for the second Fact 1 and that round v is  $(\eta, \theta)$ -good, and for the last one Requirement (R2).

<span id="page-21-2"></span>**Theorem 2** (Common Prefix). In any typical execution of a  $(\gamma, s)$ -respecting environment, the common-prefix property holds for  $k \geq \frac{\theta \gamma m}{4\tau}$ .

Proof. Consider—towards a contradiction—honest parties  $P_1$  and  $P_2$  with adopted chains  $C_1$  and  $C_2$  at rounds  $r_1 \leq r_2$  respectively, such that  $C_1^{\lceil k} \nleq C_2$ . Define  $r \geq r_1$  as the least round in which an honest party P adopts a chain C such that  $C_1^{\lceil k} \nleq C$ . Consider the last block on the common prefix of  $C_1$  and C that was computed by an honest party and let  $r^*$  be the round on which it was computed (set  $r^* = 0$  if no such block exists). Denote by  $C^*$  the common part of  $C_1$  and C up to (and including) this block. Let also  $S = \{u : r^* < u < r\}$  and J the set of adversarial queries in S. By Proposition 6,  $|S| \geq \frac{m}{16\tau f}$ ; it is not hard to verify that the bounds on |J| and |S| of Definition 8 and Proposition 3 hold. We are going to argue that

<span id="page-22-0"></span>
$$(1+\epsilon)p\sum_{u\in S}t_u \ge \sum_{j\in J}A_j \ge \sum_{u\in S}Q_u \ge (1-\epsilon)(1-\theta f)p\sum_{u\in S}n_u.$$
 (2)

Note that this provides a contradiction, since Requirements (R0) and (R2) imply  $t_u < (1 - \delta)n_u \le (1 - 4\epsilon - 2\theta f)n_u < (1 - 2\epsilon)(1 - \theta f)n_u \le \frac{1-\epsilon}{1+\epsilon} \cdot (1-\theta f)n_u$ . The first and third inequalities hold in any typical execution; we proceed to show the middle one.

We first make a simple but crucial observation. Consider any block B extending a chain  $\mathcal{C}'$  that was computed by an honest party in a uniquely successful round  $u \in S$ . For any  $d \in \mathbb{R}$  such that  $\operatorname{diff}(\mathcal{C}') \leq d < \operatorname{diff}(\mathcal{C}'B)$ , let us write  $d \in B$ . We are going to argue that if another chain of difficulty at least d exists, then the block that "contains" the point of difficulty d was computed by the adversary. More formally, suppose a chain  $\mathcal{C}''B'$  exists such that  $B' \neq B$  and  $d \in B'$ . We observe that B' was computed by the adversary. This is because no honest party would extend  $\mathcal{C}''$  at a round later than u since  $\operatorname{diff}(\mathcal{C}'') \leq d < \operatorname{diff}(\mathcal{C}'B)$ ; on the other hand, if an honest party computed B' at some round u' < u, then no honest party would have extended  $\mathcal{C}'$  at round u since  $\operatorname{diff}(\mathcal{C}') \leq d < \operatorname{diff}(\mathcal{C}''B'')$ ; finally, note that u is also ruled out since it was uniquely successful.

Let us now return to the proof of (2). By the Chain-Growth Lemma (Lemma 1),  $\operatorname{diff}(\mathcal{C}) \geq \operatorname{diff}(\mathcal{C}^*) + \sum_{u \in S} Q_u$ . The observation in the previous paragraph implies that there is an injection from the set

 $U = \{d \in B : B \text{ was computed in a uniquely successful round in } S\}$

into the set

$$W = \{d \in B' : B' \text{ was computed by the adversary in a round in } S\}.$$

To see this, note first that both sets are subsets of  $(\operatorname{diff}(\mathcal{C}^*), \operatorname{diff}(\mathcal{C}))$ . We claim that for any  $d \in U$  and B such that  $d \in B$ , there is always a  $B' \neq B$  that lies either on  $\mathcal{C}_1$ , or on  $\mathcal{C}$ , or on their common prefix. Indeed, B cannot be both on  $\mathcal{C}$  and  $\mathcal{C}'$ ; by the definition of  $r^*$ , B cannot be on their common prefix; by the definition of r, B cannot be on the part of  $\mathcal{C}$  of greater difficulty than  $\operatorname{diff}(\mathcal{C}_1)$ .

Since the size of the first set is  $\sum_{u \in S} Q_u$  and the size of the second—by Proposition 5—is at most  $\sum_{i \in J} A_i$ , the inequality in (2) follows.

**Theorem 3** (Chain Quality). In any typical execution of a  $(\gamma, s)$ -respecting environment, the chain-quality property holds for  $\ell \geq \frac{\theta \gamma m}{8\tau}$  and  $\mu = \delta - 2\epsilon - \theta f \geq \delta/2$ .

Proof. Let us denote by  $B_i$  the *i*-th block of  $\mathcal{C}$  so that  $\mathcal{C} = B_1 \dots B_{\operatorname{len}(\mathcal{C})}$  and consider L consecutive blocks  $B_u, \dots, B_v$ . Define L' as the least number of consecutive blocks  $B_{u'}, \dots, B_{v'}$  that include the L given ones (i.e.,  $u' \leq u$  and  $v \leq v'$ ) and have the properties (1) that the block  $B_{u'}$  was computed by an honest party or is  $B_1$  in case such block does not exist, and (2) that there exists a round at which an honest party was trying to extend the chain ending at block  $B_{v'}$ . Observe that number L' is well defined since  $B_{\operatorname{len}(\mathcal{C})}$  is at the head of a chain that an honest party is trying to extend. Denote by d' the total difficulty of these L' blocks. Define also  $r_1$  as the round that  $B_{u'}$  was created (set  $r_1 = 0$  if  $B_{u'}$  is the genesis block),  $r_2$  as the first round that an honest party attempts to extend  $B_{v'}$ , and let  $S = \{r : r_1 \leq r \leq r_2\}$ . Note that, by Proposition  $6, |S| \geq \frac{m}{16\tau f}$ .

Now let x denote the total difficulty of all the blocks from honest parties that are included in the L blocks and—towards a contradiction—assume that

<span id="page-22-1"></span>
$$x < \mu d \le \mu d'. \tag{3}$$

Suppose first that all the L' blocks  $\{B_j : u' \leq j \leq v'\}$  have been computed during the rounds in the set S. We now argue the following sequence of inequalities.

<span id="page-23-2"></span>
$$(1+\epsilon)(1-\delta)p\sum_{u\in S}n_u \ge (1+\epsilon)p\sum_{u\in S}t_u > \sum_{j\in J}A_j \ge d'-x \ge (1-\mu)d' \ge (1-\mu)\sum_{u\in S}Q_u.$$
 (4)

The first inequality is due to our requirement that  $t_u \leq (1-\delta)n_u$  holds for any round u. The second one holds in any typical execution and Remark ??. The third one follows from the definition of x and d' and Proposition 5. The fourth one comes from the relation between x and d' outlined in (3). To see the last inequality, assume  $\sum_{u \in S} Q_u > d'$ . But then, by the Chain-Growth Lemma 1, the assumption than an honest party is on  $B_{v'}$  at round  $r_2$  is contradicted as all honest parties should be at chains of greater length. We now observe that (4) contradicts Proposition 3, since

$$(1-\mu)\sum_{u\in S} Q_u > (1-\mu)(1-\epsilon)(1-\theta f)p\sum_{u\in S} n_u \ge (1+\epsilon)(1-\delta)p\sum_{u\in S} n_u,$$

where the last inequality follows by Requirement (R2).

To finish the proof we need to consider the case in which these L' blocks contain blocks that the adversary computed in rounds outside S. It is not hard to see that this case implies either a prediction or an insertion and cannot occur in a typical execution.

#### 6.6 Persistence and Liveness

<span id="page-23-1"></span>**Theorem 4.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Persistence is satisfied with depth  $k \geq \frac{\theta \gamma m}{4\tau}$ .

*Proof.* If the chain  $\mathcal{C}$  of an honest party at round r contains a transaction in  $\mathcal{C}^{\lceil k}$ , it follows by the commonprefix property that for the chain  $\mathcal{C}'$  of another honest party at any round  $r' \geq r$  it holds  $\mathcal{C}^{\lceil k} \leq \mathcal{C}'$ .

**Proposition 7.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Suppose an honest party has a prefix of C at a round u and an honest party adopted a prefix of C at round  $v \ge u + \frac{m}{16\tau f}$ . During the set of consecutive rounds  $S = \{r : u \le r < v\}$ , C acquired at least  $(1 - \epsilon)(1 - \theta f)\eta f|S|/\gamma$  blocks.

Proof. Assume first that  $|S| \leq s - \frac{m}{8\tau f}$ . Suppose  $\mathcal C$  at round u has difficulty d. By the Chain Growth Lemma 1,  $\mathcal C$  has difficulty at least  $d' = d + \sum_{r \in S} D_r$  by round v. Let T be the least target among the targets of the blocks acquired during the rounds in S. By Lemmas 2 and 3, there is an honest block on  $\mathcal C$  computed in  $S' = \{r : u - \frac{m}{16\tau f} \leq r < v + \frac{m}{16\tau f}\}$  that lies in the same epoch and so has target T. Since the execution is good (Theorem 1),  $S \subseteq S'$ , and  $|S'| \leq s$ , we obtain (Fact 1)  $pTn_r \geq \eta f/\gamma$ , for any  $r \in S$ . It follows that  $\mathcal C$  acquired at least

$$T(d'-d) = T \sum_{r \in S} D_r \ge T \sum_{r \in S} Q_r > (1-\epsilon)(1-\theta f) \sum_{r \in S} pT n_r \ge (1-\epsilon)(1-\theta f)\eta f |S|/\gamma$$

blocks during the rounds in S.

To avoid the upper bound on S and obtain the statement, observe that by Lemma 2 we can partition S so that each part  $S_i$  satisfies  $\frac{m}{16\tau f} \leq |S| \leq s - \frac{m}{8\tau f}$ , an honest party has (a prefix of) C at the beginning of  $S_i$ , and an honest party has adopted (a prefix of) C at the end of  $S_i$ . Summing over each part we obtain the general statement.

<span id="page-23-0"></span>**Theorem 5.** Let E be a typical execution in a  $(\gamma, s)$ -respecting environment. Liveness is satisfied for depth  $k \geq \frac{\theta \gamma m}{8\tau}$  and wait-time  $\frac{m}{16\tau f} + \frac{\gamma k}{\eta f(1-\epsilon)(1-\theta f)}$ .

*Proof.* Suppose a transaction tx is included in any block computed by an honest party for  $\frac{m}{16\tau f}$  consecutive rounds and consider the chain  $\mathcal C$  of an arbitrary honest party after these rounds. By Lemma 2,  $\mathcal C$  contains an honest block computed in the  $\frac{m}{16\tau f}$  rounds and this block contains tx. Denote by S the set of at least  $\gamma k/[\eta f(1-\epsilon)(1-\theta f)]$  rounds that follow the round that this honest block was computed. By Proposition ??, on top of this block there has been accumulated at least k blocks.

## References

- <span id="page-24-2"></span>[1] Back, A.: Hashcash. http://www.cypherspace.org/hashcash (1997)
- <span id="page-24-5"></span>[2] Bahack, L.: Theoretical bitcoin attacks with less than half of the computational power (draft). IACR Cryptology ePrint Archive 2013, 868 (2013), <http://eprint.iacr.org/2013/868>
- <span id="page-24-4"></span>[3] Bellare, M., Rogaway, P.: Random oracles are practical: A paradigm for designing efficient protocols. In: Denning, D.E., Pyle, R., Ganesan, R., Sandhu, R.S., Ashby, V. (eds.) CCS '93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993. pp. 62–73. ACM (1993), <http://doi.acm.org/10.1145/168588.168596>
- <span id="page-24-10"></span>[4] Canetti, R.: Security and composition of multiparty cryptographic protocols. J. Cryptology 13(1), 143–202 (2000)
- <span id="page-24-11"></span>[5] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067 (2000), <http://eprint.iacr.org/2000/067>
- <span id="page-24-12"></span>[6] Canetti, R.: Universally composable security: A new paradigm for cryptographic protocols. In: 42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA. pp. 136–145. IEEE Computer Society (2001), [http://dx.doi.org/10.1109/SFCS.2001.](http://dx.doi.org/10.1109/SFCS.2001.959888) [959888](http://dx.doi.org/10.1109/SFCS.2001.959888)
- <span id="page-24-8"></span>[7] Dwork, C., Lynch, N.A., Stockmeyer, L.J.: Consensus in the presence of partial synchrony. J. ACM 35(2), 288–323 (1988), <http://doi.acm.org/10.1145/42282.42283>
- <span id="page-24-1"></span>[8] Dwork, C., Naor, M.: Pricing via processing or combatting junk mail. In: Brickell, E.F. (ed.) CRYPTO. Lecture Notes in Computer Science, vol. 740, pp. 139–147. Springer (1992)
- <span id="page-24-6"></span>[9] Eyal, I., Sirer, E.G.: Majority is not enough: Bitcoin mining is vulnerable. In: Keromytis, A.D. (ed.) Financial Cryptography. Lecture Notes in Computer Science, vol. 7397. Springer (2014), [http:](http://dx.doi.org/10.1007/978-3-642-32946-3) [//dx.doi.org/10.1007/978-3-642-32946-3](http://dx.doi.org/10.1007/978-3-642-32946-3)
- <span id="page-24-9"></span>[10] Garay, J.A., Kiayias, A., Leonardos, N.: The Bitcoin Backbone Protocol: Analysis and Applications. IACR Cryptology ePrint Archive 2014, 765 (2014), <http://eprint.iacr.org/2014/765>
- <span id="page-24-0"></span>[11] Garay, J.A., Kiayias, A., Leonardos, N.: The bitcoin backbone protocol: Analysis and applications. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II. Lecture Notes in Computer Science, vol. 9057, pp. 281–310. Springer (2015), [http://dx.doi.org/10.1007/978-3-662-46803-6\\_10](http://dx.doi.org/10.1007/978-3-662-46803-6_10)
- <span id="page-24-13"></span>[12] Hadzilacos, V., Toueg, S.: A modular approach to fault-tolerant broadcasts and related problems. Tech. rep. (1994)
- <span id="page-24-3"></span>[13] Juels, A., Brainard, J.G.: Client puzzles: A cryptographic countermeasure against connection depletion attacks. In: NDSS. The Internet Society (1999)
- <span id="page-24-7"></span>[14] Kiayias, A., Koutsoupias, E., Kyropoulou, M., Tselekounis, Y.: Blockchain mining games. In: Conitzer, V., Bergemann, D., Chen, Y. (eds.) Proceedings of the 2016 ACM Conference on Economics and Computation, EC '16, Maastricht, The Netherlands, July 24-28, 2016. pp. 365–382. ACM (2016), <http://doi.acm.org/10.1145/2940716.2940773>
- <span id="page-24-14"></span>[15] Kiayias, A., Panagiotakos, G.: Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive 2015, 1019 (2015), <http://eprint.iacr.org/2015/1019>

- <span id="page-25-2"></span>[16] Lamport, L., Shostak, R.E., Pease, M.C.: The byzantine generals problem. ACM Trans. Program. Lang. Syst. 4(3), 382–401 (1982)
- <span id="page-25-7"></span>[17] McDiarmid, C.: Probabilistic Methods for Algorithmic Discrete Mathematics, chap. Concentration, pp. 195–248. Springer Berlin Heidelberg, Berlin, Heidelberg (1998), [http://dx.doi.org/10.1007/](http://dx.doi.org/10.1007/978-3-662-12788-9_6) [978-3-662-12788-9\\_6](http://dx.doi.org/10.1007/978-3-662-12788-9_6)
- <span id="page-25-8"></span>[18] Mitzenmacher, M., Upfal, E.: Probability and computing - randomized algorithms and probabilistic analysis. Cambridge University Press (2005)
- <span id="page-25-3"></span>[19] Nakamoto, S.: Bitcoin open source implementation of p2p currency. http://p2pfoundation.ning.com/forum/topics/bitcoin-open-source (February 2009)
- <span id="page-25-5"></span>[20] Pass, R., Seeman, L., Shelat, A.: Analysis of the blockchain protocol in asynchronous networks. In: Coron, J., Nielsen, J.B. (eds.) Advances in Cryptology - EUROCRYPT 2017 - 36th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Paris, France, April 30 - May 4, 2017, Proceedings, Part II. Lecture Notes in Computer Science, vol. 10211, pp. 643–673 (2017), [https://doi.org/10.1007/978-3-319-56614-6\\_22](https://doi.org/10.1007/978-3-319-56614-6_22)
- <span id="page-25-1"></span>[21] Pease, M.C., Shostak, R.E., Lamport, L.: Reaching agreement in the presence of faults. J. ACM 27(2), 228–234 (1980)
- <span id="page-25-0"></span>[22] Rivest, R.L., Shamir, A., Wagner, D.A.: Time-lock puzzles and timed-release crypto. Tech. rep., Cambridge, MA, USA (1996)
- <span id="page-25-4"></span>[23] Sapirshtein, A., Sompolinsky, Y., Zohar, A.: Optimal selfish mining strategies in bitcoin. CoRR abs/1507.06183 (2015), <http://arxiv.org/abs/1507.06183>

## <span id="page-25-6"></span>A The Bitcoin Backbone Protocol with Variable Difficulty (cont'd)

In this section we give a a more detailed description of the Bitcoin backbone protocol with chains of variable difficulty. The presentation is based on the description in [\[11\]](#page-24-0).

### A.1 The protocol

As in [\[11\]](#page-24-0) in our description oof the backbone protocol we intentionally avoid specifying the type of values/content that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions G(·), H(·)), and the way they interpret the chain. These checks and operations are handled by the external functions V (·), I(·) and R(·) (the content validation function, the input contribution function and the chain reading function, resp.) which are specified by the application that runs "on top" of the backbone protocol.

The Bitcoin backbone protocol in the dynamic setting is specified as Algorithm [4](#page-28-0) and depends on three sub-procedures.

Chain validation. The validate algorithm performs a validation of the structural properties of a given chain C. It is given as input the value q, as well as hash functions H(·), G(·). It is parameterized by the content validation predicate predicate V (·) as well as by D(·), the target calculation function (see Section [3\)](#page-4-1). For each block of the chain, the algorithm checks that the proof of work is properly solved (with a target that is suitable as determined by the target calculation function), and that the counter ctr does not exceed q. Furthermore it collects the inputs from all blocks, xC, and tests them via the predicate V (xC); note that V (ε) = true. Chains that fail these validation procedure are rejected. (Algorithm [1.](#page-26-0))

<span id="page-26-0"></span>**Algorithm 1** The *chain validation predicate*, parameterized by q, D, the hash functions  $G(\cdot), H(\cdot)$ , and the input validation predicate  $V(\cdot)$ . The input is chain C.

```
1: function validate(r_{now}, C)
            valid \leftarrow V(\mathbf{x}_{\mathcal{C}})
 2:
            if valid = \text{True} \land (C \neq \varepsilon) then
                                                                                                             \triangleright C is non-empty and meaningful w.r.t. V(\cdot)
 3:
                  r' \leftarrow r_{\text{now}}
 4:
                  \langle r, st, x, ctr \rangle \leftarrow \text{head}(\mathcal{C})
 5:
                  st' \leftarrow H(ctr, G(r, st, x))
 6:
                  repeat
 7:
                         \langle r, st, x, ctr \rangle \leftarrow \text{head}(\mathcal{C})
 8:
                                                                                                                                     \triangleright Calculate target based on \mathcal{C}^{\lceil 1 \rceil}
                        T \leftarrow D(\mathbf{r}_{\mathcal{C}^{\lceil 1}})
 9:
                        if validblock _{a}^{T}(\langle st, x, ctr \rangle) \wedge (H(ctr, G(r, st, x)) = st') \wedge (r < r') then
10:
                                                                                                                                             ▶ Retain round timestamp
11:
                              st' \leftarrow st
                                                                                                                                                          ▶ Retain hash value
12:
                              \mathcal{C} \leftarrow \mathcal{C}^{\lceil 1 \rceil}
                                                                                                                                             \triangleright Remove the head from \mathcal{C}
13:
                        else
14:
                               valid \leftarrow False
15:
                        end if
16:
                  until (\mathcal{C} = \varepsilon) \vee (valid = False)
17:
            end if
18:
19:
            return valid
20: end function
```

Chain comparison. The objective of the second algorithm, called maxvalid, is to find the "best possible" chain when given a set of chains. The algorithm is straightforward and is parameterized by a  $\max(\cdot)$  function that applies some ordering in the space of chains. The most important aspect is the chains' difficulty in which case  $\max(\mathcal{C}_1, \mathcal{C}_2)$  will return the most difficult of the two. In case  $\operatorname{diff}(\mathcal{C}_1) = \operatorname{diff}(\mathcal{C}_2)$ , some other characteristic can be used to break the tie. In our case,  $\max(\cdot, \cdot)$  will always return the first operand to reflect the fact that parties adopt the first chain they obtain from the network. (Algorithm 2.)

<span id="page-26-1"></span>**Algorithm 2** The function that finds the "best" chain, parameterized by function  $\max(\cdot)$ . The input is  $\{C_1, \ldots, C_k\}$ .

```
1: function maxvalid(r, C_1, \dots, C_k)

2: temp \leftarrow \varepsilon

3: for i = 1 to k do

4: if validate(r, C_i) then

5: temp \leftarrow \max(C, temp)

6: end if

7: end for

8: return temp

9: end function
```

**Proof of work.** The third algorithm, called pow, is the proof of work-finding procedure. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  $H(\cdot), G(\cdot)$  as well as the parameter q. Moreover, the algorithm calls the target calculation function  $D(\cdot)$  om prder to determine the value T that will be used for the proof of work. The procedure, given a chain C and a value x to be inserted in the chain, hashes these values to obtain h and initializes a counter ctr. Subsequently, it increments ctr and checks to see whether H(ctr,h) < T; in case a suitable ctr is found then the algorithm succeeds in solving the POW and extends chain C by one block. (Algorithm 3.)

<span id="page-27-0"></span>Algorithm 3 The proof of work function, parameterized by q and hash functions H(·), G(·). The input is (x, C).

```
1: function pow(r, x, C)
2: if C = ε then . Determine proof of work instance.
3: st ← 0
4: else
5: hr
        0
        , st0
           , x0
             , ctr0
                i ← head(C)
6: st ← H(ctr0
               , G(r
                  0
                  , st0
                     , x0
                       ))
7: end if
8: ctr ← 1
9: B ← ε
10: T ← D(rC) . Calculate target for next block based on timestamps.
11: h ← G(r, st, x)
12: while (ctr ≤ q) do
13: if (H(ctr, h) < T) then . This H(·) invocation is subject to the q-bound.
14: B ← hr, st, x, ctri
15: break
16: end if
17: ctr ← ctr + 1
18: end while
19: C ← CB . Chain is extended
20: return C
21: end function
```

The backbone protocol. The core of the protocol is similar to that of [\[11\]](#page-24-0), with several important distinctions. First is the procedure to follow when they become active. Parties check the ready flag they possess that is false if and only if they have been inactive in the previous round. In case the ready flag is false, they broadcast a special message 'Join' to request the most recent version of the blockchain(s). Similarly, parties that receive the special request message in their Receive() tape they broadcast their chain. As before, parties run "indefinitely" (our security analysis will apply when the total running time is polynomial in κ). The input contribution function I(·) and the chain reading function R(·) are applied to the values stored in the chain. Parties check their communication tape Receive() to see whether any necessary update of their local chain is due; then they attempt to extend it via the POW algorithm pow. The function I(·) determines the input to be added in the chain given the party's state st, the current chain C, the contents of the party's input tape Input() and communication tape Receive(). The input tape contains two types of symbols, Read and (Insert, value); other inputs are ignored. In case the local chain C is extended the new chain is broadcast to the other parties. Finally, in case a Read symbol is present in the communication tape, the protocol applies function R(·) to its current chain and writes the result onto the output tape Output(). The pseudocode of the backbone protocol is presented in Algorithm [4.](#page-28-0)

<span id="page-28-0"></span>**Algorithm 4** The Bitcoin backbone protocol in the dynamic setting at round "round" on local state  $(st, \mathcal{C})$  parameterized by the *input contribution function*  $I(\cdot)$  and the *chain reading function*  $R(\cdot)$ . The "ready" flag is False if and only if the party was inactive in the previous round.

```
1: if ready = True then
            DIFFUSE(Ready)
 2:
           \tilde{\mathcal{C}} \leftarrow \mathsf{maxvalid}(\mathcal{C}, \mathsf{all\ chains}\ \mathcal{C}' \ \mathsf{found\ in\ Receive}())
 3:
           if Input() contains Read then
 4:
                   write R(\mathbf{x}_{\mathcal{C}}) to Output()
 5:
            end if
 6:
            \langle st, x \rangle \leftarrow I(st, \tilde{\mathcal{C}}, \mathtt{round}, \mathtt{INPUT}(), \mathtt{RECEIVE}())
 7:
           C_{\mathsf{new}} \leftarrow \mathsf{pow}(\mathsf{round}, x, \mathcal{C})
 8:
           if (\mathcal{C} \neq \mathcal{C}_{new}) \vee (\mathsf{Join} \in \mathsf{Receive}()) then
 9:
                 \mathcal{C} \leftarrow \mathcal{C}_{\mathsf{new}}
10:
11:
                 Diffuse(\mathcal{C})
                                                                                   b chain is diffused when updated or when someone joins.
12:
           end if
            DIFFUSE(RoundComplete)
13:
14: else
           ready \leftarrow True
15:
            DIFFUSE(Join, RoundComplete)
16:
17: end if
```

## **B** Robust Public Transaction Ledgers

In this section we reproduce the presentation of public transaction ledgers given in [10, 11]. A public transaction ledger is defined with respect to a set of valid ledgers  $\mathcal{L}$  and a set of valid transactions  $\mathcal{T}$ , each one possessing an efficient membership test. A ledger  $\mathbf{x} \in \mathcal{L}$  is a vector of sequences of transactions  $\mathbf{tx} \in \mathcal{T}$ . Each transaction  $\mathbf{tx}$  may be associated with one or more accounts, denoted  $a_1, a_2, \ldots$  etc.

The backbone protocol parties, called *miners* in the context of this section, process sequences of transactions of the form  $x = \mathrm{tx}_1 \dots \mathrm{tx}_e$  that are supposed to be incorporated into their local chain  $\mathcal{C}$ . The input inserted at each block of the chain  $\mathcal{C}$  is the sequence x of transactions. Thus, a ledger is a vector of transaction sequences  $\langle x_1, \dots, x_m \rangle$ , and a chain  $\mathcal{C}$  of length m contains the ledger  $\mathbf{x}_{\mathcal{C}} = \langle x_1, \dots, x_m \rangle$  if the input of the j-th block in  $\mathcal{C}$  is  $x_j$ .

The description and properties of the ledger protocol will be expressed relative to an oracle Txgen which will control a set of accounts by creating them and issuing transactions on their behalf. In an execution of the backbone protocol, the environment  $\mathcal{Z}$  as well as the miners will have access to Txgen. Specifically, Txgen is a stateful oracle that responds to two types of queries (which we purposely only describe at a high level):

- GenAccount( $1^{\kappa}$ ): It generates an account a.
- Issue Trans $(1^{\kappa}, \tilde{tx})$ : It returns a transaction tx provided that  $\tilde{tx}$  is some suitably formed string, or  $\perp$ .

We also consider a symmetric relation on  $\mathcal{T}$ , denoted by  $C(\cdot, \cdot)$ , which indicates when two transactions  $\mathrm{tx}_1, \mathrm{tx}_2$  are conflicting. Valid ledgers  $\mathbf{x} \in \mathcal{L}$  can never contain two conflicting transactions. We call oracle Txgen *unambiguous* if it holds that for all PPT  $\mathcal{A}$ , the probability that  $\mathcal{A}^{\mathsf{Txgen}}$  produces a transaction  $\mathrm{tx}'$  such that  $C(\mathrm{tx}',\mathrm{tx}) = 1$ , for tx issued by Txgen, is negligible in  $\kappa$ .

Finally, a transaction tx is called *neutral* if  $C(\mathsf{tx}, \mathsf{tx}') = 0$  for any other transaction  $\mathsf{tx}'$ . The presence of neutral transactions in the ledger can be helpful for a variety of purposes, as we will see next and in the BA protocol that we build on top of the ledger. For convenience we will assume that a single random nonce  $\rho \in \{0,1\}^{\kappa}$  is also a valid transaction. Nonces will be neutral transactions and may be included in the ledger for the sole purpose of ensuring independence between the POW instances solved by the honest parties.

Next, we determine the three functions  $V(\cdot)$ ,  $I(\cdot)$ ,  $R(\cdot)$  that will turn the backbone protocol into  $\Pi_{PL}$ , a protocol realizing a public transaction ledger. See Figure 1.

| Content validation predi- | $V(\langle x_1,\ldots,x_m\rangle)$ is true if and only if the vector $\langle x_1,\ldots,x_m\rangle$ is a valid ledger,            |
|---------------------------|------------------------------------------------------------------------------------------------------------------------------------|
| cate $V(\cdot)$           | i.e., $\langle x_1, \ldots, x_m \rangle \in \mathcal{L}$ .                                                                         |
| Chain reading function    | If $V(\langle x_1, \ldots, x_m \rangle)$ = True, the value $R(\mathcal{C})$ is equal to $\langle x_1, \ldots, x_m \rangle$ ; unde- |
| $R(\cdot)$                | fined otherwise.                                                                                                                   |
| Input contribution func-  | I(st, C, round, Input) operates as follows: if the input tape contains                                                             |
| tion $I(\cdot)$           | (Insert, $v$ ), it parses $v$ as a sequence of transactions and retains the largest                                                |
|                           | subsequence $x' \leq v$ that is valid with respect to $\mathbf{x}_{\mathcal{C}}$ (and whose transactions                           |
|                           | are not already included in $\mathbf{x}_{\mathcal{C}}$ ). Finally, $x = \mathrm{tx}_0 x'$ where $\mathrm{tx}_0$ is a neutral       |
|                           | random nonce transaction.                                                                                                          |

<span id="page-29-3"></span>Figure 1: The public transaction ledger protocol  $\Pi_{PL}$ , built on the Bitcoin backbone.

In Section 4.3 we introduced two essential properties for a protocol maintaining a public transaction ledger: (i) *Persistence* and (ii) *Liveness*. In a nutshell, Persistence states that once an honest player reports a transaction "deep enough" in the ledger, then all other honest players will report it indefinitely whenever they are asked, and at exactly the same position in the ledger (essentially, this means that all honest players agree on all the transactions that took place and in what order). In a more concrete Bitcoin-like setting, Persistence is essential to ensure that credits are final and that they happened at a certain "time" in the system's timeline (which is implicitly defined by the ledger itself).

Persistence is useful but not enough to ensure that the ledger makes progress, i.e., that transactions are eventually inserted in a chain. This is captured by the Liveness property, which states that as long as a transaction comes from an honest account holder and is provided by the environment to all honest players, then it will be inserted into the honest players' ledgers, assuming the environment keeps providing it as an input for a sufficient number of rounds.

For more details about the specification of a robust transaction ledger, in particular Bitcoin-like transactions and ledger, refer to [10, 11].

# <span id="page-29-1"></span>C Martingale Sequences and Other Mathematical Facts

**Definition 9.** [18, Chapter 12] A sequence of random variables  $X_0, X_1, \ldots$  is a martingale with respect to the sequence  $Y_0, Y_1, \ldots$ , if, for all  $n \geq 0$ , (1)  $X_n$  is a function of  $Y_0, \ldots, Y_n$ , (2)  $\mathbf{E}[|X_n|] < \infty$ , and (3)  $\mathbf{E}[X_{n+1}|Y_0, \ldots, Y_n] = X_n$ .

<span id="page-29-0"></span>**Theorem 6.** [17, Theorem 3.15] Let  $X_0, X_1, \ldots$  be a martingale with respect to the sequence  $Y_0, Y_1, \ldots$  For  $n \geq 0$ , let

$$V = \sum_{i=1}^{n} \operatorname{var}(X_i - X_{i-1} | Y_0, \dots, Y_{i-1}) \text{ and } b = \max_{1 \le i \le n} \sup(X_i - X_{i-1} | Y_0, \dots, Y_{i-1}),$$

where sup is taken over all possible assignments to  $Y_0, \ldots, Y_{i-1}$ . Then, for any  $t, v \ge 0$ ,

$$\mathbf{Pr}\big[(X_n \ge X_0 + t) \land (V \le v)\big] \le \exp\bigg\{-\frac{t^2}{2v + 2bt/3}\bigg\}.$$

<span id="page-29-2"></span>**Fact 2.** Suppose  $f: \mathbb{R}_{\geq 0} \to \mathbb{R}_{\geq 0}$  is concave and  $f(0) \geq 0$ . Then, for any  $x, y \in [0, \infty)$  and  $\lambda \in [1, \infty)$ ,  $f(x/\lambda) \geq f(x)/\lambda$ ,  $f(\lambda x) \leq \lambda f(x)$ ,  $f(x+y) \leq f(x) + f(y)$ .

The following well-known inequalities may be used without reference.

Fact 3. (1)  $1 + x < e^x$ , for all x. (2)  $-\frac{x}{1-x} < \ln(1-x)$ , for  $x \in (0,1)$ . (3)  $\frac{x}{1+x/2} < \ln(1+x) < x$ , for x > 0.