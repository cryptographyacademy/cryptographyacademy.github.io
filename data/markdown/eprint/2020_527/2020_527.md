# Aggregatable Subvector Commitments for Stateless Cryptocurrencies

Alin Tomescu,1,[0000−0002−6896−1380], Ittai Abraham<sup>1</sup> , Vitalik Buterin<sup>2</sup> , Justin Drake<sup>2</sup> , Dankrad Feist<sup>2</sup> , and Dmitry Khovratovich<sup>2</sup> {alint,iabraham}@vmware.com, {vitalik,justin,dankrad,dmitry.khovratovich}@ethereum.org

> <sup>1</sup> VMware Research, Palo Alto, CA, US <sup>2</sup> Ethereum Foundation, Singapore, Singapore

Abstract. An aggregatable subvector commitment (aSVC) scheme is a vector commitment (VC) scheme that can aggregate multiple proofs into a single, small subvector proof. In this paper, we formalize aSVCs and give a construction from constant-sized polynomial commitments. Our construction is unique in that it has linear-sized public parameters, it can compute all constant-sized proofs in quasilinear time, it updates proofs in constant time and it can aggregate multiple proofs into a constant-sized subvector proof. Furthermore, our concrete proof sizes are small due to our use of pairing-friendly groups. We use our aSVC to obtain a payments-only stateless cryptocurrency with very low communication and computation overheads. Specifically, our constant-sized, aggregatable proofs reduce each block's proof overhead to a single group element, which is optimal. Furthermore, our subvector proofs speed up block verification and our smaller public parameters further reduce block size.

# 1 Introduction

In a stateless cryptocurrency, neither miners nor cryptocurrency users need to store the full ledger state. Instead, this state consisting of users' account balances is split among all users using an authenticated data structure. This way, miners only store a succinct digest of the ledger state and each user stores their account balance. Nonetheless, miners can still validate transactions sent by users, who now include proofs that they have sufficient balance. Furthermore, miners can still propose new blocks of transactions and users can easily synchronize or update their proofs as new blocks get published.

Stateless cryptocurrencies have received increased attention [\[Dry19,](#page-13-0) [RMCI17,](#page-13-1) [CPZ18,](#page-13-2) [BBF19,](#page-13-3) [GRWZ20,](#page-13-4) [STS99,](#page-14-0) [Mil12,](#page-13-5) [Tod16,](#page-14-1) [But17\]](#page-13-6) due to several advantages. First, stateless cryptocurrencies eliminate hundreds of gigabytes of miner storage needed to validate blocks. Second, statelessness makes scaling consensus via sharding much easier, by allowing miners to efficiently switch from one shard to another [\[KJG](#page-13-7)+18[,Com16\]](#page-13-8). Third, statelessness lowers the barrier to entry for full nodes, resulting in a much more resilient, distributed cryptocurrency.

Stateless Cryptocurrencies from VCs. At a high level, a VC scheme allows a prover to compute a succinct commitment c to a vector v = [v0, v1, . . . , vn−1] of n elements where v<sup>i</sup> ∈ Zp. Importantly, the prover can generate a proof π<sup>i</sup> that v<sup>i</sup> is the element at position i in v, and any verifier can check it against the commitment c. The prover needs a proving key prk to commit to vectors and to compute proofs, while the verifier needs a verification key vrk to verify proofs. (Usually |vrk| |prk|.) Some VC schemes support updates: if one or more elements in the vector change, the commitment and proofs can be updated efficiently. For this, a static update key upk<sup>j</sup> tied only to the updated position j is necessary. Alternatively, some schemes require dynamic update hints uph<sup>j</sup> , typically consisting of the actual proof π<sup>j</sup> . The proving, verification and update keys comprise the VC's public parameters. Lastly, subvector commitment (SVC) schemes [\[LM19\]](#page-13-9) support computing succinct proofs for I-subvectors (vi)i∈<sup>I</sup> where I ⊂ [0, n). Furthermore, some schemes are aggregatable: multiple proofs π<sup>i</sup> for v<sup>i</sup> , ∀i ∈ I can be aggregated into a single, succinct I-subvector proof.

Chepurnoy, Papamanthou and Zhang pioneered the idea of building account-based [\[Woo\]](#page-14-2), stateless cryptocurrencies on top of any vector commitment (VC) scheme [\[CPZ18\]](#page-13-2). Ideally, such a VC would have (1) sublinear-sized, updatable proofs with sublinear-time verification, (2) updatable commitments and (3) sublinear-sized update keys. In particular, static update keys (rather than dynamic update hints) help reduce interaction and thus simplify the design (see Section [4.1\)](#page-9-0). We say such a VC has "scalable updates." Unfortunately, most VCs do not have scalable updates (see Section [1.1](#page-1-0) and Tables [2](#page-6-0) and [3\)](#page-24-0) or, if they do [\[CPZ18,](#page-13-2)[Tom20\]](#page-14-3), they are not optimal in their proof and update key sizes. Lastly, while some schemes in hidden-order groups have scalable updates [\[CFG](#page-13-10)<sup>+</sup>20], they suffer from larger concrete proof sizes and are likely to require more computation in practice.

Our Contributions. In this paper, we formalize a new aggregatable subvector commitment (aSVC) notion that supports commitment updates, proof updates and aggregation of proofs into subvector proofs. Then, we construct

<span id="page-1-1"></span>Table 1. Asymptotic comparison of our work with other stateless cryptocurrencies. n is the number of users,  $\lambda$  is the security parameter, and b is the number of transactions in a block.  $\mathbb{G}$  is an exponentiation in a known-order group.  $\mathbb{G}_{?}$  is a (slower) exponentiation (of size  $2\lambda$  bits) in a hidden-order group.  $\mathbb{P}$  is a pairing computation.  $|\pi_i|$  is the size of a proof for a user's account balance.  $|\text{upk}_i|$  is the size of user i's update key.  $|\pi_I|$  is the size of a proof aggregated from all  $\pi_i$ 's in a block. We give each Miner's storage in terms of VC public parameters (e.g., update keys). A miner takes: (1) Check digest time, to check that, by "applying" the transactions from block t+1 to block t's digest, he obtains the correct digest for block t+1, (2) Aggr. proofs time, to aggregate b transaction proofs, and (3) Vrfy.  $|\pi_I|$  time, to verify the aggregated proof. A user takes Proof synchr. time to "synchronize" or update her proof by "applying" all the transactions in a new block. We treat [GRWZ20] and [CFG<sup>+</sup>20] as a payments-only stateless cryptocurrency without smart contracts. Our aggregation and verification times have an extra  $b \log^2 b$   $\mathbb{F}$  term, consisting of very fast field operations. A detailed analysis of the underlying VCs can be found in Appendices D.4, D.6, D.7 and E.1.

| Account-based stateless cryptocurrencies | Edrax<br>[CPZ18]              | Pointproofs<br>[GRWZ20]       |                            | Our work                                             |
|------------------------------------------|-------------------------------|-------------------------------|----------------------------|------------------------------------------------------|
| $ \pi_i $                                | $\log n \mid \mathbb{G} \mid$ | 1  G                          | $1  \mathbb{G}_? $         | 1  G                                                 |
| $ upk_i $                                | $\log n \mid \mathbb{G} \mid$ | $n$ $ \mathbb{G} $            | $1  \mathbb{G}_? $         | $1  \mathbb{G} $                                     |
| $ \pi_I $                                | $b\log n$ $ \mathbb{G} $      | $1  \mathbb{G} $              | $1  \mathbb{G}_? $         | $1  \mathbb{G} $                                     |
| Miner's storage                          | $n$ $ \mathbb{G} $            | $n$ $ \mathbb{G} $            | $1  \mathbb{G}_? $         | $b \mid \mathbb{G} \mid$                             |
| Vrfy. $ \pi_I $ time                     | $b\log n$ $\mathbb{P}$        | $2 \mathbb{P} + b \mathbb{G}$ | $b \log b \mathbb{G}_?$    | $2 \mathbb{P} + b \mathbb{G} + b \lg^2 b \mathbb{F}$ |
| Check digest time                        | $b \ \mathbb{G}$              | $b \ \mathbb{G}$              | $b   \mathbb{G}_?$         | $b \ \mathbb{G}$                                     |
| Aggr. proofs time                        | ×                             | $b \ \mathbb{G}$              | $b\log^2 b \ \mathbb{G}_?$ | $b \mathbb{G} + \frac{b \lg^2 b}{\mathbb{F}}$        |
| Proof synchr. time                       | $b \log n \mathbb{G}$         | $b \ \mathbb{G}$              | $b \; \mathbb{G}_?$        | $b \ \mathbb{G}$                                     |

an aSVC with scalable updates over pairing-friendly groups. Compared to other pairing-based VCs, our aSVC has constant-sized, aggregatable proofs that can be updated with constant-sized update keys (see Table 2). Furthermore, our aSVC supports computing all proofs in quasilinear time. We prove security of our aSVC by strengthening (and re-proving) the security definition of KZG polynomial commitments [KZG10].

A Highly-Efficient Stateless Cryptocurrency. We use our aSVC to construct a stateless cryptocurrency based on the elegant design of Edrax [CPZ18]. Our stateless cryptocurrency has very low storage, communication and computation overheads (see Table 1). First, our constant-sized update keys have a smaller impact on block size and help users update their proofs faster. Second, our proof aggregation drastically reduces block size and speeds up block validation. Third, our verifiable update keys remove the need for miners to either (1) store all O(n) update keys or (2) interact during transaction validation to check update keys.

#### <span id="page-1-0"></span>1.1 Related Work

Vector Commitments (VCs). The notion of VCs appears early in [CFM08, LY10, KZG10] but Catalano and Fiore [CF13] are the first to formalize it. They introduce schemes based on the Computational Diffie-Hellman (CDH), with  $O(n^2)$ -sized public parameters, and on the RSA problem, with O(1)-sized public parameters, which can be specialized into O(n)-sized ones when needed. Lai and Malavolta [LM19] formalize subvector commitments (SVCs) and extend both constructions from [CF13] with constant-sized I-subvector proofs. Camenisch et al. [CDHK15] build VCs from KZG commitments [KZG10] to Lagrange polynomials (see Section 2.1) that are not only binding but also hiding. However, their scheme intentionally prevents aggregation of proofs as a security feature. Feist and Khovratovich [FK20] introduce a technique for precomputing all constant-sized evaluation proofs in KZG commitments when the evaluation points are all roots of unity. We use their technique to compute VC proofs fast. Chepurnoy et al. [CPZ18] instantiate VCs using multivariate polynomial commitments [PST13] but with logarithmic rather than constant-sized proofs. Then, they build the first efficient, account-based, stateless cryptocurrency on top of their scheme. Later on, Tomescu [Tom20] presents a very similar scheme but from univariate polynomial commitments [KZG10] which supports subvector proofs.

Boneh et al. [BBF19] instantiate VCs using hidden-order groups. They are the first to support aggregating multiple proofs (under certain conditions; see [BBF18, Sec. 5.2, p. 20]). They are also the first to have constant-sized public parameters, without the need to specialize them into O(n)-sized ones. However, their VC uses update hints (rather than keys), which is less suitable for stateless cryptocurrencies. Furthermore, they introduce key-value map commitments (KVCs), which support a larger set of positions from  $[0, 2^{2\lambda})$  rather than [0, n), where  $\lambda$  is a security parameter. They argue their KVC can be used for account-based stateless cryptocurrencies, but do not explore a construction in depth. Campanelli et al. [CFG<sup>+</sup>20] also formalize SVCs with a more powerful notion of infinite (dis) aggregation of proofs.

In contrast, our aSVC only supports "one hop" aggregation and does not support disaggregation. They also formalize a notion of updatable, distributed VCs as Verified Decentralized Storage (VDS). However, their use of hidden-order groups leads to larger concrete proof sizes. Both of their schemes have O(1)-sized public parameters and can compute all proofs efficiently in quasilinear time. One scheme supports update hints while the other supports update keys.

Concurrent with our work, Gorbunov et al. [GRWZ20] also formalize aSVCs with a stronger notion of cross-commitment aggregation. However, their formalization lacks (verifiable) update keys, which hides many complexities that arise in stateless cryptocurrencies (see Section 4.2.2). Their VC scheme extends [LY10] with (1) aggregating proofs into I-subvector proofs and (2) aggregating multiple I-subvector proofs with respect to different VCs into a single, constant-sized proof. However, this versatility comes at the cost of (1) losing the ability to precompute all proofs fast, (2) O(n)-sized update keys for updating proofs, and (3) O(n)-sized verification key. This makes it difficult to apply their scheme in a stateless cryptocurrency for payments such as Edrax [CPZ18]. Furthermore, Gorbunov et al. also enhance KZG-based VCs with proof aggregation, but they do not consider proof updates. Lastly, they show it is possible to aggregate I-subvector proofs across different commitments for KZG-based VCs.

Kohlweiss and Rial [KR13] extend VCs with zero-knowledge protocols for proving correct computation of a new commitment, for opening elements at secret positions, and for proving secret updates of elements at secret positions.

Stateless Cryptocurrencies. The concept of stateless validation appeared early in the cryptocurrency community [Mil12, Tod16, But17] and later on in the academic community [RMCI17, Dry19, CPZ18, BBF19, GRWZ20].

UTXO-based. Initial proposals for UTXO-based cryptocurrencies used Merkle hash trees [Mil12,Tod16,Dry19,CPZ18]. In particular, Dryja [Dry19] gives a beautiful Merkle forest construction that significantly reduces communication. Boneh et al. [BBF19] further reduce communication by using RSA accumulators [BdM94,LLX07].

Account-based. Reyzin et al. [RMCI17] introduce a Merkle-based construction for account-based stateless cryptocurrencies. Unfortunately, their construction relies on proof-serving nodes: every user sending coins has to fetch the recipient's Merkle proof from a node and include it with her own proof in the transaction. Edrax [CPZ18] obviates the need for proof-serving nodes by using a vector commitment (VC) with update keys (rather than update hints like Merkle trees). Nonetheless, proof-serving nodes can still be used to assist users who do not want to manually update their proofs (which is otherwise very fast). Unfortunately, Edrax's (non-aggregatable) proofs are logarithmic-sized and thus sub-optimal.

Gorbunov et al. [GRWZ20] introduce *Pointproofs*, a versatile VC scheme which can aggregate proofs across different commitments. They use this power to solve a slightly different problem: stateless block validation for smart contract executions (rather than for payments as in Edrax). Unfortunately, their approach requires miners to store a different commitment for each smart contract, or around 4.5 GBs of (dynamic) state in a system with  $10^8$  smart contracts. This could be problematic in applications such as sharded cryptocurrencies, where miners would have to download part of this large state from one another when switching shards. Lastly, the verification key in Pointproofs is O(n)-sized, which imposes additional storage requirements on miners. Furthermore, Gorbunov et al. do not discuss how to update nor precompute proofs efficiently. Instead they assume that all contracts have  $n \le 10^3$  memory locations and users can compute all proofs in  $O(n^2)$  time. In contrast, our aSVC can compute all proofs in  $O(n \log n)$  time [FK20]. Nonetheless, their approach is a very promising direction for supporting smart contracts in stateless cryptocurrencies.

Bonneau et al. [BMRS20] use recursively-composable, succinct non-interactive arguments of knowledge (SNARKs) [BSCTV14] for stateless validation. However, while block validators do not have to store the full state in their system, miners who propose blocks still have to. In contrast, in previous stateless cryptocurrencies (including ours), even miners who propose blocks are stateless.

## 2 Preliminaries

**Notation.**  $\lambda$  is our security parameter.  $\mathbb{G}_1, \mathbb{G}_2$  are groups of prime order p endowed with a pairing  $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$  [MVO91,Jou00]. (We assume symmetric pairings where  $\mathbb{G}_1 = \mathbb{G}_2$  for simplicity of exposition.)  $\mathbb{G}_?$  is a hidden-order group. We use multiplicative notation for all groups.  $\omega$  is a primitive nth root of unity in  $\mathbb{Z}_p$  [vzGG13a]. poly(·) is any function upper-bounded by some univariate polynomial.  $\operatorname{negl}(\cdot)$  is any negligible function.  $\log x$  and  $\lg x$  are shorthand for  $\log_2 x$ .  $[i,j] = \{i,i+1,\ldots,j-1,j\}$ , [0,n) = [0,n-1] and [n] = [1,n].  $\mathbf{v} = (v_i)_{i \in [0,n)}$  is a vector of size n with elements  $v_i \in \mathbb{Z}_p$ .

#### <span id="page-2-0"></span>2.1 Lagrange Polynomial Interpolation

Given n pairs  $(x_i, y_i)_{i \in [0,n)}$ , we can find or interpolate the unique polynomial  $\phi(X)$  of degree < n such that  $\phi(x_i) = y_i, \forall i \in [0,n)$  using Lagrange interpolation [BT04] in  $O(n \log^2 n)$  time [vzGG13b] as  $\phi(X) = \sum_{i \in [0,n)} \mathcal{L}_i(X) y_i$ , where

 $\mathcal{L}_i(X) = \prod_{j \in [0,n), j \neq i} \frac{X - x_j}{x_i - x_j}$ . Recall that a Lagrange polynomial  $\mathcal{L}_i(X)$  has the property that  $\mathcal{L}_i(x_i) = 1$  and  $\mathcal{L}_i(x_j) = 0$ ,  $\forall i, j \in [0,n)$  with  $j \neq i$ . Note that  $\mathcal{L}_i(X)$  is defined in terms of the  $x_i$ 's which, throughout this paper, will be either  $(\omega^i)_{i \in [0,n)}$  or  $(\omega^i)_{i \in I}, I \subset [0,n)$ .

## <span id="page-3-0"></span>2.2 KZG Polynomial Commitments

Kate, Zaverucha and Goldberg (KZG) proposed a constant-sized commitment scheme for degree n polynomials  $\phi(X)$ . Importantly, an evaluation proof for any  $\phi(a)$  is constant-sized and constant-time to verify; it does not depend in any way on the degree of the committed polynomial. KZG requires public parameters  $(g^{\tau^i})_{i \in [0,n]}$ , which can be computed via a decentralized MPC protocol [BGM17] that hides the trapdoor  $\tau$ . KZG is computationally-hiding under the discrete log assumption and computationally-binding under n-SDH [BB08].

**Committing.** Let  $\phi(X)$  denote a polynomial of degree  $d \leq n$  with coefficients  $c_0, c_1, \ldots, c_d$  in  $\mathbb{Z}_p$ . A KZG commitment to  $\phi(X)$  is a single group element  $C = \prod_{i=0}^d \left(g^{\tau^i}\right)^{c_i} = g^{\sum_{i=0}^d c_i \tau^i} = g^{\phi(\tau)}$ . Committing to  $\phi(X)$  takes  $\Theta(d)$  time.

**Proving One Evaluation.** To compute an evaluation proof that  $\phi(a) = y$ , KZG leverages the polynomial remainder theorem, which says  $\phi(a) = y \Leftrightarrow \exists q(X)$  such that  $\phi(X) - y = q(X)(X - a)$ . The proof is just a KZG commitment to q(X): a single group element  $\pi = g^{q(\tau)}$ . Computing the proof takes  $\Theta(d)$  time. To verify  $\pi$ , one checks (in constant time) if  $e(C/g^y, g) = e(\pi, g^\tau/g^a) \Leftrightarrow e(g^{\phi(\tau)-y}, g) = e(g^{q(\tau)}, g^{\tau-a}) \Leftrightarrow e(g, g)^{\phi(\tau)-y} = e(g, g)^{q(\tau)(\tau-a)} \Leftrightarrow \phi(\tau) - y = q(\tau)(\tau-a)$ .

Proving Multiple Evaluations. Given a set of points I and their evaluations  $\{\phi(i)\}_{i\in I}$ , KZG can prove all evaluations with a constant-sized batch proof rather than |I| individual proofs. The prover computes an accumulator polynomial  $a(X) = \prod_{i\in I}(X-i)$  in  $\Theta(|I|\log^2|I|)$  time and computes  $\phi(X)/a(X)$  in  $\Theta(d\log d)$  time, obtaining a quotient q(X) and remainder r(X). The batch proof is  $\pi_I = g^{q(\tau)}$ . To verify  $\pi_I$  and  $\{\phi(i)\}_{i\in I}$  against C, the verifier first computes a(X) from I and interpolates r(X) such that  $r(i) = \phi(i), \forall i \in I$  in  $\Theta(|I|\log^2|I|)$  time (see Section 2.1). Next, she computes  $g^{a(\tau)}$  and  $g^{r(\tau)}$ . Finally, she checks if  $e(C/g^{r(\tau)}, g) = e(g^{q(\tau)}, g^{a(\tau)})$ . We stress that batch proofs are only useful when  $|I| \leq d$ . Otherwise, if |I| > d, the verifier can interpolate  $\phi(X)$  directly from the evaluations, which makes verifying any  $\phi(i)$  trivial.

#### <span id="page-3-1"></span>2.3 Account-based Stateless Cryptocurrencies

In a stateless cryptocurrency based on VCs [CPZ18], there are miners running a permissionless consensus algorithm [Nak08] and users, numbered from 0 to n-1 who have accounts with a balance of coins. (n can be  $\infty$  if the VC is unbounded.) For simplicity of exposition, we do not give details on the consensus algorithm, on transaction signature verification nor on monetary policy. These all remain the same as in previous stateful cryptocurrencies.

The (Authenticated) State. The state is an authenticated data structure (ADS) mapping each user i's public key to their account balance  $\mathsf{bal}_i$ . (In practice, the mapping is also to a transaction counter  $c_i$ , which is necessary to avoid transaction replay attacks. We address this in Section 4.3.1.) Importantly, miners and users are stateless: they do not store the state, just its digest  $d_t$  at the latest block t they are aware of. Additionally, each user t stores a proof t for their account balance that verifies against t.

Miners. Despite miners being stateless, they can still validate transactions, assemble them into a new block, and propose that block. Specifically, a miner can verify every new transaction spends valid coins by checking the sending user's balance against the latest digest  $d_t$ . This requires each user i who sends coins to j to include her proof  $\pi_{i,t}$  in her transaction. Importantly, user i should not have to include the recipient's proof  $\pi_{j,t}$  in the transaction, since that would require interacting with proof-serving nodes (see Section 4.3.2)

Once the miner has a set V of valid transactions, he can use them to create the next block t+1 and propose it. The miner obtains this new block's digest  $d_{t+1}$  by "applying" all transactions in V to  $d_t$ . When other miners receive this new block t+1, they can validate its transactions from V against  $d_t$  and check that the new digest  $d_{t+1}$  was produced correctly from  $d_t$  by "reapplying" all the transactions from V.

Users. When creating a transaction tx for block t+1, user i includes her proof  $\pi_{i,t}$  for miners to verify she has sufficient balance. When she sees a new block t+1, she can update her proof  $\pi_{i,t}$  to a new proof  $\pi_{i,t+1}$ , which verifies against the new digest  $d_{t+1}$ . For this, she will look at all changes in balances  $(j, \Delta \mathsf{bal}_j)_{j \in J}$ , where J is the set of users with transactions in block t+1, and "apply" those changes to her proof. Similarly, miners can also update proofs of pending transactions which did not make it in block t and now need a proof w.r.t.  $d_{t+1}$ 

Users assume that the consensus mechanism produces correct blocks. As a result, they do *not* need to verify transactions in the block; they only need to update their own proof. Nonetheless, since block verification is stateless and fast, users could easily participate as block validators, should they choose to.

# <span id="page-4-0"></span>3 Aggregatable Subvector Commitment (aSVC) Schemes

In this section, we introduce the notion of aggregatable subvector commitments (aSVCs) as a natural extension to subvector commitments (SVCs) [LM19] where anybody can aggregate b proofs for individual positions into a single constant-sized subvector proof for those positions. Our formalization differs from previous work [BBF19, GRWZ20] in that it accounts for (static) update keys as the verifiable auxiliary information needed to update commitments and proofs. This is useful in distributed settings where the public parameters of the scheme are split amongst many participants, such as in stateless cryptocurrencies. In Section 3.3, we introduce an efficient aSVC construction with scalable updates from KZG commitments to Lagrange polynomials.

#### <span id="page-4-1"></span>3.1 aSVC API

Our API resembles the VC API by Chepurnoy et al. [CPZ18] and the SVC API by Lai and Malavolta [LM19], extended with an API for verifying update keys (see Section 4.2.2) and an API for aggregating proofs. Unlike [CPZ18], our VC.UpdateProof API receives both  $\mathsf{upk}_i$  and  $\mathsf{upk}_j$  as input. This is reasonable in the stateless setting, since each user has to store their  $\mathsf{upk}_i$  anyway and they extract  $\mathsf{upk}_j$  from the transactions (see Section 4).

VC.KeyGen $(1^{\lambda}, n) \to \text{prk}, \text{vrk}, (\text{upk}_j)_{j \in [0, n)}$ . Randomized algorithm that, given a security parameter  $\lambda$  and an upper-bound n on vector size, returns a proving key prk, a verification key vrk and update keys  $(\text{upk}_j)_{j \in [0, n)}$ .

VC.Commit(prk,  $\mathbf{v}$ )  $\to c$ . Deterministic algorithm that returns a commitment c to any vector  $\mathbf{v}$  of size  $\leq n$ .

VC.ProvePos(prk, I,  $\mathbf{v}$ )  $\to \pi_I$ . Deterministic algorithm that returns a proof  $\pi_I$  that  $\mathbf{v}_I = (v_i)_{i \in I}$  is the I-subvector of  $\mathbf{v}$ . For notational convenience, I can be either an index set  $I \subseteq [0, n)$  or an individual index  $I = i \in [0, n)$ .

VC. VerifyPos(vrk, c,  $\mathbf{v}_I$ , I,  $\pi_I$ )  $\to T/F$ . Deterministic algorithm that verifies the proof  $\pi_I$  that  $\mathbf{v}_I$  is the I-subvector of the vector committed in c. As before, I can be either an index set  $I \subseteq [0, n)$  or an individual index  $I = i \in [0, n)$ .

VC. Verify UPK  $(vrk, i, upk_i) \rightarrow T/F$ . Deterministic algorithm that verifies that  $upk_i$  is indeed the *i*th update key.

VC.UpdateComm $(c, \delta, j, \mathsf{upk}_j) \to c'$ . Deterministic algorithm that returns a new commitment c' to  $\mathbf{v'}$  obtained by updating  $v_j$  to  $v_j + \delta$  in the vector  $\mathbf{v}$  committed in c. Needs  $\mathsf{upk}_j$  associated with the updated position j.

VC.UpdateProof $(\pi_i, \delta, i, j, \mathsf{upk}_i, \mathsf{upk}_j) \to \pi'_i$ . Deterministic algorithm that updates an old proof  $\pi_i$  for the *i*th element  $v_i$ , given that the *j*th element was updated to  $v_j + \delta$ . Note that *i* can be equal to *j*.

VC.AggregateProofs $(I,(\pi_i)_{i\in I}) \to \pi_I$  Deterministic algorithm that, given proofs  $\pi_i$  for  $v_i, \forall i \in I$ , aggregates them into a succinct I-subvector proof  $\pi_I$ .

#### 3.2 aSVC Correctness and Security Definitions

We argue why our aSVC from Section 3 satisfies these definitions in Section 3.4.5.

**Definition 1 (Aggregatable SVC Scheme).** (VC.KeyGen, VC.Commit, VC.ProvePos, VC.VerifyPos, VC.VerifyUPK, VC.UpdateComm, VC.UpdateProof, VC.AggregateProofs) is a secure aggregatable subvector commitment scheme if  $\forall$  upper-bounds  $n = \text{poly}(\lambda)$  it satisfies the following properties:

**Definition 2 (Opening Correctness).**  $\forall$  vectors  $\mathbf{v} = (v_j)_{j \in [0,n)}$ ,  $\forall$  index sets  $I \subseteq [0,n)$ :

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ c \leftarrow \mathsf{VC}.\mathsf{Commit}(\mathsf{prk}, \mathbf{v}), \\ \pi_I \leftarrow \mathsf{VC}.\mathsf{ProvePos}(\mathsf{prk}, I, \mathbf{v}) : \\ \mathsf{VC}.\mathsf{VerifyPos}(\mathsf{vrk}, c, \mathbf{v}_I, I, \pi_I) = T \end{bmatrix} \geq 1 - \mathsf{negl}(\lambda)$$

**Definition 3 (Commitment and Proof Update Correctness).**  $\forall \ vectors \ \mathbf{v} = (v_j)_{j \in [0,n)}, \ \forall \ positions \ i,k \in [0,n), \ \forall \ updates \ \delta \in \mathbb{Z}_p, \ let \ \mathbf{u} = (u_j)_{j \in [0,n)} \ be \ the \ same \ vector \ as \ \mathbf{v} \ except \ with \ v_k + \delta \ rather \ than \ v_k \ at \ position \ k.$  Then:

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ c \leftarrow \mathsf{VC}.\mathsf{Commit}(\mathsf{prk}, \mathbf{v}), \\ \hat{c} \leftarrow \mathsf{VC}.\mathsf{UpdateComm}(c, \delta, k, \mathsf{upk}_k), \\ c' \leftarrow \mathsf{VC}.\mathsf{Commit}(\mathsf{prk}, \mathbf{u}) : \\ c' = \hat{c} \end{bmatrix} \geq 1 - \mathsf{negl}(\lambda)$$

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ c \leftarrow \mathsf{VC}.\mathsf{Commit}(\mathsf{prk}, \mathbf{v}), \\ c' \leftarrow \mathsf{VC}.\mathsf{UpdateComm}(c, \delta, k, \mathsf{upk}_k), \\ \pi_i \leftarrow \mathsf{VC}.\mathsf{ProvePos}(\mathsf{prk}, i, \mathbf{v}), \\ \pi'_i \leftarrow \mathsf{VC}.\mathsf{UpdateProof}(\pi_i, \delta, i, k, \mathsf{upk}_i, \mathsf{upk}_k) : \\ \mathsf{VC}.\mathsf{VerifyPos}(\mathsf{vrk}, c', u_i, i, \pi'_i) = T \end{bmatrix} \geq 1 - \mathsf{negI}(\lambda)$$

**Definition 4 (Aggregation Correctness).**  $\forall \ vectors \ \mathbf{v} = (v_j)_{j \in [0,n)}, \ \forall \ index \ sets \ I \subseteq [0,n)$ :

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ c \leftarrow \mathsf{VC}.\mathsf{Commit}(\mathsf{prk}, \mathbf{v}), \\ (\pi_i \leftarrow \mathsf{VC}.\mathsf{ProvePos}(\mathsf{prk}, i, \mathbf{v}))_{i \in I}, \\ \pi_I \leftarrow \mathsf{VC}.\mathsf{AggregateProofs}(I, (\pi_i)_{i \in I}) : \\ \mathsf{VC}.\mathsf{VerifyPos}(\mathsf{vrk}, c, \mathbf{v}_I, I, \pi_I) = T \end{bmatrix} \geq 1 - \mathsf{negl}(\lambda)$$

**Definition 5 (Update Key Correctness).**  $\forall$  positions  $i \in [0, n)$ :

$$\Pr\left[ \begin{array}{c} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n) : \\ \mathsf{VC}.\mathsf{VerifyUPK}(\mathsf{vrk}, i, \mathsf{upk}_i) = T \end{array} \right] \geq 1 - \mathsf{negl}(\lambda)$$

<span id="page-5-1"></span>**Definition 6 (Update Key Uniqueness).**  $\forall$  adversaries  $\mathcal{A}$  running in time  $poly(\lambda)$ :

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ i, \mathsf{upk}, \mathsf{upk}' \leftarrow \mathcal{A}(1^\lambda, \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_j)_{j \in [0,n)}) : \\ \mathsf{VC}.\mathsf{VerifyUPK}(\mathsf{vrk}, i, \mathsf{upk}) = T \land \\ \mathsf{VC}.\mathsf{VerifyUPK}(\mathsf{vrk}, i, \mathsf{upk}') = T \land \\ \mathsf{upk} \neq \mathsf{upk}' \end{bmatrix} \leq \mathsf{negl}(\lambda)$$

Observation: Definitions that allow for dynamic update hints rather than unique update keys are possible too, but would be less simple to state and less useful for stateless cryptocurrencies (see Section 4).

**Definition 7** (Position Binding Security).  $\forall$  adversaries  $\mathcal{A}$  running in time  $poly(\lambda)$ , if  $\mathbf{v}_I = (v_i)_{i \in I}$  and  $\mathbf{v}'_J = (v'_i)_{j \in J}$ , then:

$$\Pr \begin{bmatrix} \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_i)_{i \in [0,n)} \leftarrow \mathsf{VC}.\mathsf{KeyGen}(1^\lambda, n), \\ (c, I, J, \mathbf{v}_I, \mathbf{v}_J', \pi_I, \pi_J) \leftarrow \mathcal{A}(1^\lambda, \mathsf{prk}, \mathsf{vrk}, (\mathsf{upk}_i)_{i \in [0,n)}) : \\ \mathsf{VC}.\mathsf{VerifyPos}(\mathsf{vrk}, c, \mathbf{v}_I, I, \pi_I) = T \ \land \\ \mathsf{VC}.\mathsf{VerifyPos}(\mathsf{vrk}, c, \mathbf{v}_J', J, \pi_J) = T \ \land \\ \exists k \in I \cap J, \ such \ that \ v_k \neq v_k' \end{bmatrix} \leq \mathsf{negl}(\lambda)$$

#### <span id="page-5-0"></span>3.3 aSVC From KZG Commitments to Lagrange Polynomials

In this subsection, we present our aSVC from KZG commitments to Lagrange polynomials. Similar to previous work, we represent a vector  $\mathbf{v} = [v_0, v_1, \dots, v_{n-1}]$  as a polynomial  $\phi(X) = \sum_{i \in [0,n)} \mathcal{L}_i(X)v_i$  in Lagrange basis [KZG10,CDHK15, Tom20,GRWZ20]. However, unlike previous work, we add support for efficiently updating and aggregating proofs. For aggregation, we use known techniques for aggregating KZG proofs via partial fraction decomposition [But20]. For updating proofs, we introduce a new mechanism to reduce the update key size from linear to constant. We use roots of unity and "store"  $v_i$  as  $\phi(\omega^i) = v_i$ , which means our Lagrange polynomials are  $\mathcal{L}_i(X) = \prod_{j \in [0,n), j \neq i} \frac{X - \omega^j}{\omega^i - \omega^j}$ . For this to work efficiently, we assume without loss of generality that n is a power of two.

<span id="page-6-0"></span>Table 2. Asymptotic comparison of our aSVC with other (aS)VCs based on prime-order groups. n is the vector size and b is the subvector size. See Appendix D for a more detailed analysis. All schemes have O(n)-sized parameters (except [LM19] has  $O(n^2)$  and [CFG<sup>+</sup>20] has O(1)); can update commitments in O(1) time (except for [KZG10]); have O(1)-sized proofs that verify in O(1) time (except [CPZ18] and [Tom20] proofs are  $O(\lg n)$ ). Com. is the time to commit to a size-n vector. Proof upd. is the time to update one individual proof  $\pi_i$  after a change to one vector element  $v_j$ . Prove one, Prove subv. and Prove each are the times to compute a proof  $\pi_i$  for one  $v_i$ , a size-b subvector proof  $\pi_I$  and proofs for all  $(v_i)_{i \in [0,n)}$ , respectively.

| (aS)VC<br>scheme                | vrk         | $ upk_i $ | Com.        | Prove<br>one | Proof upd. | Prove subv.         |             | Aggr-<br>egate |           |
|---------------------------------|-------------|-----------|-------------|--------------|------------|---------------------|-------------|----------------|-----------|
| [LM19]                          | n           | n         | n           | n            | 1          | bn                  | b           | ×              | $n^2$     |
| [KZG10]                         | b           | X         | $n\lg^2 n$  | n            | X          | $b\lg^2 b + n\lg n$ | $b \lg^2 b$ | ×              | $n^2$     |
| [CDHK15]                        | n           | n         | $n \lg^2 n$ | n            | 1          | $n \lg^2 n$         | $b \lg^2 b$ | ×              | $n^2$     |
| [CPZ18]                         | $\lg n$     | $\lg n$   | n           | n            | $\lg n$    | ×                   | ×           | ×              | $n^2$     |
| [Tom 20]                        | $\lg n + b$ | $\lg n$   | $n \lg n$   | $n \lg n$    | $\lg n$    | $b\lg^2 b + n\lg n$ | $b \lg^2 b$ | ×              | $n \lg n$ |
| [GRWZ20]                        | n           | n         | n           | n            | 1          | bn                  | b           | b              | $n^2$     |
| $[CFG^+20]$                     | 1           | 1         | $n \lg n$   | $n \lg n$    | 1          | $(n-b)\lg(n-b)$     | b           | $b\lg^2 b$     | $n \lg n$ |
| Our work                        | b           | 1         | n           | n            | 1          | $b\lg^2 b + n\lg n$ | $b \lg^2 b$ | $b \lg^2 b$    | $n \lg n$ |
| $\mathbf{Our}\ \mathbf{work}^*$ | b           | 1         | $n \lg n$   | 1            | 1          | $b\lg^2 b$          |             | $b \lg^2 b$    |           |

Committing. A commitment to  $\mathbf{v}$  is just a KZG commitment  $c = g^{\phi(\tau)}$  to  $\phi(X)$ , where  $\tau$  is the trapdoor of the KZG scheme (see Section 2.2). Similar to previous work [CDHK15], the proving key includes commitments to all Lagrange polynomials  $\ell_i = g^{\mathcal{L}_i(\tau)}$ . Thus, we can compute  $c = \prod_{i=1}^n (\ell_i)^{v_i}$  in O(n) time without interpolating  $\phi(X)$  and update it as  $c' = c \cdot (\ell_i)^{\delta}$  after adding  $\delta$  to  $v_i$ . Note that c' is just a commitment to an updated  $\phi'(X) = \phi(X) + \delta \cdot \mathcal{L}_i(X)$ .

**Proving.** A proof  $\pi_i$  for a single element  $v_i$  is just a KZG evaluation proof for  $\phi(\omega^i)$ . A subvector proof  $\pi_I$  for  $v_I, I \subseteq [0, n)$  is just a KZG batch proof for all  $\phi(\omega^i)_{i \in I}$  evaluations. Importantly, we use the Feist-Khovratovich (FK) [FK20] technique to compute all proofs  $(\pi_i)_{i \in [0,n)}$  in  $O(n \log n)$  time. This allows us to aggregate I-subvector proofs faster in  $O(|I|\log^2|I|)$  time (see Table 2).

#### <span id="page-6-1"></span>3.4 Partial Fraction Decomposition

A key ingredient in our aSVC scheme is partial fraction decomposition [Wik19], which we re-explain from the perspective of Lagrange interpolation. First, let us rewrite the Lagrange polynomial for interpolating  $\phi(X)$  given all  $(\phi(\omega^i))_{i \in I}$ :

$$\mathcal{L}_i(X) = \prod_{j \in I, j \neq i} \frac{X - \omega^j}{\omega^i - \omega^j} = \frac{A_I(X)}{A_I'(\omega^i)(X - \omega^i)}, \text{ where } A_I(X) = \prod_{i \in I} (X - \omega^i)$$
 (1)

Here,  $A_I'(X) = \sum_{j \in I} A_I(X)/(X - \omega^j)$  is the derivative of  $A_I(X)$  [vzGG13b]. Next, for any  $\phi(X)$ , we can rewrite the Lagrange interpolation formula as  $\phi(X) = A_I(X) \sum_{i \in [0,n)} \frac{y_i}{A_I'(\omega^i)(X - \omega^i)}$ . In particular, for  $\phi(X) = 1$ , this implies  $\frac{1}{A_I(X)} = \sum_{i \in [0,n)} \frac{1}{A_I'(\omega^i)(X - \omega^i)}$ . In other words, we can decompose  $A_I(X)$  as:

$$\frac{1}{A_I(X)} = \frac{1}{\prod_{i \in I} (X - \omega^i)} = \sum_{i \in [0, n)} c_i \cdot \frac{1}{X - \omega^i}, \text{ where } c_i = \frac{1}{A'_I(\omega^i)}$$
 (2)

 $A_I(X)$  can be computed in  $O(|I|\log^2|I|)$  time using a subproduct tree and DFT-based polynomial multiplication [vzGG13b]. Its derivative,  $A_I'(X)$ , can be computed in O(|I|) time and evaluated at all  $\omega^i$ 's in  $O(|I|\log^2|I|)$  time [vzGG13b]. Thus, all  $c_i$ 's can be computed in  $O(|I|\log^2|I|)$  time. For the special case of I=[0,n), we have  $A_I(X)=A(X)=\prod_{i\in[0,n)}(X-\omega^i)=X^n-1$  and  $A'(\omega^i)=n\omega^{-i}$  (see Appendix A). In this case, any  $c_i$  can be computed in O(1) time.

#### <span id="page-6-2"></span>3.4.1 Aggregating Proofs

We build upon Drake and Buterin's observation [But20] that partial fraction decomposition (see Section 3.4) can be used to aggregate KZG evaluation proofs. Since our VC proofs are KZG proofs, we show how to aggregate a set of proofs  $(\pi_i)_{i\in I}$  for elements  $v_i$  of  $\mathbf{v}$  into a constant-sized I-subvector proof  $\pi_I$  for  $(v_i)_{i\in I}$ .

Recall that  $\pi_i$  is a commitment to  $q_i(X) = \frac{\phi(X) - v_i}{X - \omega^i}$  and  $\pi_I$  is a commitment to  $q(X) = \frac{\phi(X) - R(X)}{A_I(X)}$ , where  $A_I(X) = \prod_{i \in I} (X - \omega^i)$  and R(X) is interpolated such that  $R(\omega^i) = v_i, \forall i \in I$ . Our goal is to find coefficients  $c_i \in \mathbb{Z}_p$ 

such that  $q(X) = \sum_{i \in I} c_i q_i(X)$  and thus aggregate  $\pi_I = \prod_{i \in I} \pi_i^{c_i}$ . We observe that:

$$q(X) = \phi(X) \frac{1}{A_I(X)} - R(X) \frac{1}{A_I(X)}$$
(3)

$$= \phi(X) \sum_{i \in I} \frac{1}{A'_I(\omega^i)(X - \omega^i)} - \left( A_I(X) \sum_{i \in I} \frac{v_i}{A'_I(\omega^i)(X - \omega^i)} \right) \cdot \frac{1}{A_I(X)}$$
(4)

$$= \sum_{i \in I} \frac{\phi(X)}{A'_I(\omega^i)(X - \omega^i)} - \sum_{i \in I} \frac{v_i}{A'_I(\omega^i)(X - \omega^i)} = \sum_{i \in I} \frac{1}{A'_I(\omega^i)} \cdot \frac{\phi(X) - v_i}{X - \omega^i}$$
 (5)

$$= \sum_{i \in I} \frac{1}{A'_I(\omega^i)} \cdot q_i(X) \tag{6}$$

Thus, we can compute all  $c_i = 1/A_I'(\omega^i)$  using  $O(|I|\log^2|I|)$  field operations (see Section 3.4) and compute  $\pi_I = \prod_{i \in I} \pi_i^{c_i}$  with an O(|I|)-sized multi-exponentiation.

## <span id="page-7-0"></span>3.4.2 Updating Proofs

When updating  $\pi_i$  after a change to  $v_j$ , it could be that either i=j or  $i\neq j$ . First, recall that  $\pi_i$  is a KZG commitment to  $q_i(X)=\frac{\phi(X)-v_i}{X-\omega^i}$ . Second, recall that, after a change  $\delta$  to  $v_j$ , the polynomial  $\phi(X)$  is updated to  $\phi'(X)=\phi(X)+\delta\cdot\mathcal{L}_j(X)$ . We refer to the party updating their proof  $\pi_i$  as the *proof updater*.

The i = j Case. Consider the quotient polynomial  $q'_i(X)$  in the updated proof  $\pi'_i$  after  $v_i$  changed to  $v_i + \delta$ :

$$q_i'(X) = \frac{\phi'(X) - (v_i + \delta)}{X - \omega^i} = \frac{(\phi(X) + \delta \mathcal{L}_i(X)) - v_i - \delta}{X - \omega^i}$$

$$(7)$$

$$= \frac{\phi(X) - v_i}{X - \omega^i} + \frac{\delta(\mathcal{L}_i(X) - 1)}{X - \omega^i} = q_i(X) + \delta\left(\frac{\mathcal{L}_i(X) - 1}{X - \omega^i}\right)$$
(8)

This means the proof updater needs a KZG commitment to  $\frac{\mathcal{L}_i(X)-1}{X-\omega^i}$ , which is just a KZG evaluation proof that  $\mathcal{L}_i(\omega^i)=1$ . This can be addressed very easily by making this commitment part of  $\operatorname{upk}_i$ . To conclude, to update  $\pi_i$ , the proof updater obtains  $u_i=g^{\frac{\mathcal{L}_i(\tau)-1}{\tau-\omega^i}}$  from  $\operatorname{upk}_i$  and computes  $\pi_i'=\pi_i\cdot(u_i)^\delta$ . (Remember that the proof updater, who calls VC.UpdateProof $(\pi_i,\delta,i,i,\operatorname{upk}_i,\operatorname{upk}_i)$ , has  $\operatorname{upk}_i$ .)

The  $i \neq j$  Case. Now, consider the quotient polynomial  $q'_i(X)$  after  $v_j$  changed to  $v_j + \delta$ :

$$q_i'(X) = \frac{\phi'(X) - v_i}{X - \omega^i} = \frac{(\phi(X) + \delta \mathcal{L}_j(X)) - v_i}{X - \omega^i}$$

$$\tag{9}$$

$$= \frac{\phi(X) - v_i}{X - \omega^i} + \frac{\delta \mathcal{L}_j(X)}{X - \omega^i} = q_i(X) + \delta \left(\frac{\mathcal{L}_j(X)}{X - \omega^i}\right)$$
(10)

In this case, the proof updater will need to construct a KZG commitment to  $\frac{\mathcal{L}_j(X)}{X-\omega^i}$ . For this, we put enough information in  $\mathsf{upk}_i$  and  $\mathsf{upk}_j$ , which the proof updater has (see Section 3.1), to help her do so.

Since  $U_{i,j}(X) = \frac{A(X)}{A'(\omega^j)(X-\omega^j)(X-\omega^i)}$  and  $A'(\omega^j) = n\omega^{-j}$  (see Appendix A), it is sufficient to reconstruct a KZG commitment to  $W_{i,j}(X) = \frac{A(X)}{(X-\omega^j)(X-\omega^i)}$ , which can be decomposed as  $W_{i,j}(X) = A(X)\left(c_i\frac{1}{X-\omega^i} + c_j\frac{1}{X-\omega_j}\right) = c_i\frac{A(X)}{X-\omega^i} + c_j\frac{A(X)}{X-\omega^j}$ , where  $c_i = 1/(\omega^i - \omega^j)$  and  $c_j = 1/(\omega^j - \omega^i)$  (see Section 3.4). Thus, if we include  $a_j = g^{A(\tau)/(\tau-\omega^j)}$  in each  $\operatorname{upk}_j$ , the proof updater can first compute  $w_{i,j} = a_i^{c_i}a_j^{c_j}$ , then compute  $u_{i,j} = (w_{i,j})^{\frac{1}{A'(\omega^j)}}$  and finally update the proof as  $\pi'_i = \pi_i \cdot (u_{i,j})^{\delta}$ .

#### <span id="page-7-1"></span>3.4.3 aSVC Algorithms

Having established the intuition for our aSVC, we can now describe it in detail using the aSVC API from Section 3.1. To support verifying I-subvector proofs, our verification key is O(|I|)-sized.

 $\begin{aligned} & \text{VC.KeyGen}(1^{\lambda}, n) \ \rightarrow \ \text{prk}, \text{vrk}, (\text{upk}_j)_{j \in [0, n)}. \ \text{Generates} \ n\text{-SDH} \ \text{public parameters} \ g, g^{\tau}, g^{\tau^2}, \dots, g^{\tau^n}. \ \text{Computes} \ a = g^{A(\tau)}, \text{ where} \ A(X) = X^n - 1. \ \text{Computes} \ a_i = g^{A(\tau)/(X - \omega^i)} \ \text{and} \ \ell_i = g^{\mathcal{L}_i(\tau)}, \forall i \in [0, n). \ \text{Computes} \ \text{KZG proofs} \ u_i = g^{\frac{\mathcal{L}_i(\tau) - 1}{X - \omega^i}} \ \text{for} \ \mathcal{L}_i(\omega^i) = 1. \ \text{Sets} \ \text{upk}_i = (a_i, u_i), \ \text{prk} = \left((g^{\tau^i})_{i \in [0, n]}, (\ell_i)_{i \in [0, n)}, \ (\text{upk}_i)_{i \in [0, n)}\right) \ \text{and} \ \text{vrk} = \left((g^{\tau^i})_{i \in [0, |I|]}, a\right). \end{aligned}$ 

VC.Commit(prk,  $\mathbf{v}$ )  $\to c$ . Returns  $c = \prod_{i \in [0,n)} (\ell_i)^{v_i}$ .

VC.ProvePos(prk,  $I, \mathbf{v}$ )  $\to \pi_I$ . Computes  $A_I(X) = \prod_{i \in I} (X - \omega^i)$  in  $O(|I| \log^2 |I|)$  time. Divides  $\phi(X)$  by  $A_I(X)$  in  $O(n \log n)$  time, obtaining a quotient q(X) and a remainder r(X). Returns  $\pi_I = g^{q(\tau)}$ . (We give an O(n) time algorithm in Appendix D.7 for the |I| = 1 case.)

VC. VerifyPos(vrk,  $c, \mathbf{v}_I, I, \pi_I$ )  $\to T/F$ . Computes  $A_I(X) = \prod_{i \in I} (X - \omega^i)$  in  $O(|I| \log^2 |I|)$  time and commits to it as  $g^{A_I(\tau)}$  in O(|I|) time. Interpolates  $R_I(X)$  such that  $R_I(i) = v_i, \forall i \in I$  in  $O(|I| \log^2 |I|)$  time and commits to it as  $g^{R_I(\tau)}$  in O(|I|) time. Returns T iff.  $e(c/g^{R_I(\tau)}, g) = e(\pi_I, g^{A_I(\tau)})$ . (When  $I = \{i\}$ , we have  $A_I(X) = X - \omega^i$  and  $R_I(X) = v_i$ .)

VC.VerifyUPK(vrk, i, upk $_i$ )  $\to T/F$ . Checks that  $\omega^i$  is a root of  $X^n-1$  (which is committed in a) via  $e(a_i, g^{\tau}/g^{(\omega^i)}) = e(a, g)$ . Checks that  $\mathcal{L}_i(\omega^i) = 1$  via  $e(\ell_i/g^1, g) = e(u_i, g^{\tau}/g^{(\omega^i)})$ , where  $\ell_i = a_i^{1/A'(\omega^i)} = g^{\mathcal{L}_i(\tau)}$ .

VC.UpdateComm $(c, \delta, j, \mathsf{upk}_j) \to c'$ . Returns  $c' = c \cdot (\ell_j)^{\delta}$ , where  $\ell_j = a_i^{1/A'(\omega^j)}$ .

VC.UpdateProof $(\pi_i, \delta, i, j, \mathsf{upk}_i, \mathsf{upk}_j) \to \pi'_i$ . If i = j, returns  $\pi'_i = \pi_i \cdot (u_i)^{\delta}$ . If  $i \neq j$ , computes  $w_{i,j} = a_i^{1/(\omega^i - \omega^j)} \cdot a_j^{1/(\omega^j - \omega^i)}$  and  $u_{i,j} = w_{i,j}^{1/A'(\omega^j)}$  (see Section 3.4.2) and returns  $\pi'_i = \pi_i \cdot (u_{i,j})^{\delta}$ .

VC.AggregateProofs $(I, (\pi_i)_{i \in I}) \to \pi_I$ . Computes  $A_I(X) = \prod_{i \in I} (X - \omega^i)$ , its derivative  $A'_I(X)$  and all  $c_i = (A'_I(\omega^i))_{i \in I}$  in  $O(|I| \log^2 |I|)$  time. Returns  $\pi_I = \prod_{i \in I} \pi_i^{c_i}$ .

## <span id="page-8-1"></span>3.4.4 Distributing the Trusted Setup

Our aSVC requires a centralized, trusted setup phase that computes its public parameters. We can decentralize this phase using highly-efficient MPC protocols that generate  $(g^{\tau^i})$ 's in a distributed fashion [BGM17]. Then, we can derive the remaining parameters from the  $(g^{\tau^i})$ 's, which has the advantage of keeping our parameters updatable. First, the commitment  $a=g^{A(\tau)}$  to  $A(X)=X^n-1$  can be computed in O(1) time via an exponentiation. Second, the commitments  $\ell_i=g^{\mathcal{L}_i(\tau)}$  to Lagrange polynomials can be computed via a single DFT on the  $(g^{\tau^i})$ 's [Vir17, Sec 3.12.3, pg. 97]. Third, each  $a_i=g^{A(\tau)/(\tau-\omega^i)}$  is a bilinear accumulator membership proof for  $\omega^i$  w.r.t. A(X) and can all be computed in  $O(n\log n)$  time using FK [FK20]. But what about computing each  $u_i=g^{\frac{\mathcal{L}_i(\tau)-1}{X-\omega^i}}$ ?

Computing All  $u_i$ 's Fast. Inspired by the FK technique [FK20], we show how to compute all n  $u_i$ 's in  $O(n \log n)$  time using a single DFT on group elements. First, note that  $u_i = g^{\frac{\mathcal{L}_i(\tau)-1}{X-\omega^i}}$  is a KZG evaluation proof for  $\mathcal{L}_i(\omega^i) = 1$ . Thus,  $u_i = g^{Q_i(\tau)}$  where  $Q_i(X) = \frac{\mathcal{L}_i(X)-1}{X-\omega^i}$ . Second, let  $\psi_i(X) = A'(\omega^i)\mathcal{L}_i(X) = \frac{X^n-1}{X-\omega^i}$ . Then, let  $\pi_i = g^{q_i(\tau)}$  be an evaluation proof for  $\psi_i(\omega^i) = A'(\omega^i)$  where  $q_i(X) = \frac{\psi_i(X)-A'(\omega^i)}{X-\omega^i}$  and note that  $Q_i(X) = \frac{1}{A'(\omega^i)}q_i(X)$ . Thus, computing all  $u_i$ 's reduces to computing all  $\pi_i$ 's. However, since each proof  $\pi_i$  is for a different polynomial  $\psi_i(X)$ , directly applying FK does not work. Instead, we give a new algorithm that leverages the structure of  $\psi_i(X)$  when divided by  $X - \omega^i$ . Specifically, in Appendix B, we show that:

$$q_i(X) = \sum_{j \in [0, n-2]} H_j(X)\omega^{ij}, \forall i \in [0, n), \text{ where } H_j(X) = (j+1)X^{(n-2)-j}$$
(11)

If we let  $h_j$  be a KZG commitment to  $H_j(X)$ , then we have  $\pi_i = \prod_{j \in [0, n-2]} h_j^{(\omega^{ij})}$ ,  $\forall i \in [0, n)$ . Next, recall that the Discrete Fourier Transform (DFT) on a vector of group elements  $\mathbf{a} = [a_0, a_1, \dots, a_{n-1}] \in \mathbb{G}^n$  is:

<span id="page-8-2"></span>
$$\mathsf{DFT}_n(\mathbf{a}) = \hat{\mathbf{a}} = [\hat{a}_0, \hat{a}_1, \dots, \hat{a}_{n-1}] \in \mathbb{G}^n, \text{ where } \hat{a}_i = \prod_{j \in [0, n)} a_j^{(\omega^{ij})}$$

$$\tag{12}$$

If we let  $\pi = [\pi_0, \pi_1, \dots, \pi_{n-1}]$  and  $\mathbf{h} = [h_0, h_1, \dots, h_{n-2}, 1_{\mathbb{G}}, 1_{\mathbb{G}}]$ , then  $\pi = \mathsf{DFT}_{\mathsf{n}}(\mathbf{h})$ . Thus, computing all n  $h_i$ 's takes O(n) time and computing all n  $\pi_i$ 's takes an  $O(n \log n)$  time DFT. As a result, computing all  $u_i$ 's from the  $(g^{\tau^i})$ 's takes  $O(n \log n)$  time overall.

#### <span id="page-8-0"></span>3.4.5 Correctness and Security

The correctness of our aSVC scheme follows naturally from Lagrange interpolation. Aggregation and proof updates are correct by the arguments laid out in Sections 3.4.1 and 3.4.2, respectively. Subvector proofs are correct by the correctness of KZG batch proofs [KZG10].

The security of our aSVC schemes does *not* follow naturally from the security of KZG polynomial commitments. Specifically, as pointed out in [GRWZ20], two inconsistent subvector proofs do *not* lead to a direct break of KZG's batch evaluation binding, as defined in [KZG10, Sec. 3.4]. To address this, we propose a stronger batch evaluation

binding definition (see Definition [8](#page-16-0) in Appendix [C.1\)](#page-16-1) and prove KZG satisfies it under n-SBDH. This new definition is directly broken by two inconsistent subvector proofs, which implies our aSVC is secure under n-SBDH. Lastly, we prove update key uniqueness holds unconditionally in Appendix [C.2.](#page-17-0)

# <span id="page-9-1"></span>4 A Highly-efficient Stateless Cryptocurrency

In this section, we enhance Edrax's elegant design by replacing their VC with our secure aggregatable subvector commitment (aSVC) scheme from Section [3.3.](#page-5-0) As a result, our stateless cryptocurrency has smaller, aggregatable proofs and smaller update keys. This leads to smaller, faster-to-verify blocks for miners and faster proof synchronization for users (see Table [1\)](#page-1-1). Furthermore, our verifiable update keys reduce the storage overhead of miners from O(n) update keys to O(1). We also address a denial of service (DoS) attack in Edrax's design.

## <span id="page-9-0"></span>4.1 From VCs to Stateless Cryptocurrencies

Edrax pioneered the idea of building account-based, stateless cryptocurrencies on top of any VC scheme [\[CPZ18\]](#page-13-2). In contrast, previous approaches were based on authenticated dictionaries (ADs) [\[RMCI17,](#page-13-1) [But17\]](#page-13-6), for which efficient constructions with static update keys are not known. In other words, these AD-based approaches used dynamic update hints uph<sup>j</sup> consisting of the proof for position j. This complicated their design, requiring user i to ask a proof-serving node for user j's proof in order to create a transaction sending money to j.

Trusted Setup. To support up to n users, public parameters (prk, vrk, (upk<sup>i</sup> )i∈[0,n)) ← VC.KeyGen(1<sup>λ</sup> , n) are generated via a trusted setup, which can be decentralized using MPC protocols [\[BGM17\]](#page-13-27). Miners need to store all O(n) update keys to propose blocks and to validate blocks (which we fix in Section [4.2.2\)](#page-10-0). The prk is only needed for proof-serving nodes (see Section [4.3.2\)](#page-12-0).

The (Authenticated) State. The state is a vector v = (vi)i∈[0,n) of size n that maps user i to v<sup>i</sup> = (addr<sup>i</sup> |bali) ∈ Zp, where bal<sup>i</sup> is her balance and addr<sup>i</sup> is her address, which we define later. (We discuss including transaction counters for preventing replay attacks in Section [4.3.1.](#page-11-0)) Importantly, since p ≈ 2 <sup>256</sup>, the first 224 bits of v<sup>i</sup> are used for addr<sup>i</sup> and the last 32 bits for bal<sup>i</sup> . The genesis block's state is the all zeros vector with digest d<sup>0</sup> (e.g., in our aSVC, d<sup>0</sup> = g 0 ). Initially, each user i is unregistered and starts with a proof πi,<sup>0</sup> that their v<sup>i</sup> = 0.

"Full" vs. "Traditional" Public Keys. User i's address is computed as addr<sup>i</sup> = H(FPKi), where FPK<sup>i</sup> = (i, upk<sup>i</sup> ,tpk<sup>i</sup> ) is her full public key and H is a collision-resistant hash function. Here, tpk<sup>i</sup> denotes a "traditional" public key for a digital signature scheme, with corresponding secret key tsk<sup>i</sup> used to authorize user i's transactions. To avoid confusion, we will clearly refer to public keys as either "full" or "traditional."

Registering via INIT Transactions. INIT transactions are used to register new users and assign them a unique, ever-increasing number from 1 to n. For this, each block t stores a count of users registered so far cntt. To register, a user generates a traditional secret key tsk with a corresponding traditional public key tpk. Then, she broadcasts an INIT transaction:

$$\mathsf{tx} = [\mathtt{INIT}, \mathsf{tpk}]$$

A miner working on block t + 1 who receives tx, proceeds as follows.

- 1. He sets i = cntt+1 and increments the count cntt+1 of registered users,
- 2. He updates the VC via dt+1 = VC.UpdateComm(dt+1,(addr<sup>i</sup> |0), i, upk<sup>i</sup> ),
- 3. He incorporates tx in block t + 1 as tx<sup>0</sup> = [INIT,(i, upk<sup>i</sup> ,tpk<sup>i</sup> )] = [INIT, FPK<sup>i</sup> ].

The full public key with upk<sup>i</sup> is included so other users can correctly update their VC when they process tx<sup>0</sup> . (The index i is not necessary, since it can be computed from the block's cntt+1 and the number of INIT transactions processed in the block so far.) Note that to compute addr<sup>i</sup> = H(FPKi), the miner needs to have the correct upk<sup>i</sup> which requires O(n) storage. We discuss how to avoid this in Section [4.2.2.](#page-10-0)

Transferring Coins via SPEND Transactions. When transferring v coins to user j, user i (who has v <sup>0</sup> ≥ v coins) must first obtain FPK<sup>j</sup> = (j, upk<sup>j</sup> ,tpk<sup>j</sup> ). This is similar to existing cryptocurrencies, except the (full) public key is now slightly larger. Then, user i broadcasts a SPEND transaction, signed with her tsk<sup>i</sup> :

$$\mathsf{tx} = [\mathtt{SPEND}, t, \mathsf{FPK}_i, j, \mathsf{upk}_j, v, \pi_{i,t}, v']$$

A miner working on block t + 1 processes this SPEND transaction as follows:

- 1. He checks that  $v \leq v'$  and verifies the proof  $\pi_{i,t}$  that user i has v' coins via VC.VerifyPos(vrk,  $d_t$ , (addr $_i|v'$ ), i,  $\pi_{i,t}$ ). (If the miner receives another transaction from user i, it needs to carefully account for i's new v' v balance.)
- 2. He updates i's balance in block t+1 with  $d_{t+1} = \mathsf{VC.UpdateComm}(d_{t+1}, -v, i, \mathsf{upk}_i)$ , which only sets the lower order bits of  $v_i$  corresponding to  $\mathsf{bal}_i$ , without touching the higher order bits for  $\mathsf{addr}_i$ .
- 3. He does the same for j with  $d_{t+1} = VC.UpdateComm(d_{t+1}, +v, j, upk_j)$ .

Validating Blocks. Suppose a miner receives a new block t+1 with digest  $d_{t+1}$  that has b SPEND transactions:

$$\mathsf{tx} = [\mathtt{SPEND}, t, \mathsf{FPK}_i, j, \mathsf{upk}_j, v, \pi_{i,t}, v']$$

To validate this block, the miner (who has  $d_t$ ) proceeds in three steps (INIT transactions can be handled analogously):

Step 1: Check Balances. First, for each tx, he checks that  $v \le v'$  and that user i has balance v' via VC.VerifyPos(vrk,  $d_t$ ,  $(\mathsf{addr}_i|v'), i, \pi_{i,t}) = T$ . Since the sending user i might have multiple transactions in the block, the miner has to carefully keep track of each sending user's balance to ensure it never goes below zero.

Step 2: Check Digest. Second, he checks  $d_{t+1}$  has been computed correctly from  $d_t$  and from the new transactions in block t+1. Specifically, he sets  $d'=d_t$  and for each tx, he computes  $d'=VC.UpdateComm(d',-v,i,upk_i)$  and  $d'=VC.UpdateComm(d',+v,j,upk_i)$ . Then, he checks that  $d'=d_{t+1}$ .

Step 3: Update Proofs, If Any. If the miner lost the race to build block t+1, he can start mining block t+2 by "moving over" the SPEND transactions from his unmined block. For this, he updates all proofs in those SPEND transactions, so they are valid against the new digest  $d_{t+1}$ . Similarly, the miner must also "move over" all INIT transactions, since block t+1 might have registered new users.

User Proof Synchronization. Consider a user i who has processed the ledger up to time t and has digest  $d_t$  and proof  $\pi_{i,t}$ . Eventually, she receives a new block t+1 with digest  $d_{t+1}$  and needs to update her proof so it verifies against  $d_{t+1}$ . Initially, she sets  $\pi_{i,t+1} = \pi_{i,t}$ . For each [INIT, FPK $_j$ ] transaction, she updates her proof  $\pi_{i,t+1} = \text{VC.UpdateProof}(\pi_{i,t+1}, (H(\text{FPK}_j)|0), i, j, \text{upk}_i, \text{upk}_j)$ . For each [SPEND, t, FPK $_j$ , t, upk $_i$ , t, t, upk $_i$ , t, when t is the updates her proof twice:  $\pi_{i,t+1} = \text{VC.UpdateProof}(\pi_{i,t+1}, -v, i, j, \text{upk}_i, \text{upk}_j)$  and  $\pi_{i,t+1} = \text{VC.UpdateProof}(\pi_{i,t+1}, +v, i, k, \text{upk}_i, \text{upk}_k)$ . We stress that users can safely be offline and miss new blocks. Eventually, when a user comes back online, she downloads the missed blocks, updates her proof and is ready to transact.

#### 4.2 Efficient Stateless Cryptocurrencies from aSVCs

In this subsection, we explain how replacing the Edrax VC with our aSVC from Section 3.3 results in a more efficient stateless cryptocurrency (see Table 1). Then, we address a denial of service attack on user registrations in Edrax.

#### 4.2.1 Smaller, Faster, Aggregatable Proofs

Our aSVC enables miners to aggregate all b proofs in a block of b transactions into a single, constant-sized proof. This drastically reduces Edrax's per-block proof overhead from  $O(b \log n)$  group elements to just one group element. Unfortunately, the b update keys cannot be aggregated, but we still reduce their overhead from  $O(b \log n)$  to b group elements per block (see Section 4.2.3). Our smaller proofs are also faster to update, taking O(1) time rather than  $O(\log n)$ . While verifying an aggregated proof in our aSVC is  $O(b \log^2 b)$  time, which is asymptotically slower than the O(b) time for verifying b individual ones, it is still concretely faster as it only requires two, rather than O(b), cryptographic pairings. This makes validating new blocks much faster in practice.

#### <span id="page-10-0"></span>4.2.2 Reducing Miner Storage Using Verifiable Update Keys

We stress that miners must validate update keys before using them to update a digest. Otherwise, they risk corrupting that digest, which results in a denial of service. Edrax miners sidestep this problem by simply storing all O(n) update keys. Alternatively, Edrax proposes outsourcing update keys to an untrusted third party via a static Merkle tree. Unfortunately, this would either require interaction during block proposal and block validation or would double the update key size. For example, miners would need to fetch the correct update key and/or its Merkle proof to process a SPEND transaction. Our implicitly-verifiable update keys avoid these pitfalls, since miners can directly verify the update keys in a SPEND transaction via VC.VerifyUPK. Furthermore, for INIT transactions, miners can fetch (in the background) a running window of the update keys needed for the next k registrations. By carefully upper-bounding the number of registrations expected in the near future, we can avoid interaction during the block proposal. This background fetching could be implemented in Edrax too, either with a small overhead via Merkle proofs or by making their update keys verifiable (which seems possible).

## <span id="page-11-1"></span>4.2.3 Smaller Update Keys

Although, in our aSVC, upk<sup>i</sup> contains a<sup>i</sup> = g A(τ)/(X−ω i ) and u<sup>i</sup> = g Li (τ)−1 X−ωi , miners only need to include a<sup>i</sup> in the block. This is because of two reasons. First, user i already has u<sup>i</sup> to update her own proof after changes to her own balance. Second, no other user j 6= i will need u<sup>i</sup> to update her proof π<sup>j</sup> . However, as hinted in Section [4.1,](#page-9-0) miners actually need u<sup>i</sup> when only a subset of i's pending transactions get included in block t. In this case, the excluded transactions must have their proofs updated using u<sup>i</sup> so they can be included in block t + 1. Fortunately, this is not a problem, since miners always receive u<sup>i</sup> with user i's transactions. The key observation is that they do not have to include u<sup>i</sup> in the mined block, since users do not need it.

## 4.2.4 Addressing DoS Attacks on User Registrations.

Unfortunately, the registration process based on INIT transactions is susceptible to Denial of Service (DoS) attacks: an attacker can simply send a large number of INIT transactions and quickly exhaust the free space in the vector v. There are several ways to address this. First, one can use an aSVC from hidden-order groups, which supports an unbounded number of elements [\[CFG](#page-13-10)+20]. However, that would negatively impact performance. Second, as future work, one could develop and use unbounded, authenticated dictionaries with scalable updates. Third, one could simply use multiple bounded aSVCs together with cross-commitment proof aggregation, which our aSVC supports [\[GRWZ20\]](#page-13-4). Lastly, one can add a cost to user registrations via a new INITSPEND transaction that registers a user j by having user i send her some coins:

[INITSPEND, 
$$t$$
, FPK<sub>i</sub>, tpk,  $v$ ,  $\pi_{i,t}$ ,  $v'$ ], where  $0 < v \le v'$ 

Miners processing this transaction would first register a new user j with traditional public key tpk and then transfer her v coins. We stress that this is how existing cryptocurrencies operate anyway: in order to join, one has to be transferred some coins from existing users. Lastly, we can ensure that each tpk is only registered once by including in each INIT/INITSPEND transaction a non-membership proof for tpk in a Merkle prefix tree of all TPKs. We leave a careful exploration of this to future work.

Finally, miners (and only miners) will be allowed to create a single [INIT, FPK<sup>i</sup> ] transaction per block to register themselves. This has the advantage of letting new miners join, without "permission" from other miners or users, while severely limiting DoS attacks, since malicious miners can only register a new user per block. Furthermore, transaction fees and/or additional proof-of-work can also severely limit the frequency of INITSPEND transactions.

#### 4.2.5 Minting Coins and Transaction Fees.

Support for minting new coins can be added with a new MINT transaction type:

$$\mathsf{tx} = [\mathtt{MINT}, i, \mathsf{upk}_i, v]$$

Here, i is the miner's user account and v is the amount of newly minted coins. (Note that miners must register as users using INIT transactions if they are to receive block rewards.) To support transaction fees, we can extend the SPEND transaction format to include a fee, which is then added to the miner's block reward specified in the MINT transaction.

## 4.3 Discussion

#### <span id="page-11-0"></span>4.3.1 Making Room for Transaction Counters

As mentioned in Section [2.3,](#page-3-1) to prevent transaction replay attacks, account-based stateless cryptocurrencies such as Edrax should actually map a user i to v<sup>i</sup> = (addr<sup>i</sup> |ci |bali), where c<sup>i</sup> is her transaction counter. This change is trivial, but does leave less space in v<sup>i</sup> for addr<sup>i</sup> , depending on how many bits are needed for c<sup>i</sup> and bal<sup>i</sup> . (Recall that v<sup>i</sup> ∈ Z<sup>p</sup> typically has ≈ 256 bits.) To address this, we propose using one aSVC for mapping i to addr<sup>i</sup> and another aSVC for mapping i to (c<sup>i</sup> |bali). Our key observation is that if the two aSVCs use different n-SDH parameters (e.g., (g τ i )'s and (h τ )'s, such that log<sup>g</sup> h is unknown), then we could aggregate commitments, proofs and update keys so as to introduce zero computational and communication overhead in our stateless cryptocurrency. Security of this scheme could be argued similar to security of perfectly hiding KZG commitments [\[KZG10\]](#page-13-11), which commit to φ(X) as g <sup>φ</sup>(τ)h r(τ) in an analogous fashion. We leave investigating the details of this scheme to future work.

## <span id="page-12-0"></span>4.3.2 Overhead of Synchronizing Proofs

In a stateless cryptocurrency, users need to keep their proofs updated w.r.t. the latest block. For example, in our scheme, each user spends O(b·∆t) time updating her proof, if there are ∆t new blocks of b transactions each. Fortunately, when the underlying VC scheme supports precomputing all n proofs fast [\[Tom20\]](#page-14-3), this overhead can be shifted to untrusted third parties called proof-serving nodes [\[CPZ18\]](#page-13-2). Specifically, a proof-serving node would have access to the proving key prk and periodically compute all proofs for all n users. Then, any user with an out-of-sync proof could ask a node for their proof and then manually update it, should it be slightly out of date with the latest block. Proof-serving nodes save users a significant amount of proof update work, which is important for users running on constrained devices such as mobile phones.

# 5 Conclusion

In this paper, we formalized a new cryptographic primitive called an aggregatable subvector commitment (aSVC) that supports aggregating and updating proofs (and commitments) using only constant-sized, static auxiliary information referred to as an "update key." We constructed an efficient aSVC from KZG commitments to Lagrange polynomials which, compared to other pairing-based schemes, can precompute, aggregate and update proofs efficiently and, compared to schemes from hidden-order groups, has smaller proofs and should perform better in practice. Lastly, we continued the study of stateless validation initiated by Chepurnoy et al., improving block validation time and block size, while addressing attacks and limitations. We hope our work will ignite further research into stateless validation for payments and smart contracts and lead to improvements both at the theoretical and practical level.

## Acknowledgements

The authors want to thank Madars Virza for pointing out the Lagrange-based approach to VCs and the DFT technique for computing all KZG commitments to Lagrange polynomials. We also thank Leonid Reyzin and Dimitris Kolonelos for corrections and productive conversations that helped improve this paper.

# References

- <span id="page-13-28"></span>BB08. Dan Boneh and Xavier Boyen. Short Signatures Without Random Oracles and the SDH Assumption in Bilinear Groups. Journal of Cryptology, Apr 2008.
- <span id="page-13-18"></span>BBF18. Dan Boneh, Benedikt B¨unz, and Ben Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. Cryptology ePrint Archive, Report 2018/1188, 2018. <https://eprint.iacr.org/2018/1188>.
- <span id="page-13-3"></span>BBF19. Dan Boneh, Benedikt B¨unz, and Ben Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. In CRYPTO'19, 2019.
- <span id="page-13-20"></span>BdM94. Josh Benaloh and Michael de Mare. One-Way Accumulators: A Decentralized Alternative to Digital Signatures. In Tor Helleseth, editor, EUROCRYPT '93, pages 274–285, Berlin, Heidelberg, 1994. Springer Berlin Heidelberg.
- <span id="page-13-27"></span>BGM17. Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model, 2017. <https://eprint.iacr.org/2017/1050>.
- <span id="page-13-22"></span>BMRS20. Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Coda: Decentralized Cryptocurrency at Scale, 2020. <https://eprint.iacr.org/2020/352>.
- <span id="page-13-23"></span>BSCTV14. Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable Zero Knowledge via Cycles of Elliptic Curves. In CRYPTO'14, 2014.
- <span id="page-13-26"></span>BT04. J. Berrut and L. Trefethen. Barycentric Lagrange Interpolation. SIAM Review, 46(3):501–517, 2004.
- <span id="page-13-6"></span>But17. Vitalik Buterin. The stateless client concept. ethresear.ch, 2017. [https://ethresear.ch/t/](https://ethresear.ch/t/ the-stateless-client-concept/172) [the-stateless-client-concept/172](https://ethresear.ch/t/ the-stateless-client-concept/172).
- <span id="page-13-30"></span>But20. Vitalik Buterin. Using polynomial commitments to replace state roots. [https://ethresear.ch/t/](https://ethresear.ch/t/using-polynomial-commitments-to-replace-state-roots/7095) [using-polynomial-commitments-to-replace-state-roots/7095](https://ethresear.ch/t/using-polynomial-commitments-to-replace-state-roots/7095), 2020.
- <span id="page-13-15"></span>CDHK15. Jan Camenisch, Maria Dubovitskaya, Kristiyan Haralambiev, and Markulf Kohlweiss. Composable and Modular Anonymous Credentials: Definitions and Practical Constructions. In ASIACRYPT'15, 2015.
- <span id="page-13-14"></span>CF13. Dario Catalano and Dario Fiore. Vector Commitments and Their Applications. In PKC'13, 2013.
- <span id="page-13-10"></span>CFG<sup>+</sup>20. Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, and Luca Nizzardo. Vector Commitment Techniques and Applications to Verifiable Decentralized Storage, 2020. <https://eprint.iacr.org/2020/149>.
- <span id="page-13-12"></span>CFM08. Dario Catalano, Dario Fiore, and Mariagrazia Messina. Zero-Knowledge Sets with Short Proofs. In EURO-CRYPT'08, 2008.
- <span id="page-13-31"></span>CLRS09. Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Third Edition. The MIT Press, 3rd edition, 2009.
- <span id="page-13-8"></span>Com16. Ethereum Community. Sharding FAQ. <https://github.com/ethereum/wiki/wiki/Sharding-FAQ>, 2016.
- <span id="page-13-2"></span>CPZ18. Alexander Chepurnoy, Charalampos Papamanthou, and Yupeng Zhang. Edrax: A Cryptocurrency with Stateless Transaction Validation, 2018. <https://eprint.iacr.org/2018/968>.
- <span id="page-13-0"></span>Dry19. Thaddeus Dryja. Utreexo: A dynamic hash-based accumulator optimized for the Bitcoin UTXO set, 2019. [https:](https://eprint.iacr.org/2019/611) [//eprint.iacr.org/2019/611](https://eprint.iacr.org/2019/611).
- <span id="page-13-16"></span>FK20. Dankrad Feist and Dmitry Khovratovich. Fast amortized Kate proofs, 2020. [https://github.com/khovratovich/](https://github.com/khovratovich/Kate) [Kate](https://github.com/khovratovich/Kate).
- <span id="page-13-4"></span>GRWZ20. Sergey Gorbunov, Leonid Reyzin, Hoeteck Wee, and Zhenfei Zhang. Pointproofs: Aggregating Proofs for Multiple Vector Commitments, 2020. <https://eprint.iacr.org/2020/419>.
- <span id="page-13-25"></span>Jou00. Antoine Joux. A One Round Protocol for Tripartite Diffie–Hellman. In Algorithmic Number Theory, 2000.
- <span id="page-13-7"></span>KJG<sup>+</sup>18. E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and B. Ford. OmniLedger: A Secure, Scale-Out, Decentralized Ledger via Sharding. In IEEE S&P'18, May 2018.
- <span id="page-13-19"></span>KR13. Markulf Kohlweiss and Alfredo Rial. Optimally Private Access Control. In ACM WPES'13, 2013.
- <span id="page-13-11"></span>KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-Size Commitments to Polynomials and Their Applications. In ASIACRYPT'10, 2010.
- <span id="page-13-21"></span>LLX07. Jiangtao Li, Ninghui Li, and Rui Xue. Universal Accumulators with Efficient Nonmembership Proofs. In Jonathan Katz and Moti Yung, editors, Applied Cryptography and Network Security, pages 253–269, Berlin, Heidelberg, 2007. Springer Berlin Heidelberg.
- <span id="page-13-9"></span>LM19. Russell W. F. Lai and Giulio Malavolta. Subvector Commitments with Application to Succinct Arguments. In CRYPTO'19, 2019.
- <span id="page-13-13"></span>LY10. Benoˆıt Libert and Moti Yung. Concise Mercurial Vector Commitments and Independent Zero-Knowledge Sets with Short Proofs. In TCC'10, 2010.
- <span id="page-13-5"></span>Mil12. Andrew Miller. Storing UTXOs in a balanced Merkle tree (zero-trust nodes with O(1)-storage), 2012. [https:](https://bitcointalk.org/index.php?topic=101734.msg1117428) [//bitcointalk.org/index.php?topic=101734.msg1117428](https://bitcointalk.org/index.php?topic=101734.msg1117428).
- <span id="page-13-24"></span>MVO91. Alfred Menezes, Scott Vanstone, and Tatsuaki Okamoto. Reducing Elliptic Curve Logarithms to Logarithms in a Finite Field. In ACM STOC, 1991.
- <span id="page-13-29"></span>Nak08. Satoshi Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. <https://bitcoin.org/bitcoin.pdf>, 2008.
- <span id="page-13-17"></span>PST13. Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of Correct Computation. In TCC'13, 2013.
- <span id="page-13-1"></span>RMCI17. Leonid Reyzin, Dmitry Meshkov, Alexander Chepurnoy, and Sasha Ivanov. Improving Authenticated Dynamic Dictionaries, with Applications to Cryptocurrencies. In FC'17, 2017.
- <span id="page-13-32"></span>Sha81. Adi Shamir. On the generation of cryptographically strong pseudo-random sequences. In Shimon Even and Oded Kariv, editors, Automata, Languages and Programming, pages 544–550, Berlin, Heidelberg, 1981. Springer Berlin Heidelberg.

- <span id="page-14-0"></span>STS99. Tomas Sander and Amnon Ta-Shma. Auditable, Anonymous Electronic Cash. In Michael Wiener, editor, Advances in Cryptology — CRYPTO' 99, pages 555–572, Berlin, Heidelberg, 1999. Springer Berlin Heidelberg.
- <span id="page-14-10"></span>STSY01. Tomas Sander, Amnon Ta-Shma, and Moti Yung. Blind, Auditable Membership Proofs. In Yair Frankel, editor, Financial Cryptography, pages 53–71, Berlin, Heidelberg, 2001. Springer Berlin Heidelberg.
- <span id="page-14-9"></span>TCZ<sup>+</sup>20. Alin Tomescu, Robert Chen, Yiming Zheng, Ittai Abraham, Benny Pinkas, Guy Golan Gueta, and Srinivas Devadas. Towards Scalable Threshold Cryptosystems. In IEEE S&P'20, May 2020.
- <span id="page-14-1"></span>Tod16. Peter Todd. Making UTXO set growth irrelevant with low-latency delayed TXO commitments, 2016. [https:](https://petertodd.org/2016/delayed-txo-commitments) [//petertodd.org/2016/delayed-txo-commitments](https://petertodd.org/2016/delayed-txo-commitments).
- <span id="page-14-3"></span>Tom20. Alin Tomescu. How to Keep a Secret and Share a Public Key (Using Polynomial Commitments). PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, USA, 2020.
- <span id="page-14-7"></span>Vir17. Madars Virza. On Deploying Succinct Zero-Knowledge Proofs. PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, USA, 2017.
- <span id="page-14-4"></span>vzGG13a. Joachim von zur Gathen and Jurgen Gerhard. Fast Multiplication. In Modern Computer Algebra, chapter 8, pages 221–254. Cambridge University Press, 3rd edition, 2013.
- <span id="page-14-5"></span>vzGG13b. Joachim von zur Gathen and Jurgen Gerhard. Fast polynomial evaluation and interpolation. In Modern Computer Algebra, chapter 10, pages 295–310. Cambridge University Press, 3rd edition, 2013.
- <span id="page-14-8"></span>vzGG13c. Joachim von zur Gathen and Jurgen Gerhard. Newton iteration. In Modern Computer Algebra, chapter 9, pages 257–292. Cambridge University Press, 3rd edition, 2013.
- <span id="page-14-6"></span>Wik19. Wikipedia contributors. Partial fraction decomposition — Wikipedia, the free encyclopedia, 2019. [Online; accessed 11-April-2020].
- <span id="page-14-2"></span>Woo. Gavin Wood. Ethereum: A Secure Decentralised Generalised Transaction Ledger. <http://gavwood.com/paper.pdf>.

# <span id="page-15-0"></span>A Closed-form Formula for Evaluating the Derivative of X<sup>n</sup> − 1 at Roots of Unity

Let A(X) = X<sup>n</sup> − 1 and recall that Li(X) = <sup>A</sup>(X) A0(ωi)·(X−ωi) (see Section [3.4\)](#page-6-1). Let A<sup>0</sup> (X) be the derivative of X<sup>n</sup> − 1 and let g(x) = A(X)/(X − ω i ).

First, note that A<sup>0</sup> (ω i ) = g(ω i ). Second, by carrying out the division of X<sup>n</sup> − 1 by (X − ω i ), one can verify that:

$$g(x) = (\omega^{i})^{0} X^{n-1} + (\omega^{i})^{1} X^{n-2} + (\omega^{i})^{2} X^{n-3} + \dots + (\omega^{i})^{n-2} X^{1} + (\omega^{i})^{n-1} X^{0}$$

$$\tag{13}$$

Third, evaluating A<sup>0</sup> (X) at X = ω <sup>i</sup> gives:

$$A'(\omega^{i}) = g(\omega^{i}) = (\omega^{i})^{0} \omega^{i(n-1)} + (\omega^{i})^{1} \omega^{i(n-2)} + (\omega^{i})^{2} \omega^{i(n-3)} + \dots + (\omega^{i})^{n-2} \omega^{i\cdot 1} + (\omega^{i})^{n-1} \omega^{i\cdot 0}$$
(14)

$$= n\omega^{i(n-1)} = n(\omega^{i \cdot n - i}) = n\omega^{-i} \tag{15}$$

#### <span id="page-15-1"></span>B Computing all u<sup>i</sup> = g Li (τ)−1 τ−ωi in O(n log n) time from g τ i 's

In Section [3.4.4,](#page-8-1) we argued all u<sup>i</sup> 's can be computed in O(n log n) time. Here, we prove correctness of the formula for the qi(X)'s from Equation [\(11\)](#page-8-2). As an example, let us look at the quotient q1(X) obtained when dividing ψ1(X) by X − ω 1 , assuming n = 8:

$$\frac{X^{6} + 2\omega X^{5} + 3\omega^{2} X^{4} + 4\omega^{3} X^{3} + 5\omega^{4} X^{2} + 6\omega^{5} X + 7\omega^{6}}{X^{7} + \omega X^{6} + \omega^{2} X^{5} + \omega^{3} X^{4} + \omega^{4} X^{3} + \omega^{5} X^{2} + \omega^{6} X + \omega^{7}}$$

$$- X^{7} + \omega X^{6} - 2\omega^{2} X^{5} + \omega^{3} X^{4} + \omega^{4} X^{3} + \omega^{5} X^{2} + \omega^{6} X + \omega^{7}$$

$$- 2\omega X^{6} + 2\omega^{2} X^{5} - 2\omega^{2} X^{5} + \omega^{3} X^{4} - 3\omega^{2} X^{5} + 3\omega^{3} X^{4}$$

$$- 3\omega^{2} X^{5} + 3\omega^{3} X^{4} + \omega^{4} X^{3} - 4\omega^{3} X^{4} + 4\omega^{4} X^{3}$$

$$- 4\omega^{3} X^{4} + 4\omega^{4} X^{3} - 5\omega^{4} X^{3} + \omega^{5} X^{2}$$

$$- 5\omega^{4} X^{3} + 5\omega^{5} X^{2}$$

$$- 6\omega^{5} X^{2} + \omega^{6} X$$

$$- 6\omega^{5} X^{2} + 6\omega^{6} X$$

$$- 7\omega^{6} X + \omega^{7}$$

$$- 7\omega^{6} X + 7\omega^{7}$$

$$- 8\omega^{7}$$

In general, we want to show that:

$$q_i(X) = \sum_{j \in [0, n-2]} (j+1)(\omega^i)^j X^{(n-2)-j}, \forall i \in [0, n)$$
(16)

We do this by showing that the polynomial remainder theorem holds; i.e., ψi(X) = qi(X)(X − ω i ) + ψi(ωi):

$$q_i(X)(X - \omega^i) + \psi_i(\omega_i) = \tag{17}$$

$$= q_i(X)(X - \omega^i) + n\omega^{-i} \tag{18}$$

$$= n\omega^{-i} + (X - \omega^{i}) \sum_{j \in [0, n-2]} (j+1)(\omega^{i})^{j} X^{(n-2)-j}$$
(19)

$$= n\omega^{-i} + X \cdot \sum_{j \in [0, n-2]} (j+1)(\omega^{i})^{j} X^{(n-2)-j} - \omega^{i} \cdot \sum_{j \in [0, n-2]} (j+1)(\omega^{i})^{j} X^{(n-2)-j}$$
(20)

$$= n\omega^{-i} + \sum_{j \in [0, n-2]} (j+1)(\omega^{i})^{j} X^{(n-1)-j} - \sum_{j \in [0, n-2]} (j+1)(\omega^{i})^{j+1} X^{(n-2)-j}$$
(21)

$$= n\omega^{-i} + \sum_{j \in [0, n-2]} (j+1)\omega^{ij} X^{(n-1)-j} - \sum_{j \in [1, n-1]} j\omega^{ij} X^{(n-2)-(j-1)}$$
(22)

$$= n\omega^{-i} + \sum_{j \in [0, n-2]} (j+1)\omega^{ij} X^{(n-1)-j} - \sum_{j \in [1, n-1]} j\omega^{ij} X^{(n-1)-j}$$
(23)

$$= n\omega^{-i} + \left(X^{n-1} + \sum_{j \in [1, n-2]} (j+1)\omega^{ij}X^{(n-1)-j}\right) - \left((n-1)\omega^{i(n-1)}X^0 + \sum_{j \in [1, n-2]} j\omega^{ij}X^{(n-1)-j}\right)$$
(24)

$$= \left(X^{n-1} + \sum_{j \in [1, n-2]} (j+1)\omega^{ij} X^{(n-1)-j} - \sum_{j \in [1, n-2]} j\omega^{ij} X^{(n-1)-j}\right) - \left((n-1)\omega^{i(n-1)} X^0 - n\omega^{-i}\right)$$
(25)

$$= \left(X^{n-1} + \sum_{j \in [1, n-2]} \omega^{ij} X^{(n-1)-j}\right) - \left((n-1)\omega^{-i} X^0 - n\omega^{-i} X^0\right)$$
(26)

$$= \sum_{j \in [0, n-2]} \omega^{ij} X^{(n-1)-j} + \omega^{-i} X^0$$
 (27)

$$= \sum_{j \in [0, n-2]} \omega^{ij} X^{(n-1)-j} + \omega^{in-i} X^0$$
(28)

$$= \sum_{j \in [0, n-2]} \omega^{ij} X^{(n-1)-j} + \omega^{i(n-1)} X^0$$
(29)

$$= \sum_{j \in [0,n)} \omega^{ij} X^{(n-1)-j} \tag{30}$$

$$=\psi_i(X) \tag{31}$$

# C Security Proofs

#### <span id="page-16-1"></span>C.1 KZG Batch Opening Binding (Re)definition

We strengthen the batch opening binding definition of KZG [KZG10, Sec. 3.4, pg. 9] and prove KZG still satisfies it.

<span id="page-16-0"></span>**Definition 8 (Batch Opening Binding).**  $\forall$  adversaries  $\mathcal{A}$  running in time  $poly(\lambda)$ :

$$\Pr \begin{bmatrix} \mathsf{pp} \leftarrow \mathsf{KZG}.\mathsf{Setup}(1^\lambda, n), \\ c, I, J, v_I(X), v_J(X), \pi_I, \pi_J \leftarrow \mathcal{A}(\mathsf{pp}, 1^\lambda) : \\ \mathsf{KZG}.\mathsf{VerifyEvalBatch}(\mathsf{pp}, c, I, \pi_I, v_I(X)) = T \land \\ \mathsf{KZG}.\mathsf{VerifyEvalBatch}(\mathsf{pp}, c, J, \pi_J, v_J(X)) = T \land \\ \exists k \in I \cap J, \ such \ that \ v_I(k) \neq v_J(k) \end{bmatrix} \leq \mathsf{negl}(\lambda)$$
 (32)

Suppose an adversary breaks the definition. Let  $A_I(X) = \prod_{i \in I} (X - i)$ . Then, the following holds:

$$e(c,g) = e(\pi_I, g^{A_I(\tau)})e(g^{v_I(\tau)}, g)$$
(33)

$$e(c,g) = e(\pi_J, g^{A_J(\tau)})e(g^{v_J(\tau)}, g)$$
 (34)

Divide the top equation by the bottom one to get:

$$\mathbf{1}_T = \frac{e(g^{v_I(\tau)}, g)}{e(g^{v_J(\tau)}, g)} \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})} \Leftrightarrow$$

$$(35)$$

$$\mathbf{1}_T = e(g^{v_I(\tau) - v_J(\tau)}, g) \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})} \Leftrightarrow$$
(36)

$$e(g^{v_J(\tau)-v_I(\tau)},g) = \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})}$$
(37)

Let  $v_k = v_I(k)$  and  $v'_k = v_J(k)$ . We can rewrite  $v_I(X)$  using the polynomial remainder theorem as  $v_I(X) = q_I(X)(X - k) + v_k$ . Similarly,  $v_J(X) = q_J(X)(X - k) + v'_k$ .

$$e(g^{q_J(\tau)(\tau-k)+v_k'-q_I(\tau)(\tau-k)-v_k},g) = \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})} \Leftrightarrow$$

$$(38)$$

$$e(g^{(\tau-k)(q_J(\tau)-q_I(\tau))+v_k'-v_k},g) = \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})} \Leftrightarrow$$

$$(39)$$

$$e(g^{(\tau-k)(q_J(\tau)-q_I(\tau))}, g)e(g^{v_k'-v_k}, g) = \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})} \Leftrightarrow$$
(40)

$$e(g^{q_J(\tau)-q_I(\tau)}, g)^{\tau-k} e(g, g)^{v_k'-v_k} = \frac{e(\pi_I, g^{A_I(\tau)})}{e(\pi_J, g^{A_J(\tau)})}$$
(41)

Factor out (X - k) in  $A_I(X)$  to get  $A_I(X) = a_I(X)(\tau - k)$ . Similarly,  $A_J(X) = a_J(X)(\tau - k)$ .

$$e(g^{q_J(\tau) - q_I(\tau)}, g)^{\tau - k} e(g, g)^{v_k' - v_k} = \left(\frac{e(\pi_I, g^{a_I(\tau)})}{e(\pi_J, g^{a_J(\tau)})}\right)^{\tau - k} \Leftrightarrow$$
(42)

$$e(g^{q_J(\tau) - q_I(\tau)}, g)e(g, g)^{\frac{v_k' - v_k}{\tau - k}} = \frac{e(\pi_I, g^{a_I(\tau)})}{e(\pi_J, g^{a_J(\tau)})} \Leftrightarrow$$
(43)

$$e(g,g)^{\frac{v_k'-v_k}{\tau-k}} = \frac{e(\pi_I, g^{a_I(\tau)})}{e(\pi_I, g^{a_J(\tau)})e(g^{q_J(\tau)-q_I(\tau)}, g)} \Leftrightarrow$$
(44)

$$e(g,g)^{\frac{1}{\tau-k}} = \left(\frac{e(\pi_I, g^{a_I(\tau)})}{e(\pi_J, g^{a_J(\tau)})e(g^{q_J(\tau)-q_I(\tau)}, g)}\right)^{\frac{1}{v_k'-v_k}}$$
(45)

Since the commitments to  $a_I(X), a_J(X), q_I(X), q_J(X)$  can be easily reconstructed from  $v_I(X), v_J(X), I$  and J, and since  $v'_k \neq v_k$ , this constitutes a direct break of n-SBDH.

## <span id="page-17-0"></span>C.2 Update Key Uniqueness

We prove that our aSVC scheme from Section 3 has  $Update\ Key\ Uniqueness$  as defined in Definition 6. Let a be the commitment to  $A(X)=X^n-1$  from the verification key vrk. Suppose an adversary outputs two update keys  $\mathsf{upk}_i=(a_i,u_i)$  and  $\mathsf{upk}_i'=(a_i',u_i')$  at position i that both pass VC.VerifyUPK but  $\mathsf{upk}_i\neq\mathsf{upk}_i'$ . Then, it must be the case that either  $a_i\neq a_i'$  or that  $u_i\neq u_i'$ .

 $a_i \neq a_i'$  Case: Since both update keys pass verification, the following pairing equations hold:

$$e(a_i, g^{\tau}/g^{\omega^i}) = e(a, g) \tag{46}$$

$$e(a_i', g^{\tau}/g^{\omega^i}) = e(a, g) \tag{47}$$

Thus, it follows that:

$$e(a_i, g^{\tau}/g^{\omega^i}) = e(a_i', g^{\tau}/g^{\omega^i}) \Leftrightarrow$$
(48)

$$e(a_i, g) = e(a_i', g) \Leftrightarrow \tag{49}$$

$$a_i = a_i' \tag{50}$$

Contradiction.

 $u_i \neq u_i'$  Case: Let A'(X) denote the derivative of  $A(X) = X^n - 1$ . Let  $\ell_i = a_i^{1/A'(\omega^i)} = g^{\mathcal{L}_i(\tau)}$ . Since both update keys pass verification, the following pairing equations hold:

$$e(\ell_i/g^1, g) = e(u_i, g^{\tau}/g^{\omega^i})$$
(51)

$$e(\ell_i/g^1, g) = e(u_i', g^{\tau}/g^{\omega^i})$$
 (52)

Thus, it follows that:

$$e(u_i, g^{\tau}/g^{\omega^i}) = e(u_i', g^{\tau}/g^{\omega^i})$$
(53)

$$e(u_i, g) = e(u_i', g) \Leftrightarrow \tag{54}$$

$$u_i = u_i' \tag{55}$$

Contradiction.

# <span id="page-18-0"></span>D Complexities of Pairing-based VCs in Table 2

We survey each *pairing-based* VC scheme from Table 2 and explain its complexities. In Appendix E, we do the same for VCs based on hidden-order groups. Despite our best efforts to understand the complexities of each scheme, we recognize there could be better upper bounds for some of them.

## D.1 Complexities of CDH-based [LM19]

This scheme was originally proposed by Catalano and Fiore [CF13] and extended by Lai and Malavolta to support subvector proofs [LM19].

**Public Parameters.** The proving key is  $\mathsf{prk} = (h_{i,j})_{i,j \in [0,n)}$  and is  $O(n^2)$  sized. Here,  $h_{i,j} = g^{z_i \cdot z_j}$  when  $i \neq j$  and  $h_{i,i} = h_i = g^{z_i}$ , with each  $z_i \in \mathbb{Z}_p$  picked uniformly at random. The verification key is  $\mathsf{vrk} = (h_i)_{i \in [0,n)}$  and is O(n)-sized. The ith update key is  $\mathsf{upk}_i = (h_i, (h_{i,j})_{j \in [0,n)})$ . Note that  $h_{i,j} = h_i^{z_i} = h_i^{z_j}$ .

**Commitment.** A commitment is  $c = \prod_{i \in [0,n)} h_i^{v_i}$  and can be computed with O(n) exponentiations. If any vector element  $v_j$  changes to  $v_j + \delta$ , the commitment can be updated in O(1) time using  $h_j$  from  $\mathsf{upk}_j$  as  $c' = c \cdot (h_j)^{\delta}$ .

**Proofs for a**  $v_i$ . A proof for  $v_i$  is:

$$\pi_i = \prod_{j \in [0,n) \setminus \{i\}} h_{i,j}^{v_j} = \left(\prod_{j \in [0,n) \setminus \{i\}} h_j^{v_j}\right)^{z_i}$$
(56)

The proof is O(1)-sized and can be computed from the  $h_{i,j}$ 's in the prk with O(n) exponentiations. It can be verified in O(1) time using  $h_i$  from the vrk as:

$$e(C/h_i^{v_i}, h_i) = e(\pi_i, g) \tag{57}$$

If any vector element  $v_j, j \neq i$  changes to  $v_j + \delta$ , the proof  $\pi_i$  can be updated in O(1) time using  $h_{i,j}$  from  $\mathsf{upk}_j$  as  $\pi'_i = \pi_i \cdot \left(h^\delta_{i,j}\right)$ . This new  $\pi'_i$  will verify against the updated c' commitment defined earlier. If  $v_i$  changes to  $v_i + \delta$ , the proof  $\pi_i$  need not be updated.

Subvector Proofs for  $(v_i)_{i \in I}$  A O(1)-sized subvector proof for  $\mathbf{v}_I$  is:

$$\pi_{I} = \prod_{i \in I} \prod_{j \in [0,n) \setminus I} h_{i,j}^{v_{j}} = \prod_{i \in I} \left( \prod_{j \in [0,n) \setminus I} h_{j}^{v_{j}} \right)^{z_{i}} = \prod_{i \in I} \pi_{i}^{*}$$
(58)

As intuition, note that the inner product  $\pi_i^* = \left(\prod_{j \in [0,n) \setminus I} h_j^{v_j}\right)^{z_i}$  is very similar to a proof  $\pi_i = \left(\prod_{j \in [0,n) \setminus \{i\}} h_j^{v_j}\right)^{z_i}$  for  $v_i$ . Let b = |I|. The proof can be computed from the  $h_{i,j}$ 's in the prk with O(b(n-b)) exponentiations (because each  $\pi_i^*$  can be computed in O(n-b) exponentiations). A subvector proof  $\pi_I$  can be verified using  $(h_i)_{i \in I}$  from vrk by checking in O(b) time if:

$$e\left(c/\prod_{j\in I}h_{j}^{v_{j}},\prod_{i\in I}h_{i}\right)=e(\pi_{I},g)\Leftrightarrow\tag{59}$$

$$e\left(\prod_{j\in[0,n)\setminus I} h_j^{v_j}, \prod_{i\in I} g^{z_i}\right) = e\left(\prod_{i\in I} \prod_{j\in[0,n)\setminus I} h_{i,j}^{v_j}, g\right)$$

$$(60)$$

$$e\left(\prod_{j\in[0,n)\backslash I} h_j^{v_j}, g^{\sum_{i\in I} z_i}\right) = e\left(\prod_{i\in I} \left(\prod_{j\in[0,n)\backslash I} h_j^{v_j}\right)^{z_i}, g\right)$$
(61)

$$e\left(\left(\prod_{j\in[0,n)\backslash I}h_j^{v_j}\right)^{\sum_{i\in I}z_i},g\right) = e\left(\left(\prod_{j\in[0,n)\backslash I}h_j^{v_j}\right)^{\sum_{i\in I}z_i},g\right)$$
(62)

Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed in [CF13, LM19], but it seems possible. Finally, precomputing all proofs efficiently is not discussed. Naively, it can be done inefficiently in  $O(n^2)$  time.

## <span id="page-19-1"></span>D.2 Complexities of KZG [KZG10]

Kate, Zaverucha and Goldberg also discuss using their polynomial commitment scheme [KZG10] to commit to a sequence of messages, thus implicitly obtaining a VC scheme. Although they do not analyze its complexity in their paper, we do so here.

**Public Parameters.** The proving key is  $\operatorname{prk} = (g^{\tau^i})_{i \in [0, n-1]}$  and is O(n) sized. The verification key is  $\operatorname{vrk} = (g, (g^{\tau^i})_{i \in b})$ , where b = |I| is the size of the largest subvector whose proof the verifier should be able to check, and is thus O(b)-sized. There is no support for updating commitments and proofs using update keys, although our work shows this is possible (see Section 3.3).

**Commitment.** A commitment is  $c = g^{\phi(\tau)}$  where  $\phi(X) = \sum_{i \in [0,n)} \mathcal{L}_i(X) v_i$  and can be computed with  $O(n \log^2 n)$  field operations (see Section 2.1) and O(n) exponentiations. Commitment updates are not discussed, but the scheme could be modified to support them (see Section 3.3).

**Proofs for a**  $v_i$ . A proof for  $v_i$  is:

$$\pi_i = g^{\frac{\phi(\tau) - v_i}{\tau - i}} = g^{q_i(\tau)} \tag{63}$$

The proof is O(1)-sized and can be computed by dividing  $\phi(X)$  by (X-i) in O(n) field operations, obtaining  $q_i(X)$ , and committing to  $q_i(X)$  using the  $g^{\tau^i}$ 's in the prk with O(n) exponentiations. The proof can be verified in O(1) time using  $g^{\tau}$  from the vrk by computing two pairings:

$$e(c/g^{v_i}, g) = e(\pi_i, g^{\tau}/g^i)$$

$$(64)$$

Proof updates are not discussed, but the scheme could be modified to support them (see Section 3.3).

Subvector Proofs for  $(v_i)_{i \in I}$  A O(1)-sized subvector proof for  $\mathbf{v}_I$  is:

$$\pi_I = g^{\frac{\phi(\tau) - R_I(\tau)}{A_I(\tau)}} = g^{q_I(\tau)}$$
 (65)

Here,  $R_I(X)$  of degree  $\leq b-1$  is interpolated in  $O(b\log^2 b)$  field operations so that  $R_I(i) = v_i, \forall i \in I$  (see Section 2.1). Also,  $A_I(X) = \prod_{i \in I} (X-i)$  is computed in  $O(b\log^2 b)$  field operations via a *subproduct tree* [vzGG13b]. The proof leverages the fact that dividing  $\phi(X)$  by  $A_I(X)$  gives quotient  $q_I(X)$  and remainder  $R_I(X)$ . The quotient  $q_I(X)$  can be obtained in  $O(n\log n)$  field operations via a DFT-based division [vzGG13c]. Given  $g^{\tau^i}$ 's from the prk, committing to  $q_I(X)$  takes O(n-b) exponentiations, since  $\deg(q_I) = \deg(\phi) - \deg(A_I) \leq (n-1) - b$ . Thus, the overall subvector proving time is  $O(n\log n + b\log^2 b)$ .

To verify a subvector proof  $\pi_I$ , first, the verifier must recompute  $R_I(X)$  and  $A_I(X)$  in  $O(b \log^2 b)$  field operations. Then, the verifier uses  $(g^{\tau^i})_{i\in b}$  from the vrk to compute KZG commitments  $g^{R_I(\tau)}$  and  $g^{A_I(\tau)}$  in O(b) exponentiations. Finally, the verifier checks using two pairings if:

$$e(c/g^{R_I(\tau)}, g) = e(\pi_I, g^{A_I(\tau)})$$
 (66)

Thus, the overall subvector proof verification time is  $O(b \log^2 b)$  time.

Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed, but the scheme can be modified to support them (see Section 3.4.1). Finally, precomputing all proofs efficiently is not discussed, but is possible (see Section 3.3). Naively, it can be done inefficiently in  $O(n^2)$  time.

## <span id="page-19-0"></span>D.3 Complexity of CDHK [CDHK15]

In this scheme, we assume the vector  $\mathbf{v} = [v_1, v_2, \dots, v_n]$  is indexed from 1 to n. This scheme is similar to a KZG-based VC, except (1) it is randomized, (2) it computes proofs in a slightly different way and (3) it willfully prevents aggregation of proofs as a security feature.

**Public Parameters.** The proving key is  $\operatorname{prk} = \left( (g^{\tau^i})_{i \in [0,n+1]}, (g^{\mathcal{L}_i(\tau)})_{i \in [0,n]}, g^{P(\tau)} \right)$ , where  $P(X) = X \cdot \prod_{i \in [n]} (X-i)$  and is O(n) sized. (Note that the Lagrange polynomials  $\mathcal{L}_i(X) = \prod_{j \in [0,n], j \neq i} \frac{X-j}{i-j}$  are defined over the points [0,n], not [n].) The verification key is  $\operatorname{vrk} = (g, (g^{\mathcal{L}_i(\tau)})_{i \in [n]}, (g^{\tau^i})_{i \in [0,b+1]})$ , where b = |I| is the size of the largest subvector whose proof the verifier should be able to check. Unfortunately, the verification key is O(n)-sized. There is no support for

updating commitments and proofs using update keys, although adding it is possible via our techniques (see Section 3.3).

As a result, we treat this scheme as if it used an O(n)-sized update key  $\mathsf{upk}_i = \left(g^{\mathcal{L}_i(\tau)}, \left(g^{\frac{\mathcal{L}_j(\tau)}{\tau-i}}\right)_{j \in [n]}\right)$ 

Commitment. A commitment is  $c = \prod_{i \in [n]} \left(g^{\mathcal{L}_i(\tau)}\right)^{v_i} \left(g^{P(\tau)}\right)^r = g^{\phi(\tau) + r \cdot P(\tau)}$  where  $\phi(X) = \sum_{i \in [0,n]} \mathcal{L}_i(X) v_i$ , with  $v_0 = 0$ . To compute the commitment,  $\phi(X)$  must first be interpolated using  $O(n \log^2 n)$  field operations. Then, c can be computed with O(n) exponentiations, given the Lagrange commitments and  $g^{P(\tau)}$  from prk. Commitment updates are not discussed, but they can be trivially implemented by setting  $\operatorname{upk}_i = g^{\mathcal{L}_i(\tau)}$  and having  $c' = c \cdot \left(g^{\mathcal{L}_j(\tau)}\right)^{\delta}$  be the new commitment after a change  $\delta$  to  $v_j$ . We reflect this in Table 2.

**Proofs for a**  $v_i$ . A proof for  $v_i$  is:

$$\pi_i = g^{\frac{(\phi(\tau) + r \cdot P(\tau)) - v_i \mathcal{L}_i(\tau)}{\tau - i}} = g^{q_i(\tau)}$$

$$\tag{67}$$

The proof is O(1)-sized and can be computed by dividing  $\phi(X) + r \cdot P(X) - v_i \mathcal{L}_i(X)$  by (X - i) in O(n) field operations, obtaining  $q_i(X)$ , and committing to  $q_i(X)$  using the  $g^{\tau^i}$ 's in the prk with O(n) exponentiations. The proof can be verified in O(1) time using  $g^{\mathcal{L}_i(\tau)}$  from the vrk by computing two pairings:

$$e\left(c/\left(g^{\mathcal{L}_i(\tau)}\right)^{v_i}, g\right) = e(\pi_i, g^{\tau}/g^i)$$
 (68)

Proof updates are not discussed, but the scheme could be modified to support them (see Section 3.3).

Subvector Proofs for  $(v_i)_{i \in I}$  A O(1)-sized subvector proof for  $\mathbf{v}_I$  is:

$$\pi_I = g^{\frac{\phi(\tau) + r \cdot P(\tau) - R_I(\tau)}{A_I(\tau)}} = g^{q_I(\tau)} \tag{69}$$

Here,  $R_I(X)$  is defined so that  $R_I(i) = v_i, \forall i \in I$  and  $R_I(i) = 0, \forall i \in [0, n] \setminus I$ . (In particular, this means  $R_I(0) = 0$ .) Interpolating  $R_I(X)$  takes  $O(n \log^2 n)$  field operations. Also,  $A_I(X) = X \prod_{i \in I} (X - i)$  is computed in  $O(b \log^2 b)$  field operations via a subproduct tree [vzGG13b]. Given  $g^{\tau^i}$ 's from the prk, committing to  $q_I(X)$  takes O(n - b) exponentiations (because  $\deg(q_I) = \deg(\phi) - \deg(A_I) \le n - (b+1)$ ). Thus, the overall subvector proving time is  $O(n \log^2 n)$ .

To verify a subvector proof  $\pi_I$ , first, the verifier recomputes the commitment to  $g^{R_I(\tau)} = \sum_{i \in I} \left(g^{\mathcal{L}_i(\tau)}\right)^{v_i}$  using O(b) exponentiations. (Recall that  $\mathcal{L}_i(X)$  is defined over [0,n] and has its KZG commitment in the vrk.) Then, he computes  $A_I(X)$  in  $O(b \log^2 b)$  field operations using a *subproduct tree* [vzGG13b]. Then, the verifier uses  $(g^{\tau^i})_{i \in [0,b+1]}$  from the vrk to compute a KZG commitment to  $g^{A_I(\tau)}$  in O(b) exponentiations. Finally, the verifier checks if:

$$e(c/g^{R_I(\tau)}, g) = e(\pi_I, g^{A_I(\tau)})$$
 (70)

Thus, the overall subvector proof verification time is  $O(b \log^2 b)$ .

Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is willfully prevented by this scheme, as a security feature. Finally, precomputing all proofs efficiently is not discussed, but it can be done inefficiently in  $O(n^2)$  time. Importantly, because the proofs are slightly different from KZG, they are not amenable to known techniques for precomputing all n proofs in  $O(n \log n)$  time [FK20].

#### <span id="page-20-0"></span>D.4 Complexities of CPZ [CPZ18]

Since the Edrax paper clearly summarizes its performance, we refer the reader to [CPZ18, Table 1], with one exception discussed below.

Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed and it is unclear if the scheme can be modified to support it. Precomputing all proofs efficiently is not discussed either to the best of our knowledge, but could be possible.

## <span id="page-20-1"></span>D.5 Complexities of TCZ [TCZ<sup>+</sup>20, Tom20]

In their paper on scaling threshold cryptosystems, Tomescu et al. [TCZ<sup>+</sup>20] present a technique for computing n logarithmic-sized evaluation proofs for a KZG committed polynomial of degree t in  $O(n \log t)$  time. Later on, Tomescu extends these results to obtain a full VC scheme [Tom20, Sec 9.2].

**Public Parameters.** The proving key is  $\operatorname{prk} = ((g^{\tau^i})_{i \in [0,n-1]}, (g^{\mathcal{L}_i(\tau)})_{i \in [0,n)})$  and is O(n) sized. Importantly, n is assumed to be a power of two, and  $\mathcal{L}_i(X) = \prod_{j \in [0,n), j \neq i} \frac{X - \omega^j}{\omega^i - \omega^j}$  where  $\omega$  is a primitive nth root of unity [vzGG13a].

The verification key is  $\operatorname{vrk} = (g, (g^{\tau^{2^{i}}})_{i \in [\lfloor \log_{2}(n-1) \rfloor]}, (g^{\tau^{i}})_{i \in [b]})$ , where b = |I| is the size of the largest subvector whose proof the verifier should be able to check, and is thus O(b)-sized. The ith update key  $\operatorname{upk}_{i}$  is the  $\operatorname{authenticated}$   $\operatorname{multipoint}$  evaluation tree (AMT) of  $\mathcal{L}_{i}(X)$  at all points  $(\omega^{i})_{i \in [0,n)}$  (see [TCZ<sup>+</sup>20, Sec III-B] and [Tom20, Ch 9]). This AMT will be  $O(\log n)$ -sized, consisting of a single path of non-zero quotient commitments leading to the evaluation of  $\mathcal{L}_{i}(\omega^{i})$  [Tom20, Sec 9.2.2], since all other evaluations  $\mathcal{L}_{i}(\omega^{j}), j \neq i$  are zero.

**Commitment.** A commitment is  $c = g^{\phi(\tau)}$  where  $\phi(\omega^i) = v_i, \forall i \in [0, n)$ . Note that  $\phi(X)$  can be computed with  $O(n \log n)$  field operations via an inverse Discrete Fourier Transform (DFT) [CLRS09, Ch 30.2]. Then, computing c requires O(n) exponentiations. Commitment updates remain the same as in the KZG-based scheme from Appendix D.3:  $c' = c \cdot \left(g^{\mathcal{L}_j(\tau)}\right)^{\delta}$ , where  $\delta$  is the change at position j in the vector and the Lagrange polynomial commitment can be obtained from  $\mathsf{upk}_j$ .

**Proofs for a**  $v_i$ . A proof for  $v_i$  is:

$$\pi_i = (g^{q_w(\tau)})_{w \in [1+|\log(n-1)|]} \tag{71}$$

Here, each  $q_w(X)$  is a quotient polynomial along the AMT tree path to  $\phi(\omega^i)$ . The proof is  $O(\log n)$ -sized and can be computed by "repeatedly" dividing  $\phi(X)$  by accumulator polynomials of ever-decreasing sizes  $n/2,\ldots,4,2,1$  in  $T(n) = O(n\log n) + T(n/2) = O(n\log n)$  field operations, and committing to each  $q_w(X)$  using the  $g^{\tau^i}$ 's in the prk with T'(n) = O(n) + T'(n/2) = O(n) exponentiations. ("Repeatedly" dividing means we first divide  $\phi(X)$  by a degree n/2 accumulator. Then, we take the remainder of this division and divide it by the degree n/4 accumulator. We then take this remainder and divide it by a degree n/8 accumulator. And so on. This ensures the remainder degrees always halve.) The proof can be verified in  $O(\log n)$  time using the  $g^{\tau^{2^i}}$ 's from the vrk:

$$e(c/g^{v_i}, g) = \prod_{w \in [1+|\log(n-1)|]} e(g^{q_w(\tau)}, g^{a_w(\tau)})$$
(72)

Here, the  $a_w(X)$ 's denote the accumulator polynomials along the AMT path to  $\phi(\omega^i)$ , which are always of the form  $X^{2^i} - c$  for some constant c and some  $i \in [0, \lfloor \log (n-1) \rfloor]$ .

**Proof Updates.** If any vector element  $v_j$  changes to  $v_j + \delta$ , the proof  $\pi_i$  can be updated in  $O(\log n)$  time. (It could be that j = i.) The idea is to consider the quotient commitments  $g^{q_w(\tau)}$  along  $\pi_i$ 's AMT path and the  $g^{u_w(\tau)}$  commitments along  $\operatorname{upk}_j$ 's AMT path. For all locations w where the two paths intersect, the quotient commitments are combined in constant time as  $g^{q'_w(\tau)} = g^{q_w(\tau)} \cdot \left(g^{u_w(\tau)}\right)^{\delta}$ . Since there are at most  $O(\log n)$  locations w to intersect in, this takes  $O(\log n)$  exponentiations. This new  $\pi'_i$  with quotient commitments  $g^{q'_w(\tau)}$  will verify against the updated c' commitment defined earlier.

Subvector Proofs for  $(v_i)_{i \in I}$  This scheme uses the same subvector proof as the original KZG-based scheme in Appendix D.2. Thus, the subvector proving time is  $O(n \log n + b \log^2 b)$  and the verification time is  $O(b \log^2 b)$  time.

Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed and it is unclear if the scheme can be modified to support it. Precomputing all logarithmic-sized proofs efficiently is possible via the AMT technique in  $O(n \log n)$  time.

#### <span id="page-21-0"></span>D.6 Complexity of Pointproofs [GRWZ20, LY10]

Gorbunov et al. [GRWZ20] enhance the VC by Libert and Yung [LY10] with the ability to aggregate multiple VC proofs into a subvector proof. Additionally, they also enable aggregation of subvector proofs across different vector commitments, which they show is useful for stateless smart contract validation in cryptocurrencies. In this scheme, we assume the vector  $\mathbf{v} = [v_1, v_2, \dots, v_n]$  is indexed from 1 to n.

**Public Parameters.** Their scheme works over Type III pairings  $e: \mathbb{G}_1 \times \mathbb{G}_2 \to \mathbb{G}_T$ . Let  $g_1, g_2, g_T$  be generators of  $\mathbb{G}_1, \mathbb{G}_2$  and  $\mathbb{G}_T$  respectively. The proving key  $\mathsf{prk} = (g_1, (g_1^{\alpha^i})_{i \in [1,2n] \setminus \{n+1\}}, g_2, (g_2^{\alpha^i})_{i \in [1,n]}, g_T^{\alpha^{n+1}})$ . Note that  $g_1^{\alpha^{n+1}}$  is "missing" from the proving key, which is essential for security. The verification key  $\mathsf{vrk} = ((g_2^{\alpha^i})_{i \in [1,n]}, g_T^{\alpha^{n+1}})$  is O(n)-sized. The ith update key is  $\mathsf{upk}_i = g_1^{\alpha^i}$ . They only support updating commitments, but proofs could be made updatable at the cost of linear-sized update keys.

Commitment. A commitment is  $c = \prod_{i \in [n]} \left(g_1^{\alpha^i}\right)^{v_i} = g_1^{\sum_{i \in [n]} v_i \alpha^i}$  and can be computed with O(n) exponentiations. If any vector element  $v_j$  changes to  $v_j + \delta$ , the commitment can be updated in O(1) time as  $c' = c \cdot (\mathsf{upk}_j)^{\delta} = c \cdot (g_1^{\alpha^j})^{\delta}$ .

**Proofs for a**  $v_i$ . A proof for  $v_i$  is obtained by re-committing to v so that  $v_i$  "lands" at position n+1 (i.e., has coefficient  $\alpha^{n+1}$ ) rather than position i (i.e., has coefficient  $\alpha^i$ ). Furthermore, this commitment will **not** contain  $v_i$ : it cannot, since that would require having  $g_1^{\alpha^{n+1}}$ . To get position i to n+1, we must "shift" it (and every other position) by (n+1)-i. Thus, the proof is:

$$\pi_i = g_1^{\sum_{j \in [n] \setminus \{i\}} v_j \alpha^{j+(n+1)-i}}$$
(73)

$$=g_1^{\sum_{j\in[n]\setminus\{i\}}v_j\alpha^j\alpha^{(n+1)-i}} \tag{74}$$

$$= \left(g_1^{\sum_{j \in [n] \setminus \{i\}} v_j \alpha^j}\right)^{\alpha^{(n+1)-i}} \tag{75}$$

$$= \left(\frac{g_1^{\sum_{j \in [n]} v_j \alpha^j}}{g_1^{v_i \alpha^i}}\right)^{\alpha^{(n+1)-i}} \tag{76}$$

$$= (c/g_1^{v_i\alpha^i})^{\alpha^{(n+1)-i}} \tag{77}$$

The proof is constant-sized and can be computed with O(n) exponentiations. It can be verified in O(1) time using  $g_2^{\alpha^{(n+1)-i}}$  from vrk:

$$e(c, g_2^{\alpha^{(n+1)-i}}) = e(\pi_i, g_2) \left(g_T^{\alpha^{n+1}}\right)^{v_i}$$
 (78)

Updating the proof is not discussed but can be done in O(1) time, if the update keys are tweaked to be linear rather than constant-sized.

Subvector Proofs for  $(v_i)_{i\in I}$  An O(1)-sized subvector proof for  $\mathbf{v}_I$  is just a random linear combination of all proofs  $\pi_i$ ,  $\forall i \in I$ . First, all b proofs  $\pi_i$  are computed in O(bn) exponentiations as described above. Second, for each  $i \in I$ ,  $t_i = H(c, I, (v_i)_{i \in I})$  is computed using a random oracle  $H : \{0, 1\}^* \to \mathbb{Z}_p$ . Third, the subvector proof  $\pi_I$  is computed as:

$$\pi_I = \prod_{i \in I} \pi_i^{t_i} \tag{79}$$

If computed this way, a subvector proof would take O(bn) exponentiations. However, Gorbunov et al. observe that  $\pi_I$  can be computed with an O(n)-sized multi-exponentiation on a subset of the 2n generators  $(g_1^{\alpha^i})_{i\in[0,2n]\setminus\{n+1\}}$ . The exponents will be a combination of the messages and the  $t_i$ 's (see [GRWZ20, Sec 4.1] for more details). However, they do not bound the time to compute these exponents, which appears to be O(bn) field operations in the worst-case.

The subvector proof can be verified in O(b) time using  $(g_2^{\alpha^{(n+1)-i}})_{i\in I}$  from vrk as:

$$e\left(c, \prod_{i \in I} \left(g_2^{\alpha^{(n+1)-i}}\right)^{t_i}\right) = e(\pi_I, g_2) \left(g_T^{\alpha^{n+1}}\right)^{\sum_{i \in I} v_i t_i} \Leftrightarrow \tag{80}$$

$$e\left(c, g_2^{\sum_{i \in I} t_i \alpha^{(n+1)-i}}\right) = e\left(\prod_{i \in I} \pi_i^{t_i}, g_2\right) g_T^{\alpha^{n+1} \sum_{i \in I} v_i t_i} \Leftrightarrow \tag{81}$$

$$= e\left(\prod_{i \in I} \pi_i^{t_i}, g_2\right) e\left(g_1^{\alpha^{n+1} \sum_{i \in I} v_i t_i}, g_2\right) \Leftrightarrow \tag{82}$$

$$= e\left(\prod_{i \in I} \pi_i^{t_i} \cdot g_1^{\alpha^{n+1} \sum_{i \in I} v_i t_i}, g_2\right) \Leftrightarrow \tag{83}$$

$$= e \left( \prod_{i \in I} \pi_i^{t_i} \cdot \prod_{i \in I} g_1^{\alpha^{n+1} v_i t_i}, g_2 \right) \Leftrightarrow \tag{84}$$

$$= e\left(\prod_{i \in I} \left(\pi_i \cdot g_1^{\alpha^{n+1}v_i}\right)^{t_i}, g_2\right) \tag{85}$$

Recall that  $\pi_i = (c/g_1^{v_i\alpha^i})^{\alpha^{(n+1)-i}}$ .

$$e\left(c, g_2^{\sum_{i \in I} t_i \alpha^{(n+1)-i}}\right) = e\left(\prod_{i \in I} \left(\left(c/g_1^{v_i \alpha^i}\right)^{\alpha^{(n+1)-i}} \cdot g_1^{\alpha^{n+1} v_i}\right)^{t_i}, g_2\right) \Leftrightarrow \tag{86}$$

$$= e \left( \prod_{i \in I} \left( (c/g_1^{v_i \alpha^i}) \cdot g_1^{\frac{\alpha^{n+1} v_i}{\alpha^{(n+1)-i}}} \right)^{t_i \alpha^{(n+1)-i}}, g_2 \right) \Leftrightarrow \tag{87}$$

$$= e\left(\prod_{i \in I} \left( (c/g_1^{v_i \alpha^i}) \cdot g_1^{v_i \alpha^i} \right)^{t_i \alpha^{(n+1)-i}}, g_2 \right) \Leftrightarrow \tag{88}$$

$$= e\left(\prod_{i \in I} c^{t_i \alpha^{(n+1)-i}}, g_2\right) \Leftrightarrow \tag{89}$$

$$= e\left(c^{\sum_{i \in I} t_i \alpha^{(n+1)-i}}, g_2\right) \Leftrightarrow \tag{90}$$

$$= e\left(c, g_2^{\sum_{i \in I} t_i \alpha^{(n+1)-i}}\right) \tag{91}$$

Aggregating Proofs and Precomputing All Proofs. A subvector proof requires b hash computations and an O(b)-sized multi-exponentiation and thus takes O(b) time. Precomputing all proofs efficiently is not discussed. Naively, it can be done in  $O(n^2)$  time.

## <span id="page-23-0"></span>D.7 Complexity of our Lagrange-based aSVC from Section 3.3

Our scheme builds upon previous VCs using KZG commitments [CDHK15, KZG10]. Since we give its full algorithmic description in Section 3.4.3, this section will be briefer than previous ones.

**Public Parameters.** The proving key, verification key and *i*th update key are O(n), O(b) and O(1)-sized, respectively. Similar to Appendix D.5, n is assumed to be a power of two, and  $\mathcal{L}_i(X) = \prod_{j \in [0,n), j \neq i} \frac{X - \omega^j}{\omega^i - \omega^j}$  where  $\omega$  is a primitive nth root of unity [vzGG13a].

**Commitment.** A commitment is  $c = \prod_{i \in [0,n)} \ell_i^{v_i} = g^{\phi(\tau)}$  where  $\phi(X) = \sum_{i \in [0,n)} \mathcal{L}_i(X)v_i$  and  $\phi(\omega^i) = v_i$ . If any vector element  $v_j$  changes to  $v_j + \delta$ , the commitment can be updated in O(1) time using as  $c' = c \cdot (\mathsf{upk}_i)^{\delta} = c \cdot (\ell_i)^{\delta}$ .

**Proofs for a**  $v_i$ . A proof for  $v_i$  is:

$$\pi_i = g^{\frac{\phi(\tau) - v_i}{\tau - \omega^i}} = g^{q_i(\tau)} \tag{92}$$

However, note that:

$$\frac{\phi(\tau) - \phi(\omega^i)}{\tau - \omega^i} = \frac{\sum_{j \in [0,n)} \mathcal{L}_j(\tau) v_j - v_i}{\tau - \omega^i}$$
(93)

$$= \frac{\sum_{j \in [0,n) \setminus \{i\}} \mathcal{L}_j(\tau) v_j}{\tau - \omega^i} + \frac{\mathcal{L}_i(\tau) v_i - v_i}{\tau - \omega^i}$$
(94)

$$= \sum_{j \in [0,n) \setminus \{i\}} v_j \frac{\mathcal{L}_j(\tau)}{\tau - \omega^i} + v_i \frac{\mathcal{L}_i(\tau) - 1}{\tau - \omega^i}$$

$$\tag{95}$$

Recall from Section 3.4.2 that (1) the ith update key contains a KZG commitment  $u_i$  to  $\frac{\mathcal{L}_i(\tau)-1}{\tau-\omega^i}$  and that (2) the  $a_i$ 's and  $a_j$ 's from  $\mathsf{upk}_i$  and  $\mathsf{upk}_j$  can be used to compute in O(1) time a KZG commitment  $u_{i,j}$  to  $\frac{\mathcal{L}_j(\tau)}{\tau-\omega^i}$ . (Note that the partial fraction decomposition only requires evaluating a degree-1 polynomial at two points. Also, computing  $A'(\omega^j)$  can be done in O(1) time as explained in Appendix A.) Thus, the proof  $\pi_i$  can be computed in O(n) field operations and O(n) exponentiations as:

$$\pi_i = g^{q_i(\tau)} = \prod_{j \in [0,n) \setminus \{i\}} (u_{i,j})^{v_j} \cdot (u_i)^{v_i}$$
(96)

<span id="page-24-0"></span>Table 3. Asymptotic comparison of our aSVC with (aS)VCs based on hidden-order groups. n is the vector size, b is the subvector size,  $\ell$  is the length in bits of vector elements,  $N=n\ell$  and  $\lambda$  is the security parameter. For schemes based on hidden-order groups, the complexities in the table are asymptotic in terms group operations rather than exponentiations. This gives a better sense of performance, since exponents cannot be "reduced" in hidden-order groups as they can in known-order groups. We try to account for field operations (of size  $2\lambda$  bits), but quantifying them precisely in these schemes can be very cumbersome. Also, since field operations are much faster, they can be mostly ignored. For our aSVC scheme, we give the same complexities in terms of group exponentiations, pairings and field operations (see Appendix D.7 for details). Because of this, the reader must be careful when comparing our scheme with the other schemes in this table: a group exponentiation in our scheme is roughly equivalent to  $O(\lambda)$  group operations in the hidden-order group schemes. (\*Updating the commitment in CFG $_{\ell}^{1}$  only works in a weaker security model where the commitment is not produced adversarially.)

| (aS)VC scheme                          | prk | vrk | $\begin{array}{c}  upk_i  \text{ or } \\  uph_i  \end{array}$ | Com.      | Com.<br>upd. | $ \pi_i $            | Prove one $v_i$ | $\begin{array}{c} \text{Verify} \\ \text{one} \\ v_i \end{array}$ | Proof<br>upd. | Prove subv. $(v_i)_{i \in I}$ | Verify subv. $(v_i)_{i \in I}$ | $\begin{array}{c} \text{Aggr-} \\ \text{egate} \end{array}$ | Prove each $(v_i)_{i \in [n]}$ |
|----------------------------------------|-----|-----|---------------------------------------------------------------|-----------|--------------|----------------------|-----------------|-------------------------------------------------------------------|---------------|-------------------------------|--------------------------------|-------------------------------------------------------------|--------------------------------|
| $BBF_{\ell}$ [BBF19]                   | 1   | 1   | 1                                                             | $N \lg N$ | $\ell \lg N$ | $\ell \lg N$ bits    | $N \lg N$       | $\ell \lg N + \lambda$                                            | ×             | $N \lg N$                     | $b\ell \lg N + \lambda$        | $\ell b \lg N$                                              | $N \lg^2 N$                    |
| $CFG_{\ell}^{1}$ [CFG <sup>+</sup> 20] | 1   | 1   | 1                                                             | $N \lg N$ | 1*           | $1  \mathbb{G}_{?} $ | $N \lg N$       | $\ell \lg N + \lambda$                                            | 1             | $\ell(n-b) \lg N$             | $b\ell \lg N + \lambda$        | $\ell b \lg b \lg N$                                        | $N \lg^2 N$                    |
| $CFG_{\ell}^{5}$ [CFG <sup>+</sup> 20] | 1   | 1   | 1                                                             | $N \lg n$ | 1            | $1  \mathbb{G}_{?} $ | $N \lg n$       | $\ell$                                                            | 1             | $\ell(n-b)\lg(n-b)$           | $\ell b$                       | $\ell b \lg^2 b$                                            | $N \lg n$                      |
| Our aSVC                               | n   | b   | 1                                                             | n         | 1            | 1                    | n               | 1                                                                 | 1             | $b \lg^2 b + n \lg n$         | $b \lg^2 b$                    | $b \lg^2 b$                                                 | $n \lg n$                      |

The proof can be verified in O(1) time using  $g^{\tau}$  from the vrk by computing two pairings:

$$e(c/g^{v_i}, g) = e(\pi_i, g^{\tau}/g^{\omega^i})$$

$$\tag{97}$$

**Proof Updates.** If any vector element  $v_j, j \neq i$  changes to  $v_j + \delta$ , the proof  $\pi_i$  can be updated in O(1) time using  $a_i, a_j$  from  $\mathsf{upk}_i, \mathsf{upk}_j$ . First, one computes  $u_{i,j}$  in O(1) time as described in the previous paragraph. Then, one updates  $\pi'_i = \pi_i \cdot (u_{i,j})^{\delta}$  in O(1) time. This new  $\pi'_i$  will verify against the updated c' commitment defined earlier. If  $v_i$  changes to  $v_i + \delta$ , the proof  $\pi_i$  is updated in O(1) time using  $u_i$  from  $\mathsf{upk}_i$  as  $\pi'_i = \pi_i \cdot (u_i)^{\delta}$  (see Section 3.4.2).

Subvector Proofs for  $(v_i)_{i \in I}$  We use the same style of subvector proofs as in Appendix D.2. Thus, the subvector proving time is  $O(n \log n + b \log^2 b)$  and the subvector proof verification time is  $O(b \log^2 b)$  time.

Aggregating Proofs and Precomputing All Proofs. Aggregating all proofs  $(\pi_i)_{i\in I}$  requires computing coefficients  $c_i = 1/A'_I(\omega^i), \forall i \in I$  using partial fraction decomposition (see Section 3.4.1). This can be done by (1) computing  $A_I(X) = \prod_{i\in I}(X-\omega^i)$  in  $O(b\log^2 b)$  field operations, (2) computing its derivative  $A'_I(X)$  in O(b) field operations and (3) evaluating  $A'_I(X)$  at all  $(\omega^i)_{i\in I}$  using a multipoint evaluation in  $O(b\log^2 b)$  field operations [vzGG13b]. Then, the subvector proof can be aggregated with O(b) exponentiations as:

$$\pi_I = \prod_{i \in I} \pi_i^{c_i} \tag{98}$$

Thus, aggregation takes  $O(b \log^2 b)$  time.

Finally, precomputing all proofs can be done efficiently in  $O(n \log n)$  time using the FK technique [FK20].

Slower Commitment Time for Faster (Subvector) Proofs. When comitting to a vector, we can use the FK technique to precompute all n proofs in  $O(n \log n)$  time and store them as auxiliary information. Then, we can serve any individual proof  $\pi_i$  in O(1) time and any subvector proof in  $O(b \log^2 b)$  time by aggregating it from the  $\pi_i$ 's.

# <span id="page-24-1"></span>E Complexity of VCs Based on Hidden-order Groups

We give complexities of VCs based on hidden-order groups in Table 3. These can be challenging to describe succinctly due to the many variable-length integer operations that arise. In an effort to keep complexities simple without leaving out too much detail, we often measure (and even approximate) complexities in terms of operations in a finite field of size  $2^{2\lambda}$  (e.g., additions, multiplications, computing Bézout coefficients, Shamir tricks), where  $\lambda$  is our security parameter. Another reason to do so is for fairness with VC schemes in known-order groups, which also use finite fields of size  $2^{2\lambda}$ . Otherwise, a  $2\lambda$ -bit multiplication would be counted as  $O(\lambda \log \lambda)$  in schemes such as BBF<sub> $\ell$ </sub> [BBF18]<sup>3</sup> and as O(1) time for schemes like KZG (see Appendix D.2).

The Shamir Trick. The "Shamir Trick" [Sha81, BBF18] can be used to compute an eth root of g given an  $e_1$ th root and an  $e_2$ th root where  $e=e_1e_2$  and  $\gcd(e_1,e_2)=1$ . The idea is to compute Bézout coefficients a,b such that  $ae_1+be_2=1$ . Then,  $\left(g^{\frac{1}{e_1}}\right)^b\left(g^{\frac{1}{e_2}}\right)^a=g^{\frac{be_2}{e_1e_2}}g^{\frac{ae_1}{e_1e_2}}=g^{\frac{ae_1+be_2}{e_1e_2}}=g^{\frac{1}{e_1e_2}}$ . Note that  $|a|\approx |e_2|$  and  $|b|\approx |e_1|$ .

<span id="page-24-2"></span><sup>&</sup>lt;sup>3</sup> Assuming recent progress on multiplying b-bit integers in  $O(b \log b)$  time.

## <span id="page-25-0"></span>E.1 Complexity of $BBF_{\ell}$ [BBF19]

In this scheme, we assume the vector  $\mathbf{v} = [v_1, v_2, \dots, v_n]$  is indexed from 1 to n.

**Public Parameters.** Let  $\ell$  denote the size of vector elements in bits. Let n denote the number of vector elements. Let  $N = \ell n$ . Let  $\mathbb{G}_{?}$  denote a hidden-order group and g be a random group element in  $\mathbb{G}_{?}$ . Let  $H : [N] \to \mathsf{Primes}$  be a bijective function that on input i outputs the ith prime number  $p_i$ . (Note that  $|p_N| = \log{(\ell n)}$  bits.) The prk and vrk consist of only g. This scheme does not use "fixed" update keys compatible with our definitions. Instead, this scheme uses "dynamic" update hints: the ith update hint w.r.t. a commitment c is a VC proof for  $v_i$  that verifies against c. In this sense, similar to Merkle trees, this scheme is less suitable for account-based stateless cryptocurrencies [CPZ18], since it requires user i to fetch user j's proof too, before sending her money.

Commitment. An  $\ell$ -bit vector element  $v_i$  can be written as a vector of  $\ell$  bits  $(v_{i,j})_{j \in [0,\ell-1]}$  Then, each bit  $v_{i,j}$  is mapped to the unique prime  $p_{(i-1)\cdot\ell+j}$ . Put differently, each  $v_i$  is mapped to  $\ell$  unique primes  $(p_{(i-1)\cdot\ell+0}, p_{(i-1)\cdot\ell+1}, \ldots, p_{(i-1)\cdot\ell+(\ell-1)})$ . Then, for each  $v_i$ , take the product of all primes corresponding to non-zero bits as  $P_i = \prod_{j \in [0,\ell-1]} v_{i,j} \cdot (p_{(i-1)\cdot\ell+j})$ . Note that  $|P_i| = O(\ell \log (\ell n))$ . A commitment to the vector  $\mathbf{v} = (v_i)_{i \in [n]}$  will be an RSA accumulator over these  $P_i$ 's:

$$c = g^{\prod_{i \in [n]} \prod_{j \in [0, \ell-1]} v_{i,j} \cdot (p_{(i-1)\cdot \ell+j})}$$
(99)

$$=g^{\prod_{i\in[n]}P_i}\tag{100}$$

The exponent of c is a product of at most  $\ell n$  primes, with the biggest prime having size  $O(\log(\ell n))$ . Thus, computing the O(1)-sized commitment c takes  $O(\ell n \log(\ell n))$  group operations. (Note that, for hidden-order groups, we are counting group operations rather than exponentiations. This is to give a better sense of performance, which varies with the exponent size, since exponents cannot be "reduced" in hidden-order groups.)

Since updating commitments requires update hints, which are VC proofs, we must first discuss VC proofs.

#### E.1.1 Proofs for a $v_i$

A proof  $\pi_i$  for  $v_i$  must show two things:

- 1. That  $P_i$  corresponding to all non-zero bits is accumulated in c.
- 2. That  $Z_i = \prod_{j \in [0, \ell-1]} (1 v_{i,j}) \cdot (p_{(i-1) \cdot \ell+j})$  corresponding to all zero bits is *not* accumulated in c. (Note that  $|Z_i| = |P_i| = O(\ell \log(\ell n))$ .)

**Proving "One" Bits are Accumulated.** To prove  $P_i$  is "in", an O(1)-sized RSA accumulator subset proof w.r.t. c can be computed with  $O(\ln \log (\ln n))$  group operations (via A.MemWitCreate\* in [BBF18, Sec 4.2, pg. 15]):

<span id="page-25-1"></span>
$$\pi_i^{[1]} = g^{\prod_{j \in [n], j \neq i} P_j} = c^{1/P_i} \tag{101}$$

To speed up the verification of this (part of) the proof, a constant-sized proof of exponentiation (PoE) [BBF18] is computed in  $O(\ell \log (\ell n))$  field and group operations. We discuss this later in Appendix E.1.2.

Proving "Zero" Bits are Accumulated. To prove  $Z_i$  is "out", an  $O(\ell \log{(\ell n)})$ -sized disjointness proof  $\pi_i^{[0]}$  can be computed w.r.t. c (via A.NonMemWitCreate in [BBF18, Sec 4.1, pg. 14]). First,  $Z_i$  must be computed, but we assume this can be done in  $O(\ell \log{(\ell n)})$  field operations. Second, Bézout coefficients are computed such that  $\alpha \prod_{i \in n} P_i + \beta Z_i = 1$ . Then, the disjointness proof is  $\pi_i^{[0]} = (g^\beta, \alpha)$ . Since  $|\alpha| \approx |Z_i|$ , the proof is  $O(\ell \log{(\ell n)})$ -sized. Although this disjointness proof can be made O(1)-sized via proofs of knowledge of exponent (PoKE) proofs, this seems to break the ability to aggregate VC proofs in BBF $_\ell$  [BBF18, Sec 5.2, pg. 20]. However, the prover can still include two constant-sized PoE proofs for  $(g^\beta)^{Z_i}$  and for  $c^\alpha$  to make the verifier's job easier, which costs him only  $O(\ell \log{(\ell n)})$  field and group operations.

To analyze the time complexity of computing  $\pi_i^{[0]}$ , recall that:

- 1. The asymptotic complexity of computing Bézout coefficients on b-bit numbers is  $O(b \log^2 b)$  time.
- 2.  $b = \left| \prod_{i \in n} P_i \right| = O(n\ell \log (\ell n)).$

As a result, the Bézout coefficients take  $O((n\ell \log{(\ell n)})\log^2{(n\ell \log{(\ell n)})} = O(n\ell \log{(\ell n)}(\log{n\ell} + \log\log{(\ell n)})^2) = O(n\ell \log^3(\ell n))$  time. However, since these are bit operations, we will count them as  $O(n\ell \log{(\ell n)})$  field operations. Furthermore, computing  $g^{\beta}$ , where  $|\beta| \approx |\prod_{i \in [n]} P_i| = O(n\ell \log{(\ell n)})$  takes  $O(n\ell \log{(\ell n)})$  group operations.

Overall, the time to compute  $\pi_i$  is  $O(\ln \log (\ln n)) = O(\ln \log n)$ .

## <span id="page-26-0"></span>E.1.2 Verifying a Proof for $v_i$

To verify  $\pi_i = (\pi_i^{[0]}, \pi_i^{[1]})$ , the verifier proceeds as follows. First, he computes  $P_i$  in  $O(\ell \log (\ell n))$  field operations. Second, he checks that  $\left(\pi_i^{[1]}\right)^{P_i} = c$  via the PoE proof in  $\pi_i^{[1]}$  using  $O(\lambda)$  group operations and  $O(\ell \log n)$  field operations. Third, he parses  $(g^{\beta}, \alpha)$  from  $\pi_i^{[0]}$  and checks if  $(g^{\beta})^{Z_i} c^{\alpha} = g$ . Since the prover included PoE proofs, this can be verified with  $O(\lambda)$  group operations and  $O(\ell \log (\ell n))$  field operations.

## E.1.3 Updates

**Updating Commitments.** Suppose  $v_i$  changes to  $v_i'$ . For message bits that are changed from 0 to 1, updating the commitment c involves "accumulating" new primes associated with those bits in c. For message bits that are changed from 1 to 0, updating c involves removing the primes associated with those bits from c. Recall that, in BBF $_\ell$ , the ith update hint  $\mathsf{uph}_i$  is actually the VC proof  $\pi_i$  for  $v_i$  w.r.t. c. Also recall that  $\pi_i^{[1]} = c^{1/P_i}$  from  $\pi_i$  is exactly the commitment c without any of the primes associated with  $v_i$ . Thus, to update the commitment, we can compute  $P_i' = \prod_{j \in [0,\ell-1]} v_{i,j}' p_{(i-1)\cdot \ell+j}$  in  $O(\ell)$  field operations and set  $c' = \left(\pi_i^{[1]}\right)^{P_i'}$  in  $O(\ell \log{(\ell n)})$  group operations.

To process several updates for b updated elements  $(v_i)_{i\in I}$  with  $\mathsf{uph}_i$ 's that all verify w.r.t. c, we have to take an additional step. First, we use O(b) Shamir tricks on the  $\pi_i^{[1]}$ 's from  $\mathsf{uph}_i$  to obtain the commitment  $c^{1/\prod_{i\in I}P_i}$ , which no longer accumulates any primes associated with the old elements  $(v_i)_{i\in I}$ . Then, we can add back the new primes  $P_i'$  associated with the new elements  $(v_i')_{i\in I}$  in  $O(b\ell\log(\ell n))$  group operations. We assume the O(b) Shamir tricks can be done in O(b) field operations.

**Updating Proofs.** Proof updates are not discussed in [BBF19], but seem possible. We leave it to future work to describe them and their complexity.

## E.1.4 Subvector Proofs for $(v_i)_{i \in I}$

Recall that a normal VC proof for  $v_i$  reasons about which primes associated with  $v_i$  are (not) accumulated in c. A subvector proof will do the same, except it will reason about primes associated with all  $(v_i)_{i \in I}$ . Thus, instead of reasoning about two  $O(\ell \log (\ell n))$ -sized  $P_i$  and  $Z_i$ , it will reason about two  $O(b\ell \log (\ell n))$ -sized  $\prod_{i \in I} P_i$  and  $\prod_{i \in I} Z_i$ . Specifically, an I-subvector proof consists of:

$$\pi_I^{[1]} = g^{\prod_{j \in [n] \setminus I} P_j} = c^{1/\prod_{i \in I} P_i} \tag{102}$$

$$\pi_I^{[0]} = (g^{\beta}, \alpha) \text{ such that } (g^{\beta})^{\prod_{i \in I} Z_i} c^{\alpha} = g$$
 (103)

Let us analyze the proving time and the proof size. First, computing  $\pi_I^{[1]}$  can be done in  $O(\ell(n-b)\log(\ell n))$  group operations, which is slightly faster than the  $O(\ell n\log(\ell n))$  time for computing  $\pi_i^{[1]}$  in an individual proof for  $v_i$  (see Equation (101)). Second, computing the PoE for  $\left(\pi_I^{[1]}\right)^{\prod_{i\in I}P_i}=c$  can be done in  $O(b\ell\log(\ell n))$  field and group operations. Third, computing  $\pi_I^{[0]}$  maintains the same asymptotic complexity, since it is dominated by the time to compute  $g^\beta$ , which remains just as expensive. However,  $\pi_I^{[0]}$ 's size would increase to  $O(b\ell\log(\ell n))$ , since the Bézout coefficient  $\alpha$  will be roughly of size  $|\prod_{i\in I} Z_i|$ . Fortunately, the prover can avoid this by giving  $c^\alpha$  rather than  $\alpha$  along with a PoKE proof (i.e., one group element and one  $2\lambda$ -bit integer), while maintaining the same asymptotic complexity. As before, the prover also gives a PoE proof for  $\left(g^\beta\right)^{Z_i}$  to speed up the verifier's job.

Because of the PoE proof, verification of  $\pi_I^{[1]}$  only requires  $O(\lambda)$  group operations as before, but the number of field operations increases to  $O(b\ell \log{(\ell n)})$ . Similarly, the PoKE proof will speed up verification of  $\pi_I^{[0]}$  to  $O(\lambda)$  group operations, but the  $O(b\ell \log{(\ell n)})$  field operations remain for verifying the PoE proof for  $(g^\beta)^{Z_i}$ .

#### E.1.5 Aggregating Proofs

Since aggregating RSA membership and non-membership witnesses is possible [BBF18], and BBF $_\ell$  VC proofs consist of one RSA membership (subset) proof and one non-membership (disjointness) proof, it follows that aggregating proofs is possible. We leave it to future work to analyze the complexity of aggregation, which has to be at least  $\Omega(b\ell \log{(\ell n)})$  since it must read all b VC proofs as input, which are each  $O(\ell \log{(\ell n)})$ -sized.

## E.1.6 Precomputing All Proofs

Computing all membership and non-membership witnesses for an RSA accumulators over N elements is possible in  $O(N \log N)$  exponentiations [BBF18,STSY01]. Since for BBF $_\ell$  we have  $N = \ell n$  and an exponentiation costs  $O(\log (\ell n))$  group operations, this would take  $O(\ell n \log^2 (\ell n))$  group operations. We are ignoring (1) the overhead of aggregating membership and non-membership witnesses and (2) the overhead of computing PoE proofs, which we assume is dominated by the cost to compute the witnesses.

# E.2 Complexity of CFG $_{\ell}^1$ [CFG $^+$ 20] and CFG $_{\ell}^2$ [CF13,LM19,CFG $^+$ 20]

We refer the reader to [CFG<sup>+</sup>20, Table 1, pg. 35] for most of these these complexities.

**Aggregating Proofs.** For CFG<sub> $\ell$ </sub><sup>1</sup>, aggregating b proofs into an I-subvector proof takes  $O(b \log b \log N)$  group operations [CFG<sup>+</sup>20, Sec 5.1, pg. 23]. For CFG<sub> $\ell$ </sub><sup>2</sup>, this takes  $O(\ell b \log^2 b)$  group operations [CFG<sup>+</sup>20, Sec 5.2, pg. 32].

**Precomputing All Proofs.** The paper gives a generic technique of using incremental (dis)aggregation to precompute auxiliary information for serving proofs fast. This technique can also be used to precompute all proofs fast in quasilinear time. In  $CFG_{\ell}^1$ , we believe this will take  $O(N\log^2 N)$  group operations, dominated by the complexity of computing all  $N = \ell n$  RSA accumulator membership witnesses. In  $CFG_{\ell}^2$ , we estimate this will take  $O(\ell n \log n)$  group operations (since disaggregating a proof of size m into two proofs of size m/2 takes  $O(\ell m)$  group operations).