---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/590';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'An Algebraic Framework for Universal and Updatable SNARKs';
const AUTHORS_HTML = 'Carla Ràfols, Arantxa Zapico';

const CONTENT = `    <p class="text-gray-300">An Algebraic Framework for Universal and Updatable SNARKs</p>

    <p class="text-gray-300">Carla Ràfols\\<em>,1,2 and Arantxa Zapico\\</em>\\*,1</p>

    <p class="text-gray-300"><span class="math">^{1}</span> Universitat Pompeu Fabra <span class="math">^{2}</span> Cybercat carla.rafols@upf.edu, arantxa.zapico@upf.edu</p>

    <p class="text-gray-300">Abstract. We introduce Checkable Subspace Sampling Arguments, a new information theoretic interactive proof system in which the prover shows that a vector has been sampled in a subspace according to the verifier's coins. We show that this primitive provides a unifying view that explains the technical core of most of the constructions of universal and updatable pairing-based (zk)SNARKs. This characterization is extended to a fully algebraic framework for designing such SNARKs in a modular way. We propose new constructions of CSS arguments that lead to SNARKs with different performance trade-offs. Our most efficient construction, Basilisk, seems to have the smallest proof size in the literature, although it pays a price in terms of structure reference string for the number of multiplicative gates whose fan-out exceeds a certain bound.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Zero-Knowledge proofs [GMR89], and in particular, non-interactive ones [BFM88] have played a central role in both the theory and practice of cryptography. A long line of research [Kil92, Mic00, Gro10, GGPR13, Gro16] has led to efficient pairing-based zero-knowledge Succinct Non-interactive ARguments of Knowledge or SNARKs. These arguments are succinct, in fact, they allow to prove that circuits of arbitrary size are satisfied with a constant-size proof. They are also extremely efficient concretely (3 group elements in the best construction for arithmetic circuits [Gro16]).</p>

    <p class="text-gray-300">Despite this impressive performance, some aspects of these constructions of SNARKs are still unsatisfactory. Probably the most problematic and not fully solved issue is their reliance on long trusted, structured, and circuit dependent parameters (a circuit dependent SRS, for structured reference string).</p>

    <p class="text-gray-300">Albeit the significant research effort in finding alternatives to bypass the need of a trusted third party by constructing transparent arguments, i.e. in the uniform random string model (URS) [BBB⁺18, BCC⁺16, BBHR18, AHIV17, BBHR19, COS20, XZZ⁺19, WTs⁺18], pairing-based SNARKs such as [Gro16] still seem the most practical alternative in many settings due to their very fast verification, which is a must in many blockchain applications. On the other hand, multiparty solutions for the problem are not fully scalable [BGG19, BGM17].</p>

    <p class="text-gray-300">As an alternative to a trusted SRS, Groth et al. [GKM⁺18] define the updatable model, in which the SRS can be updated by any party, non-interactively, and in a verifiable way, resulting in a properly generated structured reference string where the simulation trapdoor is unknown to all parties if at least one is honest. Further, they propose a construction where the SRS is universal and can be used for arbitrary circuits up to a maximum given size.</p>

    <p class="text-gray-300">Arithmetic Circuit Satisfiability can be reduced to a set of quadratic and affine constraints over a finite field. The quadratic ones are universal and can be easily proven in the pairing-based setting with a Hadamard product argument, the basic core of most zkSNARKS constructions starting from [GGPR13]. On the other</p>

    <p class="text-gray-300">\\* This paper is part of a project that has received funding from the European Union’s Horizon 2020 research and innovation programme under grant agreement No 856879.</p>

    <p class="text-gray-300">\\<em>\\</em> The project that gave rise to these results received the support of a fellowship from la Caixa Foundation (ID100010434). The fellowship code is LCF/BQ/DI18/11660052. This project has received funding from the European Union’s Horizon 2020 research and innovation programme under the Marie Skłodowska-Curie grant agreement No.71367.</p>

    <p class="text-gray-300">hand, affine constraints are circuit-dependent, and it is a challenging task to efficiently prove them with a universal SRS <em>[x11, CHM^{+}20, x10, CFF^{+}20, x13, x14, x15, x20]</em>.</p>

    <p class="text-gray-300">In Groth et al. <em>[GKM^{+}18]</em> they are proven via a very expensive subspace argument that requires a SRS quadratic in the circuit size and a preprocessing step that is cubic. Sonic <em>[x11]</em>, the first efficient, universal, and updatable SNARK, gives two different ways to prove the affine constraints, a fully succinct one (not so efficient) and another one in the amortized setting (very efficient). Follow-up work (most notably, Marlin <em>[CHM^{+}20]</em>, Plonk <em>[x10]</em>, Lunar <em>[CFF^{+}20]</em>) has significantly improved the efficiency in the fully succinct mode.</p>

    <p class="text-gray-300">There is an important trend in cryptography, that advocates for constructing protocols in a modular way. One reason for doing so is the fact that, by breaking complicated protocols into simpler steps, they become easier to analyze. Ishai <em>[x15]</em> mentions comparability as another fundamental motive. Specially in the area of zero-knowledge, given the surge of interest in practical constructions, it is hard not to lose sight of what each proposal achieves. As Ishai puts it: “one reason such comparisons are difficult is the multitude of application scenarios, implementation details, efficiency desiderata, cryptographic assumptions, and trust models”.</p>

    <p class="text-gray-300">Starting from Sonic, all the aforementioned works on universal and updatable zkSNARKs follow this trend. More concretely, they first build an information-theoretic proof system, that is then compiled into a full argument under some computational assumptions in bilinear groups. The main ingredient of the compiler is a polynomial commitment <em>[x16, x2, x14]</em>. However, the information theoretic component is still very complex and comparison among these works remains difficult, for precisely the same reasons stated by Ishai. In particular, it is hard to extract the new ideas in each of them in the complex description of the arguments, that use sophisticated tricks for improving efficiency, as well as advanced properties of multiplicative subgroups of a finite field or bivariate Lagrange interpolation. Further, it is striking that all fully succinct arguments are for restricted types of constraints (sums of permutations in Sonic, sparse matrices in Marlin, and Lunar) or pay a price for additive gates (Plonk). A modular, unified view of these important works seems essential for a clearer understanding of the techniques. In turn, this should allow for a better comparison, more flexibility in combining the different methods, and give insights on current limitations.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Our Contributions.</h4>

    <p class="text-gray-300">We propose an algebraic framework that takes a step further in achieving modular constructions of universal and updatable SNARKs. We identify the technical core of previous work as instances of a <em>Checkable Subspace Sampling</em> (CSS) Argument. In this information-theoretic proof system, two parties, prover and verifier, on input a field <span class="math">\\mathbb{F}</span> and a matrix <span class="math">\\mathbf{M}\\in\\mathbb{F}^{Q\\times m}</span>, agree on a polynomial <span class="math">D(X)</span> encoding a vector <span class="math">\\bm{d}</span> in the row space of <span class="math">\\mathbf{M}</span>. The interesting part is that, even though the coefficients of the linear combination that define <span class="math">\\bm{d}</span> are sampled with the verifier’s coins, the latter does not need to perform a linear (in <span class="math">Q</span>, the number of rows) number of operations to verify that <span class="math">D(X)</span> is correct. Instead, this must be demonstrated by the prover.</p>

    <p class="text-gray-300">With this algebraic formulation, it is immediate to see that a CSS argument can be used as a building block for an argument of membership in linear spaces. Basically, given a matrix <span class="math">\\mathbf{M}</span>, we can prove that some vector <span class="math">\\bm{y}</span> is orthogonal to the row vectors of <span class="math">\\mathbf{M}</span> by sampling after <span class="math">\\bm{y}</span> is declared, a <em>sufficiently random</em> vector <span class="math">\\bm{d}</span> in the row space of <span class="math">\\mathbf{M}</span> and checking an inner product relation, namely, whether <span class="math">\\bm{d}\\cdot\\bm{y}=0</span>. The purpose of a CSS argument is to guarantee that the sampling process can be checked by the verifier in sublinear time without sacrificing soundness.</p>

    <p class="text-gray-300">Naturally, for building succinct proofs, instead of <span class="math">\\bm{y},\\bm{d}</span>, the argument uses polynomial encodings <span class="math">Y(X)</span> and <span class="math">D(X)</span> (which are group elements after the compilation step). To compute the inner product of this encoded vectors, we introduce a new argument in Section 3, which is specific to the case where the polynomials are encoded in the Lagrange polynomial basis but can be easily generalized to the monomial basis. The argument is a straightforward application of the univariate sumcheck of Aurora <em>[BCR^{+}19]</em>. However, we contribute a</p>

    <p class="text-gray-300">generalized sumcheck (that works not only for multiplicative subgroups of finite fields), with a completely new proof that relates it with polynomial evaluation at some fixed point <span class="math">v</span>.</p>

    <p class="text-gray-300">These building blocks can be put together as an argument for the language of Rank1 constraint systems. For efficiency, we stick to R1CS-fite, a variant recently proposed by Lunar, which is slightly simpler but still NP-complete. Our final construction can be instantiated with any possible choice of CSS scheme, so in particular, it can essentially recover the construction of Marlin and Lunar by isolating the CSS argument implicit in these works, or the amortized construction of Sonic. We hope that this serves to better identify the challenge behind building updatable and universal SNARKs, and allow for new steps in improving efficiency, as well as more easily combining the techniques.</p>

    <p class="text-gray-300">In summary, we reduce R1CS constraint systems to three algebraic relations: an inner product, a Hadamard product, and a CSS argument. We think this algebraic formulation is very clear, and also makes it easier to relate advances in universal and updatable SNARKS with other works that have used a similar language, for example, the arguments for inner product of <em>[BCC^{+}16]</em>, of membership in linear spaces <em>[x11]</em>, or for linear algebra relations <em>[x13]</em>.</p>

    <p class="text-gray-300">Finally, we give several constructions of CSS arguments. In Section 5, we start from the representation of a matrix <span class="math">\\mathbf{W}</span> as bivariate polynomial introduced in <em>[CHM^{+}20]</em> to construct an alternative CSS argument for sparse matrices. Our contribution is to introduce a new linearization step that allows us to build it modularly from an argument for what we refer to as <em>simple matrices</em>, i.e., those with at most one non-zero element per column. Compared to <em>[CHM^{+}20, CFF^{+}20]</em>, at a minimal increase in communication cost, our argument significantly reduces the size of the derived SRS. We generalize these arguments to sums of simple and sparse matrices, without increasing the communication complexity. In Section 7, we show the helped Sonic mode works as a CSS argument in the amortized setting. In Section 6, we introduce a CSS argument that works for arbitrary matrices and, even though it requires quadratic indexer work and linear verifier memory, can be combined with other schemes to increase efficiency or expressivity, as we show in Section 4.4.</p>

    <p class="text-gray-300">In the appendix, we introduce a generalized universal relation that captures the one considered in Plonk <em>[x12]</em> and we study the performance trade-offs resulting from the different possible choices of CSS argument of Section 5. In particular. we observe that the argument for simple matrices and sums of simple matrices is useful on its own, and not only to achieve modularity. We study the efficiency of our zkSNARK when: a) the CSS argument is our argument for sparse matrices of Section 5.3, b) when the Plonk constraint system is used and the matrix of constraints is a permutation, which is a special case of a simple matrix, and c) when the circuit has bounded fan-out, which results in a matrix of constraints that is a sum of simple matrices. To the best of our knowledge, the latter construction is the most efficient in proof size updatable and universal zkSNARK. Following the trend to give SNARKs the name of fabulous creatures, and given the importance of linear algebra and the Lagrange basis in our work, we call it BASILISK.</p>

    <p class="text-gray-300">The efficiency of the zkSNARKs built from the different CSS arguments detailed can be found in Table 1. The details of the constructions are given in the Appendix.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Bivariate Polynomial Evaluation Arguments.</h4>

    <p class="text-gray-300">As mentioned before, the complexity of building updatable and universal zkSNARKs protocols is mainly caused by proving affine constraints. A natural way to encode them is through a bivariate public polynomial <span class="math">P(X,Y)</span>; in order to avoid having a quadratic SRS, this polynomial can only be given to the verifier evaluated or partially evaluated in the field. The common approach is to let the verifier chose arbitrary field elements <span class="math">x,y</span> and having the prover evaluate and send <span class="math">\\sigma=P(y,x)</span>. The challenge is to prove that the evaluation has been performed correctly. In Sonic <em>[x16]</em>, this last step is called a <em>signature of correct computation</em> <em>[x19]</em> and can be performed by the prover or by the verifier with some help from an untrusted third party. The drawback of the first construction is that, while still linear, prover’s work is considerably costly; also, linear constraints are assumed to be sparse and the protocol works exclusively for a very particular polynomial <span class="math">P(X,Y)</span>. The second construction is interesting only in some restricted settings where the same verifier checks a linear amount of proofs for one circuit. Marlin <em>[CHM^{+}20]</em> bases its construction on the univariate sum-check protocol of Aurora <em>[BCR^{+}19]</em> and presents a novel way to navigate from the naive quadratic representation <span class="math">P(X,Y)</span> to a linear one. This</p>

    <p class="text-gray-300">approach results in succinct prover and verifier work, but restricts their protocol to the case where the number of non-zero entries of matrix  <span class="math">\\mathbf{W}</span>  is bounded by the size of some multiplicative subgroup of the field of definition. Lunar  <span class="math">\\left[\\mathrm{CFF}^{+}20\\right]</span>  uses the same representation as Marlin but improves on it, among other tweaks by introducing a new language (R1CS-lite) that can also encode arithmetic circuit satisfiability, but has a lighter representation than other constraint systems. Plonk [GWC19] does not use bivariate polynomials or require sparse matrices but the SRS size depends on the number of both multiplicative and additive gates. As we do, Plonk, Marlin and Lunar use the Lagrange interpolation basis to commit to vectors, while Claymore [SZ20] presents a modular construction for zkSNARKs based on similar algebraic building blocks but in the monomial basis: inner product, Hadamard product and matrix-vector product arguments. Notably, it also uses implicitly a CSS argument.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">srsu</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">srsw</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KeyGen</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Derive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Sonic [MBKM19]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">4M</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">4M</td>

            <td class="px-3 py-2 border-b border-gray-700">36m</td>

            <td class="px-3 py-2 border-b border-gray-700">273m</td>

            <td class="px-3 py-2 border-b border-gray-700">7P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">4M</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4M</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log K)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Marlin [CHM+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3K</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">3K</td>

            <td class="px-3 py-2 border-b border-gray-700">12K</td>

            <td class="px-3 py-2 border-b border-gray-700">14m + 8K</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log K)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonk [GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3N</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">3N</td>

            <td class="px-3 py-2 border-b border-gray-700">8n</td>

            <td class="px-3 py-2 border-b border-gray-700">11n</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">LunarLite2x4 [CFF+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">16K</td>

            <td class="px-3 py-2 border-b border-gray-700">8m + 4K</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log K)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work Sec. 5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700">K</td>

            <td class="px-3 py-2 border-b border-gray-700">6K</td>

            <td class="px-3 py-2 border-b border-gray-700">6m + 4K</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(K log K)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log K)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work Fig. 11</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">N</td>

            <td class="px-3 py-2 border-b border-gray-700">11n</td>

            <td class="px-3 py-2 border-b border-gray-700">8n</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Basilisk App. F</td>

            <td class="px-3 py-2 border-b border-gray-700">G1</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">3V + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">M</td>

            <td class="px-3 py-2 border-b border-gray-700">(3v + 1)m</td>

            <td class="px-3 py-2 border-b border-gray-700">6m</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">G2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">F</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(l + log m)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1. Comparison with state of the art universal and updatable zkSNARKs.  <span class="math">m</span> : number of multiplicative gates,  <span class="math">n</span> : number of total gates,  <span class="math">v</span> : bounded fan-out,  <span class="math">K</span> : non-zero elements of the matrix that describe the circuit  $\\left( {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">{\\mathbf{F} + \\mathbf{G}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right.<span class="math">  in our case).  </span>N,\\bar{K},V,M<span class="math">  : maximum supported values for  </span>n,K,m,v<span class="math">  .  </span>{N}^{ * } = M + A$  . The numbers for our work take into account the trick to eliminate non-trivial degree checks in App.E.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Information Theoretic Proof Systems. All these previous works follow the two step process described in the introduction and build their succinct argument by compiling an information theoretically secure one. Marlin introduces Algebraic Holographic proofs, that are variation of interactive oracle proofs (IOPs) [BCS16].</p>

    <p class="text-gray-300">Holographic refers to the fact that the verifier never receives the input explicitly (otherwise, succinctness would be impossible), but rather its encoding as an oracle computed by an indexer or encoder. The term algebraic refers to the fact that oracles are low degree polynomials, and malicious provers are also bound to output low degree polynomials. This notion is similar to the one of Idealised Low Degree protocols of Plonk. Lunar refines this model by introducing Polynomial Holographic IOPs, which generalize these works mostly by allowing for a fine grained analysis of the zero-knowledge property, including degree checks, and letting prover and verifier send field elements.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Polynomial Commitments.</h4>

    <p class="text-gray-300">Polynomial commitments allow to commit to a polynomial <span class="math">p(X)\\in\\mathbb{F}[X]</span>, and open it at any point <span class="math">x\\in\\mathbb{F}</span>. As it is common, we will use a polynomial commitment based on the one by Kate et al. <em>[x10]</em>. Sonic gave a proof of extractability of the latter in the Algebraic Group Model <em>[x7]</em>, and Marlin completed the proof to make the commitments usable as a standalone primitive, and also have an alternative construction under knowledge assumptions. Both Marlin and Plonk considered versions of polynomial commitments where queries in the same point can be batched together. For this work, we use the same definitions and construction as these works. The formal definition is given in Section 2.4.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Untrusted Setup.</h4>

    <p class="text-gray-300">The original constructions of pairing-based zkSNARKs crucially depend for soundness on a trusted setup, although, as was shown in <em>[x1, x6]</em>, the zero-knowledge property is still easy to achieve when the setup is subverted. Groth et al. introduced the updatable SRS model in <em>[GKM^{+}18]</em> to address the issue of trust in SRS generation. There are several alternatives to achieve transparent setup and constant-size proofs, but all of them have either linear verifier <em>[BCC^{+}16, BBB^{+}18, BCR^{+}19, x2]</em>, or work only for very structured types of computation <em>[x3, WTs^{+}18]</em>. An exception is the work of Setty <em>[x17]</em>. Concretely, the approach is less efficient in terms of proof size and verification complexity compared to recent constructions of updatable and universal pairing-based SNARKs.</p>

    <h2 id="sec-6" class="text-2xl font-bold">2 Preliminaries</h2>

    <p class="text-gray-300">A bilinear group <span class="math">gk</span> is a tuple <span class="math">gk=(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,\\mathcal{P}_{1},\\mathcal{P}_{2})</span> where <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">q</span>, the elements <span class="math">\\mathcal{P}_{1},\\mathcal{P}_{2}</span> are generators of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> respectively, <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently computable, non-degenerate bilinear map, and there is an efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. Elements in <span class="math">\\mathbb{G}_{\\gamma}</span>, are denoted implicitly as <span class="math">[a]_{\\gamma}=a\\mathcal{P}_{\\gamma}</span>, where <span class="math">\\gamma\\in\\{1,2,T\\}</span> and <span class="math">\\mathcal{P}_{T}=e(\\mathcal{P}_{1},\\mathcal{P}_{2})</span>. With this notation, <span class="math">e([a]_{1},[b]_{2})=[ab]_{T}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">n\\in\\mathbb{N}</span>, <span class="math">[n]</span> is the set of integers <span class="math">\\{1,\\ldots,n\\}</span>. Vectors and matrices are denoted in boldface. Given two vectors <span class="math">\\bm{a},\\bm{b}</span>, their Hadamard product is denoted as <span class="math">\\bm{a}\\circ\\bm{b}</span>, and their inner product as <span class="math">\\bm{a}\\cdot\\bm{b}</span>. The subspace of polynomials of degree at most <span class="math">d</span> in <span class="math">\\mathbb{F}[X]</span> is denoted as <span class="math">\\mathbb{F}_{\\leq d}[X]</span>. Given a matrix <span class="math">\\mathbf{M}</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ refers to the number of its non-zero entries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.1 Constraint Systems</h3>

    <p class="text-gray-300">Formally, we will construct an argument for the universal relation <span class="math">\\mathcal{R}^{\\prime}_{\\text{R1CS-lite}}</span>, an equivalent of the relation <span class="math">\\mathcal{R}_{\\text{R1CS-lite}}</span> introduced in Lunar <em>[CFF^{+}20]</em>. The latter is a simpler version of Rank 1 Constraint Systems, it is still NP complete and encodes circuit satisfiability in a natural way:</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">(R1CS) Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">m,l,s\\in\\mathbb{N}</span>. We define the universal relation R1CS as:</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{R1CS}=\\left\\{\\begin{array}[]{c}(\\mathsf{R},\\textnormal{x},\\textnormal{w}):=\\left((\\mathbb{F},s,m,l,\\mathbf{F},\\mathbf{G},\\mathbf{O}),\\bm{x},\\bm{w}\\right):\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F},\\mathbf{G},\\mathbf{O}\\in\\mathbb{F}^{m\\times m},\\bm{x}\\in\\mathbb{F}^{l-1},\\bm{w}\\in\\mathbb{F}^{m-l},s=\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{O}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\},\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\textnormal{and for }\\bm{c}:=(1,\\bm{x},\\bm{w}),(\\mathbf{F}\\bm{c})\\circ(\\mathbf{G}\\bm{c})=\\mathbf{O}\\bm{c}\\end{array}\\right\\} \\]</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Definition 2. (R1CS-lite) Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">m, l, s \\in \\mathbb{N}</span> . We define the universal relation R1CS-lite as:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {R 1 C S - l i t e}} = \\left\\{ \\begin{array}{c} (\\mathsf {R}, \\mathsf {x}, \\mathsf {w}) := \\big ((\\mathbb {F}, s, m, l, \\mathbf {F}, \\mathbf {G}), \\boldsymbol {x}, \\boldsymbol {w} \\big): \\\\ \\mathbf {F}, \\mathbf {G} \\in \\mathbb {F} ^ {m \\times m}, \\boldsymbol {x} \\in \\mathbb {F} ^ {l - 1}, \\boldsymbol {w} \\in \\mathbb {F} ^ {m - l}, s = \\max  \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}, \\\\ a n d f o r \\boldsymbol {c} := (1, \\boldsymbol {x}, \\boldsymbol {w}), (\\mathbf {F} \\boldsymbol {c}) \\circ (\\mathbf {G} \\boldsymbol {c}) = \\boldsymbol {c} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">As an equivalent formulation of this relation, we use the following:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {R} _ {\\mathrm {R 1 C S - l i t e}} ^ {\\prime} = \\left\\{ \\begin{array}{c} (\\mathsf {R}, \\mathsf {x}, \\mathsf {w}) := \\big ((\\mathbb {F}, s, m, l, \\mathbf {F}, \\mathbf {G}), \\boldsymbol {x}, (\\boldsymbol {a} ^ {\\prime}, \\boldsymbol {b} ^ {\\prime}) \\big): \\mathbf {F}, \\mathbf {G} \\in \\mathbb {F} ^ {m \\times m}, \\boldsymbol {x} \\in \\mathbb {F} ^ {l - 1}, \\\\ \\boldsymbol {a} ^ {\\prime}, \\boldsymbol {b} ^ {\\prime} \\in \\mathbb {F} ^ {m - l}, s = \\max  \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}, \\text {a n d f o r} \\boldsymbol {a} := (1, \\boldsymbol {x}, \\boldsymbol {a} ^ {\\prime}), \\boldsymbol {b} := (\\mathbf {1}, \\boldsymbol {b} ^ {\\prime}) \\\\ \\left( \\begin{array}{c c} \\mathbf {I} &amp; \\mathbf {0} - \\mathbf {F} \\\\ \\mathbf {0} &amp; \\mathbf {I} - \\mathbf {G} \\end{array} \\right) \\left( \\begin{array}{c} \\boldsymbol {a} \\\\ \\boldsymbol {b} \\\\ \\boldsymbol {a} \\circ \\boldsymbol {b} \\end{array} \\right) = \\mathbf {0} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">To see they are equivalent, observe that, if in  <span class="math">\\mathcal{R}_{\\mathrm{R1CS - lite}}^{\\prime}</span>  we define the vector  <span class="math">c = a\\circ b</span> , the linear equation reads as  <span class="math">a = \\mathbf{F}c</span>  and  <span class="math">b = \\mathbf{G}c</span> . A formal proof is a direct consequence of the proof that arithmetic circuit satisfiability reduces to R1CS-lite found in Lunar([CFF+20]).</p>

    <p class="text-gray-300">In Appendix A we introduce  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span> , a generalization of these relations that can also express the relation considered in Plonk.</p>

    <h2 id="sec-9" class="text-2xl font-bold">2.2 zkSNARKs</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">\\mathcal{R}</span>  be a family of universal relations. Given a relation  <span class="math">\\mathsf{R} \\in \\mathcal{R}</span>  and an instance  <span class="math">\\mathsf{x}</span>  we call  <span class="math">\\mathsf{w}</span>  a witness for  <span class="math">\\mathsf{x}</span>  if  <span class="math">(\\mathsf{x}, \\mathsf{w}) \\in \\mathsf{R}</span> ,  $\\mathcal{L}(\\mathsf{R}) = \\{\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\exists \\mathsf{w} : (\\mathsf{x}, \\mathsf{w}) \\in \\mathsf{R}\\}<span class="math">  is the language of all the  </span>\\mathsf{x}<span class="math">  that have a witness  </span>\\mathsf{w}<span class="math">  in the relation  </span>\\mathsf{R}<span class="math"> , while  </span>\\mathcal{L}(\\mathcal{R})<span class="math">  is the language of all the pairs  </span>(\\mathsf{x}, \\mathsf{R})<span class="math">  such that  </span>\\mathsf{x} \\in \\mathcal{L}(\\mathsf{R})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 3. A Universal Succinct Non-Interactive Argument of Knowledge is a tuple of PPT algorithms (KeyGen, KeyGenD, Prove, Verify, Simulate) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{srs}_{\\mathsf{u}},\\tau)\\gets \\mathsf{KeyGen}(\\mathcal{R})</span>  : On input a family of relations  <span class="math">\\mathcal{R}</span>  , KeyGen outputs a universal structured common reference string  <span class="math">\\mathsf{srs}_{\\mathsf{u}}</span>  and a trapdoor  <span class="math">\\tau</span></li>

      <li><span class="math">\\mathsf{srs}_{\\mathsf{R}} \\gets \\mathsf{KeyGenD}(\\mathsf{srs}_{\\mathsf{u}}, \\mathsf{R})</span> : On input  <span class="math">\\mathsf{R} \\in \\mathcal{R}</span> , this algorithm outputs a relation dependent SRS that includes  <span class="math">\\mathsf{srs}_{\\mathsf{u}}</span> ;</li>

      <li><span class="math">\\pi \\gets \\operatorname{Prove}(\\mathsf{R}, \\mathsf{srs}_{\\mathsf{R}}, (\\mathsf{x}, \\mathsf{w}))</span> : On input the relation,  <span class="math">\\mathsf{srs}_{\\mathsf{R}}</span>  and a pair  <span class="math">(\\mathsf{x}, \\mathsf{w}) \\in \\mathsf{R}</span> , it outputs a proof  <span class="math">\\pi</span> ;</li>

      <li><span class="math">1/0 \\gets \\text{Verify}(\\mathsf{srs}_{\\mathsf{R}}, \\mathsf{x}, \\pi)</span> : Verify takes as input  <span class="math">\\mathsf{srs}_{\\mathsf{R}}</span> , the instance  <span class="math">\\mathsf{x}</span>  and the proof and produces a bit expressing acceptance (1), or rejection (0);</li>

      <li><span class="math">\\pi_{\\mathrm{sim}} \\gets \\text{Simulate}(\\mathsf{R}, \\tau, \\mathsf{x})</span> : The simulator has the relation  <span class="math">\\mathsf{R}</span> , the trapdoor  <span class="math">\\tau</span>  and the instance  <span class="math">\\mathsf{x}</span>  as inputs and it generates a simulated proof  <span class="math">\\pi_{\\mathrm{sim}}</span> ,</li>

    </ul>

    <p class="text-gray-300">and that satisfies completeness, succinctness and  <span class="math">\\epsilon</span> -knowledge soundness as defined below.</p>

    <p class="text-gray-300">Definition 4. Completeness holds if an honest prover will always convince an honest verifier. Formally,  <span class="math">\\forall \\mathsf{R} \\in \\mathcal{R}, (\\mathsf{x}, \\mathsf{w}) \\in \\mathsf{R}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\text{Verify} (\\mathsf{srs}_{\\mathsf{R}},\\mathsf{x},\\pi) = 1\\begin{array}{l}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l}(\\mathsf{srs}_{\\mathsf{u}},\\tau)\\leftarrow \\mathsf{KeyGen}(\\mathcal{R})\\\\ \\mathsf{srs}_{\\mathsf{R}}\\leftarrow \\mathsf{KeyGenD}(\\mathsf{srs}_{\\mathsf{u}},\\mathsf{R})\\\\ \\pi \\leftarrow \\mathsf{Prove}(\\mathsf{R},\\mathsf{srs}_{\\mathsf{R}},(\\mathsf{x},\\mathsf{w})) \\end{array} \\right.\\right] = 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Definition 5. Succinctness holds if the size of the proof  <span class="math">\\pi</span>  is poly $(\\lambda + \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  and Verify runs in time  </span>\\text{poly}(\\lambda +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{w}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 6.  <span class="math">\\epsilon</span> -knowledge soundness captures the fact that a cheating prover cannot, except with probability at most  <span class="math">\\epsilon</span> , create a proof  <span class="math">\\pi</span>  accepted by the verification algorithm unless it has a witness  <span class="math">\\mathsf{w}</span>  such that  <span class="math">(\\mathsf{x},\\mathsf{w}) \\in \\mathsf{R}</span> . Formally, for all PPT adversaries  <span class="math">\\mathcal{A}</span> , there exists a PPT extractor  <span class="math">\\mathcal{E}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} (\\mathsf {x}, \\mathsf {w}) \\notin \\mathsf {R} \\land \\mathsf {V e r i f y} (\\mathsf {s r s} _ {\\mathsf {R}}, \\mathsf {x}, \\pi) = 1 &amp;amp; \\begin{array}{l} (\\mathsf {s r s} _ {\\mathsf {u}}, \\tau) \\leftarrow \\mathsf {K e y G e n} (\\mathcal {R}) \\\\ \\mathsf {R} \\leftarrow \\mathcal {A} (\\mathsf {s r s} _ {\\mathsf {u}}) \\\\ \\mathsf {s r s} _ {\\mathsf {R}} \\leftarrow \\mathsf {K e y G e n D} (\\mathsf {s r s} _ {\\mathsf {u}}, \\mathsf {R}) \\\\ (\\mathsf {x}, \\pi) \\leftarrow \\mathcal {A} (\\mathsf {R}, \\mathsf {s r s} _ {\\mathsf {R}}) \\\\ \\mathsf {w} \\leftarrow \\mathcal {E} (\\mathsf {s r s} _ {\\mathsf {R}}, \\mathsf {x}, \\pi) \\end{array} \\end{array} \\right] \\leq \\epsilon .</span></div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 7.</h6>

    <p class="text-gray-300"><span class="math">(</span>KeyGen,KeyGenD,Prove,Verify,Simulate<span class="math">)</span> is zero-knowledge (a zkSNARK) if for all <span class="math">R\\in\\mathcal{R}</span>, instances <span class="math">x</span> and PPT adversaries <span class="math">\\mathcal{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathcal{A}(R,srs_{R},\\pi)=1\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}(srs_{u},\\tau)\\leftarrow\\mathsf{KeyGen}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">srs_{R}\\leftarrow\\mathsf{KeyGenD}(srs_{u},R)\\cr\\pi\\leftarrow\\mathsf{Prove}(R,srs_{R},(x,w))\\end{matrix}\\right.\\right]\\approx$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\mathcal{A}(R,srs_{R},\\pi_{sim})=1\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{matrix}(srs_{u},\\tau)\\leftarrow\\mathsf{KeyGen}(\\mathcal{R})\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">srs_{R}\\leftarrow\\mathsf{KeyGenD}(srs_{u},R)\\cr\\pi_{sim}\\leftarrow\\mathsf{Simulate}(R,\\tau,x)\\end{matrix}\\right.\\right].$</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Updatability.</h4>

    <p class="text-gray-300">We will say a universal zkSNARK is <em>updatable</em> if <span class="math">srs_{u}</span> is updatable as defined in <em>[x10]</em>. We remark their result states that this is the case if <span class="math">srs_{u}</span> consists solely of monomials.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3 Polynomial Holographic Proofs</h3>

    <p class="text-gray-300">In this paper, we use the notion of Polynomial Holographic Interactive Oracle Proofs (PHP), recently introduced by Campanelli et al. <em>[CFF^{+}20]</em>. It is a refinement and quite similar to other notions used in the literature to construct SNARKs in a modular way, such as Algebraic Holographic Proofs (AHP) <em>[CHM^{+}20]</em> or idealized polynomial protocols <em>[x11]</em>.</p>

    <p class="text-gray-300">A proof system for a relation <span class="math">R</span> is holographic if the verifier does not read the full description of the relation, but rather has access to an encoding of the statement produced by some holographic relation encoder, also called indexer, that outputs oracle polynomials. In all these models, the prover is restricted to send oracle polynomials or field elements, except that, for additional flexibility, the PHP model of <em>[CFF^{+}20]</em> also lets the prover send arbitrary messages. In PHPs, the queries of the verifier are algebraic checks over the polynomials sent by the verifier, as opposed to being limited to polynomial evaluations as in AHPs.</p>

    <p class="text-gray-300">The following definitions are taken almost verbatim from <em>[CFF^{+}20]</em>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 8.</h6>

    <p class="text-gray-300">A family of polynomial time computable relations <span class="math">\\mathcal{R}</span> is field dependent if each relation <span class="math">R\\in\\mathcal{R}</span>, specifies a unique finite field. More precisely, for any pair <span class="math">(x,w)\\in R</span>, <span class="math">x</span> specifies the same finite field <span class="math">\\mathbb{F}_{R}</span> (simply denoted as <span class="math">\\mathbb{F}</span> if there is no ambiguity).</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 9 (Polynomial Holographic IOPs (PHP)).</h6>

    <p class="text-gray-300">A Polynomial Holographic IOP for a family of field-dependent relations <span class="math">\\mathcal{R}</span> is a tuple <span class="math">\\mathsf{PHP}=(\\mathsf{rnd},n,m,d,n_{e},\\mathcal{I},\\mathcal{P},\\mathcal{V})</span>, where <span class="math">\\mathsf{rnd},n,m,d,n_{e}:\\{0,1\\}^{*}\\rightarrow\\mathbb{N}</span> are polynomial-time computable functions, and <span class="math">\\mathcal{I},\\mathcal{P},\\mathcal{V}</span> are three algorithms that work as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Offline phase:</em> The encoder or indexer <span class="math">\\mathcal{I}(R)</span> is executed on a relation description <span class="math">R</span>, and it returns <span class="math">n(0)</span> polynomials <span class="math">\\{p_{0,j}\\}_{j=1}^{n(0)}\\in\\mathbb{F}[X]</span> encoding the relation <span class="math">R</span> and where <span class="math">\\mathbb{F}</span> is the field specified by <span class="math">R</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <em>Online phase:</em> The prover <span class="math">\\mathcal{P}(R,x,w)</span> and the verifier <span class="math">\\mathcal{V}^{\\mathcal{I}(R)}(x)</span> are executed for $\\mathsf{rnd}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> rounds, the prover has a tuple </span>(R,x,w)\\in\\mathcal{R}<span class="math">, and the verifier has an instance </span>x<span class="math"> and oracle access to the polynomials encoding </span>R<span class="math">. In the </span>i<span class="math">-th round, </span>\\mathcal{V}<span class="math"> sends a message </span>\\rho_{i}\\in\\mathbb{F}<span class="math"> to the prover, and </span>\\mathcal{P}<span class="math"> replies with </span>m(i)<span class="math"> messages </span>\\{\\pi_{i,j}\\in\\mathbb{F}\\}_{j=1}^{m(i)}<span class="math">, and </span>n(i)<span class="math"> oracle polynomials </span>\\{p_{i,j}\\in\\mathbb{F}[X]\\}_{j=1}^{n(i)}<span class="math">, such that </span>\\deg(p_{i,j})<d(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,i,j)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Degree checks: to check a bound on the degree of the polynomials sent by the prover. More in detail, let $n_{p}=\\sum_{k=1}^{\\mathsf{rnd}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}n(k)<span class="math"> and let </span>(p_{1},\\ldots,p_{n_{p}})<span class="math"> be the polynomials sent by </span>\\mathcal{P}<span class="math">. The verifier specifies a vector of integers </span>\\bm{d}\\in\\mathbb{N}^{n_{p}}$, which satisfies the following condition</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\forall k\\in[n_{p}]:\\deg(p_{k})\\leq d_{k}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Polynomial checks: to verify that certain polynomial identities hold between the oracle polynomials and the messages sent by the prover. Let $n^{*}=\\sum_{k=0}^{\\mathsf{rnd}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}n(k)<span class="math"> and </span>m^{*}=\\sum_{k=0}^{\\mathsf{rnd}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}m(k)<span class="math">, and denote by </span>(p_{1},\\ldots,p_{n^{<em>}})<span class="math"> and </span>(\\pi_{1},\\ldots,\\pi_{n^{</em>}})<span class="math"> all the oracle polynomials (including the </span>n(0)$ ones fr</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and all the messages sent by the prover. The verifier can specify a list of <span class="math">\\mathsf{n}_{e}</span> tuples, each of the form <span class="math">(G,v_{1},\\ldots,v_{n^{<em>}})</span>, where <span class="math">G\\in\\mathbb{F}[X,X_{1},\\ldots,X_{n^{</em>}},Y_{1},\\ldots,Y_{m^{<em>}}]</span> and every <span class="math">v_{k}\\in\\mathbb{F}[X]</span>. Then a tuple <span class="math">(G,v_{1},\\ldots,v_{n^{</em>}})</span> is satisfied if and only if <span class="math">F(X)\\equiv 0</span> where</p>

    <p class="text-gray-300"><span class="math">F(X):=G\\big{(}X,\\{p_{k}(v_{k}(X))\\}_{k=1,\\ldots,n^{<em>}},\\{\\pi_{k}\\}_{k=1,\\ldots,m^{</em>}}\\big{)}.</span></p>

    <p class="text-gray-300">The verifier accepts if and only if all the checks are satisfied.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 10.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is complete if for any triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, the checks returned by <span class="math">\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}</span> after interacting with the honest prover <span class="math">\\mathcal{P}(\\mathsf{R},\\mathsf{x},\\mathsf{w})</span>, are satisfied with probability 1.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 11.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is <span class="math">\\epsilon</span>-sound if for every relation-instance tuple <span class="math">(\\mathsf{R},\\mathsf{x})\\notin\\mathcal{L}(\\mathcal{R})</span> and polynomial time prover <span class="math">\\mathcal{P}^{*}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\langle\\mathcal{P}^{*},\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}(\\mathsf{x})\\rangle=1\\Big{]}\\leq\\epsilon.</span></p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 12.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is <span class="math">\\epsilon</span>-knowledge sound if there exists a polynomial time knowledge extractor <span class="math">\\mathcal{E}</span> such that for any prover <span class="math">\\mathcal{P}^{*}</span>, relation <span class="math">\\mathsf{R}</span>, instance <span class="math">\\mathsf{x}</span> and auxiliary input <span class="math">z</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}:\\mathsf{w}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(\\mathsf{R},\\mathsf{x},z)\\Big{]}\\geq\\Pr\\Big{[}\\langle\\mathcal{P}^{</em>}(\\mathsf{R},\\mathsf{x},z),\\mathcal{V}^{\\mathcal{I}(\\mathsf{R})}(\\mathsf{x})\\rangle=1\\Big{]}-\\epsilon,</span></p>

    <p class="text-gray-300">where <span class="math">\\mathcal{E}</span> has oracle access to <span class="math">\\mathcal{P}^{<em>}</span>, it can query the next message function of <span class="math">\\mathcal{P}^{</em>}</span> (and also rewind it) and obtain all the messages and polynomials returned by it.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 13.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is <span class="math">\\epsilon</span>-zero-knowledge if there exists a PPT simulator <span class="math">\\mathcal{S}</span> such that for every triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, and every algorithm <span class="math">\\mathcal{V}^{*}</span>, the following random variables are within <span class="math">\\epsilon</span>-statistical distance:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{View}\\left(\\mathcal{P}(\\mathsf{R},\\mathsf{x},\\mathsf{w}),\\mathcal{V}^{<em>}\\right)\\approx_{c}\\mathsf{View}\\left(\\mathcal{S}^{\\mathcal{V}^{</em>}}(\\mathsf{R},\\mathsf{x})\\right),</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{View}\\left(\\mathcal{P}(\\mathsf{R},\\mathsf{x},\\mathsf{w}),\\mathcal{V}^{<em>}\\right)</span> consists of <span class="math">\\mathcal{V}^{</em>}</span>’s randomness, <span class="math">\\mathcal{P}</span>’s messages (which do not include the oracles) and <span class="math">\\mathcal{V}^{<em>}</span>’s list of checks, while <span class="math">\\mathsf{View}(\\mathcal{S}^{\\mathcal{V}^{</em>}}(\\mathsf{R},\\mathsf{x}))</span> consists of <span class="math">\\mathcal{V}^{<em>}</span>’s randomness followed by <span class="math">\\mathcal{S}</span>’s output, obtained after having straightline access to <span class="math">\\mathcal{V}^{</em>}</span>, and <span class="math">\\mathcal{V}^{*}</span>’s list of checks.</p>

    <p class="text-gray-300">We assume that in every PHP scheme there is an implicit maximum degree for all the polynomials used in the scheme. Thus, we include only degree checks that differ from this maximum. In all our PHPs, the verifier is public coin.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The following definition captures de fact that zero-knowledge should hold even when the verifier has access to <em>a bounded amount</em> of evaluations of the polynomials that contain information about the witness. Let <span class="math">\\mathcal{Q}</span> be a list of queries; we say that <span class="math">\\mathcal{Q}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-bounded for <span class="math">\\mathsf{b}\\in\\mathbb{N}^{n_{p}}</span> and <span class="math">\\mathsf{C}</span> a PT algorithm, if for every <span class="math">i\\in[\\mathsf{n}_{p}]</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(i,z):(i,z)\\in\\mathcal{Q}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{b}_{i}<span class="math">, and for all </span>(i,z)\\in\\mathcal{Q}<span class="math">, </span>\\mathsf{C}(i,z)=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 14.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-zero-knowledge if for every triple <span class="math">(\\mathsf{R},\\mathsf{x},\\mathsf{w})\\in\\mathcal{R}</span>, and every <span class="math">(\\mathsf{b},\\mathsf{C})</span>-bounded list <span class="math">\\mathcal{Q}</span>, the follow random variables are within <span class="math">\\epsilon</span> statistical distance:</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathsf{View}\\big{(}\\mathcal{P}(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathsf{w}),\\mathcal{V}\\big{)},(p_{i}(z))_{(i,z)\\in\\mathcal{Q}}\\big{)}\\approx_{\\epsilon}\\mathcal{S}\\left(\\mathbb{F},\\mathsf{R},\\mathsf{x},\\mathcal{V}(\\mathbb{F},\\mathsf{x}),\\mathcal{Q}\\right),</span></p>

    <p class="text-gray-300">where the <span class="math">p_{i}(X)</span> are the polynomials returned by the prover.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 15.</h6>

    <p class="text-gray-300">A <span class="math">\\mathsf{PHP}</span> is honest-verifier zero-knowledge with query bound <span class="math">\\mathsf{b}</span> if there exists a PT algorithm <span class="math">\\mathsf{C}</span> such that <span class="math">\\mathsf{PHP}</span> is <span class="math">(\\mathsf{b},\\mathsf{C})</span>-zero-knowledge and for all <span class="math">i\\in\\mathbb{N}</span>, <span class="math">\\Pr[\\mathsf{C}(i,z)=0]</span> is negligible, where <span class="math">z</span> is uniformly sampled over <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">9</p>

    <h2 id="sec-21" class="text-2xl font-bold">2.4 Polynomial Commitments</h2>

    <p class="text-gray-300"><strong>Definition 16 (Polynomial Commitment Scheme).</strong> A Polynomial Commitment Scheme is a tuple of algorithms (PC.KeyGen, PC.Commit, PC.Open, PC.Verify) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{srs}_{\\mathsf{PC}} \\leftarrow \\mathsf{PC.KeyGen}(\\mathsf{pp}_{\\mathsf{PC}}, d)</span>: On input the system parameters and a degree bound <span class="math">d</span>, it outputs a structured reference string.</li>

      <li><span class="math">\\mathbf{c} \\leftarrow \\mathsf{PC.Commit}(\\mathsf{srs}_{\\mathsf{PC}}, \\mathbf{p}(X), \\mathbf{d})</span>: On input the srs and a vector of <span class="math">t</span> polynomials <span class="math">p_i(X)</span> of degree up to <span class="math">d_i</span>, it outputs a vector <span class="math">\\mathbf{c}</span> where <span class="math">\\mathbf{c}_i</span> is a commitment to <span class="math">p_i(X)</span>.</li>

      <li><span class="math">(\\mathbf{s}, \\pi_{\\mathsf{PC}}) \\leftarrow \\mathsf{PC.Open}(\\mathsf{srs}_{\\mathsf{PC}}, \\mathbf{p}(X), \\mathbf{d}, \\mathcal{Q}, \\gamma)</span>: On input the srs, the vector of polynomials, the degree bounds, a query set <span class="math">\\mathcal{Q}</span> where each query is a tuple <span class="math">(i, z) \\in [t] \\times \\mathbb{F}</span>, and a opening challenge <span class="math">\\gamma</span>, it outputs a vector of evaluations <span class="math">\\mathbf{s}</span> and an evaluation proof <span class="math">\\pi_{\\mathsf{PC}}</span>.</li>

      <li><span class="math">1/0 \\leftarrow \\mathsf{PC.Verify}(\\mathsf{srs}_{\\mathsf{PC}}, \\mathbf{c}, \\mathbf{d}, \\mathcal{Q}, \\gamma, \\mathbf{s}, \\pi_{\\mathsf{PC}})</span>: On input the srs, the vector of commitments, the degree bounds, the query set, the opening challenge, a vector of evaluations <span class="math">\\mathbf{s} = (s_{i,z})_{(i,z) \\in \\mathcal{Q}}</span>, and the proof of correct evaluation, it outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme should satisfy the following properties:</p>

    <p class="text-gray-300"><strong>Completeness:</strong> It captures the fact that an honest prover will always convince an honest verifier. Formally, for any vector of polynomials <span class="math">\\mathbf{p}(X)</span> such that <span class="math">\\deg(p_i) \\leq d_i</span> and set of queries <span class="math">\\mathcal{Q}</span> the following probability is 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\deg (p _ {i}) \\leq d _ {i} \\Rightarrow &amp;amp; \\mathsf {s r s} _ {\\mathsf {P C}} \\leftarrow \\mathsf {P C . K e y G e n} \\big (\\mathsf {p p} _ {\\mathsf {P C}}, d \\big) \\\\ \\mathsf {P C . V e r i f y} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {c}, \\mathbf {d}, \\mathcal {Q}, \\gamma , \\mathbf {s}, \\pi_ {\\mathsf {P C}} \\big) = 1 &amp;amp; \\mathbf {c} \\leftarrow \\mathsf {P C . C o m m i t} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {p} (X), \\mathbf {d} \\big) \\\\ &amp;amp; \\mathbf {s} _ {(i, z)} = p _ {i} (z), (i, z) \\in \\mathcal {Q} \\\\ &amp;amp; (\\mathbf {s}, \\pi_ {\\mathsf {P C}}) \\leftarrow \\mathsf {P C . O p e n} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {p} (X), \\mathbf {d}, \\mathcal {Q}, \\gamma \\big) \\end{array} \\right]</span></div>

    <p class="text-gray-300"><strong>Soundness:</strong> Captures the fact that a cheating prover should not be able to convince the verifier of a false opening. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\exists (i, z) \\in \\mathcal {Q} \\text{ s.t. } p _ {i} (z) \\neq \\boldsymbol {s} _ {(i, z)}, \\text{ or } &amp;amp; \\mathsf {s r s} _ {\\mathsf {P C}} \\leftarrow \\mathsf {P C . K e y G e n} \\big (\\mathsf {p p} _ {\\mathsf {P C}}, d \\big) \\\\ \\exists i \\in [ t ] \\text{ s.t. } d e g (p _ {i}) &amp;gt; d _ {i}, \\text{ and } &amp;amp; \\mathbf {c} \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {p} (X), \\mathbf {d} \\big) \\\\ \\mathsf {P C . V e r i f y} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {c}, \\mathbf {d}, \\mathcal {Q}, \\gamma , \\mathbf {s}, \\pi_ {\\mathsf {P C}} \\big) = 1 &amp;amp; (\\mathbf {s}, \\pi_ {\\mathsf {P C}}) \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {p} (X), \\mathbf {d}, \\mathcal {Q}, \\gamma \\big) \\end{array} \\right] \\approx 0</span></div>

    <p class="text-gray-300"><strong>Extractability:</strong> Captures the fact that whenever the prover provides a valid opening, it knows a valid pair <span class="math">(p_i(X), p_i(z)) \\in \\mathbb{F}[X] \\times \\mathbb{F}</span>, where <span class="math">\\deg(p_i) \\leq d_i</span>. Formally, for all PPT adversaries <span class="math">\\mathcal{A}</span> there exists an efficient extractor <span class="math">\\mathcal{E}</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {P C . V e r i f y} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {c}, \\mathbf {d}, \\mathcal {Q}, \\gamma , \\mathbf {s}, \\pi_ {\\mathsf {P C}} \\big) = 1 &amp;amp; \\mathsf {s r s} _ {\\mathsf {P C}} \\leftarrow \\mathsf {P C . K e y G e n} \\big (\\mathsf {p p} _ {\\mathsf {P C}}, d \\big) \\\\ \\wedge &amp;amp; \\mathbf {c} \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} _ {\\mathsf {P C}} \\big) \\\\ \\exists (i, z) \\in \\mathcal {Q} \\text{ s.t. } p _ {i} (z) \\neq \\mathbf {s} _ {(i, z)}, \\text{ or } &amp;amp; \\mathbf {p} (X) \\leftarrow \\mathcal {E} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {c}, \\mathbf {d} \\big) \\\\ \\exists i \\in [ t ] \\text{ s.t. } d e g (p _ {i}) &amp;gt; d _ {i} &amp;amp; (\\mathcal {Q}, \\gamma) \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {c}, \\mathbf {d} \\big) \\\\ &amp;amp; (\\mathbf {s}, \\pi_ {\\mathsf {P C}}) \\leftarrow \\mathcal {A} \\big (\\mathsf {s r s} _ {\\mathsf {P C}}, \\mathbf {p} (X), \\mathbf {d}, \\mathcal {Q}, \\gamma \\big) \\end{array} \\right] \\approx 0</span></div>

    <h2 id="sec-22" class="text-2xl font-bold">2.5 Cryptographic Assumptions</h2>

    <p class="text-gray-300">Once we compile the PHP through a polynomial commitment into a zkSNARK, the latter will achieve its security properties in the Algebraic Group Model of Fuchsbauer et al. ([FKL18]). In this model adversaries are restricted to be algebraic, namely, when an adversary <span class="math">\\mathcal{A}</span> gets some group elements as input and outputs another group element, it can provide some algebraic representation of the latter in terms of the former.</p>

    <p class="text-gray-300"><strong>Definition 17 (Algebraic Adversary).</strong> Let <span class="math">\\mathbb{G}</span> be a cyclic group of order <span class="math">p</span>. We say that a PPT adversary <span class="math">\\mathcal{A}</span> is algebraic if there exists an efficient extractor <span class="math">\\mathcal{E}_{\\mathcal{A}}</span> that, given the inputs <span class="math">([x_1],\\ldots ,[x_m])</span> of <span class="math">\\mathcal{A}</span>, outputs a representation <span class="math">\\mathbf{z} = (z_{1},\\dots,z_{m})^{\\top}\\in \\mathbb{F}^{m}</span>, where <span class="math">\\mathbb{F}</span> is the finite field of <span class="math">p</span> elements, for every group element <span class="math">[y]</span> in the output of <span class="math">\\mathcal{A}</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">A d \\mathfrak {c} _ {\\mathbb {G}, \\mathcal {A}} ^ {a l g} (\\lambda) = \\left[ \\begin{array}{c} [ y ] \\leftarrow \\mathcal {A} ([ x _ {1} ], \\ldots , [ x _ {m} ]), \\mathbf {z} \\leftarrow \\mathcal {E} _ {\\mathcal {A}} ([ y ], [ x _ {1} ], \\ldots , [ x _ {m} ]), \\\\ \\mathrm {a n d} [ y ] \\neq \\sum_ {j = 1} ^ {m} z _ {j} [ x _ {j} ] \\end{array} \\right] = \\mathsf {n e g l} (\\lambda).</span></div>

    <p class="text-gray-300">The security of our final argument for R1CS-lite (after compilation) is proven in the algebraic group model under the following assumption:</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 18 (q-dlog Asymmetric Assumption).</h6>

    <p class="text-gray-300">The <span class="math">q(\\lambda)</span>-discrete logarithm assumption holds for <span class="math">gk\\leftarrow\\mathcal{G}(1^{\\lambda})</span> if for all PPT algorithm <span class="math">\\mathcal{A}</span></p>

    <p class="text-gray-300"><span class="math">Adv_{gk,\\mathcal{A}}^{q-dlog}(\\lambda)=\\mathsf{Pr}\\left[x\\leftarrow\\mathcal{A}(gk,[x]_{1,2},\\ldots,[x^{q}]_{1,2})\\right]=\\mathsf{negl}(\\lambda).</span></p>

    <h2 id="sec-24" class="text-2xl font-bold">3 Generalized Univariate Sumcheck</h2>

    <p class="text-gray-300">In this section, we revisit the sumcheck of Aurora <em>[BCR^{+}19]</em>. As presented there, this argument allows to prove that the sum of the evaluations of a polynomial in some multiplicative subgroup <span class="math">\\mathbb{H}</span> of a finite field <span class="math">\\mathbb{F}</span> sum to some value <span class="math">\\sigma</span>. We generalize the argument to arbitrary sets <span class="math">\\mathbb{H}\\subset\\mathbb{F}</span>, solving an open problem posed there. Additionally, we give a simpler proof of the same result by connecting the sumcheck to polynomial evaluation and other basic properties of polynomials.</p>

    <p class="text-gray-300">Given some finite field <span class="math">\\mathbb{F}</span>, let <span class="math">\\mathbb{H}</span> be an arbitrary set of cardinal <span class="math">m</span>, with some predefined canonical order, and <span class="math">\\mathsf{h}_{i}</span> the ith element in this order. The ith Lagrange basis polynomial associated to <span class="math">\\mathbb{H}</span> is denoted by <span class="math">\\lambda_{i}(X)</span>. The vector <span class="math">\\bm{\\lambda}(X)</span> is defined as <span class="math">\\bm{\\lambda}(X)^{\\top}=(\\lambda_{1}(X),\\ldots,\\lambda_{m}(X))</span>. The vanishing polynomial of <span class="math">\\mathbb{H}</span> will be denoted by <span class="math">t(X)</span>. When <span class="math">\\mathbb{H}</span> is a multiplicative subgroup, the following properties are known to hold:</p>

    <p class="text-gray-300"><span class="math">t(X)=X^{m}-1,\\qquad\\lambda_{i}(X)=\\frac{\\mathsf{h}_{i}}{m}\\frac{(X^{m}-1)}{(X-\\mathsf{h}_{i})},\\qquad\\lambda_{i}(0)=\\frac{1}{m},</span></p>

    <p class="text-gray-300">for any <span class="math">i=1,\\ldots,m</span>. This representation makes their computation particularly efficient: both <span class="math">t(X)</span> and <span class="math">\\lambda_{i}(X)</span> can be evaluated in <span class="math">O(\\log m)</span> field operations.</p>

    <p class="text-gray-300">We prove a generalized sumcheck theorem below, and derive the sumcheck of Aurora as a corollary for the special case where <span class="math">\\mathbb{H}</span> is a multiplicative subgroup. The intuition is simple: let <span class="math">P_{1}(X)</span> be a polynomial of arbitrary degree in <span class="math">\\mathbb{F}[X]</span>, and <span class="math">P_{2}(X)=\\sum_{i=1}^{m}\\lambda_{i}(X)P_{1}(\\mathsf{h}_{i})</span>. Note that <span class="math">P_{1}(X),P_{2}(X)</span> are congruent modulo <span class="math">t(X)</span>, and the degree of <span class="math">P_{2}(X)</span> is at most <span class="math">m-1</span>. Then, when <span class="math">P_{2}(X)</span> is evaluated at an arbitrary point <span class="math">v\\in\\mathbb{F}</span>, <span class="math">v\\notin\\mathbb{H}</span>, <span class="math">P_{2}(v)=\\sum_{i=1}^{m}\\lambda_{i}(v)P_{1}(\\mathsf{h}_{i})</span>. Thus, <span class="math">P_{2}(v)</span> is “almost” (except for the constants <span class="math">\\lambda_{i}(v)</span>) the sum of the evaluations of <span class="math">P_{1}(\\mathsf{h}_{i})</span>. Multiplying by a normalizing polynomial, we get rid of the constants and obtain a polynomial that evaluated at <span class="math">v</span> is the sum of any set of evaluations of interest. The sum will be zero if this product polynomial has a root at <span class="math">v</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Theorem 1 (Generalized Sumcheck).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{H}</span> be an arbitrary subset of some finite field <span class="math">\\mathbb{F}</span> and <span class="math">t(X)</span> the vanishing polynomial at <span class="math">\\mathbb{H}</span>. For any <span class="math">P(X)\\in\\mathbb{F}[X]</span>, <span class="math">\\mathcal{S}\\subset\\mathbb{H}</span>, and any <span class="math">v\\in\\mathbb{F},v\\notin\\mathbb{H}</span>, <span class="math">\\sum_{s\\in\\mathcal{S}}P(s)=\\sigma</span> if and only if there exist polynomials <span class="math">H(X)\\in\\mathbb{F}[X]</span>, <span class="math">R(X)\\in\\mathbb{F}_{\\leq m-2}[X]</span> such that</p>

    <p class="text-gray-300"><span class="math">P(X)N_{\\mathcal{S},v}(X)-\\sigma=(X-v)R(X)+t(X)H(X),</span></p>

    <p class="text-gray-300">where <span class="math">N_{\\mathcal{S},v}(X)=\\sum_{s\\in\\mathcal{S}}\\lambda_{s}(v)^{-1}\\lambda_{s}(X)</span> and <span class="math">\\lambda_{s}(X)</span> is the Lagrange polynomial associated to <span class="math">s</span> and the set <span class="math">\\mathbb{H}</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that <span class="math">P(X)=\\sum_{\\mathsf{h}\\in\\mathbb{H}}P(\\mathsf{h})\\lambda_{\\mathsf{h}}(X)\\mod t(X)</span>. Therefore,</p>

    <p class="text-gray-300">\\[ P(X)N_{\\mathcal{S},v}(X)-\\sigma=\\Big{(}\\sum_{\\mathsf{h}\\in\\mathbb{H}}P(\\mathsf{h})\\lambda_{\\mathsf{h}}(X)\\Big{)}\\Big{(}\\sum_{s\\in\\mathcal{S}}\\lambda_{s}(v)^{-1}\\lambda_{s}(X)\\Big{)}-\\sigma\\\\ =\\Big{(}\\sum_{s\\in\\mathcal{S}}P(s)\\lambda_{s}(v)^{-1}\\lambda_{s}(X)\\Big{)}-\\sigma\\mod t(X). \\]</p>

    <p class="text-gray-300">Let <span class="math">Q(X)=\\Big{(}\\sum_{s\\in\\mathcal{S}}P(s)\\lambda_{s}(v)^{-1}\\lambda_{s}(X)\\Big{)}-\\sigma</span>. Note that <span class="math">Q(v)=\\sum_{s\\in\\mathcal{S}}P(s)-\\sigma</span>. Thus, <span class="math">\\sum_{s\\in\\mathcal{S}}P(s)=\\sigma</span> if and only if <span class="math">Q(X)</span> is divisible by <span class="math">X-v</span>. The claim follows from this observation together with the fact that <span class="math">Q(X)</span> is the unique polynomial of degree <span class="math">m-1</span> that is congruent with <span class="math">P(X)N_{\\mathcal{S},v}(X)-\\sigma</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{S}=\\mathbb{H}</span> is a multiplicative subgroup of <span class="math">\\mathbb{F}</span>, <span class="math">N_{\\mathbb{H},0}(X)=m</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that, as <span class="math">\\mathbb{H}</span> is a multiplicative subgroup, <span class="math">\\lambda_{i}(0)=1/m</span> for all <span class="math">i=1,\\ldots,m</span>. Therefore, <span class="math">N_{\\mathbb{H},0}(X)=\\sum_{i=1}^{m}\\lambda_{i}(0)^{-1}\\lambda_{i}(X)=m\\sum_{i=1}^{m}\\lambda_{i}(X)=m</span>. ∎</p>

    <p class="text-gray-300">As a corollary of Lemma 1 and the Generalized Sumcheck, we recover the univariate sumcheck: if <span class="math">\\mathbb{H}</span> is a multiplicative subgroup, <span class="math">\\sum_{\\mathsf{h}\\in\\mathbb{H}}P(\\mathsf{h})=\\sigma</span> if and only if there exist polynomials <span class="math">R(X),H(X)</span> with <span class="math">\\deg(R(X))\\leq m-2</span> such that <span class="math">P(X)m-\\sigma=XR(X)+t(X)H(X)</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">3.1 Application to Linear Algebra Arguments</h3>

    <p class="text-gray-300">Several works <em>[BCR^{+}19, CHM^{+}20, CFF^{+}20]</em> have observed that R1CS languages can be reduced to proving a Hadamard product relation and a linear relation, where the latter consists on showing that two vectors <span class="math">\\bm{x},\\bm{y}</span> are such that <span class="math">\\bm{y}=\\mathbf{M}\\bm{x}</span>, or equivalently, that the inner product of <span class="math">(\\bm{y},\\bm{x})</span> with all the rows of <span class="math">(\\mathbf{I},-\\mathbf{M})</span> is zero. When matrices and vectors are encoded as polynomials for succinctness, for constructing a PHP it is necessary to express these linear algebra operations as polynomial identities.</p>

    <p class="text-gray-300">For the Hadamard product relation, the basic observation is that, for any polynomials <span class="math">A(X),B(X),C(X)</span>, the equation</p>

    <p class="text-gray-300"><span class="math">A(X)B(X)-C(X)=H(X)t(X),</span> (1)</p>

    <p class="text-gray-300">holds for some <span class="math">H(X)</span> if and only if <span class="math">(A(\\mathsf{h}_{1}),\\ldots,A(\\mathsf{h}_{m}))\\circ(B(\\mathsf{h}_{1}),\\ldots,B(\\mathsf{h}_{m}))-(C(\\mathsf{h}_{1}),\\ldots,C(\\mathsf{h}_{m}))=0</span>. In particular, if <span class="math">A(X)=\\bm{a}^{\\top}\\bm{\\lambda}(X)</span>, <span class="math">B(X)=\\bm{b}^{\\top}\\bm{\\lambda}(X)</span> encode vectors <span class="math">\\bm{a},\\bm{b}</span>, then <span class="math">C(X)\\mod t(X)</span> encodes <span class="math">\\bm{a}\\circ\\bm{b}</span>. This Hadamard product argument is one of the main ideas behind the zkSNARK of Gentry et al. <em>[x11]</em> and follow-up work.</p>

    <p class="text-gray-300">For linear relations, the following Theorem explicitly derives a polynomial identity that encodes the inner product relation from the univariate sumcheck. This connection in a different formulation is implicit in previous works <em>[BCR^{+}19, CHM^{+}20, CFF^{+}20]</em>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 2 (Inner Product Polynomial Relation).</h6>

    <p class="text-gray-300">For some <span class="math">k\\in\\mathbb{N}</span>, let <span class="math">\\bm{y}=(\\bm{y}_{1},\\ldots,\\bm{y}_{k})</span>, <span class="math">\\bm{y}_{i}=(y_{ij})</span>, <span class="math">\\bm{d}=(\\bm{d}_{1},\\ldots,\\bm{d}_{k})</span> be two vectors in <span class="math">\\mathbb{F}^{km}</span>, <span class="math">\\bm{y}_{i},\\bm{d}_{i}\\in\\mathbb{F}^{m}</span>, and <span class="math">\\mathbb{H}</span> a multiplicative subgroup of <span class="math">\\mathbb{F}</span> of order <span class="math">m</span>. Then, <span class="math">\\bm{y}\\cdot\\bm{d}=\\sigma</span> if and only if there exist <span class="math">H(X),R(X)\\in\\mathbb{F}[X]</span>, <span class="math">R(X)</span> of degree at most <span class="math">m-2</span> such that the following relation holds:</p>

    <p class="text-gray-300"><span class="math">\\bm{Y}(X)\\cdot\\bm{D}(X)-\\frac{\\sigma}{m}=XR(X)+t(X)H(X),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\bm{Y}(X)=(Y_{1}(X),\\ldots,Y_{k}(X))</span> is a vector of polynomials of arbitrary degree such that <span class="math">Y_{i}(\\mathsf{h}_{j})=y_{ij}</span> for all <span class="math">i=1,\\ldots,k</span>, <span class="math">j=1,\\ldots,m</span>, and <span class="math">\\bm{D}(X)=(D_{1}(X),\\ldots,D_{k}(X))</span> is such that <span class="math">D_{i}(X)=\\bm{d}_{i}^{\\top}\\bm{\\lambda}(X)</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">Y_{i}(\\mathsf{h}_{j})=y_{ij}</span>, for all <span class="math">i,j</span>, <span class="math">Y_{i}(X)=\\bm{y}_{i}^{\\top}\\bm{\\lambda}(X)\\mod t(X)</span>. Therefore, <span class="math">Y_{i}(X)D_{i}(X)=(\\bm{y}_{i}^{\\top}\\bm{\\lambda}(X))(\\bm{d}_{i}^{\\top}\\bm{\\lambda}(X))</span> mod <span class="math">t(X)</span>, and by the aforementioned properties of the Lagrange basis, this is also congruent modulo <span class="math">t(X)</span> to <span class="math">(\\bm{y}_{i}\\circ\\bm{d}_{i})^{\\top}\\bm{\\lambda}(X)</span>. Therefore,</p>

    <p class="text-gray-300"><span class="math">\\bm{Y}(X)\\cdot\\bm{D}(X)=\\sum_{i=1}^{k}Y_{i}(X)D_{i}(X)=\\sum_{i=1}^{k}(\\bm{y}_{i}\\circ\\bm{d}_{i})^{\\top}\\bm{\\lambda}(X)=\\left(\\sum_{i=1}^{k}(\\bm{y}_{i}\\circ\\bm{d}_{i})^{\\top}\\right)\\bm{\\lambda}(X)\\mod t(X).</span></p>

    <p class="text-gray-300">By Theorem 1, <span class="math">\\big{(}\\big{(}\\sum_{i=1}^{k}(\\bm{y}_{i}\\circ\\bm{d}_{i})^{\\top}\\big{)}\\bm{\\lambda}(X)\\big{)}N_{\\mathbb{H},0}(X)-\\sigma</span> is divisible by <span class="math">X</span> if and only if the sum of the coordinates of <span class="math">\\sum_{i=1}^{k}(\\bm{y}_{i}\\circ\\bm{d}_{i})</span> is <span class="math">\\sigma</span>. The implication is also true after dividing by <span class="math">N_{\\mathbb{H},0}(X)=m</span>. The <span class="math">j</span>th coordinate of <span class="math">\\sum_{i=1}^{k}(\\bm{y}_{i}\\circ\\bm{d}_{i})</span> is <span class="math">\\sum_{i=1}^{k}y_{ij}d_{ij}</span>, thus the sum of all coordinates is <span class="math">\\sum_{j=1}^{m}\\sum_{i=1}^{k}y_{ij}d_{ij}=\\bm{y}\\cdot\\bm{d}</span>, which concludes the proof. ∎</p>

    <p class="text-gray-300">In the rest of the paper <span class="math">\\mathbb{H}</span> will always be a multiplicative subgroup, both for simplicity (as <span class="math">N_{\\mathbb{H},0}=m</span>), and efficiency (due to the properties that Lagrange and vanishing polynomials associated to multiplicative subgroups have). However, Theorem 2 can be easily generalized to arbitrary sets <span class="math">\\mathbb{H}</span> (just multiplying the left side of Eq. (2) by <span class="math">N_{\\mathbb{H},0}(X)</span>).</p>

    <p class="text-gray-300">4 Checkable Subspace Sampling: Definition and Implications</p>

    <p class="text-gray-300">In a <em>Checkable Subspace Sampling</em> (CSS) argument prover and verifier interactively agree on a polynomial <span class="math">D(X)</span> representing a vector <span class="math">\\bm{d}</span> in the row space of a matrix <span class="math">\\mathbf{M}</span>. The fiber of the protocol is that <span class="math">D(X)</span> is calculated as a linear combination of encodings of the rows of <span class="math">\\mathbf{M}</span> with some coefficients determined by the verifier, but the verifier does not need to calculate <span class="math">D(X)</span> itself (this would require the verifier to do linear work in the number of rows of <span class="math">\\mathbf{M}</span>). Instead, the prover can calculate this polynomial and then convince the verifier that it has been correctly computed.</p>

    <p class="text-gray-300">Below we give the syntactical definition of Checkable Subspace Sampling. Essentially, a CSS scheme is similar to a PHP for a relation <span class="math">\\mathsf{R}_{\\mathbf{M}}</span>, except that the statement <span class="math">(\\mathsf{cn}s,D(X))</span> is decided interactively, and the verifier has only oracle access to the polynomial <span class="math">D(X)</span>. A CSS scheme can be used as a building block in a PHP, and the result is also a PHP.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 19 (Checkable Subspace Sampling, <span class="math">\\mathsf{CSS}</span>).</h6>

    <p class="text-gray-300">A checkable subspace sampling argument over a field <span class="math">\\mathbb{F}</span> defines some <span class="math">Q,m\\in\\mathbb{N}</span>, a set of admissible matrices <span class="math">\\mathcal{M}</span>, a vector of polynomials <span class="math">\\bm{\\beta}(X)\\in(\\mathbb{F}[X])^{m}</span>, a coinspace <span class="math">\\mathcal{C}</span>, a sampling function <span class="math">\\mathsf{Smp}:\\mathcal{C}\\to\\mathbb{F}^{Q}</span>, and a relation:</p>

    <p class="text-gray-300">\\[ \\mathsf{R}_{\\mathsf{CSS},\\mathbb{F}}=\\left\\{\\begin{array}[]{ll}\\big{(}\\mathbf{M},\\mathsf{cn}s,D(X)\\big{)}~{}:&\\mathbf{M}\\in\\mathcal{M}\\subset\\mathbb{F}^{Q\\times m},D(X)\\in\\mathbb{F}[X],\\mathsf{cn}s\\in\\mathcal{C},\\\\ &\\bm{s}=\\mathsf{Smp}(\\mathsf{cn}s),~{}\\text{and}~{}D(X)=\\bm{s}^{\\top}\\mathbf{M}\\bm{\\beta}(X)\\end{array}\\right\\}. \\]</p>

    <p class="text-gray-300">For any <span class="math">\\mathbf{M}\\in\\mathcal{M}</span>, it also defines:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathbf{M}}=\\left\\{\\big{(}\\mathsf{cn}s,D(X)\\big{)}~{}:~{}\\big{(}\\mathbf{M},\\mathsf{cn}s,D(X)\\big{)}\\in\\mathsf{R}_{\\mathsf{CSS},\\mathbb{F}}\\right\\}.</span></p>

    <p class="text-gray-300">It consists of three algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{I}_{\\mathsf{CSS}}</span> is the indexer: in an offline phase, on input <span class="math">(\\mathbb{F},\\mathbf{M})</span> returns a set <span class="math">\\mathcal{W}_{\\mathsf{CSS}}</span> of <span class="math">\\mathsf{n}(0)</span> polynomials <span class="math">\\{p_{0,j}(X)\\}_{j=1}^{n(0)}\\in\\mathbb{F}[X]</span>. This algorithm is run once for each <span class="math">\\mathbf{M}</span>.</li>

      <li>Prover and Verifier proceed as in a PHP, namely, the verifier sends field elements to the prover and has oracle access to the polynomials outputted by both the indexer and the prover; this phase is run in two different stages:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sampling: <span class="math">\\mathcal{P}_{\\mathsf{CSS}}</span> and <span class="math">\\mathcal{V}_{\\mathsf{CSS}}</span> engage in an interactive protocol. In some round, the verifier sends <span class="math">\\mathsf{cn}s\\leftarrow\\mathcal{C}</span>, and the prover replies with <span class="math">D(X)=\\bm{s}^{\\top}\\mathbf{M}\\bm{\\beta}(X)</span>, for <span class="math">\\bm{s}=\\mathsf{Smp}(\\mathsf{cn}s)</span>.</li>

      <li>ProveSampling: <span class="math">\\mathcal{P}_{\\mathsf{CSS}}</span> and <span class="math">\\mathcal{V}_{\\mathsf{CSS}}</span> engage in another interactive protocol to prove that <span class="math">(\\mathsf{cn}s,D(X))\\in\\mathsf{R}_{\\mathbf{M}}</span>.</li>

      <li>When the proving phase is concluded, the verifier outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">The vector <span class="math">\\bm{\\beta}(X)=(\\beta_{1}(X),\\ldots,\\beta_{m}(X))</span> defines an encoding of vectors as polynomials: vector <span class="math">\\bm{v}</span> is mapped to the polynomial <span class="math">\\bm{v}^{\\top}\\bm{\\beta}(X)=\\sum_{i=1}^{m}v_{i}\\beta_{i}(X)</span>. When using a CSS for constructing an argument of membership in linear spaces as in the next section, we choose a characterization of inner product that is compatible with Lagrange polynomials. Thus, in this work, <span class="math">\\beta_{i}(X)</span> is defined as <span class="math">\\lambda_{i}(X)</span>, the <span class="math">i</span>th Lagrange polynomial associated to some multiplicative subgroup <span class="math">\\mathbb{H}</span> of <span class="math">\\mathbb{F}</span>. Still, it also makes sense to consider also CSS arguments for other polynomial encodings, e.g. the monomial basis or Laurent polynomials. In fact, the CSS argument in the amortized setting described in Section 7 is an abstraction of the helped mode of Sonic, that was presented for the encoding with Laurent polynomials.</p>

    <p class="text-gray-300">We require a CSS argument to satisfy the following security definitions:</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Perfect Completeness.</h6>

    <p class="text-gray-300">If both prover and verifier are honest the output of the protocol is 1:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathcal{P}_{\\mathsf{CSS}}(\\mathbb{F},\\mathbf{M},\\mathsf{cn}s),\\mathcal{V}^{\\mathcal{W}_{\\mathsf{CSS}}}_{\\mathsf{CSS}}(\\mathbb{F})\\rangle=1\\right]=1.</span></p>

    <p class="text-gray-300">where the probability is taken over the random coins of prover and verifier.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{F}_{CS}^{M}=\\{f\\in\\mathcal{F}_{CS}^{M}\\mid\\ell\\in\\mathcal{F}_{CS}^{M}\\}.</span></p>

    <h5 id="sec-34" class="text-base font-semibold mt-4">Soundness</h5>

    <p class="text-gray-300">A checkable subspace sampling argument <span class="math">(\\mathcal{I}_{\\mathsf{CSS}},\\mathcal{P}_{\\mathsf{CSS}},\\mathcal{V}_{\\mathsf{CSS}})</span> is <span class="math">\\epsilon</span>-sound if for all <span class="math">\\mathbf{M}</span> and any polynomial time prover <span class="math">\\mathcal{P}_{\\mathsf{CSS}}^{*}</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}D^{*}(X)\\neq\\bm{s}^{\\top}\\mathbf{M}\\bm{\\beta}(X)\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}[]{c}(\\mathsf{cn}\\mathsf{s},D^{<em>}(X))\\leftarrow\\mathsf{Sam}\\textnormal{pling}\\langle\\mathcal{P}_{\\mathsf{CSS}}^{</em>}(\\mathbb{F},\\mathbf{M},\\mathsf{cn}\\mathsf{s}),\\mathcal{V}^{\\mathcal{W}_{\\mathsf{CSS}}}(\\mathbb{F})\\rangle;\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\bm{s}=\\mathsf{Sm}\\textnormal{p}(\\mathsf{cn}\\mathsf{s});\\ \\langle\\mathcal{P}_{\\mathsf{CSS}}^{*}(\\mathbb{F},\\mathbf{M},\\mathsf{cn}\\mathsf{s}),\\mathcal{V}_{\\mathsf{CSS}}^{\\mathcal{W}_{\\mathsf{CSS}}}(\\mathbb{F})\\rangle=1\\end{array}\\Bigg{]}\\leq\\epsilon. \\]</p>

    <p class="text-gray-300">The soundness of the CSS argument will ensure that the vector is sampled as specified by the coins of the verifier so the prover cannot influence its distribution. For a CSS argument to be useful, we additionally need that distribution induced by the sampling function is sufficiently “good”. This is a geometric property that can be captured in the Elusive Kernel property defined below.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 20.</h6>

    <p class="text-gray-300">A CSS argument is <span class="math">\\epsilon</span>-elusive kernel if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\max_{\\bm{t}\\in\\mathbb{F}^{Q},\\bm{t}\\neq\\bm{0}}\\Pr\\left[\\,\\bm{s}\\cdot\\bm{t}=0\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\bm{s}=\\mathsf{Sm}\\textnormal{p}(\\mathsf{cn}\\mathsf{s});\\mathsf{cn}\\mathsf{s}\\leftarrow\\mathcal{C}\\,\\right]\\leq\\epsilon.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In practice, for most schemes, <span class="math">\\bm{s}</span> is a vector of monomials or Lagrange basis polynomials evaluated at some point <span class="math">x=\\mathsf{cn}\\mathsf{s}</span>, and this property is an immediate application of Schwartz-Zippel lemma, so we will not explicitly prove it for most of our CSS arguments. An exception is the argument of Section 6.</p>

    <p class="text-gray-300">It is useful in some contexts to generalize the definition of CSS arguments to block matrices, that is, to extend the relation to tuples <span class="math">\\big{(}\\mathbf{M},\\mathsf{cn}\\mathsf{s},\\bm{D}(X)\\big{)}</span>, where <span class="math">\\mathbf{M}=(\\mathbf{M}_{1},\\ldots,\\mathbf{M}_{k})</span> and <span class="math">\\bm{D}(X)=(D_{1}(X),\\ldots,D_{k}(X))</span> and <span class="math">D_{i}(X)=\\bm{s}^{\\top}\\mathbf{M}_{i}\\bm{\\beta}(X)</span>, and <span class="math">\\mathbf{M}_{i}\\in\\mathbb{F}^{Q\\times m}</span>. This generalization is not necessary if correct sampling is proven for each block individually, but to save on proof size the proofs might be aggregated in some cases. This generalization is useful to formalize this technique.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">4.1 Linear Arguments from Checkable Subspace Sampling</h3>

    <p class="text-gray-300">In this section we build a PHP for the universal relation of membership in linear subspaces:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{LA}}=\\left\\{(\\mathbb{F},\\mathbf{W},\\bm{y}):\\mathbf{W}\\in\\mathbb{F}^{Q\\times km},\\bm{y}\\in\\mathbb{F}^{km}\\text{ s.t. }\\mathbf{W}\\bm{y}=\\bm{0}\\right\\},</span></p>

    <p class="text-gray-300">using a CSS scheme as building block. That is, given a vector <span class="math">\\bm{y}</span>, the argument allows to prove membership in the linear space <span class="math">\\mathbf{W}^{\\perp}=\\{y\\in\\mathbb{F}^{km}:\\mathbf{W}\\bm{y}=\\bm{0}\\}</span>. Although relation <span class="math">\\mathcal{R}_{\\mathsf{LA}}</span> is polynomial-time decidable, it is not trivial to construct a polynomial holographic proof for it, as the verifier has only an encoding of <span class="math">\\mathbf{W}</span> and <span class="math">\\bm{y}</span>.</p>

    <p class="text-gray-300">A standard way to prove that some vector <span class="math">\\bm{y}</span> is in <span class="math">\\mathbf{W}^{\\perp}</span> is to let the verifier sample a sufficiently random vector <span class="math">\\bm{d}</span> in the row space of matrix <span class="math">\\mathbf{W}</span>, and prove <span class="math">\\bm{y}\\cdot\\bm{d}=0</span>. Naturally, the vector <span class="math">\\bm{y}</span> must be declared before <span class="math">\\bm{d}</span> is chosen. We follow this strategy to construct a PHP for <span class="math">\\mathcal{R}_{\\mathsf{LA}}</span>, except that the vector <span class="math">\\bm{d}</span> is sampled by the prover itself on input the coins of the verifier through a CSS argument.</p>

    <p class="text-gray-300">As we have seen in Section 2.1, it is natural in our application to proving R1CS to consider matrices in blocks. Thus, in this section we prove membership in <span class="math">\\mathbf{W}^{\\perp}</span> where the matrix is written in <span class="math">k</span> blocks of columns, that is, <span class="math">\\mathbf{W}=(\\mathbf{W}_{1},\\ldots,\\mathbf{W}_{k})</span>. The vectors <span class="math">\\bm{y},\\bm{d}\\in\\mathbb{F}^{km}</span> are also written in blocks as <span class="math">\\bm{y}^{\\top}=(\\bm{y}_{1}^{\\top},\\ldots,\\bm{y}_{k}^{\\top})</span> and <span class="math">\\bm{d}^{\\top}=(\\bm{d}_{1}^{\\top},\\ldots,\\bm{d}_{k}^{\\top})</span>.</p>

    <p class="text-gray-300">Each block of <span class="math">\\mathbf{W}</span>, as well as the vectors <span class="math">\\bm{y},\\bm{d}</span> can be naturally encoded, respectively, as a vector of polynomials or a single polynomial multiplying on the right by <span class="math">\\bm{\\lambda}(X)</span>. However, we allow for additional flexibility in the encoding of <span class="math">\\bm{y}</span>: our argument is parameterized by a set of valid witnesses <span class="math">W_{Y}</span> and a function <span class="math">\\mathcal{E}_{Y}:W_{Y}\\rightarrow(\\mathbb{F}[X])^{k}</span> that determines how <span class="math">\\bm{y}</span> is encoded as a polynomial. Thanks to this generalization we can use the argument as a black-box in our R1CS-lite construction. There, valid witnesses are of the form <span class="math">(\\bm{a},\\bm{b},\\bm{a}\\circ\\bm{b})</span> and, for efficiency, its encoding will be <span class="math">(A(X)=\\bm{a}^{\\top}\\bm{\\lambda}(X),B(X)=\\bm{b}^{\\top}\\bm{\\lambda}(X),A(X)B(X))</span>, which means that the last element does not need to be sent.</p>

    <p class="text-gray-300">The argument goes as follows. The prover sends a vector of polynomials <span class="math">\\bm{Y}(X)</span> encoding <span class="math">\\bm{y}</span>. The CSS argument is used to delegate to the prover the sampling of <span class="math">\\bm{d}_{i}^{\\top}</span>, <span class="math">i=1,\\ldots,k</span> in the row space of <span class="math">\\mathbf{W}_{i}</span>. Then,</p>

    <p class="text-gray-300">the prover sends <span class="math">\\mathbf{D}(X)</span> together with a proof that <span class="math">\\mathbf{y} \\cdot \\mathbf{d} = 0</span>. For this inner product argument to work, we resort to Theorem 2 that guarantees that, if <span class="math">\\mathcal{E}_Y</span> is an encoding such that if <span class="math">\\mathcal{E}_Y(\\mathbf{y}) = \\mathbf{Y}(X)</span>, then <span class="math">Y_i(\\mathsf{h}_j) = y_{ij}</span>, the inner product relation holds if and only if the verification equation is satisfied for some <span class="math">H_t(X), R_t(X)</span>.</p>

    <p class="text-gray-300">Because of the soundness property of the CSS argument, the prover cannot influence the distribution of <span class="math">\\mathbf{d}</span>, which is sampled according to the verifier's coins. Therefore, if <span class="math">\\mathbf{Y}(X)</span> passes the test of the verifier, <span class="math">\\mathbf{y}</span> is orthogonal to <span class="math">\\mathbf{d}</span>. By the Elusive Kernel property of the CSS argument, <span class="math">\\mathbf{d}</span> will be sufficiently random. As it is sampled after <span class="math">\\mathbf{y}</span> is declared, this will imply that <span class="math">\\mathbf{y}</span> is in <span class="math">\\mathbf{W}^{\\perp}</span>.</p>

    <p class="text-gray-300"><strong>Offline Phase:</strong> <span class="math">\\mathcal{I}_{\\mathsf{LA}}(\\mathbb{F}, \\mathbf{W})</span>: For <span class="math">i = 1, \\ldots, k</span>, run the indexer <span class="math">\\mathcal{I}_{\\mathsf{CSS}}</span> on input <span class="math">(\\mathbb{F}, \\mathbf{W}_i)</span> to obtain the set <span class="math">\\mathcal{W}_{\\mathsf{CSS}i}</span> and output <span class="math">\\mathcal{W}_{\\mathsf{LA}} = \\bigcup_{i=1}^{k} \\mathcal{W}_{\\mathsf{CSS}i}</span>.</p>

    <p class="text-gray-300"><strong>Online Phase:</strong> <span class="math">\\mathcal{P}_{\\mathsf{LA}}</span>: On input a witness <span class="math">\\mathbf{y} \\in W_{Y} \\subset (\\mathbb{F}^{m})^{k}</span>, output <span class="math">\\mathbf{Y}(X) = \\mathcal{E}_{Y}(\\mathbf{y})</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathsf{LA}}</span> and <span class="math">\\mathcal{V}_{\\mathsf{LA}}</span> run in parallel <span class="math">k</span> instances of the CSS argument, with inputs <span class="math">(\\mathbb{F}, \\mathbf{W}_i)</span> and <span class="math">\\mathbb{F}</span>, respectively, and where the verifier is given oracle access to <span class="math">\\mathcal{W}_{\\mathsf{CSS}i}</span>. The output is a set <span class="math">\\{(\\mathsf{cn}\\mathsf{s}, D_i(X))\\}_{i=1}^k</span>, where <span class="math">\\mathsf{cn}\\mathsf{s}</span> are the same for all <span class="math">k</span> instances. Define <span class="math">\\mathbf{D}(X) = (D_1(X), \\ldots, D_k(X))</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{P}_{\\mathsf{LA}}</span>: Outputs <span class="math">R_{t}(X) \\in \\mathbb{F}_{\\leq m - 2}[X], H_{t}(X)</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Y}(X) \\cdot \\mathbf{D}(X) = X R_{t}(X) + t(X) H_{t}(X). \\tag{3}</span></div>

    <p class="text-gray-300"><strong>Decision Phase:</strong> Accept if and only if (1) <span class="math">\\deg(R_t) \\leq m - 2</span>, (2) <span class="math">\\mathcal{V}_{\\mathrm{CSS}}^i</span> accepts <span class="math">(\\mathsf{cn}\\mathsf{s}, D_i(X))</span>, and (3) the following equation holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Y}(X) \\cdot \\mathbf{D}(X) = X R_{t}(X) + t(X) H_{t}(X).</span></div>

    <p class="text-gray-300">Fig. 1. Argument for proving membership in <span class="math">\\mathbf{W}^{\\perp}</span>, parameterized by the polynomial encoding <span class="math">\\mathcal{E}_Y: W_Y \\to \\mathbb{F}[X]^k</span>, and the set <span class="math">W_Y \\subset \\mathbb{F}^{km}</span>.</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> When instantiated using a CSS scheme with perfect completeness, and when the encoding <span class="math">\\mathcal{E}_Y: W_Y \\to \\mathbb{F}[X]^k</span> satisfies that, if <span class="math">\\mathcal{E}_Y(\\mathbf{y}) = \\mathbf{Y}(X)</span>, then <span class="math">Y_i(\\mathsf{h}_j) = y_{ij}</span>, the PHP of Fig. 1 has perfect completeness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By definition, <span class="math">\\mathbf{D}(X) = (\\mathbf{s}^{\\top}\\mathbf{W}_1\\mathbf{\\lambda}(X),\\ldots ,\\mathbf{s}^{\\top}\\mathbf{W}_k\\mathbf{\\lambda}(X))</span>, for <span class="math">\\mathbf{s} = \\mathsf{Samp}(\\mathsf{cn}\\mathsf{s})</span>. Note that this is because the <span class="math">k</span> instances of the CSS scheme are run in parallel and the same coins are used to sample each of the <span class="math">\\mathbf{d}_i</span>. Thus, <span class="math">\\mathbf{D}(X)</span> is the polynomial encoding of <span class="math">\\mathbf{d} = (\\mathbf{s}^{\\top}\\mathbf{W}_1,\\dots,\\mathbf{s}^{\\top}\\mathbf{W}_k) = \\mathbf{s}^{\\top}\\mathbf{W}</span>. Therefore, if <span class="math">\\mathbf{y}</span> is in <span class="math">\\mathbf{W}^{\\perp}</span>, <span class="math">\\mathbf{d} \\cdot \\mathbf{y} = \\mathbf{s}^{\\top}\\mathbf{W}\\mathbf{y} = \\mathbf{0}</span>. By the characterization of inner product, as explained in Section 3, this implies that polynomials <span class="math">H_{t}(X), R_{t}(X)</span> satisfying the verification equation exist.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> Let CSS be <span class="math">\\epsilon</span>-sound and <span class="math">\\epsilon&#x27;</span>-Elusive Kernel, and <span class="math">\\mathcal{E}_Y: W_Y \\to \\mathbb{F}[X]^k</span> an encoding such that if <span class="math">\\mathcal{E}_Y(\\mathbf{y}) = \\mathbf{Y}(X)</span>, <span class="math">Y_i(\\mathsf{h}_j) = y_{ij}</span>. Then, for any polynomial time adversary <span class="math">\\mathcal{A}</span> against the soundness of PHP of Fig. 1:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Adv}(\\mathcal{A}) \\leq \\epsilon&#x27; + k\\epsilon.</span></div>

    <p class="text-gray-300">Further, the PHP satisfies 0-knowledge soundness.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Let <span class="math">\\mathbf{Y}^{<em>}(X) = (Y_{1}^{</em>}(X),\\ldots ,Y_{k}^{<em>}(X))</span> be the output of a cheating <span class="math">\\mathcal{P}_{\\mathsf{LA}}^{</em>}</span> and <span class="math">\\mathbf{y}^{<em>} = (\\mathbf{y}_{1}^{</em>},\\dots,\\mathbf{y}_{k}^{<em>})</span> the vector such that <span class="math">Y_{i}^{</em>}(\\mathsf{h}_{j}) = y_{ij}^{<em>}</span>. As a direct consequence of Theorem 2, <span class="math">\\mathbf{Y}^{</em>}(X)\\cdot \\mathbf{D}(X) = XR_{t}(X) + t(X)H_{t}(X)</span> only if <span class="math">\\mathbf{y}^{*}\\cdot \\mathbf{d} = 0</span>, where <span class="math">\\mathbf{d}</span> is the unique vector <span class="math">\\mathbf{d}</span> such that <span class="math">\\mathbf{D}(X) = (\\mathbf{d}_1^\\top \\pmb {\\lambda}(X),\\dots,\\mathbf{d}_k^\\top \\pmb {\\lambda}(X))</span>.</p>

    <p class="text-gray-300">On the other hand, the soundness of the CSS scheme guarantees that, for each <span class="math">i</span>, the result of sampling <span class="math">D_{i}(X)</span> corresponds to the sample coins sent by the verifier, except with probability <span class="math">\\epsilon</span>. Thus, the chances that the prover can influence the distribution of <span class="math">\\mathbf{D}(X)</span> so that so that <span class="math">\\mathbf{y}^{<em>} \\cdot \\mathbf{d} = 0</span> are at most <span class="math">k\\epsilon</span>. Excluding this possibility, a cheating prover can try to craft <span class="math">\\mathbf{y}^{</em>}</span> in the best possible way to maximize the chance that</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300"><span class="math">\\pmb{y}^{<em>}\\cdot \\pmb{d} = 0</span>  . Since  <span class="math">\\pmb{d}^{\\top} = \\pmb{s}^{\\top}\\mathbf{W}</span>  , and in a successful attack  <span class="math">\\pmb{y}^{</em>}\\notin \\mathbf{W}^{\\perp}</span>  , we can see that this possibility is bounded by the probability:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\max  _ {\\boldsymbol {y} ^ {<em>} \\notin \\mathbf {W} ^ {\\perp}} \\Pr \\left[ \\boldsymbol {d} \\cdot \\boldsymbol {y} ^ {</em>} = 0 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {c n s} \\leftarrow \\mathcal {C}; \\\\ \\boldsymbol {s} = \\mathsf {S m p} (\\mathsf {c n s}); \\\\ \\boldsymbol {d} = \\boldsymbol {s} ^ {\\top} \\mathbf {W} \\end{array} \\right. \\right] = \\max  _ {\\boldsymbol {y} ^ {<em>} \\notin \\mathbf {W} ^ {\\perp}} \\Pr \\left[ \\boldsymbol {s} ^ {\\top} \\mathbf {W} \\boldsymbol {y} ^ {</em>} = 0 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf {c n s} \\leftarrow \\mathcal {C}; \\\\ \\boldsymbol {s} = \\mathsf {S m p} (\\mathsf {c n s}) \\end{array} \\right. \\right]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since  <span class="math">\\pmb{s}^{\\top}\\mathbf{W}\\pmb{y}^{<em>} = \\pmb{s} \\cdot (\\mathbf{W}\\pmb{y}^{</em>})</span> , and  <span class="math">\\mathbf{W}\\pmb{y}^{*} \\neq \\mathbf{0}</span> , this can be bounded by  <span class="math">\\epsilon&#x27;</span> , by the elusive kernel property of the CSS scheme.</p>

    <p class="text-gray-300">For knowledge soundness, define the extractor  <span class="math">\\mathcal{E}</span>  as the algorithm that runs the prover and, by evaluating  <span class="math">Y_{i}(X)</span>  in  <span class="math">\\{\\mathsf{h}_j\\}_{j = 1}^m</span>  for all  <span class="math">i\\in [k]</span> , recovers  <span class="math">\\pmb{y}</span> . If the verifier accepts with probability greater than  <span class="math">\\epsilon^{\\prime} + k\\epsilon</span> , then  <span class="math">\\pmb{y}</span>  is such that  <span class="math">\\mathbf{W}\\pmb {y} = \\mathbf{0}</span>  with the same probability.</p>

    <p class="text-gray-300">Extension to other polynomial encodings. As mentioned, the construction is specific to the polynomial encoding defined by interpolation. However, the only place where this plays a role is in the check of equation (3). Now, if the polynomial encoding  <span class="math">\\beta(X)^{\\top}</span>  associated to the CSS argument for  <span class="math">\\mathbf{W}</span>  was set to be for instance the monomial basis, i.e.  <span class="math">\\beta(X)^{\\top} = (1, X, \\ldots, X^{m-1})</span> , the argument can be easily modified to still work. It suffices to choose the "reverse" polynomial encoding for  <span class="math">\\mathbf{y}</span> , that is define  <span class="math">\\mathbf{Y}(X) = (\\mathbf{y}_1^{\\top} \\tilde{\\beta}(X), \\ldots, \\mathbf{y}_k^{\\top} \\tilde{\\beta}(X))</span> , where  <span class="math">\\tilde{\\beta}(X)^{\\top} = (X^{m-1}, \\ldots, X, 1)</span> , and require the prover to find  <span class="math">R_t(X), H_t(X)</span> , with  <span class="math">R_t(X)</span>  of degree at most  <span class="math">m-2</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {Y} (X) \\cdot \\boldsymbol {D} (X) = R _ {t} (X) + X ^ {m} H _ {t} (X). \\tag {4}</span></div>

    <p class="text-gray-300">Indeed, observe that this check guarantees that  <span class="math">\\mathbf{Y}(X) \\cdot \\mathbf{D}(X)</span>  does not have any term of degree exactly  <span class="math">m - 1</span> , and the term of degree  <span class="math">m - 1</span>  is exactly  <span class="math">\\sum_{i=1}^{k} \\mathbf{y}_i \\cdot \\mathbf{d}_i = \\mathbf{y} \\cdot \\mathbf{d}</span> .</p>

    <h2 id="sec-37" class="text-2xl font-bold">4.2 R1CS-lite from Linear Arguments</h2>

    <p class="text-gray-300">In this section we give a PHP for R1CS-lite by combining our linear argument with other well known techniques. In this section,  <span class="math">\\mathbf{W}</span>  is the block matrix defined in Section 2.1. A similar construction for the generalized relation  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  can be found in Appendix B.</p>

    <p class="text-gray-300"><strong>Offline Phase:</strong>  <span class="math">\\mathcal{I}_{\\mathrm{lite}}(\\mathbf{W},\\mathbb{F})</span>  runs  <span class="math">\\mathcal{I}_{\\mathrm{LA}}(\\mathbf{W},\\mathbb{F})</span>  to obtain a list of polynomials  <span class="math">\\mathcal{W}_{\\mathrm{LA}}</span>  and outputs  <span class="math">\\mathcal{W}_{\\mathrm{lite}} = \\mathcal{W}_{\\mathrm{LA}}</span> .</p>

    <p class="text-gray-300"><strong>Online Phase:</strong>  <span class="math">\\mathcal{P}_{\\mathrm{lite}}(\\mathbb{F},\\mathbf{W},\\boldsymbol {x},(\\boldsymbol {a}^{\\prime},\\boldsymbol {b}^{\\prime}))</span>  defines  <span class="math">\\pmb {a} = (1,\\pmb {x},\\pmb{a}^{\\prime}),\\pmb {b} = (\\mathbf{1}_l,\\pmb {b}^{\\prime})</span>  , and computes</p>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} (X) = \\left(\\sum_ {j = l + 1} ^ {m} a _ {j} \\lambda_ {j} (X)\\right) / t _ {l} (X), B ^ {\\prime} (X) = \\left(\\left(\\sum_ {j = 1} ^ {m} b _ {j} \\lambda_ {j} (X)\\right) - 1\\right) / t _ {l} (X),</span></div>

    <p class="text-gray-300">for  <span class="math">t_l(X) = \\prod_{i=1}^{\\ell}(X - \\mathsf{h}_i)</span> . It outputs  <span class="math">(A&#x27;(X), B&#x27;(X))</span> .</p>

    <p class="text-gray-300"><span class="math">\\mathcal{V}_{\\mathrm{lite}}</span>  and  <span class="math">\\mathcal{P}_{\\mathrm{lite}}</span>  instantiate  <span class="math">\\mathcal{V}_{\\mathrm{LA}}^{\\mathcal{W}_{\\mathrm{LA}}}(\\mathbb{F})</span>  and  <span class="math">\\mathcal{P}_{\\mathrm{LA}}(\\mathbb{F},\\mathbf{W},(\\pmb {a},\\pmb {b},\\pmb {a}\\circ \\pmb {b}))</span>  . Let  <span class="math">\\pmb {Y}(X) = (A(X),B(X),A(X)B(X))</span>  be the polynomials outputted by  <span class="math">\\mathcal{P}_{\\mathrm{LA}}</span>  in the first round.</p>

    <p class="text-gray-300"><strong>Decision Phase:</strong> Define  <span class="math">C_l(X) = \\lambda_1(X) + \\sum_{j=1}^{l-1} x_j \\lambda_{j+1}(X)</span>  and accept if and only if (1)  <span class="math">A(X) = A&#x27;(X) t_l(X) + C_l(X)</span> , (2)  <span class="math">B(X) = B&#x27;(X) t_l(X) + 1</span> , and (3)  <span class="math">\\mathcal{V}_{\\mathrm{LA}}</span>  accepts.</p>

    <p class="text-gray-300">Fig. 2. PHP for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS - lite}}^{\\prime}</span>  from PHP for  <span class="math">\\mathcal{R}_{\\mathrm{LA}}</span> . The PHP for  <span class="math">\\mathcal{R}_{\\mathrm{LA}}</span>  should be instantiated for  <span class="math">W_{Y} = \\{(a,b,a\\circ b): a,b\\in \\mathbb{F}^{m}\\}</span> ,  <span class="math">\\mathcal{E}(a,b,a\\circ b) = (a^{\\top}\\lambda (X),b^{\\top}\\lambda (X),(a^{\\top}\\lambda (X))(b^{\\top}\\lambda (X)))</span> .</p>

    <p class="text-gray-300">Theorem 5. When instantiated with a complete, sound and knowledge sound linear argument, the PHP of Fig. 2 satisfies completeness, soundness and knowledge-soundness.</p>

    <p class="text-gray-300">Proof. Completeness follows directly from the definition of  <span class="math">A&#x27;(X), B&#x27;(X), A(X), B(X)</span>  and completeness of the linear argument. Soundness and knowledge soundness hold if the linear argument is sound as well, because  <span class="math">\\mathcal{V}_{\\mathrm{lite}}</span>  accepts if  <span class="math">\\mathcal{V}_{\\mathrm{LA}}</span>  accepts, meaning  <span class="math">\\mathbf{W}(\\pmb{a}, \\pmb{b}, \\pmb{a} \\circ \\pmb{b})^\\top = 0</span>  and  <span class="math">\\mathcal{R}_{\\mathrm{R1CS - lite}}&#x27;</span>  holds, and for extraction it suffices to use the extractor of the linear argument.</p>

    <p class="text-gray-300">To achieve zero-knowledge, it is common to several works on pairing-based zkSNARKS [CFF+20, CHM+20, GGPR13] to randomize the polynomial commitment to the witness with a polynomial that is a multiple of the vanishing polynomial. That is, the commitment to a vector  <span class="math">\\pmb{a}</span>  is  <span class="math">A(X) = \\sum a_{i}\\lambda_{i}(X) + t(X)h(X)</span> , where  <span class="math">t(X),\\lambda_i(X)</span>  are defined as usual, and the coefficients of  <span class="math">h(X)</span>  are the randomness. In [GGPR13],  <span class="math">h(X)</span>  can be constant, since the commitment  <span class="math">A(X)</span>  in the final argument is evaluated at a single point. In other works where the commitment needs to support queries at several point values,  <span class="math">h(X)</span>  needs to be of higher degree. In Marlin, it is suggested to choose the degree according to the number of oracle queries to maximize efficiency, and in Lunar this idea is developed into a fine-grained analysis and a vector with query bounds is specified for the compiler. Additionally, for this technique, the prover needs to send a masking polynomial to randomize the polynomial  <span class="math">R(X)</span>  of the inner product check. The reason is that this polynomial leaks information about  <span class="math">(A(X),B(X),A(X)B(X))\\cdot D(X)\\mod t(X)</span> .</p>

    <p class="text-gray-300">In this section, we show how to add zero-knowledge to the PHP for R1CS-lite of Section 4.2 without sending additional polynomials. The approach is natural and a similar technique has also been used in [SZ20]. Let  <span class="math">(\\mathsf{b}_A,\\mathsf{b}_B,\\mathsf{b}_{R_t},\\mathsf{b}_{H_t})</span>  be the tuple of bounds on the number of polynomial evaluations seen by the verifier after compiling for the polynomials  <span class="math">A(X),B(X),R_{t}(X),H_{t}(X)</span> . To commit to a vector  <span class="math">\\pmb {y}\\in \\mathbb{F}^m</span> , we sample some randomness  <span class="math">\\pmb {r}\\in \\mathbb{F}^n</span> , where  <span class="math">n</span>  is a function of  <span class="math">(\\mathsf{b}_A,\\mathsf{b}_B,\\mathsf{b}_{R_t},\\mathsf{b}_{H_t})</span>  to be specified (a small constant when compiling). The cardinal of  <span class="math">\\mathbb{H}</span>  is denoted by  <span class="math">\\tilde{m}</span>  in this section. A commitment is defined in the usual way for the vector  <span class="math">(\\pmb {y},\\pmb {r})</span> , i.e.  <span class="math">\\sum_{i = 1}^{m}y_{i}\\lambda_{i}(X) + \\sum_{i = m + 1}^{m + n}r_{i}\\lambda_{i}(X)</span> , and, naturally, we require  <span class="math">m + n\\leq \\tilde{m}</span> . Our idea is to consider related randomness for  <span class="math">A(X),B(X)</span>  so that the additional randomness sums to 0 and does not interfere with the inner product argument. The novel approach is to enforce this relation of the randomness by adding one additional constraint to  <span class="math">\\mathbf{W}</span> . The marginal cost of this for the prover is minimal. Starting from the PHP of Fig. 2 we introduce the changes described in Fig. 3.</p>

    <p class="text-gray-300">Offline Phase: For  <span class="math">\\tilde{m} = m + n</span> , the matrix of constraints is:</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde {\\mathbf {W}} = \\left( \\begin{array}{c c c c c} \\mathbf {I} _ {m} &amp;amp; \\mathbf {0} _ {m \\times n} &amp;amp; \\mathbf {0} _ {m \\times m} &amp;amp; \\mathbf {0} _ {m \\times n} &amp;amp; - \\mathbf {F} &amp;amp; \\mathbf {0} _ {m \\times n} \\\\ \\mathbf {0} _ {m \\times m} &amp;amp; \\mathbf {0} _ {m \\times n} &amp;amp; \\mathbf {I} _ {m} &amp;amp; \\mathbf {0} _ {m \\times n} &amp;amp; - \\mathbf {G} &amp;amp; \\mathbf {0} _ {m \\times n} \\\\ \\mathbf {0} _ {m} ^ {\\top} &amp;amp; \\mathbf {1} _ {n} ^ {\\top} &amp;amp; \\mathbf {0} _ {m} ^ {\\top} &amp;amp; \\mathbf {1} _ {n} ^ {\\top} &amp;amp; \\mathbf {0} _ {m} ^ {\\top} &amp;amp; \\mathbf {0} _ {n} ^ {\\top} \\end{array} \\right)</span></div>

    <p class="text-gray-300">Online Phase:  <span class="math">\\mathcal{P}_{\\mathrm{lite}}</span>  samples  <span class="math">\\pmb{r}_a \\gets \\mathbb{F}^n, \\pmb{r}_b \\gets \\mathbb{F}^n</span>  conditioned on  <span class="math">\\sum_{i=1}^{n} r_{a,i} + r_{b,i} = 0</span>  and uses  <span class="math">\\tilde{\\pmb{a}} := (1, \\pmb{x}, \\pmb{a}&#x27;, \\pmb{r}_a)</span> ,  <span class="math">\\tilde{\\pmb{b}} := (\\mathbf{1}_l, \\pmb{b}&#x27;, \\pmb{r}_b)</span> , to construct  <span class="math">\\tilde{A}(X)</span>  and  <span class="math">\\tilde{B}(X)</span> ,  <span class="math">\\tilde{A}&#x27;(X)</span>  and  <span class="math">\\tilde{B}&#x27;(X)</span>  as before.</p>

    <p class="text-gray-300">Fig. 3. Modification of the PHP for  <span class="math">\\mathcal{R}_{\\mathrm{R1CS - lite}}^{\\prime}</span>  to achieve zero-knowledge. The omitted parts are identical.</p>

    <p class="text-gray-300">Theorem 6. With the modification described in Fig. 3 the PHP of Fig. 2 is perfectly complete, sound, knowledge-sound, perfect zero-knowledge and  <span class="math">(\\mathsf{b}_A,\\mathsf{b}_B,\\mathsf{b}_{R_t},\\mathsf{b}_{H_t})</span> -bounded honest-verifier zero-knowledge if  <span class="math">n\\geq</span> <span class="math">(\\mathsf{b}_A + \\mathsf{b}_B + \\mathsf{b}_{R_t} + \\mathsf{b}_{H_t} + 1) / 2</span> , and  <span class="math">n\\geq \\max (\\mathsf{b}_A,\\mathsf{b}_B)</span> .</p>

    <p class="text-gray-300">Proof. The only difference with the previous argument is the fact that the matrix of constraints has changed, which is now  <span class="math">\\tilde{\\mathbf{W}}</span> . For completeness, observe that the additional constraint makes sure that  <span class="math">\\sum_{i=1}^{n} r_{a,i} + r_{b,i} =</span></p>

    <p class="text-gray-300"><span class="math">0</span>, and an honest prover chooses the randomness such that this holds. On the other hand, the sumcheck theorem together with this equation guarantee that the randomness does not affect the divisibility at <span class="math">0</span> of <span class="math">(\\tilde{A}(X),\\tilde{B}(X),\\tilde{A}(X)\\tilde{B}(X))\\cdot\\bm{D}(X)\\mod t(X)</span>.</p>

    <p class="text-gray-300">For soundness, note that <span class="math">\\tilde{\\mathbf{W}}\\left(\\tilde{\\bm{a}}^{\\top},\\,\\tilde{\\bm{b}}^{\\top},\\,(\\tilde{\\bm{a}}\\circ\\tilde{\\bm{b}})^{\\top}\\right)</span>, is equivalent to 1) <span class="math">\\bm{a}=\\mathbf{F}(\\bm{a}\\circ\\bm{b})</span>, 2) <span class="math">\\bm{b}=\\mathbf{G}(\\bm{a}\\circ\\bm{b})</span>, and 3) <span class="math">\\sum_{i=1}^{n}r_{a,i}+r_{b,i}=0</span>, for <span class="math">\\bm{a}:=(1,\\bm{x},\\bm{a}^{\\prime})\\ \\bm{b}:=(\\bm{1}_{l},\\bm{b}^{\\prime})</span>. This is because the first two blocks of constraints have 0s in the columns corresponding to <span class="math">\\bm{r}_{a},\\bm{r}_{b}</span>, and the other way around for the last constraint. Therefore, by the soundness of the linear argument <span class="math">\\sum_{i=1}^{n}r_{a,i}+r_{b,i}=0</span>, and the randomness does not affect divisibility at <span class="math">0</span> of <span class="math">(A(X),B(X),A(X)B(X))^{\\top}\\cdot\\bm{D}(X)\\mod t(X)</span>, so the same reasoning used for the argument of Fig. 2 applies.</p>

    <p class="text-gray-300">Perfect zero-knowledge of the PHP is immediate, as all the messages in the CSS procedure contain only public information and the rest of the information exchanged are oracle polynomials.</p>

    <p class="text-gray-300">We now prove honest-verifier bounded zero-knowledge. The simulator is similar to <em>[CFF^{+}20]</em>(Th. 4.7), but generalized to the distribution of <span class="math">\\bm{D}(X)</span> induced by the underlying CSS scheme. The simulator gets access to the random tape of the honest verifier and receives <span class="math">x</span> and the coins of the CSS scheme, as well as a list of its checks. It creates honestly all the polynomials of the CSS argument, since these are independent of the witness.</p>

    <p class="text-gray-300">For an oracle query at point <span class="math">\\gamma</span>, the simulator samples uniform random values <span class="math">A^{\\prime}_{\\gamma},B^{\\prime}_{\\gamma},R_{\\gamma,t}</span> in <span class="math">\\mathbb{F}</span> and declares them, respectively, as <span class="math">A^{\\prime}(\\gamma),B^{\\prime}(\\gamma),R_{t}(\\gamma)</span>. It then defines the rest of the values to be consistent with them. More precisely, let <span class="math">\\bm{D}(X)^{\\top}=\\bm{s}^{\\top}\\mathbf{W}\\bm{\\lambda}(X)=(D_{a}(X),D_{b}(X),D_{ab}(X))</span> be the output of the CSS argument, which the simulator can compute with the CSS coins. Then, the simulator sets:</p>

    <p class="text-gray-300"><span class="math">A_{\\gamma}=A^{\\prime}_{\\gamma}t_{l}(\\gamma)+\\sum_{i=1}^{l}x_{i}\\lambda_{i}(\\gamma),</span> <span class="math">B_{\\gamma}=B^{\\prime}_{\\gamma}t_{l}(\\gamma)+1,</span> <span class="math">p_{\\gamma}=D_{a}(\\gamma)A_{\\gamma}+D_{b}(\\gamma)B_{\\gamma}+D_{ab}(\\gamma)A_{\\gamma}B_{\\gamma}</span> <span class="math">H_{t\\gamma}=(p_{\\gamma}-\\gamma R_{t,\\gamma})/t(\\gamma),</span></p>

    <p class="text-gray-300">where <span class="math">Q_{\\gamma}</span> for <span class="math">Q\\in\\{A^{\\prime},B^{\\prime},R_{t},H_{t}\\}</span> is declared as <span class="math">Q(\\gamma)</span>. The simulator keeps a table of the computed values to answer consistently the oracle queries.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now argue that the queries have the same distribution as the evaluations of the prover’s polynomials if all the queries <span class="math">\\gamma</span> are in <span class="math">\\mathbb{F}\\setminus\\mathbb{H}</span>. Since the verifier is honest, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{H}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is assumed to be a negligible fraction of the field elements, we can always assume this is the case. In this case, the polynomial encoding of </span>\\bm{r}_{a},\\bm{r}_{b}<span class="math"> acts as a masking polynomial for </span>A^{\\prime}(X),B^{\\prime}(X),R_{t}(X),H_{t}(X)<span class="math"> and taking into account that </span>\\sum_{i=1}^{n}r_{a,i}+r_{b,i}=0<span class="math"> to have the same distribution it is sufficient that </span>2n-1\\geq\\mathsf{b}_{A}+\\mathsf{b}_{B}+\\mathsf{b}_{R_{t}}+\\mathsf{b}_{H_{t}}<span class="math">, and </span>n\\geq\\max(\\mathsf{b}_{A}+\\mathsf{b}_{B})$, as stated in the theorem. Therefore, bounded zero-knowledge is proven. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.4 Combining CSS schemes</h3>

    <p class="text-gray-300">Since a CSS scheme outputs a linear combination of the rows of a matrix <span class="math">\\mathbf{M}</span>, different instances of a CSS scheme can be easily combined with linear operations. More precisely, given a matrix <span class="math">\\mathbf{M}</span> that can be written as \\[ \\begin{pmatrix}\\mathbf{M}_{1}\\\\ \\mathbf{M}_{2}\\end{pmatrix} \\], we can use a different CSS arguments for each <span class="math">\\mathbf{M}_{i}</span>. Since all current constructions of CSS arguments have limitations in terms of the types of matrices they apply to, this opens the door to decomposing the matrix of constraints into blocks that admit different efficient CSS arguments. For instance, matrices with a few very dense constraints (i.e. with very few rows with a lot of non-zero entries) and otherwise sparse could be split to use the scheme for sparse matrices of Section 3 for one part, and the trivial approach (where one polynomial for each row is computed by the indexer, and the verifier can sample the polynomial <span class="math">D(X)</span> computing the linear combination itself) for the rest. Alternatively, the extended Vandermonde approach of Section 6 could also be used for the very dense rows. That is, one reason to divide the matrix <span class="math">\\mathbf{M}</span> into blocks is to have a broader class of admissible matrices. Another reason is efficiency, since if a block that is either <span class="math">\\bm{0}</span> or the identity matrix, the verifier can open the polynomial <span class="math">D(X)</span> itself, saving on the number of</p>

    <p class="text-gray-300">polynomials that need to be sent. More specifically, for our final construction, we will often split a matrix into two blocks of <span class="math">m</span> rows, <span class="math">\\mathbf{M}=\\binom{\\mathbf{M}_{1}}{\\mathbf{M}_{2}}</span>, use the same CSS argument for each matrix with the same coins, and combine them to save on communication. More precisely, if <span class="math">\\bm{s}=\\mathsf{Smp}(\\mathsf{cn}\\mathsf{s})</span>, and <span class="math">D_{1}(X)=\\bm{s}^{\\top}\\mathbf{M}_{1}\\bm{\\lambda}(X)</span> and <span class="math">D_{2}(X)=\\bm{s}^{\\top}\\mathbf{M}_{2}\\bm{\\lambda}(X)</span> are the polynomials associated to <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2}</span>, we will modify the CSS argument so that it sends <span class="math">D_{1}(X)+zD_{2}(X)</span> for some challenge <span class="math">z</span> chosen by the verifier, instead of <span class="math">D_{1}(X)</span> and <span class="math">D_{2}(X)</span> individually. Note that <span class="math">D_{1}(X)+zD_{2}(X)=(\\bm{s}^{\\top},z\\bm{s}^{\\top})\\mathbf{M}\\bm{\\lambda}(X)</span>, that is, this corresponds to a CSS argument where the sampling coefficients depend on <span class="math">z</span> also.</p>

    <p class="text-gray-300">We note that this cannot be done generically. The success of this technique depends on the underlying CSS argument and the type of admissible matrices. Intuitively, this modification corresponds to implicitly constructing a CSS argument for the matrix <span class="math">\\mathbf{M}_{1}+z\\mathbf{M}_{2}</span>, so it is necessary that: a) the polynomials computed by the indexer of the CSS argument for <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2}</span> can be combined, upon receiving the challenge <span class="math">z</span>, to the CSS indexer polynomials of <span class="math">\\mathbf{M}_{1}+z\\mathbf{M}_{2}</span>, and b) that <span class="math">\\mathbf{M}_{1}+z\\mathbf{M}_{2}</span> is an admissible matrix for this CSS argument. For instance, if <span class="math">\\mathbf{M}_{1},\\mathbf{M}_{2}</span> has <span class="math">K</span> non-zero entries each, and the admissible matrices of a CSS instance must have at most <span class="math">K</span> non-zero entries, then <span class="math">\\mathbf{M}_{1}+z\\mathbf{M}_{2}</span> is not generally an admissible matrix. We will be using this optimization for our final PHP for sparse matrices, and we will see there that these conditions are met in this case.</p>

    <h2 id="sec-40" class="text-2xl font-bold">5 Checkable Subspace Sampling Arguments for Sparse Matrices</h2>

    <p class="text-gray-300">Given the results of the previous sections, for our R1CS-lite argument it is sufficient to design a CSS scheme for matrices <span class="math">\\mathbf{M}\\in\\mathbb{F}^{m\\times m}</span> and then use it on all the blocks of <span class="math">\\mathbf{W}</span>. In this section, we give several novel CSS arguments for different types of square sparse matrices.</p>

    <p class="text-gray-300">We consider two disjoint sets of roots of unity, <span class="math">\\mathbb{H},\\mathbb{K}</span> of degree <span class="math">m</span> and <span class="math">K</span>, respectively. For <span class="math">\\mathbb{H}</span> we use the notation defined in Section 3. The elements of <span class="math">\\mathbb{K}</span> are assumed to have some canonical order, and we use <span class="math">\\mathsf{k}_{\\ell}</span> for the <span class="math">\\ell</span>th element in <span class="math">\\mathbb{K}</span>, <span class="math">\\mu_{\\ell}(X)</span> for the <span class="math">\\ell</span>th Lagrangian interpolation polynomial associated to <span class="math">\\mathbb{K}</span>, and <span class="math">u(X)</span> for the vanishing polynomial.</p>

    <p class="text-gray-300">Matrices <span class="math">\\mathbf{M}\\in\\mathbb{F}^{m\\times m}</span> can be naturally encoded as a bivariate polynomial as <span class="math">P(X,Y)=\\bm{\\alpha}(Y)^{\\top}\\mathbf{M}\\bm{\\beta}(X)</span>, for some <span class="math">\\bm{\\alpha}(Y)\\in\\mathbb{F}[Y]^{m},\\bm{\\beta}(X)\\in\\mathbb{F}[X]^{m}</span>. Let <span class="math">\\bm{m}_{i}^{\\top}</span> be the ith row of <span class="math">\\mathbf{M}</span>, and <span class="math">P_{i}(X)=\\bm{m}_{i}^{\\top}\\bm{\\beta}(X)</span>. Then,</p>

    <p class="text-gray-300"><span class="math">P(X,x)=\\bm{\\alpha}(x)^{\\top}\\mathbf{M}\\bm{\\beta}(X)=\\sum_{i=1}^{m}\\alpha_{i}(x)P_{i}(X).</span></p>

    <p class="text-gray-300">That is, the polynomial <span class="math">P(X,x)</span> is a linear combination of the polynomials associated to the rows of <span class="math">\\mathbf{M}</span> via the encoding defined by <span class="math">\\bm{\\beta}(X)</span>, with coefficients <span class="math">\\alpha_{i}(x)</span>. This suggests to define a CSS scheme where, in the sampling phase, the verifier sends the challenge <span class="math">x</span> and the prover replies with <span class="math">D(X)=P(X,x)</span>, and, in the proving phase, the prover convinces the verifier that <span class="math">D(X)</span> is correctly sampled from coins <span class="math">x</span>. This approach appears, implicitly or explicitly, in Sonic and most follow-up work we are aware of.</p>

    <p class="text-gray-300">In Sonic, <span class="math">\\bm{\\alpha}(Y),\\bm{\\beta}(X)</span> are vectors of Laurent polynomials. In Marlin, Lunar and in this work, we set <span class="math">\\bm{\\alpha}(Y)=\\bm{\\lambda}(Y)</span>, and <span class="math">\\bm{\\beta}(X)=\\bm{\\lambda}(X)</span>. The choice of <span class="math">\\bm{\\beta}(X)</span> is to make the encoding compatible with the inner product defined by the sumcheck, and the choice of <span class="math">\\alpha(Y)</span> is necessary for the techniques used in the proving phase of the CSS schemes that will be detailed in this Section.</p>

    <p class="text-gray-300">For the proving phase, the common strategy is to follow the general template introduced in Sonic: the verifier samples a challenge <span class="math">y\\in\\mathbb{F}</span>, checks that <span class="math">D(y)</span> is equal to a value <span class="math">\\sigma</span> sent by the prover, and that <span class="math">\\sigma=P(y,x)</span> (through what is called a signature of correct computation, as in <em>[x20]</em>). This proves that <span class="math">D(X)=P(X,x)</span>. The last one is the challenging step, and is in fact, the main technical novelty of each of the mentioned previous works. In all of them, this is achieved by restricting the sets of matrices <span class="math">\\mathbf{M}</span> to have a special structure: in Sonic they need to be sums of permutation matrices, and in Marlin, as later also Lunar, arbitrary matrices with at most <span class="math">K</span> non-zero entries.</p>

    <p class="text-gray-300">This section is organized as follows. We start by giving an overview of our new techniques in Section 5.1. In Section 5.2, we explain a basic CSS scheme, that works only for <em>simple matrices</em>, i.e., matrices with at</p>

    <p class="text-gray-300">most one non-zero element per column. In Section 5.3, we see how to compose these checks to achieve a CSS argument for arbitrary sparse matrices <span class="math">\\mathbf{M}</span> with at most <span class="math">K</span> non-zero elements, where <span class="math">K</span> is the size of a multiplicative subgroup <span class="math">\\mathbb{K}\\subset\\mathbb{F}</span>. In Section 5.4, we give an extension of the basic construction to matrices with at most <span class="math">V</span> non-zero elements per column, for some small bound <span class="math">V</span>. This technique is used in Section 5.5 to generalize the second argument to matrices that can be written as a sum of <span class="math">V</span> matrices of sparsity <span class="math">K</span>, resulting on a scheme for matrices with sparsity <span class="math">VK</span> that uses the same multiplicative subgroup and does not increase the communication complexity with respect to the one for matrices with sparsity <span class="math">K</span>. Finally, in Section 5.6 we observe that our results also apply to low tensor rank matrices.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">5.1 Overview of New Techniques</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our main result of this section is a CSS scheme for any matrix <span class="math">\\mathbf{M}=(m_{i,j})\\in\\mathbb{F}^{m\\times m}</span> of at most <span class="math">K</span> non-zero entries. Assuming the non-zero entries are ordered, this matrix can be represented, as proposed in Marlin, by three functions <span class="math">\\mathsf{v}:\\mathbb{K}\\to\\mathbb{F}</span>, <span class="math">\\mathsf{r}:\\mathbb{K}\\to[m]</span>, <span class="math">\\mathsf{c}:\\mathbb{K}\\to[m]</span> such that <span class="math">P(X,Y)=\\sum_{\\ell=1}^{K}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(Y)\\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(X)</span>, where the <span class="math">\\ell</span>th non-zero entry is <span class="math">\\mathsf{v}(\\mathsf{k}_{\\ell})=m_{\\mathsf{r}(\\mathsf{k}_{\\ell}),\\mathsf{c}(\\mathsf{k}_{\\ell})}</span>. If the matrix has less than <span class="math">K</span> non-zero entries <span class="math">\\mathsf{v}(\\mathsf{k}_{\\ell})=0</span>, for $\\ell=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1,\\ldots,K<span class="math">, and </span>\\mathsf{r}(\\mathsf{k}_{\\ell}),\\mathsf{c}(\\mathsf{k}_{\\ell})$ are defined arbitrarily. We borrow this representation but design our own CSS scheme by following a “linearization strategy”.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see that <span class="math">P(y,x)</span> is correctly evaluated, we observe that it can be written as:</p>

    <p class="text-gray-300"><span class="math">P(y,x)=\\big{(}\\lambda_{\\mathsf{r}(\\mathsf{k}_{1})}(x),\\ldots,\\lambda_{\\mathsf{r}(\\mathsf{k}_{K})}(x)\\big{)}\\cdot\\big{(}\\mathsf{v}(\\mathsf{k}_{1})\\lambda_{\\mathsf{c}(\\mathsf{k}_{1})}(y),\\ldots,\\mathsf{v}(\\mathsf{k}_{K})\\lambda_{\\mathsf{c}(\\mathsf{k}_{K})}(y)\\big{)}.</span></p>

    <p class="text-gray-300">We define low degree extensions of each of these vectors respectively as:</p>

    <p class="text-gray-300"><span class="math">e_{x}(X)=\\sum_{\\ell=1}^{K}\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(x)\\mu_{\\ell}(X),\\qquad e_{y}(X)=\\sum_{\\ell=1}^{K}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(y)\\mu_{\\ell}(X).</span></p>

    <p class="text-gray-300">If the prover can convince the verifier that <span class="math">e_{x}(X),e_{y}(X)</span> are correctly computed, then it can show that <span class="math">P(y,x)=\\sigma</span> by using the inner product argument of Section 3 to prove that the sum of <span class="math">e_{x}(X)e_{y}(X)\\mod t(X)</span> at <span class="math">\\mathbb{K}</span> is <span class="math">\\sigma</span>.</p>

    <p class="text-gray-300">Observe that <span class="math">e_{x}(X)=\\boldsymbol{\\lambda}(x)^{\\top}\\mathbf{M}_{x}\\boldsymbol{\\mu}(X)</span> and <span class="math">e_{y}(X)=\\boldsymbol{\\lambda}(y)^{\\top}\\mathbf{M}_{y}\\boldsymbol{\\mu}(X)</span>, for some matrices <span class="math">\\mathbf{M}_{x},\\mathbf{M}_{y}</span> with at most one non-zero element per column. To prove they are correctly computed it suffices to design a CSS argument for these simple matrices. This can be done in a much simpler way than in Marlin (and as in Lunar, that uses a similar technique), who prove directly that a low degree extension of <span class="math">e_{x}(X)e_{y}(X)</span> is correctly computed (intuitively, theirs is a quadratic check that requires the indexer to publish more information, as verifiers can only do linear operations in the polynomials output by it). Still, our technique is similar to theirs: given an arbitrary polynomial <span class="math">e_{x}(X)=\\sum_{\\ell=1}^{K}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}(x)\\mu_{\\ell}(X)</span>, for some function <span class="math">\\mathsf{f}:\\mathbb{K}\\to[m]</span>, we can “complete” the Lagrange <span class="math">\\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}(x)</span> with the missing term <span class="math">(x-\\mathsf{h}_{\\mathsf{f}(\\mathsf{k}_{\\ell})})</span> to get the vanishing polynomial <span class="math">t(x)</span>. The key insight is that the low degree extension of these “completing terms” is <span class="math">x-v_{1}(X)</span>, where <span class="math">v_{1}(X)=\\sum_{\\ell=1}^{K}\\mathsf{h}_{\\mathsf{f}(\\mathsf{k}_{\\ell})}\\mu_{\\ell}(X)</span> can be computed by the indexer.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The encoding for sparse matrices requires <span class="math">K</span> to be at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and generating a field with this large multiplicative subgroup can be a problem. We consider a generalization to matrices </span>\\mathbf{M}<span class="math"> of a special form with sparsity </span>KV<span class="math">, for any </span>V\\in\\mathbb{N}<span class="math">. The interesting point is that communication complexity does not grow with </span>V<span class="math">, and only the number of indexer polynomials grows (as </span>2V+2$). This generalization is constructed from the argument for sums of basic matrices presented in Section 5.4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We stress the importance of the linearization step: it not only allows for a simple explanation of underlying techniques for the proving phase, but also for generalizations such as the ones in Sections 5.4, 5.5 and 5.6. The argument for basic matrices is also the key to our most efficient construction, as discussed in Appendix C.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.2 CSS Argument for Simple Matrices</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our basic building block is a CSS argument for matrices <span class="math">\\mathbf{M}=(m_{ij})\\in\\mathbb{F}^{m\\times K}</span> with at most one non-zero value in each column, in particular, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math">. We define two functions associated to </span>\\mathbf{M}<span class="math">, </span>\\mathsf{v}:\\mathbb{K}\\to\\mathbb{F}<span class="math">, </span>\\mathsf{f}:\\mathbb{K}\\to[m]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given an element  <span class="math">\\mathsf{k}_{\\ell} \\in \\mathbb{K}</span> ,  <span class="math">\\mathsf{v}(\\mathsf{k}_{\\ell}) = m_{\\mathsf{f}(\\mathsf{k}_{\\ell}),\\ell} \\neq 0</span> , i.e., function  <span class="math">\\mathsf{v}</span>  outputs the only non-zero value of column  <span class="math">\\ell</span>  and  <span class="math">\\mathsf{f}</span>  the corresponding row; if such a value does not exist set  <span class="math">\\mathsf{v}(\\mathsf{k}_{\\ell}) = 0</span>  and  <span class="math">\\mathsf{f}(\\mathsf{k}_{\\ell})</span>  arbitrarily. We define the polynomial  <span class="math">P(X,Y)</span>  such that  <span class="math">D(X) = P(X,x)</span>  as  <span class="math">P(X,Y) = \\lambda(Y)^{\\top}\\mathbf{M}\\boldsymbol{\\mu}(X)</span> . Observe that, by definition of  <span class="math">\\mathsf{v}</span>  and  <span class="math">\\mathsf{f}</span> ,  <span class="math">P(X,Y) = \\sum_{\\ell=1}^{K} \\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}(Y)\\mu_{\\ell}(X)</span> .</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 4. A simple CSS scheme for matrices with at most one non-zero element per column.</p>

    <p class="text-gray-300">Theorem 7. The argument of Fig. 4 satisfies completeness and perfect soundness.</p>

    <p class="text-gray-300">Proof. When evaluated in any  <span class="math">\\mathsf{k}_{\\ell} \\in \\mathbb{K}</span> , the right side of the verification equation is  <span class="math">t(x)v_{2}(\\mathsf{k}_{\\ell}) = t(x)\\mathsf{v}(\\mathsf{k}_{\\ell})\\mathsf{h}_{\\mathsf{f}(\\mathsf{k}_{\\ell})}m^{-1}</span> . Completeness follows from the fact that the left side is:</p>

    <div class="my-4 text-center"><span class="math-block">D \\left(\\mathrm {k} _ {\\ell}\\right) \\left(x - v _ {1} \\left(\\mathrm {k} _ {\\ell}\\right)\\right) = \\left(\\mathrm {v} \\left(\\mathrm {k} _ {\\ell}\\right) \\lambda_ {\\mathrm {f} \\left(\\mathrm {k} _ {\\ell}\\right)} (x)\\right) \\left(x - \\mathrm {h} _ {\\mathrm {f} \\left(\\mathrm {k} _ {\\ell}\\right)}\\right) = t (x) \\mathrm {v} \\left(\\mathrm {k} _ {\\ell}\\right) m ^ {- 1} \\mathrm {h} _ {\\mathrm {f} \\left(\\mathrm {k} _ {\\ell}\\right)}.</span></div>

    <p class="text-gray-300">For soundness, note that the degree of  <span class="math">D(X)</span>  is at most  <span class="math">K - 1</span>  and that the left side of the verification is  <span class="math">D(\\mathsf{k}_{\\ell})(x - v_{1}(\\mathsf{k}_{\\ell}))</span> , so  <span class="math">D(\\mathsf{k}_{\\ell}) = t(x)\\mathsf{v}(\\mathsf{k}_{\\ell})m^{-1}\\mathsf{h}_{\\mathsf{f}(\\mathsf{k}_{\\ell})}(x - \\mathsf{h}_{\\mathsf{f}(\\mathsf{k}_{\\ell})})^{-1} = \\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}</span> , for all  <span class="math">\\mathsf{k}_{\\ell} \\in \\mathbb{K}</span> . Thus,  <span class="math">D(X) = \\sum_{\\ell=1}^{K}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}\\mu_{\\ell}(X)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we present a CSS argument for matrices  <span class="math">\\mathbf{M}</span>  that are sparse but without any restriction on the non-zero entries per column. We assume a set of roots of unity  <span class="math">\\mathbb{K}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math">  and define  </span>P(X,Y) = \\sum_{\\ell=1}^{K} \\mathsf{v}(\\mathsf{k}_{\\ell}) \\lambda_{\\mathsf{f}(\\mathsf{k}_{\\ell})}(Y) \\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(X)<span class="math"> . As explained in the overview,  </span>P(y,x)<span class="math">  can be written as the inner product of two vectors that depend only on  </span>x<span class="math">  and  </span>y<span class="math"> , and the low degree extensions of these vectors,  </span>e_x(X), e_y(X)<span class="math"> , are nothing but the encodings of new matrices  </span>\\mathbf{M}_x<span class="math">  and  </span>\\mathbf{M}_y<span class="math">  in  </span>\\mathbb{F}^{m \\times K}$  that have at most one non-zero element per column, so the basic CSS of Section 5.2 can be used to prove correctness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 8. The argument of Fig. 5 satisfies completeness and  $(2K + 1) /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ -soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Completeness follows immediately and thus we only prove soundness. Although it does so in a batched form, the prover is showing that the following equations are satisfied,</p>

    <div class="my-4 text-center"><span class="math-block">e _ {x} (X) \\left(x - v _ {\\mathrm {r}} (X)\\right) = t (x) m ^ {- 1} v _ {\\mathrm {r}} (X) + H _ {u, x} (X) u (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">e _ {y} (X) \\left(y - v _ {1, \\mathrm {c}} (X)\\right) = t (y) v _ {2, \\mathrm {c}} (X) + H _ {u, y} (X) u (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">K e _ {x} (X) e _ {y} (X) - \\sigma = X R _ {u} (X) + u (X) H _ {u, x, y} (X),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, since all the left terms of the equations are defined before the verifier sends  <span class="math">z</span> , by the Schwartz-Zippel lemma, with all but probability  $3 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , the verifier accepts if and only such  </span>H_{u,x}(X), H_{u,y}(X), H_{u,x,y}(X), R_u(X)$  exist.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assuming they do, the rest of the proof is a consequence of (1) soundness of the protocol in Fig. 4, which implies that  <span class="math">e_{x}(X), e_{y}(X)</span>  correspond to the correct polynomials modulo  <span class="math">u(X)</span> , and (2) Lemma 2 (see below) shows that if the last equation is satisfied, and  <span class="math">e_{x}(X), e_{y}(X)</span>  coincide with the honest polynomials modulo  <span class="math">u(X)</span> , then  <span class="math">\\sigma = P(y,x)</span> . Because the prover sends  <span class="math">D(X)</span>  sma before receiving  <span class="math">y</span>  and  <span class="math">D(y) = \\sigma</span> , from the Schwartz-Zippel lemma we have that, except with negligible probability,  <span class="math">P(X,x) = D(X)</span>  and the argument is sound.</p>

    <p class="text-gray-300">Lemma 2. Given  <span class="math">e_x(X), e_y(X)</span>  such that  <span class="math">e_x(X) = \\sum_{\\ell=1}^{K} \\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(x) \\mu_{\\ell}(X)</span>  and  <span class="math">e_y(X) = \\sum_{\\ell=1}^{K} \\mathsf{v}(\\mathsf{k}_{\\ell}) \\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(y) \\mu_{\\ell}(X)</span> ,  <span class="math">P(y, x) = \\sum_{\\ell=1}^{K} \\mathsf{v}(\\mathsf{k}_{\\ell}) \\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(y) \\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(x) = \\sigma</span>  if and only if there exist polynomials  <span class="math">R_u(X) \\in \\mathbb{F}_{\\leq m-2}[X]</span> ,  <span class="math">H_{u,x,y}(X)</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">e _ {x} (X) e _ {y} (X) - \\sigma / K = X R _ {u} (X) + H _ {u, x, y} (X) u (X).</span></div>

    <p class="text-gray-300">Proof. Note that  <span class="math">e_x(X)e_y(X) = \\sum_{\\ell=1}^{K}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(y)\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(x)\\mu_{\\ell}(X) \\mod u(X)</span> . By the univariate sumcheck (Lemma 1),  <span class="math">e_x(X)e_y(X) - \\sigma / K</span>  is divisible by  <span class="math">X</span>  if and only if  <span class="math">P(y,x) = \\sigma</span> , which concludes the proof.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fig. 5. CSS argument for  <span class="math">\\mathbf{M}</span> , with  <span class="math">\\mathbb{K}</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{K}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section, we use  <span class="math">\\mathbf{M}</span>  for a matrix in  <span class="math">\\mathbb{F}^{m\\times K}</span>  that can be written as  <span class="math">\\sum_{i = 1}^{\\nu}\\mathbf{M}_i</span> , with each  <span class="math">\\mathbf{M}_i</span>  having at most one non-zero element in each column. We define two functions associated to each  <span class="math">\\mathbf{M}_i</span> ,  <span class="math">\\mathsf{v}_i:\\mathbb{K}\\to \\mathbb{F}</span> ,  <span class="math">\\mathsf{f}_i:\\mathbb{K}\\to [m]</span>  as in Section 5.2. This type of matrices will be used to design a generalization of the CSS</p>

    <p class="text-gray-300">argument for sums of sparse matrices in Section 5.5. Also, in Appendix C we use this argument in the context where  <span class="math">\\mathbf{M}</span>  is a matrix in  <span class="math">\\mathbb{F}^{K\\times m}</span> . In that case, the role of the multiplicative subgroups  <span class="math">\\mathbb{K},\\mathbb{H}</span>  should be inversed.</p>

    <p class="text-gray-300">Define  <span class="math">P(X,Y) = \\pmb{\\lambda}(Y)^{\\top}\\mathbf{M}\\pmb{\\mu}(X)</span> , and  <span class="math">D(X) = P(X,x)</span> . Observe that  <span class="math">P(X,Y) = \\sum_{i=1}^{V}\\sum_{\\ell=1}^{K}\\mathsf{v}_i(\\mathsf{k}_\\ell)\\lambda_{\\mathsf{f}_i(\\mathsf{k}_\\ell)}(Y)\\mu_\\ell(X)</span> . Let  <span class="math">S_\\ell = \\{\\mathsf{f}_i(\\mathsf{k}_\\ell): i \\in [V]\\}</span> , and  <span class="math">S_\\ell^c = [K] - S_\\ell</span> . The intuition is that, since there are at most  <span class="math">V</span>  non-zero  <span class="math">\\mathsf{v}_i(\\mathsf{k}_\\ell)</span>  for each  <span class="math">\\ell</span> , we can factor as:</p>

    <div class="my-4 text-center"><span class="math-block">P (\\mathsf {k} _ {\\ell}, x) = \\sum_ {i = 1} ^ {V} \\mathsf {v} _ {i} (\\mathsf {k} _ {\\ell}) \\lambda_ {\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell})} (x) = \\prod_ {s \\in S _ {\\ell} ^ {c}} (x - \\mathsf {h} _ {s}) R _ {\\ell} (x),</span></div>

    <p class="text-gray-300">where  <span class="math">R_{\\ell}(X)</span>  is a polynomial of degree  <span class="math">V</span> . So, to "complete"  <span class="math">P(\\mathsf{k}_{\\ell},x)</span>  to be a multiple of  <span class="math">t(x)</span> , we need to multiply it by  <span class="math">\\prod_{s\\in S_{\\ell}}(x - \\mathsf{h}_s)</span> , and the result will be  <span class="math">t(x)R_{\\ell}(x)</span> . The trick is that  <span class="math">\\hat{I}_{\\ell}(Y) = \\prod_{s\\in S_{\\ell}}(Y - \\mathsf{h}_s)</span> , and  <span class="math">R_{\\ell}(X)</span>  are polynomials of degrees  <span class="math">V</span> ,  <span class="math">V - 1</span> , respectively. Thus, if the indexer publishes the coefficients of these polynomials in the monomial basis, they can be reconstructed by the verifier with coefficients  <span class="math">1,x,\\ldots ,x^{V}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 6. A CSS scheme for matrices with at most  <span class="math">V</span>  non-zero elements per column.</p>

    <p class="text-gray-300">Theorem 9. The argument of Fig. 6 satisfies completeness and perfect soundness.</p>

    <p class="text-gray-300">Proof. When evaluated in any  <span class="math">\\mathsf{k}_{\\ell} \\in \\mathbb{K}</span> , the right side of the verification equation is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} t (x) \\hat {R} _ {x} (x) = \\frac {t (x)}{m} \\sum_ {i = 1} ^ {V} \\mathsf {v} _ {i} (\\mathsf {k} _ {\\ell}) \\mathsf {h} _ {\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell})} \\prod_ {s \\in S _ {\\ell} - \\{\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell}) \\}} (x - \\mathsf {h} _ {s}) \\\\ = \\sum_ {i = 1} ^ {V} \\mathsf {v} _ {i} (\\mathsf {k} _ {\\ell}) \\frac {\\mathsf {h} _ {\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell})}}{m} \\frac {t (x)}{x - \\mathsf {h} _ {\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell})}} \\prod_ {s \\in S _ {\\ell}} (x - \\mathsf {h} _ {s}) = \\prod_ {s \\in S _ {\\ell}} (x - \\mathsf {h} _ {s}) \\sum_ {i = 1} ^ {V} \\mathsf {v} _ {i} (\\mathsf {k} _ {\\ell}) \\lambda_ {\\mathsf {f} _ {i} (\\mathsf {k} _ {\\ell})} (x). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The left side of the equation is  <span class="math">D(\\mathsf{k}_{\\ell})\\hat{I}_x(\\mathsf{k}_{\\ell}) = \\big(\\sum_{i = 1}^{V}\\mathsf{v}_i(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}_i(\\mathsf{k}_{\\ell})}(x)\\big)\\big(\\prod_{s\\in S_\\ell}(x - \\mathsf{h}_s)\\big)</span> , so completeness is immediate. For soundness, if the verifier accepts  <span class="math">D(X)</span> , then  <span class="math">D(\\mathsf{k}_{\\ell})\\hat{I}_x(\\mathsf{k}_{\\ell}) = t(x)\\hat{R}_x(\\mathsf{k}_{\\ell})</span>  and  <span class="math">\\hat{I}_x(\\mathsf{k}_{\\ell}) = \\hat{I}_{\\ell}(x)</span></p>

    <p class="text-gray-300">therefore:</p>

    <p class="text-gray-300"><span class="math">D(\\mathsf{k}_{\\ell})=\\hat{I}_{\\ell}(x)^{-1}t(x)\\hat{R}_{\\ell}(x)=\\big{(}\\prod_{s\\in S^{c}_{i}}(x-\\mathsf{h}_{s})\\big{)}\\hat{R}_{x}(x)=\\sum_{i=1}^{V}\\mathsf{v}_{i}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{f}_{i}(\\mathsf{k}_{\\ell})}(x).</span></p>

    <p class="text-gray-300">We conclude that <span class="math">D(X)=P(X,x)\\mod u(X)</span>. Since both have degree at most <span class="math">K-1</span>, soundness is proven. ∎</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.5 CSS Argument for Sums of Sparse Matrices</h3>

    <p class="text-gray-300">The argument for general sparse matrices of last section can be easily generalized without increasing the communication complexity to any matrix <span class="math">\\mathbf{\\tilde{M}}</span> such that <span class="math">\\mathbf{\\tilde{M}}=\\sum_{i=1}^{V}\\mathbf{\\tilde{M}}_{i}</span>, where there exists one function <span class="math">\\mathsf{r}:\\mathbb{K}\\to[m]</span>, and, for each <span class="math">i</span>, two functions <span class="math">\\mathsf{c}_{i}:\\mathbb{K}\\to[m]</span>, and <span class="math">\\mathsf{v}_{i}:\\mathbb{K}\\to\\mathbb{F}</span>, such that: <span class="math">\\boldsymbol{\\lambda}(X)^{\\top}\\mathbf{\\tilde{M}}_{i}\\boldsymbol{\\lambda}(Y)=\\tilde{P}_{i}(X,Y)=\\sum_{\\ell=1}^{K}\\mathsf{v}_{i}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(Y)\\lambda_{\\mathsf{c}_{i}(\\mathsf{k}_{\\ell})}(X)</span>,</p>

    <p class="text-gray-300">Choosing the row and the column function smartly, this can cover many sparse matrices with <span class="math">KV</span> non-zero entries, considerably increasing the expressiveness of the CSS argument. For this generalization, we observe that if <span class="math">\\tilde{P}(X,Y)=\\sum_{i=1}^{V}\\tilde{P}_{i}(X,Y)</span>, then</p>

    <p class="text-gray-300"><span class="math">\\tilde{P}(y,x)=\\big{(}\\lambda_{\\mathsf{r}(\\mathsf{k}_{1})}(x),\\ldots,\\lambda_{\\mathsf{r}(\\mathsf{k}_{K})}(x)\\big{)}\\cdot\\sum_{i=1}^{V}\\big{(}\\mathsf{v}_{i}(\\mathsf{k}_{1})\\lambda_{\\mathsf{c}_{i}(\\mathsf{k}_{1})}(y),\\ldots,\\mathsf{v}_{i}(\\mathsf{k}_{K})\\lambda_{\\mathsf{c}_{i}(\\mathsf{k}_{K})}(y)\\big{)}.</span></p>

    <p class="text-gray-300">We can define <span class="math">e_{x}(X)</span> as Section 5.3, and <span class="math">e_{y}(X)=\\sum_{i=1}^{V}\\sum_{\\ell=1}^{K}\\mathsf{v}_{i}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{c}_{i}(\\mathsf{k}_{\\ell})}(y)\\mu_{\\ell}(X)</span>. Thus, <span class="math">e_{y}(X)=\\boldsymbol{\\lambda}(Y)^{\\top}\\mathbf{M}_{y}\\boldsymbol{\\mu}(X)</span>, where <span class="math">\\mathbf{M}_{y}</span> is a matrix with at most <span class="math">V</span> non-zero entries in each column. The CSS is constructed as in the one for sparse matrices of Section 5.3, except that to prove that <span class="math">e_{y}(X)</span> is correctly sampled, we use the CSS for sums of basic matrices of Section 5.4. Note that this change does not represent an increase in the communication complexity with respect to Section 5.3, only in the SRS size.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">5.6 Extension to Low Tensor Rank Matrices</h3>

    <p class="text-gray-300">Similar techniques to the ones in Section 5.1 can be used to construct a CSS scheme for matrices that are not sparse but for which a representation of low tensor rank is known. A matrix <span class="math">\\mathbf{M}\\in\\mathbb{F}^{m\\times m}</span> has tensor rank <span class="math">r</span> if there exist vectors <span class="math">\\boldsymbol{\\alpha}_{i},\\boldsymbol{\\beta}_{i}\\in\\mathbb{F}^{m}</span>, <span class="math">i\\in[r]</span> such that <span class="math">\\mathbf{M}=\\sum_{i=1}^{r}\\boldsymbol{\\alpha}_{i}\\boldsymbol{\\beta}_{i}^{\\top}</span>. The main observation is that, in this case, <span class="math">P(y,x)=\\boldsymbol{\\lambda}(x)^{\\top}\\mathbf{M}\\boldsymbol{\\lambda}(y)=\\sum_{i}(\\boldsymbol{\\lambda}(x)^{\\top}\\boldsymbol{\\alpha}_{i})\\cdot(\\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{\\lambda}(y))</span>. For each <span class="math">i</span>, we can compute low degree extensions of <span class="math">(\\boldsymbol{\\lambda}(x)^{\\top}\\boldsymbol{\\alpha}_{i})</span> and <span class="math">(\\boldsymbol{\\lambda}(y)\\boldsymbol{\\beta}_{i}^{\\top})</span> as before (but taking <span class="math">\\mathbb{K}=\\mathbb{H}</span>), and prove correctness with the basic CSS scheme of Section 5.2. Then, we can use the sumcheck theorem to see that <span class="math">\\sigma_{x,i}=\\boldsymbol{\\lambda}(x)^{\\top}\\boldsymbol{\\alpha}_{i}</span>, and <span class="math">\\sigma_{y,i}=\\boldsymbol{\\beta}_{i}^{\\top}\\boldsymbol{\\lambda}(y)</span>, and check <span class="math">P(y,x)=\\sum_{i=1}^{r}\\sigma_{x,i}\\sigma_{y,i}</span>. Naturally, the communication complexity depends on the tensor rank.</p>

    <p class="text-gray-300">There is no reason to expect that in practice the tensor rank will be low and, further, in general it is hard to compute. But we think it is of theoretical value to note that sparsity is not always the key for building efficient CSS schemes.</p>

    <h2 id="sec-47" class="text-2xl font-bold">6 A Simple CSS: Extended Vandermonde Sampling</h2>

    <p class="text-gray-300">The constructions discussed in the previous section impose (once the finite field is fixed) some conditions of the type of admissible matrices considered by the CSS scheme. For many practical use cases, this does not seem to be a limitation. However, regardless of the types of constraints that appear in applications so far, we think it is interesting to explore ways of constructing CSS arguments for more general matrices both for future applications and for theoretical understanding.</p>

    <p class="text-gray-300">The most trivial CSS scheme for a matrix <span class="math">\\mathbf{M}\\in\\mathbb{F}^{Q\\times m}</span> works as follows: indexer sends <span class="math">Q</span> oracle polynomials, one for each row, as <span class="math">P_{i}(X)=\\sum_{j=1}^{m}m_{ij}\\lambda_{j}(X)</span>. The verifier samples <span class="math">x\\leftarrow\\mathbb{F}</span>, and both prover and verifier compute the same polynomial <span class="math">D(X)=\\sum_{i=1}^{Q}x^{i-1}P_{i}(X)</span>, the verifier only accepts if the prover sends the same <span class="math">D(X)</span> it computed itself. This “Vandermonde Sampling” of polynomials associated with the row</p>

    <p class="text-gray-300">space of  <span class="math">\\mathbf{M}</span>  requires  <span class="math">\\mathcal{W}_{\\mathrm{CSS}}</span>  size and prover work to be linear in  <span class="math">Q</span> . When using this argument as part of a zkSNARK, the verifier will be linear in the circuit size, which is completely impractical in most scenarios.</p>

    <p class="text-gray-300">Below, we introduce a simple extension of the "Vandermonde sampling" technique, but trading memory for verifier work. This is impractical if  <span class="math">\\mathbf{M}</span>  is the matrix that encodes the circuit's affine constraints, as  <span class="math">Q \\approx m</span> . However, since this CSS scheme works for any arbitrary  <span class="math">\\mathbf{M}</span> , it is interesting to combine it as explained in Section 4.4 with other approaches: for example, this CSS argument can be used to encode a few very dense constraints, and the approach in Section 5.3 can be used for the rest.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The argument depends on two parameters  <span class="math">J, \\ell</span> :  $J =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{J}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the number of exponentiations that the verifier does, and  </span>\\ell<span class="math">  defines the size of the SRS. As we will prove, the argument is Elusive Kernel with probability  </span>\\epsilon = \\left(\\frac{Q}{Q + \\ell}\\right)^J<span class="math"> . Fixing the soundness error to some  </span>\\lambda<span class="math"> , one can derive a trade-off between the size of  </span>J, \\ell<span class="math"> . Taking  </span>\\ell<span class="math">  as some constant multiple of  </span>Q<span class="math"> , for having low verifier work, indexer work would be  </span>O(Qm + Q^2)<span class="math">  and verifier memory  </span>O(Q)<span class="math"> . Again, this only makes sense when  </span>Q$  represents some small set of constraints.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Offline Phase:  <span class="math">\\mathcal{I}_{\\mathrm{CSS}}(\\mathbb{F},\\mathbf{M},J,\\ell)</span>  : For all  <span class="math">i\\in [Q]</span> , defines the polynomials  <span class="math">P_{i}(X) = \\sum_{j = 1}^{m}m_{ij}\\lambda_{j}(X)</span> . For  <span class="math">i\\in [\\ell]</span> , it defines  <span class="math">P_{Q + i}(X) = \\sum_{j = 1}^{Q}i^{j - 1}P_{j}(X)</span> . It outputs  <span class="math">\\mathcal{W}_{\\mathrm{CSS}} = \\{P_1(X),\\ldots ,P_{Q + \\ell}(X)\\}</span> .</p>

    <p class="text-gray-300">Online Phase:  <span class="math">\\mathcal{V}_{\\mathrm{CSS}}</span>  samples  <span class="math">x \\gets \\mathbb{F}</span>  and a set of  <span class="math">J</span>  indices  <span class="math">\\mathcal{J} \\subset [Q + \\ell]</span> .  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  computes and outputs  <span class="math">D(X) = \\sum_{i_j \\in \\mathcal{J}} x^{j-1} P_{i_j}(X)</span> .</p>

    <p class="text-gray-300">Fig. 7. CSS argument with verifier sampling</p>

    <p class="text-gray-300">The prover does not need to send the polynomial  <span class="math">D(X)</span>  as it is computed by the verifier, and in the decision phase the verifier will always accept, so we omit it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 10. The argument of Fig. 7 is perfectly complete, perfectly sound and  <span class="math">\\epsilon</span> -Elusive Kernel, for  $\\epsilon = \\frac{J}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\left(\\frac{Q}{Q + \\ell}\\right)^J$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The verifier samples  <span class="math">D(X)</span>  on its own and thus completeness and soundness follow immediately. On the other hand, the probability that  <span class="math">\\pmb{y}^*</span>  is not orthogonal to  <span class="math">\\mathbf{M}</span>  but it is orthogonal to  <span class="math">\\sum_{i_j \\in \\mathcal{J}} x^{j-1} P_{i_j}(X)</span>  can be upper bounded by standard techniques by  $\\frac{J}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\left( \\frac{Q}{Q + \\ell} \\right)^J<span class="math"> . Indeed, there are two options, a) either it is orthogonal to all the vectors encoded in  </span>\\{P_{i_j}(X)\\}_{i_j \\in \\mathcal{J}}<span class="math"> , or b) it is not. The probability of b) is at most  </span>\\frac{J}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  by Schwartz-Zippel. For a), note that if  </span>\\pmb{y}^<em><span class="math">  is not orthogonal to  </span>\\mathbf{M}<span class="math"> , it can satisfy at most  </span>Q - 1<span class="math">  constraints out of  </span>Q + \\ell<span class="math"> . Since the set  </span>\\mathcal{J}<span class="math">  is chosen independently of  </span>\\pmb{y}^</em><span class="math"> , the probability that the set  </span>\\mathcal{J}<span class="math">  coincides with constraints  </span>\\pmb{m}_{i_j}<span class="math">  such that  </span>\\pmb{y} \\cdot \\pmb{m}_{i_j} = 0$  is at most:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\binom {Q - 1} {J}}{\\binom {Q + \\ell} {J}} \\leq \\left(\\frac {Q}{Q + \\ell}\\right) ^ {J}.</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">In this section we present a CSS argument that works only in the amortized setting as considered in Sonic [MBKM19]. The construction is basically the protocol in the named work, but for a bivariate polynomial in the Lagrange basis rather than the basis of monomials.</p>

    <p class="text-gray-300">In the amortized setting, the same verifier aims to check the output of different provers  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  in Sampling. The cost of the verification is linear in  <span class="math">m</span>  and thus the scheme is only recommended when the number of proofs is linear in  <span class="math">m</span>  as well. The construction is not holographic due to the fact that the verifier needs to read the matrix  <span class="math">\\mathbf{M}</span>  that describes the relation and thus the indexer is trivial.</p>

    <p class="text-gray-300">Still, in the ProveSampling algorithm, the verifier has oracle access to a set  <span class="math">\\mathcal{D} = \\{D_1(X),\\ldots ,D_t(X)\\}</span>  of polynomials where each  <span class="math">D_{s}(X)</span>  is the output of a different execution of Sampling with verifier's challenge  <span class="math">x_{s}</span> . Following the original definition, the verifier also has oracle access to the polynomials outputted by  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  (instantiated by what in Sonic is called a helper) in ProveSampling.</p>

    <p class="text-gray-300">Online Phase:  <span class="math">\\mathcal{V}_{\\mathrm{CSS}}</span>  samples  <span class="math">x_{s} \\gets \\mathbb{F}</span> .  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  defines  <span class="math">P(X,Y) = \\sum_{i=1}^{m} \\lambda_{i}(Y)P_{i}(X)</span> , for  <span class="math">P_{i}(X) = \\sum_{j=1}^{m} m_{ij}\\lambda_{j}(X)</span> . It outputs  <span class="math">D_{s}(X) = P(X,x_{s})</span> .</p>

    <p class="text-gray-300">Online Helped Phase:  <span class="math">\\mathcal{V}_{\\mathrm{CSS}}</span>  chooses  <span class="math">u_{1} \\gets \\mathbb{F}</span> .  <span class="math">\\mathcal{P}_{\\mathrm{CSS}}</span>  outputs  <span class="math">\\tilde{D}(X) = P(u_{1}, X)</span> .</p>

    <p class="text-gray-300">Decision Phase: Chooses  <span class="math">u_{2} \\gets \\mathbb{F}</span> , and calculate  <span class="math">P(u_{1}, u_{2})</span> . Accept if and only if  <span class="math">\\tilde{D}(u_{2}) = P(u_{1}, u_{2})</span>  and, for every  <span class="math">\\{x_{s}\\}_{s=1}^{t}</span> ,  <span class="math">\\tilde{D}(x_{s}) = D_{s}(u_{1})</span> .</p>

    <p class="text-gray-300">Fig. 8. Amortized CSS scheme from [MBKM19].</p>

    <p class="text-gray-300">ABLZ17. Behzad Abdolmaleki, Karim Baghery, Helger Lipmaa, and Michal Zajac. A subversion-resistant SNARK. In Tsuyoshi Takagi and Thomas Peyrin, editors, ASIACRPT 2017, Part III, volume 10626 of LNCS, pages 3-33, Hong Kong, China, December 3-7, 2017. Springer, Heidelberg, Germany. 5 AHIV17. Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2087-2104, Dallas, TX, USA, October 31 - November 2, 2017. ACM Press. 1, 5 <span class="math">\\mathrm{BBB^{+}18}</span>  . Benedikt Bunz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315-334, San Francisco, CA, USA, May 21-23, 2018. IEEE Computer Society Press. 1, 5 BBHR18. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and postquantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046, 2018. https://eprint.iacr.org/2018/046. 1, 5 BBHR19. Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 701-732, Santa Barbara, CA, USA, August 18-22, 2019. Springer, Heidelberg, Germany. 1 <span class="math">\\mathrm{BCC}^{+}16</span> . Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327-357, Vienna, Austria, May 8-12, 2016. Springer, Heidelberg, Germany. 1, 3, 5 <span class="math">\\mathrm{BCR}^{+}19</span> . Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103-128, Darmstadt, Germany, May 19-23, 2019. Springer, Heidelberg, Germany. 2, 3, 5, 10, 11 BCS16. Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31-60, Beijing, China, October 31 - November 3, 2016. Springer, Heidelberg, Germany. 4</p>

    <p class="text-gray-300">BFM88. Manuel Blum, Paul Feldman, and Silvio Micali. Non-interactive zero-knowledge and its applications (extended abstract). In 20th ACM STOC, pages 103–112, Chicago, IL, USA, May 2–4, 1988. ACM Press. 1</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706, Zagreb, Croatia, May 10–14, 2020. Springer, Heidelberg, Germany. 2</li>

      <li>BG12. Stephanie Bayer and Jens Groth. Efficient zero-knowledge argument for correctness of a shuffle. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 263–280, Cambridge, UK, April 15–19, 2012. Springer, Heidelberg, Germany. 29, 33</li>

      <li>BGG19. Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for constructing the public parameters of the pinocchio zk-SNARK. In Aviv Zohar, Ittay Eyal, Vanessa Teague, Jeremy Clark, Andrea Bracciali, Federico Pintore, and Massimiliano Sala, editors, FC 2018 Workshops, volume 10958 of LNCS, pages 64–77, Nieuwpoort, Curaçao, March 2, 2019. Springer, Heidelberg, Germany. 1</li>

      <li>BGM17. Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. http://eprint.iacr.org/2017/1050. 1</li>

      <li>CFF^{+}20. Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: a toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. Cryptology ePrint Archive, Report 2020/1069, 2020. https://eprint.iacr.org/2020/1069. 2, 3, 4, 5, 6, 7, 11, 16, 17, 31, 34</li>

      <li>CHM^{+}20. Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768, Zagreb, Croatia, May 10–14, 2020. Springer, Heidelberg, Germany. 2, 3, 4, 7, 11, 16</li>

      <li>COS20. Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793, Zagreb, Croatia, May 10–14, 2020. Springer, Heidelberg, Germany. 1</li>

      <li>DRZ20. Vanesa Daza, Carla Ràfols, and Alexandros Zacharakis. Updateable inner product argument with logarithmic verifier and applications. In Aggelos Kiayias, Markulf Kohlweiss, Petros Wallden, and Vassilis Zikas, editors, PKC 2020, Part I, volume 12110 of LNCS, pages 527–557, Edinburgh, UK, May 4–7, 2020. Springer, Heidelberg, Germany. 2</li>

      <li>FKL18. Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62, Santa Barbara, CA, USA, August 19–23, 2018. Springer, Heidelberg, Germany. 5, 9</li>

      <li>Fuc18. Georg Fuchsbauer. Subversion-zero-knowledge SNARKs. In Michel Abdalla and Ricardo Dahab, editors, PKC 2018, Part I, volume 10769 of LNCS, pages 315–347, Rio de Janeiro, Brazil, March 25–29, 2018. Springer, Heidelberg, Germany. 5</li>

      <li>Gab19. Ariel Gabizon. AuroraLight: Improved prover efficiency and SRS size in a sonic-like system. Cryptology ePrint Archive, Report 2019/601, 2019. https://eprint.iacr.org/2019/601. 2</li>

      <li>GGPR13. Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645, Athens, Greece, May 26–30, 2013. Springer, Heidelberg, Germany. 1, 11, 16</li>

      <li>GKM^{+}18. Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728, Santa Barbara, CA, USA, August 19–23, 2018. Springer, Heidelberg, Germany. 1, 2, 5</li>

      <li>GMMM18. Sanjam Garg, Mohammad Mahmoody, Daniel Masny, and Izaak Meckler. On the round complexity of OT extension. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 545–574, Santa Barbara, CA, USA, August 19–23, 2018. Springer, Heidelberg, Germany. 7</li>

      <li>GMR89. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proofs. In SIAM Journal on Computing, pages 186–208, 1989. 1</li>

      <li>Gro09. Jens Groth. Linear algebra with sub-linear zero-knowledge arguments. In Shai Halevi, editor, CRYPTO 2009, volume 5677 of LNCS, pages 192–208, Santa Barbara, CA, USA, August 16–20, 2009. Springer, Heidelberg, Germany. 3</li>

    </ul>

    <p class="text-gray-300">Gro10. Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340, Singapore, December 5–9, 2010. Springer, Heidelberg, Germany. 1</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326, Vienna, Austria, May 8–12, 2016. Springer, Heidelberg, Germany. 1</li>

      <li>GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953. 2, 3, 4, 7, 28, 35</li>

      <li>Ish20. Yuval Ishai. Zero-knowledge proofs from information theoretic proof systems. In Zkproofs Blog, https://zkproof.org/2020/08/12/information-theoretic-proof-systems/, 2020. 2</li>

      <li>JR13. Charanjit S. Jutla and Arnab Roy. Shorter quasi-adaptive NIZK proofs for linear subspaces. In Kazue Sako and Palash Sarkar, editors, ASIACRYPT 2013, Part I, volume 8269 of LNCS, pages 1–20, Bengalore, India, December 1–5, 2013. Springer, Heidelberg, Germany. 3</li>

      <li>Kil92. Joe Kilian. A note on efficient zero-knowledge proofs and arguments (extended abstract). In 24th ACM STOC, pages 723–732, Victoria, BC, Canada, May 4–6, 1992. ACM Press. 1</li>

      <li>KPV19. Assimakis Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: Transparent SNARKs from list polynomial commitment IOPs. Cryptology ePrint Archive, Report 2019/1400, 2019. https://eprint.iacr.org/2019/1400. 2</li>

      <li>KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194, Singapore, December 5–9, 2010. Springer, Heidelberg, Germany. 2, 5</li>

      <li>MBKM19. Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 11–15, 2019. 2, 3, 4, 25</li>

      <li>Mic00. Silvio Micali. The knowledge complexity of interactive proofs. In SIAM Journal on Computing 30 (4), pages 1253–1298, 2000. 1</li>

      <li>MRV16. Paz Morillo, Carla Ràfols, and Jorge Luis Villar. The kernel matrix Diffie-Hellman assumption. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part I, volume 10031 of LNCS, pages 729–758, Hanoi, Vietnam, December 4–8, 2016. Springer, Heidelberg, Germany. 13</li>

      <li>PST13. Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of correct computation. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 222–242, Tokyo, Japan, March 3–6, 2013. Springer, Heidelberg, Germany. 3, 18</li>

      <li>Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737, Santa Barbara, CA, USA, August 17–21, 2020. Springer, Heidelberg, Germany. 2, 5</li>

      <li>SZ20. Alan Szepieniec and Yuncong Zhang. Polynomial iops for linear algebra relations. Cryptology ePrint Archive, Report 2020/1022, 2020. https://eprint.iacr.org/2020/1022. 2, 4, 16</li>

      <li>WTs^{+}18. Riad S. Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walfish. Doubly-efficient zkSNARKs without trusted setup. In 2018 IEEE Symposium on Security and Privacy, pages 926–943, San Francisco, CA, USA, May 21–23, 2018. IEEE Computer Society Press. 1, 5</li>

      <li>XZZ^{+}19. Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. Libra: Succinct zero-knowledge proofs with optimal prover computation. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 733–764, Santa Barbara, CA, USA, August 18–22, 2019. Springer, Heidelberg, Germany. 1</li>

    </ul>

    <h2 id="sec-50" class="text-2xl font-bold">Appendix A A Generalized Constraint System</h2>

    <p class="text-gray-300">In this section we present a constraint system that, inspired by Plonk, generalizes R1CS and R1CS-lite as introduced in Section 2.1. We can extend our algebraic framework to this relation to build modularly a (zk)SNARK from an argument for linear relations.</p>

    <p class="text-gray-300">Consider the following universal relation, that depends on a set <span class="math">\\mathcal{M}</span> of admissible matrices:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {W - R 1 C S}} = \\left\\{ \\begin{array}{c} (\\mathsf {R}, \\mathsf {x}, \\mathsf {w}) := \\left((\\mathbb {F}, m, l, l _ {b}, \\mathbf {W}, \\boldsymbol {q} _ {M}, \\boldsymbol {q} _ {L}, \\boldsymbol {q} _ {R}, \\boldsymbol {q} _ {C}), \\boldsymbol {x}, (\\boldsymbol {a} ^ {\\prime}, \\boldsymbol {b} ^ {\\prime})\\right): \\mathbf {W} \\in \\mathcal {M} \\subset \\mathbb {F} ^ {Q \\times 3 m}, \\\\ \\boldsymbol {q} _ {\\gamma} \\in \\mathbb {F} ^ {m} \\text {f o r} \\gamma \\in \\{L, R, M, C \\}, \\boldsymbol {x} \\in \\mathbb {F} ^ {l - 1}, \\boldsymbol {a} ^ {\\prime} \\in \\mathbb {F} ^ {m - l}, \\boldsymbol {b} ^ {\\prime} \\in \\mathbb {F} ^ {m - l _ {b}} \\text {a n d f o r} \\boldsymbol {a} := (1, \\boldsymbol {x}, \\boldsymbol {a} ^ {\\prime}), \\boldsymbol {b} = (\\mathbf {1} _ {l _ {b}}, \\boldsymbol {b} ^ {\\prime}) \\\\ \\mathbf {W} \\left( \\begin{array}{c} \\boldsymbol {a} \\\\ \\boldsymbol {b} \\\\ \\boldsymbol {q} _ {M} \\circ \\boldsymbol {a} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {L} \\circ \\boldsymbol {a} + \\boldsymbol {q} _ {R} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {C} \\end{array} \\right) = \\mathbf {0} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">The relation is called  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  for weighted-R1CS. Indeed, with this arithmetization, the vector  <span class="math">\\pmb{c}</span>  of outputs is implicitly set to be a weighted combination of  <span class="math">\\pmb{a},\\pmb{b},\\pmb{a} \\circ \\pmb{b}</span>  and the constant 1.</p>

    <p class="text-gray-300">Below, we show how  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  captures some existing universal relations, for different types of admissible matrices. In Appendix B, we present a PHP for  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  that is a straightforward generalization of the one in Section 4.2 and also builds on an argument for linear relations. Such an argument can be built generically from a CSS Argument (as explained in Section 4.1), as long as the argument has compatible admissible matrices. In Appendix C, we give details on different choices of CSS schemes. Finally, in Appendix D, we expand on the compilation step and the efficiency of the resulting possible zkSNARKs. Finally, in Appendix F, we present our most efficient construction, Basilisk, rolled-out.</p>

    <p class="text-gray-300">R1CS-lite. Note that for the case where  <span class="math">l = l_{b}</span> ,  <span class="math">\\pmb{q}_{M} = \\mathbf{1}</span> ,  <span class="math">\\pmb{q}_{L} = \\pmb{q}_{R} = \\pmb{q}_{C} = \\mathbf{0}</span> , and  <span class="math">\\mathbf{W} = \\begin{pmatrix} \\mathbf{I} &amp;amp; \\mathbf{0} &amp;amp; -\\mathbf{F} \\\\ \\mathbf{0} &amp;amp; \\mathbf{I} &amp;amp; -\\mathbf{G} \\end{pmatrix}</span>  for matrices  <span class="math">\\mathbf{F}, \\mathbf{G}</span>  in  <span class="math">\\mathbb{F}^{m \\times m}</span>  containing the coefficients for the linear constraints of the circuit, the relation described above corresponds to R1CS-lite. The set of admissible matrices will depend on the CSS to be used, for instance, it should be the set of matrices  <span class="math">\\mathbf{W}</span>  of the form given above and such that  <span class="math">\\mathbf{F}, \\mathbf{G}</span>  have at most  <span class="math">K</span>  non-zero entries when the scheme of Section 5.3 is applied. We give one instantiation of a CSS scheme for such matrices in Fig. 10.</p>

    <p class="text-gray-300">Plonk's Constraint System. To see that the constraint system presented in Plonk [GWC19] is a particular case of  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span> , we first note that the former can be written the following form:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {P l o n k}} = \\left\\{ \\begin{array}{c} (\\mathsf {R}, \\mathsf {x}, \\mathsf {w}) := \\left((\\mathbb {F}, m, l, \\mathbf {P}, \\boldsymbol {q} _ {L}, \\boldsymbol {q} _ {R}, \\boldsymbol {q} _ {O}, \\boldsymbol {q} _ {M}, \\boldsymbol {q} _ {C}), \\boldsymbol {x}, (\\boldsymbol {a} ^ {\\prime}, \\boldsymbol {b}, \\boldsymbol {c})): \\mathbf {P} \\in \\mathbb {F} ^ {3 m \\times 3 m} \\text {a p e r m u t a t i o n m a t r i x ,} \\\\ \\boldsymbol {q} _ {\\gamma} \\in \\mathbb {F} ^ {m} \\text {f o r} \\gamma \\in \\{L, R, O, M, C \\}, \\boldsymbol {x} \\in \\mathbb {F} ^ {l - 1}, \\boldsymbol {a} ^ {\\prime} \\in \\mathbb {F} ^ {m - l}, \\boldsymbol {a} = (1, \\boldsymbol {x}, \\boldsymbol {a} ^ {\\prime}), \\\\ (1) \\mathbf {P} \\left( \\begin{array}{c} \\boldsymbol {a} \\\\ \\boldsymbol {b} \\\\ \\boldsymbol {c} \\end{array} \\right) = \\left( \\begin{array}{c} \\boldsymbol {a} \\\\ \\boldsymbol {b} \\\\ \\boldsymbol {c} \\end{array} \\right), \\text {a n d} (2) \\boldsymbol {q} _ {L} \\circ \\boldsymbol {a} + \\boldsymbol {q} _ {R} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {O} \\circ \\boldsymbol {c} + \\boldsymbol {q} _ {M} \\circ \\boldsymbol {a} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {C} = \\mathbf {0} \\end{array} \\right\\}.</span></div>

    <p class="text-gray-300">The first equation is a "copy constraint" approach that takes care of consistency among wires. The second equation represents the different types of gates. When writing Circuit Satisfiability as satisfiability of this constraint system,  <span class="math">m</span>  represents the number of additive and multiplicative gates.</p>

    <p class="text-gray-300">This relation is a rewriting of the one considered in Plonk. Indeed, the only difference is that we require  <span class="math">\\pmb{a}</span>  to have the public input in the first positions, instead of forcing this in Eq.(2). Still, this is only a reformulation and does not modify the constraint system itself.</p>

    <p class="text-gray-300">Now, we show that  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  can encode  <span class="math">\\mathcal{R}_{\\mathrm{Plonk}}^8</span>  when the set of admissible matrices includes  <span class="math">\\mathbf{P} - \\mathbf{I}</span> , where  <span class="math">\\mathbf{P}</span>  is a permutation and  <span class="math">\\mathbf{I}</span>  the identity matrix, and when we restrict ourselves to relations  <span class="math">\\mathsf{R}</span>  such that  <span class="math">q_{O} = -\\mathbf{1}</span> . Indeed, it suffices to define  <span class="math">\\mathbf{W} = \\mathbf{P} - \\mathbf{I}</span> , and observe that if Eq.(2) in  <span class="math">\\mathcal{R}_{\\mathrm{Plonk}}</span>  is satisfied, this means that</p>

    <div class="my-4 text-center"><span class="math-block">\\boldsymbol {q} _ {L} \\circ \\boldsymbol {a} + \\boldsymbol {q} _ {R} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {M} \\circ \\boldsymbol {a} \\circ \\boldsymbol {b} + \\boldsymbol {q} _ {C} = \\boldsymbol {c}.</span></div>

    <p class="text-gray-300">The restriction that  <span class="math">\\pmb{q}_O = -\\mathbf{1}</span>  limits the expressiveness of the constraint system, but still captures all the constraint types described in Plonk, as we argue next.</p>

    <p class="text-gray-300">First, observe that given some encoding of a relation <span class="math">\\mathsf{R}</span> as in <span class="math">\\mathcal{R}_{\\mathsf{Plonk}}</span> with vectors <span class="math">\\bm{q}_{L}^{\\prime},\\bm{q}_{R}^{\\prime},\\bm{q}_{O}^{\\prime},\\bm{q}_{M}^{\\prime},\\bm{q}_{C}^{\\prime}</span>, such that <span class="math">(q_{O}^{\\prime})_{i}\\neq 0</span> for all <span class="math">i</span>, we can rewrite the constraints for some vectors <span class="math">\\bm{q}_{L},\\bm{q}_{R},\\bm{q}_{O},\\bm{q}_{M},\\bm{q}_{C}</span> such that <span class="math">\\bm{q}_{O}=-1</span> by a normalization process. On the other hand, <span class="math">(q_{O}^{\\prime})_{i}=0</span> in Plonk only for the case where <span class="math">i</span> corresponds to public inputs or to a boolean constraint. As explained above, we enforce public input constraints separately by including them in <span class="math">\\bm{a}</span>; also, boolean constraints can be easily written enforcing <span class="math">(q_{O})_{i}=-1</span>: instead of requiring <span class="math">a_{j}=b_{j}</span>, and <span class="math">a_{j}-a_{j}b_{j}=0</span> for some <span class="math">b_{j}</span> such that <span class="math">\\sigma(a_{j})=b_{j}</span> as suggested in Plonk, they can be written as <span class="math">a_{j}=b_{j}=c_{j}</span>, <span class="math">a_{j}b_{j}-c_{j}=0</span>.</p>

    <p class="text-gray-300">As mentioned before, we present a PHP for <span class="math">\\mathcal{R}_{\\mathsf{W}\\text{-}\\mathsf{R}1\\mathsf{CS}}</span> that builds generically on an argument for linear relations. When the latter is an adaptation of the permutation argument of Bayer and Groth <em>[x1]</em>, one essentially recovers Plonk.</p>

    <p class="text-gray-300">Alternatively, we propose to construct the argument for linear relations from one CSS arguments for matrices of the form <span class="math">\\mathbf{W}=\\mathbf{P}-\\mathbf{I}</span> in Fig. 11. The approach is less efficient in terms of proof size than PLONK, but we think the additional flexibility of the CSS argument is a plus. We argue that combining this approach with the bounded fan-out approach presented next, the SRS size does not need to depend on the total number of gates (additive plus multiplicative), as it will be discussed.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Bounded fan-out.</h4>

    <p class="text-gray-300">Circuits with fan-out bounded by some constant <span class="math">V</span> can naturally be encoded as an instance of <span class="math">\\mathcal{R}_{\\mathsf{W}\\text{-}\\mathsf{R}1\\mathsf{CS}}</span> for the set <span class="math">\\mathcal{M}</span> of matrices <span class="math">\\mathbf{W}=\\begin{pmatrix}\\mathbf{I}&amp;\\mathbf{0}&amp;-\\mathbf{F}\\cr\\mathbf{0}&amp;\\mathbf{I}&amp;-\\mathbf{G}\\end{pmatrix}</span> with <span class="math">\\mathbf{F},\\mathbf{G}\\in\\mathbb{F}^{m\\times m}</span> such that there are at most <span class="math">V</span> non-zero elements per column in each. As we shall see in Fig. 12, there exists a very efficient proof system for this relation, since the structure of the matrices allows to use basic CSS arguments that cannot be used in the general case.</p>

    <p class="text-gray-300">For circuits with bounded fan-out, we can set <span class="math">l=l_{b}</span>, <span class="math">\\bm{q}_{M}=\\bm{1}</span>, <span class="math">\\bm{q}_{L}=\\bm{q}_{R}=\\bm{q}_{C}=\\bm{0}</span>. This choice also gives very short specific SRS, since these vectors do not need to be computed by the indexer. We present the rolled out zkSNARK for such matrices in Appendix F.</p>

    <p class="text-gray-300">However, we note that a more flexible choice of these values can be helpful to encode general circuits. Indeed, any circuit can be transformed to a circuit with bounded fan-out by artificially augmenting the vector <span class="math">\\bm{c}</span> and adding constraints of the form <span class="math">c_{i}=c_{j}</span> that ensure consistency. To express satisfiability of this system as an instance of <span class="math">\\mathcal{R}_{\\mathsf{W}\\text{-}\\mathsf{R}1\\mathsf{CS}}</span>, the additional constraints <span class="math">c_{i}=c_{j}</span> can rewritten as an equation involving left (or right) wires, i.e. <span class="math">a_{i}=c_{j}</span>, that is encoded in the matrix <span class="math">\\mathbf{W}</span>, and a gate, i.e. <span class="math">a_{i}=c_{i}</span> (setting <span class="math">(q_{M})_{i}=(q_{R})_{i}=(q_{C})_{i}=0</span>, <span class="math">(q_{L})_{i}=1</span>). If the fan-out of a certain gate is <span class="math">\\kappa</span>, this requires extending <span class="math">(\\bm{a},\\bm{b},\\bm{c})</span> by approximately <span class="math">3\\kappa/V</span> dummy variables, and include <span class="math">\\bm{q}_{M}</span> and <span class="math">\\bm{q}_{L}</span> in the SRS (the rest are trivial). The construction of Appendix F can be easily modified for that case and we omit further details.</p>

    <h2 id="sec-52" class="text-2xl font-bold">Appendix B A zkSNARK for <span class="math">\\mathcal{R}_{\\mathsf{W}\\text{-}\\mathsf{R}1\\mathsf{CS}}</span></h2>

    <p class="text-gray-300">Below, we present a PHP for <span class="math">\\mathcal{R}_{\\mathsf{W}\\text{-}\\mathsf{R}1\\mathsf{CS}}</span> that uses as building block a linear argument as in Section 4.1. Note that the only difference with the PHP of Fig. 2 is the set <span class="math">W_{Y}</span> and the encoding <span class="math">\\mathcal{E}_{Y}</span> that is one of the parameters of the linear argument. Given the similarity with Section 2.3, we omit the proof of Theorem 11 and refer the reader to that section.</p>

    <p class="text-gray-300">Offline Phase:  <span class="math">\\mathcal{I}_{\\mathrm{W - R1CS}}(\\mathbb{F},m,l,l_b,\\mathbf{W},\\pmb {q}_M,\\pmb {q}_L,\\pmb {q}_R,\\pmb {q}_C)</span>  parses  <span class="math">\\mathbf{W}</span>  as  <span class="math">(\\mathbf{W}_a,\\mathbf{W}_b,\\mathbf{W}_c)</span>  and runs the indexer  <span class="math">\\mathcal{I}_{\\mathrm{LA}}</span>  on input  <span class="math">(\\mathbb{F},\\mathbf{W}_a,\\mathbf{W}_b,\\mathbf{W}_c)</span>  to obtain the set  <span class="math">\\mathcal{W}_{\\mathrm{LA}} = \\mathcal{W}_{\\mathrm{LAa}}\\cup \\mathcal{W}_{\\mathrm{LAb}}\\cup \\mathcal{W}_{\\mathrm{LAc}}</span></p>

    <p class="text-gray-300">For  <span class="math">\\gamma \\in \\{L,R,M,C\\}</span> , the indexer computes polynomials  <span class="math">q_{\\gamma}(X) = q_{\\gamma}^{\\top}\\lambda(X)</span> .</p>

    <p class="text-gray-300">Outputs  <span class="math">\\mathcal{W}_{\\mathrm{W - R1CS}} = \\mathcal{W}_{\\mathrm{LA}}\\cup \\{q_L(X),q_R(X),q_M(X),q_C(X)\\}</span></p>

    <p class="text-gray-300">Online Phase:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathrm{W - R1CS}}</span>  Computes and outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} (X) = \\left(\\sum_ {j = l + 1} ^ {m} a _ {j} \\lambda_ {j} (X)\\right) / t _ {l} (X), B ^ {\\prime} (X) = \\left(\\left(\\sum_ {j = 1} ^ {m} b _ {j} \\lambda_ {j} (X)\\right) - 1\\right) / t _ {l _ {b}} (X),</span></div>

    <p class="text-gray-300">where  <span class="math">t_l(X) = \\prod_{j=1}^l (X - \\mathsf{h}_j)</span> ,  <span class="math">t_{l_b}(X) = \\prod_{j=1}^{l_b}(X - \\mathsf{h}_j)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{\\mathrm{W - R1CS}}</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{W - R1CS}}</span>  instantiate  <span class="math">\\mathcal{P}_{\\mathrm{LA}}(\\mathbb{F},\\mathbf{W},(\\pmb {a},\\pmb {b},\\pmb {q}_M\\circ \\pmb {a}\\circ \\pmb {b} + \\pmb {q}_L\\circ \\pmb {a} + \\pmb {q}_R\\circ \\pmb {b} + \\pmb {q}_C))</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{LA}}^{\\mathcal{W}_{\\mathrm{LA}}}(\\mathbb{F})</span> . Let  <span class="math">\\pmb {Y}(X) = (A(X),B(X),q_{M}(X)A(X)B(X) + q_{L}(X)A(X) + q_{R}(X)B(X) + q_{C}(X))</span>  be the polynomials  <span class="math">\\mathcal{P}_{\\mathrm{LA}}</span>  outputs in the first round.</li>

    </ul>

    <p class="text-gray-300">Decision Phase: Defines  <span class="math">C_l(X) = \\lambda_1(X) + \\sum_{j=1}^{l-1} x_j \\lambda_{j+1}(X)</span>  and accepts if and only if (1)  <span class="math">A(X) = A&#x27;(X) t_l(X) + C_l(X)</span> , (2)  <span class="math">B(X) = B&#x27;(X) t_{l_b}(X) + 1</span> , and (3)  <span class="math">\\mathcal{V}_{\\mathrm{LA}}</span>  accepts.</p>

    <p class="text-gray-300">Fig.9. PHP for the universal relation  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span> . The set of admissible matrices must coincide with the set of admissible matrices of the linear argument, which in fact depends on the admissible matrices of the CSS argument. The PHP for  <span class="math">\\mathcal{R}_{\\mathrm{LA}}</span>  should be instantiated for  <span class="math">W_{Y} = \\{(a,b,q_{M}\\circ a\\circ b + q_{L}\\circ a + q_{R}\\circ b + q_{C}):a,b\\in \\mathbb{F}^{m}\\}</span> ,  <span class="math">\\mathcal{E}(a,b,q_M\\circ a\\circ b + q_L\\circ a + q_R\\circ b + q_C) = (a^\\top \\lambda (X),b^\\top \\lambda (X),(\\pmb {q}_M^\\top \\pmb {\\lambda}(X))(\\pmb {a}^\\top \\pmb {\\lambda}(X))(\\pmb {b}^\\top \\pmb {\\lambda}(X)) + (\\pmb {q}_L^\\top \\pmb {\\lambda}(X))(\\pmb {a}^\\top \\pmb {\\lambda}(X)) + (\\pmb {q}_R^\\top \\pmb {\\lambda}(X))(\\pmb {b}^\\top \\pmb {\\lambda}(X)) + (\\pmb {q}_C^\\top \\pmb {\\lambda}(X))</span></p>

    <p class="text-gray-300">Theorem 11. When instantiated with a complete, sound and knowledge soundness linear argument, the PHP of Fig. 9 satisfies completeness, knowledge and knowledge-soundness.</p>

    <p class="text-gray-300">Adding Zero Knowledge To add zero-knowledge to the PHP of Fig. 9 we can proceed as explained in Section 4.3. For  <span class="math">i = m + 1, \\ldots, \\tilde{m}</span> , let  <span class="math">(\\pmb{q}_M)_i = 1</span> ,  <span class="math">(\\pmb{q}_L)_i = (\\pmb{q}_R)_i = (\\pmb{q}_C)_i = 0</span> , so  <span class="math">c_i = a_i b_i</span>  for these indexes, just as before. Choosing  <span class="math">\\pmb{r}_a, \\pmb{r}_b</span>  subject to  <span class="math">\\sum r_{a,i} + r_{b,i} = 0</span>  and modifying the matrix of constraints as explained there, we obtain a PHP with zero-knowledge.</p>

    <p class="text-gray-300">In this section we present several instantiations of CSS arguments for different sets of admissible matrices. Using them as a starting point, we can construct linear arguments that can be used as a building block in the PHP of Fig. 9 for different specific families of weighted R1CS relations. The final goal is to study the efficiency trade-offs that result from the different approaches. We start by describing the general approach and some general techniques that allow for better efficiency. We then describe the particular cases separately, presenting a full description of each scheme.</p>

    <p class="text-gray-300">A fundamental observation is that matrix  <span class="math">\\mathbf{W}</span>  can be seen as a matrix with three blocks  <span class="math">(\\mathbf{W}_a, \\mathbf{W}_b, \\mathbf{W}_c)</span>  and sampling in each of these blocks must be done separately, as the prover needs to receive  <span class="math">(D_a(X), D_b(X), D_c(X))</span>  to do the inner product with  <span class="math">(A(X), B(X), C(X))</span> , where  <span class="math">C(X) = q_M(X)A(X)B(X) + q_L(X)A(X) + q_R(X)B(X) + q_C(X)</span> . Naively, the polynomials  <span class="math">D_a(X), D_b(X)</span> , and  <span class="math">D_c(X)</span>  are obtained by running one CSS scheme for each matrix  <span class="math">\\mathbf{W}_a, \\mathbf{W}_b</span> , and  <span class="math">\\mathbf{W}_c</span> , but more careful approaches can save elements in communication complexity.</p>

    <p class="text-gray-300">Before we flesh out the different options of CSS arguments for  <span class="math">\\mathbf{W}</span>  we note some general principles to improve efficiency and possible trade-offs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each of the column blocks <span class="math">\\mathbf{W}_{a},\\mathbf{W}_{b},\\mathbf{W}_{c}</span> is a matrix of <span class="math">Q</span> rows, where <span class="math">Q=2m</span> or <span class="math">Q=3m</span>. One possibility is to use one of the CSS arguments described in Sections 5.2,5.3,5.4,5.5 directly for each one of these matrices of <span class="math">Q</span> rows (assuming they belong to the set of admisible matrices). Another possibility is to cut each <span class="math">\\mathbf{W}_{a},\\mathbf{W}_{b},\\mathbf{W}_{c}</span> into blocks of <span class="math">m</span> rows. For instance, this is the approach explained before for R1CS-lite, where \\[ \\mathbf{W}_{c}=\\begin{pmatrix}\\mathbf{F}\\\\</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}\\end{pmatrix} \\] and, assuming $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K<span class="math">, we implicitly use the CSS argument of Section 5.3 for the matrix </span>\\mathbf{F}+z\\mathbf{G}\\in\\mathbb{F}^{m\\times m}<span class="math">, where </span>z<span class="math"> is an element chosen by the verifier. Technically, this is in fact a CSS argument for the matrix </span>\\mathbf{W}_{c}<span class="math"> where the sampling coefficients depends also on </span>z$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When a block of size <span class="math">m\\times m</span> is trivial, that is, either <span class="math">\\mathbf{0}</span> or <span class="math">\\mathbf{I}</span>, the corresponding <span class="math">D(X)</span> is either zero or can be opened by the verifier. Indeed, when the block is <span class="math">\\mathbf{0}</span> so is the resulting polynomial, and when it is <span class="math">\\mathbf{I}\\in\\mathbb{F}^{m\\times m}</span>, we define <span class="math">P(X,Y)=\\boldsymbol{\\lambda}(Y)^{\\top}\\mathbf{I}\\lambda(X)^{\\top}=\\lambda(Y)^{\\top}\\lambda(X)</span>, and the value <span class="math">P(y,x)=\\big{(}t(x)y-xt(y)\\big{)}/(x-y)</span> can be calculated by the verifier with <span class="math">O(\\log m)</span> field operations (a proof of this can be found, for example, in Lemma 3 of Lunar <em>[CFF^{+}20]</em>). Thus, when <span class="math">\\mathbf{W}_{a},\\mathbf{W}_{b}</span> consist of trivial blocks of size <span class="math">m\\times m</span>, as in R1CS-lite, it makes sense to use the approach described in a) and cut these matrices in blocks of <span class="math">m</span> rows. The verifier can then open <span class="math">D_{a}(X),D_{b}(X)</span> itself (as they are linear combination of the polynomials corresponding to trivial blocks), so there is no need to use a CSS argument to prove correct sampling.</li>

      <li>The proofs that <span class="math">D_{a}(X),D_{b}(X),D_{c}(X)</span> are correctly sampled (in case neither of the matrices has a simple form and none of these polynomials can be sampled by the verifier) can be aggregated.</li>

    </ul>

    <p class="text-gray-300">Sparse Matrix Approach: This is the approach followed by Marlin and Lunar, and also explored in Section 5. The main idea in this line of work is to prove correct sampling in the row space of some matrix <span class="math">\\mathbf{M}</span> with no particular structure except for being sparse. The number of non-zero entries is at most <span class="math">K</span>, which is the size of some multiplicative group <span class="math">\\mathbb{K}</span> of <span class="math">\\mathbb{F}</span>. This approach was introduced in Marlin, and is pursued in Lunar and also in Section 5.3 of this work. It can be generalized to sums of sparse matrices without increasing the communication complexity, as explained in Section 5.5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Below, we give the full details of the CSS argument for R1CS-lite tweaking the techniques introduced in Section 5.3, for the case where a matrix in <span class="math">\\mathbb{F}^{Q\\times m}</span> is split into blocks of <span class="math">m</span> rows. Given that the encoding of <span class="math">\\mathbf{W}_{a}</span> and <span class="math">\\mathbf{W}_{b}</span> can be opened and checked by the verifier, we only need to run a CSS argument for <span class="math">\\mathbf{W}_{c}</span>. We assume two multiplicative subgroups, <span class="math">\\mathbb{H}</span> with size at least <span class="math">m</span> and <span class="math">\\mathbb{K}</span> with size $K\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and define </span>K_{1},K_{2}<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K_{1},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq K_{2}<span class="math"> and </span>K=K_{1}+K_{2}<span class="math">. Technically, we construct a CSS argument for the matrix </span>\\mathbf{W}_{c}<span class="math"> where the coefficients depend on </span>x,z<span class="math">. As mentioned before, this corresponds to implicitly applying the results in Section 5.3 to a matrix </span>\\mathbf{\\hat{W}_{c}}=\\mathbf{W}_{c}^{1}+z\\mathbf{W}_{c}^{2}<span class="math"> that depends on the verifier’s challenge </span>z$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{v}:\\mathbb{K}\\to\\mathbb{F}</span> be the function that maps an element <span class="math">\\mathsf{k}_{\\ell}\\in\\mathbb{K}</span> to the value of the <span class="math">\\ell</span>th non-zero element of matrix <span class="math">\\mathbf{F}</span>, if <span class="math">\\ell\\leq K_{1}</span>, and to the value of the <span class="math">(\\ell-K_{1})</span>th element of <span class="math">\\mathbf{G}</span> if <span class="math">\\ell&gt;K_{1}</span>. Define also <span class="math">\\mathsf{c},\\mathsf{r}:\\mathbb{K}\\to[m]</span> as the functions that output its row and column position in the corresponding matrix, we define <span class="math">P_{1}(X,Y)=\\sum_{\\ell=1}^{K_{1}}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(Y)\\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(X)</span> the sparse encoding of <span class="math">\\mathbf{F}</span> and <span class="math">P_{2}(X,Y)=\\sum_{\\ell=K_{1}+1}^{K_{2}}\\mathsf{v}(\\mathsf{k}_{\\ell})\\lambda_{\\mathsf{r}(\\mathsf{k}_{\\ell})}(Y)\\lambda_{\\mathsf{c}(\\mathsf{k}_{\\ell})}(X)</span> the sparse encoding of <span class="math">\\mathbf{G}</span>. Our argument implicitly constructs the sparse encoding of <span class="math">\\mathbf{F}+z\\mathbf{G}</span> as <span class="math">P(X,Y)=P_{1}(X,Y)+zP_{2}(X,Y)</span>. As explained in Section 5.1, <span class="math">P(y,x)</span> can be written as the inner product of two vectors that depend only on <span class="math">x</span> and <span class="math">y</span>, and the low degree extensions of these vectors, <span class="math">e_{x}(X),e_{y}(X)</span>, are nothing but the encodings of new matrices <span class="math">\\mathbf{M}_{x}</span> and <span class="math">\\mathbf{M}_{y}</span> in <span class="math">\\mathbb{F}^{m\\times K}</span> that have at most one non-zero element per column, so the basic CSS argument of Section 5.2 can be used to prove correctness. We present this scheme in Fig. 10.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 10. CSS Argument for  <span class="math">\\mathbf{W}_c = \\begin{pmatrix} \\mathbf{F} \\\\ \\mathbf{G} \\end{pmatrix}</span> , a matrix with at most  <span class="math">K</span>  non-zero entries.</p>

    <p class="text-gray-300">Permutation Matrix Approach: As explained before, in order to instantiate  <span class="math">\\mathcal{R}_{\\mathrm{W - R1CS}}</span>  following Plonk, we consider matrices of the form  <span class="math">\\mathbf{W} = \\mathbf{P} - \\mathbf{I}</span> , where  <span class="math">\\mathbf{P}</span>  is a matrix of permutations in  <span class="math">\\mathbb{F}^{3n\\times 3n}</span> . For simplifying notation, we define the mapping  <span class="math">\\iota : \\{1,2,3\\} \\to \\{a,b,c\\}</span>  as  <span class="math">\\iota (1) = a,\\iota (2) = b</span>  and  <span class="math">\\iota (3) = c</span> .</p>

    <p class="text-gray-300">There are several possible ways of proving correct sampling in the rows of  <span class="math">\\mathbf{P} - \\mathbf{I}</span> . For instance, we could consider  <span class="math">\\mathbf{P}</span>  as a matrix of three column blocks  <span class="math">\\mathbf{P}_a, \\mathbf{P}_b</span>  and  <span class="math">\\mathbf{P}_c</span> , and define the polynomial encoding of each block as  <span class="math">\\pmb{\\mu}(Y)^{\\top} \\mathbf{P}_{\\top} \\pmb{\\lambda}(X)</span> , where  <span class="math">\\pmb{\\mu}(X)^{\\top} = (\\mu_1(X), \\dots, \\mu_{3m}(X))</span>  are Lagrange interpolation polynomials associated to a multiplicative subgroup of size at least  <span class="math">3m</span> . However, the simplest and most efficient one, splits this matrix into 9 blocks  <span class="math">m \\times m</span> . Since all the blocks of  <span class="math">m</span>  rows of  <span class="math">\\mathbf{I} \\in \\mathbb{F}^{3m \\times 3m}</span>  are either  <span class="math">\\mathbf{0}</span>  or  <span class="math">\\mathbf{I}</span> , the verifier can open the polynomial associated to  <span class="math">\\mathbf{I} \\in \\mathbb{F}^{3m \\times 3m}</span>  on its own, and a CSS argument is necessary only to sample in the rows of  <span class="math">\\mathbf{P}</span> .</p>

    <p class="text-gray-300">For this approach, parse  <span class="math">\\mathbf{P}</span>  as  <span class="math">(\\mathbf{P}_a,\\mathbf{P}_b,\\mathbf{P}_c)</span>  and, for  <span class="math">i = 1,2,3</span> , each  <span class="math">\\mathbf{P}_{\\iota (i)}</span>  as three matrices  <span class="math">\\mathbb{F}^{m\\times m}</span>  corresponding to blocks of  <span class="math">m</span>  rows and denoted as  <span class="math">\\mathbf{P}_{\\iota (i)}^{1},\\mathbf{P}_{\\iota (i)}^{2}</span> , and  <span class="math">\\mathbf{P}_{\\iota (i)}^{3}</span> . For  <span class="math">i = 1,2,3</span> , define the function  <span class="math">\\mathsf{r}_i:\\mathbb{H}\\to [3m]</span>  that, given an element  <span class="math">\\mathsf{h}_{\\ell}\\in \\mathbb{H}</span>  outputs the row corresponding to the only non-zero element in column  <span class="math">\\ell</span>  of matrix  <span class="math">\\mathbf{P}_{\\iota (i)}</span> . For  <span class="math">k = 1,2,3</span> , the polynomial encoding of  <span class="math">\\mathbf{P}_{\\iota (i)}^{k}</span>  is  <span class="math">P_{\\iota (i)}^{k}(X,Y) = \\lambda (Y)^{\\top}\\mathbf{P}_{\\iota (i)}^{k}\\lambda (X) = \\sum_{\\ell :(k - 1)m + 1\\leq \\mathsf{r}_i(\\mathsf{h}_\\ell)\\leq km}\\lambda_{\\mathsf{r}_i(\\mathsf{h}_\\ell) - (k - 1)m}(Y)\\lambda_\\ell (X)</span> . The polynomial  <span class="math">D_{\\iota (i)}(X)</span>  is  <span class="math">P_{\\iota (i)}(X,x) = P_{\\iota (i)}^{1}(X,x) + zP_{\\iota (i)}^{2}(X,x) + z^{2}P_{\\iota (i)}^{3}(X,x)</span> . The two key elements for efficiency are: 1) the observation that each column block  <span class="math">\\mathbf{P}_{\\iota (i)}</span>  is a simple matrix, since it has at most one non-zero element per column, and 2) the fact that the proofs for each of these blocks can be batched together.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 11. CSS Argument for  <span class="math">\\mathbf{P} \\in \\mathbb{F}^{3m \\times 3m}</span> .</p>

    <p class="text-gray-300">Bounded Fan-out: Finally, we consider the case of circuits with bounded fan-out, that is, the case where the circuit can be represented with a matrix  <span class="math">\\mathbf{W} = \\begin{pmatrix} \\mathbf{I} &amp;amp; \\mathbf{0} &amp;amp; -\\mathbf{F} \\\\ \\mathbf{0} &amp;amp; \\mathbf{I} &amp;amp; -\\mathbf{G} \\end{pmatrix}</span>  that is a sum of at most  <span class="math">V</span>  simple matrices, i.e. it has at most  <span class="math">V</span>  non-zero elements per column.</p>

    <p class="text-gray-300">As before, and since the other blocks of  <span class="math">m</span>  rows are the identity matrix or the zero matrix, it suffices to use a CSS argument to sample in the image of  <span class="math">\\mathbf{W}_c = -\\left( \\begin{array}{c}\\mathbf{F}\\\\ \\mathbf{G} \\end{array} \\right)</span> . For that, we first write the matrix  <span class="math">\\mathbf{W}_c = \\sum_{i = 1}^{V}\\binom {\\mathbf{F}_i}{\\mathbf{G}_i}</span> , where each  <span class="math">\\binom{\\mathbf{F}_i}{\\mathbf{G}_i}</span>  is a simple matrix. Once more, we will implicitly construct the scheme for  <span class="math">\\hat{\\mathbf{W}} = \\mathbf{F} + z\\mathbf{G}</span> , that can be written as  <span class="math">\\sum_{i = 1}^{V}\\mathbf{F}_{i} + z\\mathbf{G}_{i}</span> , with each  <span class="math">\\mathbf{F}_i + z\\mathbf{G}_i</span>  having at most one non-zero element in each column. We define two functions associated to each  <span class="math">\\mathbf{W}_{c,i} = \\binom{\\mathbf{F}_i}{\\mathbf{G}_i}</span> . The function  <span class="math">\\mathsf{r}_i:\\mathbb{H}\\to [2m]</span>  that, given an element  <span class="math">\\mathfrak{h}_{\\ell}\\in \\mathbb{H}</span>  outputs the row corresponding to the only non-zero element in column  <span class="math">\\ell</span>  of matrix  <span class="math">\\mathbf{W}_{c,i}</span>  and the function  <span class="math">\\mathsf{v}_i:\\mathbb{H}\\to \\mathbb{F}</span>  that outputs the value of this non-zero entry. The details of the scheme are given in Fig. 12 and for simplicity in the notation, we define the sets  <span class="math">\\mathcal{V}_{\\ell}^{1} = \\{i\\in [V]:1\\leq \\mathsf{r}_{i}(\\mathsf{h}_{\\ell})\\leq m\\}</span> ,  <span class="math">\\mathcal{V}_{\\ell}^{2} = \\{i\\in [V]:m + 1\\leq \\mathsf{r}_{i}(\\mathsf{h}_{\\ell})\\leq 2m\\}</span> ,  <span class="math">S_{\\ell} = \\left\\{\\{\\mathsf{r}_{i}(\\mathsf{h}_{\\ell}):i\\in \\mathcal{V}_{\\ell}^{1}\\} \\cup \\{\\mathsf{r}_{i}(\\mathsf{h}_{\\ell}) - m:i\\in \\mathcal{V}_{\\ell}^{2}\\} \\right\\}</span>  and  <span class="math">\\hat{\\mathcal{V}}_i^1 = \\{\\ell \\in [m]:1\\leq \\mathsf{r}_i(\\mathsf{h}_\\ell)\\leq m\\}</span> ,  <span class="math">\\hat{\\mathcal{V}}_i^2 = \\{\\ell \\in [m]:m + 1\\leq \\mathsf{r}_i(\\mathsf{h}_\\ell)\\leq 2m\\}</span> .</p>

    <p class="text-gray-300">Mixing the Bounded Fan-out and the Permutation Approach. Bayer and Groth [BG12] introduce techniques to prove that a vector is a permutation of another one. This approach is useful for many applications, but for the ones discussed in this section it has the drawback that it is not easy to extend it to sums of permutations without increasing the communication complexity. This is exactly the issue in the fully succinct mode of Sonic, where complexity grows with the number of permutation matrices into which the constraint matrix can be decomposed.</p>

    <p class="text-gray-300">To counter this issue, Plonk proposes to define the permutation  <span class="math">\\mathbf{P} \\in \\mathbb{F}^{3m \\times 3m}</span> . As mentioned before, the idea is to create a vector of copy constraints. With this approach, the fan-out can be unlimited. Values that are repeated are encoded as a cycle of the permutation and the price to pay is that additive gates are no longer for free.</p>

    <p class="text-gray-300">It is worth investigating if these ideas can be mixed. Namely, since in our case we can increase the fan-out to  <span class="math">V</span>  without paying in terms of proof size, one could follow the copy constraint approach only for the wires</p>

    <p class="text-gray-300">exceeding the fan-out bound. The result would be that additive gates involving only output wires that are input of less than  <span class="math">V</span>  multiplication gates would be for free.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 12. CSS Argument for  <span class="math">\\mathbf{W}_c = \\begin{pmatrix} -\\mathbf{F} \\\\ -\\mathbf{G} \\end{pmatrix}</span> , where  <span class="math">\\mathbf{F}, \\mathbf{G}</span>  have at most  <span class="math">V</span>  non-zero elements per column. Bounded fan-out circuits can be naturally encoded in this way.</p>

    <p class="text-gray-300">Even though there are several differences in the CSS schemes presented along this work, all our constructions are compiled in a similar manner, following the compiler in  <span class="math">\\left[\\mathrm{CFF}^{+}20\\right]</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The universal SRS of the zkSNARK will be  <span class="math">\\mathsf{srs}_{\\mathsf{u}} = \\left(\\{\\tau^{i}\\}_{1}\\right)_{i = 1}^{\\rho},\\{\\tau \\}_{2}</span> , where  <span class="math">\\rho</span>  is the maximum degree among all polynomials in  <span class="math">\\mathcal{W}_{\\mathsf{CSS}}</span>  or sent by the prover.  <span class="math">\\mathsf{srs}_{\\mathbf{W}}</span>  consists of the evaluation in  <span class="math">\\tau</span>  of the polynomials that  <span class="math">\\mathcal{I}_{\\mathsf{LA}}</span>  outputs, thus,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{srs}_{\\mathbf{W}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{W}_{\\mathsf{CSS}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 4<span class="math"> , due to polynomials  </span>q_{L}(X), q_{r}(X), q_{M}(X)<span class="math">  and  </span>q_{c}(X)<span class="math"> . Still, in all schemes but the one of Fig. 11 these polynomials are zero and then the size of  </span>\\mathsf{srs}_{\\mathbf{W}}<span class="math">  is the size of  </span>\\mathcal{W}_{\\mathsf{CSS}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Prover and Verifier instantiate  <span class="math">\\mathcal{P}_{\\mathrm{W - R1CS}}</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{W - R1CS}}</span>  for the PHP of Fig. 9 that achieves zero-knowledge through the changes presented in Fig. 3, as presented below.</p>

    <p class="text-gray-300">All oracle polynomials sent by  <span class="math">\\mathcal{P}_{\\mathrm{W - R1CS}}</span>  are translated into polynomials evaluated (in the source group) at  <span class="math">\\tau</span> . For degree checks with  <span class="math">\\deg(p) &amp;lt; \\mathrm{dg}</span> ,  <span class="math">\\mathrm{dg} &amp;lt; \\rho</span> , the prover sends a single extra polynomial and field element (see Section 2.4), while checks for  <span class="math">\\mathrm{dg} = \\rho</span>  are for free.</p>

    <p class="text-gray-300">For each polynomial equation, prover sends extra field elements corresponding to evaluations (or openings) of some of the polynomials involved on it (maximum one per quadratic term, due to the procedure stated in <em>[x10]</em> attributed to M. Maller). There are several ways to do this compilation check, but to optimize efficiency the choices are quite standard (for instance, only <span class="math">A^{\\prime}(X)</span> or <span class="math">B^{\\prime}(X)</span>, should be opened).</p>

    <p class="text-gray-300">All the openings at one point, as well as the degrees of the opened polynomials, can be proven with one group element and verified with two pairings, which sets proof size (in terms of group elements) as the amount of oracles sent by <span class="math">\\mathcal{P}_{\\text{W-R1CS}}</span> plus one element for degree check of <span class="math">R_{t}(X)</span> in the linear argument and one for each polynomial equation. The number of field elements sent by the prover changes depending on the amount of terms included in the final polynomial equation as explained above, but always include one element for each polynomial commitment opening.</p>

    <p class="text-gray-300">Prover’s work includes running <span class="math">\\mathcal{P}_{\\text{W-R1CS}}</span> as well as the computation of the polynomial commitment opening procedures. Verifier work is also <span class="math">\\mathcal{V}_{\\text{W-R1CS}}</span> plus the (batched) verification procedure of the polynomial commitments. The vector of queries is <span class="math">(\\mathsf{b}_{A},\\mathsf{b}_{B},\\mathsf{b}_{R_{t}},\\mathsf{b}_{H_{t}})=(1,0,1,0)</span>.</p>

    <p class="text-gray-300">On the other hand, we write the matrix <span class="math">\\mathbf{W}</span> that expresses the constraints as:</p>

    <p class="text-gray-300">\\[ \\mathbf{W}=\\left(\\begin{array}[]{cccccc}\\mathbf{I}_{m}&\\mathbf{0}_{m\\times n}&\\mathbf{0}_{m\\times m}&\\mathbf{0}_{m\\times n}&-\\mathbf{F}&\\mathbf{0}_{m\\times n}\\\\ \\mathbf{0}_{m\\times m}&\\mathbf{0}_{m\\times n}&\\mathbf{I}_{m}&\\mathbf{0}_{m\\times n}&-\\mathbf{G}&\\mathbf{0}_{m\\times n}\\\\ \\mathbf{0}_{m}^{\\top}&\\mathbf{1}_{n}^{\\top}&\\mathbf{0}_{m}^{\\top}&\\mathbf{1}_{n}^{\\top}&\\mathbf{0}_{m\\times m}^{\\top}&\\mathbf{0}_{m\\times n}^{\\top}\\end{array}\\right)=\\left(\\begin{array}[]{ccc}\\mathbf{I}^{\\prime}&\\mathbf{0}&\\mathbf{F}^{\\prime}\\\\ \\mathbf{0}&\\mathbf{I}^{\\prime}&\\mathbf{G}^{\\prime}\\\\ \\mathbf{w}&\\mathbf{w}&\\mathbf{0}\\end{array}\\right), \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{I}^{\\prime},\\mathbf{F}^{\\prime},\\mathbf{G}^{\\prime}</span> are of size <span class="math">m\\times(m+n)</span>, <span class="math">\\mathbf{w}</span> is a row vector of length <span class="math">m+n</span>.</p>

    <p class="text-gray-300">Our PHP is built generically for any CSS argument, but concrete efficiency depends on the specifics of it and also how the blocks of rows of <span class="math">\\mathbf{W}</span> are combined. The last constraint will always be treated separately (to exploit the symmetry of the other blocks), and because of its simple form, the verifier can compute the corresponding <span class="math">\\mathbf{D}(X)=(\\sum_{i=m+1}^{m+n}\\lambda_{i}(x),\\sum_{i=m+1}^{m+n}\\lambda_{i}(x),0)</span> itself, and combine it with the rest (see Section 4.4).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the sparse matrix construction of Fig. 5, we assume that <span class="math">K\\geq 2m</span>, which sets <span class="math">\\rho=K-1</span>. This eliminates the degree checks for <span class="math">e_{x}(X),e_{y}(X),R_{u}(X)</span>. Assuming $K\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the indexer is run for a matrix </span>\\mathbf{F}+Z\\mathbf{G}<span class="math">, where </span>Z<span class="math"> is a variable and thus outputs one polynomial </span>v_{r}(X)<span class="math">, one polynomial </span>v_{1,c}(X)<span class="math"> but two polynomials </span>v_{2,c}^{F}(X),v_{2,c}^{G}(X)<span class="math"> that will let the verifier construct </span>v_{2,c}(X)=v_{2,c}^{F}(X)+zv_{2,c}^{G}(X)<span class="math"> after choosing </span>z<span class="math">, as shown in Fig.10. This set the size of the universal srs to </span>K-1<span class="math"> and the size of </span>\\mathsf{srs}_{\\mathbf{W}}<span class="math"> to 4. Prover sends 11 polynomials, 8 of degree up to </span>m-1<span class="math"> and the rest </span>(e_{x}(X),e_{y}(X),R_{u}(X),H_{u}(X))<span class="math"> of degree </span>K-1<span class="math">. Verifier performs two pairings and the field operations to compute </span>D_{a}(y),D_{b}(y),t_{l}(y),u(y)<span class="math">, and </span>t(y)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The zkSNARK that uses the CSS argument of Fig. 11 has a universal SRS of size <span class="math">n+5</span>, for <span class="math">n</span> the total number of gates of the circuit, i.e., multiplicative and additive gates as well, while the relation dependent has 11 group elements. The proof has 9 group elements (this time the prover has to send <span class="math">D_{a}(X)</span> and <span class="math">D_{b}(X)</span>) and 5 field elements (as it also sends its evaluations on challenge <span class="math">y</span>). Prover work depends only on these polynomials and consists of <span class="math">9m</span> group operations. Similar to other constructions, verifier work includes 2 pairings and <span class="math">O(l+\\log m)</span> field operations.</p>

    <p class="text-gray-300">Finally, the zkSNARK that builds on the CSS scheme of Fig. 12 (Basilisk) is given in Fig. 13: the universal SRS has size <span class="math">m+6</span>, for <span class="math">m</span> the number of multiplicative gates of the circuit, and the one describing the relation includes <span class="math">3V+1</span> group elements. The proof includes 7 group and 3 field elements. Prover work is dominated by the generation of these polynomials, and consists of <span class="math">7m</span> group operations. Verifier performs <span class="math">O(l+\\log m)</span> operations to compute <span class="math">\\sum_{i=1}^{l}x_{i}\\lambda_{i}(y)</span> from the public input <span class="math">\\bm{x}</span> and challenge <span class="math">y</span> and to evaluate <span class="math">t(x),t(y),t_{l}(y),D_{a},D_{b}</span> from its challenges <span class="math">x</span> and <span class="math">y</span>. It also does two pairings to check the final equation. As explained in Appendix B, to generalize the construction to arbitrary circuits we can add dummy variables (the exact number depends on the number of gates that exceed the fan-out bound). The SRS will grow accordingly, and the derived SRS needs to include two additional polynomials.</p>

    <p class="text-gray-300">If the extended Vandermonde technique of (Fig. 7) is used for some set of <span class="math">Q</span> rows, we set <span class="math">\\rho=2m-1</span>. <span class="math">\\mathsf{srs}_{\\mathbf{W}}</span> outputs <span class="math">Q+\\ell</span> vectors of three polynomials. Prover only sends commitments to <span class="math">A^{\\prime}(X)</span> and <span class="math">B^{\\prime}(X)</span> and the polynomials <span class="math">R_{t}(X),H_{t}(X)</span> of the linear argument (Fig.1). Verifier checks degree of <span class="math">R_{t}(X)</span> and one polynomial equation of three terms, two of which include polynomials it can evaluate itself (<span class="math">X</span> and <span class="math">t(X)</span>).</p>

    <p class="text-gray-300">E Eliminating Non-Trivial Degree Checks</p>

    <p class="text-gray-300">As explained in Appendix D, checking that a polynomial is of degree at most <span class="math">m - 1</span> is for free, as the srs includes only powers of <span class="math">\\tau</span> up to this bound. On the other hand, checks for smaller degrees require the prover to send two extra elements, one in the field and one in the group. In all our constructions such degree check is required for the linear argument, since Theorem 2 states that the degree of polynomial <span class="math">R(X)</span> has to be at most <span class="math">m - 2</span>. Also, in the CSS of Fig. 5, it must be the case that <span class="math">\\deg(R_u) \\leq m - 2</span>.</p>

    <p class="text-gray-300">Below, we present a simple corollary of Theorem 2 to augment the degree of <span class="math">R(X)</span> by 1. This trick allows to save the aforementioned elements in the proof.</p>

    <p class="text-gray-300">Corollary 1. Let <span class="math">k, m, \\mathbf{y}, \\mathbf{d}, \\mathbb{F}, \\mathbb{H}</span> be as in Theorem 2 and let <span class="math">u \\in \\mathbb{F}^*</span>, <span class="math">u \\notin \\mathbb{H}</span>. Then, <span class="math">\\mathbf{y} \\cdot \\mathbf{d} = \\sigma</span> if and only if there exist <span class="math">H(X), R(X) \\in \\mathbb{F}[X]</span>, <span class="math">R(X)</span> of degree at most <span class="math">m - 1</span>, such that the following relation holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {Y} (X) \\cdot \\mathbf {D} (X) (X - u) - \\frac {\\sigma}{m} (X - u) = X R (X) + t (X) H (X) (X - u), \\tag {5}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{Y}(X) = (Y_{1}(X),\\ldots ,Y_{k}(X))</span> is a vector of polynomials of arbitrary degree such that <span class="math">Y_{i}(\\mathsf{h}_{j}) = y_{ij}</span> for all <span class="math">i = 1,\\dots ,k</span>, <span class="math">j = 1,\\dots ,m</span>, and <span class="math">\\mathbf{D}(X) = (D_1(X),\\ldots ,D_k(X))</span> is such that <span class="math">D_{i}(X) = \\pmb{d}_{i}^{\\top}\\pmb {\\lambda}(X)</span>.</p>

    <p class="text-gray-300">Proof. By Theorem 2, <span class="math">\\pmb{y} \\cdot \\pmb{d} = \\sigma</span> if and only if there exists some <span class="math">R&#x27;(X)</span> of degree at most <span class="math">m - 2</span> such that <span class="math">\\pmb{Y}(X) \\cdot \\pmb{D}(X) - \\frac{\\sigma}{m} = X R&#x27;(X) + t(X) H(X)</span>.</p>

    <p class="text-gray-300">If <span class="math">\\pmb{y} \\cdot \\pmb{d} = \\sigma</span> then such <span class="math">R&#x27;(X)</span> exists and the polynomial <span class="math">R(X) = (X - u)R&#x27;(X)</span> is of degree at most <span class="math">m - 1</span> and satisfies Eq. (5).</p>

    <p class="text-gray-300">We now prove the reciprocal. Suppose some <span class="math">R(X)</span> of degree at most <span class="math">m - 1</span> exists such that Eq. (5) holds. Since all the sum terms in the equation, except for <span class="math">XR(X)</span> are divisible by <span class="math">X - u</span>, and <span class="math">u \\neq 0</span>, then <span class="math">(X - u)</span> divides <span class="math">R(X)</span>. Define <span class="math">R&#x27;(X) = R(X) / (X - u)</span>. Dividing Eq. (5) by <span class="math">X - u</span>, it follows that <span class="math">R&#x27;(X)</span> satisfies Eq. (2) and is of degree at most <span class="math">m - 2</span>, so by Theorem 2 it follows that <span class="math">\\pmb{y} \\cdot \\pmb{d} = \\sigma</span>.</p>

    <p class="text-gray-300">F Rolled-out zkSNARK for Circuits with Bounded Fan-Out</p>

    <p class="text-gray-300">Below we present the final zkSNARK protocol for proving some relation <span class="math">\\mathsf{R} \\in \\mathcal{R}_{\\mathrm{W - R1CS}}</span> that represents a circuit with bounded fan-out is satisfied, i.e., sets <span class="math">\\mathbf{W} = \\begin{pmatrix} \\mathbf{I} &amp;amp; \\mathbf{0} &amp;amp; -\\mathbf{F} \\\\ \\mathbf{0} &amp;amp; \\mathbf{I} &amp;amp; -\\mathbf{G} \\end{pmatrix}</span>, where <span class="math">\\mathbf{W}_c = \\begin{pmatrix} -\\mathbf{F} \\\\ -\\mathbf{G} \\end{pmatrix}</span> has at most <span class="math">V</span> nonzero elements per column. Our choice is due to the fact that this CSS scheme is the most efficient among all the presented ones. Also, circuits can be transformed into this form by adding additional dummy constraints. We present the scheme for the case where <span class="math">l = l_b</span>, <span class="math">\\pmb{q}_M = \\mathbf{1}</span>, <span class="math">\\pmb{q}_L = \\pmb{q}_R = \\pmb{q}_C = \\mathbf{0}</span> but it is straightforward to modify the argument for other values. In blue we highlight the modifications to the PHP of Fig. 9 in order to make it zero knowledge. The functions <span class="math">\\{\\mathsf{v}_i, \\mathsf{r}_i\\}_{i=1}^V</span>, <span class="math">P(X,Y)</span>, and the sets <span class="math">\\{S_\\ell, \\mathcal{V}_\\ell^1, \\mathcal{V}_\\ell^2\\}_{\\ell=1}^m</span> are defined as above. If <span class="math">\\iota(1) = a, \\iota(2) = b, \\iota(3) = c</span>, and for <span class="math">i = 1,2</span>, <span class="math">k = 1,2</span>, let <span class="math">(P&#x27;)_{i(i)}^k(X,Y) = \\pmb{\\lambda}(Y)^\\top (\\mathbf{W}_{i(i)}^1 + z_1 \\mathbf{W}_{i(i)}^2) \\pmb{\\lambda}(X)</span>, and <span class="math">(D&#x27;)_{i(i)}^k(X) = (P&#x27;)_{i(i)}^k(X,x)</span>. Note that we eliminate the non-trivial degree check as in App. E.</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">KeyGen  <span class="math">(\\mathcal{R})</span>  : Sample  <span class="math">\\tau \\gets \\mathbb{F}</span>  and output  <span class="math">\\tau, \\mathsf{srs}_{\\mathsf{w}} = \\left(\\left\\{\\left[\\tau^{i}\\right]_{1}\\right\\}_{i=0}^{m-1}, \\left\\{\\left[\\tau^{i}\\right]_{i}\\right\\}_{i=m}^{m+5}, \\left[\\tau\\right]_{2}\\right)</span> . Choose an arbitrary  <span class="math">u \\in \\mathbb{F}^*</span> ,  <span class="math">u \\notin \\mathbb{H}</span> .</p>

    <p class="text-gray-300">KeyGenD(srso, W', w'): Parse  <span class="math">\\mathbf{W}&#x27; = (\\mathbf{W}_a&#x27;, \\mathbf{W}_b&#x27;, \\mathbf{W}_c&#x27;)</span>  and  <span class="math">\\mathbf{W}_c&#x27;</span>  as  <span class="math">\\mathbf{W}_c&#x27; = \\begin{pmatrix} \\mathbf{F} &amp;amp; \\mathbf{0}_{m \\times 6} \\\\ \\mathbf{G} &amp;amp; \\mathbf{0}_{m \\times 6} \\end{pmatrix}</span> ,  <span class="math">\\mathbf{F}, \\mathbf{G} \\in \\mathbb{F}^{m \\times m}</span> . For  <span class="math">i \\in [V]</span> ,  <span class="math">k = 1, 2</span>  define  <span class="math">\\hat{R}_{\\ell}^k(Y)</span> , and its coefficients  <span class="math">\\hat{R}_{\\ell j}^k</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\hat {R} _ {\\ell} ^ {k} (Y) = \\frac {1}{m} \\sum_ {i \\in \\mathcal {V} _ {\\ell} ^ {k}} \\mathsf {v} _ {i} (\\mathsf {h} _ {\\ell}) \\mathsf {h} _ {\\mathsf {r} _ {i} (\\mathsf {h} _ {\\ell}) - (k - 1) m} \\prod_ {s \\in S _ {\\ell} - \\{t _ {i} (\\mathsf {h} _ {\\ell}) - (k - 1) m \\}} (Y - \\mathsf {h} _ {s}) = \\sum_ {j = 0} ^ {V - 1} \\hat {R} _ {\\ell j} ^ {k} Y ^ {j},</span></div>

    <p class="text-gray-300">Also, let  <span class="math">\\hat{I}_{\\ell}(Y)</span>  and  <span class="math">\\hat{I}_{\\ell j}</span>  be such that  <span class="math">\\hat{I}_{\\ell}(Y) = \\prod_{s\\in S_{\\ell}}(Y - \\mathsf{h}_s) = \\sum_{j = 0}^{V}\\hat{I}_{\\ell j}Y^j</span></p>

    <p class="text-gray-300">Finally, for  <span class="math">j = 0,\\dots ,V - 1</span>  define  <span class="math">v_{j}^{\\hat{R},1}(X) = \\sum_{\\ell = 1}^{m}\\hat{R}_{\\ell j}^{1}\\lambda_{\\ell}(X),\\qquad v_{j}^{\\hat{R},2}(X) = \\sum_{\\ell = 1}^{m}\\hat{R}_{\\ell j}^{2}\\lambda_{\\ell}(X)</span>  and, for  <span class="math">j = 0,\\ldots ,V</span> <span class="math">v_{j}^{\\hat{I}}(X) = \\sum_{\\ell = 1}^{m}\\hat{I}_{\\ell j}\\lambda_{\\ell}(X)</span>  . Compute  <span class="math">[v_j^I ]_1 = [v_j^I (\\tau)]_1,[v_j^{\\hat{R},1}]_1 = [v_j^{\\hat{R},1}(\\tau)]_1,[v_j^{\\hat{R},2}]_1 = [v_j^{\\hat{R},2}(\\tau)]_1.</span></p>

    <p class="text-gray-300">Output  <span class="math">\\mathsf{srs}_{\\mathsf{W}} = \\left(\\mathsf{srs}_{\\mathsf{w}},\\left\\{[v_j^I ]_1\\right\\}_{j = 0}^V,\\left\\{[v_j^{\\hat{R},1}]_1,[v_j^{\\hat{R},2}]_1\\right\\}_{j = 0}^{V - 1}\\right)</span></p>

    <p class="text-gray-300">Prove(W,  <span class="math">\\mathsf{srs}_{\\mathsf{W}}</span> ,  <span class="math">(\\pmb{x},(\\pmb{a}^{\\prime},\\pmb{b}^{\\prime}))</span> ): Sample  <span class="math">\\pmb{r}_a \\gets \\mathbb{F}^4</span> ,  <span class="math">\\pmb{r}_b \\gets \\mathbb{F}^2</span>  and define  <span class="math">\\pmb{a} = (\\pmb{x},\\pmb{a}^{\\prime},\\pmb{r}_a,1)</span> ,  <span class="math">\\pmb{b} = (1,\\pmb{b}^{\\prime},1,\\pmb{r}_b)</span> . Then compute  <span class="math">A(X) = \\sum_{j=1}^{m+6} a_j \\lambda_j(X)</span> ,  <span class="math">B(X) = \\sum_{j=1}^{m+6} b_j \\lambda_j(X)</span> ,  <span class="math">B&#x27;(X) = (B(X) - 1) / (t_l(X) \\prod_{i=1}^{4} (X - h_{m+i}))</span> , and</p>

    <div class="my-4 text-center"><span class="math-block">A ^ {\\prime} (X) := \\left(\\left(\\sum_ {j = l + 1} ^ {m + 6} a _ {j} \\lambda_ {j} (X)\\right) - t _ {l} (X)\\right) / \\left(t _ {l} (X) (X - \\mathsf {h} _ {m + 5}) (X - \\mathsf {h} _ {m + 6})\\right).</span></div>

    <p class="text-gray-300">Output  <span class="math">\\pi_1 = ([A&#x27;]_1 = [A&#x27;(\\tau)]_1, [B&#x27;]_1 = [B&#x27;(\\tau)]_1)</span> .</p>

    <p class="text-gray-300">Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{W}},\\pmb {x},\\pi_1)</span>  : Send  <span class="math">x,z_{1},z_{2}\\gets \\mathbb{F}</span></p>

    <p class="text-gray-300">Prove(W,  <span class="math">\\mathsf{srs}_{\\mathsf{W}}</span> ,  <span class="math">(\\pmb{x},(\\pmb{a}^{\\prime},\\pmb{b}^{\\prime}))</span> ,  <span class="math">x,z_{1},z_{2}</span> ): For  <span class="math">i = 1,2,3</span> , let  <span class="math">D_{c(i)}^{\\prime}(X) = (D^{\\prime})_{c(i)}^{1}(X) + z_{1}(D^{\\prime})_{c(i)}^{2}(X)</span> . Let  <span class="math">D_{a}(X) = D_{a}^{\\prime}(X) + z_{1}^{2}\\sum_{j=m+1}^{m+6}\\lambda_{j}(X)</span> ,  <span class="math">D_{b}(X) = D_{b}^{\\prime}(X) + z_{1}^{2}\\sum_{j=m+1}^{m+6}\\lambda_{j}(X)</span>  and  <span class="math">D_{c}(X) = D_{c}^{\\prime}(X)</span> .</p>

    <p class="text-gray-300">Find  <span class="math">R(X), H_1(X), H_2(X)</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">A (X) D _ {a} (X) (X - u) + B (X) D _ {b} (X) (X - u) - D _ {c} (X) A (X) B (X) (X - u) = X R (X) + t (X) H _ {1} (X) (X - u)</span></div>

    <p class="text-gray-300">and, if  <span class="math">\\hat{R}_x(X) = \\sum_{j=0}^{V-1} x^j \\left( v_j^{\\hat{R},1}(X) + z_1 v_j^{\\hat{R},2}(X) \\right)</span>  and  <span class="math">\\hat{I}_x(X) = \\sum_{j=0}^{V} x^j v_j^{\\hat{I}}(X)</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">D _ {c} (X) \\hat {I} _ {x} (X) = t (x) \\hat {R} _ {x} (X) + H _ {2} (X) t (X).</span></div>

    <p class="text-gray-300">Output  <span class="math">\\pi_2 = ([D_c]_1 = [D_c(\\tau)]_1</span> ,  <span class="math">[H]_1 = [H_1(\\tau)]_1 + z_2[H_2(\\tau)]_1</span> ,  <span class="math">[R]_1 = [R(\\tau)]_1</span> .</p>

    <p class="text-gray-300">Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{W}},\\pmb {x},\\pi_1,\\pi_2)</span>  : Send  <span class="math">y,\\gamma \\gets \\mathbb{F}</span></p>

    <p class="text-gray-300">Prove(W,  <span class="math">\\mathsf{srs}_{\\mathsf{W}}</span> ,  <span class="math">(\\pmb{x},(\\pmb{a}^{\\prime},\\pmb{b}^{\\prime}))</span> ,  <span class="math">x,z_{1},z_{2},y,\\gamma)</span> : Define  <span class="math">\\sigma = D_c(y)</span>  and, for</p>

    <p class="text-gray-300"><span class="math">E(X) = A(y)D_{a}(y)(y - u) + B(X)D_{b}(y)(y - u) + \\sigma \\big(-A(y)B(X)(y - u) + z_{2}\\hat{I}_{x}(X)\\big) - yR(X)</span></p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>z _ {2} t (x) \\hat {R} _ {x} (X) - t (y) H (X) (y - u),</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><span class="math">\\pmb{p}(X) = (A(X),D_c(X),E(X))</span>  , and  <span class="math">\\pmb {d} = (m - 1,m - 1,m - 1)</span>  , calculate  <span class="math">([w]_1,(a,\\sigma ,0))\\gets \\mathsf{PC}.</span>  Open  <span class="math">(\\mathsf{srs}_{\\mathsf{w}},\\pmb {p}(X),\\pmb {d},y,\\gamma)</span>  and output  <span class="math">\\pi_3 = ([w]_1,(a,\\sigma))</span></p>

    <p class="text-gray-300">Verify  <span class="math">(\\mathsf{srs}_{\\mathsf{W}},\\pmb {x},\\pi_1,\\pi_2,\\pi_3)</span>  : Define  <span class="math">s = a + \\gamma \\sigma</span>  and  <span class="math">D_{a} = D_{b} = \\big(t(x)y - xt(y)\\big) / (x - y) - \\sum_{j = m + 1}^{m + 6}\\lambda_{j}(x)\\lambda_{j}(y).</span>  Compute  <span class="math">[A]_1 = \\big([A&#x27;]_1(y - \\mathsf{h}_{m + 5})(y - \\mathsf{h}_{m + 6}) + 1\\big)t_l(y) + \\sum_{i = 1}^l x_i[\\lambda_i(\\tau)]_1,[B]_1 = \\big([B&#x27;]_1t_l(y)\\prod_{i = 1}^4 (y - \\mathsf{h}_{m + i}) + 1\\big),</span> <span class="math">[\\hat{R}_x]_1 = \\sum_{j = 0}^{V - 1}x^j\\big([v_j^{\\hat{R},1}]_1 + z_1[v_j^{\\hat{R},2}]_1\\big),</span> <span class="math">[\\hat{I}_x]_1 = \\sum_{j = 0}^{V}x^j [v_j^{\\hat{I}}]_1</span>  , and</p>

    <p class="text-gray-300"><span class="math">[p]_1 = [A]_1 + \\gamma [D_c]_1 + \\gamma^2\\big(aD_a + z_1D_b[B]_1 + \\sigma \\big(-a[B]_1(y - u) + z_2[\\hat{I}_x]_1\\big) - y[R]_1 - z_2t(x)[\\hat{R}_x]_1 - t(y)[H]_1(y - u)\\big)</span></p>

    <p class="text-gray-300">Output 1 if and only if</p>

    <div class="my-4 text-center"><span class="math-block">e \\left([ p ] _ {1} - [ s ] _ {1}, [ 1 ] _ {2}\\right) = e \\left([ w ] _ {1}, [ \\tau - y ] _ {2}\\right).</span></div>

    <p class="text-gray-300">Fig. 13. zkSNARK for circuits with bounded fan-out. Elements in blue are added to achieve zero-knowledge.</p>`;
---

<BaseLayout title="An Algebraic Framework for Universal and Updatable SNARKs (2021/590)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/590
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
