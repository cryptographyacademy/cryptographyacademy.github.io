---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/194';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'A Note on an Encryption Scheme of Kurosawa and Desmedt∗';
const AUTHORS_HTML = 'Rosario Gennaro† Victor Shoup‡';

const CONTENT = `    <p class="text-gray-300">Rosario Gennaro† Victor Shoup‡</p>

    <p class="text-gray-300">May 18, 2005</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">Abstract</h3>

    <p class="text-gray-300">Recently, Kurosawa and Desmedt presented a new hybrid encryption scheme which is secure against adaptive chosen-ciphertext attack. Their scheme is a modification of the Cramer-Shoup encryption scheme. Its major advantage with respect to Cramer-Shoup is that it saves the computation of one exponentiation and produces shorter ciphertexts. However, the proof presented by Kurosawa and Desmedt relies on the use of information-theoretic key derivation and message authentication functions.</p>

    <p class="text-gray-300">In this note we present a different proof of security which shows that the Kurosawa-Desmedt scheme can be instantiated with any computationally secure key derivation and message authentication functions, thus extending the applicability of their paradigm, and improving its efficiency.</p>

    <p class="text-gray-300">The notion of chosen-ciphertext security was introduced by Naor and Yung [6] and developed by Rackoff and Simon [7], and Dolev, Dwork, and Naor [4].</p>

    <p class="text-gray-300">In a chosen ciphertext attack, the adversary is given access to a decryption oracle that allows him to obtain the decryptions of ciphertexts of his choosing. Intuitively, security in this setting means that an adversary obtains (effectively) no information about encrypted messages, provided the corresponding ciphertexts are never submitted to the decryption oracle.</p>

    <p class="text-gray-300">As shown in [4], security against chosen-ciphertext attack is equivalent to the notion of non-malleability. An encryption scheme is said to be non-malleable if given a ciphertext c, it is infeasible to compute a ciphertext c &lt;sup&gt;0&lt;/sup&gt; whose decryption is somewhat related to the decryption of c.</p>

    <p class="text-gray-300">For these reasons, the notion of chosen-ciphertext security has emerged as the &quot;right&quot; notion of security for encryption schemes. Indeed it can be shown that in order to model encryption as a &quot;secure envelope&quot;, then the encryption scheme used must be chosen-ciphertext secure.</p>

    <p class="text-gray-300">A number of chosen ciphertext secure cryptosystems have been proposed in the literature. The first schemes were presented in [6, 7, 4], but they were quite impractical. The first</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;Original version: August 10, 2004.</p>

    <p class="text-gray-300">&lt;sup&gt;†&lt;/sup&gt; IBM T.J.Watson Research Center, Yorktown Heights, NY, USA. rosario@watson.ibm.com</p>

    <p class="text-gray-300">&lt;sup&gt;‡&lt;/sup&gt;Computer Science Dept. NYU. shoup@cs.nyu.edu</p>

    <p class="text-gray-300">truly practical cryptosystem that is provably secure against chosen ciphertext attack was discovered by Cramer and Shoup [1]. The security of this scheme is based on the hardness of the decisional Diffie-Hellman problem. In [2] Cramer and Shoup show that their original scheme is an instance of a more generic paradigm, which can be also instantiated with the Quadratic Residuosity and N-Residuosity assumptions.</p>

    <p class="text-gray-300">In [8] Shoup presents an hybrid variant of the Cramer-Shoup cryptosystem. This scheme uses the original public-key scheme to generate an encryption of a random group element κ. Then a key derivation function (KDF) is applied to κ to compute two keys k, K which are used to encrypt the actual message with a chosen-ciphertext secure symmetric encryption scheme (recalled below).</p>

    <p class="text-gray-300">Differently than in the public-key case, symmetric encryption schemes which are secure against a chosen-ciphertext attack can be easily built out of weaker primitives. It is indeed well known that all you need is a symmetric encryption scheme E which is secure against passive adversaries, and a secure message authentication code (MAC). To encrypt a message m with keys k, K it is sufficient to encrypt m with K, i.e. compute e = EK(m), and then compute a message authentication tag for e using k, i.e. compute t = MAC &lt;sup&gt;k&lt;/sup&gt;(e). The final ciphertext is (e, t). The receiver, who also holds k, K, first checks that the tag t is correct and only in that case decrypts e.</p>

    <p class="text-gray-300">Recently Kurosawa and Desmedt [5] modified the hybrid scheme presented in [8]. The advantage of their modification is that the computation of a ciphertext in their scheme requires one less exponentiation and produces shorter ciphertexts.</p>

    <p class="text-gray-300">However their proof of security relies on the use of information theoretically secure KDF and MAC functions in the symmetric step of the hybrid construction. There are several reasons why this is not desirable, among them:</p>

    <p class="text-gray-300">efficiency The proof in [5] requires the key k to be statistically close to a random key. This means that we cannot use a pseudo-random generator to derive k from a random group element encrypted during the public-key phase. This in turns implies that the public key part of the scheme must be instantiated with larger security parameters which would result in slower execution times&lt;sup&gt;1&lt;/sup&gt; ;</p>

    <p class="text-gray-300">modularity we would like to have a scheme into which we can plug any secure component and it still remains secure. It would be hard to deploy a scheme in large-scale if it can be used only in conjunction with certain types of MACs and KDFs (and in particular, with KDFs and MACs that are not used at all by the designers of standard cryptographic algorithms).</p>

    <p class="text-gray-300">In this note we show a new and different proof of security for the Kurosawa-Desmedt scheme. We show that it is indeed possible to use any secure key derivation function and message authentication code. This effectively improves the efficiency and applicability of their scheme.</p>

    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt;For typical security parameters, this increase in computation times totally offsets the gain from performing one less exponentiation, thus making the Kurosawa-Desmedt scheme as efficient as the original Cramer-Shoup</p>

    <p class="text-gray-300">In this section we recall the Kurosawa-Desmedt scheme from [5]. We describe it using generic building blocks and at the end of the section we point out where the proof of security in [5] requires information theoretic security. The scheme makes use of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">a group G of prime order q, with (random) generators  <span class="math">g_1</span>  and  <span class="math">g_2</span> . Security assumption (DDH): Hard to distinguish  <span class="math">(g_1^r, g_2^r)</span>  from  <span class="math">(g_1^r, g_2^{r&#x27;})</span> , where r is a random element of  <span class="math">\\mathbb{Z}_q</span>  and r' is a random element of  <span class="math">\\mathbb{Z}_q \\setminus \\{r\\}</span> .</p></li>
      <li><p class="text-gray-300">a message authentication code MAC, which is a function that takes two inputs, a key k and message  <span class="math">e \\in \\{0,1\\}^*</span> , and produces a &quot;tag&quot;  <span class="math">t := MAC_k(e)</span> .</p>

    <p class="text-gray-300">Security assumption: For random k, after obtaining  <span class="math">t^* := MAC_k(e^*)</span>  for (at most one) adversarially chosen  <span class="math">e^*</span> , hard to compute a forgery pair, i.e., a pair (e,t) such that  <span class="math">e \\neq e^*</span>  and  <span class="math">t = MAC_k(e)</span> .</p></li>
      <li><p class="text-gray-300">a symmetric key encryption scheme, with encryption algorithm E and decryption algorithm D, such that for key K and plaintext  <span class="math">m \\in \\{0,1\\}^*</span> ,  <span class="math">e := E_K(m)</span>  is the encryption of m under K, and for key K and ciphertext  <span class="math">e \\in \\{0,1\\}^*</span> ,  <span class="math">m := D_K(m)</span>  is the decryption of e under K.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Security assumption (semantic security): hard to distinguish  <span class="math">E_K(m_0)</span>  from  <span class="math">E_K(m_1)</span>  for randomly chosen K and adversarially chosen  <span class="math">m_0</span>  and  <span class="math">m_1</span>  (where  <span class="math">m_0</span>  and  <span class="math">m_1</span>  are of equal length).</li>
    </ul></li>
      <li><p class="text-gray-300">a key derivation function KDF, such that for v ∈ G, KDF(v) = (k, K), where k is a
message authentication key, and K is a symmetric encryption key.
Security assumption: hard to distinguish KDF(v) from (k, K), where v, k and K are
random.</p></li>
      <li><p class="text-gray-300">a hash function  <span class="math">H: G \\times G \\to \\mathbb{Z}_q</span> . Security assumption (target collision resistance): given  <span class="math">u_1^* := g_1^r</span>  and  <span class="math">u_2^* := g_2^r</span> , for random  <span class="math">r \\in \\mathbb{Z}_q</span> , hard to find  <span class="math">(u_1, u_2) \\in G \\times G \\setminus \\{(u_1^*, u_2^*)\\}</span>  such that  <span class="math">H(u_1, u_2) = H(u_1^*, u_2^*)</span> .</p></li>
    </ul>

    <p class="text-gray-300">Note that the key space for the message authentication code is assumed to consist of all bit strings of a given length, so that by a random key k, we mean a random bit string of appropriate length. Similarly for the symmetric encryption keys.</p>

    <p class="text-gray-300">Note also that <em>KDF</em> and <em>H</em> may have associated keys (which are publicly known).</p>

    <p class="text-gray-300"><strong>Key Generation:</strong> The description of the group G is generated, along with random generators  <span class="math">g_1</span>  and  <span class="math">g_2</span>  for G. Any keys for KDF and H are also generated. Then:</p>

    <p class="text-gray-300"><span class="math">$x_1, x_2, y_1, y_2 \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q, \\ c \\leftarrow g_1^{x_1} g_2^{x_2}, \\ d \\leftarrow g_1^{y_1} g_2^{y_2}.</span>$</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;Since we are defining MAC as a function there is only one possible output for any input pair k, e. It is possible to define message authentication codes as two algorithms: a &quot;tagging&quot; and a &quot;verifying&quot; algorithm. The tagging algorithm could be randomized and thus one of several tags could be computed on the same input pair. The security property then would be that it is hard to compute any valid message/tag pair (e, t) other than  <span class="math">(e^*, t^*)</span> .</p>

    <p class="text-gray-300">The public key consists of the description of G, the generators  <span class="math">g_1</span>  and  <span class="math">g_2</span> , keys for KDF and H (if any), along with the group elements c and d. The private key consists of the public key, along with  <span class="math">x_1, x_2, y_1, y_2</span> .</p>

    <p class="text-gray-300">Encryption of  <span class="math">m \\in \\{0,1\\}^*</span> :</p>

    <pre><code class="language-text">r \\stackrel{\\notin}{\\leftarrow} \\mathbb{Z}_q, \\ u_1 \\leftarrow g_1^r \\in G, \\ u_2 \\leftarrow g_2^r \\in G, \\ \\alpha \\leftarrow H(u_1, u_2) \\in \\mathbb{Z}_q
v \\leftarrow c^r d^{r\\alpha} \\in G, \\ (k, K) \\leftarrow KDF(v), \\ e \\leftarrow E_K(m), \\ t \\leftarrow MAC_k(e)
output C := (u_1, u_2, e, t)
</code></pre>

    <p class="text-gray-300"><strong>Decryption of</strong>  <span class="math">C = (u_1, u_2, e, t)</span> :</p>

    <pre><code class="language-text">\\begin{aligned} &amp;\\alpha \\leftarrow H(u_1,u_2) \\in \\mathbb{Z}_q, \\ v \\leftarrow u_1^{x_1+y_1\\alpha}u_2^{x_2+y_2\\alpha} \\in G, \\ (k,K) \\leftarrow \\mathit{KDF}(v) \\\\ &amp;\\text{if } t \\neq \\mathit{MAC}_k(e) \\ \\text{then} \\\\ &amp;\\text{output &quot;reject&quot;} \\\\ &amp;\\text{else} \\\\ &amp;m \\leftarrow D_K(e) \\\\ &amp;\\text{output } m \\end{aligned}
</code></pre>

    <p class="text-gray-300">In addition to the above computational security assumption, the proof of security in [5] requires the following <em>information theoretic</em> assumptions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>information-theoretically secure KDF. If  <span class="math">v \\in G</span>  is random, then at least the first component k of the output of KDF(v) should be (statistically close to) uniform.</li>
      <li>information-theoretically secure MAC. For all e and t, if k is chosen at random, then  <span class="math">\\Pr[MAC_k(e) = t]</span>  is negligible.</li>
    </ul>

    <p class="text-gray-300">Our proof of security, described in the next section, does <em>not</em> need these assumptions.</p>

    <p class="text-gray-300">Kurosawa and Desmedt apparently introduce these assumptions to avoid a potential circularity in their proof. Both their proof and ours use a &quot;hybrid argument,&quot; whereby the initial attack game is transformed in a sequence of small steps into a game in which the adversary's advantage is clearly negligible. At one point in their proof, in order to justify one of the steps in this sequence, they want to prove that the decryption oracle will reject certain ciphertexts; to prove this, they must first prove that certain MAC keys are randomly distributed and that certain tag values are unpredictable; to draw this conclusion, they must first prove that the above-mentioned ciphertexts are rejected. As it happens, the way out of this circularity chosen by Kurosawa and Desmedt is to introduce informationtheoretic security assumptions. However, we show how to avoid this using a technique that is perhaps not so well appreciated, which we might call &quot;deferred analysis.&quot; We will point out below in the proof where this technique is employed. This technique has also been used before — for example, in [3], it is used in the proof of security of a version of the Cramer-Shoup encryption scheme that makes use of a universal one-way hash function (rather than a collision-resistant hash function). The original security proof in [1] was actually a bit incomplete regarding this issue.</p>

    <p class="text-gray-300">In Appendix A we recall the Cramer-Shoup hybrid scheme from [8] and compare the two schemes. In particular we point out how for typical security parameters the gains posted by the Kurosawa-Desmedt scheme may be offset by the requirement that KDF and MAC be information theoretically secure.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">Game 0</h3>

    <p class="text-gray-300">We now define a game, called  <span class="math">Game\\ \\theta</span> , which is an interactive computation between an adversary and a simulator. This game is simply the usual game used to define CCA security, in which the simulator provides the adversary's environment.</p>

    <p class="text-gray-300">Initially, the simulator runs the key generation algorithm, obtaining the description of G, generators  <span class="math">g_1</span>  and  <span class="math">g_2</span> , keys for KDF and H (if any), along with the values  <span class="math">x_1, x_2, y_1, y_2 \\in \\mathbb{Z}_q</span>  and  <span class="math">c, d \\in G</span> . The simulator gives the public key to the adversary.</p>

    <p class="text-gray-300">During the execution of the game, the adversary makes a number of &quot;decryption requests.&quot; Assume these requests are  <span class="math">C^{(1)}, \\ldots, C^{(Q)}</span> , where</p>

    <p class="text-gray-300"><span class="math">$C^{(i)} = (u_1^{(i)}, u_2^{(i)}, e^{(i)}, t^{(i)}).</span>$</p>

    <p class="text-gray-300">For each such request, the simulator decrypts the given ciphertext, and gives the adversary the result. We denote by  <span class="math">\\alpha^{(i)}</span> ,  <span class="math">v^{(i)}</span> ,  <span class="math">k^{(i)}</span> , and  <span class="math">K^{(i)}</span>  the corresponding intermediate quantities computed by the decryption algorithm on input  <span class="math">C^{(i)}</span> .</p>

    <p class="text-gray-300">The adversary may also make a single &quot;challenge request.&quot; For such a request, the adversary submits two messages  <span class="math">m_0, m_1</span> , which are bit strings of equal length, to the simulator; the simulator chooses  <span class="math">b \\in \\{0, 1\\}</span>  at random, and encrypts  <span class="math">m_b</span> , obtaining the &quot;target ciphertext&quot;  <span class="math">C^* = (u_1^*, u_2^*, e^*, t^*)</span> . The simulator gives  <span class="math">C^*</span>  to the adversary. We denote by  <span class="math">r^*</span> ,  <span class="math">\\alpha^*</span> ,  <span class="math">v^*</span> ,  <span class="math">k^*</span> , and  <span class="math">K^*</span>  the corresponding intermediate quantities computed by the encryption algorithm.</p>

    <p class="text-gray-300">The only restriction on the adversary's requests is that after it makes a challenge request, subsequent decryption requests must not be the same as the target ciphertext.</p>

    <p class="text-gray-300">At the end of the game, the adversary outputs  <span class="math">\\hat{b} \\in \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">Let  <span class="math">X_0</span>  be the event that  <span class="math">\\hat{b} = b</span> . Security means that  <span class="math">|\\Pr[X_0] - 1/2|</span>  should be negligible.</p>

    <p class="text-gray-300">We prove this by considering other games,  <span class="math">Game\\ 1</span> ,  <span class="math">Game\\ 2</span> , etc. These games will be quite similar to Game 0 in their overall structure, and will only differ from Game 0 in terms of how the simulator works. However, in each game, there will be well defined bits  <span class="math">\\hat{b}</span>  and b, so that in Game i, we always define  <span class="math">X_i</span>  to the event that  <span class="math">\\hat{b} = b</span>  in that game. All of these games should be viewed as operating on the same underlying probability space.</p>

    <p class="text-gray-300">Before moving on, we make a couple of additional assumptions about the internal structure of Game 0 that will be convenient down the road. First, we assume that  <span class="math">g_2</span>  is computed as:</p>

    <p class="text-gray-300"><span class="math">$w \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_q^*, \\ g_2 \\leftarrow g_1^w.</span>$</p>

    <p class="text-gray-300">Note that the value of w is never explicitly used in Game 0, except to compute  <span class="math">g_2</span> . Second, we assume that the quantities  <span class="math">r^*</span> ,  <span class="math">u_1^*</span> ,  <span class="math">u_2^*</span> ,  <span class="math">\\alpha^*</span> ,  <span class="math">v^*</span> ,  <span class="math">k^*</span> , and  <span class="math">K^*</span>  are computed at the very start of the game (they do not depend on the values  <span class="math">m_0</span> ,  <span class="math">m_1</span>  provided later by the adversary, so this can be done).</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Game 1</h4>

    <p class="text-gray-300">Game 1 is the same as Game 0, except that if the adversary ever submits  <span class="math">C^{(i)}</span>  for decryption with</p>

    <p class="text-gray-300"><span class="math">$(u_1^{(i)}, u_2^{(i)}) \\neq (u_1^*, u_2^*)</span>$
and  <span class="math">\\alpha^{(i)} = \\alpha^*</span> ,</p>

    <p class="text-gray-300">the simulator rejects the given ciphertext.</p>

    <p class="text-gray-300">In Game 1, the simulator may reject ciphertexts that would not have been rejected in Game 0. Let us call Rejection Rule 0 the rule by which ciphertexts are rejected as in the ordinary decryption algorithm (i.e., the message authentication tags do not match). Let us call Rejection Rule 1 this new rejection rule, introduced in Game 1.</p>

    <p class="text-gray-300">Let F&lt;sup&gt;1&lt;/sup&gt; be the event that the simulator applies Rejection Rule 1 in Game 1 to a ciphertext to which Rejection Rule 0 does not apply. Game 0 and Game 1 proceed identically until the this event occurs; in particular, the events X&lt;sup&gt;0&lt;/sup&gt; ∧ ¬F&lt;sup&gt;1&lt;/sup&gt; and X&lt;sup&gt;1&lt;/sup&gt; ∧ ¬F&lt;sup&gt;1&lt;/sup&gt; are the same (recall that we view all games to operate on the same underlying probability space); therefore,</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_0] - \\Pr[X_1]| \\le \\Pr[F_1]. \\tag{1}</span>$</p>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_1] = \\epsilon_{\\text{tcr}},\\tag{2}</span>$</p>

    <p class="text-gray-300">where tcr is the success probability that one can find a collision in H using resources similar to those of the given adversary. By assumption, tcr is negligible.</p>

    <p class="text-gray-300">Game 2 is the same as Game 1, except that the simulator computes v &lt;sup&gt;∗&lt;/sup&gt; as</p>

    <p class="text-gray-300"><span class="math">$v^* \\leftarrow (u_1^*)^{x_1 + y_1 \\alpha^*} (u_2^*)^{x_2 + y_2 \\alpha^*}.</span>$</p>

    <p class="text-gray-300">This change is purely conceptual, since v &lt;sup&gt;∗&lt;/sup&gt; has the same value either way. In particular,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[X_1] = \\Pr[X_2]. \\tag{3}</span>$</p>

    <p class="text-gray-300">Now generate u ∗ &lt;sup&gt;2&lt;/sup&gt; by the rule</p>

    <p class="text-gray-300"><span class="math">$r&#x27; \\stackrel{\\&amp;}{\\leftarrow} \\mathbb{Z}_q \\setminus \\{r^*\\}, \\ u_2^* \\leftarrow g_2^{r&#x27;}.</span>$</p>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_2] - \\Pr[X_3]| = \\epsilon_{\\text{ddh}}, \\tag{4}</span>$</p>

    <p class="text-gray-300">where ddh is the advantage with which one can solve the DDH problem, using resources similar to those of the given adversary. By assumption, ddh is negligible.</p>

    <p class="text-gray-300">The details. We can easily build a &quot;hybrid&quot; Game 2/3 that takes τ := (g1, g2, u&lt;sup&gt;∗&lt;/sup&gt; 1 , u&lt;sup&gt;∗&lt;/sup&gt; 2 ) as input, so that if τ is a random DH-tuple, Game 2/3 acts just like Game 2, and if τ is a random non-DH-tuple, then Game 2/3 acts just like Game 3. The distinguishing algorithm runs Game 2/3 on input τ , and outputs 1 if ˆb = b, and outputs 0 otherwise. The distinguishing advantage of this algorithm is exactly equal to |Pr[X2] − Pr[X3]|.</p>

    <h2 id="sec-4" class="text-2xl font-bold">Game 4</h2>

    <p class="text-gray-300">In this game, the simulator makes use of the value  <span class="math">w \\in \\mathbb{Z}_q</span> , where  <span class="math">g_2 = g_1^w</span> . The simulator did not need to make explicit use of this value in previous games. Indeed, we could not have used the DDH assumption if the simulator had to use w. However, we are now finished with the DDH assumption, and so the simulator is free to make use of w in this and subsequent games.</p>

    <p class="text-gray-300">Game 4 is the same as Game 3, except that we introduce a new Rejection Rule 2: in responding to decryption requests, the simulator rejects any ciphertext  <span class="math">C^{(i)}</span>  such that</p>

    <p class="text-gray-300"><span class="math">$(u_1^{(i)}, u_2^{(i)}) \\neq (u_1^*, u_2^*)</span>$
and  <span class="math">(u_1^{(i)})^w \\neq u_2^{(i)}</span> .</p>

    <p class="text-gray-300">Note that the condition  <span class="math">(u_1^{(i)})^w \\neq u_2^{(i)}</span>  is equivalent to  <span class="math">\\log_{g_1} u_1^{(i)} \\neq \\log_{g_2} u_2^{(i)}</span> .</p>

    <p class="text-gray-300">Define  <span class="math">F_4</span>  to be the event that a ciphertext is rejected during Game 4 using Rejection Rule 2 to which Rejection Rules 0 and 1 are not applicable.</p>

    <p class="text-gray-300">Clearly, Game 3 and Game 4 proceed identically until  <span class="math">F_4</span>  occurs; in particular, the events  <span class="math">X_3 \\wedge \\neg F_4</span>  and  <span class="math">X_4 \\wedge \\neg F_4</span>  are the same, and so</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_3] - \\Pr[X_4]| \\le \\Pr[F_4]. \\tag{5}</span>$</p>

    <p class="text-gray-300">We want to show that  <span class="math">Pr[F_4]</span>  is negligible; however, we postpone this until later. This is the &quot;deferred analysis&quot; technique: instead of attempting to bound  <span class="math">Pr[F_4]</span>  right now, we shall patiently wait until a later game, where it will be much easier. However, at this point we augment Game 4 just slightly, utilizing the well-known &quot;plug and pray&quot; technique: the simulator chooses  <span class="math">j \\in \\{1, \\ldots, Q\\}</span>  at random, and we define  <span class="math">F&#x27;_4</span>  to be the event that in Game 4, Rejection Rules 0 and 1 do not apply to  <span class="math">C^{(j)}</span> , but Rejection Rule 2 does apply to  <span class="math">C^{(j)}</span> . Clearly,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_4] \\le Q \\Pr[F_4&#x27;],\\tag{6}</span>$</p>

    <p class="text-gray-300">and so it suffices to show that  <span class="math">\\Pr[F_A&#x27;]</span>  is negligible.</p>

    <p class="text-gray-300">It will be helpful to write down in detail how Game 4 works, starting from scratch:</p>

    <p class="text-gray-300">• The simulator begins by generating the description of G, along with a random generator  <span class="math">g_1</span> , and any keys for KDF and H. It then computes:</p>

    <p class="text-gray-300"><strong>I1:</strong>
<span class="math">$w \\stackrel{\\ensuremath{\\leftarrow}}{\\leftarrow} \\mathbb{Z}_q^*, \\ g_2 \\leftarrow g_1^w</span>$</p>

    <p class="text-gray-300"><strong>12:</strong>
<span class="math">$x_1, x_2, y_1, y_2 \\stackrel{\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\</span>$</p>

    <p class="text-gray-300">12:
<span class="math">$x_1, x_2, y_1, y_2 \\leftarrow \\mathbb{Z}_q, \\ c \\leftarrow g_1^{s_1} g_2^{s_2}, \\ d \\leftarrow g_1^{s_1} g_2^{s_2}</span>$
13:  <span class="math">r^* \\leftarrow \\mathbb{Z}_q, \\ r&#x27; \\leftarrow \\mathbb{Z}_q \\setminus \\{r^*\\}, \\ u_1^* \\leftarrow g_1^{r^*}, \\ u_2^* \\leftarrow g_1^{wr&#x27;}, \\ \\alpha^* \\leftarrow H(u_1^*, u_2^*)</span>
14:  <span class="math">v^* \\leftarrow (u_1^*)^{x_1 + y_1 \\alpha^*} (u_2^*)^{x_2 + y_2 \\alpha^*}</span></p>

    <p class="text-gray-300"><strong>I4:</strong>
<span class="math">$v^* \\leftarrow (u_1^*)^{x_1+y_1\\alpha^*}(u_2^*)^{x_2+y_2\\alpha}</span>$</p>

    <p class="text-gray-300"><strong>I5:</strong>
<span class="math">$(k^*, K^*) \\leftarrow KDF(v^*)</span>$</p>

    <p class="text-gray-300"><strong>I6:</strong>
<span class="math">$j \\leftarrow \\{1, ..., Q\\}</span>$</p>

    <p class="text-gray-300">The simulator gives the description of G, the generators  <span class="math">g_1</span>  and  <span class="math">g_2</span> , keys for KDF and H (if any), along with c and d to the adversary.</p>

    <p class="text-gray-300">• In processing a decryption request  <span class="math">C^{(i)} = (u_1^{(i)}, u_2^{(i)}, e^{(i)}, t^{(i)})</span> , the simulator proceeds as follows:</p>

    <pre><code class="language-text">D01: \\alpha^{(i)} \\leftarrow H(u_1^{(i)}, u_2^{(i)})
              if (u_1^{(i)}, u_2^{(i)}) \\neq (u_1^*, u_2^*) and \\alpha^{(i)} = \\alpha^* then return &quot;reject&quot;
D03:
              else if (u_1^{(i)}, u_2^{(i)}) = (u_1^*, u_2^*) then
D04:
                         if t^{(i)} \\neq MAC_{k^*}(e^{(i)}) then return &quot;reject&quot;
D05:
                         return D_{K^*}(e^{(i)})
D06:
              else if (u_1^{(i)})^w \\neq u_2^{(i)} then
v^{(i)} \\leftarrow (u_1^{(i)})^{x_1+y_1\\alpha^{(i)}} (u_2^{(i)})^{x_2+y_2\\alpha^{(i)}}
(k^{(i)}, K^{(i)}) \\leftarrow KDF(v^{(i)})
D07:
D08:
D09:
                         if t^{(i)} \\neq MAC_{k^{(i)}}(e^{(i)}) then return &quot;reject&quot;
D10:
D11:
                          return &quot;reject&quot;
D12:
              else
                         \\begin{array}{l} v^{(i)} \\leftarrow (u_1^{(i)})^{x_1 + y_1 \\alpha^{(i)}} (u_2^{(i)})^{x_2 + y_2 \\alpha^{(i)}} \\\\ (k^{(i)}, K^{(i)}) \\leftarrow \\mathit{KDF}(v^{(i)}) \\end{array}
D13:
D14:
                         if t^{(i)} \\neq MAC_{k^{(i)}}(e^{(i)}) then return &quot;reject&quot;
D15:
                         return D_{K(i)}(e^{(i)})
D16:
</code></pre>

    <p class="text-gray-300">Note that Rejection Rule 0 is applied at lines <strong>D05</strong>, <strong>D10</strong>, and <strong>D15</strong>, while Rejection Rule 1 is applied at line <strong>D03</strong>, and Rejection Rule 2 (and no other Rejection Rule) at line <strong>D11</strong>.</p>

    <p class="text-gray-300">• In processing the challenge request, the adversary gives  <span class="math">m_0, m_1</span>  to the simulator. The simulator computes</p>

    <p class="text-gray-300"><span class="math">$b \\stackrel{\\leftarrow}{\\leftarrow} \\{0,1\\}, e^* \\leftarrow E_{K^*}(m_b), t^* \\leftarrow MAC_{k^*}(e^*),</span>$</p>

    <p class="text-gray-300">and gives  <span class="math">C^* := (u_1^*, u_2^*, e^*, t^*)</span>  to the adversary.</p>

    <p class="text-gray-300">We have written the logic of the decryption oracle in this particular way to facilitate further analysis. Note that the computations at  <span class="math">\\mathbf{D08}</span> - <span class="math">\\mathbf{D10}</span>  have no real effect, other than to determine if the event  <span class="math">F&#x27;_4</span>  occurs; indeed, once line  <span class="math">\\mathbf{D08}</span>  is reached, the ciphertext is sure to be rejected, either at line  <span class="math">\\mathbf{D10}</span>  or at line  <span class="math">\\mathbf{D11}</span> . The event  <span class="math">F&#x27;_4</span>  is simply the event that line  <span class="math">\\mathbf{D11}</span>  executes in the jth decryption request.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Game 5</h4>

    <p class="text-gray-300">Game 5 is the same as Game 4, except that we change lines <strong>I2</strong> and <strong>I4</strong>, as follows:</p>

    <p class="text-gray-300"><strong>I2:</strong>
<span class="math">$x, y \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q, \\ c \\leftarrow g_1^x, \\ d \\leftarrow g_1^y</span>$</p>

    <p class="text-gray-300"><strong>I4:</strong>  <span class="math">v^* \\stackrel{\\phi}{\\leftarrow} G</span></p>

    <p class="text-gray-300">as well as lines D08 and D13, as follows:</p>

    <p class="text-gray-300"><strong>D08:</strong>
<span class="math">$v^{(i)} \\stackrel{\\mbox{\\tiny </span>\\phi<span class="math">}}{\\leftarrow} G</span>$</p>

    <p class="text-gray-300"><strong>D13:</strong>  <span class="math">v^{(i)} \\leftarrow (u_1^{(i)})^{x+y\\alpha^{(i)}}</span></p>

    <p class="text-gray-300">Note that  <span class="math">x_1, x_2, y_1, y_2</span>  are not used at all in Game 5.</p>

    <p class="text-gray-300">We define  <span class="math">F&#x27;_5</span>  to be the event that line <strong>D11</strong> is executed in the <em>j</em>th decryption request in Game 5. We claim that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[X_4] = \\Pr[X_5] \\tag{7}</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_4&#x27;] = \\Pr[F_5&#x27;]. \\tag{8}</span>$</p>

    <p class="text-gray-300">This follows from a simple linear algebra argument, along the same lines as in [1]. The point is, we are simply swapping one set of 4-wise independent random variables for another; indeed, in both games, the variables c, d,  <span class="math">v^*</span> , and  <span class="math">v^{(j)}</span>  (as computed at line <strong>D08</strong>) are mutually independent and uniformly distributed over G.</p>

    <p class="text-gray-300">Now our sequence of games reaches a fork in the road. Games 6 and 7 below (the &quot;left fork&quot;) are used to show that  <span class="math">\\Pr[X_5]</span>  is close to 1/2. Then we define Game 6′ (the &quot;right fork&quot;), which is another modification of Game 5, to show that  <span class="math">\\Pr[F_5]</span>  is small.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Game 6</h4>

    <p class="text-gray-300">Game 6 is the same as Game 5, except that we change line I5, as follows:</p>

    <p class="text-gray-300"><strong>I5:</strong>
<span class="math">$(k^*, K^*) \\stackrel{\\phi}{\\leftarrow}</span>$
&quot;keys&quot;</p>

    <p class="text-gray-300">That is, we simply generate the keys  <span class="math">k^*</span>  and  <span class="math">K^*</span>  at random.</p>

    <p class="text-gray-300">Observe that in Game 5,  <span class="math">v^*</span>  is completely random, and is not used anywhere, except once as an input to KDF. Based on this, it is easy to see that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_5] - \\Pr[X_6]| = \\epsilon_{\\text{kdf}},\\tag{9}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{kdf}</span>  is the advantage with which one can distinguish the output of the KDF from a random key pair, using resources similar to those of the given adversary. By assumption,  <span class="math">\\epsilon_{kdf}</span>  is negligible.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">Game 7</h3>

    <p class="text-gray-300">Game 7 is the same as Game 6, except that we change line <strong>D06</strong>, as follows:</p>

    <p class="text-gray-300"><strong>D06:</strong> return &quot;reject&quot;</p>

    <p class="text-gray-300">Let  <span class="math">F_7</span>  be the event that line <strong>D06</strong> is ever executed in Game 7, in any decryption request. Clearly, Game 6 and Game 7 proceed identically until  <span class="math">F_7</span>  occurs; in particular, the events  <span class="math">X_6 \\wedge \\neg F_7</span>  and  <span class="math">X_7 \\wedge \\neg F_7</span>  are the same, and so</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_6] - \\Pr[X_7]| \\le \\Pr[F_7]. \\tag{10}</span>$</p>

    <p class="text-gray-300">Moreover, if  <span class="math">F_7</span>  occurs the adversary has effectively broken the message authentication code keyed by  <span class="math">k^*</span>  (which in Game 7 is truly random). More precisely,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_7] \\le Q\\epsilon_{\\max},\\tag{11}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{\\text{mac}}</span>  is the advantage with which one can break the message authentication code using resources similar to those of the given adversary. By assumption,  <span class="math">\\epsilon_{\\text{mac}}</span>  is negligible. The factor of Q in (11) comes from a standard &quot;plug and pray&quot; argument: the forging algorithm has to choose one of the pairs  <span class="math">(e^{(i)}, t^{(i)})</span>  at random, and hope that it is actually a forgery pair.</p>

    <p class="text-gray-300">Also, observe that the key  <span class="math">K^*</span>  in Game 7 is truly random and is used for no other purpose that to encrypt  <span class="math">m_b</span> . Based on this, it is easy to see that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_7] - 1/2| = \\epsilon_{\\text{enc}},\\tag{12}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon_{\\rm enc}</span>  is the probability of breaking the semantic security of the underlying symmetric key encryption scheme, using resources similar to those of the given adversary. By assumption,  <span class="math">\\epsilon_{\\rm enc}</span>  is negligible.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">Game 6'</h3>

    <p class="text-gray-300">We now backtrack to the fork in the road. Game 6' is the same as Game 5, except that we change line <strong>D09</strong>, as follows:</p>

    <p class="text-gray-300"><strong>D09:</strong>
<span class="math">$(k^{(i)}, K^{(i)}) \\leftarrow</span>$
&quot;keys&quot;</p>

    <p class="text-gray-300">Define  <span class="math">F&#x27;_{6&#x27;}</span>  to be the event that line <strong>D11</strong> is executed in the <em>j</em>th decryption request in Game 6'. Observe that at line <strong>D08</strong> in Game 5, the value  <span class="math">v^{(j)}</span>  is completely random, and is not used anywhere, except once as an input to KDF. Based on this, it is easy to see that</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[F_5&#x27;] - \\Pr[F_{6&#x27;}&#x27;]| = \\epsilon_{\\text{kdf}}&#x27;, \\tag{13}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon&#x27;_{kdf}</span>  is the advantage with which one can distinguish the output of the KDF from a random key pair, using resources similar to those of the given adversary. By assumption,  <span class="math">\\epsilon&#x27;_{kdf}</span>  is negligible.</p>

    <p class="text-gray-300">Observe that in Game 6', the key  <span class="math">k^{(j)}</span>  used in the message authentication code at line <strong>D10</strong> is completely random. From this, it easily follows that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F&#x27;_{6&#x27;}] \\le \\epsilon&#x27;_{\\text{mac}},\\tag{14}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\epsilon&#x27;_{\\text{mac}}</span>  is the probability of breaking the message authentication code, using resources similar to those of the given adversary. By assumption,  <span class="math">\\epsilon&#x27;_{\\text{mac}}</span>  is negligible. Indeed,  <span class="math">\\epsilon&#x27;_{\\text{mac}}</span>  is the probability of breaking the message authentication code &quot;blind&quot; (without first obtaining one valid tag).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Completing the proof</h4>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300">$$\\Pr[F_4] \\leq Q \\Pr[F'<em>4] \\qquad \\text{[by (6)]} \\
= Q \\Pr[F'_5] \\qquad \\text{[by (8)]} \\
\\leq Q(\\Pr[F'</em>{6'}] + \\epsilon'<em>{\\text{kdf}}) \\qquad \\text{[by (13)]} \\
\\leq Q(\\epsilon'</em>{\\text{mac}} + \\epsilon'_{\\text{kdf}}) \\qquad \\text{[by (14)]}$$</p>

    <p class="text-gray-300">Thus, we have</p>

    <p class="text-gray-300"><span class="math">$\\Pr[F_4] \\le Q(\\epsilon&#x27;_{\\text{mac}} + \\epsilon&#x27;_{\\text{kdf}}). \\tag{15}</span>$</p>

    <p class="text-gray-300">Finally, combining (15) with (1), (2), (3), (4), (5), (7), (9), (10), (11), and (12), we have:</p>

    <p class="text-gray-300"><span class="math">$|\\Pr[X_0] - 1/2| \\le \\epsilon_{\\text{tcr}} + \\epsilon_{\\text{ddh}} + \\epsilon_{\\text{kdf}} + \\epsilon_{\\text{enc}} + Q(\\epsilon_{\\text{mac}} + \\epsilon&#x27;_{\\text{mac}} + \\epsilon&#x27;_{\\text{kdf}}).</span>$
(16)</p>

    <p class="text-gray-300">By assumption, the right-hand side of (16) is negligible, which finishes the proof.</p>

    <p class="text-gray-300">In [2] Cramer and Shoup showed that their original scheme in [1] was a special instance of a generic paradigm based on hash proof systems. We briefly recall here the basic ideas and how they can be applied to the scheme described in the previous section.</p>

    <p class="text-gray-300">Smooth projective hashing [2]: Let X be a set and L ⊂ X a language. Loosely speaking, a hash function H&lt;sup&gt;a&lt;/sup&gt; that maps X to some set is projective if there exists a projection key that defines the action of H&lt;sup&gt;a&lt;/sup&gt; over the subset L of the domain X. That is, there exists a projection function α(·) that maps keys k into their projections s = α(a). The projection key s is such that for every x ∈ L it holds that the value of Ha(x) is uniquely determined by s and x. In contrast, nothing is guaranteed for x 6∈ L, and it may not be possible to compute Ha(x) from s and x. A smooth projective hash function has the additional property that for x /∈ L, the projection key s actually says nothing about the value of Ha(x). More specifically, given x and s = α(a), the value Ha(x) is uniformly distributed (or statistically close) to a random element in the range of Ha.</p>

    <p class="text-gray-300">An interesting feature of smooth projective hashing is that if L is an NP-language, then for every x ∈ L it is possible to efficiently compute Ha(x) using the projection key s = α(a) and a witness of the fact that x ∈ L. Alternatively, given a itself, it is possible to efficiently compute Ha(x) even without knowing a witness.</p>

    <p class="text-gray-300">Using the techniques from [2], Kurosawa and Desmedt in [5] generalize the above scheme can be generalized using smooth projective hashing as follows. The sets X, L and a projection key s = α(a) will be the public key. The key a will be the secret key.</p>

    <p class="text-gray-300">To encrypt m, the sender chooses an element x ∈ L together with a witness. He then computes v = Ha(x) using the projection s and the witness. Then the keys (k, K) = KDF(v) are derived as above. The rest of the encryption procedure remains the same, i.e., e = EK(m) and t = MACk(e). The ciphertext is x, e, t.</p>

    <p class="text-gray-300">The receiver on input (x, e, t) computes v &lt;sup&gt;0&lt;/sup&gt; = Ha(x) and (k, K) = KDF(v 0 ). If t = MACk(e) then it decrypts m = DK(e).</p>

    <p class="text-gray-300">Security Analysis. As in the proof in [2] the basic computational assumption underlying the security of this scheme is that it is hard to distinguish between random elements in L and random elements outside of L.</p>

    <p class="text-gray-300">The proof of security in [5] requires the projective hash function to be strongly 2 universal, which is a stronger condition than smoothness. Basically it is required that for x /∈ L, even given s = α(a) and the value Ha(x 0 ) for x &lt;sup&gt;0&lt;/sup&gt; ∈/ L and x &lt;sup&gt;0&lt;/sup&gt; 6= x, the distribution of the value Ha(x) is statistically close to the uniform distribution over the range of Ha. Their generalized scheme, however, still requires information-theoretically secure KDF and MAC functions.</p>

    <p class="text-gray-300">Our proof, which lifts such requirements on the KDF and MAC functions, also generalizes assuming strong 2-universal projective hashing, that one can efficiently sample elements outside of L, and there is a trapdoor that allows for efficiently testing language membership.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In CRYPTO'98.</li>
      <li>[2] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for chosen ciphertext secure public key encryption. In EuroCrypt'02.</li>
      <li>[3] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM Journal of Computing 33:167-226, 2003</li>
      <li>[4] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In STOC'91, pages 542–552, 1991.</li>
      <li>[5] K. Kurosawa and Y. Desmedt. A New Paradigm of Hybrid Encryption Scheme. In CRYPTO'04.</li>
      <li>[6] M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In STOC'90.</li>
      <li>[7] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In CRYPTO'91.</li>
      <li>[8] V. Shoup Using hash functions as a hedge against chosen ciphertext attack. In Euro-Crypt'00.</li>
    </ul>

    <p class="text-gray-300">The Cramer-Shoup hybrid encryption scheme proposed in [1], and refined in [8], uses the same tools as the one described above. However key generation, encryption and decryption algorithms are different.</p>

    <p class="text-gray-300">Key Generation: The description of the group G is generated, along with a random generator g&lt;sup&gt;1&lt;/sup&gt; for G. Any keys for KDF and H are also generated. Then:</p>

    <p class="text-gray-300"><span class="math">$w, x, y, z \\stackrel{\\phi}{\\leftarrow} \\mathbb{Z}_q, \\ g_2 \\leftarrow g_1^w, \\ c \\leftarrow g_1^x, \\ d \\leftarrow g_1^y, \\ h \\leftarrow g_1^z.</span>$</p>

    <p class="text-gray-300">The public key consists of the description of G, the generators g&lt;sup&gt;1&lt;/sup&gt; and g2, keys for KDF and H (if any), along with the group elements c, d, h. The private key consists of the public key, along with w, x, y, z.</p>

    <p class="text-gray-300">Encryption of  <span class="math">m \\in \\{0,1\\}^*</span> :</p>

    <pre><code class="language-text">r \\stackrel{\\protect}{\\leftarrow} \\mathbb{Z}_q, \\ \\kappa \\leftarrow h^r, \\ u_1 \\leftarrow g_1^r \\in G, \\ u_2 \\leftarrow g_2^r \\in G, \\ \\alpha \\leftarrow H(u_1, u_2) \\in \\mathbb{Z}_q
v \\leftarrow c^r d^{r\\alpha} \\in G, \\ (k, K) \\leftarrow KDF(\\kappa), \\ e \\leftarrow E_K(m), \\ t \\leftarrow MAC_k(e)
output C := (u_1, u_2, v, e, t)
</code></pre>

    <p class="text-gray-300"><strong>Decryption of</strong>  <span class="math">C = (u_1, u_2, v, e, t)</span> :</p>

    <pre><code class="language-text">\\alpha \\leftarrow H(u_1, u_2) \\in \\mathbb{Z}_q, \\ v&#x27; \\leftarrow u_1^{x+y\\alpha} \\in G, \\ \\kappa&#x27; \\leftarrow u_1^z, \\ (k, K) \\leftarrow KDF(\\kappa&#x27;) if t \\neq MAC_k(e) or v&#x27; \\neq v or u_2 \\neq u_1^w then reject else m \\leftarrow D_K(e) output m
</code></pre>

    <p class="text-gray-300">Notice that compared to the Kurosawa-Desmedt scheme, the encryption algorithm in this scheme computes an extra exponentiation (the computation of  <span class="math">\\kappa</span> ) and a longer ciphertext (it includes the group element v). However, that does not translate into a direct gain in efficiency.</p>

    <p class="text-gray-300">In the Cramer-Shoup scheme we can choose the prime q to be 160-bit long. This results in a random value  <span class="math">\\kappa</span>  which is computationally indistinguishable from a random group element. Then, under a suitable computational assumption on KDF, we can derive keys k, K of any required length using a pseudo-random number generator.</p>

    <p class="text-gray-300">On the other hand, the key k in the Kurosawa-Desmedt scheme must be derived from v in an information-theoretic way. We can't apply a pseudo-random number generator, otherwise we lose the information-theoretic security. For common security parameters k is required to be at least 170-bits long. The only way we know how to do this is to map v into an 160-bit string using universal hashing and the Entropy Smoothing Theorem. But this requires v to come from a distribution with min-entropy at least, say, 320. Considering that from  <span class="math">\\kappa</span>  we also need to derive the key K (say, another 128 bits), then it seems that the group G must have order q of at least about 450 bits. This increase in the security parameter clearly offsets the gain obtained by dropping one exponentiation.</p>

    <p class="text-gray-300">Using our proof, however, we can claim that the Kurosawa-Desmedt scheme can be used with a group G of order q where q is a 160-bit prime.</p>

    <p class="text-gray-300">We also note that the scheme in [8] is optimized so that all exponentiations in the decryption algorithm are with respect to the same base — this allows for speedups using techniques for exponentiation with preprocessing. We believe that similar optimizations can be applied to the Kurosawa-Desmedt scheme. Also, the scheme in [8] can be proven secure in the random oracle model under the <em>computational</em> Diffie-Hellman assumption — we believe that the same can be proven for the Kurosawa-Desmedt scheme.</p>

`;
---

<BaseLayout title="A Note on an Encryption Scheme of Kurosawa and Desmedt∗ (2004/194)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/194
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-note-on-an-encryption-scheme-of-kurosawa-and-desmedt-2004" />
  </article>
</BaseLayout>
