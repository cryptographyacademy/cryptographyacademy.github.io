---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/194';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Note on An Encryption Scheme of Kurosawa and Desmedt';
const AUTHORS_HTML = 'Rosario Gennaro, Victor Shoup';

const CONTENT = `    <p class="text-gray-300">A Note on an Encryption Scheme of Kurosawa and Desmedt*</p>

    <p class="text-gray-300">Rosario Gennaro†  Victor Shoup‡</p>

    <p class="text-gray-300">May 18, 2005</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">Recently, Kurosawa and Desmedt presented a new hybrid encryption scheme which is secure against adaptive chosen-ciphertext attack. Their scheme is a modification of the Cramer-Shoup encryption scheme. Its major advantage with respect to Cramer-Shoup is that it saves the computation of one exponentiation and produces shorter ciphertexts. However, the proof presented by Kurosawa and Desmedt relies on the use of information-theoretic key derivation and message authentication functions.</p>

    <p class="text-gray-300">In this note we present a different proof of security which shows that the Kurosawa-Desmedt scheme can be instantiated with any computationally secure key derivation and message authentication functions, thus extending the applicability of their paradigm, and improving its efficiency.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">The notion of chosen-ciphertext security was introduced by Naor and Yung [6] and developed by Rackoff and Simon [7], and Dolev, Dwork, and Naor [4].</p>

    <p class="text-gray-300">In a chosen ciphertext attack, the adversary is given access to a decryption oracle that allows him to obtain the decryptions of ciphertexts of his choosing. Intuitively, security in this setting means that an adversary obtains (effectively) no information about encrypted messages, provided the corresponding ciphertexts are never submitted to the decryption oracle.</p>

    <p class="text-gray-300">As shown in [4], security against chosen-ciphertext attack is equivalent to the notion of non-malleability. An encryption scheme is said to be non-malleable if given a ciphertext <span class="math">c</span>, it is infeasible to compute a ciphertext <span class="math">c&#x27;</span> whose decryption is somewhat related to the decryption of <span class="math">c</span>.</p>

    <p class="text-gray-300">For these reasons, the notion of chosen-ciphertext security has emerged as the "right" notion of security for encryption schemes. Indeed it can be shown that in order to model encryption as a "secure envelope", then the encryption scheme used must be chosen-ciphertext secure.</p>

    <p class="text-gray-300">A number of chosen ciphertext secure cryptosystems have been proposed in the literature. The first schemes were presented in [6, 7, 4], but they were quite impractical. The first</p>

    <p class="text-gray-300">*Original version: August 10, 2004. †IBM T.J.Watson Research Center, Yorktown Heights, NY, USA. rosario@watson.ibm.com ‡Computer Science Dept. NYU. shoup@cs.nyu.edu</p>

    <p class="text-gray-300">1</p>

    <p class="text-gray-300">truly practical cryptosystem that is provably secure against chosen ciphertext attack was discovered by Cramer and Shoup <em>[1]</em>. The security of this scheme is based on the hardness of the decisional Diffie-Hellman problem. In <em>[2]</em> Cramer and Shoup show that their original scheme is an instance of a more generic paradigm, which can be also instantiated with the Quadratic Residuosity and <span class="math">N</span>-Residuosity assumptions.</p>

    <p class="text-gray-300">In <em>[8]</em> Shoup presents an hybrid variant of the Cramer-Shoup cryptosystem. This scheme uses the original public-key scheme to generate an encryption of a random group element <span class="math">\\kappa</span>. Then a key derivation function (KDF) is applied to <span class="math">\\kappa</span> to compute two keys <span class="math">k,K</span> which are used to encrypt the actual message with a chosen-ciphertext secure symmetric encryption scheme (recalled below).</p>

    <p class="text-gray-300">Differently than in the public-key case, symmetric encryption schemes which are secure against a chosen-ciphertext attack can be easily built out of weaker primitives. It is indeed well known that all you need is a symmetric encryption scheme <span class="math">E</span> which is secure against passive adversaries, and a secure message authentication code (MAC). To encrypt a message <span class="math">m</span> with keys <span class="math">k,K</span> it is sufficient to encrypt <span class="math">m</span> with <span class="math">K</span>, i.e. compute <span class="math">e=E_{K}(m)</span>, and then compute a message authentication tag for <span class="math">e</span> using <span class="math">k</span>, i.e. compute <span class="math">t=MAC_{k}(e)</span>. The final ciphertext is <span class="math">(e,t)</span>. The receiver, who also holds <span class="math">k,K</span>, first checks that the tag <span class="math">t</span> is correct and only in that case decrypts <span class="math">e</span>.</p>

    <p class="text-gray-300">Recently Kurosawa and Desmedt <em>[5]</em> modified the hybrid scheme presented in <em>[8]</em>. The advantage of their modification is that the computation of a ciphertext in their scheme requires one less exponentiation and produces shorter ciphertexts.</p>

    <p class="text-gray-300">However their proof of security relies on the use of information theoretically secure KDF and MAC functions in the symmetric step of the hybrid construction. There are several reasons why this is not desirable, among them:</p>

    <p class="text-gray-300">The proof in <em>[5]</em> requires the key <span class="math">k</span> to be statistically close to a random key. This means that we cannot use a pseudo-random generator to derive <span class="math">k</span> from a random group element encrypted during the public-key phase. This in turns implies that the public key part of the scheme must be instantiated with larger security parameters which would result in slower execution times; we would like to have a scheme into which we can plug any secure component and it still remains secure. It would be hard to deploy a scheme in large-scale if it can be used only in conjunction with certain types of MACs and KDFs (and in particular, with KDFs and MACs that are not used at all by the designers of standard cryptographic algorithms).</p>

    <p class="text-gray-300">In this note we show a new and different proof of security for the Kurosawa-Desmedt scheme. We show that it is indeed possible to use any secure key derivation function and message authentication code. This effectively improves the efficiency and applicability of their scheme.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">In this section we recall the Kurosawa-Desmedt scheme from [5]. We describe it using generic building blocks and at the end of the section we point out where the proof of security in [5] requires information theoretic security. The scheme makes use of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a group <span class="math">G</span> of prime order <span class="math">q</span>, with (random) generators <span class="math">g_1</span> and <span class="math">g_2</span>.</li>

    </ul>

    <p class="text-gray-300">Security assumption (DDH): Hard to distinguish <span class="math">(g_1^r, g_2^r)</span> from <span class="math">(g_1^r, g_2^{r&#x27;})</span>, where <span class="math">r</span> is a random element of <span class="math">\\mathbb{Z}_q</span> and <span class="math">r&#x27;</span> is a random element of <span class="math">\\mathbb{Z}_q \\setminus \\{r\\}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a message authentication code <span class="math">MAC</span>, which is a function that takes two inputs, a key <span class="math">k</span> and message <span class="math">e \\in \\{0,1\\}^*</span>, and produces a "tag" <span class="math">t := MAC_k(e)</span>.</li>

    </ul>

    <p class="text-gray-300">Security assumption: For random <span class="math">k</span>, after obtaining <span class="math">t^<em> := MAC_k(e^</em>)</span> for (at most one) adversarially chosen <span class="math">e^<em></span>, hard to compute a forgery pair, i.e., a pair <span class="math">(e,t)</span> such that <span class="math">e \\neq e^</em></span> and <span class="math">t = MAC_k(e)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a symmetric key encryption scheme, with encryption algorithm <span class="math">E</span> and decryption algorithm <span class="math">D</span>, such that for key <span class="math">K</span> and plaintext <span class="math">m \\in \\{0,1\\}^<em></span>, <span class="math">e := E_K(m)</span> is the encryption of <span class="math">m</span> under <span class="math">K</span>, and for key <span class="math">K</span> and ciphertext <span class="math">e \\in \\{0,1\\}^</em></span>, <span class="math">m := D_K(m)</span> is the decryption of <span class="math">e</span> under <span class="math">K</span>.</li>

    </ul>

    <p class="text-gray-300">Security assumption (semantic security): hard to distinguish <span class="math">E_K(m_0)</span> from <span class="math">E_K(m_1)</span> for randomly chosen <span class="math">K</span> and adversarially chosen <span class="math">m_0</span> and <span class="math">m_1</span> (where <span class="math">m_0</span> and <span class="math">m_1</span> are of equal length).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a key derivation function <span class="math">KDF</span>, such that for <span class="math">v \\in G</span>, <span class="math">KDF(v) = (k, K)</span>, where <span class="math">k</span> is a message authentication key, and <span class="math">K</span> is a symmetric encryption key.</li>

    </ul>

    <p class="text-gray-300">Security assumption: hard to distinguish <span class="math">KDF(v)</span> from <span class="math">(k, K)</span>, where <span class="math">v, k</span> and <span class="math">K</span> are random.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a hash function <span class="math">H: G \\times G \\to \\mathbb{Z}_q</span>.</li>

    </ul>

    <p class="text-gray-300">Security assumption (target collision resistance): given <span class="math">u_1^<em> := g_1^r</span> and <span class="math">u_2^</em> := g_2^r</span>, for random <span class="math">r \\in \\mathbb{Z}_q</span>, hard to find <span class="math">(u_1, u_2) \\in G \\times G \\setminus \\{(u_1^<em>, u_2^</em>)\\}</span> such that <span class="math">H(u_1, u_2) = H(u_1^<em>, u_2^</em>)</span>.</p>

    <p class="text-gray-300">Note that the key space for the message authentication code is assumed to consist of all bit strings of a given length, so that by a random key <span class="math">k</span>, we mean a random bit string of appropriate length. Similarly for the symmetric encryption keys.</p>

    <p class="text-gray-300">Note also that <span class="math">KDF</span> and <span class="math">H</span> may have associated keys (which are publicly known).</p>

    <p class="text-gray-300">Key Generation: The description of the group <span class="math">G</span> is generated, along with random generators <span class="math">g_1</span> and <span class="math">g_2</span> for <span class="math">G</span>. Any keys for <span class="math">KDF</span> and <span class="math">H</span> are also generated. Then:</p>

    <div class="my-4 text-center"><span class="math-block">x_1, x_2, y_1, y_2 \\stackrel{\\iota}{\\leftarrow} \\mathbb{Z}_q, \\quad c \\leftarrow g_1^{x_1} g_2^{x_2}, \\quad d \\leftarrow g_1^{y_1} g_2^{y_2}.</span></div>

    <p class="text-gray-300">2Since we are defining <span class="math">MAC</span> as a function there is only one possible output for any input pair <span class="math">k, e</span>. It is possible to define message authentication codes as two algorithms: a "tagging" and a "verifying" algorithm. The tagging algorithm could be randomized and thus one of several tags could be computed on the same input pair. The security property then would be that it is hard to compute any valid message/tag pair <span class="math">(e, t)</span> other than <span class="math">(e^<em>, t^</em>)</span>.</p>

    <p class="text-gray-300">3</p>

    <p class="text-gray-300">The public key consists of the description of <span class="math">G</span>, the generators <span class="math">g_{1}</span> and <span class="math">g_{2}</span>, keys for KDF and <span class="math">H</span> (if any), along with the group elements <span class="math">c</span> and <span class="math">d</span>. The private key consists of the public key, along with <span class="math">x_{1},x_{2},y_{1},y_{2}</span>.</p>

    <p class="text-gray-300">Encryption of <span class="math">m\\in\\{0,1\\}^{*}</span>:</p>

    <p class="text-gray-300"><span class="math">r\\stackrel{{\\scriptstyle\\scriptscriptstyle t}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ u_{1}\\leftarrow g_{1}^{r}\\in G,\\ u_{2}\\leftarrow g_{2}^{r}\\in G,\\ \\alpha\\leftarrow H(u_{1},u_{2})\\in\\mathbb{Z}_{q}</span> <span class="math">v\\leftarrow c^{r}d^{r\\alpha}\\in G,\\ (k,K)\\leftarrow KDF(v),\\ e\\leftarrow E_{K}(m),\\ t\\leftarrow MAC_{k}(e)</span> output <span class="math">C:=(u_{1},u_{2},e,t)</span></p>

    <p class="text-gray-300">Decryption of <span class="math">C=(u_{1},u_{2},e,t)</span>:</p>

    <p class="text-gray-300"><span class="math">\\alpha\\leftarrow H(u_{1},u_{2})\\in\\mathbb{Z}_{q},\\ v\\leftarrow u_{1}^{x_{1}+y_{1}\\alpha}u_{2}^{x_{2}+y_{2}\\alpha}\\in G,\\ (k,K)\\leftarrow KDF(v)</span> if <span class="math">t\\neq MAC_{k}(e)</span> then output “reject” else <span class="math">m\\leftarrow D_{K}(e)</span> output <span class="math">m</span></p>

    <p class="text-gray-300">In addition to the above computational security assumption, the proof of security in <em>[5]</em> requires the following information theoretic assumptions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>information-theoretically secure KDF. If <span class="math">v\\in G</span> is random, then at least the first component <span class="math">k</span> of the output of KDF(<span class="math">v</span>) should be (statistically close to) uniform.</li>

      <li>information-theoretically secure MAC. For all <span class="math">e</span> and <span class="math">t</span>, if <span class="math">k</span> is chosen at random, then <span class="math">\\Pr[MAC_{k}(e)=t]</span> is negligible.</li>

    </ul>

    <p class="text-gray-300">Our proof of security, described in the next section, does not need these assumptions.</p>

    <p class="text-gray-300">Kurosawa and Desmedt apparently introduce these assumptions to avoid a potential circularity in their proof. Both their proof and ours use a “hybrid argument,” whereby the initial attack game is transformed in a sequence of small steps into a game in which the adversary’s advantage is clearly negligible. At one point in their proof, in order to justify one of the steps in this sequence, they want to prove that the decryption oracle will reject certain ciphertexts; to prove this, they must first prove that certain MAC keys are randomly distributed and that certain tag values are unpredictable; to draw this conclusion, they must first prove that the above-mentioned ciphertexts are rejected. As it happens, the way out of this circularity chosen by Kurosawa and Desmedt is to introduce information-theoretic security assumptions. However, we show how to avoid this using a technique that is perhaps not so well appreciated, which we might call “deferred analysis.” We will point out below in the proof where this technique is employed. This technique has also been used before — for example, in <em>[3]</em>, it is used in the proof of security of a version of the Cramer-Shoup encryption scheme that makes use of a universal one-way hash function (rather than a collision-resistant hash function). The original security proof in <em>[1]</em> was actually a bit incomplete regarding this issue.</p>

    <p class="text-gray-300">In Appendix A we recall the Cramer-Shoup hybrid scheme from <em>[8]</em> and compare the two schemes. In particular we point out how for typical security parameters the gains posted by the Kurosawa-Desmedt scheme may be offset by the requirement that KDF and MAC be information theoretically secure.</p>

    <p class="text-gray-300">3 Security proof</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">Game 0</h3>

    <p class="text-gray-300">We now define a game, called <em>Game 0</em>, which is an interactive computation between an <em>adversary</em> and a <em>simulator</em>. This game is simply the usual game used to define CCA security, in which the simulator provides the adversary’s environment.</p>

    <p class="text-gray-300">Initially, the simulator runs the key generation algorithm, obtaining the description of <span class="math">G</span>, generators <span class="math">g_{1}</span> and <span class="math">g_{2}</span>, keys for <em>KDF</em> and <span class="math">H</span> (if any), along with the values <span class="math">x_{1},x_{2},y_{1},y_{2}\\in\\mathbb{Z}_{q}</span> and <span class="math">c,d\\in G</span>. The simulator gives the public key to the adversary.</p>

    <p class="text-gray-300">During the execution of the game, the adversary makes a number of “decryption requests.” Assume these requests are <span class="math">C^{(1)},\\ldots,C^{(Q)}</span>, where</p>

    <p class="text-gray-300"><span class="math">C^{(i)}=(u_{1}^{(i)},u_{2}^{(i)},e^{(i)},t^{(i)}).</span></p>

    <p class="text-gray-300">For each such request, the simulator decrypts the given ciphertext, and gives the adversary the result. We denote by <span class="math">\\alpha^{(i)}</span>, <span class="math">v^{(i)}</span>, <span class="math">k^{(i)}</span>, and <span class="math">K^{(i)}</span> the corresponding intermediate quantities computed by the decryption algorithm on input <span class="math">C^{(i)}</span>.</p>

    <p class="text-gray-300">The adversary may also make a single “challenge request.” For such a request, the adversary submits two messages <span class="math">m_{0},m_{1}</span>, which are bit strings of equal length, to the simulator; the simulator chooses <span class="math">b\\in\\{0,1\\}</span> at random, and encrypts <span class="math">m_{b}</span>, obtaining the “target ciphertext” <span class="math">C^{<em>}=(u_{1}^{</em>},u_{2}^{<em>},e^{</em>},t^{<em>})</span>. The simulator gives <span class="math">C^{</em>}</span> to the adversary. We denote by <span class="math">r^{<em>}</span>, <span class="math">\\alpha^{</em>}</span>, <span class="math">v^{<em>}</span>, <span class="math">k^{</em>}</span>, and <span class="math">K^{*}</span> the corresponding intermediate quantities computed by the encryption algorithm.</p>

    <p class="text-gray-300">The only restriction on the adversary’s requests is that after it makes a challenge request, subsequent decryption requests must not be the same as the target ciphertext.</p>

    <p class="text-gray-300">At the end of the game, the adversary outputs <span class="math">\\hat{b}\\in\\{0,1\\}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">X_{0}</span> be the event that <span class="math">\\hat{b}=b</span>. Security means that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ should be negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We prove this by considering other games, <em>Game 1</em>, <em>Game 2</em>, etc. These games will be quite similar to Game 0 in their overall structure, and will only differ from Game 0 in terms of how the simulator works. However, in each game, there will be well defined bits <span class="math">\\hat{b}</span> and <span class="math">b</span>, so that in Game <span class="math">i</span>, we always define <span class="math">X_{i}</span> to the event that <span class="math">\\hat{b}=b</span> in that game. All of these games should be viewed as operating on the same underlying probability space.</p>

    <p class="text-gray-300">Before moving on, we make a couple of additional assumptions about the internal structure of Game 0 that will be convenient down the road. First, we assume that <span class="math">g_{2}</span> is computed as:</p>

    <p class="text-gray-300">$w\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</p>

    <p class="text-gray-300">the simulator <em>rejects</em> the given ciphertext.</p>

    <p class="text-gray-300">In Game 1, the simulator may reject ciphertexts that would not have been rejected in Game 0. Let us call Rejection Rule 0 the rule by which ciphertexts are rejected as in the ordinary decryption algorithm (i.e., the message authentication tags do not match). Let us call Rejection Rule 1 this new rejection rule, introduced in Game 1.</p>

    <p class="text-gray-300">Let <span class="math">F_{1}</span> be the event that the simulator applies Rejection Rule 1 in Game 1 to a ciphertext to which Rejection Rule 0 does not apply. Game 0 and Game 1 proceed identically until the this event occurs; in particular, the events <span class="math">X_{0}\\wedge\\neg F_{1}</span> and <span class="math">X_{1}\\wedge\\neg F_{1}</span> are the same (recall that we view all games to operate on the same underlying probability space); therefore,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{0}]-\\Pr[X_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{1}].$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{1}]=\\epsilon_{\\text{tcr}},</span> (2)</p>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\text{tcr}}</span> is the success probability that one can find a collision in <span class="math">H</span> using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon_{\\text{tcr}}</span> is negligible.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">Game 2</h3>

    <p class="text-gray-300">Game 2 is the same as Game 1, except that the simulator computes <span class="math">v^{*}</span> as</p>

    <p class="text-gray-300"><span class="math">v^{<em>}\\leftarrow(u_{1}^{</em>})^{x_{1}+y_{1}\\alpha^{<em>}}(u_{2}^{</em>})^{x_{2}+y_{2}\\alpha^{*}}.</span></p>

    <p class="text-gray-300">This change is purely conceptual, since <span class="math">v^{*}</span> has the same value either way. In particular,</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{1}]=\\Pr[X_{2}].</span> (3)</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Game 3</h3>

    <p class="text-gray-300">Now generate <span class="math">u_{2}^{*}</span> by the rule</p>

    <p class="text-gray-300"><span class="math">r^{\\prime}\\stackrel{{\\scriptstyle\\scriptstyle 4}}{{\\leftarrow}}\\mathbb{Z}_{q}\\setminus\\{r^{<em>}\\},\\ u_{2}^{</em>}\\leftarrow g_{2}^{r^{\\prime}}.</span></p>

    <p class="text-gray-300">We have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{2}]-\\Pr[X_{3}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\text{ddh}},$ (4)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\text{ddh}}</span> is the advantage with which one can solve the DDH problem, using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon_{\\text{ddh}}</span> is negligible.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>The details. We can easily build a “hybrid” Game 2/3 that takes <span class="math">\\tau:=(g_{1},g_{2},u_{1}^{<em>},u_{2}^{</em>})</span> as input, so that if <span class="math">\\tau</span> is a random DH-tuple, Game 2/3 acts just like Game 2, and if <span class="math">\\tau</span> is a random non-DH-tuple, then Game 2/3 acts just like Game 3. The distinguishing algorithm runs Game 2/3 on input <span class="math">\\tau</span>, and outputs 1 if <span class="math">\\hat{b}=b</span>, and outputs 0 otherwise. The distinguishing advantage of this algorithm is exactly equal to <span class="math">|\\Pr[X_{2}]-\\Pr[X_{3}]|</span>.</p>
    </blockquote>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Game 4</p>

    <p class="text-gray-300">In this game, the simulator makes use of the value <span class="math">w\\in\\mathbb{Z}_{q}</span>, where <span class="math">g_{2}=g_{1}^{w}</span>. The simulator did not need to make explicit use of this value in previous games. Indeed, we could not have used the DDH assumption if the simulator had to use <span class="math">w</span>. However, we are now finished with the DDH assumption, and so the simulator is free to make use of <span class="math">w</span> in this and subsequent games.</p>

    <p class="text-gray-300">Game 4 is the same as Game 3, except that we introduce a new Rejection Rule 2: in responding to decryption requests, the simulator <em>rejects</em> any ciphertext <span class="math">C^{(i)}</span> such that</p>

    <p class="text-gray-300"><span class="math">(u_{1}^{(i)},u_{2}^{(i)})\\neq(u_{1}^{<em>},u_{2}^{</em>})\\ \\ \\text{and}\\ \\ (u_{1}^{(i)})^{w}\\neq u_{2}^{(i)}.</span></p>

    <p class="text-gray-300">Note that the condition <span class="math">(u_{1}^{(i)})^{w}\\neq u_{2}^{(i)}</span> is equivalent to <span class="math">\\log_{g_{1}}u_{1}^{(i)}\\neq\\log_{g_{2}}u_{2}^{(i)}</span>.</p>

    <p class="text-gray-300">Define <span class="math">F_{4}</span> to be the event that a ciphertext is rejected during Game 4 using Rejection Rule 2 to which Rejection Rules 0 and 1 are not applicable.</p>

    <p class="text-gray-300">Clearly, Game 3 and Game 4 proceed identically until <span class="math">F_{4}</span> occurs; in particular, the events <span class="math">X_{3}\\wedge\\neg F_{4}</span> and <span class="math">X_{4}\\wedge\\neg F_{4}</span> are the same, and so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{3}]-\\Pr[X_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{4}].$ (5)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We want to show that <span class="math">\\Pr[F_{4}]</span> is negligible; however, we postpone this until later. This is the “deferred analysis” technique: instead of attempting to bound <span class="math">\\Pr[F_{4}]</span> right now, we shall patiently wait until a later game, where it will be much easier. However, at this point we augment Game 4 just slightly, utilizing the well-known “plug and pray” technique: the simulator chooses <span class="math">j\\in\\{1,\\ldots,Q\\}</span> at random, and we define <span class="math">F_{4}^{\\prime}</span> to be the event that in Game 4, Rejection Rules 0 and 1 do not apply to <span class="math">C^{(j)}</span>, but Rejection Rule 2 does apply to <span class="math">C^{(j)}</span>. Clearly,</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{4}]\\leq Q\\Pr[F_{4}^{\\prime}],</span> (6)</p>

    <p class="text-gray-300">and so it suffices to show that <span class="math">\\Pr[F_{4}^{\\prime}]</span> is negligible.</p>

    <p class="text-gray-300">It will be helpful to write down in detail how Game 4 works, starting from scratch:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator begins by generating the description of <span class="math">G</span>, along with a random generator <span class="math">g_{1}</span>, and any keys for <em>KDF</em> and <span class="math">H</span>. It then computes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>$w\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\scriptstyle{\\</li>

    </ul>

    <p class="text-gray-300">D01: <span class="math">\\alpha^{(i)} \\gets H(u_1^{(i)}, u_2^{(i)})</span> D02: if <span class="math">(u_1^{(i)}, u_2^{(i)}) \\neq (u_1^<em>, u_2^</em>)</span> and <span class="math">\\alpha^{(i)} = \\alpha^<em></span> then D03: return "reject" D04: else if <span class="math">(u_1^{(i)}, u_2^{(i)}) = (u_1^</em>, u_2^<em>)</span> then D05: if <span class="math">t^{(i)} \\neq MAC_{k^</em>}(e^{(i)})</span> then return "reject" D06: return <span class="math">D_{K^*}(e^{(i)})</span> D07: else if <span class="math">(u_1^{(i)})^w \\neq u_2^{(i)}</span> then D08: <span class="math">v^{(i)} \\gets (u_1^{(i)})^{x_1 + y_1\\alpha^{(i)}} (u_2^{(i)})^{x_2 + y_2\\alpha^{(i)}}</span> D09: <span class="math">(k^{(i)}, K^{(i)}) \\gets KDF(v^{(i)})</span> D10: if <span class="math">t^{(i)} \\neq MAC_{k^{(i)}}(e^{(i)})</span> then return "reject" D11: return "reject" D12: else D13: <span class="math">v^{(i)} \\gets (u_1^{(i)})^{x_1 + y_1\\alpha^{(i)}} (u_2^{(i)})^{x_2 + y_2\\alpha^{(i)}}</span> D14: <span class="math">(k^{(i)}, K^{(i)}) \\gets KDF(v^{(i)})</span> D15: if <span class="math">t^{(i)} \\neq MAC_{k^{(i)}}(e^{(i)})</span> then return "reject" D16: return <span class="math">D_{K^{(i)}}(e^{(i)})</span></p>

    <p class="text-gray-300">Note that Rejection Rule 0 is applied at lines D05, D10, and D15, while Rejection Rule 1 is applied at line D03, and Rejection Rule 2 (and no other Rejection Rule) at line D11.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In processing the challenge request, the adversary gives <span class="math">m_0, m_1</span> to the simulator. The simulator computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">b \\stackrel {t} {\\leftarrow} \\{0, 1 \\}, e ^ {*} \\leftarrow E _ {K ^ {*}} (m _ {b}), t ^ {*} \\leftarrow M A C _ {k ^ {*}} (e ^ {*}),</span></div>

    <p class="text-gray-300">and gives <span class="math">C^<em> \\coloneqq (u_1^</em>, u_2^<em>, e^</em>, t^*)</span> to the adversary.</p>

    <p class="text-gray-300">We have written the logic of the decryption oracle in this particular way to facilitate further analysis. Note that the computations at D08–D10 have no real effect, other than to determine if the event <span class="math">F_4&#x27;</span> occurs; indeed, once line D08 is reached, the ciphertext is sure to be rejected, either at line D10 or at line D11. The event <span class="math">F_4&#x27;</span> is simply the event that line D11 executes in the <span class="math">j</span>th decryption request.</p>

    <h2 id="sec-5" class="text-2xl font-bold">Game 5</h2>

    <p class="text-gray-300">Game 5 is the same as Game 4, except that we change lines I2 and I4, as follows:</p>

    <p class="text-gray-300">I2: <span class="math">x, y \\stackrel{t}{\\leftarrow} \\mathbb{Z}_q</span>, <span class="math">c \\gets g_1^x</span>, <span class="math">d \\gets g_1^y</span> I4: <span class="math">v^{*} \\stackrel{t}{\\leftarrow} G</span></p>

    <p class="text-gray-300">as well as lines D08 and D13, as follows:</p>

    <p class="text-gray-300">D08: <span class="math">v^{(i)} \\stackrel{t}{\\leftarrow} G</span> D13: <span class="math">v^{(i)} \\gets (u_1^{(i)})^{x + y\\alpha^{(i)}}</span></p>

    <p class="text-gray-300"><span class="math">x_{1},x_{2},y_{1},y_{2}</span> are not used at all in Game 5.</p>

    <p class="text-gray-300">We define <span class="math">F_{5}^{\\prime}</span> to be the event that line D11 is executed in the <span class="math">j</span>th decryption request in Game 5. We claim that</p>

    <p class="text-gray-300"><span class="math">\\Pr[X_{4}]=\\Pr[X_{5}]</span> (7)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{4}^{\\prime}]=\\Pr[F_{5}^{\\prime}].</span> (8)</p>

    <p class="text-gray-300">This follows from a simple linear algebra argument, along the same lines as in <em>[1]</em>. The point is, we are simply swapping one set of 4-wise independent random variables for another; indeed, in both games, the variables <span class="math">c</span>, <span class="math">d</span>, <span class="math">v^{*}</span>, and <span class="math">v^{(j)}</span> (as computed at line D08) are mutually independent and uniformly distributed over <span class="math">G</span>.</p>

    <p class="text-gray-300">Now our sequence of games reaches a fork in the road. Games 6 and 7 below (the “left fork”) are used to show that <span class="math">\\Pr[X_{5}]</span> is close to <span class="math">1/2</span>. Then we define Game 6^{′} (the “right fork”), which is another modification of Game 5, to show that <span class="math">\\Pr[F_{5}^{\\prime}]</span> is small.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">Game 6</h3>

    <p class="text-gray-300">Game 6 is the same as Game 5, except that we change line I5, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I5: <span class="math">(k^{<em>},K^{</em>})\\stackrel{{\\scriptstyle\\epsilon}}{{\\leftarrow}}</span> “keys”</li>

    </ul>

    <p class="text-gray-300">That is, we simply generate the keys <span class="math">k^{<em>}</span> and <span class="math">K^{</em>}</span> at random.</p>

    <p class="text-gray-300">Observe that in Game 5, <span class="math">v^{*}</span> is completely random, and is not used anywhere, except once as an input to KDF. Based on this, it is easy to see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{5}]-\\Pr[X_{6}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\rm kdf},$ (9)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\rm kdf}</span> is the advantage with which one can distinguish the output of the KDF from a random key pair, using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon_{\\rm kdf}</span> is negligible.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">Game 7</h3>

    <p class="text-gray-300">Game 7 is the same as Game 6, except that we change line D06, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>D06: return “reject”</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">F_{7}</span> be the event that line D06 is ever executed in Game 7, in any decryption request. Clearly, Game 6 and Game 7 proceed identically until <span class="math">F_{7}</span> occurs; in particular, the events <span class="math">X_{6}\\wedge\\neg F_{7}</span> and <span class="math">X_{7}\\wedge\\neg F_{7}</span> are the same, and so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{6}]-\\Pr[X_{7}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[F_{7}].$ (10)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if <span class="math">F_{7}</span> occurs the adversary has effectively broken the message authentication code keyed by <span class="math">k^{*}</span> (which in Game 7 is truly random). More precisely,</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{7}]\\leq Q\\epsilon_{\\rm mac},</span> (11)</p>

    <p class="text-gray-300"><span class="math">\\epsilon_{\\rm mac}</span> is the advantage with which one can break the message authentication code using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon_{\\rm mac}</span> is negligible. The factor of <span class="math">Q</span> in (11) comes from a standard “plug and pray” argument: the forging algorithm has to choose one of the pairs <span class="math">(e^{(i)},t^{(i)})</span> at random, and hope that it is actually a forgery pair.</p>

    <p class="text-gray-300">Also, observe that the key <span class="math">K^{*}</span> in Game 7 is truly random and is used for no other purpose that to encrypt <span class="math">m_{b}</span>. Based on this, it is easy to see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{7}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon_{\\rm enc},$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon_{\\rm enc}</span> is the probability of breaking the semantic security of the underlying symmetric key encryption scheme, using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon_{\\rm enc}</span> is negligible.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">Game 6^{′}</h3>

    <p class="text-gray-300">We now backtrack to the fork in the road. Game 6^{′} is the same as Game 5, except that we change line D09, as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>D09: <span class="math">(k^{(i)},K^{(i)})\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\mbox{\\tiny</span>\\scriptstyle 4<span class="math">}}}}{{{\\scriptstyle\\sim}}}</span> “keys”</li>

    </ul>

    <p class="text-gray-300">Define <span class="math">F^{\\prime}_{6^{\\prime}}</span> to be the event that line D11 is executed in the <span class="math">j</span>th decryption request in Game 6^{′}. Observe that at line D08 in Game 5, the value <span class="math">v^{(j)}</span> is completely random, and is not used anywhere, except once as an input to KDF. Based on this, it is easy to see that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[F^{\\prime}_{5}]-\\Pr[F^{\\prime}_{6^{\\prime}}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\epsilon^{\\prime}_{\\rm kdf},$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\epsilon^{\\prime}_{\\rm kdf}</span> is the advantage with which one can distinguish the output of the KDF from a random key pair, using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon^{\\prime}_{\\rm kdf}</span> is negligible.</p>

    <p class="text-gray-300">Observe that in Game 6^{′}, the key <span class="math">k^{(j)}</span> used in the message authentication code at line D10 is completely random. From this, it easily follows that</p>

    <p class="text-gray-300"><span class="math">\\Pr[F^{\\prime}_{6^{\\prime}}]\\leq\\epsilon^{\\prime}_{\\rm mac},</span> (14)</p>

    <p class="text-gray-300">where <span class="math">\\epsilon^{\\prime}_{\\rm mac}</span> is the probability of breaking the message authentication code, using resources similar to those of the given adversary. By assumption, <span class="math">\\epsilon^{\\prime}_{\\rm mac}</span> is negligible. Indeed, <span class="math">\\epsilon^{\\prime}_{\\rm mac}</span> is the probability of breaking the message authentication code “blind” (without first obtaining one valid tag).</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">Completing the proof</h3>

    <p class="text-gray-300">We have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{4}]</span> <span class="math">\\leq Q\\Pr[F^{\\prime}_{4}]</span> <span class="math">[\\text{by (6)}]</span> <span class="math">=Q\\Pr[F^{\\prime}_{5}]</span> <span class="math">[\\text{by (8)}]</span> <span class="math">\\leq Q(\\Pr[F^{\\prime}_{6^{\\prime}}]+\\epsilon^{\\prime}_{\\rm kdf})</span> <span class="math">[\\text{by (13)}]</span> <span class="math">\\leq Q(\\epsilon^{\\prime}_{\\rm mac}+\\epsilon^{\\prime}_{\\rm kdf})</span> <span class="math">[\\text{by (14)}]</span></p>

    <p class="text-gray-300">Thus, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr[F_{4}]\\leq Q(\\epsilon_{\\rm mac}^{\\prime}+\\epsilon_{\\rm kdf}^{\\prime}).</span> (15)</p>

    <p class="text-gray-300">Finally, combining (15) with (1), (2), (3), (4), (5), (7), (9), (10), (11), and (12), we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[X_{0}]-1/2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{\\rm tcr}+\\epsilon_{\\rm ddh}+\\epsilon_{\\rm kdf}+\\epsilon_{\\rm enc}+Q(\\epsilon_{\\rm mac}+\\epsilon_{\\rm mac}^{\\prime}+\\epsilon_{\\rm kdf}^{\\prime}).$ (16)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By assumption, the right-hand side of (16) is negligible, which finishes the proof.</p>

    <h2 id="sec-10" class="text-2xl font-bold">4 Hash Proof Systems</h2>

    <p class="text-gray-300">In <em>[2]</em> Cramer and Shoup showed that their original scheme in <em>[1]</em> was a special instance of a generic paradigm based on <em>hash proof systems</em>. We briefly recall here the basic ideas and how they can be applied to the scheme described in the previous section.</p>

    <p class="text-gray-300">Smooth projective hashing <em>[2]</em>: Let <span class="math">X</span> be a set and <span class="math">L\\subset X</span> a language. Loosely speaking, a hash function <span class="math">H_{a}</span> that maps <span class="math">X</span> to some set is projective if there exists a projection key that defines the action of <span class="math">H_{a}</span> over the subset <span class="math">L</span> of the domain <span class="math">X</span>. That is, there exists a projection function <span class="math">\\alpha(\\cdot)</span> that maps keys <span class="math">k</span> into their projections <span class="math">s=\\alpha(a)</span>. The projection key <span class="math">s</span> is such that for every <span class="math">x\\in L</span> it holds that the value of <span class="math">H_{a}(x)</span> is uniquely determined by <span class="math">s</span> and <span class="math">x</span>. In contrast, nothing is guaranteed for <span class="math">x\\not\\in L</span>, and it may not be possible to compute <span class="math">H_{a}(x)</span> from <span class="math">s</span> and <span class="math">x</span>. A smooth projective hash function has the additional property that for <span class="math">x\\notin L</span>, the projection key <span class="math">s</span> actually says <em>nothing</em> about the value of <span class="math">H_{a}(x)</span>. More specifically, given <span class="math">x</span> and <span class="math">s=\\alpha(a)</span>, the value <span class="math">H_{a}(x)</span> is uniformly distributed (or statistically close) to a random element in the range of <span class="math">H_{a}</span>.</p>

    <p class="text-gray-300">An interesting feature of smooth projective hashing is that if <span class="math">L</span> is an NP-language, then for every <span class="math">x\\in L</span> it is possible to efficiently compute <span class="math">H_{a}(x)</span> using the projection key <span class="math">s=\\alpha(a)</span> and a witness of the fact that <span class="math">x\\in L</span>. Alternatively, given <span class="math">a</span> itself, it is possible to efficiently compute <span class="math">H_{a}(x)</span> even without knowing a witness.</p>

    <p class="text-gray-300">Using the techniques from <em>[2]</em>, Kurosawa and Desmedt in <em>[5]</em> generalize the above scheme can be generalized using smooth projective hashing as follows. The sets <span class="math">X,L</span> and a projection key <span class="math">s=\\alpha(a)</span> will be the public key. The key <span class="math">a</span> will be the secret key.</p>

    <p class="text-gray-300">To encrypt <span class="math">m</span>, the sender chooses an element <span class="math">x\\in L</span> together with a witness. He then computes <span class="math">v=H_{a}(x)</span> using the projection <span class="math">s</span> and the witness. Then the keys <span class="math">(k,K)=KDF(v)</span> are derived as above. The rest of the encryption procedure remains the same, i.e., <span class="math">e=E_{K}(m)</span> and <span class="math">t=MAC_{k}(e)</span>. The ciphertext is <span class="math">x,e,t</span>.</p>

    <p class="text-gray-300">The receiver on input <span class="math">(x,e,t)</span> computes <span class="math">v^{\\prime}=H_{a}(x)</span> and <span class="math">(k,K)=KDF(v^{\\prime})</span>. If <span class="math">t=MAC_{k}(e)</span> then it decrypts <span class="math">m=D_{K}(e)</span>.</p>

    <p class="text-gray-300">Security Analysis. As in the proof in <em>[2]</em> the basic computational assumption underlying the security of this scheme is that it is hard to distinguish between random elements in <span class="math">L</span> and random elements outside of <span class="math">L</span>.</p>

    <p class="text-gray-300">The proof of security in <em>[5]</em> requires the projective hash function to be <em>strongly 2-universal</em>, which is a stronger condition than smoothness. Basically it is required that for <span class="math">x\\notin L</span>, even given <span class="math">s=\\alpha(a)</span> <em>and the value <span class="math">H_{a}(x^{\\prime})</span> for <span class="math">x^{\\prime}\\notin L</span> and <span class="math">x^{\\prime}\\neq x</span></em>, the distribution of the value <span class="math">H_{a}(x)</span> is statistically close to the uniform distribution over the range of <span class="math">H_{a}</span></p>

    <p class="text-gray-300">Their generalized scheme, however, still requires information-theoretically secure KDF and <span class="math">MAC</span> functions.</p>

    <p class="text-gray-300">Our proof, which lifts such requirements on the KDF and <span class="math">MAC</span> functions, also generalizes assuming strong 2-universal projective hashing, that one can efficiently sample elements outside of <span class="math">L</span>, and there is a trapdoor that allows for efficiently testing language membership.</p>

    <h2 id="sec-11" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] R. Cramer and V. Shoup. A practical public key cryptosystem provably secure against adaptive chosen ciphertext attack. In CRYPTO’98.</li>

      <li>[2] R. Cramer and V. Shoup. Universal hash proofs and a paradigm for chosen ciphertext secure public key encryption. In EuroCrypt’02.</li>

      <li>[3] R. Cramer and V. Shoup. Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM Journal of Computing 33:167-226, 2003</li>

      <li>[4] D. Dolev, C. Dwork, and M. Naor. Non-malleable cryptography. In STOC’91, pages 542–552, 1991.</li>

      <li>[5] K. Kurosawa and Y. Desmedt. A New Paradigm of Hybrid Encryption Scheme. In CRYPTO’04.</li>

      <li>[6] M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen ciphertext attacks. In STOC’90.</li>

      <li>[7] C. Rackoff and D. Simon. Noninteractive zero-knowledge proof of knowledge and chosen ciphertext attack. In CRYPTO’91.</li>

      <li>[8] V. Shoup Using hash functions as a hedge against chosen ciphertext attack. In EuroCrypt’00.</li>

    </ul>

    <h2 id="sec-12" class="text-2xl font-bold">Appendix A The original scheme</h2>

    <p class="text-gray-300">The Cramer-Shoup hybrid encryption scheme proposed in <em>[1]</em>, and refined in <em>[8]</em>, uses the same tools as the one described above. However key generation, encryption and decryption algorithms are different.</p>

    <p class="text-gray-300">Key Generation: The description of the group <span class="math">G</span> is generated, along with a random generator <span class="math">g_{1}</span> for <span class="math">G</span>. Any keys for KDF and <span class="math">H</span> are also generated. Then:</p>

    <p class="text-gray-300"><span class="math">w,x,y,z\\stackrel{{\\scriptstyle\\scriptscriptstyle{\\delta}}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ g_{2}\\leftarrow g_{1}^{w},\\ c\\leftarrow g_{1}^{x},\\ d\\leftarrow g_{1}^{y},\\ h\\leftarrow g_{1}^{z}.</span></p>

    <p class="text-gray-300">The public key consists of the description of <span class="math">G</span>, the generators <span class="math">g_{1}</span> and <span class="math">g_{2}</span>, keys for KDF and <span class="math">H</span> (if any), along with the group elements <span class="math">c,d,h</span>. The private key consists of the public key, along with <span class="math">w,x,y,z</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Encryption of <span class="math">m\\in\\{0,1\\}^{*}</span>:</h6>

    <p class="text-gray-300"><span class="math">r\\stackrel{{\\scriptstyle\\scriptstyle\\scriptstyle t}}}{{\\leftarrow}}\\mathbb{Z}_{q},\\ \\kappa\\leftarrow h^{r},\\ u_{1}\\leftarrow g_{1}^{r}\\in G,\\ u_{2}\\leftarrow g_{2}^{r}\\in G,\\ \\alpha\\leftarrow H(u_{1},u_{2})\\in\\mathbb{Z}_{q}</span> <span class="math">v\\leftarrow c^{r}d^{r\\alpha}\\in G,\\ (k,K)\\leftarrow KDF(\\kappa),\\ e\\leftarrow E_{K}(m),\\ t\\leftarrow MAC_{k}(e)</span> output <span class="math">C:=(u_{1},u_{2},v,e,t)</span></p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Decryption of <span class="math">C=(u_{1},u_{2},v,e,t)</span>:</h6>

    <p class="text-gray-300"><span class="math">\\alpha\\leftarrow H(u_{1},u_{2})\\in\\mathbb{Z}_{q},\\ v^{\\prime}\\leftarrow u_{1}^{x+y\\alpha}\\in G,\\ \\kappa^{\\prime}\\leftarrow u_{1}^{z},\\ (k,K)\\leftarrow KDF(\\kappa^{\\prime})</span> if <span class="math">t\\neq MAC_{k}(e)</span> or <span class="math">v^{\\prime}\\neq v</span> or <span class="math">u_{2}\\neq u_{1}^{w}</span> then reject else <span class="math">m\\leftarrow D_{K}(e)</span> output <span class="math">m</span></p>

    <p class="text-gray-300">Notice that compared to the Kurosawa-Desmedt scheme, the encryption algorithm in this scheme computes an extra exponentiation (the computation of <span class="math">\\kappa</span>) and a longer ciphertext (it includes the group element <span class="math">v</span>). However, that does not translate into a direct gain in efficiency.</p>

    <p class="text-gray-300">In the Cramer-Shoup scheme we can choose the prime <span class="math">q</span> to be 160-bit long. This results in a random value <span class="math">\\kappa</span> which is computationally indistinguishable from a random group element. Then, under a suitable computational assumption on KDF, we can derive keys <span class="math">k,K</span> of any required length using a pseudo-random number generator.</p>

    <p class="text-gray-300">On the other hand, the key <span class="math">k</span> in the Kurosawa-Desmedt scheme must be derived from <span class="math">v</span> in an information-theoretic way. We can’t apply a pseudo-random number generator, otherwise we lose the information-theoretic security. For common security parameters <span class="math">k</span> is required to be at least 170-bits long. The only way we know how to do this is to map <span class="math">v</span> into an 160-bit string using universal hashing and the Entropy Smoothing Theorem. But this requires <span class="math">v</span> to come from a distribution with min-entropy at least, say, 320. Considering that from <span class="math">\\kappa</span> we also need to derive the key <span class="math">K</span> (say, another 128 bits), then it seems that the group <span class="math">G</span> must have order <span class="math">q</span> of at least about 450 bits. This increase in the security parameter clearly offsets the gain obtained by dropping one exponentiation.</p>

    <p class="text-gray-300">Using our proof, however, we can claim that the Kurosawa-Desmedt scheme can be used with a group <span class="math">G</span> of order <span class="math">q</span> where <span class="math">q</span> is a 160-bit prime.</p>

    <p class="text-gray-300">We also note that the scheme in <em>[8]</em> is optimized so that all exponentiations in the decryption algorithm are with respect to the same base — this allows for speedups using techniques for exponentiation with preprocessing. We believe that similar optimizations can be applied to the Kurosawa-Desmedt scheme. Also, the scheme in <em>[8]</em> can be proven secure in the random oracle model under the computational Diffie-Hellman assumption — we believe that the same can be proven for the Kurosawa-Desmedt scheme.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="A Note on An Encryption Scheme of Kurosawa and Desmedt (2004/194)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/194
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
