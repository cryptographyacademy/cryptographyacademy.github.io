---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1542';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves (ECFFT part II)';
const AUTHORS_HTML = 'Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, David Levit';

const CONTENT = `    <p class="text-gray-300">Eli Ben–Sasson^{1}[0000-0002-0708-0483], Dan Carmon^{1}[0000-0001-9952-5947], Swastik Kopparty^{2}[0000-0003-2704-8808], and David Levit^{1}[0000-0001-6334-3738]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Concretely efficient interactive oracle proofs (IOPs) are of interest due to their applications to scaling blockchains, their minimal security assumptions, and their potential future-proof resistance to quantum attacks.</p>

    <p class="text-gray-300">Scalable IOPs, in which prover time scales quasilinearly with the computation size and verifier time scales poly-logarithmically with it, have been known to exist thus far only over a set of finite fields of negligible density, namely, over “FFT-friendly” fields that contain a sub-group of size <span class="math">2^{k}</span>.</p>

    <p class="text-gray-300">Our main result is to show that scalable IOPs can be constructed over <em>any</em> sufficiently large finite field, of size that is at least quadratic in the length of computation whose integrity is proved by the IOP. This result has practical applications as well, because it reduces the proving and verification complexity of cryptographic statements that are naturally stated over pre-defined finite fields which are not “FFT-friendly”.</p>

    <p class="text-gray-300">Prior state-of-the-art scalable IOPs relied heavily on arithmetization via univariate polynomials and Reed–Solomon codes over FFT-friendly fields. To prove our main result and extend scalability to all large finite fields, we generalize the prior techniques and use new algebraic geometry codes evaluated on sub-groups of elliptic curves (elliptic curve codes).</p>

    <p class="text-gray-300">We also show a new arithmetization scheme that uses the rich and well-understood group structure of elliptic curves to reduce statements of computational integrity to other statements about the proximity of functions evaluated on the elliptic curve to the new family of elliptic curve codes.</p>

    <p class="text-gray-300">This paper continues our recent work <em>[9]</em> that used elliptic curves and their subgroups to create FFT-based algorithms for polynomial manipulation over generic finite fields. However, our new IOP constructions force us to use new codes (ones that are not based on polynomials), and this poses a new set of challenges involving the more restricted automorphism group of these codes, and the constraints of Riemann–Roch spaces of strictly positive genus.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Arithmetization was first used to construct interactive proofs in the seminal work of Lund et al. <em>[47]</em> and shortly after played a key role in Shamir’s proof of <span class="math">\\mathsf{IP}=\\mathsf{PSPACE}</span> <em>[55]</em>. Ever since, this invaluable tool has dominated the construction of interactive proofs (<span class="math">\\mathsf{IP}</span>), multiprover interactive proofs (<span class="math">\\mathsf{MIP}</span>), zero knowledge proofs (<span class="math">\\mathsf{ZK}</span>), probabilistically checkable proofs (<span class="math">\\mathsf{PCP}</span>) and related protocols. Arithmetization reduces statements about computational integrity, like</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“I processed <span class="math">\\mathsf{T}=10,000</span> valid Ethereum transactions, leading to new Ethereum state <span class="math">S</span>”</p>
    </blockquote>

    <p class="text-gray-300">to completely different statements, about low degree polynomials over a finite field <span class="math">\\mathbb{F}</span>, like</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>“I know polynomials <span class="math">A(X),B(X)</span> over finite field <span class="math">\\mathbb{F}</span> of degree at most <span class="math">\\mathsf{T}</span> that satisfy a set of polynomial constraints”.</p>
    </blockquote>

    <p class="text-gray-300">The question studied in this paper is: Which finite fields <span class="math">\\mathbb{F}</span> can be used to create transparent, scalable and concretely efficient proof systems? We start by surveying the existing state of the art in this area.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">To reach polynomial efficiency, any large finite field suffices.</h4>

    <p class="text-gray-300">Early uses of arithmetization, for example, in the seminal proofs of (i) <span class="math">\\mathsf{MIP}=\\mathsf{NEXP}</span> <em>[5]</em>, (ii) the poly-logarithmic verification of <span class="math">\\mathsf{NP}</span> <em>[4]</em> and (iii) the PCP Theorem <em>[2, 3]</em>, all work with any sufficiently large finite field, of size at least <span class="math">\\mathsf{poly}(\\mathsf{T})</span>, where <span class="math">\\mathsf{T}</span> denotes the length of the (nondeterministic) computation whose integrity is being proved; in the case of the PCP Theorem, a field of size <span class="math">\\mathsf{polylog}(\\mathsf{T})</span> suffices. The communication complexity in all of these celebrated protocols is extremely efficient — at most poly-logarithmic in <span class="math">\\mathsf{T}</span>. However, none of these early constructions were ever deployed in practice because their proofs, although of polynomial length in <span class="math">\\mathsf{T}</span>, were of impractical size, and the arithmetic complexity of both prover and verifier were, concretely, prohibitively large.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Scalable proof systems over FFT-friendly fields.</h4>

    <p class="text-gray-300">The situation changed dramatically, in terms of both efficiency and field type, with the advent of scalable information theoretic proof systems. A proof system is called scalable when both (i) proving time scales quasilinearly in <span class="math">\\mathsf{T}</span> and, simultaneously (ii) verification time scales poly-logarithmically in <span class="math">\\mathsf{T}</span> (and polynomially in the description of the computation whose integrity is proved); see <em>[7, Definition 3.3]</em> for an exact definition. Scalable PCP systems for any language in <span class="math">\\mathsf{NEXP}</span> were presented by <em>[20, 17, 12]</em>, improving proving time from <span class="math">\\mathsf{T}^{O(1)}</span> to <span class="math">\\mathsf{T}\\operatorname{polylog}\\mathsf{T}</span>. However, these constructions</p>

    <p class="text-gray-300">limited <span class="math">\\mathbb{F}</span> to be <em>FFT-friendly</em> which means it must contain a sub-group of size <span class="math">2^{\\mathsf{k}}</span>, for integer <span class="math">\\mathsf{k}</span> (the group can be multiplicative or additive). In spite of their improved efficiency, scalable PCPs are not used in practice because the exponents in the poly-log expressions for proving and verification time, and the amortized soundness error per PCP-query, are still, practically speaking, too large.</p>

    <p class="text-gray-300">The last and final step needed to create concretely efficient proof systems for <span class="math">\\mathsf{NEXP}</span> was taken within a relatively new computational model, the interactive oracle proof (<span class="math">\\mathsf{IOP}</span>) model <em>[15, 52]</em> that generalizes both IP and PCP. From a computational complexity point of view, <span class="math">\\mathsf{IOP}=\\mathsf{MIP}=\\mathsf{PCP}=\\mathsf{NEXP}</span> (see <em>[15]</em>). Within this model, proving time was reduced to <span class="math">O(\\mathsf{T}\\log\\mathsf{T})</span> and verification time to <span class="math">O(\\log\\mathsf{T})</span>, with relatively small asymptotic constants <em>[7]</em>. The requirement that <span class="math">\\mathbb{F}</span> be an FFT-friendly field remained.</p>

    <p class="text-gray-300">To summarize, early <span class="math">\\mathsf{IP}</span>, <span class="math">\\mathsf{MIP}</span> and <span class="math">\\mathsf{PCP}</span> constructions work over any sufficiently large finite field, but <em>scalable</em> <span class="math">\\mathsf{PCP}</span>s and <span class="math">\\mathsf{IOP}</span>s required FFT-friendly ones. This raises the question of whether FFT-friendliness is needed for scalability, and sets the ground for our main result.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1 Main Results</h3>

    <p class="text-gray-300">The language most naturally suited for creating scalable IOPs is that of arithmetic intermediate representations (AIR) <em>[7, 57]</em>. Informally, an AIR instance of complexity <span class="math">m</span> and length <span class="math">\\mathsf{T}</span> is defined over a finite field <span class="math">\\mathbb{F}</span> by a set of low-degree multivariate constraints, described by arithmetic circuits whose total sum (number of gates) is <span class="math">m</span>, and by a cyclic group <span class="math">\\mathsf{D}</span> of size <span class="math">\\mathsf{T}</span> (see Definition 1). An AIR witness is a tuple of functions <span class="math">f_{1},\\ldots,f_{w}:\\mathsf{D}\\to\\mathbb{F}</span> (see Definition 4), and the AIR instance is satisfied by it if the application of the polynomial constraints to the functions <span class="math">f_{1},\\ldots,f_{w}</span> and various cyclic shifts of them satisfy the polynomial constraints of the AIR instance (see Definition 5).</p>

    <p class="text-gray-300">From a concrete complexity point of view, the language of AIRs is used to define computational integrity statements for scalable and transparent argument of knowledge (STARK) systems, directly for specific computations like hashing with ethSTARK <em>[57]</em>, for domain specific languages like Winterfell, and for universal (Turing complete) virtual machines like Cairo <em>[36]</em>. In all these cases, the computations and virtual machines are specified by AIRs. Systems written over these machines, like StarkEx, have been used to process millions of transactions and billions of dollars on Ethereum, underscoring their practical relevance.</p>

    <p class="text-gray-300">From an asymptotic complexity point of view, the language of satisfiable AIR instances is complete for <span class="math">\\mathsf{NEXP}</span>. When restricting AIR to FFT-friendly fields, the ensuing sub-language (FFT-friendly-AIR) remains <span class="math">\\mathsf{NEXP}</span>-complete. As mentioned earlier, prior to this work, it was known that the language of</p>

    <p class="text-gray-300">FFT-friendly-AIR has a <em>strictly</em> scalable and transparent IOP <em>[7]</em>. By strictly scalable we mean that (i) prover complexity is <span class="math">\\mathsf{T}\\cdot(O(\\log\\mathsf{T})+\\mathsf{poly}(m))</span> and, simultaneously, (ii) verifier complexity is <span class="math">O(\\log\\mathsf{T})+\\mathsf{poly}(m)</span>, i.e., the exponents in all polylog expressions are 1.</p>

    <p class="text-gray-300">The main result of this paper is to remove the FFT-friendly requirement about fields, leading to the following statement.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (Main Theorem — Informal).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any finite field <span class="math">\\mathbb{F}</span> and $\\mathsf{T}\\leq\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, the satisfiability of AIR instances over </span>\\mathbb{F}<span class="math"> of size </span>m<span class="math"> and computation length at most </span>\\mathsf{T}<span class="math"> can be verified by a strictly scalable and transparent IOP of knowledge with advice. In particular, there exist randomized procedures for proving and verification that require </span>\\mathsf{T}\\cdot(O(\\log\\mathsf{T})+\\mathsf{poly}(m))<span class="math"> arithmetic operations over </span>\\mathbb{F}<span class="math"> for proving, and </span>\\lambda\\cdot(O(\\log\\mathsf{T})+\\mathsf{poly}(m))<span class="math"> arithmetic operations over </span>\\mathbb{F}<span class="math"> for verification with knowledge soundness error at most </span>2^{-\\lambda}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We point out that our results apply to other NEXP complete languages for succinct IOPs, such as the succinct R1CS systems used in <em>[14]</em>; due to the concrete considerations mentioned above, as well as space limitations, we focus only on AIR.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Remark 1 (Zero Knowledge).</h6>

    <p class="text-gray-300">The construction used in Theorem 1 can be augmented to achieve perfect zero knowledge, just like the FFT-friendly version of it (Theorem 3) can be augmented to an IOP with perfect zero knowledge <em>[10]</em>. We omit the addition of zero knowledge from this version due to space considerations.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Remark 2 (Post-quantum security).</h6>

    <p class="text-gray-300">A number of works have shown that applying the Kilian-Micali and/or the BCS transformation from IOPs to noninteractive arguments are secure in the quantum random oracle model, and these generic transformations apply to all our results, rendering them post-quantum secure in this model <em>[29, 28, 27]</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Fast IOPs of Proximity for Reed–Solomon and Elliptic Curve codes</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A major step, and bottleneck, in the construction of IOPs and PCPs is that of low-degree testing. This is the sub-protocol that is given oracle access to a function <span class="math">f:\\mathsf{D}^{\\prime}\\to\\mathbb{F}</span> and is charged with distinguishing between the case that <span class="math">f</span> is a low-degree polynomial, i.e., a Reed–Solomon (RS) codeword, and the case that <span class="math">f</span> is far, in Hamming distance, from the RS code. Strictly scalable IOPs use the Fast RS IOPP (FRI) <em>[6]</em> protocol targeted for RS codes. For a function of blocklength $n=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the FRI protocol guarantees linear proving time (</span>O(n)<span class="math"> arithmetic operations), strictly logarithmic verification time and query complexity (</span>O(\\lambda\\log n)<span class="math"> arithmetic operations, to reduce the soundness error to </span>2^{-\\lambda}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">One of the main reasons that until now scalable IOPs were limited to FFT-friendly fields was the fact that the FRI protocol is tightly related to the FFT</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">algorithm, and can be described as “randomly folding” an FFT. As part of our proof of Theorem 1 we also extend the FRI protocol from <em>[6]</em>, and its analysis from <em>[8]</em>, to hold over all fields, provided $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\Omega(n^{2})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 2 (FRI over all fields, informal).</h6>

    <p class="text-gray-300">For any finite field <span class="math">\\mathbb{F}</span> of size <span class="math">q</span>, integer <span class="math">n</span> a power of <span class="math">2</span> satisfying <span class="math">n\\leq\\sqrt{q}</span>, integer <span class="math">t</span> and integer <span class="math">\\mathcal{R}</span>, the following holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists a subset $\\mathsf{D}^{\\prime}\\subseteq\\mathbb{F},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{D}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">, such that the family of RS codes of rate </span>\\rho=2^{-\\mathcal{R}}<span class="math"> evaluated over </span>\\mathsf{D}^{\\prime}$ has an IOP of proximity with:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">O(n)</span> proving complexity,</li>

      <li><span class="math">O(t\\cdot\\log n)</span> verification complexity,</li>

      <li><span class="math">t\\cdot\\log n</span> query complexity,</li>

      <li>the following soundness behavior: if <span class="math">f</span> is <span class="math">\\delta</span>-far in Hamming distance from the code, the probability that <span class="math">f</span> is accepted by the protocol is at most</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\left(\\max\\left\\{(1-\\delta),\\sqrt{\\rho}\\right\\}-o(1)\\right)^{t}.</span></p>

    <p class="text-gray-300">See Section 2.3 for more details and a formal statement of the result above.</p>

    <p class="text-gray-300">We point out that we also obtain (and need, to prove Theorem 1) an IOPP for a more general family of codes – which comprises evaluations of functions over certain carefully selected points on an elliptic curve <span class="math">E</span>; the points of evaluation are cosets of a cyclic group of size <span class="math">2^{\\text{k}}</span> inside the elliptic curve group. We call this protocol an <em>elliptic curve</em> FRI, abbreviated EC-FRI, because the IOPP for this family of elliptic curve codes works by “decomposing” a function on the elliptic curve into a pair of RS codewords and applying Theorem 2 to this pair. See Section 6.3 for details.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Applications to concrete scalability</h4>

    <p class="text-gray-300">We briefly argue why Theorem 1 is interesting from the point of view of concrete (rather than asymptotic) complexity, in applied cryptography settings. There are quite a few cryptographic primitives used in practice that are naturally defined over specific, and non-FFT-friendly, finite fields. Examples include the NIST Curve P-256 (used, e.g., on Apple smartphones) and the secp256k1 curve (used for Bitcoin signatures), both of which are prime, non-FFT-friendly, fields. Consider a prover attempting to prove she processed correctly a large batch of ECDSA signatures over either one of these primes, denoting it by <span class="math">p</span>. Today, the prover would need to arithmetize her statement over some FFT-friendly field, and thus simulate the basic arithmetic operations of the (non-FFT friendly) field <span class="math">\\mathbb{F}_{p}</span> over some other field <span class="math">\\mathbb{F}_{q}</span>, resulting in significant overhead. For example, the implementation of secp256k1 and NIST P-256 ECDSA in the Cairo programming language (which uses an IOP-based</p>

    <p class="text-gray-300">STARK over a 254-bit, FFT-friendly, prime field <span class="math">\\mathbb{F}_{q}</span>) requires roughly 128 arithmetic operations over <span class="math">\\mathbb{F}_{q}</span> to simulate a single <span class="math">\\mathbb{F}_{p}</span> multiplication (this implementation uses various optimizations, the naive bit-wise multiplication would be far costlier).</p>

    <p class="text-gray-300">Using the construction of Theorem 1 one may do better. The statement for each of these curves could be constructed over the native prime field <span class="math">\\mathbb{F}_{p}</span>, meaning that each multiplication gate in the computation of the ECDSA “costs” only one constraint, and addition comes for free. When computing the tradeoff between using an FFT-friendly field <span class="math">\\mathbb{F}_{q}</span> or our new construction over <span class="math">\\mathbb{F}_{p}</span>, one should carefully measure the difference resulting from the new construction (which, as explained later, involves elliptic curves rather than plain polynomials). We leave this interesting question for future work, but speculate that in most cases the new <span class="math">\\mathbb{F}_{p}</span>-native constructions will be far better, in terms of prover time, verifier time, and proof length, than arithmetization over a different, yet FFT-friendly, field.</p>

    <p class="text-gray-300">Next we discuss the four parts in which FFT-friendliness was demanded in prior scalable systems, and then explain how we get rid of this requirement.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.2 Why do PCPs and IOPs require FFT-friendliness?</h3>

    <p class="text-gray-300">The very first step taken by a scalable PCP/IOP prover, when writing a proof for the integrity of a computation of length <span class="math">\\mathsf{T}</span>, is typically to view the execution trace of the computation as a series of functions <span class="math">f_{1},\\ldots,f_{w}:\\mathsf{D}\\to\\mathbb{F}</span> for some evaluation domain <span class="math">\\mathsf{D}\\subset\\mathbb{F},\\lvert\\mathsf{D}\\rvert=\\mathsf{T}</span>, and then compute the low degree extension of each <span class="math">f_{i}</span> by first interpolating the polynomial <span class="math">P_{i}(X),\\deg(P_{i})&lt;\\mathsf{T}</span> that agrees with <span class="math">f_{i}</span>, and then evaluating <span class="math">P_{1},\\ldots,P_{w}</span> on a larger domain <span class="math">\\mathsf{D}^{\\prime}\\subset\\mathbb{F},\\lvert\\mathsf{D}^{\\prime}\\rvert\\gg\\lvert\\mathsf{D}\\rvert</span>, leading to a new sequence <span class="math">f_{1}^{\\prime},\\ldots,f_{w}^{\\prime}:\\mathsf{D}^{\\prime}\\to\\mathbb{F}</span> that are submitted to the verifier as the very first part of the PCP/IOP. The four reasons <span class="math">\\mathsf{D}</span> needs to be a cyclic group of size <span class="math">2^{\\mathsf{k}}</span> are explained next. If we wish to create scalable IOPs over all fields, including ones that do not contain such groups, we shall need to find other ways to achieve these properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Super-efficient Reed–Solomon encoding: The main asymptotic bottleneck of scalable IOPs on the prover side is the computation of the low degree extensions of <span class="math">f_{1},\\ldots,f_{w}</span> from <span class="math">\\mathsf{D}</span> to <span class="math">\\mathsf{D}^{\\prime}</span>. When <span class="math">\\mathsf{D}</span> is a subgroup of size <span class="math">2^{\\mathsf{k}}</span> and <span class="math">\\mathsf{D}^{\\prime}</span> is a finite union of cosets of <span class="math">\\mathsf{D}</span>, as used in all scalable PCP/IOP constructions, the classical FFT algorithm can be used to solve the encoding problem in time <span class="math">O(w\\mathsf{T}\\log\\mathsf{T})</span>; the asymptotic constants hidden by <span class="math">O</span>-notation are rather small, which helps for concrete prover efficiency.</li>

      <li>Codewords are invariant to cyclic shifts: The algebraic constraints in AIRs over the trace involve elements from previous timesteps, which correspond to evaluations of <span class="math">f_{1}^{\\prime},\\ldots,f_{w}^{\\prime}</span> at translated arguments. Thus we need work not only with the codewords <span class="math">f_{1}^{\\prime},\\ldots,f_{w}^{\\prime}</span>, but with words obtained by cyclic shifts of their values (where the cyclic order is determined by the indexing of the trace’s elements by <span class="math">\\mathsf{D}</span>). To control the degree of the evaluated</li>

    </ul>

    <p class="text-gray-300">constraints, it is necessary to know that these shifted words are also evaluations of polynomials of degree <span class="math">&lt;\\mathsf{T}</span>, i.e. codewords. This is indeed the case when <span class="math">\\mathsf{D}</span> is a cyclic group generated by <span class="math">\\mathsf{g}</span>, <span class="math">\\mathsf{D}^{\\prime}</span> is a finite union of its cosets, and the rows are indexed according to the cyclic order: shifting the values of <span class="math">f^{\\prime}_{i}(x)</span> by <span class="math">t</span> yields the function <span class="math">f^{\\prime}_{i}(\\mathsf{g}^{t}x)</span>, which has the same degree as <span class="math">f^{\\prime}_{i}(x)</span> (each coset of <span class="math">\\mathsf{D}</span> undergoes the same cyclic shift).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Polylogarithmic verification requires sparse domain polynomials: To allow the verifier to check that the polynomial constraints arising out of the arithmetization reduction hold for each of the <span class="math">\\mathsf{T}</span> steps of the computation, as claimed by the prover, the verifier needs to evaluate the “vanishing polynomial” of <span class="math">\\mathsf{D}</span>, denoted <span class="math">Z_{\\mathsf{D}}(X)</span>, which is the degree-<span class="math">\\mathsf{T}</span> monic polynomial whose roots are <span class="math">\\mathsf{D}</span>, as well as polynomials that vanish on certain subsets <span class="math">D_{1},\\ldots,D_{s}\\subset\\mathsf{D}</span>, denoted <span class="math">Z_{D_{i}}(X)</span>. To facilitate scalable (polylogarithmic) verification, the verifier needs to evaluate <span class="math">Z_{\\mathsf{D}}(X),Z_{D_{1}}(X),\\ldots,Z_{D_{s}}(X)</span> all in time <span class="math">\\operatorname{polylog}\\mathsf{T}</span>. When <span class="math">\\mathsf{D}</span> is a multiplicative group of size <span class="math">\\mathsf{T}</span> we have <span class="math">Z_{\\mathsf{D}}(X)=X^{\\mathsf{T}}-1</span>. This is a sparse polynomial that can be evaluated on any <span class="math">x_{0}</span> using <span class="math">O(\\log\\mathsf{T})</span> arithmetic operations. Likewise, when <span class="math">D_{1},\\ldots,D_{s}</span> are subgroups of <span class="math">\\mathsf{D}</span> or, more generally, of “low-complexity” when expressed using subgroups (see Definition 3 for a definition of this term), then scalable (poly-logarithmic) verification is possible.</li>

      <li>Low-degree testing: Soundness of scalable PCPs/IOPs requires a protocol designed to verify that each of the functions <span class="math">f^{\\prime}_{1},\\ldots,f^{\\prime}_{w}:\\mathsf{D}^{\\prime}\\to\\mathbb{F}</span> submitted by the prover is an RS codeword (or is close to it in Hamming distance). All scalable protocols — from the quasilinear RS-PCP of Proximity (PCPP) of <em>[20]</em> to the linear Fast RS IOP of Proximity (IOPP) protocol of <em>[6]</em> (abbreviated as FRI) — rely on the FFT-friendly structure of the domain <span class="math">\\mathsf{D}^{\\prime}</span> over which functions are evaluated. In more detail, the fact that a cyclic group of size <span class="math">2^{k}</span> has a cyclic group of size <span class="math">2^{k-1}</span> as a quotient group plays a vital role in the FRI protocol.</li>

    </ul>

    <p class="text-gray-300">To summarize, there are four separate places in which FFT-friendliness is important in the construction of FRI-AIR STARK systems. RS encoding requires quasilinear running time over any finite field but the best asymptotic running time is obtained over multiplicative groups of order <span class="math">2^{k}</span>, i.e., within FFT-friendly fields. Expressing general constraints requires the RS codewords to be invariant to cyclic shifts, which occurs when the domain is itself a cyclic group. Scalable (poly-logarithmic) verification requires an evaluation domain that is represented by a sparse polynomial, and any multiplicative subgroup could be used. Finally, the low-degree testing protocol that lies at the heart of scalable PCP/IOP constructions requires an FFT-friendly domain.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.3 Elliptic curves save the day, again</h3>

    <p class="text-gray-300">The virtues of elliptic curves in cryptography, computer science and mathematics are well established <em>[56, 59, 44]</em>. Here we make novel use of their properties — to create strictly scalable IOPs over any sufficiently large finite field, with</p>

    <p class="text-gray-300">the same asymptotic and concrete arithmetic complexity as obtained over FFT-friendly fields. A brief overview of some relevant standard facts and terms related to elliptic curves may be found in Appendix A.</p>

    <p class="text-gray-300">Our starting point is our recent work <em>[9]</em>, that showed how to use elliptic curve groups to enable an FFT-like computation over all finite fields, thus enabling fast low degree extensions. This essentially gives us (with some small modifications) the analogue of the first item from Section 1.2. Developing analogues of the remaining three items is completely new to this paper, and it requires us to dig deeper than <em>[9]</em> into the elliptic curve group structure and properties of Riemann–Roch spaces over elliptic curves.</p>

    <p class="text-gray-300">Another contribution of this paper is a randomized near-linear time algorithm for doing all the (one-time) precomputation required for the ECFFT and the EC based IOP. Additionally, in this paper we also provide a more explicit description of the curves and maps that appear in the isogeny chain, which in turn give us more explicit formulas for the FFTs themselves. This allows for easy implementation and easy determination of running time with concrete constants. See Section 4 and Section 4.3 in particular.</p>

    <p class="text-gray-300">Taking a 30,000-feet view, fix any finite field <span class="math">\\mathbb{F}</span> of size <span class="math">q</span>. The family of elliptic curves defined over <span class="math">\\mathbb{F}</span> is a family of algebraic groups whose size range and structure are well understood. Size-wise, nearly any number in the Hasse–Weil bound <span class="math">[q+1\\pm 2\\sqrt{q}]</span> is the size of some elliptic curve over <span class="math">\\mathbb{F}</span> (when <span class="math">q</span> is prime then <em>every</em> number in that range is the size of an elliptic curve). The group structure of elliptic curves is somewhat more elaborate, but suffice to say that for any size <span class="math">2^{\\mathsf{k}}</span>, there will exist some elliptic curve that contains a <em>cyclic</em> subgroup of size <span class="math">2^{\\mathsf{k}}</span>, permitted that <span class="math">2^{\\mathsf{k}}</span> is, roughly, at most <span class="math">\\sqrt{q}</span>.</p>

    <p class="text-gray-300">Based on these observations, we shall replace the multiplicative subgroup of size <span class="math">2^{\\mathsf{k}}</span> (which may not exist inside <span class="math">\\mathbb{F}_{q}^{*}</span>) with a cyclic subgroup of size <span class="math">2^{\\mathsf{k}}</span> of points of some elliptic curve <span class="math">E</span> defined over <span class="math">\\mathbb{F}_{q}</span>. Then, we shall use a novel arithmetization scheme that reduces computational problems to problems regarding “low-degree” functions defined over the points of the elliptic curve; formally, these functions will be members of a low-degree Riemann–Roch (RR) space. The choice of this Riemann–Roch space in a way that enables arithmetization is the crux of our IOP construction, and we discuss this next.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">1.0.1 Arithmetization and automorphisms</h4>

    <p class="text-gray-300">One property of polynomials (in the classical FFT-friendly field IOP setting) which is needed for efficient arithmetization is their invariance under certain linear transformations. In particular, if <span class="math">G\\subset\\mathbb{F}_{q}</span> is a multiplicative group generated by <span class="math">g</span>, and <span class="math">f:G\\to\\mathbb{F}_{q}</span> is an evaluation of a polynomial of degree <span class="math">d</span>, then <span class="math">f(g\\cdot x)</span> is also a polynomial of degree <span class="math">d</span>. In other words, the space of functions of degree at most <span class="math">d</span> is invariant under the permutation that maps <span class="math">x</span> to <span class="math">g\\cdot x</span>.</p>

    <p class="text-gray-300">Now suppose we wish to arithmetize using a cyclic group <span class="math">H</span> that is generated by a point <span class="math">h</span> on an elliptic curve (i.e, <span class="math">H</span> is a sub-group of the curve). A permutation that is natural in this context is given by <span class="math">x\\mapsto x+h</span> (where <span class="math">x,h</span> are points on the curve and <span class="math">+</span> is the curve’s group operand). We need a space of functions that are invariant under this action, and this identifies a natural candidate space – the Riemann–Roch space of functions that is supported in a symmetric way on <span class="math">H</span>, defined by the divisor <span class="math">\\sum_{z\\in H}[z]</span>.</p>

    <p class="text-gray-300">Another way of viewing this generalization is as follows. The space of polynomials of degree at most <span class="math">d</span> in the projective space <span class="math">\\mathbb{P}^{1}</span> (cf. Appendix A.1) is the Riemann–Roch space associated with the divisor <span class="math">D=d\\cdot[\\infty]</span> (see Eq. (31)), and <span class="math">D</span> is invariant under the action <span class="math">[x]\\mapsto[g\\cdot x]</span>. In the case of an elliptic curve group, <span class="math">\\infty\\neq h+\\infty</span> so we cannot use <span class="math">D</span> but rather need a different divisor, one that is invariant under the mapping induced by <span class="math">h</span>. The natural divisor is <span class="math">D^{\\prime}:=\\sum_{z\\in H}[z]</span> which is clearly invariant under the action of <span class="math">h</span> because <span class="math">H</span> is cyclic.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">3.2.2 Key ingredients for the new IOPs, and the relationship to ECFFT Part I <em>[9]</em></h4>

    <p class="text-gray-300">Let us now see the elliptic curve analogues of the four ingredients that go into IOPs in FFT-friendly fields. The first of these essentially comes from <em>[9]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Super-efficient EC code encoding: This essentially comes from <em>[9]</em>. Here we generalize the results slightly to extend low-degree functions evaluated over <span class="math">\\mathsf{D}</span> to evaluations over a constant number of other cosets of <span class="math">\\mathsf{D}</span>, in time <span class="math">O(\\mathsf{T}\\log\\mathsf{T})</span> and with small concrete asymptotic constants. See Section 6.2 for details.</li>

      <li>Invariance to cyclic shifts: This is where the choice of the Riemann–Roch space is crucially used. It was specifically constructed to be invariant to translation of the argument by any element of the cyclic subgroup of size <span class="math">2^{\\mathsf{k}}</span> in <span class="math">E</span>, similarly to the case of polynomials with bounded degree. Since <span class="math">\\mathsf{D}^{\\prime}</span> is a union of cosets of the cyclic subgroup, these translations correspond to cyclic permutations of each coset in <span class="math">\\mathsf{D}^{\\prime}</span>. See Section 5.4 for details.</li>

      <li>Polylogarithmic evaluation of the “vanishing RR function” of <span class="math">\\mathsf{D}</span>: The verifier now needs to evaluate “low-degree” “vanishing RR functions” (the analogue of a vanishing polynomial in the Riemann–Roch space) <span class="math">\\tilde{Z}_{\\mathsf{D}}(P)</span> on an arbitrary point <span class="math">P=(x_{0},y_{0})</span> of <span class="math">E</span>, where <span class="math">\\tilde{Z}_{\\mathsf{D}}</span> is the RR function that vanishes over <span class="math">\\mathsf{D}</span>. It turns out that <span class="math">\\mathsf{D}</span> can be constructed using a sequence of <span class="math">k=\\log\\mathsf{T}</span> rational functions and this implies that <span class="math">\\tilde{Z}_{\\mathsf{D}}(P)</span> is computable using <span class="math">O(\\log\\mathsf{T})</span> arithmetic operations, as before. Likewise, for subsets <span class="math">D_{1},\\ldots,D_{s}\\subset\\mathsf{D}</span> of “low complexity” (per Definition 3), the verifier can evaluate <span class="math">\\tilde{Z}_{D_{i}}(P)</span> as efficiently for subsets of elliptic curves as was the case with subsets of multiplicative groups. See section Section 7 for details.</li>

      <li>Low-degree testing: The FRI protocol can be described informally as “random folding of an FFT”. Thus, once we have obtained a generalization of the FFT algorithm to codes defined over elliptic curve groups, we also generalize the FRI protocol to verify the proximity of functions to low-degree RR functions. Details appear in Section 6.3.</li>

    </ul>

    <p class="text-gray-300">1.4 Related work</p>

    <p class="text-gray-300">Over the past decade we have experienced a Cambrian explosion in the field of concretely efficient proof systems, with and without zero knowledge. These systems are classified under various definitions including CS proofs <em>[49]</em>, NIZKs and succinct NIZKs <em>[35]</em>, SNARGs, SNARKs, STARKs, and more. Realizations in code include Pinocchio <em>[51]</em>, C-SNARKs <em>[13]</em>, PLONK <em>[34]</em>, Halo <em>[23]</em>, Fractal <em>[29]</em>, Marlin <em>[26]</em>, Ligero <em>[1]</em>, Sonic <em>[48]</em>, Bulletproofs <em>[24]</em> and more.</p>

    <p class="text-gray-300">Nearly all of these systems involve arithmetization via polynomials (univariate and multivariate) over large fields, of size at least <span class="math">\\mathsf{poly}(\\mathsf{T})</span>, and thus when efficiency (concrete and asymptotic) is of interest, FFT-friendliness is required, along with proving time that is quasi-linear (or worse). An interesting research question, not addressed here, is whether the techniques discussed in this paper are relevant to some of these works. It seems likely to conjecture that many of the works that are information theoretically secure, like the important lines of works based on “interactive proofs for muggles” <em>[37]</em> and “MPC in the head” <em>[42]</em> may be constructed with better efficiency over general large fields, using our results.</p>

    <p class="text-gray-300">A class of concretely efficient and widely deployed ZK-SNARK systems is based on knowledge-of-exponent assumptions and bi-linear pairings, starting with the work of <em>[51]</em>. Several blockchain systems, including Zcash, Filecoin and Tornado cash use the popular and efficient Groth16 ZK-SNARK <em>[39]</em>. The use of bilinear pairings significantly limits the class of fields that can be arithmetized efficiently, requiring <span class="math">\\mathbb{F}</span> to be a prime field with small embedding degree and ruling out fields that are of prime power size. Other constructions that rely on number-theoretic assumptions but which do not require knowledge of exponent assumptions, nor bilinear pairings (e.g., BulletProofs and Halo), may be amenable to efficient constructions over non-FFT friendly, cryptographically large primes/curves (but it seems unlikely they can be amended to allow native arithmetization over fields of small characteristic).</p>

    <p class="text-gray-300">An interesting and noteworthy recent line of works gives strictly linear proving time, thereby avoiding the need for FFTs <em>[21, 22, 53, 38]</em> and large fields and offering strictly better asymptotic proving time than mentioned above. However, thus far this line of works has not produced scalable systems (per the definition above) and requires super-polylogarithmic verification time which should be performed either directly by the verifier or by a pre-processing entity trusted by it. In particular, our main results (Theorems 1 and 2) do not imply these works and vice versa.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Elliptic curves and FFT.</h4>

    <p class="text-gray-300">This work is a direct continuation of our previous paper on quasilinear time Elliptic Curve FFT <em>[9]</em> (cf. <em>[32]</em> for an earlier work on using elliptic curves to compute an FFT-like transform, as well as the discussion in <em>[9]</em> of that paper). Indeed, the sequence of isogenies used in Section 4.2 is adapted</p>

    <p class="text-gray-300">from that work, and the EC-FRI protocol of Section 6.3 relies on our FFT-like interpolation and evaluation algorithms of that work. Although we made this paper self-contained, reading our previous work should help the reader with intuition (and notation) here. See Section 1.3 for a detailed discussion of what is new in this paper in comparison to <em>[9]</em>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">1.4.2 Algebraic Geometry codes and PCPs/IOPs</h4>

    <p class="text-gray-300">A line of works used algebraic geometry codes to obtain PCPs and IOPs with extremely efficient proof length and query complexity over constant size fields <em>[18, 11]</em>. Those works are incomparable to ours because the curves there are of much higher genus, and the end results are not related to our goal of constructing scalable proof systems over any finite field.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">1.5 Outline of the rest of the paper</h3>

    <p class="text-gray-300">The next section presents the main results more formally, and Section 3 gives a self-contained proof of our main result (Section 3). This proof relies on further results discussed later, as follows. Section 4 gives an efficient procedure for selecting a “good”, i.e., “FFT-like” sequence of curves, needed for the IOP. Section 5 defines the family of elliptic curve codes used by our arithmetization, and discusses some of their properties. Section 6 presents quasi-linear algorithms for encoding (or “low-degree extending”) functions in this family of codes, and analyzes efficient IOPs of proximity for them. Section 7 defines and discusses the zero loci of elliptic curve code members that is needed to define the enforcement domains of AIR constraints. The appendix contains mathematical definitions and a more detailed analysis of the EC version of the FRI protocol (Appendices A and B, respectively).</p>

    <p class="text-gray-300">We note that Sections 4 to 7 use notations which differ slightly from the notation used in Section 3. The main reason for this is that the in-depth sections must deal not with a single curve, Riemann–Roch space etc., but with families and chains of such, and the relationships between them, due to the recursive nature of algorithms such as FFT and FRI, and the likewise recursive structure of this objects. These families require an additional level of indexation. However, to simply use FFT and FRI as done in Section 3, it is not necessary to go beyond the first layer. Thus, we are able to use a slightly simplified notation in that section.</p>

    <p class="text-gray-300">In the next section we formally state our main results. After briefly recalling some needed notation in Appendix A, we specify the needed FFT-like structure inside elliptic curves in Section 4. Section 5 defines the RS codes and elliptic curve codes — codes that are evaluations of function in a special “low-degree” Riemann–Roch space — that will be used in the construction of the EC-FRI and scalable IOP later on. Section 6 presents FFT and fast IOPPs for these classes of codes (over any finite field). Section 7 discusses a modification needed to evaluate constraints over domains that are subgroups of elliptic curve groups, as such groups (and the fact that the curve has positive genus) pose challenges</p>

    <p class="text-gray-300">that do not exist when constructing IOPs over RS codes. Finally, in Section 3 we describe the new IOP protocol and prove its soundness.</p>

    <h2 id="sec-19" class="text-2xl font-bold">2 Main results</h2>

    <p class="text-gray-300">Our main result below is a scalable and transparent IOP of knowledge (abbreviated as STIK) for the language of satisfiable AIR instances defined over any sufficiently large finite field. Thus, we start by defining this language (Definition 6). Then we state and discuss our main theorem (Theorem 4). We conclude with a statement of the auxiliary results on FRI and EC-FRI over any finite field.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">2.1 The AIR Language and Relation</h3>

    <p class="text-gray-300">We recall the definition of an AIR instance from <em>[7]</em>, using the more recent formulation in <em>[57, Section 5]</em>, generalizing it slightly by using an abstract cyclic group instead of a multiplicative group of a finite field. As shown in that paper, this language, even when restricted to FFT-friendly fields, is NEXP-complete. We start with the notion of an AIR instance.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 1 (AIR Instance).</h6>

    <p class="text-gray-300">An Algebraic Intermediate Representation (AIR) instance is a tuple <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H}_{0},\\mathsf{g},\\mathsf{l},\\mathsf{Cset})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a finite field</li>

      <li><span class="math">\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s}</span> are integers indicating the following sizes:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{w}</span> is the number of columns in the trace</li>

      <li><span class="math">\\mathsf{h}</span> denotes the logarithm of the size of the trace domain</li>

      <li><span class="math">\\mathsf{d}</span> is the maximal degree of a constraint</li>

      <li><span class="math">\\mathsf{s}</span> is the size of the set of constraints</li>

      <li><span class="math">\\mathsf{H}_{0}</span> is a cyclic group of size <span class="math">2^{\\mathsf{h}}</span>, and <span class="math">\\mathsf{g}</span> is a generator of it. We write <span class="math">\\mathsf{H}_{0}</span> multiplicatively, so that <span class="math">\\mathsf{g}^{j}\\cdot y</span> means applying <span class="math">\\mathsf{g}^{j}</span> (the <span class="math">j</span>-length cyclic shift) to <span class="math">y</span>. We call <span class="math">\\mathsf{H}_{0}</span> the <em>trace domain</em>.</li>

      <li><span class="math">\\mathsf{I}\\subseteq\\{0,1,\\ldots,2^{\\mathsf{h}}-1\\}\\times\\{1,\\ldots,\\mathsf{w}\\}</span> is a set of pairs known as the set of <em>mask indices</em>. Let <span class="math">\\mathsf{Z}=\\{\\mathsf{Z}_{j,l}:(j,l)\\in\\mathsf{I}\\}</span> be a set of formal variables, called the <em>mask variables</em>, indexed by elements of <span class="math">\\mathsf{I}</span>.</li>

      <li><span class="math">\\mathsf{Cset}=\\{\\mathsf{C}_{1},\\ldots,\\mathsf{C}_{\\mathsf{s}}\\}</span> is a finite set of constraints, of size <span class="math">\\mathsf{s}</span>. Each constraint is an ordered pair <span class="math">\\mathsf{C}_{\\alpha}=(\\mathsf{Q}_{\\alpha},\\mathsf{H}_{\\alpha})</span> where:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Q}_{\\alpha}\\in\\mathbb{F}^{\\leq\\mathsf{d}}[\\mathsf{Z}]</span> is a multivariate polynomial over the mask variables, of total degree at most <span class="math">\\mathsf{d}</span>, called the <span class="math">\\alpha</span>-th constraint polynomial.</li>

      <li><span class="math">\\mathsf{H}_{\\alpha}\\subseteq\\mathsf{H}_{0}</span> is a subset of the group, called the <span class="math">\\alpha</span>-th constraint enforcement domain.</li>

    </ul>

    <p class="text-gray-300">The kind of result we will show is that the language of satisfiable AIRs over every field has an efficient IOPP. The efficiency will be in terms of the complexity of the constraints of the AIR, which we define next. Informally, the complexity of the AIR constraints depend on two things. The first is the circuit complexity of individual constraints, defined first (Definition 2). The second, less trivial, component, is the specification of the domain on which different constraints must be enforced (Definition 3).</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 2 (Complexity of Constraints of an AIR).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an AIR <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H}_{0},\\mathsf{g},\\mathsf{I},\\mathsf{Cset})</span>, we define the complexity of the constraints of <span class="math">\\mathsf{A}</span>, denoted $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">:=\\sum_{\\alpha=1}^{\\mathsf{s}}(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Q}_{\\alpha}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{\\alpha}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Q}_{\\alpha}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the arithmetic complexity of the circuit computing the polynomial </span>\\mathsf{Q}_{\\alpha}<span class="math">, and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{\\alpha}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the coset complexity of </span>\\mathsf{H}_{\\alpha}$ (see definition below).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As motivation for the following definition, consider a linear computation in which a constraint should be applied only to half of the timesteps. Informally, a constraint applied periodically, every other step (on even-numbered time steps) has lower complexity than a constraint that should be applied to a randomly selected set of time steps. We define the set of relevant time steps using polynomials and rational functions, and it turns out the the following measure is an upper bound on their complexity as arithmetic circuits.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 3 (Coset Complexity).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a subset <span class="math">S</span> of a finite group <span class="math">H</span>, we define the coset complexity of <span class="math">S</span>, denoted $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, to be the smallest value of</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sum_{i}(\\log_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+1),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">over all ways of writing the indicator function <span class="math">\\mathbf{1}_{S}</span> of <span class="math">S</span> as a signed sum of indicator functions:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{1}_{S}=\\sum_{i}\\epsilon_{i}\\cdot\\mathbf{1}_{J_{i}},</span></p>

    <p class="text-gray-300">where each <span class="math">J_{i}</span> is a coset of a subgroup of <span class="math">H</span> and <span class="math">\\epsilon_{i}=\\pm 1</span>.</p>

    <p class="text-gray-300">Next, we recall the definition of an AIR witness.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 4 (AIR witness and composition).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An AIR witness is a sequence of functions <span class="math">\\vec{\\mathsf{f}}=(\\mathsf{f}_{1},\\ldots,\\mathsf{f}_{\\mathsf{w}})</span>, where each <span class="math">\\mathsf{f}_{l}</span> is a function from <span class="math">\\mathsf{H}_{0}</span> to <span class="math">\\mathbb{F}</span>. The <em>witness size</em> is $\\mathsf{w}\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given an AIR constraint polynomial <span class="math">\\mathsf{Q}\\in\\mathbb{F}[\\mathsf{Z}]</span>, the <em>composition</em> of <span class="math">\\mathsf{Q}</span> and the witness <span class="math">\\vec{\\mathsf{f}}</span> is the function</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Q}\\circ\\vec{\\mathsf{f}}:\\mathsf{H}_{0}\\to\\mathbb{F},</span></p>

    <p class="text-gray-300">where, for all <span class="math">y\\in\\mathsf{H}_{0}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{Q}\\circ\\vec{\\mathsf{f}})(y)=\\mathsf{Q}\\left(\\left(\\mathsf{f}_{l}(\\mathsf{g}^{j}\\cdot y)\\right)_{j,l}\\right).</span></p>

    <p class="text-gray-300">(On the right hand side, we replaced the variable <span class="math">\\mathsf{Z}_{j,l}\\in\\mathsf{Z}</span> that appears in <span class="math">\\mathsf{Q}(\\mathsf{Z})</span> with <span class="math">\\mathsf{f}_{l}(\\mathsf{g}^{j}\\cdot y)</span>).</p>

    <p class="text-gray-300">We now define which witnesses are said to satisfy an instance. As motivation, consider a typical way that an AIR can encode a computation. We could have a machine with <span class="math">\\mathsf{w}</span> <span class="math">\\mathbb{F}_{q}</span>-registers, and ask that <span class="math">\\mathsf{f}_{l}(g^{j})</span> represents the contents of the <span class="math">l</span>-th register at time <span class="math">j</span>. Then we use the constraints to (1) capture the transition rules between time step <span class="math">j</span> and <span class="math">j+1</span> for all <span class="math">j</span> in the enforcement domain <span class="math">[0,T]</span>, and (2) enforce boundary constraints on the values of the registers at time <span class="math">0</span> and at time <span class="math">T</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Definition 5 (Satisfiability)</h6>

    <p class="text-gray-300">We say that the AIR witness <span class="math">\\vec{\\mathsf{f}}=(\\mathsf{f}_{1},\\ldots,\\mathsf{f}_{\\mathsf{w}})</span> satisfies the AIR instance <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H}_{0},\\mathsf{g},\\mathsf{I},\\mathsf{Cset})</span> if and only if</p>

    <p class="text-gray-300"><span class="math">\\forall\\alpha\\in[\\mathsf{s}]:\\quad y\\in\\mathsf{H}_{\\alpha}\\Rightarrow(\\mathsf{Q}_{\\alpha}\\circ\\vec{\\mathsf{f}})(y)=0.</span></p>

    <p class="text-gray-300">In words, <span class="math">\\vec{\\mathsf{f}}</span> satisfies <span class="math">\\mathsf{A}</span> iff for every constraint <span class="math">\\mathsf{C}_{\\alpha}=(\\mathsf{Q}_{\\alpha},\\mathsf{H}_{\\alpha})\\in\\mathsf{Cset}</span> it holds that <span class="math">\\mathsf{Q}_{\\alpha}\\circ\\vec{\\mathsf{f}}</span> vanishes on the <span class="math">\\alpha</span>-th constraint enforcement domain <span class="math">\\mathsf{H}_{\\alpha}</span>. We say that the AIR <span class="math">\\mathsf{A}</span> is satisfiable if there exists an AIR witness <span class="math">\\vec{\\mathsf{f}}</span> that satisfies it.</p>

    <p class="text-gray-300">We now reach the main definition of this subsection, that of the language, and relation, corresponding to satisfiable AIRs over fields of quadratic size.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 6 (AIR Language/Relation)</h6>

    <p class="text-gray-300">The AIR relation <span class="math">\\mathsf{R}_{\\mathsf{AIR}}</span> is</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R}_{\\mathsf{AIR}}=\\{(\\mathsf{A},\\vec{\\mathsf{f}})\\mid\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H}_{0},\\mathsf{g},\\mathsf{I},\\mathsf{Cset})</span> is an AIR, <span class="math">\\vec{\\mathsf{f}}</span> is a satisfying AIR witness for <span class="math">\\mathsf{A}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\Omega(\\mathsf{d}^{2}\\cdot 2^{2\\mathsf{h}})\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The language of satisfiable AIRs is the projection of <span class="math">\\mathsf{R}_{\\mathsf{AIR}}</span> onto its first coordinate,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{L}_{\\mathsf{AIR}}=\\{\\mathsf{A}\\mid\\exists\\vec{\\mathsf{f}}\\ (\\mathsf{A},\\vec{\\mathsf{f}})\\in\\mathsf{R}_{\\mathsf{AIR}}\\}.</span></p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Remark 3 (Field size)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The definition above requires $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>(\\mathsf{d}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{H}_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{2}<span class="math">. When this is not the case one may embed </span>\\mathbb{F}<span class="math"> in a finite extension field </span>\\mathbb{K}<span class="math"> which is sufficiently large, and apply our results to the AIR over </span>\\mathbb{K}<span class="math">. This increases the various complexity measures (proving time, verification time and query complexity) by a multiplicative factor of at most </span>M([\\mathbb{K}:\\mathbb{F}])<span class="math">, where </span>M([\\mathbb{K}:\\mathbb{F}])<span class="math"> denotes the complexity of </span>\\mathbb{K}<span class="math">-multiplication in terms of arithmetic operations over </span>\\mathbb{F}<span class="math">; notice that </span>M(k)\\leq k^{2}<span class="math"> for any </span>\\mathbb{K}<span class="math"> that is the degree </span>k<span class="math"> extension of </span>\\mathbb{F}<span class="math">. For instance, in the extremal case of the smallest possible field size, </span>\\mathbb{F}_{2}<span class="math">, any AIR per Definition 1 over </span>\\mathbb{F}_{2}<span class="math">, using an (abstract) group </span>\\mathsf{H}_{0}<span class="math"> of size </span>n<span class="math">, would lead to using </span>k=2\\log n+O(1)<span class="math">, leading to total prover complexity of </span>O(n\\log n\\cdot M([\\mathbb{F}_{2^{2\\log n+O(1)}}:\\mathbb{F}_{2}])\\leq O(n\\log^{3}n)<span class="math"> measured in arithmetic operations over </span>\\mathbb{F}_{2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">2.2 A Scalable and Transparent IOP for <span class="math">\\mathsf{L_{AIR}}</span></h3>

    <p class="text-gray-300">To state our main result we assume familiarity with the definition of an IOP, and briefly recall its main parameters <em>[15, 52]</em>.</p>

    <p class="text-gray-300">An Interactive Oracle Proof (IOP) for a language <span class="math">\\mathsf{L}</span> is an interactive proof system defined by a prover <span class="math">\\mathsf{P}</span> and verifier <span class="math">\\mathsf{V}</span>, in which the verifier need not read the prover’s messages in full. Rather, the IOP model allows the verifier oracle access to the prover’s messages. (The prover is assumed to read all verifier messages in entirety.) The main parameters of interest are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>query complexity <span class="math">\\mathsf{q}</span> is the total number of symbols queried by the verifier from the prover’s messages</li>

      <li>round complexity <span class="math">\\mathsf{k}</span> is the number of rounds of interaction between the two parties.</li>

      <li>prover complexity <span class="math">\\mathsf{time_{P}}</span> and verifier complexity <span class="math">\\mathsf{time_{V}}</span>, which, in this paper, will assume unit cost for arithmetic operations over the ambient field</li>

      <li>proof length <span class="math">\\mathsf{l}</span> is the sum of lengths of oracles sent by the prover throughout the protocol.</li>

      <li>soundness error <span class="math">\\mathsf{err}</span> is the probability of the verifier accepting a false statement.</li>

    </ul>

    <h5 id="sec-29" class="text-base font-semibold mt-4">Main Result</h5>

    <p class="text-gray-300">It was shown by <em>[7]</em> that the sub-language of <span class="math">\\mathsf{L_{AIR}}</span> restricted to <span class="math">\\mathsf{FFT}</span>-friendly fields has a scalable and transparent IOP of knowledge. Formally, let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{L_{AIR,FFT}}=\\{\\mathsf{A}\\in\\mathsf{L_{AIR}}\\mid\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H_{0}},\\mathsf{g},\\mathsf{l},\\mathsf{Cset})\\text{ satisfies }2^{\\mathsf{h}}\\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main theorem of <em>[7]</em> is:</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 2.1 (STIK for <span class="math">\\mathsf{L_{AIR,FFT}}</span> – Prior state of art).</h6>

    <p class="text-gray-300">There is an IOP protocol for the language <span class="math">\\mathsf{L_{AIR,FFT}}</span> such that for <span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H_{0}},\\mathsf{g},\\mathsf{l},\\mathsf{Cset})</span> of witness size <span class="math">n=\\mathsf{w}\\cdot 2^{\\mathsf{h}}</span> and parameter <span class="math">t</span> we have:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness, Proving time and Proof size: There is a Prover algorithm that given <span class="math">\\mathsf{\\vec{f}}</span> such that <span class="math">(\\mathsf{A},\\mathsf{\\vec{f}})\\in\\mathsf{R_{AIR}}</span>, makes the verifier accept with probability <span class="math">1</span>. Prover running time is</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$O(n\\cdot(\\log n+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and proof length <span class="math">\\mathsf{l}</span> is <span class="math">O(n)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier runtime and query complexity: For all instances</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{A}=(\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H_{0}},\\mathsf{g},\\mathsf{l},\\mathsf{Cset}),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the verifier runs in time $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Cset}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+t\\cdot\\mathsf{h})<span class="math"> and makes a total of of </span>\\mathsf{q}\\leq t\\log n$ queries</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness and soundness: There exists an efficient extractor running in time <span class="math">\\mathsf{poly}(n)</span> such that, given access to a Prover which satisfies the verifier with probability greater than <span class="math">2^{-t}</span>, outputs <span class="math">\\mathsf{\\vec{f}}</span> such that <span class="math">(\\mathsf{A},\\mathsf{\\vec{f}})\\in\\mathsf{R_{AIR}}</span>. In particular, if <span class="math">\\mathsf{A}\\not\\in\\mathsf{L_{AIR}}</span> then, for any Prover strategy, the verifier will reject with probability at least <span class="math">1-2^{-t}</span>.</li>

    </ul>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 4 (Soundness and knowledge soundness)</h6>

    <p class="text-gray-300">Often in the analysis of interactive proofs, the soundness error parameter is smaller than the knowledge soundness parameter. In the theorem above we state the same parameter for both because the state-of-the-art soundness analysis in our case is actually efficient, and uses a witness extractor.</p>

    <p class="text-gray-300">The first step of the above IOPP is to identify the cyclic group <span class="math">\\mathsf{H}_{0}</span> with a subgroup of the multiplicative group <span class="math">\\mathbb{F}_{q}^{*}</span>, and to view satisfying AIR witnesses <span class="math">\\mathsf{f}_{l}:\\mathsf{H}_{0}\\to\\mathbb{F}_{q}</span> as the values of a low degree univariate polynomial <span class="math">\\mathsf{f}_{l}(Y)\\in\\mathbb{F}_{q}[Y]</span>. This then makes the AIR a collection of constraints on the values of low-degree polynomials at certain points of the field <span class="math">\\mathbb{F}_{q}</span>, and brings the tools of algebra into play.</p>

    <p class="text-gray-300">The FFT-friendliness is crucial for this approach — without it, there is no suitable multiplicative subgroup in <span class="math">\\mathbb{F}_{q}^{*}</span> to identify the cyclic group <span class="math">\\mathsf{H}_{0}</span> with, and the above approach fails to get off the ground (see Section 1.2).</p>

    <p class="text-gray-300">Our main result, given below, removes the FFT-friendliness restriction, and gives an IOPP for satisfiable AIRs over all finite fields with almost identical guarantees as Theorem 3. The key ingredient is to identify the cyclic group <span class="math">\\mathsf{H}_{0}</span> with a cyclic subgroup of an elliptic curve <span class="math">\\mathsf{E}</span> over <span class="math">\\mathbb{F}</span>, and to view satisfying AIR witnesses <span class="math">\\mathsf{f}_{l}:\\mathsf{H}_{0}\\to\\mathbb{F}_{q}</span> as the values of low degree rational functions <span class="math">\\mathsf{f}_{l}</span> defined on the curve <span class="math">\\mathsf{E}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 4 (Scalable and Transparent IOPs of Knowledge over all large fields)</h6>

    <p class="text-gray-300">There is an IOP protocol for the language <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> with properties and parameters as stated in Theorem 3 above.</p>

    <p class="text-gray-300">The complexity parameters of the theorem, along with completeness, are argued along the lines of the proof of Theorem 3 (see <em>[57, Section 5]</em>). The most delicate part is the soundness analysis (as is always the case with IOP systems). The proof appears in Section 3.3.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">EC-STARKs</h4>

    <p class="text-gray-300">Assuming the existence of a family of collision resistant hash functions, and replacing the interactive oracles with Merkle commitment schemes a la <em>[43]</em>, one obtains an interactive Scalable Transparent ARgument of Knowledge (STARK) as defined in <em>[7]</em>. Alternatively, working in the random oracle model and applying the BCS reduction <em>[15]</em>, one obtains a noninteractive STARK (which is also, in particular, a transparent SNARK). Details of both reductions are identical to prior STARKs and discussed elsewhere (e.g., <em>[43, 49, 15, 31, 30]</em>). We point out that STARKs based on FFT-friendly fields (Theorem 3) are concretely practical, as evidenced by the StarkEx system which implements them to scale transactions on Ethereum. We conjecture that the new EC-based construction of Theorem 1 will have practical applications in certain settings (as discussed in Section 1.1).</p>

    <p class="text-gray-300">2.3 IOPs of Proximity (IOPPs) for RS codes over all large fields</p>

    <p class="text-gray-300">In this section we state our auxiliary main result: FRI over all large finite fields. We start with a few necessary definitions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use <span class="math">\\Delta</span> to denote relative Hamming distance between two vectors <span class="math">u,v\\in\\mathbb{F}^{n}</span>, defined as $\\Delta(u,v)=\\frac{1}{n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{i\\in[n]\\mid u_{i}\\neq v_{i}\\right\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and for a set </span>V\\subset\\mathbb{F}^{n}<span class="math"> we let </span>\\Delta(u,V)=\\min\\left\\{\\Delta(u,v)\\mid v\\in V\\right\\}<span class="math">. The agreement of </span>u,v<span class="math"> and </span>u,V<span class="math"> is defined to be </span>\\mathsf{agree}(u,v)=1-\\Delta(u,v),\\mathsf{agree}(u,V)=1-\\Delta(u,V)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 7 (IOP of Proximity (IOPP)).</h6>

    <p class="text-gray-300">Fix <span class="math">V\\subset\\mathbb{F}^{n}</span>. An IOP system <span class="math">(\\mathsf{P},\\mathsf{V})</span> is said to be an IOP of proximity (IOPP) for <span class="math">V</span> with soundness error function <span class="math">\\mathsf{err}:[0,1]\\to[0,1]</span> (and additional complexity parameters as defined for standard IOP systems above) if, assuming the verifier has oracle access to <span class="math">v\\in\\mathbb{F}^{n}</span>, the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There exists a prover <span class="math">\\mathsf{P}</span> such that for <span class="math">v\\in V</span>,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathsf{V}^{v}\\leftrightarrow\\mathsf{P}(v)\\rangle=\\mathsf{accept}\\right]=1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">v\\not\\in V</span> (so <span class="math">\\Delta(v,V)&gt;0</span>) then for any prover <span class="math">\\mathsf{P}^{*}</span> we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\langle\\mathsf{V}^{v}\\leftrightarrow\\mathsf{P}(v)\\rangle=\\mathsf{accept}\\right]\\leq\\mathsf{err}(\\Delta(v,V))</span></p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Reed Solomon Codes</h4>

    <p class="text-gray-300">Let <span class="math">\\mathsf{RS}[\\mathbb{F}_{q},L,\\rho]</span> denote the Reed–Solomon code over field <span class="math">\\mathbb{F}_{q}</span>, evaluation domain <span class="math">L</span> and rate <span class="math">\\rho</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{RS}[\\mathbb{F}_{q},L,\\rho]=\\{f:L\\to\\mathbb{F}_{q}:\\deg(f)<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}.$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Recall the previous state of the art with respect to IOPPs for Reed–Solomon codes. We call a finite field <span class="math">\\mathbb{F}</span> <em><span class="math">n</span>-smooth</em> if it contains a sub-group (additive or multiplicative) of size <span class="math">n=2^{k}</span> for integer <span class="math">\\mathsf{k}</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 5 (FRI over smooth fields <em>[6, 8]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be an <span class="math">n</span>-smooth finite field. Then there is a subset <span class="math">L\\subseteq\\mathbb{F}</span> with size <span class="math">n</span> such that for any rate parameter <span class="math">\\rho=2^{-\\mathcal{R}}</span> (<span class="math">\\mathcal{R}\\in\\mathbb{N}</span>) and repetition parameter <span class="math">t</span>, the Reed–Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},L,\\rho]</span> has an IOPP with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>linear proving time <span class="math">\\mathsf{time}_{\\mathsf{P}}=O(n)</span> and proof length <span class="math">\\mathsf{l}&lt;n</span>,</li>

      <li>logarithmic query complexity <span class="math">\\mathsf{q}=t\\cdot\\log(n)+O(1)</span> and verification time <span class="math">\\mathsf{time}_{\\mathsf{V}}=O(t\\log n)</span></li>

      <li>soundness error function <span class="math">\\mathsf{err}</span>, where:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{err}(\\delta)=O\\left(\\frac{n^{2}}{q}\\right)+\\left(\\min(\\delta,1-\\sqrt{\\rho})-o(1)\\right)^{t}.</span></p>

    <p class="text-gray-300">Our second main result shows essentially the same bounds over any finite field, not just smooth ones.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 6 (FRI over all fields).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}</span> be the finite field of size <span class="math">q</span>, a prime power. Then for every <span class="math">n\\leq O(\\sqrt{q})</span> there exists a set <span class="math">L\\subseteq\\mathbb{F}_{q}</span> of size <span class="math">\\Theta(n)</span> such that for any rate parameter <span class="math">\\rho=2^{-\\mathcal{R}}</span> (<span class="math">\\mathcal{R}\\in\\mathbb{N}</span>) and repetition parameter <span class="math">t</span> the Reed–Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},L,\\rho]</span> has an IOPP with the complexity measures as stated in Theorem 5.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">2.4 Fast IOPs of Proximity for Elliptic Curve Codes</h3>

    <p class="text-gray-300">We generalize Theorem 2.2 to certain algebraic geometry codes, evaluations of functions in a low-degree Riemann–Roch space over FFT-friendly subgroups of elliptic curves(definitions of these terms appear in Appendix A). To define the specific codes recall the definition of Algebraic Geometry (or Goppa) codes.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 8 (Algebraic Geometry Codes).</h6>

    <p class="text-gray-300">Let <span class="math">X</span> be a non-singular projective curve over a field <span class="math">\\mathbb{F}</span>, let <span class="math">D=\\{x_{1},\\ldots,x_{n}\\}</span> be a set of <span class="math">\\mathbb{F}</span>-rational points and <span class="math">G</span> be a divisor with support disjoint from <span class="math">D</span>. Let <span class="math">\\mathscr{L}(G)</span> be the Riemann–Roch space defined by <span class="math">G</span>. Then the <em>algebraic geometry (AG) code</em> (also known as a Goppa code) <span class="math">C(D,G)</span> is</p>

    <p class="text-gray-300"><span class="math">C(D,G):=\\{f(x_{1}),\\ldots,f(x_{n})\\mid f\\in\\mathscr{L}(G),x_{i}\\in D\\}</span> (2)</p>

    <p class="text-gray-300">Our next result is the following.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 2.3 (Fast Elliptic Curve Code IOPP).</h6>

    <p class="text-gray-300">Let <span class="math">E</span> be an elliptic curve over <span class="math">\\mathbb{F}</span>, let <span class="math">G\\subset E</span> be a cyclic group of size <span class="math">2^{h}</span> and let <span class="math">D</span> be a union of <span class="math">m</span> nontrivial and disjoint cosets of <span class="math">G</span>, such that <span class="math">G\\cap D=\\emptyset</span>. Let <span class="math">[G]:=\\sum_{P\\in G}[P]</span> be the divisor naturally associated with <span class="math">G</span> (see Appendix A.5). Then, for any repetition parameter <span class="math">t</span> and setting <span class="math">\\rho=1/m</span>, the AG code <span class="math">C(D,[G])</span> has an IOPP with complexity parameters as in Theorem 2.2.</p>

    <h2 id="sec-41" class="text-2xl font-bold">3 Scalable IOPs for AIRs over any large field</h2>

    <p class="text-gray-300">In this section we prove our main theorem – Theorem 2.3, relying on certain claims that are proved in later sections.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">3.1 The ECFFT Infrastructure</h3>

    <p class="text-gray-300">The proof of Theorem 2.2 relies on delicately chosen elliptic curves, subgroups of those curves, Riemann–Roch spaces and AG codes, and special “degree-correction” functions on the curve. All of these are explained meticulously, and the required properties proven formally, in later sections. The goal of this section is to lay out, in a self-contained manner, all the results which are needed to derive our main results regarding IOPs and IOPs of proximity (in Section 3.2).</p>

    <p class="text-gray-300">This section builds upon our recent results in <em>[9]</em>, and we advise the reader to consult that paper regarding the results quoted here from that work.</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">3.1.1 The EC backbone</h4>

    <p class="text-gray-300">The backbone of all of the constructions in this paper is the chain of 2-isogenies whose existence was shown in <em>[9, Theorem 4.9]</em>, which we quote here:</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">Theorem 8. For any prime power  <span class="math">q \\geq 7</span>  and any  <span class="math">1 &amp;lt; \\mathsf{K} = 2^{\\mathbf{k}} \\leq 2\\sqrt{q}</span> , there exist elliptic curves  <span class="math">E_0, E_1, \\ldots, E_{\\mathbf{k}}</span>  over  <span class="math">\\mathbb{F}_q</span>  in extended Weierstrass form, a subgroup  <span class="math">G_0 \\subseteq E_0</span>  of size  <span class="math">\\mathsf{K}</span> , 2-isogenies  <span class="math">\\varphi_i : E_i \\to E_{i+1}</span>  and rational functions  <span class="math">\\psi_i : \\mathbb{P}^1 \\to \\mathbb{P}^1</span>  of degree 2, such that the following diagram is commutative:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c} E _ {0} \\xrightarrow {\\varphi_ {0}} E _ {1} \\xrightarrow {\\varphi_ {1}} \\dots \\xrightarrow {\\varphi_ {k - 1}} E _ {k} \\\\ \\pi_ {0} \\Biggl \\downarrow \\quad \\pi_ {1} \\Biggl \\downarrow \\quad \\Biggl \\downarrow \\pi_ {k} \\\\ \\mathbb {P} ^ {1} \\xrightarrow {\\psi_ {0}} \\mathbb {P} ^ {1} \\xrightarrow {\\psi_ {1}} \\dots \\xrightarrow {\\psi_ {k - 1}} \\mathbb {P} ^ {1} \\end{array} \\tag {3}</span></div>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_i</span>  are the projection maps to the  <span class="math">x</span> -coordinate of each curve;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi_{i - 1} \\circ \\dots \\circ \\varphi_0(G_0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{2^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k - i}$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G_0</span>  has a coset  <span class="math">C</span>  such that  <span class="math">C \\neq -C</span>  (as elements of the quotient group  <span class="math">E_0(\\mathbb{F}_q) / G_0</span> ).</li>

    </ul>

    <p class="text-gray-300">Note that this theorem is very abstract: It only establishes the existence of these curves and maps, but says almost nothing about the form of the equations defining  <span class="math">E_{i}</span>  or of the isogenies  <span class="math">\\varphi_{i}</span>  and maps  <span class="math">\\psi_{i}</span> , does not specify the structure of  <span class="math">G_{0}</span> , and does not show how to find such curves.</p>

    <p class="text-gray-300">In Section 4 we revisit this theorem, and strengthen and refine it for our needs. First, we show a realization of the above curve sequence using elliptic curves  <span class="math">E_{i}</span>  of a simple form, and obtain simple, explicit formulas for  <span class="math">\\varphi_{i}</span>  and  <span class="math">\\psi_{i}</span> . Next, we show how to get the above sequence with  <span class="math">G_{0}</span>  being a cyclic group (isomorphic to  <span class="math">\\mathbb{Z}/2^{\\mathbf{k}}\\mathbb{Z}</span> ) — this is crucial for doing efficient arithmetization of AIRs (which are defined in terms of cyclic groups). Finally, we give a probabilistic algorithm for finding such curves in nearly optimal  <span class="math">O(2^{\\mathbf{k}}\\mathrm{polylog}q)</span>  time. The following statement summarizes these improvements to Theorem 8.</p>

    <p class="text-gray-300">Theorem 9. There exists a randomized algorithm Find Curve, that on input  <span class="math">\\mathsf{k}</span>  and  <span class="math">q \\geq \\max \\left\\{7,2^{2(\\mathsf{k} - 1)}\\right\\}</span> , runs in time  <span class="math">O(2^{\\mathsf{k}}\\log^{2}q\\log \\log q)</span> , and with high probability finds elliptic curves  <span class="math">E_{i}</span>  in Weierstrass form and maps  <span class="math">\\varphi_{i},\\psi_{i}</span>  as in Theorem 8, such that  <span class="math">G_{0}</span>  is a cyclic group of size  <span class="math">2^{\\mathsf{k}}</span>  and the maps  <span class="math">\\varphi_{i},\\psi_{i}</span>  are computable via  <span class="math">O(1)</span>  operations in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">The upper bound on the algorithm's runtime can be improved by a  <span class="math">\\tilde{O} (\\log q)</span>  factor assuming the Riemann Hypothesis, and we believe that it should be even faster. For details see Section 4.</p>

    <p class="text-gray-300">Function Spaces and Evaluation Domains We are now ready to explicitly describe the setup we will need for our IOP for satisfiable AIRs. For analogues of the FFT and IFFT algorithms and the FRI protocol, we will need to identify some special functions and some special sets of evaluation points. These are captured below.</p>

    <p class="text-gray-300">Proposition 1 (Setup). For every  <span class="math">q, k</span>  with  <span class="math">q \\geq \\Omega(2^{2k})</span> , there exists an elliptic curve  <span class="math">\\mathsf{E} / \\mathbb{F}_q</span>  such that  <span class="math">\\mathsf{E}(\\mathbb{F}_q)</span>  contains a cyclic group  <span class="math">G</span>  of size  <span class="math">2^k</span> .</p>

    <p class="text-gray-300">Fixing such a curve  <span class="math">\\mathsf{E}</span> , we introduce some notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">\\ell\\leq\\mathsf{k}</span>, let <span class="math">G^{\\langle\\ell\\rangle}</span> be the cyclic subgroup of <span class="math">G</span> of size <span class="math">2^{\\ell}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A basic subset <span class="math">S</span> of <span class="math">\\mathsf{E}(\\mathbb{F}_{q})</span> at scale <span class="math">\\ell</span> is a set <span class="math">S=C\\cup(-C)</span>, where <span class="math">C\\subseteq\\mathsf{E}(\\mathbb{F}_{q})</span> is a coset of <span class="math">G^{\\langle\\ell\\rangle}</span> with <span class="math">C\\neq-C</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\ell+1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An <em>evaluation domain</em> <span class="math">\\mathbf{S}</span> of <span class="math">\\mathsf{E}(\\mathbb{F}_{q})</span> at scale <span class="math">\\ell</span> is a union of disjoint basic subsets of <span class="math">\\mathsf{E}(\\mathbb{F}_{q})</span> at scale <span class="math">\\ell</span>.</li>

      <li>Let <span class="math">\\mathcal{K}^{\\langle\\ell\\rangle}</span> be the <span class="math">\\mathbb{F}_{q}</span>-linear space <span class="math">\\mathscr{L}([G^{\\langle\\ell+1\\rangle}])</span> of rational functions on <span class="math">\\mathsf{E}</span>. By the Riemann–Roch theorem, we have <span class="math">\\dim(\\mathcal{K}^{\\langle\\ell\\rangle})=2^{\\ell+1}</span>.</li>

    </ul>

    <p class="text-gray-300">We now set up similar notions on the projective line, obtained by projecting down to the <span class="math">x</span>-coordinate via the map <span class="math">\\pi</span>. The curve <span class="math">\\mathsf{E}</span> is assumed to be in Weierstrass form.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A basic subset <span class="math">T</span> of <span class="math">\\mathbb{F}_{q}</span> at scale <span class="math">\\ell</span> is the projection <span class="math">T=\\pi(S)</span> of a basic subset of <span class="math">\\mathsf{E}(\\mathbb{F}_{q})</span> at scale <span class="math">\\ell</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\ell}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An <em>evaluation domain</em> of <span class="math">\\mathbb{F}_{q}</span> at scale <span class="math">\\ell</span> is a union of disjoint basic subsets of <span class="math">\\mathbb{F}_{q}</span> at scale <span class="math">\\ell</span>. Equivalently, it is a set of the form <span class="math">\\mathbf{T}=\\pi(\\mathbf{S})</span>, where <span class="math">\\mathbf{S}</span> is an evaluation domain of <span class="math">\\mathsf{E}(\\mathbb{F}_{q})</span>.</li>

      <li>Let <span class="math">\\mathcal{M}^{\\langle\\ell\\rangle}</span> denote the space of polynomials in <span class="math">\\mathbb{F}_{q}[X]</span> of degree at most <span class="math">2^{\\ell}-1</span>. Note that <span class="math">\\dim(\\mathcal{M}^{\\langle\\ell\\rangle})=2^{\\ell}</span>.</li>

    </ul>

    <p class="text-gray-300">The <span class="math">\\mathcal{K}^{\\langle\\ell\\rangle}</span> and <span class="math">\\mathcal{M}^{\\langle\\ell\\rangle}</span> spaces above are related through a certain univariate polynomial <span class="math">\\Omega^{\\langle\\ell\\rangle}(X)</span> of degree exactly <span class="math">2^{\\ell}-1</span> (see Section 5.1 for an explicit description). Corollary 2 shows that every rational function <span class="math">f(X,Y)\\in\\mathcal{K}^{\\langle\\ell\\rangle}</span> can be written uniquely in the following form:</p>

    <p class="text-gray-300"><span class="math">f(X,Y)=\\frac{1}{\\Omega^{\\langle\\ell\\rangle}(X)}\\left(f_{0}(X)+\\frac{Y}{X}f_{1}(X)\\right),</span> (4)</p>

    <p class="text-gray-300">where <span class="math">f_{0}(X),f_{1}(X)\\in\\mathcal{M}^{\\langle\\ell\\rangle}</span>. We will sometimes write this as:</p>

    <p class="text-gray-300"><span class="math">f(Z)=\\frac{1}{\\Omega^{\\langle\\ell\\rangle}(\\pi(Z))}\\left(f_{0}(\\pi(Z)+\\zeta(Z)f_{1}(\\pi(Z))\\right),</span></p>

    <p class="text-gray-300">where <span class="math">Z=(X,Y)</span> is a pair of formal (related) variables representing a point on the curve, <span class="math">\\pi</span> is the projection from <span class="math">\\mathsf{E}</span> onto the <span class="math">x</span>-coordinate, and <span class="math">\\zeta((X,Y))=\\frac{Y}{X}</span>.</p>

    <p class="text-gray-300">This representation will let us move between the space of rational functions <span class="math">\\mathcal{K}^{\\langle\\ell\\rangle}</span> and the space of polynomials <span class="math">\\mathcal{M}^{\\langle\\ell\\rangle}</span>.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">FFT and IFFT</h4>

    <p class="text-gray-300">The following theorems give the new FFT and IFFT transformations that we will need. The proofs of the following theorems appear in Section 6.1. The bases that appear in the theorems are defined in Definitions 11 and 12. Following the notation in <em>[9]</em>, for a function <span class="math">f</span> defined on an evaluation domain <span class="math">S</span>, we denote by <span class="math">\\langle f\\wr S\\rangle</span> the evaluation table of <span class="math">f</span> on <span class="math">S</span>. When <span class="math">f</span> belongs in a linear space spanned by a basis <span class="math">\\beta</span>, we denote by <span class="math">[f]_{\\beta}</span> the representation of <span class="math">f</span> in the basis.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Theorem 10 (FFT and IFFT- Elliptic Curve Version).</h6>

    <p class="text-gray-300">For each <span class="math">\\ell</span>, there is a basis <span class="math">\\kappa^{\\langle\\ell\\rangle}=(\\kappa_{j}^{\\langle\\ell\\rangle})_{j=0}^{2^{\\ell+1}-1}</span> of <span class="math">\\mathcal{K}^{\\langle\\ell\\rangle}</span> such that for any basic set <span class="math">S</span> at scale <span class="math">\\ell</span></p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is a  <span class="math">O(\\ell \\cdot 2^{\\ell})</span>  time algorithm  <span class="math">\\mathsf{FFT}_S</span> , that when given  <span class="math">[f]_{\\kappa^{(\\ell)}}</span>  as input, computes  <span class="math">\\langle f \\wr S \\rangle</span> .</li>

      <li>there is a  <span class="math">O(\\ell \\cdot 2^{\\ell})</span>  time algorithm  <span class="math">\\mathsf{IFFT}_S</span> , that when given  <span class="math">\\langle f \\wr S \\rangle</span>  as input for some  <span class="math">f \\in \\mathcal{K}^{(\\ell)}</span> , computes  <span class="math">[f]_{\\kappa^{(\\ell)}}</span> . (In particular,  <span class="math">f \\in \\mathcal{K}^{(\\ell)}</span>  is uniquely specified by  <span class="math">\\langle f \\wr S \\rangle</span> ).</li>

    </ul>

    <p class="text-gray-300">Theorem 11 (FFT and IFFT- Univariate Polynomial Version). For each  <span class="math">\\ell</span> , there is a basis  <span class="math">\\mu^{(\\ell)} = (\\mu_j^{(\\ell)})_{j=0}^{2^{\\ell}-1}</span>  of  <span class="math">\\mathcal{M}^{(\\ell)}</span>  such that for any basic subset  <span class="math">T</span>  of  <span class="math">\\mathbb{F}_q</span>  at scale  <span class="math">\\ell</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is a  <span class="math">O(\\ell \\cdot 2^{\\ell})</span>  time algorithm  <span class="math">\\mathsf{FFT}_T</span> , that when given  <span class="math">[g]_{\\mu^{(\\ell)}}</span>  as input, computes  <span class="math">\\langle g \\wr T \\rangle</span> .</li>

      <li>there is a  <span class="math">O(\\ell \\cdot 2^{\\ell})</span>  time algorithm  <span class="math">\\mathsf{IFFT}_T</span> , that when given  <span class="math">\\langle g \\wr T \\rangle</span>  as input for some  <span class="math">g \\in \\mathcal{M}^{(\\ell)}</span> , computes  <span class="math">[g]_{\\mu^{(\\ell)}}</span> . (In particular,  <span class="math">g \\in \\mathcal{M}^{(\\ell)}</span>  is uniquely specified by  <span class="math">\\langle g \\wr T \\rangle</span> ).</li>

    </ul>

    <p class="text-gray-300">FRI Our key tool is the FRI protocol for testing proximity to univariate polynomials. Specifically, when the set of evaluation points  <span class="math">\\mathbf{T}</span>  is an evaluation domain in  <span class="math">\\mathbb{F}_q</span> , then the FFT infrastructure enables a version of the FRI protocol for  <span class="math">\\mathsf{RS}[\\mathbb{F}_q,\\mathbf{T},\\rho]</span> , stated below. The proof appears in Appendix B.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 12 (Basic FRI). Let  <span class="math">q, k, E</span>  and the setup be as above. Let  <span class="math">\\ell \\leq k</span> . Let  <span class="math">\\mathcal{R}</span>  be a positive integer, and set  <span class="math">\\rho = 2^{-\\mathcal{R}}</span> . Let  <span class="math">\\mathbf{T} \\subseteq \\mathbb{F}_q</span>  be an evaluation domain at scale  <span class="math">\\ell</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{\\rho} 2^{\\ell}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Given a repetition parameter  <span class="math">t &amp;gt; 0</span> , there is an IOPP protocol (FRI) with prover  <span class="math">\\mathsf{P}</span>  and verifier  <span class="math">\\mathsf{V}</span>  for  <span class="math">\\mathsf{RS}[\\mathbb{F}_q, \\mathbf{T}, \\rho]</span>  with:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: There exists a prover  <span class="math">\\mathsf{P}</span>  such that for any  <span class="math">f\\in \\mathsf{RS}[\\mathbb{F}_q,\\mathbf{T},\\rho ]</span>  causes the verifier  <span class="math">\\mathsf{V}</span>  to accept  <span class="math">f</span>  with probability 1.</li>

      <li>Soundness: If  <span class="math">f</span>  is  <span class="math">\\delta</span>  far from  <span class="math">\\mathsf{RS}[\\mathbb{F}_q, \\mathbf{T}, \\rho]</span>  then for any prover  <span class="math">\\mathsf{P}^*</span> , we have</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\operatorname<em>{Pr}\\left[\\langle \\mathsf{V}(f)\\leftrightarrow \\mathsf{P}^{</em>}(f)\\rangle = \\mathsf{accept}\\right]\\leq (1 - \\min \\{\\varDelta (f,\\mathsf{RS}[\\mathbb{F}_{q},\\mathbf{T},\\rho ]),\\sqrt{\\rho}\\} +o(1))^{t}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover runtime:  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  arithmetic operations over  </span>\\mathbb{F}_q$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Proof length:  $O(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{T}</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math">  field elements in  </span>\\mathbb{F}_q$ .</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From the proximity gap property of Reed-Solomon codes [8], this leads to a protocol for simultaneously checking a batch of functions evaluated on an evaluation domain in  <span class="math">\\mathbb{F}_q</span>  are low-degree. The proof appears in Appendix B.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 13 (Batched FRI). Let  <span class="math">q, k, E</span>  and the setup be as above. Let  <span class="math">\\ell \\leq k</span> . Let  <span class="math">\\mathcal{R}</span>  be a positive integer, and set  <span class="math">\\rho = 2^{-\\mathcal{R}}</span> . Let  <span class="math">\\mathbf{T} \\subseteq \\mathbb{F}_q</span>  be an evaluation domain at scale  <span class="math">\\ell</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{\\rho} 2^{\\ell}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">d_1, \\ldots, d_k</span>  be integers such that  $d_i \\leq \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  for all  </span>i<span class="math"> . Given a repetition parameter  </span>t &gt; 0$  and oracle access to functions</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">g _ {1}, g _ {2}, \\dots , g _ {k}: \\mathbf {T} \\rightarrow \\mathbb {F} _ {q},</span></div>

    <p class="text-gray-300">there is an IOP protocol with the following behavior.</p>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness: If for all <span class="math">i</span>, <span class="math">g_i</span> is the evaluation of some polynomial in <span class="math">\\mathbb{F}_q[X]</span> of degree <span class="math">&amp;lt; d_i</span>, then there is a prover strategy to make the verifier accept with probability 1.</li>

      <li>Soundness: Suppose the protocol accepts with probability</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p \\geq (\\rho^{1/2} + \\epsilon)^t + O\\left(\\frac{\\rho^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{\\epsilon^7 q}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Then there exist polynomials <span class="math">G_1(X), \\ldots, G_k(X) \\in \\mathbb{F}_q[X]</span>, with <span class="math">\\deg(G_i) &amp;lt; d_i</span> and a set <span class="math">V \\subseteq \\mathbf{T}</span> such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (\\rho^{1/2} + \\epsilon)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g_i(x) = G_i(x)</span> for all <span class="math">x \\in V</span>, <span class="math">i \\in [k]</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover runtime: $O(k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> arithmetic operations over </span>\\mathbb{F}_q$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Proof length: $O(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{T}</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math"> field elements in </span>\\mathbb{F}_q$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note: The constants in <span class="math">O(\\cdot)</span> in the last three items in both Theorems 12 and 13 are some explicit small constants that are each at most 10.</p>

    <p class="text-gray-300">Vanishing detection The final tool that we need is a way to check that some given rational function on <span class="math">\\mathsf{E}</span> vanishes at a given set of points. This is essentially the content of Lemma 7 and Theorem 19, and is proved in Section 7.</p>

    <p class="text-gray-300">Theorem 14 (Vanishing detection). Let <span class="math">I \\subseteq \\mathsf{E}(\\mathbb{F}_q)</span> be a subset which is contained in a coset of <span class="math">G^{\\langle \\ell \\rangle}</span>. There is a well-defined rational function <span class="math">\\omega_I^{\\langle \\ell \\rangle} \\in \\mathcal{L}([G^{\\langle \\ell + 1 \\rangle} \\setminus G^{\\langle \\ell \\rangle}] - [G^{\\langle \\ell \\rangle}] + [I])</span> on <span class="math">\\mathsf{E}</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">f \\in \\mathcal{L}(2[G^{\\langle \\ell \\rangle}])</span>, we have:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f \\text{ vanishes on } I \\Leftrightarrow \\omega_I^{\\langle \\ell \\rangle} \\cdot f \\in \\mathcal{L}([G^{\\langle \\ell + 1 \\rangle}]).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- For almost every <span class="math">P \\in \\mathsf{E}(\\mathbb{F}_q)</span>, excluding at most three cosets of <span class="math">G^{\\langle \\ell + 1 \\rangle}</span>, <span class="math">\\omega_I^{\\langle \\ell \\rangle}(P)</span> can be computed using $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell)<span class="math"> </span>\\mathbb{F}_q<span class="math">-operations (where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the coset complexity of </span>I$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-46" class="text-2xl font-bold">3.2 The IOP Protocol</h2>

    <p class="text-gray-300">In this section we describe an IOP for the satisfiable AIR language of Definition 6.</p>

    <p class="text-gray-300">The crux of this protocol is for the prover to do a "low-degree extension" of a satisfying AIR-witness <span class="math">\\bar{\\mathsf{f}} = (\\mathsf{f}_1, \\ldots, \\mathsf{f}_w)</span>, where each <span class="math">\\mathsf{f}_l : \\mathsf{H}_0 \\to \\mathbb{F}_q</span>. This is not the standard univariate polynomial low-degree extension; instead it is an elliptic curve variant. Indeed, we first identify <span class="math">\\mathsf{H}_0</span> with a coset <span class="math">C</span> of a cyclic subgroup of size <span class="math">2^h</span> of a suitable elliptic curve <span class="math">\\mathsf{E}</span> over <span class="math">\\mathbb{F}_q</span>. Thus we may view each <span class="math">\\mathsf{f}_l</span> as a function defined at some points of <span class="math">\\mathsf{E}</span>. Next, we consider the Riemann-Roch space <span class="math">\\mathcal{K}^{\\langle h \\rangle}</span> of <span class="math">\\mathsf{E}</span>, and the prover finds elements <span class="math">\\widehat{f}_l</span> of <span class="math">\\mathcal{K}^{\\langle h \\rangle}</span> whose restrictions to <span class="math">C</span> agree with the values taken on <span class="math">\\mathsf{H}_0</span> by the <span class="math">\\mathsf{f}_l</span>'s. Finally, the prover provides</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">evaluations of these rational functions <span class="math">\\widehat{f}_l</span>'s at another set of points <span class="math">\\mathsf{D} \\subseteq \\mathsf{E}(\\mathbb{F}_q)</span>. These extended evaluations are at the core of the prover's proof of satisfiability of an AIR.</p>

    <p class="text-gray-300">To describe the IOP for <span class="math">\\mathsf{L}_{\\mathsf{AIR}}</span> we need to fix some auxiliary parameters aux that will be used by it. For simplicity and ease of exposition, we will only describe the IOP for AIRs which have the constraint degree <span class="math">\\mathsf{d} = 2</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The rate parameter <span class="math">\\rho = 2^{-\\mathcal{R}}</span> for some integer <span class="math">\\mathcal{R}</span>. In practical settings, <span class="math">\\rho</span> is typically fixed to a small constant such as <span class="math">\\frac{1}{16}</span> (thus <span class="math">\\mathcal{R} = 4</span>), and it may help the reader to consider this setting on first reading.</li>

      <li>An elliptic curve <span class="math">\\mathsf{E}</span> over <span class="math">\\mathbb{F}_q</span> with a cyclic subgroup <span class="math">G</span> of size <span class="math">2^k</span>, for <span class="math">k = h + \\mathcal{R} + 5</span>. We then use the setup from Proposition 1 with respect to this curve.</li>

      <li>A choice of a coset <span class="math">C</span> of <span class="math">G^{\\langle h\\rangle}</span> such that <span class="math">C \\neq -C</span>. We identify <span class="math">\\mathsf{H}_0</span> with <span class="math">C</span> by first picking an arbitrary <span class="math">Q_0 \\in C</span>, an arbitrary generator <span class="math">g</span> of <span class="math">G^{\\langle h\\rangle}</span>, and identifying</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {g} ^ {j} \\leftrightarrow Q _ {0} + j \\cdot g.</span></div>

    <p class="text-gray-300">With this identification, the constraint enforcement domains <span class="math">\\mathsf{H}_{\\alpha} \\subseteq \\mathsf{H}_0</span> get identified with <span class="math">\\mathsf{U}_{\\alpha} \\subseteq C</span> using:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm {U} _ {\\alpha} = \\left\\{Q _ {0} + j \\cdot g \\mid \\mathrm {g} ^ {j} \\in \\mathrm {H} _ {\\alpha} \\right\\}.</span></div>

    <p class="text-gray-300">Note that <span class="math">C\\cup (-C)</span> is a basic set at scale h.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An evaluation domain <span class="math">\\mathbf{S} \\subseteq \\mathsf{E}(\\mathbb{F}_q)</span> at scale <span class="math">\\mathsf{h}</span> (as in Section 5.3), of size <span class="math">2^{\\mathsf{k}&#x27;} = \\mathsf{d} \\cdot \\frac{1}{\\rho} \\cdot 2^{\\mathsf{h} + 1} = 2^{\\mathsf{h} + \\mathcal{R} + 1}</span>, which is disjoint from the trace domain <span class="math">\\mathsf{H}_0</span>. Thus <span class="math">\\mathbf{S}</span> is the union of <span class="math">\\frac{\\mathsf{d}}{\\rho} = 2^{\\mathcal{R} + 1}</span> basic sets at scale <span class="math">\\mathsf{h}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The projection <span class="math">\\mathbf{T} \\subseteq \\mathbb{F}_q</span> of the evaluation domain <span class="math">\\mathbf{S}</span> to the <span class="math">x</span>-coordinate (recall the curve is in Weierstrass form) — this is an evaluation domain of <span class="math">\\mathbb{F}_q</span> at scale <span class="math">\\mathsf{h}</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{\\rho} 2^{\\mathsf{h} + 1} = 2^{\\mathsf{h} + \\mathcal{R} + 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Later in the protocol, we shall represent functions <span class="math">f(x,y):\\mathbf{S}\\to \\mathbb{F}_q</span> as a pair <span class="math">f_0(x),f_1(x):\\mathbf{T}\\rightarrow \\mathbb{F}_q</span> where <span class="math">\\mathbf{T}</span> is the projection of <span class="math">\\mathbf{S}</span> onto the <span class="math">x</span>-coordinate, using the decomposition of (4), i.e., defining</p>

    <div class="my-4 text-center"><span class="math-block">f (x, y) := \\frac {1}{\\Omega^ {\\langle \\ell \\rangle} (x)} \\left(f _ {0} (x) + \\frac {y}{x} \\cdot f _ {1} (x)\\right),</span></div>

    <p class="text-gray-300">where <span class="math">f</span> is (or is supposed to be) an evaluation of a function in <span class="math">\\mathcal{K}^{\\langle \\ell \\rangle}</span>.</p>

    <p class="text-gray-300">We shall also use the following notation:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">f: \\mathbf{T} \\to \\mathbb{F}_q</span> and a function <span class="math">u: A \\to \\mathbb{F}_q</span>, where <span class="math">A \\cap \\mathbf{T} = \\emptyset</span>, we define the quotient of <span class="math">f</span> by <span class="math">u</span> to be the function:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {Q u o t i e n t} (f; u): \\mathbf {T} \\rightarrow \\mathbb {F} _ {q}, \\quad \\operatorname {Q u o t i e n t} (f; u) (x) := \\frac {f (x) - U (x)}{Z _ {A} (x)},</span></div>

    <p class="text-gray-300">where:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">U(X) \\in \\mathbb{F}_q[X]</span> is the unique polynomial of degree at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math"> with </span>U</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_A = u$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Z_A(X) = \\prod_{a \\in A} (X - a)</span> is the vanishing polynomial of <span class="math">A</span>.</li>

    </ul>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <p class="text-gray-300">Description of the protocol The protocol starts with an AIR instance  <span class="math">\\mathsf{A} = (\\mathbb{F},\\mathsf{w},\\mathsf{h},\\mathsf{d},\\mathsf{s},\\mathsf{H}_0,\\mathsf{g},\\mathsf{l},\\mathsf{Cset})</span>  and auxiliary IOP parameters  <span class="math">\\mathsf{aux} = (\\mathsf{E},G,C,\\mathsf{S},\\mathsf{k}&#x27;,t)</span>  given to both prover and verifier.</p>

    <p class="text-gray-300">At the high level, the steps closely track the corresponding steps in the STARK protocol given in [57] <span class="math">^{12}</span> , with rational functions and points on the curve replacing univariate polynomials and points in  <span class="math">\\mathbb{F}_q</span> .</p>

    <p class="text-gray-300">At some points, we represent rational functions on the elliptic curve by pairs of univariate polynomials, and invoke results about univariate polynomials. A more natural and clean version could have been given if we had analogues of (i) the proximity gaps phenomenon [8], and (ii) the DEEP query and quotienting method [16], for AG codes on elliptic curves. We believe that this approach ought to work but have not pursued these here in the interest of the simplicity of relying on previous results for RS codes.</p>

    <p class="text-gray-300">We now give the description of the IOP protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. Execution trace oracle: The prover first finds an AIR witness  <span class="math">\\widehat{\\mathbf{f}} = (\\mathsf{f}_1, \\ldots, \\mathsf{f}_w)</span>  that satisfies the AIR instance  <span class="math">\\mathsf{A}</span>  according to Definition 5. Next, the prover finds functions  <span class="math">\\widehat{f}_1, \\ldots, \\widehat{f}_w \\in \\mathcal{K}^{\\langle \\mathsf{h} \\rangle}</span>  extending the  <span class="math">\\mathsf{f}_l</span> 's. Specifically,  <span class="math">\\widehat{f}_l</span>  is rational function  <span class="math">\\widehat{f}_l(X, Y) \\in \\mathcal{K}^{\\langle \\mathsf{h} \\rangle}</span>  such that  $\\left. \\widehat{f}_l \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_C = \\left. \\mathsf{f}_l \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{H}_0}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that a function  <span class="math">\\widehat{f}_l\\in \\mathcal{K}^{\\langle \\mathsf{h}\\rangle}</span>  can be specified by giving its values on the entire basic set  <span class="math">C\\cup (-C)</span>  (using the IFFT from Theorem 10); thus the prover has many valid choices for  <span class="math">\\widehat{f}_l</span> , determined by the values of  $\\left.\\widehat{f}_l\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{-C}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The prover then expresses each  <span class="math">\\widehat{f}_l(X,Y)</span>  using a pair of univariate polynomials  <span class="math">\\widehat{f}_{l,0}(X),\\widehat{f}_{l,1}(X)\\in \\mathbb{F}_q[X]</span>  of degree  <span class="math">&amp;lt; 2^{\\mathrm{h}}</span> , via the decomposition of (4), i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {f} _ {l} (X, Y) := \\frac {1}{\\Omega^ {\\langle \\mathrm {h} \\rangle} (X)} \\left(\\widehat {f} _ {l, 0} (X) + \\frac {Y}{X} \\widehat {f} _ {l, 1} (X)\\right).</span></div>

    <p class="text-gray-300">The prover then evaluates these  <span class="math">2\\mathsf{w}</span>  low-degree polynomials  <span class="math">\\langle \\widehat{f}_{l,0},\\widehat{f}_{l,1}\\mid l\\in [\\mathsf{w}]\\rangle</span>  at all the points of  <span class="math">\\mathbf{T}</span> .</p>

    <p class="text-gray-300">Prover sends  <span class="math">\\left\\langle \\widehat{f}_{l,m} \\mid \\mathbf{T} \\right\\rangle</span>  for each  <span class="math">(l, m) \\in [\\mathsf{w}] \\times \\{0, 1\\}</span> .</p>

    <p class="text-gray-300">Note that these are evaluations of degree  <span class="math">2^{\\mathsf{h}}</span>  polynomials on a set  <span class="math">\\mathbf{T}</span>  of size  <span class="math">\\frac{1}{\\rho} 2^{\\mathsf{h} + 1}</span> , so they are all supposed to be codewords of  <span class="math">\\mathsf{RS}(\\mathbb{F}_q, \\mathbf{T}, \\rho)</span>  (and even of  <span class="math">\\mathsf{RS}(\\mathbb{F}_q, \\mathbf{T}, \\rho / 2)</span> ).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint randomness:</li>

    </ol>

    <p class="text-gray-300">Verifier samples uniform randomness  <span class="math">\\vec{r} \\coloneqq (r_1, \\ldots, r_s) \\in \\mathbb{F}_q^{\\mathrm{s}}</span> , one field element per constraint, and sends it to the prover.</p>

    <p class="text-gray-300">We now explain the role of this step. These random field elements will be coefficients for taking a “random linear combination of the constraints” – and the prover will now try to convince the verifier that this random linear combination of the constraints is satisfied by the witness underlying the <span class="math">\\widehat{f}_{l,0}</span>’s and the <span class="math">\\widehat{f}_{l,1}</span>’s.</p>

    <p class="text-gray-300">In more detail, constraint <span class="math">\\mathsf{C}_{\\alpha}</span> asks that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Q}_{\\alpha}((\\mathsf{f}_{l}(\\mathsf{g}^{j}\\cdot t))_{l,j})=0,</span></p>

    <p class="text-gray-300">for all <span class="math">t\\in\\mathsf{H}_{\\alpha}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the <span class="math">\\widehat{f}_{l}\\in\\mathcal{K}^{\\langle\\mathsf{h}\\rangle}</span> are truly such that $\\widehat{f}_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathsf{H}_{0}}=\\left.\\mathsf{f}_{l}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C}$, then this is the same as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{Q}_{\\alpha}((\\widehat{f}_{l}(P+j\\cdot g))_{(l,j)\\in\\mathsf{I}})=0,</span></p>

    <p class="text-gray-300">for all <span class="math">P\\in\\mathsf{U}_{\\alpha}\\subset\\mathsf{E}</span>.</p>

    <p class="text-gray-300">Since <span class="math">\\widehat{f}_{l}\\in\\mathcal{K}^{\\langle\\mathsf{h}\\rangle}=\\mathscr{L}([G^{\\langle\\mathsf{h}+1\\rangle}])</span> and <span class="math">\\mathsf{Q}_{\\alpha}</span> has degree at most <span class="math">\\mathsf{d}=2</span>, we get that the function <span class="math">B_{\\alpha}:\\mathsf{E}\\to\\mathbb{F}_{q}</span> defined by:</p>

    <p class="text-gray-300"><span class="math">B_{\\alpha}(P):=\\mathsf{Q}_{\\alpha}((\\widehat{f}_{l}(P+j\\cdot g))_{(l,j)\\in\\mathsf{I}})\\quad\\forall P\\in\\mathsf{E},</span></p>

    <p class="text-gray-300">lies in <span class="math">\\mathscr{L}(2[G^{\\langle\\mathsf{h}+1\\rangle}])</span>. Note that the verifier can simulate oracle access to <span class="math">B_{\\alpha}</span> at points in <span class="math">\\mathbf{S}</span> using oracle access to evaluations of <span class="math">\\widehat{f}_{l}</span> at points in <span class="math">\\mathbf{S}</span>, which themselves can be reconstituted from evaluations of <span class="math">\\widehat{f}_{l,0}</span> and <span class="math">\\widehat{f}_{l,1}</span> at points in <span class="math">\\mathbf{T}</span>.</p>

    <p class="text-gray-300">By Lemma 7, checking that <span class="math">B_{\\alpha}</span> vanishes at all points in <span class="math">\\mathsf{H}_{\\alpha}</span> is equivalent to checking that the rational function</p>

    <p class="text-gray-300"><span class="math">\\omega_{\\alpha}\\cdot B_{\\alpha}</span></p>

    <p class="text-gray-300">lies in <span class="math">\\mathscr{L}([G^{\\langle\\mathsf{h}+2\\rangle}]=\\mathcal{K}^{\\langle\\mathsf{h}+1\\rangle}</span>, where <span class="math">\\omega_{\\alpha}:=\\omega_{\\mathsf{H}_{\\alpha}}</span> is the degree adjustment function for <span class="math">\\mathsf{U}_{\\alpha}</span>.</p>

    <p class="text-gray-300">Now we can explain where the randomness <span class="math">\\overline{\\mathsf{r}}</span> is used — it is to check all the above memberships of <span class="math">\\omega_{\\alpha}\\cdot B_{\\alpha}</span> in <span class="math">\\mathcal{K}^{\\langle\\mathsf{h}+1\\rangle}</span> simultaneously. The prover will try to convince the verifier that the random linear combination:</p>

    <p class="text-gray-300"><span class="math">\\widehat{f}^{\\overline{\\mathsf{r}}}=\\sum_{\\alpha}\\mathsf{r}_{\\alpha}\\omega_{\\alpha}B_{\\alpha}</span> (5)</p>

    <p class="text-gray-300">lies in <span class="math">\\mathcal{K}^{\\langle\\mathsf{h}+1\\rangle}</span>. This is what the prover does next.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint trace oracle:</li>

    </ol>

    <p class="text-gray-300">The Prover then represents the rational function <span class="math">\\widehat{f}^{\\overline{\\mathsf{r}}}\\in\\mathcal{K}^{\\langle\\mathsf{h}+1\\rangle}</span> as 2 univariate polynomials:</p>

    <p class="text-gray-300"><span class="math">\\widehat{f}^{\\overline{\\mathsf{r}}}(X,Y)=\\frac{1}{\\Omega^{\\langle\\mathsf{h}+1\\rangle}(X)}\\bigg{(}\\widehat{f}_{0}^{\\overline{\\mathsf{r}}}(X)+\\frac{Y}{X}\\widehat{f}_{1}^{\\overline{\\mathsf{r}}}(X)\\bigg{)},</span></p>

    <p class="text-gray-300">where <span class="math">\\widehat{f}_{m}^{\\overline{\\mathsf{r}}}\\in\\mathcal{M}_{\\mathsf{h}+1}</span> for <span class="math">m\\in\\{0,1\\}</span>.</p>

    <p class="text-gray-300">The prover then evaluates both univariate polynomials at the points of <span class="math">\\mathbf{T}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300"><span class="math">\\left\\langle\\widehat{f}_{0}^{t}\\,l\\,\\mathbf{T}\\right\\rangle</span>, <span class="math">\\left\\langle\\widehat{f}_{1}^{t}\\,l\\,\\mathbf{T}\\right\\rangle</span>.</p>

    <p class="text-gray-300">Note that these are evaluations of univariate polynomials of degree <span class="math">&lt;2^{h+1}</span> at <span class="math">2^{h+\\mathcal{R}+1}</span> points.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DEEP query:</li>

    </ol>

    <p class="text-gray-300">Verifier samples DEEP query <span class="math">\\mathsf{q}=(\\mathsf{x}_{0},\\mathsf{y}_{0})</span> uniformly at random from <span class="math">\\mathsf{E}(\\mathbb{F}_{q})\\setminus(\\overline{C}\\cup\\mathbf{S})</span>, where <span class="math">\\overline{C}=G^{\\langle\\mathsf{h}+2\\rangle}\\cup(G^{\\langle\\mathsf{h}+2\\rangle}+C)\\cup(G^{\\langle\\mathsf{h}+2\\rangle}-C)</span> is a union of three cosets of <span class="math">G^{\\langle\\mathsf{h}+2\\rangle}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>DEEP answer:</li>

    </ol>

    <p class="text-gray-300">Prover sends an answer sequence</p>

    <p class="text-gray-300"><span class="math">\\mathsf{answer}=\\langle\\langle\\alpha_{j,l,0},\\alpha_{j,l,1}:(j,l)\\in\\mathsf{I}\\rangle,\\langle\\beta_{0},\\beta_{1}\\rangle\\rangle\\in\\mathbb{F}_{q}^{\\mathsf{I}\\times\\{0,1\\}}\\times\\mathbb{F}_{q}^{2}.</span></p>

    <p class="text-gray-300">The <span class="math">\\alpha_{j,l,m}</span> are supposed to be the evaluations <span class="math">\\widehat{f}_{l,m}(\\mathsf{q}+jg)</span>, and <span class="math">\\beta_{m}</span> is supposed to be the evaluation <span class="math">\\widehat{f}_{m}^{t}(\\mathsf{q})</span>. Following the DEEP philosophy <em>[16]</em>, we can then incorporate these claimed evaluations of <span class="math">\\widehat{f}_{l,m}</span> and <span class="math">\\widehat{f}_{m}^{t}</span> by <em>quotienting</em>. This will be taken into account in the next step of the protocol. But first, the verifier has to do a basic sanity check on the claimed evaluations. Letting</p>

    <p class="text-gray-300"><span class="math">\\alpha_{j,l}</span> <span class="math">:=\\frac{1}{\\Omega^{\\langle\\mathsf{h}\\rangle}(\\pi(\\mathsf{q}+j\\cdot g))}\\left(\\alpha_{j,l,0}+\\zeta(\\mathsf{q}+j\\cdot g)\\cdot\\alpha_{j,l,1}\\right)</span> <span class="math">\\beta</span> <span class="math">:=\\frac{1}{\\Omega^{\\langle\\mathsf{h}+1\\rangle}(\\pi(\\mathsf{q}))}(\\beta_{0}+\\zeta(\\mathsf{q})\\beta_{1})</span></p>

    <p class="text-gray-300">then supposedly <span class="math">\\alpha_{j,l}=\\widehat{f}_{l}(\\mathsf{q}+j\\cdot g)</span> and <span class="math">\\beta=\\widehat{f}^{t}(\\mathsf{q})</span>. We say the constraints <span class="math">\\mathsf{Q}_{\\alpha}</span> are <em>validated</em> by answer if the following equality holds:</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\alpha}\\mathsf{r}_{\\alpha}\\omega_{\\alpha}(\\mathsf{q})\\mathsf{Q}_{\\alpha}\\big{(}(\\alpha_{j,l})_{(j,l)\\in\\mathsf{I}}\\big{)}=\\beta,</span> (6)</p>

    <p class="text-gray-300">i.e., the answers are consistent with Eq. (5).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>FRI Protocol: This step verifies the low-degreeness of various functions simultaneously. But first, we quotient out the functions <span class="math">\\widehat{f}_{l,m}</span> and <span class="math">\\widehat{f}_{m}^{t}</span> by their evaluations that the prover claimed in the previous step.</li>

    </ol>

    <p class="text-gray-300">For <span class="math">l\\in[\\mathsf{w}]</span>, define <span class="math">A_{l}\\subseteq\\mathbb{F}_{q}</span> to be the set:</p>

    <p class="text-gray-300"><span class="math">A_{l}=\\{\\pi(\\mathsf{q}+j\\cdot g)\\mid(j,l)\\in\\mathsf{I}\\}</span></p>

    <p class="text-gray-300">Define <span class="math">u_{l,m}:A_{l}\\to\\mathbb{F}_{q}</span> to be:</p>

    <p class="text-gray-300"><span class="math">u_{l,m}(\\pi(\\mathsf{q}+j\\cdot g))=\\alpha_{j,l,m}.</span></p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">For <span class="math">l\\in[\\mathsf{w}]</span> and <span class="math">m\\in\\{0,1\\}</span>, define <span class="math">\\widehat{b}_{l,m}:\\mathbf{T}\\to\\mathbb{F}_{q}</span> by:</p>

    <p class="text-gray-300"><span class="math">\\widehat{b}_{l,m}(x)=\\textsf{Quotient}\\left(\\widehat{f}_{l,m};u_{l,m}\\right)(x),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and degree parameter $d_{l,m}=2^{\\mathsf{h}}-1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">m\\in\\{0,1\\}</span>, define <span class="math">u_{m}:\\{\\pi(\\mathsf{q})\\}\\to\\mathbb{F}_{q}</span> by</p>

    <p class="text-gray-300"><span class="math">u_{m}(\\pi(\\mathsf{q}))=\\beta_{m}.</span></p>

    <p class="text-gray-300">Now define <span class="math">\\widehat{b}_{m}^{\\prime}:\\mathbf{T}\\to\\mathbb{F}_{q}</span> by:</p>

    <p class="text-gray-300"><span class="math">\\widehat{b}_{m}^{\\prime}(x)=\\textsf{Quotient}\\left(\\widehat{f}_{m}^{\\prime};u_{m}\\right)(x),</span></p>

    <p class="text-gray-300">and degree parameter <span class="math">d_{m}=2^{\\mathsf{h}+1}-2</span>.</p>

    <p class="text-gray-300">Note that oracle access to these functions can be simulated by the verifier from oracle access to <span class="math">\\widehat{f}_{l,m}</span> and <span class="math">\\widehat{f}_{m}^{\\prime}</span> on <span class="math">\\mathbf{T}</span>.</p>

    <p class="text-gray-300">&gt; Prover and Verifier now run the Batched FRI protocol from Theorem 13 on all the <span class="math">\\widehat{b}_{l,m}</span> and the <span class="math">\\widehat{b}_{m}^{\\prime}</span> with degree parameters <span class="math">d_{l,m}</span> and <span class="math">d_{m}</span>, and repetition parameter <span class="math">t</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that all the degree parameters are smaller than $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> – thus the soundness of this step is governed by </span>\\rho<span class="math"> and </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decision:</li>

    </ol>

    <p class="text-gray-300">&gt; Verifier accepts iff (i) the constraints <span class="math">\\mathsf{Q}_{\\alpha}</span> are validated by answer (i.e., equation (6) holds), and (ii) the FRI protocol accepts.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">3.3 Proof of Theorem 4</h3>

    <p class="text-gray-300">We now prove Theorem 4. As usual, the most intricate part is the claim of soundness, or, in our case, knowledge soundness.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Theorem 15.</h6>

    <p class="text-gray-300">Let <span class="math">n=2^{\\mathsf{h}}\\cdot w</span>. Let <span class="math">\\eta&amp;gt;0</span> be an arbitrary real number. The protocol described in Section 3.2 has the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proving Complexity: <span class="math">O(2^{\\mathsf{h}}\\cdot\\mathsf{h}\\cdot w\\cdot\\frac{1}{\\rho}+t)</span>,</li>

      <li>Query Complexity: <span class="math">O(\\mathsf{h}\\cdot w\\cdot t)</span>,</li>

      <li>Verification Time: <span class="math">O(t\\cdot\\mathsf{h})</span>,</li>

      <li>Proof Length: <span class="math">\\frac{1}{\\rho}\\cdot 2^{\\mathsf{h}}\\cdot 2\\cdot(2w+3)</span>, which is at most <span class="math">10\\cdot\\frac{1}{\\rho}\\cdot n</span>.</li>

      <li>Completeness: If the AIR is satisifable, there is a strategy that makes the verifier accept with probability <span class="math">1</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness and knowledge soundness: If some prover <span class="math">\\mathsf{P}^{*}</span> can make the verifier specified above accept with probability greater than soundness error <span class="math">p_{0}</span>, where</li>

    </ul>

    <p class="text-gray-300"><span class="math">p_{0}=\\left(\\rho^{1/2}+\\eta\\right)^{t}+O\\left(\\frac{2^{2\\mathsf{h}}}{\\eta^{7}q}\\right),</span> (7)</p>

    <p class="text-gray-300">then the AIR is satisfiable. Furthermore, there is an extractor that runs in time <span class="math">\\mathsf{poly}(2^{\\mathsf{h}})</span> while interacting with <span class="math">\\mathsf{P}^{*}</span> and outputs w.h.p. a satisfying assignment per Definition 5.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">6.2.2 Resources</h4>

    <p class="text-gray-300">We first verify the claims about the running times, communication and proof lengths.</p>

    <p class="text-gray-300">An honest prover, given access to a satisfying assignment <span class="math">\\mathsf{f}</span> to the AIR <span class="math">\\mathsf{A}</span>, will:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>perform an <span class="math">\\mathsf{IFFT}</span> and some <span class="math">\\mathsf{FFT}</span>s in Step 1 to compute the <span class="math">\\widehat{f}_{l}</span> and the <span class="math">\\left\\langle\\widehat{f}_{l}\\wr\\mathbf{S}\\right\\rangle</span> (in time <span class="math">O(\\mathsf{w}\\cdot\\mathsf{h}\\cdot 2^{\\mathsf{h}})</span>),</li>

      <li>compute <span class="math">\\left\\langle B_{\\alpha}\\wr\\mathbf{S}\\right\\rangle</span> and <span class="math">\\omega_{\\alpha}</span> for each <span class="math">\\alpha</span> (in time <span class="math">O\\left(2^{\\mathsf{h}}\\cdot\\sum_{\\alpha}(\\left\\lVert\\mathsf{Q}_{\\alpha}\\right\\rVert+\\left\\lVert\\mathsf{H}_{\\alpha}\\right\\rVert)\\right)</span>),</li>

      <li>Compute <span class="math">\\widehat{f}^{\\mathsf{r}}</span> and <span class="math">\\left\\langle\\widehat{f}^{\\mathsf{r}}\\wr\\mathbf{S}\\right\\rangle</span>,</li>

      <li>Find <span class="math">\\widehat{f}_{l}(\\mathsf{q}+j\\cdot g)</span> for each <span class="math">(j,l)\\in\\mathsf{I}</span>, and then use this to find <span class="math">\\widehat{f}^{\\mathsf{r}}(\\mathsf{q})</span>.</li>

    </ul>

    <p class="text-gray-300">The claimed running time of the prover thus follows easily.</p>

    <p class="text-gray-300">The verifier running time is similarly easily seen.</p>

    <p class="text-gray-300">The total proof length comes from <span class="math">2w+2</span> functions from <span class="math">\\mathbf{T}</span> to <span class="math">\\mathbb{F}_{q}</span>, along with what the prover sends during the <span class="math">\\mathsf{FRI}</span> protocol: this gives the desired claim about the total proof length.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">6.2.3 Completeness</h4>

    <p class="text-gray-300">The intended response of the prover is specified in the description of the IOP. The completeness is immediate from this description.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">6.2.4 Soundness and knowledge soundness</h4>

    <p class="text-gray-300">Suppose the Prover has a strategy that makes the Verifier accept with probability at least <span class="math">p_{0}</span> as defined in Eq. (7). We will show that the AIR instance <span class="math">\\mathsf{A}</span> is satisfiable, and that a knowledge extractor can find the satisfying AIR assignment. This establishes the claimed soundness of the protocol.</p>

    <p class="text-gray-300">For knowledge soundness, one shows that this satisfying assignment can be found by an efficient knowledge extractor – given our soundness analysis, the details are almost identical to the FFT-friendly case <em>[57]</em>, and we omit them. A key role is played by the Guruswami–Sudan list decoding algorithm for Reed–Solomon codes <em>[41]</em>.</p>

    <p class="text-gray-300">Since the Prover communicates first, we may as well assume that the Prover’s first message (the <span class="math">\\left\\langle\\widehat{f}_{l}\\wr\\mathbf{T}\\right\\rangle</span>) is fixed to be the one that maximizes the probability of acceptance, and thus to one which makes it at least <span class="math">p_{0}</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Consider the list of all tuples of polynomials that have high agreement with the <span class="math">\\left\\langle\\widehat{f}_{l}\\wr\\mathbf{T}\\right\\rangle</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}=\\bigg{\\{}(P_{l,m})_{l\\in[\\mathsf{w}],m\\in\\{0,1\\}}\\in(\\mathbb{F}_{q}[X])^{2\\mathsf{w}}\\mid\\deg(P_{l,m})\\leq 2^{\\mathsf{h}},</span> <span class="math">\\Pr_{x\\in\\mathbf{T}}\\Big{[}\\forall(l,m)\\in[\\mathsf{w}]\\times\\{0,1\\},P_{l,m}(x)=\\widehat{f}_{l,m}(x)\\Big{]}\\geq\\rho^{1/2}+\\eta\\bigg{\\}}.</span></p>

    <p class="text-gray-300">By the Johnson bound (Theorem 20), we have that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{1}{2\\eta\\sqrt{\\rho}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The satisfying AIR assignment will come from one of these tuples.</p>

    <p class="text-gray-300">Similarly, let</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}^{\\prime}=\\bigg{\\{}(P_{m})_{m\\in\\{0,1\\}}\\in(\\mathbb{F}_{q}[X])^{2}\\mid</span> <span class="math">\\deg(P_{m})\\leq 2^{\\mathsf{h}+1},</span> <span class="math">\\Pr_{x\\in\\mathbf{T}}\\Big{[}\\forall m\\in\\{0,1\\},P_{m}(x)=\\widehat{f}_{m}^{\\prime}(x)\\Big{]}\\geq\\rho^{1/2}+\\eta\\bigg{\\}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the Johnson bound, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{1}{2\\eta\\sqrt{\\rho}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define <span class="math">\\epsilon</span> by:</p>

    <p class="text-gray-300"><span class="math">\\epsilon:=\\frac{1}{\\eta^{2}\\rho}\\left(\\frac{2^{\\mathsf{h}+\\mathcal{R}+1}}{q}\\right)+\\frac{1}{\\eta\\sqrt{\\rho}}\\frac{1}{q}.</span></p>

    <p class="text-gray-300">Since <span class="math">2^{2\\mathsf{h}}&lt;q</span>, we get that <span class="math">\\epsilon=o\\left(\\frac{2^{2\\mathsf{h}}}{\\eta^{2}q}\\right)</span> as <span class="math">q\\to\\infty</span>.</p>

    <p class="text-gray-300">Let <span class="math">E</span> be the event that after the first 5 steps of the protocol, both the following happen:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the probability of the FRI protocol accepting in step 6 is at least</li>

    </ul>

    <p class="text-gray-300"><span class="math">p_{0}-\\epsilon\\geq\\left(\\rho^{1/2}+\\eta\\right)^{t}+O\\left(\\frac{2^{2\\mathsf{h}}}{\\eta^{7}q}\\right)</span></p>

    <p class="text-gray-300">for <span class="math">p_{0}</span> defined in Eq. (7); and</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Eq. (6) holds.</li>

    </ul>

    <p class="text-gray-300">Then <span class="math">\\Pr[E]\\geq\\epsilon</span>.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6"><span class="math">E</span> implies a special relationship between <span class="math">\\mathcal{L}</span>, <span class="math">\\mathcal{L}^{\\prime}</span> and <span class="math">\\mathfrak{q}</span></h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">E</span> occurs. Then by Theorem 13 we get that there exists a subset <span class="math">V\\subseteq\\mathbf{T}</span>, with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\sqrt{\\rho}+\\eta<span class="math"> and polynomials </span>\\widehat{B}_{l,m}(X)<span class="math"> of degree at most </span>d_{l,m}<span class="math"> and </span>\\widehat{B}_{m}(X)<span class="math"> of degree at most </span>d_{m}<span class="math"> such that for all </span>x\\in V<span class="math"> and all </span>l,m$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\widehat{B}_{l,m}(x)=\\widehat{b}_{l,m}(x),</span></p>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {B} _ {m} (x) = \\widehat {b} _ {m} ^ {\\mathrm {r}} (x).</span></div>

    <p class="text-gray-300">Opening up the definition of quotient in the  <span class="math">\\widehat{b}_{l,m}</span>  and the  <span class="math">\\widehat{b}_m^r</span> , we get that for all  <span class="math">x \\in V</span> :</p>

    <div class="my-4 text-center"><span class="math-block">F _ {l, m} (x) = \\widehat {f} _ {l, m} (x),</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {m} (x) = \\widehat {f} _ {m} ^ {\\mathrm {r}} (x),</span></div>

    <p class="text-gray-300">where:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {l, m} (X) = \\widehat {B} _ {l, m} (X) \\cdot Z _ {A _ {l}} (X) + U _ {l} (X)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is a polynomial of degree at most  $d_{l,m} +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_l</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{\\mathsf{h}} - 1$ , and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">F _ {m} (X) = \\widehat {B} _ {m} (X) (X - \\pi (\\mathfrak {q})) + \\beta_ {m}</span></div>

    <p class="text-gray-300">is a polynomial of degree at most  <span class="math">d_m + 1 = 2^{\\mathsf{h} + 1} - 1</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\rho^{1 / 2} + \\eta$ , we conclude that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">(F _ {l, m}) _ {l \\in [ \\mathbf {w} ], m \\in \\{0, 1 \\}} \\in \\mathcal {L}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(F _ {m}\\right) _ {m \\in \\{0, 1 \\}} \\in \\mathcal {L} ^ {\\prime}.</span></div>

    <p class="text-gray-300">Observe that each  <span class="math">F_{l,m}</span>  and  <span class="math">F_{m}</span>  is a polynomial whose evaluations are consistent with the claimed DEEP answers:</p>

    <div class="my-4 text-center"><span class="math-block">F _ {l, m} (\\pi (\\mathfrak {q} + j \\cdot g)) = \\alpha_ {j, l, m}.</span></div>

    <div class="my-4 text-center"><span class="math-block">F _ {m} (\\pi (\\mathfrak {q})) = \\beta_ {m}.</span></div>

    <p class="text-gray-300">Combining the above argument with Eq. (6), the situation can be summarized as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">\\vec{P} = (P_{l,m})_{(l,m)\\in \\mathsf{I}}\\in \\mathcal{L}</span> , define the rational functions:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">P _ {l} (Z) := \\frac {1}{\\Omega^ {\\langle \\mathfrak {h} \\rangle} (\\pi (Z))} \\left(P _ {l, 0} (\\pi (Z)) + \\zeta (Z) P _ {l, 1} (\\pi (Z))\\right), l \\in \\{1, \\dots , \\mathbf {w} \\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\gamma_ {\\vec {P}} (Z) := \\sum_ {\\alpha} \\mathsf {r} _ {\\alpha} \\omega_ {\\alpha} (Z) \\mathsf {Q} _ {\\alpha} \\left((P _ {l} (Z + j \\cdot g)) _ {(j, l) \\in \\mathsf {I}}\\right),</span></div>

    <p class="text-gray-300">Observe that  <span class="math">\\vec{P}(Z) \\in \\mathcal{L}([G^{\\langle \\mathfrak{h} + 2\\rangle}] + [C])</span> . Indeed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">l</span> ,  <span class="math">P_{l}</span>  is in  <span class="math">\\mathcal{K}^{\\langle \\mathfrak{h}\\rangle}</span>  (since  <span class="math">\\deg(P_{l,0}), \\deg(P_{l,1}) \\leq 2^{\\mathfrak{h}} - 1</span> ), and since  <span class="math">\\mathcal{K}^{\\langle \\mathfrak{h}\\rangle}</span>  is invariant under translation of the argument by  <span class="math">g</span> ,  <span class="math">P_{l}(Z + j \\cdot g)</span>  is also in  <span class="math">\\mathcal{K}^{\\langle \\mathfrak{h}\\rangle}</span> .</li>

      <li>Applying the degree 2 polynomial  <span class="math">Q_{\\alpha}</span>  to a collection of elements in  <span class="math">\\mathcal{K}^{\\langle \\mathfrak{h}\\rangle} = \\mathcal{L}([G^{\\langle \\mathfrak{h} + 1\\rangle}])</span>  results in a rational function in  <span class="math">\\mathcal{L}(2[G^{\\langle \\mathfrak{h} + 1\\rangle}])</span> .</li>

      <li>Multiplying a rational function in  <span class="math">\\mathcal{L}(2[G^{\\langle \\mathfrak{h} + 1\\rangle}])</span>  with  <span class="math">\\omega_{\\alpha}</span>  results in a function in  <span class="math">\\mathcal{L}([G^{\\langle \\mathfrak{h} + 2\\rangle}] + [C])</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">\\vec{W} = (W_{m})_{m\\in \\{0,1\\}}\\in \\mathcal{L}^{\\prime}</span> , define the rational function:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\lambda_ {\\vec {W}} (Z) := \\frac {1}{\\Omega^ {\\langle \\mathfrak {h} + 1 \\rangle} (\\pi (Z))} \\left(W _ {0} (\\pi (Z)) + \\zeta (Z) W _ {1} (\\pi (Z))\\right).</span></div>

    <p class="text-gray-300">Observe that  <span class="math">\\lambda_{\\vec{W}}(Z)\\in \\mathcal{K}^{\\langle \\mathfrak{h} + 1\\rangle}</span>  (since  <span class="math">\\deg (W_0),\\deg (W_1)\\leq 2^{\\mathfrak{h} + 1} - 1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">E</span> occurs, then there is some <span class="math">\\vec{P}=(P_{l,m})_{(l,m)\\in\\mathsf{I}}\\in\\mathcal{L}</span> and some <span class="math">\\vec{W}=(W_{m})_{m\\in\\{0,1\\}}\\in\\mathcal{L}^{\\prime}</span> such that the low-degree rational functions <span class="math">\\gamma_{\\vec{P}}\\in\\mathscr{L}([G^{\\langle\\mathfrak{h}+2\\rangle}]+[C])</span> and <span class="math">\\lambda_{\\vec{W}}\\in\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}=\\mathscr{L}([G^{\\langle\\mathfrak{h}+2\\rangle}])</span> have the same evaluation at the point <span class="math">\\mathfrak{q}</span>.</li>

    </ul>

    <h4 id="sec-53" class="text-lg font-semibold mt-6"><span class="math">\\mathcal{L}</span> and <span class="math">\\mathcal{L}^{\\prime}</span> have a special relationship often</h4>

    <p class="text-gray-300">We know that <span class="math">\\Pr[E]\\geq\\epsilon</span>, and whenever <span class="math">E</span> happens, there is a strong relationship between <span class="math">\\mathcal{L}</span>, <span class="math">\\mathcal{L}^{\\prime}</span> and <span class="math">\\mathfrak{q}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathcal{L}</span> is determined after Step 1, and <span class="math">\\mathcal{L}^{\\prime}</span> is determined by Step 3 of the protocol. <span class="math">\\mathfrak{q}</span> is only chosen in Step 4. We now show that by Step 3 of the protocol, <span class="math">\\mathcal{L}</span> and <span class="math">\\mathcal{L}^{\\prime}</span> must already have quite a special relationship.</p>

    <p class="text-gray-300">Let <span class="math">H</span> be the event, determined after Step 3, that there exist some <span class="math">\\vec{P}\\in\\mathcal{L}</span> and some <span class="math">\\vec{W}\\in\\mathcal{L}^{\\prime}</span> such that the rational functions <span class="math">\\lambda_{\\vec{P}}</span> and <span class="math">\\gamma_{\\vec{W}}</span> are identical.</p>

    <p class="text-gray-300">We will show that</p>

    <p class="text-gray-300"><span class="math">\\Pr[H]\\geq\\epsilon-\\frac{1}{4\\eta^{2}\\rho}\\frac{2^{\\mathsf{h}+\\mathcal{R}+1}}{q}&gt;\\frac{1}{\\eta\\sqrt{\\rho}}\\frac{1}{q}.</span> (8)</p>

    <p class="text-gray-300">The second inequality is by definition of <span class="math">\\epsilon</span>, and the first follows from:</p>

    <p class="text-gray-300">Claim.</p>

    <p class="text-gray-300"><span class="math">\\Pr[E\\mid\\overline{H}]\\leq\\frac{1}{4\\eta^{2}\\rho}\\frac{2^{\\mathsf{h}+\\mathcal{R}+1}}{q}.</span></p>

    <p class="text-gray-300">Proof (Proof of Section 3.3). Condition on the state of the protocol at the conclusion of Step 3. For fixed <span class="math">\\vec{P}\\in\\mathcal{L}</span>, <span class="math">\\vec{W}\\in\\mathcal{L}^{\\prime}</span>, let <span class="math">E_{\\vec{P},\\vec{W}}</span> denote the event that <span class="math">\\gamma_{\\vec{P}}</span> and <span class="math">\\lambda_{\\vec{W}}</span> agree at <span class="math">\\mathfrak{q}</span>. By the above,</p>

    <p class="text-gray-300"><span class="math">E\\subseteq\\bigcup_{\\vec{P}\\in\\mathcal{L},\\vec{W}\\in\\mathcal{L}^{\\prime}}E_{\\vec{P},\\vec{W}}.</span></p>

    <p class="text-gray-300">By the union bound, we get:</p>

    <p class="text-gray-300"><span class="math">\\Pr[E\\mid\\overline{H}]\\leq\\sum_{\\vec{P}\\in\\mathcal{L},\\vec{W}\\in\\mathcal{L}^{\\prime}}\\Pr[E_{\\vec{P},\\vec{W}}\\mid\\overline{H}].</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For each <span class="math">\\vec{P}\\in\\mathcal{L}</span> and <span class="math">\\vec{W}\\in\\mathcal{L}^{\\prime}</span>, we know that <span class="math">\\gamma_{\\vec{P}}</span> and <span class="math">\\lambda_{\\vec{W}}</span> are distinct, low-degree rational functions (they both lie in <span class="math">\\mathscr{L}([G^{\\langle\\mathfrak{h}+2\\rangle}]+[C])</span>, and thus the probability that they agree on the randomly chosen point <span class="math">\\mathfrak{q}</span> (chosen uniformly from among $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{E}(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq q-2\\sqrt{q}-2^{\\mathsf{h}+\\mathcal{R}+3}$ points) is small. Explicitly, we get:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[E_{\\vec{P},\\vec{W}}\\mid\\overline{H}]\\leq\\frac{2^{\\mathsf{h}+\\mathcal{R}}}{q-2\\sqrt{q}-2^{\\mathsf{h}+\\mathcal{R}+3}}\\leq\\frac{2^{\\mathsf{h}+\\mathcal{R}+1}}{q},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and by our bounds on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{L}^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, Section 3.3 follows, and with it, so does Eq. (8).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">tracting the satisfying AIR assignment</p>

    <p class="text-gray-300">We just saw that the event <span class="math">H</span> happens with noticeable probability.</p>

    <p class="text-gray-300">If <span class="math">H</span> happens, then it means that there is some <span class="math">\\vec{P}\\in\\mathcal{L}</span> such that <span class="math">\\gamma_{\\vec{P}}\\in\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}</span>. Recall that <span class="math">\\mathcal{L}</span> is determined after Step 1 (and is deterministic by our assumption that the Prover’s first message is deterministic), but <span class="math">\\gamma_{\\vec{P}}</span> is only determined after the randomness <span class="math">\\vec{r}:=(r_{1},\\ldots,r_{s})\\in\\mathbb{F}_{q}^{s}</span> is chosen in Step 2.</p>

    <p class="text-gray-300">Let us look into the structure of the rational function <span class="math">\\gamma_{\\vec{P}}</span> (which apriori lies in <span class="math">\\mathscr{L}([G^{\\langle\\mathfrak{h}+2\\rangle}]+[C])</span>. It is the inner product between</p>

    <p class="text-gray-300"><span class="math">\\vec{r}:=(r_{1},\\ldots,r_{s})\\in\\mathbb{F}_{q}^{s}</span></p>

    <p class="text-gray-300">and the vector <span class="math">\\Gamma_{\\vec{P}}\\in\\mathscr{L}([G^{\\langle\\mathfrak{h}+2\\rangle}]+[C])^{s}</span> given by:</p>

    <p class="text-gray-300"><span class="math">\\Gamma_{\\vec{P}}=\\left(\\omega_{\\alpha}(Z)\\mathsf{Q}_{\\alpha}\\left(\\left(P_{l}(Z+j\\cdot g)\\right)_{(j,l)\\in\\mathsf{I}}\\right)\\right)_{\\alpha\\in\\{1,\\ldots,s\\}}.</span></p>

    <p class="text-gray-300">We say <span class="math">\\vec{P}</span> is good if all entries of <span class="math">\\Gamma_{\\vec{P}}</span> lie in <span class="math">\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\vec{P}</span> is not good, then the probability that a random linear combination of the entries of <span class="math">\\Gamma_{\\vec{P}}</span> entries lies in <span class="math">\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}</span> (which is a strict subspace of the span of the entries) is at most <span class="math">\\frac{1}{q}</span>. That is,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\gamma_{\\vec{P}}\\in\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}]\\leq\\frac{1}{q}.</span></p>

    <p class="text-gray-300">If all the <span class="math">\\vec{P}\\in\\mathcal{L}</span> are not good, we get:</p>

    <p class="text-gray-300"><span class="math">\\Pr[H]</span> <span class="math">\\leq\\Pr[\\exists\\vec{P}\\in\\mathcal{L}\\text{ s.t. }\\gamma_{\\vec{P}}\\in\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}]</span> <span class="math">\\leq\\sum_{\\vec{P}\\in\\mathcal{L}}\\Pr[\\gamma_{\\vec{P}}\\in\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}]</span> <span class="math">\\leq\\frac{1}{2\\eta\\sqrt{\\rho}}\\cdot\\frac{1}{q},</span></p>

    <p class="text-gray-300">which contradicts our lower bound (Eq. (8)) on <span class="math">\\Pr[H]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus some <span class="math">\\vec{P}\\in\\mathcal{L}</span> is good. This will give us our satisfying AIR assignment. For each <span class="math">l\\in[\\mathsf{w}]</span>, let <span class="math">f_{l}^{\\star}=P_{l}\\in\\mathcal{K}^{\\langle\\mathfrak{h}\\rangle}</span> for some fixed good <span class="math">\\vec{P}</span>. Then $\\left.f_{l}^{\\star}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{C}<span class="math"> gives us a function defined on </span>\\mathsf{H}_{0}<span class="math"> (via the identification of </span>\\mathsf{H}_{0}<span class="math"> with the coset </span>C$). We claim that this is the desired satisfying AIR assignment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fix <span class="math">\\alpha</span>. By the goodness of <span class="math">\\vec{P}</span>, we get that the rational function:</p>

    <p class="text-gray-300"><span class="math">\\omega_{\\alpha}(Z)\\cdot Q_{\\alpha}\\left(\\left(f_{l}^{\\star}(Z+j\\cdot g)\\right)_{(j,l)\\in\\mathsf{I}}\\right)</span></p>

    <p class="text-gray-300">lies in <span class="math">\\mathcal{K}^{\\langle\\mathfrak{h}+1\\rangle}</span>, which means (by the defining property of <span class="math">\\omega_{\\alpha}</span>) that the rational function</p>

    <p class="text-gray-300"><span class="math">B_{\\alpha}^{\\star}(Z)=Q_{\\alpha}\\left(\\left(f_{l}^{\\star}(Z+j\\cdot g)\\right)_{(j,l)\\in\\mathsf{I}}\\right)</span></p>

    <p class="text-gray-300">vanishes at all points is <span class="math">\\mathsf{U}_{\\alpha}</span> (which is identified with the <span class="math">\\alpha</span>-th enforcement domain <span class="math">\\mathsf{H}_{\\alpha}</span>). This is precisely the statement that <span class="math">(f_{l}^{\\star})_{l\\in[\\mathsf{w}]}</span> satisfies the <span class="math">\\alpha</span>-th constraint.</p>

    <p class="text-gray-300">Since this holds for each <span class="math">\\alpha</span>, we conclude that <span class="math">f_{1}^{\\star},\\ldots,f_{\\mathsf{w}}^{\\star}</span> is a satisfying AIR assignment per Definition 5, as desired.</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">The backbone of all of the constructions in this paper is the chain of 2-isogenies whose existence was shown in [9, Theorem 4.9], which we quoted earlier and restate here:</p>

    <p class="text-gray-300">Theorem 16. For any prime power  <span class="math">q \\geq 7</span>  and any  <span class="math">1 &amp;lt; \\mathsf{K} = 2^{\\mathsf{k}} \\leq 2\\sqrt{q}</span> , there exist elliptic curves  <span class="math">E_0, E_1, \\ldots, E_{\\mathsf{k}}</span>  over  <span class="math">\\mathbb{F}_q</span>  in extended Weierstrass form, a subgroup  <span class="math">G_0 \\subseteq E_0</span>  of size  <span class="math">\\mathsf{K}</span> , 2-isogenies  <span class="math">\\varphi_i : E_i \\to E_{i+1}</span>  and rational functions  <span class="math">\\psi_i : \\mathbb{P}^1 \\to \\mathbb{P}^1</span>  of degree 2, such that the following diagram is commutative:</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_i</span>  are the projection maps to the  <span class="math">x</span> -coordinate of each curve;</li>

      <li><span class="math">\\ker (\\varphi_i)\\subseteq G_i\\coloneqq \\varphi_{i - 1}\\circ \\dots \\circ \\varphi_0(G_0)</span>  for all  <span class="math">i</span>  ; and</li>

      <li><span class="math">G_0</span>  has a coset  <span class="math">C</span>  such that  <span class="math">C \\neq -C</span>  (as elements of the quotient group  <span class="math">E_0 / G_0</span> ).</li>

    </ul>

    <p class="text-gray-300">Note that this theorem is very abstract: It only establishes the existence of these curves and maps, but says almost nothing about how the form of the equations defining  <span class="math">E_{i}</span>  or of the isogenies  <span class="math">\\varphi_{i}</span>  and maps  <span class="math">\\psi_{i}</span> , does not specify the structure of the 2-groups  <span class="math">G_{i}</span> , and does not show how to find such curves.</p>

    <p class="text-gray-300">In this section we will restrict the form of the curves  <span class="math">E_{i}</span>  and obtain explicit formulas for  <span class="math">\\varphi_{i}</span>  and  <span class="math">\\psi_{i}</span> ; we will restrict  <span class="math">G_{0}</span>  to be a cyclic group isomorphic to  <span class="math">\\mathbb{Z}/2^{\\mathbf{k}}\\mathbb{Z}</span>  (and thus all other  <span class="math">G_{i}</span> -s are also cyclic) and show that it is a feasible requirement; and outline a probabilistic algorithm for finding such curves efficiently. More specifically, we show:</p>

    <p class="text-gray-300">There is an efficient algorithm, FindCurve(q,k), which yields an elliptic curve  <span class="math">E_0</span>  over  <span class="math">\\mathbb{F}_q</span>  with cyclic subgroup  <span class="math">G_0</span>  of order  <span class="math">2^{\\mathrm{k}}</span>  and run in quasilinear time (Theorem 17). This curve can then be presented as a good curve (Definitions 9 and 10 and Lemma 3), from which an isogeny chain as in Eq. (3) can be constructed (Section 4.2), where all curves  <span class="math">E_1,\\ldots ,E_{\\mathrm{k - 1}}</span>  are good curves and all isogenies  <span class="math">\\varphi_0,\\dots ,\\varphi_{\\mathrm{k - 1}}</span>  are good isogenies (Lemmas 1 and 2).</p>

    <p class="text-gray-300">In this subsection, we define particularly nice forms for our desired curves: one form for odd  <span class="math">q</span> , and one for even  <span class="math">q</span> . These forms will have the property that once  <span class="math">E_0</span>  is of this form, then all the rest of the curves in the chain are, too. They will also all share the same 2-torsion point  <span class="math">\\mathbf{0} = (0,0)</span> , and all isogenies will be such that  <span class="math">\\ker \\varphi_i = \\{\\mathbf{0},\\infty\\}</span> , leading to efficiently computable formulas for  <span class="math">\\varphi_i</span>  and  <span class="math">\\psi_i</span> , of the same form at every level.</p>

    <p class="text-gray-300">We first present all relevant definitions and statements about these forms.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Definition 9 (Good curve over odd size fields)</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be an odd prime power. Denote by <span class="math">E_{a,B}</span> the elliptic curve over <span class="math">\\mathbb{F}_{q}</span> given by the Weierstrass equation</p>

    <p class="text-gray-300"><span class="math">E_{a,B}:\\qquad Y^{2}=X^{3}+aX^{2}+BX.</span></p>

    <p class="text-gray-300">Note that for the curve to be non-singular, we must have <span class="math">B,a^{2}-4B\\neq 0</span>.</p>

    <p class="text-gray-300">We say that the curve <span class="math">E_{a,B}</span> is <em>good</em> if <span class="math">B=b^{2}\\neq 0</span> is a non-zero quadratic residue, and <span class="math">a+2b</span> is a quadratic residue. In this case the point <span class="math">P=\\left(b,b\\sqrt{a+2b}\\right)</span> is an <span class="math">\\mathbb{F}_{q}</span>-point on the curve, which we call its <em>good point</em>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Definition 10 (Good curve over even size fields)</h6>

    <p class="text-gray-300">Let <span class="math">q</span> be a power of <span class="math">2</span>. Denote by <span class="math">E_{B}</span> the elliptic curve over <span class="math">\\mathbb{F}_{q}</span> given by the Weierstrass equation</p>

    <p class="text-gray-300"><span class="math">E_{B}:\\qquad Y^{2}+XY=X^{3}+BX.</span></p>

    <p class="text-gray-300">Note that the curve is non-singular iff <span class="math">B\\neq 0</span>, and all such curves will be called <em>good</em>. Write <span class="math">B=b^{2}</span> with <span class="math">b\\in\\mathbb{F}_{q}</span> (always possible in characteristic 2). The <em>good point</em> of <span class="math">E_{b^{2}}</span> is <span class="math">P=(b,b)</span>.</p>

    <p class="text-gray-300">These curves have the following properties: All curves <span class="math">E_{a,B}</span> and <span class="math">E_{B}</span> pass through the points <span class="math">\\boldsymbol{\\infty}=[0:1:0]</span> and <span class="math">\\mathbf{0}=(0,0)</span>, and <span class="math">\\mathbf{0}</span> is a 2-torsion point, as mentioned above. For good curves, the good point <span class="math">P</span> is always a 4-torsion point, with <span class="math">2P=\\mathbf{0}</span> (the conditions for being a good curve are exactly the conditions for the existence of such a point). Finally, the good curves all have nice isogenies to other curves of similar forms, as described by the following lemmas:</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Lemma 1 (Good isogenies over odd size fields)</h6>

    <p class="text-gray-300">Let <span class="math">E=E_{a,b^{2}}</span> be a good curve in odd characteristic, with good point <span class="math">P</span>. Let <span class="math">E^{\\prime}=E_{a+6b,4ab+8b^{2}}</span>. Then there is a 2-isogeny <span class="math">\\varphi=\\varphi_{b}:E\\to E^{\\prime}</span> given by</p>

    <p class="text-gray-300"><span class="math">\\varphi(x,y)=\\left(x-2b+\\frac{b^{2}}{x},\\left(1-\\frac{b^{2}}{x^{2}}\\right)y\\right).</span></p>

    <p class="text-gray-300">Furthermore, we have <span class="math">\\ker\\varphi=\\{\\mathbf{0},\\boldsymbol{\\infty}\\}</span> and <span class="math">\\varphi^{-1}(\\mathbf{0})=\\{\\pm P\\}</span>. We call this <span class="math">\\varphi</span> the <em>good isogeny</em> of <span class="math">E</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 2 (Good isogenies over even size fields)</h6>

    <p class="text-gray-300">Let <span class="math">E=E_{b^{2}}</span> be a good curve in even characteristic, with good point <span class="math">P</span>. Denote <span class="math">E^{\\prime}=E_{b}</span>. Then there is a <span class="math">2</span>-isogeny <span class="math">\\varphi=\\varphi_{b}:E\\to E^{\\prime}</span> given by</p>

    <p class="text-gray-300"><span class="math">\\varphi(x,y)=\\left(x+\\frac{b^{2}}{x},\\frac{b(b+x)}{x}+\\left(1+\\frac{b^{2}}{x^{2}}\\right)y\\right)</span></p>

    <p class="text-gray-300">Furthermore, we have <span class="math">\\ker\\varphi=\\{\\mathbf{0},\\boldsymbol{\\infty}\\}</span> and <span class="math">\\varphi^{-1}(\\mathbf{0})=\\{\\pm P\\}</span>. We call this <span class="math">\\varphi</span> the <em>good isogeny</em> of <span class="math">E</span>.</p>

    <p class="text-gray-300">We also remark that these forms do not restrict us in any way; in either odd or even characteristic, any curve with a 4-torsion point can be expressed as a good curve, after an appropriate change of coordinates. Formally, we have:</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">Lemma 3. Given an elliptic curve  <span class="math">E</span>  over any finite field with a 4-torsion point  <span class="math">P</span> , it is isomorphic to a good curve with good point that corresponds to  <span class="math">P</span> .</p>

    <p class="text-gray-300">We now explore and prove the above properties and statements, dealing separately with the odd and even cases.</p>

    <p class="text-gray-300">Odd characteristic case Let  <span class="math">E_{a,B}</span>  be a curve as in Definition 9. We explore the conditions for there being a point  <span class="math">P = (b,y_b)\\in E(\\mathbb{F}_q)</span>  with  <span class="math">2P = 0</span> . Since  <span class="math">\\mathbf{0} = -\\mathbf{0}</span> , this is equivalent to the tangent to the curve at  <span class="math">P</span>  passing through  <span class="math">\\mathbf{0}</span> . Equivalently, the vector  <span class="math">\\overrightarrow{\\mathbf{0}P} = (b,y_b)</span>  must be parallel to the tangent at  <span class="math">P</span> , which is equivalent to being perpendicular to the gradient of the curve equation at  <span class="math">P</span> , i.e. to  <span class="math">\\nabla_{(b,y_b)}E_{a,B}</span> . Thus  <span class="math">2P = \\mathbf{0}</span>  is equivalent to</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\langle \\nabla_ {(b, y _ {b})} E _ {a, B}, (b, y _ {b}) \\right\\rangle = 2 y _ {b} ^ {2} - 3 b ^ {3} - 2 a b ^ {2} - B b = - b ^ {3} + B b.</span></div>

    <p class="text-gray-300">Note that  <span class="math">b \\neq 0</span>  (since otherwise it would imply  <span class="math">2P = \\infty</span> ), so we can divide the identity by  <span class="math">b</span>  to obtain  <span class="math">B = b^2</span> . In other words, such curves are of the form</p>

    <div class="my-4 text-center"><span class="math-block">E _ {a, b ^ {2}}: \\qquad Y ^ {2} = X ^ {3} + a X ^ {2} + b ^ {2} X,</span></div>

    <p class="text-gray-300">with the point  <span class="math">P</span>  being  <span class="math">(b, b\\sqrt{a + 2b})</span> , as per the definition of a good curve and point. Note that in general there may be multiple viable options for  <span class="math">P</span> : Clearly  <span class="math">-P = (b, -b\\sqrt{a + 2b})</span>  always works, and when the 2-torsion is of size 4 (which is equivalent to  <span class="math">a^2 - 4b^2</span>  and  <span class="math">a - 2b</span>  also being quadratic residues) then the points  <span class="math">P&#x27; = (-b, \\pm b\\sqrt{a - 2b})</span>  also satisfy  <span class="math">2P&#x27; = 0</span> . Our definition partially eliminates this ambiguity: the statement " <span class="math">E_{a,b^2}</span>  is a good curve with good point  <span class="math">P</span> " always means  <span class="math">P_x = b</span> , and never allows for  <span class="math">P_x = -b</span> . In other words, writing  <span class="math">B = b^2</span>  explicitly requires a specific choice of square-root  <span class="math">b</span>  of  <span class="math">B</span> , and this choice will always be equal to the  <span class="math">x</span> -coordinate of the good point  <span class="math">P</span> .</p>

    <p class="text-gray-300">We now prove the properties of the good isogeny, described in Lemma 1:</p>

    <p class="text-gray-300">Proof (Proof of Lemma 1). We first demonstrate this is a curve morphism, i.e. that if  <span class="math">(x,y)\\in E</span> , then  <span class="math">(x^{\\prime},y^{\\prime}) = \\varphi (x,y)\\in E^{\\prime}</span> . From the definition of  <span class="math">\\varphi</span>  we have</p>

    <div class="my-4 text-center"><span class="math-block">y ^ {\\prime} = \\left(1 - \\frac {b ^ {2}}{x ^ {2}}\\right) y, \\quad x ^ {\\prime} = \\left(1 - \\frac {b}{x}\\right) ^ {2} x</span></div>

    <p class="text-gray-300">Thus</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\frac {y ^ {\\prime 2}}{x ^ {\\prime}} = \\frac {1}{x ^ {\\prime}} \\left(1 - \\frac {b ^ {2}}{x ^ {2}}\\right) ^ {2} y ^ {2} = \\frac {1}{x} \\left(1 + \\frac {b}{x}\\right) ^ {2} (x ^ {3} + a x ^ {2} + b ^ {2} x) = \\frac {(x + b) ^ {2} (x ^ {2} + a x + b ^ {2})}{x ^ {2}} \\\\ = \\frac {1}{x ^ {2}} \\left(x ^ {4} + (a + 2 b) x ^ {3} + (2 a b + 2 b ^ {2}) x ^ {2} + (a b ^ {2} + 2 b ^ {3}) x + b ^ {4}\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300">and on the other hand</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {\\prime 2} + (a + 6 b) x ^ {\\prime} + (4 a b + 8 b ^ {2}) = \\frac {(x - b) ^ {4} + (a + 6 b) (x - b) ^ {2} x + (4 a b + 8 b ^ {2})}{x ^ {2}}</span></div>

    <p class="text-gray-300"><span class="math">=</span> <span class="math">\\frac{1}{x^{2}}\\big{(}(x^{4}-4bx^{3}+6b^{2}x^{2}-4b^{3}x+b^{4})</span> <span class="math">+((a+6b)x^{3}-(2ab+12b^{2})x^{2}+(ab^{2}+6b^{3})x)+(4ab+8b^{2})x^{2}\\big{)}</span> <span class="math">=</span> <span class="math">\\frac{1}{x^{2}}\\big{(}x^{4}+(a+2b)x^{3}+(2ab+2b^{2})x^{2}+(ab^{2}+2b^{3})x+b^{4}\\big{)}=\\frac{y^{\\prime}{}^{2}}{x^{\\prime}},</span></p>

    <p class="text-gray-300">as claimed. Note that <span class="math">\\varphi</span> is not immediately defined at <span class="math">\\infty</span> and <span class="math">\\mathbf{0}</span> (even in projective coordinates) but using the orders of zeros/poles of <span class="math">X</span> and <span class="math">Y</span> at <span class="math">\\mathbf{0}</span> and <span class="math">\\infty</span> it is easy to see that <span class="math">\\varphi(\\mathbf{0})=\\varphi(\\infty)=\\infty</span>, and in particular <span class="math">\\varphi</span> is an isogeny. It is also clear that <span class="math">\\varphi(Q)\\neq\\infty</span> for any <span class="math">Q\\notin\\{\\mathbf{0},\\infty\\}</span> (since <span class="math">Q_{x}\\neq 0</span>), thus <span class="math">\\ker\\varphi=\\{\\mathbf{0},\\infty\\}</span> and <span class="math">\\varphi</span> is a 2-isogeny. Finally,</p>

    <p class="text-gray-300"><span class="math">\\varphi(Q)=\\mathbf{0}\\Leftrightarrow\\varphi(Q)_{x}=0\\Leftrightarrow\\bigg{(}1-\\frac{b}{Q_{x}}\\bigg{)}^{2}=0\\Leftrightarrow Q_{x}=b\\Leftrightarrow Q=\\pm P,</span></p>

    <p class="text-gray-300">thus <span class="math">\\varphi^{-1}(\\mathbf{0})=\\pm P</span>.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Remark 5</h6>

    <p class="text-gray-300">Since <span class="math">(a+6b)^{2}-4(4ab+8b^{2})=a^{2}-4ab+4b^{2}=(a-2b)^{2}</span> is always a quadratic residue, <span class="math">E^{\\prime}(\\mathbb{F}_{q})[2]</span> is always of size 4, containing the points <span class="math">\\{\\infty,\\mathbf{0},(-4b,0),(-a-2b,0)\\}</span>. If <span class="math">\\#E(\\mathbb{F}_{q})[2]=4</span> as well, then the other good point candidates satisfy <span class="math">\\varphi((-b,\\pm b\\sqrt{a-2b}))=(-4b,0)</span> and the other 2-torsion points satisfy <span class="math">\\varphi((\\frac{-a\\pm\\sqrt{a^{2}-4b^{2}}}{2},0))=(-a-2b,0)</span>. Otherwise, <span class="math">(-4b,0),(-a-2b,0)</span> are not in the image of <span class="math">\\varphi</span>. We do not use these properties in the rest of the paper.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Even characteristic case</h4>

    <p class="text-gray-300">Let <span class="math">E_{B}</span> be a curve as in Definition 10. To find conditions for existence of <span class="math">P\\in E(\\mathbb{F}_{q})</span> with <span class="math">2P=\\mathbf{0}</span>, let us calculate the <span class="math">x</span>-coordinate of the formula for doubling a point on <span class="math">E_{B}</span>. Differentiate the equation to compute the tangent at <span class="math">(x_{0},y_{0})</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\lambda=\\left.\\left(-\\frac{\\partial E_{B}}{\\partial X}\\bigg{/}\\frac{\\partial E_{B}}{\\partial Y}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(x_{0},y_{0})}=\\frac{y_{0}+x_{0}^{2}+B}{x_{0}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The tangent equation is then <span class="math">Y=\\lambda X+\\mu</span> for some <span class="math">\\mu</span>. Substitute <span class="math">\\lambda X+\\mu</span> for <span class="math">Y</span> in the curve equation to get a polynomial equation in <span class="math">X</span>, with a double root at <span class="math">x_{0}</span> and another root at <span class="math">x_{1}=(2(x_{0},y_{0}))_{x}=(-2(x_{0},y_{0}))_{x}</span>:</p>

    <p class="text-gray-300"><span class="math">(\\lambda X+\\mu)^{2}+X(\\lambda X+\\mu)+X^{3}+BX=0.</span></p>

    <p class="text-gray-300">This is a monic polynomial, thus the coefficient of <span class="math">X^{2}</span> equals the sum of its roots, i.e.</p>

    <p class="text-gray-300"><span class="math">x_{1}=x_{0}+x_{0}+x_{1}=\\lambda^{2}+\\lambda=\\frac{y_{0}^{2}+x_{0}^{4}+B^{2}}{x_{0}^{2}}+\\frac{y_{0}+x_{0}^{2}+B}{x_{0}}=\\frac{x_{0}^{4}+B^{2}}{x_{0}^{2}},</span></p>

    <p class="text-gray-300">where in the last transition we used the fact that <span class="math">y_{0}^{2}+x_{0}y_{0}+x_{0}^{3}+Bx_{0}=0</span>. Thus in general:</p>

    <p class="text-gray-300"><span class="math">(2(x,y))_{x}=\\frac{x^{4}+B^{2}}{x^{2}}.</span></p>

    <p class="text-gray-300">This means that <span class="math">\\mathbf{0}</span> is the only 2-torsion point on <span class="math">E_{B}</span> other than <span class="math">\\mathbf{\\infty}</span> and that the points <span class="math">\\pm P=\\{(b,0),(b,b)\\}\\subset E_{B}</span>, where <span class="math">b^{2}=B</span>, satisfy <span class="math">2P=\\mathbf{0}</span> and are the only 4-torsion points of <span class="math">E_{B}</span>. Again note that squaring is an automorphism of <span class="math">\\mathbb{F}_{q}</span>, so such <span class="math">b</span> uniquely exists. Thus, as per Definition 10, all curves <span class="math">E_{b^{2}}</span> are good and the good point <span class="math">P=(b,b)</span> satisfies <span class="math">2P=\\mathbf{0}</span>. Note that we may as well have defined <span class="math">P=(b,0)</span> as the good point with no other changes.</p>

    <p class="text-gray-300">We now prove the properties of the good isogeny, described in Lemma 2:</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof (Proof of Lemma 2).</h6>

    <p class="text-gray-300">We first show that <span class="math">(x^{\\prime},y^{\\prime})=\\varphi(x,y)\\in E^{\\prime}</span>. Denote <span class="math">r=1+\\frac{b}{x}</span>, then <span class="math">x^{\\prime}=r^{2}x</span> and <span class="math">y^{\\prime}=br+r^{2}y</span>. Thus</p>

    <p class="text-gray-300"><span class="math">y^{\\prime}{}^{2}+x^{\\prime}y^{\\prime}</span> <span class="math">=b^{2}r^{2}+r^{4}y^{2}+br^{3}x+r^{4}xy=r^{4}\\left(y^{2}+xy\\right)+b^{2}r^{2}+br^{3}x</span> <span class="math">=r^{4}\\left(x^{3}+b^{2}x\\right)+b^{2}r^{2}+br^{3}x=r^{4}\\left(x+b\\right)^{2}x+br^{2}\\left(b+rx\\right)</span> <span class="math">=r^{6}x^{3}+br^{2}x={x^{\\prime}}^{3}+bx^{\\prime}.</span></p>

    <p class="text-gray-300">The kernel of <span class="math">\\varphi</span> is at the poles of the rational function from <span class="math">E</span> to <span class="math">\\mathbb{P}^{1}</span> given by the <span class="math">x</span>-coordinate of <span class="math">\\varphi</span>, i.e. <span class="math">x^{\\prime}=r^{2}x=\\frac{(x+b)^{2}}{x}</span>, which are at <span class="math">\\mathbf{0}</span> and <span class="math">\\mathbf{\\infty}</span>. Likewise, <span class="math">\\varphi^{-1}(\\mathbf{0})</span> are the zeros of <span class="math">x^{\\prime}</span>, which are the points with <span class="math">x=b</span>, namely <span class="math">\\{\\pm P\\}</span>.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Remark 6.</h6>

    <p class="text-gray-300">In the even-characteristic case, the good isogeny <span class="math">\\varphi</span> is the dual of the Frobenius isogeny <span class="math">F:E^{\\prime}\\to E</span> which maps <span class="math">(x,y)\\in E^{\\prime}</span> to <span class="math">(x^{2},y^{2})\\in E</span>: The composition <span class="math">F\\circ\\varphi</span> is the doubling endomorphism of <span class="math">E</span>, and <span class="math">\\varphi\\circ F</span> is the doubling endomorphism of <span class="math">E^{\\prime}</span>. Equivalently, one can define <span class="math">\\varphi</span> as the composition of the inverse of Frobenius on the doubling endomorphism.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Moving to a good curve</h4>

    <p class="text-gray-300">Finally, we prove Lemma 3, that every curve with a 4-torsion point can be expressed as a good curve.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof (Proof of Lemma 3).</h6>

    <p class="text-gray-300">If the characteristic is odd (including 3), <span class="math">E</span> is isomorphic to a curve of the form</p>

    <p class="text-gray-300"><span class="math">Y^{2}=X^{3}+a_{2}X^{2}+a_{4}X+a_{6}.</span></p>

    <p class="text-gray-300">In that representation the <span class="math">y</span> coordinate of <span class="math">2P</span> is 0 because <span class="math">2P</span> is a 2-torsion point. Applying the change of variables <span class="math">X^{\\prime}=X-x_{0},Y^{\\prime}=Y</span>, where <span class="math">x_{0}</span> is the <span class="math">x</span> coordinate of <span class="math">2P</span>, maps <span class="math">2P</span> to the point <span class="math">(0,0)</span> in coordinates <span class="math">(X^{\\prime},Y^{\\prime})</span>, thus in these coordinates the equation of the curve takes the form:</p>

    <p class="text-gray-300"><span class="math">{Y^{\\prime}}^{2}={X^{\\prime}}^{3}+a_{2}^{\\prime}{X^{\\prime}}^{2}+a_{4}^{\\prime}X^{\\prime}</span></p>

    <p class="text-gray-300">and <span class="math">2P^{\\prime}=\\mathbf{0}</span>, i.e. <span class="math">P^{\\prime}</span> is a good point.</p>

    <p class="text-gray-300">Now assume that the characteristic is 2. Then <span class="math">E</span> is isomorphic to a curve of the form</p>

    <p class="text-gray-300"><span class="math">Y^{2}+a_{1}XY+a_{3}Y=X^{3}+a_{2}X^{2}+a_{4}X+a_{6}</span></p>

    <p class="text-gray-300">where <span class="math">a_{1}\\neq 0</span>, since otherwise <span class="math">E</span> is either singular (if <span class="math">a_{3}=0</span>) or supersingular, and then it has no 4-torsion point. Substituting <span class="math">X=X^{\\prime}+\\frac{a_{3}}{a_{1}}</span>, the left hand side</p>

    <p class="text-gray-300">then becomes <span class="math">Y^{2}+a_{1}X^{\\prime}Y</span> and the right hand side stays a monic polynomial in <span class="math">X^{\\prime}</span> of degree <span class="math">3</span>. Thus our equation is</p>

    <p class="text-gray-300"><span class="math">Y^{2}+a_{1}X^{\\prime}Y=X^{\\prime}{}^{3}+a_{2}^{\\prime}X^{\\prime}{}^{2}+a_{4}^{\\prime}X^{\\prime}+a_{6}^{\\prime}.</span></p>

    <p class="text-gray-300">We next substitute <span class="math">Y=Y^{\\prime}+\\gamma</span>, where <span class="math">\\gamma^{2}=a_{6}^{\\prime}</span>, and get</p>

    <p class="text-gray-300"><span class="math">Y^{\\prime}{}^{2}+a_{1}X^{\\prime}Y^{\\prime}=X^{\\prime}{}^{3}+a_{2}^{\\prime}X^{\\prime}{}^{2}+a_{4}^{\\prime\\prime}X^{\\prime}</span></p>

    <p class="text-gray-300">where <span class="math">a_{4}^{\\prime\\prime}=a_{4}^{\\prime}+a_{1}\\gamma</span>. In these coordinates <span class="math">(x^{\\prime},y^{\\prime})=(0,0)</span> is the only <span class="math">2</span>-torsion point, as <span class="math">X^{\\prime}=0</span> is the only vertical line that intersects <span class="math">E</span> exactly once (and more generally, we have <span class="math">-(x^{\\prime},y^{\\prime})=(x^{\\prime},y^{\\prime}+a_{1}x^{\\prime})</span>) . In particular <span class="math">(2P^{\\prime})_{x^{\\prime}}=0</span>, where <span class="math">P^{\\prime}=(x_{1}^{\\prime},y_{1}^{\\prime})</span> is the representation of <span class="math">P</span> in <span class="math">(x^{\\prime},y^{\\prime})</span> coordinates. Computing as in Section 4.1 we find the doubling formula and substitute <span class="math">P^{\\prime}</span>:</p>

    <p class="text-gray-300"><span class="math">0=(2P^{\\prime})_{x^{\\prime}}=\\frac{{x_{1}^{\\prime}}^{4}+{a_{4}^{\\prime\\prime}}^{2}}{{a_{1}^{2}}{x_{1}^{\\prime}}^{2}},</span></p>

    <p class="text-gray-300">hence <span class="math">{x_{1}^{\\prime}}^{2}=a_{4}^{\\prime\\prime}</span>. Finally, we make the last change of variables: <span class="math">X^{\\prime}=a_{1}^{2}X^{\\prime\\prime}</span> and <span class="math">Y^{\\prime}=a_{1}^{3}Y^{\\prime\\prime}+a_{1}^{2}\\frac{y_{1}^{\\prime}}{x_{1}^{\\prime}}X^{\\prime\\prime}</span>. The curve equation becomes</p>

    <p class="text-gray-300"><span class="math">a_{1}^{6}Y^{\\prime\\prime}{}^{2}+a_{1}^{4}\\frac{{y_{1}^{\\prime}}^{2}}{{x_{1}^{\\prime}}^{2}}X^{\\prime\\prime}{}^{2}+a_{1}^{6}X^{\\prime\\prime}Y^{\\prime\\prime}+a_{1}^{5}\\frac{y_{1}^{\\prime}}{x_{1}^{\\prime}}X^{\\prime\\prime}{}^{2}=a_{1}^{6}X^{\\prime\\prime}{}^{3}+a_{2}^{\\prime}a_{1}^{4}X^{\\prime\\prime}{}^{2}+a_{4}^{\\prime\\prime}a_{1}^{2}X^{\\prime\\prime}.</span></p>

    <p class="text-gray-300">Since <span class="math">a_{1}\\neq 0</span> we can divide both sides by <span class="math">a_{1}^{6}</span>. Additionally, we use the known curve equation on <span class="math">(x_{1}^{\\prime},y_{1}^{\\prime})</span> together with <span class="math">{x_{1}^{\\prime}}^{2}=a_{4}^{\\prime\\prime}</span> to erase the coefficient of <span class="math">X^{\\prime\\prime}{}^{2}</span>, which is</p>

    <p class="text-gray-300"><span class="math">a_{1}^{4}\\frac{{y_{1}^{\\prime}}^{2}+a_{1}x_{1}^{\\prime}y_{1}^{\\prime}+{a_{2}^{\\prime}}{x_{1}^{\\prime}}^{2}}{{x_{1}^{\\prime}}^{2}}=a_{1}^{4}\\frac{{x_{1}^{\\prime}}^{3}+a_{4}^{\\prime\\prime}x_{1}^{\\prime}}{{x_{1}^{\\prime}}^{2}}=0.</span></p>

    <p class="text-gray-300">The final curve equation is then</p>

    <p class="text-gray-300"><span class="math">Y^{\\prime\\prime}{}^{2}+X^{\\prime\\prime}Y^{\\prime\\prime}=X^{\\prime\\prime}{}^{3}+\\frac{a_{4}^{\\prime\\prime}}{a_{1}^{3}}X^{\\prime\\prime},</span></p>

    <p class="text-gray-300">which is exactly <span class="math">E_{b^{2}}</span> for <span class="math">b=\\frac{x_{4}^{\\prime}}{a_{1}^{2}}</span> as claimed.</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">4.2 An isogeny chain of good curves</h3>

    <p class="text-gray-300">In this subsection we show that any elliptic curve <span class="math">E</span> with a large cyclic subgroup of order <span class="math">2^{\\mathsf{k}}</span> gives rise to an isogeny chain where all curves and all isogenies are good.</p>

    <p class="text-gray-300">Suppose that <span class="math">E=E_{0}</span> is an elliptic curve over <span class="math">\\mathbb{F}_{q}</span> (any finite field) such that <span class="math">E(\\mathbb{F}_{q})</span> contains a cyclic subgroup of order <span class="math">2^{\\mathsf{k}}</span> with <span class="math">\\mathsf{k}\\geq 2</span>, and let <span class="math">g=g_{0}</span> be the generator of such a subgroup. According to Lemma 3, by applying projective transformations we may assume that <span class="math">E</span> is a good curve with good</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">point  <span class="math">P_0 = 2^{\\mathbf{k} - 2}g_0</span> , with  <span class="math">E = E_{a_0,b_0^2}</span>  if the characteristic is odd, or  <span class="math">E = E_{b_0^2}</span>  if the characteristic is 2. Lemmas 1 and 2 give us the good 2-isogeny  <span class="math">\\varphi_0 = \\varphi_{b_0}:E_0\\to E_1</span> , with  <span class="math">\\varphi_0(\\mathbf{0}) = \\infty ,\\varphi_0(2^{\\mathbf{k} - 2}g_0) = \\mathbf{0}</span> . It follows that  <span class="math">g_{1} = \\varphi_{0}(g_{0})</span>  generates a cyclic subgroup of order  <span class="math">2^{\\mathbf{k} - 1}</span>  inside  <span class="math">E_{1}</span> , and satisfies  <span class="math">2^{\\mathbf{k} - 2}g_{1} = \\mathbf{0}</span> . If  <span class="math">\\mathbf{k} &amp;gt; 2</span> , we may continue similarly:</p>

    <p class="text-gray-300">For the general iteration  <span class="math">0 \\leq i \\leq k - 2</span> , we have a curve  <span class="math">E_{i}</span>  with a point  <span class="math">g_{i}</span>  of order  <span class="math">2^{k - i}</span>  satisfying  <span class="math">2^{k - i - 1}g_{i} = 0</span> . It follows that  <span class="math">E_{i}</span>  (which equals  <span class="math">E_{a_i, b_i^2}</span>  if the characteristic is odd, or  <span class="math">E_{b_i^2}</span>  if the characteristic is 2) is a good curve with good point  <span class="math">P_{i} = 2^{k - i - 2}g_{i}</span>  (note that  <span class="math">P_{i}</span>  is well defined, and  <span class="math">b_{i}</span>  is chosen to equal  <span class="math">(P_{i})_{x}</span> ). Lemmas 1 and 2 then give us the good 2-isogeny  <span class="math">\\varphi_{i}: E_{i} \\to E_{i + 1}</span> , with  <span class="math">g_{i + 1} = \\varphi_{i}(g_{i})</span>  of order  <span class="math">2^{k - i - 1}</span>  satisfying  <span class="math">2^{k - i - 2}g_{i + 1} = 0</span> . The final curve  <span class="math">E_{k - 1}</span>  need not necessarily be good, and  <span class="math">b_{k - 1}</span>  is not necessarily defined, but  <span class="math">b_{k - 1}^2</span>  is still meaningful.</p>

    <p class="text-gray-300">Considering the  <span class="math">x</span> -projection maps  <span class="math">\\pi_i: E_i \\to \\mathbb{P}^1</span> , the  <span class="math">x</span> -coordinate of  <span class="math">\\varphi_i</span>  is the degree 2 rational function  <span class="math">\\psi_i: \\mathbb{P}^1(\\mathbb{F}_q) \\to \\mathbb{P}^1(\\mathbb{F}_q)</span>  given by</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {i} (x) := \\left\\{ \\begin{array}{c c} \\frac {(x - b _ {i}) ^ {2}}{x} &amp;amp; x \\notin \\{0, \\infty \\} \\\\ \\infty &amp;amp; x \\in \\{0, \\infty \\} \\end{array} \\right.</span></div>

    <p class="text-gray-300">and the following diagram commutes:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c c c c c c} E _ {0} &amp; \\xrightarrow {\\varphi_ {0}} &amp; E _ {1} &amp; \\xrightarrow {\\varphi_ {1}} &amp; \\dots &amp; \\xrightarrow {\\varphi_ {k - 2}} &amp; E _ {k - 1} \\\\ \\pi_ {0} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; &amp; \\pi_ {1} \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; &amp; &amp; &amp; \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_ {k} \\\\ \\mathbb {P} ^ {1} &amp; \\xrightarrow {\\psi_ {0}} &amp; \\mathbb {P} ^ {1} &amp; \\xrightarrow {\\psi_ {1}} &amp; \\dots &amp; \\xrightarrow {\\psi^ {(k - 2)}} &amp; \\mathbb {P} ^ {1} \\end{array} \\tag {10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <h2 id="sec-67" class="text-2xl font-bold">4.3 Finding the start of a long isogeny chain</h2>

    <p class="text-gray-300">As explained in Section 4.2, an isogeny chain of length  <span class="math">\\mathsf{k}</span>  can be constructed from an elliptic curve with a point of order  <span class="math">2^{\\mathsf{k}}</span> . In [9] it was shown that for a finite field of size  <span class="math">q</span>  such curve exists for any  <span class="math">\\mathsf{k} \\leq \\frac{1}{4} \\log_2 q</span> , but the question of how to find it was not investigated. This section provides a probabilistic algorithm, called FindCurve, for efficiently finding such curves, with the following proven and conjectural runtime bounds:</p>

    <p class="text-gray-300">Theorem 17. Let  <span class="math">q</span>  be a prime power and  <span class="math">k \\leq \\frac{1}{2} \\log_2 q - 2</span> . The algorithm FindCurve( <span class="math">q, k</span> ) will find a curve over  <span class="math">\\mathbb{F}_q</span>  with a point of order  <span class="math">2^k</span>  using, on average, at most  <span class="math">O(2^k \\log^2 q \\min(k, \\log \\log q))</span>  field operations.</p>

    <p class="text-gray-300">Assuming the generalized Riemann Hypothesis, the bound can be replaced by  <span class="math">O(2^k \\log q \\log \\log q \\min(\\mathsf{k}, \\log \\log q))</span>  field operations.</p>

    <p class="text-gray-300">Conjecture 1. Let  <span class="math">q</span>  be a prime power and  <span class="math">k \\leq \\frac{1}{2} \\log_2 q + 1</span> . The algorithm FindCurve( <span class="math">q, k</span> ) will find a curve over  <span class="math">\\mathbb{F}_q</span>  with a point of order  <span class="math">2^k</span>  using, on average,  <span class="math">O(2^k \\log q)</span>  field operations.</p>

    <p class="text-gray-300">The conjectural bound is based on commonly accepted heuristics as well as experimental implementation.</p>

    <p class="text-gray-300">The main idea of this method is to exhaustively pick random elliptic curves and compute their maximal <span class="math">2</span>-subgroups until we get one with a subgroup of order <span class="math">2^{\\mathsf{k}}</span>. We then use the found curve to find another elliptic curve of the same order, in which the maximal <span class="math">2</span>-subgroup is cyclic.</p>

    <p class="text-gray-300">To bound the expected number of elliptic curves that will be picked this way we cite Proposition 2, proven by Lenstra in <em>[46]</em>, where he deals with a similar problem of sampling curves until one is of order divisible by a given prime for the famous ECM factoring algorithm.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proposition 2 (Lenstra).</h6>

    <p class="text-gray-300">There exist effectively computable positive constants <span class="math">c_{1},c_{2}</span> such that for each prime number <span class="math">p&gt;3</span> the following two assertions are valid:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">S</span> is a set of integers <span class="math">s</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s-(p+1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\sqrt{p}$ then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#^{\\prime}\\{E:E\\text{ elliptic curve over }\\mathbb{F}_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{p})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S\\}/\\cong_{\\mathbb{F}_{p}}\\leq c_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{p}(\\log p)(\\log\\log p)^{2}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#^{\\prime}\\{E:E\\text{ elliptic curve over }\\mathbb{F}_{p},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{p})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S\\}/\\cong_{\\mathbb{F}_{p}}\\geq c_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2)\\sqrt{p}/\\log p.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here <span class="math">\\cong_{\\mathbb{F}_{p}}</span> denotes the isomorphism over <span class="math">\\mathbb{F}_{p}</span> relation and <span class="math">\\#^{\\prime}A</span> of a set <span class="math">A</span> of elliptic curves denotes the weighted size $\\sum_{E\\in A}\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Aut}(E)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ of the set.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lenstra proves this result only for prime fields, as that was the sole focus of his paper. Nonetheless, his method can be immediately applied for proving a similar claim over all finite fields, with a few extra conditions. The main tool used in the proof is a theorem by Schoof relating the number of curves of a given size to class numbers <em>[54]</em>, which is valid for all prime powers, but slightly simpler for primes. The other elements of the proof are related to estimating the class number itself, in which the original field size plays no role. Using the simplest case of Schoof’s result for general prime powers inside Lenstra’s argument yields the following:</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Let <span class="math">q=p^{e}</span> be a prime power.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If <span class="math">S</span> is a set of integers <span class="math">s</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s-(q+1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{q}$, then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#^{\\prime}\\{E:E\\text{ elliptic curve over }\\mathbb{F}_{q},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S\\}/\\cong_{\\mathbb{F}_{q}}\\leq c_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt{q}(\\log q)(\\log\\log q)^{2}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#^{\\prime}\\{E:E\\text{ elliptic curve over }\\mathbb{F}_{q},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S\\}/\\cong_{\\mathbb{F}_{q}}\\geq c_{2}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2)\\sqrt{q}/\\log q.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the constants <span class="math">c_{1},c_{2}</span> are the same as in Lenstra’s result, and only the lower bound required a more delicate condition on the elements of <span class="math">S</span>. Lenstra comments that if the generalized Riemann hypothesis is assumed then the <span class="math">\\log p</span> in the denominator of the lower bound can be replaced by <span class="math">\\log\\log p</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">may be replaced by $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The same is true in our generalized result, with </span>p<span class="math"> replaced by </span>q$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Earlier in that paper, Lenstra observes that the number of <span class="math">(a,b)</span> pairs of <span class="math">\\mathbb{F}_{p}</span> elements such that the curve <span class="math">Y^{2}=X^{3}+aX+b</span> is isomorphic to a given elliptic curve <span class="math">E</span> is equal to $\\frac{p-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Aut}(E)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Aut}(E)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in\\{2,4,6\\}<span class="math">, and the same is true for odd prime powers. For binary fields, it is the case that each elliptic curve </span>E<span class="math"> with </span>4\\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is isomorphic to </span>\\theta(1)<span class="math"> curves of the form </span>E_{B}$ (see Section 4.1). Together with Proposition 3 this yields the following corollary:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-70" class="text-base font-medium mt-4">Corollary 1</h6>

    <p class="text-gray-300">For every odd prime power <span class="math">q=p^{e}</span> and natural number <span class="math">v&lt;\\sqrt{q}/3</span>, when <span class="math">a</span> and <span class="math">b</span> are sampled uniformly at random from <span class="math">\\mathbb{F}_{q}</span>, the random curve <span class="math">E\\colon\\&gt;Y^{2}=X^{3}+aX+b</span> satisfies:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr(E\\text{ is ordinary}\\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\equiv 0\\ (\\mathrm{mod}\\ v))=\\Omega\\bigg{(}\\frac{1}{v\\log q}\\bigg{)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For binary fields the same lower bound holds, but when the random curve is in the form <span class="math">E_{B}</span>, where <span class="math">B</span> is sampled uniformly from <span class="math">\\mathbb{F}_{q}^{*}</span>, and under the additional condition that <span class="math">4\\mid v</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Define sets</p>

    <p class="text-gray-300"><span class="math">S^{\\prime}</span> <span class="math">=\\{s\\in[q-\\sqrt{q}+1,q+\\sqrt{q}+1]\\cap\\mathbb{Z}:s\\equiv 0\\ (\\mathrm{mod}\\ v)\\}</span> <span class="math">S</span> <span class="math">=\\{s\\in[q-\\sqrt{q}+1,q+\\sqrt{q}+1]\\cap\\mathbb{Z}:s\\equiv 0\\ (\\mathrm{mod}\\ v),s\\not\\equiv 1\\ (\\mathrm{mod}\\ p)\\}</span> <span class="math">=S^{\\prime}\\setminus\\{s\\equiv 1\\ (\\mathrm{mod}\\ p)\\}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that the event $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S<span class="math"> is a sub-event of </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\equiv 0\\ (\\mathrm{mod}\\ v)<span class="math">. The set </span>S^{\\prime}<span class="math"> is an arithmetic sequence modulo </span>v<span class="math"> contained in an interval of length </span>2\\sqrt{q}<span class="math">, thus </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\left\\lfloor\\frac{2\\sqrt{q}}{v}\\right\\rfloor\\geq 6<span class="math">. </span>S<span class="math"> is obtained from </span>S^{\\prime}<span class="math"> by removing the elements which are </span>1<span class="math"> modulo </span>p<span class="math">. Note that if </span>p\\mid v<span class="math"> then the conditions </span>s\\equiv 0\\ (\\mathrm{mod}\\ v)<span class="math"> and </span>s\\equiv 1\\ (\\mathrm{mod}\\ p)<span class="math"> are incompatible, so no elements are removed, and otherwise, at most </span>\\left\\lceil\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{p}\\right\\rceil<span class="math"> are removed, so </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\left\\lfloor\\frac{(p-1)}{p}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\rfloor\\geq 3$. We thus have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2=\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\Omega(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\Omega\\bigg{(}\\frac{\\sqrt{q}}{v}\\bigg{)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the constant in the final <span class="math">\\Omega</span> expression can be bounded from below by <span class="math">\\frac{1}{8}</span> (but in practice is closer to <span class="math">\\frac{2(p-1)}{p}</span>, when <span class="math">v\\ll\\sqrt{q}</span>). From Proposition 3 it then follows that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\#^{\\prime}\\{E:E\\text{ elliptic curve over }\\mathbb{F}_{q},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(\\mathbb{F}_{q})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\in S\\}/\\cong_{\\mathbb{F}_{q}}=\\Omega\\bigg{(}\\frac{q}{v\\log q}\\bigg{)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For odd characteristic, combining the last bound with the fact that each isomorphism class of curves has <span class="math">\\theta(q)</span> representatives and dividing by the <span class="math">q^{2}</span> different options for <span class="math">(a,b)</span> yields the claimed lower bound on the probability. For binary fields, similarly each isomorphism class has only <span class="math">\\theta(1)</span> representatives, and we must divide by <span class="math">q</span> different values of <span class="math">B</span>, yielding the same bound.</p>

    <p class="text-gray-300">Taking <span class="math">v=2^{\\mathsf{k}}&lt;\\frac{\\sqrt{q}}{3}</span> in Corollary 1, we see that the expected number of elliptic curves that will be considered in FindCurve is <span class="math">O(2^{\\mathsf{k}}\\log q)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Nevertheless, for <span class="math">v&lt;2\\sqrt{q}</span>, all the sets of numbers in the Hasse bound that correspond to the different residue classes modulo <span class="math">v</span> are of almost the same size. Moreover, by <em>[33, 60]</em>, we know that any number <span class="math">N=q+1-t</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\sqrt{q}<span class="math"> and </span>t<span class="math"> is coprime to </span>q<span class="math">, has an elliptic curve </span>E<span class="math"> over </span>\\mathbb{F}_{q}<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=N<span class="math">. These facts, together with known empirical observations, make it reasonable to believe in Conjecture 2, which reduces the number of elliptic curves that will be considered in FindCurve to </span>O(2^{\\mathsf{k}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-72" class="text-base font-medium mt-4">Conjecture 2.</h6>

    <p class="text-gray-300">For every odd prime power <span class="math">q</span> and a power of two <span class="math">2^{\\mathsf{k}}&lt;2\\sqrt{q}</span>, when <span class="math">a</span> and <span class="math">b</span> are sampled uniformly at random from <span class="math">\\mathbb{F}_{q}</span>, the random curve <span class="math">E\\colon\\&gt;Y^{2}=X^{3}+aX+b</span> satisfies:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\big{(}E\\text{ is ordinary}\\wedge</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\equiv 0\\ (\\text{mod}\\ 2^{\\mathsf{k}}))=\\Theta\\big{(}2^{-\\mathsf{k}}\\big{)}\\big{)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For binary fields we conjecture the same bound, but when the curve is in the form <span class="math">E_{B}</span>, where <span class="math">B</span> is sampled uniformly from <span class="math">\\mathbb{F}_{q}^{*}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To compute the maximal 2-subgroup of <span class="math">E</span> without first computing its size, we use the algorithm given in <em>[50]</em>, which terminates after <span class="math">O(l)</span> calls to a univariate quadratic equation solver, where <span class="math">2^{l}</span> is the maximal power of 2 that divides $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. An additional cubic equation needs to be solved if the equation is not given in one of the good forms </span>E_{a,B}<span class="math"> or </span>E_{B}<span class="math">. Solving a univariate polynomial of degree </span>\\leq 3<span class="math"> can be done in </span>O(\\log q)$ field operations using the Cantor–Zassenhaus algorithm <em>[25]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the context of FindCurve, we consider the average running time of a randomly chosen input. Considering the algorithm of <em>[50]</em> as a loop with <span class="math">l</span> steps, let <span class="math">P_{i}</span> denote the probability of entering the <span class="math">i</span>-th iteration, which equals the probability of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> being divisible by </span>2^{i}<span class="math">. Thus each loop executes a total of </span>O(\\sum_{i=1}^{\\mathsf{k}}P_{i})<span class="math"> iterations in expectation. This is of course bounded by </span>O(\\mathsf{k})<span class="math">, but this bound can be improved for large </span>\\mathsf{k}<span class="math">. By Proposition 3, </span>P_{i}=O\\Big{(}\\frac{(\\log p)(\\log\\log p)^{2}}{2^{i}}\\Big{)}<span class="math">, which improves on </span>P_{i}\\leq 1<span class="math"> starting from </span>i_{0}=\\log\\log p+2\\log\\log\\log p<span class="math">. Thus, using the trivial bound for the first </span>i_{0}$ iterations and Proposition 3 for the remaining iterations, we find</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">O\\Bigg{(}\\sum_{i=1}^{\\mathsf{k}}P_{i}\\Bigg{)}=O\\Bigg{(}\\log\\log p+2\\log\\log\\log p+\\sum_{j\\geq 0}\\frac{1}{2^{j}}\\Bigg{)}=O(\\log\\log p).</span></p>

    <p class="text-gray-300">If Conjecture 2 is true, then for any prime power <span class="math">q</span> we have <span class="math">P_{i}=O(2^{-i})</span>, hence <span class="math">O(\\sum_{i=1}^{\\mathsf{k}}P_{i})=O(1)</span>.</p>

    <p class="text-gray-300">Once we find an ordinary elliptic curve <span class="math">E</span> whose size is divisible by <span class="math">2^{\\mathsf{k}}</span>, we use Sutherland’s <em>[58]</em> FindFloor algorithm, which finds an elliptic curve <span class="math">E^{\\prime}</span> isogenous to <span class="math">E</span> and with a cyclic subgroup of order <span class="math">2^{\\mathsf{k}}</span>, in <span class="math">O(\\delta\\log q)</span> field operations.</p>

    <p class="text-gray-300">The <span class="math">\\log q</span> term stands for the running time of finding all the 2-isogenies of a given curve and <span class="math">\\delta</span> denotes the distance of <span class="math">E</span> from <span class="math">V_{d}</span> (the “floor”) in the 2-isogenies graph.</p>

    <p class="text-gray-300">Sutherland describes the components of this graph as “volcanoes” whose vertices are partitioned into one or more levels <span class="math">V_{0},\\ldots,V_{d}</span> such that the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The subgraph on <span class="math">V_{0}</span> (the surface) is a regular graph of degree at most 2;</li>

      <li>For <span class="math">i&gt;0</span>, each vertex in <span class="math">V_{i}</span> has exactly one neighbor in level <span class="math">V_{i-1}</span>, and this accounts for every edge not on the surface; and</li>

      <li>For <span class="math">i&lt;d</span>, each vertex in <span class="math">V_{i}</span> has degree 3.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It follows that $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all </span>0<i<d<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> if </span>V_{1}<span class="math"> is nonempty. In particular, for </span>\\delta\\leq d<span class="math">, at least </span>2^{-\\delta-1}<span class="math"> of the vertices lie on </span>V_{d-\\delta}<span class="math">. Thus, the average </span>\\delta<span class="math"> is </span>O(\\sum_{\\delta\\geq 0}\\delta\\cdot 2^{-\\delta-1})=O(1)<span class="math">. We conclude that FindFloor takes </span>O(\\log q)$ field operations in expectation on an equidistributed random curve of given order.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above analysis is not valid for the exceptional case of components containing the curves with <span class="math">j</span>-invariants 0 and 1728. These components are not classical volcanoes, but the analysis of FindFloor for them is similar.</p>

    <h4 id="sec-73" class="text-lg font-semibold mt-6">Empirical results</h4>

    <p class="text-gray-300">To demonstrate the efficiency of this method, we present empirical results of our C++ implementation of FindCurve. We were looking for an elliptic curve over <span class="math">\\mathbb{F}_{2^{64}}</span> with order divisible by <span class="math">2^{34}</span>. The only such number in the Hasse bound is <span class="math">2^{64}</span> and we found an elliptic curve of this order after checking 1803907700 curves in less then 8 hours on a single thread. Note that we came across significantly less than <span class="math">2^{34}</span> curves, that is because we checked only curves of the form <span class="math">E_{B}</span>, which are known to have size divisible by 4. The curve that we found is <span class="math">E_{B}:Y^{2}+XY=X^{3}+BX</span> where <span class="math">B</span> is a root of the following degree 64 irreducible polynomial over <span class="math">\\mathbb{F}_{2}</span>:</p>

    <p class="text-gray-300"><span class="math">X^{64}+X^{59}+X^{54}+X^{53}+X^{52}+X^{51}+X^{50}+X^{49}+X^{48}+X^{46}+X^{43}+X^{42}</span> <span class="math">+X^{41}+X^{40}+X^{37}+X^{35}+X^{33}+X^{29}+X^{27}+X^{26}+X^{25}+X^{23}+X^{20}</span> <span class="math">+X^{18}+X^{17}+X^{14}+X^{12}+X^{9}+X^{6}+X^{4}+X^{3}+X^{2}+1.</span></p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Alternative search methods</h4>

    <p class="text-gray-300">We remark that elliptic curves with constraints on their group size and underlying field size can be constructed efficiently using Lay and Zimmer’s method <em>[45]</em>, based on curves with complex multiplication and special endomorphism rings. Specifically, the method could be used to generate curves with orders divisible by <span class="math">2^{\\mathsf{k}}</span> in time <span class="math">\\mathsf{poly}(\\mathsf{k})</span>, from which FindFloor could then be used to find an isogenous curve with a cyclic subgroup of the same size, as above. However, this method requires some flexibility in the size of the field over which the curve will be defined: the size <span class="math">q</span> will be generated by the algorithm, and only some specific could be attainable by the method in reasonable time. For applications where <span class="math">q</span> may be chosen arbitrarily, it would be better still to take <span class="math">q\\equiv 1\\pmod{2^{\\mathsf{k}}}</span>, so that the standard FFT and accompanying algorithms may be used. For the case where <span class="math">q</span> must be a general prespecified value, FindCurve outperforms any other known method.</p>

    <p class="text-gray-300">5 Codes derived from the elliptic curves</p>

    <p class="text-gray-300">In this section we construct two related families of linear codes, which are the main characters in our IOPP and STARK protocols. One family consists of AG codes, and the other of Reed–Solomon codes over specially chosen evaluation domains. AG codes are defined by three parameters: The curve that gives rise to the code; the divisor in the curve which defines a Riemann–Roch space of functions on the curve; and a set of points on the curve, disjoint from the divisor, on which the functions are evaluated.</p>

    <p class="text-gray-300">We have already defined the relevant curves: these are the elliptic curves <span class="math">E_{i}</span> discussed in the previous section. To describe the codes we still need to specify their divisors and evaluation domains. In the next subsections we will define these divisors and sets, building up to the codes themselves, and prove some useful properties which will be necessary for our protocols in the following sections.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">5.1 Special sets in <span class="math">\\boldsymbol{E_{i}}</span> and <span class="math">\\mathbb{F}_{q}</span></h3>

    <p class="text-gray-300">In this subsection we define special sets <span class="math">G_{i},G_{i}^{\\prime}\\subset E_{i}</span> and <span class="math">H_{i}\\subset\\mathbb{F}_{q}</span>, as well as polynomials <span class="math">\\Omega_{i}(X)\\in\\mathbb{F}_{q}[X]</span>, which will be necessary for defining the AG-code and relating it to the Reed–Solomon codes.</p>

    <p class="text-gray-300">Let <span class="math">E_{0},\\ldots,E_{k-1}</span> be a sequence of curves as in Section 4.2, with cyclic subgroups <span class="math">\\langle g_{i}\\rangle\\subset E_{i}</span> of size <span class="math">2^{k-i}</span> and good points <span class="math">P_{i}=2^{k-i-2}g_{i}\\in E_{i}</span> for <span class="math">i\\leq k-2</span>. Denote <span class="math">G_{i}=\\langle g_{i}\\rangle</span> and define for each <span class="math">i\\leq k-1</span></p>

    <p class="text-gray-300"><span class="math">G_{i}^{\\prime}=G_{i}\\setminus\\{\\boldsymbol{0},\\boldsymbol{\\infty}\\}=G_{i}\\setminus\\{2^{k-i-1}g_{i},2^{k-i}g_{i}\\},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is of size <span class="math">2^{k-i}-2</span>. Denote <span class="math">H_{i}=\\pi_{i}(G_{i}^{\\prime})</span>, and note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{k-i-1}-1<span class="math">, since </span>\\pi_{i}:G_{i}^{\\prime}\\to H_{i}<span class="math"> is 2-to-1: indeed, the preimage of any </span>\\pi_{i}(P)\\in H_{i}<span class="math"> is </span>\\pi_{i}^{-1}(\\pi_{i}(P))=\\{P,-P\\}<span class="math">, and </span>P\\neq-P<span class="math"> since the only 2-torsion points in </span>G_{i}<span class="math"> are </span>\\boldsymbol{0},\\boldsymbol{\\infty}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can also characterize <span class="math">H_{i}</span> by a reverse-recursive construction, starting with <span class="math">H_{k-1}=\\emptyset</span>, and defining</p>

    <p class="text-gray-300"><span class="math">H_{i}=\\psi_{i}^{-1}(H_{i+1})\\cup\\{b_{i}\\}.</span> (11)</p>

    <p class="text-gray-300">Indeed, every point <span class="math">P=(x,y)\\in G_{i}^{\\prime}</span> either satisfies <span class="math">\\varphi_{i}(P)\\in G_{i+1}^{\\prime}</span>, in which case <span class="math">\\psi_{i}(x)=\\pi_{i+1}(\\varphi_{i}(P))\\in H_{i+1}</span>, or else <span class="math">\\varphi(P)=\\boldsymbol{0}</span>, i.e. <span class="math">P=\\pm P_{i}</span> and <span class="math">x=b_{i}</span>. This establishes</p>

    <p class="text-gray-300"><span class="math">H_{i}\\subseteq\\psi_{i}^{-1}(H_{i+1})\\cup\\{b_{i}\\}.</span></p>

    <p class="text-gray-300">In the other direction, note that <span class="math">\\psi_{i}</span> is at most 2-to-1, so</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi_{i}^{-1}(H_{i+1})\\cup\\{b_{i}\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This also implies that $\\left.\\psi_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{H_{i}\\setminus\\{b_{i}\\}}:H_{i}\\setminus\\{b_{i}\\}\\to H_{i+1}<span class="math"> is exactly 2-to-1. It can also be directly checked that for every </span>x=\\pi_{i}(\\pm P)\\in H_{i}\\setminus\\{b_{i}\\}<span class="math">, the point </span>x^{\\prime}=\\frac{b_{i}^{2}}{x}<span class="math"> with </span>\\psi_{i}(x^{\\prime})=\\psi_{i}(x)$ is also given by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">x^{\\prime}=\\pi_{i}(\\pm P+\\boldsymbol{0})=\\pi_{i}(\\pm P+2^{k-i-1}g_{i})\\in H_{i},</span></p>

    <p class="text-gray-300">and indeed <span class="math">\\{\\pm P+\\mathbf{0}\\}</span> is disjoint from <span class="math">\\{\\pm P\\}</span> whenever <span class="math">P\\neq\\pm P_{i}</span>.</p>

    <p class="text-gray-300">Define <span class="math">\\Omega_{i}(X)=\\prod_{u\\in H_{i}}(X-u)</span>, the vanishing polynomial of <span class="math">H_{i}</span>, which is monic of degree <span class="math">2^{\\mathsf{k}-i-1}-1</span> (for <span class="math">i=\\mathsf{k}-1</span>, the empty product gives <span class="math">\\Omega_{\\mathsf{k}-1}=1</span>). Note that from (11) and <span class="math">\\psi_{i}(X)</span> having denominator <span class="math">X</span> we get for <span class="math">i&lt;\\mathsf{k}-1</span> the recursive formula</p>

    <p class="text-gray-300"><span class="math">\\Omega_{i}(X)=(X-b_{i})\\cdot X^{2^{\\mathsf{k}-i-2}-1}\\cdot\\Omega_{i+1}(\\psi_{i}(X)).</span> (12)</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">5.2 Function and polynomial spaces</h3>

    <p class="text-gray-300">In this section we define three families of linear spaces, one consisting of polynomial over <span class="math">\\mathbb{F}_{q}</span>, another of rational functions over <span class="math">\\mathbb{F}_{q}</span>, and the third of functions on the elliptic curves <span class="math">E_{i}</span>. The first and third will be the backbones of our Reed–Solomon and AG codes, respectively, whereas the second will act as a useful stepping stone between them. We will also define special bases for these spaces and prove several lemmas relating these spaces and bases to each other, which will be key to obtaining FFT and FRI equivalents for these functions and codes.</p>

    <p class="text-gray-300">For any positive integer <span class="math">d</span>, let</p>

    <p class="text-gray-300"><span class="math">\\mathbb{F}_{q}[X]^{&lt;d}=\\{p(X)\\in\\mathbb{F}_{q}[X]:\\deg(p(X))&lt;d\\}</span></p>

    <p class="text-gray-300">denote the <span class="math">d</span>-dimensional space of polynomials of degree strictly less than <span class="math">d</span>. Denote <span class="math">\\mathcal{M}_{i}=\\mathbb{F}_{q}[X]^{&lt;2^{\\mathsf{k}-i-1}}</span> for every <span class="math">i\\leq\\mathsf{k}-1</span>. We define a related space of <em>rational</em> functions,</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{i}=\\left\\{\\frac{p(X)}{\\Omega_{i}(X)}:p(X)\\in\\mathcal{M}_{i}\\right\\}\\subset\\mathbb{F}_{q}(X).</span></p>

    <p class="text-gray-300">Clearly, <span class="math">\\mathcal{L}_{i}</span> and <span class="math">\\mathcal{M}_{i}</span> are isomorphic as linear spaces, with the isomorphism given by dividing or multiplying by <span class="math">\\Omega_{i}(X)</span>. In particular <span class="math">\\mathcal{L}_{i}</span> is also of dimension <span class="math">2^{\\mathsf{k}-i-1}</span>. Another characterization of the elements of <span class="math">\\mathcal{L}_{i}</span> is that they are the rational functions which have at most a simple pole at each <span class="math">u\\in H_{i}</span>, and no other poles (including at <span class="math">\\infty</span>). In other words, it is the Riemann–Roch space <span class="math">\\mathscr{L}([H_{i}])</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly to <span class="math">\\mathcal{L}_{i}</span>, let <span class="math">\\mathcal{K}_{i}=\\mathscr{L}([G_{i}])\\subset k_{E_{i}}</span> be the Riemann–Roch space with divisor <span class="math">[G_{i}]</span>, i.e., the space of rational functions on <span class="math">E_{i}</span> whose poles are all simple and lie in the subgroup <span class="math">G_{i}</span>. By the Riemann–Roch theorem, $\\dim\\mathcal{K}_{i}=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\mathsf{k}-i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now wish to connect between adjacent spaces <span class="math">\\mathcal{M}_{i}</span> and <span class="math">\\mathcal{M}_{i+1}</span>; by the above-mentioned isomorphism, this will also be equivalent to a connection between adjacent <span class="math">\\mathcal{L}_{i}</span> and <span class="math">\\mathcal{L}_{i+1}</span>. Additionally we would like to connect between <span class="math">\\mathcal{K}_{i}</span> and <span class="math">\\mathcal{L}_{i}</span>, which is again equivalent to a connection between <span class="math">\\mathcal{K}_{i}</span> and <span class="math">\\mathcal{M}_{i}</span>. In all of the above, we are connecting a certain space to a space of half its dimension; and indeed, these connections will all show that the larger space is the direct sum of two copies of the smaller space, suitably transformed, and these connections will give rise to recursively defined bases for the spaces.</p>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">Connections and bases for <span class="math">\\mathcal{M}_{i}</span> and <span class="math">\\mathcal{L}_{i}</span></h4>

    <p class="text-gray-300">To connect adjacent <span class="math">\\mathcal{M}_{i}</span>-s, we use the degree 2 rational functions <span class="math">\\psi_{i}</span> as well as two auxiliary linear functions:</p>

    <h6 id="sec-78" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let <span class="math">i\\leq\\mathsf{k}-2</span>, and let <span class="math">\\chi_{i,0},\\chi_{i,1}</span> be a basis of <span class="math">\\mathbb{F}_{q}[X]^{&lt;2}</span>, i.e. any two independent linear polynomials. Denote <span class="math">v_{i}(X)=X</span>, the denominator of <span class="math">\\psi_{i}</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathcal{M}_{i}=(\\chi_{i,0}\\cdot\\psi_{i}^{<em>}(\\mathcal{M}_{i+1})\\oplus\\chi_{i,1}\\cdot\\psi_{i}^{</em>}(\\mathcal{M}_{i+1}))\\cdot v_{i}^{2^{\\mathsf{k}-i-2}-1}.</span> (13)</p>

    <p class="text-gray-300">In other words, any <span class="math">f(X)\\in\\mathcal{M}_{i}</span> can be uniquely decomposed as</p>

    <p class="text-gray-300"><span class="math">f(X)=(\\chi_{i,0}(X)f_{0}(\\psi_{i}(X))+\\chi_{i,1}(X)f_{1}(\\psi_{i}(X)))\\cdot X^{2^{\\mathsf{k}-i-2}-1}</span></p>

    <p class="text-gray-300">with <span class="math">f_{0},f_{1}\\in\\mathcal{M}_{i+1}</span>, and vice versa, every <span class="math">f</span> of this form is in <span class="math">\\mathcal{M}_{i}</span>.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The lemma is an almost immediate application of <em>[9, Lemma 3.1]</em>, with <span class="math">d=2^{\\mathsf{k}-i-1}</span> and <span class="math">\\delta=2</span>. There is a slight difference in that the original statement was only for the standard basis <span class="math">\\chi_{i,0}=1,\\chi_{i,1}=X</span> of <span class="math">\\mathbb{F}_{q}[X]^{&lt;2}</span>. We leave it as an exercise for the reader to verify that the proof applies equally well over any basis; alternatively, that a decomposition in one basis can be transformed into a decomposition in any other basis by applying the corresponding base change transformation to the polynomials <span class="math">f_{0},f_{1}</span>.</p>

    <p class="text-gray-300">Next, we connect adjacent <span class="math">\\mathcal{L}_{i}</span>-s, again using <span class="math">\\psi_{i}</span> and an auxiliary function <span class="math">\\xi_{i}</span>, described below. This decomposition will be equivalent to the above decomposition of <span class="math">\\mathcal{M}_{i}</span>, under the identifications <span class="math">\\mathcal{L}_{i}=\\Omega_{i}(X)^{-1}\\mathcal{M}_{i}</span>, <span class="math">\\mathcal{L}_{i+1}=\\Omega_{i+1}(X)^{-1}\\mathcal{M}_{i+1}</span>; thus, the validity of the two decompositions will also be equivalent. For completeness, we will prove the validity of the <span class="math">\\mathcal{L}_{i}</span> decomposition directly; thus the reader need not rely on <em>[9, Lemma 3.1]</em> for the proof of Lemma 4.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Let <span class="math">i\\leq\\mathsf{k}-2</span>, and let <span class="math">\\xi_{i}\\in\\mathbb{F}_{q}(X)</span> be a rational function with a simple pole at <span class="math">b_{i}</span>, and no other poles, including at <span class="math">\\infty</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{i}=\\psi_{i}^{<em>}(\\mathcal{L}_{i+1})\\oplus\\xi_{i}\\cdot\\psi_{i}^{</em>}(\\mathcal{L}_{i+1}).</span> (14)</p>

    <p class="text-gray-300">In other words, any <span class="math">f\\in\\mathcal{L}_{i}</span> can be uniquely decomposed as</p>

    <p class="text-gray-300"><span class="math">f(X)=f_{0}(\\psi_{i}(X))+\\xi_{i}(X)f_{1}(\\psi_{i}(X))</span></p>

    <p class="text-gray-300">with <span class="math">f_{0},f_{1}\\in\\mathcal{L}_{i+1}</span>, and vice versa, every <span class="math">f</span> of this form is in <span class="math">\\mathcal{L}_{i}</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first show that the sum on the right hand side of (14) is direct. Note that <span class="math">\\psi_{i}</span> is ramified at the points <span class="math">\\pm b_{i}</span>, and only there, and the ramification degree at those points is 2. It follows that every function in <span class="math">\\psi_{i}^{<em>}(\\mathcal{L}_{i+1})</span> has a zero or pole of even multiplicity at <span class="math">b_{i}</span>. On the other hand, <span class="math">\\xi_{i}</span> has a simple pole at <span class="math">b_{i}</span>, so any function in <span class="math">\\xi_{i}\\cdot\\psi_{i}^{</em>}(\\mathcal{L}_{i+1})</span> will have a zero or pole of odd multiplicity at <span class="math">b_{i}</span>. In particular the two spaces are disjoint and the sum is direct.</p>

    <p class="text-gray-300">It is now clear that both sides of (14) are of dimension <span class="math">\\dim\\mathcal{L}_{i}=2^{\\mathsf{k}-i-1}=2\\dim\\mathcal{L}_{i+1}</span>, so it suffices to show that one contains the other in order to prove equality. Let us show that the right hand side is contained in the left hand side.</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">As noted before, the only ramification points of <span class="math">\\psi_{i}</span> are at <span class="math">\\pm b_{i}</span>, but these points are not in <span class="math">\\psi_{i}^{-1}(H_{i+1})</span>, since they are <span class="math">x</span>-coordinates of 4-torsion points, which <span class="math">\\varphi_{i}</span> maps either to <span class="math">\\mathbf{0}</span> or outside <span class="math">G_{i+1}</span>. It follows that for any functions <span class="math">f_{0}, f_{1} \\in \\mathcal{L}_{i+1}</span>, which have at most simple poles and only at the points of <span class="math">H_{i+1}</span>, the functions <span class="math">f_{j} \\circ \\psi_{i}</span> will also have at most simple poles and only at the points of <span class="math">\\psi_{i}^{-1}(H_{i+1}) \\subset H_{i}</span>, thus <span class="math">f_{0} \\circ \\psi_{i} \\in \\mathcal{L}_{i}</span>. Similarly, since <span class="math">\\xi_{i}</span> has only a simple pole at <span class="math">b_{i} \\notin \\psi_{i}^{-1}(H_{i+1})</span>, <span class="math">\\xi_{i} \\cdot (f_{1} \\circ \\psi_{i})</span> will have at most simple poles at <span class="math">\\psi_{i}^{-1}(H_{i+1}) \\cup \\{b_{i}\\} = H_{i}</span> and again <span class="math">\\xi_{i} \\cdot (f_{1} \\circ \\psi_{i}) \\in \\mathcal{L}_{i}</span>. Thus <span class="math">f_{0} \\circ \\psi_{i} + \\xi_{i} \\cdot (f_{1} \\circ \\psi_{i}) \\in \\mathcal{L}_{i}</span> for any <span class="math">f_{0}, f_{1} \\in \\mathcal{L}_{i+1}</span>, as we wanted to show.</p>

    <p class="text-gray-300">Remark 7. To make the lemma more explicit, the condition on the poles of <span class="math">\\xi_{i}</span> is equivalent to it being equal to some linear function divided by <span class="math">X - b_{i}</span>, such that the ratio is non-constant. We will see in Section 6.1 that it is also useful to have some nice connection between the values of <span class="math">\\xi_{i}(X)</span> and <span class="math">\\xi_{i}\\big(b_{i}^{2} / X\\big)</span>, allowing for more efficient computations. For example, choosing <span class="math">\\xi_{i}(X) = \\frac{X + b_{i}}{X - b_{i}}</span> gives <span class="math">\\xi_{i}\\big(b_{i}^{2} / X\\big) = -\\xi_{i}(X)</span>. This function only works for odd characteristic, since in characteristic 2 it is constant; there we may take instead <span class="math">\\xi_{i}(X) = \\frac{b_{i}}{X - b_{i}}</span>, which satisfies <span class="math">\\xi_{i}\\big(b_{i}^{2} / X\\big) = \\xi_{i}(X) + 1</span> in characteristic 2.</p>

    <p class="text-gray-300">Remark 8. As previously noted, Lemma 5 is equivalent to Lemma 4; more specifically, to the case where <span class="math">\\chi_{i,0} = X - b_i</span> and <span class="math">\\chi_{i,1}</span> is the numerator of <span class="math">\\xi_{i}</span>. The reader is invited to verify that the two decompositions can be deduced from each other by multiplying or dividing both sides by <span class="math">\\Omega_{i}(X)</span>, using the RHS of the recursion formula (12) for relating between <span class="math">\\mathcal{L}_{i + 1}</span> and <span class="math">\\mathcal{M}_{i + 1}</span>.</p>

    <p class="text-gray-300">Lemma 5 gives us constructions for natural bases <span class="math">\\{\\lambda_{i,j}(X)\\}_{j=0}^{2^{k-i-1}-1}</span> to each <span class="math">\\mathcal{L}_i</span> and <span class="math">\\{\\mu_{i,j}(X)\\}_{j=0}^{2^{k-i-1}-1}</span> to <span class="math">\\mathcal{M}_i</span>:</p>

    <p class="text-gray-300">Definition 11. Let <span class="math">\\xi_0, \\ldots, \\xi_{k-2}</span> be as in Lemma 5. The base <span class="math">\\{\\lambda_{k-1,0}\\}</span> for <span class="math">\\mathcal{L}_{k-1}</span> is defined by <span class="math">\\lambda_{k-1,0} = 1</span>, and for each <span class="math">i = k-2, \\ldots, 0</span>, the basis <span class="math">\\{\\lambda_{i,j}(X)\\}_{j=0}^{2^{k-i-1}-1}</span> is defined recursively by</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda_{i,2j} = \\lambda_{i+1,j} \\circ \\psi_{i}, \\quad \\lambda_{i,2j+1} = \\xi_{i} \\cdot \\lambda_{i+1,j} \\circ \\psi_{i}.</span></div>

    <p class="text-gray-300">The bases <span class="math">\\{\\mu_{i,j}(X)\\}_{j=0}^{2^{k-i-1}-1}</span> to <span class="math">\\mathcal{M}_i</span> are then defined by <span class="math">\\mu_{i,j} = \\Omega_i \\cdot \\lambda_{i,j}</span>.</p>

    <p class="text-gray-300">Note that the <span class="math">\\mu_{i,j}</span> defined above also satisfy recursion relations similar to Lemma 4, specifically,</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_{i,2j} = X^{2^{k-i-2}-1} \\cdot \\chi_{i,0} \\cdot \\mu_{i+1,j} \\circ \\psi_{i}, \\quad \\mu_{i,2j+1} = X^{2^{k-i-2}-1} \\cdot \\chi_{i,1} \\cdot \\mu_{i+1,j} \\circ \\psi_{i}</span></div>

    <p class="text-gray-300">where <span class="math">\\chi_{i,0} = X - b_i</span>, <span class="math">\\chi_{i,1} = (X - b_i) \\cdot \\xi_i</span>,</p>

    <p class="text-gray-300">Connections and bases for <span class="math">\\kappa_{i}</span> Next, we decompose <span class="math">\\kappa_{i}</span> as the sum of two copies of <span class="math">\\mathcal{L}_i</span>:</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Lemma 6</h6>

    <p class="text-gray-300">Let <span class="math">i\\leq\\mathsf{k}-1</span>, and let <span class="math">\\zeta_{i}(X,Y)=\\frac{Y}{X}</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}_{i}=\\pi_{i}^{<em>}(\\mathcal{L}_{i})\\oplus\\zeta_{i}\\cdot\\pi_{i}^{</em>}(\\mathcal{L}_{i}).</span></p>

    <p class="text-gray-300">In other words, any <span class="math">f(X,Y)\\in\\mathcal{K}_{i}</span> can be uniquely decomposed as</p>

    <p class="text-gray-300"><span class="math">f(X,Y)=f_{0}(\\pi_{i}(X,Y))+\\zeta_{i}(X,Y)f_{1}(\\pi_{i}(X,Y))=f_{0}(X)+\\frac{Y}{X}f_{1}(X)</span> (15)</p>

    <p class="text-gray-300">with <span class="math">f_{0},f_{1}\\in\\mathcal{L}_{i}</span>, and vice versa, every <span class="math">f</span> of this form is in <span class="math">\\mathcal{K}_{i}</span>.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Since <span class="math">Y^{2}</span> can be written as a function of <span class="math">X</span> on the curve, it is immediate and well known that any rational function <span class="math">f(X,Y)</span> can be decomposed uniquely as in (15), with <span class="math">f_{0},f_{1}</span> rational functions. Thus it only remains to be seen that given such a decomposition, <span class="math">f</span> is in <span class="math">\\mathcal{K}_{i}</span> if and only if <span class="math">f_{0},f_{1}</span> are both in <span class="math">\\mathcal{L}_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In one direction, suppose <span class="math">f_{0},f_{1}\\in\\mathcal{L}_{i}</span>. Since <span class="math">\\mathcal{K}_{i}</span> is a linear space, it is enough to check that <span class="math">f_{0}(X)</span> and <span class="math">\\frac{Y}{X}f_{1}(X)</span> are both in <span class="math">\\mathcal{K}_{i}</span>. By definition of <span class="math">\\mathcal{L}_{i}</span> we know that as rational functions in one variable, <span class="math">f_{0},f_{1}</span> can have at most simple poles and only at points of <span class="math">H_{i}</span>. It follows that <span class="math">f_{0}\\circ\\pi_{i}</span>, <span class="math">f_{1}\\circ\\pi_{i}</span> can have poles only at the points of <span class="math">\\pi_{i}^{-1}(H_{i})=G_{i}^{\\prime}\\subset G_{i}</span>, and indeed these poles are all simple since $\\left.\\pi_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{G_{i}^{\\prime}}:G_{i}^{\\prime}\\to H_{i}<span class="math"> is exactly 2-to-1 and has no ramified points. In particular </span>f_{0}\\circ\\pi_{i}\\in\\mathcal{K}_{i}<span class="math">. Furthermore, the function </span>\\zeta_{i}=\\frac{Y}{X}<span class="math"> has exactly two simple poles, one at each point of </span>G_{i}\\setminus G_{i}^{\\prime}=\\{\\mathbf{0},\\mathbf{\\infty}\\}<span class="math">. Since </span>f_{1}\\circ\\pi_{i}<span class="math"> does not have poles at these points, it follows that </span>\\zeta_{i}\\cdot f_{1}\\circ\\pi_{i}<span class="math"> also has at most simple poles at the points of </span>G_{i}<span class="math">, i.e. belongs to </span>\\mathcal{K}_{i}$, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From the above analysis it follows that the map</p>

    <p class="text-gray-300"><span class="math">(f_{0},f_{1})\\mapsto f_{0}\\circ\\pi_{i}+\\zeta_{i}\\cdot f_{1}\\circ\\pi_{i}</span></p>

    <p class="text-gray-300">is a linear map from <span class="math">\\mathcal{L}_{i}\\oplus\\mathcal{L}_{i}</span> to <span class="math">\\mathcal{K}_{i}</span>. The uniqueness of the (general) decomposition implies this map is injective. Since we also have <span class="math">\\dim\\mathcal{K}_{i}=2^{\\mathsf{k}-i}=\\dim(\\mathcal{L}_{i}\\oplus\\mathcal{L}_{i})</span>, the map must be an isomorphism, and in particular surjective, i.e. the required decomposition indeed exists.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Remark 9</h6>

    <p class="text-gray-300">As in Lemma 5 and Remark 7, one may replace <span class="math">\\frac{Y}{X}</span> by a different function <span class="math">\\zeta_{i}</span>, as long as it has the same poles, which is equivalent to it being a linear combination of <span class="math">\\frac{Y}{X}</span> and a constant function. The particular choice of <span class="math">\\zeta_{i}=\\frac{Y}{X}</span> will provide elegant formulas in both odd and even characteristic.</p>

    <p class="text-gray-300">Using the basis we have for <span class="math">\\mathcal{L}_{i}</span>, Lemma 6 also yields a canonical basis <span class="math">\\{\\kappa_{i,j}\\}_{j=0}^{2^{\\mathsf{k}-i}-1}</span> to <span class="math">\\mathcal{K}_{i}</span>:</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Definition 12</h6>

    <p class="text-gray-300">For each <span class="math">i=0,\\ldots,\\mathsf{k}-1</span>, the basis <span class="math">\\{\\kappa_{i,j}\\}_{j=0}^{2^{\\mathsf{k}-i}-1}</span> is defined by</p>

    <p class="text-gray-300"><span class="math">\\kappa_{i,2j}=\\lambda_{i,j}\\circ\\pi_{i},\\ \\kappa_{i,2j+1}=\\zeta_{i}\\cdot\\lambda_{i,j}\\circ\\pi_{i}.</span></p>

    <p class="text-gray-300">As a corollary of Lemma 6, we can also decompose <span class="math">\\mathcal{K}_{i}</span> as the sum of two copies of <span class="math">\\mathcal{M}_{i}</span>, simply by including an additional factor of <span class="math">\\Omega_{i}</span></p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Corollary 2</h6>

    <p class="text-gray-300">Let <span class="math">i\\leq\\mathsf{k}-1</span>, and let <span class="math">\\zeta_{i}(X,Y)=\\frac{Y}{X}</span>. Then</p>

    <p class="text-gray-300"><span class="math">\\mathcal{K}_{i}=(\\pi_{i}^{<em>}(\\mathcal{M}_{i})\\oplus\\zeta_{i}\\cdot\\pi_{i}^{</em>}(\\mathcal{M}_{i}))\\cdot(\\Omega_{i}\\circ\\pi_{i})^{-1}.</span></p>

    <p class="text-gray-300">In other words, any <span class="math">f(X,Y)\\in\\mathcal{K}_{i}</span> can be uniquely decomposed as</p>

    <p class="text-gray-300"><span class="math">f(X,Y)=\\frac{f_{0}(\\pi_{i}(X,Y))+\\zeta_{i}(X,Y)f_{1}(\\pi_{i}(X,Y))}{\\Omega_{i}(X)}=\\frac{f_{0}(X)}{\\Omega_{i}(X)}+\\frac{Y}{X}\\frac{f_{1}(X)}{\\Omega_{i}(X)}</span> (16)</p>

    <p class="text-gray-300">with <span class="math">f_{0},f_{1}\\in\\mathcal{M}_{i}</span>, and vice versa, every <span class="math">f</span> of this form is in <span class="math">\\mathcal{K}_{i}</span>. ∎</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Remark 10</h6>

    <p class="text-gray-300">The curious reader might ask: If <span class="math">\\mathcal{M}_{i}</span> and <span class="math">\\mathcal{L}_{i}</span> are direct sums of copies of <span class="math">\\psi_{i}^{<em>}(\\mathcal{M}_{i})</span> and <span class="math">\\psi_{i}^{</em>}(\\mathcal{L}_{i})</span>, correspondingly, shouldn’t <span class="math">\\mathcal{K}_{i}</span> also be a direct sum of copies of <span class="math">\\varphi_{i}^{<em>}(\\mathcal{K}_{i+1})</span>? Shouldn’t there be such a decomposition which commutes with the decompositions of Lemmas 5 and 6? Perhaps surprisingly, the answer is no. The reader is invited to check that the only functions <span class="math">\\eta_{i}</span> such that <span class="math">\\eta_{i}\\cdot\\varphi_{i}^{</em>}(\\mathcal{K}_{i+1})\\subset\\mathcal{K}_{i}</span> are the constant functions: <span class="math">\\eta_{i}</span> may not have any poles, because for every point in <span class="math">E_{i}</span> there exists functions in <span class="math">\\varphi_{i}^{<em>}(\\mathcal{K}_{i+1})</span> with the maximal allowed order of pole at the point (i.e. 1 if the point is in <span class="math">G_{i}</span> or 0 otherwise). Thus, any sum <span class="math">\\eta_{i,0}\\cdot\\varphi_{i}^{</em>}(\\mathcal{K}_{i+1})+\\eta_{i,1}\\cdot\\varphi_{i}^{<em>}(\\mathcal{K}_{i+1})</span> is either not direct or not wholly contained in <span class="math">\\mathcal{K}_{i}</span>, and in any case is not equal to it. Attempting to construct such a decomposition so as to commute with those of Lemmas 5 and 6 fails because <span class="math">\\zeta_{i}</span> does not equal <span class="math">\\zeta_{i+1}\\circ\\varphi_{i}</span>, and in fact is not in <span class="math">\\varphi_{i}^{</em>}(k_{E_{i+1}})</span> at all.</p>

    <h3 id="sec-88" class="text-xl font-semibold mt-8">5.3 Evaluation domains</h3>

    <p class="text-gray-300">In this subsection we construct the evaluation domains used for our Reed–Solomon and AG codes.</p>

    <p class="text-gray-300">Let <span class="math">Q_{0}</span> be a point on <span class="math">E_{0}</span> such that <span class="math">2Q_{0}</span> is not in <span class="math">2G_{0}=\\langle 2g_{0}\\rangle</span>. Define the basic set for <span class="math">G_{0}</span> corresponding to <span class="math">Q_{0}</span> as</p>

    <p class="text-gray-300"><span class="math">S_{0}=S_{0}(Q_{0})=(Q_{0}+\\langle 2g_{0}\\rangle)\\cup(-Q_{0}+\\langle 2g_{0}\\rangle).</span></p>

    <p class="text-gray-300">Because <span class="math">2Q_{0}\\not\\in 2G_{0}</span>, this is a union of two distinct, complementary cosets of <span class="math">2G_{0}</span>, and is of size <span class="math">2^{\\mathsf{k}}</span>. Define inductively for <span class="math">0\\leq i\\leq\\mathsf{k}-2</span>, <span class="math">Q_{i+1}=\\varphi_{i}(Q_{i})</span>. Note that <span class="math">2Q_{i+1}=\\varphi_{i}(2Q_{i})\\not\\in 2G_{i+1}</span>, since <span class="math">2Q_{i}\\not\\in 2G_{i}=\\varphi_{i}^{-1}(2G_{i+1})</span>, and therefore</p>

    <p class="text-gray-300"><span class="math">S_{i+1}=\\varphi_{i+1}(S_{i})=(Q_{i+1}+\\langle 2g_{i+1}\\rangle)\\cup(-Q_{i+1}+\\langle 2g_{i+1}\\rangle)</span></p>

    <p class="text-gray-300">is again a union of two complementary and distinct cosets of <span class="math">2G_{i+1}</span>, and of size <span class="math">2^{\\mathsf{k}-i-1}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define <span class="math">T_{i}=\\pi_{i}(S_{i})</span> for <span class="math">0\\leq i\\leq\\mathsf{k}-1</span>, and note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{\\mathsf{k}-i-1}<span class="math">, since </span>\\left.\\pi_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{S_{i}}<span class="math"> is exactly 2-to-1, with all fibers being of the form </span>\\{Q_{i}+2kg_{i},-Q_{i}-2kg_{i}\\}<span class="math">. By the commutativity of Eq. (3) we also get that </span>T_{i+1}=\\psi_{i}(T_{i})<span class="math">, with </span>\\left.\\psi_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{T_{i}}<span class="math"> being 2-to-1. We note that it is easy to to split </span>T_{i}<span class="math"> to the pairs corresponding to fibers of </span>\\psi_{i}<span class="math">, i.e. pairs </span>\\{x,x^{\\prime}\\}\\subset T_{i}<span class="math">, such that </span>\\psi_{i}(x)=\\psi_{i}(x^{\\prime})<span class="math"> (or equivalently, </span>x^{\\prime}=\\frac{k\\mathsf{f}}{x}$):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <p class="text-gray-300">indeed, if <span class="math">x = x_{j} = \\pi_{i}(Q_{i} + 2jg_{i})</span>, then it will be paired with <span class="math">x&#x27; = x_{j+2^{k-i-2}} = \\pi_{i}(Q_{i} + 2(j+2^{k-i-2})g_{i})</span>, since</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\varphi_{i}(Q_{i} + 2(j + 2^{k - i - 2}) g_{i}) = \\varphi_{i}(Q_{i} + 2 j g_{i}) + \\varphi_{i}(2^{k - i - 1} g_{i}) \\\\ = \\varphi_{i}(Q_{i} + 2 j g_{i}) + \\infty = \\varphi_{i}(Q_{i} + 2 j g_{i}) \\\\ \\Rightarrow \\psi_{i}(\\pi_{i}(Q_{i} + 2(j + 2^{k - i - 2}) g_{i})) = \\pi_{i + 1}(\\varphi_{i}(Q_{i} + 2(j + 2^{k - i - 2}) g_{i})) \\\\ = \\pi_{i + 1}(\\varphi_{i}(Q_{i} + 2 j g_{i})) = \\psi_{i}(\\pi_{i}(Q_{i} + 2 j g_{i})). \\end{array}</span></div>

    <p class="text-gray-300">Note that the <span class="math">S_{i}</span> are disjoint from <span class="math">G_{i}</span>, and thus similarly <span class="math">T_{i}</span> are disjoint from <span class="math">H_{i}</span>. It follows that for any function <span class="math">f \\in \\mathcal{K}_{i}</span> we can evaluate <span class="math">f(s) \\in \\mathbb{F}_{q}</span> for all <span class="math">s \\in S_{i}</span>, and likewise for <span class="math">f \\in \\mathcal{L}_{i}</span> we can evaluate <span class="math">f(t) \\in \\mathbb{F}_{q}</span> for all <span class="math">t \\in T_{i}</span>, since such functions are guaranteed to not have poles in <span class="math">S_{i}</span> or <span class="math">T_{i}</span>, respectively. Similarly, the polynomial <span class="math">\\Omega_{i}(t)</span> is non-zero for any <span class="math">t \\in T_{i}</span>.</p>

    <p class="text-gray-300">Our evaluation domains will be made from unions of disjoint basic sets. For a set of points <span class="math">\\mathbf{Q}_0 = \\{Q_{0,1},\\ldots ,Q_{0,m}\\} \\subset E_0</span> such that the corresponding basic sets are all pairwise disjoint, let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{S}_{0} = \\bigcup_{k = 1}^{m} S_{0, k} = \\bigcup_{k = 1}^{m} S_{0} (Q_{0, k}), \\quad \\mathbf{T}_{0} = \\bigcup_{k = 1}^{m} T_{0, k} = \\bigcup_{k = 1}^{m} \\pi_{0} (S_{0, k})</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and again define <span class="math">\\mathbf{Q}_i, \\mathbf{S}_i, \\mathbf{T}_i</span> using <span class="math">\\varphi_i, \\pi_i, \\psi_i</span>. We will have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k - i} \\cdot m<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k - i - 1} \\cdot m$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Following the notation in [9], for a function <span class="math">f</span> defined on an evaluation domain <span class="math">S</span>, we denote by <span class="math">\\langle f \\wr S \\rangle</span> the evaluation table of <span class="math">f</span> on <span class="math">S</span>.</p>

    <p class="text-gray-300">Remark 11. Readers might recognize the construction of the sets <span class="math">T_{i}</span> from [9]: these correspond exactly to the construction of an FFTTree, with <span class="math">T_{i}(Q_{i})</span> being its <span class="math">i</span>-th layer. The new notions here are the construction of the sets <span class="math">S_{i}</span>, which can be considered as an extension of the FFTTree to the curves rather than just <span class="math">\\mathbb{F}_q</span>; and considering multiple such trees side-by-side in <span class="math">\\mathbf{T}_i</span> and <span class="math">\\mathbf{S}_i</span>, useful for error-correcting codes.</p>

    <h2 id="sec-89" class="text-2xl font-bold">5.4 The codes</h2>

    <p class="text-gray-300">We are finally ready to introduce our families of codes, mentioned earlier:</p>

    <p class="text-gray-300">Definition 13. Given a curve <span class="math">E_{i}</span> and an evaluation domain <span class="math">\\mathbf{S}_i</span> as above, denote</p>

    <div class="my-4 text-center"><span class="math-block">U_{i} = U_{i} (\\mathbf{S}_{i}) = C (\\mathbf{S}_{i}, [G_{i}]) = \\{\\langle f \\wr \\mathbf{S}_{i} \\rangle : f \\in \\mathcal{K}_{i} \\}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This is the AG code over <span class="math">E_{i}</span> with divisor <span class="math">[G_i]</span> and evaluation domain <span class="math">\\mathbf{S}_i</span>, which has blocksize $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k - i} \\cdot m<span class="math">, dimension </span>\\dim \\mathcal{K}_i = 2^{k - i}<span class="math"> and rate </span>\\frac{1}{m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Similarly, denote</p>

    <div class="my-4 text-center"><span class="math-block">W_{i} = \\mathsf{RS}[\\mathbb{F}_{q}, \\mathbf{T}_{i}, \\frac{1}{m}] = \\{\\langle f \\wr \\mathbf{T}_{i} \\rangle : f \\in \\mathcal{M}_{i} \\},</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is a Reed-Solomon code of blocksize $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{T}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{k - i - 1} \\cdot m<span class="math">, dimension </span>\\dim \\mathcal{M}_i = 2^{k - i - 1}<span class="math"> and rate </span>\\frac{1}{m}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The two codes are deeply related: Corollary 2 gives us a natural isomorphism between <span class="math">U_{i}</span> and <span class="math">W_{i}\\oplus W_{i}</span>, which will be discussed further in Section 6.4. It will also be useful to keep in mind the AG code</p>

    <p class="text-gray-300"><span class="math">V_{i}=C(\\mathbf{T}_{i},[H_{i}])=\\{\\langle f\\wr\\mathbf{T}_{i}\\rangle:f\\in\\mathcal{L}_{i}\\},</span></p>

    <p class="text-gray-300">defined over the projective line <span class="math">\\mathbb{P}^{1}</span>, as an intermediary between <span class="math">U_{i}</span> and <span class="math">W_{i}</span>. The isomorphism between <span class="math">\\mathcal{L}_{i}</span> and <span class="math">\\mathcal{M}_{i}</span> yields an isomorphism between <span class="math">V_{i}</span> and <span class="math">W_{i}</span>, via pointwise multiplication or division by <span class="math">\\langle\\Omega_{i}\\wr\\mathbf{T}_{i}\\rangle</span> (which is non-zero valued).</p>

    <p class="text-gray-300">An important property of the code <span class="math">U_{i}</span> is that it has a large <em>automorphism group</em>, and more specifically that there is a large <em>cyclic</em> group of code automorphisms. An automorphism of a code is a permutation of the words’ entries which preserves the property of being a codeword. These automorphisms can be described explicitly: For any point <span class="math">P\\in\\mathbf{E}_{i}</span>, let <span class="math">\\tau_{P}:E_{i}\\to E_{i}</span> denote the translation by <span class="math">P</span> map, defined by <span class="math">\\tau_{P}(Q)=Q+P,\\ \\forall Q\\in E_{i}</span>. Note that for any <span class="math">P\\in G_{i}</span>, <span class="math">\\tau_{P}(G_{i})=G_{i}</span>, which implies that <span class="math">\\tau_{P}^{<em>}:f\\mapsto f\\circ\\tau_{P}</span> is an automorphism of <span class="math">\\mathcal{K}_{i}</span>, as simple poles in <span class="math">G_{i}</span> are shifted to simple poles in <span class="math">G_{i}</span>. If we further restrict to <span class="math">P\\in 2G_{i}</span>, we find that the map <span class="math">\\tau_{P}^{</em>}:\\langle f\\wr\\mathbf{S}_{i}\\rangle\\mapsto\\langle f\\circ\\tau_{P}\\wr\\mathbf{S}_{i}\\rangle</span> is indeed an automorphism of <span class="math">U_{i}</span>, where the entries are permuted inside the <span class="math">2m</span> different cosets of <span class="math">2G_{i}</span> which comprise <span class="math">\\mathbf{S}_{i}</span>; the different cosets are never intermixed by these automorphisms. Finally, note that <span class="math">\\tau:P\\mapsto\\tau_{P}</span> is itself a homomorphism, i.e. <span class="math">\\tau_{P+Q}=\\tau_{P}\\circ\\tau_{Q}</span>, and thus so is <span class="math">\\tau^{<em>}:P\\mapsto\\tau_{P}^{</em>}</span>. It follows that <span class="math">\\tau_{2G_{i}}^{<em>}=\\langle\\tau_{2g_{i}}^{</em>}\\rangle</span> is a cyclic group of automorphisms of <span class="math">U_{i}</span> of size <span class="math">2^{\\mathbf{k}-i-1}</span>. Equivalently, this can be viewed as a faithful action of <span class="math">2G_{i}</span> on <span class="math">U_{i}</span> by code automorphisms.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Remark 12</h6>

    <p class="text-gray-300">There are additional natural automorphisms of the code <span class="math">U_{i}</span>, given by composition with reflection maps <span class="math">Q\\leftrightarrow P-Q</span>, for <span class="math">P\\in 2G_{i}</span>. These automorphisms no longer preserve the cosets of <span class="math">2G_{i}</span> comprising <span class="math">\\mathbf{S}_{i}</span>, but rather switch between the two pairs of cosets in each basic sets <span class="math">S_{i,k}</span>. These reflection maps, together with the translations <span class="math">\\tau_{2G_{i}}</span>, form a <em>dihedral</em> group of size <span class="math">2^{\\mathbf{k}-i}</span>; equivalently we can say that this dihedral group acts on <span class="math">E_{i}</span> and on <span class="math">U_{i}</span>. In fact, it is more natural to define the basic sets <span class="math">S_{i,k}</span> as <em>orbits</em> of this dihedral action. For our purposes, the cyclic part of the action is more useful than the full dihedral action, and the reader can safely ignore these extra automorphisms.</p>

    <h2 id="sec-91" class="text-2xl font-bold">6 ECFFT and ECFRI</h2>

    <p class="text-gray-300">In this section we examine FFT-like algorithms for the spaces <span class="math">\\mathcal{K}_{i},\\mathcal{L}_{i},\\mathcal{M}_{i}</span>, which transform between their representations in the bases defined in Section 5.2 and their evaluations on the basic sets defined in Section 5.3 in quasilinear time, as described in Theorem 18. We then present several applications of these algorithms: In Section 6.2 we describe low degree extensions, which allows for fast generation of the codewords from codes defined in Section 5.4. In Section 6.3</p>

    <p class="text-gray-300">we give a high level description of fast IOPP for these same curves. Finally, in Section 6.4 we describe in detail a certain relationship between the codes which arises from the FFT structure.</p>

    <p class="text-gray-300">Some of the results in this section, particularly in Section 6.2, are retreading of ideas appearing in <em>[9]</em>. This section generalizes and expands on these ideas, to more general function spaces and further applications.</p>

    <h3 id="sec-92" class="text-xl font-semibold mt-8">6.1 ECFFT</h3>

    <p class="text-gray-300">Recall that the function spaces <span class="math">\\mathcal{K}_{i},\\mathcal{L}_{i},\\mathcal{M}_{i}</span> have special bases <span class="math">\\kappa_{i,j}</span>, <span class="math">\\lambda_{i,j}</span>, <span class="math">\\mu_{i,j}</span> (Definitions 11 and 12). For a function <span class="math">f\\in\\mathcal{K}_{i}</span>, let <span class="math">[f]_{\\kappa_{i}}</span> represent its representation in the <span class="math">\\kappa_{i}</span> basis, i.e. the vector <span class="math">(c_{j})_{j=0,\\ldots,2^{k-i}-1}</span> such that <span class="math">f=\\sum c_{j}\\kappa_{i,j}</span>. Similarly, we will denote by <span class="math">[f]_{\\lambda_{i}}</span> the representation of a function <span class="math">f\\in\\mathcal{L}_{i}</span> in the <span class="math">\\lambda_{i}</span> basis, and by <span class="math">[f]_{\\mu_{i}}</span> the representation of a function <span class="math">f\\in\\mathcal{M}_{i}</span> in the <span class="math">\\mu_{i}</span> basis.</p>

    <p class="text-gray-300">Let <span class="math">Q_{i}\\in E_{i}</span> generate an orbit <span class="math">S_{i}</span> of size <span class="math">2^{k-i}</span> and let <span class="math">T_{i}=\\pi_{i}(S_{i})</span>.</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Theorem 18 (ECFFT).</h6>

    <p class="text-gray-300">There exist invertible linear transformations <span class="math">\\mathsf{FFT}_{\\mathcal{K}_{i},S_{i}}</span>, <span class="math">\\mathsf{IFFT}_{\\mathcal{K}_{i},S_{i}}</span> such that <span class="math">\\forall f\\in\\mathcal{K}_{i}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FFT}_{\\mathcal{K}_{i},S_{i}}([f]_{\\kappa_{i}})=\\langle f\\wr S_{i}\\rangle\\,,\\ \\mathsf{IFFT}_{\\mathcal{K}_{i},S_{i}}(\\langle f\\wr S_{i}\\rangle)=[f]_{\\kappa_{i}}.</span></p>

    <p class="text-gray-300">Similarly, there exist invertible linear transformations <span class="math">\\mathsf{FFT}_{\\mathcal{L}_{i},T_{i}}</span>, <span class="math">\\mathsf{IFFT}_{\\mathcal{L}_{i},T_{i}}</span> such that <span class="math">\\forall f\\in\\mathcal{L}_{i}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FFT}_{\\mathcal{L}_{i},T_{i}}([f]_{\\lambda_{i}})=\\langle f\\wr T_{i}\\rangle\\,,\\ \\mathsf{IFFT}_{\\mathcal{L}_{i},T_{i}}(\\langle f\\wr T_{i}\\rangle)=[f]_{\\lambda_{i}},</span></p>

    <p class="text-gray-300">and invertible linear transformations <span class="math">\\mathsf{FFT}_{\\mathcal{M}_{i},T_{i}}</span>, <span class="math">\\mathsf{IFFT}_{\\mathcal{M}_{i},T_{i}}</span> such that <span class="math">\\forall f\\in\\mathcal{M}_{i}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FFT}_{\\mathcal{M}_{i},T_{i}}([f]_{\\mu_{i}})=\\langle f\\wr T_{i}\\rangle\\,,\\ \\mathsf{IFFT}_{\\mathcal{M}_{i},T_{i}}(\\langle f\\wr T_{i}\\rangle)=[f]_{\\mu_{i}}.</span></p>

    <p class="text-gray-300">Moreover, all <span class="math">\\mathsf{FFT},\\mathsf{IFFT}</span> above are computable in <span class="math">O(N\\log_{2}N)</span> arithmetic operations over the ambient field, where <span class="math">N</span> is the dimension of the space (which equals the size of the evaluation domain).</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first prove for <span class="math">\\mathcal{L}_{i},T_{i}</span>. For <span class="math">i=\\mathsf{k}-1</span>, <span class="math">\\mathcal{L}_{i}</span> consists only of constant functions, with <span class="math">[c]=(c)</span> and <span class="math">\\langle c\\wr T_{i}\\rangle=(c)</span>, so the transforms are simply the identity. We continue by reverse induction. For any <span class="math">f\\in\\mathcal{L}_{i}</span>, <span class="math">i\\leq\\mathsf{k}-2</span>, write</p>

    <p class="text-gray-300"><span class="math">f(x)=f_{0}(\\psi_{i}(x))+\\xi_{i}(x)f_{1}(\\psi_{i}(x))</span> (17)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as in Lemma 5, with <span class="math">f_{0},f_{1}\\in\\mathcal{L}_{i+1}</span>. Note that by the definition of the base <span class="math">\\lambda_{i}</span> from <span class="math">\\lambda_{i+1}</span>, the translation between <span class="math">[f]_{\\lambda_{i}}</span> and <span class="math">[f_{0}]_{\\lambda_{i+1}},[f_{1}]_{\\lambda_{i+1}}</span> is trivial — the coefficient of <span class="math">\\lambda_{i+1,j}</span> in <span class="math">[f_{k}]_{\\lambda_{i+1}}</span> is exactly the coefficient of <span class="math">\\lambda_{i,2j+k}</span> in <span class="math">[f]_{\\lambda_{i}}</span>. Using <span class="math">\\mathsf{FFT}_{T_{i+1}}</span> or <span class="math">\\mathsf{IFFT}_{T_{i+1}}</span>, we can replace <span class="math">[f_{0}]_{\\lambda_{i+1}},[f_{1}]_{\\lambda_{i+1}}</span> by <span class="math">\\langle f_{0}\\wr T_{i+1}\\rangle\\,,\\langle f_{1}\\wr T_{i+1}\\rangle</span> (or vice versa) in $O(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log_{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i+1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. To conclude, we need to show that </span>\\langle f_{0}\\wr T_{i+1}\\rangle\\,,\\langle f_{1}\\wr T_{i+1}\\rangle<span class="math"> and </span>\\langle f\\wr T_{i}\\rangle<span class="math"> can be interchanged in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> operations. And this is indeed doable: let </span>x_{0},x_{1}\\in T_{i}<span class="math"> be any pair with </span>\\psi_{i}(x_{0})=\\psi_{i}(x_{1})=x^{\\prime}<span class="math">. As noted in Section 5.3, such pairs satisfy </span>x_{0}x_{1}=b_{i}^{2}<span class="math">, so </span>x^{\\prime}=x_{0}+x_{1}-2b_{i}$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">they can be easily located as they are always at distance $\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> from each other when ordered according to the coset. Substituting </span>x=x_{j}$ in (17), we find</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">f(x_{0})=f_{0}(x^{\\prime})+\\xi_{i}(x_{0})f_{1}(x^{\\prime}),\\quad f(x_{1})=f_{0}(x^{\\prime})+\\xi_{i}(x_{1})f_{1}(x^{\\prime}).</span> (18)</p>

    <p class="text-gray-300">Since <span class="math">\\xi_{i}</span> is a degree-<span class="math">1</span> rational function, it is one-to-one, thus <span class="math">\\xi_{i}(x_{0})\\neq\\xi_{i}(x_{1})</span> and the equation system (18) is invertible, allowing to solve for <span class="math">f_{0}(x^{\\prime}),f_{1}(x^{\\prime})</span> from <span class="math">f(x_{0}),f(x_{1})</span>. When <span class="math">\\xi_{i}(x_{0}),\\xi_{i}(x_{1})</span> are nicely related, the inversion formula can also be simplified: If <span class="math">\\xi_{i}(x_{1})=-\\xi_{i}(x_{0})</span> (in the odd characteristic case), then</p>

    <p class="text-gray-300"><span class="math">f_{0}(x^{\\prime})=\\frac{f(x_{0})+f(x_{1})}{2},\\quad f_{1}(x^{\\prime})=\\frac{f(x_{0})-f(x_{1})}{2\\xi_{i}(x_{0})};</span> (19)</p>

    <p class="text-gray-300">and in characteristic <span class="math">2</span>, if <span class="math">\\xi_{i}(x_{1})=\\xi_{i}(x_{0})+1</span>, then</p>

    <p class="text-gray-300"><span class="math">f_{1}(x^{\\prime})=f(x_{0})+f(x_{1}),\\quad f_{0}(x^{\\prime})=f(x_{0})+\\xi_{i}(x_{0})f_{1}(x^{\\prime}).</span> (20)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can thus exchange between <span class="math">f(x_{0}),f(x_{1})</span> and <span class="math">f_{0}(x^{\\prime}),f_{1}(x^{\\prime})</span> in <span class="math">O(1)</span> operations, using one of (18), (19) or (20) depending on the direction and characteristic. More specifically, assuming precomputation of values of the <span class="math">\\xi_{i}(x_{0})</span> and their inverses, we use only <span class="math">1</span> multiplication and <span class="math">2</span> additions/subtractions for each pair, in either direction (for <span class="math">\\mathsf{IFFT}</span> in odd characteristic, we can postpone all divisions by <span class="math">2</span> to the end). We repeat this $\\frac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times to cover all values, to obtain the transition in </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For functions in <span class="math">\\mathcal{K}_{i}</span>, the argument is similar to the argument for <span class="math">\\mathcal{L}_{i}</span>, using the decomposition</p>

    <p class="text-gray-300"><span class="math">f(x,y)=f_{0}(x)+\\zeta_{i}(x,y)f_{1}(x)</span> (21)</p>

    <p class="text-gray-300">from Lemma 6, with <span class="math">f_{0},f_{1}\\in\\mathcal{L}_{i}</span>. Again the translation between <span class="math">[f]_{\\kappa_{i}}</span> and <span class="math">[f_{0}]_{\\lambda_{i}},[f_{1}]_{\\lambda_{i}}</span> is trivial by the choice of the base, the coefficients <span class="math">[f_{j}]_{\\lambda_{i}}</span> can be translated to and from values on <span class="math">T_{i}</span> using <span class="math">\\mathsf{FFT}_{\\mathcal{L}_{i},T_{i}}</span> and <span class="math">\\mathsf{IFFT}_{\\mathcal{L}_{i},T_{i}}</span>, and for any pair <span class="math">(x,y),(x,y^{\\prime})\\in S_{i}</span> (where <span class="math">y^{\\prime}=-y</span> in odd characteristic, or <span class="math">y^{\\prime}=y+x</span> in characteristic <span class="math">2</span>) we use the relations</p>

    <p class="text-gray-300"><span class="math">f(x,y)=f_{0}(x)+\\zeta_{i}(x,y)f_{1}(x),\\quad f(x,y^{\\prime})=f_{0}(x)+\\zeta_{i}(x,y^{\\prime})f_{1}(x),</span> (22)</p>

    <p class="text-gray-300">for the remaining transitions in <span class="math">\\mathsf{FFT}</span>. Similarly to the above for <span class="math">\\xi_{i}</span>, for <span class="math">\\zeta_{i}(X,Y)=\\frac{Y}{X}</span> we again have <span class="math">\\zeta_{i}(x,y^{\\prime})=-\\zeta_{i}(x,y)</span> in odd characteristic and <span class="math">\\zeta_{i}(x,y^{\\prime})=\\zeta_{i}(x,y)+1</span> in even characteristic, so to complete the <span class="math">\\mathsf{IFFT}</span> we may use either of</p>

    <p class="text-gray-300"><span class="math">f_{0}(x)=\\frac{f(x,y)+f(x,-y)}{2},\\quad f_{1}(x)=\\frac{f(x,y)-f(x,-y)}{2\\zeta_{i}(x,y)},\\text{ or}</span> (23) <span class="math">f_{1}(x)=f(x,y)+f(x,y+x),\\quad f_{0}(x)=f(x,y)+\\zeta_{i}(x,y)f_{1}(x)</span> (24)</p>

    <p class="text-gray-300">depending on the parity of the characteristic.</p>

    <p class="text-gray-300">For <span class="math">\\mathcal{M}_{i},T_{i}</span>, we may argue similarly to the <span class="math">\\mathcal{L}_{i}</span> case using Lemma 4, with the forward formulas</p>

    <p class="text-gray-300"><span class="math">f(x_{0})</span> <span class="math">=x_{0}^{2^{k-i-1}-1}\\cdot(\\chi_{i,0}(x_{0})f_{0}(x^{\\prime})+\\chi_{i,1}(x_{0})f_{1}(x^{\\prime})),</span> (25) <span class="math">f(x_{1})</span> <span class="math">=x_{1}^{2^{k-i-1}-1}\\cdot(\\chi_{i,0}(x_{1})f_{0}(x^{\\prime})+\\chi_{i,1}(x_{1})f_{1}(x^{\\prime})),</span> (26)</p>

    <p class="text-gray-300">and inverse formulas similarly involving more coefficients; thus we may need to perform up to 4 multiplications instead of only one at every level of the transform; the coefficients themselves are assumed to be precomputed and given as advice.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A more efficient way to compute <span class="math">\\mathsf{FFT}_{\\mathcal{M}_{i},T_{i}}</span> is by instead running <span class="math">\\mathsf{FFT}_{\\mathcal{L}_{i},T_{i}}</span> on the same input (interpreted as coefficients in <span class="math">\\lambda_{i}</span>), and multiplying the result pointwise by precomputed values of <span class="math">\\langle\\Omega_{i}\\wr T_{i}\\rangle</span>, in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> operations. This yields the correct result, since </span>\\mu_{i,j}=\\Omega_{i}\\cdot\\lambda_{i,j}<span class="math">. Similarly, </span>\\mathsf{IFFT}_{\\mathcal{M}_{i},T_{i}}<span class="math"> can be computed by first dividing by </span>\\langle\\Omega_{i}\\wr T_{i}\\rangle<span class="math"> and then running </span>\\mathsf{IFFT}_{\\mathcal{L}_{i},T_{i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">These <span class="math">\\mathsf{FFT}</span>s and their inverses are analogous to the usual FFT. The main difference is that for standard FFT, the basis for the space of polynomials is the standard basis, so <span class="math">[f]</span> is simply the vector of coefficients of monomials, whereas in the EC case the “natural” basis is more complicated. The circuit itself is very similar, consisting of <span class="math">\\frac{N}{2}</span> butterflies in each of the <span class="math">\\log_{2}N</span> layers, each layer using a different stride size. For the transforms of <span class="math">\\mathcal{K}_{i}</span> and <span class="math">\\mathcal{L}_{i}</span> in the odd characteristic case, the only difference between these butterflies and those of the usual FFT is in the twiddle factors used: the values of <span class="math">\\zeta_{i}</span> or <span class="math">\\xi_{i}</span> at the points of <span class="math">S_{i}</span> or <span class="math">T_{i}</span>, instead of roots of unity (or a coset). These values are determined by a precomputation, which the <span class="math">\\mathsf{FFT}/\\mathsf{IFFT}</span> circuit need not be aware of.</p>

    <h3 id="sec-95" class="text-xl font-semibold mt-8">6.2 Low Degree Extensions and the codes</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbf{S}_{i}=\\bigcup_{k=1}^{m}S_{i,k}</span> be an evaluation domain as in Section 5.3. Given an array of elements of <span class="math">\\mathbb{F}_{q}</span> of size <span class="math">2^{k-i}</span>, we can interpret it as an evaluation table <span class="math">\\langle f\\wr S_{i,1}\\rangle</span> of a unique function <span class="math">f\\in\\mathcal{K}_{i}</span>, and compute <span class="math">[f]_{\\kappa_{i}}</span> by <span class="math">\\mathsf{IFFT}_{\\mathcal{K}_{i},S_{i,1}}</span>. Then, by applying <span class="math">\\mathsf{FFT}_{\\mathcal{K}_{i},S_{i,2}},\\ldots,\\mathsf{FFT}_{\\mathcal{K}_{i},S_{i,m}}</span> to <span class="math">[f]_{\\kappa_{i}}</span>, we can evaluate <span class="math">\\langle f\\wr\\mathbf{S}_{i}\\rangle\\in U_{i}</span>. This process is the <em>low degree extension</em> (or LDE) from <span class="math">\\langle f\\wr S_{i,1}\\rangle</span> to <span class="math">\\langle f\\wr\\mathbf{S}_{i}\\rangle</span>, which extends a given array into the unique <span class="math">U_{i}</span> codeword that matches it.</p>

    <p class="text-gray-300">Similarly, let <span class="math">\\mathbf{T}_{i}=\\bigcup_{k=1}^{m}T_{i,k}</span> be an evaluation domain for <span class="math">\\mathcal{L}_{i}</span> or <span class="math">\\mathcal{M}_{i}</span>. We can uniquely extend any function <span class="math">\\langle f\\wr T_{i,1}\\rangle</span> to <span class="math">\\langle f\\wr\\mathbf{T}_{i}\\rangle</span> with <span class="math">f\\in\\mathcal{L}_{i}</span> or <span class="math">f\\in\\mathcal{M}_{i}</span>, yielding codewords in <span class="math">V_{i}</span> or <span class="math">W_{i}</span> respectively, and again the extensions can be computed efficiently with inverse and forward <span class="math">\\mathsf{FFT}</span>s.</p>

    <p class="text-gray-300">In <em>[9]</em>, the main building block of the algorithms was the EXTEND algorithm, transforming an evaluation table of a low degree polynomial <span class="math">\\langle P\\wr T_{i,0}\\rangle</span> to an evaluation of it on a different set <span class="math">\\langle P\\wr T_{i,1}\\rangle</span>. It can be seen that this algorithm indeed simply the composition of <span class="math">\\mathsf{FFT}_{\\mathcal{M}_{i},T_{i,1}}</span> on <span class="math">\\mathsf{IFFT}_{\\mathcal{M}_{i},T_{i,0}}</span>, as was briefly mentioned in the paper. The reader is encouraged to compare the EXTEND algorithm as described in <em>[9]</em> to this composition of <span class="math">\\mathsf{FFT}</span>s and observe they are equivalent.</p>

    <p class="text-gray-300">###</p>

    <h3 id="sec-96" class="text-xl font-semibold mt-8">6.3 EC-FRI</h3>

    <p class="text-gray-300">In this section we present a high-level description of how the FFT structure enables the FRI protocol for the Reed–Solomon codes <span class="math">W_{i}</span>, and similar results for the AG-codes <span class="math">U_{i}</span> and <span class="math">V_{i}</span>. More details about this protocol, including the choice of the queries and the soundness analysis, appear in Appendix B.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{T}_{0}=\\bigcup_{k=1}^{m}T_{0,k}</span> be an evaluation domain for <span class="math">\\mathcal{M}_{0}</span> as in Section 5.3, and let <span class="math">T_{i,k},\\mathbf{T}_{i}</span> be the corresponding domains for <span class="math">\\mathcal{M}_{i}</span>. A prover <span class="math">\\mathsf{P}</span> has access to a function <span class="math">f_{0}:\\mathbf{T}_{0}\\to\\mathbb{F}_{q}</span>, and wishes to prove to verifier <span class="math">\\mathsf{V}</span> that it is an evaluation table <span class="math">\\langle f\\wr\\mathbf{T}_{0}\\rangle</span> of a function <span class="math">f\\in\\mathcal{M}_{0}</span>, i.e. a codeword from <span class="math">U_{0}</span>, or at least close to one in Hamming distance.</p>

    <p class="text-gray-300">Over <span class="math">\\mathsf{k}-1</span> (or fewer) rounds of interaction, the verifier will provide randomness <span class="math">z_{i}</span>, and the prover will commit (and provide oracle access to) a table <span class="math">\\langle f_{i+1}\\wr\\mathbf{T}_{i+1}\\rangle</span>, where <span class="math">f_{i+1}</span> is supposedly defined by</p>

    <p class="text-gray-300"><span class="math">f_{i+1}(X)=f_{i,0}(X)+z_{i}f_{i,1}(X)</span> (27)</p>

    <p class="text-gray-300">where <span class="math">f_{i,0},f_{i,1}\\in M_{i+1}</span> are the functions from the decomposition</p>

    <p class="text-gray-300"><span class="math">f_{i}(X)=(\\chi_{i,0}(X)f_{i,0}(\\psi_{i}(X))+\\chi_{i,1}(X)f_{i,1}(\\psi_{i}(X)))\\cdot X^{2^{k-i-2}-1}</span> (28)</p>

    <p class="text-gray-300">given by Lemma 4. The verifier can check that <span class="math">f_{i+1}</span> was appropriately computed by querying <span class="math">f_{i+1}</span> at points <span class="math">x^{\\prime}\\in\\mathbf{T}_{i+1}</span> and <span class="math">f_{i}</span> at <span class="math">\\{x_{0},x_{1}\\}=\\psi_{i}^{-1}(x^{\\prime})\\subset\\mathbf{T}_{i}</span>, computing <span class="math">f_{i,0}(x^{\\prime}),f_{i,1}(x^{\\prime})</span> from <span class="math">f_{i}(x_{0}),f_{i}(x_{1})</span> by (28) (as in the matching <span class="math">\\mathsf{IFFT}_{\\mathcal{M}_{i}}</span>), and verifying (27) holds at <span class="math">x^{\\prime}</span>. In the final round the prover will also commit to <span class="math">f_{\\mathsf{k}-1}</span> being a constant function; or, if performing only <span class="math">r</span> rounds, will give <span class="math">f_{r}</span> explicitly, for example by the coefficient list <span class="math">[f_{r}]_{\\mu_{r}}</span>, allowing for quick evaluation to each <span class="math">T_{r,k}</span>.</p>

    <p class="text-gray-300">A similar method can be used for proving proximity to the <span class="math">V_{0}</span> code, i.e. to an evaluation table <span class="math">\\langle f\\wr\\mathbf{T}_{0}\\rangle</span> with <span class="math">f\\in\\mathcal{L}_{0}</span>. The process is equivalent to that for <span class="math">\\mathcal{M}_{i}</span> and the <span class="math">U_{i}</span> codes above, and in each step both the words and the codes differ only by fixed pointwise multiplications, which does not affect the Hamming distance. Note that verifying the relationship between <span class="math">f_{i}</span> and <span class="math">f_{i+1}</span> in this setting will require the prover and the verifier to use the <span class="math">\\mathsf{IFFT}_{\\mathcal{L}_{i}}</span> formulas (either (19) or (20) depending on the characteristic) instead, which are computationally cheaper than inverting (27).</p>

    <p class="text-gray-300">We can extend this method to an IOPP for the AG code <span class="math">U_{0}</span>: Given an evaluation domain <span class="math">\\mathbf{S}_{0}=\\bigcup_{k=1}^{m}S_{0,k}</span> for <span class="math">\\mathcal{K}_{0}</span> and an evaluation table <span class="math">\\langle h\\wr\\mathbf{S}_{0}\\rangle</span> supposedly of a function <span class="math">h\\in\\mathcal{K}_{0}</span>, the prover can either compute the decomposition</p>

    <p class="text-gray-300"><span class="math">h(X,Y)=\\widetilde{h}_{0}(X)+\\zeta_{0}(X,Y)\\widetilde{h}_{1}(X)</span> (29)</p>

    <p class="text-gray-300">from Lemma 6 or</p>

    <p class="text-gray-300"><span class="math">h(X,Y)=\\frac{h_{0}(X)}{D_{0}(X)}+\\zeta_{0}(X,Y)\\frac{h_{1}(X)}{D_{0}(X)}</span> (30)</p>

    <p class="text-gray-300">from Corollary 2. The prover then computes <span class="math">f_{0}=\\widetilde{h}_{0}+z\\cdot\\widetilde{h}_{1}</span> (or <span class="math">h_{0}+z\\cdot h_{1}</span>) and commits to <span class="math">\\langle f_{0}\\wr\\mathbf{T}_{0}\\rangle</span>, where <span class="math">z</span> is randomness from the verifier. After this first</p>

    <p class="text-gray-300">step the protocol continues as above to show <span class="math">f_{0}</span> is close to a <span class="math">V_{0}/W_{0}</span> codeword. As before, the methods are equivalent whether we work with <span class="math">V_{i}</span> or <span class="math">W_{i}</span>, but the <span class="math">V_{i}</span> method is more efficient. However, we will focus on working over <span class="math">W_{i}</span> in the next section, to more immediately apply existing soundness results.</p>

    <h3 id="sec-97" class="text-xl font-semibold mt-8">6.4 The isomorphism between <span class="math">U_{0}</span> and <span class="math">W_{0}\\oplus W_{0}</span></h3>

    <p class="text-gray-300">We note that equation (30), evaluated at all points <span class="math">(x,y)\\in\\mathbf{S}_{0}</span>, gives rise to an isomorphism between <span class="math">U_{0}</span> and <span class="math">W_{0}\\oplus W_{0}</span>, which sends <span class="math">\\langle h\\wr\\mathbf{S}_{0}\\rangle</span> to the table of pairs <span class="math">\\langle(h_{0},h_{1})\\wr\\mathbf{T}_{0}\\rangle</span> and vice versa; the same equation and map can also be applied to evaluation tables or pairs which are not necessarily codewords. Importantly, this map is local: to access <span class="math">h_{0}(x)</span> and/or <span class="math">h_{1}(x)</span>, <span class="math">h</span> need only be accessed at the two points in <span class="math">\\{(x,y),(x,y^{\\prime})\\}=\\pi_{0}^{-1}(x)</span>. This also implies that this isomorphism roughly preserves the Hamming distance; more specifically, if we consider <span class="math">U_{0}</span> and <span class="math">W_{0}\\oplus W_{0}</span> as codes over the alphabet <span class="math">\\mathbb{F}_{q}^{2}</span>, whose characters are folded as <span class="math">(h(x,y),h(x,y^{\\prime}))</span> and <span class="math">(h_{0}(x),h_{1}(x))</span>, correspondingly, then the isomorphism preserves the Hamming distance of errors in these pairs: each character is independently acted upon by an invertible <span class="math">\\mathrm{GL}_{2}(\\mathbb{F}_{q})</span> matrix.</p>

    <p class="text-gray-300">The above protocol can thus be viewed as applying the isomorphism to replace <span class="math">\\langle h\\wr\\mathbf{S}_{0}\\rangle</span> with <span class="math">\\langle(h_{0},h_{1})\\wr\\mathbf{T}_{0}\\rangle</span>, then moving to a random linear combination of <span class="math">h_{0},h_{1}</span> to prove that both are proximal to <span class="math">W_{0}</span> simultaneously. Our main application for this protocol would involve proving proximity not for a single table <span class="math">\\langle h\\wr\\mathbf{S}_{0}\\rangle</span> but multiple tables <span class="math">\\langle h_{l}\\wr\\mathbf{S}_{0}\\rangle</span>, <span class="math">l=1,\\ldots,\\mathsf{w}</span> batched together. In this scenario we would prefer to first split each <span class="math">h_{l}</span> into <span class="math">h_{l,0},h_{l,1}</span> via our isomorphism, then take a random linear combination <span class="math">\\sum_{l=1}^{\\mathsf{w}}\\sum_{j=0}^{1}z_{l,j}h_{l,j}</span> of all <span class="math">2\\mathsf{w}</span> functions and apply FRI to it, batching all <span class="math">2\\mathsf{w}</span> proofs together. An alternative, and perhaps more natural, approach would be to take first a random linear combination <span class="math">\\sum_{l=1}^{\\mathsf{w}}z_{l}h_{l}</span> of the <span class="math">\\mathsf{w}</span> functions on <span class="math">\\mathbf{S}_{0}</span>, and then apply once the full proximity proof to <span class="math">U_{0}</span>. The difference between the two approaches is subtle, and the main advantage of the first approach over the second is that its soundness analysis is again an immediate application of existing results.</p>

    <h2 id="sec-98" class="text-2xl font-bold">7 Degree Adjustment</h2>

    <p class="text-gray-300">In Section 6.3 we discussed a proof protocol for showing an evaluation table <span class="math">\\langle f\\wr\\mathbf{S}_{0}\\rangle</span> arises from a function <span class="math">f\\in\\mathcal{K}_{0}=\\mathscr{L}([G_{0}])</span>. Our STARK proofs will need another, slightly more complex tool: we would like to show that certain functions also have zeros on a specified set of points; and on the other hand, the poles of these functions might not be simple and not at the entirety of <span class="math">G_{0}</span>, but rather be contained in some subgroup <span class="math">2^{e}G_{0}</span>, and have multiplicity at most <span class="math">2^{e}</span> each.</p>

    <p class="text-gray-300">More explicitly, let <span class="math">e\\geq 1</span> and let <span class="math">C</span> be some coset of <span class="math">2^{e+1}G_{0}</span> which is disjoint from <span class="math">\\mathbf{S}_{0}</span> and from <span class="math">G_{0}</span>. Our goal in this section is to construct a proof of proximity to the AG code of evaluation tables <span class="math">\\langle f\\wr\\mathbf{S}_{0}\\rangle</span> where <span class="math">f\\in\\mathscr{L}(2^{e}[2^{e}G_{0}]-[I])</span>, where <span class="math">I</span> is any non-empty subset of <span class="math">C</span>; it will be assumed that <span class="math">f</span> is already known to</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">be in <span class="math">\\mathscr{L}(2^{e}[2^{e}G_{0}])</span>. This will be achieved by reducing this problem to the problem of proximity testing to <span class="math">U_{0}</span>, where the reduction is performed by pointwise multiplication by a function <span class="math">\\omega_{I}</span> with appropriate properties, listed below. For simplicity of presentation, we will henceforth assume <span class="math">e=1</span>; the results can be immediately generalized to larger <span class="math">e</span>.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Definition 14.</h6>

    <p class="text-gray-300">A function <span class="math">\\omega_{I}\\in k_{E_{0}}</span> is called a <em>degree adjustment</em> for validity domain <span class="math">I</span>, if it satisfies the following four properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">P\\in 2G_{0}</span>, <span class="math">\\omega_{I}</span> has (at least) a simple zero at <span class="math">P</span>;</li>

      <li>For every <span class="math">P\\in g_{0}+2G_{0}</span>, <span class="math">\\omega_{I}</span> has (at most) a simple pole at <span class="math">P</span>;</li>

      <li>For every <span class="math">P\\in I</span>, <span class="math">\\omega_{I}</span> has (exactly) a simple pole at <span class="math">P</span>;</li>

      <li><span class="math">\\omega_{I}</span> has no other poles except as specified above. It may have other zeros.</li>

    </ol>

    <p class="text-gray-300">The following claim shows that such a function enables the wanted reduction:</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Let <span class="math">\\omega_{I}</span> be a degree adjustment for a set <span class="math">I\\subset C</span>. Then for every <span class="math">f\\in\\mathscr{L}(2[2G_{0}])</span>, we have</p>

    <p class="text-gray-300"><span class="math">f\\ \\text{vanishes at all points in }I\\ \\Leftrightarrow\\omega_{I}\\cdot f\\in\\mathscr{L}([G_{0}])=\\mathcal{K}_{0}.</span></p>

    <p class="text-gray-300">In other words, if it is known that a function <span class="math">f</span> has poles only at <span class="math">2G_{0}</span> and of multiplicity at most 2, then <span class="math">f</span> also vanishes at the points of <span class="math">I</span> if and only if <span class="math">\\omega_{I}\\cdot f</span> is a <span class="math">\\mathcal{K}_{0}</span> function, i.e. with at most simple poles and only at <span class="math">G_{0}</span>.</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In terms of divisors, properties 1–4 translate immediately to the inequality</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}(\\omega_{I})\\geq[2G_{0}]-[g_{0}+2G_{0}]-[I]=(2[2G_{0}]-[I])-[G_{0}],</span></p>

    <p class="text-gray-300">from which the <span class="math">\\Rightarrow</span> direction follows immediately by the definition of the spaces.</p>

    <p class="text-gray-300">Note that the above inequality does not capture the conditions perfectly: specifically, property 3 states that <span class="math">\\omega_{I}</span> <em>has</em> poles at the points of <span class="math">I</span>, and rules out the possibility of the function being defined or vanishing at those points, which the inequality itself does not. This in turn is necessary (and sufficient) for the <span class="math">\\Leftarrow</span> direction: if <span class="math">\\omega_{I}\\cdot f\\in\\mathscr{L}([G_{0}])</span>, then it does not have poles at the points of <span class="math">I</span> (which is disjoint from <span class="math">G_{0}</span>). Since <span class="math">\\omega_{I}</span> does have poles at those points, it follows that <span class="math">f</span> must vanish at them. Since we already assume <span class="math">f\\in\\mathscr{L}(2[2G_{0}])</span>, giving the necessary bounds on the location and multiplicity of poles, this is enough to deduce <span class="math">f\\in\\mathscr{L}(2[2G_{0}]-[I])</span>.</p>

    <p class="text-gray-300">Our aim in this section is to construct such degree adjustments. Moreover, since these are to be used as part of a proof protocol, we need the construction to be well defined in terms of <span class="math">I</span>, and succinct, so that both prover and verifier can compute it in reasonable time. We will show:</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Theorem 19.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">C</span> be a coset of <span class="math">2G_{0}</span> disjoint from <span class="math">G_{0}</span>. Denote <span class="math">\\overline{C}=G_{0}\\cup(C+G_{0})\\cup(-C+G_{0})</span>, a union of three cosets of <span class="math">G_{0}</span>. For every non-empty subset <span class="math">I\\subset C</span>, there exists a well-defined degree-adjustment <span class="math">\\omega_{I}</span>. Moreover, for any point <span class="math">P\\in E_{0}\\setminus\\overline{C}</span>, <span class="math">\\omega_{I}(P)</span> is computable in $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{k})<span class="math"> field operations, where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the coset complexity of </span>I$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">In the following subsections we construct the degree adjustment in three steps. Each step will provide us with a function with some properties related to the definition of the degree adjustment. We denote these functions <span class="math">\\nu_{0},\\mu_{I},\\eta_{I}</span> (<span class="math">\\nu_{0}</span> will not depend on the zero-set <span class="math">I</span>, only on the curve). The full degree adjustment will be the product of the three functions, <span class="math">\\omega_{I}=\\nu_{0}\\cdot\\mu_{I}\\cdot\\eta_{I}</span>.</p>

    <p class="text-gray-300">A useful tool in the construction of these functions will be the following lemma:</p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Lemma 8</h6>

    <p class="text-gray-300">Let <span class="math">P,Q,R,S\\in E</span> be points on an elliptic curve with <span class="math">P+Q=R+S</span>. Then there exists a function <span class="math">r=r_{P,Q;R,S}\\in k_{E}</span> with</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}(r)=[P]+[Q]-[R]-[S].</span></p>

    <p class="text-gray-300">Moreover, <span class="math">r(T)</span> can be computed in <span class="math">O(1)</span> field operations for any <span class="math">T\\in E\\setminus\\{R,S,-R-S\\}</span>.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">Consider the equations defining the line passing through <span class="math">P,Q</span>, and the line passing through <span class="math">R,S</span> (if, say <span class="math">P=Q</span>, then we use the tangent to the curve). Both lines pass through a common third point, <span class="math">-P-Q=-R-S</span>. The ratio of the two equations gives a function as desired. Since the function is of the form <span class="math">r(X,Y)=\\frac{a_{1}X+b_{1}Y+c_{1}}{a_{2}X+b_{2}Y+c_{2}}</span>, clearly it is computable in <span class="math">O(1)</span> field operations whenever the denominator is non-zero. Additionally, extracting the coefficients of <span class="math">r</span> from the points <span class="math">P,Q,R,S</span> can also be done in <span class="math">O(1)</span> operations.</p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Remark 13</h6>

    <p class="text-gray-300">Note that <span class="math">r</span> is only well defined up to multiplication by a constant. For consistency we should normalize it such that the process always returns the same function. For example, we can normalize each line equation <span class="math">aX+bY+c</span> to have either <span class="math">a=1</span>, or <span class="math">a=0</span> and <span class="math">b=1</span>, or <span class="math">a=b=0</span> and <span class="math">c=1</span>.</p>

    <p class="text-gray-300">The condition that <span class="math">P+Q=R+S</span> is necessary for such <span class="math">r</span> to exist. In the next subsections, whenever we refer to a function <span class="math">r_{P,Q;R,S}</span>, it will be implicit that <span class="math">P+Q=R+S</span> (and this will always be obvious to verify).</p>

    <h3 id="sec-106" class="text-xl font-semibold mt-8">7.1 Step 1 - the independent part of the degree adjustment</h3>

    <p class="text-gray-300">In this section we construct the function <span class="math">\\nu_{0}</span>, whose job is to shift the double poles at <span class="math">2G_{0}</span> to simple poles at <span class="math">G_{0}</span>, i.e. to satisfy properties 1 and 2 of the degree adjustment. This is in fact too much to ask: due to structure of the curve, no function exists with exactly this property. We compromise by allowing <span class="math">\\nu_{0}</span> not to touch the pole at <span class="math">\\mathbf{0}</span>, and have a double zero at <span class="math">\\mathbf{\\infty}</span> instead.</p>

    <p class="text-gray-300">More precisely, we construct functions <span class="math">\\nu_{i}\\in k_{E_{i}}</span> for <span class="math">i\\leq\\mathsf{k}-2</span> with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">P\\in 2G_{i}\\setminus\\{\\mathbf{0},\\mathbf{\\infty}\\}</span>, <span class="math">\\nu_{i}</span> has a simple zero at <span class="math">P</span>;</li>

      <li>For every <span class="math">P\\in g_{i}+2G_{i}</span>, <span class="math">\\nu_{i}</span> has a simple pole at <span class="math">P</span>;</li>

      <li><span class="math">\\nu_{i}</span> has a <em>double zero</em> at <span class="math">\\mathbf{\\infty}</span>;</li>

      <li><span class="math">\\nu_{i}</span> has no other poles and zeros except as specified above, in particular it has no pole and no zero at <span class="math">\\mathbf{0}</span>.</li>

    </ol>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">In other words, <span class="math">\\nu_{i}</span> must have the divisor</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}(\\nu_{i})=[2G_{i}]-[g_{i}+2G_{i}]+[\\infty]-[\\mathbf{0}],</span></p>

    <p class="text-gray-300">which defines it up to a scalar. We thus show the following claim:</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Claim</h6>

    <p class="text-gray-300">There exists an explicit function <span class="math">\\nu_{0}\\in k_{E_{0}}</span> with</p>

    <p class="text-gray-300"><span class="math">\\operatorname{div}(\\nu_{0})=[2G_{0}]-[g_{0}+2G_{0}]+[\\infty]-[\\mathbf{0}].</span></p>

    <p class="text-gray-300">For any <span class="math">P\\notin G_{0}</span>, <span class="math">\\nu(P)</span> can be computed using <span class="math">O(\\mathsf{k})</span> field operations.</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof</h6>

    <p class="text-gray-300">We construct <span class="math">\\nu_{i}</span> by backwards induction, starting from <span class="math">i=\\mathsf{k}-2</span>. We have that <span class="math">2G_{\\mathsf{k}-2}=\\{\\mathbf{0},\\infty\\}</span> so we only need a double zero at <span class="math">\\infty</span> and simple poles at <span class="math">\\pm P_{\\mathsf{k}-2}</span>, which is satisfied by the function</p>

    <p class="text-gray-300"><span class="math">\\nu_{\\mathsf{k}-2}(X,Y)=\\frac{1}{X-b_{\\mathsf{k}-2}}=r_{\\infty,\\infty;P_{\\mathsf{k}-2},-P_{\\mathsf{k}-2}}(X,Y).</span></p>

    <p class="text-gray-300">We then construct each <span class="math">\\nu_{i}</span> from <span class="math">\\nu_{i+1}</span> by</p>

    <p class="text-gray-300"><span class="math">\\nu_{i}(X,Y)=\\frac{X-b_{i}}{X}\\cdot\\nu_{i+1}(\\varphi_{i}(X,Y)).</span></p>

    <p class="text-gray-300">The simple poles of <span class="math">\\nu_{i+1}</span> at <span class="math">g_{i+1}+2G_{i+1}</span> are translated to simple poles of <span class="math">\\nu_{i+1}\\circ\\varphi_{i}</span> at <span class="math">g_{i}+2G_{i}=\\varphi_{i}^{-1}(g_{i+1}+2G_{i+1})</span>. The simple zeros of <span class="math">\\nu_{i+1}</span> at <span class="math">2G_{i+1}\\setminus\\{\\mathbf{0},\\infty\\}</span> are translated to simple zeros of <span class="math">\\nu_{i+1}\\circ\\varphi_{i}</span> at <span class="math">2G_{i}\\setminus\\{\\mathbf{0},\\infty,\\pm P_{i}\\}</span> and the double zero of <span class="math">\\nu_{i+1}</span> at <span class="math">\\infty</span> is translated to double zeros of <span class="math">\\nu_{i+1}\\circ\\varphi_{i}</span> at <span class="math">\\mathbf{0}</span> and <span class="math">\\infty</span>. The term <span class="math">\\frac{X-b_{i}}{X}=r_{P_{i},-P_{i};\\mathbf{0},\\mathbf{0}}(X,Y)</span> then compensates for the lack of zero at <span class="math">\\pm P_{i}</span> and the spare double zero at <span class="math">\\mathbf{0}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using this recursive formula, the function <span class="math">\\nu_{0}</span> can be evaluated at any point outside of <span class="math">G_{0}</span> in just <span class="math">O(\\mathsf{k})</span> field operations (which is logarithmic in the number of evaluation points). Moreover, when evaluating <span class="math">\\nu_{0}</span> on a coset of <span class="math">2G_{0}</span> we use <span class="math">\\nu_{i+1}(\\varphi_{i}(P))</span> both in the evaluation of <span class="math">\\nu_{i}(P)</span> and of <span class="math">\\nu_{i}(P+\\mathbf{0})</span>. Since the sizes of the layers shrink exponentially, it follows that evaluating <span class="math">\\nu_{0}</span> on an entire coset of <span class="math">2G_{0}</span> can be done in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2G_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> field operations. Moreover, this computation does not depend on </span>I<span class="math">, so it can be done once and stored as a precomputation for any required </span>\\omega_{I}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-109" class="text-xl font-semibold mt-8">7.2 Step 2 - the part that depends on the validity domain</h3>

    <p class="text-gray-300">In this subsection we construct the function <span class="math">\\mu_{I}</span>, which is the part of <span class="math">\\omega_{I}</span> responsible for ensuring there are simple poles at the points of <span class="math">I</span> (property 3). More precisely, we show the following:</p>

    <h6 id="sec-110" class="text-base font-medium mt-4">Claim</h6>

    <p class="text-gray-300">For any <span class="math">I\\subset C</span>, there exists an explicit function <span class="math">\\mu_{I}\\in k_{E_{0}}</span> with</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\operatorname{div}(\\mu_{I})=[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}]-[\\infty]+\\sum_{P\\in I}([P-g_{0}]-[P]).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">P\\notin\\overline{C}</span>, <span class="math">\\mu_{I}(P)</span> can be computed in $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ field operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <p class="text-gray-300">Note that such a function exists (and well defined up to a constant) since it has the same number of poles and zeros, and the sum of poles equals the sum of zeros. Additionally, since <span class="math">I</span> is contained in a coset of <span class="math">2G_0</span> which is disjoint from <span class="math">G_0</span>, all points in the divisor above are pairwise different, and in particular <span class="math">\\mu_I</span> does have simple poles at every point of <span class="math">I</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that the coset complexity of $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> of </span>I<span class="math"> is the smallest possible sum </span>\\sum_{J} (\\log_2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + 1)<span class="math"> over all presentations </span>\\mathbf{1}_I = \\sum_J \\epsilon_J \\cdot \\mathbf{1}_J<span class="math">, where each </span>J<span class="math"> is a coset of a subgroup of </span>2G_0<span class="math">. We first show how to construct each </span>\\mu_J<span class="math"> with the above divisor, then show that </span>\\mu_J<span class="math"> can be obtained from </span>\\prod \\mu_J^{\\epsilon_J}$ and a small correction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Periodic validity domain <span class="math">J</span></strong> Since <span class="math">J</span> is a coset of a subgroup of <span class="math">2G_0</span>, we have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^m<span class="math"> for some </span>m \\leq k - 1<span class="math">. Denote </span>J_0 = J<span class="math"> and define recursively </span>J_1, \\ldots, J_m<span class="math"> by </span>J_{i+1} = \\varphi_i(J_i)<span class="math">. We then have that each </span>J_i<span class="math"> is a coset of a subgroup </span>2G_i<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{m-i}<span class="math">. We construct </span>\\mu_{J_i} \\in k_{E_i}$ with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{div}(\\mu_{J_i}) = [2^{m-i} g_i] - [\\infty] + \\sum_{P \\in J_i} ([P - g_i] - [P])</span></div>

    <p class="text-gray-300">by backwards induction, starting from <span class="math">i = m</span>.</p>

    <p class="text-gray-300">For <span class="math">i = m</span> we have <span class="math">J_m = \\{P\\}</span>. The function <span class="math">\\mu_{J_m}</span> should satisfy</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{div}(\\mu_{J_m}) = [g_m] + [P - g_m] - [\\infty] - [P],</span></div>

    <p class="text-gray-300">so we take <span class="math">\\mu_{J_m} = r_{g_m,P - g_m;\\infty,P}</span>, which is computable in <span class="math">O(1)</span> everywhere except <span class="math">\\pm P</span> and <span class="math">\\infty</span>.</p>

    <p class="text-gray-300">Because <span class="math">J_i = \\varphi_i^{-1}(J_{i+1})</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{div}(\\mu_{J_{i+1}} \\circ \\varphi_i) = [2^{m-i-1} g_i] + [2^{m-i-1} g_i + \\mathbf{0}] - [\\infty] - [\\mathbf{0}] + \\sum_{P \\in J_i} ([P - g_i] - [P]).</span></div>

    <p class="text-gray-300">To get the right divisor we must therefore add a correction of</p>

    <div class="my-4 text-center"><span class="math-block">[2^{m-i} g_i] + [\\mathbf{0}] - [2^{m-i-1} g_i] - [2^{m-i-1} g_i + \\mathbf{0}),</span></div>

    <p class="text-gray-300">which can do by defining</p>

    <div class="my-4 text-center"><span class="math-block">\\mu_{J_i} = r_{2^{m-i} g_i, \\mathbf{0}; 2^{m-i-1} g_i, 2^{m-i-1} g_i + \\mathbf{0}} \\cdot \\mu_{J_{i+1}} \\circ \\varphi_i.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Putting this all together, we find that the computation of <span class="math">\\mu_J</span> can be performed everywhere outside <span class="math">G_0</span> and <span class="math">(J \\cup -J) \\subset (C \\cup -C)</span>, in $O(m + 1) = O(\\log_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1)<span class="math"> operations, and the computation of all relevant </span>\\mu_J<span class="math"> is done in </span>O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations, and we conclude the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Obtaining <span class="math">\\mu_I</span> from <span class="math">\\prod_J \\mu_J^{\\epsilon_J}</span></strong> We now wish to obtain a way to compute <span class="math">\\mu_I</span> from its components <span class="math">\\mu_J</span>. To do this, it can be helpful to first expand the notion of <span class="math">\\mu_I</span> from merely subsets <span class="math">I \\subset C</span>, to <em>signed multisubsets</em> of <span class="math">C</span>. These are simply integer valued functions <span class="math">I: C \\to \\mathbb{Z}</span>, and we would like the function <span class="math">\\mu_I</span> to satisfy</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{div}(\\mu_{I})=[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}]-[\\infty]+\\sum_{P\\in C}I(P)\\cdot([P-g_{0}]-[P]),$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\sum_{P\\in C}I(P)<span class="math">. Note that standard sets can be identified with their indicator functions, and the definition of </span>\\mu_{I}=\\mu_{\\mathbf{1}_{I}}<span class="math"> remains consistent. Since we have </span>\\mathbf{1}_{I}=\\sum_{J}\\epsilon_{J}\\cdot\\mathbf{1}_{J}<span class="math">, we see that to obtain </span>\\mu_{\\mathbf{1}_{I}}<span class="math"> it will be sufficient to be able to relate </span>\\mu_{J},\\mu_{J^{\\prime}}<span class="math"> to </span>\\mu_{J\\pm J^{\\prime}}<span class="math">, for any two signed multisets </span>J,J^{\\prime}<span class="math">, and apply this procedure repeatedly on the </span>\\sum_{J}\\epsilon_{J}J$. And indeed, it can be verified that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mu_{J+J^{\\prime}}</span> $=r_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J+J^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0},\\infty;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}}\\cdot\\mu_{J}\\cdot\\mu_{J^{\\prime}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and both can be computed in <span class="math">O(1)</span> field operations, given the values of <span class="math">\\mu_{J}</span> and <span class="math">\\mu_{J^{\\prime}}</span>. Thus the additional work of deriving <span class="math">\\mu_{I}</span> from the <span class="math">\\{\\mu_{J}\\}</span> is also bounded by $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ operations per evaluation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-111" class="text-xl font-semibold mt-8">7.3 Step 3 - the last small adjustments</h3>

    <p class="text-gray-300">We are almost done by now. The function <span class="math">\\nu_{0}\\cdot\\mu_{I}</span> almost matches all properties of <span class="math">\\omega_{I}</span>. Its divisor is</p>

    <p class="text-gray-300"><span class="math">\\mathrm{div}(\\nu_{0}\\cdot\\mu_{I})</span> <span class="math">=\\mathrm{div}(\\nu_{0})+\\mathrm{div}(\\mu_{I})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$=[2G_{0}]-[g_{0}+2G_{0}]+[\\infty]-[\\mathbf{0}]+[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}]-[\\infty]+\\sum_{P\\in I}([P-g_{0}]-[P])$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the only possible remaining issue is the “<span class="math">-[\\mathbf{0}]</span>” which appears at the end, meaning <span class="math">\\nu_{0}\\cdot\\mu_{I}</span> does not have a zero at <span class="math">\\mathbf{0}</span> as it should (except in the special case <span class="math">I=C</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}=\\mathbf{0}<span class="math">). On the other hand, we have extra zeros, at the points of </span>I-g_{0}<span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}<span class="math">, which we may move to assist us in creating a zero at </span>\\mathbf{0}$. We show the following:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim. For any non-empty <span class="math">I\\subset C</span>, there exists an explicit function <span class="math">\\eta_{I}\\in k_{E_{0}}</span> such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathrm{div}(\\eta_{I})=[\\mathbf{0}]-[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}]-[Q]+[Q^{\\prime}],$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">Q,Q^{\\prime}\\in E_{0}</span> are points such that <span class="math">Q\\in I-g_{0}</span> and <span class="math">Q^{\\prime}\\notin I</span>. For any <span class="math">P\\notin\\overline{C}</span>, <span class="math">\\eta_{I}(P)</span> is computable in <span class="math">O(1)</span> field operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We first want to find a pair <span class="math">Q\\in I-g_{0},Q^{\\prime}\\notin I</span> with $Q^{\\prime}=Q+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}-\\mathbf{0}<span class="math">. This is equivalent to finding a point </span>P=Q+g_{0}\\in I<span class="math"> such that </span>P+(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1+2^{\\mathsf{k}-1})g_{0}=Q^{\\prime}\\notin I<span class="math">. If no such pair exists, then since </span>I<span class="math"> is non-empty, it must be a union of cosets of </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+2^{\\mathsf{k}-1}-1)G_{0}<span class="math">. These cosets are all even sized, so </span>I<span class="math"> must be even; but then it follows that these are cosets of </span>G_{0}<span class="math"> itself, which is a contradiction since </span>I<span class="math"> is fully contained inside a coset of </span>2G_{0}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Having found such a pair, we have $Q+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}=Q^{\\prime}+\\mathbf{0}<span class="math">, so we may simply define </span>\\eta_{I}=r_{Q^{\\prime},\\mathbf{0};Q,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g_{0}}<span class="math">, which is computable in </span>O(1)$, and we are done.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <p class="text-gray-300">Finally, when we take <span class="math">\\omega_{I}=\\nu_{0}\\cdot\\mu_{I}\\cdot\\eta_{I}</span>, we obtain</p>

    <p class="text-gray-300"><span class="math">\\mathrm{div}(\\omega_{I})=([2G_{0}]-[g_{0}+2G_{0}]-[I])+([I-g_{0}]-[Q])+[Q^{\\prime}]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which indeed satisfies all requirements, since the additional zeros at <span class="math">(I-g_{0})\\setminus\\{Q\\}\\cup\\{Q^{\\prime}\\}</span> are all outside <span class="math">I</span>. Furthermore, by checking the components we immediately see that <span class="math">\\omega_{I}(P)</span> is computable for all <span class="math">P\\in E_{0}\\setminus\\overline{C}</span> in $O(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\mathsf{k})$ operations, as claimed.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-112" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ames, S., Hazay, C., Ishai, Y., Venkitasubramaniam, M.: Ligero: Lightweight sublinear arguments without a trusted setup. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. pp. 2087–2104. CCS ’17 (2017)</li>

      <li>[2] Arora, S., Lund, C., Motwani, R., Sudan, M., Szegedy, M.: Proof verification and the hardness of approximation problems. Journal of the ACM 45(3), 501–555 (1998), preliminary version in FOCS ’92.</li>

      <li>[3] Arora, S., Safra, S.: Probabilistic checking of proofs: a new characterization of NP. Journal of the ACM 45(1), 70–122 (1998), preliminary version in FOCS ’92.</li>

      <li>[4] Babai, L., Fortnow, L., Levin, L.A., Szegedy, M.: Checking computations in poly-logarithmic time. In: Proceedings of the 23rd Annual ACM Symposium on Theory of Computing. pp. 21–32. STOC ’91 (1991)</li>

      <li>[5] Babai, L., Fortnow, L., Lund, C.: Non-deterministic exponential time has two-prover interactive protocols. Computational Complexity 1, 3–40 (1991), preliminary version appeared in FOCS ’90.</li>

      <li>[6] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Fast reed-solomon interactive oracle proofs of proximity. In: Chatzigiannakis, I., Kaklamanis, C., Marx, D., Sannella, D. (eds.) ICALP. LIPIcs, vol. 107, pp. 14:1–14:17. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2018), http://www.dagstuhl.de/dagpub/978-3-95977-076-7</li>

      <li>[7] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable zero knowledge with no trusted setup. In: Boldyreva, A., Micciancio, D. (eds.) CRYPTO. Lecture Notes in Computer Science, vol. 11694, pp. 701–732. Springer (2019)</li>

      <li>[8] Ben-Sasson, E., Carmon, D., Ishai, Y., Kopparty, S., Saraf, S.: Proximity gaps for reed-solomon codes. In: Irani, S. (ed.) 61st IEEE Annual Symposium on Foundations of Computer Science, FOCS 2020, Durham, NC, USA, November 16-19, 2020. pp. 900–909. IEEE (2020). https://doi.org/10.1109/FOCS46700.2020.00088</li>

      <li>[9] Ben-Sasson, E., Carmon, D., Kopparty, S., Levit, D.: Elliptic curve fast fourier transform (ECFFT) part I: fast polynomial algorithms over all finite fields. Electron. Colloquium Comput. Complex. p. 103 (2021), https://eccc.weizmann.ac.il/report/2021/103</li>

      <li>[10] Ben-Sasson, E., Chiesa, A., Forbes, M.A., Gabizon, A., Riabzev, M., Spooner, N.: Zero knowledge protocols from succinct constraint detection. In: Kalai, Y., Reyzin, L. (eds.) Theory of Cryptography - 15th International Conference, TCC 2017, Baltimore, MD, USA, November 12-15, 2017, Proceedings, Part II. Lecture Notes in Computer Science, vol. 10678, pp. 172–206. Springer (2017). https://doi.org/10.1007/978-3-319-70503-3_6</li>

      <li>[11] Ben-Sasson, E., Chiesa, A., Gabizon, A., Riabzev, M., Spooner, N.: Interactive oracle proofs with constant rate and query complexity. In: Chatzigiannakis, I., Indyk,</li>

    </ul>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">P., Kuhn, F., Muscholl, A. (eds.) 44th International Colloquium on Automata, Languages, and Programming, ICALP 2017, July 10-14, 2017, Warsaw, Poland. LIPIcs, vol. 80, pp. 40:1–40:15. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2017). https://doi.org/10.4230/LIPIcs.ICALP.2017.40</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[12] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E.: On the concrete efficiency of probabilistically-checkable proofs. In: Boneh, D., Roughgarden, T., Feigenbaum, J. (eds.) Symposium on Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013. pp. 585–594. ACM (2013). https://doi.org/10.1145/2488608.2488681</li>

      <li>[13] Ben-Sasson, E., Chiesa, A., Genkin, D., Tromer, E., Virza, M.: SNARKs for C: Verifying program executions succinctly and in zero knowledge. In: Proceedings of the 33rd Annual International Cryptology Conference. pp. 90–108. CRYPTO ’13 (2013)</li>

      <li>[14] Ben-Sasson, E., Chiesa, A., Goldberg, L., Gur, T., Riabzev, M., Spooner, N.: Linear-size constant-query IOPs for delegating computation. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’19 (2019)</li>

      <li>[15] Ben-Sasson, E., Chiesa, A., Spooner, N.: Interactive oracle proofs. In: Theory of Cryptography Conference. pp. 31–60. Springer (2016)</li>

      <li>[16] Ben-Sasson, E., Goldberg, L., Kopparty, S., Saraf, S.: DEEP-FRI: sampling outside the box improves soundness. In: Vidick, T. (ed.) 11th Innovations in Theoretical Computer Science Conference, ITCS 2020, January 12-14, 2020, Seattle, Washington, USA. LIPIcs, vol. 151, pp. 5:1–5:32. Schloss Dagstuhl - Leibniz-Zentrum für Informatik (2020). https://doi.org/10.4230/LIPIcs.ITCS.2020.5</li>

      <li>[17] Ben-Sasson, E., Goldreich, O., Harsha, P., Sudan, M., Vadhan, S.: Short PCPs verifiable in polylogarithmic time. In: Proceedings of the 20th Annual IEEE Conference on Computational Complexity. pp. 120–134. CCC ’05 (2005)</li>

      <li>[18] Ben-Sasson, E., Kaplan, Y., Kopparty, S., Meir, O., Stichtenoth, H.: Constant rate pcps for circuit-sat with sublinear query complexity. J. ACM 63(4), 32:1–32:57 (2016). https://doi.org/10.1145/2901294</li>

      <li>[19] Ben-Sasson, E., Kopparty, S., Saraf, S.: Worst-case to average case reductions for the distance to a code. In: Proceedings of the 33rd ACM Conference on Computer and Communications Security. pp. 24:1–24:23. CCS ’18 (2018)</li>

      <li>[20] Ben-Sasson, E., Sudan, M.: Short PCPs with polylog query complexity. SIAM J. Comput 38(2), 551–607 (2008)</li>

      <li>[21] Bootle, J., Cerulli, A., Ghadafi, E., Groth, J., Hajiabadi, M., Jakobsen, S.K.: Linear-time zero-knowledge proofs for arithmetic circuit satisfiability. In: Takagi, T., Peyrin, T. (eds.) Advances in Cryptology - ASIACRYPT 2017 - 23rd International Conference on the Theory and Applications of Cryptology and Information Security, Hong Kong, China, December 3-7, 2017, Proceedings, Part III. Lecture Notes in Computer Science, vol. 10626, pp. 336–365. Springer (2017). https://doi.org/10.1007/978-3-319-70700-6_12</li>

      <li>[22] Bootle, J., Chiesa, A., Groth, J.: Linear-time arguments with sublinear verification from tensor codes. In: Pass, R., Pietrzak, K. (eds.) Theory of Cryptography - 18th International Conference, TCC 2020, Durham, NC, USA, November 16-19, 2020, Proceedings, Part II. Lecture Notes in Computer Science, vol. 12551, pp. 19–46. Springer (2020). https://doi.org/10.1007/978-3-030-64378-2_2</li>

      <li>[23] Bowe, S., Grigg, J., Hopwood, D.: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021 (2019), https://ia.cr/2019/1021</li>

    </ul>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[24] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., Maxwell, G.: Bulletproofs: Short proofs for confidential transactions and more. In: Proceedings of the 39th IEEE Symposium on Security and Privacy. pp. 315–334. S&amp;P ’18 (2018)</li>

      <li>[25] Cantor, D.G., Zassenhaus, H.: A new algorithm for factoring polynomials over finite fields. Math. Comp. pp. 587–592 (1981). https://doi.org/10.1090/S0025-5718-1981-0606517-5</li>

      <li>[26] Chiesa, A., Hu, Y., Maller, M., Mishra, P., Vesely, N., Ward, N.: Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In: Proceedings of the 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques. pp. 738–768. EUROCRYPT ’20 (2020)</li>

      <li>[27] Chiesa, A., Ma, F., Spooner, N., Zhandry, M.: Post-quantum succinct arguments. Electron. Colloquium Comput. Complex. p. 38 (2021), https://eccc.weizmann.ac.il/report/2021/038</li>

      <li>[28] Chiesa, A., Manohar, P., Spooner, N.: Succinct arguments in the quantum random oracle model. In: Hofheinz, D., Rosen, A. (eds.) Theory of Cryptography - 17th International Conference, TCC 2019, Nuremberg, Germany, December 1-5, 2019, Proceedings, Part II. Lecture Notes in Computer Science, vol. 11892, pp. 1–29. Springer (2019). https://doi.org/10.1007/978-3-030-36033-7_1</li>

      <li>[29] Chiesa, A., Ojha, D., Spooner, N.: Fractal: Post-quantum and transparent recursive proofs from holography. In: Canteaut, A., Ishai, Y. (eds.) Advances in Cryptology - EUROCRYPT 2020 - 39th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Zagreb, Croatia, May 10-14, 2020, Proceedings, Part I. Lecture Notes in Computer Science, vol. 12105, pp. 769–793. Springer (2020). https://doi.org/10.1007/978-3-030-45721-1_27</li>

      <li>[30] Chiesa, A., Yogev, E.: Subquadratic snargs in the random oracle model. In: Malkin, T., Peikert, C. (eds.) Advances in Cryptology - CRYPTO 2021 - 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part I. Lecture Notes in Computer Science, vol. 12825, pp. 711–741. Springer (2021). https://doi.org/10.1007/978-3-030-84242-0_25</li>

      <li>[31] Chiesa, A., Yogev, E.: Tight security bounds for micali’s snargs. In: Nissim, K., Waters, B. (eds.) Theory of Cryptography - 19th International Conference, TCC 2021, Raleigh, NC, USA, November 8-11, 2021, Proceedings, Part I. Lecture Notes in Computer Science, vol. 13042, pp. 401–434. Springer (2021). https://doi.org/10.1007/978-3-030-90459-3_14</li>

      <li>[32] Chudnovsky, D.V., Chudnovsky, G.V.: Computational problems in arithmetic of linear differential equations. some diophantine applications. In: Chudnovsky, D.V., Chudnovsky, G.V., Cohn, H., Nathanson, M.B. (eds.) Number Theory. pp. 12–49. Springer Berlin Heidelberg, Berlin, Heidelberg (1989)</li>

      <li>[33] Deuring, M.: Die typen der multiplikatorenringe elliptischer funktionenkörper. Abhandlungen aus dem Mathematischen Seminar der Universität Hamburg 14(1), 197–272 (Dec 1941). https://doi.org/10.1007/BF02940746, https://doi.org/10.1007/BF02940746</li>

      <li>[34] Gabizon, A., Williamson, Z.J., Ciobotaru, O.: Plonk: Permutations over lagrangebases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953 (2019), https://ia.cr/2019/953</li>

      <li>[35] Gennaro, R., Gentry, C., Parno, B., Raykova, M.: Quadratic span programs and succinct NIZKs without PCPs. In: Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques. pp. 626–645. EUROCRYPT ’13 (2013)</li>

    </ul>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[36] Goldberg, L., Papini, S., Riabzev, M.: Cairo - a turing-complete stark-friendly CPU architecture. IACR Cryptol. ePrint Arch. p. 1063 (2021), https://eprint.iacr.org/2021/1063</li>

      <li>[37] Goldwasser, S., Kalai, Y.T., Rothblum, G.N.: Delegating computation: Interactive proofs for Muggles. In: Proceedings of the 40th Annual ACM Symposium on Theory of Computing. pp. 113–122. STOC ’08 (2008)</li>

      <li>[38] Golovnev, A., Lee, J., Setty, S., Thaler, J., Wahby, R.S.: Brakedown: Linear-time and post-quantum snarks for r1cs. Cryptology ePrint Archive, Report 2021/1043 (2021), https://ia.cr/2021/1043</li>

      <li>[39] Groth, J.: On the size of pairing-based non-interactive arguments. In: Fischlin, M., Coron, J. (eds.) Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II. Lecture Notes in Computer Science, vol. 9666, pp. 305–326. Springer (2016). https://doi.org/10.1007/978-3-662-49896-5_11</li>

      <li>[40] Guruswami, V.: Algorithmic results in list decoding. Foundations and Trends® in Theoretical Computer Science 2(2), 107–195 (2007). https://doi.org/10.1561/0400000007, http://dx.doi.org/10.1561/0400000007</li>

      <li>[41] Guruswami, V., Sudan, M.: Improved decoding of reed-solomon and algebraic-geometry codes. IEEE Trans. Information Theory 45(6), 1757–1767 (1999). https://doi.org/10.1109/18.782097, http://dx.doi.org/10.1109/18.782097</li>

      <li>[42] Ishai, Y., Kushilevitz, E., Ostrovsky, R., Sahai, A.: Zero-knowledge from secure multiparty computation. In: Proceedings of the Thirty-Ninth Annual ACM Symposium on Theory of Computing. p. 21–30. STOC ’07, Association for Computing Machinery, New York, NY, USA (2007). https://doi.org/10.1145/1250790.1250794</li>

      <li>[43] Kilian, J.: A note on efficient zero-knowledge proofs and arguments (extended abstract). In: Proceedings of the Twenty-Fourth Annual ACM Symposium on Theory of Computing. p. 723–732. STOC ’92, Association for Computing Machinery, New York, NY, USA (1992). https://doi.org/10.1145/129712.129782</li>

      <li>[44] Koblitz, N.: Elliptic curve cryptosystems. Mathematics of Computation 48, 203–209 (1987)</li>

      <li>[45] Lay, G.J., Zimmer, H.G.: Constructing elliptic curves with given group order over large finite fields. In: Adleman, L.M., Huang, M.D. (eds.) Algorithmic Number Theory. pp. 250–263. Springer Berlin Heidelberg, Berlin, Heidelberg (1994)</li>

      <li>[46] Lenstra, H.W.: Factoring integers with elliptic curves. Annals of Mathematics 126(3), 649–673 (1987), http://www.jstor.org/stable/1971363</li>

      <li>[47] Lund, C., Fortnow, L., Karloff, H.J., Nisan, N.: Algebraic methods for interactive proof systems. Journal of the ACM 39(4), 859–868 (1992)</li>

      <li>[48] Maller, M., Bowe, S., Kohlweiss, M., Meiklejohn, S.: Sonic: Zero-knowledge SNARKs from linear-size universal and updateable structured reference strings. Cryptology ePrint Archive, Report 2019/099 (2019)</li>

      <li>[49] Micali, S.: Computationally sound proofs. SIAM J. Comput. 30(4), 1253–1298 (oct 2000). https://doi.org/10.1137/S0097539795284959</li>

      <li>[50] Miret, J.M., Moreno Chiral, R., Rio, A., Valls, M.: Determining the 2-sylow subgroup of an elliptic curve over a finite field. Mathematics of Computation 74, 411–427 (01 2005). https://doi.org/10.1090/S0025-5718-04-01640-0</li>

      <li>[51] Parno, B., Gentry, C., Howell, J., Raykova, M.: Pinocchio: Nearly practical verifiable computation. In: Proceedings of the 34th IEEE Symposium on Security and Privacy. pp. 238–252. Oakland ’13 (2013)</li>

    </ul>

    <p class="text-gray-300">Ben-Sasson, Carmon, Kopparty &amp; Levit</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(52) Reingold, O., Rothblum, R., Rothblum, G.: Constant-round interactive proofs for delegating computation. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. pp. 49–62. STOC ’16 (2016)</li>

      <li>(53) Ron-Zewi, N., Rothblum, R.: Proving as fast as computing: Succinct arguments with constant prover overhead. Electron. Colloquium Comput. Complex. p. 180 (2021), https://eccc.weizmann.ac.il/report/2021/180</li>

      <li>(54) Schoof, R.: Nonsingular plane cubic curves over finite fields. Journal of Combinatorial Theory, Series A 46(2), 183–211 (1987). https://doi.org/https://doi.org/10.1016/0097-3165(87)90003-3, https://www.sciencedirect.com/science/article/pii/0097316587900033</li>

      <li>(55) Shamir, A.: IP = PSPACE. Journal of the ACM 39(4), 869–877 (1992)</li>

      <li>(56) Silverman, J.H.: The Arithmetic of Elliptic Curves. Graduate texts in mathematics, Springer, Dordrecht, 2nd edn. (2009). https://doi.org/10.1007/978-0-387-09494-6</li>

      <li>(57) StarkWare: ethstark documentation. Cryptology ePrint Archive, Report 2021/582 (2021), https://eprint.iacr.org/2021/582</li>

      <li>(58) Sutherland, A.: Isogeny volcanoes. The Open Book Series 1 (08 2012). https://doi.org/10.2140/obs.2013.1.507</li>

      <li>(59) Washington, L.C.: Elliptic Curves: Number Theory and Cryptography, Second Edition. Chapman &amp; Hall/CRC, 2 edn. (2008)</li>

      <li>(60) Waterhouse, W.C.: Abelian varieties over finite fields. Annales scientifiques de l’École Normale Supérieure Ser. 4, 2(4), 521–560 (1969). https://doi.org/10.24033/asens.1183, http://www.numdam.org/articles/10.24033/asens.1183/</li>

    </ul>

    <h2 id="sec-113" class="text-2xl font-bold">Appendix A Mathematical background</h2>

    <p class="text-gray-300">In this section we survey some standard notions and notations from the theory of algebraic geometry and elliptic curves in particular. We list definitions and statements without proof; further details can be found in <em>[56, 59]</em>.</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">A.1 Projective Space</h3>

    <p class="text-gray-300">We denote by <span class="math">\\mathbb{P}^{n}(\\mathbb{F}_{q})</span> (or simply <span class="math">\\mathbb{P}^{n}</span>) the <span class="math">n</span>-dimensional projective space over <span class="math">\\mathbb{F}_{q}</span>; only <span class="math">\\mathbb{P}^{1}</span> and <span class="math">\\mathbb{P}^{2}</span> will appear in the paper. Points in <span class="math">\\mathbb{P}^{n}</span> are given by homogenized coordinates <span class="math">[x_{1}:x_{2}:\\cdots:x_{n+1}]</span> where at least one <span class="math">x_{i}</span> is non-zero, and with the equivalence relation</p>

    <p class="text-gray-300"><span class="math">[x_{1}:x_{2}:\\cdots:x_{n+1}]\\sim[cx_{1}:cx_{2}:\\cdots:cx_{n+1}],\\quad\\forall c\\neq 0.</span></p>

    <p class="text-gray-300">Points in the affine space <span class="math">\\mathbb{F}_{q}^{n}</span> are given by affine coordinates <span class="math">(x_{1},\\ldots,x_{n})</span>, and in this paper we equate such points with their standard embedding into projective space, i.e.</p>

    <p class="text-gray-300"><span class="math">(x_{1},\\ldots,x_{n})=[x_{1}:\\cdots:x_{n}:1].</span></p>

    <p class="text-gray-300">Thus, <span class="math">\\mathbb{P}^{n}</span> is the disjoint union of <span class="math">\\mathbb{F}_{q}^{n}</span> and a copy of <span class="math">\\mathbb{P}^{n-1}</span> “at infinity”, i.e. with an additional <span class="math">x_{n+1}=0</span> coordinate. In particular, <span class="math">\\mathbb{P}^{1}(\\mathbb{F}_{q})=\\mathbb{F}_{q}\\cup\\{\\infty\\}</span>, where <span class="math">\\infty</span> denotes the unique point at infinity, <span class="math">[1:0]</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">We will refer to the two coordinates of the affine plane <span class="math">\\mathbb{F}_{q}^{2}</span> as <span class="math">x</span> and <span class="math">y</span>. For a point <span class="math">P\\in\\mathbb{F}_{q}^{2}</span>, we will denote its <span class="math">x,y</span> coordinates by <span class="math">P_{x},P_{y}</span>, respectively. For a point <span class="math">P\\in\\mathbb{P}^{2}</span>, the coordinates <span class="math">P_{x},P_{y}</span> will only be defined if it is an affine point, according to the above notation.</p>

    <h3 id="sec-115" class="text-xl font-semibold mt-8">A.2 Elliptic Curves</h3>

    <p class="text-gray-300">An elliptic curve <span class="math">E</span> over <span class="math">\\mathbb{F}_{q}</span> is the set of solutions to a cubic equation in the projective plane, with the additional condition of being smooth. Every elliptic curve can be presented in extended Weierstrass form, where the defining equation is</p>

    <p class="text-gray-300"><span class="math">E(X,Y):\\quad Y^{2}+a_{1}XY+a_{3}Y=X^{3}+a_{2}X^{2}+a_{4}X+a_{6}</span></p>

    <p class="text-gray-300">with <span class="math">a_{1},a_{2},a_{3},a_{4},a_{6}\\in\\mathbb{F}_{q}</span>. All curves mentioned in this paper are assumed to be represented in Weierstrass form, and this will be essential when discussing the projection of the curve to <span class="math">\\mathbb{P}^{1}</span>. Every such curve passes through a unique non-affine point, <span class="math">\\boldsymbol{\\infty}=[0:1:0]</span>. The points of an elliptic curve form an abelian group, where <span class="math">\\boldsymbol{\\infty}</span> is the neutral element and for any three points <span class="math">P,Q,R\\in E</span>, <span class="math">P+Q+R=\\boldsymbol{\\infty}</span> if and only if the three points are colinear (and if any two are equal, the line must be tangent to the curve at that point). The rank of the group is at most <span class="math">2</span>, meaning it is of the form <span class="math">\\mathbb{Z}/m_{1}\\mathbb{Z}\\times\\mathbb{Z}/m_{2}\\mathbb{Z}</span>, where <span class="math">m_{2}\\mid m_{1}</span>. The size of the group <span class="math">m_{1}\\cdot m_{2}</span> is in the Hasse–Weil bound <span class="math">[q+1\\pm 2\\sqrt{q}]</span>.</p>

    <h3 id="sec-116" class="text-xl font-semibold mt-8">A.3 Rational functions</h3>

    <p class="text-gray-300"><em>Rational functions</em> over <span class="math">\\mathbb{F}_{q}</span> are quotients <span class="math">R(X)=P(X)/Q(X)</span> where <span class="math">P,Q\\in\\mathbb{F}_{q}[X]</span> are coprime polynomials and <span class="math">Q</span> is non-zero. Rational functions form a field, denoted by <span class="math">\\mathbb{F}_{q}(X)</span>, as well as <span class="math">k_{\\mathbb{P}^{1}}</span>.</p>

    <p class="text-gray-300">Rational functions can be considered as maps from <span class="math">\\mathbb{P}^{1}</span> to itself, where zeros of <span class="math">Q</span> are mapped to <span class="math">\\infty</span> and are called <em>poles</em> of the rational function, with multiplicity equal to their multiplicity as zeros of <span class="math">Q</span>. Depending on whether <span class="math">\\deg(P)-\\deg(Q)</span> is positive, negative, or zero, the point <span class="math">\\infty</span> is either a pole of multiplicity <span class="math">\\deg(P)-\\deg(Q)</span>, a zero of multiplicity <span class="math">\\deg(Q)-\\deg(P)</span>, or mapped to the ratio between the leading coefficients of <span class="math">P</span> and <span class="math">Q</span>, correspondingly.</p>

    <p class="text-gray-300">The <em>degree</em> of <span class="math">R</span> is defined as <span class="math">\\deg(R)\\coloneqq\\max(\\deg(P),\\deg(Q))</span>, and is equal to both the total number of zeros and the total number of poles of <span class="math">R</span>, including at <span class="math">\\infty</span>, counted with multiplicity.</p>

    <p class="text-gray-300">Rational functions over <span class="math">\\mathbb{F}_{q}^{2}</span> are simply ratios of polynomial in <span class="math">\\mathbb{F}_{q}[X,Y]</span>. Given an elliptic curve <span class="math">E</span>, the rational functions on <span class="math">E</span> are simply restrictions of rational functions of <span class="math">\\mathbb{F}_{q}^{2}</span> to <span class="math">E</span>, and are thus defined only modulo the equation of <span class="math">E</span>. The field of rational functions on <span class="math">E</span> is denoted <span class="math">k_{E}</span>, and is equal to the function field <span class="math">\\mathbb{F}_{q}(X,Y)/(E(X,Y))</span>. A non-zero rational function over <span class="math">E</span> can also have zeros or poles at some points of <span class="math">E</span>, with multiplicities. The total number of zeros will always equal the total number of poles, and be called the <em>degree</em> of the rational function.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A.4 Rational functions between varieties</p>

    <p class="text-gray-300">A rational function between elliptic curves is a function <span class="math">\\varphi:E\\to E^{\\prime}</span> whose coordinates are given by rational functions. If a rational function also maps the neutral element of <span class="math">E</span> to the neutral element of <span class="math">E^{\\prime}</span>, then it is also a group homomorphism, and is called an <em>isogeny</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any rational function <span class="math">\\varphi:A\\to B</span> between varieties (in our cases: <span class="math">\\mathbb{P}^{1}\\to\\mathbb{P}^{1}</span>, <span class="math">E\\to\\mathbb{P}^{1}</span> or <span class="math">E\\to E^{\\prime}</span>), the <em>fibers</em> of <span class="math">\\varphi</span> are the preimages <span class="math">\\{\\varphi^{-1}(P):P\\in B\\}</span>. When considered over the algebraic closure <span class="math">\\overline{\\mathbb{F}}_{q}</span>, almost all fibers are of the same maximal size. This size is the <em>separable degree</em> of <span class="math">\\varphi</span>. In this paper we shall deal only with separable functions, where the separable degree is also the degree itself (and this definition coincides with the previous definitions for functions to <span class="math">\\mathbb{P}^{1}</span>). The points <span class="math">P\\in B</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi^{-1}(P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\deg(\\varphi)<span class="math"> are called <em>unramified</em>, and the points where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varphi^{-1}(P)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\deg(\\varphi)$ are ramification points; over the algebraic closure, all but finitely many points are unramified. For an isogeny of curves, because it is a group homomorphism, it is unramified everywhere, and its degree is equal to the size of the kernel.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The map <span class="math">\\varphi:A\\to B</span> induces a <em>pullback</em> map <span class="math">\\varphi^{<em>}:k_{B}\\to k_{A}:f\\mapsto f\\circ\\varphi</span>. The zeros and poles of <span class="math">\\varphi^{</em>}(f)=f\\circ\\varphi</span> are exactly at points <span class="math">P</span> such that <span class="math">\\varphi(P)</span> is a zero or pole of <span class="math">f</span>, i.e., at the fibers of <span class="math">\\varphi</span> over the zeros and poles of <span class="math">f</span>. For every <span class="math">P\\in A</span>, there is a <em>ramification index</em> <span class="math">e_{P}\\geq 1</span> which satisfies that <span class="math">f</span> has a zero/pole of multiplicity <span class="math">m</span> at <span class="math">\\varphi(P)</span> iff <span class="math">f\\circ\\varphi</span> has a zero/pole of multiplicity <span class="math">e_{P}\\cdot m</span> at <span class="math">P</span>, for every <span class="math">m</span>. In each fiber, the sum of all ramification indices of the points is equal to the degree. Thus a point is unramified iff all ramification indices of points above it are <span class="math">1</span>, and zeros and poles of <span class="math">f</span> translate to zeros and poles of <span class="math">f</span> of the same multiplicity over the fiber. A special case of interest is that if <span class="math">\\varphi</span> has degree <span class="math">2</span>, then every point is either unramified, or its fiber is a single point with ramification index <span class="math">2</span>.</p>

    <h3 id="sec-117" class="text-xl font-semibold mt-8">A.5 Divisors and Riemann–Roch spaces</h3>

    <p class="text-gray-300">For a variety <span class="math">A</span> (either <span class="math">\\mathbb{P}^{1}</span> or an elliptic curve for our purposes), its <em>divisor group</em> <span class="math">\\operatorname{Div}(A)</span> is a free abelian group generated by the symbols <span class="math">\\{[P]:P\\in A\\}</span>, whose elements are called divisors. A divisor <span class="math">D=\\sum_{P\\in A}n_{P}[P]</span> is said to be non-negative if <span class="math">n_{P}\\geq 0</span> for every <span class="math">P\\in A</span>. The degree of a divisor is <span class="math">\\deg(D)=\\sum n_{P}</span>. Divisors have a partial order given by <span class="math">D\\geq D^{\\prime}</span> iff <span class="math">D-D^{\\prime}</span> is non-negative. For sets <span class="math">S\\subset A</span>, we abuse the notation and write <span class="math">[S]</span> as shorthand for the divisor <span class="math">\\sum_{P\\in S}[P]</span>.</p>

    <p class="text-gray-300">Let <span class="math">k_{A}^{\\vee}=k_{A}\\setminus\\{0\\}</span> be the set of all non-zero rational functions on <span class="math">f</span>. For any <span class="math">f\\in k_{A}^{\\vee}</span>, the divisor of <span class="math">f</span> is <span class="math">\\operatorname{div}(f)=\\sum m_{P}[P]</span>, where the sum is taken over all zeros and poles of <span class="math">f</span>: for zeros <span class="math">m_{P}</span> equals their multiplicity, and for poles <span class="math">m_{P}</span> is minus the multiplicity. Thus <span class="math">\\deg(\\operatorname{div}(f))=0</span>, since the total multiplicities of zeros and poles are equal. Divisors of the form <span class="math">\\operatorname{div}(f)</span> are called <em>principal divisors</em>. For <span class="math">\\mathbb{P}^{1}</span>, every divisor of degree <span class="math">0</span> is a principal divisor. For elliptic curves, a divisor <span class="math">\\sum n_{P}[P]</span> of degree <span class="math">0</span> is principal iff <span class="math">\\sum n_{P}P=\\infty</span> according to the group structure.</p>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <p class="text-gray-300">For a given divisor <span class="math">D</span>, the Riemann–Roch space associated with <span class="math">D</span> is</p>

    <p class="text-gray-300"><span class="math">\\mathscr{L}(D)=\\{f\\in k_{A}^{\\times}:\\operatorname{div}(f)\\geq-D\\}\\cup\\{0\\},</span> (31)</p>

    <p class="text-gray-300">which is a linear space over <span class="math">\\mathbb{F}_{q}</span>. Its dimension is denoted by <span class="math">\\ell(D)=\\dim\\mathscr{L}(D)</span>. Note that since <span class="math">\\deg(\\operatorname{div}(f))=0</span>, it follows that <span class="math">\\ell(D)=0</span> whenever <span class="math">\\deg(D)&amp;lt;0</span>. The Riemann–Roch theorem is a useful tool for estimating <span class="math">\\ell(D)</span> when <span class="math">\\deg(D)\\geq 0</span>. We won’t describe it in general, but mention its applications for the projective line and elliptic curves:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In <span class="math">\\mathbb{P}^{1}</span>, for any divisor <span class="math">D</span> with <span class="math">\\deg(D)\\geq 0</span>, <span class="math">\\ell(D)=\\deg(D)+1</span>.</li>

      <li>In an elliptic curve, for any divisor <span class="math">D</span> with <span class="math">\\deg(D)\\geq 1</span>, <span class="math">\\ell(D)=\\deg(D)</span>. If <span class="math">\\deg(D)=0</span>, then <span class="math">\\ell(D)\\in\\{0,1\\}</span>, and the value depends on whether <span class="math">D</span> is a principal divisor or not.</li>

    </ul>

    <h3 id="sec-118" class="text-xl font-semibold mt-8">A.6 The Johnson Bound</h3>

    <p class="text-gray-300">We say that a code <span class="math">V\\subset\\mathbb{F}_{q}^{n}</span> is <span class="math">(\\gamma,\\ell)</span>-list decodable if for every <span class="math">u\\in\\mathbb{F}_{q}^{n}</span>, there are no more than <span class="math">\\ell</span> codewords of <span class="math">V</span> that are within relative Hamming distance at most <span class="math">\\gamma</span> from <span class="math">u</span>. Our first result is the Johnson bound for RS codes; see, e.g., <em>[40, Theorem 3.3]</em> for a proof of this particular version.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Theorem 20 (Johnson bound).</h6>

    <p class="text-gray-300">For every <span class="math">\\eta\\in(0,1-\\sqrt{\\rho})</span>, the code <span class="math">\\mathsf{RS}[\\mathbb{F}_{q},\\mathbf{T},\\rho]</span> is <span class="math">(1-\\sqrt{\\rho}-\\eta,1/(2\\eta\\sqrt{\\rho}))</span>-list-decodable.</p>

    <h2 id="sec-120" class="text-2xl font-bold">Appendix B FRI over all finite fields</h2>

    <p class="text-gray-300">We begin by recapping (verbatim from <em>[16]</em>) the FRI protocol, as well as its main technical ingredient, a certain algebraic hash function based on the classical FFT (which hence constrains the ambient finite field to be special). We will then introduce a new (but closely related) algebraic hash function based on the ECFFT, that can be defined over all finite fields. Finally, we sketch the proof that original FRI protocol with the new algebraic hash function has the desired soundness properties over all finite fields — here we simply state the key features of the algebraic hash function that were needed for the soundness analysis from <em>[8]</em> of the original FRI protocol to work, and observe that the new algebraic has function also has them.</p>

    <h3 id="sec-121" class="text-xl font-semibold mt-8">B.1 FRI</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our starting point is a function <span class="math">f_{0}:L_{0}\\to\\mathbb{F}</span> where <span class="math">\\mathbb{F}</span> is a finite field, the evaluation domain <span class="math">L_{0}\\subset\\mathbb{F}</span> is a coset of a group contained in <span class="math">\\mathbb{F}</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{k_{0}}<span class="math">. We assume the target rate is </span>\\rho=2^{-\\mathcal{R}}<span class="math"> for some positive integer </span>\\mathcal{R}$. The</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">15 The group can be additive, in which case \\mathbb{F} is a binary field, or multiplicative, in which case it is not.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{FRI}</span> protocol is a two-phase protocol (the two phases are called COMMIT and QUERY) that convinces a verifier that <span class="math">f_{0}</span> is close to the Reed–Solomon code <span class="math">\\mathsf{RS}[\\mathbb{F},L_{0},\\rho]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The COMMIT phase of the <span class="math">\\mathsf{FRI}</span> protocol involves <span class="math">\\mathsf{k}=k_{0}-\\mathcal{R}</span> rounds. Before any communication, the prover and verifier agree on a sequence of (cosets of) sub-groups <span class="math">L_{i}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2^{k_{0}-i}<span class="math">. Let </span>\\mathsf{RS}_{i}<span class="math"> denote the Reed–Solomon code </span>\\mathsf{RS}[\\mathbb{F},L_{i},d_{i}]<span class="math">, where </span>d_{i}=\\rho\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The main ingredient of the <span class="math">\\mathsf{FRI}</span> protocol is a special algebraic hash function <span class="math">H_{z}</span>, which takes a seed <span class="math">z\\in\\mathbb{F}</span>, and given as input a function <span class="math">f:L_{i}\\to\\mathbb{F}</span>, it produces as output a hash whose length is <span class="math">1/2</span> as long as <span class="math">f</span>. More concretely, <span class="math">H_{z}[f]</span> is a function</p>

    <p class="text-gray-300"><span class="math">H_{z}[f]:L_{i+1}\\to\\mathbb{F}</span></p>

    <p class="text-gray-300">with the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>locality: For any <span class="math">s\\in L_{i+1}</span>, <span class="math">H_{z}<a href="s">f</a></span> can be computed by querying <span class="math">f</span> at just two points in its domain (these two points are <span class="math">(q_{i})^{-1}(s)</span>).</li>

      <li>completeness: If <span class="math">f\\in\\mathsf{RS}_{i}</span>, then for all <span class="math">z\\in\\mathbb{F}</span>, we have that <span class="math">H_{z}[f]\\in\\mathsf{RS}_{i+1}</span>.</li>

      <li>soundness: If <span class="math">f</span> is far from <span class="math">\\mathsf{RS}_{i}</span>, then with high probability over the choice of seed <span class="math">z</span>, <span class="math">H_{z}[f]</span> is quite far from <span class="math">\\mathsf{RS}_{i+1}</span>.</li>

    </ol>

    <p class="text-gray-300">These last two properties roughly show that for random <span class="math">z</span>, <span class="math">H_{z}</span> preserves distance to Reed–Solomon codes. The original <span class="math">H_{z}</span> from the <span class="math">\\mathsf{FRI}</span> protocol was based on the classical FFT decomposition <em>[19]</em>. In the next subsection, we propose a different <span class="math">H_{z}</span>, based on ECFFT and Equation (13) in particular, that allows <span class="math">\\mathsf{FRI}</span> to be generalized to all fields.</p>

    <p class="text-gray-300">The high-level idea of the <span class="math">\\mathsf{FRI}</span> protocol can then be described as follows. First we are in the COMMIT phase of the protocol. The verifier picks a random <span class="math">z_{0}\\in\\mathbb{F}</span> and asks the prover to write down the hash <span class="math">H_{z_{0}}[f_{0}]:L^{(1)}\\to\\mathbb{F}</span>. By Properties 2 and 3 above, our original problem of estimating the distance of <span class="math">f_{0}</span> to <span class="math">\\mathsf{RS}_{0}</span> reduces to estimating the distance of <span class="math">H_{z_{0}}[f_{0}]</span> to <span class="math">\\mathsf{RS}^{(1)}</span> (which is a problem of <span class="math">1/2</span> the size). This process is then repeated: the verifier picks a random <span class="math">z^{(1)}\\in\\mathbb{F}</span> and asks the prover to write down <span class="math">H_{z^{(1)}}[H_{z_{0}}[f_{0}]]</span>, and so on. After <span class="math">\\mathsf{k}</span> rounds of this, we are reduced to a constant sized problem which can be solved in a trivial manner. However, the verifier cannot blindly trust that the functions <span class="math">f^{(1)},\\ldots</span> that were written down by the prover truly are obtained by repeatedly hashing <span class="math">f_{0}</span>. This has to be checked, and the verifier does this in the QUERY phase of the protocol, using Property 1 above.</p>

    <p class="text-gray-300">We describe the phases of the protocol below.</p>

    <p class="text-gray-300">COMMIT Phase:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=0</span> to <span class="math">\\mathsf{k}-1</span>:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier picks uniformly random <span class="math">z_{i}\\in\\mathbb{F}</span> and sends it to the prover.</li>

      <li>The prover writes down a function <span class="math">f_{i+1}:L_{i+1}\\to\\mathbb{F}</span>. (In the case of an honest prover, <span class="math">f_{i+1}=H_{z_{i}}[f_{i}]</span>.)</li>

      <li>The prover writes down a value <span class="math">C\\in\\mathbb{F}_{q}</span>. (In the case of an honest prover, <span class="math">f^{(\\mathsf{k})}</span> is the constant function with value <span class="math">=C</span>).</li>

    </ol>

    <p class="text-gray-300">Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Repeat <span class="math">\\ell</span> times:</li>

    </ol>

    <p class="text-gray-300">(a) Pick <span class="math">s_0 \\in L_0</span> uniformly at random.</p>

    <p class="text-gray-300">(b) For <span class="math">i = 0</span> to <span class="math">k - 1</span>:</p>

    <p class="text-gray-300">i. Define <span class="math">s_{i+1} \\in L_{i+1}</span> by <span class="math">s_{i+1} = q_i(s_i)</span>.</p>

    <p class="text-gray-300">ii. Compute <span class="math">H_{z_i}<a href="s_{i+1}">f_i</a></span> by making 2 queries to <span class="math">f_i</span>.</p>

    <p class="text-gray-300">iii. If <span class="math">f_{i+1}(s_{i+1}) \\neq H_{z_i}<a href="s_{i+1}">f_i</a></span>, then REJECT.</p>

    <p class="text-gray-300">(c) If <span class="math">f^{(k)}(s^{(k)}) \\neq C</span>, then REJECT.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ACCEPT</li>

    </ol>

    <h2 id="sec-123" class="text-2xl font-bold">B.2 The new algebraic hash function</h2>

    <p class="text-gray-300">We now describe our new algebraic hash function <span class="math">H_{z}</span>.</p>

    <p class="text-gray-300">The description of the hash function requires us to first fix a certain chain of isogenies of elliptic curves, as we do to define the ECFFT. For each <span class="math">i \\in [0, k]</span> we let <span class="math">L_i \\subseteq \\mathbb{F}_q</span> be the set <span class="math">T_i</span> of size <span class="math">2^{k - i}</span> from that theorem, and let <span class="math">\\psi_i \\in \\mathbb{F}_q(X)</span> be the degree 2 rational function that maps <span class="math">L_i</span> in a 2-to-1 manner to <span class="math">L_{i + 1}</span>. Let <span class="math">\\psi_i = u_i(X) / v_i(X)</span>, where <span class="math">u_{i}(X),v_{i}(X) \\in \\mathbb{F}_{q}[X]</span> polynomials with <span class="math">\\deg (u_i),\\deg (v_i) \\leq 2</span>.</p>

    <p class="text-gray-300">Given <span class="math">z \\in \\mathbb{F}</span>, <span class="math">f: L_i \\to \\mathbb{F}</span>, the hash of <span class="math">f</span> with seed <span class="math">z</span> is defined to be the function <span class="math">H_z[f]: L_{i+1} \\to \\mathbb{F}</span> as follows. For <span class="math">s \\in L_{i+1}</span>, let <span class="math">s_0, s_1 \\in L_i</span> be the two roots of <span class="math">\\psi_i(X) - s</span>. Let <span class="math">P_{f,s}(Z) \\in \\mathbb{F}[Z]</span> be the unique degree <span class="math">\\leq 1</span> polynomial satisfying</p>

    <div class="my-4 text-center"><span class="math-block">P _ {f, s} \\left(s _ {0}\\right) = \\frac {f \\left(s _ {0}\\right)}{\\left(v _ {i} \\left(s _ {0}\\right)\\right) ^ {\\left(d _ {i} / 2\\right) - 1}}, \\tag {32}</span></div>

    <div class="my-4 text-center"><span class="math-block">P _ {f, s} \\left(s _ {1}\\right) = \\frac {f \\left(s _ {1}\\right)}{\\left(v _ {i} \\left(s _ {1}\\right)\\right) ^ {\\left(d _ {i} / 2\\right) - 1}}. \\tag {33}</span></div>

    <p class="text-gray-300">Then we define</p>

    <div class="my-4 text-center"><span class="math-block">H _ {z} [ f ] (s) = P _ {f, s} (z). \\tag {34}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that <span class="math">H_{z}<a href="s">f</a></span> can be computed by querying <span class="math">f</span> on the set <span class="math">\\{s_0, s_1\\}</span>, and we denote this set by <span class="math">S_i(s)</span>. Note also that the definition of <span class="math">H_{z}[f]</span> for <span class="math">f \\in L_i</span> explicitly depends on the degree $d_i = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> — this is a difference from the definition of </span>H_{z}<span class="math"> in the original FRI protocol, where the definition of </span>H_{z}[f]<span class="math"> did not depend on the </span>\\rho$ at all.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To understand <span class="math">H_{z}</span> better, it is instructive to see what it does to <span class="math">\\mathsf{RS}_i</span>. Let <span class="math">f \\in \\mathsf{RS}_i</span>. The underlying polynomial <span class="math">f(X)</span> thus has degree less than $d = \\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We may write </span>f(X)$ as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">f (X) = \\left(f _ {0} \\left(\\psi_ {i} (X)\\right) + X \\cdot f _ {1} \\left(\\psi_ {i} (X)\\right)\\right) \\cdot v (X) ^ {(d / 2) - 1}, \\tag {35}</span></div>

    <p class="text-gray-300">where each <span class="math">f_{i}(Y)</span> has degree less than <span class="math">d / 2</span>.</p>

    <p class="text-gray-300">Now take any <span class="math">s\\in L_{i+1}</span>, and let <span class="math">S_{i}(s)=\\{s_{0},s_{1}\\}</span>. Substituting <span class="math">X=s_{i}</span> into the above equation and using the fact that <span class="math">\\psi_{i}(s_{i})=s</span>, we get:</p>

    <p class="text-gray-300"><span class="math">\\frac{f(s_{i})}{v(s_{i})^{(d/2)-1}}=f_{0}(s)+s_{i}\\cdot f_{1}(s).</span></p>

    <p class="text-gray-300">Comparing with Equations (32) and (33), we get that:</p>

    <p class="text-gray-300"><span class="math">P_{f,s}(Z)=f_{0}(s)+Z\\cdot f_{1}(s),</span></p>

    <p class="text-gray-300">and thus for all <span class="math">s\\in L_{i+1}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">H_{z}<a href="s">f</a>=f_{0}(s)+zf_{1}(s).</span></p>

    <p class="text-gray-300">Thus <span class="math">H_{z}[f]</span> equals <span class="math">\\langle f_{0}+zf_{1}\\wr L_{i+1}\\rangle</span>, and is thus an element of <span class="math">\\mathsf{RS}_{i+1}</span>.</p>

    <h3 id="sec-124" class="text-xl font-semibold mt-8">B.3 Analysis of the new FRI protocol</h3>

    <p class="text-gray-300">The proof of soundness of the new FRI protocol is almost identical to the proof of soundness of the original FRI protocol from <em>[8]</em>. Indeed, the only properties of the algebraic hash function <span class="math">H_{z}</span> that are used in that proof are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every <span class="math">f:L_{i}\\to\\mathbb{F}_{q}</span>, there are two functions <span class="math">g,h:L_{i+1}\\to\\mathbb{F}_{q}</span> such that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">H_{z}[f]=g+z\\cdot h</span>,</li>

      <li>Let <span class="math">\\mu:L_{i}\\to[0,1]</span> be a weight function. Let <span class="math">\\mu^{\\prime}:L_{i+1}\\to[0,1]</span> be defined by:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mu^{\\prime}(s)=\\mathbf{E}_{t\\in S_{i}(s)}\\mu(t).</span></p>

    <p class="text-gray-300">Then the <span class="math">\\mu</span>-weighted agreement of <span class="math">f</span> with <span class="math">\\mathsf{RS}_{i}</span> is completely determined by <span class="math">g</span> and <span class="math">h</span> by the following formula:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{agree}_{\\eta}(f,\\mathsf{RS}_{i})=\\mathsf{agree}_{\\eta^{\\prime}}(g\\oplus h,\\mathsf{RS}_{i+1}\\oplus\\mathsf{RS}_{i+1}),</span></p>

    <p class="text-gray-300">where for two vectors <span class="math">u,v\\in\\mathbb{F}_{q}^{n}</span>, we let <span class="math">u\\oplus v\\in(\\mathbb{F}_{q}^{2})^{n}</span> be the vector whose <span class="math">i</span>th coordinate equals <span class="math">(u_{i},v_{i})\\in(\\mathbb{F}_{q}^{2})</span>.</p>

    <h3 id="sec-125" class="text-xl font-semibold mt-8">B.4 Batched FRI</h3>

    <p class="text-gray-300">In this section, we prove Theorem 13 on Batched FRI. To simultaneously check that a collection of functions <span class="math">g_{1},\\ldots,g_{k}:T\\to\\mathbb{F}_{q}</span> are all low-degree (<span class="math">\\deg(g_{i})&lt;d_{i}</span>), they key is to take a random linear combination of the <span class="math">g_{i}</span> with appropriate polynomial coefficients (in order to adjust their claimed degrees to all be the same) and run the FRI protocol on this. The reason this works is the proximity gaps phenomenon for Reed–Solomon codes <em>[8]</em>.</p>

    <p class="text-gray-300">Formally, the Batched FRI protocol is given below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For each <span class="math">i\\in[k]</span>, define $c_{i}=\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1-d_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i\\in[k]</span>, pick random <span class="math">(r_{i},r_{i}^{\\prime})\\in\\mathbb{F}_{q}^{2}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consider the function <span class="math">f:T\\to\\mathbb{F}_{q}</span> given by:</li>

    </ol>

    <p class="text-gray-300"><span class="math">f(x)=\\sum_{i=1}^{k}(r_{i}+r^{\\prime}_{i}x^{c_{i}})g_{i}(x).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. Run FRI on <span class="math">f</span> with degree parameter $\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and repetition parameter </span>t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The analysis is identical to the analysis of Batched FRI in <em>[8]</em>, which we sketch below. If <span class="math">f</span> passes the FRI step with good probability, then <span class="math">f</span> itself must be close to degree $<\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The key point is that </span>f<span class="math"> is a random linear combination of the functions </span>g_{i}<span class="math"> and the functions </span>g^{\\prime}_{i}<span class="math">, where </span>g^{\\prime}_{i}(x)=x^{c_{i}}g_{i}(x)<span class="math">. By the basic Proximity Gaps result of <em>[8]</em>, if </span>f<span class="math"> ends up being close to degree </span><\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> with good probability, then all the functions </span>g_{i}<span class="math"> and </span>g^{\\prime}_{i}<span class="math"> must themselves agree with degree polynomials </span>G_{i}<span class="math"> and </span>G^{\\prime}_{i}<span class="math"> on a large common agreement set. By the definition of </span>g^{\\prime}_{i}<span class="math">, this means that </span>G_{i}(X)<span class="math"> and </span>X^{c_{i}}G_{i}(X)<span class="math"> are both polynomials of degree </span><\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and this means that for each </span>i<span class="math">, </span>G_{i}(X)<span class="math"> (which we know is close to </span>g_{i}<span class="math">) is in fact a polynomial of degree </span><\\rho</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-c_{i}$, as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Scalable and Transparent Proofs over All Large Fields, via E... (2022/1542)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1542
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
