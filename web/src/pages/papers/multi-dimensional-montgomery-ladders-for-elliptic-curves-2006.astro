---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2006/220';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Multi-Dimensional Montgomery Ladders for Elliptic Curves';
const AUTHORS_HTML = 'Daniel R.  L.  Brown';

const CONTENT = `    <p class="text-gray-300">Daniel R. L. Brown</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Montgomery’s ladder algorithm for elliptic curve scalar multiplication uses only the x-coordinates of points. Avoiding calculation of the y-coordinates saves time for certain curves. Montgomery introduced his method to accelerate Lenstra’s elliptic curve method for integer factoring. Bernstein extended Montgomery’s ladder algorithm by computing integer combinations of two points, thus accelerating signature verification over certain curves. This paper modifies and extends Bernstein’s algorithm to integer combinations of two or more points.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Montgomery observed that, for some elliptic curves, the x-coordinate of the point <span class="math">P+Q</span>, where <span class="math">+</span> is elliptic curve addition, could be calculated from the x-coordinate of the three points <span class="math">P</span>, <span class="math">Q</span> and <span class="math">Q-P</span>.</p>

    <p class="text-gray-300">Using this observation, Montgomery proposed that <span class="math">kG</span> could be computed in such by computing a sequence of pairs of x-coorindates of two points <span class="math">P=sG</span> and <span class="math">Q=(s+1)G</span>, for appropriately selected values of <span class="math">s</span>. This sequence has property that <span class="math">Q-R=G</span>, so the difference of the points in known, and therefore <span class="math">P+Q=(2s+1)G</span> can be computed with using a y-coordinate. The other element of the next pair is either <span class="math">2sG=2P</span> or <span class="math">2(s+1)G=2Q</span>, either of whose x-coordinate can be computed without y-coordinates.</p>

    <p class="text-gray-300">For certain special kinds of elliptic curve, computing only with x-coordinates is faster than other efficient implementation methods. For prime NIST curves, this does not seem to be the case. Montgomery has defined a class of prime field curves for which not using the y-coordinate provides some savings. For non-Koblitz binary fields, there are y-free formulae that are comparable in cost with at least some other efficient implementations.</p>

    <p class="text-gray-300">Suppose that one wants to compute <span class="math">k_{1}G_{1}+\\cdots+k_{d}G_{d}</span>, using x-coordinates only, or at least mostly. Bernstein gives an algorithm for doing this when <span class="math">d=2</span>. At each step, a triple of x-coordinates is computed. The three points whose x-coordinates are computed at each stage have differences of the form <span class="math">l_{1}G_{1}+l_{2}G_{2}</span> where <span class="math">l_{1},l_{2}\\in\\{-1,0,1\\}</span>. Therefore Montgomery’s formula can be used, once the x-coordinates of <span class="math">G_{1}+G_{2}</span> and <span class="math">G_{1}-G_{2}</span> are found using convential addition with y-coordinates. This paper modifies and extends Bernstein’s algorith to <span class="math">d\\geqslant 2</span>.</p>

    <p class="text-gray-300">Potential applications of <span class="math">d&gt;2</span> include: batch ECC operations, accelerating Lenstra’s ECM factoring algorithm, exploiting expanded ECC certificates (which contain pre-computed multiples of a party’s public key), to incremental hashing based on elliptic curves, to accelerate verification of ECDSA signatures. Careful analysis is needed in each case to ascertain whether the algorithm presented outperforms existing efficient alternatives.</p>

    <p class="text-gray-300">2 The Algorithm</p>

    <p class="text-gray-300">Suppose that we wish to compute <span class="math">a_{1}P_{1}+\\cdots+a_{d}P_{d}</span> using a Montgomery ladder, where the <span class="math">a_{i}</span> are <span class="math">m</span> bit positive integers. We do the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Execute the precomputation phase:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Precompute and store, or otherwise make available, all the <span class="math">(3^{d}-1)/2</span> x-coordinates of points <span class="math">c_{1}P_{1}+\\cdots+c_{d}P_{d}</span> where <span class="math">c_{i}\\in\\{-1,0,1\\}</span>, and the <span class="math">c_{i}</span> are not all zero.</li>

      <li>Execute the matrix phase, as follows.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Allocate <span class="math">(m+1)\\times d</span> bit matrix <span class="math">A=(A_{nk})</span> and two <span class="math">(d+1)\\times d</span> bit matrices <span class="math">B=(B_{jk})</span> and <span class="math">C_{jk}</span>. Rows of <span class="math">A</span> and <span class="math">B</span> are indicated as <span class="math">A_{j}</span> and <span class="math">B_{j}</span>, respectively.</li>

      <li>Allocate <span class="math">(d+1)\\times(m+1)</span> integer matrices <span class="math">F=(F_{j,n})</span> and <span class="math">G=(G_{j,n})</span>, with entry values ranging from <span class="math">0</span> to <span class="math">d+1</span>.</li>

      <li>Allocate an <span class="math">(m+1)</span>-wide array of <span class="math">\\{-1,0,1\\}</span>-valued <span class="math">(d+1)\\times d</span> matrices <span class="math">D^{j}</span>.</li>

      <li>Initialize <span class="math">A</span> such that <span class="math">a_{k}=A_{0,k}+2A_{1,k}+2^{2}A_{2,k}+\\ldots</span>.</li>

      <li>Initialize <span class="math">B</span> as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">h</span> be the number odd entries in row <span class="math">A_{0}</span> (that is, the number of odd <span class="math">a_{k}</span>).</li>

      <li>Let <span class="math">B_{h}=A_{0}</span>.</li>

      <li>For each <span class="math">j&lt;h</span>, let <span class="math">B_{j}</span> be obtained from <span class="math">B_{j+1}</span> by subtracting one from a <span class="math">1</span> valued entry (the choice of entry is arbitrary).</li>

      <li>For each <span class="math">j&gt;h</span>, let <span class="math">B_{j}</span> be obtained from <span class="math">B_{j-1}</span> by adding one to a <span class="math">0</span> valued entry (the choice of entry is arbitrary).</li>

      <li>Let <span class="math">n=0</span>.</li>

      <li>Let <span class="math">D^{n}=B</span>.</li>

      <li>Set <span class="math">D^{n}=D^{n}\\circ(-1)^{A_{1}}</span>, meaning to negate the columns of <span class="math">D</span> in corresponding to positions <span class="math">A_{1}</span> with value <span class="math">1</span>.</li>

      <li>Set the value matrix <span class="math">C</span> and entries of <span class="math">F</span> and <span class="math">G</span> as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">j\\leftarrow 0</span>.</li>

      <li>Set <span class="math">R\\leftarrow A_{0}+A_{1}\\bmod 2</span>.</li>

      <li>Let <span class="math">h</span> be the Hamming weight of <span class="math">R</span>.</li>

      <li>Let <span class="math">C_{h}=R</span>.</li>

      <li>Let <span class="math">F_{0,n}=G_{0,n}=h</span>.</li>

      <li>Set <span class="math">R\\leftarrow B_{j+1}+C_{F_{j,n}}</span>.</li>

      <li>Let <span class="math">h</span> be the Hamming weight of <span class="math">R</span>.</li>

      <li>If <span class="math">h&lt;F_{j,n}</span> then</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">F_{j+1,n}=h</span>,</li>

      <li>Set <span class="math">G_{j+1,n}=G_{j,n}</span>,</li>

    </ol>

    <p class="text-gray-300">Else</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">R\\leftarrow B_{j+1}+C_{G_{j,n}}</span>,</li>

      <li>Let <span class="math">h</span> be the Hammning weight of <span class="math">R</span></li>

    </ol>

    <p class="text-gray-300">. Set <span class="math">F_{j+1,n}=F_{j,n}</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set <span class="math">G_{j+1,n}=h</span>,</li>

      <li>Set <span class="math">C_{h}=R</span>.</li>

      <li>If <span class="math">j&lt;d-1</span>, then set <span class="math">j\\leftarrow j+1</span> and go back to Step 2(i)vi.</li>

      <li>Set <span class="math">B\\leftarrow C</span>.</li>

      <li>Drop row <span class="math">A_{0}</span> from <span class="math">A</span>, so that <span class="math">A_{j}\\leftarrow A_{j+1}</span>.</li>

      <li>Unless <span class="math">n=m</span>, set <span class="math">n\\leftarrow n+1</span>, and go back to Step 2g.</li>

      <li>Execute the point addition phase:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Initialize points <span class="math">Q_{0},\\ldots,Q_{d}</span>, as follows:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">Q_{j}\\leftarrow B_{j,1}P_{1}+\\cdots+B_{j,d}P_{d}</span>. These points are among the precomputed points. Note that <span class="math">Q_{0}=\\infty</span> and <span class="math">Q_{d}=P_{1}+\\cdots+P_{d}</span>.</li>

      <li>Compute points <span class="math">R_{0},\\ldots,R_{d}</span> as follows :</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R_{j}\\leftarrow Q_{F_{j,n}}+Q_{G_{j,n}}</span>.</li>

      <li>When making above the computation, the difference of <span class="math">Q_{F_{j,n}}-Q_{G_{j,n}}</span> is given by row <span class="math">j</span> of matrix <span class="math">D^{n}</span>, which means one look up the difference among the pre-computed points. Thus the y-coordinate is not needed to compute <span class="math">R_{j}</span> from the <span class="math">Q</span> points.</li>

      <li>Set <span class="math">Q_{j}\\leftarrow R_{j}</span> for each <span class="math">j</span>.</li>

      <li>If <span class="math">n&gt;0</span>, then set <span class="math">n\\leftarrow n-1</span> and go back to Step 3b.</li>

      <li>Let <span class="math">h</span> be the number of <span class="math">a_{k}</span> that are odd.</li>

      <li>Output <span class="math">Q_{h}</span>.</li>

    </ol>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Example</h3>

    <p class="text-gray-300">Suppose that one wants to compute <span class="math">10P_{1}+14P_{2}+9P_{3}+11P_{4}</span> using the algorithm above.</p>

    <p class="text-gray-300">The binary representations of the multiples <span class="math">10,14,9,11</span> are <span class="math">1010_{2},1110_{2},1001_{2},1011_{2}</span>, respectively. Therefore, we initiliaze a matrix <span class="math">A</span> as</p>

    <p class="text-gray-300">\\[ A=\\begin{pmatrix}0&0&1&1\\\\ 1&1&0&0\\\\ 0&1&0&0\\\\ 1&1&1&1\\\\ 0&0&0&0\\end{pmatrix} \\] (1)</p>

    <p class="text-gray-300">where each column represnts a multipes with least significant bit at the top. A bottom row of all zeroes is appended for bookkeeping purposes. During the execution of the algorithm, the top row of <span class="math">A</span> will be popped off. Equivalently, one can just move a pointer down a row, with the pointer starting at the top row.</p>

    <p class="text-gray-300">The three ways that <span class="math">A</span> is used in the algorithm are (a) to initialize the matrix <span class="math">B</span>, which is done using the top row only, (b) to update matrix <span class="math">B</span>, which is done using the modulo two sum of the first and second rows, and (c) to add determines the signs of the <span class="math">D</span> matrices, which is done using the second row.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">To initiliaze matrix <span class="math">B</span>, first we take the top row of <span class="math">A</span>, which has weight two. Therefore <span class="math">B_{2} = A_{0}</span> (indexing the top row with 0). Rows <span class="math">B_{1}</span> and <span class="math">B_{0}</span> are obtained by replacing 1's with 0's and rows <span class="math">B_{3}</span> and <span class="math">B_{4}</span>, by replacing 0's with 1's:</p>

    <div class="my-4 text-center"><span class="math-block">B = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\tag{2}</span></div>

    <p class="text-gray-300">We have thus used <span class="math">A</span> to initialized <span class="math">B</span>. The second use (b) of <span class="math">A</span> uses the sum of consecutive rows, that is <span class="math">A_0 + A_1</span>, <span class="math">A_1 + A_2</span>, <span class="math">A_2 + A_3</span> and <span class="math">A_3 + A_4</span>, which we compute below:</p>

    <div class="my-4 text-center"><span class="math-block">A _ {0} + A _ {1} = \\left( \\begin{array}{cccc} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\end{array} \\right) \\tag{3}</span></div>

    <div class="my-4 text-center"><span class="math-block">A _ {1} + A _ {2} = \\left( \\begin{array}{cccc} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\tag{4}</span></div>

    <div class="my-4 text-center"><span class="math-block">A _ {2} + A _ {3} = \\left( \\begin{array}{cccc} 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\tag{5}</span></div>

    <div class="my-4 text-center"><span class="math-block">A _ {3} + A _ {4} = \\left( \\begin{array}{cccc} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\tag{6}</span></div>

    <p class="text-gray-300">These sums of rows are used to update <span class="math">B</span> and in turn determine the integer entries in the arrays <span class="math">F</span> and <span class="math">G</span>.</p>

    <p class="text-gray-300">We now update <span class="math">B</span>, putting the results temporarily in another matrix <span class="math">C</span>. By definition <span class="math">A_0 + A_1</span> must be row of <span class="math">C</span>, and since it has weight 3, it will be row <span class="math">C_3</span>. Also we get <span class="math">F_{0,0} = G_{0,0} = 3</span>.</p>

    <p class="text-gray-300">Now consider <span class="math">C_3 + B_1 = (1 \\ 1 \\ 1)</span> , which has weight 4, so must be row <span class="math">C_4</span> , and we get <span class="math">F_{0,1} = 3</span> and <span class="math">G_{0,1} = 4</span> . Although not specified in the actual algorithm, we actually know that the entries of <span class="math">G</span> cannot decrease and as 4 is the maximum, we will have <span class="math">G_{0,j} = 4</span> for <span class="math">j \\geqslant 2</span> . When <span class="math">G</span> does not increase, then <span class="math">F</span> decreases by one, so we get <span class="math">F_{0,2} = 2</span> , <span class="math">F_{0,3} = 1</span> and <span class="math">F_{0,4} = 0</span> . Also, we know that the value of <span class="math">F</span> or <span class="math">G</span> that differs from the previous iteration gives the index of the newly determined row of <span class="math">C</span> , so rows <span class="math">C_2 = B_2 + C_4</span> , and <span class="math">C_1 = B_3 + C_4</span> and <span class="math">C_0 = B_4 + C_4</span> . Now <span class="math">B</span> is updated to this new value of <span class="math">C</span> :</p>

    <div class="my-4 text-center"><span class="math-block">B \\leftarrow C = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\quad \\quad \\quad \\left( \\begin{array}{c} 4 \\\\ 3 \\\\ 2 \\\\ 0 \\\\ 1 \\end{array} \\right) \\tag{8}</span></div>

    <p class="text-gray-300">where the column of integers indicates the order in which the rows of <span class="math">C</span> were computed. The matrices <span class="math">F</span> and <span class="math">G</span> have been partially computed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">F = \\left( \\begin{array}{cccc} 3 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 3 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 2 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 1 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 0 &amp;amp; . &amp;amp; . &amp;amp; . \\end{array} \\right) \\quad \\quad \\quad G = \\left( \\begin{array}{cccc} 3 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; . &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; . &amp;amp; . &amp;amp; . \\end{array} \\right) \\tag{9}</span></div>

    <p class="text-gray-300">Now we repeat this process, starting with <span class="math">A_1 + A_2</span> which has parity two. Matrix <span class="math">B</span> gets updated</p>

    <p class="text-gray-300">to</p>

    <div class="my-4 text-center"><span class="math-block">B \\leftarrow C = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\quad \\quad \\quad \\left( \\begin{array}{c} 4 \\\\ 1 \\\\ 0 \\\\ 2 \\\\ 3 \\end{array} \\right) \\tag{10}</span></div>

    <p class="text-gray-300">with the column again indicating the order of computing the rows of the updated <span class="math">B</span>. Matrices <span class="math">F</span> and <span class="math">G</span> have been further filled out as follows:</p>

    <div class="my-4 text-center"><span class="math-block">F = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; . &amp;amp; . \\\\ 3 &amp;amp; 1 &amp;amp; . &amp;amp; . \\\\ 2 &amp;amp; 1 &amp;amp; . &amp;amp; . \\\\ 1 &amp;amp; 1 &amp;amp; . &amp;amp; . \\\\ 0 &amp;amp; 0 &amp;amp; . &amp;amp; . \\end{array} \\right) \\quad \\quad \\quad G = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; 2 &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; 3 &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; 4 &amp;amp; . &amp;amp; . \\\\ 4 &amp;amp; 4 &amp;amp; . &amp;amp; . \\end{array} \\right) \\tag{11}</span></div>

    <p class="text-gray-300">Though most of the work to obtain this update have been left out, one can see without any work that <span class="math">C_2 = A_1 + A_2</span>. Working out the computation of the other rows one on own's is encouraged to appreciate what is involved. The reader may by now have noticed that we have been skipping the computation of the <span class="math">D</span> matrices. We defer this because in this example, we will just look back at all the values <span class="math">B</span> and adjust their signs using rows of <span class="math">A</span>. Another update of <span class="math">B</span> is given by:</p>

    <div class="my-4 text-center"><span class="math-block">B \\leftarrow C = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\quad \\quad \\quad \\left( \\begin{array}{c} 4 \\\\ 2 \\\\ 1 \\\\ 0 \\\\ 3 \\end{array} \\right). \\tag{12}</span></div>

    <p class="text-gray-300">Matrices <span class="math">F</span> and <span class="math">G</span> have been further filled out as follows:</p>

    <div class="my-4 text-center"><span class="math-block">F = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; 3 &amp;amp; . \\\\ 3 &amp;amp; 1 &amp;amp; 2 &amp;amp; . \\\\ 2 &amp;amp; 1 &amp;amp; 1 &amp;amp; . \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; . \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; . \\end{array} \\right) \\quad \\quad \\quad G = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; 3 &amp;amp; . \\\\ 4 &amp;amp; 2 &amp;amp; 3 &amp;amp; . \\\\ 4 &amp;amp; 3 &amp;amp; 3 &amp;amp; . \\\\ 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; . \\\\ 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; . \\end{array} \\right) \\tag{13}</span></div>

    <p class="text-gray-300">The final update is</p>

    <div class="my-4 text-center"><span class="math-block">B \\leftarrow C = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\quad \\quad \\quad \\left( \\begin{array}{c} 4 \\\\ 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{array} \\right). \\tag{14}</span></div>

    <p class="text-gray-300">Matrices <span class="math">F</span> and <span class="math">G</span> have been further finalized as:</p>

    <div class="my-4 text-center"><span class="math-block">F = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 \\\\ 3 &amp;amp; 1 &amp;amp; 2 &amp;amp; 3 \\\\ 2 &amp;amp; 1 &amp;amp; 1 &amp;amp; 2 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\end{array} \\right) \\quad \\quad \\quad G = \\left( \\begin{array}{cccc} 3 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 \\\\ 4 &amp;amp; 2 &amp;amp; 3 &amp;amp; 4 \\\\ 4 &amp;amp; 3 &amp;amp; 3 &amp;amp; 4 \\\\ 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; 4 \\\\ 4 &amp;amp; 4 &amp;amp; 4 &amp;amp; 4 \\end{array} \\right). \\tag{15}</span></div>

    <p class="text-gray-300">The difference matrices that we need are</p>

    <p class="text-gray-300"><span class="math">D^{0}=\\left(\\matrix{0&amp;0&amp;0&amp;0\\cr 0&amp;0&amp;0&amp;-1\\cr 0&amp;0&amp;1&amp;-1\\cr 0&amp;-1&amp;1&amp;-1\\cr-1&amp;-1&amp;1&amp;-1}\\right),D^{1}=\\left(\\matrix{0&amp;0&amp;0&amp;0\\cr 1&amp;0&amp;0&amp;0\\cr 1&amp;-1&amp;0&amp;0\\cr 1&amp;-1&amp;1&amp;0\\cr 1&amp;-1&amp;1&amp;1}\\right),D^{2}=\\left(\\matrix{0&amp;0&amp;0&amp;0\\cr 0&amp;0&amp;0&amp;-1\\cr-1&amp;0&amp;0&amp;-1\\cr-1&amp;-1&amp;0&amp;-1\\cr-1&amp;-1&amp;-1&amp;-1}\\right),D^{3}=\\left(\\matrix{0&amp;0&amp;0&amp;0\\cr 0&amp;0&amp;1&amp;0\\cr 1&amp;0&amp;1&amp;0\\cr 1&amp;0&amp;1&amp;1\\cr 1&amp;1&amp;1&amp;1}\\right),</span> (16)</p>

    <p class="text-gray-300">which are obtained by taking the successive <span class="math">B</span> matrices (excluding the last one), and negating the columns where the corresponding rows of <span class="math">A</span> (excluding the top row) have a one.</p>

    <p class="text-gray-300">The final bit matrix <span class="math">B</span>, the integer matrices <span class="math">F</span> and <span class="math">G</span> and the difference matrices <span class="math">D^{0},D^{1},D^{2},D^{3}</span> make up the plan used for the point addition phase. The matrix <span class="math">B</span> says how to initialize the the sequence of points. The matrices <span class="math">F</span> and <span class="math">G</span> say how to update the sequence of points, by virtue of which elements to add. The matrices <span class="math">D^{j}</span> say how to determine the differences of the points being added, which is needed to the x-only Montgomery addition laws.</p>

    <p class="text-gray-300">We summarize the entire point addition phase in the following array</p>

    <p class="text-gray-300"><span class="math">\\matrix{0&amp;0&amp;0&amp;0&amp;2&amp;2&amp;2&amp;2&amp;4&amp;2&amp;2&amp;6&amp;8&amp;4&amp;6&amp;10&amp;14&amp;10&amp;12\\cr 0&amp;1&amp;0&amp;0&amp;2&amp;2&amp;1&amp;2&amp;2&amp;4&amp;2&amp;3&amp;5&amp;8&amp;4&amp;6&amp;10&amp;14&amp;10&amp;11\\cr 0&amp;1&amp;0&amp;1&amp;1&amp;2&amp;1&amp;2&amp;3&amp;4&amp;2&amp;3&amp;5&amp;7&amp;4&amp;6&amp;10&amp;14&amp;9&amp;11\\cr 1&amp;1&amp;0&amp;1&amp;1&amp;2&amp;1&amp;1&amp;3&amp;3&amp;2&amp;3&amp;5&amp;7&amp;5&amp;6&amp;10&amp;15&amp;9&amp;11\\cr 1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;1&amp;3&amp;3&amp;3&amp;3&amp;5&amp;7&amp;5&amp;5&amp;11&amp;15&amp;9&amp;11\\cr}</span> (17)</p>

    <p class="text-gray-300">Think of this as five <span class="math">5\\times 4</span> matrices whose rows of the form <span class="math">(r_{1},r_{2},r_{3},r_{4})</span> represent computation of the point <span class="math">r_{1}P_{1}+\\cdots+r_{4}P_{4}</span>. It remains to explain how the plan leads to this computatain.</p>

    <p class="text-gray-300">The first of the five matrices is the final value of bit matrix <span class="math">B</span>. To obtain the subsequent matrices we use the previous matrix and the matrices <span class="math">F</span> and <span class="math">G</span> and the <span class="math">D^{j}</span> matrices. However, we must use the columns of <span class="math">F</span> and <span class="math">G</span> and the matrices <span class="math">D^{j}</span> in the <em>reverse</em> order that they were obtained.</p>

    <p class="text-gray-300">For example, to obtain the third row of the second matrix, we note that that third row of the last column of <span class="math">F</span> and <span class="math">G</span> have the values two and four respecitvely, so therefore we add rows 2 and 4 of the first matrix to <span class="math">(0,1,0,1)+(1,1,1,1)=(1,2,1,2)</span>. Here we have added using integer vector arithmetic, we are no longer working modulo two. In fact, there is no big integer arithmetic in the point addition phase, just point addition, so we actually be doing a single point addition, as follows:</p>

    <p class="text-gray-300"><span class="math">(P_{2}+P_{4})+(P_{1}+P_{2}+P_{3}+P_{4})=(P_{1}+2P_{2}+P_{3}+2P_{4})</span> (18)</p>

    <p class="text-gray-300">where the additions inside the parenthesis on the left hand side were already done as part of the initialization, and the additions in the right hand side are achieve implicitly by the additions on the left hand side. The only point addition actually being done in this step is the one in the left hand side outside of the parentheses. Now <span class="math">(1,1,1,1)-(0,1,0,1)=(1,0,1,0)</span>, which is row 2 (counting with 0 from top as usual) of the last difference matrix.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Straightforward Simplifications</h3>

    <p class="text-gray-300">Evidently from the example, and from the theory numerous simplifications to the algorithm are possible. For example, the top row of <span class="math">B</span> is always all zeros and the bottom row is always all ones. Similarly, the bottom row <span class="math">F</span> is all zeros and the bottom row of <span class="math">G</span> is always all <span class="math">d</span>’s. The top rows of <span class="math">F</span> and <span class="math">G</span> are identical and are determined by the weights of the sums of successive rows of <span class="math">A</span>.</p>

    <p class="text-gray-300">Because the columns of <span class="math">F</span> weakly fall, and the columns of <span class="math">G</span> weakly rise, with exactly one rise or fall between rows, it follows that we use single bits to indicate whether <span class="math">F</span> falls or <span class="math">G</span> rises. Thus integers can be used for only for the common top row of <span class="math">F</span> and <span class="math">G</span>, if this has some advantage.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 Room for Improvement</h3>

    <p class="text-gray-300">It would be more convenient if the <span class="math">D</span> matrices and columns of <span class="math">F</span> and <span class="math">G</span> could somehow be computed in the opposite order, because then one could interleave the bit matrix phase and the point addition phase. Technically, the total computation time might be the same whether or not one interleaves the two phases, but in practice interleaving may help slightly because mainly some implementations can do pipelining, effectively allowing independent computations to be done simultaneously. If the bit matrix phase has to be done first, during that the time the pipeline is unavailable for doing point additions.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Why It Works</h2>

    <p class="text-gray-300">This section describes why the algorithm works. To do this, several definitions, lemmas and theorems about matrices are introduced.</p>

    <p class="text-gray-300">The algorithm has two phases, the matrix phase and the point addition phase. In the matrix phase, a plan, or ladder, is made of which intermediate integer combinations of the points that shall be computed on the way to the compute the target combination. The matrix phase uses integer matrices and does not involve any elliptic curve arithmetic. The point addition phase then uses this plan, or climbs the ladder, to add points together, for the most part not using y-coordinates, ultimately arriving at the target integer combination of points.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 The Matrix Phase</h3>

    <p class="text-gray-300">We will use the following convention for indexing matrices. A matrix with <span class="math">d</span> columns (rows) will have columns (rows) indexed by <span class="math">1,2,\\ldots,d</span>, while a matrix with <span class="math">d+1</span> rows (columns) will have rows (columns) indexed by <span class="math">0,1,2,\\ldots,d</span>. The parameter <span class="math">d</span> is called the dimension, and will be the number of points that we wish to combine in the application of the algorithm. Write <span class="math">M_{j}</span> for the row of a matrix <span class="math">M</span> indexed by <span class="math">j</span> under the conventions stated above . Write <span class="math">e_{i}</span> for an elementary row vector that has a one in position <span class="math">i</span> and zero in all other positions.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A state matrix is a <span class="math">(d+1)\\times d</span> integer matrix <span class="math">S</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">S_{j}-S_{j+1}=\\pm e_{i}</span> for some <span class="math">i</span>.</li>

      <li><span class="math">S_{j}</span> has <span class="math">j</span> odd entries.</li>

    </ul>

    <p class="text-gray-300">An example state matrix is</p>

    <p class="text-gray-300">\\[ S=\\begin{pmatrix}S_{0}\\\\ S_{1}\\\\ S_{2}\\\\ S_{3}\\end{pmatrix}=\\begin{pmatrix}28&30&18\\\\ 28&29&18\\\\ 29&29&18\\\\ 29&29&19\\end{pmatrix}. \\] (19)</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Any integer row vector <span class="math">R</span> is the row of some state matrix <span class="math">S</span>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">R</span> has <span class="math">j</span> odd entries. Then set <span class="math">S_{j}=R</span>. For <span class="math">1\\leqslant i\\leqslant j</span>, choose <span class="math">S_{i-1}</span> be adding <span class="math">\\pm 1</span> to one of the odd entries of <span class="math">S_{i}</span>. For <span class="math">j\\leqslant i&lt;d</span>, choose row <span class="math">S_{i+1}</span> by adding <span class="math">\\pm 1</span> to one of the even entries. ∎</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Lemma 2.</h6>

    <p class="text-gray-300">If <span class="math">S</span> is a state and <span class="math">i&lt;j</span>, the set of indices of odd entries of <span class="math">S_{i}</span> is a subset of the corresponding set for row <span class="math">S_{j}</span>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">If suffices to prove this for <span class="math">j=i+1</span>, for which it is obvious. ∎</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A transition matrix is an <span class="math">(d+1)\\times(d+1)</span> integer matrix <span class="math">M</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">M_{j}=e_{i}+e_{i+j}</span> for some <span class="math">i</span>.</li>

      <li><span class="math">M_{j}-M_{j+1}=\\pm(e_{i}-e_{i+1})</span> for some <span class="math">i</span>.</li>

    </ul>

    <p class="text-gray-300">An example transition matrix is</p>

    <p class="text-gray-300">\\[ M=\\begin{pmatrix}M_{0}\\\\ M_{1}\\\\ M_{2}\\\\ M_{3}\\end{pmatrix}=\\begin{pmatrix}0&0&2&0\\\\ 0&1&1&0\\\\ 0&1&0&1\\\\ 1&0&0&1\\end{pmatrix}. \\] (20)</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">If <span class="math">M</span> is a transition matrix and <span class="math">S</span> is a state, then <span class="math">T=MS</span> is a state.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Now <span class="math">T_{j}=M_{j}S</span>. Since <span class="math">M_{j}=e_{i}+e_{i+j}</span>, we have <span class="math">T_{j}=S_{i}+S_{i+j}</span>. By Lemma 2, the odd entries of <span class="math">S_{i}</span> will cancel <span class="math">i</span> odd entries in <span class="math">S_{i+j}</span>, leaving <span class="math">j</span> entries as desired. To establish the second state property for <span class="math">T</span>, we calculate that <span class="math">T_{j}-T_{j+1}=(M_{j}-M_{j+1})S=\\pm(e_{i}-e_{i+1})S=\\pm(S_{i}-S_{i+1})=\\pm e_{k}</span> for some <span class="math">k</span>. ∎</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">If <span class="math">T</span> is a state matrix, then there exists a unique state matrix <span class="math">S</span> and unique transition matrix <span class="math">M</span>, such that <span class="math">T=MS</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We determine the rows of <span class="math">M</span> in order, <span class="math">M_{0},M_{1},\\ldots,M_{d}</span>, and the rows of <span class="math">S</span> in an order to be determined. Suppose that <span class="math">\\frac{1}{2}T_{0}</span> has <span class="math">h</span> odd entries. This implies that</p>

    <p class="text-gray-300"><span class="math">M_{0}=2e_{h}\\qquad\\text{and}\\qquad S_{h}=\\frac{1}{2}T_{0}.</span> (21)</p>

    <p class="text-gray-300">This is the base of the induction for determining the remaining rows. The induction will be on <span class="math">f</span> and <span class="math">g</span> such that <span class="math">0\\leqslant f\\leqslant g\\leqslant d</span>, starting with <span class="math">f=g=h</span>. At each stage of induction, rows <span class="math">S_{f},S_{f+1},\\ldots,S_{g}</span> and <span class="math">M_{0},\\ldots,M_{g-f}</span> will have have been determined. Moreover we will have</p>

    <p class="text-gray-300"><span class="math">M_{g-f}=e_{f}+e_{g}.</span> (22)</p>

    <p class="text-gray-300">Let <span class="math">j=g-f+1</span>. By definition of transition matrices, we must have</p>

    <p class="text-gray-300"><span class="math">M_{j}\\in\\{e_{f-1}+e_{g},e_{f}+e_{g+1}\\}.</span> (23)</p>

    <p class="text-gray-300">In order for <span class="math">T=MS</span> to hold, this must imply that</p>

    <p class="text-gray-300"><span class="math">T_{j}\\in\\{S_{f-1}+S_{g},S_{f}+S_{g+1}\\}</span> (24)</p>

    <p class="text-gray-300">Therefore we need one of the following two equations to hold:</p>

    <div class="my-4 text-center"><span class="math-block">S _ {f - 1} = T _ {j} - S _ {g} \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {g + 1} = T _ {j} - S _ {f}</span></div>

    <p class="text-gray-300">Whichever these equations is valid will determine another row of the matrix <span class="math">S</span>, namely, either <span class="math">S_{f-1}</span> or <span class="math">S_{g+1}</span>. If <span class="math">T_j - S_g</span> has <span class="math">f-1</span> odd entries then we must have the equation for <span class="math">S_{f-1}</span>. If <span class="math">T_j - S_f</span> has <span class="math">g+1</span> odd entries, we must have the equation for <span class="math">S_{g+1}</span>.</p>

    <p class="text-gray-300">To show that exactly one of the conditions in (25) holds, note that <span class="math">T_{j-1} = S_f + S_g</span>, and that <span class="math">T_j</span> has one more odd entry than <span class="math">T_{j-1}</span>. The extra odd entry in <span class="math">T_j</span> can must in a position where <span class="math">S_f</span> has an even entry. The entry in that position can be even or odd for <span class="math">S_g</span>. If it is even for <span class="math">S_g</span>, then the equation for <span class="math">S_{g+1}</span> holds, and if odd, the equation for <span class="math">S_{f-1}</span> holds.</p>

    <p class="text-gray-300">To illustrate, let us apply the algorithm in the proof to</p>

    <div class="my-4 text-center"><span class="math-block">T = \\left( \\begin{array}{l} T _ {0} \\\\ T _ {1} \\\\ T _ {2} \\\\ T _ {3} \\\\ T _ {4} \\end{array} \\right) = \\left( \\begin{array}{cccc} 24 &amp;amp; 28 &amp;amp; 18 &amp;amp; 22 \\\\ 24 &amp;amp; 28 &amp;amp; 18 &amp;amp; 23 \\\\ 24 &amp;amp; 29 &amp;amp; 18 &amp;amp; 23 \\\\ 25 &amp;amp; 29 &amp;amp; 18 &amp;amp; 23 \\\\ 25 &amp;amp; 29 &amp;amp; 19 &amp;amp; 23 \\end{array} \\right). \\tag{26}</span></div>

    <p class="text-gray-300">As in the proof, we compute the rows of <span class="math">M</span> and <span class="math">S</span> one at a time.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Row <span class="math">T_0 = (24, 28, 18, 22)</span>, so <span class="math">S_h = \\frac{1}{2} T_0 = (12, 14, 9, 11)</span>. The number of odd entries of <span class="math">S_h</span> is two, so <span class="math">h = 2</span>, and <span class="math">M_0 = 2e_2</span>.</li>

      <li>The next row of <span class="math">S</span> to compute must be <span class="math">T_{1} - S_{2} = (12, 14, 9, 12)</span>, which has just one entry, so must be <span class="math">S_{1}</span>. Thus <span class="math">M_{1} = e_{1} + e_{2}</span>.</li>

      <li>The next row of <span class="math">S</span> to compute is either <span class="math">S_0 = T_2 - S_2</span> or <span class="math">S_3 = T_2 - S_1</span>, as in (25). Because <span class="math">T_2 - S_1 = (12, 15, 9, 11)</span> has three odd entries, <span class="math">S_3</span> is the choice. Thus <span class="math">M_2 = e_1 + e_3</span>.</li>

      <li>The next row of <span class="math">S</span> to compute is either <span class="math">S_0 = T_3 - S_3</span> or <span class="math">S_4 = T_3 - S_1</span>, depending on parity. The choice is <span class="math">S_4 = T_3 - S_1 = (13, 15, 9, 11)</span>. Thus <span class="math">M_3 = e_1 + e_4</span>.</li>

      <li>The last of <span class="math">S</span> to be determined is thus <span class="math">S_0 = T_4 - S_4 = (12, 14, 10, 12)</span>, and as always <span class="math">M_4 = e_0 + e_4</span>.</li>

    </ol>

    <p class="text-gray-300">Therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{cccc} 24 &amp;amp; 28 &amp;amp; 18 &amp;amp; 22 \\\\ 24 &amp;amp; 28 &amp;amp; 18 &amp;amp; 23 \\\\ 24 &amp;amp; 29 &amp;amp; 18 &amp;amp; 23 \\\\ 25 &amp;amp; 29 &amp;amp; 18 &amp;amp; 23 \\\\ 25 &amp;amp; 29 &amp;amp; 19 &amp;amp; 23 \\end{array} \\right) = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\left( \\begin{array}{cccc} 12 &amp;amp; 14 &amp;amp; 10 &amp;amp; 12 \\\\ 12 &amp;amp; 14 &amp;amp; 9 &amp;amp; 12 \\\\ 12 &amp;amp; 14 &amp;amp; 9 &amp;amp; 11 \\\\ 12 &amp;amp; 15 &amp;amp; 9 &amp;amp; 11 \\\\ 13 &amp;amp; 15 &amp;amp; 9 &amp;amp; 11 \\end{array} \\right). \\tag{27}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3.</strong> For any matrix <span class="math">A</span>, define $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to the maximum of the absolute values of the entries of </span>A$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 5.</strong> If <span class="math">S</span> and <span class="math">T</span> are state matrices, <span class="math">M</span> is a transition matrix, and <span class="math">T = MS</span>, then $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 \\leqslant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. By definition, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{j,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>j<span class="math"> and </span>k<span class="math">. Now </span>T_{j,k} = S_{i,k} + S_{(i+j),k}<span class="math">, by the properties of </span>M<span class="math">. Therefore </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{(i+j),k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By definition, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for some </span>j<span class="math"> and </span>k<span class="math">. It is easy to see that there will some </span>j<span class="math"> such that </span>M_j = e_f + e_g<span class="math"> where </span>i \\in \\{f,g\\}<span class="math">. Then </span>T_{j,k} = S_{f,k} + S_{g,k}<span class="math">. Without loss of generality, suppose that </span>i = f<span class="math">. By properties of state matrices, </span>S_{g,k} = S_{f,k} + \\sigma<span class="math">, with </span>\\sigma \\in \\{-1,0,1\\}<span class="math">. But </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{g,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{f,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, so </span>\\sigma = 0<span class="math">, or it has the opposite sign to </span>S_{f,k}<span class="math">. Noting that </span>T_{j,k} = 2S_{i,k} + \\sigma<span class="math">, we see that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{j,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geqslant 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i,k}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1<span class="math">, which gives </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geqslant 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 6. If <span class="math">S</span> and <span class="math">T</span> are state matrices, <span class="math">M</span> is a transition matrix, and <span class="math">T = MS</span>, then either $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> or </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Suppose that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then </span>2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 \\leqslant 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1 \\leqslant</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and adding </span>1 -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to both ends gives </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leqslant 1<span class="math">. The case </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 0<span class="math"> is impossible, because </span>T$ has odd entries.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 7. If <span class="math">S</span> and <span class="math">T</span> are state matrices, <span class="math">M</span> is a transition matrix, <span class="math">T = MS</span>, and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">, then </span>S = T<span class="math"> and </span>M_j = e_0 + e_j<span class="math"> for all </span>j$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math">, row </span>T_0 = 0<span class="math">, because </span>T_0<span class="math"> has all even entries with absolute values at most one. Suppose that </span>M<span class="math"> satisfies </span>M_j = e_0 + e_j<span class="math"> and </span>S = T<span class="math">. Then </span>S_0 = T_0 = 0<span class="math"> and </span>T_j = S_0 + S_j = S_j<span class="math">. Therefore </span>T = MS<span class="math">. Because </span>T<span class="math"> factors uniquely, these choices of </span>M<span class="math"> and </span>S$ are the only possibilities.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 8. Let <span class="math">S</span> be a state matrix. Then <span class="math">S</span> factors uniquely as a product</p>

    <div class="my-4 text-center"><span class="math-block">S = AB \\dots CT \\tag{28}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where: <span class="math">A, B, \\ldots, C</span> are transition matrices, <span class="math">C_0 \\neq 2e_0</span>, and <span class="math">T</span> is a state matrix with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1$. Conversely, every such product is a state matrix.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Immediate from the previous results.</p>

    <p class="text-gray-300">To illustrate, we give the following factorization</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\left( \\begin{array}{cccc} 12 &amp;amp; 14 &amp;amp; 10 &amp;amp; 12 \\\\ 12 &amp;amp; 14 &amp;amp; 9 &amp;amp; 12 \\\\ 12 &amp;amp; 14 &amp;amp; 9 &amp;amp; 11 \\\\ 12 &amp;amp; 15 &amp;amp; 9 &amp;amp; 11 \\\\ 13 &amp;amp; 15 &amp;amp; 9 &amp;amp; 11 \\end{array} \\right) = \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\\\ \\times \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 2 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 2 \\\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 1 \\\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\end{array} \\right) \\left( \\begin{array}{cccc} 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ 1 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \\\\ 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; 1 \\end{array} \\right) \\tag{29} \\end{array}</span></div>

    <p class="text-gray-300">Definition 4. Let <span class="math">A</span> be a matrix or a vector. We write <span class="math">A \\geqslant 0</span> and say that <span class="math">A</span> is nonnegative, if all entries of <span class="math">A</span> are nonnegative.</p>

    <p class="text-gray-300">Theorem 9. If <span class="math">S</span> and <span class="math">T</span> are state matrices, <span class="math">M</span> is a transition matrix, and <span class="math">T = MS</span>, and <span class="math">T \\geqslant 0</span> if and only if <span class="math">S \\geqslant 0</span>.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">S\\geqslant 0</span>. Since <span class="math">M\\geqslant 0</span> and the product of nonnegative matrices is nonnegative, we then have <span class="math">T=MS\\geqslant 0</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">S\\ngeqslant 0</span>. Then <span class="math">S</span> has a negative entry <span class="math">S_{i,k}&lt;0</span>. It follows that <span class="math">S_{l,k}\\leqslant 0</span> for all <span class="math">l</span>. There exists a <span class="math">j</span> such that <span class="math">T_{j,k}=S_{f,k}+S_{g,k}</span> for some <span class="math">f</span> and <span class="math">g</span>, with <span class="math">i\\in\\{f,g\\}</span>. It then follows that <span class="math">T_{j,k}&lt;0</span>, and thus <span class="math">T\\ngeqslant 0</span>. ∎</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Lemma 10.</h6>

    <p class="text-gray-300">If <span class="math">T</span> is a state matrix, then it has rank <span class="math">d</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Induction on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. For </span>T=1<span class="math">, it is obvious. Otherwise </span>T=MS<span class="math"> for some state matrix </span>S<span class="math"> with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Because </span>M<span class="math"> is invertible, matrices </span>T<span class="math"> and </span>S$ have the same rank. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Doubtlessly, because of the general interest of matrices in mathematics, there exist many different matrix factorization algorithms, perhaps some quite general. One may thus wonder if any of such algorithms cover the result above: here we speculate that they do not, mainly on the grounds that nobody would have had reason to consider the peculiar form of matrices that we needed to consider.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Incidentally, transition matrices have determinant <span class="math">\\pm 2</span>, because only one permuation is embeddable into the nonzero entries of <span class="math">M</span>. Therefore, transition matrices are always invertible. State matrices are not square, so have neither determinant nor inverse. Although not needed for the multi-dimensional Montgomery ladder algorithm, one can amend the definition of state matrices by preprend a zeroth column, all of whose entries are equal to a power of two. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math">, the power of two should be one, and otherwise it should be </span>2^{t}<span class="math"> where </span>t<span class="math"> is the number of transition matrices in the (28). These amended state matrices are invertible and have determinant </span>\\pm 2^{t}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The number of transition matrices is <span class="math">2^{d}</span>, which can be seen by starting from the last row, which is always <span class="math">e_{0}+e_{d}</span>, and noting that each successive row can have either the left entry or the right entry shifted one step in the opposite direction. The number of state matrices <span class="math">T</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1<span class="math"> is </span>2^{d}d!<span class="math">, or just </span>d!<span class="math"> if </span>T<span class="math"> is also nonnegative. Therefore, the number of state matrices that factor into the form in (28) with </span>t<span class="math"> transition matrices is </span>2^{dt}(2^{d}-1)d!<span class="math">, or just </span>2^{d(t-1)}(2^{d}-1)d!$ when counting only nonnegative state matrices.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.2 Difference Matrices</h3>

    <p class="text-gray-300">The point addition phases needs not only the transition matrices and the minimal state matrix, but it also needs the difference matrices (to be defined), so that Montgomery formula for point addition with <span class="math">x</span>-coordinate only can be used.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">M</span> be a state matrix, such that it rows of the form <span class="math">M_{j}=e_{f}+e_{g}</span> with <span class="math">f\\leqslant g</span>. Define <span class="math">\\hat{M}</span> such that it rows of the form <span class="math">\\hat{M}_{j}=e_{f}-e_{g}</span>. As usual, suppose that <span class="math">T</span> is a state matrix factoring uniquely into as <span class="math">T=MS</span> where <span class="math">M</span> is a transition matrix and <span class="math">S</span> is a state matrix. The difference matrix corresponding to <span class="math">T</span> is the matrix <span class="math">D=\\hat{M}S</span>. We note that a difference matrix <span class="math">D</span> is actually a state matrix and that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A simple rule may be used to determine the difference matrix <span class="math">D=(d_{j,k})</span> corresponding to state matrix <span class="math">T=(t_{j,k})</span>. If <span class="math">t_{j,k}</span> is even, then <span class="math">d_{j,k}=0</span>. Otherwise <span class="math">t_{j,k}\\equiv d_{j,k}\\bmod 4</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">3.3 Simplified Matrix Phase</h3>

    <p class="text-gray-300">One disadvantage of the methods given by §3.1 is the big integer arithmetic in the computation of the intermediate state matrices. A second disadvantage is the computation of the transition matrices in the matrix phase is in an order opposite to how they applied in the point addition</p>

    <p class="text-gray-300">phase, which means that matrix phase has to be complete before the addition phase can be begun. Therefore we develop some more theory that can be used to overcome these disadvantages.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 5.</h6>

    <p class="text-gray-300">Fix some <span class="math">1\\leqslant c\\leqslant d</span>. Let <span class="math">S</span> be any state matrix <span class="math">S</span>. Let <span class="math">S^{\\prime}</span> the matrix obtained by deleting column <span class="math">c</span> and the deleting the row in which the entry of column <span class="math">c</span> does not equal the value in the row below.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">If <span class="math">S</span> is a state matrix for dimension <span class="math">d</span>, then <span class="math">S^{\\prime}</span> is a state matrix for dimension <span class="math">d-1</span>.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For any row vector <span class="math">R</span>, let <span class="math">R^{\\prime}</span> indicate the row vector with entry <span class="math">c</span> deleted. For each <span class="math">j</span>, we have <span class="math">S^{\\prime}_{j}=(S_{j^{\\prime}})^{\\prime}</span> where <span class="math">j^{\\prime}\\in\\{j,j+1\\}</span>, with the choice depending on whether <span class="math">j</span> lies below the deleted row of matrix <span class="math">S</span>. Now <span class="math">S^{\\prime}_{j}</span> has <span class="math">j</span> odd entries if <span class="math">j^{\\prime}=j</span>, because the deleted entry of <span class="math">S_{j^{\\prime}}</span> is even, and <span class="math">S^{\\prime}_{j}</span> has <span class="math">j</span> odd entries if <span class="math">j^{\\prime}=j+1</span> because <span class="math">S_{j^{\\prime}}</span> has <span class="math">j^{\\prime}=j+1</span> odd entries and one odd entry, in position <span class="math">c</span>, is deleted to give <span class="math">j</span> odd entries.</p>

    <p class="text-gray-300">Now <span class="math">S^{\\prime}_{j}-S^{\\prime}_{j+1}\\in\\{(S_{j}-S_{j+1})^{\\prime},(S_{j}-S_{j+2})^{\\prime},(S_{j+1}-S_{j+2})^{\\prime}\\}</span>, depending on whether <span class="math">j</span> lies above, at, or below the deleted row of the matrix <span class="math">S</span>. Because <span class="math">S</span> is a state matrix will have <span class="math">i\\neq c</span> such that <span class="math">S_{j}-S_{j+1}=\\pm e_{i}</span>, and <span class="math">S_{j}-S_{j+2}=\\pm e_{i}\\pm e_{c}</span> and <span class="math">S_{j+1}-S_{j+2}=\\pm e_{i}</span>. Upon deleteion of entry <span class="math">c</span>, wee see that <span class="math">S^{\\prime}_{j}-S^{\\prime}_{j+1}</span> has the form <span class="math">\\pm e_{i}</span>. ∎</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Theorem 12.</h6>

    <p class="text-gray-300">If <span class="math">S</span> and <span class="math">T</span> are state matrices, <span class="math">M</span> is a transition matrix, and <span class="math">T=MS</span>, then <span class="math">T^{\\prime}=M^{\\prime}S^{\\prime}</span> for some transition matrix <span class="math">M^{\\prime}</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For any row vector <span class="math">R</span>, let <span class="math">R^{\\prime}</span> indicate the row vector with entry <span class="math">c</span> deleted. For each <span class="math">j</span> we have <span class="math">T_{j}=S_{f}+S_{g}</span> for some <span class="math">f</span> and <span class="math">g</span>. Therefore <span class="math">(T_{j})^{\\prime}=(S_{f})^{\\prime}+(S_{g})^{\\prime}</span>. We write <span class="math">(T_{j})^{\\prime}=T^{\\prime}_{j^{\\prime}}</span> where <span class="math">j^{\\prime}\\in\\{j,j+1\\}</span>, with the choice of value depending on whether <span class="math">j</span> lies above or below the row deleted from <span class="math">T</span>. Similarly, we write <span class="math">(S_{k})^{\\prime}=S^{\\prime}_{k^{\\prime}}</span> where <span class="math">k^{\\prime}\\in\\{k,k+1\\}</span>. Therefore, we have <span class="math">T^{\\prime}_{j^{\\prime}}=S^{\\prime}_{f^{\\prime}}+S^{\\prime}_{g^{\\prime}}</span>. This means that <span class="math">T^{\\prime}=M^{\\prime}S^{\\prime}</span> for matrix <span class="math">M^{\\prime}</span> such that <span class="math">M^{\\prime}_{j^{\\prime}}=e_{f^{\\prime}}+e_{g^{\\prime}}</span> with the same values of indices as used previously. We need only now to show that <span class="math">M^{\\prime}</span> is a transition matrix.</p>

    <p class="text-gray-300">To prove that <span class="math">M^{\\prime}</span> is a transition matrix, we need to show both (a) that <span class="math">g^{\\prime}-f^{\\prime}=j^{\\prime}</span> and (b) that successive rows of <span class="math">M^{\\prime}</span> differ by <span class="math">\\pm(e_{i}-e_{i+1})</span> for some <span class="math">i</span>.</p>

    <p class="text-gray-300">To show (a), consider the parity of the entries of rows of state matrices <span class="math">S^{\\prime}</span> and <span class="math">T^{\\prime}</span> (in other words, look at the Hamming weight modulo two). Since <span class="math">T^{\\prime}_{j^{\\prime}}</span> has <span class="math">j^{\\prime}</span> odd entries, the <span class="math">f^{\\prime}</span> odd entries of row <span class="math">S^{\\prime}_{f^{\\prime}}</span> are subset of the <span class="math">g^{\\prime}</span> odd entries of row <span class="math">S^{\\prime}_{g^{\\prime}}</span>, we must have <span class="math">j^{\\prime}=g^{\\prime}-f^{\\prime}</span>.</p>

    <p class="text-gray-300">To show (b), consider that successive rows of <span class="math">T^{\\prime}</span> differ in just one entry, with a difference of <span class="math">\\pm 1</span>. Suppose that <span class="math">T^{\\prime}_{j}-T^{\\prime}_{j+1}=\\pm e_{i}</span>. We may also suppose, because the work above, that <span class="math">T^{\\prime}_{j}=S_{f}+S_{g}</span> where <span class="math">g-f=j</span> and <span class="math">T^{\\prime}_{j+1}=S_{e}+S_{h}</span> where <span class="math">h-e=j+1</span>. Therefore <span class="math">\\pm e_{i}=S^{\\prime}_{f}+S^{\\prime}_{g}-S^{\\prime}_{e}-S^{\\prime}_{h}</span>. The columns of <span class="math">S^{\\prime}</span> may be ordered according to in which row they become odd. The odd entried positions of <span class="math">S^{\\prime}_{f}+S^{\\prime}_{g}</span> correspond an interval, a contigous set of consecutive entries, in this ordering of the colmunns of <span class="math">S^{\\prime}</span>. The same holds for <span class="math">S^{\\prime}_{e}+S^{\\prime}_{h}</span>. The difference of these two sums of rows, has only one odd entry, so therefore, the corresponding intervals must overlap in all but one point. Moreover the interval for <span class="math">S^{\\prime}_{e}+S^{\\prime}_{h}</span> must extend that of <span class="math">S^{\\prime}_{f}+S^{\\prime}_{g}</span> by appending the next element either above or below. This implies that <span class="math">(e,h)\\in\\{(f-1,g),(f,g+1)\\}</span>, which implies condition (b) for <span class="math">M^{\\prime}</span> be a transition matrix. ∎</p>

    <p class="text-gray-300">An application of Theorem 12, is that the all integers appearing the successive state matrices need not be computed multiple times for occurrence. Instead, one can reduce each column to dimension <span class="math">d=1</span> for computing the values of the entries. Dimension <span class="math">d=1</span> is the classical Montgomery method. An advantage of this observation is that values in the intermediate state matrix entries</p>

    <p class="text-gray-300">may be computed easily from the bit representations of the initial state matrix, as the following theorem illustrates.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 13.</h6>

    <p class="text-gray-300">For <span class="math">d=1</span>, let <span class="math">T</span> be a state matrix of the form</p>

    <p class="text-gray-300">\\[ T=\\begin{pmatrix}2a_{0}+2a_{s+1}+4a_{s+2}+2^{3}a_{3}+\\dots\\\\ 1+2a_{s+1}+4a_{s+2}+2^{3}a_{3}+\\dots\\end{pmatrix} \\] (30)</p>

    <p class="text-gray-300">where <span class="math">a_{i}\\in\\{0,1\\}</span>. Then for <span class="math">s\\geqslant 1</span>, we have</p>

    <p class="text-gray-300">\\[ T=M_{a_{0}+a_{1}}M_{a_{1}+a_{2}}\\dots M_{a_{s-1}+a_{s}}\\begin{pmatrix}2a_{s}+2a_{s+1}+4a_{s+2}+\\dots\\\\ 1+2a_{s+1}+4a_{s+2}+\\dots\\end{pmatrix} \\] (31)</p>

    <p class="text-gray-300">where <span class="math">M_{0}=M_{2}=(\\begin{smallmatrix}2&amp;0\\\\ 1&amp;1\\end{smallmatrix})</span> and <span class="math">M_{1}=(\\begin{smallmatrix}0&amp;2\\\\ 1&amp;1\\end{smallmatrix})</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Induction on <span class="math">s</span>. For <span class="math">s=1</span>, we can verify the result by inspecting each of four cases <span class="math">(a_{0},a_{1})\\in\\{(0,0),(0,1),(1,0),(1,1)\\}</span> individually. This covers the base of induction. Suppose (31) holds, then we shall show that it also holds with <span class="math">s</span> replaced by <span class="math">s+1</span>. Let</p>

    <p class="text-gray-300"><span class="math">S=\\begin{pmatrix}2a_{s}+2a_{s+1}+4a_{s+2}+\\dots\\\\ 1+2a_{s+1}+4a_{s+2}+\\dots\\end{pmatrix}</span> (32)</p>

    <p class="text-gray-300">so that (31) becomes <span class="math">T=M_{a_{1}}M_{a_{1}+a_{2}}\\dots M_{a_{s-1}+a_{s}}S</span>. Now apply the base case of induction to matrix <span class="math">S</span>, getting <span class="math">S=M_{a_{s}+a_{s+1}}U</span>, where <span class="math">U</span> has the desired form. ∎</p>

    <p class="text-gray-300">This result represents a simplification to the procedure in this <span class="math">d=1</span>, by overcoming both of the disadvantages mentioned earlier. The transition matrices can be computed using only manipulations of the bit representations of the entries of the initial state matrix <span class="math">T</span>, and they can be computed in any order. Furthermore, the intermediate state matrices do not even need to be calculated, so no big integer arithmetic is required in the matrix phase. The output of the matrix phase only needs to include the transition matrices and the minimal state matrix.</p>

    <p class="text-gray-300">Note that traditionally, the Montgomery ladder is presented in a slightly different, but equivalent manner. The differnce is that intermediate state matrices even and odd entries are occasionally swapped as needed, so that the transition operations depend on only a single bit in the representation, not two consecutive bits. The reason for us to use a slightly different form is to extend the algorithm to <span class="math">d&gt;1</span> consistently with the methods already described.</p>

    <p class="text-gray-300">The first step of extending the simplification to <span class="math">d&gt;1</span>, is to recognize that the value entries in each column of the <span class="math">s^{\\text{th}}</span> intermediate state matrix may be represented by the bit values <span class="math">(a_{s},a_{s+1},\\dots)</span> in the notation of Theorem 13. The reduction of the intermediate state matrix modulo two, a binary matrix, together with the information <span class="math">(a_{s},a_{s+1},\\dots)</span>, completely determines the full value of the intermediate state matrix. Therefore we may equivalent represent the state matrices as a pair <span class="math">(A,B)</span> of binary matrices, where <span class="math">A=(a_{j,k})</span> encodes values like <span class="math">a_{s}</span> and <span class="math">B=(b_{j,k})</span> encodes the modulo two values of the state matrix. More precisely for state matrix <span class="math">S=(s_{j,k})</span> , we have</p>

    <p class="text-gray-300"><span class="math">s_{j,k}=2a_{0,k}(1-b_{j,k})+b_{j,k}+2a_{1,k}+4a_{2,k}+2^{3}a_{3,k}+\\dots</span> (33)</p>

    <p class="text-gray-300">On the basis of Theorems 12 and 13, when transitioning to a smaller matrix, the effect on the <span class="math">A</span> component of the state is precisely deletion of the zeroth row. Although the <span class="math">B</span> component is itself a state matrix, the effect on <span class="math">B</span> depends on <span class="math">A</span></p>

    <p class="text-gray-300">To determine the effect on <span class="math">B</span>, when transitioning down, we review how Theorem 4 takes a state matrix <span class="math">T</span> and determines the unique transition matrix <span class="math">M</span> and smaller state matrix <span class="math">S</span> such that <span class="math">T=MS</span>. The first step of the proof is to halve <span class="math">T_{0}</span> and examine the parity. We have <span class="math">\\frac{1}{2}t_{0,k}=a_{0,k}+a_{1,k}+2a_{2,k}+\\dots</span>. Therefore <span class="math">h</span> is the number of <span class="math">k</span> such that <span class="math">a_{0,k}+a_{1,k}</span> is odd, and <span class="math">S_{h}=\\frac{1}{2}T_{0}</span>. Let <span class="math">B^{\\prime}</span> be the <span class="math">B</span> component of <span class="math">S</span>. Then we have <span class="math">b^{\\prime}_{h,k}\\equiv a_{0,k}+a_{1,k}\\bmod 2</span>. We may write this <span class="math">B^{\\prime}_{h}\\equiv A_{0}+A_{1}\\bmod 2</span>.</p>

    <p class="text-gray-300">We have determined <span class="math">M_{0}</span> and <span class="math">S_{h}</span> and <span class="math">B^{\\prime}_{h}</span>, and next is to determine <span class="math">M_{1}</span> and <span class="math">S_{h\\pm 1}</span> and <span class="math">B^{\\prime}_{h\\pm 1}</span>, for some choice of <span class="math">h\\pm 1</span>. To do this, we consider <span class="math">S_{h\\pm 1}=T_{1}-S_{h}=T_{1}-T_{0}+S_{h}</span>. But <span class="math">(T_{1}-T_{0})_{k}=(2a_{0,k}-1)(b_{1,k}-b_{0,k})=2a_{0,k}-1b_{1,k}</span>. Now <span class="math">2a_{0,k}-1\\in\\{-1,1\\}</span>, and there is a unique value of <span class="math">k</span> such that <span class="math">b_{1,k}=1</span>. Now the next row to consider is <span class="math">h^{\\prime}=h+1</span> if, for this unique <span class="math">k</span>, we have <span class="math">b^{\\prime}_{h,k}=0</span> and otherwise the next row to consider to consider is <span class="math">h^{\\prime}=h-1</span>. In either case, we have <span class="math">B^{\\prime}_{h^{\\prime}}\\equiv B^{\\prime}_{h}+B_{1}\\bmod 2</span>.</p>

    <p class="text-gray-300">Continuing, we just imitate the proof of Theorem 4, except that now the decisions made in that proof using rows of <span class="math">T</span> and <span class="math">S</span> are replaced by decision made using rows of <span class="math">B</span> and <span class="math">B^{\\prime}</span>. This can be done, since only the parities of the differences of rows of <span class="math">T</span> and <span class="math">S</span> are used to determine <span class="math">M</span> and <span class="math">S</span>.</p>

    <p class="text-gray-300">When implementing the algorithm, it is not necessary to actually the transition matrices <span class="math">M</span> as matrices per se, because most the entries are <span class="math">0</span>. Instead, one can compute the values of <span class="math">f</span> and <span class="math">g</span> for each row, so that <span class="math">M_{j}=e_{f}+e_{g}</span>. In the description of the algorithm the <span class="math">f</span> values are put into a matrix <span class="math">F</span> and the <span class="math">g</span> values are put into a matrix <span class="math">G</span>.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">3.4 The Point Addition Phase</h3>

    <p class="text-gray-300">A row <span class="math">(r_{1},\\dots,r_{d})</span> of a state will represent a point <span class="math">r_{1}G_{1}+\\dots+r_{d}G_{d}</span> whose x-coordinate we may compute. The difference of any two rows of a state has the form <span class="math">(l_{1},\\dots,l_{d})</span> where <span class="math">l_{1},\\dots,l_{d}\\in\\{-1,0,1\\}</span>. The Montgomery point addition formula will be used, with the aid of computation of <span class="math">l_{1}G_{1}+\\dots+l_{d}G_{d}</span> when needed. To compute a combination <span class="math">k_{1}G+\\dots+k_{d}G</span>, we first find a state with <span class="math">(k_{1},\\dots,k_{d})</span> as a row. From this state, we will find a sequence successfully smaller states, related transition matrices, which are defined next.</p>

    <p class="text-gray-300">Therefore to compute <span class="math">r_{1}G_{1}+\\dots+r_{d}G_{d}</span>. Find a state matrix <span class="math">T</span> with <span class="math">R=(r_{1},\\dots,r_{d})</span> as a row. It will be convenient to write <span class="math">G=(G_{1},\\dots,G_{d})</span>, and to write <span class="math">RG=r_{1}G_{1}+\\dots+r_{d}G_{d}</span>, for any such row vector <span class="math">R</span> in general.</p>

    <p class="text-gray-300">Now factor <span class="math">T</span> per Theorem 8, which can be done efficiently. For each of the intermediate state matrix <span class="math">S</span> in the factorization, and each row <span class="math">S_{j}</span> of the state matrix, we will calculate the elliptic curve point <span class="math">S_{j}G</span>. Now <span class="math">S</span> is obtained from a smaller state, say <span class="math">U</span>, and <span class="math">S_{j}=U_{f}+U_{g}</span> for some rows of <span class="math">U_{f}</span> and <span class="math">U_{g}</span> of <span class="math">U</span>. We calculate <span class="math">S_{j}G=U_{f}G+U_{g}G</span>.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Adrian Antipa, René Struik, Rob Lambert, and Scott Vanstone provided extremely helpful discussions of this algorithm.</p>

    <h2 id="sec-33" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] To be added.</li>

    </ul>`;
---

<BaseLayout title="Multi-Dimensional Montgomery Ladders for Elliptic Curves (2006/220)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2006 &middot; eprint 2006/220
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
