---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2006/220';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Multi-Dimensional Montgomery Ladders for Elliptic Curves';
const AUTHORS_HTML = 'Daniel R. L. Brown';

const CONTENT = `    <p class="text-gray-300">Daniel R. L. Brown</p>

    <p class="text-gray-300">June 12, 2006</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Montgomery's ladder algorithm for elliptic curve scalar multiplication uses only the xcoordinates of points. Avoiding calculation of the y-coordinates saves time for certain curves. Montgomery introduced his method to accelerate Lenstra's elliptic curve method for integer factoring. Bernstein extended Montgomery's ladder algorithm by computing integer combinations of two points, thus accelerating signature verification over certain curves. This paper modifies and extends Bernstein's algorithm to integer combinations of two or more points.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Montgomery observed that, for some elliptic curves, the x-coordinate of the point P + Q, where + is elliptic curve addition, could be calculated from the x-coordinate of the three points P, Q and Q − P.</p>

    <p class="text-gray-300">Using this observation, Montgomery proposed that kG could be computed in such by computing a sequence of pairs of x-coorindates of two points P = sG and Q = (s + 1)G, for appropriately selected values of s. This sequence has property that Q − R = G, so the difference of the points in known, and therefore P + Q = (2s + 1)G can be computed with using a y-coordinate. The other element of the next pair is either 2sG = 2P or 2(s + 1)G = 2Q, either of whose x-coordinate can be computed without y-coordinates.</p>

    <p class="text-gray-300">For certain special kinds of elliptic curve, computing only with x-coordinates is faster than other efficient implementation methods. For prime NIST curves, this does not seem to be the case. Montgomery has defined a class of prime field curves for which not using the y-coordinate provides some savings. For non-Koblitz binary fields, there are y-free formulae that are comparable in cost with at least some other efficient implementations.</p>

    <p class="text-gray-300">Suppose that one wants to compute k1G&lt;sup&gt;1&lt;/sup&gt; + · · · + kdGd, using x-coordinates only, or at least mostly. Bernstein gives an algorithm for doing this when d = 2. At each step, a triple of xcoordinates is computed. The three points whose x-coordinates are computed at each stage have differences of the form l1G&lt;sup&gt;1&lt;/sup&gt; + l2G&lt;sup&gt;2&lt;/sup&gt; where l1, l&lt;sup&gt;2&lt;/sup&gt; ∈ {−1, 0, 1}. Therefore Montgomery's formula can be used, once the x-coordinates of G&lt;sup&gt;1&lt;/sup&gt; + G&lt;sup&gt;2&lt;/sup&gt; and G&lt;sup&gt;1&lt;/sup&gt; − G&lt;sup&gt;2&lt;/sup&gt; are found using convential addition with y-coordinates. This paper modifies and extends Bernstein's algorith to d &gt; 2.</p>

    <p class="text-gray-300">Potential applications of d &gt; 2 include: batch ECC operations, accelerating Lenstra's ECM factoring algorithm, exploiting expanded ECC certificates (which contain pre-computed multiples of a party's public key), to incremental hashing based on elliptic curves, to accelerate verification of ECDSA signatures. Careful analysis is needed in each case to ascertain whether the algorithm presented outperforms existing efficient alternatives.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 The Algorithm</h2>

    <p class="text-gray-300">Suppose that we wish to compute a1P&lt;sup&gt;1&lt;/sup&gt; + · · · + adP&lt;sup&gt;d&lt;/sup&gt; using a Montgomery ladder, where the a&lt;sup&gt;i&lt;/sup&gt; are m bit positive integers. We do the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Execute the precomputation phase:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Precompute and store, or otherwise make available, all the (3&lt;sup&gt;d&lt;/sup&gt; − 1)/2 x-coordinates of points c1P&lt;sup&gt;1&lt;/sup&gt; + · · · + cdP&lt;sup&gt;d&lt;/sup&gt; where c&lt;sup&gt;i&lt;/sup&gt; ∈ {−1, 0, 1}, and the c&lt;sup&gt;i&lt;/sup&gt; are not all zero.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Execute the matrix phase, as follows.</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Allocate (m + 1) × d bit matrix A = (Ank) and two (d + 1) × d bit matrices B = (Bjk) and Cjk. Rows of A and B are indicated as A&lt;sup&gt;j&lt;/sup&gt; and B&lt;sup&gt;j&lt;/sup&gt; , respectively.</li>
      <li>(b) Allocate (d+ 1)×(m + 1) integer matrices F = (Fj,n) and G = (Gj,n), with entry values ranging from 0 to d + 1.</li>
      <li>(c) Allocate an (m + 1)-wide array of {−1, 0, 1}-valued (d + 1) × d matrices D&lt;sup&gt;j&lt;/sup&gt; .</li>
      <li>(d) Initialize A such that a&lt;sup&gt;k&lt;/sup&gt; = A0,k + 2A1,k + 22A2,k + . . . .</li>
      <li>(e) Initialize B as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. Let h be the number odd entries in row A&lt;sup&gt;0&lt;/sup&gt; (that is, the number of odd ak.</li>
      <li>ii. Let B&lt;sup&gt;h&lt;/sup&gt; = A0.</li>
      <li>iii. For each j &lt; h, let B&lt;sup&gt;j&lt;/sup&gt; be obtained from Bj+1 by subtracting one from a 1 valued entry (the choice of entry is arbitrary).</li>
      <li>iv. For each j &gt; h, let B&lt;sup&gt;j&lt;/sup&gt; be obtained from Bj−&lt;sup&gt;1&lt;/sup&gt; by adding one to a 0 valued entry (the choice of entry is arbitrary).</li>
    </ul></li>
      <li>(f) Let n = 0.</li>
      <li>(g) Let D&lt;sup&gt;n&lt;/sup&gt; = B.</li>
      <li>(h) Set D&lt;sup&gt;n&lt;/sup&gt; = Dn◦(−1)A&lt;sup&gt;1&lt;/sup&gt; , meaning to negate the columns of D in corresponding to positions A&lt;sup&gt;1&lt;/sup&gt; with value 1.</li>
      <li>(i) Set the value matrix C and entries of F and G as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. Set j ← 0.</li>
      <li>ii. Set R ← A&lt;sup&gt;0&lt;/sup&gt; + A&lt;sup&gt;1&lt;/sup&gt; mod 2.</li>
      <li>iii. Let h be the Hammning weight of R.</li>
      <li>iv. Let C&lt;sup&gt;h&lt;/sup&gt; = R.</li>
      <li>v. Let F0,n = G0,n = h.</li>
      <li>vi. Set R ← Bj+1 + CFj,n .</li>
      <li>vii. Let h be the Hamming weight of R.</li>
      <li>viii. If h &lt; Fj,n then    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Set Fj+1,n = h,</li>
      <li>B. Set Gj+1,n = Gj,n,</li>
    </ul></li>
    </ul></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Else</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">A. Set R ← Bj+1 + CGj,n ,</p></li>
      <li><p class="text-gray-300">B. Let h be the Hammning weight of R,</p></li>
      <li><p class="text-gray-300">C. Set Fj+1,n = Fj,n,</p></li>
      <li><p class="text-gray-300">D. Set Gj+1,n = h,</p></li>
      <li><p class="text-gray-300">ix. Set C&lt;sup&gt;h&lt;/sup&gt; = R.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>x. If j &lt; d − 1, then set j ← j + 1 and go back to Step 2(i)vi.</li>
    </ul></li>
      <li><p class="text-gray-300">(j) Set B ← C.</p></li>
      <li><p class="text-gray-300">(k) Drop row A&lt;sup&gt;0&lt;/sup&gt; from A, so that A&lt;sup&gt;j&lt;/sup&gt; ← Aj+1.</p></li>
      <li><p class="text-gray-300">(l) Unless n = m, set n ← n + 1, and go back to Step 2g.</p></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Execute the point addition phase:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(a) Initialize points Q0, . . . , Qd, as follows:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. Q&lt;sup&gt;j&lt;/sup&gt; ← Bj,1P&lt;sup&gt;1&lt;/sup&gt; + · · · + Bj,dPd. These points are among the precomputed points. Note that Q&lt;sup&gt;0&lt;/sup&gt; = ∞ and Q&lt;sup&gt;d&lt;/sup&gt; = P&lt;sup&gt;1&lt;/sup&gt; + · · · + Pd.</li>
    </ul></li>
      <li>(b) Compute points R0, . . . , R&lt;sup&gt;d&lt;/sup&gt; as follows :    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>i. R&lt;sup&gt;j&lt;/sup&gt; ← QFj,n + QGj,n .</li>
      <li>ii. When making above the computation, the difference of QFj,n −QGj,n is given by row j of matrix D&lt;sup&gt;n&lt;/sup&gt; , which means one look up the difference among the pre-computed points. Thus the y-coordinate is not needed to compute R&lt;sup&gt;j&lt;/sup&gt; from the Q points.</li>
    </ul></li>
      <li>(c) Set Q&lt;sup&gt;j&lt;/sup&gt; ← R&lt;sup&gt;j&lt;/sup&gt; for each j.</li>
      <li>(d) If n &gt; 0, then set n ← n − 1 and go back to Step 3b.</li>
      <li>(e) Let h be the number of a&lt;sup&gt;k&lt;/sup&gt; that are odd.</li>
      <li>(f) Output Qh.</li>
    </ul></li>
    </ul>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1 Example</h3>

    <p class="text-gray-300">Suppose that one wants to compute 10P&lt;sup&gt;1&lt;/sup&gt; + 14P&lt;sup&gt;2&lt;/sup&gt; + 9P&lt;sup&gt;3&lt;/sup&gt; + 11P&lt;sup&gt;4&lt;/sup&gt; using the algorithm above.</p>

    <p class="text-gray-300">The binary representations of the multiples 10, 14, 9, 11 are 10102, 11102, 10012, 10112, respectively. Therefore, we initiliaze a matrix A as</p>

    <p class="text-gray-300"><span class="math">$A = \\begin{pmatrix} 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\tag{1}</span>$</p>

    <p class="text-gray-300">where each column represnts a multipes with least significant bit at the top. A bottom row of all zeroes is appended for bookkeeping purposes. During the execution of the algorithm, the top row of A will be popped off. Equivalently, one can just move a pointer down a row, with the pointer starting at the top row.</p>

    <p class="text-gray-300">The three ways that A is used in the algorithm are (a) to initialize the matrix B, which is done using the top row only, (b) to update matrix B, which is done using the modulo two sum of the first and second rows, and (c) to add determines the signs of the D matrices, which is done using the second row.</p>

    <p class="text-gray-300">To initiliaze matrix B, first we take the top row of A, which has weight two. Therefore B&lt;sup&gt;2&lt;/sup&gt; = A&lt;sup&gt;0&lt;/sup&gt; (indexing the top row with 0). Rows B&lt;sup&gt;1&lt;/sup&gt; and B&lt;sup&gt;0&lt;/sup&gt; are obtained by replacing 1's with 0's and rows B&lt;sup&gt;3&lt;/sup&gt; and B4, by replacing 0's with 1's:</p>

    <p class="text-gray-300"><span class="math">$B = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\tag{2}</span>$</p>

    <p class="text-gray-300">We have thus used A to initialized B. The second use (b) of A uses the sum of consecutive rows, that is A&lt;sup&gt;0&lt;/sup&gt; + A1, A&lt;sup&gt;1&lt;/sup&gt; + A2, A&lt;sup&gt;2&lt;/sup&gt; + A&lt;sup&gt;3&lt;/sup&gt; and A&lt;sup&gt;3&lt;/sup&gt; + A4, which we compute below:</p>

    <p class="text-gray-300"><span class="math">$A_0 + A_1 = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 0 \\end{pmatrix} \\tag{3}</span>$</p>

    <p class="text-gray-300"><span class="math">$A_1 + A_2 = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\tag{4}</span>$</p>

    <p class="text-gray-300"><span class="math">$A_2 + A_3 = \\begin{pmatrix} 1 &amp; 0 &amp; 1 &amp; 1 \\end{pmatrix} \\tag{5}</span>$</p>

    <p class="text-gray-300"><span class="math">$A_3 + A_4 = \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\tag{6}</span>$</p>

    <p class="text-gray-300">(7)</p>

    <p class="text-gray-300">These sums of rows are used to update B and in turn determine the integer entries in the arrays F and G.</p>

    <p class="text-gray-300">We now update B, putting the results temporarily in another matrix C. By definition A&lt;sup&gt;0&lt;/sup&gt; + A&lt;sup&gt;1&lt;/sup&gt; must be row of C, and since it has weight 3, it will be row C3. Also we get F0,&lt;sup&gt;0&lt;/sup&gt; = G0,&lt;sup&gt;0&lt;/sup&gt; = 3.</p>

    <p class="text-gray-300">Now consider C&lt;sup&gt;3&lt;/sup&gt; + B&lt;sup&gt;1&lt;/sup&gt; = (1 1 1 1), which has weight 4, so must be row C4, and we get F0,&lt;sup&gt;1&lt;/sup&gt; = 3 and G0,&lt;sup&gt;1&lt;/sup&gt; = 4. Although not specified in the actual algorithm, we actually know that the entries of G cannot decrease and as 4 is the maximum, we will have G0,j = 4 for j &gt; 2. When G does not increase, then F decreases by one, so we get F0,&lt;sup&gt;2&lt;/sup&gt; = 2, F0,&lt;sup&gt;3&lt;/sup&gt; = 1 and F0,&lt;sup&gt;4&lt;/sup&gt; = 0. Also, we know that the value of F or G that differs from the previous iteration gives the index of the newly determined row of C, so rows C&lt;sup&gt;2&lt;/sup&gt; = B&lt;sup&gt;2&lt;/sup&gt; + C4, and C&lt;sup&gt;1&lt;/sup&gt; = B&lt;sup&gt;3&lt;/sup&gt; + C&lt;sup&gt;4&lt;/sup&gt; and C&lt;sup&gt;0&lt;/sup&gt; = B&lt;sup&gt;4&lt;/sup&gt; + C4. Now B is updated to this new value of C:</p>

    <p class="text-gray-300"><span class="math">$B \\leftarrow C = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\qquad \\begin{pmatrix} 4 \\\\ 3 \\\\ 2 \\\\ 0 \\\\ 1 \\end{pmatrix}</span>$
(8)</p>

    <p class="text-gray-300">where the column of integers indicates the order in which the rows of C were computed. The matrices F and G have been partially computed as follows:</p>

    <p class="text-gray-300"><span class="math">$F = \\begin{pmatrix} 3 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 3 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 2 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 1 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 0 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\end{pmatrix} \\qquad G = \\begin{pmatrix} 3 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 4 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 4 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 4 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\\\ 4 &amp; \\cdot &amp; \\cdot &amp; \\cdot \\end{pmatrix} \\tag{9}</span>$</p>

    <p class="text-gray-300">Now we repeat this process, starting with A&lt;sup&gt;1&lt;/sup&gt; + A&lt;sup&gt;2&lt;/sup&gt; which has parity two. Matrix B gets updated</p>

    <p class="text-gray-300">to</p>

    <p class="text-gray-300"><span class="math">$B \\leftarrow C = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\qquad \\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\\\ 2 \\\\ 3 \\end{pmatrix} \\tag{10}</span>$</p>

    <p class="text-gray-300">with the column again indicating the order of computing the rows of the updated B. Matrices F and G have been further filled out as follows:</p>

    <p class="text-gray-300"><span class="math">$F = \\begin{pmatrix} 3 &amp; 2 &amp; \\dots \\\\ 3 &amp; 1 &amp; \\dots \\\\ 2 &amp; 1 &amp; \\dots \\\\ 1 &amp; 1 &amp; \\dots \\\\ 0 &amp; 0 &amp; \\dots \\end{pmatrix} \\qquad G = \\begin{pmatrix} 3 &amp; 2 &amp; \\dots \\\\ 4 &amp; 2 &amp; \\dots \\\\ 4 &amp; 3 &amp; \\dots \\\\ 4 &amp; 4 &amp; \\dots \\\\ 4 &amp; 4 &amp; \\dots \\end{pmatrix}</span>$
(11)</p>

    <p class="text-gray-300">Though most of the work to obtain this updates have been left out, one can can see without any work that C&lt;sup&gt;2&lt;/sup&gt; = A1+A2. Working out the computation of the other rows one on own's is encouraged to appreciate what is involved. The reader may by now have noticed that we have been skipping the computation of the D matrices. We defer this because in this example, we will just look back at all the values B and adjust their signs using rows of A. Another update of B is given by:</p>

    <p class="text-gray-300"><span class="math">$B \\leftarrow C = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\qquad \\begin{pmatrix} 4 \\\\ 2 \\\\ 1 \\\\ 0 \\\\ 3 \\end{pmatrix}. \\tag{12}</span>$</p>

    <p class="text-gray-300">Matrices F and G have been further filled out as follows:</p>

    <p class="text-gray-300"><span class="math">$F = \\begin{pmatrix} 3 &amp; 2 &amp; 3 &amp; . \\\\ 3 &amp; 1 &amp; 2 &amp; . \\\\ 2 &amp; 1 &amp; 1 &amp; . \\\\ 1 &amp; 1 &amp; 1 &amp; . \\\\ 0 &amp; 0 &amp; 0 &amp; . \\end{pmatrix} \\qquad G = \\begin{pmatrix} 3 &amp; 2 &amp; 3 &amp; . \\\\ 4 &amp; 2 &amp; 3 &amp; . \\\\ 4 &amp; 3 &amp; 3 &amp; . \\\\ 4 &amp; 4 &amp; 4 &amp; . \\\\ 4 &amp; 4 &amp; 4 &amp; . \\end{pmatrix}</span>$
(13)</p>

    <p class="text-gray-300">The final update is</p>

    <p class="text-gray-300"><span class="math">$B \\leftarrow C = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix} \\qquad \\begin{pmatrix} 4 \\\\ 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix}. \\tag{14}</span>$</p>

    <p class="text-gray-300">Matrices F and G have been further finalized as:</p>

    <p class="text-gray-300"><span class="math">$F = \\begin{pmatrix} 3 &amp; 2 &amp; 3 &amp; 4 \\\\ 3 &amp; 1 &amp; 2 &amp; 3 \\\\ 2 &amp; 1 &amp; 1 &amp; 2 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\qquad G = \\begin{pmatrix} 3 &amp; 2 &amp; 3 &amp; 4 \\\\ 4 &amp; 2 &amp; 3 &amp; 4 \\\\ 4 &amp; 3 &amp; 3 &amp; 4 \\\\ 4 &amp; 4 &amp; 4 &amp; 4 \\\\ 4 &amp; 4 &amp; 4 &amp; 4 \\end{pmatrix}. \\tag{15}</span>$</p>

    <p class="text-gray-300">The difference matrices that we need are</p>

    <p class="text-gray-300"><span class="math">$D^{0} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -1 \\\\ 0 &amp; 0 &amp; 1 &amp; -1 \\\\ 0 &amp; -1 &amp; 1 &amp; -1 \\\\ -1 &amp; -1 &amp; 1 &amp; -1 \\end{pmatrix}, D^{1} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 1 &amp; -1 &amp; 0 &amp; 0 \\\\ 1 &amp; -1 &amp; 1 &amp; 1 \\end{pmatrix}, D^{2} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -1 \\\\ -1 &amp; 0 &amp; 0 &amp; -1 \\\\ -1 &amp; -1 &amp; 0 &amp; -1 \\\\ -1 &amp; -1 &amp; -1 &amp; -1 \\end{pmatrix}, D^{3} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{pmatrix}, (16)</span>$</p>

    <p class="text-gray-300">which are obtained by taking the successive B matrices (excluding the last one), and negating the columns where the corresponding rows of A (excluding the top row) have a one.</p>

    <p class="text-gray-300">The final bit matrix B, the integer matrices F and G and the difference matrices D&lt;sup&gt;0&lt;/sup&gt; , D&lt;sup&gt;1&lt;/sup&gt; , D&lt;sup&gt;2&lt;/sup&gt; , D&lt;sup&gt;3&lt;/sup&gt; make up the plan used for the point addition phase. The matrix B says how to initialize the the sequence of points. The matrices F and G say how to update the sequence of points, by virtue of which elements to add. The matrices D&lt;sup&gt;j&lt;/sup&gt; say how to determine the differences of the points being added, which is needed to the x-only Montgomery addition laws.</p>

    <p class="text-gray-300">We summarize the entire point addition phase in the following array</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{c|ccccccccccccccccccccccccccccccccccc</span>$</p>

    <p class="text-gray-300">Think of this as five 5 × 4 matrices whose rows of the form (r1, r2, r3, r4) represent computation of the point r1P&lt;sup&gt;1&lt;/sup&gt; + · · · + r4P4. It remains to explain how the plan leads to this computatain.</p>

    <p class="text-gray-300">The first of the five matrices is the final value of bit matrix B. To obtain the subsequent matrices we use the previous matrix and the matrices F and G and the D&lt;sup&gt;j&lt;/sup&gt; matrices. However, we must use the columns of F and G and the matrices D&lt;sup&gt;j&lt;/sup&gt; in the reverse order that they were obtained.</p>

    <p class="text-gray-300">For example, to obtain the third row of the second matrix, we note that that third row of the last column of F and G have the values two and four respecitvely, so therefore we add rows 2 and 4 of the first matrix to (0, 1, 0, 1) + (1, 1, 1, 1) = (1, 2, 1, 2). Here we have added using integer vector arithmetic, we are no longer working modulo two. In fact, there is no big integer arithmetic in the point addition phase, just point addition, so we actually be doing a single point addition, as follows:</p>

    <p class="text-gray-300"><span class="math">$(P_2 + P_4) + (P_1 + P_2 + P_3 + P_4) = (P_1 + 2P_2 + P_3 + 2P_4)</span>$
(18)</p>

    <p class="text-gray-300">where the additions inside the parenthesis on the left hand side were already done as part of the initialization, and the additions in the right hand side are achieve implicitly by the additions on the left hand side. The only point addition actually being done in this step is the one in the left hand side outside of the parentheses. Now (1, 1, 1, 1) − (0, 1, 0, 1) = (1, 0, 1, 0), which is row 2 (counting with 0 from top as usual) of the last difference matrix.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.2 Straightforward Simplifications</h3>

    <p class="text-gray-300">Evidently from the example, and from the theory numerous simplifications to the algorithm are possible. For example, the top row of B is always all zeros and the bottom row is always all ones. Similarly, the bottom row F is all zeros and the bottom row of G is always all d's. The top rows of F and G are identical and are determined by the weights of the sums of successive rows of A.</p>

    <p class="text-gray-300">Because the columns of F weakly fall, and the columns of G weakly rise, with exactly one rise or fall between rows, it follows that we use single bits to indicate whether F falls or G rises. Thus integers can be used for only for the common top row of F and G, if this has some advantage.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.3 Room for Improvement</h3>

    <p class="text-gray-300">It would be more convenient if the D matrices and columns of F and G could somehow be computed in the opposite order, because then one could interleave the bit matrix phase and the point addition phase. Technically, the total computation time might be the same whether or not one interleaves the two phases, but in practice interleaving may help slightly because mainly some implementations can do pipelining, effectively allowing independent computations to be done simultaneously. If the bit matrix phase has to be done first, during that the time the pipeline is unavailable for doing point additions.</p>

    <h2 id="sec-7" class="text-2xl font-bold">3 Why It Works</h2>

    <p class="text-gray-300">This section describes why the algorithm works. To do this, several definitions, lemmas and theorems about matrices are introduced.</p>

    <p class="text-gray-300">The algorithm has two phases, the matrix phase and the point addition phase. In the matrix phase, a plan, or ladder, is made of which intermediate integer combinations of the points that shall be computed on the way to the compute the target combination. The matrix phase uses integer matrices and does not involve any elliptic curve arithmetic. The point addition phase then uses this plan, or climbs the ladder, to add points together, for the most part not using y-coordinates, ultimately arriving at the target integer combination of points.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3.1 The Matrix Phase</h3>

    <p class="text-gray-300">We will use the following convention for indexing matrices. A matrix with d columns (rows) will have columns (rows) indexed by 1, 2, . . . , d, while a matrix with d + 1 rows (columns) will have rows (columns) indexed by 0, 1, 2, . . . , d. The parameter d is called the dimension, and will be the number of points that we wish to combine in the application of the algorithm. Write M&lt;sup&gt;j&lt;/sup&gt; for the row of a matrix M indexed by j under the conventions stated above . Write e&lt;sup&gt;i&lt;/sup&gt; for an elementary row vector that has a one in position i and zero in all other positions.</p>

    <p class="text-gray-300">Definition 1. A state matrix is a (d + 1) × d integer matrix S such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S&lt;sup&gt;j&lt;/sup&gt; − Sj+1 = ±e&lt;sup&gt;i&lt;/sup&gt; for some i.</li>
      <li>S&lt;sup&gt;j&lt;/sup&gt; has j odd entries.</li>
    </ul>

    <p class="text-gray-300">An example state matrix is</p>

    <p class="text-gray-300"><span class="math">$S = \\begin{pmatrix} S_0 \\\\ S_1 \\\\ S_2 \\\\ S_3 \\end{pmatrix} = \\begin{pmatrix} 28 &amp; 30 &amp; 18 \\\\ 28 &amp; 29 &amp; 18 \\\\ 29 &amp; 29 &amp; 18 \\\\ 29 &amp; 29 &amp; 19 \\end{pmatrix}. \\tag{19}</span>$</p>

    <p class="text-gray-300">Lemma 1. Any integer row vector R is the row of some state matrix S.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that R has j odd entries. Then set  <span class="math">S_j = R</span> . For  <span class="math">1 \\le i \\le j</span> , choose  <span class="math">S_{i-1}</span>  be adding  <span class="math">\\pm 1</span>  to one of the odd entries of  <span class="math">S_i</span> . For  <span class="math">j \\le i &lt; d</span> , choose row  <span class="math">S_{i+1}</span>  by adding  <span class="math">\\pm 1</span>  to one of the even entries.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> If S is a state and i &lt; j, the set of indices of odd entries of  <span class="math">S_i</span>  is a subset of the corresponding set for row  <span class="math">S_i</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> If suffices to prove this for j = i + 1, for which it is obvious.</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> A transition matrix is an  <span class="math">(d+1) \\times (d+1)</span>  integer matrix M such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">M_i = e_i + e_{i+j}</span>  for some i.</li>
      <li><span class="math">M_i M_{i+1} = \\pm (e_i e_{i+1})</span>  for some i.</li>
    </ul>

    <p class="text-gray-300">An example transition matrix is</p>

    <p class="text-gray-300"><span class="math">$M = \\begin{pmatrix} M_0 \\\\ M_1 \\\\ M_2 \\\\ M_3 \\end{pmatrix} = \\begin{pmatrix} 0 &amp; 0 &amp; 2 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix}. \\tag{20}</span>$</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> If M is a transition matrix and S is a state, then T = MS is a state.</p>

    <p class="text-gray-300"><em>Proof.</em> Now  <span class="math">T_j = M_j S</span> . Since  <span class="math">M_j = e_i + e_{i+j}</span> , we have  <span class="math">T_j = S_i + S_{i+j}</span> . By Lemma 2, the odd entries of  <span class="math">S_i</span>  will cancel i odd entries in  <span class="math">S_{i+j}</span> , leaving j entries as desired. To establish the second state property for T, we calculate that  <span class="math">T_j - T_{j+1} = (M_j - M_{j+1})S = \\pm (e_i - e_{i+1})S = \\pm (S_i - S_{i+1}) = \\pm e_k</span>  for some k.</p>

    <p class="text-gray-300"><strong>Theorem 4.</strong> If T is a state matrix, then there exists a unique state matrix S and unique transition matrix M, such that T = MS.</p>

    <p class="text-gray-300"><em>Proof.</em> We determine the rows of M in order,  <span class="math">M_0, M_1, \\ldots, M_d</span> , and the rows of S in an order to be determined. Suppose that  <span class="math">\\frac{1}{2}T_0</span>  has h odd entries. This implies that</p>

    <p class="text-gray-300"><span class="math">$M_0 = 2e_h</span>$
and  <span class="math">S_h = \\frac{1}{2}T_0</span> . (21)</p>

    <p class="text-gray-300">This is the base of the induction for determining the remaining rows. The induction will be on f and g such that  <span class="math">0 \\le f \\le g \\le d</span> , starting with f = g = h. At each stage of induction, rows  <span class="math">S_f, S_{f+1}, \\ldots, S_g</span>  and  <span class="math">M_0, \\ldots, M_{g-f}</span>  will have have been determined. Moreover we will have</p>

    <p class="text-gray-300"><span class="math">$M_{q-f} = e_f + e_q. (22)</span>$</p>

    <p class="text-gray-300">Let j = g - f + 1. By definition of transition matrices, we must have</p>

    <p class="text-gray-300"><span class="math">$M_i \\in \\{e_{f-1} + e_q, e_f + e_{q+1}\\}.</span>$
(23)</p>

    <p class="text-gray-300">In order for T = MS to hold, this must imply that</p>

    <p class="text-gray-300"><span class="math">$T_i \\in \\{S_{f-1} + S_a, S_f + S_{a+1}\\} \\tag{24}</span>$</p>

    <p class="text-gray-300">Therefore we need one of the following two equations to hold:</p>

    <p class="text-gray-300"><span class="math">$S_{f-1} = T_j - S_g</span>$</p>

    <p class="text-gray-300"><span class="math">S_{g+1} = T_j - S_f</span>  (25)</p>

    <p class="text-gray-300">Whichever these equations is valid will determine another row of the matrix S, namely, either Sf−&lt;sup&gt;1&lt;/sup&gt; or Sg+1. If T&lt;sup&gt;j&lt;/sup&gt; − S&lt;sup&gt;g&lt;/sup&gt; has f − 1 odd entries then we must have the equation for Sf−1. If T&lt;sup&gt;j&lt;/sup&gt; − S&lt;sup&gt;f&lt;/sup&gt; has g + 1 odd entries, we must have the equation for Sg+1.</p>

    <p class="text-gray-300">To show that exactly one of the conditions in (25) holds, note that Tj−&lt;sup&gt;1&lt;/sup&gt; = S&lt;sup&gt;f&lt;/sup&gt; + Sg, and that T&lt;sup&gt;j&lt;/sup&gt; has one more odd entry than Tj−1. The extra odd entry in T&lt;sup&gt;j&lt;/sup&gt; can must in a position where S&lt;sup&gt;f&lt;/sup&gt; has an even entry. The entry in that position can be even or odd for Sg. If it is even for Sg, then the equation for Sg+1 holds, and if odd, the equation for Sf−&lt;sup&gt;1&lt;/sup&gt; holds.</p>

    <p class="text-gray-300">To illustrate, let us apply the algorithm in the proof to</p>

    <p class="text-gray-300"><span class="math">$T = \\begin{pmatrix} T_0 \\\\ T_1 \\\\ T_2 \\\\ T_3 \\\\ T_4 \\end{pmatrix} = \\begin{pmatrix} 24 &amp; 28 &amp; 18 &amp; 22 \\\\ 24 &amp; 28 &amp; 18 &amp; 23 \\\\ 24 &amp; 29 &amp; 18 &amp; 23 \\\\ 25 &amp; 29 &amp; 18 &amp; 23 \\\\ 25 &amp; 29 &amp; 19 &amp; 23 \\end{pmatrix}. \\tag{26}</span>$</p>

    <p class="text-gray-300">As in the proof, we compute the rows of M and S one at a time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Row T&lt;sup&gt;0&lt;/sup&gt; = (24, 28, 18, 22), so S&lt;sup&gt;h&lt;/sup&gt; = 1 2 T&lt;sup&gt;0&lt;/sup&gt; = (12, 14, 9, 11). The number of odd entries of S&lt;sup&gt;h&lt;/sup&gt; is two, so h = 2, and M&lt;sup&gt;0&lt;/sup&gt; = 2e2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The next row of S to compute must be T&lt;sup&gt;1&lt;/sup&gt; − S&lt;sup&gt;2&lt;/sup&gt; = (12, 14, 9, 12), which has just one entry, so must be S1. Thus M&lt;sup&gt;1&lt;/sup&gt; = e&lt;sup&gt;1&lt;/sup&gt; + e2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The next row of S to compute is either S&lt;sup&gt;0&lt;/sup&gt; = T&lt;sup&gt;2&lt;/sup&gt; − S&lt;sup&gt;2&lt;/sup&gt; or S&lt;sup&gt;3&lt;/sup&gt; = T&lt;sup&gt;2&lt;/sup&gt; − S1, as in (25). Because T&lt;sup&gt;2&lt;/sup&gt; − S&lt;sup&gt;1&lt;/sup&gt; = (12, 15, 9, 11) has three odd entries, S&lt;sup&gt;3&lt;/sup&gt; is the choice. Thus M&lt;sup&gt;2&lt;/sup&gt; = e&lt;sup&gt;1&lt;/sup&gt; + e3.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The next row of S to comptue is either S&lt;sup&gt;0&lt;/sup&gt; = T&lt;sup&gt;3&lt;/sup&gt; − S&lt;sup&gt;3&lt;/sup&gt; or S&lt;sup&gt;4&lt;/sup&gt; = T&lt;sup&gt;3&lt;/sup&gt; − S1, depending on parity. The choice is S&lt;sup&gt;4&lt;/sup&gt; = T&lt;sup&gt;3&lt;/sup&gt; − S&lt;sup&gt;1&lt;/sup&gt; = (13, 15, 9, 11). Thus M&lt;sup&gt;3&lt;/sup&gt; = e&lt;sup&gt;1&lt;/sup&gt; + e4.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The last of S to be determined is thus S&lt;sup&gt;0&lt;/sup&gt; = T&lt;sup&gt;4&lt;/sup&gt; − S&lt;sup&gt;4&lt;/sup&gt; = (12, 14, 10, 12), and as always M&lt;sup&gt;4&lt;/sup&gt; = e&lt;sup&gt;0&lt;/sup&gt; + e4.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Therefore</p>

    <p class="text-gray-300">$$\\begin{pmatrix}
24 &amp; 28 &amp; 18 &amp; 22 \\
24 &amp; 28 &amp; 18 &amp; 23 \\
24 &amp; 29 &amp; 18 &amp; 23 \\
25 &amp; 29 &amp; 18 &amp; 23 \\
25 &amp; 29 &amp; 19 &amp; 23
\\end{pmatrix} = \\begin{pmatrix}
0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
12 &amp; 14 &amp; 10 &amp; 12 \\
12 &amp; 14 &amp; 9 &amp; 12 \\
12 &amp; 14 &amp; 9 &amp; 11 \\
12 &amp; 15 &amp; 9 &amp; 11 \\
13 &amp; 15 &amp; 9 &amp; 11
\\end{pmatrix}.$$
(27)</p>

    <p class="text-gray-300">Definition 3. For any matrix A, define |A| to the be maximum of the absolute values of the entries of A.</p>

    <p class="text-gray-300">Theorem 5. If S and T are state matrices, M is a transition matrix, and T = MS, then 2|S|−1 6 |T| 6 2|S|.</p>

    <p class="text-gray-300">Proof. By definition, |T| = |Tj,k| for some j and k. Now Tj,k = Si,k + S(i+j),k, by the properties of M. Therefore |T| 6 |Si,k| + |S(i+j),k| 6 2|S|.</p>

    <p class="text-gray-300">By definition, |S| = |Si,k| for some j and k. It is easy to see that there will some j such that M&lt;sup&gt;j&lt;/sup&gt; = e&lt;sup&gt;f&lt;/sup&gt; + e&lt;sup&gt;g&lt;/sup&gt; where i ∈ {f, g}. Then Tj,k = Sf,k + Sg,k. Without loss of generality, suppose that i = f. By properties of state matrices, Sg,k = Sf,k + σ, with σ ∈ {−1, 0, 1}. But |Sg,k| 6 |Sf,k| = |S|, so σ = 0, or it has the opposite sign to Sf,k. Noting that Tj,k = 2Si,k + σ, we see that |Tj,k| &gt; 2|Si,k| − 1, which gives |T| &gt; 2|S| − 1.</p>

    <p class="text-gray-300">Corollary 6. If S and T are state matrices, M is a transition matrix, and T = MS, then either |S| &lt; |T| or |T| = 1.</p>

    <p class="text-gray-300">Proof. Suppose that |T| 6 |S|. Then 2|T| − 1 6 2|S| − 1 6 |T|, and adding 1 − |T| to both ends gives |T| 6 1. The case |T| = 0 is impossible, because T has odd entries.</p>

    <p class="text-gray-300">Lemma 7. If S and T are state matrices, M is a transition matrix, T = MS, and |T| = 1, then S = T and M&lt;sup&gt;j&lt;/sup&gt; = e&lt;sup&gt;0&lt;/sup&gt; + e&lt;sup&gt;j&lt;/sup&gt; for all j.</p>

    <p class="text-gray-300">Proof. Since |T| = 1, row T&lt;sup&gt;0&lt;/sup&gt; = 0, because T&lt;sup&gt;0&lt;/sup&gt; has all even entries with absolute values at most one. Suppose that M satisfies M&lt;sup&gt;j&lt;/sup&gt; = e&lt;sup&gt;0&lt;/sup&gt; + e&lt;sup&gt;j&lt;/sup&gt; and S = T. Then S&lt;sup&gt;0&lt;/sup&gt; = T&lt;sup&gt;0&lt;/sup&gt; = 0 and T&lt;sup&gt;j&lt;/sup&gt; = S&lt;sup&gt;0&lt;/sup&gt; + S&lt;sup&gt;j&lt;/sup&gt; = S&lt;sup&gt;j&lt;/sup&gt; . Therefore T = MS. Because T factors uniquely, these choices of M and S are the only possibilities.</p>

    <p class="text-gray-300">Theorem 8. Let S be a state matrix. Then S factors uniquely as a product</p>

    <p class="text-gray-300"><span class="math">$S = AB \\dots CT \\tag{28}</span>$</p>

    <p class="text-gray-300">where: A, B, . . . , C are transition matrices, C&lt;sup&gt;0&lt;/sup&gt; 6= 2e0, and T is a state matrix with |T| = 1. Conversely, every such product is a state matrix.</p>

    <p class="text-gray-300">Proof. Immediate from the previous results.</p>

    <p class="text-gray-300">To illustrate, we give the following factorization</p>

    <p class="text-gray-300">$$\\begin{pmatrix}
12 &amp; 14 &amp; 10 &amp; 12 \\
12 &amp; 14 &amp; 9 &amp; 12 \\
12 &amp; 14 &amp; 9 &amp; 11 \\
12 &amp; 15 &amp; 9 &amp; 11 \\
13 &amp; 15 &amp; 9 &amp; 11
\\end{pmatrix} = \\begin{pmatrix}
0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
0 &amp; 0 &amp; 2 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} \\begin{pmatrix}
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
\\end{pmatrix} (29)$$</p>

    <p class="text-gray-300">Definition 4. Let A be a matrix or a vector. We write A &gt; 0 and say that A is nonnegative, if all entries of A are nonnegative.</p>

    <p class="text-gray-300">Theorem 9. If S and T are state matrices, M is a transition matrix, and T = MS, and T &gt; 0 if and only if S &gt; 0.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that  <span class="math">S \\ge 0</span> . Since  <span class="math">M \\ge 0</span>  and the product of nonnegative matrices is nonnegative, we then have  <span class="math">T = MS \\ge 0</span> .</p>

    <p class="text-gray-300">Suppose that  <span class="math">S \\not\\geq 0</span> . Then S has a negative entry  <span class="math">S_{i,k} &lt; 0</span> . It follows that  <span class="math">S_{l,k} \\leq 0</span>  for all l. There exists a j such that  <span class="math">T_{j,k} = S_{f,k} + S_{g,k}</span>  for some f and g, with  <span class="math">i \\in \\{f,g\\}</span> . It then follows that  <span class="math">T_{j,k} &lt; 0</span> , and thus  <span class="math">T \\not\\geq 0</span> .</p>

    <p class="text-gray-300"><strong>Lemma 10.</strong> If T is a state matrix, then it has rank d.</p>

    <p class="text-gray-300"><em>Proof.</em> Induction on |T|. For T=1, it is obvious. Otherwise T=MS for some state matrix S with |S|&lt;|T|. Because M is invertible, matrices T and S have the same rank.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Doubtlessly, because of the general interest of matrices in mathematics, there exist many different matrix factorization algorithms, perhaps some quite general. One may thus wonder if any of such algorithms cover the result above: here we speculate that they do not, mainly on the grounds that nobody would have had reason to consider the peculiar form of matrices that we needed to consider.</p>

    <p class="text-gray-300">Incidentally, transition matrices have determinant  <span class="math">\\pm 2</span> , because only one permuation is embeddable into the nonzero entries of M. Therefore, transition matrices are always invertible. State matrices are not square, so have neither determinant nor inverse. Although not needed for the multi-dimensional Montgomery ladder algorithm, one can amend the definition of state matrices by preprend a zeroth column, all of whose entries are equal to a power of two. If |T| = 1, the power of two should be one, and otherwise it should be  <span class="math">2^t</span>  where t is the number of transition matrices in the (28). These amended state matrices are invertible and have determinant  <span class="math">\\pm 2^t</span> .</p>

    <p class="text-gray-300">The number of transition matrices is  <span class="math">2^d</span> , which can be seen by starting from the last row, which is always  <span class="math">e_0 + e_d</span> , and noting that each successive row can have either the left entry or the right entry shifted one step in the opposite direction. The number of state matrices T with |T| = 1 is  <span class="math">2^d d!</span> , or just d! if T is also nonnegative. Therefore, the number of state matrices that factor into the form in (28) with t transition matrices is  <span class="math">2^{dt}(2^d - 1)d!</span> , or just  <span class="math">2^{d(t-1)}(2^d - 1)d!</span>  when counting only nonnegative state matrices.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">3.2 Difference Matrices</h4>

    <p class="text-gray-300">The point addition phases needs not only the transition matrices and the minimal state matrix, but it also needs the difference matrices (to be defined), so that Montgomery formula for point addition with x-coordinate only can be used.</p>

    <p class="text-gray-300">Let M be a state matrix, such that it rows of the form  <span class="math">M_j = e_f + e_g</span>  with  <span class="math">f \\leq g</span> . Define  <span class="math">\\hat{M}</span>  such that it rows of the form  <span class="math">\\hat{M}_j = e_f - e_g</span> . As usual, suppose that T is a state matrix factoring uniquely into as T = MS where M is a transition matrix and S is a state matrix. The difference matrix corresponding to T is the matrix  <span class="math">D = \\hat{M}S</span> . We note that a difference matrix D is actually a state matrix and that |D| = 1.</p>

    <p class="text-gray-300">A simple rule may be used to determine the difference matrix  <span class="math">D = (d_{j,k})</span>  corresponding to state matrix  <span class="math">T = (t_{j,k})</span> . If  <span class="math">t_{j,k}</span>  is even, then  <span class="math">d_{j,k} = 0</span> . Otherwise  <span class="math">t_{j,k} \\equiv d_{j,k} \\mod 4</span> .</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.3 Simplified Matrix Phase</h4>

    <p class="text-gray-300">One disadvantage of the methods given by §3.1 is the big integer arithmetic in the computation of the intermediate state matrices. A second disadvantage is the computation of the transition matrices in the matrix phase is in an order opposite to how they applied in the point addition</p>

    <p class="text-gray-300">phase, which means that matrix phase has to be complete before the addition phase can be begun. Therefore we develop some more theory that can be used to overcome these disadvantages.</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> Fix some  <span class="math">1 \\le c \\le d</span> . Let S be any state matrix S. Let S' the matrix obtained by deleting column c and the deleting the row in which the entry of column c does not equal the value in the row below.</p>

    <p class="text-gray-300"><strong>Lemma 11.</strong> If S is a state matrix for dimension d, then S' is a state matrix for dimension d-1.</p>

    <p class="text-gray-300"><em>Proof.</em> For any row vector R, let R' indicate the row vector with entry c deleted. For each j, we have  <span class="math">S&#x27;_j = (S_{j&#x27;})&#x27;</span>  where  <span class="math">j&#x27; \\in \\{j, j+1\\}</span> , with the choice depending on whether j lies below the deleted row of matrix S. Now  <span class="math">S&#x27;_j</span>  has j odd entries if j' = j, because the deleted entry of  <span class="math">S_{j&#x27;}</span>  is even, and  <span class="math">S&#x27;_j</span>  has j odd entries if j' = j + 1 because  <span class="math">S_{j&#x27;}</span>  has j' = j + 1 odd entries and one odd entry, in position c, is deleted to give j odd entries.</p>

    <p class="text-gray-300">Now  <span class="math">S&#x27;_j - S&#x27;_{j+1} \\in \\{(S_j - S_{j+1})&#x27;, (S_j - S_{j+2})&#x27;, (S_{j+1} - S_{j+2})&#x27;\\}</span> , depending on whether j lies above, at, or below the deleted row of the matrix S. Because S is a state matrix will have  <span class="math">i \\neq c</span>  such that  <span class="math">S_j - S_{j+1} = \\pm e_i</span> , and  <span class="math">S_j - S_{j+2} = \\pm e_i \\pm e_c</span>  and  <span class="math">S_{j+1} - S_{j+2} = \\pm e_i</span> . Upon deleteion of entry c, we see that  <span class="math">S&#x27;_j - S&#x27;_{j+1}</span>  has the form  <span class="math">\\pm e_i</span> .</p>

    <p class="text-gray-300"><strong>Theorem 12.</strong> If S and T are state matrices, M is a transition matrix, and T = MS, then T' = M'S' for some transition matrix M'.</p>

    <p class="text-gray-300">Proof. For any row vector R, let R' indicate the row vector with entry c deleted. For each j we have  <span class="math">T_j = S_f + S_g</span>  for some f and g. Therefore  <span class="math">(T_j)&#x27; = (S_f)&#x27; + (S_g)&#x27;</span> . We write  <span class="math">(T_j)&#x27; = T&#x27;_{j&#x27;}</span>  where  <span class="math">j&#x27; \\in \\{j, j+1\\}</span> , with the choice of value depending on whether j lies above or below the row deleted from T. Similarly, we write  <span class="math">(S_k)&#x27; = S&#x27;_{k&#x27;}</span>  where  <span class="math">k&#x27; \\in \\{k, k+1\\}</span> . Therefore, we have  <span class="math">T&#x27;_{j&#x27;} = S&#x27;_{f&#x27;} + S&#x27;_{g&#x27;}</span> . This means that T' = M'S' for matrix M' such that  <span class="math">M&#x27;_{j&#x27;} = e_{f&#x27;} + e_{g&#x27;}</span>  with the same values of indices as used previously. We need only now to show that M' is a transition matrix.</p>

    <p class="text-gray-300">To prove that M' is a transition matrix, we need to show both (a) that g' - f' = j' and (b) that successive rows of M' differ by  <span class="math">\\pm (e_i - e_{i+1})</span>  for some i.</p>

    <p class="text-gray-300">To show (a), consider the parity of the entries of rows of state matrices S' and T' (in other words, look at the Hamming weight modulo two). Since  <span class="math">T&#x27;_{j&#x27;}</span>  has j' odd entries, the f' odd entries of row  <span class="math">S&#x27;_{f&#x27;}</span>  are subset of the g' odd entries of row  <span class="math">S&#x27;_{g&#x27;}</span> , we must have j' = g' - f'.</p>

    <p class="text-gray-300">To show (b), consider that successive rows of T' differ in just one entry, with a difference of  <span class="math">\\pm 1</span> . Suppose that  <span class="math">T&#x27;_j - T&#x27;_{j+1} = \\pm e_i</span> . We may also suppose, because the work above, that  <span class="math">T&#x27;_j = S_f + S_g</span>  where g - f = j and  <span class="math">T&#x27;_{j+1} = S_e + S_h</span>  where h - e = j + 1. Therefore  <span class="math">\\pm e_i = S&#x27;_f + S&#x27;_g - S&#x27;_e - S&#x27;_h</span> . The columns of S' may be ordered according to in which row they become odd. The odd entried positions of  <span class="math">S&#x27;_f + S&#x27;_g</span>  correspond an interval, a contigous set of consecutive entries, in this ordering of the columns of S'. The same holds for  <span class="math">S&#x27;_e + S&#x27;_h</span> . The difference of these two sums of rows, has only one odd entry, so therefore, the corresponding intervals must overlap in all but one point. Moreover the interval for  <span class="math">S&#x27;_e + S&#x27;_h</span>  must extend that of  <span class="math">S&#x27;_f + S&#x27;_g</span>  by appending the next element either above or below. This implies that  <span class="math">(e,h) \\in \\{(f-1,g),(f,g+1)\\}</span> , which implies condition (b) for M' be a transition matrix.</p>

    <p class="text-gray-300">An application of Theorem 12, is that the all integers appearing the successive state matrices need not be computed multiple times for occurrence. Instead, one can reduce each column to dimension d = 1 for computing the values of the entries. Dimension d = 1 is the classical Montgomery method. An advantage of this observation is that values in the intermediate state matrix entries</p>

    <p class="text-gray-300">may be computed easily from the bit representations of the initial state matrix, as the following theorem illustrates.</p>

    <p class="text-gray-300"><strong>Theorem 13.</strong> For d = 1, let T be a state matrix of the form</p>

    <p class="text-gray-300"><span class="math">$T = \\begin{pmatrix} 2a_0 + 2a_{s+1} + 4a_{s+2} + 2^3 a_3 + \\dots \\\\ 1 + 2a_{s+1} + 4a_{s+2} + 2^3 a_3 + \\dots \\end{pmatrix}</span>$
(30)</p>

    <p class="text-gray-300">where  <span class="math">a_i \\in \\{0,1\\}</span> . Then for  <span class="math">s \\ge 1</span> , we have</p>

    <p class="text-gray-300"><span class="math">$T = M_{a_0+a_1} M_{a_1+a_2} \\dots M_{a_{s-1}+a_s} \\begin{pmatrix} 2a_s + 2a_{s+1} + 4a_{s+2} + \\dots \\\\ 1 + 2a_{s+1} + 4a_{s+2} + \\dots \\end{pmatrix}</span>$
(31)</p>

    <p class="text-gray-300">where  <span class="math">M_0 = M_2 = \\begin{pmatrix} 2 &amp; 0 \\\\ 1 &amp; 1 \\end{pmatrix}</span>  and  <span class="math">M_1 = \\begin{pmatrix} 0 &amp; 2 \\\\ 1 &amp; 1 \\end{pmatrix}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Induction on s. For s = 1, we can verify the result by inspecting each of four cases  <span class="math">(a_0, a_1) \\in \\{(0,0), (0,1), (1,0), (1,1)\\}</span>  individually. This covers the base of induction. Suppose (31) holds, then we shall show that it also holds with s replaced by s + 1. Let</p>

    <p class="text-gray-300"><span class="math">$S = \\begin{pmatrix} 2a_s + 2a_{s+1} + 4a_{s+2} + \\dots \\\\ 1 + 2a_{s+1} + 4a_{s+2} + \\dots \\end{pmatrix}</span>$
(32)</p>

    <p class="text-gray-300">so that (31) becomes  <span class="math">T = M_{a_1} M_{a_1+a_2} \\dots M_{a_{s-1}+a_s} S</span> . Now apply the base case of induction to matrix S, getting  <span class="math">S = M_{a_s+a_{s+1}} U</span> , where U has the desired form.</p>

    <p class="text-gray-300">This result represents a simplification to the procedure in this d=1, by overcoming both of the disadvantages mentioned earlier. The transition matrices can be computed using only manipulations of the bit representations of the entries of the initial state matrix T, and they can be computed in any order. Furthermore, the intermediate state matrices do not even need to be calculated, so no big integer arithmetic is required in the matrix phase. The output of the matrix phase only needs to include the transition matrices and the minimal state matrix.</p>

    <p class="text-gray-300">Note that traditionally, the Montgomery ladder is presented in a slightly different, but equivalent manner. The difference is that intermediate state matrices even and odd entries are occasionally swapped as needed, so that the transition operations depend on only a single bit in the representation, not two consecutive bits. The reason for us to use a slightly different form is to extend the algorithm to d &gt; 1 consistently with the methods already described.</p>

    <p class="text-gray-300">The first step of extending the simplification to d &gt; 1, is to recognize that the value entries in each column of the  <span class="math">s^{\\text{th}}</span>  intermediate state matrix may be represented by the bit values  <span class="math">(a_s, a_{s+1}, \\dots)</span>  in the notation of Theorem 13. The reduction of the intermediate state matrix modulo two, a binary matrix, together with the information  <span class="math">(a_s, a_{s+1}, \\dots)</span> , completely determines the full value of the intermediate state matrix. Therefore we may equivalent represent the state matrices as a pair (A, B) of binary matrices, where  <span class="math">A = (a_{j,k})</span>  encodes values like  <span class="math">a_s</span>  and  <span class="math">B = (b_{j,k})</span>  encodes the modulo two values of the state matrix. More precisely for state matrix  <span class="math">S = (s_{j,k})</span> , we have</p>

    <p class="text-gray-300"><span class="math">$s_{j,k} = 2a_{0,k}(1 - b_{j,k}) + b_{j,k} + 2a_{1,k} + 4a_{2,k} + 2^3 a_{3,k} + \\dots</span>$
(33)</p>

    <p class="text-gray-300">On the basis of Theorems 12 and 13, when transitioning to a smaller matrix, the effect on the A component of the state is precisely deletion of the zeroth row. Although the B component is itself a state matrix, the effect on B depends on A.</p>

    <p class="text-gray-300">To determine the effect on B, when transitioning down, we review how Theorem 4 takes a state matrix T and determines the unique transition matrix M and smaller state matrix S such that T = MS. The first step of the proof is to halve  <span class="math">T_0</span>  and examine the parity. We have  <span class="math">\\frac{1}{2}t_{0,k} = a_{0,k} + a_{1,k} + 2a_{2,k} + \\ldots</span>  Therefore h is the number of k such that  <span class="math">a_{0,k} + a_{1,k}</span>  is odd, and  <span class="math">S_h = \\frac{1}{2}T_0</span> . Let B' be the B component of S. Then we have  <span class="math">b&#x27;_{h,k} \\equiv a_{0,k} + a_{1,k} \\mod 2</span> . We may write this  <span class="math">B&#x27;_h \\equiv A_0 + A_1 \\mod 2</span> .</p>

    <p class="text-gray-300">We have determined  <span class="math">M_0</span>  and  <span class="math">S_h</span>  and  <span class="math">B&#x27;_h</span> , and next is to determine  <span class="math">M_1</span>  and  <span class="math">S_{h\\pm 1}</span>  and  <span class="math">B&#x27;_{h\\pm 1}</span> , for some choice of  <span class="math">h\\pm 1</span> . To do this, we consider  <span class="math">S_{h\\pm 1}=T_1-S_h=T_1-T_0+S_h</span> . But  <span class="math">(T_1-T_0)_k=(2a_{0,k}-1)(b_{1,k}-b_{0,k})=2a_{0,k}-1b_{1,k}</span> . Now  <span class="math">2a_{0,k}-1\\in\\{-1,1\\}</span> , and there is a unique value of k such that  <span class="math">b_{1,k}=1</span> . Now the next row to consider is h'=h+1 if, for this unique k, we have  <span class="math">b&#x27;_{h,k}=0</span>  and otherwise the next row to consider to consider is h'=h-1. In either case, we have  <span class="math">B&#x27;_{h&#x27;}\\equiv B&#x27;_h+B_1 \\mod 2</span> .</p>

    <p class="text-gray-300">Continuing, we just imitate the proof of Theorem 4, except that now the decisions made in that proof using rows of T and S are replaced by decision made using rows of B and B'. This can be done, since only the parities of the differences of rows of T and S are used to determine M and S.</p>

    <p class="text-gray-300">When implementing the algorithm, it is not necessary to actually the transition matrices M as matrices per se, because most the entries are 0. Instead, one can compute the values of f and g for each row, so that  <span class="math">M_j = e_f + e_g</span> . In the description of the algorithm the f values are put into a matrix F and the g values are put into a matrix G.</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">3.4 The Point Addition Phase</h4>

    <p class="text-gray-300">A row  <span class="math">(r_1, \\ldots, r_d)</span>  of a state will represent a point  <span class="math">r_1G_1 + \\cdots + r_dG_d</span>  whose x-coordinate we may compute. The difference of any two rows of a state has the form  <span class="math">(l_1, \\ldots, l_d)</span>  where  <span class="math">l_1, \\ldots, l_d \\in \\{-1, 0, 1\\}</span> . The Montgomery point addition formula will be used, with the aid of computation of  <span class="math">l_1G_1 + \\cdots + l_dG_d</span>  when needed. To compute a combination  <span class="math">k_1G + \\cdots + k_dG</span> , we first find a state with  <span class="math">(k_1, \\ldots, k_d)</span>  as a row. From this state, we will find a sequence successfully smaller states, related transition matrices, which are defined next.</p>

    <p class="text-gray-300">Therefore to compute  <span class="math">r_1G_1 + \\cdots + r_dG_d</span> . Find a state matrix T with  <span class="math">R = (r_1, \\dots, r_d)</span>  as a row. It will be convenient to write  <span class="math">G = (G_1, \\dots, G_d)</span> , and to write  <span class="math">RG = r_1G_1 + \\cdots + r_dG_d</span> , for any such row vector R in general.</p>

    <p class="text-gray-300">Now factor T per Theorem 8, which can be done efficiently. For each of the intermediate state matrix S in the factorization, and each row  <span class="math">S_j</span>  of the state matrix, we will calculate the elliptic curve point  <span class="math">S_jG</span> . Now S is obtained from a smaller state, say U, and  <span class="math">S_j = U_f + U_g</span>  for some rows of  <span class="math">U_f</span>  and  <span class="math">U_g</span>  of U. We calculate  <span class="math">S_jG = U_fG + U_gG</span> .</p>

    <h2 id="sec-12" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Adrian Antipa, René Struik, Rob Lambert, and Scott Vanstone provided extremely helpful discussions of this algorithm.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">References</h3>

    <p class="text-gray-300">To be added.</p>

`;
---

<BaseLayout title="Multi-Dimensional Montgomery Ladders for Elliptic Curves (2006/220)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2006 &middot; eprint 2006/220
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="multi-dimensional-montgomery-ladders-for-elliptic-curves-2006" />
  </article>
</BaseLayout>
