---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1049';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Counter-in-Tweak: Authenticated Encryption Modes for Tweakable Block Ciphers';
const AUTHORS_HTML = 'Thomas Peyrin, Yannick Seurin';

const CONTENT = `    <p class="text-gray-300">Thomas Peyrin and Yannick Seurin</p>

    <p class="text-gray-300">SPMS, NTU, Singapore ANSSI, Paris, France</p>

    <p class="text-gray-300">thomas.peyrin@ntu.edu.sg yannick.seurin@m4x.org</p>

    <p class="text-gray-300">May 22, 2017</p>

    <p class="text-gray-300"><strong>Abstract.</strong> We propose the Synthetic Counter-in-Tweak (SCT) mode, which turns a tweakable block cipher into a nonce-based authenticated encryption scheme (with associated data). The SCT mode combines in a SIV-like manner a Wegman-Carter MAC inspired from PMAC for the authentication part and a new counter-like mode for the encryption part, with the unusual property that the counter is applied on the tweak input of the underlying tweakable block cipher rather than on the plaintext input. Unlike many previous authenticated encryption modes, SCT enjoys provable security beyond the birthday bound (and even up to roughly 2 <em>n</em> tweakable block cipher calls, where <em>n</em> is the block length, when the tweak length is sufficiently large) in the nonce-respecting scenario where nonces are never repeated. In addition, SCT ensures security up to the birthday bound even when nonces are reused, in the strong nonce-misuse resistance sense (MRAE) of Rogaway and Shrimpton (EUROCRYPT 2006). To the best of our knowledge, this is the first authenticated encryption mode that provides at the same time close-to-optimal security in the noncerespecting scenario and birthday-bound security for the nonce-misuse scenario. While two passes are necessary to achieve MRAE-security, our mode enjoys a number of desirable features: it is simple, parallelizable, it requires the encryption direction only, it is particularly efficient for small messages compared to other nonce-misuse resistant schemes (no precomputation is required) and it allows incremental update of associated data.</p>

    <p class="text-gray-300"><strong>Keywords:</strong> authenticated encryption, tweakable block cipher, nonce-misuse resistance, beyond-birthday-bound security, CAESAR competition</p>

    <p class="text-gray-300"><em><sup>?</sup></em> c IACR 2016. This is the full version of the article submitted by the authors to the IACR and to Springer-Verlag in May 2016, which appears in the proceedings of CRYPTO 2016.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8"><strong>1 Introduction</strong></h3>

    <p class="text-gray-300">Background on Authenticated Encryption. Confidentiality and authenticity of data are the two main security properties that one must ensure when communicating over an insecure channel. In the symmetric key setting, it has long been known how to ensure both of them independently, e.g., starting from a secure block cipher, by using a suitable encryption mode for confidentiality [\\[BDJR97\\]](#page-27-0) and a block cipher-based MAC for authenticity [\\[BKR00\\]](#page-27-1). However, how exactly to combine both tools has long been left to the practitioners, leading to major security breaches <a href="#page-29-0">\\[Kra01,</a> <a href="#page-28-0">DR11,</a> [AP13\\]](#page-27-2). Sometimes, protocol designers even overlooked that authenticity was a necessary requirement besides confidentiality, as exemplified by padding oracle attacks [\\[Vau02\\]](#page-31-0). Even when the combination of the encryption and the MAC schemes is properly done, it might not be the most efficient solution, especially when the two parts rely on two different primitives. For these reasons, interest has shifted towards designing "integrated" Authenticated Encryption (AE) schemes ensuring jointly authenticity and confidentiality of data, which are more efficient and less likely to be incorrectly used. Besides, it has become standard for an AE scheme to have the ability to handle so-called associated data (AD), which are authenticated but not encrypted [\\[Rog02\\]](#page-30-0) (such a scheme was for a time called an AEAD scheme, but since this feature is so important in practice, virtually all modern AE schemes provide it; we will only talk of AE in this paper, implicitly meaning AEAD). Even though ad-hoc AE schemes were already used since a long time, the formal treatment of these constructions only started around 2000 <a href="#page-27-3">\\[BN00,</a> <a href="#page-27-4">BR00,</a> [KY06\\]](#page-29-1). At about the same time, provably secure AE designs started to appear, such as IAPM <a href="#page-29-2">\\[Jut01,</a> [Jut08\\]](#page-29-3), XCBC [\\[GD01\\]](#page-28-1), CCM [\\[WHF02\\]](#page-31-1), OCB <a href="#page-30-1">\\[RBB03,</a> [Rog04a\\]](#page-30-2), or GCM [\\[MV04\\]](#page-30-3). The CAESAR competition [\\[CAE\\]](#page-28-2) for authenticated encryption, started in 2014, recently put this research topic in the limelight. Various AE schemes were proposed, from purely ad-hoc designs to (tweakable) block cipher operating modes.</p>

    <p class="text-gray-300">Nonce-Misuse Resistance. Since most symmetric-key primitives (in particular block ciphers) from which AE schemes are built are deterministic, a random IV or a nonce (i.e., a value which must never be repeated for the same secret key) is a necessary ingredient for achieving strong security goals. Failing to ensure the corresponding requirement (high entropy for an IV, non-repetition for a nonce) can have dramatic consequences for security. For example, reusing a nonce just a single time for encrypting two messages in OCB completely breaks confidentiality: an attacker can immediately detect repeated message blocks since the corresponding ciphertext blocks will be equal. The non-repeating requirement on the nonce can be challenging to fulfill in some contexts, for example when encryption is implemented in a stateless device.<a href="#page-1-0">1</a> It is likely (and it has happened before) that some implementations will, e.g., simply generate nonces at random,</p>

    <p class="text-gray-300"><span id="page-1-0"></span><sup>1</sup> Similarly, the high-entropy requirement on the IV is hard to meet when no good randomness source is available.</p>

    <p class="text-gray-300">"hoping" that no collision will occur. For that reason, a recent trend in AE has been to design schemes achieving <em>nonce-misuse resistance</em>, which informally means that the impact on security of a nonce repetition should be as limited as possible. This goal was first put forward by Rogaway and Shrimpton [\\[RS06\\]](#page-30-4), who formalized the notion of <em>misuse-resistant AE</em> (MRAE). For a scheme enjoying this property, authenticity is not harmed by nonce repetitions, while confidentiality is only damaged insofar as the adversary can detect whether the same triple of nonce, AD and message values is repeated. Example of schemes achieving this security notion are EAX [\\[BRW04\\]](#page-28-3), SIV [\\[RS06\\]](#page-30-4), AEZ [\\[HKR15\\]](#page-29-4), or GCM-SIV [\\[GL15\\]](#page-28-4). Because the MRAE notion cannot be achieved for an online scheme (since each bit of the ciphertext must depend on every bit of the plaintext), Fleischmann <em>et al.</em> [\\[FFL12\\]](#page-28-5) proposed a relaxation of the MRAE notion called <em>online AE</em> (OAE), which can be achieved with a single pass on the input. Examples of schemes ensuring this security property are McOE [\\[FFL12\\]](#page-28-5), COPA <a href="#page-27-5">\\[ABL</a><sup>+</sup>13], or POET <a href="#page-27-6">\\[AFF</a><sup>+</sup>14]. However, the interest in the OAE notion has been recently reduced by some serious security concerns, notably the so-called chosen-prefix/secret-suffix (CPSS) generic attack [\\[HRRV15\\]](#page-29-5), that shares some similarities with the BEAST attack [\\[DR11\\]](#page-28-0).</p>

    <p class="text-gray-300">Birthday and Beyond-Birthday Security. Another important shortcoming of most AE operating modes is that they provide only birthday-bound security with respect to the block length of the underlying primitive. Since virtually all existing block ciphers have block length at most 128 bits (in particular the current block cipher standard AES), this means that security is lost at 2 <sup>64</sup> block cipher calls at best, which is low given modern security requirements (for 64-bit block ciphers, the situation is even more problematic). Moreover, this is rarely a problem with the tightness of the security proof: attacks matching the bound are often known. For example, Ferguson [\\[Fer02\\]](#page-28-6) described a simple collision-based attack on OCB that breaks authenticity with 2 <sup>64</sup> blocks of messages. Recently, some AE schemes providing security beyond the birthday bound (BBB) were proposed <a href="#page-29-6">\\[Iwa06,</a> [Iwa08\\]](#page-29-7), but they usually come at an expensive performance price. One could argue that using a double-block-length block cipher would provide the expected security, but this solution comes with an important efficiency penalty (as can be seen in generic double-block-length block cipher constructions) and would be highly problematic for hardware implementations where internal state size is a major contribution to the total area cost.</p>

    <p class="text-gray-300">AE from Tweakable Block Ciphers. Compared with a conventional block cipher, a tweakable block cipher (TBC) <em><sup>E</sup></em><sup>e</sup> takes an additional input called a <em>tweak</em> bringing inherent variability to the primitive (equivalently, a TBC can be seen as a family of block ciphers indexed by the tweak). In the same paper that formalized the corresponding security notion [\\[LRW02\\]](#page-29-8), it was pointed out that a TBC was a very convenient starting point for building various schemes. In particular, for AE schemes, two prominent examples are the sibling modes TAE [\\[LRW02\\]](#page-29-8) and ΘCB [\\[KR11\\]](#page-29-9) (the TBC-based generalization of OCB). They have "perfect" security in the sense that, when used with an ideal TBC, the advantage of any adversary is zero against confidentiality and close to 2 <sup>−</sup><em><sup>τ</sup></em> against</p>

    <p class="text-gray-300">authenticity, where <em>τ</em> is the tag length. However, as already pointed out, a weakness of both TAE and ΘCB (even when used with an ideal TBC) is that their security completely collapses as soon as a nonce is repeated. As a matter of fact, existing AE schemes built from an ideal TBC either ensure perfect security in the nonce-respecting scenario only (like TAE or ΘCB), or fulfill the weak OAE notion only (e.g. COPA, once recast to use an ideal TBC), or ensure MRAEsecurity but only up to the birthday bound, even if nonces are not repeated (like AEZ). The PIV construction by Shrimpton and Terashima [\\[ST13\\]](#page-31-2) allows to construct a variable-input-length TBC with BBB-security, which in turn allows to construct (via the Encode-then-Encipher method) an AEAD scheme with BBB-security against nonce-respecting adversaries and birthday-bound security against nonce-misusing ones. However, PIV requires as a building block a fixedinput-length TBC with <em>variable</em> tweak length (comparable to the maximal input length of the PIV construction), which in turn requires to appeal to universal hash functions with key length comparable to the maximal tweak length. Hence, the resulting AEAD scheme must use very large keys to ensure BBB-security for large messages. As of today, there is no AEAD scheme based on a fixed-tweak-length TBC that ensures both BBB-security in the nonce-respecting scenario and (at least) birthday-bound security in the nonce-misuse scenario. Yet this seems a very desirable goal since such a scheme would at the same time yield very high (BBB) security guarantees in the nominal, nonce-respecting use case and retain acceptable (birthday-bound) security when inadvertently misused.</p>

    <p class="text-gray-300">Our Contributions. In this paper, we propose the SCT (Synthetic Counterin-Tweak) nonce-based AE mode for tweakable block ciphers and prove that it ensures BBB-security in the nonce-respecting scenario, and birthday-bound security in the nonce-misuse scenario (in the strong MRAE sense [\\[RS06\\]](#page-30-4)). More precisely, for the nonce-respecting case, when using an ideal TBC with block length <em>n</em> and "effective" tweak length<a href="#page-3-0">2</a> <em>w</em>, SCT is secure as long as the total number of <em>n</em>-bit blocks in encryption/decryption adversarial queries is less than roughly 2 (<em>n</em>+<em>w</em>)<em>/</em>2 , which is always larger than 2 <em>n/</em>2 . The SCT mode requires two passes (as is inevitable for MRAE-security), but it is simple, parallelizable, it requires the encryption direction only, it is particularly efficient for small messages compared to other nonce-misuse resistant schemes (no precomputation is required) and it allows incremental update of associated data.</p>

    <p class="text-gray-300">With respect to how authentication and encryption are combined, our design draws inspiration from the SIV generic composition method [\\[RS06\\]](#page-30-4): the nonce <em>N</em>, the associated data <em>A</em>, and the message <em>M</em> are first input to a keyed function <em>FK</em>, yielding an pseudorandom initial value <em>IV</em> , which will serve as authentication tag. The message is then encrypted, using the generated <em>IV and the nonce N</em> (see Fig. <a href="#page-25-0">4\\)</a>. This "recycling" of the nonce in the encryption part of the mode is</p>

    <p class="text-gray-300"><span id="page-3-0"></span><sup>2</sup> The SCT mode uses 5 tweak prefixes to separate the different usages of the TBC. The "effective" tweak length is what remains once 3 bits have been used to encode the prefix.</p>

    <p class="text-gray-300">what makes our high-level construction (called NSIV) crucially different from SIV and allows to reach BBB-security in the nonce-respecting case.<a href="#page-4-0">3</a></p>

    <p class="text-gray-300">It remains to instantiate the two components of the NSIV construction, the keyed function <em>F<sup>K</sup></em> and the encryption scheme. Since we aim at BBB-security in the nonce-respecting case, a natural starting point for <em>F<sup>K</sup></em> is the Wegman-Carter paradigm <a href="#page-31-3">\\[WC81,</a> <a href="#page-28-7">Bra82,</a> [Sho96\\]](#page-30-5). Hence, we propose a nonce-based MAC mode called PWC (<em>Parallel Wegman-Carter</em>) which combines a xor-universal hash function inspired from PMAC <a href="#page-27-7">\\[BR02,</a> [Rog04a\\]](#page-30-2) applied to the AD and the message, and a simple pseudorandom function applied to the nonce. In order to achieve nonce-misuse resistance (which in general Wegman-Carter MACs do not provide), we add an additional encryption layer, which results in the EPWC (<em>Encrypted PWC</em>) mode.</p>

    <p class="text-gray-300">The real challenge lies in designing an encryption scheme which is BBB-secure in the nonce-respecting case. Since on one hand it seems hard to leverage on the non-repeating property of the nonce without actually giving the nonce as input to the encryption mode, and on the other hand we need to make use in some way of the pseudorandom IV computed from <em>FK</em>, <a href="#page-4-1">4</a> it appears that what we need to design is actually a <em>combined nonce- and IV-based encryption scheme</em> (<em>nivE scheme</em> for short). To the best of our knowledge, this notion has never appeared before, and we introduce it in this paper. The encryption mode that we propose, called CTRT (<em>CounTeR in Tweak</em>), is a counter-like mode with the unusual property that the counter is applied on the tweak input of the underlying TBC rather than on the plaintext input, where the nonce comes in. The combination of EPWC and CTRT through the NSIV construction (the IV generated by EPWC being used as initial counter in CTRT) yields the SCT mode, illustrated in Fig. <a href="#page-5-0">1.</a></p>

    <p class="text-gray-300">For completeness, we also describe the CTPWC (CTRT<em>-then-</em>PWC) mode, an <em>online</em> nonce-based AE scheme which combines in an "encrypt-then-MAC" manner a slight variant of the CTRT encryption mode and the PWC authentication mode. The security guarantees provided by CTPWC are similar to those of ΘCB, but it is roughly twice less efficient, so that we do not claim that it is of particularly high interest. One small advantage that we see for this mode compared with ΘCB is that the nonce length can be as large as the block length of the underlying TBC, whereas for ΘCB the sum of the nonce length and of the maximal length of encrypted messages must be less than the tweak length of the underlying tweakable block cipher, which might be restrictive in some settings (e.g., for KIASU-BC [\\[JNP14c\\]](#page-29-10)). It might also escape the patent issues which hindered the adoption of OCB.</p>

    <p class="text-gray-300">Instantiating the TBC. As just discussed, our new AE modes offer BBBsecurity (in the nonce-respecting case) when used with an ideal TBC. If one aims at leveraging this security level in the real world, one must instantiate</p>

    <p class="text-gray-300"><span id="page-4-0"></span><sup>3</sup> While SIV corresponds to generic composition method A4 in the nomenclature of Namprempre <em>et al.</em> [\\[NRS14\\]](#page-30-6), NSIV does not fit any of the NRS schemes.</p>

    <p class="text-gray-300"><span id="page-4-1"></span><sup>4</sup> This excludes for example a simple OCB-like encryption mode since it is only noncebased, not IV-based.</p>

    <p class="text-gray-300"><img src="_page_5_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-5-0"></span><strong>Fig. 1.</strong> The SCT mode, using a TBC  <span class="math">\\widetilde{E}</span>  with tweak space  <span class="math">\\{1,\\ldots,5\\}\\times\\mathcal{T}</span>  and domain  <span class="math">\\mathcal{X}=\\{0,1\\}^n</span> . For each call to  <span class="math">\\widetilde{E}_K</span> , the tweak enters left while the plaintext enters on top. We denote  <span class="math">\\widetilde{E}_K^i(T,X)</span>  for  <span class="math">\\widetilde{E}_K((i,T),X)</span>  and  <span class="math">\\widetilde{E}_K^{i/j}</span>  means that prefix i is used when the input block is complete and unpadded, whereas j is used when the input block is incomplete and padded. Function Inc is a cyclic permutation of  <span class="math">\\mathcal{T}</span> , and Conv is a regular function from  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{T}</span>  (e.g., truncation when  <span class="math">\\mathcal{X}=\\{0,1\\}^n</span>  and  <span class="math">\\mathcal{T}=\\{0,1\\}^w, w\\leq n</span> ).</p>

    <p class="text-gray-300">the TBC with care. Most existing TBCs are built from conventional block ciphers in a generic way, the prominent example being the XE/XEX construction [\\[Rog04a\\]](#page-30-2) which only ensures security up to the birthday bound. Hence, using XE/XEX in our schemes would in a sense waste their nice security promises.<a href="#page-6-0">5</a> To remedy this problem, one can use either generic TBC constructions with BBB-security <a href="#page-30-7">\\[Min09,</a> <a href="#page-29-11">LST12,</a> <a href="#page-29-12">LS13,</a> [Men15\\]](#page-30-8) (but they are often inefficient or provably secure in the ideal cipher model only), or ad-hoc TBC designs without known weaknesses. The second option was chosen for a number of CAESAR candidates <a href="#page-29-13">\\[JNP14a,</a> <a href="#page-29-14">JNP14b,</a> <a href="#page-29-10">JNP14c,</a> <a href="#page-28-8">GLS</a><sup>+</sup>14]. In fact, the SCT mode was explicitly designed as a replacement to the COPA mode used in versions 1.1 and 1.2 of CAESAR candidates Deoxys [\\[JNP14a\\]](#page-29-13) (128-bit blocks, 128-bit tweaks) and Joltik [\\[JNP14b\\]](#page-29-14) (64-bit blocks, 64-bit tweaks).<a href="#page-6-1">6</a> We refer to the submission documents of these two candidates for a detailed report on implementation results, which are quite competitive. Other potential candidates for instantiating the SCT mode are Scream <a href="#page-28-8">\\[GLS</a><sup>+</sup>14] and Threefish, the TBC on which the hash function Skein <a href="#page-28-9">\\[FLS</a><sup>+</sup>10] is based. There is currently a shift towards designing dedicated TBCs achieving higher security and efficiency than generic BC-based constructions, and we hope to see more and more TBC proposals that could be used with SCT.</p>

    <p class="text-gray-300">Open Problems and Future Work. The CTRT encryption scheme has the notable feature that its security degrades gracefully with the maximal number of repetitions of nonces: when the nonce repetitions are limited, security remains close to the security bound in the nonce-respecting case. In contrast, the security of the EPWC authentication mode (and more generally of any encrypted Wegman-Carter MAC) falls back to birthday bound as soon as the adversary can repeat one single nonce twice (see Remark <a href="#page-24-0">2</a> in Section <a href="#page-18-0">5\\)</a>. It remains a pending question to modify EPWC so that it provides graceful security degradation with the maximal number of nonce repetitions as well. This would make the resulting AE scheme a good candidate for high security in both nonce-respecting and nonce-misuse models for most practical scenarios. Another challenging open problem would be to construct an AE scheme which remains BBB-secure even when nonces are arbitrarily repeated. The main difficulty is to build a deterministic, stateless, BBB-secure MAC, which is known to be notably hard <a href="#page-31-4">\\[Yas11,</a> [DS11\\]](#page-28-10). Another possible direction for future work would be to design a mode similar to SCT using only one pass and achieving online nonce-misuse resistance in the OAE sense [\\[FFL12\\]](#page-28-5). Such a feature would allow users to smoothly choose the best security achievable, depending on whether two passes can be tolerated or not by the application. Finally, it would be interesting to analyze how to strengthen SCT against other misuse scenarios such as release of unverified plaintext <a href="#page-27-8">\\[ABL</a><sup>+</sup>14], and to study how its security is affected by tag truncation [\\[HKR15\\]](#page-29-4).</p>

    <p class="text-gray-300"><span id="page-6-0"></span><sup>5</sup> Similarly, the only reason why OCB is secure up to the birthday bound whereas ΘCB is "perfectly" secure is because it relies on XE/XEX for instantiating the TBC.</p>

    <p class="text-gray-300"><span id="page-6-1"></span><sup>6</sup> The tweak prefixes used in this paper were chosen for ease of exposition and are slightly different from the ones used in Deoxys and Joltik v1.3, which were chosen mainly for efficiency reasons.</p>

    <p class="text-gray-300">Organization. In Section <a href="#page-7-0">2</a> we provide a high-level description of the various possibilities that we considered for constructing a BBB-secure nivE scheme. After introducing the notation and standard security notions in Section <a href="#page-8-0">3,</a> we describe the CTRT encryption scheme and prove its security in Section <a href="#page-12-0">4,</a> while we describe the PWC and EPWC nonce-based MAC schemes and prove their security in Section <a href="#page-18-0">5.</a> Finally, we explain how to combine CTRT and EPWC using the NSIV construction to build the nonce-based AE mode SCT and prove its security in Section <a href="#page-24-1">6.</a> In Appendix <a href="#page-35-0">C,</a> we describe the CTPWC mode, an online nonce-based AE mode derived from CTRT and PWC.</p>

    <p class="text-gray-300">As motivated in introduction, our goal is to design a simple TBC-based AE scheme that provides BBB-security in the nonce-respecting setting and (at least) birthday-bound MRAE-security. As already mentioned, an encrypted Wegman-Carter MAC solves the problem for the authentication part, so that we focus here on encryption. Hence, our problem is as follows: given a nonce and a synthetic IV generated pseudorandomly from the nonce, the AD and the message, how do we use them to encrypt the message with BBB-security? We give a quick overview of the various constructions that we considered and why, except the CTRT encryption mode we propose, they fail or are unsatisfactory.</p>

    <p class="text-gray-300">A natural direction to explore is to start from a scheme providing BBB-security for non-repeating nonces, such as TAE [\\[LRW02\\]](#page-29-8) or ΘCB [\\[KR11\\]](#page-29-9), which are similar with regard to encryption: it simply consists in a "tweakable" codebook mode, the tweak holding the nonce and a message block counter. This is obviously not noncemisuse resistant: repeating the nonce a single time will lead to a complete break of confidentiality since a constant message block leads to a constant ciphertext block. One could incorporate the IV by simply concatenating it to the nonce and the counter to form the tweak. However, this would require a TBC with larger tweak, which is usually very costly to achieve.<a href="#page-7-1">7</a> Rather than concatenating the nonce and the IV, one could try to combine them into a single shorter string <em>S</em>, but this would presumably result in birthday security even in the nonce-respecting scenario (since a collision on <em>S</em> would directly break confidentiality). Hence, a codebook encryption mode does not seem to be a very convenient starting point.</p>

    <p class="text-gray-300">For this reason, we preferred to consider a counter mode (note that this was the encryption mode favored by Rogaway and Shrimpton to instantiate the SIV composition method [\\[RS06\\]](#page-30-4)). The question now is: how do we feed the nonce, the IV, and the <em>i</em>-th counter to the TBC in order to create the mask that will be xored to the <em>i</em>-th message block? We considered several possibilities (we do not claim this to be exhaustive):</p>

    <p class="text-gray-300">(a) One can put the nonce in the tweak input, and the sum of the IV and the counter in the plaintext input. The problem is that confidentiality caps at</p>

    <p class="text-gray-300"><span id="page-7-1"></span><sup>7</sup> For example, for TBCs following the TWEAKEY approach <a href="#page-29-13">\\[JNP14a,</a> <a href="#page-29-14">JNP14b,</a> [JNP14d\\]](#page-29-15), there is a large gap in the number of rounds needed to make the TBC secure as the tweak length increases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>birthday bound even in the nonce-respecting scenario: the adversary can query the encryption of a single message with 2 <em>n/</em>2 equal blocks, and observe that no collision occurs in the corresponding ciphertext blocks (since the nonce is fixed and all TBC calls use the same tweak), which will distinguish the ciphertext from a random string (for which a collision would be expected).</li>

      <li>(b) One can concatenate the nonce and the counter in the tweak input, and use the IV for the plaintext input. Since the tweak is different for each message block position, this solves the issue of the previous solution. We conjecture that this mode meets our security objectives, but an important drawback is that a larger tweak length is required and, as mentioned before, this is very costly.</li>

      <li>(c) One can put the sum of the nonce and the counter in the tweak input (instead of concatenating them) and the IV in the plaintext input. This mode might meet our security objectives, however the adversary can very easily provoke collisions on tweak inputs even in the nonce-respecting scenario, which might complicate the proof of BBB-security. Another drawback is that in the noncemisuse scenario, a collision on the IV immediately breaks confidentiality, which dashes any hope for BBB nonce-misuse resistance. Note that one could imagine variants where the nonce and the IV are first encrypted before being used, but it is not clear if this would prevent the issues just mentioned and this would presumably make the security proof quite complex.</li>

      <li>(d) Finally, one can put the sum of the IV and the counter in the tweak input and the nonce in the plaintext input, which is exactly the CTRT mode. We will prove in Section <a href="#page-12-0">4</a> that it meets our security goal. The first idea is that the counter in the tweak input ensures that all the calls to the internal TBC will use different tweaks for one single message query, so that the ciphertext looks uniformly random in that case. Thus, the adversary has to query several messages with different nonce values and hope that many collisions will occur between tweak inputs in order to observe a divergence from uniformity in the ciphertexts. However, these collisions are hard to control since they depend on the pseudorandom IV (in contrast with other modes discussed above, where the tweak input can be easily controlled by the adversary). Moreover, the nonce-misuse scenario helps the adversary only if it can repeat the same nonce a very high number of times until a collision happens on the tweaks, so that the security of the CTRT mode degrades gracefully with the maximal number of nonce repetitions.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notation. Given a string <em>X</em> ∈ {0<em>,</em> 1} ∗ ,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>X</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">denotes its length. If <em>X</em> and <em>Y</em> are respectively <em>n</em>-bit and <em>m</em>-bit strings, <em>n < m</em>, then <em>X</em> ⊕ <em>Y</em> denotes the <em>n</em>-bit string obtained by xoring <em>X</em> with the <em>n</em> leftmost bits of <em>Y</em> . Given some implicit length <em>n</em> and a bit-string <em>X</em> of length 1 ≤</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>X</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>< n</em>, we denote <em>X</em>10<sup>∗</sup> the string obtained by appending a single 1 and (<em>n</em> −</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>X</em></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">− 1) 0's to <em>X</em>. Given two sets X and Y, the set of all functions from X to Y is denoted Func(X <em>,</em> Y). A function <em>F</em> ∈ Func(X <em>,</em> Y) is said regular if all  <span class="math">Y \\in \\mathcal{Y}</span>  have the same number of preimages by F (this obviously requires  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  to be a multiple of  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TWEAKABLE BLOCK CIPHERS. A tweakable block cipher (TBC) with key space  <span class="math">\\mathcal{K}</span> , tweak space  <span class="math">\\mathcal{T}</span> , and domain  <span class="math">\\mathcal{X}</span>  is a mapping  <span class="math">\\widetilde{E}:\\mathcal{K}\\times\\mathcal{T}\\times\\mathcal{X}\\to\\mathcal{X}</span>  such that for any key  <span class="math">K\\in\\mathcal{K}</span>  and any tweak  <span class="math">T\\in\\mathcal{T},X\\mapsto\\widetilde{E}(K,T,X)</span>  is a permutation of  <span class="math">\\mathcal{X}</span> . We often write  <span class="math">\\widetilde{E}_K(T,X)</span>  or  <span class="math">\\widetilde{E}_K^T(X)</span>  in place of  <span class="math">\\widetilde{E}(K,T,X)</span> . We denote TBC( <span class="math">\\mathcal{K},\\mathcal{T},\\mathcal{X}</span> ) the set of all tweakable block ciphers with key space  <span class="math">\\mathcal{K}</span> , tweak space  <span class="math">\\mathcal{T}</span> , and domain  <span class="math">\\mathcal{X}</span> . A tweakable permutation with tweak space  <span class="math">\\mathcal{T}</span>  and domain  <span class="math">\\mathcal{X}</span>  is a mapping  <span class="math">\\widetilde{P}:\\mathcal{T}\\times\\mathcal{X}\\to\\mathcal{X}</span>  such that for any tweak  <span class="math">T\\in\\mathcal{T},X\\mapsto\\widetilde{P}(T,X)</span>  is a permutation of  <span class="math">\\mathcal{X}</span> . We often write  <span class="math">\\widetilde{P}^T(X)</span>  in place of  <span class="math">\\widetilde{P}(T,X)</span> . We denote TP( <span class="math">\\mathcal{T},\\mathcal{X}</span> ) the set of all tweakable permutations with tweak space  <span class="math">\\mathcal{T}</span>  and domain  <span class="math">\\mathcal{X}</span> . The security of a TBC is defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 1 (TPRP security).</strong> Let  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}, \\mathcal{X})</span>  and A be an adversary with oracle access to a tweakable permutation with tweak space  <span class="math">\\mathcal{T}</span>  and domain  <span class="math">\\mathcal{X}</span> . The advantage of A in breaking the TPRP-security of  <span class="math">\\widetilde{E}</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr} \\left[ K \\leftarrow_{\\<span class="math">} \\mathcal{K} : \\mathsf{A}^{\\widetilde{E}_K} = 1 \\right] - \\mathrm{Pr} \\left[ \\widetilde{P} \\leftarrow_{\\</span>} \\mathsf{TP}(\\mathcal{T}, \\mathcal{X}) : \\mathsf{A}^{\\widetilde{P}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that we do not need the strongest "two-sided" version of TPRP-security (where the adversary also has access to a decryption oracle) since all constructions considered in this paper only use the forward (encryption) direction of the underlying TBC.</p>

    <p class="text-gray-300">TWEAK SEPARATION. Let  <span class="math">\\widetilde{E}</span>  be a TBC with tweak space of the form  <span class="math">\\mathcal{T}&#x27; = \\mathcal{I} \\times \\mathcal{T}</span>  for some subset  <span class="math">\\mathcal{I} \\subset \\mathbb{N}</span>  and some set  <span class="math">\\mathcal{T}</span> . We call  <span class="math">\\mathcal{T}</span>  the effective tweak space of  <span class="math">\\widetilde{E}</span> . Then, for  <span class="math">i \\in \\mathcal{I}</span> , we denote  <span class="math">\\widetilde{E}^i</span>  the tweakable block cipher with the same key and message spaces as  <span class="math">\\widetilde{E}</span>  and tweak space  <span class="math">\\mathcal{T}</span>  defined by</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{E}^{i}(K,T,X) = \\widetilde{E}(K,(i,T),X).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the same convention as before, we write  <span class="math">\\widetilde{E}_K^i(T,X)</span>  or  <span class="math">\\widetilde{E}_K^{i,T}(X)</span>  for  <span class="math">\\widetilde{E}^i(K,T,X)</span> . Clearly, when  <span class="math">\\widetilde{E}</span>  is an ideal TBC drawn uniformly at random from  <span class="math">\\mathsf{TBC}(\\mathcal{K},\\mathcal{T}&#x27;,\\mathcal{M})</span> , then each  <span class="math">\\widetilde{E}^i</span>  is an independent ideal TBC drawn uniformly at random from  <span class="math">\\mathsf{TBC}(\\mathcal{K},\\mathcal{T},\\mathcal{M})</span> . Given a bit-string X of length  $1 \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n$ , we compactly write</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{E}^{i/j}(K,T,X(10^*)),\\quad \\widetilde{E}^{i/j}_K(T,X(10^*)),\\quad \\text{or}\\quad \\widetilde{E}^{i/j,T}_K(X(10^*))</span></div>

    <p class="text-gray-300">to mean <span class="math-block">\\widetilde{E}^i(K,T,X)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">when  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n<span class="math">  and  </span>\\widetilde{E}^j(K,T,X10^*)<span class="math">  when  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< n$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">STANDARD SECURITY NOTIONS. We give the security definitions of a nonce-based PRF, a nonce-based MAC, and a nonce-based Authenticated Encryption scheme. All these are standard, except maybe the nonce-based PRF notion which is a straightforward adaptation of the classical definition of a PRF to the nonce-based setting. Our definition of the security of a MAC is indistinguishability-based</p>

    <p class="text-gray-300">(which will be more convenient later), but it is easy to see that it is equivalent to the more conventional unforgeability-based definition. In the following, a nonce-based keyed function is a function  <span class="math">F: \\mathcal{K} \\times \\mathcal{N} \\times \\mathcal{D} \\to \\mathcal{Y}</span> , where  <span class="math">\\mathcal{K}</span>  is the key space,  <span class="math">\\mathcal{N}</span>  the nonce space,  <span class="math">\\mathcal{D}</span>  the domain and  <span class="math">\\mathcal{Y}</span>  the range.</p>

    <p class="text-gray-300"><span id="page-10-0"></span><strong>Definition 2 (Nonce-Based PRF).</strong> Let  <span class="math">F: \\mathcal{K} \\times \\mathcal{N} \\times \\mathcal{D} \\to \\mathcal{Y}</span>  be a nonce-based keyed function, and let us write  <span class="math">F_K(N,D)</span>  for F(K,N,D). Let A be an adversary with oracle access to a function from  <span class="math">\\mathcal{N} \\times \\mathcal{D}</span>  to  <span class="math">\\mathcal{Y}</span> . The advantage of A against the PRF-security of F is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\mathbf{Adv}_F^{\\mathrm{PRF}}(\\mathsf{A}) &= \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ K \\leftarrow_{\\<span class="math">} \\mathcal{K} : \\mathsf{A}^{F_K} = 1 \\right] \\\\ &amp;- \\Pr \\left[ R \\leftarrow_{\\</span>} \\mathsf{Func}(\\mathcal{N} \\times \\mathcal{D}, \\mathcal{Y}) : \\mathsf{A}^R = 1 \\right] \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The adversary is said nonce-respecting if it never repeats a nonce  <span class="math">N \\in \\mathcal{N}</span>  in its oracle queries. In that case, we denote its advantage  <span class="math">\\mathbf{Adv}_F^{\\mathrm{nPRF}}(\\mathsf{A})</span> .</p>

    <p class="text-gray-300"><span id="page-10-2"></span><strong>Definition 3 (Nonce-Based MAC).</strong> Let F be as in Definition 2. Let B be an adversary with oracle access to two oracles, the first oracle being a function from  <span class="math">\\mathcal{N} \\times \\mathcal{D}</span>  to  <span class="math">\\mathcal{Y}</span> , the second oracle with inputs in  <span class="math">\\mathcal{N} \\times \\mathcal{D} \\times \\mathcal{Y}</span>  and outputs in  <span class="math">\\{1, \\bot\\}</span> . The advantage of B against the MAC-security of F is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}_F^{\\mathrm{MAC}}(\\mathsf{B}) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[ K \\leftarrow_{\\<span class="math">} \\mathcal{K} : \\mathsf{B}^{F_K,\\mathsf{Ver}_K} = 1 \\right] - \\Pr\\left[ K \\leftarrow_{\\</span>} \\mathcal{K} : \\mathsf{B}^{F_K,\\mathsf{Rej}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\operatorname{Ver}_K</span>  is an oracle which takes as input a triple  <span class="math">(N,D,\\operatorname{tag}) \\in \\mathcal{N} \\times \\mathcal{D} \\times \\mathcal{Y}</span>  and returns 1 if  <span class="math">F_K(N,D) = \\operatorname{tag}</span> , and  <span class="math">\\bot</span>  otherwise, and  <span class="math">\\operatorname{Rej}</span>  is an oracle which always returns  <span class="math">\\bot</span> . The adversary is not allowed to ask a verification query  <span class="math">(N,D,\\operatorname{tag})</span>  if a previous query (N,D) to  <span class="math">F_K</span>  returned  <span class="math">\\operatorname{tag}</span> . The adversary is said nonce-respecting if it never repeats a nonce  <span class="math">N \\in \\mathcal{N}</span>  in its queries to the first oracle  <span class="math">F_K</span> . In that case, we denote its advantage  <span class="math">\\operatorname{Adv}_F^{\\operatorname{nMAC}}(\\mathsf{B})</span> .</p>

    <p class="text-gray-300">Note that in the general case where the adversary is allowed to repeat nonces, F can be seen as a standard (i.e., not nonce-based) keyed function with domain  <span class="math">\\mathcal{N} \\times \\mathcal{D}</span> , in which case one recovers the standard definitions of a PRF and a MAC (hence our notation of the advantage when the adversary is unrestricted w.r.t. nonces). While it is a well-known fact that if F is a secure PRF, then it is a secure MAC [BKR00, GGM86], we stress that this is not true for the nonce-based variants of the two notions, which are in fact incomparable.<sup>8</sup></p>

    <p class="text-gray-300">We then give the definition of a nonce-based Authenticated Encryption (nAE) scheme (with associated data), for which we first recall the syntax. Let  <span class="math">\\mathcal{K}</span> ,  <span class="math">\\mathcal{N}</span> ,  <span class="math">\\mathcal{A}</span> , and  <span class="math">\\mathcal{M}</span>  be non-empty sets. A nAE scheme is a tuple  <span class="math">\\Pi = (\\mathcal{K}, \\mathcal{N}, \\mathcal{A}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span> , where Enc and Dec are deterministic algorithms. The encryption algorithm Enc takes as input a key  <span class="math">K \\in \\mathcal{K}</span> , a nonce  <span class="math">N \\in \\mathcal{N}</span> , associated data  <span class="math">A \\in \\mathcal{A}</span> , and a</p>

    <p class="text-gray-300"><span id="page-10-1"></span> <span class="math">&lt;sup&gt;^8&lt;/sup&gt;</span>  E.g., an nPRF-secure function F might depend only on the nonce, in which case it is trivial to forge and break nMAC-security, while an nMAC-secure function F might have all its outputs starting with a 0 bit, which allows to trivially break nPRF-security.</p>

    <p class="text-gray-300">message  <span class="math">M \\in \\mathcal{M}</span> , and outputs a binary string  <span class="math">C \\in \\{0,1\\}^<em></span>  (we assume that Enc returns  <span class="math">\\bot</span>  if one of the inputs is not in the intended set). The decryption algorithm Dec takes as input a key  <span class="math">K \\in \\mathcal{K}</span> , a nonce  <span class="math">N \\in \\mathcal{N}</span> , associated data  <span class="math">A \\in \\mathcal{A}</span> , and a binary string  <span class="math">C \\in \\{0,1\\}^</em></span> , and outputs either a message  <span class="math">M \\in \\mathcal{M}</span> , or a special symbol  <span class="math">\\bot</span> . We require that  <span class="math">\\operatorname{Dec}(K,N,A,\\operatorname{Enc}(K,N,A,M)) = M</span>  for all tuples  <span class="math">(K,N,A,M) \\in \\mathcal{K} \\times \\mathcal{N} \\times \\mathcal{A} \\times \\mathcal{M}</span> . We write  <span class="math">\\operatorname{Enc}_K(N,A,M)</span>  for  <span class="math">\\operatorname{Enc}(K,N,A,M)</span>  and  <span class="math">\\operatorname{Dec}_K(N,A,C)</span>  for  <span class="math">\\operatorname{Dec}(K,N,A,C)</span> .</p>

    <p class="text-gray-300"><span id="page-11-1"></span><strong>Definition 4 (Nonce-Based AE).</strong> Let  <span class="math">\\Pi = (\\mathcal{K}, \\mathcal{N}, \\mathcal{A}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span>  be a nAE scheme. The advantage of an adversary  <span class="math">\\mathsf{A}</span>  in breaking  <span class="math">\\Pi</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\mathbf{Adv}^{\\mathrm{AE}}_{\\varPi}(\\mathsf{A}) &= \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ K \\leftarrow_{\\$} \\mathcal{K} : \\mathsf{A}^{\\varPi.\\mathsf{Enc}_{K}(\\cdot,\\cdot,\\cdot),\\,\\varPi.\\mathsf{Dec}_{K}(\\cdot,\\cdot,\\cdot)} = 1 \\right] \\\\ &- \\Pr \\left[ \\mathsf{A}^{\\mathsf{Rand}(\\cdot,\\cdot,\\cdot),\\,\\mathsf{Rej}(\\cdot,\\cdot,\\cdot)} = 1 \\right] \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where Rand is an oracle which on input  <span class="math">(N, A, M) \\in \\mathcal{N} \\times \\mathcal{A} \\times \\mathcal{M}</span>  outputs a random<sup>9</sup> string of length  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi.\\mathsf{Enc}_K(N,A,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and Rej is an oracle which always outputs  </span>\\bot<span class="math"> . The adversary is not allowed to make a decryption query (N,A,C) if a previous encryption query (N,A,M) returned C. The adversary is said noncerespecting if it never repeats a nonce  </span>N \\in \\mathcal{N}<span class="math">  in its encryption queries, in which case we denote its advantage  </span>\\mathbf{Adv}_n^{\\mathrm{nAE}}(A)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that in the general case where the adversary is allowed to repeat nonces,  <span class="math">\\Pi</span>  can be seen as a deterministic AE scheme [RS06] with header space (in the terms of [RS06])  <span class="math">\\mathcal{N} \\times \\mathcal{A}</span> , so that one exactly recovers the definition of the MRAE notion of Rogaway and Shrimpton [RS06] (which we simply abbreviate to AE here).</p>

    <p class="text-gray-300">ADVERSARY CHARACTERISTICS. In all the paper, given some implicit parameter n, a  <span class="math">(q, m, \\ell, \\sigma, t)</span> -adversary against a nonce-based scheme is an adversary:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>which makes at most q oracle queries; when the adversary has access to two oracles (i.e., when attacking the MAC-security of a keyed function or a nAE scheme), this means q queries in total to both oracles;</li>

      <li>which uses any nonce at most m times throughout its queries (m = 1 for a nonce-respecting adversary); when the adversary has access to two oracles, this only applies to queries to its first oracle (MAC or encryption oracle);</li>

      <li>such that the length of any of its queries (nonce excluded) is at most  <span class="math">\\ell</span>  blocks of n bits; for a keyed function with domain  <span class="math">\\mathcal{D} = \\mathcal{A} \\times \\mathcal{M}</span>  or a nAE scheme, this means that <em>both</em> the AD length and the message length of any query is at most  <span class="math">\\ell</span>  blocks of n bits;</li>

      <li>such that the total length of all its queries (nonce excluded) is at most  <span class="math">\\sigma</span>  blocks of n bits; for a keyed function with domain  <span class="math">\\mathcal{D} = \\mathcal{A} \\times \\mathcal{M}</span>  or a nAE scheme, this means the sum of the AD and the message length over all queries;</li>

      <li>which runs in time at most t.</li>

    </ul>

    <p class="text-gray-300"><span id="page-11-0"></span><sup>&</sup>lt;sup>9</sup> We assume that Rand returns the same output if a query is repeated.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">4.1 Syntax and Security of nivE Schemes</h4>

    <p class="text-gray-300">Most existing encryption schemes are either nonce-based [Rog04b] or IV-based [BDJR97], i.e., they employ an externally provided value which either should not repeat (nonce), or should be selected uniformly at random (IV). (See also [NRS14].) Here, we introduce the notion of combined nonce- and IV-based encryption scheme (nivE for short).</p>

    <p class="text-gray-300">Syntactically, a nivE scheme is a tuple  <span class="math">\\Pi = (\\mathcal{K}, \\mathcal{N}, \\mathcal{IV}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span>  where  <span class="math">\\mathcal{K}, \\mathcal{N}, \\mathcal{IV}</span>  and  <span class="math">\\mathcal{M}</span>  are non-empty sets and  <span class="math">\\mathsf{Enc}</span>  and  <span class="math">\\mathsf{Dec}</span>  are deterministic algorithms. The encryption algorithm  <span class="math">\\mathsf{Enc}</span>  takes as input a key  <span class="math">K \\in \\mathcal{K}</span> , a nonce  <span class="math">N \\in \\mathcal{N}</span> , an initial value  <span class="math">IV \\in \\mathcal{IV}</span> , and a message  <span class="math">M \\in \\mathcal{M}</span> , and outputs a binary string  <span class="math">C \\in \\{0,1\\}^<em></span>  (we assume that  <span class="math">\\mathsf{Enc}</span>  returns  <span class="math">\\bot</span>  if one of the inputs is not in the intended set). The decryption algorithm  <span class="math">\\mathsf{Dec}</span>  takes as input a key  <span class="math">K \\in \\mathcal{K}</span> , a nonce  <span class="math">N \\in \\mathcal{N}</span> , an initial value  <span class="math">IV \\in \\mathcal{IV}</span> , and a binary string  <span class="math">C \\in \\{0,1\\}^</em></span> , and outputs either a message  <span class="math">M \\in \\mathcal{M}</span> , or a special symbol  <span class="math">\\bot</span> . We require that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Dec}(K,N,IV,\\mathsf{Enc}(K,N,IV,M)) = M</span></div>

    <p class="text-gray-300">for all tuples  <span class="math">(K, N, IV, M) \\in \\mathcal{K} \\times \\mathcal{N} \\times \\mathcal{IV} \\times \\mathcal{M}</span> .</p>

    <p class="text-gray-300">We denote  <span class="math">\\mathsf{Enc}^\\$$  the probabilistic algorithm which takes as input  </span>(K,N,M) \\in \\mathcal{K} \\times \\mathcal{N} \\times \\mathcal{M}<span class="math"> , internally generates a uniformly random  </span>IV \\leftarrow_\\<span class="math"> \\mathcal{IV}</span> , computes  <span class="math">C = \\mathsf{Enc}(K,N,IV,M)</span> , and outputs  <span class="math">(IV,C) \\in \\mathcal{IV} \\times \\{0,1\\}^*</span> . We write  <span class="math">\\mathsf{Enc}_K(N,IV,M)</span>  for  <span class="math">\\mathsf{Enc}(K,N,IV,M)</span>  and  <span class="math">\\mathsf{Enc}_K^\\</span>(N,M)<span class="math">  for  </span>\\mathsf{Enc}(K,N,M)$ . The security of a nivE scheme is defined as follows.</p>

    <p class="text-gray-300"><strong>Definition 5 (Security of a nivE scheme).</strong> Let  <span class="math">\\Pi = (\\mathcal{K}, \\mathcal{N}, \\mathcal{IV}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span>  be a nivE scheme. The advantage of an adversary A in breaking  <span class="math">\\Pi</span>  is defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}_{II}^{\\mathrm{ivE}}(\\mathsf{A}) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ K \\leftarrow_{\\<span class="math">} \\mathcal{K} : \\mathsf{A}^{II.\\mathsf{Enc}_{K}^{\\</span>}(\\cdot,\\cdot)} = 1 \\right] - \\Pr \\left[ \\mathsf{A}^{\\mathsf{Rand}(\\cdot,\\cdot)} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where Rand is an oracle which on input  <span class="math">(N,M) \\in \\mathcal{N} \\times \\mathcal{M}</span>  outputs a random string of length  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi.\\mathsf{Enc}_K^{\\$}(N,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The adversary is said nonce-respecting if it never repeats a nonce  </span>N \\in \\mathcal{N}<span class="math">  in its oracle queries, in which case we denote its advantage  </span>\\mathbf{Adv}_H^{\\mathrm{nivE}}(\\mathsf{A})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Note that when the adversary is allowed to repeat nonces,  <span class="math">\\Pi</span>  can be seen as a family of purely IV-based encryption (ivE) schemes [NRS14] indexed by the nonce space  <span class="math">\\mathcal{N}</span> , hence our notation of the advantage in that case.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">4.2 Definition and Analysis of the CTRT Mode</h4>

    <p class="text-gray-300">We now define the CTRT (CounTeR in Tweak) mode, turning a tweakable block cipher into a nivE scheme. Let K and T be non-empty sets, and let</p>

    <pre><code class="language-text"> \\begin{cases} \\text{1} &amp; \\textbf{algorithm} \\ \\mathsf{CTRT}[\\widetilde{E}].\\mathsf{Enc}_K(N,IV,M) \\\\ \\text{2} &amp; \\ell := |M|/n \\\\ \\text{3} &amp; \\text{parse } M \\ \\text{as } M_1 \\| \\cdots \\| M_\\ell, \\ \\text{with } |M_1| = \\ldots = |M_{\\ell-1}| = n \\ \\text{and } 1 \\leq |M_\\ell| \\leq n \\\\ \\text{4} &amp; \\textbf{for } i = 1 \\ \\textbf{to} \\ \\ell \\ \\textbf{do} \\\\ \\text{5} &amp; C_i := M_i \\oplus \\widetilde{E}_K^{1,IV}(N) \\\\ \\text{6} &amp; IV := \\mathsf{Inc}(IV) \\\\ \\text{7} &amp; \\textbf{return } C_1 \\| C_2 \\| \\cdots \\| C_\\ell \\end{aligned}</code></pre>

    <p class="text-gray-300"><span id="page-13-1"></span><strong>Fig. 2.</strong> Definition of the CTRT mode, using a TBC  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{T}&#x27; = \\{1\\} \\times \\mathcal{T}</span>  and  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span> .</p>

    <p class="text-gray-300"> <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  be a tweakable block cipher with key space  <span class="math">\\mathcal{K}</span> , tweak space  <span class="math">\\mathcal{T}&#x27; = \\{1\\} \\times \\mathcal{T}</span> , and domain  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span> . Let Inc be a cyclic permutation of  <span class="math">\\mathcal{T}</span> . We construct from  <span class="math">\\widetilde{E}</span>  a nivE scheme  <span class="math">\\mathsf{CTRT}[\\widetilde{E}]</span>  with key space  <span class="math">\\mathcal{K}</span> , nonce space  <span class="math">\\mathcal{N} = \\mathcal{X} = \\{0,1\\}^n</span> , IV space  <span class="math">\\mathcal{IV} = \\mathcal{T}</span> , and message space  <span class="math">\\mathcal{M} = \\{0,1\\}^*</span>  as defined in Fig. 2 and illustrated on bottom of Fig. 1.</p>

    <p class="text-gray-300">The security of CTRT is captured by Theorem 1 below. Here  <span class="math">t_{\\mathsf{CTRT}}(\\sigma)</span>  is an upper bound on the time needed for computing  <span class="math">\\mathsf{CTRT}[\\widetilde{E}].\\mathsf{Enc}_K</span>  on inputs of total message length at most  <span class="math">\\sigma</span>  blocks of n bits when calls to  <span class="math">\\widetilde{E}_K</span>  cost unit time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-13-2"></span><strong>Theorem 1 (Security of CTRT).</strong> Let  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{X} = \\{0, 1\\}^n</span>  and  <span class="math">\\mathcal{T}&#x27; = \\{1\\} \\times \\mathcal{T}</span> . Let  <span class="math">\\mathsf{A}</span>  be a  <span class="math">(q, m, \\ell, \\sigma, t)</span> -adversary against  <span class="math">\\mathsf{CTRT}[\\widetilde{E}]</span>  with  $\\ell \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Then there exists an adversary  </span>\\mathsf{A}'<span class="math">  against the TPRP-security of  </span>\\widetilde{E}<span class="math"> , making at most  </span>\\sigma<span class="math">  oracle queries and running in time at most  </span>t + t_{\\mathsf{CTRT}}(\\sigma)$ , such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}^{\\mathrm{ivE}}_{\\mathsf{CTRT}[\\widetilde{E}]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}') + \\frac{2(m-1)\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In particular, if A is nonce-respecting (m = 1), one has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}^{\\mathrm{nivE}}_{\\mathsf{CTRT}[\\widetilde{E}]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}') + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Before proceeding to the proof, we comment the security bound of this theorem. Consider first the case of a nonce-respecting adversary A. Letting  <span class="math">\\mathcal{T} = \\{0,1\\}^w</span> , we see that  <span class="math">\\mathsf{CTRT}[\\widetilde{E}]</span>  is secure up to roughly  <span class="math">2^{(n+w)/2}</span>  message blocks, which is always larger than  <span class="math">2^{n/2}</span> . In particular, if w = n/2 (as e.g. for KIASU-BC [JNP14c]), then security is ensured up to roughly  <span class="math">2^{3n/4}</span>  message blocks. In the nonce-misuse scenario, note that the additional term  $2(m-1)\\sigma/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  remains small as long as nonces are not repeated too many times (e.g.  </span>m \\leq 100<span class="math"> ) and  </span>\\sigma \\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-13-0"></span> <span class="math">&lt;sup&gt;^{10}&lt;/sup&gt;</span>  The CTRT mode does not need tweak separation per se. We use a single 1 prefix in order to conveniently combine CTRT with EPWC later.</p>

    <p class="text-gray-300">turns into a birthday-like term only in the extreme case where a few nonces are repeated close to  <span class="math">\\sigma</span>  times. This means that a few nonce repetitions will not hurt and that nonces must be "seriously" mishandled before security goes down to birthday bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PROOF OF THEOREM 1. Fix a  $(q', m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\sigma, t)<span class="math"> -adversary A against CTRT </span>[\\widetilde{E}]<span class="math">  (we denote q&#x27; the maximal number of adversarial queries and will later use q for the actual number of queries in a specific attack). The first part of the proof is standard, and consists in introducing an intermediate game where all calls to  </span>\\widetilde{E}_K<span class="math">  in the CTRT construction are replaced by calls to a random tweakable permutation  </span>\\widetilde{P}<span class="math"> . Consider the following adversary A&#x27; against the TPRP-security of  </span>\\widetilde{E}<span class="math"> . Let  </span>G \\in \\{\\widetilde{E}_K, \\widetilde{P}\\}<span class="math">  be the oracle to which A&#x27; has access. Adversary A&#x27; runs A, answers its encryption queries (N, M) by drawing a random IV and executing the code in Fig. 2 on input (N, IV, M), replacing calls to  </span>\\widetilde{E}_K<span class="math">  by oracle calls to G, and finally outputs the same bit as A. Clearly, A&#x27; makes at most  </span>\\sigma<span class="math">  oracle queries and runs in time at most  </span>t + t_{\\text{CTRT}}(\\sigma)$ . Moreover, it is easy to see that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-14-1"></span> <span class="math-block">\\mathbf{Adv}^{\\mathrm{ivE}}_{\\mathsf{CTRT}[\\widetilde{E}]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}&#x27;) + \\delta, \\tag{1}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span id="page-14-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\widetilde{P} \\leftarrow_{\\<span class="math">} \\mathsf{TP}(\\mathcal{T}, \\mathcal{X}) : \\mathsf{A}^{\\mathsf{CTRT}[\\widetilde{P}].\\mathsf{Enc}^{\\</span>}} = 1 \\right] - \\Pr \\left[ \\mathsf{A}^{\\mathsf{Rand}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag{2}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and  <span class="math">\\mathsf{CTRT}[\\widetilde{P}]</span>  is a slight abuse of notation for the  <span class="math">\\mathsf{CTRT}</span>  construction based on an arbitrary tweakable permutation  <span class="math">\\widetilde{P}</span> .</p>

    <p class="text-gray-300">Upper bounding  <span class="math">\\delta</span>  is now a purely information-theoretic problem, so that we allow A to be computationally unbounded, and hence, wlog, deterministic. The adversary is now trying to distinguish between  <span class="math">\\mathsf{CTRT}[\\tilde{P}]</span>  for a random  <span class="math">\\tilde{P}</span>  (thereafter called the "real world") and  <span class="math">\\mathsf{Rand}</span>  (thereafter called the "ideal world"). We assume wlog that A always makes queries of length a multiple of the block length n, and of total length  <span class="math">\\sigma</span>  blocks (if not, we pad all queries whose final block is incomplete with zeros for free, which can only increase the adversary's advantage).</p>

    <p class="text-gray-300">Following the H-coefficients method [Pat08b, CS14], we summarize the interaction of A with its oracle in the so-called transcript of the attack</p>

    <div class="my-4 text-center"><span class="math-block">\\tau = ((N_1, M_1, IV_1, C_1), \\dots, (N_q, M_q, IV_q, C_q)),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">(N_i, M_i)</span>  denotes the <em>i</em>-th query of the attacker and  <span class="math">(IV_i, C_i)</span>  the corresponding answer of the oracle. Furthermore, we denote  $M_i = M_{i,1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M_{i,\\ell_i}<span class="math"> ,  </span>C_i = C_{i,1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{i,\\ell_i}<span class="math"> , where  </span>\\ell_i<span class="math">  is the number of blocks of the <em>i</em>-th message, and  </span>IV_{i,j} = \\ln c^{j-1}(IV_i)<span class="math">  the <em>j</em>-th counter for the <em>i</em>-th message,  </span>j = 1, \\ldots, \\ell_i<span class="math"> . Let  </span>\\Theta_{\\text{re}}<span class="math"> , resp.  </span>\\Theta_{\\text{id}}<span class="math"> , denote the distribution of the transcript in the real world, resp. ideal world. We say that a transcript  </span>\\tau<span class="math">  is A-attainable (or simply attainable) if the probability to obtain  </span>\\tau<span class="math">  in the ideal world is non-zero. Note that the number of queries q and the lengths of the queries  </span>\\ell_1, \\ldots, \\ell_q$  are themselves random variables</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(they can vary for distinct A-attainable transcripts), yet by the assumption that the attacker always asks the maximal number of allowed blocks throughout its queries, one always has  <span class="math">\\sum_{i=1}^{q} \\ell_i = \\sigma</span> .</p>

    <p class="text-gray-300">From  <span class="math">\\tau</span>  we define for each possible tweak  <span class="math">T \\in \\mathcal{T}</span>  the "load" of the tweak as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$L(T) =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\{(i, j) : IV_{i, j} = T\\}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In words, L(T) is the number of times the tweak T appears as a counter when encrypting the queries of the adversary. Clearly, one has</p>

    <p class="text-gray-300"><span id="page-15-0"></span> <span class="math-block">\\sum_{T \\in \\mathcal{T}} L(T) = \\sigma. \\tag{3}</span></p>

    <p class="text-gray-300">The proof relies on the fundamental lemma of the H-coefficients technique (see e.g. [CS14] for the proof).</p>

    <p class="text-gray-300"><span id="page-15-1"></span><strong>Lemma 1.</strong> Assume that the set of A-attainable transcripts is partitioned into two disjoint sets GoodT and BadT, and that there exists  <span class="math">\\varepsilon_1</span>  and  <span class="math">\\varepsilon_2</span>  such that for any  <span class="math">\\tau \\in \\mathsf{GoodT}</span> , one has</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\Pr\\left[\\Theta_{\\rm re} = \\tau\\right]}{\\Pr\\left[\\Theta_{\\rm id} = \\tau\\right]} \\ge 1 - \\varepsilon_1,</span></div>

    <p class="text-gray-300">and  <span class="math">\\Pr [\\Theta_{id} \\in \\mathsf{BadT}] \\leq \\varepsilon_2</span> . Then  <span class="math">\\delta \\leq \\varepsilon_1 + \\varepsilon_2</span> , with  <span class="math">\\delta</span>  as defined by (2).</p>

    <p class="text-gray-300">We say that an attainable transcript  <span class="math">\\tau</span>  is bad if one of the two following conditions are met:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(C-1) there exists  <span class="math">(i, j) \\neq (i&#x27;, j&#x27;)</span>  such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span>  and  <span class="math">N_i = N_{i&#x27;}</span> ;</li>

      <li>(C-2) there exists  <span class="math">(i, j) \\neq (i&#x27;, j&#x27;)</span>  such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span> ,  <span class="math">N_i \\neq N_{i&#x27;}</span> , and  <span class="math">M_{i,j} \\oplus C_{i,j} = M_{i&#x27;,j&#x27;} \\oplus C_{i&#x27;,j&#x27;}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that condition (C-1) can only be satisfied for a nonce-misuse adversary, since (by the assumption that the length of each query is at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  blocks of n bits so that counters do not loop)  </span>IV_{i,j} = IV_{i',j'}<span class="math">  requires  </span>i \\neq i'<span class="math"> , which implies that  </span>N_i \\neq N_{i'}<span class="math">  for a nonce-respecting adversary. Note also that the condition (C-2) can only be satisfied in the ideal world. Indeed, in the real world,  </span>M_{i,j} \\oplus C_{i,j} = \\widetilde{P}(IV_{i,j}, N_i)<span class="math">  and  </span>M_{i',j'} \\oplus C_{i',j'} = \\widetilde{P}(IV_{i',j'}, N_{i'})<span class="math"> , so that if  </span>IV_{i,j} = IV_{i',j'}<span class="math">  and  </span>N_i \\neq N_{i'}<span class="math">  one necessarily has  </span>M_{i,j} \\oplus C_{i,j} \\neq M_{i',j'} \\oplus C_{i',j'}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We let BadT be the set of bad transcripts, and GoodT be the set of attainable transcripts which are not bad, henceforth called good transcripts. We first consider good transcripts.</p>

    <p class="text-gray-300"><span id="page-15-2"></span><strong>Lemma 2.</strong> Let  <span class="math">\\tau \\in \\mathsf{GoodT}</span>  be a good transcript. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{\\Pr[\\Theta_{\\mathrm{re}} = \\tau]}{\\Pr[\\Theta_{\\mathrm{id}} = \\tau]} \\geq 1.</span></div>

    <p class="text-gray-300">Proof. Note that a good transcript has the property that for each  <span class="math">(i,j) \\neq (i&#x27;,j&#x27;)</span>  such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span> , one has  <span class="math">N_i \\neq N_i&#x27;</span>  and  <span class="math">M_{i,j} \\oplus C_{i,j} \\neq M_{i&#x27;,j&#x27;} \\oplus C_{i&#x27;,j&#x27;}</span> . In other words, the transcript encodes a partial tweakable permutation, where for each tweak  <span class="math">T \\in \\mathcal{T}</span>  there are exactly L(T) distinct values  <span class="math">N_i</span>  mapped to some value  <span class="math">M_{i,j} \\oplus C_{i,j}</span> . The probability to obtain a good transcript  <span class="math">\\tau</span>  in the ideal and real worlds can now be easily computed. In the ideal world, since the  <span class="math">IV_i</span> 's and the  <span class="math">C_i</span> 's are uniformly random, one has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr[\\Theta_{id} = \\tau] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}\\mathcal{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^q \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^\\sigma}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the real world, the  <span class="math">IV_i</span> 's are random as well, but now the probability to obtain the  <span class="math">C_i</span> 's can easily be seen to be the probability that the random tweakable permutation  <span class="math">\\widetilde{P}</span>  is compatible with the partial tweakable permutation encoded by  <span class="math">\\tau</span>  [CS14]. Hence, one has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr[\\Theta_{\\mathrm{re}} = \\tau] = \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{I}\\mathcal{V}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^q} \\cdot \\prod_{T \\in \\mathcal{T}} \\frac{1}{(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)_{L(T)}},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">(a)_b</span>  denotes the falling factorial  <span class="math">a(a-1)\\cdots(a-b+1)</span> , with  <span class="math">(a)_0=1</span>  by convention. From this and Eq. (3), we deduce that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\Pr[\\Theta_{\\text{re}} = \\tau]}{\\Pr[\\Theta_{\\text{id}} = \\tau]} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{\\sigma}}{\\prod_{T \\in \\mathcal{T}} (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)_{L(T)}} = \\prod_{T \\in \\mathcal{T}} \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{L(T)}}{(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)_{L(T)}} \\ge 1.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to upper bound the probability to obtain a bad transcript in the ideal world. For  <span class="math">i \\in \\{1, 2\\}</span> , let  <span class="math">\\mathsf{BadT}_i</span>  be the set of attainable transcripts satisfying condition (C-i). We first consider condition (C-1).</p>

    <p class="text-gray-300"><span id="page-16-0"></span>Lemma 3. One has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\Theta_{\\mathrm{id}} \\in \\mathsf{BadT}_1\\right] \\leq \\frac{2(m-1)\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Proof.</em> Consider two distinct queries  <span class="math">(N_i, M_i)</span>  and  <span class="math">(N_{i&#x27;}, M_{i&#x27;})</span> . If the nonces are the same  <span class="math">(N_i = N_{i&#x27;})</span> , then the probability, over the random draw of  <span class="math">IV_i</span>  and  <span class="math">IV_{i&#x27;}</span>  in  <span class="math">\\mathcal{T}</span> , that there exists j and j' such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span> , is  $(\\ell_i + \\ell_{i'} - 1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . If the nonces are distinct, then clearly condition (C-1) cannot be satisfied for i and i'. Hence, summing over all possible nonces, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\Theta_{\\mathrm{id}} \\in \\mathsf{BadT}_1\\right] \\leq \\sum_{\\substack{N \\in \\mathcal{N} \\\\ N_i = N_{t'} = N}} \\frac{\\ell_i + \\ell_{i'} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fix some nonce N, and assume for notational simplicity that the first q' queries use nonce N, with  <span class="math">q&#x27; \\leq m</span>  by assumption. Then the probability that condition</p>

    <p class="text-gray-300">(C-1) is met for nonce N is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\sum_{i=1}^{q'-1} \\sum_{i'=i+1}^{q'} \\frac{\\ell_i + \\ell_{i'} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\le \\sum_{i=1}^{q'-1} \\frac{(q'-1)\\ell_i + \\ell(N)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$$\\le \\frac{2(m-1)\\ell(N)}{</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathcal{T}</td>

            <td class="px-3 py-2 border-b border-gray-700">},$$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where  <span class="math">\\ell(N)</span>  is the total length of queries using nonce N. The result follows by summing over all possible nonces, using  <span class="math">\\sum_{N \\in \\mathcal{N}} \\ell(N) = \\sigma</span> .</p>

    <p class="text-gray-300">We handle condition (C-2) in the following lemma.</p>

    <p class="text-gray-300"><span id="page-17-0"></span>Lemma 4. One has</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\Theta_{\\mathrm{id}} \\in \\mathsf{BadT}_2\\right] \\leq \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix any two distinct pairs of indices  <span class="math">(i,j) \\neq (i&#x27;,j&#x27;)</span>  such that  <span class="math">N_i \\neq N_{i&#x27;}</span> . If i=i', then necessarily  <span class="math">IV_{i,j} \\neq IV_{i&#x27;,j&#x27;}</span>  by the assumption that the length of any encryption query is at most  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  blocks of n bits so that counters do not loop, and hence condition (C-2) cannot be fulfilled for this pair of indices. Assume now that  </span>i \\neq i'<span class="math"> . Since  </span>IV_{i,j} = \\operatorname{Inc}^{j-1}(IV_i)<span class="math">  and  </span>IV_{i',j'} = \\operatorname{Inc}^{j'-1}(IV_{i'})<span class="math">  where  </span>IV_i<span class="math">  and  </span>IV_{i'}<span class="math">  are uniformly random and independent, and since  </span>\\operatorname{Inc}<span class="math">  is a cyclic permutation of  </span>\\mathcal{T}<span class="math"> , we have that  </span>IV_{i,j} = IV_{i',j'}<span class="math">  with probability  </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Besides, since in the ideal world  </span>C_{i,j}<span class="math">  and  </span>C_{i',j'}<span class="math">  are uniformly random and independent in  </span>\\mathcal{X}<span class="math"> , we have that  </span>M_{i,j} \\oplus C_{i,j} = M_{i',j'} \\oplus C_{i',j'}<span class="math">  with probability  </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Summing over the at most  </span>\\sigma^2/2$  pairs of indexes, we get the result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Completing the Proof of Theorem 1. From Lemmas 3 and 4, we obtain by the union bound that</p>

    <p class="text-gray-300"><span id="page-17-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\Theta_{\\mathrm{id}} \\in \\mathsf{BadT}\\right] \\le \\frac{2(m-1)\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.\\tag{4}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Eq. (4) with Lemmas 1 and 2 (taking  <span class="math">\\varepsilon_1 = 0</span> ), we obtain the same upper bound on the information-theoretic distinguishing advantage  <span class="math">\\delta</span>  (defined by Eq. (2)), i.e.,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta \\le \\frac{2(m-1)\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, Eq. (1) yields the result.</p>

    <p class="text-gray-300">VARIANTS. In Appendix B, we describe two variants of CTRT, a purely noncebased one and a purely IV-based one.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">5 The PWC and EPWC Message Authentication Codes</h4>

    <p class="text-gray-300">In this section, we describe two related modes for message authentication, PWC (Parallel Wegman-Carter) and EPWC (Encrypted PWC). Let  <span class="math">\\mathcal{K}</span>  and  <span class="math">\\mathcal{T}</span>  be two sets, and let  <span class="math">\\widetilde{E}</span>  be a tweakable block cipher with key space  <span class="math">\\mathcal{K}</span> , tweak space<sup>11</sup>  <span class="math">\\mathcal{T}&#x27; = \\{2, \\ldots, 5\\} \\times \\mathcal{T}</span> , and domain  <span class="math">\\mathcal{X} = \\{0, 1\\}^n</span> . Let Inc be a cyclic permutation of  <span class="math">\\mathcal{T}</span> . From  <span class="math">\\widetilde{E}</span> , we construct two nonce-based keyed functions, PWC[ <span class="math">\\widetilde{E}</span> ] and EPWC[ <span class="math">\\widetilde{E}</span> ], both with key space  <span class="math">\\mathcal{K}</span> , nonce-space  <span class="math">\\mathcal{N} = \\mathcal{X} = \\{0, 1\\}^n</span> , domain  <span class="math">\\mathcal{D} = \\mathcal{A} \\times \\mathcal{M}</span> , where  <span class="math">\\mathcal{A} = \\mathcal{M} = \\{0, 1\\}^*, ^{12}</span>  and range  <span class="math">\\mathcal{Y} = \\mathcal{X} = \\{0, 1\\}^n</span> , as defined in Fig. 3 and illustrated on top of Fig. 1 (for PWC, just omit the final call to  <span class="math">\\widetilde{E}_K^{4,0}</span> ). We will prove that both PWC[ <span class="math">\\widetilde{E}</span> ] and EPWC[ <span class="math">\\widetilde{E}</span> ] are  <span class="math">2^n</span> -secure as nonce-based MAC and nonce-based PRF, and that EPWC[ <span class="math">\\widetilde{E}</span> ] is moreover a birthday bound-secure PRF in the nonce-misuse scenario.</p>

    <p class="text-gray-300">The PWC construction follows the Wegman-Carter paradigm [WC81, Bra82, Sho96] by combining a xor-universal hash function H inspired from PMAC [BR02, Rog04a] applied to (A, M), and a pseudorandom function F applied to the nonce N. This pseudorandom function is constructed from  <span class="math">\\widetilde{E}</span>  by summing two independent pseudorandom permutations in order to obtain security beyond the birthday bound [Luc00]. The EPWC construction is simply PWC with an additional layer of encryption to provide nonce-misuse resistance.</p>

    <p class="text-gray-300">Before stating and proving the security results for (E)PWC, we focus on how to obtain the BBB-secure pseudorandom function F from  <span class="math">\\widetilde{E}</span> . A straightforward way would be to "put the nonce in the tweak", e.g.,</p>

    <div class="my-4 text-center"><span class="math-block">F_K&#x27;(N) = \\widetilde{E}_K^{6,N}(0).</span></div>

    <p class="text-gray-300">This would result in a uniformly random value for each new nonce, but this is only possible when the intended nonce space is smaller than the effective tweak space  <span class="math">\\mathcal{T}</span>  of  <span class="math">\\widetilde{E}</span> . In order to allow the nonce length to be as large as the block length of  <span class="math">\\widetilde{E}</span> , we use instead the "sum-of-PRPs" construction by defining (the exact tweak prefixes are unimportant)</p>

    <p class="text-gray-300"><span id="page-18-3"></span> <span class="math-block">F_K(N) = \\widetilde{E}_K^{2,0}(N) \\oplus \\widetilde{E}_K^{2,1}(N).</span>  (5)</p>

    <p class="text-gray-300">The pseudorandomness of this construction has been well studied. Assuming that  <span class="math">\\widetilde{E}_K^{2,0}</span>  and  <span class="math">\\widetilde{E}_K^{2,1}</span>  are perfectly random and independent permutations, Lucks [Luc00, Theorem 5] showed that an information-theoretic adversary trying to distinguish  <span class="math">F_K</span>  from a random function  <span class="math">\\rho: \\{0,1\\}^n \\to \\{0,1\\}^n</span>  within q queries has an advantage upper bounded by  <span class="math">q^3/2^{2n-1}</span>  (see also [CLP14]). Better bounds were proposed in three different papers: Bellare and Impagliazzo [BI99] proved that</p>

    <p class="text-gray-300"><span id="page-18-1"></span><sup>&</sup>lt;sup>11</sup> We use a set of prefixes which is disjoint from the set used for the CTRT mode in order to later combine the two modes smoothly.</p>

    <p class="text-gray-300"><span id="page-18-2"></span>When constructing an AE scheme, it is more convenient to directly define a vector-input MAC, rather than a string-input MAC that must later be transformed to handle vectors of strings, as required for an AE scheme.</p>

    <pre><code class="language-text">algorithm PWC[\\widetilde{E}]_K(N, A, M)
                                                                                         \\mathsf{EPWC}[\\widetilde{E}]_K(N,A,M)
        \\ell_a := |A|/n
         \\ell_m := |M|/n
         parse A as A_1 \\| \\cdots \\| A_{\\ell_a}, with |A_1| = \\ldots = |A_{\\ell_a - 1}| = n, 1 \\le |A_{\\ell_a}| \\le n
         parse M as M_1 \\| \\cdots \\| M_{\\ell_m}, with |M_1| = \\ldots = |M_{\\ell_m - 1}| = n, 1 \\le |M_{\\ell_m}| \\le n
         \\mathsf{auth} := \\widetilde{E}_K^{2,0}(N) \\oplus \\widetilde{E}_K^{2,1}(N)
         if \\ell_a &gt; 0 then
             for i = 1 to \\ell_a - 1 do
                \\mathsf{auth} := \\mathsf{auth} \\oplus \\widetilde{E}_K^{2,i+1}(A_i)
             if |A_{\\ell_a}| = n then
10
                \\operatorname{auth} := \\operatorname{auth} \\oplus \\widetilde{E}_K^{2,\\ell_a+1}(A_{\\ell_a})
11
12
                \\mathsf{auth} := \\mathsf{auth} \\oplus \\widetilde{E}_K^{3,\\ell_a+1}(A_{\\ell_a}10^*)
13
         if \\ell_m &gt; 0 then
14
             for i = 1 to \\ell_m - 1 do
15
                 \\operatorname{\\mathsf{auth}} := \\operatorname{\\mathsf{auth}} \\oplus \\widetilde{E}^{4,i}_K(M_i)
16
             if |M_{\\ell_m}| = n then
17
                \\mathsf{auth} := \\mathsf{auth} \\oplus \\widetilde{E}_K^{4,\\ell_m}(M_{\\ell_m})
18
19
                \\mathsf{auth} := \\mathsf{auth} \\oplus \\widetilde{E}_K^{5,\\ell_m}(M_{\\ell_m}10^*)
20
21
         return tag</code></pre>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-19-0"></span><strong>Fig. 3.</strong> Definition of the PWC and EPWC modes, using a TBC  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{T}&#x27; = \\{2, \\ldots, 5\\} \\times \\mathcal{T}</span>  and  <span class="math">\\mathcal{X} = \\{0, 1\\}^n</span> . The boxed statement only applies to EPWC. For notational simplicity, we identify  <span class="math">\\mathcal{T}</span>  with  $\\{0, \\ldots,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1\\}<span class="math">  and  </span>\\mathsf{Inc}^i(0)$  with i.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">the advantage is upper bounded by  <span class="math">\\mathcal{O}(n)(q/2^n)^{1.5}</span> , while Patarin proved in two different ways [Pat08a, Pat13] an upper bound  <span class="math">\\mathcal{O}(q/2^n)</span> . However, in all three cases the exact  <span class="math">\\mathcal{O}(\\cdot)</span>  function was left unspecified and the upper bound was not explicitly worked out. For the sake of concreteness, we propose the following optimistic conjecture.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-19-2"></span>Conjecture 1. There is an absolute constant C such the advantage of any adversary trying to distinguish the sum of two independent random permutations of  <span class="math">\\mathcal{X}</span>  from a random function from  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{X}</span>  within q queries is at most  $Cq/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-19-1"></span>The security of PWC and EPWC is captured by Theorems 2 and 3 below. We denote by  <span class="math">t_{\\mathsf{PWC}}(\\sigma)</span> , resp.  <span class="math">t_{\\mathsf{EPWC}}(\\sigma)</span> , an upper bound on the time needed to compute  <span class="math">\\mathsf{PWC}[\\widetilde{E}]</span> , resp.  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]</span>  on inputs of total (AD + message) length at most  <span class="math">\\sigma</span>  blocks of n bits when calls to  <span class="math">\\widetilde{E}_K</span>  cost unit time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Theorem 2</strong> (PRF-Security of PWC and EPWC). Let  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span>  and  <span class="math">\\mathcal{T}&#x27; = \\{2,\\dots,5\\} \\times \\mathcal{T}</span> , and assume Conjecture 1. Let A be a  <span class="math">(q,m,\\ell,\\sigma,t)</span> -adversary against the PRF-security of  <span class="math">\\mathsf{PWC}[\\widetilde{E}]</span> , resp.  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]</span> , with  $\\ell \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math"> . Then there exists an absolute constant C and an adversary  </span>\\mathsf{A}'<span class="math"> , resp.  </span>\\mathsf{A}''<span class="math"> , against the TPRP-security of  </span>\\widetilde{E}<span class="math"> , making at most  </span>\\sigma + 2q<span class="math"> , resp.  </span>\\sigma + 3q<span class="math">  oracle queries and running it time at most  </span>t + t_{\\mathsf{PWC}}(\\sigma)<span class="math"> , resp.  </span>t + t_{\\mathsf{EPWC}}(\\sigma)$ , such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) if A is nonce-respecting (m=1), then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{aligned} \\mathbf{Adv}_{\\mathsf{PWC}[\\widetilde{E}]}^{\\mathsf{nPRF}}(\\mathsf{A}) &\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathsf{TPRP}}(\\mathsf{A}') + \\frac{Cq}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}; \\\\ \\mathbf{Adv}_{\\mathsf{EPWC}[\\widetilde{E}]}^{\\mathsf{nPRF}}(\\mathsf{A}) &\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathsf{TPRP}}(\\mathsf{A}'') + \\frac{Cq}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}; \\end{aligned}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) if A is allowed to repeat nonces (m > 1), then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}^{\\mathrm{PRF}}_{\\mathsf{EPWC}[\\widetilde{E}]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}'') + \\frac{q^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Fix a  $(q, m,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2, \\sigma, t)<span class="math"> -adversary A against the PRF-security of PWC </span>[\\widetilde{E}]<span class="math">  or EPWC </span>[\\widetilde{E}]<span class="math"> , trying to distinguish the construction from a random function  </span>R \\leftarrow_{\\<span class="math">} \\mathsf{Func}(\\mathcal{N} \\times \\mathcal{D}, \\mathcal{Y})</span> , where  <span class="math">\\mathcal{D} = \\mathcal{A} \\times \\mathcal{M}</span> . We start by proving (a), assuming A is nonce-respecting (m=1). First, slightly abusing the notation, let us see (E)PWC as a construction based on an arbitrary tweakable permutation, identifying (E)PWC <span class="math">[\\widetilde{E}]_K</span>  with (E)PWC <span class="math">[\\widetilde{E}_K]</span> . We start by replacing  <span class="math">\\widetilde{E}_K</span>  in the security experiment by a uniformly random tweakable permutation  <span class="math">\\widetilde{P}</span> . One can see  <span class="math">\\mathsf{A}^{\\mathsf{PWC}[\\cdot]}</span> , resp.  <span class="math">\\mathsf{A}^{\\mathsf{EPWC}[\\cdot]}</span> , as an adversary  <span class="math">\\mathsf{A}&#x27;</span> , resp.  <span class="math">\\mathsf{A}&#x27;&#x27;</span>  against the TPRP-security of  <span class="math">\\widetilde{E}</span> , making at most  <span class="math">\\sigma + 2q</span> , resp.  <span class="math">\\sigma + 3q</span>  queries to its oracle (since a query of  <span class="math">\\ell_i</span>  blocks to PWC, resp.  <span class="math">\\mathsf{EPWC}</span> , costs  <span class="math">\\ell_i + 2</span> , resp.  <span class="math">\\ell_i + 3</span>  calls to  <span class="math">\\widetilde{E}</span> ) and running in time at most  <span class="math">t&#x27; = t + t_{\\mathsf{PWC}}(\\sigma)</span> , resp.  <span class="math">t&#x27; = t + t_{\\mathsf{EPWC}}(\\sigma)</span> , so that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-20-1"></span><span id="page-20-0"></span> <span class="math-block">\\mathbf{Adv}_{\\mathsf{PWC}[\\widetilde{E}]}^{\\mathsf{nPRF}}(\\mathsf{A}) \\le \\mathbf{Adv}_{\\widetilde{E}}^{\\mathsf{TPRP}}(\\mathsf{A}&#x27;) + \\delta, \\tag{6}</span></p>

    <p class="text-gray-300"><span id="page-20-2"></span> <span class="math-block">\\mathbf{Adv}_{\\mathsf{EPWC}[\\widetilde{E}]}^{\\mathsf{nPRF}}(\\mathsf{A}) \\le \\mathbf{Adv}_{\\widetilde{E}}^{\\mathsf{TPRP}}(\\mathsf{A}&#x27;&#x27;) + \\delta, \\tag{7}</span></p>

    <p class="text-gray-300">where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\delta &= \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\widetilde{P} \\leftarrow_{\\<span class="math">} \\mathsf{TP}(\\mathcal{T}&#x27;, \\mathcal{X}) : \\mathsf{A}^{(\\mathsf{E})\\mathsf{PWC}[\\widetilde{P}]} = 1 \\right] \\\\ &amp;- \\Pr \\left[ R \\leftarrow_{\\</span>} \\mathsf{Func}(\\mathcal{N} \\times \\mathcal{D}, \\mathcal{Y}) : \\mathsf{A}^R = 1 \\right] \\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\quad (8) \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to upper bound  <span class="math">\\delta</span> , we abstract the high-level structure of (E)PWC <span class="math">[\\widetilde{P}]</span>  as follows. First, we see how A and M are handled as applying a keyed hash</p>

    <p class="text-gray-300">function (the key being  <span class="math">\\widetilde{P}</span> ) to the pair (A, M), viz.</p>

    <div class="my-4 text-center"><span class="math-block">H_{\\widetilde{P}}(A, M) \\stackrel{\\text{def}}{=} \\left( \\bigoplus_{i=1}^{\\ell_a - 1} \\widetilde{P}^{2, i+1}(A_i) \\right) \\oplus \\widetilde{P}^{2/3, \\ell_a + 1}(A_{\\ell_a}(10^*))</span></div>

    <div class="my-4 text-center"><span class="math-block">\\oplus \\left( \\bigoplus_{i=1}^{\\ell_m - 1} \\widetilde{P}^{4, i}(M_i) \\right) \\oplus \\widetilde{P}^{4/5, \\ell_m}(M_{\\ell_m}(10^*)). \\quad (9)</span></div>

    <p class="text-gray-300">We also define a pseudorandom function (again with key  <span class="math">\\widetilde{P}</span> ) as</p>

    <p class="text-gray-300"><span id="page-21-4"></span><span id="page-21-3"></span><span id="page-21-2"></span><span id="page-21-1"></span> <span class="math-block">F_{\\widetilde{P}}(N) \\stackrel{\\text{def}}{=} \\widetilde{P}^{2,0}(N) \\oplus \\widetilde{P}^{2,1}(N). \\tag{10}</span></p>

    <p class="text-gray-300">Then,  <span class="math">(\\mathsf{E})\\mathsf{PWC}[\\widetilde{P}]</span>  can be written</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PWC}[\\widetilde{P}](N,A,M) = F_{\\widetilde{P}}(N) \\oplus H_{\\widetilde{P}}(A,M), \\tag{11}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{EPWC}[\\widetilde{P}](N,A,M) = \\widetilde{P}^{4,0}\\Big(F_{\\widetilde{P}}(N) \\oplus H_{\\widetilde{P}}(A,M)\\Big), \\tag{12}</span></div>

    <p class="text-gray-300">which should make it clear that the PWC construction follows the Wegman-Carter paradigm [WC81] with an additional layer of encryption for EPWC (note that the three sets of tweaks used in  <span class="math">F,\\,H,</span>  and for the final encryption call are disjoint, so that these three building blocks are independent).</p>

    <p class="text-gray-300">We start by showing that the hash function family  <span class="math">(H_{\\widetilde{P}})</span> , with  <span class="math">\\widetilde{P} \\in \\mathsf{TP}(\\mathcal{T}&#x27;, \\mathcal{X})</span> , is xor-universal, i.e., for any two distinct inputs (A, M), (A', M'), and any  <span class="math">X \\in \\mathcal{X} = \\{0, 1\\}^n</span> , the probability, over the random draw of  <span class="math">\\widetilde{P} \\leftarrow_{\\</span>} \\mathsf{TP}(\\mathcal{T}', \\mathcal{X})$ , that</p>

    <p class="text-gray-300"><span id="page-21-0"></span> <span class="math-block">H_{\\widetilde{P}}(A,M) \\oplus H_{\\widetilde{P}}(A&#x27;,M&#x27;) = X,</span>  (13)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is less than  $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Assume that  </span>A \\neq A'<span class="math">  (the reasoning is similar if A = A&#x27; and  </span>M \\neq M'<span class="math"> ), let  </span>\\ell_a =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n<span class="math">  and  </span>\\ell_a' =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/n<span class="math"> , and assume wlog that  </span>\\ell_a \\geq \\ell_a'<span class="math"> . Denote  </span>A = A_1 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{\\ell_a}<span class="math">  and  </span>A' = A_1' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A_{\\ell_a'}'<span class="math"> . Assume first that  </span>\\ell_a > \\ell_a'$ . Then (13) is equivalent to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{P}^{2/3,\\ell_a+1}(A_{\\ell_a}(10^*)) = Z,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where Z is independent of permutations  <span class="math">\\widetilde{P}^{2,\\ell_a+1}</span>  and  <span class="math">\\widetilde{P}^{3,\\ell_a+1}</span> , hence the probability is exactly  $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Assume now that  </span>\\ell_a = \\ell'_a<span class="math"> . There is necessarily an index  </span>i \\leq \\ell_a<span class="math">  such that  </span>A_i \\neq A'_i<span class="math"> . If  </span>i < \\ell_a$ , then (13) is equivalent to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{P}^{2,i+1}(A_i) \\oplus \\widetilde{P}^{2,i+1}(A_i&#x27;) = Z,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where Z is a value potentially depending on  <span class="math">\\widetilde{P}</span>  for tweaks different from (2, i+1). Since the probability of this equality (over the random draw of  <span class="math">\\widetilde{P}^{2,i+1}</span> ) is either 0 when Z=0 or exactly  $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  when  </span>Z\\neq 0<span class="math"> , it follows that the condition is met with probability at most  </span>1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  in that case. Similarly, if  </span>i=\\ell_a$ , then (13) is equivalent to</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{P}^{2/3,i+1}(A_i(10^*)) \\oplus \\widetilde{P}^{2/3,i+1}(A_i&#x27;(10^*)) = Z,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where Z is a value potentially depending on  <span class="math">\\widetilde{P}</span>  for tweaks different from (2,i+1) and (3,i+1). Again, the condition is met with probability at most  $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  in that case. This concludes the proof that H is xor-universal.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a second step, we replace  <span class="math">F_{\\widetilde{P}}</span>  by a uniformly random function  <span class="math">\\rho</span>  from  <span class="math">\\mathcal{N}=\\{0,1\\}^n</span>  to  <span class="math">\\mathcal{X}=\\{0,1\\}^n</span> . Let  <span class="math">\\mathsf{PWC}&#x27;[\\rho,\\widetilde{P}]</span> , resp.  <span class="math">\\mathsf{EPWC}&#x27;[\\rho,\\widetilde{P}]</span>  be defined as in (11), resp. (12), except that  <span class="math">F_{\\widetilde{P}}</span>  is replaced by a call to  <span class="math">\\rho</span> . Since A is noncerespecting, then both  <span class="math">\\mathsf{PWC}&#x27;[\\rho,\\widetilde{P}]</span>  and  <span class="math">\\mathsf{EPWC}&#x27;[\\rho,\\widetilde{P}]</span>  are perfectly indistinguishable from Rand (this is obvious for  <span class="math">\\mathsf{PWC}&#x27;</span> , while for  <span class="math">\\mathsf{EPWC}&#x27;</span>  this follows from the fact that applying any fixed permutation to uniformly random values yields uniformly random values). Hence, it remains to upper bound A's advantage in distinguishing  <span class="math">(\\mathsf{E})\\mathsf{PWC}[\\widetilde{P}]</span>  from  <span class="math">(\\mathsf{E})\\mathsf{PWC}&#x27;[\\rho,\\widetilde{P}]</span> . By a straightforward hybrid argument, this is exactly the advantage of an adversary A''' simulating H (and  <span class="math">\\widetilde{P}^{4,0}</span>  for  <span class="math">\\mathsf{EPWC}</span> ) in distinguishing  <span class="math">F_{\\widetilde{P}}</span>  from  <span class="math">\\rho</span>  within at most q queries (since each query to the construction translates in exactly one query to the function applied to the nonce). Using Conjecture 1, this advantage is upper bounded by  $Cq/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . Combining this with (6), resp. (7), we obtain the result.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We then prove (b), assuming A is allowed to repeat nonces (m > 1). Exactly as before, one has</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}^{\\mathrm{PRF}}_{\\mathsf{EPWC}[\\widetilde{E}]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{TPRP}}_{\\widetilde{E}}(\\mathsf{A}&#x27;&#x27;) + \\delta,</span></div>

    <p class="text-gray-300">with  <span class="math">\\delta</span>  defined as in (8). We now see  <span class="math">\\mathsf{EPWC}[\\widetilde{P}]</span>  as a construction based on a universal hash function applied to (N,A,M) followed by a PRF. More precisely, let</p>

    <div class="my-4 text-center"><span class="math-block">H_{\\widetilde{P}}&#x27;(N,A,M)=F_{\\widetilde{P}}(N)\\oplus H_{\\widetilde{P}}(A,M),</span></div>

    <p class="text-gray-300">with H and F as defined in resp. (9) and (10). Then</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{EPWC}[\\widetilde{P}](N,A,M) = \\widetilde{P}^{4,0}(H_{\\widetilde{P}}&#x27;(N,A,M)).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is easy to adapt the proof that H is xor-universal to show that H' is also xor-universal (hence, in particular, universal, which is all we need here). The remaining of the proof is now standard [Sho04], and we only sketch it. We first replace  <span class="math">\\widetilde{P}^{4,0}</span>  in EPWC[ <span class="math">\\widetilde{P}</span> ] by a uniformly random function  <span class="math">\\rho: \\mathcal{X} \\to \\mathcal{X}</span> , and denote EPWC"[ <span class="math">\\rho, \\widetilde{P}</span> ] the resulting construction. By the PRP-PRF switching lemma, A can distinguish EPWC[ <span class="math">\\widetilde{P}</span> ] from EPWC"[ <span class="math">\\rho, \\widetilde{P}</span> ] with advantage at most  $q^2/(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , and because H&#x27; is universal, it can distinguish EPWC&quot;[ </span>\\rho, \\widetilde{P}<span class="math"> ] from Rand with advantage at most  </span>q^2/(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ . The result follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-22-0"></span><strong>Theorem 3 (MAC-Security of PWC and EPWC).</strong> Let  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span>  and  <span class="math">\\mathcal{T}&#x27; = \\{2,\\dots,5\\} \\times \\mathcal{T}</span> , and assume Conjecture 1. Let B be a nonce-respecting  <span class="math">(q,1,\\ell,\\sigma,t)</span> -adversary against the MAC-security of  <span class="math">\\mathsf{PWC}[\\widetilde{E}]</span> , resp.  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]</span> , with  $\\ell \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math"> . Then there exists an absolute constant C and an adversary B&#x27;, resp. B&quot;, against the TPRP-security of  </span>\\widetilde{E}$ , making at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"> <span class="math">\\sigma + 2q</span> , resp.  <span class="math">\\sigma + 3q</span>  oracle queries and running it time at most  <span class="math">t + t_{PWC}(\\sigma)</span> , resp.  <span class="math">t + t_{EPWC}(\\sigma)</span> , such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\mathbf{Adv}_{\\mathsf{PWC}[\\widetilde{E}]}^{\\mathrm{nMAC}}(\\mathsf{B}) & \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{TPRP}}(\\mathsf{B}') + \\frac{(C+1)q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}; \\\\ \\mathbf{Adv}_{\\mathsf{EPWC}[\\widetilde{E}]}^{\\mathrm{nMAC}}(\\mathsf{B}) & \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{TPRP}}(\\mathsf{B}'') + \\frac{(C+1)q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The proof is standard and only sketched. Let B be a nonce-respecting  $(q,1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2,\\sigma,t)<span class="math"> -adversary against the MAC-security of  </span>\\mathsf{PWC}[\\widetilde{E}]<span class="math">  or  </span>\\mathsf{EPWC}[\\widetilde{E}]<span class="math"> . Let  </span>W_1 = ((\\mathsf{E})\\mathsf{PWC}[\\widetilde{E}]_K,\\mathsf{Ver}_K)<span class="math">  and  </span>W_4 = ((\\mathsf{E})\\mathsf{PWC}[\\widetilde{E}]_K,\\mathsf{Rej})<span class="math">  be the two worlds that B tries to distinguish, with  </span>\\mathsf{Ver}_K<span class="math">  and  </span>\\mathsf{Rej}<span class="math">  as in Definition 3. Let Win be the event that B asks a right (verification) query which returns 1. Clearly, B&#x27;s distinguishing advantage is equal to the probability of event Win when B interacts with  </span>W_1<span class="math"> , which we now upper bound. As in the proof of Theorem 2, we first replace all calls to  </span>\\widetilde{E}_K<span class="math">  made by the two oracles in  </span>W_1<span class="math">  by a call to a uniformly random tweakable permutation  </span>\\widetilde{P}<span class="math"> , and let (with obvious simplification to the notation)  </span>W_2 = ((\\mathsf{E})\\mathsf{PWC}[\\widetilde{P}],\\mathsf{Ver}_{\\widetilde{P}})<span class="math"> . In  </span>W_3<span class="math"> , we further replace the pseudorandom function  </span>F_{\\widetilde{P}}<span class="math">  as defined by (10) by a uniformly random function  </span>\\rho: \\mathcal{N} \\to \\mathcal{X}$ . Then, depending on whether we are considering PWC or EPWC, and using Conjecture 1, one has</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\Pr\\left[\\mathsf{B}^{W_1}:\\mathsf{Win}\\right] &\\leq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\mathsf{B}^{W_1}:\\mathsf{Win}\\right] - \\Pr\\left[\\mathsf{B}^{W_2}:\\mathsf{Win}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\ &+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr\\left[\\mathsf{B}^{W_2}:\\mathsf{Win}\\right] - \\Pr\\left[\\mathsf{B}^{W_3}:\\mathsf{Win}\\right]\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\Pr\\left[\\mathsf{B}^{W_3}:\\mathsf{Win}\\right] \\\\ &\\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathsf{TPRP}}(\\mathsf{B}'/\\mathsf{B}'') + \\frac{Cq}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\Pr\\left[\\mathsf{B}^{W_3}:\\mathsf{Win}\\right], \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with  <span class="math">\\mathsf{B}&#x27;</span>  and  <span class="math">\\mathsf{B}&#x27;&#x27;</span>  as in the statement of the theorem. In  <span class="math">W_3</span> ,  <span class="math">\\mathsf{B}</span>  is trying to forge a MAC for</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{PWC}&#x27;[\\rho,\\widetilde{P}](N,A,M) = \\rho(N) \\oplus H_{\\widetilde{P}}(A,M), \\tag{14}</span></div>

    <p class="text-gray-300">or <span class="math-block">\\mathsf{EPWC}&#x27;<a href="N,A,M">\\rho,\\widetilde{P}</a> = \\widetilde{P}^{4,0}\\Big(\\rho(N) \\oplus H_{\\widetilde{P}}(A,M)\\Big), \\tag{15}</span></p>

    <p class="text-gray-300">where H is defined by (9) and was shown to be xor-universal in the proof of Theorem 2. The classical result on Wegman-Carter MACs [Sho96] applies (the additional encryption layer for EPWC does not modify it), and gives</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\mathsf{B}^{W_3}:\\mathsf{Win}\\right] \\leq \\frac{q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This concludes the proof.</p>

    <p class="text-gray-300">Remark 1. While it is in principle possible to save one encryption call in the EPWC construction by keeping the final AD or message block unencrypted as in the standard PMAC construction [BR02, Rog04a], we avoid this to ensure that static AD always gets treated the same, independently of the message. Indeed,</p>

    <p class="text-gray-300">applying this optimization would result in a construction where the final block of AD should be treated differently depending on whether the message is empty or not. Handling the AD independently of the message allows to precompute</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{auth}&#x27; = \\bigoplus_{i=1}^{\\ell_a-1} \\widetilde{P}^{2,i+1}(A_i) \\oplus \\widetilde{P}^{2/3,\\ell_a+1}(A_{\\ell_a}(10^*))</span></div>

    <p class="text-gray-300">and to process the nonce and the message later (in particular, when the AD is static, auth' need not be recomputed each time).</p>

    <p class="text-gray-300"><span id="page-24-0"></span>Remark 2. In the nonce-misuse scenario, there is a simple birthday attack against  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]</span>  as soon as the adversary can repeat a single nonce twice. The attack proceeds as follows: simply query  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]_K</span>  for roughly  <span class="math">2^{n/2}</span>  pairs  <span class="math">(N_i, A, M)</span>  with distinct nonces and the same AD and message until a collision occurs on the outputs for two nonces  <span class="math">N_1</span>  and  <span class="math">N_2</span> . Clearly, a collision on the MACs implies that  <span class="math">F_K(N_1) = F_K(N_2)</span>  (where  <span class="math">F_K</span>  is given by (5)). Hence, the adversary can now query  <span class="math">Y = \\mathsf{EPWC}[\\widetilde{E}]_K(N_1, A&#x27;, M&#x27;)</span>  for a new pair  <span class="math">(A&#x27;, M&#x27;) \\neq (A, M)</span> . Then Y is a valid forgery for  <span class="math">(N_2, A&#x27;, M&#x27;)</span> . It remains an open problem to design a nonce-based MAC scheme ensuring graceful degradation of security with the maximal number of nonce repetitions.</p>

    <h2 id="sec-9" class="text-2xl font-bold">6 The SCT Mode</h2>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">6.1 The NSIV Construction</h4>

    <p class="text-gray-300">In this section, we present the nAE mode SCT and analyze its security. We first describe a generic composition method named NSIV, which defines a nAE scheme from a nonce-based keyed function and an nivE scheme. The NSIV construction results from a small (but important from a security viewpoint) modification to the (generic) SIV construction [RS06]. While in SIV the encryption part is purely IV-based, NSIV relies on a combined nonce- and IV-based encryption (nivE) scheme, the nonce being used as input both to the keyed function and the nivE scheme. This is the only difference with SIV, where the nonce is only given as input to the keyed function.</p>

    <p class="text-gray-300">More formally, let F be a nonce-based keyed function with key-space  <span class="math">\\mathcal{K}_1</span> , nonce space  <span class="math">\\mathcal{N}</span> , domain  <span class="math">\\mathcal{D} = \\mathcal{A} \\times \\mathcal{M}</span> , and range  <span class="math">\\mathcal{Y}</span> , and  <span class="math">\\Pi = (\\mathcal{K}_2, \\mathcal{N}, \\mathcal{I}\\mathcal{V}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span>  be a nivE scheme. Fix a regular function  <span class="math">\\mathsf{Conv}: \\mathcal{Y} \\to \\mathcal{I}\\mathcal{V}</span> . We define the nAE scheme<sup>13</sup>  <span class="math">\\mathsf{NSIV}[F, \\Pi] = (\\mathcal{K}, \\mathcal{N}, \\mathcal{A}, \\mathcal{M}, \\mathsf{Enc}, \\mathsf{Dec})</span>  with key-space  <span class="math">\\mathcal{K} = \\mathcal{K}_1 \\times \\mathcal{K}_2</span>  as specified on Fig. 4.</p>

    <p class="text-gray-300">The security of  <span class="math">\\mathsf{NSIV}[F,\\Pi]</span>  is given by Theorem 4 below. We assume that  <span class="math">\\mathcal{A} = \\mathcal{M} = \\{0,1\\}^*</span>  for convenience, but this restriction can be lifted easily. We denote by  <span class="math">t_{\\Pi}(\\sigma)</span>  an upper bound on the time needed for computing  <span class="math">\\Pi</span> .Enc or</p>

    <p class="text-gray-300"><span id="page-24-2"></span><sup>&</sup>lt;sup>13</sup> Our formalization of an nAE scheme in Definition 4 assumes that the ciphertext is a binary string, whereas in our description,  <span class="math">\\mathsf{NSIV}[F,\\Pi]</span> . Enc returns a pair  <span class="math">(C,\\mathsf{tag})</span> . We assume some implicit encoding of this pair into a single binary string.</p>

    <p class="text-gray-300"><img src="_page_25_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <pre><code class="language-text">1 algorithm NSIV[F, Π].EncK1,K2
                                (N, A, M)
2 tag := FK1
              (N, A, M)
3 IV := Conv(tag)
4 C := Π.EncK2
                 (N, IV, M)
5 return (C,tag)
6
7 algorithm NSIV[F, Π].DecK1,K2
                                (N, A, C,tag)
8 IV := Conv(tag)
9 M := Π.DecK2
                  (N, IV, C)
10 tag0
        := FK1
               (N, A, M)
11 if tag0 = tag then return M else return ⊥</code></pre>

    <p class="text-gray-300"><span id="page-25-0"></span><strong>Fig. 4.</strong> The NSIV construction, defining a nAE scheme from a nonce-based keyed function <em>F</em> : K<sup>1</sup> × N × D → Y where D = A × M and a nivE scheme <em>Π</em> = (K2<em>,</em> N <em>,</em> IV<em>,</em>M<em>,</em> Enc<em>,</em> Dec). Function Conv is a regular function from Y to IV.</p>

    <p class="text-gray-300"><em>Π.</em>Dec on inputs of total message length at most <em>σ</em> blocks of <em>n</em> bits, and we assume that computing Conv(tag) or sampling uniformly from Conv<sup>−</sup><sup>1</sup> (<em>IV</em> ) takes negligible time for any tag ∈ Y and <em>IV</em> ∈ IV. The proof of this theorem is similar to the security proof of SIV, and deferred to Appendix <a href="#page-31-6">A.</a></p>

    <p class="text-gray-300"><span id="page-25-1"></span><strong>Theorem 4 (Security of</strong> NSIV<strong>).</strong> <em>Let F</em> : K<sup>1</sup> ×N × D → Y<em>, where</em> D = A×M<em>, be a nonce-based keyed function, Π</em> = (K2<em>,</em> N <em>,</em> IV<em>,</em>M<em>,</em> Enc<em>,</em> Dec) <em>be a nivE scheme, and</em> Conv : Y → IV <em>be a regular function. Let</em> A <em>be a</em> (<em>q, m, \`, σ, t</em>)<em>-adversary against</em> NSIV[<em>F, Π</em>]<em>. Then, letting t</em> <sup>0</sup> = <em>t</em> + <em>tΠ</em>(<em>σ</em>)<em>, the following holds:</em></p>

    <p class="text-gray-300"><em>(a) if</em> A <em>is allowed to repeat nonces (m ></em> 1<em>), then there exists a</em> (<em>q, m, <code>, σ, t&lt;/em&gt;&lt;sup&gt;0&lt;/sup&gt; ) &lt;em&gt;adversary&lt;/em&gt; A &lt;sup&gt;0&lt;/sup&gt; &lt;em&gt;against Π and a&lt;/em&gt; (&lt;em&gt;q, q, </code>, σ, t</em><sup>0</sup> )<em>-adversary</em> A <sup>00</sup> <em>against the PRFsecurity of F such that</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}_{\\mathsf{NSIV}[F,H]}^{\\mathsf{AE}}(\\mathsf{A}) \\leq \\mathbf{Adv}_{H}^{\\mathsf{ivE}}(\\mathsf{A}') + \\mathbf{Adv}_{F}^{\\mathsf{PRF}}(\\mathsf{A}'') + \\frac{q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">};$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>(b) if</em> A <em>is nonce-respecting (m</em> = 1<em>), then there exists a</em> (<em>q,</em> 1<em>, <code>, σ, t&lt;/em&gt;&lt;sup&gt;0&lt;/sup&gt; )&lt;em&gt;-adversary&lt;/em&gt; A &lt;sup&gt;0&lt;/sup&gt; &lt;em&gt;against Π and&lt;/em&gt; (&lt;em&gt;q,&lt;/em&gt; 1&lt;em&gt;, </code>, σ, t</em><sup>0</sup> )<em>-adversaries</em> A <sup>00</sup> <em>and</em> A <sup>000</sup> <em>against respectively</em> the PRF- and the MAC-security of F, all nonce-respecting, such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{Adv}^{\\mathrm{nAE}}_{\\mathsf{NSIV}[F,\\varPi]}(\\mathsf{A}) \\leq \\mathbf{Adv}^{\\mathrm{nivE}}_{\\varPi}(\\mathsf{A}&#x27;) + \\mathbf{Adv}^{\\mathrm{nPRF}}_{F}(\\mathsf{A}&#x27;&#x27;) + \\mathbf{Adv}^{\\mathrm{nMAC}}_{F}(\\mathsf{A&#x27;&#x27;&#x27;}).</span></div>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">6.2 From NSIV to SCT</h4>

    <p class="text-gray-300">The  <span class="math">\\mathsf{SCT}[\\widetilde{E}]</span>  mode is simply  <span class="math">\\mathsf{NSIV}[F,\\Pi]</span>  where F is instantiated with  <span class="math">\\mathsf{EPWC}[\\widetilde{E}]</span>  and  <span class="math">\\Pi</span>  is instantiated with  <span class="math">\\mathsf{CTRT}[\\widetilde{E}]</span> . Additionally, in order to be able to use the same key for calls to  <span class="math">\\widetilde{E}</span>  both in  <span class="math">\\mathsf{EPWC}</span>  and in  <span class="math">\\mathsf{CTRT}</span> , we use tweak separation to ensure that all calls to  <span class="math">\\widetilde{E}</span>  in  <span class="math">\\mathsf{EPWC}</span>  and in  <span class="math">\\mathsf{CTRT}</span>  are independent. The resulting construction is illustrated in Fig. 1. Combining Theorem 4 with Theorems 1, 2, and 3, we finally obtain the following result for the security of  <span class="math">\\mathsf{SCT}.^{14}</span>  We denote by  <span class="math">t_{\\mathsf{SCT}}(\\sigma)</span>  an upper bound on the time needed for computing  <span class="math">\\mathsf{SCT}[\\widetilde{E}].\\mathsf{Enc}_K</span>  or  <span class="math">\\mathsf{SCT}[\\widetilde{E}].\\mathsf{Dec}_K</span>  on inputs of total (AD + message) length at most  <span class="math">\\sigma</span>  blocks of n bits when calls to  <span class="math">\\widetilde{E}_K</span>  cost unit time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-26-1"></span><strong>Theorem 5 (Security of SCT).</strong> Let  <span class="math">\\widetilde{E} \\in \\mathsf{TBC}(\\mathcal{K}, \\mathcal{T}&#x27;, \\mathcal{X})</span>  with  <span class="math">\\mathcal{X} = \\{0, 1\\}^n</span>  and  <span class="math">\\mathcal{T}&#x27; = \\{1, \\dots, 5\\} \\times \\mathcal{T}</span> . Let  <span class="math">\\mathsf{Conv}</span>  be a regular function from  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{IV} = \\mathcal{T}</span> . Assume Conjecture 1. Let  <span class="math">\\mathsf{A}</span>  be a  <span class="math">(q, m, \\ell, \\sigma, t)</span> -adversary against  <span class="math">\\mathsf{SCT}[\\widetilde{E}]</span>  with  $\\ell \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 2<span class="math"> . Then there exists an absolute constant C and an adversary  </span>\\mathsf{A}'<span class="math">  against the TPRP-security of  </span>\\widetilde{E}<span class="math"> , making at most  </span>\\sigma + 3q<span class="math">  oracle queries and running in time at most  </span>t + t_{\\mathsf{SCT}}(\\sigma)$ , such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(a) if A is allowed to repeat nonces in encryption queries (m > 1), then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}_{\\mathsf{SCT}[\\widetilde{E}]}^{\\mathrm{AE}}(\\mathsf{A}) \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{TPRP}}(\\mathsf{A}') + \\frac{2(m-1)\\sigma}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{q^2+q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">};$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(b) if A is nonce-respecting (m = 1), then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathbf{Adv}_{\\mathsf{SCT}[\\widetilde{E}]}^{\\mathrm{nAE}}(\\mathsf{A}) \\leq \\mathbf{Adv}_{\\widetilde{E}}^{\\mathrm{TPRP}}(\\mathsf{A}') + \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{(2C+1)q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 3. Note that the regularity condition on Conv, required for the NSIV composition theorem to hold because an arbitrary nivE scheme might fail to provide security when IV is not uniformly random in  <span class="math">\\mathcal{IV}</span> , imposes  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{IV}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . When the TBC is such that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , one can always define  </span>\\mathcal{IV}<span class="math">  to be a subset  </span>\\overline{\\mathcal{T}} \\subset \\mathcal{T}<span class="math">  of tweaks of size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and use a cyclic permutation Inc of  </span>\\overline{\\mathcal{T}}<span class="math">  in order to apply Theorem 1, but we remark that the security of the CTRT mode is likely to be improved by using a cyclic permutation of  </span>\\mathcal{T}$  instead.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-26-0"></span><sup>&</sup>lt;sup>14</sup> In more details, it is more convenient to prove Theorem 5 by first replacing  <span class="math">\\widetilde{E}_K</span>  by a uniformly random tweakable permutation, and then applying Theorems 1, 2, and 3 for a perfect TBC.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8"><strong>Acknowledgements</strong></h3>

    <p class="text-gray-300">The authors would like to thank Jérémy Jean and Ivica Nikolic for their remarks on early designs, and Mridul Nandi for pointing out a simpler proof of Lemma <a href="#page-17-0">4</a> leading to a simpler and better bound in Theorem <a href="#page-13-2">1.</a> The first author is supported by the Singapore National Research Foundation Fellowship 2012 (NRF-NRFF2012-06).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-27-5"></span>[ABL<sup>+</sup>13] Elena Andreeva, Andrey Bogdanov, Atul Luykx, Bart Mennink, Elmar Tischhauser, and Kan Yasuda. Parallelizable and Authenticated Online Ciphers. In Kazue Sako and Palash Sarkar, editors, <em>Advances in Cryptology - ASIACRYPT 2013 (Proceedings, Part I)</em>, volume 8269 of <em>LNCS</em>, pages 424–443. Springer, 2013.</li>

      <li><span id="page-27-8"></span>[ABL<sup>+</sup>14] Elena Andreeva, Andrey Bogdanov, Atul Luykx, Bart Mennink, Nicky Mouha, and Kan Yasuda. How to Securely Release Unverified Plaintext in Authenticated Encryption. In <em>Advances in Cryptology - ASIACRYPT 2014 (Proceedings, Part I)</em>, volume 8873 of <em>LNCS</em>, pages 105–125. Springer, 2014.</li>

      <li><span id="page-27-6"></span>[AFF<sup>+</sup>14] Farzaneh Abed, Scott R. Fluhrer, Christian Forler, Eik List, Stefan Lucks, David A. McGrew, and Jakob Wenzel. Pipelineable On-line Encryption. In Carlos Cid and Christian Rechberger, editors, <em>Fast Software Encryption - FSE 2014</em>, volume 8540 of <em>LNCS</em>, pages 205–223. Springer, 2014.</li>

      <li><span id="page-27-2"></span>[AP13] Nadhem J. AlFardan and Kenneth G. Paterson. Lucky Thirteen: Breaking the TLS and DTLS Record Protocols. In <em>2013 IEEE Symposium on Security and Privacy - SP 2013</em>, pages 526–540. IEEE Computer Society, 2013.</li>

      <li><span id="page-27-0"></span>[BDJR97] Mihir Bellare, Anand Desai, E. Jokipii, and Phillip Rogaway. A Concrete Security Treatment of Symmetric Encryption. In <em>Symposium on Foundations of Computer Science - FOCS '97</em>, pages 394–403. IEEE Computer Society, 1997.</li>

      <li><span id="page-27-9"></span>[BI99] Mihir Bellare and Russell Impagliazzo. A tool for obtaining tighter security analyses of pseudorandom function based constructions, with applications to PRP to PRF conversion. IACR Cryptology ePrint Archive, Report 1999/024, 1999. Available at <http://eprint.iacr.org/1999/024>.</li>

      <li><span id="page-27-1"></span>[BKR00] Mihir Bellare, Joe Kilian, and Phillip Rogaway. The Security of the Cipher Block Chaining Message Authentication Code. <em>Journal of Computer and System Sciences</em>, 61(3):362–399, 2000.</li>

      <li><span id="page-27-3"></span>[BN00] Mihir Bellare and Chanathip Namprempre. Authenticated Encryption: Relations among Notions and Analysis of the Generic Composition Paradigm. In Tatsuaki Okamoto, editor, <em>Advances in Cryptology - ASIACRYPT 2000</em>, volume 1976 of <em>LNCS</em>, pages 531–545. Springer, 2000.</li>

      <li><span id="page-27-4"></span>[BR00] Mihir Bellare and Phillip Rogaway. Encode-Then-Encipher Encryption: How to Exploit Nonces or Redundancy in Plaintexts for Efficient Cryptography. In Tatsuaki Okamoto, editor, <em>Advances in Cryptology - ASIACRYPT 2000</em>, volume 1976 of <em>LNCS</em>, pages 317–330. Springer, 2000.</li>

      <li><span id="page-27-7"></span>[BR02] John Black and Phillip Rogaway. A Block-Cipher Mode of Operation for Parallelizable Message Authentication. In Lars R. Knudsen, editor, <em>Advances in Cryptology - EUROCRYPT 2002</em>, volume 2332 of <em>LNCS</em>, pages 384–397. Springer, 2002.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-28-7"></span>[Bra82] Gilles Brassard. On Computationally Secure Authentication Tags Requiring Short Secret Shared Keys. In David Chaum, Ronald L. Rivest, and Alan T. Sherman, editors, <em>Advances in Cryptology - CRYPTO '82</em>, pages 79–86. Plenum Press, New York, 1982.</li>

      <li><span id="page-28-3"></span>[BRW04] Mihir Bellare, Phillip Rogaway, and David Wagner. The EAX Mode of Operation. In Bimal K. Roy and Willi Meier, editors, <em>Fast Software Encryption - FSE 2004</em>, volume 3017 of <em>LNCS</em>, pages 389–407. Springer, 2004.</li>

      <li><span id="page-28-2"></span>[CAE] CAESAR: Competition for Authenticated Encryption: Security, Applicability, and Robustness. See <http://competitions.cr.yp.to/caesar.html>.</li>

      <li><span id="page-28-13"></span>[CLP14] Benoît Cogliati, Rodolphe Lampe, and Jacques Patarin. The Indistinguishability of the XOR of <em>k</em> Permutations. In Carlos Cid and Christian Rechberger, editors, <em>Fast Software Encryption - FSE 2014</em>, volume 8540 of <em>LNCS</em>, pages 285–302. Springer, 2014.</li>

      <li><span id="page-28-12"></span>[CS14] Shan Chen and John Steinberger. Tight Security Bounds for Key-Alternating Ciphers. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>Advances in Cryptology - EUROCRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 327–350. Springer, 2014. Full version available at <a href="http://eprint.iacr.org/2013/222">http:</a> <a href="http://eprint.iacr.org/2013/222">//eprint.iacr.org/2013/222</a>.</li>

      <li><span id="page-28-0"></span>[DR11] Thai Duong and Juliano Rizzo. Here Come The ⊕ Ninjas. Unpublished manuscript, 2011. Available at <a href="https://bug665814.bugzilla.mozilla.org/attachment.cgi?id=540839">https://bug665814.bugzilla.mozilla.</a> <a href="https://bug665814.bugzilla.mozilla.org/attachment.cgi?id=540839">org/attachment.cgi?id=540839</a>.</li>

      <li><span id="page-28-10"></span>[DS11] Yevgeniy Dodis and John P. Steinberger. Domain Extension for MACs Beyond the Birthday Barrier. In Kenneth G. Paterson, editor, <em>Advances in Cryptology - EUROCRYPT 2011</em>, volume 6632 of <em>LNCS</em>, pages 323–342. Springer, 2011.</li>

      <li><span id="page-28-6"></span>[Fer02] Niels Ferguson. Collision Attacks on OCB. Unpublished manuscript, 2002. Available at <http://www.cs.ucdavis.edu/~rogaway/ocb/fe02.pdf>.</li>

      <li><span id="page-28-5"></span>[FFL12] Ewan Fleischmann, Christian Forler, and Stefan Lucks. McOE: A Family of Almost Foolproof On-Line Authenticated Encryption Schemes. In Anne Canteaut, editor, <em>Fast Software Encryption - FSE 2012</em>, volume 7549 of <em>LNCS</em>, pages 196–215. Springer, 2012.</li>

      <li><span id="page-28-9"></span>[FLS<sup>+</sup>10] Niels Ferguson, Stefan Lucks, Bruce Schneier, Doug Whiting, Mihir Bellare, Tadayoshi Kohno, Jon Callas, and Jesse Walker. The Skein Hash Function Family. SHA3 Submission to NIST (Round 3), 2010.</li>

      <li><span id="page-28-1"></span>[GD01] Virgil D. Gligor and Pompiliu Donescu. Fast Encryption and Authentication: XCBC Encryption and XECB Authentication Modes. In Mitsuru Matsui, editor, <em>Fast Software Encryption - FSE 2001</em>, volume 2355 of <em>LNCS</em>, pages 92–108. Springer, 2001.</li>

      <li><span id="page-28-11"></span>[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. <em>J. ACM</em>, 33(4):792–807, 1986.</li>

      <li><span id="page-28-4"></span>[GL15] Shay Gueron and Yehuda Lindell. GCM-SIV: Full Nonce Misuse-Resistant Authenticated Encryption at Under One Cycle per Byte. In Indrajit Ray, Ninghui Li, and Christopher Kruegel, editors, <em>ACM Conference on Computer and Communications Security - CCS 2015</em>, pages 109–119. ACM, 2015.</li>

      <li><span id="page-28-8"></span>[GLS<sup>+</sup>14] Vincent Grosso, Gaëtan Leurent, François-Xavier Standaert, Kerem Varici, François Durvaux, Lubos Gaspar, and Stéphanie Kerckhof. SCREAM and iSCREAM. Submitted to the CAESAR competition, 2014.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-29-4"></span>[HKR15] Viet Tung Hoang, Ted Krovetz, and Phillip Rogaway. Robust Authenticated-Encryption: AEZ and the Problem That It Solves. In Elisabeth Oswald and Marc Fischlin, editors, <em>Advances in Cryptology - EUROCRYPT 2015 (Proceedings, Part I)</em>, volume 9056 of <em>LNCS</em>, pages 15–44. Springer, 2015.</li>

      <li><span id="page-29-5"></span>[HRRV15] Viet Tung Hoang, Reza Reyhanitabar, Phillip Rogaway, and Damian Vizár. Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance. In Rosario Gennaro and Matthew Robshaw, editors, <em>Advances in Cryptology - CRYPTO 2015 (Proceedings, Part I)</em>, volume 9215 of <em>LNCS</em>, pages 493–517. Springer, 2015.</li>

      <li><span id="page-29-6"></span>[Iwa06] Tetsu Iwata. New Blockcipher Modes of Operation with Beyond the Birthday Bound Security. In Matthew J. B. Robshaw, editor, <em>Fast Software Encryption - FSE 2006</em>, volume 4047 of <em>LNCS</em>, pages 310–327. Springer, 2006.</li>

      <li><span id="page-29-7"></span>[Iwa08] Tetsu Iwata. Authenticated Encryption Mode for Beyond the Birthday Bound Security. In Serge Vaudenay, editor, <em>Progress in Cryptology - AFRICACRYPT 2008</em>, volume 5023 of <em>LNCS</em>, pages 125–142. Springer, 2008.</li>

      <li><span id="page-29-13"></span>[JNP14a] Jérémy Jean, Ivica Nikolic, and Thomas Peyrin. Deoxys v1. Submitted to the CAESAR competition, 2014.</li>

      <li><span id="page-29-14"></span>[JNP14b] Jérémy Jean, Ivica Nikolic, and Thomas Peyrin. Joltik v1. Submitted to the CAESAR competition, 2014.</li>

      <li><span id="page-29-10"></span>[JNP14c] Jérémy Jean, Ivica Nikolic, and Thomas Peyrin. KIASU v1. Submitted to the CAESAR competition, 2014.</li>

      <li><span id="page-29-15"></span>[JNP14d] Jérémy Jean, Ivica Nikolic, and Thomas Peyrin. Tweaks and Keys for Block Ciphers: The TWEAKEY Framework. In Palash Sarkar and Tetsu Iwata, editors, <em>Advances in Cryptology - ASIACRYPT 2014 (Proceedings, Part II)</em>, volume 8874 of <em>LNCS</em>, pages 274–288. Springer, 2014.</li>

      <li><span id="page-29-2"></span>[Jut01] Charanjit S. Jutla. Encryption Modes with Almost Free Message Integrity. In Birgit Pfitzmann, editor, <em>Advances in Cryptology - EUROCRYPT 2001</em>, volume 2045 of <em>LNCS</em>, pages 529–544. Springer, 2001.</li>

      <li><span id="page-29-3"></span>[Jut08] Charanjit S. Jutla. Encryption Modes with Almost Free Message Integrity. <em>J. Cryptology</em>, 21(4):547–578, 2008. Earlier version at EUROCRYPT 2001.</li>

      <li><span id="page-29-9"></span>[KR11] Ted Krovetz and Phillip Rogaway. The Software Performance of Authenticated-Encryption Modes. In Antoine Joux, editor, <em>Fast Software Encryption - FSE 2011</em>, volume 6733 of <em>LNCS</em>, pages 306–327. Springer, 2011.</li>

      <li><span id="page-29-0"></span>[Kra01] Hugo Krawczyk. The Order of Encryption and Authentication for Protecting Communications (or: How Secure Is SSL?). In Joe Kilian, editor, <em>Advances in Cryptology - CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 310–331. Springer, 2001.</li>

      <li><span id="page-29-1"></span>[KY06] Jonathan Katz and Moti Yung. Characterization of Security Notions for Probabilistic Private-Key Encryption. <em>J. Cryptology</em>, 19(1):67–95, 2006. Preliminary version in <em>Proceedings of STOC 2000</em>.</li>

      <li><span id="page-29-8"></span>[LRW02] Moses Liskov, Ronald L. Rivest, and David Wagner. Tweakable Block Ciphers. In Moti Yung, editor, <em>Advances in Cryptology - CRYPTO 2002</em>, volume 2442 of <em>LNCS</em>, pages 31–46. Springer, 2002.</li>

      <li><span id="page-29-12"></span>[LS13] Rodolphe Lampe and Yannick Seurin. Tweakable Blockciphers with Asymptotically Optimal Security. In Shiho Moriai, editor, <em>Fast Software Encryption - FSE 2013</em>, volume 8424 of <em>LNCS</em>, pages 133–151. Springer, 2013.</li>

      <li><span id="page-29-11"></span>[LST12] Will Landecker, Thomas Shrimpton, and R. Seth Terashima. Tweakable Blockciphers with Beyond Birthday-Bound Security. In Reihaneh Safavi-Naini and Ran Canetti, editors, <em>Advances in Cryptology - CRYPTO 2012</em>,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>volume 7417 of <em>LNCS</em>, pages 14–30. Springer, 2012. Full version available at <http://eprint.iacr.org/2012/450>.</li>

      <li><span id="page-30-11"></span>[Luc00] Stefan Lucks. The Sum of PRPs Is a Secure PRF. In Bart Preneel, editor, <em>Advances in Cryptology - EUROCRYPT 2000</em>, volume 1807 of <em>LNCS</em>, pages 470–484. Springer, 2000.</li>

      <li><span id="page-30-8"></span>[Men15] Bart Mennink. Optimally Secure Tweakable Blockciphers. In Gregor Leander, editor, <em>Fast Software Encryption - FSE 2015</em>, volume 9054 of <em>LNCS</em>, pages 428–448. Springer, 2015. Full version available at <a href="http://eprint.iacr.org/2015/363">http:</a> <a href="http://eprint.iacr.org/2015/363">//eprint.iacr.org/2015/363</a>.</li>

      <li><span id="page-30-7"></span>[Min09] Kazuhiko Minematsu. Beyond-Birthday-Bound Security Based on Tweakable Block Cipher. In Orr Dunkelman, editor, <em>Fast Software Encryption - FSE 2009</em>, volume 5665 of <em>LNCS</em>, pages 308–326. Springer, 2009.</li>

      <li><span id="page-30-3"></span>[MV04] David A. McGrew and John Viega. The Security and Performance of the Galois/Counter Mode (GCM) of Operation. In Anne Canteaut and Kapalee Viswanathan, editors, <em>Progress in Cryptology - INDOCRYPT 2004</em>, volume 3348 of <em>LNCS</em>, pages 343–355. Springer, 2004.</li>

      <li><span id="page-30-6"></span>[NRS14] Chanathip Namprempre, Phillip Rogaway, and Thomas Shrimpton. Reconsidering Generic Composition. In Phong Q. Nguyen and Elisabeth Oswald, editors, <em>Advances in Cryptology - EUROCRYPT 2014</em>, volume 8441 of <em>LNCS</em>, pages 257–274. Springer, 2014.</li>

      <li><span id="page-30-12"></span>[Pat08a] Jacques Patarin. A Proof of Security in <em>O</em>(2<em><sup>n</sup></em> ) for the Xor of Two Random Permutations. In Reihaneh Safavi-Naini, editor, <em>Information Theoretic Security - ICITS 2008</em>, volume 5155 of <em>LNCS</em>, pages 232–248. Springer, 2008. Full version available at <http://eprint.iacr.org/2008/010>.</li>

      <li><span id="page-30-10"></span>[Pat08b] Jacques Patarin. The "Coefficients H" Technique. In Roberto Maria Avanzi, Liam Keliher, and Francesco Sica, editors, <em>Selected Areas in Cryptography - SAC 2008</em>, volume 5381 of <em>LNCS</em>, pages 328–345. Springer, 2008.</li>

      <li><span id="page-30-13"></span>[Pat13] Jacques Patarin. Security in <em>O</em>(2<em><sup>n</sup></em> ) for the Xor of Two Random Permutations: Proof with the Standard <em>H</em> Technique. IACR Cryptology ePrint Archive, Report 2013/368, 2013. Available at <a href="http://eprint.iacr.org/2013/368">http://eprint.iacr.org/</a> <a href="http://eprint.iacr.org/2013/368">2013/368</a>.</li>

      <li><span id="page-30-1"></span>[RBB03] Phillip Rogaway, Mihir Bellare, and John Black. OCB: A block-cipher mode of operation for efficient authenticated encryption. <em>ACM Trans. Inf. Syst. Secur.</em>, 6(3):365–403, 2003.</li>

      <li><span id="page-30-0"></span>[Rog02] Phillip Rogaway. Authenticated-encryption with associated-data. In Vijayalakshmi Atluri, editor, <em>ACM Conference on Computer and Communications Security - CCS 2002</em>, pages 98–107. ACM, 2002.</li>

      <li><span id="page-30-2"></span>[Rog04a] Phillip Rogaway. Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. In Pil Joong Lee, editor, <em>Advances in Cryptology - ASIACRYPT 2004</em>, volume 3329 of <em>LNCS</em>, pages 16–31. Springer, 2004.</li>

      <li><span id="page-30-9"></span>[Rog04b] Phillip Rogaway. Nonce-Based Symmetric Encryption. In Bimal K. Roy and Willi Meier, editors, <em>Fast Software Encryption - FSE 2004</em>, volume 3017 of <em>LNCS</em>, pages 348–359. Springer, 2004.</li>

      <li><span id="page-30-4"></span>[RS06] Phillip Rogaway and Thomas Shrimpton. A Provable-Security Treatment of the Key-Wrap Problem. In Serge Vaudenay, editor, <em>Advances in Cryptology - EUROCRYPT 2006</em>, volume 4004 of <em>LNCS</em>, pages 373–390. Springer, 2006.</li>

      <li><span id="page-30-5"></span>[Sho96] Victor Shoup. On Fast and Provably Secure Message Authentication Based on Universal Hashing. In Neal Koblitz, editor, <em>Advances in Cryptology - CRYPTO '96</em>, volume 1109 of <em>LNCS</em>, pages 313–328. Springer, 1996.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-31-5"></span>[Sho04] Victor Shoup. Sequences of Games: A Tool for Taming Complexity in Security Proofs. IACR Cryptology ePrint Archive, Report 2004/332, 2004. Available at http://eprint.iacr.org/2004/332.pdf.</li>

      <li><span id="page-31-2"></span>[ST13] Thomas Shrimpton and R. Seth Terashima. A Modular Framework for Building Variable-Input-Length Tweakable Ciphers. In Kazue Sako and Palash Sarkar, editors, <em>Advances in Cryptology - ASIACRYPT 2013 (Proceedings, Part I)</em>, volume 8269 of <em>LNCS</em>, pages 405–423. Springer, 2013.</li>

      <li><span id="page-31-0"></span>[Vau02] Serge Vaudenay. Security Flaws Induced by CBC Padding - Applications to SSL, IPSEC, WTLS ... In Lars R. Knudsen, editor, Advances in Cryptology - EUROCRYPT 2002, volume 2332 of LNCS, pages 534–546. Springer, 2002.</li>

      <li><span id="page-31-3"></span>[WC81] Mark N. Wegman and Larry Carter. New Hash Functions and Their Use in Authentication and Set Equality. J. Comput. Syst. Sci., 22(3):265–279, 1981</li>

      <li><span id="page-31-1"></span>[WHF02] Doug Whiting, Russ Housley, and Niels Ferguson. Counter with CBC-MAC (CCM). Submission to NIST, 2002. Available at http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ccm/ccm.pdf.</li>

      <li><span id="page-31-4"></span>[Yas11] Kan Yasuda. A New Variant of PMAC: Beyond the Birthday Bound. In Phillip Rogaway, editor, <em>Advances in Cryptology - CRYPTO 2011</em>, volume 6841 of <em>LNCS</em>, pages 596–609. Springer, 2011.</li>

    </ul>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">A Proof of Theorem 4</h4>

    <p class="text-gray-300">Let  <span class="math">\\widetilde{H} = \\mathsf{NSIV}[F,H]</span>  and let  <span class="math">\\mathsf{A}</span>  be a  <span class="math">(q,m,\\ell,\\sigma,t)</span> -adversary against  <span class="math">\\widetilde{H}</span>  (we do not specify whether  <span class="math">\\mathsf{A}</span>  is nonce-respecting or not yet). We denote</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} W_1 &amp;= (\\widetilde{\\varPi}.\\mathsf{Enc}_{K_1,K_2},\\widetilde{\\varPi}.\\mathsf{Dec}_{K_1,K_2}), \\\\ W_4 &amp;= (\\mathsf{Rand},\\mathsf{Rej}) \\end{split}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">the two worlds that A must tell apart, where  <span class="math">\\mathsf{Rand}(N,A,M)</span>  returns a random string of length  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widetilde{H}.\\mathsf{Enc}_{K_1,K_2}(N,A,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>\\mathsf{Rej}<span class="math">  always returns  </span>\\bot<span class="math"> . We introduce intermediate worlds  </span>W_2^{\\mathrm{AE}}<span class="math"> ,  </span>W_2^{\\mathrm{nAE}}<span class="math"> , and  </span>W_3<span class="math"> . As the names suggest,  </span>W_2^{\\mathrm{AE}}<span class="math"> , resp.  </span>W_2^{\\mathrm{nAE}}<span class="math"> , will be used for nonce-misuse, resp. nonce-respecting adversaries, while  </span>W_3<span class="math">  will be used in both cases. In  </span>W_2^{\\mathrm{AE}}<span class="math"> , we replace  </span>F_{K_1}<span class="math">  by a uniformly random function  </span>\\rho: \\mathcal{N} \\times \\mathcal{D} \\to \\mathcal{Y}<span class="math">  in both the encryption and decryption algorithms. Formally, letting  </span>\\widetilde{H}' = \\mathsf{NSIV}[\\mathsf{Func}(\\mathcal{N} \\times \\mathcal{D}, \\mathcal{Y}), H]$ , we define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">W_2^{\\mathrm{AE}} = (\\widetilde{\\varPi}&#x27;.\\mathsf{Enc}_{\\rho,K_2},\\widetilde{\\varPi}&#x27;.\\mathsf{Dec}_{\\rho,K_2}).</span></div>

    <p class="text-gray-300">In  <span class="math">W_2^{\\text{nAE}}</span> , on the other hand, we replace the decryption algorithm of  <span class="math">W_1</span>  by an always-rejecting oracle, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">W_2^{\\mathrm{nAE}} = (\\widetilde{\\varPi}.\\mathsf{Enc}_{K_1,K_2},\\mathsf{Rej}).</span></div>

    <p class="text-gray-300">Finally, world  <span class="math">W_3</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">W_3=(\\widetilde{\\varPi}&#x27;.\\mathsf{Enc}_{\\rho,K_2},\\mathsf{Rej}).</span></div>

    <p class="text-gray-300">We first consider A's advantage in distinguishing  <span class="math">W_3</span>  from  <span class="math">W_4</span> . Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{3,4} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf{A}^{W_3} = 1 \\right] - \\Pr \\left[ \\mathsf{A}^{W_4} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider the adversary A' against the nivE-security of  <span class="math">\\Pi</span>  working as follows. Let  <span class="math">G \\in \\{\\Pi.\\mathsf{Enc}_{K_2}^\\</span>,\\mathsf{Rand'}\\}<span class="math">  be the oracle to which A&#x27; has access, where  </span>\\mathsf{Rand'}(N,M)<span class="math">  returns a random string of length  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi.\\mathsf{Enc}_{K_2}^\\$(N,M)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Adversary A&#x27; runs A. When A asks an encryption query (N,A,M), A&#x27; queries G(N,M), thereby obtaining an answer (IV,C). It samples uniformly at random tag in the set of preimages  </span>\\mathsf{Conv}^{-1}(IV)<span class="math">  and returns  </span>(C,\\mathsf{tag})<span class="math">  to A. When A asks a decryption query, A&#x27; simply answers  </span>\\bot<span class="math"> . When A halts and outputs some bit, A&#x27; outputs the same bit. Note that independently of whether G is  </span>\\Pi.\\mathsf{Enc}_{K_2}^\\<span class="math-block">  or  <span class="math">\\mathsf{Rand&amp;#x27;}</span> , the first element IV in its answers is uniformly random, and hence tag is uniformly random as well since  <span class="math">\\mathsf{Conv}</span>  is regular. It follows that A&#x27; perfectly simulates  <span class="math">W_3</span>  when  <span class="math">G = \\Pi.\\mathsf{Enc}_{K_2}^\\&lt;/span&gt; , and perfectly simulates  </span>W_4<span class="math">  when  </span>G = \\mathsf{Rand'}<span class="math"> . Moreover, it is easy to see that A&#x27; is a  </span>(q,m,\\ell,\\sigma,t')$ -adversary. In particular, A' is nonce-respecting iff A is nonce-respecting. Hence,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta_{3,4} \\leq \\mathbf{Adv}_{II}^{\\text{nivE}}(\\mathsf{A}&#x27;) \\quad \\text{or} \\quad \\delta_{3,4} \\leq \\mathbf{Adv}_{II}^{\\text{ivE}}(\\mathsf{A}&#x27;),</span></div>

    <p class="text-gray-300">depending on whether A is nonce-respecting or not.</p>

    <p class="text-gray-300">We now prove part (a) of the theorem, assuming  <span class="math">{\\sf A}</span>  is allowed to repeat nonces. Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{1,2}^{\\mathrm{AE}} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr} \\left[ \\mathsf{A}^{W_1} = 1 \\right] - \\mathrm{Pr} \\left[ \\mathsf{A}^{W_2^{\\mathrm{AE}}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let A" be the following adversary against the PRF-security of F. Denote  <span class="math">G \\in \\{F_{K_1}, \\rho\\}</span>  the oracle to which A" has access. Adversary A" picks a random  <span class="math">K_2 \\leftarrow_{\\</span>} K_2<span class="math">  and runs A. When A makes an encryption query (N, A, M), or a decryption query  </span>(N, A, C, \\mathsf{tag})<span class="math"> , A&quot; simply executes the corresponding code of Fig. 4, replacing all calls to  </span>F_{K_1}<span class="math">  by a call to its oracle G. When A halts and outputs some bit, A&quot; outputs the same bit. Then A&quot; perfectly simulates  </span>W_1<span class="math">  when  </span>G = F_{K_1}<span class="math">  for some random key  </span>K_1<span class="math"> , and perfectly simulates world  </span>W_2<span class="math">  when  </span>G = \\rho<span class="math">  for some random random function  </span>\\rho$ , so that</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{1,2}^{AE} \\leq \\mathbf{Adv}_F^{PRF}(\\mathsf{A}&#x27;&#x27;).</span></div>

    <p class="text-gray-300">Moreover, it is easy to see that  <span class="math">\\mathsf{A}&#x27;&#x27;</span>  is a  <span class="math">(q,q,\\ell,\\sigma,t&#x27;)</span> -adversary. <sup>15</sup> Next, we upper bound</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{2,3}^{\\mathrm{AE}} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr} \\left[ \\mathsf{A}^{W_2^{\\mathrm{AE}}} = 1 \\right] - \\mathrm{Pr} \\left[ \\mathsf{A}^{W_3} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For this, we simply apply the H-coefficients technique. See  <span class="math">W_2^{AE}</span>  as the ideal world and  <span class="math">W_3</span>  as the real world in the language of Lemma 1, and define a bad</p>

    <p class="text-gray-300"><span id="page-32-0"></span>Note that A" may repeat nonces in its oracle queries even when A is nonce-respecting because a nonce-respecting A is allowed to repeat nonces in <em>decryption</em> queries. This is why this transition from  <span class="math">W_1</span>  to  <span class="math">W_2^{AE}</span>  cannot be used for a nonce-respecting adversary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">transcript as a transcript which contains a decryption query which returned  <span class="math">M \\neq \\bot</span> . Consequently, an attainable transcript  <span class="math">\\tau</span>  is good if it only contains decryption queries that were answered by  <span class="math">\\perp</span> . Since the encryption oracles are exactly the same in worlds  <span class="math">W_2^{AE}</span>  and  <span class="math">W_3</span> , and since the right (decryption) oracle always rejects in world  <span class="math">W_3</span> , it follows that for any good transcript  <span class="math">\\tau</span> ,  <span class="math">\\Pr[\\Theta_{re} = \\tau] \\ge \\Pr[\\Theta_{id} = \\tau]</span> . It remains to upper bound  <span class="math">\\Pr[\\Theta_{id} \\in \\mathsf{BadT}]</span> , i.e., the probability that the adversary makes a decryption query that returns  <span class="math">M \\neq \\bot</span>  in world  <span class="math">W_2^{AE}</span> . Consider a decryption query  <span class="math">(N, A, C, \\mathsf{tag})</span> , and let  <span class="math">IV = \\mathsf{Conv}(\\mathsf{tag})</span> and  <span class="math">M = \\Pi.Dec_{K_2}(N, IV, C)</span> . Assume first that there was a previous encryption query (N, A, M) that returned (C, tag'). By our assumption that the adversary never asks a decryption query (N, A, C, tag') if a previous encryption query (N, A, M) returned  <span class="math">(C, \\mathsf{tag&#x27;})</span> , one necessarily has  <span class="math">\\mathsf{tag} \\neq \\mathsf{tag&#x27;} = \\rho(N, A, M)</span> , so that the decryption oracle necessarily returns  <span class="math">\\perp</span> . Hence, the adversary is essentially trying to guess a random value  <span class="math">\\rho(N, A, M)</span>  within at most q(N, A, M) trials, where q(N, A, M) is the number of decryption queries of the form (N, A, C, tag)with  <span class="math">C = \\Pi.\\mathsf{Enc}_{K_2}(N,\\mathsf{Conv}(\\mathsf{tag}),M)</span> , something it can achieve with probability at most  $q(N, A, M)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Summing over all possible values of (N, A, M), we obtain that  </span>\\Pr[\\Theta_{id} \\in \\mathsf{BadT}] \\leq q/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ . Hence, by Lemma 1, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{2,3}^{AE} \\le \\frac{q}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{Y}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The result follows since  <span class="math">\\mathbf{Adv}_{\\widetilde{II}}^{\\mathrm{AE}}(\\mathsf{A}) \\leq \\delta_{1,2}^{\\mathrm{AE}} + \\delta_{2,3}^{\\mathrm{AE}} + \\delta_{3,4}</span> . Let us now prove part (b) of the theorem, assuming A is nonce-respecting. Let</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{2,3}^{\\mathrm{nAE}} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\mathsf{A}^{W_{2}^{\\mathrm{nAE}}} = 1 \\right] - \\Pr \\left[ \\mathsf{A}^{W_{3}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let A" be the following adversary against the nPRF-security of F. Denote  <span class="math">G \\in</span>  <span class="math">\\{F_{K_1}, \\rho\\}</span>  the oracle to which A" has access. Adversary A" samples  <span class="math">K_2 \\leftarrow_{\\</span>} \\mathcal{K}_2<span class="math">  and runs A. When A makes an encryption query (N, A, M), A&quot; asks query (N, A, M)to its G oracle to get the corresponding tag value, computes IV = Conv(tag) and  </span>C = \\Pi.\\mathsf{Enc}_{K_2}(N, IV, M)<span class="math"> , and returns  </span>(C, \\mathsf{tag})<span class="math"> . When A asks a decryption query, A&#x27;&#x27; simply returns  </span>\\bot<span class="math"> . When A halts and returns some output bit, A&#x27;&#x27; outputs the same bit. It is easy to see that A&quot; perfectly simulates  </span>W_2^{\\text{nAE}}<span class="math">  when  </span>G = F_{K_1}<span class="math"> while it perfectly simulates  </span>W_3<span class="math">  when  </span>G = \\rho<span class="math"> . Moreover, it is easy to see that A&quot; is a  </span>(q, 1, \\ell, \\sigma, t')$ -adversary and in particular A" is nonce-respecting because A is nonce-respecting. Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{2,3}^{\\text{nAE}} \\leq \\mathbf{Adv}_F^{\\text{nPRF}}(\\mathsf{A}&#x27;&#x27;).</span></div>

    <p class="text-gray-300">It remains to upper bound</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\delta_{1,2}^{\\mathrm{nAE}} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Pr} \\left[ \\mathsf{A}^{W_1} = 1 \\right] - \\mathrm{Pr} \\left[ \\mathsf{A}^{W_2^{\\mathrm{nAE}}} = 1 \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let A''' be the following adversary against the nMAC-security of F. Denote  <span class="math">(F_{K_1}, G)</span>  the two oracles to which A''' has access, with  <span class="math">G \\in \\{Ver_{K_1}, Rej\\}</span> . Adversary A''' samples  <span class="math">K_2 \\leftarrow_{\\</span>} \\mathcal{K}_2<span class="math">  and runs A. When A makes a encryption query (N, A, M), A&quot;&quot; asks query (N,A,M) to its  </span>F_{K_1}<span class="math">  oracle to get the corresponding tag value, computes  </span>IV = \\mathsf{Conv}(\\mathsf{tag})<span class="math">  and  </span>C = II.\\mathsf{Enc}_{K_2}(N,IV,M)<span class="math"> , and returns  </span>(C,\\mathsf{tag})<span class="math"> . When A asks a decryption query  </span>(N,A,C,\\mathsf{tag})<span class="math"> , A&quot;&quot; computes  </span>IV = \\mathsf{Conv}(\\mathsf{tag})<span class="math">  and  </span>M = II.\\mathsf{Dec}_{K_2}(N,IV,C)<span class="math"> , asks query  </span>(N,A,M,\\mathsf{tag})<span class="math">  to its oracle G, and returns M if  </span>G(N,A,M,\\mathsf{tag}) = 1<span class="math">  or  </span>\\bot<span class="math">  if  </span>G(N,A,M,\\mathsf{tag}) = \\bot<span class="math"> . When A halts and returns some output bit, A&quot;&quot; outputs the same bit. It is easy to see that A&quot;&quot; perfectly simulates  </span>W_1<span class="math">  when  </span>G = \\mathsf{Ver}_{K_1}<span class="math"> , while it perfectly simulates  </span>W_2^{\\mathsf{nAE}}<span class="math">  when  </span>G = \\mathsf{Rej}<span class="math"> . Moreover, it is easy to see that A&quot;&quot; is a  </span>(q,1,\\ell,\\sigma,t')$ -adversary and in particular A"" is nonce-respecting because A is nonce-respecting. Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\delta_{1,2}^{\\text{nAE}} \\leq \\mathbf{Adv}_{F}^{\\text{nMAC}}(\\mathsf{A}&#x27;&#x27;&#x27;).</span></div>

    <p class="text-gray-300">The result follows since  <span class="math">\\mathbf{Adv}^{\\mathrm{nAE}}_{\\widetilde{\\mathcal{H}}}(\\mathsf{A}) \\leq \\delta^{\\mathrm{nAE}}_{1,2} + \\delta^{\\mathrm{nAE}}_{2,3} + \\delta_{3,4}</span> .</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">B Variants of the CTRT Mode</h4>

    <p class="text-gray-300">A Pure Nonce-Based Variant. From CTRT, we can define a purely nonce-based encryption scheme by simply generating the IV in a pseudorandom way from the nonce N. Namely, if  <span class="math">\\widetilde{E}</span>  has tweak space  <span class="math">\\mathcal{T}&#x27; = \\{0,1\\} \\times \\mathcal{T}</span> , then let</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} IV &amp;= \\mathsf{Conv}\\big(\\widetilde{E}_K^{(0,0)}(N)\\big), \\\\ C &amp;= \\mathsf{CTRT}[\\widetilde{E}].\\mathsf{Enc}_K(N,IV,M), \\end{split}</span></div>

    <p class="text-gray-300">where Conv is a regular function from  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{IV} = \\mathcal{T}</span> . We denote the resulting mode NCTRT, and it is illustrated in Fig. 5 (gray box). This mode will be useful when defining the online scheme CTPWC in Section C.</p>

    <p class="text-gray-300">Clearly, the NCTRT mode offers no security against an adversary allowed to repeat nonces. Against nonce-respecting adversaries however, this mode enjoys a security bound very close to the one of Theorem 1 (b). The only differences are an increase in the number of oracle queries made by adversary A' (since there is an additional call to  <span class="math">\\widetilde{E}_K</span>  for each encryption query), and the fact that the IV's are not uniformly random any more since they are generated by applying Conv to values  <span class="math">\\widetilde{E}_K^{(0,0)}(N)</span>  drawn (up to replacing  <span class="math">\\widetilde{E}_K^{(0,0)}</span>  by a random permutation) uniformly at random without replacement. The only modification to bring to the proof of Theorem 1 is in Lemma 4 dealing with condition (C-2) defining a bad transcript. Namely, given two pairs of indices (i,j) and (i',j') such that  <span class="math">i \\neq i&#x27;</span> , the probability, over the draw of  <span class="math">IV_i</span>  and  <span class="math">IV_{i&#x27;}</span>  uniformly random and distinct in  <span class="math">\\mathcal{X}</span> , that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span> , is at most</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-34-1"></span>One could, of course, replace  <span class="math">\\widetilde{E}_K^{(0,0)}</span>  by a random function in the security proof, but this would require the PRP-PRF switching lemma and one would bump into the birthday bound.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">since each point in  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  has exactly  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  preimages by Conv. (If i=i&#x27; and  </span>j \\neq j'<span class="math"> , we necessarily have  </span>IV_{i,j} \\neq IV_{i',j'}$ .) Hence condition (C-2) is satisfied with probability at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\sigma^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)} = \\frac{\\sigma^2}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">which is also an upper bound for the advantage of any distinguisher against NCTRT[E] when E is ideal (since condition (C-1) can never be met for a noncerespecting adversary).</p>

    <p class="text-gray-300">Remark 4. A more straightforward way to generate a uniformly random IV for each new nonce would be to put the nonce in the tweak, by letting for example  <span class="math">IV = \\mathsf{Conv}(\\widetilde{E}_K^{(0,N)}(0))</span> . However, this is only possible when the intended nonce space is smaller than the effective tweak space  <span class="math">\\mathcal{T}</span>  of  <span class="math">\\widetilde{E}</span> . Note that, starting from a block cipher with t-bit tweaks, the nonce in that case can be of length at most t-1 bits because of tweak separation.</p>

    <p class="text-gray-300">A Pure IV-Based Variant. We can also define a purely IV-based variant of CTRT. For this, rename N in CTRT IV', and assume that both IV and IV'are chosen uniformly at random at each encryption call. Call the resulting mode IVCTRT. The security of this variant can be easily derived by slightly adapting the proof of Theorem 1. The only change is in the definition of bad transcripts, namely conditions (C-1) and (C-2) defining a bad transcript now become:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(C-1) there exists  <span class="math">(i,j) \\neq (i&#x27;,j&#x27;)</span>  such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span>  and  <span class="math">IV_i&#x27; = IV_{i&#x27;}&#x27;</span> ; (C-2) there exists  <span class="math">(i,j) \\neq (i&#x27;,j&#x27;)</span>  such that  <span class="math">IV_{i,j} = IV_{i&#x27;,j&#x27;}</span> ,  <span class="math">IV_i&#x27; \\neq IV_{i&#x27;}&#x27;</span> , and  <span class="math">M_{i,j} \\oplus C_{i,j} = M_{i&#x27;,j&#x27;} \\oplus C_{i&#x27;,j&#x27;}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability of condition (C-1) is now at most  $\\sigma^2/(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> , while the probability of (C-2) is also upper bounded by  </span>\\sigma^2/(2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  as in Lemma 4. Hence, when E is ideal, the advantage of any adversary A against IVCTRT[E] is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\frac{\\sigma^2}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-16" class="text-lg font-semibold mt-6"><span class="math">\\mathbf{C}</span> The Online CTPWC Mode</h4>

    <p class="text-gray-300">In this section, we propose a nonce-based, online AEAD mode called CTPWC (Counter-in-Tweak then Parallel Wegman-Carter). It combines in an "encryptthen-MAC" manner the NCTRT nonce-based encryption mode described in Appendix B and the nonce-based keyed function PWC of Section 5. More precisely, according to the NRS nomenclature [NRS14], it uses the N2 generic composition method: on input (N, A, M), compute  <span class="math">C = \\mathsf{NCTRT}[E]_K(N, M)</span> ,  <span class="math">tag = PWC[\\widetilde{E}]_K(N, A, C)</span> , and return (C, tag). This is illustrated in Fig. 5. The nAE-security of this mode is tightly related to the security (as a nonce-based encryption scheme [NRS14]) of NCTRT and the nPRF- and nMAC-security of PWC given in Theorems 2 and 3. We omit the details.</p>

    <p class="text-gray-300"><img src="_page_36_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-36-0"></span>Fig. 5. The CTPWC mode, using a TBC  <span class="math">\\widetilde{E}</span>  with tweak space  <span class="math">\\{0,\\ldots,5\\} \\times \\mathcal{T}</span>  and domain  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span> . It is obtained by applying the "encrypt-then-MAC" composition method to NCTRT and PWC. We recall that  <span class="math">\\widetilde{E}_K^i(T,X) = \\widetilde{E}_K((i,T),X)</span>  and that  <span class="math">\\widetilde{E}_K^{i,j}</span>  means that prefix i is used when the input block is complete and unpadded, whereas j is used when the input block is incomplete and padded. Function Inc is a cyclic permutation of  <span class="math">\\mathcal{T}</span> , and Conv is a regular function from  <span class="math">\\mathcal{X}</span>  to  <span class="math">\\mathcal{T}</span>  (e.g., truncation when  <span class="math">\\mathcal{X} = \\{0,1\\}^n</span>  and  <span class="math">\\mathcal{T} = \\{0,1\\}^w</span>  with  <span class="math">w \\leq n</span> ).</p>`;
---

<BaseLayout title="Counter-in-Tweak: Authenticated Encryption Modes for Tweakab... (2015/1049)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1049
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="counter-in-tweak-authenticated-encryption-modes-for-2015" />
  </article>
</BaseLayout>
