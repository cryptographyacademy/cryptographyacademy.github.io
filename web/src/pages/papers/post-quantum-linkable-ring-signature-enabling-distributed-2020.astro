---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1121';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Post-Quantum Linkable Ring Signature Enabling Distributed Authorised Ring Confidential Transactions in Blockchain';
const AUTHORS_HTML = 'Wilson Alberto Torres, Ron Steinfeld, Amin Sakzad, Veronika Kuchta';

const CONTENT = `    <p class="text-gray-300">Wilson Alberto Torres (☑), Ron Steinfeld, Amin Sakzad, Veronika Kuchta</p>

    <p class="text-gray-300">Faculty of Information Technology, Monash University Melbourne, Australia {Wilson.Torres,Ron.Steinfeld, Amin.Sakzad,Veronika.Kuchta}@monash.edu</p>

    <p class="text-gray-300">Abstract. When electronic wallets are transferred by more than one party, the level of security can be enhanced by decentralising the distribution of authorisation amongst those parties. Threshold signature schemes enable this functionality by allowing multiple cosigners to cooperate in order to create a joint signature. These cosigners interact to sign a transaction which then confirms that a wallet has been transferred. However, in the event of a post-quantum attack, existing threshold signature schemes that support such an authorisation technique in privacy-preserving cryptocurrency protocols - like Ring Confidential Transaction (RingCT) - would not provide adequate security.</p>

    <p class="text-gray-300">In this paper, we present a new post-quantum cryptographic mechanism, called Lattice-based Linkable Ring Signature with Co-Signing (L2RS-CS), which offers a distributed authorisation feature to protect electronic wallets. A novel security model for L2RS-CS is also formalised to capture the security and privacy requirements to protect transactions in applications to blockchain cryptocurrency protocols, such as the RingCT. To address key-generation security concerns, and to support compression of keys and signatures, the L2RS-CS incorporates a distributed key generation along with a solid public-key aggregation. Finally, we prove the security of our constructed L2RS-CS in the random oracle model and the standard lattice-based Module-SIS hardness assumption.</p>

    <p class="text-gray-300">Keywords: Lattice-Based Cryptography, Post-Quantum Cryptography, Privacy-Preserving Protocols, Cryptocurrencies, Threshold Signatures, RingCT</p>

    <p class="text-gray-300">The notion of <span class="math">(t,n)</span>-Threshold Signature (TS) schemes was initially conceptualised by Desmedt and Frankel in [18]. They defined TS as a cryptographic protocol where a subset of size <span class="math">t</span> out of <span class="math">n</span> cosigners collaborates to jointly sign a given message <span class="math">m</span>. Contrary to standard digital signatures, TS splits the secret key (sk) into multiple shares distributed across <span class="math">n</span> participants. Later, an</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">interactive protocol is performed with at least the threshold number of cosigners (<span class="math">t</span> out of <span class="math">n</span>) to produce a signature. TS constructions contain several benefits including reliability and security. For instance, TS is employed to augment the confidentiality of secret keys, increase the resilience against secret key exposure, and enable decentralisation of trust <em>[10]</em>. Furthermore, metering applications <em>[17]</em> utilise TS to measure the interaction between servers and clients so e-business can charge fees for advertisements. Similarly, blockchain technology, particularly cryptocurrencies <em>[27]</em>, incorporates TS schemes to provide an extra, more restrictive layer of security. More specifically, this involves the authorisation in digital currencies where a certain number of parties collaborates to approve electronic payments.</p>

    <p class="text-gray-300">Securing the cryptographic keys is always crucial to attaining a respectable level of reliability in any secure cryptocurrency application. Since the digital wallets can be spent with their sk’s, this would be a single point of vulnerability. For instance, if such sk’s are stolen or lost, the owners of the corresponding wallets would be unable to access their funds. Consequently, TS protocols enable this authorisation property to segregate the ownership of digital wallets. Besides TS schemes increasing the difficulty for adversaries to mount an attack (as multiple cosigners need to be compromised), they also offer redundancy, which might protect sk’s from being lost <em>[21]</em>. In addition, there are other mechanisms that help to secure the generation of cryptographic keys in digital currencies. The Distributed Key Generation (DKG) protocol guarantees that nobody learns about the sk during the execution of the protocol <em>[26, 44]</em>. DKG also operates in a complete decentralised distribution of the trust among the parties, so it requires no trusted party. The public-key aggregation is another mechanism that allows the public verifier to only see the aggregate public-key rather than the cosigners’ public-keys, providing more favourable privacy and performance results <em>[4, 9, 35]</em>. The integration of these controls would prevent the well-known rogue key (or key cancellation) attacks where a dishonest actor is capable of signing transactions on behalf of honest cosigners <em>[4, 28, 44]</em>.</p>

    <p class="text-gray-300">The security concept of most cryptographic primitives and protocols is changing due to the foreseeable presence of a sufficiently powerful quantum computer. The security assumptions of public-key cryptography that are based on the classical number theory would be efficiently broken in the event of large-scale quantum computers becoming practical <em>[39]</em>. Nowadays, post-quantum cryptographers are devising new algorithms in anticipation of quantum attacks. Among the several approaches proposed to address this concern, lattice-based cryptography appears to be a practical alternative to both classical cryptography and this quantum computing threat. Many lattice-based schemes and protocols have shown optimal performance, simplicity, and reliable security proofs based on the worst-case hardness assumptions, meaning that at least one instance of the lattice problem is hard to solve. Moreover, lattice-based cryptosystems even allow powerful new classes of cryptographic mechanisms, such as fully homomorphic encryption and functional encryption <em>[2, 12, 13, 45]</em>.</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">The Ring Confidential Transaction (RingCT) <em>[37]</em> is a cryptographic protocol that is widely employed by Monero, one of the most popular cryptocurrencies to date. The RingCT performs e-commerce operations in a decentralised network while maintaining <em>complete-anonymity</em> for the parties involved and also preventing double spending coins <em>[16]</em>. These security properties are achieved by employing <em>Linkable Ring Signature</em> (LRS) schemes <em>[31]</em>. In the RingCT framework, <em>complete-anonymity</em> provides a remarkable advantage since other cryptocurrencies, such as Bitcoin, are only <em>pseudo-anonymous</em> <em>[29]</em>. Further improvements were proposed in RingCT 2.0 <em>[43]</em> and RingCT 3.0 <em>[50]</em>. These presented formal definitions for both the cryptocurrency protocol and the corresponding security model. Moreover, certain variants of RingCT incorporate an authorisation feature for distributed and co-signing digital wallets by adapting a combination of TS and <em>Ring Signature</em> (RS) schemes <em>[4, 28]</em>. However, this authorisation model has been constructed with number theory assumptions and thus it would be insecure against quantum attacks. In the <em>post-quantum</em> setting, the first Lattice-based RingCT (LRCT) was devised in <em>[1, 3]</em>. The LRCT uses the Bimodal Lattice-based Signature Scheme (BLISS) <em>[19]</em>, a demonstrated, practical and secure lattice-based digital signature <em>[19, 20]</em>, as an underlying building block. In a recent study, an efficient, scalable and practical lattice-based RingCT protocol was devised in <em>[22]</em>. Nonetheless, these <em>post-quantum</em> approaches did not incorporate an authorisation model in their design which, as discussed above, can be achieved by using TS schemes.</p>

    <p class="text-gray-300">Related Works. Several TS schemes have been proposed after its introduction in <em>[18]</em>. Most of the existing TS schemes <em>[23, 24, 25, 8, 40]</em> and <em>Threshold Ring Signature</em> (TRS) schemes <em>[32, 38, 30, 46, 48, 49, 11]</em> have been designed with the classical cryptographic assumptions, and only a few constructions are lattice-based. The first lattice-based TRS <em>[14]</em> was devised based on an identification scheme and the standard lattice-based Short Integer Solution (SIS) hardness problem. The signature size of this scheme was around 25 MB with <span class="math">t=50</span> and <span class="math">n=100</span>. Later, a new study <em>[7]</em> proposed an enhanced version of <em>[14]</em>. The authors modified this model for the anonymity property, which brought improvements to the signature size (around 13 MB with same ring and threshold sizes as <em>[14]</em>). In <em>[47]</em>, an ID-Based TRS from lattices was designed in the random oracle model. The security properties therein relied on a non-standard lattice-based assumption that they defined as a general Graded Computational Diffie-Hellman Problem (gCDHP). Another scheme was constructed in <em>[15]</em> to be applied in a message block sharing application; however, its analysis disregarded the evaluation of the best known lattice attacks, and overlooked a security reduction in the standard lattice-based Ring-SIS problem seemingly used in this work. However, since DKG protocols are not utilised in their designs, in all likelihood these lattice-based proposals will find themselves vulnerable to rogue key attacks. In addition, they are incompatible with the linkability technique.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Contributions</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We construct the first <em>post-quantum</em> Lattice-based Linkable Ring Signature with Co-Signing (L2RS-CS) scheme which can be adapted to a <em>post-quantum</em></li>

    </ul>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">cryptocurrency protocol such as the LRCT [1]. The L2RS-CS offers complete-anonymity, and can support Multiple Input wallets to be transferred to Multiple Output wallets (MIMO). The L2RS-CS is built on top of the post-quantum LRS from [3] and integrates a DKG together with a solid public-key aggregation (in the post-quantum settings) which bring a high level of security and compression for the cosigners' keys.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Additionally, we formalise another new security model, called Linkable Ring Signature with Co-Signing (LRS-CS), having a special combination of two constructions, the  <span class="math">(N_{CS}</span> -out-of- <span class="math">N_{CS}</span> )-TS and (1-out-of- <span class="math">w</span> )-LRS schemes (which are used in Monero [4, 28]). Although TRS can be seen as a combination of TS and RS schemes, it is a different type of primitive to our proposed LRS-CS. Namely, in TRS any subset of  <span class="math">t</span>  out of  <span class="math">n</span>  signers can cooperate to generate a signature while hiding the signers' subset. In contrast, under our LRS-CS model, there are  <span class="math">w</span>  groups of  <span class="math">N_{CS}</span>  cosigners, so that all the  <span class="math">N_{CS}</span>  signing keys within the signing group cooperate to produce the signature while hiding the signers among the  <span class="math">w</span>  groups. Furthermore, in LRS-CS the  <span class="math">N_{CS}</span>  cosigners interactively generate and share a single public-key, whereas in TRS each cosigner has an individual public-key generated with a non-interactive key-generation algorithm. Therefore, LRS-CS can be viewed as a more specialised primitive than TRS; however, one that suffices for RingCT authorisation and can also be implemented with much shorter signatures than existing lattice-based TRS schemes, as we demonstrate in the evaluation of our scheme.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The security of our proposed L2RS-CS scheme is proven in the classical random oracle model where the properties of unforgeability, linkability and nonslanderability are demonstrated to be computationally secure from the standard lattice-based Module-SIS hardness assumption. In terms of anonymity, we show that this construction is unconditionally secure under the Leftover Hash Lemma (LHL) [19]. Table 1 illustrates a comparison of the existing lattice-based TRS schemes, including our L2RS-CS construction.</li>

    </ul>

    <p class="text-gray-300">Table 1. Lattice-based Threshold Ring Signatures with  <span class="math">t = {50}</span>  and  <span class="math">n = {100}</span>  .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proposals</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Linkability</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DKG</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggregate pk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lattice-based Assumption</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Signature Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cayrel et al. [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">25 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bettaieb et al. [7]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">ISIS</td>

            <td class="px-3 py-2 border-b border-gray-700">13 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Wei et al. [47]</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

            <td class="px-3 py-2 border-b border-gray-700">gGCDHP1</td>

            <td class="px-3 py-2 border-b border-gray-700">NP2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work (L2RS-CS)</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">Module-SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">1.2 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1 general Graded Computational Diffie-Hellman Problem Parameter values and signature sizes were not provided</p>

    <p class="text-gray-300">The remaining paper is structured as follows. In Section 2, we introduce notations and definitions that are used throughout the paper. Following that,</p>

    <p class="text-gray-300">in Section 3, our proposed LRS-CS is defined, and its security model is then explained in Section 4. Next, the construction of the L2RS-CS scheme is described in Section 5. The security and performance analyses are shown in Section 6 and Section 7, respectively.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use a polynomial ring <span class="math">\\mathcal{R}=\\mathbb{Z}[x]/f(x)</span>, where <span class="math">f(x)=x^{n}+1</span> with <span class="math">n</span> being a power of <span class="math">2</span>. The ring <span class="math">\\mathcal{R}_{q}</span> is then defined to be the quotient ring <span class="math">\\mathcal{R}_{q}=\\mathcal{R}/(q\\mathcal{R})=\\mathbb{Z}_{q}[x]/f(x)</span>, where <span class="math">\\mathbb{Z}_{q}</span> denotes the set of all positive integers modulo <span class="math">q</span> (a prime number <span class="math">q=1\\bmod 2n</span>) in the interval <span class="math">\\left[\\lfloor\\frac{-q}{2}\\rfloor,\\lfloor\\frac{q}{2}\\rfloor\\right]</span>. The challenge space <span class="math">\\mathcal{S}_{n,\\kappa}</span>, is the set of all binary vectors of length <span class="math">n</span> and Hamming weight <span class="math">\\kappa</span>. Hash functions are modeled as Random Oracle Model (ROM), <span class="math">H_{0}:\\to\\{0,1\\}^{l}</span>, <span class="math">H_{1}</span> with range <span class="math">\\mathcal{S}_{n,\\kappa}\\subseteq\\mathcal{R}_{2q}</span>, and similarly <span class="math">H_{2}</span> with range <span class="math">\\mathcal{S}_{n,\\kappa_{2}}\\subseteq\\mathcal{R}_{2q}</span>. When we write <span class="math">x\\leftarrow D</span>, for a distribution <span class="math">D</span>, it means that if <span class="math">D</span> is a set then <span class="math">x</span> is chosen uniformly at random from <span class="math">D</span>. The discrete Gaussian distribution over <span class="math">\\mathbb{Z}^{m}</span> with standard deviation <span class="math">\\sigma\\in\\mathbb{R}</span> and center at zero, is defined by <span class="math">D_{\\sigma}^{m}(x)=\\rho_{\\sigma}(x)/\\rho_{\\sigma}(\\mathbb{Z}^{m})</span>, where <span class="math">\\rho_{\\sigma}</span> is the <span class="math">m</span>-dimensional Gaussian function $\\rho_{\\sigma}(x)=\\exp(-\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}/(2\\sigma^{2}))<span class="math"> for </span>x\\in\\mathbb{Z}^{m}<span class="math">. Vector transposition is denoted by </span>\\mathbf{v}^{T}<span class="math">. We say that a function </span>\\mathit{neg}(n)<span class="math"> is negligible in </span>n<span class="math"> if </span>\\mathit{neg}(n)<\\frac{1}{2^{n}}<span class="math">, and a function </span>f(n)<span class="math"> is overwhelming if </span>1-f(n)$ is negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1 (MSIS<span class="math">{}^{\\mathcal{K}}_{q,m,k,\\beta}</span> problem)</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{K}</span> be some uniform distribution over the ring <span class="math">\\mathcal{R}_{q}^{k\\times m}</span>. Given a random matrix <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{k\\times m}</span> sampled from <span class="math">\\mathcal{K}</span>, find a non-zero vector <span class="math">\\mathbf{v}\\in\\mathcal{R}_{q}^{m\\times 1}</span> such that <span class="math">\\mathbf{A}\\mathbf{v}=\\mathbf{0}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\beta<span class="math">, where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}$ denotes the Euclidean norm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-6" class="text-base font-medium mt-4">Lemma 1 (Rejection Sampling)</h6>

    <p class="text-gray-300">(<em>[19]</em>, Lemma 2.1). Let V be an arbitrary set, and <span class="math">h:V\\to\\mathbb{R}</span> and <span class="math">f:\\mathbb{Z}^{m}\\to R</span> be probability distributions. If <span class="math">g_{v}:\\mathbb{Z}^{m}\\to R</span> is a family of probability distributions indexed by <span class="math">v\\in V</span> with the property that there exists a <span class="math">M\\in\\mathbb{R}</span> such that <span class="math">\\forall v\\in V,\\forall\\mathbf{v}\\in\\mathbb{Z}^{m},M\\cdot g_{v}(\\mathbf{z})\\geq f(\\mathbf{z})</span>. Then the output distributions of the following two algorithms are identical: 1) <span class="math">v\\leftarrow h,\\mathbf{z}\\leftarrow g_{v},\\mathit{output}(\\mathbf{z},v)</span> with probability <span class="math">f(\\mathbf{z})/(M\\cdot g_{v}(\\mathbf{z}))</span>. 2) <span class="math">v\\leftarrow h,\\mathbf{z}\\leftarrow f,\\mathit{output}(\\mathbf{z},v)</span> with probability <span class="math">1/M</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Lemma 2</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em>[6]</em>) Let <span class="math">\\mathcal{R}=\\mathbb{Z}[x]/(x^{n}+1)</span> where <span class="math">n&gt;1</span> is a power of <span class="math">2</span> and <span class="math">0&lt;i,j&lt;2n-1</span>. Then all the coefficients of <span class="math">2(x^{i}-x^{j})^{-1}\\in\\mathcal{R}</span> are in <span class="math">\\{-1,0,1\\}</span>. This implies that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2(x^{i}-x^{j})^{-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{n}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 3</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">a,b\\in\\mathcal{R}_{q}</span>, the following relations hold $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{n}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\cdot b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\sqrt{n}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\cdot b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Lemma 4 (Leftover Hash Lemma (LHL))</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(<em>[19]</em>, Lemma B.1). Let <span class="math">\\mathcal{H}</span> be a universal hash family of hash functions from X to Y. If <span class="math">h\\leftarrow\\mathcal{H}</span> and <span class="math">x\\leftarrow X</span> are chosen uniformly and independently, then the statistical distance between (h,h(x)) and the uniform distribution on <span class="math">\\mathcal{H}\\times Y</span> is at most $\\frac{1}{2}\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">######</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Remark 1</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use this lemma for a <span class="math">\\mathsf{SIS}</span> family of hash function <span class="math">H(\\mathbf{S})=\\mathbf{A}\\cdot\\mathbf{S}\\in\\mathcal{R}_{q},\\text{with }\\mathbf{S}\\in\\mathsf{Dom}_{\\mathbf{S}}</span>, where each function is indexed by <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{1\\times(m-1)}</span> and <span class="math">\\mathsf{Dom}_{\\mathbf{S}}\\subseteq\\mathcal{R}_{q}^{1\\times(m-1)}</span> consists of vectors of <span class="math">\\mathcal{R}_{q}</span> elements with coefficients in <span class="math">\\Gamma\\triangleq(-2^{\\gamma},2^{\\gamma})</span>. This is a universal hash family since for all <span class="math">\\mathbf{S}\\neq\\mathbf{S}^{\\prime}</span>, we have $\\Pr\\left[\\mathbf{A}\\cdot\\mathbf{S}=\\mathbf{A}\\cdot\\mathbf{S}^{\\prime}\\right]=\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. This is a universal hash family if there exists </span>1\\leq i\\leq m-1<span class="math"> such that </span>s_{i}-s_{i}^{\\prime}<span class="math"> is invertible in </span>\\mathcal{R}_{q}<span class="math"> with </span>s_{i},s_{i}^{\\prime}\\in\\Gamma<span class="math">. This can be guaranteed by appropriate choice of </span>q<span class="math">, e.g. as shown in (<em>[34]</em>, Corollary 1.2), it is sufficient to use </span>q<span class="math"> such that </span>f(x)=x^{n}+1<span class="math"> factors into </span>k<span class="math"> irreducible factors modulo </span>q<span class="math"> and </span>2^{\\gamma}<\\frac{1}{\\sqrt{k}}\\cdot q^{1/k}<span class="math"> where </span>n<k\\leq 1<span class="math"> are powers of </span>2<span class="math">. We assume that </span>\\mathcal{R}_{q}$ is chosen to satisfy this condition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-11" class="text-2xl font-bold">3 Definition of a Linkable Ring Signature with Co-Signing</h2>

    <p class="text-gray-300">In this section, we present the definition of our proposed model, the Linkable Ring Signature with Co-Signing (<span class="math">\\mathsf{LRS}</span>-<span class="math">\\mathsf{CS}</span>), which offers an authorisation feature. Under this model, any group of <span class="math">N_{CS}</span> cosigners among <span class="math">w</span> groups has the ability to participate in a protocol that produces the signature, whilst hiding the identity of the signing group. The model also includes a linking tag, making it capable of detecting whether two signatures have been signed by same group of cosigners. Despite this authorisation functionality being implicitly used by Monero <em>[28, 4]</em>, it was not formalised; therefore, we have proposed this new model. The <span class="math">\\mathsf{LRS}</span>-<span class="math">\\mathsf{CS}</span> consists of a five-tuple scheme, with (<span class="math">\\mathsf{Setup}</span>, <span class="math">\\mathsf{KeyGen}</span>, <span class="math">\\mathsf{SigGen}</span>, <span class="math">\\mathsf{SigVer}</span>, <span class="math">\\mathsf{SigLink}</span>), which we define as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span>: a Probabilistic Polynomial Time (PPT) algorithm that takes the security parameter <span class="math">\\lambda</span> and produces the Public Parameters (<span class="math">\\mathsf{PP}</span>).</li>

      <li><span class="math">(\\mathbf{pk},\\mathcal{SK})\\leftarrow\\mathsf{KeyGen}(\\mathsf{PP})</span>: a PPT interactive protocol among a number of cosigners (<span class="math">N_{CS}</span>) that by taking the <span class="math">\\mathsf{PP}</span>, it produces a pair of keys: the aggregate shared public-key <span class="math">\\mathbf{pk}</span> and the set of cosigner’ secret-keys <span class="math">\\mathcal{SK}=\\{\\mathbf{sk}_{1},\\ldots,\\mathbf{sk}_{N_{CS}}\\}</span>.</li>

      <li><span class="math">\\sigma(\\mu)\\leftarrow\\mathsf{SigGen}(\\mathcal{SK},\\mu,L,\\mathsf{PP})</span>: a PPT interactive protocol that receives the <span class="math">\\mathsf{PP}</span>, a message <span class="math">\\mu</span>, the list <span class="math">L</span> as in (1) to be the list of public keys with <span class="math">w</span> users in the ring, and <span class="math">N_{in}</span> inputs (i.e this represents the number of input wallets of each user in a cryptocurrency application). The cosigners owning the secret keys in the set <span class="math">\\mathcal{SK}=\\{\\mathbf{sk}_{i,1}^{(k)},\\ldots,\\mathbf{sk}_{i,N_{CS}}^{(k)}\\}</span> interact to produce the signature <span class="math">\\sigma(\\mu)</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">L=\\left\\{\\mathbf{pk}_{i}^{(k)}\\right\\}_{i\\in[w],k\\in[N_{in}]}</span> (1)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{Accept}/\\mathsf{Reject})\\leftarrow\\mathsf{SigVer}(\\sigma(\\mu),\\mu,L,\\mathsf{PP})</span>: a deterministic algorithm that takes <span class="math">\\mathsf{PP}</span>, a signature <span class="math">\\sigma(\\mu)</span>, the list <span class="math">L</span>, and the message <span class="math">\\mu</span> and checks <span class="math">\\sigma(\\mu)</span> is a correct signature. If the signature is valid, it outputs <span class="math">\\mathsf{Accept}</span>, otherwise <span class="math">\\mathsf{Reject}</span>.</li>

      <li><span class="math">(\\mathsf{Linked}/\\mathsf{Unlinked})\\leftarrow\\mathsf{SigLink}(\\sigma(\\mu)_{1},\\sigma(\\mu)_{2})</span>: a deterministic algorithm that verifies if two signatures <span class="math">\\sigma(\\mu)_{1}</span> and <span class="math">\\sigma(\\mu)_{2}</span> were produced by the same signer while hiding the identity of such signer. Thus, this algorithm outputs <span class="math">\\mathsf{Linked}</span> if such condition is met, otherwise outputs <span class="math">\\mathsf{Unlinked}</span>.</li>

    </ul>

    <p class="text-gray-300">The LRS-CS scheme satisfies the SigGen Correctness where valid signatures are produced by honest signers, and it is then accepted by a public verifier with overwhelming probability. We said that the LRS-CS scheme is correct if for any <span class="math">\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span>, a honest user <span class="math">\\pi</span> runs the protocols <span class="math">(\\mathbf{p}\\mathbf{k}_{\\pi},\\mathcal{S}\\mathcal{K}_{\\pi})\\leftarrow\\mathsf{KeyGen}(\\mathsf{PP})</span>, and <span class="math">\\sigma(\\mu)\\leftarrow\\mathsf{SigGen}(\\mathcal{S}\\mathcal{K}_{\\pi},\\mu,L,\\mathsf{PP})</span>, it holds that <span class="math">\\Pr[\\mathsf{Accept}\\leftarrow\\mathsf{SigVer}(\\sigma(\\mu),\\mu,L,\\mathsf{PP})]=1-neg(\\lambda)</span>.</p>

    <p class="text-gray-300">The scheme also achieves SigLink Correctness. Such property guarantees that two valid signatures <span class="math">\\sigma(\\mu)_{1}</span> and <span class="math">\\sigma(\\mu)_{2}</span> are signed and linked by an honest signer with overwhelming probability. We show that the LRS-CS scheme satisfies SigLink Correctness property if for any <span class="math">\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> with a honest user <span class="math">\\pi</span> runs the protocols <span class="math">(\\mathbf{p}\\mathbf{k}_{\\pi},\\mathcal{S}\\mathcal{K}_{\\pi})\\leftarrow\\mathsf{KeyGen}(\\mathsf{PP})</span>, and <span class="math">\\sigma(\\mu)_{1}\\leftarrow\\mathsf{SigGen}(\\mathcal{S}\\mathcal{K}_{\\pi},\\mu,L,\\mathsf{PP})</span>, <span class="math">\\sigma(\\mu)_{2}\\leftarrow\\mathsf{SigGen}(\\mathcal{S}\\mathcal{K}_{\\pi},\\mu,L,\\mathsf{PP})</span>, it holds that <span class="math">\\Pr[\\mathsf{Linked}\\leftarrow\\mathsf{SigLink}(\\sigma(\\mu)_{1},\\sigma(\\mu)_{2})]=1-neg(\\lambda)</span>.</p>

    <p class="text-gray-300">The communication model assumes that the parties involve in our computational model are connected by a network of point-to-point and broadcast channels.</p>

    <h2 id="sec-12" class="text-2xl font-bold">4 Security Model for LRS-CS</h2>

    <p class="text-gray-300">Our security model is motivated by <em>[3, 7]</em> where the adversary corrupts and controls the behaviour of <span class="math">(N_{CS}-1)</span> cosigners, so forging LRS-CS is as hard as solving the underlying hardness problem. This model also captures anonymity, linkability and non-slanderability as principal properties to secure LRS-CS schemes. We begin by defining the oracles that can be accessed by the adversary.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 Oracles for adversaries</h3>

    <p class="text-gray-300">The following oracles are available to any adversary who tries to break the security of the L2RS-CS scheme <span class="math">\\forall k\\in[N_{in}]</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{p}\\mathbf{k}_{i}^{(k)}\\leftarrow\\mathcal{KO}(\\bot)</span>. The KeyGen Oracle, on request, adds new user(s) to the system. It runs the KeyGen interactive protocol between the challenger (who controls one cosigner) and the adversary (who controls <span class="math">(N_{CS}-1)</span> cosigners). This oracle returns the aggregate shared public-key <span class="math">\\mathbf{p}\\mathbf{k}_{i}^{(k)}</span>.</li>

    </ul>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark 2</h6>

    <p class="text-gray-300">The challenger <span class="math">\\mathcal{C}</span> generates with the KeyGen algorithm, the aggregate shared public-key <span class="math">\\mathbf{p}\\mathbf{k}_{\\pi}^{(k)}</span> and its pair-keys <span class="math">(\\mathbf{p}\\mathbf{k}_{\\pi,1}^{(k)\\dagger},\\mathbf{s}\\mathbf{k}_{\\pi,1}^{(k)\\dagger})</span>, where <span class="math">L^{sh}=\\left\\{\\mathbf{p}\\mathbf{k}_{\\pi,1}^{(k)\\dagger},\\ldots,\\mathbf{p}\\mathbf{k}_{\\pi,N_{CS}}^{(k)}\\right\\}</span>. Without loss of generality, we define the <span class="math">\\mathcal{C}</span>’s public-key <span class="math">(\\mathbf{p}\\mathbf{k}_{\\pi,1}^{(k)\\dagger})</span> to occur at least once, and to be in the first position of the <span class="math">L^{sh}</span>. On the other hand, the adversary <span class="math">\\mathcal{A}</span> arbitrarily chooses its public-key for <span class="math">(N_{CS}-1)</span> cosigners, so it can control <span class="math">\\left\\{\\mathbf{p}\\mathbf{k}_{\\pi,2}^{(k)},\\ldots,\\mathbf{p}\\mathbf{k}_{\\pi,N_{CS}}^{(k)}\\right\\}</span> from <span class="math">L^{sh}</span>. Then, <span class="math">\\mathcal{A}</span> can also compute its aggregate shared public-key <span class="math">\\mathbf{p}\\mathbf{k}_{\\pi}^{(k)}</span> by calling the <span class="math">\\mathcal{KO}</span> oracle. This means that <span class="math">\\mathcal{A}</span> can play the role of all cosigners, except for <span class="math">\\mathbf{p}\\mathbf{k}_{\\pi,1}^{(k)\\dagger}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\sigma(\\mu)\\leftarrow\\mathcal{SO}(L,\\mu,\\mathbf{p}\\mathbf{k}_{\\pi}^{(k)})</span>. The Signing Oracle, on input a group size <span class="math">w</span>, a set <span class="math">L</span> as in (1), the signer’s <span class="math">\\mathbf{p}\\mathbf{k}_{\\pi}^{(k)}</span>, and a message <span class="math">\\mu</span>. This oracle returns a valid signature <span class="math">\\sigma(\\mu)</span>.</li>

    </ul>

    <p class="text-gray-300">4.2 One-Time Unforgeability</p>

    <p class="text-gray-300">We point out that forging LRS-CS is infeasible assuming that the adversary is able to corrupt (<span class="math">N_{CS}-1</span>) cosigners. Consequently, the LRS-CS scheme is secure against any existentially unforgeable PPT adversary <span class="math">\\mathcal{A}</span> under chosen-message attacks if no <span class="math">\\mathcal{A}</span> has a non-negligible advantage. One-time unforgeability property is then defined in the following interactive game between the challenger <span class="math">\\mathcal{C}</span> and an existential adversary <span class="math">\\mathcal{A}</span> who has access to the oracles in Section 4.1:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> runs <span class="math">\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> and gives it to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> queries the <span class="math">\\mathcal{KO}</span> oracle <span class="math">Q_{k}</span> times.</li>

      <li><span class="math">\\mathcal{A}</span> queries the <span class="math">\\mathcal{SO}</span> oracle <span class="math">Q_{s}</span> times on input <span class="math">(\\mu,L,\\mathbf{p}\\mathbf{k}_{s}^{(k)})</span> for a message <span class="math">\\mu</span>, <span class="math">L=\\{\\mathbf{p}\\mathbf{k}_{1}^{(k)},\\ldots,\\mathbf{p}\\mathbf{k}_{s}^{(k)},\\ldots,\\mathbf{p}\\mathbf{k}_{w}^{(k)}\\}</span> (with <span class="math">w-1</span> decoyed users in the ring) as in (1), which contains the aggregate shared public-key <span class="math">(\\mathbf{p}\\mathbf{k}_{s}^{(k)})^{sh}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> finishes this simulation and outputs a forgery <span class="math">(L^{<em>},\\mu^{</em>},\\sigma(\\mu^{<em>})^{</em>})</span> for a new message <span class="math">\\mu^{<em>}</span>, where <span class="math">L^{</em>}=\\left\\{\\mathbf{p}\\mathbf{k}_{i}^{*(k)}\\right\\}_{i\\in[w],k\\in[N_{in}]}</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> wins the game if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{SigVer}(L^{<em>},\\mu^{</em>},\\sigma(\\mu^{<em>})^{</em>})</span> outputs Accept.</li>

      <li><span class="math">\\mathcal{SO}</span> was queried at most once.</li>

      <li><span class="math">(L^{<em>},\\mu^{</em>},\\sigma(\\mu^{<em>})^{</em>})</span> is not an output of <span class="math">\\mathcal{SO}</span>.</li>

      <li>For all <span class="math">i\\in[w]</span>, there exists <span class="math">k\\in[N_{in}]</span> such that <span class="math">\\mathbf{p}\\mathbf{k}_{i}^{<em>(k)}\\in L^{</em>}</span> was generated by the <span class="math">\\mathcal{KO}</span> oracle.</li>

      <li>Every <span class="math">\\mathbf{p}\\mathbf{k}_{i}^{*(k)}</span> was used to query <span class="math">\\mathcal{SO}</span> as a signing key rather than a decoy at most once.</li>

    </ol>

    <p class="text-gray-300">The advantage of the adversary <span class="math">\\mathcal{A}</span> in breaking the LRS-CS scheme is defined as the probability that <span class="math">\\mathcal{A}</span> wins the above game. We say that <span class="math">\\mathcal{A}</span> breaks this game with <span class="math">(\\tau,Q_{s},Q_{k},\\epsilon_{uf})</span> if <span class="math">\\mathcal{A}</span> runs in time at most <span class="math">\\tau</span> and with negligible probability <span class="math">\\epsilon_{uf}</span> after having made at most <span class="math">Q_{s}</span> signing queries, <span class="math">Q_{k}</span> queries to <span class="math">\\mathcal{KO}</span>, and <span class="math">(N_{CS}-1)</span> corrupt cosigners. Thus, we denote this property as <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\text{ot-unf}}(\\lambda)=\\Pr[\\mathcal{A}\\text{ wins the game}]</span>.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 2 (One-Time Unforgeability)</h6>

    <p class="text-gray-300">The LRS-CS scheme is said to be one-time unforgeable if no adversary with <span class="math">(\\tau,Q_{s},Q_{k},\\epsilon_{uf})</span> is able to break the scheme.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.3 Unconditional Anonymity</h3>

    <p class="text-gray-300">This property requires that any powerful adversaries are incapable of saying which member of the ring created a particular signature. We define that it should be infeasible for an adversary <span class="math">\\mathcal{A}</span> to distinguish a signer’s <span class="math">\\mathbf{p}\\mathbf{k}_{s}^{(k)}</span> with non-negligible advantage, even if the adversary has unlimited computing resources and time. This property for LRS-CS schemes is defined in the following game between a simulator <span class="math">\\mathcal{S}</span> and an unbounded adversary <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span>  may query  <span class="math">\\mathcal{KO}</span>  oracle according to any adaptive strategy.</li>

      <li><span class="math">\\mathcal{A}</span>  gives  <span class="math">\\mathcal{S}</span>  the  <span class="math">L = \\left\\{\\mathbf{pk}_{i_0}^{(k)},\\mathbf{pk}_{i_1}^{(k)}\\right\\}_{k\\in [N_{in}]}</span> , where  <span class="math">i_0,i_1\\in [w]</span>  which is the output of the  <span class="math">\\mathcal{KO}</span>  oracle, and a message  <span class="math">\\mu</span> .</li>

      <li><span class="math">\\mathcal{S}</span>  flips a coin  <span class="math">b = \\{0,1\\}</span> , then  <span class="math">\\mathcal{S}</span>  computes the signature  <span class="math">\\sigma(\\mu)_b = \\operatorname{SigGen}(L, \\mathbf{sk}_{i_0}^{(k)}, \\mu, \\mathsf{PP})</span> . This signature is given to  <span class="math">\\mathcal{A}</span> .</li>

      <li><span class="math">\\mathcal{A}</span>  outputs a bit  <span class="math">b&#x27;</span> .</li>

      <li>The output of this experiment is defined to be 1 if  <span class="math">b = b&#x27;</span> , otherwise 0.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  wins the game if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{pk}_{i_0}^{(k)},\\mathbf{pk}_{i_1}^{(k)}</span>  , and  <span class="math">\\mathbf{sk}^{(k)}\\notin \\{\\mathbf{sk}_{i_0}^{(k)},\\mathbf{sk}_{i_1}^{(k)}\\}</span>  cannot be used by  <span class="math">\\mathcal{SO}</span></li>

      <li>Outputs 1, where  <span class="math">b = b&#x27;</span> .</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The unconditional anonymity advantage of the LRS-CS scheme is denoted by  $\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathsf{Anon}}(\\lambda) = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname*{Pr}[b = b'] - \\frac{1}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 3 (Unconditional Anonymity). The LRS-CS scheme is unconditional anonymous if for any unbounded adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathsf{Anon}}(\\lambda)</span>  is negligible.</p>

    <p class="text-gray-300">It should be infeasible for an adversary  <span class="math">\\mathcal{A}</span>  to generate (with same  <span class="math">\\mathbf{sk}_{\\pi}</span> ) two valid LRS-CS signatures which are Unlinked. To describe this, we use the interaction between a simulator  <span class="math">\\mathcal{S}</span>  and  <span class="math">\\mathcal{A}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The  <span class="math">\\mathcal{A}</span>  queries the  <span class="math">\\mathcal{KO}</span>  oracle multiple times.</li>

      <li>The  <span class="math">\\mathcal{A}</span>  outputs two signatures  <span class="math">\\sigma(\\mu)</span>  and  <span class="math">\\sigma(\\mu)&#x27;</span>  and two lists  <span class="math">L</span>  as in (1) and  <span class="math">L&#x27; = \\left\\{\\mathbf{pk}_i^{(k)}\\right\\}_{i \\in [w], k \\in [N_{in}]}</span> .</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span>  wins the game if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By calling SigVer on input  <span class="math">\\sigma (\\mu)</span>  and  <span class="math">\\sigma (\\mu)^{\\prime}</span> , it outputs Accept on both inputs.</li>

      <li>The  <span class="math">\\mathbf{pk}^{(k)}</span> 's in  <span class="math">L</span>  and  <span class="math">L&#x27;</span>  are outputs of  <span class="math">\\mathcal{KO}</span>  oracle.</li>

      <li>Finally, it gets Unlinked, when calling SigLink on input  <span class="math">\\sigma (\\mu)</span>  and  <span class="math">\\sigma (\\mu)^{\\prime}</span> .</li>

    </ol>

    <p class="text-gray-300">Thus the advantage of the linkability in the LRS-CS scheme is denoted by  <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathrm{Link}}(\\lambda) = \\operatorname*{Pr}[\\mathcal{A}</span>  wins the game].</p>

    <p class="text-gray-300">Definition 4 (Linkability). The LRS-CS scheme is linkable if for all PPT adversary  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathrm{Link}}(\\lambda)</span>  is negligible in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">It should be infeasible for an adversary  <span class="math">\\mathcal{A}</span>  to output linked for two valid LRS-CS signatures which were correctly generated with different  <span class="math">\\mathbf{sk}^{(k)}</span> 's. This means that an adversary can frame an honest user for signing a valid signature so the adversary can produce another valid signature such that the SigLink algorithm outputs Linked. To describe this, we use the interaction between a simulator  <span class="math">\\mathcal{S}</span>  and an adversary  <span class="math">\\mathcal{A}</span> :</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> generates and gives the list <span class="math">L</span> to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> queries the <span class="math">\\mathcal{KO}</span> oracle to obtain <span class="math">(\\mathbf{pk}_{\\pi}^{(k)},\\mathbf{sk}_{\\pi}^{(k)})</span>, and gives them to <span class="math">\\mathcal{S}</span>.</li>

      <li><span class="math">\\mathcal{S}</span> calls the <span class="math">\\mathcal{SO}</span> with <span class="math">\\mathbf{sk}_{\\pi}^{(k)}</span> and outputs a valid signature <span class="math">\\sigma(\\mu)</span>, which is then given to <span class="math">\\mathcal{A}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> uses the remaining <span class="math">(w - 1)</span> keys of the ring signature to create a second signature <span class="math">\\sigma(\\mu)&#x27;</span> by calling the <span class="math">\\mathcal{SO}</span> algorithm.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> wins the game if:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The SigVer, on input <span class="math">\\sigma(\\mu)</span> and <span class="math">\\sigma(\\mu)&#x27;</span>, outputs Accept.</li>

      <li><span class="math">(\\mathbf{pk}_{\\pi}^{(k)},\\mathbf{sk}_{\\pi}^{(k)})</span> were not used to generate the second signature <span class="math">\\sigma (\\mu)&#x27;</span></li>

      <li>When calling the SigLink on input <span class="math">\\sigma (\\mu)</span> and <span class="math">\\sigma (\\mu)&#x27;</span>, it outputs linked.</li>

    </ol>

    <p class="text-gray-300">Thus the advantage of the non-slanderability in the LRS-CS scheme is denoted by <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathrm{NS}}(\\lambda) = \\operatorname*{Pr}[\\mathcal{A}</span> wins the game].</p>

    <p class="text-gray-300"><strong>Definition 5 (Non-Slanderability).</strong> The LRS-CS scheme is non-slandable if for all PPT adversary <span class="math">\\mathcal{A}</span>, <span class="math">\\mathbf{Advantage}_{\\mathcal{A}}^{\\mathrm{NS}}(\\lambda)</span> is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">This section describes technically the Lattice-based Linkable Ring Signature with Co-Signing (MIMO.L2RS-CS) scheme. This construction comprises the following algorithms, Setup, KeyGen, SigGen SigVer, and SigLink.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5.1 Setup</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By receiving the security parameter <span class="math">\\lambda</span>, this Setup defines $\\mathbf{A} = [\\mathbf{A}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}]\\in \\mathcal{R}_q^{2\\times (m - 1)}<span class="math"> and </span>\\mathbf{H} = [\\mathbf{H}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}]\\in \\mathcal{R}_q^{2\\times (m - 1)}<span class="math"> (as Lemma 5), where </span>\\mathbf{A}'\\gets \\mathcal{R}_q^{2\\times (m - 3)}<span class="math">, </span>\\mathbf{H}'\\gets \\mathcal{R}_q^{2\\times (m - 3)}<span class="math"> are chosen uniformly and randomly, and </span>\\mathbf{I}<span class="math"> denotes the identity. This algorithm outputs the public parameters (PP): </span>\\mathbf{A}<span class="math"> and </span>\\mathbf{H}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5.</strong> If <span class="math">q \\geq 4n</span>, then solving the MSIS-HNF problem with a matrix $\\mathbf{A} = [\\mathbf{A}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{I}] \\in \\mathcal{R}_q^{2 \\times (m - 1)}<span class="math">, in the Hermite Normal Form (HNF), is as hard as solving the </span>\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}<span class="math"> problem with </span>\\mathbf{A} = [\\mathbf{A}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}''] \\in \\mathcal{R}_q^{2 \\times (m - 1)}$ uniformly random.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Given the MSIS instance $\\mathbf{A} = [\\mathbf{A}'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}''] \\in \\mathcal{R}_q^{2 \\times (m - 1)}<span class="math">, if </span>\\mathbf{A}''^{-1}<span class="math"> exists, then we can reduce it to MSIS-HNF instance, which is of the form </span>\\tilde{\\mathbf{A}} = \\mathbf{A}_{1,1}^{\\prime \\prime -1} \\times \\mathbf{A}<span class="math">. Therefore, this reduction works with probability equal to the probability that </span>\\mathbf{A}_{1,1}^{\\prime \\prime -1}$ exists; then, it remains to show that this probability is non-negligible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We denote the entries of <span class="math">\\mathbf{A}&#x27;&#x27; = \\begin{bmatrix} \\mathbf{A}_{1,1}&#x27;&#x27; &amp;amp; \\mathbf{A}_{1,2}&#x27;&#x27; \\\\ \\mathbf{A}_{2,1}&#x27;&#x27; &amp;amp; \\mathbf{A}_{2,2}&#x27;&#x27; \\end{bmatrix} \\in \\mathcal{R}_q^{2\\times 2}</span>, so the inverse matrix</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} ^ {\\prime \\prime - 1} = \\frac {1}{\\operatorname* {d e t} (\\mathbf {A} ^ {\\prime \\prime})} \\cdot \\left[ \\begin{array}{c c} \\mathbf {A} _ {2, 2} ^ {\\prime \\prime} &amp;amp; - \\mathbf {A} _ {1, 2} ^ {\\prime \\prime} \\\\ - \\mathbf {A} _ {2, 1} ^ {\\prime \\prime} &amp;amp; \\mathbf {A} _ {1, 1} ^ {\\prime \\prime} \\end{array} \\right], \\text {w i t h} \\det  (\\mathbf {A} ^ {\\prime \\prime}) ^ {- 1} = (\\mathbf {A} _ {1, 1} ^ {\\prime \\prime} \\mathbf {A} _ {2, 2} ^ {\\prime \\prime} - \\mathbf {A} _ {1, 2} ^ {\\prime \\prime} \\mathbf {A} _ {2, 1} ^ {\\prime \\prime}) ^ {- 1} \\in \\mathcal {R} _ {q} \\text { if the inverse exists. Then, we have that } \\mathbf {A} ^ {\\prime \\prime} \\text { is invertible if and only if } \\frac {1}{\\operatorname* {d e t} (\\mathbf {A} ^ {\\prime \\prime})} \\text { exists in } \\mathcal {R} _ {q}. \\text { Let&#x27;s define the events } S _ {0} = \\left\\{\\mathbf {A} ^ {\\prime \\prime - 1} \\text { does not exist } \\right\\}, \\text { and } S _ {1} = \\left\\{\\det  (\\mathbf {A} ^ {\\prime \\prime}) ^ {- 1} \\text { does not exist in } \\mathcal {R} _ {q} \\right\\}. \\text { We said that } \\Pr_ {\\mathbf {A} ^ {\\prime \\prime} \\leftarrow \\mathcal {R} _ {q} ^ {2 \\times 2}} \\left[ S _ {0} \\right] = \\frac {1}{2} \\left(\\operatorname* {d e t} (\\mathbf {A} ^ {\\prime \\prime}) ^ {- 1} - \\frac {1}{2} \\operatorname* {d e t} (\\mathbf {A} ^ {\\prime \\prime}) - \\frac {1}{2} \\operatorname* {d e t} (\\mathbf {A} ^ {\\prime \\prime}) \\right]</span></div>

    <p class="text-gray-300"><span class="math">\\Pr\\left[S_{1}\\right]=P_{1}+P_{2}</span>, where <span class="math">P_{1}=\\Pr\\left[S_{1}\\mid\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\text{ exists}\\right]\\times\\Pr\\left[\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\text{ exists}\\right]</span>, and <span class="math">P_{2}=\\Pr\\left[S_{1}\\mid\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\text{ does not exist}\\right]\\times\\Pr\\left[\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\text{ does not exist}\\right]</span>. We consider that if <span class="math">\\mathbf{A}_{1,1}^{\\prime\\prime}\\leftarrow\\mathcal{R}_{q}</span> and <span class="math">\\mathbf{A}_{2,2}^{\\prime\\prime-1}</span> exists in <span class="math">\\mathcal{R}_{q}</span>, then <span class="math">\\mathbf{A}_{1,1}^{\\prime\\prime}\\times\\mathbf{A}_{2,2}^{\\prime\\prime}</span> is uniform in <span class="math">\\mathcal{R}_{q}</span>, i.e. <span class="math">\\forall\\bar{\\mathbf{A}}\\in\\mathcal{R}_{q}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\mathbf{A}_{1,1}^{\\prime\\prime}\\leftarrow\\mathcal{R}_{q}}\\left[\\mathbf{A}_{1,1}^{\\prime\\prime}\\times\\mathbf{A}_{2,2}^{\\prime\\prime}=\\bar{\\mathbf{A}}\\right]=\\Pr_{\\mathbf{A}_{1,1}^{\\prime\\prime}\\leftarrow\\mathcal{R}_{q}}\\left[\\mathbf{A}_{1,1}^{\\prime\\prime}=\\bar{\\mathbf{A}}\\times\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\right]=\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}_{q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event where a uniform element in <span class="math">\\mathcal{R}_{q}</span> is not invertible in <span class="math">\\mathcal{R}_{q}</span>. We observe that <span class="math">\\Pr\\left[S_{2}\\right]\\leq\\frac{n}{q}</span> as in <em>[42]</em>. Then by using (2), we have that <span class="math">P_{1}\\leq\\Pr\\left[S_{2}\\right]</span> and <span class="math">P_{2}\\leq\\Pr\\left[\\mathbf{A}_{2,2}^{\\prime\\prime-1}\\text{ does not exist in }\\mathcal{R}_{q}\\right]</span>, which is equivalent to <span class="math">\\Pr\\left[S_{2}\\right]</span>, since <span class="math">\\mathbf{A}_{2,2}^{\\prime\\prime}</span> is uniformly random element in <span class="math">\\mathcal{R}_{q}</span>. Therefore, we argue that <span class="math">\\Pr\\left[S_{1}\\right]\\leq P_{1}+P_{2}\\leq 2\\times\\Pr\\left[S_{2}\\right]\\leq\\frac{2n}{q}</span>. Subsequently, we want to show that <span class="math">1-\\Pr\\left[S_{2}\\right]\\geq\\texttt{non-negligible}</span> and this is implied by <span class="math">q\\geq 4n</span>. These conditions lead to the probability that <span class="math">\\det(\\mathbf{A}^{\\prime\\prime})^{-1}</span> exist in <span class="math">\\mathcal{R}_{q}</span> is: <span class="math">1-\\Pr\\left[S_{1}\\right]=\\Pr\\left[\\det(\\mathbf{A}^{\\prime\\prime})^{-1}\\text{ exist in }\\mathcal{R}_{q}\\right]\\geq\\frac{2n}{q}\\geq\\frac{1}{2}</span>. ∎</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">Setup incorporates a trapdoor in <span class="math">\\mathbf{A}</span> or <span class="math">\\mathbf{H}</span>, in practice Setup would generate <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{H}</span> based on the cryptographic Hash function <span class="math">H_{2}</span> evaluated at two distinct and fixed constants.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 6 (Function Lift).</h6>

    <p class="text-gray-300">This function maps <span class="math">\\mathcal{R}_{q}^{2}</span> to <span class="math">\\mathcal{R}_{2q}</span> with respect to a public parameter <span class="math">\\mathbf{A}\\in\\mathcal{R}_{q}^{2\\times(m-1)}</span>. Given <span class="math">\\mathbf{a}\\in\\mathcal{R}_{q}^{2}</span>, we let <span class="math">\\textsf{Lift}(\\mathbf{A},\\mathbf{a})\\triangleq(2\\cdot\\mathbf{A},-2\\cdot\\mathbf{a}+\\mathbf{q})\\in\\mathcal{R}_{2q}^{2\\times m}</span> with <span class="math">\\mathbf{q}=q\\cdot(1,1)^{T}</span>.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">5.2 Key Generation (KeyGen)</h3>

    <p class="text-gray-300">The KeyGen (Algorithm 1) is an interactive protocol where <span class="math">N_{CS}</span> cosigners collaborate to produce a pair of keys. We define the public-key to be <span class="math">\\mathbf{a}\\triangleq\\mathbf{p}\\mathbf{k}</span>, and the secret-key as <span class="math">\\mathbf{S}\\triangleq\\mathbf{s}\\mathbf{k}</span>. Once receiving the public parameters <span class="math">\\mathsf{PP}</span>, each cosigner creates the corresponding secret-key <span class="math">\\mathbf{\\bar{S}}_{p}^{T}</span> and public-key <span class="math">\\bar{\\mathbf{a}}_{p}</span> (steps 2-4). After the cosigners interact to verify their public-keys, the aggregate shared public-key <span class="math">\\mathbf{a}^{sh}</span> is jointly computed by each cosigner (step 14). The cosigners also calculate their corresponding secret-key <span class="math">\\mathbf{S}_{p}^{T}</span> using the list of cosigners (step 16). This solid aggregate shared public-key enables this scheme to be secure against <em>rogue key attacks</em> <em>[4, 28, 44]</em>.</p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">5.3 Signature Generation (SigGen)</h3>

    <p class="text-gray-300">The SigGen (Algorithm 2) is an interactive protocol, among <span class="math">N_{CS}</span> cosigners, which outputs the signature <span class="math">\\sigma(\\mu)</span>. This protocol receives a message <span class="math">\\mu</span>, the public parameters, the list <span class="math">L</span> that contains the public-keys of <span class="math">w</span> users in the ring, and a set with the consigners’ secret keys, <span class="math">\\mathcal{SK}=\\left\\{\\mathbf{S}_{\\pi,1}^{(k)},\\ldots,\\mathbf{S}_{\\pi,p}^{(k)},\\ldots,\\mathbf{S}_{\\pi,N_{CS}}^{(k)}\\right\\}_{k\\in[N_{in}]}</span> with <span class="math">N_{in}</span> number of input wallets. The SigGen extends the L2RS <em>[3]</em> which follows the Fiat-Shamir transformation and uses the rejection sampling technique (step 40) that hides the secret key from the signature.</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Algorithm 1 Key Generation Input: PP:  <span class="math">\\mathbf{A}\\in \\mathcal{R}_q^{2\\times (m - 1)}</span> Output:  <span class="math">\\left(\\mathbf{a}^{sh},\\mathcal{S}\\mathcal{K}\\right)</span>  with  <span class="math">\\mathcal{S}\\mathcal{K} = \\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{NCS}^T\\right\\}</span>  being the shared public-key and cosigner's secret-key, respectively. 1: procedure KEYGEN(A) 2: Each cosigner  <span class="math">p\\in \\{1,\\ldots ,N_{CS}\\}</span> 3: Selects  <span class="math">\\bar{\\mathbf{S}}_p^T = (\\bar{\\mathbf{s}}_{p,1},\\dots ,\\bar{\\mathbf{s}}_{p,m - 1})\\in \\mathcal{R}_q^{1\\times (m - 1)}</span>  where  <span class="math">\\bar{\\mathbf{s}}_{p,i}\\gets (-2^{\\gamma},2^{\\gamma})^{n}</span>  for  <span class="math">1\\leq i\\leq m - 1</span> 4:Calculates  <span class="math">\\bar{\\mathbf{a}}_p = (\\bar{\\mathbf{a}}_1,\\bar{\\mathbf{a}}_2)^T = \\mathbf{A}\\cdot \\bar{\\mathbf{S}}_p</span>  mod  <span class="math">q\\in \\mathcal{R}_q^2</span> 5:  <span class="math">\\mathbf{o}_p = H_0(\\bar{\\mathbf{a}}_p)</span> 6: Broadcasts  <span class="math">\\mathbf{o}_p</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7:Receives  <span class="math">\\mathbf{o}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "p" sends  <span class="math">\\bar{\\mathbf{a}}_p</span>  to the cosigners 8:Receives  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span> 9:Each cosigner verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if  <span class="math">\\mathbf{o}_{p^{\\prime}} = H_{0}(\\bar{\\mathbf{a}}_{p^{\\prime}})</span>  then Accept 12: else Abort protocol 13:Each cosigner computes the shared public-key as: 14:  <span class="math">\\mathbf{a}^{sh} = \\sum_{p&#x27;}^{N_{CS}}H_2(\\bar{\\mathbf{a}}_{p&#x27;},L^{sh})\\cdot \\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">L^{sh} = \\left\\{\\bar{\\mathbf{a}}_1,\\dots ,\\bar{\\mathbf{a}}_{N_{CS}}\\right\\}</span> 15:Each cosigner calculates its corresponding secret-key as: 16:  <span class="math">\\mathbf{S}_p^T = H_2(\\bar{\\mathbf{a}}_p,L^{sh})\\cdot \\bar{\\mathbf{S}}_p^T</span> 17: return  <span class="math">\\left(\\mathbf{a}^{sh},\\mathcal{S}\\mathcal{K}\\right)</span>  , without loss of generality, each cosigner only outputs and holds its corresponding secret-key  <span class="math">\\mathbf{S}_{p&#x27;}^T</span></p>

    <p class="text-gray-300">The SigVer (Algorithm 3) verifies the generated signature by receiving  <span class="math">(\\mu, L, \\sigma(\\mu), \\mathsf{PP})</span>  and outputting Accept or Reject. Additionally, Theorem 1 shows the bound of  <span class="math">\\beta_v</span>  that is used in this algorithm.</p>

    <p class="text-gray-300">Theorem 1. Let  <span class="math">\\beta_v = \\eta \\sigma \\sqrt{nm}</span> ,  <span class="math">q/4 &amp;gt; \\sigma \\sqrt{2(\\lambda + 1)\\ln 2 + 2\\ln(nm)}</span> , and  <span class="math">\\sigma(\\mu) = \\left(\\mathbf{c}_1, \\left\\{\\mathbf{f}_1^{(k)}, \\ldots, \\mathbf{f}_w^{(k)}\\right\\}_{k \\in [N_{in}]}, \\left\\{\\mathbf{h}_\\pi^{(k)}\\right\\}_{k \\in [N_{in}]}\\right)</span>  be generated based on Algorithm 2. Then the output of Algorithm 3 on input  <span class="math">\\sigma(\\mu)</span>  is accepted with probability  <span class="math">1 - 2^{-\\lambda}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. For a desired expected rejection and repetition  <span class="math">M</span> , if we take the definition of  <span class="math">\\alpha</span>  where  <span class="math">M = e^{\\frac{1}{2\\alpha^2}}</span> , then  <span class="math">\\mathbf{t}_{\\pi}^{(k)}</span>  will be indistinguishable from  <span class="math">D_{\\sigma}</span>  if  $\\sigma \\geq \\alpha \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_{2q,\\pi,p}^{(k)} \\cdot \\mathbf{c}_{\\pi} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  [Section 3.2 in [19]]. We also use [lemma 4.4, parts 1 and 3, in [33]]. The part 3 of this lemma shows that the bound on Euclidean norm  </span>\\beta_v = \\eta \\sigma \\sqrt{nm}<span class="math">  for a given  </span>\\eta &gt; 1<span class="math"> , has a probability  </span>\\operatorname*{Pr}\\left[\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_i^{(k)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &gt; \\eta \\sigma \\sqrt{nm}\\right] \\geq 1 - 2^{-\\lambda}<span class="math"> . In addition, the bound on infinity norm  </span>(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; q/4)<span class="math">  is analysed in part 1 of this lemma where its union bound is also considered. It turns out that  </span>\\eta<span class="math">  is required such  </span>q/4 &gt; \\eta \\sigma &gt; \\sigma \\sqrt{2(\\lambda + 1) \\ln 2 + 2 \\ln(nm)}<span class="math"> , except with probability  </span>2^{-\\lambda}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The SigLink (Algorithm 4) checks whether two signatures were correctly produced by the same signer, but it does not reveal the identity of such signer. The correctness proof of this algorithm is described in Appendix A.2.</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">Algorithm 2 Signature Generation Input:  <span class="math">\\mathcal{SK} = \\left\\{\\mathbf{S}_{\\pi ,p^{\\prime}}^{(k)}\\right\\}_{p^{\\prime}\\in [N_{CS}],k\\in [N_{in}]}</span> <span class="math">\\mu ,L = \\left\\{\\mathbf{a}_i^{(k)}\\right\\}_{i\\in [w],k\\in [N_{in}]}</span>  as in (1), and PP. Output:  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span> 1: procedure SIGGEN(SK,  <span class="math">\\mu ,L</span>  ,PP) 2: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 3: Each cosigner "  <span class="math">\\pi ,p</span>  " 4: Computes the linking tag  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)} = \\mathbf{H}\\cdot \\mathbf{S}_{\\pi ,p}^{(k)}\\in \\mathcal{R}_q^2</span> 5:  <span class="math">\\hat{\\mathbf{u}}_{\\pi ,p}^{(k)} = H_0\\bigl {\\{}\\mathbf{h}_{\\pi ,p}^{(k)}\\bigr \\}}</span> 6: Broadcasts  <span class="math">\\hat{\\mathbf{u}}_{\\pi ,p}^{(k)}</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7: Receives  <span class="math">\\hat{\\mathbf{u}}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "  <span class="math">\\pi ,p</span>  " securely sends  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)}</span>  to the cosigners 8: Receives  <span class="math">\\mathbf{h}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span> 9: "  <span class="math">\\pi ,p</span>  " verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if  <span class="math">\\mathbf{a}_{\\pi ,p^{\\prime}}^{(k)} = H_0\\bigl {\\{}\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}\\bigr \\}</span>  then Accept 12: else Abort protocol 13: Computes the shared linking tag  <span class="math">\\mathbf{h}_{\\pi}^{(k)} = \\sum_{p^{\\prime}}^{N_{CS}}\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}</span> 14: Calls Lift(H,  <span class="math">\\mathbf{h}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{H}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{H}, - 2\\cdot \\mathbf{h}_{\\pi}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 15: Calls Lift(A,  <span class="math">\\mathbf{a}_i^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 16: Chooses  <span class="math">\\mathbf{u}_{\\pi ,p}^{(k)} = (u_{\\pi ,p,1},\\dots ,u_{\\pi ,p,m})^T</span>  , where  <span class="math">u_{\\pi ,p,i}\\gets D_{\\pi}^{u}</span>  , for  <span class="math">1\\leq i\\leq m</span> 17: Computes  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)} = \\mathbf{A}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)} = \\mathbf{H}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span> 18:  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)} = H_0(\\mathbf{r}_{\\pi ,p}^{(k)},\\mathbf{z}_{\\pi ,p}^{(k)})</span> 19: Broadcasts  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 20: Receives  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "  <span class="math">\\pi ,p</span>  " securely sends  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)}</span>  to the cosigners 21: Receives  <span class="math">\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span> 22: "  <span class="math">\\pi ,p</span>  " verifies: 23: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 24: if  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)} = H_0(\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)},\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)})</span>  then Accept 25: else Abort protocol 26: "  <span class="math">\\pi ,p</span>  " computes  <span class="math">\\mathbf{r}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span> 27: "  <span class="math">\\pi ,p</span>  " performs  <span class="math">\\forall k\\in [N_{in}]</span>  ,  <span class="math">c_{\\pi +1} = H_1(L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\mathbf{r}_\\pi^{(k)},\\mathbf{z}_\\pi^{(k)})</span> 28: for  <span class="math">(i = \\pi +1,\\pi +2,\\dots ,w,1,2,\\dots ,\\pi -1)</span>  do 29: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 30: Each cosigner "  <span class="math">\\pi ,p</span>  " 31: Selects  <span class="math">\\mathbf{t}_{i,p}^{(k)} = (t_{i,p,1},\\dots ,t_{i,p,m})^T</span>  , where  <span class="math">t_{i,p,j}\\gets D_{\\pi}^{u}</span>  , for  <span class="math">1\\leq j\\leq m</span> 32: Sends  <span class="math">\\mathbf{t}_{i,p}^{(k)}</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span>  securely 33: Receives  <span class="math">\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span>  from other cosigners 34: Computes  <span class="math">\\mathbf{t}_i^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span> 35: "  <span class="math">\\pi ,p</span>  " calls Lift(A,  <span class="math">\\mathbf{a}_i^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,i}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 36: Compute  <span class="math">\\forall k\\in [N_{in}]</span> <span class="math">c_{i + 1} = H_1(L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,i}^{(k)},\\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} ,\\left\\{\\mathbf{H}_{2q,\\pi}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\})</span> 37: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 38: Choose  <span class="math">b^{(k)}\\gets \\{0,1\\}</span> 39: "  <span class="math">\\pi ,p</span>  " computes  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)} = \\mathbf{u}_{\\pi ,p}^{(k)} + \\mathbf{S}_{2q,\\pi ,p}^{(k)}\\cdot \\mathbf{c}_{\\pi}\\cdot (-1)^{b^{(k)}}</span>  , where  <span class="math">\\mathbf{S}_{2q,\\pi ,p}^{(k)} = [(\\mathbf{S}_{\\pi ,p}^{(k)})^T,1]^T</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">40: Continue with prob.  $\\left(M\\exp \\left(-\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{2\\sigma^2}\\right)\\cosh \\left(\\frac{\\langle\\mathbf{t}_{\\pi,p}^{(k)},\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\rangle}{\\sigma^2}\\right)\\right)^{-1}$  otherwise Restart.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">41: "  <span class="math">\\pi ,p</span>  " broadcasts  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)}</span>  to other cosigners 42: "  <span class="math">\\pi ,p</span>  " receives  <span class="math">\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\neq p</span>  and computes  <span class="math">\\mathbf{t}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span> 43: return  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span></p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Algorithm 3 Signature Verification Input:  <span class="math">\\sigma (\\mu),\\mu ,\\mathrm{PP}</span>  and  <span class="math">L = \\left\\{\\mathbf{a}_i^{(k)}\\right\\}_{i\\in [w],k\\in [N_{in}]}</span> Output: Accept or Reject 1: procedure SIGNVEH  <span class="math">(\\sigma (\\mu),\\mu ,L,\\mathrm{PP})</span> 2:Computes  <span class="math">\\mathbf{H}_{2q}^{(k)} = (2\\cdot \\mathbf{H}, - 2\\cdot \\mathbf{h}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 3: for  <span class="math">(i = 1,\\dots ,w)</span>  do 4: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 5:  <span class="math">{}^{\\prime \\prime}\\pi ,p^{\\prime \\prime}</span>  calls Lift(A,a(i) to obtain  <span class="math">\\mathbf{A}_{2q,i}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 6: Compute  <span class="math">\\forall k\\in [N_{in}],\\mathbf{c}_{i + 1} = H_1\\big(L,\\mathbf{H}_{2q}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,i}^{(k)},\\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} ,\\left\\{\\mathbf{H}_{2q}^{(k)},\\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} \\big)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">7: Check  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_{i,p'}^{(k)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\beta_v$  (see Theorem 1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">9: if  <span class="math">\\mathbf{c}_1 = H_1\\big(L,\\mathbf{H}_{2q}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,w}^{(k)}\\cdot \\mathbf{t}_w^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_w\\right\\} ,\\left\\{\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_w^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_w\\right\\} \\big)</span>  then Accept 10: else Reject 11: return Accept or Reject</p>

    <p class="text-gray-300">Algorithm 4 Signature Linkability Input:  <span class="math">\\sigma (\\mu)_1</span>  and  <span class="math">\\sigma (\\mu)_2</span> Output: Linked or Unlinked 1: procedure SIGLINK  <span class="math">(\\sigma (\\mu)_1,\\sigma (\\mu)_2)</span> 2: if  <span class="math">\\left(\\mathrm{SigVer}(\\sigma (\\mu)_1,<em>) = \\mathrm{Accept}\\right.</span>  and  <span class="math">\\mathrm{SigVer}(\\sigma (\\mu)_2,</em>) = \\mathrm{Accept})</span>  then Continue [ 3: else if  <span class="math">\\mathbf{h}_{n_i}^{(k)} = \\mathbf{h}_{n_2}^{(k)}</span>  then Linked 4: else Unlinked ] 5: return Linked or Unlinked</p>

    <p class="text-gray-300">This section presents the results of our security evaluation. It demonstrates that the L2RS-CS is computationally secure in terms of unforgeability, linkability and non-slanderability from the Module-SIS lattice assumption, and it is unconditionally secure for anonymity under the Leftover Hash Lemma (LHL).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2 (One-Time Unforgeability). If there is a PPT algorithm against one-time unforgeability of L2RS-CS that makes  <span class="math">Q_{uf}</span>  queries to the random oracles  <span class="math">H_0, \\mathcal{SO}</span>  and  <span class="math">\\mathcal{KO}</span> , with non-negligible probability  <span class="math">\\delta</span> ; then, there exist a PPT algorithm that can extract a solution to the  <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span>  problem, where  <span class="math">\\beta = 2\\beta_v</span>  and with non-negligible probability  $\\left(\\delta - \\epsilon_{uf} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(\\frac{\\delta - \\epsilon_{uf} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{Q_s + Q_1} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)<span class="math"> . The  </span>\\epsilon_{uf}$  is neg(n) if the following conditions hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\frac{2\\cdot N_{in}\\cdot N_{CS}(2\\cdot Q_{uf} + 1)^2}{2^{n + 1}}\\leq neg(n)</span>  , with  <span class="math">Q_{uf} = max(Q_0,Q_s,Q_k)</span></li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2.  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\text{neg}(n)$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\frac{1}{\\sqrt{k}} \\cdot q^{1 / k} \\leq \\text{neg}(n)</span> .</li>

    </ol>

    <p class="text-gray-300">Proof. The proof is given in Appendix B.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 3 (Anonymity).</h6>

    <p class="text-gray-300">Suppose that the quantities: <span class="math">\\frac{N_{in}\\cdot N_{CS}}{2}\\cdot\\sqrt{\\frac{q^{4n}}{2^{(\\gamma+1)\\cdot(m-1)\\cdot n}}}</span> and <span class="math">\\frac{2\\cdot Q_{anon}\\cdot(2\\cdot Q_{anon}+2\\cdot Q_{anon}\\cdot N_{CS}+1)}{2^{n}}}</span> are negligible in <span class="math">n</span> with <span class="math">Q_{anon}=max(Q_{0},Q_{1},Q_{s})</span>. Then, the L2RS-CS scheme provides unconditionally anonymity against any adversary who makes <span class="math">Q_{anon}</span> queries to the random oracles <span class="math">H_{0},H_{1}</span>, and <span class="math">\\mathcal{SO}</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is given in Appendix C. ∎</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 4 (Linkability).</h6>

    <p class="text-gray-300">The L2RS-CS scheme is linkable in the random oracle model if the <span class="math">\\mathbf{MSIS}^{\\mathcal{K}}_{q,m,k,\\beta}</span> problem is hard with <span class="math">\\beta\\leq 2\\beta_{v}(1+\\sqrt{n}N_{in}2^{\\gamma})</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is given in Appendix D. ∎</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Theorem 5 (Non-Slanderability).</h6>

    <p class="text-gray-300">For any linkable ring signature, if it satisfies unforgeability and linkability, then it satisfies non-slanderability.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is given in Appendix E. ∎</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Corollary 1 (Non-Slanderability).</h6>

    <p class="text-gray-300">The L2RS-CS scheme is non-slanderable under the assumptions of Theorem 2 and Theorem 4.</p>

    <h2 id="sec-35" class="text-2xl font-bold">7 Performance Analysis</h2>

    <p class="text-gray-300">After consolidating the conditions from the correctness and security analyses, which were discussed in earlier sections, we chose the optimal parameters of our L2RS-CS with Hermite factor <span class="math">\\delta=1.0045</span> and security parameter <span class="math">\\lambda=128</span> bits. This evaluation follows the analysis of the attack on SIS from <em>[36]</em> that we use to estimate secure values for the parameters. In our experiment, we then set the polynomial ring degree <span class="math">n=2^{8}</span> instead of <span class="math">n=2^{7}</span> since it yields a shorter signature size and a optimal value for <span class="math">\\log_{2}(q)=58</span>, as illustrated in Figures 1.a and 1.b, respectively. Consequently, we selected the number of ring elements of the matrices of the PP to be <span class="math">m=23</span>. This also allowed us to determine the Hamming weight of each challenge vector (<span class="math">\\kappa=23</span>), the Gaussian standard deviation (<span class="math">\\sigma=188416</span>), and the <span class="math">\\log\\beta=38.9</span> (which also solves the lattice assumption). With these results, we attained a signature size of 1.26 MB with the cosigner’s pair of keys (sk=10 KB, pk=3.6 KB). This evaluation was restricted to ring size <span class="math">w=100</span>, <span class="math">N_{in}=1</span> and <span class="math">N_{out}=1</span>, which was compared with existing lattice-based TRS schemes <em>[7, 14]</em>, as shown in Table 1. In a different experiment, we analysed how the signature size grows with the ring size and <span class="math">N_{CS}</span> cosigners while comparing our L2RS-CS with <em>[7, 14]</em>. Despite all approaches growing linearly with the ring size <span class="math">w</span>, our L2RS-CS scheme generated shorter signature sizes than previous constructions (Figure 2.a). In terms of the <span class="math">N_{CS}</span> cosigners (Figure 2.b), our proposed scheme achieved constant time and provided better signature sizes than other lattice-based TRS, in particular when <span class="math">N_{CS}&gt;2^{2}</span>.</p>

    <p class="text-gray-300">Finally, we also explored how the signature size grows when selecting regular values for <span class="math">N_{in}</span> and <span class="math">N_{out}</span>. We also set <span class="math">w=11</span> since it currently offers secure</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a)  <span class="math">n</span>  vs.  <span class="math">\\sigma (\\mu)</span>  size</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b)  <span class="math">n</span>  vs.  <span class="math">q</span></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 1. Analysis of signature size and  <span class="math">q</span>  versus  <span class="math">n</span>  with fixed  <span class="math">w = 11</span> . (a)  <span class="math">\\sigma (\\mu)</span>  size vs.  <span class="math">w</span> <span class="math">(N_{CS} = 50)</span> Fig. 2. Analysis of signature size versus  <span class="math">w</span>  and  <span class="math">N_{CS}</span> .</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (b)  <span class="math">\\sigma (\\mu)</span>  size vs.  <span class="math">N_{CS}</span> <span class="math">(w = 100)</span></p>

    <p class="text-gray-300">anonymity, according to Monero's blockchain <span class="math">^{1}</span> . The outcome of this evaluation is presented in Table 2. This reveals that the signature size grows linearly with the  <span class="math">N_{in}</span>  for any  <span class="math">N_{CS} &amp;gt; 2</span> .</p>

    <p class="text-gray-300">Table 2. Size estimation for L2RS-CS for any  <span class="math">N_{CS} \\geq 2</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L2RS-CS</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Nin, Nout) = (1, 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Nin, Nout) = (2, 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Nin, Nout) = (3, 2)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Signature size (w = 11)</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 138.8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 289.8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 452.9 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Private-key size</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 10.6 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 11.1 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 11.6 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Public-key size</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 3.6 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 3.8 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">≈ 4 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] W. Alberto Torres, V. Kuchta, R. Steinfeld, A. Sakzad, J. K. Liu, and J. Cheng. Lattice RingCT v2.0 with Multiple Input and Output Wallets. In ACISP, pages 156–175. Springer, 2019.</li>

      <li>[2] W. A. Alberto Torres, N. Bhattacharjee, and B. Srinivasan. Privacy-preserving biometrics authentication systems using fully homomorphic encryption. International Journal of Pervasive Computing and Communications, 11(2):151–168, 6 2015.</li>

      <li>[3] W. A. Alberto Torres, R. Steinfeld, A. Sakzad, J. K. Liu, V. Kuchta, N. Bhattacharjee, M. H. Au, and J. Cheng. Post-Quantum One-Time Linkable Ring Signature and Application to Ring Confidential Transactions in Blockchain (Lattice RingCT v1.0). In ACISP, pages 558–576. Springer, 2018.</li>

      <li>[4] K. Alonso. Zero to Monero: Multisig Chapter. https://github.com/SarangNoether/zero-to-monero/blob/master/multisig_chapter-1-0.pdf, 2018.</li>

      <li>[5] M. Bellare and G. Neven. Multi-signatures in the plain public-key model and a general forking lemma. In CCS, page 390. ACM, 2006.</li>

      <li>[6] F. Benhamouda, J. Camenisch, S. Krenn, V. Lyubashevsky, and G. Neven. Better Zero-Knowledge Proofs for Lattice Encryption and Their Application to Group Signatures. In ASIACRYPT, pages 551–572. Springer, 2014.</li>

      <li>[7] S. Bettaieb and J. Schrek. Improved Lattice-Based Threshold Ring Signature Scheme. In PQCRYPTO, pages 34–51. Springer, 2013.</li>

      <li>[8] A. Boldyreva. Threshold Signatures, Multisignatures and Blind Signatures Based on the Gap-Diffie-Hellman-Group Signature Scheme. In PKC, pages 31–46. Springer, 2003.</li>

      <li>[9] D. Boneh, M. Drijvers, and G. Neven. Compact Multi-signatures for Smaller Blockchains. In ASIACRYPT, pages 435–464. Springer, 12 2018.</li>

      <li>[10] L. T. A. N. Brandão. Towards Standardization of Threshold Schemes at NIST. In Proceedings of ACM Workshop on Theory of Implementation Security Workshop, pages 29–29, New York, 2019. ACM Press.</li>

      <li>[11] E. Bresson, J. Stern, and M. Szydlo. Threshold Ring Signatures and Applications to Ad-hoc Groups. In CRYPTO, pages 465–480. Springer, 2002.</li>

      <li>[12] J. Buchmann, K. Lauter, and M. Mosca. Postquantum Cryptography State-of-the-Art. IEEE Symposium on Security and Privacy, 15(4):12–13, 2017.</li>

      <li>[13] J. Buchmann, K. Lauter, and M. Mosca. Postquantum Cryptography, Part 2. IEEE Symposium on Security and Privacy, 16(5):12–13, 9 2018.</li>

      <li>[14] P.-L. Cayrel, R. Lindner, M. Rückert, and R. Silva. A Lattice-Based Threshold Ring Signature Scheme. In LATINCRYPT, pages 255–272. Springer, 2010.</li>

      <li>[15] J. Chen, Y. Hu, W. Gao, and H. Liang. Lattice-based Threshold Ring Signature with Message Block Sharing. TIIS, 13(2):1003–1019, 2019.</li>

      <li>[16] M. Conti, S. K. E, C. Lal, and S. Ruj. A Survey on Security and Privacy Issues of Bitcoin. IEEE Communications Surveys and Tutorials, 20(4):3416 – 3452, 2018.</li>

      <li>[17] V. Daza, J. Herranz, and G. Saez. Some protocols useful on the Internet from threshold signature schemes. In 14th International Workshop on Database and Expert Systems Applications, pages 359–363. IEEE, 2003.</li>

      <li>[18] Y. Desmedt and Y. Frankel. Threshold cryptosystems. In CRYPTO, pages 307–315. Springer, 1989.</li>

      <li>[19] L. Ducas, A. Durmus, T. Lepoint, and V. Lyubashevsky. Lattice signatures and bimodal gaussians. In CRYPTO, pages 40–56. Springer, 2013.</li>

    </ul>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] L. Ducas, T. Lepoint, V. Lyubashevsky, P. Schwabe, G. Seiler, and D. Stehlé. CRYSTALS – Dilithium: Digital Signatures from Module Lattices. In IACR Transactions on Symmetric Cryptology, pages 238–268, 2018.</li>

      <li>[21] R. El Bansarkhani and J. Sturm. An Efficient Lattice-Based Multisignature Scheme with Applications to Bitcoins. In CANS, pages 140–155. Springer, 2016.</li>

      <li>[22] M. F. Esgin, R. K. Zhao, R. Steinfeld, J. K. Liu, and D. Liu. MatRiCT: Efficient, Scalable and Post-Quantum Blockchain Confidential Transactions Protocol. In CCS, pages 567–584. ACM Press, 2019.</li>

      <li>[23] R. Gennaro, S. Goldfeder, and A. Narayanan. Threshold-Optimal DSA/ECDSA Signatures and an Application to Bitcoin Wallet Security. In ACNS, pages 156–174. Springer, 2016.</li>

      <li>[24] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Robust Threshold DSS Signatures. In EUROCRYPT, pages 354–371. Springer, 1996.</li>

      <li>[25] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure Applications of Pedersen’s Distributed Key Generation Protocol. In CT-RSA, pages 373–390. Springer, 2003.</li>

      <li>[26] R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin. Secure Distributed Key Generation for Discrete-Log Based Cryptosystems. Journal of Cryptology, 20(1):51–83, 1 2007.</li>

      <li>[27] S. Goldfeder, J. Bonneau, R. Gennaro, and A. Narayanan. Escrow Protocols for Cryptocurrencies: How to Buy Physical Goods Using Bitcoin. In Financial Cryptography, pages 321–339. Springer, 2017.</li>

      <li>[28] B. Goodell and S. Noether. Thring Signatures and their Applications to Spender-Ambiguous Digital Currencies. In Cryptology ePrint Archive: Report 2018/774, 2018.</li>

      <li>[29] P. Koshy, D. Koshy, and P. McDaniel. An Analysis of Anonymity in Bitcoin Using P2P Network Traffic. In Financial Cryptography, pages 469–485. Springer, 2014.</li>

      <li>[30] J. K. Liu, V. K. Wei, and D. S. Wong. A Separable Threshold Ring Signature Scheme. In ICISC, pages 12–26. Springer, 2004.</li>

      <li>[31] J. K. Liu, V. K. Wei, and D. S. Wong. Linkable spontaneous anonymous group signature for ad hoc groups. In ACISP, pages 325–335. Springer, 2004.</li>

      <li>[32] J. K. Liu and D. S. Wong. On the Security Models of (Threshold) Ring Signature Schemes. In ICISC, pages 204–217. Springer, 2005.</li>

      <li>[33] V. Lyubashevsky. Lattice Signatures without Trapdoors. In EUROCRYPT. Springer, 2012.</li>

      <li>[34] V. Lyubashevsky and G. Seiler. Short, Invertible Elements in Partially Splitting Cyclotomic Rings and Applications to Lattice-Based Zero-Knowledge Proofs. In EUROCRYPT, pages 204–224. Springer, 2018.</li>

      <li>[35] G. Maxwell, A. Poelstra, Y. Seurin, and P. Wuille. Simple Schnorr multi-signatures with applications to Bitcoin. Designs, Codes and Cryptography, 87(9):2139–2164, 9 2019.</li>

      <li>[36] D. Micciancio and O. Regev. Lattice-based cryptography. In Post-quantum cryptography, pages 147–191. Springer, 2009.</li>

      <li>[37] S. Noether. Ring Signature Confidential Transactions for Monero. In Cryptology ePrint Archive: Report 2015/1098, 2015.</li>

      <li>[38] T. Okamoto, R. Tso, M. Yamaguchi, and E. Okamoto. A k-out-of-n Ring Signature with Flexible Participation for Signers. In Cryptology ePrint Archive: Report 2018/728, 2018.</li>

      <li>[39] P. W. Shor. Polynomial-time algorithms for prime factorization and discrete logarithms on a quantum computer. SIAM review, 41(2):303–332, 1999.</li>

    </ul>

    <p class="text-gray-300">40] V. Shoup. Practical Threshold Signatures. In EUROCRYPT, pages 207–220. Springer, 2000.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[41] V. Shoup. Sequences of games: a tool for taming complexity in security proofs. In Cryptology ePrint Archive: Report 2004/332, 2004.</li>

      <li>[42] D. Stehlé, R. Steinfeld, K. Tanaka, and K. Xagawa. Efficient Public Key Encryption Based on Ideal Lattices. In ASIACRYPT, pages 617–635. Springer, 2009.</li>

      <li>[43] S.-F. Sun, M. H. Au, J. K. Liu, and T. H. Yuen. RingCT 2.0: A Compact Accumulator-Based (Linkable Ring Signature) Protocol for Blockchain Cryptocurrency Monero. In ESORICS, pages 456–474. Springer, 2017.</li>

      <li>[44] A. Tomescu, R. Chen, Y. Zheng, I. Abraham, B. Pinkas, G. Golan, and S. Devadas. Towards Scalable Threshold Cryptosystems. In IEEE Symposium on Security and Privacy, 2020.</li>

      <li>[45] W. A. A. Torres, N. Bhattacharjee, and B. Srinivasan. Effectiveness of Fully Homomorphic Encryption to Preserve the Privacy of Biometric Data. In Proceedings of the 16th International Conference on Information Integration and Web-based Applications & Services - iiWAS ’14, pages 152–158, New York, New York, USA, 2014. ACM Press.</li>

      <li>[46] P. P. Tsang, V. K. Wei, T. K. Chan, M. H. Au, J. K. Liu, and D. S. Wong. Separable Linkable Threshold Ring Signatures. In INDOCRYPT, pages 384–398. Springer, 2004.</li>

      <li>[47] B. Wei, Y. Du, H. Zhang, F. Zhang, H. Tian, and C. Gao. Identity Based Threshold Ring Signature from Lattices. In NSS, pages 233–245. Springer, 2014.</li>

      <li>[48] D. S. Wong, K. Fung, J. K. Liu, and V. K. Wei. On the RS-Code Construction of Ring Signature Schemes and a Threshold Setting of RST. In ICICS, pages 34–46. Springer, 2003.</li>

      <li>[49] T. H. Yuen, J. K. Liu, M. H. Au, W. Susilo, and J. Zhou. Threshold ring signature without random oracles. In ASIACCS, page 261. ACM Press, 2011.</li>

      <li>[50] T. H. Yuen, S.-f. Sun, J. K. Liu, M. H. Au, M. F. Esgin, Q. Zhang, and D. Gu. RingCT 3.0 for Blockchain Confidential Transaction: Shorter Size and Stronger Security. In Cryptology ePrint Archive. Report 2019/508, 2019.</li>

    </ul>

    <h2 id="sec-37" class="text-2xl font-bold">Appendix 0.A Correctness of MIMO.L2RS-CS</h2>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">0.A.1 Correctness of SigGen</h3>

    <p class="text-gray-300">We show in the following proof that valid signatures are signed by honest signers, such that <span class="math">\\sigma(\\mu)=\\left(\\mathbf{c}_{1},\\left\\{\\mathbf{t}_{1}^{(k)},\\ldots,\\mathbf{t}_{w}^{(k)}\\right\\}_{k\\in[N_{in}]},\\left\\{\\mathbf{h}_{\\pi}^{(k)}\\right\\}_{k\\in[N_{in}]}\\right)</span> is the output of the SigGen algorithm on input <span class="math">(\\mu,L,\\mathbf{S}_{\\pi,p}^{(k)},\\mathsf{PP})</span>. Then, on input <span class="math">(\\mu,L,\\sigma(\\mu),\\mathsf{PP})</span>, the SigVer algorithm outputs Accept with overwhelming probability.</p>

    <p class="text-gray-300">We demonstrate that when SigVer (step 9) computes <span class="math">\\forall k,\\in</span> <span class="math">[N_{in}]</span>, <span class="math">H_{1}\\Big{(}L,\\mathbf{H}_{2q}^{(k)},\\mu,\\Big{\\{}\\mathbf{A}_{2q,w}^{(k)}\\cdot\\mathbf{t}_{w}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{w}\\Big{\\}},\\Big{\\{}\\mathbf{H}_{2q}^{(k)}\\cdot\\mathbf{t}_{w}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{w}\\Big{\\}}\\Big{)}</span>, this result should be equal to <span class="math">\\mathbf{c}_{1}</span>. The SigVer also verifies <span class="math">\\forall k,w\\in[N_{in}],[w]</span> that <span class="math">H_{1}\\Big{(}L,\\mathbf{H}_{2q}^{(k)},\\mu,\\Big{\\{}\\mathbf{A}_{2q,i}^{(k)}\\cdot\\mathbf{t}_{i}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{i}\\Big{\\}},\\Big{\\{}\\mathbf{H}_{2q}^{(k)}\\cdot\\mathbf{t}_{i}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{i}\\Big{\\}}\\Big{)}=\\mathbf{c}_{i+1}</span>. This evaluation considers two scenarios:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">i\\neq\\pi,\\ \\forall k\\in[N_{in}]</span>, SigGen evaluates <span class="math">\\mathbf{c}_{i+1}=H_{1}\\Big{(}L,\\mathbf{H}_{2q}^{(k)},\\mu,\\Big{\\{}\\mathbf{A}_{2q,i}^{(k)}\\cdot\\mathbf{t}_{i}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{i}\\Big{\\}},\\Big{\\{}\\mathbf{H}_{2q}^{(k)}\\cdot\\mathbf{t}_{i}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{i}\\Big{\\}}\\Big{)}</span>, while SigVer computes <span class="math">\\mathbf{c}_{i+1}=H_{1}\\Big{(}L,\\mathbf{H}_{2q}^{(k)},\\mu,\\Big{\\{}\\mathbf{A}_{2q,i}^{(k)}\\cdot\\mathbf{t}_{i}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{i}\\Big{\\}}\\Big{)}</span></li>

    </ul>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300"><span class="math">H_{1}\\Big(L,\\mathbf{H}_{2q}^{(k)},\\mu ,\\Big\\{\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_{i}^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_{i}\\Big\\} ,\\Big\\{\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_{i}^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_{i}\\Big\\} \\Big).</span>  These are equal since  <span class="math">\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_i^{(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_i</span>  (in SigGen)  <span class="math">= \\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_i^{(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_i</span>  (in SigVer); and  <span class="math">\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i</span>  (in SigGen)  <span class="math">= \\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i</span>  (in SigVer).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">i = \\pi</span> ,  <span class="math">\\forall k \\in [N_{in}]</span> , SigGen checks  <span class="math">\\mathbf{c}_{\\pi + 1} = H_1\\Big(L, \\mathbf{H}_{2q,\\pi}^{(k)}, \\mu, \\mathbf{r}_\\pi^{(k)}, \\mathbf{z}_\\pi^{(k)}\\Big)</span> , whereas SigVer calculates  <span class="math">\\mathbf{c}_{\\pi + 1} = H_1\\Big(L, \\mathbf{H}_{2q,\\pi}^{(k)}, \\mu, \\mathbf{A}_{2q,\\pi}^{(k)} \\cdot \\mathbf{t}_\\pi^{(k)} \\cdot \\mathbf{q} \\cdot \\mathbf{c}_\\pi, \\mathbf{H}_{2q,\\pi}^{(k)} \\cdot \\mathbf{t}_\\pi^{(k)} + \\mathbf{q} \\cdot \\mathbf{c}_\\pi\\Big)</span> . In this case, we need to show that  <span class="math">\\mathbf{c}_{\\pi + 1}</span>  (in SigGen) =  <span class="math">\\mathbf{c}_{\\pi + 1}</span>  (in SigVer). In doing so, we evaluate two equalities one related to the public key  <span class="math">\\mathbf{r}_\\pi^{(k)} = \\mathbf{A}_{2q,\\pi}^{(k)} \\cdot \\mathbf{t}_\\pi^{(k)} + \\mathbf{q} \\cdot \\mathbf{c}_\\pi</span> , and the other associated to the linking tag  <span class="math">\\mathbf{z}_{\\pi,p&#x27;}^{(k)} = \\mathbf{H}_{2q,\\pi,p&#x27;}^{(k)} \\cdot \\mathbf{t}_{\\pi,p&#x27;}^{(k)} + \\mathbf{q} \\cdot \\mathbf{c}_\\pi</span> . These equalities are analysed as follows:</li>

    </ul>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first equality is compared with  <span class="math">\\forall (k,p^{\\prime})\\in [N_{in}]\\times [N_{CS}]</span> :</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {r} _ {\\pi} ^ {(k)} = \\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {t} _ {\\pi} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {r} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\left\\{\\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {t} _ {\\pi , p ^ {\\prime}} ^ {(k)} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\left\\{\\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left(\\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}}\\right) \\right\\} +</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{\\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} +</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{\\mathbf {A} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{(2 \\cdot \\mathbf {A}, - 2 \\cdot \\mathbf {a} _ {\\pi} ^ {(k)} + \\mathbf {q}) \\cdot [ \\mathbf {S} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] ^ {T} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\mathbf {A}, - 2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {q} \\right\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot [ \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] \\right\\} ^ {T} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\mathbf {A} \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, - 2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {q} \\right\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, - 2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {q} \\right\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} = \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We distinguish two cases for  <span class="math">b</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">b = 0</span> , we verify that  <span class="math">-\\mathbf{q} \\cdot \\mathbf{c}_{\\pi} = \\mathbf{q} \\cdot \\mathbf{c}_{\\pi} \\mod 2q</span> .</li>

      <li>When  <span class="math">b = 1</span> , we have  <span class="math">\\mathbf{q} \\cdot \\mathbf{c}_{\\pi} = \\mathbf{q} \\cdot \\mathbf{c}_{\\pi} \\mod 2q</span> .</li>

    </ul>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consequently, the second equality is also examined with  <span class="math">\\forall (k,p^{\\prime})\\in</span> <span class="math">[N_{in}]\\times [N_{CS}]</span>  ..</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} _ {\\pi} ^ {(k)} = \\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {t} _ {\\pi} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {z} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\left\\{\\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {t} _ {\\pi , p ^ {\\prime}} ^ {(k)} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\left\\{\\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left(\\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}}\\right) \\right\\} +</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {u} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{\\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} +</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{\\mathbf {H} _ {2 q, \\pi} ^ {(k)} \\cdot \\mathbf {S} _ {2 q, \\pi , p ^ {\\prime}} ^ {(k)} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{(2 \\cdot \\mathbf {H}, - 2 \\cdot \\mathbf {h} _ {\\pi} ^ {(k)} + \\mathbf {q}) \\cdot [ \\mathbf {S} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] ^ {T} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_ {p ^ {\\prime} = 1} ^ {N _ {C S}} \\left\\{(2 \\cdot \\mathbf {H}, - 2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} \\mathbf {h} _ {\\pi , p ^ {\\prime}} ^ {\\prime (k)} + \\mathbf {q}) \\cdot [ \\mathbf {S} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] ^ {T} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} \\right\\} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\mathbf {H}, - 2 \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} \\mathbf {H} \\cdot \\mathbf {S} _ {\\pi , p ^ {\\prime}} ^ {(k)} + \\mathbf {q} \\right\\} \\cdot \\left\\{\\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot [ \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] \\right\\} ^ {T}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\mathbf {H}, - 2 \\cdot \\mathbf {H} \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k), T} + \\mathbf {q} \\right\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot [ \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, 1 ] \\right\\} ^ {T} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\left\\{2 \\cdot \\mathbf {H} \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, - 2 \\cdot \\mathbf {H} \\cdot \\sum_ {p ^ {\\prime}} ^ {N _ {C S}} H (\\bar {\\mathbf {a}} _ {\\pi , p ^ {\\prime}} ^ {(k)}, L ^ {s h}) \\cdot \\bar {\\mathbf {S}} _ {\\pi , p ^ {\\prime}} ^ {(k), T} + \\mathbf {q} \\right\\}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block">0 = \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} + \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\cdot (- 1) ^ {b ^ {(k)}} = \\mathbf {q} \\cdot \\mathbf {c} _ {\\pi} \\iff</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We distinguish between two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When  <span class="math">b = 0</span> , it is verified that  <span class="math">-\\mathbf{q} \\cdot \\mathbf{c}_{\\pi} = \\mathbf{q} \\cdot \\mathbf{c}_{\\pi} \\mod 2q</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When <span class="math">b=1</span>, we have <span class="math">\\mathbf{q}\\cdot\\mathbf{c}_{\\pi}=\\mathbf{q}\\cdot\\mathbf{c}_{\\pi}\\bmod 2q</span>.</li>

    </ul>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">A.2 Correctness of SigLink</h3>

    <p class="text-gray-300">We show that an honest user <span class="math">\\pi</span> who signs two messages <span class="math">\\mu_{1}</span> and <span class="math">\\mu_{2}</span> in the MIMO.L2RS-CS scheme with the list of public-keys <span class="math">L</span>, obtains a Linked output from SigLink algorithm with overwhelming probability. As shown in Algorithm 4, two signatures <span class="math">\\sigma(\\mu)_{1}</span> and <span class="math">\\sigma(\\mu)_{2}</span> were created, and then successfully verified by SigVer. Therefore, the linkability tags <span class="math">\\mathbf{h}_{\\mu_{1}}^{(k)}</span> and <span class="math">\\mathbf{h}_{\\mu_{2}}^{(k)}</span> <span class="math">\\forall k\\in[N_{in}]</span> must be equal. To prove this, we show that:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{H}_{2q,\\mu_{1}}^{(k)}</span> <span class="math">=\\big{(}2\\cdot\\mathbf{H},-2\\cdot\\mathbf{h}_{\\mu_{1}}^{(k)}+\\mathbf{q}\\big{)}\\in\\mathcal{R}_{2q}^{2\\times m},\\text{where}</span> <span class="math">\\mathbf{H}</span> <span class="math">=\\mathsf{PP}\\text{ and }\\mathbf{h}_{\\mu_{1}}^{(k)}=(\\mathbf{H}\\cdot\\mathbf{S}_{\\pi}^{(k)}+\\mathbf{q})\\in\\mathcal{R}_{q}^{2}</span> <span class="math">\\mathbf{H}_{2q,\\mu_{2}}^{(k)}</span> <span class="math">=\\big{(}2\\cdot\\mathbf{H},-2\\cdot\\mathbf{h}_{\\mu_{2}}^{(k)}+\\mathbf{q}\\big{)}\\in\\mathcal{R}_{2q}^{2\\times m},\\text{where}</span> <span class="math">\\mathbf{H}</span> <span class="math">=\\mathsf{PP}\\text{ and }\\mathbf{h}_{\\mu_{2}}^{(k)}=(\\mathbf{H}\\cdot\\mathbf{S}_{\\pi}^{(k)}+\\mathbf{q})\\in\\mathcal{R}_{q}^{2}</span></p>

    <p class="text-gray-300">The first parts of the linkability tag in both MIMO.L2RS-CS signatures have same equality with following probability:</p>

    <p class="text-gray-300"><span class="math">Pr\\big{[}2\\cdot\\mathbf{H}=2\\cdot\\mathbf{H}\\big{]}=1.</span></p>

    <p class="text-gray-300">Ultimately, the second part uses the honest user’s secret-key <span class="math">\\mathbf{S}_{\\pi}^{(k)}</span> is used, so we conclude that:</p>

    <p class="text-gray-300"><span class="math">Pr\\big{[}-2\\cdot\\mathbf{h}_{\\mu_{1}}^{(k)}+\\mathbf{q}+2\\cdot\\mathbf{h}_{\\mu_{2}}^{(k)}-\\mathbf{q}=0\\big{]}=1.</span></p>

    <h2 id="sec-40" class="text-2xl font-bold">Appendix B MIMO.L2RS-CS - One-Time Unforgeability</h2>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The MIMO.L2RS-CS scheme relies on the <span class="math">\\mathbf{MSIS}_{q.m,k,\\beta}^{\\mathcal{K}}</span> problem to be secure against any existential forger. This means that a forgery algorithm succeeds with a negligible probability. We conclude that under this probability, the attacker will also find a solution to the <span class="math">\\mathbf{MSIS}_{q.m,k,\\beta}^{\\mathcal{K}}</span> problem. We consider the sequence of games in this proof where a PPT <span class="math">\\mathcal{A}</span> is the adversary against the MIMO.L2RS-CS scheme.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Game 0 - Real Game</h4>

    <p class="text-gray-300">: This is defined as the original attack game where the challenger <span class="math">\\mathcal{C}</span> and the adversary <span class="math">\\mathcal{A}</span> interact to produce a forgery. We know that <span class="math">\\mathbf{a}\\triangleq\\mathbf{pk}</span> and <span class="math">\\mathbf{S}\\triangleq\\mathbf{sk}</span>; then, the real Game starts with the challenger <span class="math">\\mathcal{C}</span> who calls <span class="math">\\mathsf{PP}\\leftarrow\\mathsf{Setup}(1^{\\lambda})</span> and gives <span class="math">\\mathsf{PP}</span> to <span class="math">\\mathcal{A}</span>. <span class="math">\\mathcal{C}</span> runs KeyGen (Algorithm 1), where <span class="math">\\mathcal{C}</span> starts computing <span class="math">\\bar{\\mathbf{a}}_{1}^{\\dagger}</span> and <span class="math">\\bar{\\mathbf{S}}_{1}^{\\dagger}</span>. When the adversary <span class="math">\\mathcal{A}</span> sends <span class="math">\\bar{\\mathbf{a}}_{p^{\\prime}}</span> with <span class="math">p^{\\prime}\\in[2,N_{CS}]</span>, <span class="math">\\mathcal{C}</span> returns <span class="math">\\bar{\\mathbf{a}}_{1}^{\\dagger}</span> to <span class="math">\\mathcal{A}</span>. After that, <span class="math">\\mathcal{C}</span> performs the aggregate shared public-key as <span class="math">\\mathbf{a}_{\\pi}^{sh}=\\sum_{p^{\\prime}}^{N_{CS}}H_{2}(\\bar{\\mathbf{a}}_{p^{\\prime}},L^{sh})\\cdot\\bar{\\mathbf{a}}_{p^{\\prime}}</span> with <span class="math">L^{sh}=\\big{\\{}\\bar{\\mathbf{a}}_{1},\\dots,\\bar{\\mathbf{a}}_{N_{CS}}\\big{\\}}</span>. <span class="math">\\mathcal{C}</span> outputs <span class="math">(\\mathbf{a}_{\\pi}^{sh},\\mathbf{S}_{1}^{T})</span></p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">with its secret-key computed as <span class="math">\\mathbf{S}_1^T = H_2(\\bar{\\mathbf{a}}_1, L^{sh}) \\cdot \\bar{\\mathbf{S}}_1^T</span>. <span class="math">\\mathcal{A}</span> queries the <span class="math">\\mathcal{KO}</span> oracle <span class="math">Q_k</span> times.</p>

    <p class="text-gray-300">The challenger <span class="math">\\mathcal{C}</span> and the adversary <span class="math">\\mathcal{A}</span> interact to generate a signature <span class="math">\\sigma(\\mu)^t</span> on <span class="math">(L^t, \\mu^t)</span> with <span class="math">L^t = \\left\\{\\mathbf{a}_1^{(k)}, \\ldots, (\\mathbf{a}_\\pi^{(k)})^{sh}, \\ldots, \\mathbf{a}_w^{(k)}\\right\\} \\forall k \\in [N_{in}]</span> and for any <span class="math">t \\in [1, Q_s]</span>. We assume that <span class="math">(\\mathbf{a}_\\pi^{(k)})^{sh}</span> was generated following the KeyGen algorithm and from which the challenger <span class="math">\\mathcal{C}</span>'s public-key <span class="math">(\\bar{\\mathbf{a}}_1^\\dagger)</span> occurs once. Whenever <span class="math">\\mathcal{A}</span> sends interactive queries <span class="math">Q_s</span> with <span class="math">(L^t, \\mu^t)</span> to <span class="math">\\mathcal{C}</span> who behaves as in Algorithm 5 and ultimately returns <span class="math">\\sigma(\\mu)^t</span> to <span class="math">\\mathcal{A}</span>.</p>

    <p class="text-gray-300">The adversary <span class="math">\\mathcal{A}</span> completes the simulation and outputs a forgery <span class="math">(L^{<em>},\\mu^{</em>},\\sigma (\\mu)^{*})</span>. <span class="math">\\mathcal{A}</span> wins the game if this forgery satisfies the following conditions:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>SigVer <span class="math">(L^{<em>},\\mu^{</em>},\\sigma (\\mu^{<em>})^{</em>})</span> outputs Accept.</li>

      <li><span class="math">\\mathcal{SO}</span> was queried at most once.</li>

      <li><span class="math">(L^{<em>},\\mu^{</em>},\\sigma (\\mu^{<em>})^{</em>})</span> is not an output of <span class="math">\\mathcal{SO}</span>.</li>

      <li>For all <span class="math">i \\in [w]</span>, there exists <span class="math">k \\in [N_{in}]</span> such that <span class="math">\\mathbf{p}\\mathbf{k}_i^{<em>(k)} \\in L^</em></span> was generated by the KO oracle.</li>

      <li>Every <span class="math">\\mathbf{p}\\mathbf{k}_i^{*(k)}</span> was used to query <span class="math">\\mathcal{SO}</span> as a signing key rather than a decoy at most once.</li>

    </ol>

    <p class="text-gray-300">If we define the event <span class="math">S_0</span> where the adversary <span class="math">\\mathcal{A}</span> wins Game 0, then we argued that <span class="math">\\mathcal{A}</span>'s advantage is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ S _ {0} \\right] \\leq \\epsilon_ {0}. \\tag {3}</span></div>

    <p class="text-gray-300"><strong>Game 1</strong>: This game is similar to <strong>Game 0</strong>, but this time the challenger <span class="math">\\mathcal{C}</span> behaves different in the random oracle <span class="math">H_0</span> as illustrated in Algorithm 6 (step 15). On a <span class="math">y</span>-th query <span class="math">\\mathbf{r}_y^{(k)}</span> and <span class="math">\\mathbf{z}_y^{(k)}</span> from the adversary <span class="math">\\mathcal{A}</span>, then <span class="math">\\mathcal{C}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> returns <span class="math">H_0\\big(\\mathbf{r}_y^{(k)},\\mathbf{z}_y^{(k)}\\big)</span> if this is already defined.</li>

      <li><span class="math">\\mathcal{C}</span> chooses at random <span class="math">\\mathbf{o}_y^{(k)}\\gets S_{n,\\kappa}</span>, otherwise.</li>

      <li><span class="math">\\mathcal{C}</span> verifies if there exists <span class="math">p&#x27; \\in [1, y - 1]</span> such that <span class="math">\\mathbf{o}_y^{(k)} = H_0\\big(\\mathbf{r}_{\\pi, p&#x27;}^{(k)}, \\mathbf{z}_{\\pi, p&#x27;}^{(k)}\\big)</span> for previous queries of <span class="math">\\mathbf{r}_{\\pi, p&#x27;}^{(k)}</span> and <span class="math">\\mathbf{z}_{\\pi, p&#x27;}^{(k)}</span>. In the case where <span class="math">p&#x27;</span> exists, the game is aborted, otherwise:</li>

      <li><span class="math">\\mathcal{C}</span> sets <span class="math">\\mathbf{o}_y^{(k)} = H_0\\big(\\mathbf{r}_{\\pi ,p&#x27;}^{(k)},\\mathbf{z}_{\\pi ,p&#x27;}^{(k)}\\big)</span> and returns <span class="math">\\mathbf{o}_y^{(k)}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">The difference between the <strong>Game 0</strong> and <strong>Game 1</strong> is that the challenger <span class="math">\\mathcal{C}</span> aborts when he tries to set a same hash value <span class="math">H_0</span> for two different inputs. This game evaluates the probability that <span class="math">\\mathcal{C}</span> aborts the game under this situation. The total number of queries <span class="math">Q_0</span> to <span class="math">H_0</span> oracle is at most <span class="math">Q_0 + Q_s</span>. Then the probability that <span class="math">\\mathcal{C}</span> aborts <strong>Game 1</strong> is</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">|  Algorithm 5 SigGen - Game 0  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: S K = {S(sk)π,p'} p' ∈ [NCS], k ∈ [Nin], μ, L = {a(k)i ∈ [w], k ∈ [Nin]} as in (1), and PP.  |   |</p>

    <p class="text-gray-300">|  Output: σ(μ) = (c1, {t1(k), ..., tw(k)} k ∈ [Nin], {hw(k)} k ∈ [Nin])  |   |</p>

    <p class="text-gray-300">|  1: procedure SIGGEN(SK, μ, L, PP)  |   |</p>

    <p class="text-gray-300">|  2: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  3: The challenger C computes the linking tag h(k)π, p = H · S(k)π, p ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  4: C sets o(k)π, p = H0(h(k)π, p)  |   |</p>

    <p class="text-gray-300">|  5: When A sends o(k)π, p' with p' ∈ [2, NCS], C returns o(k)π, p to A.  |   |</p>

    <p class="text-gray-300">|  6: When A sends h(k)π, p' with p' ∈ [2, NCS], C sends h(k)π, p to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  7: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  8: if o(k)π, p' = H0(h(k)π, p') then Accept  |   |</p>

    <p class="text-gray-300">|  9: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  10: C computes the shared linking tag h(k)π = ∑p' NCS h(k)π, p'  |   |</p>

    <p class="text-gray-300">|  11: C calls Lift(H, h(k)π) to obtain H(k)π, p = (2 · H, -2 · h(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  12: C calls Lift(A, a(k)π) to obtain A(k)π, p = (2 · A, -2 · a(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  13: C chooses u(k)π, p = (uπ, p, 1, ..., uπ, p, m)T, where uπ, p, i ← Dπ, for 1 ≤ i ≤ m.  |   |</p>

    <p class="text-gray-300">|  14: C computes r(k)π, p = A(k)π, p' = u(k)π, p and z(k)π, p = H(k)π, p' = u(k)π, p  |   |</p>

    <p class="text-gray-300">|  15: C sets o(k)π, p = H0(r(k)π, p', z(k)π)  |   |</p>

    <p class="text-gray-300">|  16: When A sends o(k)π, p' with p' ∈ [2, NCS], C returns o(k)π, p to A.  |   |</p>

    <p class="text-gray-300">|  17: When A sends r(k)π, p' and z(k)π, p' with p' ∈ [2, NCS], C sends r(k)π, p and z(k)π, p to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  18: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  19: if o(k)π, p' = H0(r(k)π, p', z(k)π) then Accept  |   |</p>

    <p class="text-gray-300">|  20: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  21: C computes r(k)π = ∑p' = 1 NCS t(k)π, p' and z(k)π = ∑p' = 1 NCS z(k)π, p'  |   |</p>

    <p class="text-gray-300">|  22: C performs ∀k ∈ [Nin], cπ+1 = H1(L, H(k)π, p, r(k)π, z(k)π).  |   |</p>

    <p class="text-gray-300">|  23: for (i = π + 1, π + 2, ..., w, 1, 2, ..., π - 1) do  |   |</p>

    <p class="text-gray-300">|  24: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  25: C selects t(k)π = (ti, p, 1, ..., ti, p, m)T, where ti, p, j ← Dπ, for 1 ≤ j ≤ m.  |   |</p>

    <p class="text-gray-300">|  26: When A sends t(k)π, p' with p' ∈ [2, NCS], C returns t(k)π, p to A.  |   |</p>

    <p class="text-gray-300">|  27: C computes t(k)π = ∑p' = 1 NCS t(k)π, p'  |   |</p>

    <p class="text-gray-300">|  28: C calls Lift(A, a(k)π) to obtain A(k)π, p = (2 · A, -2 · a(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  29: C runs ∀k ∈ [Nin] c i+1 = H1(L, H(k)π, p, {A(k)π, p' + t(k) + q · c i}, {H(k)π, p' + t(k) + q · c i}).  |   |</p>

    <p class="text-gray-300">|  30: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  31: C chooses b(k) ← {0, 1}.  |   |</p>

    <p class="text-gray-300">|  32: C computes t(k)π = u(k)π + S(k)π, p' ∈ [2, NCS], C returns t(k)π, p to A  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33: Continue with prob. (M exp(-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(k)π, p' - cπ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2/2σ2) cosh((t(k)π, p, S(k)π, p' - cπ))^−1 otherwise Restart.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  34: When A sends t(k)π, p' with p' ∈ [2, NCS], C returns t(k)π, p to A  |   |</p>

    <p class="text-gray-300">|  35: C computes t(k)π = ∑p' = 1 NCS t(k)π, p'  |   |</p>

    <p class="text-gray-300">|  36: return σ(μ) = (c1, {t1(k), ..., tw(k)}k ∈ [Nin], {h0(k)}k ∈ [Nin]).  |   |</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{y=1}^{Q_0 + Q_s} \\Pr \\left[ \\left(\\mathbf{r}_{\\pi,p&#x27;}^{(k)}, \\mathbf{z}_{\\pi,p&#x27;}^{(k)}\\right) \\in \\left\\{\\mathbf{r}_{y&#x27;}^{(k)}, \\mathbf{z}_{y&#x27;}^{(k)}\\right\\}_{y&#x27; &amp;lt; y} \\right] \\leq</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{y=1}^{Q_0 + Q_s} \\sum_{y&#x27;=1}^{y-1} \\mathbf{u}_{\\pi,p&#x27;}^{(k)} \\leftarrow D_{\\sigma}^{n} \\left[ \\mathbf{r}_{\\pi,p&#x27;}^{(k)} = \\mathbf{r}_{y&#x27;}^{(k)} \\right] \\leq</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{y=1}^{Q_0 + Q_s} \\frac{y-1}{2^n} \\leq \\frac{(Q_0 + Q_s)(Q_0 + Q_s + 1)}{2^n}</span></div>

    <p class="text-gray-300">Let <span class="math">S_1</span> be the event where the <span class="math">\\mathcal{A}</span> wins this Game with negligible probability <span class="math">\\frac{(Q_0 + Q_s)(Q_0 + Q_s + 1)}{2^n} \\leq \\epsilon_1</span>. Then we argue that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_0] - \\Pr[S_1] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_1. \\tag{4}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Game 2</strong>: This game is identical to <strong>Game 1</strong> except that the <strong>SigGen</strong> algorithm is still modified by the challenger <span class="math">\\mathcal{C}</span>. When <span class="math">\\mathcal{A}</span> sends interactive queries <span class="math">Q_s</span> with <span class="math">(L^t, \\mu^t)</span> to <span class="math">\\mathcal{C}</span> for signing using the <strong>SigGen</strong> algorithm, then <span class="math">\\mathcal{C}</span> behaves as shown in Algorithm 7.</p>

    <p class="text-gray-300">The <span class="math">\\mathcal{C}</span> chooses <span class="math">\\mathbf{c}_{\\pi+1}</span> at random from <span class="math">S_{n,\\kappa} \\subseteq \\mathcal{R}_{2q}</span>, Algorithm 7 (step 22), after that <span class="math">\\mathcal{C}</span> programs the answer of the random oracle <span class="math">H_1 \\ \\forall k \\in [N_{in}]</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">H_1 \\left(L, \\mathbf{H}_{2q,\\pi}^{(k)}, \\mu, \\mathbf{r}_{\\pi}^{(k)}, \\mathbf{z}_{\\pi}^{(k)}\\right) = H_1 \\left(L, \\mathbf{H}_{2q,\\pi}^{(k)}, \\mu, \\mathbf{A}_{2q,\\pi}^{(k)} \\cdot \\mathbf{t}_{\\pi}^{(k)} \\cdot \\mathbf{q} \\cdot \\mathbf{c}_{\\pi}, \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left. \\mathbf{H}_{2q,\\pi}^{(k)} \\cdot \\mathbf{t}_{\\pi}^{(k)} + \\mathbf{q} \\cdot \\mathbf{c}_{\\pi} \\right\\}),</span></div>

    <p class="text-gray-300">without verifying if the values of <span class="math">\\mathbf{r}_{\\pi}^{(k)} = \\sum_{p&#x27;=1}^{N_{CS}} \\mathbf{A}_{2q,\\pi}^{(k)} \\cdot \\mathbf{u}_{\\pi,p&#x27;}^{(k)}</span> and <span class="math">\\mathbf{z}_{\\pi}^{(k)} = \\sum_{p&#x27;=1}^{N_{CS}} \\mathbf{H}_{2q,\\pi}^{(k)} \\cdot \\mathbf{u}_{\\pi,p&#x27;}^{(k)} \\ \\forall (k,p&#x27;) \\in [N_{in}] \\times [N_{CS}]</span> were already set. Every time Algorithm 7 is called by <span class="math">\\mathcal{A}</span>, the probability of generating <span class="math">\\mathbf{u}_{\\pi,p&#x27;}^{(k)}</span>, such that <span class="math">\\mathbf{r}_{\\pi}^{(k)}</span> and <span class="math">\\mathbf{z}_{\\pi}^{(k)}</span> are equal to one of the previous values that were queried is at most <span class="math">2^{-n+1}</span>. Therefore, if the <strong>SigGen</strong> in Game 2 and <span class="math">H_1</span> are queried <span class="math">Q_s</span> and <span class="math">Q_1</span> times, respectively, then the probability of getting one collision each time is at most <span class="math">N_{in} \\cdot N_{CS} \\cdot (Q_s + Q_1) \\cdot 2^{-n+1}</span>. Additionally, the probability that a collision happens after <span class="math">Q_s</span> queries is at most <span class="math">N_{in} \\cdot N_{CS} \\cdot Q_s \\cdot (Q_s + Q_1) \\cdot 2^{-n+1}</span>, which is negligible (Based on [19], Lemma 3.4).</p>

    <p class="text-gray-300">Let <span class="math">S_2</span> be the event where the <span class="math">\\mathcal{A}</span> wins <strong>Game 2</strong> with negligible probability <span class="math">N_{in} \\cdot N_{CS} \\cdot Q_s \\cdot (Q_s + Q_1) \\cdot 2^{-n+1} \\leq \\epsilon_2</span>. Then we claim that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_1] - \\Pr[S_2] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_2. \\tag{5}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">|  Algorithm 6 SigGen - Game 1  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: S K = {S(sk),k∈[NCS],k∈[Nin], μ, L = {a(k)}i∈[w],k∈[Nin] as in (1), and PP.  |   |</p>

    <p class="text-gray-300">|  Output: σ(μ) = (c1, {t1(k), ..., tw(k)}k∈[Nin], {hπ(k)}k∈[Nin])  |   |</p>

    <p class="text-gray-300">|  1: procedure SigGen(SK, μ, L, PP)  |   |</p>

    <p class="text-gray-300">|  2: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  3: The challenger C computes the linking tag h(sk),k = H · S(sk),k ∈ R24.  |   |</p>

    <p class="text-gray-300">|  4: C sets o(k)k = H0(h(k)k)  |   |</p>

    <p class="text-gray-300">|  5: When A sends o(k),k with p' ∈ [2, NCS], C returns o(k),k to A.  |   |</p>

    <p class="text-gray-300">|  6: When A sends h(k),k with p' ∈ [2, NCS], C sends h(k),k to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  7: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  8: if o(k),k = H0(h(k),k) then Accept  |   |</p>

    <p class="text-gray-300">|  9: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  10: C computes the shared linking tag h(k) = ∑p' NCS h(k),k  |   |</p>

    <p class="text-gray-300">|  11: C calls Lift(H, h(k)) to obtain H(k) = (2 · H, -2 · h(k) + q) ∈ R22×m.  |   |</p>

    <p class="text-gray-300">|  12: C calls Lift(A, a(k)) to obtain A(k),k = (2 · A, -2 · a(k) + q) ∈ R22×m.  |   |</p>

    <p class="text-gray-300">|  13: C chooses u(k),k = (uπ,p,1, ..., uπ,p,m)T, where uπ,p,i ← Dπ, for 1 ≤ i ≤ m.  |   |</p>

    <p class="text-gray-300">|  14: C computes r(k),k = A(k),k · u(k),k and z(k),k = H(k) + u(k),k  |   |</p>

    <p class="text-gray-300">|  15: C chooses at random o(k),k ← Sn,n  |   |</p>

    <p class="text-gray-300">|  16: When A sends o(k),k with p' ∈ [2, NCS], C returns o(k),k to A.  |   |</p>

    <p class="text-gray-300">|  17: When A sends r(k),k and z(k),k with p' ∈ [2, NCS], C sends r(k),k and z(k),k to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  18: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  19: if o(k),k = H0(r(k),k, z(k),k) then Accept  |   |</p>

    <p class="text-gray-300">|  20: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  21: C computes r(k) = ∑p'=1NCS r(k),k and z(k) = ∑p'=1NCS z(k),k  |   |</p>

    <p class="text-gray-300">|  22: C performs ∀k ∈ [Nin], cπ+1 = H1(L, H(k),k, μ, r(k),k, z(k)).  |   |</p>

    <p class="text-gray-300">|  23: for (i = π + 1, π + 2, ..., w, 1, 2, ..., π - 1) do  |   |</p>

    <p class="text-gray-300">|  24: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  25: C selects t(k),k = (ti,p,1, ..., ti,p,m)T, where ti,p,j ← Dπ, for 1 ≤ j ≤ m.  |   |</p>

    <p class="text-gray-300">|  26: When A sends t(k),k with p' ∈ [2, NCS], C returns t(k),k to A.  |   |</p>

    <p class="text-gray-300">|  27: C computes t(k) = ∑p'=1NCS t(k),k  |   |</p>

    <p class="text-gray-300">|  28: C calls Lift(A, a(k)) to obtain A(k) = (2 · A, -2 · a(k) + q) ∈ R22×m.  |   |</p>

    <p class="text-gray-300">|  29: C runs ∀k ∈ [Nin] c1+1 = H1(L, H(k),k, μ, {A(k),k, t(k) + q · c1}, {H(k),k, t(k) + q · c1}).  |   |</p>

    <p class="text-gray-300">|  30: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  31: C chooses b(k) ← {0, 1}.  |   |</p>

    <p class="text-gray-300">|  32: C computes t(k),k = u(k),k + S(k),k · cπ · (-1)b(k), where S(k),k = [(S(k),k)T, 1]T.  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33: Continue with prob. (M exp(-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(k),k, π, p · cπ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2/2σ2) cosh(⟨t(k),k, S(k),k, π, p · cπ⟩/σ2)) -1 otherwise Restart.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  34: When A sends t(k),k with p' ∈ [2, NCS], C returns t(k),k to A  |   |</p>

    <p class="text-gray-300">|  35: C computes t(k) = ∑p'=1NCS t(k),k  |   |</p>

    <p class="text-gray-300">|  36: return σ(μ) = (c1, {t1(k), ..., tw(k)}k∈[Nin], {hπ(k)}k∈[Nin]).  |   |</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Algorithm 7 SigGen - Game 2 Input:  <span class="math">\\mathcal{SK} = \\left\\{\\mathbf{S}_{\\pi ,p^{\\prime}}^{(k)}\\right\\}_{p^{\\prime}\\in [N_{CS}],k\\in [N_{in}]}</span> <span class="math">\\mu ,L = \\left\\{\\mathbf{a}_i^{(k)}\\right\\}_{i\\in [w],k\\in [N_{in}]}</span>  as in (1), and PP. Output:  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span> 1: procedure SigGEN(SK,  <span class="math">\\mu ,L</span>  ,PP) 2: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 3: The challenger  <span class="math">\\mathcal{C}</span>  computes the linking tag  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)} = \\mathbf{H}\\cdot \\mathbf{S}_{\\pi ,p}^{(k)}\\in \\mathcal{R}_q^2</span> 4:  <span class="math">\\mathcal{C}</span>  sets  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p}^{(k)} = H_0\\big(\\mathbf{h}_{\\pi ,p}^{(k)}\\big)</span> 5: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 6: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  sends  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span>  . Then,  <span class="math">\\mathcal{C}</span>  computes as follows: 7: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 8: if  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p^{\\prime}}^{(k)} = H_0\\big(\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}\\big)</span>  then Accept 9: else Abort protocol 10:  <span class="math">\\mathcal{C}</span>  computes the shared linking tag  <span class="math">\\mathbf{h}_{\\pi}^{(k)} = \\sum_{p^{\\prime}}^{N_{CS}}\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}</span> 11:  <span class="math">\\mathcal{C}</span>  calls Lift(H,  <span class="math">\\mathbf{h}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{H}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{H}, - 2\\cdot \\mathbf{h}_\\pi^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 12:  <span class="math">\\mathcal{C}</span>  calls Lift(A,  <span class="math">\\mathbf{a}_\\pi^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_\\pi^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 13:  <span class="math">\\mathcal{C}</span>  chooses  <span class="math">\\mathbf{u}_{\\pi ,p}^{(k)} = (u_{\\pi ,p,1},\\dots ,u_{\\pi ,p,m})^T</span>  where  <span class="math">u_{\\pi ,p,i}\\gets D_{\\pi}^{n}</span>  for  <span class="math">1\\leq i\\leq m</span> 14:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)} = \\mathbf{A}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)} = \\mathbf{H}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span> 15:  <span class="math">\\mathcal{C}</span>  chooses at random  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}\\gets S_{n,n}</span> 16: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 17: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  sends  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span>  . Then,  <span class="math">\\mathcal{C}</span>  computes as follows: 18: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 19: if  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)} = H_0\\big(\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)},\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}\\big)</span>  then Accept 20: else Abort protocol 21:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{r}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span> 22:  <span class="math">\\mathcal{C}</span>  chooses at random  <span class="math">\\mathbf{c}_{\\pi +1}\\gets S_{n,n}</span> 23: for  <span class="math">(i = \\pi +1,\\pi +2,\\dots ,w,1,2,\\dots ,\\pi -1)</span>  do 24: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 25:  <span class="math">\\mathcal{C}</span>  selects  <span class="math">\\mathbf{t}_{i,p}^{(k)} = (t_{i,p,1},\\dots ,t_{i,p,m})^T</span>  where  <span class="math">t_{i,p,j}\\gets D_{\\sigma}^{n}</span>  for  <span class="math">1\\leq j\\leq m</span> 26: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{t}_{i,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 27:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_i^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span> 28:  <span class="math">\\mathcal{C}</span>  calls Lift(A,  <span class="math">\\mathbf{a}_i^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,i}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 29:  <span class="math">\\mathcal{C}</span>  runs  <span class="math">\\forall k\\in [N_{in}]</span> <span class="math">\\mathbf{c}_{i + 1} = H_1\\Big(L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,1}^{(k)}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} ,\\left\\{\\mathbf{H}_{2q,\\pi}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} \\Big).</span> 30: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 31:  <span class="math">\\mathcal{C}</span>  chooses  <span class="math">b^{(k)}\\gets \\{0,1\\}</span> 32:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)} = \\mathbf{u}_{\\pi ,p}^{(k)} + \\mathbf{S}_{2q,\\pi ,p}^{(k)}\\cdot \\mathbf{c}_{\\pi}\\cdot (-1)^{b^{(k)}}</span>  where  <span class="math">\\mathbf{S}_{2q,\\pi ,p}^{(k)} = [(\\mathbf{S}_{\\pi ,p}^{(k)})^T,1]^T</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33: Continue with prob.  $\\left(M\\exp \\left(-\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{2\\sigma^2}\\right)\\cosh \\left(\\frac{\\langle\\mathbf{t}_{\\pi,p}^{(k)},\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\rangle}{\\sigma^2}\\right)\\right)^{-1}$  otherwise Restart.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">34: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span> <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 35:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span> 36: return  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\left\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\right\\}_{k\\in [N_{in}]},\\left\\{\\mathbf{h}_\\sigma^{(k)}\\right\\}_{k\\in [N_{in}]}\\right).</span></p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game 3 : In this game the adversary  <span class="math">\\mathcal{A}</span>  queries the random oracle  <span class="math">H_0</span>  as in Algorithm 8 (step 5), and stores the answers in  <span class="math">Q_{H_0}</span> . The game aborts as in (step 11) if the  <span class="math">\\bar{\\mathbf{a}}_p</span> 's are not in the set  <span class="math">Q_{H_0}</span> . The successful acceptance of  <span class="math">\\bar{\\mathbf{a}}_p</span>  is equal to guess a preimage for the given  <span class="math">\\mathbf{o}_p</span>  that is committed in (step 5). As a result, the success probability is at most  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">S_{3}</span>  be the event where the  <span class="math">\\mathcal{A}</span>  wins Game 3 with negligible probability over  <span class="math">\\mathcal{R}_q^2</span>  which is at most  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,n}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\epsilon_3$ . Then we claim that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {2} \\right] - \\Pr \\left[ S _ {3} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {3}. \\tag {6}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Algorithm 8 KeyGen - Game 3 and Game 4 Input: PP:  <span class="math">\\mathbf{A}\\in \\mathcal{R}_q^{2\\times (m - 1)}</span> Output:  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{N_{CS}}^T\\right\\}\\right)</span>  , being the shared public-key and cosigner's secret-key, respectively. 1: procedure KeyGen(A) 2: Each cosigner  <span class="math">p\\in \\{1,\\ldots ,N_{CS}\\}</span>  .. 3: Selects  <span class="math">\\bar{\\mathbf{S}}_p^T = (\\bar{\\mathbf{s}}_{p,1},\\dots ,\\bar{\\mathbf{s}}_{p,m - 1})\\in \\mathcal{R}_q^{1\\times (m - 1)}</span>  , where  <span class="math">\\bar{\\mathbf{s}}_{p,i}\\gets (-2^{\\gamma},2^{\\gamma})^{n}</span>  , for  <span class="math">1\\leq i\\leq m - 1</span> 4: Calculates  <span class="math">\\bar{\\mathbf{a}}_p = (\\bar{\\mathbf{a}}_1,\\bar{\\mathbf{a}}_2)^T = \\mathbf{A}\\cdot \\bar{\\mathbf{S}}_p</span>  mod  <span class="math">q\\in \\mathcal{R}_q^2</span> 5:  <span class="math">\\mathbf{o}_p = H_0(\\bar{\\mathbf{a}}_p)</span> 6: Broadcasts  <span class="math">\\mathbf{o}_p</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7: Receives  <span class="math">\\mathbf{o}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "p" sends  <span class="math">\\bar{\\mathbf{a}}_p</span>  to the cosigners 8: Receives  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span> 9: Each cosigner verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if  <span class="math">\\mathbf{o}_{p^{\\prime}} = H_{0}(\\bar{\\mathbf{a}}_{p^{\\prime}})</span>  then Accept 12: else Abort protocol 13: Each cosigner computes the shared public-key as: 14:  <span class="math">\\mathbf{a}^{sh} = \\sum_{p&#x27;}^{N_{CS}}H_2(\\bar{\\mathbf{a}}_{p&#x27;},L^{sh})\\cdot \\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">L^{sh} = \\{\\bar{\\mathbf{a}}_1,\\dots ,\\bar{\\mathbf{a}}_{N_{CS}}\\}</span> 15: Each cosigner calculates its corresponding secret-key as: 16:  <span class="math">\\mathbf{S}_p^T = H_2(\\bar{\\mathbf{a}}_p,L^{sh})\\cdot \\bar{\\mathbf{S}}_p^T</span> 17: return  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{N_{CS}}^T\\right\\}\\right)</span>  , without loss of generality, each cosigner only outputs and holds its corresponding secret-key  <span class="math">\\mathbf{S}_{p&#x27;}^T</span></p>

    <p class="text-gray-300">Game 4: In this game the adversary  <span class="math">\\mathcal{A}</span>  queries the random oracle  <span class="math">H_{2}</span>  as in Algorithm 8 (step 16), and stores the answers in  <span class="math">Q_{H_2}</span> . The game aborts if the  <span class="math">\\bar{\\mathbf{a}}_p, L^{sh}</span> 's are in the set  <span class="math">Q_{H_2}</span> . We upper bound the probability of this abort in this game at most  <span class="math">\\frac{Q_{H_2}}{2^P}</span>  where  <span class="math">P</span>  is the min-entropy of  <span class="math">\\bar{\\mathbf{a}}_p</span> . We use the Leftover Hash Lemma (LHL) argument to show that the distribution of  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  is closed to uniform just by itself. The statistical distance between the distribution  <span class="math">D(\\bar{\\mathbf{a}}_{p&#x27;})</span>  and the uniform distribution  <span class="math">\\mathcal{R}_q^2</span>  is at most  <span class="math">\\epsilon_{LHL}</span> , where the min-entropy of  <span class="math">\\mathcal{R}_q^2 = 2 \\cdot n \\log q</span> . Likewise, we argue the min-entropy of  <span class="math">D(\\bar{\\mathbf{a}}_p) \\leq \\frac{1}{2^n}</span> . This proves that if this is not aborting, the output of  <span class="math">H_{2}</span>  and  <span class="math">\\bar{\\mathbf{a}}_p</span>  are completely independent of any adversary view.</p>

    <p class="text-gray-300">Let  <span class="math">S_4</span>  be the event where the  <span class="math">\\mathcal{A}</span>  wins Game 4 with negligible probability over  <span class="math">\\mathcal{R}_q^2</span>  which is at most  <span class="math">\\frac{Q_{H_2}}{2^n} \\leq \\epsilon_4</span> . Then we claim that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{3}]-\\Pr[S_{4}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{4}.$ (7)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-43" class="text-base font-medium mt-4">Game 5</h6>

    <p class="text-gray-300">: This Game now modify the KeyGen in algorithm 9 (step 4), and SigGen, Algorithm 10 (step 3), where the linking tag is computed. We recall that public-key as <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}^{(k)}=\\mathbf{A}\\cdot\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}\\bmod q\\in\\mathcal{R}_{q}^{2}</span>. We now choose <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}^{(k)}\\ \\forall(k,p^{\\prime})\\in[N_{CS}]\\times[N_{in}]</span> uniformly and randomly such <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}^{(k)}\\leftarrow\\mathcal{R}_{q}^{2}</span>. Moreover, we now choose <span class="math">\\mathbf{h}_{\\pi,p^{\\prime}}^{(k)}\\ \\forall(k,p^{\\prime})\\in[N_{CS}]\\times[N_{in}]</span> uniformly and randomly such <span class="math">\\mathbf{h}_{\\pi,p^{\\prime}}^{(k)}\\leftarrow\\mathcal{R}_{q}^{2}</span>, rather than computing the linking tag as <span class="math">\\mathbf{h}_{\\pi,p}^{(k)}=\\mathbf{H}\\cdot\\mathbf{S}_{\\pi,p}^{(k)}\\in\\mathcal{R}_{q}^{2}</span>. We recall that <span class="math">\\mathbf{S}_{\\pi,p}^{(k)}=H_{2}(\\bar{\\mathbf{a}}_{p},L^{sh})\\cdot\\bar{\\mathbf{S}}_{p}^{T}</span> (as KeyGen Algorithm 1) where <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span> is chosen small and with coefficients in <span class="math">(-2^{\\gamma},2^{\\gamma})</span>. We redefine <span class="math">\\mathbf{h}_{\\pi,p}^{(k)}=\\mathbf{H}\\cdot H_{2}(\\bar{\\mathbf{a}}_{p},L^{sh})\\cdot\\bar{\\mathbf{S}}_{p}^{T}</span>. Then, we now define a new random matrix <span class="math">\\mathbf{H}_{new}=\\mathbf{H}\\cdot H_{2}(\\bar{\\mathbf{a}}_{p},L^{sh})</span>.</p>

    <p class="text-gray-300">We know that the public parameter <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{H}_{new}</span> are uniform and <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span> is chosen small and with coefficients in <span class="math">(-2^{\\gamma},2^{\\gamma})</span>. Then, multiplying these <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{H}_{new}</span> by the secret key <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span>, it results in <span class="math">\\mathbf{a}_{\\pi}^{(k)}</span> that is close to uniform over <span class="math">\\mathcal{R}_{q}^{2}</span>.</p>

    <p class="text-gray-300">By the Leftover Hash Lemma (LHL) argument (Lemma 4), we show that the statistical distance between the distribution of <span class="math">\\mathbf{a}^{(k)}\\bmod q</span> and the uniform distribution on <span class="math">\\mathcal{R}_{q}^{2}</span> is at most <span class="math">N_{in}\\cdot N_{CS}\\cdot\\frac{1}{2}\\cdot\\sqrt{\\frac{q^{4n}}{2^{(\\gamma+1)\\cdot(m-1)\\cdot n}}}</span>, which is negligible in <span class="math">n</span>.</p>

    <p class="text-gray-300">Let <span class="math">S_{5}</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 5 with negligible probability <span class="math">\\mathcal{R}_{q}^{2}</span> is at most <span class="math">N_{in}\\cdot N_{CS}\\cdot\\frac{1}{2}\\cdot\\sqrt{\\frac{q^{4n}}{2^{(\\gamma+1)\\cdot(m-1)\\cdot n}}}\\leq\\epsilon_{5}</span>. Then we claim that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{4}]-\\Pr[S_{5}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{5}.$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-44" class="text-base font-medium mt-4">Game 6</h6>

    <p class="text-gray-300">: The challenger <span class="math">\\mathcal{C}</span> behaves different in the random oracle <span class="math">H_{0}</span> as illustrated in Algorithm 11 (step 11). On a <span class="math">y</span>-th query <span class="math">\\bar{\\mathbf{a}}_{p^{\\prime}}</span>, from the adversary <span class="math">\\mathcal{A}</span>, then <span class="math">\\mathcal{C}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> returns <span class="math">H_{0}\\big{(}\\bar{\\mathbf{a}}_{y}\\big{)}</span> if this is already defined.</li>

      <li><span class="math">\\mathcal{C}</span> chooses at random <span class="math">\\mathbf{o}_{y}\\leftarrow\\mathcal{S}_{n,\\kappa}</span>, otherwise.</li>

      <li><span class="math">\\mathcal{C}</span> verifies if there exists <span class="math">p^{\\prime}\\in[1,y-1]</span> such that <span class="math">\\mathbf{o}_{y}^{(k)}=H_{0}\\big{(}\\bar{\\mathbf{a}}_{p^{\\prime}}\\big{)}</span> for previous queries of <span class="math">\\bar{\\mathbf{a}}_{p^{\\prime}}</span>. In the case where <span class="math">p^{\\prime}</span> exists, the game is aborted, otherwise:</li>

      <li><span class="math">\\mathcal{C}</span> sets <span class="math">\\mathbf{o}_{y}^{(k)}=H_{0}\\big{(}\\bar{\\mathbf{a}}_{p^{\\prime}}\\big{)}</span> and returns <span class="math">\\mathbf{o}_{y}^{(k)}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">The difference between the Game 5 and Game 6 is that the challenger <span class="math">\\mathcal{C}</span> aborts when he tries to set a same hash value <span class="math">H_{0}</span> for two different inputs. This game evaluates the probability that <span class="math">\\mathcal{C}</span> aborts the game under this situation. The total number of queries <span class="math">Q_{0}</span> to <span class="math">H_{0}</span> oracle is at most <span class="math">Q_{0}+Q_{k}</span> where <span class="math">Q_{k}</span> is the number of queries to the <span class="math">\\mathcal{KO}</span> oracle. Then the probability that <span class="math">\\mathcal{C}</span> aborts Game 6 is</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">Algorithm 9 KeyGen - Game 5 Input: PP:  <span class="math">\\mathbf{A}\\in \\mathcal{R}_q^{2\\times (m - 1)}</span> Output:  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{N_{CS}}^T\\right\\}\\right)</span>  , being the shared public-key and cosigner's secret-key, respec-. tively. 1: procedure KEYGEN(A) 2: Each cosigner  <span class="math">p\\in \\{1,\\ldots ,N_{CS}\\}</span>  .. 3: Selects  <span class="math">\\bar{\\mathbf{S}}_p^T = (\\bar{\\mathbf{s}}_{p,1},\\dots ,\\bar{\\mathbf{s}}_{p,m - 1})\\in \\mathcal{R}_q^{1\\times (m - 1)}</span>  , where  <span class="math">\\bar{\\mathbf{s}}_{p,i}\\gets (-2^{\\gamma},2^{\\gamma})^{n}</span>  , for  <span class="math">1\\leq i\\leq m - 1</span> 4: Choose  <span class="math">\\bar{\\mathbf{a}}_p\\gets \\mathcal{R}_q^2</span> 5:  <span class="math">\\mathbf{o}_p = H_0(\\bar{\\mathbf{a}}_p)</span> 6: Broadcasts  <span class="math">\\mathbf{o}_p</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7: Receives  <span class="math">\\mathbf{o}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "p" sends  <span class="math">\\bar{\\mathbf{a}}_p</span>  to the cosigners 8: Receives  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span> 9: Each cosigner verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if  <span class="math">\\mathbf{o}_{p^{\\prime}} = H_{0}(\\bar{\\mathbf{a}}_{p^{\\prime}})</span>  then Accept 12: else Abort protocol 13: Each cosigner computes the shared public-key as: 14:  <span class="math">\\mathbf{a}^{sh} = \\sum_{p&#x27;}^{N_{CS}}H_2(\\bar{\\mathbf{a}}_{p&#x27;},L^{sh})\\cdot \\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">L^{sh} = \\{\\bar{\\mathbf{a}}_1,\\dots ,\\bar{\\mathbf{a}}_{N_{CS}}\\}</span> 15: Each cosigner calculates its corresponding secret-key as: 16:  <span class="math">\\mathbf{S}_p^T = H_2(\\bar{\\mathbf{a}}_p,L^{sh})\\cdot \\bar{\\mathbf{S}}_p^T</span> 17: return  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{N_{CS}}^T\\right\\}\\right)</span>  , without loss of generality, each cosigner only outputs and holds its corresponding secret-key  <span class="math">\\mathbf{S}_{p&#x27;}^T</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {y = 1} ^ {Q _ {0} + Q _ {k}} \\Pr \\left[ \\left(\\bar {\\mathbf {a}} _ {p ^ {\\prime}}\\right) \\in \\left\\{\\bar {\\mathbf {a}} _ {y ^ {\\prime}} \\right\\} _ {y ^ {\\prime} &amp;lt;   y} \\right] \\leq \\sum_ {y = 1} ^ {Q _ {0} + Q _ {k}} \\sum_ {y ^ {\\prime} = 1} ^ {y - 1} \\Pr_ {\\mathbf {A} \\leftarrow \\mathcal {R} _ {q} ^ {2 \\times (m - 1)}} \\left[ \\bar {\\mathbf {a}} _ {p ^ {\\prime}} = \\bar {\\mathbf {a}} _ {y ^ {\\prime}} \\right] \\leq \\\\ \\sum_ {y = 1} ^ {Q _ {0} + Q _ {k}} \\frac {y - 1}{2 ^ {n}} \\leq \\frac {(Q _ {0} + Q _ {k}) (Q _ {0} + Q _ {k} + 1)}{2 ^ {n}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let  <span class="math">S_6</span>  be the event where the  <span class="math">\\mathcal{A}</span>  wins this Game with negligible probability  <span class="math">\\frac{(Q_0 + Q_k)(Q_0 + Q_k + 1)}{2^n} \\leq \\epsilon_6</span> . Then we argue that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {5} \\right] - \\Pr \\left[ S _ {6} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {6}. \\tag {9}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Game 7: This Game performs similar to Game 6 but we now modify (for the signer  <span class="math">\\pi</span> ) the KeyGen Algorithm 12 (step 14). The aggregate public-key as  <span class="math">\\mathbf{a}_{\\pi}^{sh(k)} = \\sum_{p&#x27;}^{N_{CS}} H_2(\\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}, L^{sh}) \\cdot \\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}</span> . We now choose  <span class="math">\\mathbf{a}_{\\pi}^{sh(k)} \\forall (k) \\in [N_{in}]</span>  uniformly and randomly such that  <span class="math">\\mathbf{a}_{\\pi}^{sh(k)} \\gets \\mathcal{R}_q^2</span> . As in Game 1, it shows that  <span class="math">\\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}</span>  is uniformly random. We assume that  <span class="math">\\forall h \\gets S_{n,\\kappa}</span>  where  <span class="math">h</span>  is the output of the hash function  <span class="math">H_2</span> . We said that  <span class="math">h</span>  needs to be invertible in  <span class="math">\\mathcal{R}_q^2</span> , then to achieve this condition, we choose  <span class="math">S_{n,\\kappa}</span>  such that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\frac{1}{\\sqrt{k}} \\cdot q^{1/k}$  as shown in ([34], Corollary 1.2), with probability 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Algorithm 10 SigGen - Game 5 Input:  <span class="math">\\mathcal{SK} = \\left\\{\\mathbf{S}_{\\pi ,p^{\\prime}}^{(k)}\\right\\}_{p^{\\prime}\\in [N_{CS}],k\\in [N_{in}]}</span> <span class="math">\\mu ,L = \\left\\{\\mathbf{a}_i^{(k)}\\right\\}_{i\\in [w],k\\in [N_{in}]}</span>  as in (1), and PP. Output:  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span> 1: procedure SigGEN(SK,  <span class="math">\\mu ,L</span>  ,PP) 2: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 3: The linking tag is chosen at random  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)}\\gets \\mathcal{R}_q^2</span> 4: C sets  <span class="math">\\hat{\\mathbf{o}}_{\\pi ,p}^{(k)} = H_0(\\mathbf{h}_{\\pi ,p}^{(k)})</span> 5: When A sends  <span class="math">\\hat{\\mathbf{o}}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C returns  <span class="math">\\hat{\\mathbf{o}}_{\\pi ,p}^{(k)}</span>  to A. 6: When A sends  <span class="math">\\mathbf{h}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C sends  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)}</span>  to A. Then, C computes as follows: 7: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 8: if  <span class="math">\\hat{\\mathbf{o}}_{\\pi ,p&#x27;}^{(k)} = H_0(\\mathbf{h}_{\\pi ,p&#x27;}^{(k)})</span>  then Accept 9: else Abort protocol 10: C computes the shared linking tag  <span class="math">\\mathbf{h}_{\\pi}^{(k)} = \\sum_{p&#x27;}^{N_{CS}}\\mathbf{h}_{\\pi ,p&#x27;}^{(k)}</span> 11: C calls Lift(H,  <span class="math">\\mathbf{h}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{H}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{H}, - 2\\cdot \\mathbf{h}_{\\pi}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 12: C calls Lift(A,  <span class="math">\\mathbf{a}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_{\\pi}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 13: C chooses  <span class="math">\\mathbf{u}_{\\pi ,p}^{(k)} = (u_{\\pi ,p,1},\\dots ,u_{\\pi ,p,m})^T</span>  , where  <span class="math">u_{\\pi ,p,i}\\gets D_{\\sigma}^{u}</span>  , for  <span class="math">1\\leq i\\leq m</span> 14: C computes  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)} = \\mathbf{A}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)} = \\mathbf{H}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span> 15: C chooses at random  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}\\gets S_{n,n}</span> 16: When A sends  <span class="math">\\mathbf{o}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C returns  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}</span>  to A. 17: When A sends  <span class="math">\\mathbf{r}_{\\pi ,p&#x27;}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C sends  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)}</span>  to A. Then, C computes as follows: 18: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 19: if  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)} = H_0(\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)},\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)})</span>  then Accept 20: else Abort protocol 21: C computes  <span class="math">\\mathbf{r}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span> 22: C chooses at random  <span class="math">\\mathbf{c}_{\\pi +1}\\gets S_{n,n}</span> 23: for  <span class="math">(i = \\pi +1,\\pi +2,\\dots ,w,1,2,\\dots ,\\pi -1)</span>  do 24: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 25: C selects  <span class="math">\\mathbf{t}_{i,p}^{(k)} = (t_{i,p,1},\\dots ,t_{i,p,m})^T</span>  , where  <span class="math">t_{i,p,j}\\gets D_{\\sigma}^{u}</span>  , for  <span class="math">1\\leq j\\leq m</span> 26: When A sends  <span class="math">\\mathbf{t}_{i,p&#x27;}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C returns  <span class="math">\\mathbf{t}_{i,p}^{(k)}</span>  to A. 27: C computes  <span class="math">\\mathbf{t}_i^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span> 28: C calls Lift(A,  <span class="math">\\mathbf{a}_i^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,i}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\times m}</span> 29: C runs  <span class="math">\\forall k\\in [N_{in}]</span> <span class="math">\\mathbf{c}_{i + 1} = H_1\\bigl (L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} ,\\left\\{\\mathbf{H}_{2q,\\pi}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} \\bigr)</span> 30: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 31: C chooses  <span class="math">b^{(k)}\\gets \\{0,1\\}</span> 32: C computes  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)} = \\mathbf{u}_{\\pi ,p}^{(k)} + \\mathbf{S}_{2q,\\pi ,p}^{(k)}\\cdot \\mathbf{c}_{\\pi}\\cdot (-1)^{b^{(k)}}</span>  , where  <span class="math">\\mathbf{S}_{2q,\\pi ,p}^{(k)} = [(\\mathbf{S}_{\\pi ,p}^{(k)})^T,1]^T</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">33: Continue with prob.  $\\left(M\\exp \\left(-\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{2\\sigma^2}\\right)\\cosh \\left(\\frac{(\\mathbf{t}_{\\pi,p}^{(k)},\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi})}{\\sigma^2}\\right)\\right)^{-1}$  otherwise Restart.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">34: When A sends  <span class="math">\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  , C returns  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)}</span>  to A 35: C computes  <span class="math">\\mathbf{t}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span> 36: return  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\sigma^{(k)}\\}_{k\\in [N_{in}]}\\right)</span></p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">Algorithm 11 KeyGen - Game 6 Input: PP:  <span class="math">\\mathbf{A}\\in \\mathcal{R}_q^{2\\times (m - 1)}</span> Output:  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{NCS}^T\\right\\}\\right)</span>  , being the shared public-key and cosigner's secret-key, respec-. tively. 1: procedure KeyGEN(A) 2: Each cosigner  <span class="math">p\\in \\{1,\\ldots ,N_{CS}\\}</span>  .. 3: Selects  <span class="math">\\bar{\\mathbf{S}}_p^T = (\\bar{\\mathbf{s}}_{p,1},\\dots ,\\bar{\\mathbf{s}}_{p,m - 1})\\in \\mathcal{R}_q^{1\\times (m - 1)}</span>  , where  <span class="math">\\bar{\\mathbf{s}}_{p,i}\\gets (-2^{\\gamma},2^{\\gamma})^{n}</span>  , for  <span class="math">1\\leq i\\leq m - 1</span> 4: Choose  <span class="math">\\bar{\\mathbf{a}}_p\\gets \\mathcal{R}_q^2</span> 5:  <span class="math">\\mathbf{o}_p = H_0(\\bar{\\mathbf{a}}_p)</span> 6: Broadcasts  <span class="math">\\mathbf{o}_p</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7: Receives  <span class="math">\\mathbf{o}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "p" sends  <span class="math">\\bar{\\mathbf{a}}_p</span>  to the cosigners 8: Receives  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span> 9: Each cosigner verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if Choose  <span class="math">\\mathbf{o}_{p&#x27;}\\gets \\mathcal{R}_q^2</span>  then Accept 12: else Abort protocol 13: Each cosigner computes the shared public-key as: 14:  <span class="math">\\mathbf{a}^{sh} = \\sum_{p&#x27;}^{N_{CS}}H_2(\\bar{\\mathbf{a}}_{p&#x27;},L^{sh})\\cdot \\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">L^{sh} = \\{\\bar{\\mathbf{a}}_1,\\dots ,\\bar{\\mathbf{a}}_{N_{CS}}\\}</span> 15: Each cosigner calculates its corresponding secret-key as: 16:  <span class="math">\\mathbf{S}_p^T = H_2(\\bar{\\mathbf{a}}_p,L^{sh})\\cdot \\bar{\\mathbf{S}}_p^T</span> 17: return  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{N_{CS}}^T\\right\\}\\right)</span>  , without loss of generality, each cosigner only outputs and holds its corresponding secret-key  <span class="math">\\mathbf{S}_{p&#x27;}^T</span></p>

    <p class="text-gray-300">Algorithm 12 KeyGen - Game 7 Input: PP:  <span class="math">\\mathbf{A}\\in \\mathcal{R}_q^{2\\times (m - 1)}</span> Output:  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{NCS}^T\\right\\}\\right)</span>  , being the shared public-key and cosigner's secret-key, respec-. tively. 1: procedure KeyGEN(A) 2: Each cosigner  <span class="math">p\\in \\{1,\\ldots ,N_{CS}\\}</span>  .. 3: Selects  <span class="math">\\bar{\\mathbf{S}}_p^T = (\\bar{\\mathbf{s}}_{p,1},\\dots ,\\bar{\\mathbf{s}}_{p,m - 1})\\in \\mathcal{R}_q^{1\\times (m - 1)}</span>  , where  <span class="math">\\bar{\\mathbf{s}}_{p,i}\\gets (-2^{\\gamma},2^{\\gamma})^{n}</span>  , for  <span class="math">1\\leq i\\leq m - 1</span> 4: Choose  <span class="math">\\bar{\\mathbf{a}}_p\\gets \\mathcal{R}_q^2</span> 5:  <span class="math">\\mathbf{o}_p = H_0(\\bar{\\mathbf{a}}_p)</span> 6: Broadcasts  <span class="math">\\mathbf{o}_p</span>  to other cosigners  <span class="math">p^\\prime \\in [N_{CS}]</span> 7: Receives  <span class="math">\\mathbf{o}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span>  , then "p" sends  <span class="math">\\bar{\\mathbf{a}}_p</span>  to the cosigners 8: Receives  <span class="math">\\bar{\\mathbf{a}}_{p&#x27;}</span>  with  <span class="math">p^\\prime \\neq p</span> 9: Each cosigner verifies: 10: for  <span class="math">(1\\leq p^{\\prime}\\leq N_{CS})</span>  do 11: if  <span class="math">\\mathbf{o}_{p^{\\prime}} = H_0(\\bar{\\mathbf{a}}_{p^{\\prime}})</span>  then Accept 12: else Abort protocol 13: Each cosigner computes the shared public-key as: 14: Choose  <span class="math">\\mathbf{a}^{sh}\\gets \\mathcal{R}_q^2</span> 15: Each cosigner calculates its corresponding secret-key as: 16:  <span class="math">\\mathbf{S}_p^T = H_2(\\bar{\\mathbf{a}}_p,L^{sh})\\cdot \\bar{\\mathbf{S}}_p^T</span> 17: return  <span class="math">\\left(\\mathbf{a}^{sh},\\left\\{\\mathbf{S}_1^T,\\dots ,\\mathbf{S}_{NCS}^T\\right\\}\\right)</span>  , without loss of generality, each cosigner only outputs and holds its corresponding secret-key  <span class="math">\\mathbf{S}_{p&#x27;}^T</span></p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Let <span class="math">S_7</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 7 with negligible probability, that is <span class="math">1 \\leq \\epsilon_7</span>. Then we claim that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {6} \\right] - \\Pr \\left[ S _ {7} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {7}. \\tag {10}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Game 8</strong>: This Game now changes are made on the <span class="math">\\mathbf{t}_1^{(k)},\\ldots ,\\mathbf{t}_w^{(k)}</span> from the SigGen algorithm. When <span class="math">\\mathcal{A}</span> sends interactive queries <span class="math">Q_{s}</span> with <span class="math">(L^t,\\mu^t)</span> to <span class="math">\\mathcal{C}</span> for signing using the SigGen algorithm, then <span class="math">\\mathcal{C}</span> behaves as in Algorithm 13. This time, the <span class="math">\\mathcal{C}</span> chooses <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)}</span> at random from <span class="math">D_{\\sigma}^{n\\times m}</span> as in Algorithm 13 (step 33) instead of computing it as <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)} = \\mathbf{u}_{\\pi ,p}^{(k)} + \\mathbf{S}_{2q,\\pi ,p}^{(k)}\\cdot \\mathbf{c}_{\\pi}\\cdot (-1)^{k^{(k)}}</span> (Based on [19], Lemma 3.5). We claim that this Game is forgeable when <span class="math">\\mathcal{A}</span> finds a PPT algorithm <span class="math">\\mathcal{F}</span> to solve the <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{K}</span> problem. This attack performs as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Random coins are selected for the forger <span class="math">\\phi</span> and signer <span class="math">\\psi</span>.</li>

      <li>The random oracle <span class="math">H_{1}</span> is called to generate the responses of the users in the SigGen scheme, <span class="math">(\\mathbf{c}_1,\\dots ,\\mathbf{c}_w)\\gets S_{n,\\kappa}</span>.</li>

      <li>These create a SubRoutine that takes as input <span class="math">(\\mathbf{A}_{2q,\\pi}^{(k)},\\phi ,\\psi ,\\mathbf{c}_1,\\ldots ,\\mathbf{c}_w)</span>.</li>

      <li><span class="math">\\mathcal{F}</span> is initialized and run by providing the <span class="math">\\mathbf{A}_{2q,\\pi}^{(k)}</span> and forger's random coins <span class="math">\\phi</span>.</li>

      <li>The SubRoutine signs the message <span class="math">\\mu</span> using the signer's coins <span class="math">\\psi</span> in the Algorithm 13, this produces a signature <span class="math">\\sigma_L(\\mu)</span>.</li>

      <li>During the signing process, <span class="math">\\mathcal{F}</span> calls the oracle <span class="math">H_{1}</span> and answers are placed in the list <span class="math">(\\mathbf{c}_1,\\dots ,\\mathbf{c}_w)</span>, the queries are kept in a table in the event that same queries are used in this oracle.</li>

      <li><span class="math">\\mathcal{F}</span> is stops this simulation and outputs a forgery <span class="math">\\sigma (\\mu)^{<em>} = \\left(\\mathbf{c}_1^</em>,\\{\\mathbf{t}_1^{<em>(k)},\\ldots ,\\mathbf{t}_w^{</em>(k)}\\} ,\\mathbf{h}_{\\pi}^{*(k)}\\right)</span>, with negligible probability. This output has to be successfully accepted by the SigVer algorithm.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the random oracle was not called using some input <span class="math">\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_i^{<em>(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_i^</em></span>, <span class="math">\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_i^{<em>(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i^</em></span> (<span class="math">\\forall i,k\\in [w]\\times [N_{in}]</span>), then <span class="math">\\mathcal{F}</span> has $1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> chances of producing a </span>\\mathbf{c}_{i + 1}^<em><span class="math"> such that </span>\\mathbf{c}_{i + 1}^{</em>} = H_{1}\\Big(L^{<em>},\\mathbf{H}_{2q}^{(k)},\\mu^{</em>},\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_{i}^{<em>(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_{i}^{</em>},\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_{i}^{<em>(k)} + \\mathbf{q}\\cdot \\mathbf{c}_{i}^{</em>}\\Big)<span class="math">. We claim that </span>\\epsilon_7 - 1 /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the probability that </span>\\mathbf{c}_{i + 1}^{*} = \\mathbf{c}_{j + 1}<span class="math"> for some </span>j$. In this analysis, we now consider two types of forgeries:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Forgery 1.</strong> We consider that <span class="math">\\mathbf{c}_{j+1}</span> is the result after using <span class="math">\\mathcal{F}</span> which is <span class="math">\\mathbf{c}_{j+1} = H_1\\left(L&#x27;, \\mathbf{H}_{2q}^{(k)}, \\mu&#x27;, \\mathbf{A}_{2q,j}^{(k)} \\cdot \\mathbf{t}_j^{(k)} \\cdot \\mathbf{q} \\cdot \\mathbf{c}_j, \\mathbf{H}_{2q}^{(k)} \\cdot \\mathbf{t}_j^{(k)} + \\mathbf{q} \\cdot \\mathbf{c}_j\\right)</span>. Then we have <span class="math">\\forall k \\in [N_{in}]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} H _ {1} \\left(L ^ {*}, \\mathbf {H} _ {2 q} ^ {(k)}, \\mu^ {*}, \\mathbf {A} _ {2 q, j} ^ {(k)} \\cdot \\mathbf {t} _ {j} ^ {* (k)} \\cdot \\mathbf {q} \\cdot \\mathbf {c} _ {j}, \\mathbf {H} _ {2 q} ^ {(k)} \\cdot \\mathbf {t} _ {j} ^ {* (k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {j}\\right) = \\\\ H _ {1} \\left(L ^ {\\prime}, \\mathbf {H} _ {2 q} ^ {(k)}, \\mu^ {\\prime}, \\mathbf {A} _ {2 q, j} ^ {(k)} \\cdot \\mathbf {t} _ {j} ^ {\\prime (k)} \\cdot \\mathbf {q} \\cdot \\mathbf {c} _ {j}, \\mathbf {H} _ {2 q} ^ {(k)} \\cdot \\mathbf {t} _ {j} ^ {\\prime (k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {j}\\right), \\\\ \\end{array}</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{F}</span> finds a preimage of <span class="math">\\mathbf{c}_{j + 1}</span> if <span class="math">\\mu^{<em>}\\neq \\mu^{\\prime}</span> or <span class="math">\\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{</em>(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j\\neq \\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j</span> or <span class="math">\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{<em>(k)} + \\mathbf{q}\\cdot \\mathbf{c}_j\\neq \\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)} + \\mathbf{q}\\cdot \\mathbf{c}_j</span>. Then, we have with overwhelming probability that <span class="math">\\mu^{</em>} = \\mu^{\\prime}</span> or <span class="math">\\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{*(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j = \\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j</span></p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">|  Algorithm 13 SigGen - Game 8  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: S K = {S(sk)π, p' ∈ [NCS], k ∈ [Nin], μ, L = {a(k)}i ∈ [w], k ∈ [Nin] as in (1), and PP.  |   |</p>

    <p class="text-gray-300">|  Output: σ(μ) = (c1, {t1(k), ..., tn(k)}k ∈ [Nin], {h0(k)}k ∈ [Nin])  |   |</p>

    <p class="text-gray-300">|  1: procedure SigGEN(SK, μ, L, PP)  |   |</p>

    <p class="text-gray-300">|  2: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  3: The linking tag is chosen at random h0(k) ← R2q.  |   |</p>

    <p class="text-gray-300">|  4: C sets o(k) = H0(h0(k))  |   |</p>

    <p class="text-gray-300">|  5: When A sends o(k), with p' ∈ [2, NCS], C returns o(k) to A.  |   |</p>

    <p class="text-gray-300">|  6: When A sends h(k), with p' ∈ [2, NCS], C sends h(k) to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  7: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  8: if o(k) = H0(h(k), p') then Accept  |   |</p>

    <p class="text-gray-300">|  9: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  10: C computes the shared linking tag h(k) = ∑p' NCS h(k), p'  |   |</p>

    <p class="text-gray-300">|  11: C calls Lift(H, h(k)) to obtain H(k) = (2 · H, -2 · h(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  12: C calls Lift(A, a(k)) to obtain A(k) = (2 · A, -2 · a(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  13: C chooses u(k) = (uπ,p,1, ..., uπ,p,m)T, where uπ,p,i ← Dπ, for 1 ≤ i ≤ m.  |   |</p>

    <p class="text-gray-300">|  14: C computes r(k) = A(k) = A(k) and z(k) = H(k) + q.  |   |</p>

    <p class="text-gray-300">|  15: C chooses at random o(k) ← Sn,n.  |   |</p>

    <p class="text-gray-300">|  16: When A sends o(k), with p' ∈ [2, NCS], C returns o(k) to A.  |   |</p>

    <p class="text-gray-300">|  17: When A sends r(k), and z(k), with p' ∈ [2, NCS], C sends r(k) and z(k) to A. Then, C computes as follows:  |   |</p>

    <p class="text-gray-300">|  18: for (2 ≤ p' ≤ NCS) do  |   |</p>

    <p class="text-gray-300">|  19: if o(k), p' = H0(r(k), p'), z(k), p' then Accept  |   |</p>

    <p class="text-gray-300">|  20: else Abort protocol  |   |</p>

    <p class="text-gray-300">|  21: C computes r(k) = ∑p' = 1 NCS r(k), p', and z(k) = ∑p' = 1 NCS z(k), p'  |   |</p>

    <p class="text-gray-300">|  22: C chooses at random e+1 ← Sn,n.  |   |</p>

    <p class="text-gray-300">|  23: for (i = π + 1, π + 2, ..., w, 1, 2, ..., π - 1) do  |   |</p>

    <p class="text-gray-300">|  24: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  25: C selects t(k), p = (ti,p,1, ..., ti,p,m)T, where ti,p,j ← Dπ, for 1 ≤ j ≤ m.  |   |</p>

    <p class="text-gray-300">|  26: When A sends t(k), p' with p' ∈ [2, NCS], C returns t(k), p to A.  |   |</p>

    <p class="text-gray-300">|  27: C computes t(k) = ∑p' = 1 NCS t(k), p'  |   |</p>

    <p class="text-gray-300">|  28: C calls Lift(A, a(k)) to obtain A(k) = (2 · A, -2 · a(k) + q) ∈ R2q.  |   |</p>

    <p class="text-gray-300">|  29: C runs ∀k ∈ [Nin] c1+1 = H1(L, H(k), p, {A(k), t(k) + q · c1}, {H2q,π · t(k) + q · c1}).  |   |</p>

    <p class="text-gray-300">|  30: for (1 ≤ k ≤ Nin) do  |   |</p>

    <p class="text-gray-300">|  31: C chooses b(k) ← {0, 1}.  |   |</p>

    <p class="text-gray-300">|  32: C chooses t(k), p ← Dπn×m  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">34: Continue with prob. (M exp(-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S(k), p' - cπ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2/2σ2) cosh((t(k), p', S(k), p' - cπ)/σ2))^-1 otherwise Restart.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  35: When A sends t(k), p' with p' ∈ [2, NCS], C returns t(k), p to A  |   |</p>

    <p class="text-gray-300">|  36: C computes t(k) = ∑p' = 1 NCS t(k), p'  |   |</p>

    <p class="text-gray-300">|  37: return σ(μ) = (c1, {t1(k), ..., tn(k)}k ∈ [Nin], {h0(k)}k ∈ [Nin]).  |   |</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or  <span class="math">\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{<em>(k)} + \\mathbf{q}\\cdot \\mathbf{c}_j = \\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)} + \\mathbf{q}\\cdot \\mathbf{c}_j</span>  . These equalities will result in:  <span class="math">\\mathbf{A}_{2q,j}^{(k)}(\\mathbf{t}_j^{</em>(k)} - \\mathbf{t}_j^{\\prime (k)}) = 0\\bmod q</span>  and  <span class="math">\\mathbf{H}_{2q}^{(k)}(\\mathbf{t}_j^{<em>(k)} - \\mathbf{t}_j^{\\prime (k)}) = 0\\bmod q</span>  . We assume that both  <span class="math">\\mathbf{t}_j^{</em>(k)}</span>  and  <span class="math">\\mathbf{t}_j^{\\prime (k)}</span>  are different and they met the SigVer Algorithm conditions, so it results in  <span class="math">\\mathbf{t}_j^{*(k)} - \\mathbf{t}_j^{\\prime (k)}\\neq 0\\bmod q</span>  , and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_j^{*(k)} - \\mathbf{t}_j^{\\prime (k)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_v$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Forgery 2. We assume that  <span class="math">\\mathbf{c}_{j+1}</span>  was a response to a random oracle  <span class="math">H_1</span>  query made by  <span class="math">\\mathcal{A}</span>  and it records the  <span class="math">\\mathbf{c}_{j+1}</span>  and the signature  <span class="math">\\sigma(\\mu)</span>  on message  <span class="math">\\mu</span> . Then, fresh random elements are generated as  <span class="math">(\\mathbf{c}_j&#x27;, \\ldots, \\mathbf{c}_w&#x27;) \\gets S_{n,\\kappa}</span> . We use the forking lemma [5] to show the probability of  <span class="math">\\mathbf{c}_{j+1} \\neq \\mathbf{c}_{j+1}&#x27;</span>  and the forger uses an oracle response  <span class="math">\\mathbf{c}_{j+1}&#x27;</span>  is at least:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\operatorname * {P r} [ S _ {7} ] - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(\\frac {\\operatorname * {P r} [ S _ {7} ] - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{Q _ {s} + Q _ {1}} - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">which is negligible. Therefore, with this probability,  <span class="math">\\mathcal{A}</span>  creates a signature  <span class="math">\\sigma (\\mu)&#x27; = \\left(\\mathbf{c}_1&#x27;,\\{\\mathbf{t}_1&#x27;^{(k)},\\dots ,\\mathbf{t}_w&#x27;^{(k)}\\} ,\\mathbf{h}_w&#x27;^{(k)}\\right)</span>  where  <span class="math">\\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{<em>(k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j = \\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)}\\cdot \\mathbf{q}\\cdot \\mathbf{c}_j^{\\prime}</span>  and  <span class="math">\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{</em>(k)} + \\mathbf{q}\\cdot \\mathbf{c}_j = \\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{t}_j^{\\prime (k)} + \\mathbf{q}\\cdot \\mathbf{c}_j^{\\prime}</span> . We now obtain  <span class="math">\\mathbf{A}_{2q,j}^{(k)}\\cdot (\\mathbf{t}_j^{<em>(k)} - \\mathbf{t}_j^{\\prime (k)}) =</span> <span class="math">\\mathbf{q}(\\mathbf{c}_j - \\mathbf{c}_j^{\\prime})\\bmod 2q</span>  and  <span class="math">\\mathbf{H}_{2q}^{(k)}(\\mathbf{t}_j^{</em>(k)} - \\mathbf{t}_j^{\\prime (k)}) = \\mathbf{q}(\\mathbf{c}_j - \\mathbf{c}_j^{\\prime})\\bmod 2q</span> . Since  <span class="math">\\mathbf{c}_j - \\mathbf{c}_j^{\\prime}\\neq 0\\bmod 2</span> , so in both equations, we have  <span class="math">\\mathbf{t}_j^{*(k)} - \\mathbf{t}_j^{\\prime (k)}\\neq 0\\bmod 2q</span>  where  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_j^{*(k)} - \\mathbf{t}_j^{\\prime (k)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; q / 2<span class="math"> . By applying mod  </span>q<span class="math">  reduction, we find a small non-zero vector  </span>\\mathbf{v}^{(k)} = \\mathbf{t}_j^{*(k)} - \\mathbf{t}_j^{\\prime (k)}\\neq 0\\bmod q<span class="math"> . This  </span>\\mathbf{v}^{(k)}<span class="math">  will compute  </span>\\mathbf{A}_{2q,j}^{(k)}\\cdot \\mathbf{v}^{(k)} = \\mathbf{0}\\bmod q<span class="math">  and  </span>\\mathbf{H}_{2q}^{(k)}\\cdot \\mathbf{v}^{(k)} = \\mathbf{0}\\bmod q<span class="math">  with  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}^{(k)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_v<span class="math"> . Since  </span>\\mathbf{v}^{(k)}<span class="math">  is same for both  </span>\\mathbf{A}_{2q,j}^{(k)}<span class="math">  and  </span>\\mathbf{H}_{2q}^{(k)}<span class="math"> , we only use the former to continue this analysis. We say that  </span>\\mathbf{A}_{2q,j}^{(k)}\\bmod q = 2(\\mathbf{A}, - \\mathbf{a}^{(k)})\\bmod q<span class="math"> , then  </span>2(\\mathbf{A}, - \\mathbf{a}^{(k)})\\mathbf{v}^{(k)} = \\mathbf{0}\\bmod q<span class="math"> , this implies that  </span>(\\mathbf{A}, - \\mathbf{a}^{(k)})\\mathbf{v}^{(k)} = \\mathbf{0}\\bmod q<span class="math"> , since  </span>q<span class="math">  is odd. Therefore, this vector  </span>\\mathbf{v}<span class="math">  will be a solution to the  </span>\\mathbf{MSIS}_{q,m,k,\\beta}^{K}<span class="math">  problem, where  </span>\\beta = 2\\beta_v<span class="math"> , with non-negligible probability and with respect to  </span>(\\mathbf{A}, - \\mathbf{a}^{(k)})<span class="math">  over  </span>\\mathcal{R}_q^2$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  <span class="math">S_{8}</span>  be the event where the  <span class="math">\\mathcal{A}</span>  wins Game 8 with negligible probability  $\\left(\\operatorname*{Pr}[S_7] - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(\\frac{\\operatorname*{Pr}[S_7] - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{Q_s + Q_1} - \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)<span class="math">  to solve the  </span>\\mathbf{MSIS}_{q,m,k,\\beta}^{K}$  problem. Combining the results of the above Games (3), (4), (5), (6), (7), (8), (9), and (10) we obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\operatorname * {P r} [ S _ {7} ] - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\cdot \\left(\\frac {\\operatorname * {P r} [ S _ {7} ] - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{Q _ {s} + Q _ {1}} - \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {S} _ {n , \\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\operatorname * {P r} [ \\mathrm {S o l v e M S I S} ],</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since  <span class="math">\\operatorname<em>{Pr}[S_7]\\geq \\operatorname</em>{Pr}[S_0] - \\epsilon_{uf}</span>  with  <span class="math">\\epsilon_{uf} = \\sum_{i = 1}^{7}\\epsilon_{i}</span> , and we let  <span class="math">\\delta = \\operatorname*{Pr}[S_0]</span>  then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(\\delta-\\epsilon_{uf}-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\cdot\\left(\\frac{\\delta-\\epsilon_{uf}-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{Q_{s}+Q_{1}}-\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}_{n,\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\Pr[\\text{Solve MSIS}]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-45" class="text-2xl font-bold">Appendix C MIMO.L2RS-CS - Anonymity</h2>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the anonymity property of the MIMO.L2RS-CS scheme by using the sequence-of-games approach <em>[41]</em>:</p>

    <p class="text-gray-300">Game 0 - Real Game: This Game follows the definition of unconditional anonymity in Section 4. We assume that an adversary <span class="math">\\mathcal{A}</span>, by using the <span class="math">\\mathcal{KO}</span>, creates a list of <span class="math">\\mathbf{pk}^{(k)}</span>’s <span class="math">L=\\left(\\mathbf{pk}^{(k)}_{i_{0}},\\mathbf{pk}^{(k)}_{i_{1}}\\right)</span> <span class="math">\\forall k\\in[N_{in}]</span> and <span class="math">\\forall i_{0},i_{1}\\in[w]</span>. <span class="math">\\mathcal{A}</span> gives the <span class="math">L</span> and a message <span class="math">\\mu</span> to the challenger. The challenger then flips a coin <span class="math">b\\leftarrow\\{0,1\\}</span>, then creates a signature <span class="math">\\sigma(\\mu)_{b}=\\textup{{SigGen}}(\\mathbf{S}^{(k)}_{i_{b}},\\mu,L,\\textup{{PP}})</span> and gives <span class="math">\\sigma(\\mu)_{b}</span> to <span class="math">\\mathcal{A}</span>. The adversary <span class="math">\\mathcal{A}</span> outputs a guess <span class="math">b^{\\prime}</span>. <span class="math">\\mathcal{A}</span> wins this game if the following conditions are achieved:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{pk}^{(k)}_{i_{0}}</span> and <span class="math">\\mathbf{pk}^{(k)}_{i_{1}}</span> must not be used by <span class="math">\\mathcal{CO}</span> and <span class="math">\\mathcal{SO}</span>.</li>

      <li>Outputs 1 such that <span class="math">b=b^{\\prime}</span>, with <span class="math">\\Pr=1/2</span>.</li>

    </ol>

    <p class="text-gray-300">If we define the event <span class="math">S_{0}</span> where the adversary <span class="math">\\mathcal{A}</span> wins Game 0, then we claim that <span class="math">\\mathcal{A}_{2}</span>’s advantage is <span class="math">\\frac{1}{2}+\\epsilon_{0}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\tfrac{1}{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{0}.$ (11)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game 1: In this game, we analyse the KeyGen Algorithm 1 in order to show that <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}^{(k)}</span> is independent to <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}^{(k)}</span>. In the step 11 of this protocol, the challenger verifies that <span class="math">\\mathbf{o}_{\\pi,p^{\\prime}}=H_{0}(\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}})</span>. Then, there are two cases to be considered:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}</span> was queried by <span class="math">\\mathcal{A}</span> to the random oracle <span class="math">H_{0}</span> before <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}</span> was sent. We define the event <span class="math">E_{1}</span> where the adversary <span class="math">\\mathcal{A}</span> queries the <span class="math">H_{0}</span> up to revealing <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}</span>. <span class="math">E_{2}</span> to be the event when <span class="math">\\mathcal{A}</span> guesses <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}</span>, with no information of <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}</span>. Then, we state that with the following probability <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}</span> is independent of <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}</span>:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[E_{1}]=\\Pr[E_{2}]\\leq\\frac{1}{2^{n}}</span></p>

    <p class="text-gray-300">, where <span class="math">2^{n}</span> is the min-entropy of <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}}</span> was not queried, which means that the chance to satisfy the following condition is negligible:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\mathbf{o}_{\\pi,p^{\\prime}}=H_{0}(\\bar{\\mathbf{a}}_{\\pi,p^{\\prime}})]\\leq\\frac{1}{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">H_{0}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">S_{1}</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 1 with negligible probability <span class="math">\\mathcal{R}_{q}^{2}</span> is at most <span class="math">\\frac{1}{2^{n}}\\leq\\epsilon_{1}</span>. Then we claim that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{0}]-\\Pr[S_{1}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{1}.$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Game 2: This Game now modifies the KeyGen Algorithm 1 (step 4), and SigGen Algorithm 2 (step 3), where the linking tag is computed. We know that the public-key is computed as <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}^{(k)} = \\mathbf{A} \\cdot \\bar{\\mathbf{S}}_{\\pi,p}^{(k)} \\bmod q \\in \\mathcal{R}_q^2</span>. Then, we choose <span class="math">\\bar{\\mathbf{a}}_{\\pi,p&#x27;}^{(k)} \\forall (k,p&#x27;) \\in [N_{CS}] \\times [N_{in}]</span> uniformly and randomly such <span class="math">\\bar{\\mathbf{a}}_{\\pi,p&#x27;}^{(k)} \\gets \\mathcal{R}_q^2</span>. Moreover, we select <span class="math">\\mathbf{h}_{\\pi,p&#x27;}^{(k)} \\forall (k,p&#x27;) \\in [N_{CS}] \\times [N_{in}]</span> uniformly and randomly such <span class="math">\\mathbf{h}_{\\pi,p&#x27;}^{(k)} \\gets \\mathcal{R}_q^2</span>, rather than computing the linking tag as <span class="math">\\mathbf{h}_{\\pi,p}^{(k)} = \\mathbf{H} \\cdot \\mathbf{S}_{\\pi,p}^{(k)} \\in \\mathcal{R}_q^2</span>. We recall that <span class="math">\\mathbf{S}_{\\pi,p}^{(k)} = H_2(\\bar{\\mathbf{a}}_p, L^{sh}) \\cdot \\bar{\\mathbf{S}}_p^T</span> (as KeyGen Algorithm 1) where <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span> is chosen small and with coefficients in <span class="math">(-2^\\gamma, 2^\\gamma)</span>. We redefine <span class="math">\\mathbf{h}_{\\pi,p}^{(k)} = \\mathbf{H} \\cdot H_2(\\bar{\\mathbf{a}}_{\\pi,p}^{(k)}, L^{sh}) \\cdot \\bar{\\mathbf{S}}_p^T</span>, where a new random matrix <span class="math">\\mathbf{H}_{new} = \\mathbf{H} \\cdot H_2(\\bar{\\mathbf{a}}_{\\pi,p}^{(k)}, L^{sh})</span>.</p>

    <p class="text-gray-300">Since the public parameter <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{H}_{new}</span> are uniform and <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span> is chosen small and with coefficients in <span class="math">(-2^{\\gamma}, 2^{\\gamma})</span>, then multiplying these <span class="math">\\mathbf{A}</span> and <span class="math">\\mathbf{H}_{new}</span> by the secret key <span class="math">\\bar{\\mathbf{S}}_{\\pi,p}^{(k)}</span>, it results in <span class="math">\\bar{\\mathbf{a}}_{\\pi,p}^{(k)}</span> and <span class="math">\\mathbf{h}_{\\pi,p}^{(k)}</span> that are close to uniform over <span class="math">\\mathcal{R}_q^2</span>. By the Leftover Hash Lemma (LHL) argument (Lemma 4), we show that the statistical distance between the distribution of <span class="math">\\mathbf{a}^{(k)} \\bmod q</span> and the uniform distribution on <span class="math">\\mathcal{R}_q^2</span> is at most <span class="math">N_{in} \\cdot N_{CS} \\cdot \\frac{1}{2} \\cdot \\sqrt{\\frac{q^{4n}}{2^{(\\gamma + 1) \\cdot (m - 1) \\cdot n}}}</span>, which is negligible in <span class="math">n</span>.</p>

    <p class="text-gray-300">Let <span class="math">S_{2}</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 2 with negligible probability <span class="math">\\mathcal{R}_q^2</span> is at most <span class="math">N_{in} \\cdot N_{CS} \\cdot \\frac{1}{2} \\cdot \\sqrt{\\frac{q^{4n}}{2^{(\\gamma + 1) \\cdot (m - 1) \\cdot n}}} \\leq \\epsilon_{2}</span>. Then we claim that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {1} \\right] - \\Pr \\left[ S _ {2} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {2}. \\tag {13}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Game 3: Rather that computing <span class="math">\\bar{\\mathbf{o}}_{\\pi,p}^{(k)} = H_0\\big(\\mathbf{h}_{\\pi,p}^{(k)}\\big)</span>, <span class="math">\\bar{\\mathbf{o}}_{\\pi,p}^{(k)}</span> is now chosen at random as seen in Algorithm 14, in step 5. On a <span class="math">y</span>-th query <span class="math">\\mathbf{h}_y^{(k)}</span> from the adversary <span class="math">\\mathcal{A}</span>, then <span class="math">\\mathcal{C}</span> proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span> returns <span class="math">H_0\\big(\\mathbf{h}_y^{(k)}\\big)</span> if this is already defined.</li>

      <li><span class="math">\\mathcal{C}</span> chooses at random <span class="math">\\bar{\\mathbf{o}}_y^{(k)}\\gets \\mathcal{S}_{n,\\kappa}</span>, otherwise.</li>

      <li><span class="math">\\mathcal{C}</span> verifies if there exists <span class="math">p&#x27; \\in [1, y - 1]</span> such that <span class="math">\\bar{\\mathbf{o}}_y^{(k)} = H_0\\big(\\mathbf{h}_{\\pi, p&#x27;}^{(k)}\\big)</span> for previous queries of <span class="math">\\mathbf{h}_{\\pi, p&#x27;}^{(k)}</span>. In the case where <span class="math">p&#x27;</span> exists, the game is aborted, otherwise:</li>

      <li><span class="math">\\mathcal{C}</span> sets <span class="math">\\bar{\\mathbf{o}}_y^{(k)} = H_0\\big(\\mathbf{h}_{\\pi ,p&#x27;}^{(k)}\\big)</span> and returns <span class="math">\\bar{\\mathbf{o}}_y^{(k)}</span> to <span class="math">\\mathcal{A}</span>.</li>

    </ol>

    <p class="text-gray-300">The difference between the Game 2 and Game 3 is that the challenger <span class="math">\\mathcal{C}</span> aborts when he tries to set a same hash value <span class="math">H_0</span> for two different inputs. This game evaluates the probability that <span class="math">\\mathcal{C}</span> aborts the game under this situation. The total number of queries <span class="math">Q_0</span> to <span class="math">H_0</span> oracle is at most <span class="math">Q_0 + Q_s</span>. Then the probability that <span class="math">\\mathcal{C}</span> aborts Game 3 is</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_{y=1}^{Q_{0}+Q_{s}} \\Pr \\left[ \\left(\\mathbf{h}_{\\pi, p&#x27;}^{(k)}\\right) \\in \\left\\{\\mathbf{h}_{y&#x27;}^{(k)} \\right\\}_{y&#x27; &amp;lt; y} \\right] \\leq \\sum_{y=1}^{Q_{0}+Q_{s}} \\sum_{y&#x27;=1}^{y-1} \\Pr_{\\bar{\\mathbf{o}}_{y}^{(k)} \\leftarrow \\mathcal{S}_{n, \\kappa}} \\left[ \\mathbf{h}_{\\pi, p&#x27;}^{(k)} = \\mathbf{h}_{y&#x27;}^{(k)} \\right] \\leq \\\\ \\sum_{y=1}^{Q_{0}+Q_{s}} \\frac{y-1}{2^{n}} \\leq \\frac{(Q_{0}+Q_{s})(Q_{0}+Q_{s}+1)}{2^{n}} \\end{array}</span></div>

    <p class="text-gray-300">Let <span class="math">S_{3}</span> be the event where the <span class="math">\\mathcal{A}</span> wins this Game with negligible probability <span class="math">\\frac{(Q_0 + Q_s)(Q_0 + Q_s + 1)}{2^n} \\leq \\epsilon_3</span>. Then we argue that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {2} \\right] - \\Pr \\left[ S _ {3} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {3}. \\tag{14}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Game 4</strong>: This Game performs similar to <strong>Game 3</strong> but we now modify (for the signer <span class="math">\\pi</span>) the <strong>KeyGen</strong>, Algorithm 1 (step 14). The aggregate public-key as <span class="math">\\bar{\\mathbf{a}}_{\\pi}^{(k)} = \\sum_{p&#x27;}^{N_{CS}} H_2(\\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}, L^{sh}) \\cdot \\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}</span>. We now choose <span class="math">\\bar{\\mathbf{a}}_{\\pi}^{(k)} \\forall (k) \\in [N_{in}]</span> uniformly and randomly such that <span class="math">\\bar{\\mathbf{a}}_{\\pi}^{(k)} \\gets \\mathcal{R}_q^2</span>. As in <strong>Game 1</strong>, it shows that <span class="math">\\bar{\\mathbf{a}}_{\\pi, p&#x27;}^{(k)}</span> is uniformly random. We assume that <span class="math">\\forall h \\gets \\mathcal{S}_{n, \\kappa}</span> where <span class="math">h</span> is the output of the hash function <span class="math">H_2</span>. We said that <span class="math">h</span> needs to be invertible in <span class="math">\\mathcal{R}_q^2</span>, then to achieve this condition, we choose <span class="math">\\mathcal{S}_{n, \\kappa}</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; \\frac{1}{\\sqrt{k}} \\cdot q^{1/k}$ as shown in ([34], Corollary 1.2), with probability 1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">S_4</span> be the event where the <span class="math">\\mathcal{A}</span> wins <strong>Game 4</strong> with negligible probability, that is <span class="math">1 \\leq \\epsilon_4</span>. Then we claim that:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {3} \\right] - \\Pr \\left[ S _ {4} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {4}. \\tag{15}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Game 5</strong>: Changes on this game are made in the remaining public-keys <span class="math">\\bar{\\mathbf{a}}_i^{(k)}</span> (<span class="math">1 \\leq i \\leq w</span>, <span class="math">i \\neq \\pi</span>), <span class="math">\\forall k \\in [N_{in}]</span> which are in the list of the ring <span class="math">L</span>. We know that <span class="math">\\bar{\\mathbf{a}}_i^{(k)} = \\sum_{p&#x27;}^{N_{CS}} H(\\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)}, L^{sh}) \\cdot \\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)}</span> and secret-key <span class="math">\\bar{\\mathbf{S}}_i^{(k)} = \\sum_{p&#x27;}^{N_{CS}} H(\\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)}, L^{sh}) \\cdot \\bar{\\mathbf{S}}_{i,p&#x27;}^{(k)}</span>, where <span class="math">\\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)} = \\mathbf{A} \\cdot \\bar{\\mathbf{S}}_{i,p&#x27;}^{(k)} \\forall (k, p&#x27;) \\in [N_{CS}] \\times [N_{in}]</span>. We now choose uniformly random <span class="math">\\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)}</span>, and all <span class="math">\\bar{\\mathbf{S}}_{i,p&#x27;}^{(k)}</span>'s are chosen small with coefficients in <span class="math">(-2^{\\gamma}, 2^{\\gamma})</span>. When the <span class="math">\\bar{\\mathbf{S}}_{i,p&#x27;}^{(k)}</span>'s are multiplied by the public parameter <span class="math">\\mathbf{A}</span>, it gives <span class="math">(\\bar{\\mathbf{a}}_{i,p&#x27;}^{(k)})</span>'s that are close to uniform over <span class="math">\\mathcal{R}_q^2</span>.</p>

    <p class="text-gray-300">By the Leftover Hash Lemma (LHL) argument (Lemma 4), we show that the statistical distance between the distribution of the <span class="math">(\\mathbf{A} \\cdot \\mathbf{S}_i^{(k)} \\bmod q)</span>'s and the uniform distribution on <span class="math">\\mathcal{R}_q^2 \\times \\mathcal{R}_q^2</span> is at most <span class="math">N_{in} \\cdot N_{CS} \\cdot \\frac{1}{2} \\cdot \\sqrt{\\frac{q^{4n}}{2^{(\\gamma + 1) \\cdot (m - 1) \\cdot n}}} \\cdot (w - 1)</span>.</p>

    <p class="text-gray-300">We define the event <span class="math">S_{5}</span> where <span class="math">\\mathcal{A}</span> wins <strong>Game 5</strong> with negligible probability <span class="math">N_{in} \\cdot N_{CS} \\cdot \\frac{1}{2} \\cdot \\sqrt{\\frac{q^{4n}}{2^{(\\gamma + 1) \\cdot (m - 1) \\cdot n}}} \\cdot (w - 1) \\leq \\epsilon_{5}</span>.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ S _ {4} \\right] - \\Pr \\left[ S _ {5} \\right] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\epsilon_ {5}. \\tag{16}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">Algorithm 14 SigGen - Game 3 Input:  <span class="math">\\mathcal{SK} = \\left\\{\\mathbf{S}_{\\pi ,p^{\\prime}}^{(k)}\\right\\}_{p^{\\prime}\\in [N_{CS}],k\\in [N_{in}]}</span> <span class="math">\\mu ,L = \\left\\{\\mathbf{a}_i^{(k)}\\right\\}_{i\\in [w],k\\in [N_{in}]}</span>  as in (1), and PP. Output:  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span> 1: procedure SIGGEN(SK,  <span class="math">\\mu ,L</span>  ,PP) 2: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 3: The challenger  <span class="math">\\mathcal{C}</span>  computes the linking tag  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)} = \\mathbf{H}\\cdot \\mathbf{S}_{\\pi ,p}^{(k)}\\in \\mathcal{R}_q^2</span> 4:  <span class="math">\\mathcal{C}</span>  sets  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p}^{(k)} = H_0\\big(\\mathbf{h}_{\\pi ,p}^{(k)}\\big)</span> 5:  <span class="math">\\mathcal{C}</span>  chooses at random  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p}^{(k)}\\gets S_{n,n}</span> 6: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 7: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  sends  <span class="math">\\mathbf{h}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span>  . Then,  <span class="math">\\mathcal{C}</span>  computes as follows: 8: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 9: if  <span class="math">\\bar{\\mathbf{o}}_{\\pi ,p^{\\prime}}^{(k)} = H_0\\big(\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}\\big)</span>  then Accept 10: else Abort protocol 11:  <span class="math">\\mathcal{C}</span>  computes the shared linking tag  <span class="math">\\mathbf{h}_{\\pi}^{(k)} = \\sum_{p^{\\prime}}^{N_{CS}}\\mathbf{h}_{\\pi ,p^{\\prime}}^{(k)}</span> 12:  <span class="math">\\mathcal{C}</span>  calls Lift(H,  <span class="math">\\mathbf{h}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{H}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{H}, - 2\\cdot \\mathbf{h}_{\\pi}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\pi m}</span> 13:  <span class="math">\\mathcal{C}</span>  calls Lift(A,  <span class="math">\\mathbf{a}_{\\pi}^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,\\pi}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_{\\pi}^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\pi m}</span> 14:  <span class="math">\\mathcal{C}</span>  chooses  <span class="math">\\mathbf{u}_{\\pi ,p}^{(k)} = (u_{\\pi ,p,1},\\dots ,u_{\\pi ,p,m})^T</span>  , where  <span class="math">u_{\\pi ,p,i}\\gets D_{\\pi}^{u}</span>  , for  <span class="math">1\\leq i\\leq m</span> 15:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)} = \\mathbf{A}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)} = \\mathbf{H}_{2q,\\pi}^{(k)}\\cdot \\mathbf{u}_{\\pi ,p}^{(k)}</span> 16:  <span class="math">\\mathcal{C}</span>  sets  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)} = H_0(\\mathbf{r}_{\\pi ,p}^{(k)},\\mathbf{z}_{\\pi ,p}^{(k)})</span> 17: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{o}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 18: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  sends  <span class="math">\\mathbf{r}_{\\pi ,p}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span>  . Then,  <span class="math">\\mathcal{C}</span>  computes as follows: 19: for  <span class="math">(2\\leq p^{\\prime}\\leq N_{CS})</span>  do 20: if  <span class="math">\\mathbf{o}_{\\pi ,p^{\\prime}}^{(k)} = H_0\\big(\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)},\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}\\big)</span>  then Accept 21: else Abort protocol 22:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{r}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{r}_{\\pi ,p^{\\prime}}^{(k)}</span>  and  <span class="math">\\mathbf{z}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{z}_{\\pi ,p^{\\prime}}^{(k)}</span> 23:  <span class="math">\\mathcal{C}</span>  performs  <span class="math">\\forall k\\in [N_{in}]</span>  ,  <span class="math">\\mathbf{c}_{\\pi +1} = H_1\\big(L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\mathbf{r}_{\\pi}^{(k)},\\mathbf{z}_{\\pi}^{(k)}\\big)</span> 24: for  <span class="math">(i = \\pi +1,\\pi +2,\\dots ,w,1,2,\\dots ,\\pi -1)</span>  do 25: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 26:  <span class="math">\\mathcal{C}</span>  selects  <span class="math">\\mathbf{t}_{i,p}^{(k)} = (t_{i,p,1},\\ldots ,t_{i,p,m})^T</span>  , where  <span class="math">t_{i,p,j}\\gets D_{\\sigma}^{u}</span>  , for  <span class="math">1\\leq j\\leq m</span> 27: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{t}_{i,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 28:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_i^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{i,p^{\\prime}}^{(k)}</span> 29:  <span class="math">\\mathcal{C}</span>  calls Lift(A,  <span class="math">\\mathbf{a}_i^{(k)})</span>  to obtain  <span class="math">\\mathbf{A}_{2q,i}^{(k)} = (2\\cdot \\mathbf{A}, - 2\\cdot \\mathbf{a}_i^{(k)} + \\mathbf{q})\\in \\mathcal{R}_{2q}^{2\\pi m}</span> 30:  <span class="math">\\mathcal{C}</span>  runs  <span class="math">\\forall k\\in [N_{in}]</span> <span class="math">\\mathbf{c}_{i + 1} = H_1\\big(L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu ,\\left\\{\\mathbf{A}_{2q,i}^{(k)}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} ,\\left\\{\\mathbf{H}_{2q,\\pi}\\cdot \\mathbf{t}_i^{(k)} + \\mathbf{q}\\cdot \\mathbf{c}_i\\right\\} \\big)</span> 31: for  <span class="math">(1\\leq k\\leq N_{in})</span>  do 32:  <span class="math">\\mathcal{C}</span>  chooses  <span class="math">b^{(k)}\\gets \\{0,1\\}</span> 33:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)} = \\mathbf{u}_{\\pi ,p}^{(k)} + \\mathbf{S}_{2q,\\pi ,p}^{(k)}\\cdot \\mathbf{c}_{\\pi}\\cdot (-1)^{b^{(k)}}</span>  , where  <span class="math">\\mathbf{S}_{2q,\\pi ,p}^{(k)} = [(\\mathbf{S}_{\\pi ,p}^{(k)})^T,1]^T</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">34: Continue with prob.  $\\left(M\\exp \\left(-\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^2}{2\\sigma^2}\\right)\\cosh \\left(\\frac{\\langle\\mathbf{t}_{x,p}^{(k)},\\mathbf{S}_{2q,\\pi,p}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\rangle}{\\sigma^2}\\right)\\right)^{-1}$  otherwise Restart.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">35: When  <span class="math">\\mathcal{A}</span>  sends  <span class="math">\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span>  with  <span class="math">p^\\prime \\in [2,N_{CS}]</span>  ,  <span class="math">\\mathcal{C}</span>  returns  <span class="math">\\mathbf{t}_{\\pi ,p}^{(k)}</span>  to  <span class="math">\\mathcal{A}</span> 36:  <span class="math">\\mathcal{C}</span>  computes  <span class="math">\\mathbf{t}_{\\pi}^{(k)} = \\sum_{p^{\\prime} = 1}^{N_{CS}}\\mathbf{t}_{\\pi ,p^{\\prime}}^{(k)}</span> 37: return  <span class="math">\\sigma (\\mu) = \\left(\\mathbf{c}_1,\\{\\mathbf{t}_1^{(k)},\\dots ,\\mathbf{t}_w^{(k)}\\}_{k\\in [N_{in}]},\\{\\mathbf{h}_\\pi^{(k)}\\}_{k\\in [N_{in}]}\\right)</span></p>

    <p class="text-gray-300">Game 6: It changes the behaviour of the random oracle <span class="math">H_{1}</span> in the SigGen, Algorithm 2 (step 21). The challenger chooses <span class="math">\\mathbf{c}_{\\pi+1}</span> at random from <span class="math">\\mathcal{S}_{n,\\kappa}\\subseteq\\mathcal{R}_{2q}</span>, after that, the answer of the random oracle is programmed <span class="math">H_{1}</span> <span class="math">\\forall k\\in[N_{in}]</span> as:</p>

    <p class="text-gray-300"><span class="math">H_{1}\\Big{(}L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu,\\mathbf{r}_{\\pi}^{(k)},\\mathbf{z}_{\\pi}^{(k)}\\Big{)}=H_{1}\\Big{(}L,\\mathbf{H}_{2q,\\pi}^{(k)},\\mu,\\mathbf{A}_{2q,\\pi}^{(k)}\\cdot\\mathbf{t}_{\\pi}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{\\pi},</span> <span class="math">\\mathbf{H}_{2q,\\pi}^{(k)}\\cdot\\mathbf{t}_{\\pi}^{(k)}+\\mathbf{q}\\cdot\\mathbf{c}_{\\pi}\\Big{)}\\Big{)}</span></p>

    <p class="text-gray-300">without verifying if the values of <span class="math">\\mathbf{r}_{\\pi}^{(k)}=\\sum_{p^{\\prime}=1}^{N_{CS}}\\mathbf{A}_{2q,\\pi}^{(k)}\\cdot\\mathbf{u}_{\\pi,p^{\\prime}}^{(k)}</span> and <span class="math">\\mathbf{z}_{\\pi}^{(k)}=\\sum_{p^{\\prime}=1}^{N_{CS}}\\mathbf{H}_{2q,\\pi}^{(k)}\\cdot\\mathbf{u}_{\\pi,p^{\\prime}}^{(k)}</span> were already set <span class="math">\\forall p^{\\prime}\\in[N_{CS}]</span>. We argue that the probability of <span class="math">\\mathcal{A}</span> generating <span class="math">\\mathbf{u}_{\\pi,p^{\\prime}}^{(k)}</span>, such that <span class="math">\\mathbf{r}_{\\pi}^{(k)}</span> and <span class="math">\\mathbf{z}_{\\pi}^{(k)}</span> are equal to one of previous queries is at most <span class="math">2^{-n+1}</span>. Therefore, if the SigGen (in this Game 3) and <span class="math">H_{1}</span> are queried <span class="math">Q_{s}</span> and <span class="math">Q_{1}</span> times, respectively, then the probability of getting one collision each time is at most <span class="math">N_{CS}\\cdot(Q_{s}+Q_{1})2^{-n+1}</span>. Additionally, the probability that a collision happens after <span class="math">Q_{s}</span> queries is at most <span class="math">N_{CS}\\cdot Q_{s}\\cdot(Q_{s}+Q_{1})2^{-n+1}</span>, which is negligible (Based on <em>[19]</em>, Lemma 3.4).</p>

    <p class="text-gray-300">Let <span class="math">S_{6}</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 6 with negligible probability <span class="math">N_{CS}\\cdot Q_{s}\\cdot(Q_{s}+Q_{1})2^{-n+1}\\leq\\epsilon_{6}</span>. Then we claim that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[S_{5}]-\\Pr[S_{6}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\epsilon_{6}.$ (17)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Game 7: Changes in this game are made on the <span class="math">\\mathbf{t}_{1}^{(k)},\\ldots,\\mathbf{t}_{w}^{(k)}</span> from the SigGen, Algorithm 2 (step 39). This time, the challenger chooses <span class="math">\\forall p^{\\prime}</span>, <span class="math">\\mathbf{t}_{\\pi,p^{\\prime}}^{(k)}</span> now directly from the Gaussian distribution <span class="math">D_{\\sigma}^{n\\times m}</span>, instead of computing it as <span class="math">\\mathbf{t}_{\\pi}^{(k)}=\\sum_{p^{\\prime}=1}^{N_{CS}}\\mathbf{t}_{\\pi,p^{\\prime}}^{(k)}</span> with <span class="math">\\mathbf{t}_{\\pi,p^{\\prime}}^{(k)}=\\mathbf{u}_{\\pi,p^{\\prime}}^{(k)}+\\mathbf{S}_{2q,\\pi,p^{\\prime}}^{(k)}\\cdot\\mathbf{c}_{\\pi}\\cdot(-1)^{b^{(k)}}</span> (Based on <em>[19]</em>, Lemma 3.5). Since <span class="math">\\mathbf{t}_{\\pi,p^{\\prime}}^{(k)}</span> is computed using rejection sampling (as Lemma 1), thus it is always sample from the Gaussian distribution <span class="math">D_{\\sigma}^{n}(\\mu)</span>. This means that any adversary will have no advantage in breaking the anonymity property in this Game due to both cases have same distribution.</p>

    <p class="text-gray-300">Let <span class="math">S_{7}</span> be the event where the <span class="math">\\mathcal{A}</span> wins Game 7 with zero probability <span class="math">0=\\epsilon_{7}</span>. Then we claim that:</p>

    <p class="text-gray-300">In this game, the view of the adversary <span class="math">\\mathcal{A}</span> is independent of <span class="math">b</span>; therefore,</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{7}]=\\Pr[b^{\\prime}=b]=\\tfrac{1}{2}.</span> (18)</p>

    <p class="text-gray-300">The results of the Games are combined from (11), (12), (13), (14), (15), (16), (17), and (18) we obtain</p>

    <p class="text-gray-300"><span class="math">\\Pr[S_{0}]=\\Pr[S_{7}]+\\sum_{i=1}^{6}\\epsilon_{i},</span></p>

    <p class="text-gray-300">by replacing (18) in the <span class="math">\\Pr[S_{0}]</span>, we have</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ S _ {0} ] = \\frac {1}{2} + \\sum_ {i = 1} ^ {6} \\epsilon_ {i},</span></div>

    <p class="text-gray-300">and this is negligible.</p>

    <p class="text-gray-300">Proof. We construct a challenger  <span class="math">\\mathcal{C}</span>  and an adversary  <span class="math">\\mathcal{A}</span>  to solve the  <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span>  problem. They run the linkability attack game (Def. 4)  <span class="math">\\forall k\\in [N_{in}]</span> , namely:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{C}</span>  generates using the KeyGen (Algorithm 1) all secret-keys  <span class="math">\\mathbf{S}_i^{(k)}</span> 's with the corresponding public-keys  <span class="math">\\mathbf{a}_i^{(k)}</span> 's, then  <span class="math">\\mathcal{C}</span>  gives  <span class="math">\\mathbf{S}_{\\pi}^{(k)} = \\sum_{p&#x27;}^{N_{CS}} \\mathbf{S}_{\\pi, p&#x27;}^{(k)}</span>  to the adversary  <span class="math">\\mathcal{A}</span> .</li>

      <li><span class="math">\\mathcal{A}</span>  outputs two signatures  <span class="math">\\sigma(\\mu_1)</span>  and  <span class="math">\\sigma&#x27;(\\mu_1&#x27;)</span>  along with their corresponding lists  <span class="math">L</span>  and  <span class="math">L&#x27;</span> , respectively. These signatures are successfully verified by SigVer (Algorithm 3) with their linkability tags different such that  <span class="math">\\mathbf{h}_{\\mu_1}^{(k)} \\neq \\mathbf{h}_{\\mu_1&#x27;}^{(k)}</span> .</li>

      <li><span class="math">\\mathcal{C}</span>  computes the linking tags as  <span class="math">\\mathbf{h}_{\\pi}^{(k)} = \\mathbf{H} \\cdot \\mathbf{S}_{\\pi,p}^{(k)} \\bmod q</span> , where “ <span class="math">\\pi</span> ” is the legitimate signer. This  <span class="math">\\mathbf{h}_{\\pi}^{(k)}</span>  can then be compared with the linkability tags  <span class="math">\\mathbf{h}_{\\mu_1}^{(k)}</span>  and  <span class="math">\\mathbf{h}_{\\mu&#x27;}^{(k)}</span>  that were outputted by  <span class="math">\\mathcal{A}</span>  (in step 2) and one of them would be different.</li>

      <li>Without loss of generality, suppose  <span class="math">\\mathbf{h}_{\\mu_1}^{(k)} \\neq \\mathbf{h}_{\\pi}^{(k)} \\bmod q</span> . Using the forking lemma [5],  <span class="math">\\mathcal{C}</span>  rewinds the attacker  <span class="math">\\mathcal{A}</span>  to the random oracle " <span class="math">H_1</span> " query that corresponds to the SigVer of the signature  <span class="math">\\sigma_L(\\mu_1)</span> .  <span class="math">\\mathcal{C}</span>  reruns  <span class="math">\\mathcal{A}</span>  with a different response of  <span class="math">H_1</span>  and obtains two signatures:  <span class="math">\\sigma(\\mu_2)</span>  and  <span class="math">\\sigma&#x27;(\\mu_2&#x27;)</span> . Then, we use this signature  <span class="math">\\sigma(\\mu_1)</span>  and  <span class="math">\\sigma(\\mu_2)</span>  to extract a solution to the  <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span>  problem if the adversary  <span class="math">\\mathcal{A}</span>  finds an efficient algorithm to unlink these signatures (as further shown in step 7).</li>

      <li>The adversary  <span class="math">\\mathcal{A}</span>  matches the challenge message of both signatures where  <span class="math">\\mathbf{H}_{2q,\\mu_1}^{(k)},\\mathbf{A}_{2q,w,\\mu_1}^{(k)}</span>  and  <span class="math">\\mathbf{q}</span>  are fixed. Subsequently, we obtain the following relations:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} _ {2 q, w, \\mu_ {1}} ^ {(k)} \\cdot \\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {w, \\mu_ {1}} = \\mathbf {A} _ {2 q, w, \\mu_ {1}} ^ {(k)} \\cdot \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {w, \\mu_ {2}} \\tag {19} \\\\ \\mathbf {H} _ {2 q, \\mu_ {1}} ^ {(k)} \\cdot \\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {w, \\mu_ {1}} = \\mathbf {H} _ {2 q, \\mu_ {1}} ^ {(k)} \\cdot \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)} + \\mathbf {q} \\cdot \\mathbf {c} _ {w, \\mu_ {2}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">These expressions can be represented as:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} _ {2 q, w, \\mu_ {1}} ^ {(k)} \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {q} \\cdot \\left(\\mathbf {c} _ {w, \\mu_ {2}} - \\mathbf {c} _ {w, \\mu_ {1}}\\right) \\tag {20} \\\\ \\mathbf {H} _ {2 q, \\mu_ {1}} ^ {(k)} \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {q} \\cdot \\left(\\mathbf {c} _ {w, \\mu_ {2}} - \\mathbf {c} _ {w, \\mu_ {1}}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Reducing (20) mod  <span class="math">q</span>  with  <span class="math">(\\mathbf{c}_{w,\\mu_2} - \\mathbf{c}_{w,\\mu_1})\\neq \\mathbf{0}\\bmod 2</span> , it results in:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {A} _ {2 q, w, \\mu_ {1}} ^ {(k)} \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {0} \\bmod q \\tag {21} \\\\ \\mathbf {H} _ {2 q, \\mu_ {1}} ^ {(k)} \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {0} \\bmod q \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">We recall the definition of  <span class="math">\\mathbf{H}_{2q,\\mu_1}^{(k)}</span>  and  <span class="math">\\mathbf{A}_{2q,w,\\mu_1}^{(k)}</span>  in SigGen, Algorithm 2 (steps 8 and 9), respectively, then we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(2 \\cdot \\mathbf {A}, - 2 \\cdot \\mathbf {a} _ {\\mu_ {1}} ^ {(k)} + \\mathbf {q}\\right) \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {0} \\bmod q \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(2 \\cdot \\mathbf {H}, - 2 \\cdot \\mathbf {h} _ {\\mu_ {1}} ^ {(k)} + \\mathbf {q}\\right) \\cdot \\left(\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)}\\right) = \\mathbf {0} \\bmod q</span></div>

    <p class="text-gray-300">Afterwards, if we define  <span class="math">(\\mathbf{t}_{w,\\mu_1}^{(k)} - \\mathbf{t}_{w,\\mu_2}^{(k)})</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {t} _ {w, \\mu_ {1}} ^ {(k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {(k)} = \\left( \\begin{array}{l} \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime (k)} \\\\ \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime \\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime \\prime (k)} \\end{array} \\right) \\in \\mathcal {R} _ {q} ^ {m} \\tag {23}</span></div>

    <p class="text-gray-300">Then, by replacing (22) in (23), it results in:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(2 \\cdot \\mathbf {A}, - 2 \\cdot \\mathbf {a} _ {\\mu_ {1}} ^ {(k)} + \\mathbf {q}\\right) \\cdot \\left( \\begin{array}{l} \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime (k)} \\\\ \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime \\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime \\prime (k)} \\end{array} \\right) = \\mathbf {0} \\bmod q \\tag {24}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(2 \\cdot \\mathbf {H}, - 2 \\cdot \\mathbf {h} _ {\\mu_ {1}} ^ {(k)} + \\mathbf {q}\\right) \\cdot \\left( \\begin{array}{c} \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime (k)} \\\\ \\mathbf {t} _ {w, \\mu_ {1}} ^ {\\prime \\prime (k)} - \\mathbf {t} _ {w, \\mu_ {2}} ^ {\\prime \\prime (k)} \\end{array} \\right) = \\mathbf {0} \\bmod q</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since we reduce (24) to mod  <span class="math">q</span> ,  <span class="math">q</span>  is odd, and  <span class="math">\\mathbf{H} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime(k)}) = \\mathbf{h}_{\\mu_1}^{(k)} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)}) \\mod q</span> . We claim that  <span class="math">(\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)}) \\neq \\mathbf{0}</span>  is invertible in  <span class="math">\\mathcal{R}_q</span> . To show this, we have  <span class="math">(\\mathbf{c}_{w,\\mu_2} - \\mathbf{c}_{w,\\mu_1}) \\neq \\mathbf{0} \\mod 2</span> . Therefore, using (20), we conclude  <span class="math">(\\mathbf{t}_{w,\\mu_1}^{(k)} - \\mathbf{t}_{w,\\mu_2}^{(k)}) \\neq \\mathbf{0} \\mod 2</span> , and  <span class="math">(\\mathbf{t}_{w,\\mu_1}^{(k)} - \\mathbf{t}_{w,\\mu_2}^{(k)}) \\neq \\mathbf{0} \\mod 2q</span> . Additionally, we know that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_{w,\\mu_1}^{(k)} - \\mathbf{t}_{w,\\mu_2}^{(k)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; q/2<span class="math">  and  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{t}_{w,\\mu_1}^{(k)} - \\mathbf{t}_{w,\\mu_2}^{(k)} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 &lt; 2\\beta_v<span class="math">  as SigVer, Algorithm 3, which implies that  </span>(\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)}) \\neq \\mathbf{0} \\mod q<span class="math"> . Furthermore, since  </span>2\\beta_v &lt; \\frac{1}{\\sqrt{k}} \\cdot q^{1/k}<span class="math">  as in ([34], Corollary 1.2), then  </span>(\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)})<span class="math">  is invertible in  </span>\\mathcal{R}_q<span class="math"> . After that, we establish  </span>\\mathbf{h}_{\\mu_1}^{(k)}$  as:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {h} _ {\\mu_ {1}} ^ {(k)} = \\mathbf {H} \\cdot \\frac {\\left(\\mathbf {t} _ {w , \\mu_ {1}} ^ {\\prime (k)} - \\mathbf {t} _ {w , \\mu_ {2}} ^ {\\prime (k)}\\right)}{\\left(\\mathbf {t} _ {w , \\mu_ {1}} ^ {\\prime \\prime (k)} - \\mathbf {t} _ {w , \\mu_ {2}} ^ {\\prime \\prime (k)}\\right)} \\bmod q \\tag {25}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Then,  <span class="math">\\bar{\\mathbf{S}}_{\\mu_1}^{(k)}</span>  is well-defined since  <span class="math">(\\mathbf{t}_{w,\\mu_1}^{\\prime \\prime (k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime \\prime (k)})</span>  is invertible in  <span class="math">\\mathcal{R}_q</span> , then we said that:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\bar {\\mathbf {S}} _ {\\mu_ {1}} ^ {(k)} \\triangleq \\frac {\\left(\\mathbf {t} _ {w , \\mu_ {1}} ^ {\\prime (k)} - \\mathbf {t} _ {w , \\mu_ {2}} ^ {\\prime (k)}\\right)}{\\left(\\mathbf {t} _ {w , \\mu_ {1}} ^ {\\prime \\prime (k)} - \\mathbf {t} _ {w , \\mu_ {2}} ^ {\\prime \\prime (k)}\\right)} \\bmod q \\tag {26}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By using  <span class="math">\\mathbf{S}_{\\pi}^{(k)}</span>  from (step 3), we consider two cases, when  <span class="math">\\bar{\\mathbf{S}}_{\\mu_1}^{(k)} = \\mathbf{S}_{\\pi}^{(k)} \\bmod q</span>  and  <span class="math">\\bar{\\mathbf{S}}_{\\mu_1}^{(k)} \\neq \\mathbf{S}_{\\pi}^{(k)} \\bmod q</span> . These cases are analysed as follows:</li>

    </ol>

    <p class="text-gray-300">(a) Case 1: If  <span class="math">\\bar{\\mathbf{S}}_{\\mu_1}^{(k)} = \\mathbf{S}_{\\pi}^{(k)} \\bmod q</span> , we show that  <span class="math">\\mathbf{h}_{\\mu_1}^{(k)} = -2 \\cdot \\mathbf{H} \\cdot \\bar{\\mathbf{S}}_{\\mu_1}^{(k)} = -2 \\cdot \\mathbf{H} \\cdot \\mathbf{S}_{\\pi}^{(k)} = \\mathbf{h}_{\\pi}^{(k)} \\bmod q</span> , which is a contradiction with respect to the above assumption (step 4), where  <span class="math">\\mathbf{h}_{\\mu_1}^{(k)} \\neq \\mathbf{h}_{\\pi}^{(k)} \\bmod q</span> .</p>

    <p class="text-gray-300">W. Alberto Torres et al.</p>

    <p class="text-gray-300">(b) Case 2: When <span class="math">\\bar{\\mathbf{S}}_{\\mu_1}^{(k)} \\neq \\mathbf{S}_{\\pi}^{(k)} \\bmod q</span>, we have <span class="math">\\mathbf{a}_{\\mu_1}^{(k)} = \\mathbf{A} \\cdot \\bar{\\mathbf{S}}_{\\mu_1}^{(k)} = \\mathbf{A} \\cdot \\mathbf{S}_{\\pi}^{(k)} = \\mathbf{a}_{\\pi}^{(k)} \\bmod q</span>, then using (26) we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{A} \\cdot \\frac{(\\mathbf{t}_{w,\\mu_1}^{\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime(k)})}{(\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)})} = \\mathbf{A} \\cdot \\mathbf{S}_{\\pi}^{(k)} \\bmod q \\iff \\\\ \\mathbf{A} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime(k)}) = \\mathbf{A} \\cdot \\mathbf{S}_{\\pi}^{(k)} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)}) \\bmod q \\iff \\\\ \\mathbf{A} \\cdot \\left((\\mathbf{t}_{w,\\mu_1}^{\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime(k)}) - \\mathbf{S}_{\\pi}^{(k)} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)})\\right) = 0 \\bmod q \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">then we let this small non-zero vector <span class="math">\\mathbf{v} \\triangleq \\left((\\mathbf{t}_{w,\\mu_1}^{\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime(k)}) - \\mathbf{S}_{\\pi}^{(k)} \\cdot (\\mathbf{t}_{w,\\mu_1}^{\\prime\\prime(k)} - \\mathbf{t}_{w,\\mu_2}^{\\prime\\prime(k)})\\right)</span> be the output of the adversary <span class="math">\\mathcal{A}</span>, and this vector is a solution to the <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span> problem with respect to the public parameter <span class="math">\\mathbf{A} \\in \\mathcal{R}_q^{2 \\times (m-1)}</span>, where $\\beta = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2\\beta_v(1 + \\sqrt{n} N_{in} 2^\\gamma)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">Proof. Let's suppose there is a non-slanderability adversary <span class="math">\\mathcal{A}_{\\text{Sland}}</span> who is given <span class="math">\\mathbf{p}\\mathbf{k}_i, \\mathbf{s}\\mathbf{k}_i, i \\neq \\pi</span>, and <span class="math">i \\in \\{1, \\ldots, w\\}</span>, and he produces a valid signature <span class="math">\\sigma&#x27;(\\mu)</span> with linkability tag <span class="math">\\mathbf{h}_{\\sigma&#x27;(\\mu)}</span> which is equal to <span class="math">\\mathbf{h}_{\\sigma(\\mu)}</span>, <span class="math">\\sigma(\\mu)</span> being the legitimate signature generated with respect to <span class="math">\\mathbf{s}\\mathbf{k}_{\\pi}</span>. This means that <span class="math">\\mathcal{A}_{\\text{Sland}}</span> can create a signature with the linkability tag <span class="math">\\mathbf{h}_{\\sigma(\\mu)}</span> without knowing <span class="math">\\mathbf{s}\\mathbf{k}_{\\pi}</span>. The adversary can also compute a valid <span class="math">\\sigma&#x27;&#x27;(\\mu)</span> with <span class="math">\\mathbf{s}\\mathbf{k}_i</span>, <span class="math">i \\neq \\pi</span>, and <span class="math">i \\in \\{1, \\ldots, w\\}</span> for which <span class="math">\\mathbf{h}_{\\sigma&#x27;&#x27;(\\mu)} \\neq \\mathbf{h}_{\\sigma&#x27;(\\mu)}</span>. We give <span class="math">(\\sigma&#x27;&#x27;(\\mu), \\sigma&#x27;(\\mu))</span> to the forger, which can turn it to an <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span> solution. In particular, it will be computationally secure when two valid signatures created by different users are unlinked using the L2RS-CS algorithms. An adversary <span class="math">\\mathcal{A}</span> will break these properties with negligible probability as demonstrated in Theorems (2 and 4), and with these probabilities the <span class="math">\\mathcal{A}</span> will find a <span class="math">\\mathbf{MSIS}_{q,m,k,\\beta}^{\\mathcal{K}}</span> solution. Therefore, non-slanderability is implied by the definitions of the unforgeability (Def. 2) and linkability (Def. 4), and security analysis, in Appendix B) and Appendix D, respectively.</p>

    <p class="text-gray-300">Post-Quantum Lattice-based Linkable Ring Signature with Co-Signing</p>

    <p class="text-gray-300">Table 3. List conditions for MIMO.L2RS-CS's performance analysis</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Order</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Condition</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Description</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">Sn,e=(n)·2n>2λ</td>

            <td class="px-3 py-2 border-b border-gray-700">The challenge space</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">γ≥log(nk)</td>

            <td class="px-3 py-2 border-b border-gray-700">n/a</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Sc</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≤√mnk2γ</td>

            <td class="px-3 py-2 border-b border-gray-700">Rejection sampling</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">σ≥α</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Sc</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Rejection sampling from BLISS, α = {0.5,0.55,0.7,1}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700">βe=ησ√nm</td>

            <td class="px-3 py-2 border-b border-gray-700">SigVer and Correctness, with (η=1.1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">NinNCS1/4√(2n/2(1+1)(m-1)n)≤2-λ</td>

            <td class="px-3 py-2 border-b border-gray-700">Left Over Hash Lemma, with security parameter (λ=128)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700">β≤2βe+2βe√n2γ</td>

            <td class="px-3 py-2 border-b border-gray-700">β from the linkability analysis</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">min(q,22√2n log(q) log(δ))>β</td>

            <td class="px-3 py-2 border-b border-gray-700">Shortest vector length ([36]-P156), with Hermite factor (δ=1.0045)</td>

          </tr>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="Post-Quantum Linkable Ring Signature Enabling Distributed Au... (2020/1121)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1121
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
