---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/403';
const CRAWLER = 'marker';
---

<BaseLayout title="Griffin (2022/403)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Horst Meets Fluid-SPN: Griffin for Zero-Knowledge
        Applications
      </h1>
      <p class="text-gray-400 mb-2">
        Lorenzo Grassi, Yonglin Hao, Christian Rechberger,
        Markus Schofnegger, Roman Walch, Qingju Wang
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Full Version &middot; eprint 2022/403
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Hash and Compression Functions in ZK Settings</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Our Contribution</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            Cost Metrics for Zero-Knowledge Proof Systems</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Zero-Knowledge Proofs</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                Arithmetization</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Rank-1 Constraint Satisfaction Systems (R1CS)</a>
            </li>
            <li>
              <a href="#sec-2.4"
                class="hover:text-white">
                Plonk Arithmetization</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">The Road to Griffin</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                Related Work: SPN Schemes for ZK Applications</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Non-SPN Schemes: From Feistel to Horst</a>
            </li>
            <li>
              <a href="#sec-3.3"
                class="hover:text-white">
                Constructing Nonzero Functions G</a>
            </li>
            <li>
              <a href="#sec-3.4"
                class="hover:text-white">
                Combining Horst with a Rescue-like SPN</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">Modes of Operation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Sponge Hash Functions</a>
            </li>
            <li>
              <a href="#sec-4.2"
                class="hover:text-white">
                Compression Functions</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            Griffin and Griffin-<span class="math">\pi</span></a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-5.1"
                class="hover:text-white">
                Specification of Griffin-<span class="math">\pi</span></a>
            </li>
            <li>
              <a href="#sec-5.2"
                class="hover:text-white">
                Number of Rounds of Griffin-<span class="math">\pi</span></a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Security of Griffin and Griffin-<span class="math">\pi</span></a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-6.1"
                class="hover:text-white">
                Statistical Attacks on Griffin-<span class="math">\pi</span></a>
            </li>
            <li>
              <a href="#sec-6.2"
                class="hover:text-white">
                Algebraic Attacks</a>
            </li>
            <li>
              <a href="#sec-6.3"
                class="hover:text-white">
                Feistel versus Horst</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-7"
            class="hover:text-white">Performance Evaluation</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-7.1"
                class="hover:text-white">
                Plain Performance</a>
            </li>
            <li>
              <a href="#sec-7.2"
                class="hover:text-white">
                R1CS-Based SNARKs with Griffin</a>
            </li>
            <li>
              <a href="#sec-7.3"
                class="hover:text-white">
                Plonk Performance of Griffin</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-8"
            class="hover:text-white">Acknowledgments</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li>
          <a href="#app-a"
            class="hover:text-white">STARKs with Griffin</a>
        </li>
        <li>
          <a href="#app-b"
            class="hover:text-white">
            Security of Horst Schemes</a>
        </li>
        <li>
          <a href="#app-c"
            class="hover:text-white">
            Proofs &ndash; Differential Cryptanalysis</a>
        </li>
        <li>
          <a href="#app-d"
            class="hover:text-white">
            Dedicated MILP Tool for Rebound Attacks</a>
        </li>
        <li>
          <a href="#app-e"
            class="hover:text-white">
            Algebraic Attacks &ndash; Details</a>
        </li>
        <li>
          <a href="#app-f"
            class="hover:text-white">
            Security Analysis &ndash; Other Attacks</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        Zero-knowledge (ZK) applications form a large group of use
        cases in modern cryptography, and recently gained in popularity
        due to novel proof systems. For many of these applications,
        cryptographic hash functions are used as the main building
        blocks, and they often dominate the overall performance and
        cost of these approaches.
      </p>
      <p class="text-gray-300">
        Therefore, in the last years several new hash functions were
        built in order to reduce the cost in these scenarios, including
        Poseidon and <em>Rescue</em> among others. These hash
        functions often look very different from more classical designs
        such as AES or SHA-2. For example, they work natively over
        prime fields rather than binary ones. At the same time, for
        example Poseidon and <em>Rescue</em> share some common
        features, such as being SPN schemes and instantiating the
        nonlinear layer with invertible power maps. While this allows
        the designers to provide simple and strong arguments for
        establishing their security, it also introduces crucial
        limitations in the design, which may affect the performance in
        the target applications.
      </p>
      <p class="text-gray-300">
        In this paper, we propose the Horst construction, in which the
        addition in a Feistel scheme
        <span class="math">(x, y) \mapsto (y + F(x), x)</span> is
        extended via a multiplication, i.e.,
        <span class="math">(x, y) \mapsto (y \times G(x) + F(x), x)</span>.
      </p>
      <p class="text-gray-300">
        By carefully analyzing the performance metrics in SNARK and
        STARK protocols, we show how to combine an expanding Horst
        scheme with a <em>Rescue</em>-like SPN scheme in order to
        provide security and better efficiency in the target
        applications. We provide an extensive security analysis for our
        new design Griffin and a comparison with all current
        competitors.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> Hash Functions &ndash; Griffin
        &ndash; Zero-Knowledge &ndash; Horst &ndash; Fluid-SPN
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>
      <p class="text-gray-300">
        Concepts like multi-party computation (MPC), homomorphic
        encryption (HE), post-quantum signature schemes, and
        zero-knowledge (ZK) proof systems have recently grown in
        popularity. Some of these applications favor cryptographic
        schemes with specific properties, such as a small number of
        multiplications. Considering
        <span class="math">\mathbb&#123;F&#125;_p^t</span> for a prime
        <span class="math">p \geq 3</span> and
        <span class="math">t \geq 1</span>, examples include
        Feistel-MiMC, GMiMC, Poseidon, <em>Rescue</em>, Grendel,
        Reinforced Concrete, Neptune, and Anemoi, among others.
      </p>
      <p class="text-gray-300">
        The performance metrics vary between the different use cases.
        While the cost in e.g. MPC is well-studied, ZK protocols often
        have more sophisticated optimization targets. The two major
        classes of ZK proof systems are zero-knowledge succinct
        non-interactive arguments of knowledge (zk-SNARKs) and
        zero-knowledge scalable transparent arguments of knowledge
        (zk-STARKs), which are also the ones the authors focus on.
      </p>
      <p class="text-gray-300">
        Recent hash functions proposed for these protocols differ
        substantially from each other, however their internal
        permutations are usually SPN constructions. While this
        approach may have advantages for arguing security, it can also
        have various limitations affecting the performance in ZK
        protocols.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Hash and Compression Functions in ZK Settings
      </h3>
      <p class="text-gray-300">
        <strong>Cost Metrics in ZK Protocols.</strong> In many ZK
        applications, the prover uses ZK proofs to convince a verifier
        that they know a preimage
        <span class="math">x</span> of a given hash or compression
        output
        <span class="math">y = \mathcal&#123;H&#125;(x)</span> without
        revealing anything about
        <span class="math">x</span>. The efficiency of these protocols
        depends on the details of
        <span class="math">\mathcal&#123;H&#125;</span>. In zk-SNARKs,
        the cost of the proof is proportional to the number of
        nonlinear operations one has to perform. In zk-STARKs, the
        cost is related to the degree and the depth of the circuit
        that must be verified. In both cases, it is not required to
        recompute
        <span class="math">\mathcal&#123;H&#125;</span> in order to
        determine if
        <span class="math">y = \mathcal&#123;H&#125;(x)</span>.
        Indeed, one can verify any equivalent cheaper representation
        <span class="math">\mathcal&#123;F&#125;(x,y) = 0</span>
        which is satisfied if and only if
        <span class="math">y = \mathcal&#123;H&#125;(x)</span>.
      </p>
      <p class="text-gray-300">
        Most previous designs focused only on a subset of cost
        metrics. For example, MiMC, HadesMiMC, and Poseidon aimed to
        minimize the number of multiplications, leading to efficiency
        in SNARKs but disadvantages in other proof systems. In
        contrast, <em>Rescue</em> has an inner structure tailored for
        STARKs but suffers in other SNARKs and in plain performance.
      </p>
      <p class="text-gray-300">
        <strong>SPN Schemes and Power Maps.</strong> Competitive hash
        functions for ZK protocols include <em>Rescue</em> and
        Poseidon. Both schemes are instantiated via an SPN permutation,
        whose round function
        <span class="math">\mathcal&#123;R&#125; : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
        is defined as
      </p>
      <div class="math-block">
        \mathcal&#123;R&#125;(\cdot) = c + M \times S(\cdot)
      </div>
      <p class="text-gray-300">
        where <span class="math">c</span> is a round constant,
        <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;t \times t&#125;</span>
        is an MDS matrix, and
        <span class="math">S : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
        is an S-box layer defined as
      </p>
      <div class="math-block">
        S(x_0, x_1, \dots, x_&#123;t-1&#125;) = S_0(x_0) \| S_1(x_1) \| \dots \| S_&#123;t-1&#125;(x_&#123;t-1&#125;)
      </div>
      <p class="text-gray-300">
        for invertible maps
        <span class="math">S_i : \mathbb&#123;F&#125;_p \to \mathbb&#123;F&#125;_p</span>.
        Every round of <em>Rescue</em> consists of two steps, one in
        which all
        <span class="math">S_i</span> correspond to
        <span class="math">x \mapsto x^&#123;1/d&#125;</span> and one
        in which all
        <span class="math">S_i</span> correspond to
        <span class="math">x \mapsto x^d</span>. Poseidon uses two
        different rounds, one in which
        <span class="math">S_i(x) = x^d</span> and one in which
        <span class="math">S_0(x) = x^d</span> and
        <span class="math">S_&#123;i \neq 0&#125;(x) = x</span>
        (identity).
      </p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Our Contribution
      </h3>
      <p class="text-gray-300">
        <strong>SPN Schemes in ZK.</strong> An SPN scheme usually
        allows for simple and strong security arguments regarding
        statistical attacks. However, SPN schemes over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> have a
        crucial limitation in the ZK setting. A common way to
        instantiate the nonlinear layer is to use invertible power maps
        <span class="math">x \mapsto x^d</span> (hence,
        <span class="math">\gcd(d, p-1) = 1</span>). Since the
        square function is not a permutation over
        <span class="math">\mathbb&#123;F&#125;_p</span>, one must use
        a function of degree
        <span class="math">d \geq 3</span>, which affects the
        performance. The number of multiplications is at least
        <span class="math">2t</span> for a
        <span class="math">t</span>-element state, and
        <span class="math">3t</span> for the particular ZK settings
        considered.
      </p>
      <p class="text-gray-300">
        <strong>Horst Schemes.</strong> Together with an SPN, another
        popular cryptographic construction is the Feistel one. Given a
        function <span class="math">F</span> over a generic field
        <span class="math">\mathbb&#123;F&#125;</span>, a Feistel
        scheme is defined as the map
        <span class="math">(x,y) \mapsto (y + F(x), x)</span> over
        <span class="math">\mathbb&#123;F&#125;_p^2</span>. The
        authors propose a modified Feistel scheme, called Horst, in
        which the linear relation between
        <span class="math">y</span> and
        <span class="math">F(x)</span> is combined with a nonlinear
        one:
        <span class="math">(y, x) \mapsto (x, y \times G(x) + F(x))</span>.
        To guarantee invertibility, we require that
        <span class="math">G(x) \neq 0</span> for each input
        <span class="math">x</span>.
      </p>
      <p class="text-gray-300">
        <strong>Griffin.</strong> Griffin is a new family of sponge
        hash and compression functions using the internal permutation
        Griffin-<span class="math">\pi</span>. The permutation cannot
        be rewritten as a standard SPN since its nonlinear layer is
        not divided into independent nonlinear S-boxes. Instead, it is
        composed of two nonlinear sublayers defined via three different
        nonlinear functions. Two of them are defined via the invertible
        power maps
        <span class="math">x \mapsto x^d</span> and
        <span class="math">x \mapsto x^&#123;1/d&#125;</span>
        (inspired by <em>Rescue</em>), and the final one is defined by
        the proposed Horst strategy, using the map
        <span class="math">(x,y) \mapsto (x, y \cdot G(x))</span>
        for a quadratic function
        <span class="math">G</span> such that
        <span class="math">G(z) \neq 0</span> for each
        <span class="math">z</span>.
      </p>
      <p class="text-gray-300">
        <strong>Modes of Operation.</strong> The proposed permutation
        Griffin-<span class="math">\pi</span> can be used both in a
        sponge mode and in a compression mode. The former is more
        versatile while the latter can be more efficient in specific
        settings.
      </p>
      <p class="text-gray-300">
        <strong>Security Analysis.</strong> A security analysis is
        given in Section 6. From the algebraic perspective, Grobner
        basis attacks at the round level are the most efficient ones.
        From the statistical perspective, the authors apply bounds
        against classical differential and linear attacks. For
        rebound attacks, an analysis using dedicated MILP tools
        provides bounds on the minimal number of rounds needed.
      </p>
      <p class="text-gray-300">
        <strong>Efficiency.</strong> Griffin aims to find a beneficial
        tradeoff between all cost metrics. In R1CS-based SNARKs,
        Griffin is better suited than any previously proposed design.
        In zk-STARKs and Plonk, Griffin provides similar performance
        as the currently best hash functions for STARKs, and the
        best performance for many configurations in Plonk.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. COST METRICS FOR ZK PROOF SYSTEMS                        -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">
        2. Cost Metrics for Zero-Knowledge Proof Systems
      </h2>
      <p class="text-gray-300">
        This section analyzes the cost metrics for R1CS-based SNARKs
        and Plonk. The authors start by providing a brief introduction
        to arithmetization techniques used in various ZK proof systems,
        focusing on iterative functions.
      </p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Zero-Knowledge Proofs
      </h3>
      <p class="text-gray-300">
        A ZK proof system is a two-player protocol between a prover
        and a verifier, allowing the prover to convince the verifier
        that they know a witness
        <span class="math">w</span> to a statement
        <span class="math">x</span> without revealing anything about
        the witness beyond what can be implied by
        <span class="math">x</span>. The proof system needs to be
        complete and sound with a negligible soundness error
        <span class="math">\epsilon</span>, and it must fulfill the
        zero-knowledge property.
      </p>
      <p class="text-gray-300">
        The two major classes of ZK proof systems are zk-SNARKs and
        zk-STARKs, where zk-SNARKs require a trusted setup and are
        not post-quantum secure. Two main use cases relying on hash
        functions are set membership proofs based on Merkle tree
        accumulators and verifiable computation based on recursive
        proofs.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 Arithmetization
      </h3>
      <p class="text-gray-300">
        To prove a solution of a computational problem, one has to
        translate the problem into an algebraic representation. This
        step is known as arithmetization and differs between the
        various proof systems. Many representations have been proposed,
        with rank-1 constraint satisfaction systems (R1CS) and Plonk
        gates being the most widely used in zk-SNARKs, and the
        algebraic intermediate representation (AIR) being used in
        zk-STARKs.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 1 (Zero-Equivalence)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">q = p^n</span> for a prime
            <span class="math">p \geq 2</span> and
            <span class="math">n \geq 1</span>. Let
            <span class="math">\mathcal&#123;F&#125;_0, \ldots, \mathcal&#123;F&#125;_&#123;r-1&#125; : \mathbb&#123;F&#125;_q^t \to \mathbb&#123;F&#125;_q^t</span>
            be
            <span class="math">r \geq 1</span> functions. Let
            <span class="math">\mathcal&#123;G&#125;_0, \ldots, \mathcal&#123;G&#125;_&#123;s-1&#125; : (\mathbb&#123;F&#125;_q^t)^r \to \mathbb&#123;F&#125;_q^t</span>
            be
            <span class="math">s \geq 1</span> functions. We say that
            <span class="math">\mathcal&#123;G&#125;_0, \ldots, \mathcal&#123;G&#125;_&#123;s-1&#125;</span>
            are <strong>zero-equivalent</strong> to
            <span class="math">\mathcal&#123;F&#125;_0, \ldots, \mathcal&#123;F&#125;_&#123;r-1&#125;</span>
            if for each
            <span class="math">x_0, x_1, \ldots, x_&#123;r-1&#125; \in \mathbb&#123;F&#125;_q^t</span>
            the following holds:
          </p>
          <div class="math-block">
            \forall i \in \&#123;0, \dots, r-1\&#125; : x_&#123;i+1&#125; = \mathcal&#123;F&#125;_i(x_i) \iff \forall j \in \&#123;0, \dots, s-1\&#125; : \mathcal&#123;G&#125;_j(x_0, \dots, x_&#123;r-1&#125;) = 0
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        This strategy is based on the notion of
        <em>non-procedural computation</em>, which describes the idea
        of not only evaluating schemes in the plain direction, but
        using intermediate relations instead. A scheme is
        <em>fluid</em> if it admits an equivalent representation which
        can be proven and/or verified more efficiently.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2 (CCZ Equivalence)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Two functions
            <span class="math">\mathcal&#123;F&#125;, \mathcal&#123;G&#125; : \mathbb&#123;F&#125;_q^t \to \mathbb&#123;F&#125;_q^t</span>
            are CCZ-equivalent if there exists an affine permutation
            <span class="math">\mathcal&#123;A&#125;</span> over
            <span class="math">(\mathbb&#123;F&#125;_q^t)^2</span> such
            that
            <span class="math">\&#123;(x, \mathcal&#123;F&#125;(x)) \mid \forall x \in \mathbb&#123;F&#125;_q^t\&#125; = \&#123;\mathcal&#123;A&#125; \circ (x, \mathcal&#123;G&#125;(x)) \mid \forall x \in \mathbb&#123;F&#125;_q^t\&#125;</span>.
          </p>
        </div>
      </div>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Rank-1 Constraint Satisfaction Systems (R1CS)
      </h3>
      <p class="text-gray-300">
        Many proof systems (e.g., Groth16, Ligero, Aurora,
        Bulletproofs) require translating the circuit into an R1CS,
        with Groth16 being the fastest proof system with the smallest
        proofs to date. An R1CS is a set of
        <span class="math">\eta</span> equations (constraints) on the
        variables
        <span class="math">a_0, \ldots, a_m \in \mathbb&#123;F&#125;_q</span>
        (with <span class="math">a_0 = 1</span>) such that
      </p>
      <div class="math-block">
        \forall j \in \&#123;0, 1, \dots, \eta - 1\&#125;: \quad \left(\sum_i u_&#123;i,j&#125; \cdot a_i\right) \cdot \left(\sum_i v_&#123;i,j&#125; \cdot a_i\right) = \left(\sum_i w_&#123;i,j&#125; \cdot a_i\right)
      </div>
      <p class="text-gray-300">
        In R1CS constraints, every statement needs to be translated
        into multiplications of linear combinations of the witness
        variables. Linear operations can be embedded into subsequent
        constraints and do not require additional constraints.
      </p>
      <p class="text-gray-300">
        <strong>Cost Metric.</strong> The number of R1CS constraints,
        i.e., the minimum number of nonlinear operations of linear
        combinations of witness variables required to fully represent
        any equivalent relation between the input and its output.
      </p>

      <h3 id="sec-2.4" class="text-xl font-semibold mt-8 mb-3">
        2.4 Plonk Arithmetization
      </h3>
      <p class="text-gray-300">
        Plonk is a zk-SNARK which does not use R1CS constraints. Its
        arithmetization is based on Plonk gates with constraints of
        the form
      </p>
      <div class="math-block">
        q_&#123;L_i&#125; \cdot a_&#123;L_i&#125; + q_&#123;R_i&#125; \cdot a_&#123;R_i&#125; + q_&#123;O_i&#125; \cdot a_&#123;O_i&#125; + q_&#123;M_i&#125; \cdot (a_&#123;L_i&#125; \cdot a_&#123;R_i&#125;) + q_&#123;C_i&#125; = 0
      </div>
      <p class="text-gray-300">
        Using this equation, one can either describe a 2-fan-in
        addition (setting
        <span class="math">q_&#123;M,i&#125; = 0</span>) or a 2-fan-in
        multiplication (setting
        <span class="math">q_&#123;L,i&#125; = q_&#123;R,i&#125; = 0</span>).
        Contrary to R1CS constraints, additions cannot be embedded
        into subsequent multiplication constraints anymore and require
        separate Plonk gates.
      </p>
      <p class="text-gray-300">
        <strong>Cost Metric.</strong> The number of Plonk gates, i.e.,
        the minimum number of 2-fan-in additions and multiplications
        of witness variables required to fully represent any equivalent
        relation between the input and its output.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. THE ROAD TO GRIFFIN                                       -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. The Road to Griffin</h2>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 Related Work: SPN Schemes for ZK Applications
      </h3>
      <p class="text-gray-300">
        <strong>Poseidon and <em>Rescue</em>.</strong> Two well-known
        examples of SPN schemes for ZK settings. Their round function
        is defined via an MDS matrix and S-box layer where all
        S-boxes operate over
        <span class="math">\mathbb&#123;F&#125;_p</span> independently.
        An important advantage is that techniques such as the wide
        trail design strategy have been developed to study their
        security. At the same time, a strong limitation on the choice
        of the S-box arises: the designer is restricted to S-box
        functions of degree
        <span class="math">d \geq 3</span>. Quadratic nonlinear
        components cannot be used, leading to performance limitations.
      </p>
      <p class="text-gray-300">
        <strong>Neptune and Anemoi.</strong> One way to gain more
        flexibility regarding the degree is by considering S-boxes
        over
        <span class="math">\mathbb&#123;F&#125;_p^n</span> for
        <span class="math">n \geq 2</span>. Neptune is inspired by
        Poseidon but replaces the power maps in external rounds with
        quadratic Lai-Massey functions. Anemoi uses S-boxes based on a
        particular Feistel scheme called Flystel.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Non-SPN Schemes: From Feistel to Horst
      </h3>
      <p class="text-gray-300">
        Given functions
        <span class="math">\tilde&#123;F&#125;_0, \tilde&#123;F&#125;_1, \ldots, \tilde&#123;F&#125;_&#123;t-2&#125;</span>
        over
        <span class="math">\mathbb&#123;F&#125;_p</span>, the authors
        consider generalized Feistel schemes: Type-I, Type-II, and
        Type-III. An example of a ZK-friendly generalized Feistel
        scheme is GMiMC (broken in [BCD+20]). Practical tests suggest
        these schemes may not provide the expected security level
        against some algebraic attacks. To solve this, the authors
        propose the following.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3 (Horst Scheme)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">G : \mathbb&#123;F&#125;_q \to \mathbb&#123;F&#125;_q \setminus \&#123;0\&#125;</span>
            and
            <span class="math">F : \mathbb&#123;F&#125;_q \to \mathbb&#123;F&#125;_q</span>.
            The Horst scheme over
            <span class="math">\mathbb&#123;F&#125;_q^2</span> is defined
            as
          </p>
          <div class="math-block">
            (y, x) \mapsto (x,\; y \cdot G(x) + F(x))
          </div>
          <p class="text-gray-300">
            In particular:
          </p>
          <ul class="list-disc list-inside text-gray-300 ml-4">
            <li>
              <strong>Feistel</strong> or
              <strong><span class="math">\text&#123;Horst&#125;^+</span></strong> if
              <span class="math">G</span> is identically equal to 1.
            </li>
            <li>
              <strong><span class="math">\text&#123;Horst&#125;^\times</span></strong> if
              <span class="math">F(x) = \alpha \cdot G(x) + \beta</span>
              for certain
              <span class="math">\alpha, \beta \in \mathbb&#123;F&#125;_q</span>.
            </li>
          </ul>
          <p class="text-gray-300">
            Since
            <span class="math">\mathbb&#123;F&#125;_q</span> is a field
            and
            <span class="math">G(x) \neq 0</span> for each
            <span class="math">x \in \mathbb&#123;F&#125;_q</span>,
            Horst is invertible.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Initial Security Considerations.</strong> It is always
        possible to set up a distinguisher for one (trivial) and two
        rounds of the Horst scheme. The problems of setting up
        distinguishers for more than 2 rounds of Horst and for more
        than 6 rounds of Feistel or <span class="math">\text&#123;Horst&#125;^\times</span> are open
        for future research.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 4 (Generalized Horst)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">t \geq 2</span>. For each
            <span class="math">i \in \&#123;1, 2, \ldots, t-1\&#125;</span>,
            let
            <span class="math">G_i : \mathbb&#123;F&#125;_q^i \to \mathbb&#123;F&#125;_q \setminus \&#123;0\&#125;</span>
            and
            <span class="math">F_i : \mathbb&#123;F&#125;_q^i \to \mathbb&#123;F&#125;_q</span>.
            The Generalized Horst scheme over
            <span class="math">\mathbb&#123;F&#125;_q^t</span> is
            <span class="math">x = (x_0, \ldots, x_&#123;t-1&#125;) \mapsto y = (y_0, \ldots, y_&#123;t-1&#125;)</span>,
            where
          </p>
          <div class="math-block">
            y_i := \begin&#123;cases&#125; x_&#123;i+1&#125; \cdot G_&#123;i+1&#125;(x_0, x_1, \dots, x_i) + F_&#123;i+1&#125;(x_0, x_1, \dots, x_i) & \text&#123;if &#125; i \in \&#123;0, 1, \dots, t-2\&#125;, \\ x_0 & \text&#123;otherwise &#125; (i = t-1). \end&#123;cases&#125;
          </div>
        </div>
      </div>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8 mb-3">
        3.3 Constructing Nonzero Functions G
      </h3>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">G : \mathbb&#123;F&#125;_q \to \mathbb&#123;F&#125;_q</span>
            such that
            <span class="math">G'(x) := G(x) \cdot x</span> is a
            permutation over
            <span class="math">\mathbb&#123;F&#125;_q</span> and
            <span class="math">G(0) \neq 0</span>. Then,
            <span class="math">G(x) \neq 0</span> for each
            <span class="math">x \in \mathbb&#123;F&#125;_q</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        Let <span class="math">d \geq 3</span> be the smallest integer
        such that
        <span class="math">x \mapsto x^d</span> is invertible over
        <span class="math">\mathbb&#123;F&#125;_q</span>. Let
        <span class="math">\alpha \in \mathbb&#123;F&#125;_q \setminus \&#123;0\&#125;</span>.
        A concrete example of
        <span class="math">G</span> over
        <span class="math">\mathbb&#123;F&#125;_q</span> is
      </p>
      <div class="math-block">
        G(z) = \frac&#123;(z \pm \alpha)^d \mp \alpha^d&#125;&#123;z&#125; = \sum_&#123;i=1&#125;^d \binom&#123;d&#125;&#123;i&#125; z^&#123;i-1&#125; \cdot (\pm \alpha)^&#123;d-i&#125;
      </div>
      <p class="text-gray-300">
        <strong>Result for Prime Fields.</strong> In the case of a
        prime field
        <span class="math">\mathbb&#123;F&#125;_p</span> for
        <span class="math">p \geq 3</span>, one can exploit the fact
        that the quadratic map
        <span class="math">x \mapsto x^2</span> is not invertible
        over
        <span class="math">\mathbb&#123;F&#125;_p</span>. Let
        <span class="math">\alpha, \beta \in \mathbb&#123;F&#125;_p</span>
        such that
        <span class="math">\alpha^2 - 4\beta</span> is a quadratic
        nonresidue modulo
        <span class="math">p</span>. Then
        <span class="math">G(x) = x^2 + \alpha x + \beta</span>
        satisfies the required property.
      </p>

      <h3 id="sec-3.4" class="text-xl font-semibold mt-8 mb-3">
        3.4 Combining Horst with a Rescue-like SPN: The Birth of
        Griffin
      </h3>
      <p class="text-gray-300">
        <strong>Nonlinear Layer.</strong> By combining a
        <em>Fluid</em>-SPN scheme and Horst in a single nonlinear
        layer, the authors obtain
        <span class="math">S : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
        defined as
        <span class="math">S(\cdot) = S'' \circ S'(\cdot)</span>,
        where
      </p>
      <div class="math-block">
        (S'(x_0, \dots, x_&#123;t-1&#125;))_i = \begin&#123;cases&#125; x_0^&#123;1/d&#125; & \text&#123;if &#125; i = 0, \\ x_1^d & \text&#123;if &#125; i = 1, \\ x_i & \text&#123;otherwise,&#125; \end&#123;cases&#125;
      </div>
      <div class="math-block">
        (S''(x_0, \dots, x_&#123;t-1&#125;))_i = \begin&#123;cases&#125; x_i & \text&#123;if &#125; i \in \&#123;0, 1\&#125;, \\ x_i \cdot \left( z_&#123;i-1&#125;^2 + \alpha_i z_&#123;i-1&#125; + \beta_i \right) & \text&#123;otherwise,&#125; \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\alpha_i^2 - 4\beta_i</span> is a
        quadratic nonresidue and
        <span class="math">z_i</span> is a linear combination of the
        inputs and outputs.
      </p>
      <p class="text-gray-300">
        <strong>Number of Multiplications.</strong> The number of
        multiplications per round for the verification process is
      </p>
      <div class="math-block">
        2t + 2(\text&#123;hw&#125;(d) + \lfloor \log_2(d) \rfloor - 3) \in \mathcal&#123;O&#125;(t)
      </div>
      <p class="text-gray-300">
        Hence, for large
        <span class="math">t</span>, the cost of this design is
        almost independent of the value of
        <span class="math">d</span>.
      </p>

      <!-- Table 1: Multiplications per round comparison -->
      <div class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 1.</strong> Number of multiplications per
          round for the verification process of several ZK-friendly
          hash functions (instantiated with
          <span class="math">d = 5</span>) over
          <span class="math">\mathbb&#123;F&#125;_p^t</span>.
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Griffin</th>
              <th class="text-left py-2 pr-4">Anemoi</th>
              <th class="text-left py-2 pr-4">Poseidon*</th>
              <th class="text-left py-2">Rescue</th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                <span class="math">2t + 2</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">2.5t</span>
              </td>
              <td class="py-2 pr-4">
                <span class="math">3t</span>
              </td>
              <td class="py-2">
                <span class="math">6t</span>
              </td>
            </tr>
          </tbody>
        </table>
        <p class="text-xs text-gray-500 mt-1">
          * The number given for Poseidon refers to the external full
          rounds.
        </p>
      </div>

      <p class="text-gray-300">
        <strong>Linear Layer.</strong> For
        <span class="math">t \in \&#123;3, 4\&#125;</span>, MDS
        matrices are used. For
        <span class="math">t > 4</span>, a more efficient linear
        layer is proposed, inspired by the linear layer of AES. The
        matrix can be decomposed as the multiplication of two matrices
        that both provide full diffusion, achieving this property in
        each state word after a single round. The linear layer only
        requires around
        <span class="math">5t \in \mathcal&#123;O&#125;(t)</span>
        operations.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. MODES OF OPERATION                                        -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4. Modes of Operation</h2>
      <p class="text-gray-300">
        The authors build a hash function with the sponge construction
        and a compression function with the feed-forward operation and
        truncation. Both use the
        Griffin-<span class="math">\pi</span> permutation.
      </p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8 mb-3">
        4.1 Sponge Hash Functions
      </h3>
      <p class="text-gray-300">
        The sponge construction builds upon an internal permutation
        and can be used to achieve various goals such as encryption,
        authentication, and hashing. The state size is split into
        <span class="math">t = r + c</span>, where
        <span class="math">r</span> and
        <span class="math">c</span> denote the number of elements in
        the rate and capacity part, respectively.
      </p>
      <p class="text-gray-300">
        <strong>Security.</strong> If the inner permutation resembles
        a random one, the sponge construction is indifferentiable from
        a random oracle up to around
        <span class="math">p^&#123;c/2&#125;</span> queries. To provide
        <span class="math">\kappa</span> bits of security,
        <span class="math">c \geq \lceil 2\kappa \cdot \log_p(2) \rceil</span>.
      </p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8 mb-3">
        4.2 Compression Functions
      </h3>
      <p class="text-gray-300">
        Let <span class="math">p \geq 2</span> be a prime and let
        <span class="math">1 \leq n &lt; t</span>. A cryptographic
        compression function
        <span class="math">\mathcal&#123;C&#125; : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^n</span>
        takes
        <span class="math">t</span>-element inputs and compresses
        them to
        <span class="math">n</span>-element outputs. One way to set
        up a compression function via a permutation is to combine the
        truncation function with the feed-forward operation:
      </p>
      <div class="math-block">
        x \in \mathbb&#123;F&#125;_p^t \mapsto \mathcal&#123;C&#125;(x) := \text&#123;Tr&#125;_n(\mathcal&#123;P&#125;(x) + x) \in \mathbb&#123;F&#125;_p^n
      </div>
      <p class="text-gray-300">
        where
        <span class="math">\mathcal&#123;P&#125;</span> is a permutation
        over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> and
        <span class="math">\text&#123;Tr&#125;_n</span> yields the
        first
        <span class="math">n</span> elements.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. GRIFFIN AND GRIFFIN-PI                                     -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. Griffin and
        Griffin-<span class="math">\pi</span>
      </h2>
      <p class="text-gray-300">
        Griffin-Sponge and Griffin-Compression are respectively a
        sponge hash function and a compression function over
        <span class="math">\mathbb&#123;F&#125;_p^t</span> instantiated
        with the permutation
        Griffin-<span class="math">\pi</span>, where
        <span class="math">p > 2^&#123;63&#125;</span> for a prime
        <span class="math">p</span> and
        <span class="math">t \in \&#123;3, 4t'\&#125;</span> for a
        positive integer
        <span class="math">t' \in \&#123;1, 2, \ldots, 6\&#125;</span>,
        i.e.,
        <span class="math">t</span> is either 3 or a multiple of 4.
        The security level is
        <span class="math">\kappa</span> bits, where
        <span class="math">80 \leq \kappa \leq \min\&#123;256, \lfloor \log_2(p) \cdot t/3 \rfloor\&#125;</span>.
        It is assumed that there exists
        <span class="math">d \in \&#123;3, 5, 7, 11\&#125;</span> such
        that
        <span class="math">\gcd(d, p - 1) = 1</span>.
      </p>

      <h3 id="sec-5.1" class="text-xl font-semibold mt-8 mb-3">
        5.1 Specification of
        Griffin-<span class="math">\pi</span>
      </h3>
      <p class="text-gray-300">
        The Griffin-<span class="math">\pi</span> permutation
        <span class="math">\mathcal&#123;G&#125;^\pi : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
        is defined by
      </p>
      <div class="math-block">
        \mathcal&#123;G&#125;^\pi(\cdot) := \mathcal&#123;F&#125;_&#123;R-1&#125; \circ \cdots \circ \mathcal&#123;F&#125;_1 \circ \mathcal&#123;F&#125;_0(M \times \cdot)
      </div>
      <p class="text-gray-300">
        where
        <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;t \times t&#125;</span>
        is an invertible matrix and
        <span class="math">\mathcal&#123;F&#125;_i(\cdot) = c^&#123;(i)&#125; + M \times S(\cdot)</span>
        for a round constant
        <span class="math">c^&#123;(i)&#125; \in \mathbb&#123;F&#125;_p^t</span>
        and nonlinear layer
        <span class="math">S</span>.
      </p>
      <p class="text-gray-300">
        <strong>The Nonlinear Layer S.</strong> Let
        <span class="math">d \in \&#123;3, 5, 7, 11\&#125;</span> be the
        smallest integer such that
        <span class="math">\gcd(d, p-1) = 1</span>. Let
        <span class="math">(\alpha_i, \beta_i) \in \mathbb&#123;F&#125;_p^2 \setminus \&#123;(0,0)\&#125;</span>
        be pairwise distinct such that
        <span class="math">\alpha_i^2 - 4\beta_i</span> is a
        quadratic nonresidue modulo
        <span class="math">p</span> for
        <span class="math">2 \leq i \leq t-1</span>. The nonlinear
        layer
        <span class="math">S(x_0, \ldots, x_&#123;t-1&#125;) = y_0 \| \cdots \| y_&#123;t-1&#125;</span>
        is then defined by
      </p>
      <div class="math-block">
        y_i = \begin&#123;cases&#125; x_0^&#123;1/d&#125; & \text&#123;if &#125; i = 0, \\ x_1^d & \text&#123;if &#125; i = 1, \\ x_2 \cdot \left( (L_i(y_0, y_1, 0))^2 + \alpha_2 \cdot L_i(y_0, y_1, 0) + \beta_2 \right) & \text&#123;if &#125; i = 2, \\ x_i \cdot \left( (L_i(y_0, y_1, x_&#123;i-1&#125;))^2 + \alpha_i \cdot L_i(y_0, y_1, x_&#123;i-1&#125;) + \beta_i \right) & \text&#123;otherwise,&#125; \end&#123;cases&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">y_0 = x_0^d</span>,
        <span class="math">y_1 = x_1^&#123;1/d&#125;</span>, and
        <span class="math">L_i(z_0, z_1, z_2) = \gamma_i \cdot z_0 + z_1 + z_2</span>
        for arbitrary pairwise distinct
        <span class="math">\gamma_i \in \mathbb&#123;F&#125;_p \setminus \&#123;0\&#125;</span>.
      </p>
      <p class="text-gray-300">
        <strong>The Linear Layer M.</strong> For
        <span class="math">t \in \&#123;3, 4\&#125;</span>, the
        matrices must be MDS:
      </p>
      <div class="math-block">
        M_3 = \begin&#123;pmatrix&#125; 2 & 1 & 1 \\ 1 & 2 & 1 \\ 1 & 1 & 2 \end&#123;pmatrix&#125;, \quad M_4 = \begin&#123;pmatrix&#125; 5 & 7 & 1 & 3 \\ 4 & 6 & 1 & 1 \\ 1 & 3 & 5 & 7 \\ 1 & 1 & 4 & 6 \end&#123;pmatrix&#125;
      </div>
      <p class="text-gray-300">
        For
        <span class="math">t = 4t' \geq 8</span>,
        <span class="math">M</span> is defined as
      </p>
      <div class="math-block">
        M = M'' \times M' = \begin&#123;pmatrix&#125; 2 \cdot M_4 & M_4 & \dots & M_4 \\ M_4 & 2 \cdot M_4 & \dots & M_4 \\ \vdots & \vdots & \ddots & \vdots \\ M_4 & M_4 & \dots & 2 \cdot M_4 \end&#123;pmatrix&#125;
      </div>
      <p class="text-gray-300">
        where
        <span class="math">M' = \text&#123;diag&#125;(M_4, M_4, \dots, M_4)</span>
        and
        <span class="math">M'' = \text&#123;circ&#125;(2 \cdot I, I, \dots, I)</span>.
      </p>
      <p class="text-gray-300">
        <strong>Choosing the Constants.</strong> A pseudo-random number
        generator based on SHAKE is used to choose the round constants
        and the constants
        <span class="math">(\alpha_2, \beta_2)</span> that define
        the nonlinear layer. The other constants are defined as
        <span class="math">\alpha_i = (i-1) \cdot \alpha_2</span> and
        <span class="math">\beta_i = (i-1)^2 \cdot \beta_2</span>.
      </p>

      <h3 id="sec-5.2" class="text-xl font-semibold mt-8 mb-3">
        5.2 Number of Rounds of
        Griffin-<span class="math">\pi</span>
      </h3>
      <p class="text-gray-300">
        For
        <span class="math">\kappa</span>-bit security, the round
        number
        <span class="math">R</span> including a margin of 20% must
        satisfy
      </p>
      <div class="math-block">
        R \geq \left\lceil 1.2 \cdot \max \left\&#123; 6, \left\lceil \frac&#123;2.5 \cdot \kappa&#125;&#123;\log_2(p) - \log_2(d-1)&#125; \right\rceil, 1 + R_&#123;\text&#123;GB&#125;&#125; \right\&#125; \right\rceil
      </div>

      <!-- Table 2: Instances of Griffin-pi -->
      <div class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 2.</strong> Instances of
          Griffin-<span class="math">\pi</span> with security margin
          (<span class="math">d \in \&#123;3, 5\&#125;</span>,
          <span class="math">\kappa = 128</span>,
          <span class="math">p \approx 2^&#123;256&#125;</span>).
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4"></th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 3</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 4</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 8</span>
              </th>
              <th class="text-left py-2">
                <span class="math">t \in \&#123;12,16,20,24\&#125;</span>
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                <span class="math">R\;(d=3)</span>
              </td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">11</td>
              <td class="py-2">10</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">
                <span class="math">R\;(d=5)</span>
              </td>
              <td class="py-2 pr-4">14</td>
              <td class="py-2 pr-4">11</td>
              <td class="py-2 pr-4">9</td>
              <td class="py-2">9</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 6. SECURITY                                                  -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Security of Griffin and
        Griffin-<span class="math">\pi</span>
      </h2>
      <p class="text-gray-300">
        The authors aim for
        Griffin-<span class="math">\pi</span> instances that prevent
        attacks on the hash and compression function. Distinguishers
        on Griffin-<span class="math">\pi</span> that cannot be
        exploited for an attack on the entire construction (e.g., zero
        sum partitions) are not taken into account.
      </p>

      <h3 id="sec-6.1" class="text-xl font-semibold mt-8 mb-3">
        6.1 Statistical Attacks on
        Griffin-<span class="math">\pi</span>
      </h3>
      <p class="text-gray-300">
        The best statistical attacks against
        Griffin-<span class="math">\pi</span> include the differential
        and the rebound attack. The security analysis is supported by
        dedicated automatic MILP tools.
      </p>
      <p class="text-gray-300">
        <strong>Differential Cryptanalysis.</strong> Given pairs of
        inputs with fixed input differences, differential cryptanalysis
        considers the probability distribution of the corresponding
        output differences. The differential probability for
        <span class="math">\Delta_O</span> given
        <span class="math">\Delta_I</span> is
      </p>
      <div class="math-block">
        \text&#123;Prob&#125;(\Delta_I \to \Delta_O) = \frac&#123;|\&#123;x \in \mathbb&#123;F&#125;_p^t \mid \mathcal&#123;P&#125;(x + \Delta_I) - \mathcal&#123;P&#125;(x) = \Delta_O\&#125;|&#125;&#123;p^t&#125;
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">d \geq 3</span> be an integer such
            that
            <span class="math">\gcd(d, p-1) = 1</span>. Then,
            <span class="math">\text&#123;DP&#125;_&#123;\max&#125;(x \mapsto x^d) = \text&#123;DP&#125;_&#123;\max&#125;(x \mapsto x^&#123;1/d&#125;) = (\min\&#123;d, 1/d\&#125; - 1)/p</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 3
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">\alpha, \beta \in \mathbb&#123;F&#125;_p \setminus \&#123;0\&#125;</span>
            such that
            <span class="math">\alpha^2 - 4\beta</span> is a quadratic
            nonresidue modulo
            <span class="math">p</span>. Let
            <span class="math">F : \mathbb&#123;F&#125;_p^2 \to \mathbb&#123;F&#125;_p</span>
            be defined as
            <span class="math">F(x, \ell) = x \cdot (\ell^2 + \alpha \cdot \ell + \beta)</span>.
            Given an input difference
            <span class="math">\Delta_I = (\delta_x, \delta_\ell) \neq (0,0)</span>
            and an output difference
            <span class="math">\Delta_O</span>, the maximum
            differential probability of
            <span class="math">F</span> is bounded by
            <span class="math">2/p</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The number of rounds sufficient to achieve a probability
        smaller than
        <span class="math">2^&#123;-2.5\kappa&#125;</span> over the
        entire permutation is
      </p>
      <div class="math-block">
        R \geq \frac&#123;2.5\kappa&#125;&#123;\log_2(p) - \log_2(d-1)&#125;
      </div>

      <div class="formal-block formal-block-proposition">
        <div class="formal-block-title text-violet-400">
          Proposition 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">t = 4t' \in \&#123;8, 12, \ldots, 24\&#125;</span>.
            The branch number of the matrix
            <span class="math">M \in \mathbb&#123;F&#125;_p^&#123;t \times t&#125;</span>
            is
            <span class="math">t' + 4</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Rebound Attacks.</strong> The goal is to find two
        (input, output) pairs such that the two inputs and
        corresponding outputs satisfy certain truncated differences.
        The authors claim that 6 rounds are sufficient against this
        attack, supported by a dedicated MILP tool that shows no
        feasible rebound attack can be mounted for 3 or more
        Griffin-<span class="math">\pi</span> rounds.
      </p>

      <h3 id="sec-6.2" class="text-xl font-semibold mt-8 mb-3">
        6.2 Algebraic Attacks
      </h3>
      <p class="text-gray-300">
        Algebraic attacks exploit weak algebraic properties of the
        design. The authors analyze interpolation attacks and Grobner
        basis attacks as the most efficient ones against Griffin.
      </p>
      <p class="text-gray-300">
        <strong>Interpolation Attacks.</strong> The cost of the attack
        grows with the number of different monomials in the
        interpolation polynomial. In this case, 3 rounds are
        sufficient to reach the maximum degree, and
        <span class="math">2 \cdot 3 = 6</span> rounds are conjectured
        sufficient to prevent interpolation attacks and their variants.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 5 (CICO Problem)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The invertible function
            <span class="math">\mathcal&#123;P&#125; : \mathbb&#123;F&#125;_p^t \to \mathbb&#123;F&#125;_p^t</span>
            is
            <span class="math">\kappa</span>-secure against the CICO
            <span class="math">(t_1, t_2)</span>-problem (where
            <span class="math">0 &lt; t_1, t_2 &lt; t</span> and
            <span class="math">t_1 + t_2 = t</span>) if no algorithm
            with expected complexity smaller than
            <span class="math">2^\kappa</span> finds
            <span class="math">I_2 \in \mathbb&#123;F&#125;_p^&#123;t_2&#125;</span>
            and
            <span class="math">O_2 \in \mathbb&#123;F&#125;_p^&#123;t_1&#125;</span>
            for given
            <span class="math">I_1 \in \mathbb&#123;F&#125;_p^&#123;t_1&#125;</span>
            and
            <span class="math">O_1 \in \mathbb&#123;F&#125;_p^&#123;t_2&#125;</span>
            such that
            <span class="math">\mathcal&#123;P&#125;(I_1 \| I_2) = O_1 \| O_2</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>Grobner Basis Attacks.</strong> Two strategies are
        considered. The first introduces intermediate variables for all
        state words per round, yielding a complexity requiring
      </p>
      <div class="math-block">
        \log_2 \binom&#123;dR + 1 + tR&#125;&#123;1 + tR&#125; \geq \frac&#123;\kappa&#125;&#123;2&#125;
      </div>
      <p class="text-gray-300">
        The second strategy introduces only a single intermediate
        variable per round, yielding
      </p>
      <div class="math-block">
        \log_2 \binom&#123;d^R + 1 + R&#125;&#123;1 + R&#125; \geq \frac&#123;\kappa&#125;&#123;2&#125;
      </div>

      <h3 id="sec-6.3" class="text-xl font-semibold mt-8 mb-3">
        6.3 Feistel versus Horst: Security of Griffin Instantiated
        with Feistel
      </h3>
      <p class="text-gray-300">
        The authors consider the security of Griffin instantiated with
        a classical Feistel scheme. In the first Grobner basis
        strategy with intermediate variables for the whole state, the
        practical degree of regularity was constant regardless of the
        number of rounds for
        <span class="math">R \geq 2</span>. The designers were able
        to compute Grobner bases in practice for the round numbers
        proposed for Griffin (with Horst).
      </p>
      <p class="text-gray-300">
        For the second strategy, the maximum degree in each round is
        reduced due to the missing multiplication, and faster Grobner
        basis computations were observed for the Feistel version
        (about a factor of 8 between the two versions). This suggests
        that using the multiplication instead of the addition is
        better when aiming for security and efficiency.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 7. PERFORMANCE EVALUATION                                    -->
    <!-- ============================================================ -->

    <section id="sec-7" class="mb-10">
      <h2 class="text-2xl font-bold">7. Performance Evaluation</h2>
      <p class="text-gray-300">
        The authors evaluate the performance of Griffin and compare it
        to Poseidon, Rescue-Prime, <span class="math">\text&#123;GMiMC&#125;_&#123;\text&#123;erf&#125;&#125;</span>, Grendel,
        Neptune, and Anemoi. All hash functions are instantiated to
        provide 128 bits of security. Benchmarks were obtained on
        Linux using an Intel Xeon E5-2699 v4 CPU (2.2 GHz) using
        stable Rust version 1.59.
      </p>

      <h3 id="sec-7.1" class="text-xl font-semibold mt-8 mb-3">
        7.1 Plain Performance
      </h3>
      <p class="text-gray-300">
        The plain performance is compared using the scalar fields of
        the commonly used BLS12 and BN254 elliptic curves (both using
        <span class="math">d = 5</span>). For
        <span class="math">t \leq 16</span>, the fastest permutation
        is <span class="math">\text&#123;GMiMC&#125;_&#123;\text&#123;erf&#125;&#125;</span>. However, as shown later, it has the
        worst performance in SNARKs and STARKs. Rescue-Prime and
        Grendel have the worst plain performance due to having
        <span class="math">t</span> high-degree
        <span class="math">x^&#123;1/d&#125;</span> or Legendre symbol
        evaluations per round.
      </p>
      <p class="text-gray-300">
        Griffin also uses
        <span class="math">x^&#123;1/d&#125;</span>, but only once per
        round, so it scales significantly better with larger
        <span class="math">t</span>. For small
        <span class="math">t</span>, Griffin is slower than Poseidon
        and Neptune, but the differences get smaller for larger
        <span class="math">t</span>, until Griffin is faster if
        <span class="math">t \geq 16</span>.
      </p>

      <h3 id="sec-7.2" class="text-xl font-semibold mt-8 mb-3">
        7.2 R1CS-Based SNARKs with Griffin
      </h3>
      <p class="text-gray-300">
        Describing Griffin as an R1CS system is straightforward. The
        total number of R1CS constraints for the whole
        Griffin-<span class="math">\pi</span> permutation is
      </p>
      <div class="math-block">
        (2 \cdot \lfloor \log_2(d) \rfloor + 2 \cdot \text&#123;hw&#125;(d) + 2 \cdot t - 6) \cdot R
      </div>
      <p class="text-gray-300">
        i.e.,
        <span class="math">2 \cdot R \cdot t</span> R1CS constraints
        if <span class="math">d = 3</span> and
        <span class="math">R \cdot (2t + 2)</span> if
        <span class="math">d = 5</span>.
      </p>
      <p class="text-gray-300">
        Griffin requires the smallest number of R1CS constraints to
        prove the knowledge of a preimage of a hash for several state
        sizes. Even for arities where Griffin requires a larger state
        size (since it is defined for
        <span class="math">t \in \&#123;3, 4t'\&#125;</span>), the
        approach results in significantly fewer R1CS constraints and
        smaller proving times compared to other hash functions.
        Concretely, using Griffin results in nearly half of the
        required constraints compared to Poseidon and
        <em>Rescue</em>, and two thirds compared to Neptune.
      </p>

      <h3 id="sec-7.3" class="text-xl font-semibold mt-8 mb-3">
        7.3 Plonk Performance of Griffin
      </h3>
      <p class="text-gray-300">
        Describing Griffin with Plonk gates: each affine layer usually
        requires
        <span class="math">t \cdot (t-1)</span> addition gates, but
        due to the specific structure of the linear layers, the number
        is reduced significantly. Griffin requires
      </p>
      <div class="math-block">
        (R+1) \cdot \#\text&#123;mat&#125; + R \cdot (2 \cdot \lfloor \log_2(d) \rfloor + 2 \cdot \text&#123;hw&#125;(d) + 4t - 11)
      </div>
      <p class="text-gray-300">
        Plonk gates, i.e.,
        <span class="math">(R+1) \cdot \#\text&#123;mat&#125; + R \cdot (4t - 5)</span>
        gates if <span class="math">d = 3</span> and
        <span class="math">(R+1) \cdot \#\text&#123;mat&#125; + R \cdot (4t - 3)</span>
        gates if <span class="math">d = 5</span>.
      </p>
      <p class="text-gray-300">
        Compared to Poseidon and <em>Rescue</em>, Griffin always
        requires the smallest number of Plonk gates due to having a
        small number of multiplications and rounds. Only Anemoi
        requires a smaller number of gates for
        <span class="math">d = 3</span> and small state sizes, but
        Griffin's linear layer becomes more efficient with larger
        state sizes (around
        <span class="math">t \geq 12</span>).
      </p>

      <!-- Table 5: Plonk gates comparison (excerpt for d=5) -->
      <div class="overflow-x-auto my-6">
        <p class="text-sm text-gray-400 mb-2">
          <strong>Table 5.</strong> Number of Plonk gates for
          <span class="math">d = 5</span> with a 256-bit prime field
          (2-fan-in / 3-fan-in addition gates).
        </p>
        <table class="w-full text-sm">
          <thead>
            <tr class="border-b border-gray-700">
              <th class="text-left py-2 pr-4">Hash</th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 3</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 4</span>
              </th>
              <th class="text-left py-2 pr-4">
                <span class="math">t = 8</span>
              </th>
              <th class="text-left py-2">
                <span class="math">t = 12</span>
              </th>
            </tr>
          </thead>
          <tbody class="text-gray-300">
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Griffin</td>
              <td class="py-2 pr-4">201 / 171</td>
              <td class="py-2 pr-4">228 / 193</td>
              <td class="py-2 pr-4">492 / 407</td>
              <td class="py-2">836 / 655</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Rescue-Prime</td>
              <td class="py-2 pr-4">420 / 336</td>
              <td class="py-2 pr-4">528 / 440</td>
              <td class="py-2 pr-4">1280 / 896</td>
              <td class="py-2">2688 / 1728</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Poseidon</td>
              <td class="py-2 pr-4">518 / 379</td>
              <td class="py-2 pr-4">708 / 560</td>
              <td class="py-2 pr-4">1665 / 1107</td>
              <td class="py-2">2901 / 1791</td>
            </tr>
            <tr class="border-b border-gray-800">
              <td class="py-2 pr-4">Anemoi</td>
              <td class="py-2 pr-4">&mdash;</td>
              <td class="py-2 pr-4">284 / 228</td>
              <td class="py-2 pr-4">592 / 444</td>
              <td class="py-2">1140 / 756</td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 8. ACKNOWLEDGMENTS                                           -->
    <!-- ============================================================ -->

    <section id="sec-8" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgments</h2>
      <p class="text-gray-300">
        The authors thank all reviewers for their suggestions. Lorenzo
        Grassi is supported by the German Research Foundation (DFG)
        within the framework of the Excellence Strategy of the Federal
        Government and the States &ndash; EXC 2092 CaSa &ndash;
        39078197. Roman Walch is supported by the "DDAI" COMET Module.
        Yonglin Hao is supported by National Natural Science
        Foundation of China (Grant No. 62002024). Qingju Wang was
        funded, in part, by Huawei Technologies Co., Ltd.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX A: STARKs WITH GRIFFIN                              -->
    <!-- ============================================================ -->

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix A. STARKs with Griffin
      </h2>
      <p class="text-gray-300">
        <strong>A.1 Algebraic Intermediate Representation (AIR).</strong>
        zk-STARKs require translating the computational problem into
        an algebraic intermediate representation (AIR). The AIR
        consists of a sequence of machine states (the algebraic
        execution trace (AET)) and multivariate polynomials describing
        the transition between states. The efficiency depends on
        <span class="math">w</span> (register width),
        <span class="math">T</span> (sequence length), and
        <span class="math">d_&#123;\max&#125;</span> (maximum polynomial
        degree).
      </p>
      <p class="text-gray-300">
        <strong>Cost Metric.</strong> Approximated as
        <span class="math">\mathcal&#123;O&#125;(d_&#123;\max&#125; \cdot T)</span>,
        i.e., the number of rounds times the degree of the round
        function representation.
      </p>
      <p class="text-gray-300">
        <strong>A.2 Relations Between SNARK and STARK Cost
        Metrics.</strong> While for HE it is important to minimize the
        multiplicative depth, for MPC it is crucial to minimize the
        total number of multiplications. In ZK proof systems, one must
        find an efficient equivalent representation minimizing the
        degree and/or the number of multiplications.
      </p>
      <p class="text-gray-300">
        <strong>A.3 STARK Performance of Griffin.</strong> For the AIR
        representation, the machine size
        <span class="math">w</span> equals the state size
        <span class="math">t</span>, and the maximum degree
        <span class="math">d_&#123;\max&#125;</span> equals
        <span class="math">d</span>. The AIR of Griffin is a
        straightforward translation and is easier to use in practice
        compared to Poseidon (which requires heavy precomputations)
        or <em>Rescue</em> (which needs a meet-in-the-middle
        approach).
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX B: SECURITY OF HORST SCHEMES                       -->
    <!-- ============================================================ -->

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix B. Security of Horst Schemes
      </h2>
      <p class="text-gray-300">
        The authors propose distinguishers for 3, 4, and 5 rounds of
        <span class="math">\text&#123;Horst&#125;^\times</span>, adapting analogous attacks on Feistel
        schemes by Patarin. Each round is defined as
      </p>
      <div class="math-block">
        (y, x) \mapsto (x, (y + \alpha_i) \cdot H(x) + \beta_i)
      </div>
      <p class="text-gray-300">
        <strong>3 Rounds.</strong> Consider inputs of the form
        <span class="math">(\hat&#123;y&#125;, x_i)</span> and
        corresponding outputs
        <span class="math">(z_i, w_i)</span>. The probability to have
        a collision of the form
        <span class="math">(z_i - \beta_1) \cdot x_j = (z_j - \beta_1) \cdot x_i</span>
        is around
        <span class="math">2/q</span> for <span class="math">\text&#123;Horst&#125;^\times</span>
        versus
        <span class="math">1/q</span> for a PRP.
      </p>
      <p class="text-gray-300">
        <strong>4 Rounds.</strong> The 3-round distinguisher is easily
        extended to 4 rounds by starting with inputs of the form
        <span class="math">(y_i, \hat&#123;y&#125;)</span> and reusing
        the previous distinguisher.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX C: PROOFS - DIFFERENTIAL CRYPTANALYSIS              -->
    <!-- ============================================================ -->

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix C. Proofs &ndash; Differential Cryptanalysis
      </h2>
      <p class="text-gray-300">
        <strong>C.1 Maximum Differential Probability of S.</strong>
        The proofs of Lemmas 2 and 3 are provided. For
        <span class="math">x \mapsto x^d</span>, the maximal number
        of solutions of
        <span class="math">(x + \delta_I)^d - x^d = \delta_O</span>
        is
        <span class="math">d - 1</span>, yielding
        <span class="math">\text&#123;DP&#125;_&#123;\max&#125; = (d-1)/p</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">\alpha, \beta \in \mathbb&#123;F&#125;_p \setminus \&#123;0\&#125;</span>
            such that
            <span class="math">\alpha^2 - 4\beta</span> is a quadratic
            nonresidue modulo
            <span class="math">p</span>. Let
            <span class="math">\ell, \delta_\ell \in \mathbb&#123;F&#125;_p</span>
            be arbitrary and fixed. The number of solutions of
            <span class="math">F_&#123;\ell + \delta_\ell&#125;(x + \delta_x) - F_\ell(x) = \delta_y</span>
            where
            <span class="math">F_z(x) = x \cdot (z^2 + \alpha z + \beta)</span>
            is 0, <span class="math">p</span>, or 1 depending on the
            particular case.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <strong>C.2 Branch Number of M.</strong>
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 6 (Hamming Weight)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            The Hamming weight of a vector, denoted as
            <span class="math">\text&#123;hw&#125;(\cdot)</span>, is
            defined as the number of nonzero elements.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            For <span class="math">2 \leq t' \leq 6</span>, the branch
            number of
            <span class="math">M</span> is
            <span class="math">\#b(M) = t' + 4</span>.
          </p>
        </div>
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX D: MILP TOOL FOR REBOUND ATTACKS                    -->
    <!-- ============================================================ -->

    <section id="app-d" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix D. Dedicated MILP Tool for Rebound Attacks on
        Griffin-<span class="math">\pi</span>
      </h2>
      <p class="text-gray-300">
        A dedicated mixed integer linear programming (MILP) tool is
        constructed to verify the results of rebound attacks. The core
        of the tool captures the truncated differential propagation of
        Griffin-<span class="math">\pi</span>.
      </p>
      <p class="text-gray-300">
        <strong>MILP Models for Linear Combinations.</strong> For a
        linear step
        <span class="math">z = x + y</span>, the truncated
        differential propagation rule is captured by MILP constraints.
      </p>
      <p class="text-gray-300">
        <strong>Word Conditions.</strong> In rebound attacks,
        complexities are decided by the number of word conditions
        imposed by both nonlinear and linear operations. Word
        conditions in the inbound phase can be satisfied for free via
        message modification, while those in the outbound phase have
        probability
        <span class="math">p^&#123;-1&#125;</span>.
      </p>
      <p class="text-gray-300">
        The results show that it is not possible to mount a rebound
        attack on more than 3 rounds of
        Griffin-<span class="math">\pi</span>. Equivalently, 4 rounds
        are sufficient for providing security against this attack.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX E: ALGEBRAIC ATTACKS - DETAILS                      -->
    <!-- ============================================================ -->

    <section id="app-e" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix E. Algebraic Attacks &ndash; Details
      </h2>
      <p class="text-gray-300">
        <strong>E.1 Density of
        Griffin-<span class="math">\pi</span>.</strong> Since the only
        high-degree nonlinear function is
        <span class="math">x \mapsto x^&#123;1/d&#125;</span>, the
        density is analyzed. In practice,
        <span class="math">x \mapsto x^&#123;1/d&#125;</span> provides
        almost full density over
        <span class="math">\mathbb&#123;F&#125;_p</span>. The
        polynomial representation of the construction is claimed to be
        dense after 3 rounds.
      </p>
      <p class="text-gray-300">
        <strong>E.2 Practical Results for Grobner Bases.</strong>
        Concrete data points for practical computations with
        intermediate variables show observed degrees of regularity
        <span class="math">\geq D_&#123;\text&#123;est&#125;&#125;^&#123;(1)&#125; = dR</span>.
        For partial intermediate variables, the degree of regularity
        is estimated as
        <span class="math">D_&#123;\text&#123;est&#125;&#125;^&#123;(2)&#125; = d^R</span>.
      </p>
      <p class="text-gray-300">
        <strong>E.3 Additional Strategies.</strong> Two further
        strategies are described: the full-round equation system
        (requiring
        <span class="math">\lceil \kappa / \log_2(p) \rceil + 1</span>
        rounds) and adding an intermediate variable for the degree-2
        function
        <span class="math">L</span>. Both are less efficient than the
        main strategies.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- APPENDIX F: SECURITY ANALYSIS - OTHER ATTACKS                -->
    <!-- ============================================================ -->

    <section id="app-f" class="mb-10">
      <h2 class="text-2xl font-bold">
        Appendix F. Security Analysis &ndash; Other Attacks
      </h2>
      <p class="text-gray-300">
        <strong>F.1 Other Statistical Attacks.</strong>
      </p>
      <p class="text-gray-300">
        <em>Linear Attack:</em> Due to the same analysis proposed for
        differential attacks, linear attacks pose no threat to Griffin.
      </p>
      <p class="text-gray-300">
        <em>Impossible Differential and Zero-correlation Attacks:</em>
        The difference of one word can affect the whole state by one
        round function call, so these attacks can hardly be mounted on
        3 or more rounds.
      </p>
      <p class="text-gray-300">
        <em>Boomerang Attack:</em> Differential trails with high
        probability are unlikely for more than 6 rounds, so the
        differential/rebound round numbers are sufficient.
      </p>
      <p class="text-gray-300">
        <em>Integral/Square, Multiple-of-n, and Mixture Differential
        Cryptanalysis:</em> These become quickly infeasible since the
        nonlinear layer
        <span class="math">S</span> is not aligned and the matrix
        <span class="math">M</span> provides full diffusion after a
        single round.
      </p>
      <p class="text-gray-300">
        <strong>F.2 Higher-Order Differentials and Zero-Sum
        Partitions.</strong>
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 7 (Zero-Sum Partition)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let
            <span class="math">\mathcal&#123;P&#125;</span> be a
            permutation over
            <span class="math">\mathbb&#123;F&#125;_q^t</span>. A
            zero-sum partition for
            <span class="math">\mathcal&#123;P&#125;</span> of size
            <span class="math">l &lt; t</span> is a collection of
            <span class="math">l</span> disjoint sets
            <span class="math">\&#123;X_1, \ldots, X_l\&#125;</span>
            such that they partition
            <span class="math">\mathbb&#123;F&#125;^t</span> and
            <span class="math">\sum_&#123;x \in X_i&#125; x = \sum_&#123;x \in X_i&#125; \mathcal&#123;P&#125;(x) = 0</span>
            for all <span class="math">i</span>.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        The authors explicitly state that they do not make claims
        about the security of Griffin against zero-sum partitions,
        motivated by the gap present in the literature between the
        number of rounds covered by zero-sum partitions and the number
        of rounds that can be broken via preimage or collision attacks.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside text-sm text-gray-400
        space-y-2 mt-4">
        <li>
          M. R. Albrecht, C. Cid, L. Grassi, D. Khovratovich,
          R. Luftenegger, C. Rechberger, and M. Schofnegger.
          "Algebraic Cryptanalysis of STARK-Friendly Designs:
          Application to MARVELlous and MiMC". ASIACRYPT 2019.
        </li>
        <li>
          M. R. Albrecht, L. Grassi, L. Perrin, S. Ramacher,
          C. Rechberger, D. Rotaru, A. Roy, and M. Schofnegger.
          "Feistel Structures for MPC, and More". ESORICS 2019.
          <a href="/papers/feistel-structures-mpc-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and
          T. Tiessen. "MiMC: Efficient Encryption and Cryptographic
          Hashing with Minimal Multiplicative Complexity".
          ASIACRYPT 2016.
        </li>
        <li>
          A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and
          A. Szepieniec. "Design of Symmetric-Key Primitives for
          Advanced Cryptographic Protocols".
          IACR Trans. Symmetric Cryptol. 2020.3.
        </li>
        <li>
          S. Ames, C. Hazay, Y. Ishai, and M. Venkitasubramaniam.
          "Ligero: Lightweight Sublinear Arguments Without a Trusted
          Setup". CCS 2017.
        </li>
        <li>
          M. Bardet, J.-C. Faugere, B. Salvy, and B.-Y. Yang.
          "Asymptotic behaviour of the degree of regularity of
          semi-regular polynomial systems". Proc. of MEGA 2005.
        </li>
        <li>
          E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev.
          "Scalable, transparent, and post-quantum secure
          computational integrity". ePrint 2018/46.
        </li>
        <li>
          E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner,
          M. Virza, and N. P. Ward. "Aurora: Transparent Succinct
          Arguments for R1CS". EUROCRYPT 2019.
        </li>
        <li>
          G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche.
          "Sponge functions". Ecrypt Hash Workshop 2007.
        </li>
        <li>
          G. Bertoni, J. Daemen, M. Peeters, and G. Van Assche.
          "On the Indifferentiability of the Sponge Construction".
          EUROCRYPT 2008.
        </li>
        <li>
          T. Beyne, A. Canteaut, I. Dinur, et al. "Out of Oddity -
          New Cryptanalytic Techniques Against Symmetric Primitives
          Optimized for Integrity Proof Systems". CRYPTO 2020.
          <a href="/papers/out-of-oddity-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          E. Biham and A. Shamir. "Differential Cryptanalysis of
          DES-like Cryptosystems". CRYPTO 1990.
        </li>
        <li>
          A. Biryukov, L. Perrin, and A. Udovenko. "Reverse-
          Engineering the S-Box of Streebog, Kuznyechik and
          STRIBOBr1". EUROCRYPT 2016.
        </li>
        <li>
          J. Black, P. Rogaway, and T. Shrimpton. "Black-Box
          Analysis of the Block-Cipher-Based Hash-Function
          Constructions from PGV". CRYPTO 2002.
        </li>
        <li>
          C. Boura, A. Canteaut, and C. D. Canniere. "Higher-Order
          Differential Properties of Keccak and Luffa". FSE 2011.
        </li>
        <li>
          C. Bouvier, P. Briaud, P. Chaidos, L. Perrin, R. Salen,
          V. Velichkov, and D. Willems. "Anemoi Permutations and
          Jive Compression Mode". ePrint 2022/840.
          <a href="/papers/anemoi-2022" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          B. Buchberger. "Ein Algorithmus zum Auffinden der
          Basiselemente des Restklassenringes nach einem
          nulldimensionalen Polynomideal". PhD thesis, Univ.
          Innsbruck, 1965.
        </li>
        <li>
          B. Bunz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille,
          and G. Maxwell. "Bulletproofs: Short Proofs for
          Confidential Transactions and More". IEEE S&amp;P 2018.
        </li>
        <li>
          J.-S. Coron, J. Patarin, and Y. Seurin. "The Random
          Oracle Model and the Ideal Cipher Model Are Equivalent".
          CRYPTO 2008.
        </li>
        <li>
          D. A. Cox, J. Little, and D. O'Shea. <em>Ideals,
          Varieties, and Algorithms</em>. Springer, 1997.
        </li>
        <li>
          R. A. de la Cruz Jimenez. "On some methods for
          constructing almost optimal S-Boxes and their resilience
          against side-channel attacks". ePrint 2018/618.
        </li>
        <li>
          J. Daemen and V. Rijmen. "The Wide Trail Design Strategy".
          Cryptography and Coding 2001.
        </li>
        <li>
          Y. Dai and J. P. Steinberger. "Indifferentiability of
          8-Round Feistel Networks". CRYPTO 2016.
        </li>
        <li>
          C. Dobraunig, L. Grassi, A. Guinet, and D. Kuijsters.
          "Ciminion: Symmetric Encryption Based on Toffoli-Gates
          over Large Finite Fields". EUROCRYPT 2021.
        </li>
        <li>
          V. Dolmatov and A. Degtyarev. "GOST R 34.11-2012: Hash
          Function". RFC 6986, 2013.
        </li>
        <li>
          S. Duval and G. Leurent. "MDS Matrices with Lightweight
          Circuits". IACR Trans. Symmetric Cryptol. 2018.2.
        </li>
        <li>
          Federal Agency on Technical Regulation and Metrology.
          GOST R 34.12-2015: Block Cipher. 2015.
        </li>
        <li>
          A. Gabizon and Z. J. Williamson. "plookup: A simplified
          polynomial protocol for lookup tables". ePrint 2020/315.
          <a href="/papers/plookup-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          A. Gabizon, Z. J. Williamson, and O. Ciobotaru. "PLONK:
          Permutations over Lagrange-bases for Oecumenical
          Noninteractive arguments of Knowledge". ePrint 2019/953.
          <a href="/papers/plonk-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          L. Grassi. "On Generalizations of the Lai-Massey Scheme".
          ePrint 2022/1245.
        </li>
        <li>
          L. Grassi, D. Khovratovich, R. Luftenegger,
          C. Rechberger, M. Schofnegger, and R. Walch.
          "Reinforced Concrete: Fast Hash Function for Zero
          Knowledge Proofs". ePrint 2021/1038.
          <a href="/papers/reinforced-concrete-2021" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and
          M. Schofnegger. "Poseidon: A New Hash Function for
          Zero-Knowledge Proof Systems". USENIX Security 2021.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          L. Grassi, D. Khovratovich, S. Ronjom, and
          M. Schofnegger. "The Legendre Symbol and the Modulo-2
          Operator in Symmetric Schemes". IACR Trans. Symmetric
          Cryptol. 2022.1.
        </li>
        <li>
          L. Grassi, R. Luftenegger, C. Rechberger, D. Rotaru, and
          M. Schofnegger. "On a Generalization of
          Substitution-Permutation Networks: The HADES Design
          Strategy". EUROCRYPT 2020.
          <a href="/papers/hades-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          L. Grassi, S. Onofri, M. Pedicini, and L. Sozzi.
          "Invertible Quadratic Non-Linear Layers for
          MPC-/FHE-/ZK-Friendly Schemes". IACR Trans. Symmetric
          Cryptol. 2022.3.
        </li>
        <li>
          L. Grassi, C. Rechberger, D. Rotaru, P. Scholl, and
          N. P. Smart. "MPC-Friendly Symmetric Key Primitives".
          CCS 2016.
        </li>
        <li>
          J. Groth. "On the Size of Pairing-Based Non-interactive
          Arguments". EUROCRYPT 2016.
        </li>
        <li>
          V. T. Hoang and P. Rogaway. "On Generalized Feistel
          Networks". CRYPTO 2010.
        </li>
        <li>
          H. B. Hougaard. "3-round Feistel is Not Superpseudorandom
          Over Any Group". ePrint 2021/675.
        </li>
        <li>
          T. Jakobsen and L. R. Knudsen. "The Interpolation Attack
          on Block Ciphers". FSE 1997.
        </li>
        <li>
          A. Klimov and A. Shamir. "Cryptographic Applications of
          T-Functions". SAC 2003.
        </li>
        <li>
          S. Kolbl, M. M. Lauridsen, F. Mendel, and
          C. Rechberger. "Haraka v2". IACR Trans. Symmetric
          Cryptol. 2016.2.
        </li>
        <li>
          X. Lai and J. L. Massey. "A Proposal for a New Block
          Encryption Standard". EUROCRYPT 1990.
        </li>
        <li>
          M. Lamberger, F. Mendel, C. Rechberger, V. Rijmen, and
          M. Schlaffer. "Rebound Distinguishers: Results on the
          Full Whirlpool Compression Function". ASIACRYPT 2009.
        </li>
        <li>
          M. Luby and C. Rackoff. "How to Construct Pseudorandom
          Permutations from Pseudorandom Functions". SIAM J.
          Comput. 17.2 (1988).
        </li>
        <li>
          M. Matsui. "Linear Cryptanalysis Method for DES Cipher".
          EUROCRYPT 1993.
        </li>
        <li>
          K. Matusiewicz, M. Naya-Plasencia, I. Nikolic, Y. Sasaki,
          and M. Schlaffer. "Rebound Attack on the Full Lane
          Compression Function". ASIACRYPT 2009.
        </li>
        <li>
          U. M. Maurer and K. Pietrzak. "The Security of Many-Round
          Luby-Rackoff Pseudo-Random Permutations". EUROCRYPT 2003.
        </li>
        <li>
          F. Mendel, C. Rechberger, M. Schlaffer, and
          S. S. Thomsen. "The Rebound Attack: Cryptanalysis of
          Reduced Whirlpool and Grostl". FSE 2009.
        </li>
        <li>
          R. Mollin and S. C. "On Permutation Polynomials Over
          Finite Fields". Int. J. Math. Math. Sci. 10 (1987).
        </li>
        <li>
          NIST. "SHA-3 Standard: Permutation-Based Hash and
          Extendable-Output Functions". FIPS 202, 2015.
        </li>
        <li>
          K. Nyberg. "Generalized Feistel Networks". ASIACRYPT 1996.
        </li>
        <li>
          J. Patarin. "About Feistel Schemes with Six (or More)
          Rounds". FSE 1998.
        </li>
        <li>
          J. Patarin. "Generic Attacks on Feistel Schemes".
          ASIACRYPT 2001.
        </li>
        <li>
          S. Patel, Z. Ramzan, and G. S. Sundaram. "Luby-Rackoff
          Ciphers: Why XOR Is Not So Exclusive". SAC 2002.
        </li>
        <li>
          Polygon. "Introducing Plonky2". 2022.
        </li>
        <li>
          B. Preneel, R. Govaerts, and J. Vandewalle. "Hash
          Functions Based on Block Ciphers: A Synthetic Approach".
          CRYPTO 1993.
        </li>
        <li>
          A. Szepieniec. "On the Use of the Legendre Symbol in
          Symmetric Cipher Design". ePrint 2021/984.
        </li>
        <li>
          A. Szepieniec, T. Ashur, and S. Dhooghe. "Rescue-Prime:
          a Standard Specification (SoK)". ePrint 2020/1143.
          <a href="/papers/rescue-prime-2020" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li>
          S. Vaudenay. "Decorrelation: A Theory for Block Cipher
          Security". J. Cryptol. 16.4 (2003).
        </li>
        <li>
          Zcash. "ZCash protocol specification". 2021.
        </li>
        <li>
          Y. Zheng, T. Matsumoto, and H. Imai. "On the
          Construction of Block Ciphers Provably Secure and Not
          Relying on Any Unproved Hypotheses". CRYPTO 1989.
        </li>
      </ol>
    </section>
  </article>
</BaseLayout>
