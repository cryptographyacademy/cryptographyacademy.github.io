---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1461';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Lower bounds for the depth of modular squaring';
const AUTHORS_HTML = 'Benjamin Wesolowski, Ryan Williams';

const CONTENT = `    <p class="text-gray-300">Benjamin Wesolowski<span class="math">^{1,2}</span> and Ryan Williams<span class="math">^{*3}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> Univ. Bordeaux, CNRS, Bordeaux INP, IMB, UMR 5251, F-33400, Talence, France <span class="math">^{2}</span> INRIA, IMB, UMR 5251, F-33400, Talence, France <span class="math">^{3}</span> Computer Science and Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA 02139</p>

    <p class="text-gray-300">Abstract. The modular squaring operation has attracted significant attention due to its potential in constructing cryptographic time-lock puzzles and verifiable delay functions. In such applications, it is important to understand precisely how quickly a modular squaring operation can be computed, even in parallel on dedicated hardware. We use tools from circuit complexity and number theory to prove concrete numerical lower bounds for squaring on a parallel machine, yielding nontrivial results for practical input bitlengths. For example, for <span class="math">n = 2048</span>, we prove that every logic circuit (over AND, OR, NAND, NOR gates of fan-in two) computing modular squaring on all <span class="math">n</span>-bit inputs (and any modulus that is at least <span class="math">2^{n-1}</span>) requires depth (critical path length) at least 12. By a careful analysis of certain exponential Gauss sums related to the low-order bit of modular squaring, we also extend our results to the average case. For example, our results imply that every logic circuit (over any fan-in two basis) computing modular squaring on at least <span class="math">76\\%</span> of all 2048-bit inputs (for any RSA modulus that is at least <span class="math">2^{n-1}</span>) requires depth at least 9.</p>

    <p class="text-gray-300">Keywords: Verifiable delay function · circuit · modular squaring · RSA</p>

    <p class="text-gray-300">Which computational problems are inherently sequential, and cannot be efficiently parallelized? This is the intuitive question behind the P versus NC problem, one of the major open problems in computational complexity theory and computer science. It is widely conjectured that <span class="math">\\mathsf{P} \\neq \\mathsf{NC}</span>, which would show that there are (natural) problems solvable in <span class="math">n^{O(1)}</span> time in a sequential computational model that cannot be solved in <span class="math">(\\log n)^{O(1)}</span> parallel time (a.k.a. <span class="math">(\\log n)^{O(1)}</span> depth) in a parallel computational model with <span class="math">n^{O(1)}</span> processors. Very little is known about the depth complexity of functions in P: the best known depth lower bounds for any function in P (or NP for that matter) only show that depth must be at least <span class="math">c \\log n</span> where <span class="math">c \\leq 3</span>.</p>

    <p class="text-gray-300">In cryptography, certain problems have been proposed as candidates for being inherently sequential. In this paper, we focus on the problem of integer modular squaring, which was first proposed by Rivest, Shamir, and Wagner [RSW96] in the context of time-lock puzzles. It has recently received renewed attention, when it was shown in [Wes19, Pie19] that it allows to build verifiable delay functions [BBBF18] (or VDF), a cryptographic primitive key to a wide variety of exciting applications, notably for secure decentralised systems.</p>

    <p class="text-gray-300">Repeated Modular Squaring (RMS): Given an <span class="math">n</span>-bit <span class="math">x</span>, a parameter <span class="math">T</span>, and an <span class="math">n</span>-bit modulus <span class="math">m \\in [2^{n-1}, 2^n - 1]</span>, calculate <span class="math">x^{2^T} \\mod m</span>.</p>

    <p class="text-gray-300">*Email: rrw@mit.edu.</p>

    <p class="text-gray-300">Typically, we think of <span class="math">T</span> as “large”. If <span class="math">m</span> is prime, one can calculate <span class="math">x^{2^{T}}\\ \\mathrm{mod}\\ m</span> very efficiently by first reducing the exponent <span class="math">k=2^{T}\\ \\mathrm{mod}\\ m-1</span>, then computing <span class="math">x^{k}\\ \\mathrm{mod}\\ m</span> for <span class="math">k&lt;m</span>. More generaly, knowing <span class="math">\\phi(m)</span> (or equivalently, the factorisation of <span class="math">m</span>) allows to compute <span class="math">x^{2^{T}}\\ \\mathrm{mod}\\ m</span> in about <span class="math">\\log_{2}(T)</span> multiplications in <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span>. However, if the factorisation of <span class="math">m</span> is unknown, one cannot reduce the exponent, and there is no known method to compute <span class="math">x^{2^{T}}\\ \\mathrm{mod}\\ m</span> faster than squaring <span class="math">T</span> times sequentially. In this situation, Rivest, Shamir and Wagner suggest that the depth of computing <span class="math">x^{2^{T}}\\ \\mathrm{mod}\\ m</span> is roughly <span class="math">T</span> times the depth of squaring modulo <span class="math">m</span>, when <span class="math">T\\leq 2^{n^{o(1)}}</span> (when <span class="math">T</span> is sufficiently large, it becomes advantageous to factor <span class="math">m</span> first).</p>

    <p class="text-gray-300">The parallel setting is critical here: for applications of VDFs, it is important to have a good estimate of the wall-clock time required for computing RMS: what is the depth of the shallowest circuit an adversary can build? Naively, one might conjecture that every (reasonably defined) parallel machine computing RMS requires at least <span class="math">\\hat{\\Omega}(T+\\log n)</span> depth, where the <span class="math">\\hat{\\Omega}</span> omits division by polylogarithmic factors. However, noting that the input length to RMS is only <span class="math">m\\leq O(\\log T+\\log n)</span>, such a conjecture would imply a <span class="math">2^{\\Omega(m)}</span> circuit depth lower bound, but it is well-known that every function on <span class="math">m</span>-bit input has a (non-uniform) circuit of <span class="math">2^{m}</span> size and <span class="math">O(m)</span> depth. So for such a conjecture to make sense, we also need to bound the size/work of the parallel computation as well, to be (for example) polynomial in <span class="math">T</span> and <span class="math">\\log n</span>.</p>

    <p class="text-gray-300">Other constructions with lower depth are known, such as <em>[x1]</em>, but require models whose practicality has been called into question <em>[x10]</em>, with high fan-in and fan-out. To this day, the most successful attempts at building fast hardware for RMS still boil down to efficient modular squaring <em>[x7, x11]</em>.</p>

    <p class="text-gray-300">In this article, we focus on modular squaring, and ask the relaxed question: what unconditional lower bounds can be proved for modular integer squaring? Can it be rigorously proved that even computing certain bits of <span class="math">x^{2}</span> already requires an interesting level of depth complexity?</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Results</h3>

    <p class="text-gray-300">In this paper, we focus on the following problem.</p>

    <p class="text-gray-300">Modular Squaring (MS): Given an <span class="math">n</span>-bit <span class="math">x</span> and an <span class="math">n</span>-bit modulus <span class="math">m\\in[2^{n-1},2^{n}]</span>, calculate <span class="math">x^{2}\\ \\mathrm{mod}\\ m</span>.</p>

    <p class="text-gray-300">Our goal is to prove unconditional, concrete depth lower bounds for MS. That is, we want to be able to plug in values of <span class="math">n</span> arising in practice, and obtain unconditionally true facts about the required time delays of any logic circuit computing MS on <span class="math">n</span>-bit numbers. To this end, we prove interesting worst-case lower bounds and average-case lower bounds on the depth complexity of MS. We state our results in terms of Boolean logic circuits over OR, AND, NAND, and NOR, each of fan-in two, with “free” NOT gates having cost 0. (We believe this choice of gates is reasonable for practice, because the other possible two-bit gates XOR and EQUALS in modern hardware are, to the best of our knowledge, always implemented in terms of the other gates.) In circuit complexity terminology, this corresponds to proving circuit lower bounds over the basis <span class="math">U_{2}</span> (all unate functions on two bits <em>[x14, x12]</em>).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Worst-Case Lower Bounds.</h4>

    <p class="text-gray-300">Our primary worst-case lower bound is the following.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 1 (Worst-Case Lower Bound).</h6>

    <p class="text-gray-300">For every <span class="math">n</span>, every logic circuit (over the basis <span class="math">U_{2}</span>) computing MS on <span class="math">n</span>-bit integers requires depth at least <span class="math">2\\log_{2}(n-1)-2\\log_{2}(\\log_{2}(n-1)-1)-4</span>.</p>

    <p class="text-gray-300">In particular, we show that “middle bits” of the output of MS require such depth complexity. The depth complexity of Theorem 1 is stated rather precisely, so that it is possible to plug in concrete numbers and yield interesting results. For example, when <span class="math">n=1024</span> and <span class="math">n=2048</span>, in which case Theorem 1 yields a depth lower bounds of at least <span class="math">10</span> and <span class="math">12</span>, respectively (note that the depth must be an integer). Thus, Theorem 1 allows us to make concrete statements about the delays of logic circuits computing MS, such as the following:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Every logic circuit with a <span class="math">10</span> picosecond delay per gate must take at least <span class="math">1200</span> picoseconds to compute a modular squaring operation on <span class="math">2048</span>-bit integers.</p>
    </blockquote>

    <p class="text-gray-300">The lower bound of Theorem 1 proceeds by an efficient reduction from the <span class="math">\\mathsf{SUM}</span> problem from <span class="math">n</span> bits to <span class="math">O(\\log n)</span> bits, defined as:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{SUM}(x_{1},\\ldots,x_{n}):=\\sum_{i}x_{i}.</span></p>

    <p class="text-gray-300">That is, <span class="math">\\mathsf{SUM}</span> simply outputs a binary representation of the sum of the <span class="math">1</span>s in its input. It is known that <span class="math">\\mathsf{SUM}</span> has circuits of depth at most <span class="math">4.14\\log_{2}(n)</span> <em>[x14]</em> and every circuit for <span class="math">\\mathsf{SUM}</span> must have depth at least <span class="math">2\\log_{2}(n)</span> <em>[x10]</em>. Our reduction can be stated as follows.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">If <span class="math">\\mathsf{SUM}</span> requires depth at least <span class="math">c\\log_{2}(n)</span> for constant <span class="math">c\\geq 2</span>, then MS on <span class="math">n</span>-bit integers requires depth at least <span class="math">c\\log_{2}(n-1)-c\\log_{2}(\\log_{2}(n-1)-1)-2c</span>.</p>

    <p class="text-gray-300">As a corollary, under the reasonable hypothesis that <span class="math">\\mathsf{SUM}</span> requires depth <span class="math">4\\log_{2}(n)</span>, MS on <span class="math">2048</span>-bit integers has depth complexity at least <span class="math">23</span>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Average-Case Lower Bounds.</h4>

    <p class="text-gray-300">For cryptographic reasons, it is interesting to ask if the above lower bounds hold for circuits that are only required to compute MS on a decent fraction of <span class="math">n</span>-bit inputs. In this case we can also prove non-trivial depth lower bounds for squaring with an RSA modulus, but they are weaker than what we can prove in the worst case.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">n\\geq 38</span>, and let <span class="math">m</span> be the product of two primes in <span class="math">[2^{n/2-1},2^{n/2})</span>. Every logic circuit computing <span class="math">(x^{2}\\bmod m)</span> correctly on at least <span class="math">76\\%</span> of all <span class="math">n</span>-bit integers <span class="math">x</span> (over the basis <span class="math">U_{2}</span> or <span class="math">B_{2}</span>) requires depth at least <span class="math">\\log_{2}(n/4-7.2)</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Every logic circuit (even with XOR and EQUALS gates) computing <span class="math">(x^{2}\\bmod m)</span> correctly on at least <span class="math">76\\%</span> of all <span class="math">n</span>-bit integers <span class="math">x</span> requires depth at least <span class="math">9</span>, when <span class="math">m</span> is the product of two <span class="math">1024</span>-bit primes, both of which are at least <span class="math">2^{1023}</span>.</p>

    <p class="text-gray-300">An interesting aspect of Theorem 3 is that the depth lower bound holds even over circuits from <span class="math">B_{2}</span>, the <em>full binary basis</em>: our gates may be any possible function that takes two bits as input and outputs a bit. (This point is not necessarily relevant to practice; it just turns out that the proof works in that case.)</p>

    <p class="text-gray-300">We believe that the depth complexity of MS in the average case should be roughly as hard as the worst case. However, our worst-case proofs reasoning about the “middle bit” of MS do not extend to the average case (they modify the input too much to yield “typical” inputs), so we take a different approach. We show that computing the <em>low-order bit</em> of MS is difficult on average. This is interesting, because the low-order bit of normal <em>integer squaring</em>, without modular reduction, is trivial (the low-order bit of the output only depends on the low-order bit of the input). Thus modular reduction plays a crucial role in the average-case lower bound of Theorem 3.</p>

    <p class="text-gray-300">In order to establish Theorem 3, we prove a result regarding the sensitivity of modular squaring on random inputs, and show how such sensitivity results yield size and depth lower bounds. (Here in the introduction, we will keep the discussion at an informal level.) The sensitivity of a function <span class="math">f</span> at a binary input <span class="math">x</span> measures how many distinct input bits could be “flipped” such that the value of <span class="math">f</span> changes. When <span class="math">f</span> is the low-order bit of the MS function on <span class="math">n</span>-bit integers, we use bounds on exponential sums to show (in Theorems 10 and 11) that there are at least <span class="math">n/4</span> input bits <span class="math">x_{i}</span> such that, when an <span class="math">n</span>-bit <span class="math">x</span> is chosen uniformly at random, the probability that the value of <span class="math">f(x)</span> flips is at least <span class="math">1/2-o(1)</span>. We show how such sensitivity results can be applied to prove lower bounds on the depths of all circuits computing MS even on a decent fraction of inputs, culminating in Theorem 3.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Notation and Definitions.</h4>

    <p class="text-gray-300">Let <span class="math">n\\geq 1</span> be an integer, and let <span class="math">[n]:=\\{1,\\ldots,n\\}</span>. We define the function <span class="math">\\mathsf{IS}:\\{0,1\\}^{<em>}\\to\\{0,1\\}^{</em>}</span> (Integer Squaring) to map <span class="math">n</span>-bit integers <span class="math">x</span> to <span class="math">2n</span>-bit integers <span class="math">x^{2}</span>.</p>

    <p class="text-gray-300">Let <span class="math">m\\leq 2^{n}-1</span> be an odd integer, and let <span class="math">\\mathbf{Z}/m\\mathbf{Z}=\\{0,1,\\ldots,m-1\\}</span>. We view <span class="math">(x\\bmod m)</span> as a function from <span class="math">\\mathbf{Z}</span> to the set <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span>. Define</p>

    <p class="text-gray-300"><span class="math">\\text{MS-MOD2}_{n,m}:\\{0,1\\}^{n}\\to\\{0,1\\}</span></p>

    <p class="text-gray-300">as the function which construes its <span class="math">n</span>-bit input <span class="math">x</span> as an integer in <span class="math">[0,2^{n}-1]</span>, and outputs <span class="math">((x^{2}\\bmod m)\\bmod 2)</span>. This is the least significant bit of the function <span class="math">MS(x)=(x^{2}\\bmod m)</span> as defined in the introduction.</p>

    <p class="text-gray-300">We use basic notions from circuit complexity <em>[x28, x20]</em>. Let <span class="math">\\mathcal{B}</span> be a set of functions of the form <span class="math">f:\\{0,1\\}^{k}\\to\\{0,1\\}</span> where <span class="math">k\\in\\{1,2\\}</span>. Typical choices are <span class="math">B_{2}</span>, the set of all functions on at most two inputs, and <span class="math">U_{2}</span>, the set of all unate functions on at most two inputs (a unate function <span class="math">g</span> is a monotone function with signs on some of its inputs, so for example <span class="math">g(x,y,z)=f(\\neg x,y,\\neg z)</span> is unate when <span class="math">f</span> is monotone). It is easy to verify that <span class="math">B_{2}=U_{2}\\cup\\{XOR,EQUALS\\}</span>.</p>

    <p class="text-gray-300">As is standard, an <span class="math">n</span>-input, <span class="math">m</span>-output, <span class="math">s</span>-size circuit over the basis <span class="math">\\mathcal{B}</span> is represented as a directed acyclic graph with <span class="math">n</span> sources and <span class="math">s</span> other nodes which include <span class="math">m</span> sinks. Each node is called a gate, has indegree at most two (a.k.a. fan-in at most two), and is labelled with some <span class="math">f\\in\\mathcal{B}</span>.</p>

    <p class="text-gray-300">More background on circuit complexity will be covered in Section 3.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Prior Work.</h4>

    <p class="text-gray-300">As far as we can tell, there is scant literature on proving <span class="math">numerical</span> and unconditional lower bounds for circuit depth. Meyer and Stockmeyer <em>[x30]</em> proved such results for circuit size: concretely, they showed that deciding the truth of formulas of length at most 610 from the language WS1S (a problem known to require extremely high asymptotic time complexity) requires circuits containing at least <span class="math">10^{125}</span> gates.</p>

    <p class="text-gray-300">On a technical level, the work most related to ours concerns depth lower bounds for PRAMs (parallel random access machines). It has long been known that sensitivity is tied to running time for parallel machines (a.k.a. circuit depth) <em>[x28]</em>. For example, the work of Cook, Dwork, and Reishuk <em>[x1]</em> implies that for so-called CREW (Concurrent Read Exclusive Write) PRAMs, the minimal running time for computing a function <span class="math">f</span> is at least <span class="math">\\Omega(\\log S(f))</span> where <span class="math">S(f)</span> is the sensitivity of <span class="math">f</span>, and the recently celebrated proof of the Sensitivity Conjecture by Huang <em>[x15]</em> implies (among other results) that CREW PRAM running time is bounded from above by <span class="math">O(\\log S(f))</span>. Among this literature, the reference most related to our work is that of Shlarpinski and von zur Gathen <em>[x27]</em>, who used bounds on exponential sums and sensitivity to show that modular inversion requires depth <span class="math">\\Omega(\\log_{2}(n))</span> on <span class="math">n</span>-bit integers in the worst case, with a leading constant at</p>

    <p class="text-gray-300">most <span class="math">1/2</span> in the <span class="math">\\Omega(\\cdot)</span>. To contrast, our results for modular squaring are worst-case with a leading constant of (at least) <span class="math">2</span>, and average-case with a leading constant <span class="math">1</span> in front of the <span class="math">\\log_{2}(n)</span> term, allowing us to conclude interesting numerical lower bounds.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Useful Notions from Circuit Complexity</h2>

    <p class="text-gray-300">In this section, we generalize some known concepts and theorems from circuit complexity which will be useful in our average-case depth lower bounds. Two good general references on the subject are <em>[x20, x23]</em>. In the following, let <span class="math">f:\\{0,1\\}^{n}\\to\\{0,1\\}</span> be a Boolean function. For a point <span class="math">x\\in\\{0,1\\}^{n}</span> and index <span class="math">i\\in[n]</span>, we define <span class="math">x^{(i)}</span> to be <span class="math">x</span> with the <span class="math">i</span>-th bit flipped to the opposite value. All of the following results hold over any basis of fan-in two Boolean functions, including <span class="math">B_{2}</span>.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.1 Non-Degeneracy</h3>

    <p class="text-gray-300">Roughly speaking, a function <span class="math">f</span> is non-degenerate if it depends on all of its inputs.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">A function <span class="math">f</span> is non-degenerate if for all <span class="math">i\\in[n]</span>, there is an <span class="math">a\\in\\{0,1\\}^{n}</span> such that <span class="math">f(a)\\neq f(a^{(i)})</span>.</p>

    <p class="text-gray-300">That is, <span class="math">f</span> is non-degenerate if, for all <span class="math">i</span>, there is at least one input <span class="math">a</span> such that flipping the <span class="math">i</span>-th bit of <span class="math">a</span> changes the value of <span class="math">f</span>. A function <span class="math">f</span> is degenerate if it is not non-degenerate. Intuitively, a degenerate function has at least one variable that does not affect the output: there is an <span class="math">i\\in[n]</span> such that for all assignments <span class="math">a</span>, <span class="math">f(a)=f(a^{(i)})</span>. Therefore the <span class="math">i</span>-th bit of input does not affect the output.</p>

    <p class="text-gray-300">It is not difficult to prove the following relation between non-degeneracy and circuit size. (We omit the proof, as we will prove a stronger result in a moment.)</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Proposition 1 (Folklore, <em>[x20]</em>).</h6>

    <p class="text-gray-300">Every non-degenerate <span class="math">f</span> has circuit complexity at least <span class="math">n-1</span>, over the basis of all Boolean functions on two inputs.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Corollary 2.</h6>

    <p class="text-gray-300">The AND, OR, and PARITY functions on <span class="math">n</span>-bit inputs require circuits of size at least <span class="math">n-1</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proposition 2 (Folklore).</h6>

    <p class="text-gray-300">Every non-degenerate <span class="math">f</span> has depth complexity at least <span class="math">\\log_{2}(n)</span>, over the basis of all Boolean functions on two inputs.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is by contrapositive. Consider any circuit <span class="math">C</span> of depth <span class="math">d&lt;\\log_{2}(n)</span>. Since <span class="math">C</span> has fan-in two and depth <span class="math">d</span>, the circuit <span class="math">C</span> can be converted into an equivalent formula <span class="math">F</span>, with at most <span class="math">2^{d}\\leq n-1</span> leaves. This equivalent formula <span class="math">F</span> can read at most <span class="math">n-1</span> distinct inputs, so the function computed by <span class="math">F</span> is degenerate (the missing input cannot affect the output of <span class="math">f</span>). ∎</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">The AND, OR, and PARITY functions on <span class="math">n</span>-bit inputs require circuits of depth at least <span class="math">\\log_{2}(n)</span>.</p>

    <p class="text-gray-300">In the proofs of average-case lower bounds, we will require a natural generalization of the classic non-degeneracy concept, and its application to circuit complexity.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\{0,1,\\ldots,n\\}</span>. A function <span class="math">f</span> is degenerate in <span class="math">k</span> variables if there are <span class="math">k</span> distinct <span class="math">i_{1},\\ldots,i_{k}\\in[n]</span> such that for all <span class="math">a\\in\\{0,1\\}^{n}</span> and <span class="math">j\\in[k]</span>, <span class="math">f(a)=f(a^{(i_{j})})</span>.</p>

    <p class="text-gray-300">That is, <span class="math">f</span> is degenerate in <span class="math">k</span> variables if there are <span class="math">k</span> different input indices <span class="math">i</span> such that flipping the <span class="math">i</span>-th bit of <span class="math">a</span> does not change the value of <span class="math">f</span>, for all inputs <span class="math">a</span>. The following generalizes Proposition 1.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Let <span class="math">k\\in\\{0,1,\\ldots,n\\}</span>. Every minimal fan-in two circuit with at most <span class="math">(n-1)-k</span> gates is degenerate in (at least) <span class="math">k</span> variables.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the contrapositive. Let <span class="math">s</span> be the number of gates in a minimal circuit for an <span class="math">f</span> that is not degenerate in <span class="math">k</span> variables. First, there must be at least <span class="math">n-k</span> inputs in the circuit that have at least one outgoing wire. Otherwise, <span class="math">f</span> would trivially be degenerate in (at least) <span class="math">k</span> variables: <span class="math">k</span> of the inputs have no outgoing wire, so flipping any of their values cannot change the circuit’s output on <em>any</em> input. Note that each of the <span class="math">s</span> gates have at least one outgoing wire: otherwise, that gate could be removed without changing the circuit’s functionality, contradicting minimality.</p>

    <p class="text-gray-300">Therefore the number of wires in a minimum circuit for <span class="math">f</span> is at least <span class="math">n-k+s-1</span>: there are at least <span class="math">n-k</span> wires coming out of the inputs, and <span class="math">s-1</span> wires coming out of the interior gates (subtracting one for the output gate, which has no outgoing wire). Since each gate also has fan-in two (two edges coming into it), the number of wires in the circuit is at most <span class="math">2s</span>. Therefore <span class="math">2s\\geq n-k+s-1</span>, implying <span class="math">s\\geq(n-1)-k</span>. ∎</p>

    <p class="text-gray-300">The following is analogous to the proof of Proposition 2.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Corollary 4.</h6>

    <p class="text-gray-300">Every <span class="math">f</span> that is degenerate in at most <span class="math">k</span> variables has depth complexity at least <span class="math">\\log_{2}(n-k)</span>, over the basis of all Boolean functions on two inputs.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">3.2 Sensitivity</h3>

    <p class="text-gray-300">We also use the classical concept of the sensitivity of a function.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3 (<em>[x17]</em>).</h6>

    <p class="text-gray-300">The <em>sensitivity of <span class="math">f</span> at <span class="math">x\\in\\{0,1\\}^{n}</span></em> is the number of indices <span class="math">i\\in[n]</span> such that <span class="math">f(x^{(i)})\\neq f(x)</span>.</p>

    <p class="text-gray-300">For concrete examples, note the PARITY function on <span class="math">n</span>-bit inputs has sensitivity <span class="math">n</span> at every point (flipping any bit changes the parity), and the AND function has sensitivity <span class="math">n</span> at the all-ones input but sensitivity <span class="math">0</span> at the all-zeroes input. A basic result about sensitivity is the following proposition:</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proposition 4 (<em>[x1, x17]</em>).</h6>

    <p class="text-gray-300">Suppose a function <span class="math">f:\\{0,1\\}^{n}\\to\\{0,1\\}</span> has sensitivity at least <span class="math">k</span> at some point <span class="math">x</span>. Then <span class="math">f</span> requires at least <span class="math">k-1</span> gates and <span class="math">\\log_{2}(k)</span> depth, even over <span class="math">B_{2}</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the contrapositive. Suppose <span class="math">f</span> has a minimal-size circuit <span class="math">C</span> with at most <span class="math">k-2</span> gates. By the same argument as in Proposition 3, there must be at least <span class="math">v</span> input nodes in <span class="math">C</span> that do not have an outgoing wire, where <span class="math">k-2=(n-1)-v</span>. Noting that <span class="math">v=n-k+1</span>, this means that circuit <span class="math">C</span>’s output only ever depends on at most <span class="math">n-v=k-1</span> of the inputs. Therefore <span class="math">f</span> has sensitivity at most <span class="math">k</span> at every point. The depth lower bound of at least <span class="math">\\log_{2}(k)</span> follows analogously to the proof of Proposition 2. ∎</p>

    <h2 id="sec-29" class="text-2xl font-bold">4 Worst-Case Lower Bounds for Modular Squaring</h2>

    <p class="text-gray-300">In this section, we present worst-case depth lower bounds for squaring <span class="math">n</span>-bit integers. We study the “middle bits” of the output, show they can efficiently compute symmetric Boolean functions, and use this information to prove an overall depth lower bound. Our approach proceeds by adapting a reduction of Furst-Saxe-Sipser <em>[x10]</em>, who showed how to reduce the PARITY function to MULTIPLICATION in constant depth. Recall that <span class="math">\\mathsf{IS}</span> maps <span class="math">n</span>-bit integers <span class="math">x</span> to <span class="math">2n</span>-bit integers <span class="math">x^{2}</span>. We will show that low-depth circuits for <span class="math">\\mathsf{IS}</span> can be used to obtain somewhat-low-depth circuits for the function <span class="math">\\mathsf{SUM}(x_{1},\\ldots,x_{\\ell})\\mapsto\\sum_{i}x_{i}</span> for <span class="math">\\ell\\geq\\Omega(n/\\log n)</span>.</p>

    <p class="text-gray-300">Let <span class="math">m\\in\\mathbf{Z}_{&gt;0}</span> be our modulus. If we only consider integers <span class="math">x\\in[0,\\lfloor\\sqrt{m-1}\\rfloor]</span>, then clearly <span class="math">(x^{2}\\bmod m)=\\mathsf{IS}(x)</span>, and our problem reduces to proving a depth lower bound for <span class="math">\\mathsf{IS}</span> on integers <span class="math">x</span> which are <span class="math">b</span> bits long, where <span class="math">b=\\lfloor\\log(m-1)/2\\rfloor</span>. Let us record this simple observation.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proposition 5.</h6>

    <p class="text-gray-300">Let <span class="math">m\\geq 2</span> be an integer. If <span class="math">\\mathsf{IS}</span> requires depth-<span class="math">d</span> circuits on <span class="math">b</span>-bit input, where <span class="math">b=\\lfloor\\log(m-1)/2\\rfloor</span>, then computing <span class="math">(x^{2}\\bmod m)</span> on <span class="math">b</span>-bit input requires depth-<span class="math">d</span> as well.</p>

    <p class="text-gray-300">Now we turn to the reduction. Let <span class="math">\\ell\\in\\mathbf{Z}_{&gt;0}</span>. Consider the bits <span class="math">x_{i}\\in\\{0,1\\}</span> defined by <span class="math">x=\\sum_{i=0}^{\\ell-1}x_{i}2^{i}</span>. Define the degree-<span class="math">(2\\ell-1)</span> polynomial</p>

    <p class="text-gray-300"><span class="math">p(x_{0},\\ldots,x_{\\ell-1},y):=\\sum_{i=0}^{\\ell-1}y^{i}+\\sum_{i=0}^{\\ell-1}x_{i}\\cdot y^{\\ell+i}.</span></p>

    <p class="text-gray-300">In the following, we will construe <span class="math">p</span> as a univariate polynomial in <span class="math">y</span>, with coefficients which are polynomials in the <span class="math">x_{i}</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Claim.</h6>

    <p class="text-gray-300">The degree-<span class="math">(2\\ell-1)</span> coefficient of <span class="math">p(x_{0},\\ldots,x_{\\ell-1},y)^{2}</span> equals <span class="math">2\\sum_{i=0}^{\\ell-1}x_{i}</span>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For notational simplicity, let <span class="math">c_{m}</span> be the degree-<span class="math">m</span> coefficient of <span class="math">p(x_{0},\\ldots,x_{\\ell-1},y)</span>. The degree-<span class="math">m</span> coefficient is the sum of all products <span class="math">c_{i}c_{j}</span> over ordered pairs <span class="math">(i,j)\\in\\{0,1,\\ldots,k\\}^{2}</span> such that <span class="math">i+j=m</span>. Now let <span class="math">m=2\\ell-1</span>. WLOG, consider the case where <span class="math">i&lt;j</span>. Then for each <span class="math">j</span> there is exactly one <span class="math">i&lt;j</span> such that <span class="math">i+j=2\\ell-1</span>, and <span class="math">i&lt;\\ell&lt;j</span>. Thus <span class="math">c_{i}c_{j}=x_{j-\\ell}</span>, and the coefficient is <span class="math">2\\sum_{j=\\ell}^{2\\ell-1}x_{j-\\ell}=2\\sum_{i}x_{i}</span> by double-counting the pairs <span class="math">(i,j)</span> and <span class="math">(j,i)</span>. ∎</p>

    <p class="text-gray-300">Set <span class="math">k:=2+\\lceil\\log_{2}(\\ell)\\rceil</span>, and consider the polynomial</p>

    <p class="text-gray-300"><span class="math">q(x_{0},\\ldots,x_{\\ell-1}):=p(x_{0},\\ldots,x_{\\ell-1},2^{k}).</span></p>

    <p class="text-gray-300">We claim that, for all <span class="math">a\\in\\{0,1\\}^{\\ell}</span>, the binary representation of <span class="math">q(a)^{2}</span> contains <span class="math">\\sum_{i}a_{i}</span> as a substring. By Claim 4, <span class="math">2\\sum_{i}x_{i}</span> is the coefficient of <span class="math">y^{2\\ell-1}</span> in <span class="math">p^{2}</span>. For <span class="math">j=0,\\ldots,2\\ell-1</span>, note that each coefficient of <span class="math">y^{j}</span> in <span class="math">p(a,y)^{2}</span> is at most <span class="math">j+1</span>, since the coefficients of <span class="math">p(a,y)</span> (in the variable <span class="math">y</span>) are in <span class="math">\\{0,1\\}</span>. Thus by setting <span class="math">y:=2^{k}&gt;2\\ell</span>, each coefficient <span class="math">c_{j}</span> of <span class="math">y^{j}</span> in <span class="math">p(a,y)^{2}</span> is less than <span class="math">y</span>, for <span class="math">j=0,\\ldots,2\\ell-1</span>. It follows that each such coefficient <span class="math">c_{j}</span> appears as a binary substring in the bit representation of <span class="math">q(a)^{2}</span>. In particular, the sum of all terms of degree less than <span class="math">2\\ell-1</span> in <span class="math">p(a,y)^{2}</span> contributing to <span class="math">q(a)^{2}</span> is</p>

    <p class="text-gray-300"><span class="math">\\sum_{j=0}^{2\\ell-2}c_{j}y^{j}\\leq\\sum_{j=0}^{2\\ell-2}(j+1)\\cdot 2^{jk}&lt;2^{(2\\ell-1)k}.</span></p>

    <p class="text-gray-300">Moreover, all terms of degree greater than <span class="math">2\\ell-1</span> in <span class="math">p(a,y)^{2}</span> appearing in <span class="math">q(a)^{2}</span> are multiplied by <span class="math">y^{2\\ell}=2^{2\\ell k}&gt;2\\ell\\cdot 2^{(2\\ell-1)k}\\geq(2\\sum_{i}x_{i})y^{2\\ell-1}</span>. Therefore <span class="math">2\\sum_{i}a_{i}</span> appears as a substring in the output, i.e., the substring representing <span class="math">\\sum_{i}a_{i}</span> followed by a <span class="math">0</span>.</p>

    <p class="text-gray-300">We have shown the output of <span class="math">\\mathsf{IS}(q(a))</span> contains the quantity <span class="math">\\sum_{i}a_{i}</span> in binary. Given a circuit <span class="math">C</span> for integer squaring on <span class="math">b</span> bits, we can “implement” <span class="math">q(a)</span> by simply plugging in appropriate zeroes into the inputs of <span class="math">C</span>. We have proven the following.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\ell\\in\\mathbf{Z}_{&gt;0}</span>. Given a depth-<span class="math">d</span> circuit for <span class="math">\\mathsf{IS}</span> on integers of bitlength <span class="math">b:=2\\ell\\cdot k=4\\ell+2\\ell\\log_{2}(\\ell)</span>, we can construct a depth-<span class="math">d</span> circuit for <span class="math">\\mathsf{SUM}(a_{1},\\ldots,a_{\\ell})=\\sum_{i}a_{i}</span> on <span class="math">\\ell</span>-bit inputs.</p>

    <p class="text-gray-300">Thus, lower bounds for <span class="math">\\mathsf{SUM}</span> imply lower bounds for <span class="math">\\mathsf{IS}</span>. We will utilize the following classical lower bound of Krapchenko <em>[x28, p.258-262]</em>.</p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Proposition 6 (Krapchenko 1972).</h6>

    <p class="text-gray-300">Every circuit for <span class="math">\\mathsf{SUM}</span> on <span class="math">\\ell</span>-bits requires depth at least <span class="math">2\\log_{2}(\\ell)</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The least significant bit of <span class="math">\\mathsf{SUM}</span> is the PARITY function on <span class="math">\\ell</span> bits, for which Krapchenko showed a <span class="math">2\\log_{2}(\\ell)</span> depth lower bound. ∎</p>

    <p class="text-gray-300">Applying Proposition 6 and Theorem 4 yields a worst-case lower bound for <span class="math">\\mathsf{IS}</span>.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 5.</h6>

    <p class="text-gray-300">For every circuit with AND and OR gates (and NOT gates for free), <span class="math">\\mathsf{IS}</span> on <span class="math">n</span>-bit integers requires depth at least <span class="math">2\\log_{2}(n)-2\\log_{2}\\log_{2}(n)-2</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Given any depth-<span class="math">d</span> circuit for <span class="math">\\mathsf{IS}</span> on integers of bitlength <span class="math">n:=4\\ell+2\\ell\\log_{2}(\\ell)</span>, Theorem 4 and its corollary show that we get a depth-<span class="math">d</span> circuit for <span class="math">\\mathsf{SUM}</span> on <span class="math">\\ell</span>-bit inputs. But the least significant bit of <span class="math">\\mathsf{SUM}</span> is precisely PARITY, so we also obtain a depth-<span class="math">d</span> circuit for PARITY. Observe that for all <span class="math">\\ell\\geq 1</span>, we have <span class="math">\\ell\\geq n/(2\\log_{2}(n))</span>. Therefore by Proposition 6, we must have <span class="math">d\\geq 2\\log_{2}(\\ell)\\geq 2(\\log_{2}(n)-\\log_{2}\\log_{2}(n)-1)</span>. ∎</p>

    <p class="text-gray-300">Combining Theorem 5 and Proposition 5, we obtain the desired worst-case lower bounds for MS.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Reminder of Theorem 1.</h6>

    <p class="text-gray-300">For every <span class="math">n</span>, every logic circuit over <span class="math">U_{2}</span> computing MS on <span class="math">n</span>-bit integers requires depth at least <span class="math">2\\log_{2}(n-1)-2\\log_{2}(\\log_{2}(n-1)-1)-4</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Corollary 5.</h6>

    <p class="text-gray-300">For every circuit with AND and OR gates (and NOT gates for free), MS on <span class="math">2048</span>-bit integers requires depth at least <span class="math">12</span>.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">A Generalization.</h3>

    <p class="text-gray-300">The above approach gives a reduction from <span class="math">\\mathsf{IS}</span> to <span class="math">\\mathsf{SUM}</span>, and appeals to lower bounds on computing <span class="math">\\mathsf{SUM}</span>. The best-known depth lower bound for <span class="math">\\mathsf{SUM}</span> (in fact, for any symmetric function) is only <span class="math">2\\log n</span> (see <em>[x10]</em>) and this has been the state-of-the-art since the 1970s <em>[x13]</em>.</p>

    <p class="text-gray-300">We observe a generalization of the above reduction that strongly suggests the possibility of larger depth lower bounds. Recall that a symmetric Boolean function <span class="math">f:\\{0,1\\}^{n}\\to\\{0,1\\}</span> has the property that its output is determined solely by the number of <span class="math">1</span>’s in its input. In other words, <span class="math">f</span> is symmetric if there is a “spectrum” function <span class="math">g:\\{0,1,\\ldots,n+1\\}\\to\\{0,1\\}</span> such that for all <span class="math">a\\in\\{0,1\\}^{n}</span>, <span class="math">f(a)=g(\\sum_{i}a_{i})</span>. Classic examples of symmetric functions include OR, AND, MAJORITY, PARITY, and MOD<span class="math">m</span> (which outputs <span class="math">1</span> if and only if the sum of its inputs is divisible by <span class="math">m</span>).</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Suppose there is a symmetric Boolean function <span class="math">f:\\{0,1\\}^{n}\\to\\{0,1\\}</span> with depth complexity at least <span class="math">c\\log_{2}(n)</span>, such that its spectrum function <span class="math">g</span> has a depth-<span class="math">d(n)</span> circuit on input of length <span class="math">1+\\lceil\\log_{2}(n)\\rceil</span>. Then, <span class="math">\\mathsf{IS}</span> has depth complexity at least <span class="math">c(\\log_{2}(n)-\\log_{2}\\log_{2}(n)-2)-d(n/(2\\log n))</span>.</p>

    <p class="text-gray-300">The depth <span class="math">d(n)</span> of the spectrum function is typically very small, as the input to the spectrum function is only about <span class="math">\\log(n)</span> bits. For example, with the PARITY function, the spectrum function <span class="math">g</span> has a depth-zero circuit: we only have to output the least significant bit of the input. For the MAJORITY function, when the number of input bits is a power of two, we only have to output the most significant bit of the input. (When the number of inputs is not a power of two, we have to check that the input number is at least a fixed number, which can be done in <span class="math">O(\\log\\log n)</span> depth, with small constant in the big-O.) In general, we expect <span class="math">d(n)</span> to be at most <span class="math">O(\\log\\log n)</span> for natural symmetric functions.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proof of Theorem 6.</h6>

    <p class="text-gray-300">Given any circuit of depth <span class="math">D</span> for <span class="math">\\mathsf{IS}</span> on <span class="math">n</span>-bit inputs, we first obtain a depth <span class="math">D</span> circuit for <span class="math">\\mathsf{SUM}</span> on <span class="math">\\ell</span>-bit inputs, for <span class="math">\\ell\\geq n/(2\\log_{2}n)</span> as described above. The output of <span class="math">\\mathsf{SUM}</span> is <span class="math">1+\\lceil\\log_{2}(\\ell)\\rceil</span> bits, encoding an integer in <span class="math">\\{0,1,\\ldots,\\ell\\}</span>. If the spectrum function <span class="math">g</span> has depth <span class="math">d(\\ell)</span>, then we can compute <span class="math">f</span> from the <span class="math">\\mathsf{SUM}</span> in only <span class="math">d(\\ell)</span> additional depth. Thus we get a circuit for <span class="math">f</span> on <span class="math">\\ell</span>-bit inputs of depth <span class="math">D+d(\\ell)</span>. Assuming <span class="math">f</span> has depth complexity at least <span class="math">c\\log_{2}(\\ell)</span>, we have <span class="math">D\\geq\\log_{2}(\\ell)-d(\\ell)</span>. ∎</p>

    <p class="text-gray-300">For SUM, the lowest-depth circuits over AND/OR/NOT known still have depth larger than <span class="math">4\\log_{2}(n)</span>; when XOR gates are included, the depth is still greater than <span class="math">3\\log_{2}(n)</span>. In particular, it is known how to construct circuits for SUM with depth <span class="math">4.14\\log_{2}(n)</span> (over AND/OR/NOT) and <span class="math">3.02\\log_{2}(n)</span> (over AND/OR/NOT/XOR); the current best known result seems to be by Sergeev <em>[x18]</em>. Thus there is still a fairly wide gap (<span class="math">2\\log n</span> versus <span class="math">4.14\\log n</span>) between lower bounds and upper bounds on the depth complexity of SUM, and we might expect to improve our concrete lower bound for MS by another factor of two, as follows.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Corollary 6.</h6>

    <p class="text-gray-300">If SUM on <span class="math">n</span> bits requires depth <span class="math">4\\log n</span> over AND/OR/NOT, then IS on <span class="math">n</span> bits requires depth <span class="math">4\\log_{2}(n)-4\\log\\log(n)-4</span>. For <span class="math">n=2048</span>, the depth lower bound is at least <span class="math">26</span>.</p>

    <p class="text-gray-300">The following is immediate, using the reduction from IS to MS of Proposition 5.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Reminder of Theorem 2.</h6>

    <p class="text-gray-300">Suppose SUM requires depth at least <span class="math">c\\log_{2}(n)</span> for a constant <span class="math">c&gt;2</span>. Then MS on <span class="math">n</span>-bit integers requires depth at least <span class="math">c\\log_{2}(n-1)-c\\log_{2}(\\log_{2}(n-1)-1)-2c</span>.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">4.1 Discussion</h3>

    <p class="text-gray-300">The above results show how to lower bound the depth of integer squaring (IS) using a lower bound on SUM. One might think there could be significant “loss” in reducing IS to a simple-looking problem like SUM, but surprisingly, this is not actually the case. It is also known that the depth of multiplication can be <em>upper bounded</em> by low-depth circuits for SUM, so the two problems are in fact tightly correlated in terms of depth complexity.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 7 (<em>[x14]</em> as cited in <em>[x18]</em>).</h6>

    <p class="text-gray-300">Given a depth-<span class="math">d</span> circuit for SUM on <span class="math">n</span>-bit input, there is a circuit for multiplication of two <span class="math">n</span>-bit numbers of depth at most <span class="math">d+\\log_{2}(n)</span>.</p>

    <p class="text-gray-300">Applying the results of <em>[x18]</em> to this theorem, the lowest-depth circuits known for multiplication (and thus squaring) have depth <span class="math">4.02\\log_{2}(n)</span> over all fan-in two gates, and depth <span class="math">5.14\\log_{2}(n)</span> over AND/OR/NOT gates.</p>

    <p class="text-gray-300">The arguments of this section proving for worst-case depth lower bounds do not look directly helpful for trying to prove an <em>average case</em> lower bound against IS or modular squaring. In particular, when we reduce from SUM to IS, the resulting distribution of inputs is far from nice and uniform: starting from an <span class="math">n</span>-bit input to a symmetric Boolean function, we insert many zeroes in specific places in the corresponding input to IS. We will need a different sort of argument to prove average-case lower bounds.</p>

    <h2 id="sec-47" class="text-2xl font-bold">5 Average-Case Lower Bounds</h2>

    <p class="text-gray-300">We now turn to proving average-case lower bounds for MS, where our discussion will culminate in the proof of Theorem 3.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Reminder of Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">n\\geq 38</span>, and let <span class="math">m</span> be the product of two primes in <span class="math">[2^{n/2-1},2^{n/2})</span>. Every logic circuit computing <span class="math">(x^{2}\\bmod m)</span> correctly on at least <span class="math">76\\%</span> of all <span class="math">n</span>-bit integers <span class="math">x</span> (over the basis <span class="math">U_{2}</span> or <span class="math">B_{2}</span>) requires depth at least <span class="math">\\log_{2}(n/4-7.2)</span>.</p>

    <p class="text-gray-300">Our proof will rely critically on sensitivity arguments, as defined and described in Section 3. As a warm-up, let us begin with a short argument that the <span class="math">n</span>-th output of IS (integer squaring without modular reduction) requires about <span class="math">\\log(n)</span> depth in the <em>worst case</em>, via a sensitivity argument. Note that this bound is worse than that proved in the previous section, but it will be motivating for the average case.</p>

    <p class="text-gray-300">Lower bounds for the depth of modular squaring</p>

    <p class="text-gray-300">Theorem 8. There is an <span class="math">n</span>-bit <span class="math">x</span> such that the <span class="math">n</span>-th output bit of <span class="math">\\mathsf{IS}</span> has sensitivity at least <span class="math">n/2 - 1</span> at the point <span class="math">x</span>.</p>

    <p class="text-gray-300">Proof. For simplicity assume <span class="math">n</span> is even, and let <span class="math">x \\coloneqq \\sum_{j=n/2+1}^{n-1} 2^j</span>. Observe <span class="math">x^2</span> has a 0 in the <span class="math">n</span>-th output of <span class="math">\\mathsf{IS}</span>, because <span class="math">x^2 = \\sum_{j,k \\geq n/2+1} 2^{j+k}</span>, and <span class="math">j + k &amp;gt; n</span> for all <span class="math">j, k</span>.</p>

    <p class="text-gray-300">For every <span class="math">i = 0, \\dots, n/2 - 2</span>, there is exactly one <span class="math">j&#x27; \\in [n/2 + 1, n - 1]</span> such that <span class="math">i + j&#x27; = n - 1</span>. Therefore</p>

    <div class="my-4 text-center"><span class="math-block">(x^{(i)})^2 = (x + 2^i)^2 = \\sum_{j, k \\geq n/2 + 1} 2^{j + k} + \\sum_{j = n/2 + 1}^{n - 1} 2^{i + j + 1} + 2^{2i}</span></div>

    <p class="text-gray-300">has a 1 in the <span class="math">n</span>-th output (all <span class="math">i + j + 1</span>'s are distinct, larger than <span class="math">2i</span>, and smaller than the <span class="math">j + k</span>'s).</p>

    <p class="text-gray-300">Applying Proposition 4 directly, we get a (weak) depth lower bound for IS.</p>

    <p class="text-gray-300">Corollary 7. The <span class="math">n</span>-th output bit of <span class="math">\\mathsf{IS}</span> on <span class="math">n</span>-bit integers requires depth at least <span class="math">\\log_2(n/2 - 1) \\geq \\log_2(n) - 2</span>.</p>

    <p class="text-gray-300">We would like to extend such an argument to hold for the average case, showing that any circuit that can approximately compute IS still requires an interesting level of depth. The first obvious problem is that the "bad" input <span class="math">x</span> being chosen in the proof of Theorem 8 is not at all "random"! What we would like to show is that sensitivity of IS on random points is high. Given such a result, we could then use it to prove that all small circuits cannot approximate IS well in the average case.</p>

    <p class="text-gray-300">The Framework. Let <span class="math">\\delta \\in (0,1]</span> and <span class="math">\\varepsilon \\in (0,1/2)</span> in the following.</p>

    <p class="text-gray-300">Definition 4 ((<span class="math">\\delta, \\varepsilon</span>)-sensitivity). A function <span class="math">f: \\{0,1\\}^n \\to \\{0,1\\}</span> is (<span class="math">\\delta, \\varepsilon</span>)-sensitive if there are at least <span class="math">\\delta n</span> distinct values <span class="math">i \\in \\{0,1,\\ldots,n-1\\}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{x \\sim \\{0, 1\\}^n} \\left[ f(x) \\neq f(x^{(i)}) \\right] \\geq 1/2 - \\varepsilon.</span></div>

    <p class="text-gray-300">For small <span class="math">\\varepsilon &amp;gt; 0</span>, <span class="math">(\\delta, \\varepsilon)</span>-sensitivity means that there are at least <span class="math">\\delta n</span> input indices such that, for approximately half of the possible inputs <span class="math">x</span>, <span class="math">f</span> is sensitive at <span class="math">x</span> on all of those input indices. For our lower bounds, we will want <span class="math">\\varepsilon</span> to be as small (close to 0) as possible, and we want <span class="math">\\delta</span> to be as large (close to 1) as possible.</p>

    <p class="text-gray-300">The utility of <span class="math">(\\delta, \\varepsilon)</span>-sensitivity is captured by the following theorem.</p>

    <p class="text-gray-300">Theorem 9. Let <span class="math">\\varepsilon \\in (0,1/2)</span> and <span class="math">\\delta \\in (0,1]</span>. Assume <span class="math">f</span> is <span class="math">(\\delta, \\varepsilon)</span>-sensitive. Then for all <span class="math">n \\geq 1</span>, every fan-in two circuit with at most <span class="math">\\delta n - 2</span> gates fails to compute <span class="math">f</span> on at least a <span class="math">(1/4 - \\varepsilon/2)</span>-fraction of all <span class="math">n</span>-bit inputs. A similar statement holds for any (fan-in two) circuit with depth at most <span class="math">\\log_2(\\delta n - 1)</span>.</p>

    <p class="text-gray-300">Proof. Let <span class="math">C</span> be any <span class="math">n</span>-input circuit with <span class="math">\\delta n - 2</span> gates. First of all, note if <span class="math">\\delta n - 2 &amp;lt; 1</span> then the theorem is trivial. Without loss of generality, <span class="math">C</span> is minimal (otherwise, let us take a minimum-size circuit equivalent to <span class="math">C</span>). Recall that Proposition 3 (Section 3) shows that every minimal fan-in two circuit with at most <span class="math">(n - 1) - k</span> gates is degenerate in at least <span class="math">k</span> variables. Thus our circuit <span class="math">C</span> is degenerate in at least <span class="math">n + 1 - \\delta n</span> variables (for example, if <span class="math">\\delta = 1</span>, then <span class="math">C</span> is degenerate in at least one variable). Thus there are variable indices <span class="math">i_1, \\ldots, i_{n + 1 - \\delta n} \\in [n]</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\text{For every } x \\in \\{0, 1\\}^n \\text{ and } j = 1, \\dots, n + 1 - \\delta n, C(x) = C(x^{(i_j)}). \\tag{1}</span></div>

    <p class="text-gray-300">2 Please note that the <span class="math">(\\delta, \\varepsilon)</span>-sensitivity of <span class="math">f</span> is not at all the same as the concept in the literature of the "average sensitivity of <span class="math">f</span>", which is the expected value of the sensitivity of <span class="math">f</span> at uniform random input.</p>

    <p class="text-gray-300">We show that, under the hypotheses, that <span class="math">C</span> fails to compute <span class="math">f</span> correctly on at least a <span class="math">1/4-\\varepsilon/2</span> fraction of all <span class="math">n</span>-bit inputs. The key observation is that, if <span class="math">f</span> is <span class="math">(\\delta,\\varepsilon)</span>-sensitive, then there are at least <span class="math">\\delta n</span> distinct <span class="math">i\\in[n]</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\sim\\{0,1\\}^{n}}[f(x)\\neq f(x^{(i)})]\\geq 1/2-\\varepsilon,</span> (2)</p>

    <p class="text-gray-300">but there are also at least <span class="math">n+1-\\delta n</span> values in <span class="math">[n]</span> such that <span class="math">C(x)=C(x^{(i_{j})})</span> is true for all <span class="math">x</span>. By the pigeonhole principle, there must be an index <span class="math">i\\in[n]</span> such that both <span class="math">C(x)=C(x^{(i)})</span> holds for all <span class="math">x</span>, and (2) is true.</p>

    <p class="text-gray-300">Fix such an <span class="math">i</span>, and pair up all inputs in <span class="math">\\{0,1\\}^{n}</span> into the <span class="math">2^{n-1}</span> disjoint pairs <span class="math">(x,x^{(i)})</span>. Define</p>

    <p class="text-gray-300"><span class="math">S:=\\{(x,x^{(i)})\\mid f(x)\\neq f(x^{(i)})\\}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">f</span> is <span class="math">(\\delta,\\varepsilon)</span>-sensitive, there are at least <span class="math">(1/2-\\varepsilon)\\cdot 2^{n}</span> distinct <span class="math">x\\in\\{0,1\\}^{n}</span> such that the pair <span class="math">(x,x^{(i)})</span> has <span class="math">f(x)\\neq f(x^{(i)})</span>. This implies $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq(1/2-\\varepsilon)\\cdot 2^{n-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By our choice of <span class="math">i</span>, we also have <span class="math">C(x)=C(x^{(i)})</span> for all <span class="math">x</span>. Because <span class="math">f(x)\\neq f(x^{(i)})</span> for all <span class="math">(x,x^{(i)})\\in S</span>, it follows that <span class="math">C</span> computes <span class="math">f</span> correctly on exactly <em>one</em> string in each pair <span class="math">(x,x^{(i)})\\in S</span>. Therefore there are at least <span class="math">(1/2-\\varepsilon)\\cdot 2^{n-1}=(1/4-\\varepsilon/2)\\cdot 2^{n}</span> inputs <span class="math">y</span> such that <span class="math">C(y)\\neq f(y)</span>, so the circuit <span class="math">C</span> errs on at least a <span class="math">1/4-\\varepsilon/2</span> fraction of all inputs.</p>

    <p class="text-gray-300">The depth lower bound follows analogously to the proof of Proposition 2. ∎</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Applying the Framework.</h4>

    <p class="text-gray-300">We would like to apply Theorem 9 to obtain Theorem 3. This requires us to study the <span class="math">(\\delta,\\varepsilon)</span>-sensitivity of bits of modular squaring. On a number-theoretic level, it is easier to work with the situation of picking <span class="math">x</span> at random from <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span>, but for the purposes of applying Theorem 3, we need to consider the case where <span class="math">x</span> is a uniform random <span class="math">n</span>-bit string (viewed as an integer in <span class="math">\\{0,1,\\ldots,2^{n}-1\\}</span>). To this end, consider the experiment when we pick <span class="math">x\\in\\{0,1\\}^{n}</span> at random, and let <span class="math">x^{(i)}</span> be the <span class="math">i</span>-th bit flipped. More formally, if <span class="math">x=(x_{n-1},\\ldots,x_{0})\\in\\{0,1\\}^{n}</span>, we can define</p>

    <p class="text-gray-300"><span class="math">x^{(i)}:=x+(1-2x_{i})2^{i}.</span></p>

    <p class="text-gray-300">Note that under this definition, <span class="math">x^{(i)}=x+2^{i}</span> if the <span class="math">i</span>-th bit of <span class="math">x_{i}</span> is <span class="math">0</span>, and otherwise equals <span class="math">x-2^{i}</span>. We observe an easy proposition.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proposition 7.</h6>

    <p class="text-gray-300">The distribution of outputs of <span class="math">(x\\bmod m)</span> over <span class="math">x\\sim\\mathbf{Z}/m\\mathbf{Z}</span> and the distribution of <span class="math">(x\\bmod m)</span> over <span class="math">x\\sim\\{0,1,\\ldots,2^{n}-1\\}</span> are identical, up to additive <span class="math">1/2^{n}</span> factors in the probabilities.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider the distribution <span class="math">\\mathcal{D}</span> which chooses a uniform random <span class="math">x\\in\\{0,1,\\ldots,2^{n}-1\\}</span>, and outputs <span class="math">(x\\bmod m)\\in\\{0,\\ldots,m-1\\}</span>. This distribution <span class="math">\\mathcal{D}</span> partitions <span class="math">\\{0,\\ldots,2^{n}-1\\}</span> of cardinality <span class="math">2^{n}</span> into <span class="math">m</span> equivalence classes, where each class contains at least <span class="math">2^{n}/m-1</span> elements and at most <span class="math">2^{n}/m+1</span> elements. Thus for all <span class="math">t\\in\\mathbf{Z}/m\\mathbf{Z}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\sim\\{0,1,\\ldots,2^{n}-1\\}}[(x\\bmod m)=t]\\in[1/m-1/2^{n},1/m+1/2^{n}].</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence $\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr_{x\\sim\\{0,1,\\ldots,2^{n}-1\\}}[(x\\bmod m)=t]-\\Pr_{x\\sim\\mathbf{Z}/m\\mathbf{Z}}[(x\\bmod m)=t]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 1/2^{n}$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, the two distributions of outputs of <span class="math">(x^{2}\\bmod m)\\bmod 2</span> (over <span class="math">x\\sim\\mathbf{Z}/m\\mathbf{Z}</span> and <span class="math">x\\sim\\{0,1,\\ldots,2^{n}-1\\}</span>) are also identical up to <span class="math">1/2^{n}</span> as well, so proving <span class="math">(\\delta,\\varepsilon)</span>-sensitivity results for <span class="math">x</span> chosen at random from <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span> imply analogous results for <span class="math">x</span> chosen at random from <span class="math">\\{0,1\\}^{n}</span> (construed as a non-negative integer).</p>

    <p class="text-gray-300">The following two results are proved in Section 6 and Section 6.1. Keeping in mind Proposition 7, these results are immediate corollaries of Theorem 12 and Theorem 13, respectively.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 10 (Squaring Sensitivity Theorem 1).</h6>

    <p class="text-gray-300">For all odd <span class="math">2^{n-1}\\leq m\\leq 2^{n}-1</span>, and all <span class="math">\\varepsilon&gt;0</span>, the function MS-MOD2_{n,m} is <span class="math">\\Big{(}1/4+\\frac{\\log_{2}(\\varepsilon)}{n}+o(1),\\varepsilon\\Big{)}</span>-sensitive, where <span class="math">o(1)</span> does not depend on <span class="math">\\varepsilon</span> and <span class="math">\\lim_{n\\to\\infty}o(1)=0</span>.</p>

    <p class="text-gray-300">To obtain concrete lower bounds, one should explicitly estimate the <span class="math">o(1)</span> term appearing in Theorem 10. When <span class="math">m</span> is an RSA modulus (the case of interest in all modular squaring applications we are aware of) we obtain the following explicit result.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 11 (Squaring Sensitivity Theorem 2).</h6>

    <p class="text-gray-300">For all <span class="math">n\\geq 38</span>, let <span class="math">p,q</span> be primes in <span class="math">[2^{n/2-1},2^{n/2})</span>. For all <span class="math">\\varepsilon&gt;0</span>, the function MS-MOD2_{n,pq} is <span class="math">\\Big{(}1/4+\\frac{\\log_{2}(\\varepsilon)-\\log_{2}(5.8)}{n},\\varepsilon\\Big{)}</span>-sensitive.</p>

    <p class="text-gray-300">Putting the pieces together, we can complete the proof of Theorem 3.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Proof of Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">C</span> be a circuit computing MS correctly on at least <span class="math">76\\%</span> of all <span class="math">n</span>-bit integers, modulo an RSA modulus <span class="math">m</span> as specified in the theorem. By Theorem 11, the least significant output bit of <span class="math">C</span> is <span class="math">\\Big{(}1/4+\\frac{\\log_{2}(\\varepsilon)-\\log_{2}(5.8)}{n},\\varepsilon\\Big{)}</span>-sensitive. By Theorem 9, every fan-in two circuit with at most <span class="math">\\delta n-2</span> gates fails to compute <span class="math">f</span> on at least a <span class="math">(1/4-\\varepsilon/2)</span>-fraction of all <span class="math">n</span>-bit input, where <span class="math">\\delta=1/4+\\frac{\\log_{2}(\\varepsilon)-\\log_{2}(5.8)}{n}</span>. Setting <span class="math">\\varepsilon=1/50</span>, the fraction becomes <span class="math">24\\%</span>, and <span class="math">\\delta n=n/4+\\log_{2}(1/50)-\\log_{2}(5.8)&gt;n/4-8.2</span>. Therefore the circuit size lower bound is at least <span class="math">n/4-8.2</span>, and the resulting depth lower bound is at least <span class="math">\\log_{2}(n/4-7.2)</span> (by an analogous argument as the proof of Proposition 2). ∎</p>

    <h3 id="sec-55" class="text-xl font-semibold mt-8">5.1 Discussion</h3>

    <p class="text-gray-300">Before we move to the proofs of the Squaring Sensitivity Theorems, it is worth noting why we had to introduce a notion of <span class="math">(\\delta,\\varepsilon)</span>-sensitivity, to prove what we did. It would be natural to conjecture (and we originally did) that for <em>all</em> indices <span class="math">i\\in[n]</span>, the low-order bit of <span class="math">(x^{2}\\bmod m)</span> differs from the low-order bit of <span class="math">((x^{(i)})^{2}\\bmod m)</span> with probability approximately <span class="math">1/2</span>, over a uniform random choice of <span class="math">x\\sim\\mathbf{Z}/m\\mathbf{Z}</span>.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Conjecture 1 (A Bad Squaring Sensitivity Conjecture).</h6>

    <p class="text-gray-300">For all fixed constant <span class="math">\\varepsilon&gt;0</span>, for all large enough <span class="math">n</span>, for all odd (square-free) <span class="math">2^{n-1}\\leq m\\leq 2^{n}-1</span>, and for all <span class="math">i\\in\\{0,1,\\ldots,n-1\\}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{x\\sim\\mathbf{Z}/m\\mathbf{Z}}[(x^{2}\\bmod m)\\bmod 2\\neq((x^{(i)})^{2}\\bmod m)\\bmod 2]\\geq 1/2-\\varepsilon.</span></p>

    <p class="text-gray-300">That is, Conjecture 1 posits that the parity of <span class="math">(x^{2}\\bmod m)</span> differs from the parity of <span class="math">((x^{(i)})^{2}\\bmod m)</span> with probability very close to <span class="math">1/2</span>, when <span class="math">x</span> is chosen uniformly at random from <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span>. It turns out that Conjecture 1 is false as stated (reference omitted here to preserve anonymity) and we had to resort to weaker claims where a <span class="math">\\delta</span>-fraction of the variables are sensitive on random inputs for some <span class="math">\\delta&lt;1</span>.</p>

    <h2 id="sec-57" class="text-2xl font-bold">6 The Least Significant Bit of Modular Squaring</h2>

    <p class="text-gray-300">Let <span class="math">m</span> be any odd, positive integer. Recall we identify <span class="math">\\mathbf{Z}/m\\mathbf{Z}</span> with <span class="math">\\{0,\\ldots,m-1\\}</span>, so that <span class="math">x\\bmod m</span> denotes the least positive residue of <span class="math">x</span> modulo <span class="math">m</span>. For the rest of this section, let <span class="math">f:\\mathbf{Z}/m\\mathbf{Z}\\to\\mathbf{C}^{\\times}</span> be the function induced by MS-MOD2_{n,m}, i.e.,</p>

    <p class="text-gray-300">\\[ f(x)=\\begin{cases}0&\\text{ if }x\\bmod m\\text{ is even,}\\\\ 1&\\text{ if }x\\bmod m\\text{ is odd,}\\end{cases} \\]</p>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <p class="text-gray-300">For any integer <span class="math">i</span>, and any <span class="math">x \\in \\mathbf{Z} / m\\mathbf{Z}</span>, let <span class="math">x^{(i)}</span> be the class of <span class="math">x \\bmod m</span> with the <span class="math">i</span>-th bit flipped. The goal of this section to prove the following theorem, which states that for any integer <span class="math">i \\in [0, \\log_2(m)(1/4 + o(1))]</span>, the least significant bits of <span class="math">x^2</span> and <span class="math">(x^{(i)})^2</span> are essentially independent, when <span class="math">x \\in \\mathbf{Z} / m\\mathbf{Z}</span> is uniformly distributed.</p>

    <p class="text-gray-300"><strong>Theorem 12.</strong> We have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\# \\{x \\in \\mathbf {Z} / m \\mathbf {Z} \\mid f (x ^ {2}) \\neq f ((x ^ {(i)}) ^ {2}) \\}}{m} - \\frac {1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac {2 ^ {2 i}}{m ^ {1 / 2 + o (1)}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300"><strong>Notation.</strong> For any <span class="math">x \\in \\mathbf{R}</span>, let <span class="math">e(x) = e^{2\\pi ix}</span>. For any integer <span class="math">a</span>, define the character <span class="math">\\chi_{a}</span> of <span class="math">\\mathbf{Z} / m\\mathbf{Z}</span> as <span class="math">\\chi_{a}(x) = e\\left(\\frac{ax}{a}\\right)</span>. For any integer <span class="math">x</span>, let <span class="math">\\llbracket x\\rrbracket_{m} = \\min (x \\bmod m, (-x) \\bmod m)</span> be the distance of <span class="math">x</span> to the closest multiple of <span class="math">m</span>. The function <span class="math">\\log</span> is the natural logarithm, in base <span class="math">e</span>.</p>

    <p class="text-gray-300">We now prove Theorem 12, and in Section 6.1, we specialise it to the case of RSA moduli and obtain explicit bounds. Let <span class="math">f^{(i)}(x)</span> be the <span class="math">i</span>-th least significant bit of <span class="math">x \\bmod m</span>. In particular, for our function <span class="math">f</span> we have <span class="math">f = f^{(0)}</span>.</p>

    <p class="text-gray-300">These functions <span class="math">f^{(i)}</span> are useful to study how flipping the <span class="math">i</span>-th bit affects the output of any function <span class="math">g: \\mathbf{Z} / m\\mathbf{Z} \\to \\mathbf{C}</span>, since</p>

    <div class="my-4 text-center"><span class="math-block">g \\left(x ^ {(i)}\\right) = f ^ {(i)} (x) g \\left(x - 2 ^ {i}\\right) + \\left(1 - f ^ {(i)} (x)\\right) g \\left(x + 2 ^ {i}\\right). \\tag {3}</span></div>

    <p class="text-gray-300">In particular, these bit functions can be used to compute the size of the set in Theorem 12.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1.</strong> We have <span class="math">\\# \\{x\\in \\mathbf{Z} / m\\mathbf{Z}\\mid f(x^2)\\neq f((x^{(i)})^2)\\} = 2A - 4C + \\varepsilon</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i + 2}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">A = \\sum_ {x} f (x ^ {2}), \\text{ and } C = \\sum_ {x} f ^ {(i)} (x) f (x ^ {2}) f ((x - 2 ^ {i}) ^ {2}).</span></div>

    <p class="text-gray-300"><strong>Proof.</strong> We have</p>

    <div class="my-4 text-center"><span class="math-block">\\# \\{x \\in \\mathbf {Z} / m \\mathbf {Z} \\mid f (x ^ {2}) \\neq f ((x ^ {(i)}) ^ {2}) \\} = \\sum_ {x} f (x ^ {2}) + \\sum_ {x} f ((x ^ {(i)}) ^ {2}) - 2 \\sum_ {x} f (x ^ {2}) f ((x ^ {(i)}) ^ {2}).</span></div>

    <p class="text-gray-300">Applying Equation (3) to the function <span class="math">g: x \\mapsto f(x^2)</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">f ((x ^ {(i)}) ^ {2}) = f ^ {(i)} (x) f ((x - 2 ^ {i}) ^ {2}) + f ((x + 2 ^ {i}) ^ {2}) - f ^ {(i)} (x) f ((x + 2 ^ {i}) ^ {2}).</span></div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">A = \\sum_ {x} f (x ^ {2}), \\quad B _ {\\alpha} = \\sum_ {x} f ^ {(i)} (x) f ((x + \\alpha) ^ {2}),</span></div>

    <div class="my-4 text-center"><span class="math-block">C _ {\\alpha} = \\sum_ {x} f ^ {(i)} (x) f (x ^ {2}) f ((x + \\alpha) ^ {2}), \\quad D _ {\\alpha} = \\sum_ {x} f (x ^ {2}) f ((x + \\alpha) ^ {2}),</span></div>

    <p class="text-gray-300">for <span class="math">\\alpha = \\pm 2^{i}</span>. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\# \\{x \\in \\mathbf {Z} / m \\mathbf {Z} \\mid f (x ^ {2}) = f ((x ^ {(i)}) ^ {2}) \\} = 2 A - (B _ {2 ^ {i}} - B _ {- 2 ^ {i}}) + 2 (C _ {2 ^ {i}} - C _ {- 2 ^ {i}}) - 2 D _ {2 ^ {i}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us estimate $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{2^i} - B_{-2^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. With </span>S = \\{x \\mid f^{(i)}(x + 2^{i+1}) \\neq f^{(i)}(x)\\}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} B _ {- 2 ^ {i}} = \\sum_ {x} f ^ {(i)} (x) f ((x - 2 ^ {i}) ^ {2}) = \\sum_ {x} f ^ {(i)} (x + 2 ^ {i + 1}) f ((x + 2 ^ {i}) ^ {2}) \\\\ = \\sum_ {x} f ^ {(i)} (x) f ((x + 2 ^ {i}) ^ {2}) + \\sum_ {x \\in S} (f ^ {(i)} (x + 2 ^ {i + 1}) - f ^ {(i)} (x)) f ((x + 2 ^ {i}) ^ {2}) \\\\ = B _ {2 ^ {i}} + \\sum_ {x \\in S} (1 - 2 f ^ {(i)} (x)) f ((x + 2 ^ {i}) ^ {2}). \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Lower bounds for the depth of modular squaring</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\# S \\leq 2^{i+1}</span>, we deduce $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B_{2^i} - B_{-2^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i+1}<span class="math">. Now, with </span>T = \\{x \\mid f^{(i)}(x + 2^i) \\neq 1 - f^{(i)}(x)\\}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} C_{-2^i} &amp;amp;= \\sum_x f^{(i)}(x) f(x^2) f((x - 2^i)^2) \\\\ &amp;amp;= \\sum_x f^{(i)}(x + 2^i) f((x + 2^i)^2) f(x^2) \\\\ &amp;amp;= \\sum_x (1 - f^{(i)}(x)) f((x + 2^i)^2) f(x^2) + \\sum_{x \\in T} (2 f^{(i)}(x) - 1) f((x + 2^i)^2) f(x^2) \\\\ &amp;amp;= D_{2^i} - C_{2^i} + \\sum_{x \\in T} (2 f^{(i)}(x) - 1) f((x + 2^i)^2) f(x^2). \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since <span class="math">\\# T \\leq 2^i</span>, we deduce that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_{2^i} + C_{-2^i} - D_{2^i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^i$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">2A + (B_{-2^i} - B_{2^i}) + 2(C_{2^i} - C_{-2^i}) - 2D_{2^i} = 2A - 4C_{-2^i} + \\varepsilon,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\varepsilon = (B_{-2^i} - B_{2^i}) + 2(C_{2^i} + C_{-2^i} - D_{2^i})</span>, so $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i+2}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Fourier decomposition of the bit functions.</strong> It remains to estimate the terms <span class="math">A</span> and <span class="math">C</span> from Lemma 1. To do so, we decompose the bit functions <span class="math">f^{(i)}</span> as character sums.</p>

    <p class="text-gray-300"><strong>Proposition 8.</strong> We have the Fourier decomposition</p>

    <div class="my-4 text-center"><span class="math-block">f(x) = \\frac{1}{m} \\sum_{\\chi \\in \\mathbf{Z}/m\\mathbf{Z}} c_{\\chi} \\chi(x),</span></div>

    <p class="text-gray-300">with <span class="math">c_{\\chi_0} = \\frac{m-1}{2}</span> and <span class="math">c_{\\chi} = \\frac{-1}{1+\\chi(1)}</span> for any <span class="math">\\chi \\neq \\chi_0</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> We have <span class="math">f(x) = \\frac{1}{m} \\sum_{\\chi} c_{\\chi} \\chi(x)</span>, where <span class="math">c_{\\chi} = \\sum_{x \\in \\mathbf{Z}/m\\mathbf{Z}} f(x) \\chi(x)</span>. Let <span class="math">T = \\{x \\in \\mathbf{Z}/m\\mathbf{Z} \\mid f(x) = 1\\}</span>. We have $c_{\\chi_0} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{m-1}{2}$. Now,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">c_{\\chi} = \\sum_{x \\in T} \\chi(x) = \\sum_{x \\in T} \\chi(x + 2) + \\chi(1) - \\chi(m) = c_{\\chi} \\chi(2) + \\chi(1) - 1.</span></div>

    <p class="text-gray-300">We deduce that <span class="math">c_{\\chi} = -(1 - \\chi(1)) / (1 - \\chi(2)) = -1 / (1 + \\chi(1))</span> for any <span class="math">\\chi \\neq \\chi_0</span>.</p>

    <p class="text-gray-300">The following lemma allows to bound the Fourier coefficients <span class="math">c_{\\chi}</span>, as well as the coefficients of the functions <span class="math">f^{(i)}</span>, in Proposition 9.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 2.</strong> For any integers <span class="math">a</span> and <span class="math">b</span>, we have $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + \\chi_a(b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{m}{2(m - 2\\sharp ab\\sharp_m)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> Observe that, for any <span class="math">x \\in [0,1]</span>, we have <span class="math">1 + \\cos(2\\pi x) \\geq 2(2x - 1)^2</span>. So for any <span class="math">x \\in [0,1]</span>, we have $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + e(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{1}{\\sqrt{2 + 2\\cos(2\\pi x)}} \\leq \\frac{1}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2x - 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Therefore, for any integers </span>a<span class="math"> and </span>b<span class="math">, </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + \\chi_a(b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{m}{2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2(ab \\bmod m) - m</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{m}{2(m - 2\\sharp ab\\sharp_m)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proposition 9.</strong> For all <span class="math">i \\in [n]</span>, we have the Fourier decomposition</p>

    <div class="my-4 text-center"><span class="math-block">f^{(i)}(x) = \\frac{1}{m} \\sum_{\\chi \\in \\mathbf{Z}/m\\mathbf{Z}} c_{\\chi}^{(i)} \\chi(x),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_0}^{(i)} - \\frac{m}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i-1}<span class="math"> and </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_*}^{(i)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{m2^i}{2(m - 2\\sharp a2^i\\sharp_m)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let <span class="math">T^{(i)} = \\{x \\in \\mathbf{Z} / m\\mathbf{Z} \\mid f^{(i)}(x) = 1\\}</span>. First, we have $c_{\\chi_0}^{(i)} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T^{(i)} - \\frac{m}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i-1}<span class="math">. Now, for any character </span>\\chi$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {\\chi} ^ {(i)} = \\sum_ {x \\in T ^ {(i)}} \\chi (x) = \\sum_ {x \\in T ^ {(i)}} \\chi (x + 2 ^ {i + 1}) + \\sum_ {x = 2 ^ {i}} ^ {2 ^ {i + 1} - 1} \\chi (x) - \\sum_ {x \\in T ^ {(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x + 2 ^ {i + 1} \\geq m} \\chi (x + 2 ^ {i + 1}).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let <span class="math">[z, z&#x27;] = [0, 2^i - 1] \\cap \\{x + 2^{i+1} - m \\mid x \\in T^{(i)} \\text{ and } x + 2^{i+1} \\geq m\\}</span>. For any non-trivial <span class="math">\\chi</span>, we have <span class="math">\\chi(2^{i+1}) \\neq 1</span> (recall that <span class="math">m</span> is odd), so</p>

    <div class="my-4 text-center"><span class="math-block">c _ {\\chi} ^ {(i)} = \\frac {1}{1 - \\chi (2 ^ {i + 1})} \\left(\\sum_ {x = z} ^ {z ^ {\\prime}} (\\chi (x + 2 ^ {i}) - \\chi (x))\\right) = \\frac {- 1}{1 + \\chi (2 ^ {i})} \\left(\\sum_ {x = z} ^ {z ^ {\\prime}} \\chi (x)\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It follows that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_o}^{(i)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{m2^i}{2(m - 2[[a2^i]]_m)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Notation 1. In the rest of the paper, we use the notation <span class="math">c_{\\chi}</span> and <span class="math">c_{\\chi}^{(i)}</span> for the Fourier coefficients of <span class="math">f</span> and <span class="math">f^{(i)}</span> given in Propositions 8 and 9 respectively.</p>

    <p class="text-gray-300">Gauss sums. Observe that <span class="math">A = \\sum_{x} f(x^{2}) = \\frac{1}{m} \\sum_{\\chi} c_{\\chi} \\sum_{x} \\chi(x^{2})</span>, and <span class="math">\\sum_{x} \\chi(x^{2})</span> is a Gauss sum. Generalised Gauss sums also appear in <span class="math">C</span>, and play an important role in our estimates of these two quantities.</p>

    <p class="text-gray-300">Definition 5. For any integers <span class="math">a, b, m</span>, the generalised Gauss sum is</p>

    <div class="my-4 text-center"><span class="math-block">G (a, b, m) = \\sum_ {x \\in \\mathbf {Z} / m \\mathbf {Z}} e \\left(\\frac {a x ^ {2} + b x}{m}\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 3. We have $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G(a,b,m)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\{ \\begin{array}{ll} \\sqrt{(a,m)m} &amp; \\text{if } (a,m) \\mid b, \\\\ 0 &amp; \\text{otherwise.} \\end{array} \\right.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. This is a classical result; we include a proof for completeness. We have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {x} e \\left(\\frac {a x ^ {2} + b x}{m}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^ {2} = \\sum_ {x, y} e \\left(\\frac {a x ^ {2} + b x}{m}\\right) e \\left(- \\frac {a y ^ {2} + b y}{m}\\right) \\\\ = \\sum_ {x, y} e \\left(\\frac {a (x + y) + b}{m}\\right) ^ {x - y} = \\sum_ {s} \\sum_ {t} e \\left(\\frac {a s + b}{m}\\right) ^ {t} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since <span class="math">\\sum_{t} e\\left(\\frac{as + b}{m}\\right)^{t}</span> is <span class="math">m</span> if <span class="math">as + b \\equiv 0 \\mod m</span> and 0 otherwise. We conclude by counting the number of solutions of <span class="math">as + b \\equiv 0 \\mod m</span>.</p>

    <p class="text-gray-300">Estimating <span class="math">A</span>. Here we estimate the term <span class="math">A</span> from Lemma 1.</p>

    <p class="text-gray-300">Lemma 4. For any odd positive integer <span class="math">h</span>, <span class="math">\\sum_{k=0}^{h-1} \\frac{1}{h-2[[k]]_h} \\leq \\log(h) + 2.31</span>.</p>

    <p class="text-gray-300">Proof. The result is immediate if <span class="math">h = 1</span>. For <span class="math">h &amp;gt; 1</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\sum_ {k = 0} ^ {h - 1} \\frac {1}{h - 2 [ [ k ] ] _ {h}} = \\sum_ {k = 1} ^ {(h - 1) / 2} \\frac {2}{2 k - 1} + \\frac {1}{h} \\leq \\left(2 + \\sum_ {k = 1} ^ {(h - 1) / 2} \\frac {1}{k}\\right) \\leq \\log (h - 1) + 3 - \\log (2) \\\\ \\leq \\log (h) + 2. 3 1, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where the penultimate inequality uses <span class="math">\\sum_{k=1}^{n} \\frac{1}{k} \\leq \\log(n) + 1</span>.</p>

    <p class="text-gray-300">Lower bounds for the depth of modular squaring</p>

    <p class="text-gray-300">Proposition 10. We have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac {m + 1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {\\sqrt {m}}{2} \\sum_ {g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m, g \\neq m} \\frac {1}{\\sqrt {g}} \\left(\\log (m / g) + 2. 3 1\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. For any integer  <span class="math">a</span> , define the character  <span class="math">\\chi_{a}(x) = e(ax / m)</span> . We get</p>

    <div class="my-4 text-center"><span class="math-block">A = \\sum_ {x} f (x ^ {2}) = \\frac {1}{m} \\sum_ {a} c _ {\\chi_ {a}} \\sum_ {x} \\chi_ {a} (x ^ {2}) = \\frac {1}{m} \\sum_ {a} c _ {\\chi_ {a}} G (a, 0, m) = \\frac {m + 1}{2} + \\frac {1}{m} \\sum_ {a \\neq 0} \\frac {G (a , 0 , m)}{1 + \\chi_ {a} (1)}.</span></div>

    <p class="text-gray-300">Applying Lemma 3, we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac {m + 1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {1}{m} \\sum_ {a \\neq 0} \\frac {G (a , 0 , m)}{1 + \\chi_ {a} (1)} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {1}{\\sqrt {m}} \\sum_ {a \\neq 0} \\frac {\\sqrt {(a , m)}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + \\chi_ {a} (1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\quad (4) \\\\ = \\frac {1}{\\sqrt {m}} \\sum_ {g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m, g \\neq m} \\sqrt {g} \\sum_ {k \\in (\\mathbf {Z} / (m / g) \\mathbf {Z}) ^ {\\times}} \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + \\chi_ {g k} (1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}. \\tag {5} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">With  <span class="math">h = m / g</span> , and applying Lemmata 2 and 4, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_ {k \\in (\\mathbf {Z} / h \\mathbf {Z}) ^ {\\times}} \\frac {1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 + \\chi_ {g k} (1)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\sum_ {k = 0} ^ {h - 1} \\frac {h}{2 (h - 2 [ k ] _ {h})} \\leq \\frac {h}{2} (\\log (h) + 2. 3 1),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We conclude by applying the above inequality to Equation (5).</p>

    <p class="text-gray-300">Estimating  <span class="math">C</span> . We turn to estimating the term  <span class="math">C</span>  from Lemma 1. We have</p>

    <div class="my-4 text-center"><span class="math-block">C = \\sum_ {x} f ^ {(i)} (x) f ((x - 2 ^ {i}) ^ {2}) f (x ^ {2}) = \\frac {1}{m ^ {3}} \\sum_ {a, b, c} c _ {\\chi_ {a}} ^ {(i)} c _ {\\chi_ {b}} c _ {\\chi_ {c}} \\sum_ {x} \\chi_ {a} (x) \\chi_ {b} ((x - 2 ^ {i}) ^ {2}) \\chi_ {c} (x ^ {2}).</span></div>

    <p class="text-gray-300">With  <span class="math">d = b + c = kg</span>  where  <span class="math">g = \\gcd(d, m)</span> , and  <span class="math">f = a - b2^{i+1} = g\\ell</span> , we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} C = \\frac {1}{m ^ {3}} \\sum_ {a, b, c} c _ {\\chi_ {a}} ^ {(i)} c _ {\\chi_ {b}} c _ {\\chi_ {c}} e \\left(\\frac {b 2 ^ {2 i}}{m}\\right) G (b + c, a - 2 b 2 ^ {i}, m) \\\\ = \\frac {1}{m ^ {3}} \\sum_ {b, d, e} c _ {\\chi_ {f + b 2 ^ {i + 1}}} ^ {(i)} c _ {\\chi_ {b}} c _ {\\chi_ {d - b}} e \\left(\\frac {b 2 ^ {2 i}}{m}\\right) G (d, f, m) = \\sum_ {g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m} \\sum_ {b \\in \\mathbf {Z} / g \\mathbf {Z}} E (g, b), \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">E (g, b) = \\frac {1}{m ^ {3}} \\sum_ {k \\in (\\mathbf {Z} / (m / g) \\mathbf {Z}) ^ {\\times}} \\sum_ {n, \\ell \\in \\mathbf {Z} / (m / g) \\mathbf {Z}} c _ {\\chi_ {\\ell g + b 2 ^ {i + 1}}} ^ {(i)} c _ {\\chi_ {n g + b}} c _ {\\chi_ {k g - b}} e \\left(\\frac {b 2 ^ {2 i}}{m}\\right) G (k g, \\ell g, m).</span></div>

    <p class="text-gray-300">Applying Lemma 3, we get</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E (g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {\\sqrt {m}}{m ^ {3}} \\sum_ {k \\in (\\mathbf {Z} / (m / g) \\mathbf {Z}) ^ {\\times}} \\sum_ {n, \\ell \\in \\mathbf {Z} / (m / g) \\mathbf {Z}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c _ {\\chi_ {\\ell g + b 2 ^ {i + 1}}} ^ {(i)} c _ {\\chi_ {n g + b}} c _ {\\chi_ {k g - b}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sqrt {g}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Fixing a divisor  <span class="math">g</span>  of  <span class="math">m</span> , and a non-zero element  <span class="math">b \\in \\mathbf{Z} / g\\mathbf{Z}</span> , the quantity  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g,b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\sqrt {m g} 2 ^ {i}}{8} \\left(\\sum_ {\\ell = 0} ^ {m / g - 1} \\frac {1}{m - 2 [ (\\ell g + b 2 ^ {i + 1}) 2 ^ {i} ] _ {m}}\\right) \\left(\\sum_ {n = 0} ^ {m / g - 1} \\frac {1}{m - 2 [ n g + b ] _ {m}}\\right) \\left(\\sum_ {k = 0} ^ {m / g - 1} \\frac {1}{m - 2 [ k g - b ] _ {m}}\\right).</span></div>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <p class="text-gray-300">Lemma 5. For any divisor <span class="math">g</span> of <span class="math">m</span> and any integer <span class="math">b</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{k=0}^{m/g-1} \\frac{1}{m - 2[[kg + b]]_m} \\leq \\frac{1}{g - 2[[b]]_g} + \\frac{\\log(m/g) + 2.31}{g}.</span></div>

    <p class="text-gray-300">Proof. Without loss of generality, <span class="math">b = [[b]]_g \\leq (g - 1)/2</span>. There is at most one <span class="math">k</span>-value such that <span class="math">m - 2[[kg - b]]_m &amp;lt; g</span>. It is the value <span class="math">k = (m/g - 1)/2</span>, for which we have <span class="math">m - 2[[kg - b]]_m = g - 2[[b]]_g</span>. Splitting the sum around this value, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\sum_{k=0}^{m/g-1} \\frac{1}{m - 2[[kg + b]]_m} \\\\ &amp;amp; = \\frac{1}{g - 2[[b]]_g} + \\sum_{k=0}^{(m/g-1)/2-1} \\frac{1}{m - 2[[kg + b]]_m} + \\sum_{k=(m/g-1)/2+1}^{m/g-1} \\frac{1}{m - 2[[kg + b]]_m} \\\\ &amp;amp; \\leq \\frac{1}{g - 2[[b]]_g} + \\sum_{k=0}^{(m/g-1)/2-1} \\frac{1}{m - 2[(k+1)g]_m} + \\sum_{k=(m/g-1)/2+1}^{m/g-1} \\frac{1}{m - 2[[kg]]_m} \\\\ &amp;amp; = \\frac{1}{g - 2[[b]]_g} + \\frac{1}{g} \\sum_{k=1}^{m/g-1} \\frac{1}{(m/g) - 2[(k+1)]_{m/g}} \\leq \\frac{1}{g - 2[[b]]_g} + \\frac{\\log(m/g) + 2.31}{g}, \\end{aligned}</span></div>

    <p class="text-gray-300">where the last inequality comes from Lemma 4.</p>

    <p class="text-gray-300">Let <span class="math">L(g) = \\frac{\\log(m/g) + 2.31}{g}</span> for <span class="math">g \\neq m</span> and <span class="math">L(m) = 0</span>.</p>

    <p class="text-gray-300">Proposition 11. For any <span class="math">g \\mid m</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{b=1}^{g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{m g} 2^{i-3} (\\mathcal{L}(g) + 2.83),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\mathcal{L}(g) = L(g)\\left(3\\log(g) + 6.93 + 3(g - 1)L(g) + (g - 1)L(g)^2\\right)</span>. If <span class="math">2^{2i} &amp;lt; g/12</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{b=1}^{g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{m g} 2^{i-3} \\left(\\mathcal{L}(g) + \\frac{5.66 + 2^{2i+3}}{g}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. We have</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\leq \\frac{\\sqrt{m g} 2^i}{8} \\left(\\frac{1}{g - 2[[b2^{2i+1}]]_g} + L(g)\\right) \\left(\\frac{1}{g - 2[[b]]_g} + L(g)\\right)^2, \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp; \\leq \\frac{\\sqrt{m g} 2^i}{8} \\left(L(g) \\left(\\frac{3}{g - 2[[b]]_g} + 3L(g) + L(g)^2\\right) + \\frac{1}{g - 2[[b2^{2i+1}]]_g} \\frac{1}{(g - 2[[b]]_g)^2}\\right). \\end{aligned} $$</p>

    <p class="text-gray-300">Now let us sum these terms for all non-zero values of <span class="math">b \\in \\mathbf{Z}/g\\mathbf{Z}</span>. Applying Lemma 4,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{b=1}^{g-1} \\left(\\frac{3}{g - 2[[b]]_g} + 3L(g) + L(g)^2\\right) \\leq \\left(3(\\log(g) + 2.31) + 3(g - 1)L(g) + (g - 1)L(g)^2\\right)</span></div>

    <p class="text-gray-300">It remains to estimate</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{b=1}^{g-1} \\frac{1}{g - 2[[b2^{2i+1}]]_g} \\frac{1}{(g - 2[[b]]_g)^2} = 2 \\sum_{b=1}^{(g-1)/2} \\frac{1}{g - 2[(2b-1)2^{2i}]} \\frac{1}{(2b-1)^2}.</span></div>

    <p class="text-gray-300">Lower bounds for the depth of modular squaring</p>

    <p class="text-gray-300">First, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} 2 \\sum_{b = 1}^{(g - 1) / 2} \\frac{1}{g - 2 \\llbracket (2 b - 1) 2^{2i} \\rrbracket_{g}} \\frac{1}{(2 b - 1)^{2}} \\leq 2 \\sum_{b = 1}^{(g - 1) / 2} \\frac{1}{(2 b - 1)^{2}} = 2 \\sum_{b = 0}^{(g - 1) / 2 - 1} \\frac{1}{(2 b + 1)^{2}} \\\\ \\leq 2 \\left(1 + \\frac{1}{4} \\sum_{b = 1}^{\\infty} \\frac{1}{b^{2}}\\right) = 2 + \\frac{\\pi^{2}}{12} \\leq 2.83. \\end{array}</span></div>

    <p class="text-gray-300">Finally, suppose that <span class="math">2^{2i} &amp;lt; g / 12</span>. Let <span class="math">\\kappa</span> the largest integer such that <span class="math">b \\leq \\kappa</span> implies <span class="math">(2b - 1)2^{2i} &amp;lt; g / 4</span>. On one hand,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{b = 1}^{\\kappa} \\frac{1}{g - 2 \\llbracket (2 b - 1) 2^{2i} \\rrbracket_{g}} \\frac{1}{(2 b - 1)^{2}} \\leq \\sum_{b = 1}^{\\kappa} \\frac{2}{g} \\frac{1}{(2 b - 1)^{2}} \\leq \\frac{2.83}{g}.</span></div>

    <p class="text-gray-300">On the other hand,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{b = \\kappa + 1}^{(g - 1) / 2} \\frac{1}{g - 2 \\llbracket (2 b - 1) 2^{2i} \\rrbracket_{g}} \\frac{1}{(2 b - 1)^{2}} \\leq \\sum_{b = \\kappa + 1}^{\\infty} \\frac{1}{(2 b - 1)^{2}} \\leq \\frac{1}{4} \\frac{1}{\\kappa - 1} \\leq \\frac{2^{2i + 2}}{g},</span></div>

    <p class="text-gray-300">where the last two inequalities use the fact that <span class="math">2^{2i} &amp;lt; g / 12</span> (in particular, <span class="math">\\kappa &amp;gt; 1</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 8. We have $\\sum_{g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m}\\sum_{b = 1}^{g - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g,b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m^{1 / 2 + o(1)}2^{2i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. By Proposition 11, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{g \\mid m} \\sum_{b = 1}^{g - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O \\left( (\\tilde{\\sigma}_{0}(m) + \\log(m) \\tilde{\\sigma}_{-1/2}(m) + \\log(m)^{2} \\tilde{\\sigma}_{-3/2}(m)) m^{1/2} 2^{2i} \\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\sigma_{x}(m) = \\sum_{d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m} d^{x}<span class="math"> is the divisor function and </span>\\tilde{\\sigma}_{x}(m) = \\sigma_{x}(m) - 1<span class="math">. The corollary follows from </span>\\tilde{\\sigma}_{0}(m) + \\log(m)\\tilde{\\sigma}_{-1/2}(m) + \\log(m)^{2}\\tilde{\\sigma}_{-3/2}(m) = m^{o(1)}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">It remains to deal with the terms where <span class="math">b = 0</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proposition 12. We have $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(m,0) - \\frac{m}{8}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{2^i}{8}<span class="math">, and for any </span>g \\mid m<span class="math">, </span>g \\neq m$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{g - 1}{2 \\sqrt{m g}} L(g) \\left(\\frac{m}{2} + 2^{i - 1} + m 2^{i} L(g)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. First, we have <span class="math">E(m,0) = \\frac{c_{\\chi_0}^{(i)}c_{\\chi_0}^2}{m^2}</span>. Since <span class="math">c_{\\chi_0} = \\frac{m - 1}{2}</span> and $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_0}^{(i)} - \\frac{m}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i - 1}<span class="math">, we get </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{c_{\\chi_0}^{(i)}c_{\\chi_0}^2}{m^2} - \\frac{m}{8}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{(m + 2^i)}{8} - \\frac{m}{8}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{2^i}{8}<span class="math">, and we deduce the first part of the proposition. Now suppose that </span>g \\neq m$. We have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{\\sqrt{m g}}{m^{3}} \\left( \\sum_{\\ell \\in \\mathbf{Z} / (m / g) \\mathbf{Z}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_{\\ell g}}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{n \\in \\mathbf{Z} / (m / g) \\mathbf{Z}} c_{\\chi_{n g}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left( \\sum_{k \\in (\\mathbf{Z} / (m / g) \\mathbf{Z})^{\\times}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_{k g}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Using the fact that <span class="math">\\operatorname{Re}(c_{\\chi}) = -1/2</span> and that <span class="math">c_{\\chi_{-a}} = \\overline{c_{\\chi_a}}</span> for any <span class="math">a</span>, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{n \\in \\mathbf{Z} / (m / g) \\mathbf{Z}} c_{\\chi_{n g}} = c_{\\chi_{0}} - \\sum_{n = 1}^{(m / g - 1) / 2} \\left( c_{\\chi_{a}} + c_{\\chi_{-a}} \\right) = \\frac{m - 1}{2} - \\frac{m / g - 1}{2} = \\frac{m (g - 1)}{2 g}.</span></div>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <p class="text-gray-300">In particular, <span class="math">E(1,0) = 0</span>. From Lemma 4, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{k=1}^{m/g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_{kg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq m \\sum_{k=1}^{m/g-1} \\frac{1}{m - 2\\llbracket kg\\rrbracket_m} \\leq \\frac{m}{g} (\\log(m/g) + 2.31) = mL(g).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Similarly, $\\sum_{\\ell=0}^{m/g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_{\\ell g}}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{\\chi_0}^{(i)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ m2^i L(g) \\leq \\frac{m}{2} + 2^{i-1} + m2^i L(g)$, and the second part of the proposition follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof of Theorem 12. By Proposition 12, we have $\\sum_{g</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m,g\\neq m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g,0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m^{1/2 + o(1)}2^i<span class="math">. Together with Corollary 8, we obtain </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C - \\frac{m}{8}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m^{1/2 + o(1)}2^{2i}<span class="math">. By Proposition 10, we have </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac{m}{2}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= m^{1/2 + o(1)}$. Recall from Lemma 1 that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\# \\{x \\in \\mathbf{Z}/m\\mathbf{Z} \\mid f(x^2) \\neq f((x^{(i)})^2)\\} = 2A - 4C + \\varepsilon,</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\varepsilon</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{i+2}$. Theorem 12 follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-58" class="text-2xl font-bold">6.1 Application to RSA moduli</h2>

    <p class="text-gray-300">Theorem 13. Let <span class="math">p, q \\in [2^{b-1}, 2^b)</span> be two prime numbers of <span class="math">b</span> bits, and suppose that <span class="math">b \\geq 19</span>. Then, for any non-negative integer <span class="math">i \\leq b/2</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\# \\{x \\in \\mathbf{Z}/m\\mathbf{Z} \\mid f(x^2) \\neq f((x^{(i)})^2)\\}}{m} - \\frac{1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 5.8 \\cdot \\frac{2^i}{2^{b/2}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. Recall that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\# \\{x \\in \\mathbf{Z}/m\\mathbf{Z} \\mid f(x^2) \\neq f((x^{(i)})^2)\\}}{m} - \\frac{1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{2^{i+2}}{m} + \\frac{2}{m} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac{m}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\frac{4}{m} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C - \\frac{m}{8} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Let us bound each of the three terms. First, <span class="math">\\frac{2^{i+2}}{m} \\leq \\frac{2^{b/2+2}}{2^{2b-2}} \\leq \\frac{1}{2^{b/2}} \\cdot \\frac{1}{2^{1b}}</span>. By Proposition 10, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac{m}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{1}{2} + \\frac{\\sqrt{m}}{2} \\left(\\log(m) + 2.31 + \\frac{1}{\\sqrt{p}} (\\log(q) + 2.31) + \\frac{1}{\\sqrt{q}} (\\log(p) + 2.31)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Since <span class="math">b \\geq 19</span>, we have <span class="math">\\frac{1}{\\sqrt{p}} (\\log(q) + 2.31) \\leq 0.05</span>. It follows that for <span class="math">b \\geq 19</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{2}{m} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A - \\frac{m}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{1}{\\sqrt{m}} (\\log(m) + 2.41) \\leq \\frac{1}{2^{b-1}} (2b \\log(2) + 2.41) \\leq \\frac{1}{2^{b/2}} \\cdot 0.08.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Now, we have</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{4}{m} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C - \\frac{m}{8} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp;\\leq \\frac{4}{m} \\left( \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(m, 0) - \\frac{m}{8} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sum_{b=0}^{p-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(p, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sum_{b=0}^{q-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(q, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sum_{b=1}^{m-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(m, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, <span class="math">\\frac{2^{i-1}}{m} \\leq \\frac{1}{2^{b/2}} \\cdot \\frac{1}{2^{18}}</span>. Then, by Proposition 11, for any <span class="math">g \\mid m</span>, we have $\\sum_{b=1}^{g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(g, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sqrt{mg} \\cdot 2^{i-3} (\\mathcal{L}(g) + 2.83)<span class="math">. Moreover, for any integer </span>x<span class="math"> of at least 19 bits, we have </span>\\mathcal{L}(x) \\leq 0.01$. Therefore,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{4}{m} \\left( \\sum_{b=1}^{g-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(p, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\sum_{b=1}^{q-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E(q, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right) \\leq \\frac{4}{\\sqrt{m}} (\\sqrt{p} + \\sqrt{q}) \\cdot 2^{i-3} \\cdot 2.84 \\leq \\frac{2^i \\cdot 5.68}{2^{b/2}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Lower bounds for the depth of modular squaring</p>

    <p class="text-gray-300">We also have for <span class="math">g\\in\\{p,q\\}</span> that</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {4}{m}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E (g, 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\leq \\frac {2 (g - 1)}{m \\sqrt {m g}} L (g) \\left(\\frac {m}{2} + 2 ^ {i - 1} + m 2 ^ {i} L (g)\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp; \\leq \\frac {\\log (m / g) + 2 . 3 1}{\\sqrt {m g}} \\left(1 + \\frac {2 ^ {i}}{m} + \\frac {2 ^ {i + 1} (\\log (m / g) + 2 . 3 1)}{g}\\right) \\\\ &amp; \\leq \\frac {1}{2 ^ {b / 2}} \\frac {b \\log (2) + 2 . 3 1}{2 ^ {b - 1 . 5}} \\left(1 + \\frac {1}{2 ^ {3 b / 2 - 2}} + \\frac {4 (b \\log (2) + 2 . 3 1)}{2 ^ {b / 2}}\\right) \\leq \\frac {1}{2 ^ {b / 2}} \\cdot 0. 0 0 0 1. \\end{aligned} $$</p>

    <p class="text-gray-300">Since <span class="math">i \\leq b / 2</span> and <span class="math">b \\geq 19</span>, we have <span class="math">2^{2i} &amp;lt; m / 12</span>, therefore</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {4}{m} \\sum_ {b = 1} ^ {m - 1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E (m, b)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\leq 2 ^ {i - 1} \\left(\\mathcal {L} (m) + \\frac {5 . 6 6 + 2 ^ {2 i + 3}}{m}\\right) \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">&amp; \\leq 2 ^ {i - 1} \\left(L (m) \\left(3 \\log (m) + 6. 9 3 + 3 m L (m) + m L (m) ^ {2}\\right) + \\frac {5 . 6 6 + 2 ^ {2 i + 3}}{m}\\right) \\\\ &amp; \\leq \\frac {2 ^ {i - 1}}{m} \\left(2. 3 1 \\left(3 \\log (m) + 6. 9 3 + 3 \\cdot 2. 3 1 + 2. 3 1 ^ {2} / m\\right) + 5. 6 6\\right) + \\frac {2 ^ {3 i + 2}}{m} \\\\ &amp; \\leq \\frac {1}{2 ^ {b / 2}} \\frac {1}{2 ^ {b - 1}} \\left(2. 3 1 \\left(6 b \\log (2) + 1 3. 8 6 + 2. 3 1 ^ {2} / 2 ^ {3 6}\\right) + 5. 6 6\\right) + \\frac {1}{2 ^ {b / 2}} \\frac {2 ^ {i + 4}}{2 ^ {b / 2}} \\\\ &amp; \\leq \\frac {0 . 0 0 0 9 + 2 ^ {i} \\cdot 0 . 0 3}{2 ^ {b / 2}} \\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We deduce that $\\frac{4}{m}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C - \\frac{m}{8}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac{2^{-18} + 2^i \\cdot 5.68 + 0.0002 + 0.0009 + 2^i \\cdot 0.03}{2^{b/2}} \\leq \\frac{5.71 \\cdot 2^i + 0.0012}{2^{b/2}}$. Finally,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac {\\# \\{x \\in \\mathbf {Z} / m \\mathbf {Z} \\mid f (x ^ {2}) \\neq f ((x ^ {(i)}) ^ {2}) \\}}{m} - \\frac {1}{2} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {1}{2 ^ {b / 2}} \\left(\\frac {1}{2 ^ {1 5}} + 0. 0 8 + 5. 7 1 \\cdot 2 ^ {i} + 0. 0 0 1 2\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and the result follows.</p>

    <hr class="my-8 border-gray-700" />

    <h2 id="sec-59" class="text-2xl font-bold">7 Conclusion</h2>

    <p class="text-gray-300">We have proven concrete time-delay results for modular squaring computations. Of course, one would like to prove more: that repeated squarings should also require higher depth. As discussed in the introduction, this seems extremely difficult to prove without making some unproven conjectures. Very recently, several papers [RS20, KLX20] have made significant progress on conditional lower bound results for repeated modular squaring. Still, there are several interesting open issues to consider, which do not seem too arduous to tackle. Below, we discuss two in detail.</p>

    <p class="text-gray-300"><strong>Extending the Average-Case Lower Bounds.</strong> Considering Theorems 1 and 3 together, they suggest that for proving stronger average-case lower bounds, it may be fruitful to try proving an average-case lower bound for the "middle bits" of modular squaring, rather than a lower bound on the least significant bit of modular squaring, as is done in this paper. Perhaps a different (more involved) case analysis than the above can yield a <span class="math">2\\log_2(n)</span> depth lower bound for modular squaring in the average case, for all moduli <span class="math">m</span>? It is known that the PARITY function on <span class="math">n</span> bits requires depth <span class="math">2\\log (n) - O(1)</span> to compute, even in the average case of uniform random input (see the discussion in [KR13]); this should be useful.</p>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Modular Squaring in Other Representations.</h4>

    <p class="text-gray-300">We have shown lower bounds for modular and integer squaring in the binary representation. In practice, one can convert a given integer into a different representation where repeated squaring is easier. Can similar lower bounds be proved for modular squaring in other number representations, such as redundant representations (as is used in some state-of-the-art modular multipliers <em>[x10]</em>) or the Chinese Remainder Representation?</p>

    <p class="text-gray-300">Let us consider the latter, and sketch the challenges involved. In CRR, inputs are vectors <span class="math">x=(x_{1},\\ldots,x_{t})</span> where each <span class="math">x_{i}\\in\\mathbf{Z}/p_{i}\\mathbf{Z}</span> is written in binary for distinct co-prime <span class="math">p_{i}</span>, <span class="math">t\\leq O(n/\\log n)</span>, each <span class="math">p_{i}</span> is <span class="math">O(\\log n)</span> bits (so that <span class="math">\\prod_{i}p_{i}=\\Omega(2^{n})</span>). Letting <span class="math">int(x)</span> be the non-negative integer representation of <span class="math">x</span>, we wish to know the depth complexity of computing <span class="math">(int(x)^{2}\\bmod m)</span> in Chinese Remainder Representation (CRR). This output would be a vector <span class="math">y=(y_{1},\\ldots,y_{t})</span> where each <span class="math">y_{i}\\in\\mathbf{Z}/p_{i}\\mathbf{Z}</span> is written in binary. Now, <span class="math">x&amp;lt;\\sqrt{\\prod_{i}p_{i}}</span> can be squared, by squaring each component <span class="math">x_{i}\\bmod p_{i}</span> individually, which can be done in <span class="math">O(\\log\\log n)</span> depth because each <span class="math">p_{i}</span> is only <span class="math">O(\\log n)</span> bits. Correspondingly, the sensitivity of each output bit of integer squaring is only <span class="math">O(\\log n)</span> for all integers in <span class="math">\\{0,1,\\ldots,\\lfloor\\sqrt{\\prod_{i}p_{i}}\\rfloor\\}</span>. However, for large <span class="math">x</span>, we believe the modular reduction back to <span class="math">\\{0,1,\\ldots,m-1\\}</span> should be very sensitive to the CRR. For example, if some <span class="math">p_{i}=2</span>, our CRR must track the parity of <span class="math">f(x):=(int(x)^{2}\\bmod m)</span>. It is natural to conjecture that <span class="math">f</span> is highly sensitive even for <span class="math">x</span> written in CRR: for each component <span class="math">x_{i}</span> of <span class="math">x</span>, there should be many bits of <span class="math">x_{i}</span> such that flipping any of them changes the parity of some outputs, just as it changes <span class="math">x</span> itself. (This is in line with the results we have proven about the parity of squaring modulo <span class="math">m</span>.) If we can show that a random input has many sensitive indices (say, <span class="math">n/4</span>) with nonzero probability, we will obtain interesting average-case depth lower bounds.</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">7.1 Open Problem Bounties</h3>

    <p class="text-gray-300">The Ethereum Foundation is offering first-come-first-served bounties for four specific open problems. If you believe you have a solution and wish to claim the bounty, contact information can be found at https://rsa.cash, or through the authors.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">5,000 Prove that for all </span>n\\geq 128<span class="math">, SUM on </span>n<span class="math">-bit inputs requires depth at least </span>c\\log_{2}(n)<span class="math"> for some </span>c&gt;2$. (That is, improve upon Krapchenko’s lower bound for SUM <em>[x13]</em>.)</li>

      <li><span class="math">5,000 Prove that for all </span>n\\geq 128<span class="math">, SUM on </span>n<span class="math">-bit inputs requires depth at least </span>4\\log_{2}(n)<span class="math">. (That is, prove the “reasonable hypothesis&quot; stated immediately after Theorem 2. This </span>5,000 bounty is in addition to the $5,000 bounty above.)</li>

      <li><span class="math">2,000 Prove that there is a </span>c&lt;4<span class="math"> such that for all </span>n\\geq 128<span class="math">, SUM has circuits of depth at most </span>c\\log_{2}(n)<span class="math">. (That is, refute the “reasonable hypothesis&quot;, and do so for all large enough input lengths </span>n$.)</li>

      <li><span class="math">3,000 Improve the average-case depth lower bound (Theorem 3) to </span>c\\log_{2}(n)<span class="math"> for some </span>c&gt;1$, for any algorithm computing MS-MOD2 on at least 51% of the inputs.</li>

    </ol>

    <p class="text-gray-300">We are grateful to Justin Drake and Dankrad Feist for approaching us, motivating us to work on this problem, and for useful discussions and references, as well as Simon Peffers and Erdinc Ozturk. Benjamin Wesolowski was supported by the Ethereum Foundation Grants program, through Grant FY19-0151. Ryan Williams was supported by NSF CCF-1909429 “Average-Case Fine-Grained Complexity” and the Ethereum Foundation.</p>

    <p class="text-gray-300">#</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BBBF18] Dan Boneh, Joseph Bonneau, Benedikt Bünz, and Ben Fisch. Verifiable delay functions. In Hovav Shacham and Alexandra Boldyreva, editors, Advances in Cryptology — CRYPTO 2018, volume 10991 of Lecture Notes in Computer Science, pages 757–788. Springer, 2018.</li>

      <li>[BS07] Daniel Bernstein and Jonathan Sorenson. Modular exponentiation via the explicit chinese remainder theorem. Mathematics of Computation, 76(257):443–454, 2007.</li>

      <li>[CDR86] Stephen A. Cook, Cynthia Dwork, and Rüdiger Reischuk. Upper and lower time bounds for parallel random access machines without simultaneous writes. SIAM J. Comput., 15(1):87–97, 1986.</li>

      <li>[FSS81] Merrick Furst, James Saxe, and Michael Sipser. Parity, circuits, and the polynomial-time hierarchy. Mathematical Systems Theory, 17(1):13–27, April 1984. See also FOCS’81.</li>

      <li>[GTTN18] Anna Gál, Avishay Tal, and Adrian Trejo Nuñez. Cubic formula size lower bounds based on compositions with majority. In 10th Innovations in Theoretical Computer Science Conference (ITCS 2019). Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018.</li>

      <li>[Hua19] Hao Huang. Induced subgraphs of hypercubes and a proof of the sensitivity conjecture. Annals of Mathematics, 190(3):949–955, 2019.</li>

      <li>[Juk12] Stasys Jukna. Boolean Function Complexity - Advances and Frontiers, volume 27 of Algorithms and combinatorics. Springer, 2012.</li>

      <li>[KLX20] Jonathan Katz, Julian Loss, and Jiayu Xu. On the security of time-locked puzzles and timed commitments. Cryptology ePrint Archive, Report 2020/730, 2020. https://eprint.iacr.org/2020/730.</li>

      <li>[KR13] Ilan Komargodski and Ran Raz. Average-case lower bounds for formula size. In Proceedings of the 45th Annual ACM Symposium on Theory of Computing, STOC 2013, pages 171–180, 2013.</li>

      <li>[Kra70] VM Krapchenko. Asymptotic estimation of addition time of parallel adder. Syst. Theory Res., 19:105–122, 1970.</li>

      <li>[MOS20] Ahmet Can Mert, Erdinc Ozturk, and Erkay Savas. Low-latency asic algorithms of modular squaring of large integers for vdf evaluation. Cryptology ePrint Archive, Report 2020/480, 2020. https://eprint.iacr.org/2020/480.</li>

      <li>[Özt20] Erdinç Öztürk. Design and implementation of a low-latency modular multiplication algorithm. IEEE Trans. Circuits Syst., 67-I(6):1902–1911, 2020.</li>

      <li>[Pie19] Krzysztof Pietrzak. Simple verifiable delay functions. In Avrim Blum, editor, 10th Innovations in Theoretical Computer Science Conference, ITCS 2019, volume 124 of LIPIcs, pages 60:1–60:15. Schloss Dagstuhl - Leibniz-Zentrum für Informatik, 2019.</li>

      <li>[RS20] Lior Rotem and Gil Segev. Generically speeding-up repeated squaring is equivalent to factoring: Sharp thresholds for all generic-ring delay functions. Cryptology ePrint Archive, Report 2020/812, to appear in Advances in Cryptology — CRYPTO 2020, 2020. https://eprint.iacr.org/2020/812.</li>

    </ul>

    <p class="text-gray-300">Benjamin Wesolowski and Ryan Williams</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[RSW96] Ronald L Rivest, Adi Shamir, and David A Wagner. Time-lock puzzles and timed-release crypto. Unpublished manuscript, Revised March 10, 1996.</li>

      <li>[Ser16] Igor Sergeevich Sergeev. Complexity and depth of formulas for symmetric boolean functions. Moscow University Mathematics Bulletin, 71(3):127–130, 2016.</li>

      <li>[SM02] Larry Stockmeyer and Albert R Meyer. Cosmological lower bound on the circuit complexity of a small problem in logic. Journal of the ACM (JACM), 49(6):753–784, 2002.</li>

      <li>[vzGS00] Joachim von zur Gathen and Igor E. Shparlinski. The CREW PRAM complexity of modular inversion. SIAM J. Comput., 29(6):1839–1857, 2000.</li>

      <li>[Weg87] Ingo Wegener. The complexity of Boolean functions. BG Teubner. URL: https://eccc.weizmann.ac.il/resources/pdf/cobf.pdf, 1987.</li>

      <li>[Wes19] Benjamin Wesolowski. Efficient verifiable delay functions. In Yuval Ishai and Vincent Rijmen, editors, Advances in Cryptology — EUROCRYPT 2019, volume 11478 of Lecture Notes in Computer Science, pages 379–407. Springer, 2019.</li>

    </ul>`;
---

<BaseLayout title="Lower bounds for the depth of modular squaring (2020/1461)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1461
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
