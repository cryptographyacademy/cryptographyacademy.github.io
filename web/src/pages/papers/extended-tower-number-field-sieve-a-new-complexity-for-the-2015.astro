---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2015/1027';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Extended Tower Number Field Sieve: A New Complexity for the Medium Prime Case';
const AUTHORS_HTML = 'Taechan Kim, Razvan Barbulescu';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We introduce a new variant of the number field sieve algorithm for discrete logarithms in $\\mathbb{F}_{p^n}$ called exTNFS. The most important modification is done in the polynomial selection step, which determines the cost of the whole algorithm: if one knows how to select good polynomials to tackle discrete logarithms in $\\mathbb{F}_{p^\\kappa}$, exTNFS allows to use this method when tackling $\\mathbb{F}_{p^{\\eta\\kappa}}$ whenever $\\gcd(\\eta,\\kappa)=1$. This simple fact has consequences on the asymptotic complexity of NFS in the medium prime case, where the complexity is reduced from $L_Q(1/3,\\sqrt[3]{96/9})$ to $L_Q(1/3,\\sqrt[3]{48/9})$, $Q=p^n$, respectively from $L_Q(1/3,2.15)$ to $L_Q(1/3,1.71)$ if multiple number fields are used. On the practical side, exTNFS can be used when $n=6$ and $n=12$ and this requires to updating the keysizes used for the associated pairing-based cryptosystems.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Discrete Logarithm Problem &middot; Number Field Sieve &middot; Finite Fields &middot; Cryptanalysis</p>
    </section>

    <p class="text-gray-300">The discrete logarithm problem (DLP) is at the foundation of a series of public key cryptosystems. Over a generic group of cardinality N, the best known algorithm to solve the DLP has an exponential running time of O( &radic; N). However, if the group has a special structure one can design better algorithms, as is the case for the multiplicative group of finite fields F<sup>Q</sup> = Fp<sup>n</sup> where the DLP can be solved much more efficiently than in the exponential time. For example, when the characteristic p is small compared to the extension degree n, the best known algorithms have quasi-polynomial time complexity <a href="#page-27-0">[6</a><a href="#page-28-0">,21]</a>.</p>

    <p class="text-gray-300">DLP over fields of medium and large characteristic Recall the usual LQ-notation,</p>

    <p class="text-gray-300"><span class="math">$L_Q(\\ell, c) = \\exp\\left((c + o(1))(\\log Q)^{\\ell}(\\log\\log Q)^{1-\\ell}\\right),\\,</span>$</p>

    <p class="text-gray-300"><sup>2</sup> CNRS, Univ Paris 6, Univ Paris 7, France razvan.barbulescu@imj-prg.fr</p>

    <p class="text-gray-300"><sup>?</sup> This work is a merged version of two consecutive works <a href="#page-28-1">[24]</a> and <a href="#page-27-1">[4]</a>.</p>

    <p class="text-gray-300">for some constants  <span class="math">0 \\le \\ell \\le 1</span>  and c &gt; 0. We call the characteristic  <span class="math">p = L_Q(\\ell_p, c_p)</span>  medium when  <span class="math">1/3 &lt; \\ell_p &lt; 2/3</span>  and large when  <span class="math">2/3 &lt; \\ell_p \\le 1</span> . We say that a field  <span class="math">\\mathbb{F}_{p^n}</span>  is in the boundary case if  <span class="math">\\ell_p = 2/3</span> .</p>

    <p class="text-gray-300">For medium and large characteristic, in particular when Q is prime, all the state-of-the-art attacks are variants of the number field sieve (NFS) algorithm. Initially used for factoring, NFS was rapidly introduced in the context of DLP [20,32] to target prime fields. One had to wait almost one decade before the first constructions for  <span class="math">\\mathbb{F}_{p^n}</span>  with n&gt;1 were proposed [33], known today [7] as the tower number field sieve (TNFS). This case is important because it is used to choose the key sizes for pairing based cryptosystems. Since 2006 one can cover the complete range of large and medium characteristic finite fields [22]. This latter approach that we denote by JLSV has the advantage to be very similar to the variant used to target prime fields, except for the first step called polynomial selection where two new methods were proposed: JLSV<sub>1</sub> and JLSV<sub>2</sub>.</p>

    <p class="text-gray-300">In the recent years NFS in fields  <span class="math">\\mathbb{F}_{p^n}</span>  with n&gt;1 has become a laboratory where one can push NFS to its limits and test new ideas which are ineffective or impossible in the factorization variant of NFS. Firstly, the polynomial selection methods were supplemented with the generalized Joux-Lercier (GJL) method [27,5], with the Conjugation (Conj) method [5] and the Sarkar-Singh (SS) method [31]. One can see Table 1 for a summary of the consequences of these methods on the asymptotic complexity. In particular, in all these algorithms the complexity for the medium prime case is slightly larger than that of the large prime case.</p>

    <p class="text-gray-300">Table 1: The complexity of each algorithms in the medium and large prime cases. Each cell indicates c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">p = L_Q(\\ell_p)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">1/3 &lt; \\ell_p &lt; 2/3</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">best <span class="math">\\ell_p = 2/3</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">2/3 &lt; \\ell_p &lt; 1</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TNFS [33,7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-JLSV [22]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-(Conj and GJL) [5]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-SS [31]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">96</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48 <sup>1</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48 <sup>1</sup></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Secondly, a classical idea which was introduced in the context of factorization is to replace the two polynomials f and g used in NFS by a polynomial f and several polynomials  <span class="math">g_i</span> , i = 1, 2, ... which play the role of g. All the currently known variants of NFS admit such variants with multiple number fields (MNFS) which have a slightly better asymptotic complexity, as shown in Table 2. The</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;1</sup> The best complexity is obtained when n has a factor of the appropriate size as specified in Theorem 1.</p>

    <p class="text-gray-300">discrete logarithm problem allows to have a case with no equivalent in the factorization context: instead of having a distinguished polynomial f and many sides  <span class="math">g_i</span>  all the polynomials are interchangeable [8].</p>

    <p class="text-gray-300">Table 2: The complexity of each algorithms using multiple number fields. Each cell indicates an approximation of c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">p = L_Q(\\ell_p)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">1/3 &lt; \\ell_p &lt; 2/3</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">best <span class="math">\\ell_p = 2/3</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">2/3 &lt; \\ell_p &lt; 1</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MTNFS [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MNFS-JLSV [8]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">122.87</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MNFS-(Conj and GJL) [30]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89.45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.00</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MNFS-SS [31]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89.45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.00</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MexTNFS (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45.00^2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">45.00^2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61.93</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Thirdly, when the characteristic p has a special form, as it is the case for fields in several pairing-based cryptosystems, one might speed-up the computations by variants called special number field sieve (SNFS). In Table 3 we list the asymptotic complexity of each algorithm. Once again, the medium characteristic case has been harder than the large characteristic one.</p>

    <p class="text-gray-300">Table 3: The complexity of each algorithms used when the characteristic has a special form (SNFS) Each cell indicates an approximation of c if the complexity is  <span class="math">L_Q(1/3, (c/9)^{\\frac{1}{3}})</span></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">p = L_Q(\\ell_p)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">1/3 &lt; \\ell_p &lt; 2/3</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">2/3 &lt; \\ell_p &lt; 1</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-JP [23]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">64</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">STNFS [7]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">none</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS (this article)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">32^{-2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Our contributions Let us place ourselves in the case when the extension degree is composite with relatively prime factors,  <span class="math">n=\\eta\\kappa</span>  with  <span class="math">\\gcd(\\eta,\\kappa)=1</span> . If the particular cases  <span class="math">\\eta=1</span>  and  <span class="math">\\kappa=1</span>  we obtain known algorithms but we don't exclude these cases from our presentation. The basic idea is to use the trivial equality</p>

    <p class="text-gray-300"><span class="math">$\\mathbb{F}_{p^n} = \\mathbb{F}_{(p^\\eta)^\\kappa}.</span>$</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;2</sup> The best complexity is obtained under the assumption that n has a factor of the appropriate size. See Theorem 1.</p>

    <p class="text-gray-300">In the JLSV algorithm,  <span class="math">\\mathbb{F}_{p^n}</span>  is constructed as  <span class="math">\\mathbb{F}_p[x]/k(x)</span>  for an irreducible polynomial k(x) of degree n. In the TNFS algorithm  <span class="math">\\mathbb{F}_{p^n}</span>  is obtained as R/pR where R is a ring of integers of a number field where p is inert. In our construction  <span class="math">\\mathbb{F}_{p^n} = R/pR</span>  as in TNFS and  <span class="math">\\mathbb{F}_{p^n} = (R/pR)[x]/(k(x))</span>  where k is a degree  <span class="math">\\kappa</span>  irreducible polynomial over  <span class="math">\\mathbb{F}_{p^n}</span> .</p>

    <p class="text-gray-300">Interestingly, this construction can be integrated in an algorithm, that we call the extended number field sieve (exTNFS), in which we can target  <span class="math">\\mathbb{F}_{p^{\\eta\\kappa}}</span>  with the same complexity as  <span class="math">\\mathbb{F}_{P^{\\kappa}}</span>  for a prime P of the same bitsize as  <span class="math">p^{\\eta}</span> . Hence we obtain complexities for composite extension degrees which are similar in the medium characteristic case to the large characteristic case. This is because our construction lets us to consider the norm of an element from a number field  <span class="math">K_f</span>  that is 'doubly' extended by h(t) and f(x), i.e.  <span class="math">K_f := \\mathbb{Q}(\\iota, \\alpha_f)</span> , where  <span class="math">\\iota</span>  and  <span class="math">\\alpha_f</span>  denote roots of h and f, respectively. It provides a smaller norm size, which plays an important role during the complexity analysis than when we work with an absolute extension of the same degree.</p>

    <p class="text-gray-300">Since the previous algorithms have an &quot;anomaly&quot; in the case  <span class="math">\\ell_p = 2/3</span> , where the complexity is better than in the large prime case, when n is composite we obtain a better complexity for the medium prime case than in the large prime case.</p>

    <p class="text-gray-300">Overview We introduce the new algorithm in Section 2 and analyse its complexity in Section 3. The multiple number field variant and the one dedicated to fields of SNFS characteristic are discussed in Section 4. In Section 5 we make a precise comparison to the state-of-the-art algorithms at cryptographic sizes before deriving new key sizes for pairings in Section 6. We conclude with cryptographic implications of our result in Section 7.</p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Setting</h3>

    <p class="text-gray-300">Throughout this paper, we target fields  <span class="math">\\mathbb{F}_Q</span>  with  <span class="math">Q = p^n</span>  where  <span class="math">n = \\eta \\kappa</span>  such that  <span class="math">\\eta, \\kappa \\neq 1</span> ,  <span class="math">\\gcd(\\eta, \\kappa) = 1</span>  and the characteristic p is medium or large, i.e.  <span class="math">\\ell_p &gt; 1/3</span> . First we select a polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is irreducible modulo p. We put  <span class="math">R := \\mathbb{Z}[t]/h(t)</span>  and note that  <span class="math">R/pR \\simeq \\mathbb{F}_{p^n}</span> . Then we select two polynomials f and g with integer coefficients whose reductions modulo p have a common factor k(x) of degree  <span class="math">\\kappa</span>  which is irreducible over  <span class="math">\\mathbb{F}_{p^n}</span> . Our algorithm is unchanged if f and g have coefficients in R because in all the cases we use the number fields  <span class="math">K_f</span>  (resp.  <span class="math">K_g</span> ) defined by f (resp. g) above the fraction field of R but this generalization is not needed for the purpose of this paper, except in a MNFS variant.</p>

    <p class="text-gray-300">The conditions on f, g and h yield two ring homomorphisms from R[x]/f(x) (resp. R[x]/g(x)) to  <span class="math">(R/pR)/k(x) = \\mathbb{F}_{p^{\\eta\\kappa}}</span> : in order to compute the reduction of a polynomial in R[x] modulo p then modulo k(x) one can start by reducing modulo f (resp. g) and continue by reducing modulo p and then modulo k(x). The result</p>

    <p class="text-gray-300">is the same if we use f as when we use g. Thus one has the commutative diagram in Figure 1 which is a generalization of the classical diagram of NFS.</p>

    <p class="text-gray-300">    <img src="_page_4_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1: Commutative diagram of exTNFS. When  <span class="math">R = \\mathbb{Z}</span>  this is the diagram of NFS for non-prime fields. When k(x) = x - m for some  <span class="math">m \\in R</span>  this is the diagram of TNFS. When both  <span class="math">R = \\mathbb{Z}</span>  and k(x) = x - m this is the diagram of NFS.</p>

    <p class="text-gray-300">After the polynomial selection, the exTNFS algorithm proceeds as all the variants of NFS, following the same steps: relations collection, linear algebra and individual logarithm. Most of these steps are very similar to the TNFS algorithms as we shall explain below.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Detailed Descriptions</h3>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6"><strong>Polynomial Selection</strong></h4>

    <p class="text-gray-300">Choice of h We have to select a polynomial  <span class="math">h(t) \\in \\mathbb{Z}[t]</span>  of degree  <span class="math">\\eta</span>  which is irreducible modulo p and whose coefficients are as small as possible. As in TNFS we try random polynomials h with small coefficients and factor them in  <span class="math">\\mathbb{F}_p[t]</span>  to test irreducibility. Heuristically, one succeeds after  <span class="math">\\eta</span>  trials and since  <span class="math">\\eta \\leq 3^{\\eta}</span>  we expect to find h such that  <span class="math">||h||_{\\infty} = 1</span> . For a more rigorous description on the existence of such polynomials one can refer to [7].</p>

    <p class="text-gray-300">Next we select f and g in  <span class="math">\\mathbb{Z}[x]</span>  which have a common factor k(x) modulo p of degree  <span class="math">\\kappa</span>  which remains irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span> . It is here that we use the condition  <span class="math">\\gcd(\\eta,\\kappa)=1</span>  because an irreducible polynomial  <span class="math">k(x)\\in\\mathbb{F}_p[x]</span>  remains irreducible over  <span class="math">\\mathbb{F}_{p^{\\eta}}</span>  if and only if  <span class="math">\\gcd(\\eta,\\kappa)=1</span> . If one has an algorithm to select f and g in R[x] one might drop this condition, but in this paper f and g have integer coefficients. Thus it is enough to test the irreducibility of k(x) over  <span class="math">\\mathbb{F}_p</span>  and we have the same situation as in the classical variant of NFS for non-prime fields (JLSV): JLSV<sub>1</sub>, JLSV<sub>2</sub>, Conjugation method, GJL and Sarkar-Singh. Let us present two of these methods which are important for results of asymptotic complexity.</p>

    <p class="text-gray-300"><span class="math">JLSV_2</span>  method We briefly describe the polynomial selection introduced in Section 3.2 of [22]. One first chooses a monic polynomial  <span class="math">f_0(x)</span>  of degree  <span class="math">\\kappa</span>  with small</p>

    <p class="text-gray-300">coefficients, which is irreducible over  <span class="math">\\mathbb{F}_p</span>  (and automatically over  <span class="math">\\mathbb{F}_{p^\\eta}</span>  because  <span class="math">\\gcd(\\eta,\\kappa)=1</span> ). Set an integer  <span class="math">W\\approx p^{1/(D+1)}</span> , where D is a parameter determined later subject to the condition  <span class="math">D\\geq \\kappa</span> . Then we define  <span class="math">f(x):=f_0(x+W)</span> . Take the coefficients of g(x) as the shortest vector of an LLL-reduced basis of the lattice L defined by the columns:</p>

    <p class="text-gray-300"><span class="math">$L:=(p\\cdot \\mathbf{x^0},\\ldots,p\\cdot \\mathbf{x}^\\kappa,\\mathbf{f(x)},\\mathbf{xf(x)},\\ldots,\\mathbf{x^{D+1-\\kappa}f(x)}).</span>$</p>

    <p class="text-gray-300">Here,  <span class="math">\\mathbf{f}(\\mathbf{x})</span>  denotes the vector formed by the coefficients of a polynomial f. Finally, we set k = f then we have</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} - \\deg(f) = \\kappa \\text{ and } \\|f\\|_{\\infty} = O(p^{\\frac{\\kappa}{D+1}}); \\\\ - \\deg(g) = D \\geq \\kappa \\text{ and } \\|g\\|_{\\infty} = O(p^{\\frac{\\kappa}{D+1}}). \\end{array}</span>$</p>

    <p class="text-gray-300">Conjugation method We recall the polynomial selection method in Algorithm 4 of [5]. First, one chooses two polynomials  <span class="math">g_1(x)</span>  and  <span class="math">g_0(x)</span>  with small coefficients such that  <span class="math">\\deg g_1 &lt; \\deg g_0 = \\kappa</span> . Next one chooses a quadratic, monic, irreducible polynomial  <span class="math">\\mu(x) \\in \\mathbb{Z}[x]</span>  with small coefficients. If  <span class="math">\\mu(x)</span>  has a root  <span class="math">\\delta</span>  in  <span class="math">\\mathbb{F}_p</span>  and  <span class="math">g_0 + \\delta g_1</span>  is irreducible over  <span class="math">\\mathbb{F}_p</span>  (and automatically over  <span class="math">\\mathbb{F}_{p^n}</span>  because  <span class="math">\\gcd(\\eta, \\kappa) = 1</span> ), then set  <span class="math">k = g_0 + \\delta g_1</span> . Otherwise, one repeats the above steps until such  <span class="math">g_1</span> ,  <span class="math">g_0</span> , and  <span class="math">\\delta</span>  are found. Once it has been done, find u and v such that  <span class="math">\\delta \\equiv u/v</span>  (mod p) and q0 and q1, q2 using rational reconstruction. Finally, we set q3 Resq4 (q4), q6 and q8 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 and q9 a</p>

    <pre><code class="language-text"> - \\deg(f) = 2\\kappa \\text{ and } ||f||_{\\infty} = O(1);
 - \\deg(g) = \\kappa \\text{ and } ||g||_{\\infty} = O(\\sqrt{p}) = O(Q^{\\frac{1}{2\\eta\\kappa}}).
</code></pre>

    <p class="text-gray-300">The bound on  <span class="math">||f||_{\\infty}</span>  depends on the number of polynomials  <span class="math">g_0 + \\delta g_1</span>  tested before we find one which is irreducible over  <span class="math">\\mathbb{F}_p</span> . Heuristically this happens on average after  <span class="math">2\\kappa</span>  trials. Since there are  <span class="math">3^{2\\kappa} &gt; 2\\kappa</span>  choices of  <span class="math">g_0</span>  and  <span class="math">g_1</span>  of norm 1 we have  <span class="math">||f||_{\\infty} = O(1)</span> .</p>

    <p class="text-gray-300"><strong>Relation Collection</strong> The elements of  <span class="math">R = \\mathbb{Z}[t]/h(t)</span>  can be represented uniquely as polynomials of  <span class="math">\\mathbb{Z}[t]</span>  of degree less than deg h.</p>

    <p class="text-gray-300">We proceed as in TNFS and enumerate all the pairs  <span class="math">(a,b) \\in \\mathbb{Z}[t]^2</span>  of degree  <span class="math">\\leq \\eta - 1</span>  such that  <span class="math">||a||_{\\infty}</span> ,  <span class="math">||b||_{\\infty} \\leq A</span>  for a parameter A to be determined. We say that we obtain a relation for the pair (a,b) if</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} N_f(a,b) &amp;:= \\mathrm{Res}_t(\\mathrm{Res}_x(a(t)-b(t)x,f(x)),h(t)) \\text{ and } \\\\ N_g(a,b) &amp;:= \\mathrm{Res}_t(\\mathrm{Res}_x(a(t)-b(t)x,g(x)),h(t)) \\end{aligned}</span>$</p>

    <p class="text-gray-300">are B-smooth for a parameter B to be determined (an integer is B-smooth if all its prime factors are less than B). If  <span class="math">\\iota</span>  denotes a root of h in R our enumeration is equivalent to putting linear polynomials  <span class="math">a(\\iota) - b(\\iota)x</span>  in the top of the diagram of Figure 1.</p>

    <p class="text-gray-300">One can put non-linear polynomials  <span class="math">r(x) \\in R[x]</span>  of degree  <span class="math">\\tau - 1</span>  in the diagram for any  <span class="math">\\tau \\geq 2</span>  but this is not necessary in this paper. Indeed, in this paper we</p>

    <p class="text-gray-300">enumerate polynomials r to attack  <span class="math">\\mathbb{F}_{p^{\\kappa\\eta}}</span>  of the same degree as those that one would use to attack  <span class="math">\\mathbb{F}_{p^{\\kappa}}</span>  for a prime  <span class="math">P \\approx p^{\\eta}</span> . It happens that in the large prime case and for the best parameters of the boundary case the optimal value of  <span class="math">\\tau</span>  is 2. This determines us to state Lemma 1 only in the case  <span class="math">\\tau = 2</span>  and to write everywhere  <span class="math">r = a(\\iota) - b(\\iota)x</span> , but we bear in mind that r could have a larger degree, prove Lemma 2 in Appendix A, use it in the last paragraph of Section 4 and write Table 5 for arbitrary values of  <span class="math">\\tau</span>  before observing that the optimal value is again  <span class="math">\\tau = 2</span> .</p>

    <p class="text-gray-300">Remark 1. The choice of the polynomials r in the top of the diagram is such that the norm sizes are as small as possible. If one had an algorithm to pinpoint the principal ideals of a number field which have small norms then one would use this algorithm to generate the polynomials r.</p>

    <p class="text-gray-300">As one of the referees notices, the advantage of exTNFS when compared to the classical version of NFS is that our enumeration is less naive. Indeed, since the norms are computed as an iteration of resultants, i.e.  <span class="math">N_f(r(t,x)) = \\operatorname{Res}_t(\\operatorname{Res}_x(r(t,x),f(x)),h(t))</span> , we can enumerate polynomials r which make the relative norm  <span class="math">\\operatorname{Res}_x(r(t,x),f(x))</span>  small in some sense, for example we restrict to linear polynomials r.</p>

    <p class="text-gray-300">For each pair (a, b), i.e. r = a - bx, one obtains a linear equation where the unknowns are logarithms of elements of the factor base as in the classical variant of NFS for discrete logarithms. But let us define the factor base in our particular case.</p>

    <p class="text-gray-300">Factor base Let  <span class="math">\\alpha_f</span>  (resp.  <span class="math">\\alpha_g</span> ) be a root of f in  <span class="math">K_f</span>  (resp. of g in  <span class="math">K_g</span> ), the number field it defines over the fraction field of R. Then the norm of  <span class="math">a(\\iota) - b(\\iota)\\alpha_f</span>  (resp.  <span class="math">a(\\iota) - b(\\iota)\\alpha_g</span> ) over  <span class="math">\\mathbb{Q}</span>  is  <span class="math">\\mathrm{Res}_t(\\mathrm{Res}_x(a(t) - b(t)x, f(x)), h(t))</span>  (resp.  <span class="math">\\mathrm{Res}_t(\\mathrm{Res}_x(a(t) - b(t)x, g(x)), h(t))</span> ) up to a power of l(f) (resp. l(g)), the leading coefficient of f (resp. g). We call factor base the set of prime ideals of  <span class="math">K_f</span>  and  <span class="math">K_g</span>  which can occur in the factorization of  <span class="math">a(\\iota) - b(\\iota)\\alpha_f</span>  and  <span class="math">a(\\iota) - b(\\iota)\\alpha_g</span>  when both norms are B-smooth. By Proposition 1 in [7] we can give an explicit description of the factor base as  <span class="math">\\mathcal{F}(B) := \\mathcal{F}_f(B) \\bigcup \\mathcal{F}_g(B)</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F}_f(B) = \\left\\{ \\langle \\mathfrak{q}, \\alpha - \\gamma \\rangle : \\begin{matrix} \\mathfrak{q} \\text{ is a prime in } \\mathbb{Q}(\\iota) \\text{ lying over a prime} \\\\ p \\leq B \\text{ and } f(\\gamma) \\equiv 0 \\pmod{\\mathfrak{q}} \\end{matrix} \\right\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\bigcup \\left\\{ \\text{prime ideals of } K_f \\text{ dividing } l(f) \\text{Disc}(f) \\right\\}.</span>$</p>

    <p class="text-gray-300">and similarly for  <span class="math">\\mathcal{F}_q(B)</span> .</p>

    <p class="text-gray-300">Schirokauer maps If  <span class="math">\\langle a(\\iota) - b(\\iota)\\alpha_f \\rangle = \\prod_{\\mathfrak{q} \\in \\mathcal{F}_f(B)} \\mathfrak{q}^{\\mathrm{val}_{\\mathfrak{q}}(a(\\iota) - b(\\iota)\\alpha_f)}</span>  and  <span class="math">\\langle a(\\iota) - b(\\iota)\\alpha_g \\rangle = \\prod_{\\mathfrak{q} \\in \\mathcal{F}_g(B)} \\mathfrak{q}^{\\mathrm{val}_{\\mathfrak{q}}(a(\\iota) - b(\\iota)\\alpha_g)}</span>  we write</p>

    <p class="text-gray-300"><span class="math">$\\sum_{\\mathfrak{q} \\in \\mathcal{F}_f(B)} \\operatorname{val}_{\\mathfrak{q}}(a(\\iota) - b(\\iota)\\alpha_f) \\log \\mathfrak{q} + \\epsilon_f(a,b) = \\sum_{\\mathfrak{q} \\in \\mathcal{F}_g(B)} \\operatorname{val}_{\\mathfrak{q}}(a(\\iota) - b(\\iota)\\alpha_g) \\log \\mathfrak{q} + \\epsilon_g(a,b)</span>$</p>

    <p class="text-gray-300">where the log sign denotes virtual logarithms in the sense of [32] and [22] and  <span class="math">\\epsilon_f</span>  and  <span class="math">\\epsilon_g</span>  are correction terms called Schirokauer maps which were first introduced in [32].</p>

    <p class="text-gray-300">The novelty for TNFS and exTNFS with respect to JLSV is that  <span class="math">K_f</span>  and  <span class="math">K_g</span>  are constructed as tower extensions instead of absolute extensions. On the other hand, it is more convenient to work on absolute extensions when we compute Schirokauer maps. We solve this problem by computing primitive elements  <span class="math">\\theta_f</span>  (resp.  <span class="math">\\theta_g</span> ) of  <span class="math">K_f/\\mathbb{Q}</span>  (resp.  <span class="math">K_g/\\mathbb{Q}</span> ). For a proof we refer to Section 4.3 in [22].</p>

    <p class="text-gray-300">Linear algebra and individual logarithm These two steps are unchanged with respect to the classical variant of NFS. The linear algebra step, comes after relation collection and consists in solving the linear system over  <span class="math">\\mathbb{F}_l</span>  for some prime factor l of the order of  <span class="math">\\mathbb{F}_Q^*</span> . Using Wiedemann's algorithm this has a quasi-quadratic complexity in the size of the linear system, which is equal to the cardinality of the factor base. In [7] it is shown that the factor base has  <span class="math">(2 + o(1))B/\\log B</span>  elements, so the cost of the linear algebra is  <span class="math">B^{2+o(1)}</span> .</p>

    <p class="text-gray-300">In the individual logarithm step one writes any desired discrete logarithm as a sum of virtual logarithms of elements in the factor base. Since the step is very similar to the corresponding step in NFS we keep the description for the Appendix.</p>

    <p class="text-gray-300">The complexity analysis of exTNFS follows the steps of the analysis of NFS in the case of prime fields. It is expected that the stages of the algorithm other than the relation collection and the linear algebra are negligible, hence we select parameters to minimize their cost and afterwards we check that the other stages are indeed negligible.</p>

    <p class="text-gray-300">Let us call T the time spent in average for each polynomial  <span class="math">r \\in R[x]</span>  enumerated in the relation collection stage (in this paper  <span class="math">r = a(\\iota) - b(\\iota)x</span> ), and let  <span class="math">P_f</span>  (resp.  <span class="math">P_g</span> ) be the probability that the norm  <span class="math">N_f</span>  (resp.  <span class="math">N_g</span> ) of r with respect to f (resp. g) is g-smooth. The number of polynomials that we test before finding each new relation is on average  <span class="math">1/(P_f P_g)</span> , so the cost of the relations collection is  <span class="math">\\#\\mathcal{F}(B)T/(P_f P_g)</span> .</p>

    <p class="text-gray-300">We make the usual heuristic that the proportion of smooth norms is the same as the proportion of arbitrary positive integers of the same size which are also smooth, so  <span class="math">P_f = \\text{Prob}(N_f, B)</span>  (resp  <span class="math">P_g = \\text{Prob}(N_g, B)</span> ) where Prob(x, y) is the probability that an arbitrary integer less than x is y-smooth. The value of T depends on whether we use a sieving technique or we consider each value and test smoothness with ECM [26]; if we use the latter variant we obtain  <span class="math">T = L_B(1/2, \\sqrt{2})(\\log Q)^{O(1)}</span> , so  <span class="math">T = B^{o(1)}</span> . Using the algorithm of Wiedemann [34] the cost of the linear algebra is  <span class="math">(\\#\\mathcal{F}(B))^{2+o(1)} = B^{2+o(1)}</span> . Hence, up to an exponent 1 + o(1), we have</p>

    <p class="text-gray-300">complexity(exTNFS) =
<span class="math">$\\frac{B}{\\text{Prob}(N_f, B)\\text{Prob}(N_g, B)} + B^2</span>$
. (1)</p>

    <p class="text-gray-300">This equation is the same for NFS, TNFS, exTNFS and the corresponding SNFS variants. The differences begin when we look at the size of N<sup>f</sup> and N<sup>g</sup> which depend on the polynomial selection method. In what follows we instantiate Equation <a href="#page-7-1">(1)</a> with various cases and obtain equations which have already been analyzed in the literature.</p>

    <p class="text-gray-300">Lemma 1. Let h and f be irreducible polynomials over Z and call &eta; := deg h and &kappa; := deg(f). Let a(t), b(t) &isin; Z[t] be polynomials of degree at most &eta; &minus; 1 with kak&infin;, kbk<sup>&infin;</sup> &le; A. We put N<sup>f</sup> (a, b) := Rest(Resx(a(t) &minus; b(t)x, f(x)), h(t)). Then we have</p>

    <p class="text-gray-300">1.</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| &lt; A^{\\eta \\cdot \\kappa} ||f||_{\\infty}^{\\eta} ||h||_{\\infty}^{\\kappa \\cdot (\\eta - 1)} C(\\eta, \\kappa), \\tag{2}</span>$</p>

    <p class="text-gray-300">where C(&eta;, &kappa;) = (&eta; + 1)(3&kappa;+1)&eta;/<sup>2</sup> (&kappa; + 1)3&eta;/<sup>2</sup> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Assume in addition that khk<sup>&infin;</sup> is bounded by an absolute constant H and that p = LQ(<code>p, c) for some </code><sup>p</sup> &gt; 1/3 and c &gt; 0. Then</li>
    </ol>

    <p class="text-gray-300"><span class="math">$N_f(a,b) \\le E^{\\kappa} ||f||_{\\infty}^{\\eta} L_Q(2/3, o(1)),</span>$
(3)</p>

    <p class="text-gray-300">where E = A<sup>&eta;</sup></p>

    <p class="text-gray-300">Proof. 1. This is proven in Theorem 3 in <a href="#page-27-2">[7]</a>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The overhead is bounded as follows</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\log(\\|h\\|_{\\infty}^{\\kappa(\\eta-1)}C(\\eta,\\kappa)) &amp; \\leq \\kappa\\eta \\log H + 3\\kappa\\eta \\log \\eta + 3\\eta \\log \\kappa \\\\ &amp; = O(\\log(Q)^{1-\\ell_p}(\\log\\log Q)^{\\ell_p}) \\\\ &amp; = o(1)\\log(Q)^{2/3}(\\log\\log Q)^{1/3}. \\end{split}</span>$</p>

    <p class="text-gray-300">ut</p>

    <p class="text-gray-300">If N<sup>f</sup> = LQ(2/3) then we can forget the overhead LQ(2/3, o(1)) as the Canfield-Erd&uml;os-Pomerance theorem states that the smoothness probability satisfies, uniformly on x and y in the validity domain,</p>

    <p class="text-gray-300">
<span class="math">$Prob(x^{1+o(1)}, y) = Prob(x, y)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">The next statement summarizes our results.</p>

    <p class="text-gray-300">Theorem 1. (under the classical NFS heuristics) If Q = p <sup>n</sup> is a prime power such that</p>

    <p class="text-gray-300"><span class="math">$- p = L_Q(\\ell_p, c_p) \\text{ with } 1/3 &lt; \\ell_p;</span>$</p>

    <p class="text-gray-300"><span class="math">$- n = \\eta \\kappa \\text{ such that } \\eta, \\kappa \\neq 1 \\text{ and } \\gcd(\\eta, \\kappa) = 1</span>$</p>

    <p class="text-gray-300">then the discrete logarithm over F<sup>Q</sup> can be solved in LQ(1/3, C) where C and the additional conditions are listed in Table <a href="#page-9-0">4.</a></p>

    <p class="text-gray-300">In the rest of this section we prove this statement. In any case in the table, one shares the conditions &kappa; = o ( log Q log log Q ) 1 3 or &kappa; &le; c( log Q log log Q ) 1 <sup>3</sup> for some constant c &gt; 0. These are equivalent to say that P = p <sup>&eta;</sup> = LQ(<code>&lt;sup&gt;P&lt;/sup&gt; ) for some </code><sup>P</sup> &ge; 2/3.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">C</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">exTNFS-JLSV_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(64/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-GJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(64/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa \\le \\left(\\frac{8}{3}\\right)^{-\\frac{1}{3}} \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-Conj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(48/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\ell_p &lt; 2/3 \\text{ or } \\ell_p = 2/3 \\text{ and } c_p &lt; 12^{\\frac{1}{3}}</span> <span class="math">\\kappa = 12^{-\\frac{1}{3}} \\left(\\frac{\\log Q}{\\log \\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(32/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span> <span class="math">p \\text{ is } d\\text{-SNFS with } d = \\frac{(2/3)^{\\frac{1}{3}} + o(1)}{\\kappa}\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">MexTNFS-JLSV_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}\\right)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MexTNFS-GJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\left(\\frac{92+26\\sqrt{13}}{27}\\right)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\kappa \\le \\left(\\frac{7+2\\sqrt{13}}{6}\\right)^{-1/3} \\left(\\frac{\\log Q}{\\log\\log Q}\\right)^{\\frac{1}{3}}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MexTNFS-Conj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{3+\\sqrt{3(11+4\\sqrt{6})}}{\\left(18(7+3\\sqrt{6})\\right)^{1/3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 4: Complexity of exTNFS variants.</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">exTNFS-JLSV<sub>2</sub> 3.1</h4>

    <p class="text-gray-300">In this section we assume that n has a factor  <span class="math">\\kappa</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\kappa = o\\left(\\left(\\frac{\\log(Q)}{\\log\\log(Q)}\\right)^{1/3}\\right).</span>$</p>

    <p class="text-gray-300">Let us introduce  <span class="math">||h||_{\\infty} = O(1)</span>  and the values of  <span class="math">||f||_{\\infty}, ||g||_{\\infty} \\approx p^{\\kappa/(D+1)}</span>  coming from the  <span class="math">JLSV_2</span>  method (Section 2.2) in Equation (2). Then we get</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| &lt; \\left(A^{\\eta\\kappa}(p^{\\frac{\\kappa}{D+1}})^{\\eta}\\right)^{1+o(1)} = \\left(E^{\\kappa}P^{\\frac{\\kappa}{D+1}}\\right)^{1+o(1)},</span>$
(4)</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| &lt; \\left(A^{\\eta\\kappa} (p^{\\frac{\\kappa}{D+1}})^{\\eta}\\right)^{1+o(1)} = \\left(E^{\\kappa} P^{\\frac{\\kappa}{D+1}}\\right)^{1+o(1)},</span>$</p>

    <p class="text-gray-300"><span class="math">$|N_g(a,b)| &lt; \\left(A^{\\eta D} (p^{\\frac{\\kappa}{D+1}})^{\\eta}\\right)^{1+o(1)} = \\left(E^{D} P^{\\frac{\\kappa}{D+1}}\\right)^{1+o(1)},</span>$
(5)</p>

    <p class="text-gray-300">where we set  <span class="math">E := A^{\\eta}</span>  and  <span class="math">P := |R/pR| = p^{\\eta}</span> .</p>

    <p class="text-gray-300">One recognizes the expressions for the norms in the large prime case [22, Appendix A.3.], where P = p and  <span class="math">\\kappa = n</span> . We conclude that we have the same complexity:</p>

    <p class="text-gray-300">complexity
(exTNFS with JLSV<sub>2</sub>) =
<span class="math">$L_Q(1/3, \\sqrt[3]{64/9})</span>$
.</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">exTNFS-GJL 3.2</h4>

    <p class="text-gray-300">We relax a bit the condition from the previous section: we assume that n has a factor  <span class="math">\\kappa</span>  such that</p>

    <p class="text-gray-300"><span class="math">$\\kappa \\le (8/3)^{-\\frac{1}{3}} \\left( \\frac{\\log(Q)}{\\log\\log(Q)} \\right)^{1/3}.</span>$</p>

    <p class="text-gray-300">Recall the characteristics of our polynomials: khk<sup>&infin;</sup> = O(1) and deg h = &eta;; kfk<sup>&infin;</sup> = O(1) and deg f = D + 1 for a parameter D &ge; &kappa;; kgk<sup>&infin;</sup> &asymp; p &kappa;/(D+1) and deg g = D. We inject these values in Equation <a href="#page-8-2">(2)</a> and we get</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| &lt; E^{D+1}L_Q(2/3,o(1)),</span>$
(6)</p>

    <p class="text-gray-300"><span class="math">$|N_g(a,b)| &lt; E^D Q^{1/(D+1)} L_Q(2/3, o(1)), \\tag{7}</span>$</p>

    <p class="text-gray-300">where we set E := A<sup>&eta;</sup> and P := |R/pR| = p &eta; . We recognize the expression in the first equation of Section 4.2 in <a href="#page-27-3">[5]</a>, so</p>

    <p class="text-gray-300">complexity(exTNFS with GJL) =
<span class="math">$L_Q(1/3, \\sqrt[3]{64/9})</span>$
.</p>

    <p class="text-gray-300">We propose here a variant of NFS which combines exTNFS with the Conjugation method of polynomial selection.</p>

    <p class="text-gray-300">Let us consider the case when n = &eta;&kappa; with</p>

    <p class="text-gray-300"><span class="math">$\\kappa = \\left(\\frac{1}{12^{1/3}} + o(1)\\right) \\left(\\frac{\\log(Q)}{\\log\\log(Q)}\\right)^{1/3}.</span>$</p>

    <p class="text-gray-300">Note that this implies \`<sup>p</sup> &le; 2/3 so that we are in the medium characteristic or boundary case.</p>

    <p class="text-gray-300">As before, evaluating the values coming from the Conjugation method (Section <a href="#page-4-1">2.2)</a> in Equation <a href="#page-8-2">(2)</a>, we have</p>

    <p class="text-gray-300">
<span class="math">$|N_f(a,b)| &lt; E^{2\\kappa} L_Q(2/3,o(1)),</span>$
(8)</p>

    <p class="text-gray-300"><span class="math">$|N_g(a,b)| &lt; E^{\\kappa}(p^{\\kappa\\eta})^{1/(2\\kappa)} L_Q(2/3,o(1)). \\tag{9}</span>$</p>

    <p class="text-gray-300">When we combine Equations <a href="#page-10-1">(8)</a> and <a href="#page-10-1">(9)</a> we obtain</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| \\cdot |N_g(a,b)| &lt; E^{3\\kappa} Q^{(1+o(1))/(2\\kappa)}.</span>$</p>

    <p class="text-gray-300">But this is Equation (5) in <a href="#page-27-3">[5]</a> when &tau; = 2 (the parameter &tau; is written as t in <a href="#page-27-3">[5]</a>, the number of coefficients of the sieving polynomial r). The rest of the computations are identical as in point 3. of Theorem 1 in <a href="#page-27-3">[5]</a>, so</p>

    <p class="text-gray-300">complexity(exTNFS-Conj) =
<span class="math">$L_Q(1/3, (48/9)^{1/3})</span>$
.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 The case when p has a special form (SexTNFS)</h3>

    <p class="text-gray-300">In some pairing-based constructions p has a special form, e.g. in the Barreto-Naehrig curves <a href="#page-27-5">[9]</a> p = 36u <sup>4</sup> + 36u <sup>3</sup> + 24u <sup>2</sup> + 6u + 1 of embedding degree 12 and in the Freeman pairing-friendly constructions of embedding degree 10 <a href="#page-28-7">[18,</a> Section 5.3] p = 25u <sup>4</sup> + 25u <sup>3</sup> + 25u <sup>2</sup> + 10u + 3. For a given integer d, an integer</p>

    <p class="text-gray-300">p is d-SNFS if there exists an integer u and a polynomial  <span class="math">\\varPi(x)</span>  with integer coefficients so that</p>

    <p class="text-gray-300"><span class="math">$p = \\Pi(u),</span>$</p>

    <p class="text-gray-300"><span class="math">\\deg \\Pi = d</span>  and  <span class="math">\\|\\Pi\\|_{\\infty}</span>  is bounded by an absolute constant.</p>

    <p class="text-gray-300">We consider the case when  <span class="math">n = \\eta \\kappa</span> ,  <span class="math">\\gcd(\\eta, \\kappa) = 1</span>  with  <span class="math">\\kappa = o\\left(\\left(\\frac{\\log Q}{\\log \\log Q}\\right)^{1/3}\\right)</span>  and p is d-SNFS. In this case exTNFS is unchanged: we select h, f and g three polynomials with integer coefficients so that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>h is irreducible modulo p, deg  <span class="math">h = \\eta</span>  and  <span class="math">||h||_{\\infty} = O(1)</span> ;</li>
      <li>f and g have a common factor k(x) modulo p which is irreducible of degree  <span class="math">\\kappa</span> .</li>
    </ul>

    <p class="text-gray-300">Choice of f and g using the method of Joux and Pierrot (as in SNFS-JP). Find a polynomial S of degree  <span class="math">\\kappa-1</span>  with coefficients in  <span class="math">\\{-1,0,1\\}</span>  so that  <span class="math">k(x)=x^{\\kappa}+S(x)-u</span>  is irreducible modulo p. Since the proportion of irreducible polynomials in  <span class="math">\\mathbb{F}_p</span>  of degree  <span class="math">\\kappa</span>  is  <span class="math">1/\\kappa</span>  and there are  <span class="math">3^{\\kappa}</span>  choices we expect this step to succeed. Then we set</p>

    <p class="text-gray-300"><span class="math">$\\begin{cases} g = x^{\\kappa} + S(x) - u \\\\ f = \\Pi(x^{\\kappa} + S(x)). \\end{cases}</span>$</p>

    <p class="text-gray-300">If f is not irreducible over  <span class="math">\\mathbb{Z}[x]</span> , which happens with small probability, start over. Note that g is irreducible modulo p and that f is a multiple of g modulo p. Precisely, as in [23], we choose S(x) so that it is of degree  <span class="math">O(\\log \\kappa/\\log 3)</span> . Since  <span class="math">3^{O(\\log \\kappa/\\log 3)} &gt; \\kappa</span> , we still have enough chance to have irreducible g. By construction we have:</p>

    <p class="text-gray-300"><span class="math">$\\begin{array}{l} - \\deg(g) = \\kappa \\text{ and } \\|g\\|_{\\infty} = u = p^{1/d}; \\\\ - \\deg(f) = \\kappa d \\text{ and } \\|f\\|_{\\infty} = O\\big((\\log \\kappa)^d\\big). \\end{array}</span>$</p>

    <p class="text-gray-300">Let us compute the analysis of this particular case of exTNFS. We inject these values in Equations (2) and obtain</p>

    <p class="text-gray-300"><span class="math">$|N_f(a,b)| \\le E^{\\kappa d} L_Q(2/3,o(1))</span>$</p>

    <p class="text-gray-300"><span class="math">|N_g(a,b)| \\le E^{\\kappa} P^{1/d} L_Q(2/3,o(1)),</span></p>

    <p class="text-gray-300">where  <span class="math">E := A^{\\eta}</span>  and  <span class="math">P := |R/pR| = p^{\\eta}</span> . We recognize the size of the norms in the analysis by Joux and Pierrot [23, Section 6.3.], so we obtain the same complexity as in their paper:</p>

    <p class="text-gray-300">complexity(SexTNFS) =
<span class="math">$L_Q(1/3, (32/9)^{1/3})</span>$
.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 The multiple polynomial variants (MexTNFS)</h3>

    <p class="text-gray-300">Virtually every variant of NFS can be accelerated using multiple polynomials and exTNFS makes no exception. The multiple variant of exTNFS is as follows: choose f and g which have a common factor k(x) modulo p which is irreducible of degree  <span class="math">\\kappa</span>  using any of the methods given in Section 2.2. Next we set  <span class="math">f_1 = f</span></p>

    <p class="text-gray-300">and  <span class="math">f_2 = g</span>  and select other V-2 irreducible polynomials  <span class="math">f_i := \\mu_i f_1 + \\nu_i f_2</span>  where  <span class="math">\\mu_i = \\sum_{j=0}^{\\eta-1} \\mu_{i,j} \\iota^j</span>  and  <span class="math">\\nu_i = \\sum_{j=0}^{\\eta-1} \\nu_{i,j} \\iota^j</span>  are elements of  <span class="math">R = \\mathbb{Z}[t]/h\\mathbb{Z}[t]</span>  such that  <span class="math">\\|\\mu_i\\|_{\\infty}, \\|\\nu_i\\|_{\\infty} \\leq V^{\\frac{1}{2\\eta}}</span>  where  <span class="math">V = L_Q(1/3, c_v)</span>  is a parameter which will be selected later. Denote  <span class="math">\\alpha_i</span>  a root of  <span class="math">f_i</span>  for  <span class="math">i = 1, 2, \\ldots, V</span> .</p>

    <p class="text-gray-300">Once again the complexity depends on the manner in which the polynomials f and g are selected.</p>

    <p class="text-gray-300"><strong>MexTNFS-JLSV<sub>2</sub></strong> Barbulescu and Pierrot [8, Section 5.3.] analysed the complexity of MNFS with JLSV<sub>2</sub>, so we only need to check that the size of the norm is the same for NFS and exTNFS for each polynomial  <span class="math">f_i</span>  with  <span class="math">1 \\le i \\le V</span> . By construction we have:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-\\operatorname{deg}(f_1) = \\kappa \\text{ and } \\|f_1\\|_{\\infty} = p^{\\frac{\\kappa}{D+1}};</span></li>
      <li><span class="math">-\\deg(f_i)=D\\geq \\kappa \\text{ and } \\|f_i\\|_{\\infty}=V^{\\frac{1}{2\\eta}}p^{\\frac{\\kappa}{D+1}} \\text{ for } 2\\leq i\\leq V.</span></li>
    </ul>

    <p class="text-gray-300">As before, we inject these values in Equations (2) and obtain</p>

    <p class="text-gray-300"><span class="math">$|N_{f_1}(a,b)| &lt; E^{\\kappa}(p^{\\kappa\\eta})^{\\frac{1}{D+1}} L_Q(2/3,o(1))</span>$</p>

    <p class="text-gray-300"><span class="math">$|N_{f_i}(a,b)| &lt; E^D(p^{\\kappa\\eta})^{\\frac{1}{D+1}} L_Q(2/3,o(1)) \\text{ for } 2 \\le i \\le V.</span>$</p>

    <p class="text-gray-300">We emphasize that  <span class="math">(V^{\\frac{1}{2\\eta}})^{\\eta} = V^{\\frac{1}{2}} = L_Q(1/3, c_v/2) = L_Q(2/3, o(1))</span>  which is true without any condition on  <span class="math">\\eta</span> . Hence we obtain</p>

    <p class="text-gray-300"><span class="math">$\\text{complexity}(\\text{MexTNFS-JLSV}_2) = L_Q\\left(1/3, \\left(\\frac{92 + 26\\sqrt{13}}{27}\\right)^{1/3}\\right).</span>$</p>

    <p class="text-gray-300"><strong>MexTNFS-Conj and GJL</strong> Pierrot [30] studied the multiple polynomial variant of NFS when the Conjugation method or GJL are used. To show that we obtain the same complexities we need to show that the norm with respect to each polynomial is the same as in the classical NFS, except for a factor  <span class="math">L_Q(2/3, o(1))</span> , which boils down to testing again that  <span class="math">(V^{\\frac{1}{2\\eta}})\\eta = L_Q(2/3, o(1))</span>  which is always true. When  <span class="math">P = p^{\\eta} = L_Q(2/3, c_P)</span>  such that  <span class="math">c_P &gt; (\\frac{7+2\\sqrt{13}}{6})^{1/3}</span>  and  <span class="math">\\tau</span>  is the number of coefficients of the enumerated polynomials r, then the complexity obtained is  <span class="math">L_Q(1/3, C(\\tau, c_P))</span>  where</p>

    <p class="text-gray-300"><span class="math">$C(\\tau, c_P) = \\frac{2}{c_P \\tau} + \\sqrt{\\frac{20}{9(c_P \\tau)^2} + \\frac{2}{3}c_P(\\tau - 1)}.</span>$</p>

    <p class="text-gray-300">The best case is when  <span class="math">c_P=(\\frac{56+24\\sqrt{6}}{12})^{1/3}</span>  and  <span class="math">\\tau=2</span>  (linear polynomials):</p>

    <p class="text-gray-300"><span class="math">$\\text{complexity(best case of MexTNFS-Conj)} = L_Q\\left(1/3, \\frac{3+\\sqrt{3(11+4\\sqrt{6})}}{\\left(18(7+3\\sqrt{6})\\right)^{1/3}}\\right),</span>$</p>

    <p class="text-gray-300">where the second constant being approximated by 1.71.</p>

    <p class="text-gray-300">NFS, TNFS and exTNFS have the same main lines:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>we compute a large number of integer numbers;</li>
      <li>we factor these numbers to test if they are B-smooth for some parameter B;</li>
      <li>we solve a linear system depending on the previous steps.</li>
    </ul>

    <p class="text-gray-300">If we reduce the size of the integers computed in the algorithm we reduce the work needed to find a subset of integers which are <em>B</em>-smooth, which further allows us to adapt the other parameters so that the linear algebra is also cheap. A precise analysis is complex because in some variants one tests smoothness using ECM while in others one can sieve (which is faster). Nevertheless, as a first comparison we use the criterion in which one must minimize the bitsize of the product of the norms.</p>

    <p class="text-gray-300">Each method of polynomial selection has a different expression of the norm bitsize, which depends on the number  <span class="math">\\tau</span>  of coefficients of the polynomials r(x) that are enumerated during the relation collection. Let us reproduce Table 2 in [31], which we extend with TNFS and exTNFS:</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">norms product</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions and parameters</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-JLSV <sub>1</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{4n}{\\tau}}Q^{\\frac{\\tau-1}{n}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">NFS</span> - <span class="math">JLSV_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(n+D)}{\\tau}}Q^{\\frac{\\tau-1}{D+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D = \\deg(g) \\ge n</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-GJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(2D+1)}{\\tau}}Q^{\\frac{\\tau-1}{D+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">D \\ge n</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-Conj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{6n}{\\tau}}Q^{\\frac{\\tau-1}{2n}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS-SS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2\\eta(2K+1)}{\\tau}}Q^{\\frac{\\tau-1}{\\eta(K+1)}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, K \\ge \\kappa, \\deg(g) = \\eta K</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TNFS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(d+1)}{\\tau}}Q^{\\frac{2(\\tau-1)}{d+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n \\text{ small}, d = \\deg(f)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">exTNFS\\text{-}JLSV_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1, \\eta \\text{ small}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">exTNFS\\text{-}JLSV_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1, \\eta \\text{ small}, D \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-GJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2(2D+1)}{\\tau}}Q^{\\frac{\\tau-1}{D+1}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1, \\eta \\text{ small}, D \\ge \\kappa</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-Conj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{6\\kappa}{\\tau}}Q^{\\frac{(\\tau-1)}{2\\kappa}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa, \\gcd(\\eta, \\kappa) = 1, \\eta \\text{ small}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-SS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">E^{\\frac{2\\kappa_0(2K+1)}{\\tau}}Q^{\\frac{\\tau-1}{\\kappa_0(K+1)}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">n = \\eta \\kappa_0 \\kappa_1, \\gcd(\\eta, \\kappa_1) = 1,</span><br><span class="math">\\eta \\text{ small}, K \\ge \\kappa_1, \\deg(g) = \\kappa_0 K</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 5: Comparison of norm sizes.  <span class="math">\\tau = \\deg r(x)</span>  while D and K are integer parameters subject to the conditions in the last column.</p>

    <p class="text-gray-300">Note that the method of Sarkar and Singh requires that n is composite. The settings based on TNFS (TNFS, exTNFS-GJL etc) have an overhead due to the</p>

    <p class="text-gray-300">combinatorial factor which is not written in this table, so we add the condition that the degree of the intermediate number field must be small. Finally, exTNFS requires the additional condition that &kappa; and &eta; are relatively prime.</p>

    <p class="text-gray-300">Extrapolation of E The parameter E depends on the implementation of NFS and might be different for one variant to another. Let us take for example three computations with NFS which tackle various problems of the same bitsize:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Danilov and Popovyan <a href="#page-28-8">[16]</a> factored a 180-digit RSA modulus using log<sup>2</sup> E &asymp; 30 (although the size of the pairs (a, b) in theirs computations is not written explicitly, one can compute E using the range of special-q's and the default cardinality of the sieving space per special-q, which is 230);</li>
      <li>Bouvier et al. <a href="#page-28-9">[12]</a> computed discrete logarithms in a 180-digit field F<sup>p</sup> using log<sup>2</sup> E &asymp; 30 (computed from other parameters).</li>
      <li>Barbulescu et al. <a href="#page-27-3">[5]</a> computed discrete logarithms in a 180-digit field Fp<sup>2</sup> using log<sup>2</sup> E &asymp; 29.</li>
    </ul>

    <p class="text-gray-300">We see that in the first approximation E depends only on the bitsize of the field that we target and has the same value as in the factoring variant of NFS. Let us extrapolate E from the pair (log<sup>2</sup> Q = 600, log<sup>2</sup> E = 30) using the formula</p>

    <p class="text-gray-300"><span class="math">$E = cL_Q(1/3, (8/9)^{1/3}).</span>$</p>

    <p class="text-gray-300">Since exTNFS requires that gcd(&eta;, &kappa;) = 1, the first case to study is n = 6.</p>

    <p class="text-gray-300">The case of fields Fp<sup>6</sup> When n = 6 we can use the general methods</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>NFS-JLSV<sup>1</sup> (bitsize E 24 <sup>&tau;</sup> Q &tau;&minus;1 <sup>6</sup> , best values of &tau; are 3 and 2)</li>
      <li>NFS-GJL with D equal to its optimal value, 6 (bitsize E 26 <sup>&tau;</sup> Q &tau;&minus;1 <sup>7</sup> , best values of &tau; are 3 and 2 )</li>
      <li>TNFS with deg f = 5, its optimal value for this range of fields (bitsize E 12 <sup>&tau;</sup> Q &tau;&minus;1 <sup>3</sup> , best value of &tau; is 2)</li>
    </ul>

    <p class="text-gray-300">as well as the methods which exploit the fact that n is composite</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Sarkar-Singh (NFS-SS) with &eta; = 2 and K = 3, best value so that K &ge; n/&eta; for this range of fields, (E 28 <sup>&tau;</sup> Q &tau;&minus;1 <sup>8</sup> ) respectively &eta; = 3 and K = 2, best value so that K &ge; n/&eta; for this range of fields, (bitsize E 30 <sup>&tau;</sup> Q &tau;&minus;1 <sup>9</sup> , best &tau; are 4 and 3 )</li>
      <li>exTNFS with &eta; = 2 or &eta; = 3 and one of two methods for selecting f and g    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>exTNFS-GJL with &eta; = 3, D = 2 its best value so that D &ge; n/&eta;, (bitsize E <sup>&tau;</sup> Q &tau;&minus;1 <sup>3</sup> , best value of &tau; is 2 )</li>
      <li>exTNFS-GJL with &eta; = 2, D = 3 its best value so that D &ge; n/&eta;, (E 14 <sup>&tau;</sup> Q <sup>4</sup> , best values of &tau; are 3 and 2 )</li>
      <li>exTNFS-Conj with &eta; = 2 (bitsize E 18 <sup>&tau;</sup> Q &tau;&minus;1 <sup>6</sup> , best values of &tau; is 2).</li>
      <li>exTNFS-Conj with &eta; = 3 (bitsize E 12 <sup>&tau;</sup> Q &tau;&minus;1 <sup>4</sup> , best values of &tau; are 3 and 2).</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">    <img src="_page_15_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2: Plot of the norms bitsize for several variants of NFS. Horizontal axis indicates the bitsize of p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <p class="text-gray-300">We plot the values of the norms product in Figure 2. Note that exTNFS with the Conjugation method seems to be the best choice for fields between 300 and 1000 bits.</p>

    <p class="text-gray-300">For even more insight we enter into details on a specific field.</p>

    <p class="text-gray-300"><strong>Example 1:</strong> Let us consider the field  <span class="math">\\mathbb{F}_{p^6}</span>  when</p>

    <p class="text-gray-300"><span class="math">$p = 3141592653589793238462643383589.</span>$</p>

    <p class="text-gray-300">The bitsize of  <span class="math">Q = p^6</span>  is 608 and its number of decimal digits is 182. Since the parameter E can only be chosen after an effective computation we are bound to make the hypothesis that it will have a similar value as in a series of record computations with NFS having the same input size:</p>

    <p class="text-gray-300">In the following  <span class="math">\\log_2 E = 30</span> . Let us make a list with the norm sizes obtained with each version of NFS:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>NFS-JLSV<sub>1</sub>. We take for example  <span class="math">f=x^6-1772453850905518</span>  and  <span class="math">g=1772453850905514x^6+96769484157337</span> . The sieving space contains polynomials of degree two  <span class="math">r(x)=a+xb+cx^2\\in\\mathbb{Z}[x]</span> , i.e.  <span class="math">\\tau=3</span> , and the absolute value of the coefficients is bounded by  <span class="math">E^{2/3}</span> . The upper bound on the norms' product is</li>
    </ol>

    <p class="text-gray-300">norms bitsize(NFS-JLSV<sub>1</sub>) =
<span class="math">$8\\log_2 E + \\frac{1}{3}\\log_2 Q \\approx 440</span>$
.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>NFS-Conj. We take  <span class="math">f=x^{12}+3</span>  and  <span class="math">g=1016344366092854x^6-206700367981621</span> . We sieve polynomials  <span class="math">r\\in\\mathbb{Z}[x]</span>  of degree 4, i.e.  <span class="math">\\tau=5</span> , and the absolute value of the coefficients is bounded by  <span class="math">E^{2/5}</span> . Then we obtain</li>
    </ol>

    <p class="text-gray-300">norms bitsize
(NFS-Conj) =
<span class="math">$\\frac{36}{5}\\log_2 E + \\frac{1}{3}\\log_2 Q \\approx 418.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>TNFS. We take  <span class="math">f=x^5+727139x^3+538962x^2+513716x+691133, g=x-1257274</span>  and  <span class="math">h=t^6+t^4+t+1</span> . Here, h is chosen so that  <span class="math">\\mathbb{F}_{p^6}=(\\mathbb{Z}[t]/h(t))/p(\\mathbb{Z}[t]/h(t))</span> . The sieving polynomials are of the form  <span class="math">r(x)=a(\\iota)-b(\\iota)x</span> , i.e.  <span class="math">\\tau=2</span> . Here,  <span class="math">a=\\sum_{i=0}^5 a_i \\iota^i</span>  and  <span class="math">b=\\sum_{i=0}^5 a_i \\iota^i</span>  are elements in  <span class="math">\\mathbb{Z}(\\iota)=\\mathbb{Z}[t]/h(t)</span>  with the coefficients whose absolute values bounded by  <span class="math">A=E^{1/\\deg(h)}=E^{1/6}</span> . Note that the parameter  <span class="math">d=\\deg f</span>  is equal to 5, so that we have</li>
    </ol>

    <p class="text-gray-300">norms bitsize(TNFS) =
<span class="math">$6\\log_2 E + \\frac{1}{3}\\log_2 Q \\approx 380</span>$
.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>exTNFS-Conj with  <span class="math">\\eta=2</span>  and  <span class="math">\\kappa=3</span> . We take  <span class="math">f=x^6-3</span> ,  <span class="math">g=309331385734750x^3-1851661516636217</span>  and  <span class="math">h=t^2+2</span> . We sieve polynomials of the form  <span class="math">a(\\iota)-b(\\iota)x</span> , i.e.  <span class="math">\\tau=2</span> , where a and b are linear in  <span class="math">\\iota</span>  with their coefficients bounded by  <span class="math">A=E^{1/2}</span> . Hence we obtain</li>
    </ol>

    <p class="text-gray-300">norms bitsize(exTNFS
<span class="math">$\\eta = 2</span>$
) =  <span class="math">9 \\log_2 E + \\frac{1}{6} \\log_2 Q \\approx 370</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>exTNFS-Conj with &eta; = 3 and &kappa; = 2. We take f = x <sup>4</sup> &minus; 2x <sup>3</sup> + x <sup>2</sup> &minus; 3, g = 1542330130901467x <sup>2</sup> &minus; 1542330130901467x &minus; 923667359431967 and h = t <sup>3</sup> + t + 1. Again we sieve polynomials of the form a(&iota;) &minus; b(&iota;)x, i.e. &tau; = 2, where a and b are quadratic in &iota; with coefficients bounded by A = E1/<sup>3</sup> . This leads to</li>
    </ol>

    <p class="text-gray-300">norms bitsize(exTNFS
<span class="math">$\\kappa = 2</span>$
) =  <span class="math">6 \\log_2 E + \\frac{1}{4} \\log_2 Q \\approx 330</span> .</p>

    <p class="text-gray-300">We conclude that in this example the best choice is exTNFS with &kappa; = 2.</p>

    <p class="text-gray-300">The condition gcd(&eta;, &kappa;) = 1 is also satisfied by n = 10, 12, 14, 18, 20, 24 etc, but we do not discuss these cases in detail.</p>

    <p class="text-gray-300">To compare precise norm sizes when p is a d-SNFS prime, let us consider Table <a href="#page-17-0">6.</a></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Method norms product</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">conditions</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">STNFS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2(d+1)<br>&tau;&minus;1<br>E<br>Q<br>&tau;<br>d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SNFS-JP E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2n(d+1)<br>&tau;&minus;1<br>Q<br>&tau;<br>nd</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SexTNFS E</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2&kappa;(d+1)<br>&tau;&minus;1<br>Q<br>&tau;<br>&kappa;d</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = &eta;&kappa;<br>gcd(&kappa;, &eta;) = 1<br>2 &le; &eta; &lt; n</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 6: Comparison of norm sizes when p is d-SNFS prime.</p>

    <p class="text-gray-300">Note that SexTNFS encompass SNFS-JP when &eta; = 1, and STNFS when &eta; = n, so we only call it SexTNFS when 2 &le; &eta; &lt; n.</p>

    <p class="text-gray-300">As in the case when p is arbitrary, we do not have precise estimations of E, especially in the large range of fields log<sup>2</sup> Q &isin; [1000, 10000]. We are going to extrapolate from the pair (log<sup>2</sup> Q = 1039, log<sup>2</sup> E = 30.38), due to the record of <a href="#page-27-6">[1]</a>, using the formula</p>

    <p class="text-gray-300"><span class="math">$E = cL_Q(1/3, (4/9)^{\\frac{1}{3}}).</span>$</p>

    <p class="text-gray-300">Let us introduce a notation for the bitsize of SexTNFS, for any integers &kappa; &ge; 1 and &tau; &ge; 2:</p>

    <p class="text-gray-300"><span class="math">$C_{norm}(\\tau, \\kappa) = \\frac{2\\kappa(d+1)}{\\tau} \\log E + \\frac{\\tau - 1}{\\kappa d} \\log Q.</span>$</p>

    <p class="text-gray-300">For each &kappa;, Cnorm(&tau;, &kappa;) has a minimum at the integer &tau; &ge; 2 which best approximates 2&kappa; <sup>2</sup>d(d+1) log E log Q <sup>1</sup>/<sup>2</sup> .</p>

    <p class="text-gray-300">The case of 4-SNFS primes . To fix ideas, we restrict at the case d=4. When  <span class="math">\\kappa=1</span> , i.e. STNFS, the norm size has its minimum at  <span class="math">\\tau=2</span>  as soon as  <span class="math">\\frac{\\log Q}{\\log E} \\geq 40/2^2=10</span> . In our range of interest  <span class="math">(300 \\leq \\log_2 Q \\leq 10000)</span> , the ratio  <span class="math">\\log Q/\\log E</span>  is always larger than 19. So, we only take care of sieving linear polynomials in the case of STNFS with d=4. Similarly, it suffices to consider sieving linear polynomials in the case of SexTNFS with  <span class="math">\\kappa=2</span>  (resp.  <span class="math">\\kappa=3</span> ) whenever  <span class="math">\\log Q/\\log E \\geq 40</span>  (resp.  <span class="math">\\log Q/\\log E \\geq 90</span> ). It is satisfied when Q is of at least 1450 bits (resp. 6300 bits).</p>

    <p class="text-gray-300">Let us compare the norm sizes of STNFS and SexTNFS when we sieve only linear polynomials  <span class="math">(\\tau=2)</span>  in both cases. The value  <span class="math">C_{norm}(2,\\kappa)</span>  has a minimum at  <span class="math">\\kappa=\\left(\\frac{\\log Q}{d(d+1)\\log E}\\right)^{1/2}</span> . In the case of d=4, this value has minimum at  <span class="math">\\kappa=2</span>  or  <span class="math">\\kappa=3</span>  whenever  <span class="math">20 \\leq \\log Q/\\log E \\leq 180 = 20 \\cdot 3^2</span> . Thus, in fields with large size, SexTNFS with  <span class="math">\\kappa=2</span>  or  <span class="math">\\kappa=3</span>  is better than STNFS.</p>

    <p class="text-gray-300">In Figure 3 we plot the norm sizes of SNFS-JP, STNFS, and SexTNFS for n=12 and d=4 for Q is of from 300 bits to 5000 bits. We also compare these values with the best choice for general prime cases (exTNFS with Conjugation when  <span class="math">\\kappa=3</span> ). From the plots we remark that STNFS could be a best choice for small Q otherwise SexTNFS with small  <span class="math">\\kappa</span>  becomes an important challenger against any other methods as the size of Q grows.</p>

    <p class="text-gray-300">To get a better intuition, let us see in detail a specific field.</p>

    <p class="text-gray-300"><strong>Example 2:</strong> We consider the prime  <span class="math">p = P_4(u_4)</span>  where</p>

    <p class="text-gray-300"><span class="math">$P_4(x) = 36x^4 + 36x^3 + 24x^2 + 6x + 1</span>$
and  <span class="math">u_4 = 2^{158} - 2^{128} - 2^{68} + 1</span></p>

    <p class="text-gray-300">(Section 6 in [2]), and note that p is 4-SNFS. The bitsize of  <span class="math">p^{12}</span>  is 7647 for which we predict by extrapolation that  <span class="math">\\log_2 E = 76.15</span> .</p>

    <p class="text-gray-300">Let us make a list with the norm sizes obtained with each version of NFS:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>STNFS. The size of the norms is  <span class="math">E^{2(d+1)/\\tau}Q^{(\\tau-1)/d}</span>  and has its minimum for  <span class="math">\\tau=2</span> . Take for example  <span class="math">h=x^{12}+x^{10}+x^9-x^6-1</span> ,  <span class="math">f=P_4</span>  and  <span class="math">g=x-u_4</span> .</li>
    </ol>

    <p class="text-gray-300">norms bitsize
(STNFS) =
<span class="math">$5\\log_2 E + \\frac{1}{4}\\log_2 Q \\approx 2292.</span>$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>SNFS-JP. The size of the norms is  <span class="math">E^{2n(d+1)/\\tau}Q^{(\\tau-1)/(nd)}</span>  and has its minimum when  <span class="math">\\tau=8</span> . Take for example  <span class="math">f=P_4(x^{12}+x^6+x^3+1)</span>  and  <span class="math">g=(x^{12}+x^6+x^3+1)-u_4</span> .</li>
    </ol>

    <p class="text-gray-300">norms bitsize(SNFS-JP) =
<span class="math">$\\frac{120}{7}\\log_2 E + \\frac{1}{8}\\log_2 Q \\approx 2257</span>$
.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>SexTNFS-JP  <span class="math">\\eta=4</span> . In this case the norm size is  <span class="math">E^{2\\kappa(d+1)/\\tau}Q^{\\frac{(\\tau-1)}{\\kappa d}}</span>  and has its minimum when  <span class="math">\\tau=2</span> . Take for example  <span class="math">h=x^4-x-1</span> ,  <span class="math">f=P_4(x^3-x^2)</span>  and  <span class="math">g=x^3-x^2-u_4</span> .</li>
    </ol>

    <p class="text-gray-300">norms bitsize(SexTNFS) =
<span class="math">$15 \\log_2 E + \\frac{1}{12} \\log_2 Q \\approx 1779</span>$
.</p>

    <p class="text-gray-300">One can do a similar analysis in the cases  <span class="math">d=5,\\,d=6</span>  etc, but we do not present the details here.</p>

    <p class="text-gray-300">    <img src="_page_19_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3: Comparison when n = 12 and d = 4 for 300 &le; log<sup>2</sup> Q &le; 5000. Horizontal axis indicates the bitsize of p <sup>n</sup> while the vertical axis the bitsize of the norms product.</p>

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">6 On the necessity to update key sizes</h2>

    <p class="text-gray-300">Pairings are not included in the 2012 report of NIST [28] but they are included in the 2013 report of ENISA [17, Table 3.6] where pairings and RSA have the same recommended key sizes. This is in accordance with a general belief stated for example by Lenstra [25, Section 5.1]:</p>

    <p class="text-gray-300">&quot;An RSA modulus n and a finite field  <span class="math">\\mathbb{F}_{p^k}</span>  therefore offer about the same level of security if n and  <span class="math">p^k</span>  are of the same order of magnitude.&quot;</p>

    <p class="text-gray-300">Freeman, Scott and Teske [19] compiled key size recommendations from different sources in Table 1.1, all of which make or are coherent with the above supposition.</p>

    <p class="text-gray-300">The currently recommended key sizes are derived from the complexity  <span class="math">L[c] := L_{p^n}(1/3, (c/9)^{1/3})</span>  with c = 64, which corresponds to NFS over fields whose characteristic is large and doesn't have a special form. This complexity has been a safe choice until recently because the constant c = 64 has been the smallest among the variants of NFS over fields of non-small characteristic.</p>

    <p class="text-gray-300">The case of primes of general form However, exTNFS has a constant c=48 for a vast range of fields, so the safe choice becomes to derive key sizes using L[48]. A more precise evaluation would require to determine what embedding degree is large enough to be in the medium prime case, i.e. c=48, and what degree is smaller so that we use c=64. This seems to be hard to tell, especially after the record computation presented in [5, Section 7] showed that the attack in  <span class="math">\\mathbb{F}_{p^2}</span>  was 260 times faster than the attack in  <span class="math">\\mathbb{F}_{p&#x27;}</span>  where p and p' are primes so that  <span class="math">2\\log_2(p) \\approx \\log p&#x27;</span> .</p>

    <p class="text-gray-300">A crude and naive estimation, when a constant  <span class="math">c_{\\rm old}</span>  is replaced by  <span class="math">c_{\\rm new}</span> , is to write</p>

    <p class="text-gray-300"><span class="math">$L_{Q_{\\text{new}}}(1/3, c_{\\text{new}}) = L_{Q_{\\text{old}}}(1/3, c_{\\text{old}})</span>$</p>

    <p class="text-gray-300">which is equivalent to</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\log Q_{\\text{new}}}{\\log Q_{\\text{old}}} = \\frac{c_{\\text{old}}}{c_{\\text{new}}} + o(1). \\tag{10}</span>$</p>

    <p class="text-gray-300">Overall, we might say that the key size should be increased by  <span class="math">64/48 \\approx 1.33</span>  in an asymptotic sense (simply ignoring the factor o(1)), which allows to comprehend what means a change in the second constant of NFS. We avoid to derive a table of key sizes using the methods in [29, Appendix H] and [25] not because the formulae are difficult but because we lack the experience with record computations needed to validate the formulae.</p>

    <p class="text-gray-300">The special prime case When the characteristic has a special form the constant c changed twice in three years and there are some subtle points to understand about how the key sizes were computed. Before the algorithm of Joux and Pierrot there was no variant of NFS for  <span class="math">\\mathbb{F}_{p^n}</span>  with n &gt; 1 and p of special form. Hence, the recommended values correspond to c = 64. Their SNFS algorithm updated the constants to 32 in large characteristic and 64 in the middle prime case.</p>

    <p class="text-gray-300">A pessimistic choice would have been to update the key sizes using c = 32. Nevertheless, the very important example of Barreto-Naehrig pairings has an embedding degree n = 12 which seems to be considered as medium sized (the difference between large and medium characteristic is asymptotic and is hard to translate in practice). Due to SexTNFS the constant is now c = 32 for all fields of non-small characteristic, so we don't need a precise examination anymore, as long as n has a factor &ge; 2. We conclude that the key sizes of pairings where p has a special form, in a polynomial of degree &ge; 3, should increase roughly by a factor cold/cnew = 2.</p>

    <p class="text-gray-300">Our work comes in a context of recent progress on the DLP in finite fields p n of degree n &ge; 2. The case n = 2 has been the object of precise estimations and real-life computations and is now known to be weaker than the case of prime fields. On the contrary, the cases n = 6 and n = 12 remained difficult acording to precise practical estimations.</p>

    <p class="text-gray-300">In this paper we proposed the exTNFS which allowed us to apply the polynomials constructed in the case n = 2, which have good properties, to the highly important case n = 6, where the polynomials had less good properties. A precise estimation showed that this invalidates the key sizes currently and we recommend that they should be updated (see Section <a href="#page-20-0">6)</a>. When p is of special form, as in the Barreto-Naehrig construction, one needs to update the key sizes for large characteristic because of the algorithm proposed by Joux and Pierrot in 2013 but it is not clear if the keys of the Barreto-Naehrig keys had to be updated. Due to exTNFS the key sizes of all pairings of SNFS characteristic need to be updated.</p>

    <p class="text-gray-300">It is interesting to remark that the new variants of NFS exploit those properties of some pairings which made them fast:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Special form characteristic. The advantage of using special form characteristic is that it eliminates the cost of modular reductions (see for example <a href="#page-27-8">[10,</a> Algorithm 4]). It is the same special form of p which allows to use the fastest variant of exTNFS, i.e. SexTNFS, rather than the general case algorithm.</li>
      <li>Composite embedding degree. In this case the pairings computations are done using tower extension field arithmetic, as explained for example in <a href="#page-27-8">[10,</a> Section 3.1]. The same structure of tower extension field is a main ingredient of exTNFS, as explained in Remark <a href="#page-6-0">1.</a></li>
    </ul>

    <p class="text-gray-300">A large number of pairings have either special form characteristic or an embedding degree divisible by 2 or 3, for example the Barreto-Naehrig curves have both properties. In a recent preprint Chatterjee et al. <a href="#page-28-14">[13]</a> discussed the pairing constructions which are not affected by our algorithms, in particular the pairings of embedding degree one which are as secure as DSA and RSA. This shows that, regardless on the progress on DLP in Fp<sup>n</sup> with n &gt; 1, pairings are a secure tool for cryptography. Nevertheless, safe pairings might be very slow and determine cryptographers to use alternatives, as Chillotti et al. did in <a href="#page-28-15">[14]</a> for an e-voting protocol. We conclude with the question asked by our referee: &quot;Is this the beginning of the end for pairing-based based cryptography?&quot;</p>

    <p class="text-gray-300">In all the variants of exTNFS that we have discussed, one puts linear polynomials  <span class="math">r(x) \\in R[x]</span>  in the diagram of Figure 1. This is justified by the fact that exTNFS is a way of copying the setting from large characteristic to the medium prime case. Since in the large characteristic, the best choice is to take linear polynomials in all the variants, NFS, MNFS, SNFS, we have done the same thing in exTNFS, MexTNFS and SexTNFS.</p>

    <p class="text-gray-300">The estimation of the norms sizes given in Lemma 1 is central in the analysis of exTNFS. For completion reasons we generalize this result to arbitrary degrees.</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let h be an irreducible polynomial over  <span class="math">\\mathbb{Z}</span>  of degree  <span class="math">\\eta</span>  and f be an irreducible polynomial over  <span class="math">\\mathbb{Z}[\\iota]</span>  of degree  <span class="math">\\kappa</span> . Let  <span class="math">\\iota</span>  (resp.  <span class="math">\\alpha</span> ) be a root of h (resp. f) in its number field and set  <span class="math">K_f := \\mathbb{Q}(\\iota, \\alpha)</span> . Let A &gt; 0 be a real number and  <span class="math">\\tau</span>  an integer such that  <span class="math">2 \\le \\tau \\le \\kappa</span> . For each  <span class="math">i = 0, \\ldots, \\kappa - 1</span> , let  <span class="math">a_i(t) \\in \\mathbb{Z}[t]</span>  be polynomials of degree  <span class="math">\\le \\eta - 1</span>  with  <span class="math">||a_i||_{\\infty} \\le A</span> . Put  <span class="math">r(t, x) = \\sum_{i=0}^{\\tau-1} a_i(t)x^i</span> . Then we have</p>

    <p class="text-gray-300"><span class="math">$\\left|N_{K_f/\\mathbb{Q}}\\big(r(\\iota,\\alpha)\\big)\\right| &lt; A^{\\eta\\kappa} \\|f\\|_{\\infty}^{(\\tau-1)\\eta} \\|h\\|_{\\infty}^{(\\tau+\\kappa-1)(\\eta-1)} D(\\eta,\\kappa),</span>$</p>

    <p class="text-gray-300">where  <span class="math">D(\\eta, \\kappa) = ((2\\kappa - 1)(\\eta - 1) + 1)^{\\eta/2} (\\eta + 1)^{(2\\kappa - 1)(\\eta - 1)/2} ((2\\kappa - 1)!\\eta^{2\\kappa})^{\\eta}</span> . The above formula remains the same when we restrict the coefficients of f to be integers.</p>

    <p class="text-gray-300"><em>Proof.</em> By abusing the notation, we write  <span class="math">f(t,x) := \\sum_i f_i(t)x^i</span>  with  <span class="math">\\deg_t(f_i) \\le \\kappa - 1</span>  for  <span class="math">f(x) = \\sum_i f_i(\\iota)x^i \\in \\mathbb{Z}[\\iota][x]</span> . We write  <span class="math">\\mathcal{R}(t) := \\operatorname{Res}_x \\left(A(t,x), f(t,x)\\right)</span>  and have</p>

    <p class="text-gray-300"><span class="math">$N_{K_f/\\mathbb{Q}(\\iota)}(r(\\iota,\\alpha)) = \\mathcal{R}(\\iota).</span>$</p>

    <p class="text-gray-300">By Theorem 8 and Theorem 10 in [11], the degree of  <span class="math">\\mathcal{R}(t)</span>  is given by  <span class="math">(\\kappa + \\tau - 1)(\\eta - 1)</span>  and</p>

    <p class="text-gray-300"><span class="math">$\\|\\mathcal{R}(t)\\|_{\\infty} \\le (\\tau + \\kappa - 1)! \\eta^{\\tau + \\kappa - 2} A^{\\kappa} \\|f\\|_{\\infty}^{\\tau - 1}.</span>$</p>

    <p class="text-gray-300">Then by Theorem 7 in the same article, we have</p>

    <p class="text-gray-300"><span class="math">$|N_{\\mathbb{Q}(\\iota)/\\mathbb{Q}}(\\mathcal{R}(\\iota))| \\le (\\deg \\mathcal{R} + 1)^{\\deg h/2} (\\deg h + 1)^{\\deg \\mathcal{R}/2} ||\\mathcal{R}||_{\\infty}^{\\deg h} ||h||_{\\infty}^{\\deg \\mathcal{R}}</span>$</p>

    <p class="text-gray-300">Combining all together, we obtain the desired result.</p>

    <p class="text-gray-300">This result allows to analyze MexTNFS-SS when  <span class="math">\\kappa = \\frac{1}{c_p} (\\frac{\\log Q}{\\log \\log Q})^3</span>  and  <span class="math">c_p &lt; (\\sqrt{78}/9 + 29/36)^{\\frac{1}{3}} \\approx 1.21</span> . Indeed, in this case one puts non-linear polynomials in the diagram, as indicated in Table 4 of [31].</p>

    <p class="text-gray-300">Once again we check when  <span class="math">D(\\eta,\\kappa)=L_Q(2/3,o(1))</span>  and obtain the condition  <span class="math">\\eta\\kappa=o((\\frac{\\log Q}{\\log\\log Q})^{\\frac{2}{3}})</span> . The factor  <span class="math">\\|h\\|_{\\infty}^{(T+\\kappa-1)(\\eta-1)}</span>  is also negligible under the same condition. Hence the overhead is negligible for all range  <span class="math">\\ell_p&gt;1/3</span> .</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Individual Logarithm</h2>

    <p class="text-gray-300">Let  <span class="math">s \\in \\mathbb{F}_{p^n}^* = \\mathbb{F}_{p^{\\eta\\kappa}}^*</span>  be an element for which we want to compute the discrete logarithm. In general, the discrete logarithm of s can be found by following two steps: smoothing step and special-q descent.</p>

    <p class="text-gray-300">In the smoothing step, the value s is randomized by  <span class="math">z:=s^e</span>  for random value e and  <span class="math">B_1</span> -smoothness of z (for pre-determined value  <span class="math">B_1&gt;B</span> ) is tested. Then, for each prime ideal  <span class="math">\\mathfrak D</span>  which is not in the factor base, one finds a linear relation involving  <span class="math">\\mathfrak D</span>  and other smaller ideals. This step is called special-q descent. We recursively produce the special-q descent tree, and finally deduce the desired discrete logarithm.</p>

    <p class="text-gray-300">The complexity of the individual logarithm step differs by polynomial selection methods. In the following, to fix ideas, we consider only the JLSV <span class="math">_2</span>  and Conjugation methods (exTNFS-JLSV <span class="math">_2</span>  and exTNFS-Conj), but similar argument directly applies to any other polynomial selection method.</p>

    <p class="text-gray-300"><strong>Smoothing.</strong> For each  <span class="math">z \\in \\mathbb{F}_{p^n}</span>  we compute an element  <span class="math">\\bar{z} \\in K_f = \\mathbb{Q}(\\iota, \\alpha_f)</span>  which is sent to z when  <span class="math">\\iota</span>  is mapped to a root of h in  <span class="math">\\mathbb{F}_{p^n}</span>  and  <span class="math">\\alpha_f</span>  in a root of f in  <span class="math">\\mathbb{F}_{p^{n\\kappa}}</span> . Then we test if  <span class="math">N_{K_f/\\mathbb{Q}}(\\bar{z})</span>  is  <span class="math">B_1</span> -smooth and squarefree. Let us discuss how to compute and what is the size of its norm.</p>

    <p class="text-gray-300"><span class="math">JLSV_2</span>  As before, we consider the target field  <span class="math">\\mathbb{F}_{p^n}</span>  as an extension field  <span class="math">\\mathbb{F}_{p^{\\eta\\kappa}} = \\mathbb{F}_{p^{\\eta}}(m) = \\mathbb{F}_{p^{\\eta}}[x]/k(x)</span>  over  <span class="math">\\mathbb{F}_{p^{\\eta}} = \\mathbb{F}_p(\\iota) = \\mathbb{F}_p[t]/h(t)</span> . For a given z in  <span class="math">\\mathbb{F}_{p^n}^*</span> , we write  <span class="math">z = \\sum_i z_i(\\iota)m^i</span> , where the coefficients of  <span class="math">z_i</span>  are non-negative intergers bounded by p. We set</p>

    <p class="text-gray-300"><span class="math">$\\bar{z} = \\sum_{i=0}^{\\kappa - 1} z_i(\\iota) \\alpha_f^i</span>$</p>

    <p class="text-gray-300">and, by Lemma 2 for  <span class="math">T = \\kappa</span> , we obtain</p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(\\bar{z})| \\leq \\left(p^n(p^{\\kappa/(D+1)})^{n-\\eta}\\right)^{1+o(1)} \\leq Q^{2-2/(\\kappa+1)+o(1)},</span>$</p>

    <p class="text-gray-300">where, in the last inequality, we used the condition that  <span class="math">D \\geq \\kappa</span> .</p>

    <p class="text-gray-300">Conjugation In this case, a direct lift would make that  <span class="math">\\bar{z}</span>  has degree  <span class="math">\\kappa</span>  instead of  <span class="math">2\\kappa = \\deg K_f</span> , and the coefficients  <span class="math">z_i(t)</span>  have norm bounded by p. In order to &quot;spread&quot; the coefficients, i.e. compute another polynomial with the same image in  <span class="math">\\mathbb{F}_{p^n}</span>  of degree  <span class="math">2\\kappa</span>  and coefficients of norm  <span class="math">p^{1/2}</span> , we need to use the LLL algorithm. With no extra cost we can obtain a further improvement: use the Waterloo improvement which consists in replacing the smoothness condition of integers of a given size X by the smoothness condition of two integers of size  <span class="math">X^{1/2}</span> .</p>

    <p class="text-gray-300">The Waterloo improvement for exTNFS-Conj is as follows: we find two bivariate polynomials  <span class="math">u(t,x)=\\sum_{i=0}^{2\\kappa-1}u_i(t)x^i</span>  and  <span class="math">v(t,x)=\\sum_{i=0}^{2\\kappa-1}v_i(t)x^i\\in\\mathbb{Z}[t,x]</span>  such that z is the image in  <span class="math">\\mathbb{F}_{p^n}</span>  of</p>

    <p class="text-gray-300"><span class="math">$\\bar{z} := \\frac{u(\\iota, \\alpha_f)}{v(\\iota, \\alpha_f)}</span>$</p>

    <p class="text-gray-300">where  <span class="math">||u_i||_{\\infty}, ||v_j||_{\\infty} \\leq 2^n p^{1/4}</span> . For this we LLL-reduce the lattice of dimension 4n defined by the lines of the matrix</p>

    <p class="text-gray-300">    <img src="_page_24_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">the first n rows contain only the diagonal coefficient equal to p and where, for all bivariate polynomial  <span class="math">w(t,x) = \\sum_{i=0}^{2\\kappa-1} w_i(t)x^i</span>  with  <span class="math">w_i(t) = \\sum_{j=0}^{\\eta-1} w_{i,j}t^{\\eta-1-j}</span> ,  <span class="math">\\operatorname{vec}(w) = (w_{0,0}, \\dots, w_{0,\\eta-1}, \\dots, w_{2\\kappa-1,0}, \\dots, w_{2\\kappa-1,\\eta-1})</span>  of dimension 2n. In particular,  <span class="math">k \\in \\mathbb{F}_{p^{\\eta}}[x]</span>  has been seen as a two-variate polynomial.</p>

    <p class="text-gray-300">By dividing if necessary by the leading coefficient, we can assume that k(x) is monic, hence the right-most coordinate of  <span class="math">\\operatorname{vec}(k)</span>  is 1. Then  <span class="math">\\det L = p^n</span>  and we have u, v with  <span class="math">\\|u_i\\|_{\\infty}, \\|v_j\\|_{\\infty} \\leq 2^{(4n-1)/4}Q^{\\frac{1}{4n}} \\leq 2^nQ^{\\frac{1}{4n}}</span> . By Lemma 2 we obtain that</p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(u(\\iota,\\alpha_f))N_{K_f/\\mathbb{Q}}(v(\\iota,\\alpha_f))| \\le 2^{n^2} Q\\left(\\|f\\|_{\\infty}^{(2\\kappa-1)\\eta}\\|h\\|_{\\infty}^{(3\\kappa-1)}(\\eta-1)D(\\eta,2\\kappa)\\right)^2.</span>$</p>

    <p class="text-gray-300">The term in the later bracket is  <span class="math">L_Q(2/3, o(1))</span>  and  <span class="math">2^{n^2}</span>  is negligible compared to Q if and only if  <span class="math">\\ell_p &gt; 1/2</span> . We conclude that when  <span class="math">\\ell_p &gt; 1/2</span></p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(u(\\iota,\\alpha_f))N_{K_f/\\mathbb{Q}}(v(\\iota,\\alpha_f))| = Q^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">Once the lift  <span class="math">\\bar{z}</span>  has been computed, the smoothing step is carried out as usual: one tests that the norm of  <span class="math">\\bar{z}</span>  (or u and v) is squarefree and  <span class="math">B_1</span> -smooth where  <span class="math">B_1 = L_Q(2/3, \\beta_1)</span>  for some constant  <span class="math">\\beta_1 &gt; 0</span> . We recognize the complexity analysis done in [15] in the case of prime fields: the complexity of the smoothing step is  <span class="math">L_Q(1/3, c_{\\text{smooth}})</span>  with</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-c_{\\text{smooth}} = 6^{\\frac{1}{3}} \\text{ for exTNFS-JLSV}_2;</span></li>
      <li><span class="math">-c_{\\text{smooth}} = 3^{\\frac{1}{3}} \\text{ for exTNFS-Coni.}</span></li>
    </ul>

    <p class="text-gray-300"><strong>Descent by special-q</strong> Recall how the special-q descent is done in the large characteristic case of NFS (for example NFS-JLSV<sub>2</sub>). Due to the condition that  <span class="math">N_{K_f/\\mathbb{Q}}(\\bar{z})</span>  is squarefree the ideal generated by  <span class="math">\\bar{z}</span>  factors only into prime ideals of degree 1. For a prime ideal  <span class="math">\\mathfrak{q}</span>  of degree 1 in  <span class="math">K_f</span>  that appears in the factorization of the principal ideal  <span class="math">(\\bar{z})</span> , we write the logarithm of  <span class="math">\\mathfrak{q}</span>  as a formal sum of virtual logarithms of ideals in  <span class="math">K_f</span>  and  <span class="math">K_g</span>  of norm less than  <span class="math">N(\\mathfrak{q})^c</span>  for a constant c &lt; 1. For this, we enumerate pairs  <span class="math">(a,b) \\in \\mathbb{Z} \\times \\mathbb{Z}</span>  such that  <span class="math">\\mathfrak{q}</span>  divides  <span class="math">(a-b\\alpha_f)</span>  to find one pair such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">(a-b\\alpha_f)/\\mathfrak{q}</span>  factors into prime ideals of norm less than  <span class="math">N(\\mathfrak{q})^c,</span>  and</li>
      <li>the ideal  <span class="math">(a-b\\alpha_g)</span>  factors into prime ideals of norm less than  <span class="math">N(\\mathfrak{q})^c</span> .</li>
    </ul>

    <p class="text-gray-300">To do this we find two pairs  <span class="math">(a^{(1)}, b^{(1)})</span>  and  <span class="math">(a^{(2)}, b^{(2)})</span>  of euclidean norm less than a constant times  <span class="math">N(\\mathfrak{q})^{\\frac{1}{2}}</span> , using LLL. Then we enumerate the pairs  <span class="math">i_1 + i_2</span>  for all rational integers with  <span class="math">|i_1|, |i_2| \\leq E&#x27;</span> . The complexity of the descent is mainly determined by the size of the norms:</p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(a-b\\alpha_f)| \\le \\left( (E&#x27;)^{\\kappa} N(\\mathfrak{D})^{\\kappa/2} Q^{1/(D+1)} \\right)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300"><span class="math">$|N_{K_g/\\mathbb{Q}}(a - b\\alpha_g)| \\le ((E&#x27;)^D N(\\mathfrak{D})^{D/2} Q^{1/(D+1)})^{1+o(1)}</span>$</p>

    <p class="text-gray-300">In our two cases, exTNFS-JLSV<sub>2</sub> and exTNFS-Conj, we enumerate  <span class="math">a(\\iota), b(\\iota) \\in R \\subset \\mathbb{Q}(\\iota)</span>  where  <span class="math">a(t), b(t) \\in \\mathbb{Z}[x]</span>  of degree  <span class="math">\\leq \\eta - 1</span>  and  <span class="math">||a||_{\\infty}, ||b||_{\\infty} \\leq (E&#x27;)^{\\frac{1}{\\eta}}</span>  so that  <span class="math">a(\\iota) - b(\\iota)\\alpha_f \\equiv 0 \\mod \\mathfrak{q}</span> . This can be done in the following manner (cf Appendix 7.1 in [7]). First, we construct the lattice</p>

    <p class="text-gray-300"><span class="math">$L(\\mathfrak{q}) := \\{(a,b) = (a_0, \\dots, a_{n-1}, b_0, \\dots, b_{n-1}) \\in \\mathbb{Z}^{2\\eta} : a(\\iota) - b(\\iota)\\alpha_f \\equiv 0 \\mod \\mathfrak{q}\\},\\</span>$</p>

    <p class="text-gray-300">which has determinant  <span class="math">N(\\mathfrak{q})</span> . Let  <span class="math">(a^{(k)}, b^{(k)})</span> ,  <span class="math">k = 1, 2, \\ldots, 2\\eta</span> , be the LLL-reduced basis of this lattice. Then we test the above smoothness conditions for pairs  <span class="math">(a,b) = \\sum_{k=1}^{2\\eta} i_k(a^{(k)}, b^{(k)})</span> , where  <span class="math">i_k</span>  are rational integers with absolute value less than  <span class="math">I := (E&#x27;)^{\\frac{1}{\\eta}}</span> . By Lemma 1, in the case of exTNFS-JLSV<sub>2</sub> the size of the norms is</p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(a-b\\alpha_f)| \\le \\left( (E&#x27;)^{\\kappa} N(\\mathfrak{q})^{\\kappa/2} Q^{1/(D+1)} \\right)^{1+o(1)}</span>$</p>

    <p class="text-gray-300"><span class="math">$|N_{K_g/\\mathbb{Q}}(a-b\\alpha_g)| \\le ((E&#x27;)^D N(\\mathfrak{q})^{D/2} Q^{1/(D+1)})^{1+o(1)}</span>$</p>

    <p class="text-gray-300">Then, the rest of the analysis is similar to that of Chapter 7.3. in [3] and we conclude that in exTNFS-JLSV<sub>2</sub> the special-q descent is negligible compared to the smoothing step.</p>

    <p class="text-gray-300">In the case of exTNFS-Conj, we use again Lemma 1 and obtain:</p>

    <p class="text-gray-300"><span class="math">$|N_{K_f/\\mathbb{Q}}(a-b\\alpha_f)| \\le ((E&#x27;)^{2\\kappa}N(\\mathfrak{q})^{\\kappa})^{1+o(1)},</span>$</p>

    <p class="text-gray-300"><span class="math">$|N_{K_g/\\mathbb{Q}}(a-b\\alpha_g)| \\le \\left( (E&#x27;)^{\\kappa} N(\\mathfrak{q})^{\\kappa/2} Q^{1/(2\\kappa)} \\right)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">We make an usual heuristic argument that a number x is y-smooth with the probability of  <span class="math">\\rho(\\log x/\\log y)</span>  for Dickman function  <span class="math">\\rho</span> . So, the probability of the pair (a,b) to be descended is given by</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Prob}[(a,b) \\text{ descends}] \\ge \\rho \\left( \\frac{3\\kappa \\log E&#x27; + (3\\kappa/2) \\log \\nu + (1/(2\\kappa)) \\log Q}{c \\log \\nu} \\right)^{1+o(1)}, \\tag{11}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\nu := N(\\mathfrak{q})</span> .</p>

    <p class="text-gray-300">In the case when  <span class="math">\\nu</span>  is large, i.e.  <span class="math">\\nu = L_Q(2/3, \\beta_1)</span> , where  <span class="math">\\beta_1</span>  is imposed by the smoothing step described above, the inverse of the probability can be approximated by</p>

    <p class="text-gray-300">
<span class="math">$\\rho\\big(\\frac{3\\kappa}{2c}\\big)^{-1+o(1)} = L_Q\\left(\\frac{1}{3},\\frac{c_\\kappa}{2c}\\right)^{1+o(1)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">c_{\\kappa} = \\kappa/(\\frac{\\log Q}{\\log\\log Q})^{\\frac{1}{3}} = 12^{-\\frac{1}{3}}</span> . Multiplying this by the time for  <span class="math">\\nu^c</span> -smoothness test the total cost becomes</p>

    <p class="text-gray-300"><span class="math">$L_Q\\left(1/3, \\frac{c_\\kappa}{2c} + 2\\sqrt{\\frac{c\\beta_1}{3}}\\right)^{1+o(1)}.</span>$</p>

    <p class="text-gray-300">This value is minimized by  <span class="math">L_Q(1/3, (9\\beta_1 c_{\\kappa}/2)^{1/3})</span>  when  <span class="math">c = \\left(\\frac{3c_{\\kappa}^2}{4\\beta_1}\\right)^{1/3}</span> . When we use that  <span class="math">\\beta_1 = (1/3)^{1/3}</span>  and  <span class="math">c_{\\kappa} = 12^{-\\frac{1}{3}}</span> , we deduce the complexity</p>

    <p class="text-gray-300"><span class="math">$L_Q(1/3, (81/32)^{\\frac{1}{9}})</span>$</p>

    <p class="text-gray-300">that is less than the complexity of the smoothing step.</p>

    <p class="text-gray-300">In the case of small  <span class="math">\\nu</span> , i.e.  <span class="math">\\nu = L_Q(1/3)</span> , the hardest descent step corresponds to the case when  <span class="math">\\nu^c = B</span>  (the smoothness bound for the factor base). In this case, again by Equation (11), we have the probability of the descent,</p>

    <p class="text-gray-300"><span class="math">$L_Q \\left( 1/3, \\frac{c_\\kappa}{2c} + \\frac{c_\\kappa \\epsilon}{\\beta} + \\frac{1}{6c_\\kappa \\beta} \\right)^{-1+o(1)}</span>$
.</p>

    <p class="text-gray-300">The complexity is minimized when the size of sieving space equals to the inverse of the above probability. This translates to</p>

    <p class="text-gray-300"><span class="math">$2\\epsilon = \\frac{c_{\\kappa}}{2c} + \\frac{c_{\\kappa}\\epsilon}{\\beta} + \\frac{1}{6c_{\\kappa}\\beta}.</span>$</p>

    <p class="text-gray-300">This shows that the optimal value for c can be any value close but not equal to 1, e.g. c=0.999, and the optimal complexity of descent step for small  <span class="math">\\nu</span>  is  <span class="math">L_Q(1/3, 2\\epsilon)</span>  where</p>

    <p class="text-gray-300"><span class="math">$\\epsilon = \\left(\\frac{c_{\\kappa}}{2} + \\frac{1}{6\\beta c_{\\kappa}}\\right) / \\left(2 - \\frac{c_{\\kappa}}{\\beta}\\right) = 12^{-1/3} \\approx 0.44,</span>$</p>

    <p class="text-gray-300">where we used  <span class="math">\\beta = (2/3)^{1/3}</span>  and  <span class="math">c_{\\kappa} = 12^{-1/3}</span> . This complexity is negligible to the smoothing step.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">algorithm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">rels collection<br>+lin. algebra</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">smoothing</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">special-q<br>descent</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-JLSV <sub>2</sub></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(64/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(54/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">-</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">exTNFS-Conj</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(48/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(27/9)^{\\frac{1}{3}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">negligible</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\ell_p &gt; 1/2</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 7: Complexity of individual logarithm</p>

    <p class="text-gray-300">For medium  <span class="math">\\nu</span> , i.e.  <span class="math">\\nu = L_Q(\\ell)</span>  with  <span class="math">1/3 &lt; \\ell &lt; 2/3</span> , it is obviously faster than the case of large  <span class="math">\\nu</span> . So, we omit detailed analysis for this case and refer to Chapter 7.3. in [3].</p>

    <p class="text-gray-300">We conclude this section of the Appendix with a summary of our results in Table 7.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">1. K. Aoki, J. Franke, T. Kleinjung, A. K. Lenstra, and D. A. Osvik. A kilobit special number field sieve factorization. In <em>Advances in Cryptology &ndash; ASIACRYPT 2007</em>, volume 4833 of <em>Lecture Notes in Comput. Sci.</em>, pages 1&ndash;12, 2007.</p></li>
      <li><p class="text-gray-300">2. D. F. Aranha, L. Fuentes-Castaneda, E. Knapp, A. Menezes, and F. Rodriguez-Henriquez. Implementing pairings at the 192-bit security level. In <em>Pairing-Based Cryptography &ndash; Pairing 2012</em>, volume 7708 of <em>Lecture Notes in Comput. Sci.</em>, page 177, 2012.</p></li>
      <li><p class="text-gray-300">3. R. Barbulescu. Algorithms of discrete logarithm in finite fields. Phd thesis, Universit&eacute; de Lorraine, Dec. 2013.</p></li>
      <li><p class="text-gray-300">4. R. Barbulescu. An appendix for a recent paper of Kim. <em>IACR Cryptology ePrint Archive</em>, 2015:1076, 2015.</p></li>
      <li><p class="text-gray-300"> R. Barbulescu, P. Gaudry, A. Guillevic, and F. Morain. Improving NFS for the discrete logarithm problem in non-prime finite fields. In <em>Advances in Cryptology -EUROCRYPT 2015</em>, volume 9056 of <em>Lecture Notes in Comput. Sci.</em>, pages 129&ndash;155, 2015.</p></li>
      <li><p class="text-gray-300">6. R. Barbulescu, P. Gaudry, A. Joux, and E. Thom&eacute;. A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic. In <em>Advances in Cryptology - EUROCRYPT 2014</em>, volume 8441 of <em>Lecture Notes in Comput. Sci.</em>, pages 1&ndash;16, 2014.</p></li>
      <li><p class="text-gray-300"> R. Barbulescu, P. Gaudry, and T. Kleinjung. The Towed Number Field Sieve. In Advances in Cryptology &ndash; ASIACRYPT 2015, volume 9453 of Lecture Notes in Comput. Sci., pages 31&ndash;55, 2015.</p></li>
      <li><p class="text-gray-300">8. R. Barbulescu and C. Pierrot. The multiple number field sieve for medium- and high-characteristic finite fields. <em>LMS Journal of Computation and Mathematics</em>, 17:230&ndash;246, 2014. The published version contains an error which is corrected in version 2 available at https://hal.inria.fr/hal-00952610.</p></li>
      <li><p class="text-gray-300">9. P. S. L. M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In <em>Selected Areas in Cryptography &ndash; SAC 2005</em>, volume 9566 of <em>Lecture Notes in Comput. Sci.</em>, pages 319&ndash;331, 2005.</p></li>
      <li><p class="text-gray-300">10. J.-L. Beuchat, J. E. Gonz&aacute;lez-D&iacute;az, S. Mitsunari, E. Okamoto, F. Rodr&iacute;guez-Henr&iacute;quez, and T. Teruya. High-speed software implementation of the optimal ate</p></li>
      <li><p class="text-gray-300">pairing over barreto&ndash;naehrig curves. In Pairing-Based Cryptography Pairing 2010, volume 6487 of Lecture Notes in Comput. Sci., pages 21&ndash;39. 2010.</p></li>
      <li><p class="text-gray-300">11. Y. Bistritz and A. Lifshitz. Bounds for resultants of univariate and bivariate polynomials. Linear Algebra and its Applications, 432(8):1995 &ndash; 2005, 2010. Special issue devoted to the 15th {ILAS} Conference at Cancun, Mexico, June 16-20, 2008.</p></li>
      <li><p class="text-gray-300">12. C. Bouvier, P. Gaudry, L. Imbert, H. Jeljeli, and E. Thom. Discrete logarithms in GF(p) &mdash; 180 digits, 2014. Announcement available at the NMBRTHRY archives, item 004703.</p></li>
      <li><p class="text-gray-300">13. S. Chatterjee, A. Menezes, and F. Rodriguez-Henriquez. On implementing pairingbased protocols with elliptic curves of embedding degree one. Cryptology ePrint Archive, Report 2016/403, 2016. <a href="http://eprint.iacr.org/2016/403" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2016/403</a>.</p></li>
      <li><p class="text-gray-300">14. I. Chillotti, N. Gama, M. Georgieva, and M. Izabach\`ene. A homomorphic lwe based e-voting scheme. In Post-Quantum Cryptography &ndash; PQCrypto 2016, volume 9606 of Lecture Notes in Comput. Sci., pages 245&ndash;265. Springer, 2016.</p></li>
      <li><p class="text-gray-300">15. A. Commeine and I. Semaev. An algorithm to solve the discrete logarithm problem with the number field sieve. In Public Key Cryptology&ndash;PKC 2006, volume 3958 of Lecture Notes in Comput. Sci., pages 174&ndash;190, 2006.</p></li>
      <li><p class="text-gray-300">16. S. Danilov and I. Popovyan. Factorization of RSA-180, 2010. <a href="http://eprint.iacr.org/2010/270" target="_blank" rel="noopener noreferrer">http://eprint.iacr.</a> <a href="http://eprint.iacr.org/2010/270" target="_blank" rel="noopener noreferrer">org/2010/270</a>.</p></li>
      <li><p class="text-gray-300">17. European Union Agency of Network and Information Security (ENISA). Algorithms, key sizes and parameters report, 2013 recommandations, version 1.0, October 2013. Publucation available online at <a href="https://www.enisa.europa.eu/publications/algorithms-key-sizes-and-parameters-report" target="_blank" rel="noopener noreferrer">https://www.enisa.europa.eu/</a> <a href="https://www.enisa.europa.eu/publications/algorithms-key-sizes-and-parameters-report" target="_blank" rel="noopener noreferrer">publications/algorithms-key-sizes-and-parameters-report</a>.</p></li>
      <li><p class="text-gray-300">18. D. Freeman. Constructing pairing-friendly elliptic curves with embedding degree 10. In Algorithmic Number Theory &ndash; ANTS-VII, volume 4076 of Lecture Notes in Comput. Sci., pages 452&ndash;465, 2006.</p></li>
      <li><p class="text-gray-300">19. D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing-friendly elliptic curves. Journal of Cryptology, 23(2):224&ndash;280, 2010.</p></li>
      <li><p class="text-gray-300">20. D. M. Gordon. Discrete logarithms in GF(p) using the number field sieve. SIAM J. Discret. Math., 6(1):124&ndash;138, Feb. 1993.</p></li>
      <li><p class="text-gray-300">21. R. Granger, T. Kleinjung, and J. Zumbr&uml;agel. On the powers of 2. Cryptology ePrint Archive, Report 2014/300, 2014. <a href="http://eprint.iacr.org/2014/300" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/2014/300</a>.</p></li>
      <li><p class="text-gray-300">22. A. Joux, R. Lercier, N. P. Smart, and F. Vercauteren. The number field sieve in the medium prime case. In Advances in Cryptology - CRYPTO 2006, volume 4117 of Lecture Notes in Comput. Sci., pages 326&ndash;344, 2006.</p></li>
      <li><p class="text-gray-300">23. A. Joux and C. Pierrot. The special number field sieve in Fp<sup>n</sup> &ndash; application to pairing-friendly constructions. In Pairing-Based Cryptography - Pairing 2013, volume 8365 of Lecture Notes in Comput. Sci., pages 45&ndash;61, 2013.</p></li>
      <li><p class="text-gray-300">24. T. Kim. Extended tower number field sieve: A new complexity for medium prime case. IACR Cryptology ePrint Archive, 2015:1027, 2015.</p></li>
      <li><p class="text-gray-300">25. A. K. Lenstra. Unbelievable security: Matching aes security using public key systems. In Advances in cryptology &ndash; ASIACRYPT 2001, volume 2248 of Lecture Notes in Comput. Sci., pages 67&ndash;86, 2001.</p></li>
      <li><p class="text-gray-300">26. H. W. Lenstra Jr. Factoring integers with elliptic curves. Annals of Mathematics, pages 649&ndash;673, 1987.</p></li>
      <li><p class="text-gray-300">27. D. V. Matyukhin. Effective version of the number field sieve for discrete logarithm in a field GF(p k ). Trudy po Diskretnoi Matematike, 9:121&ndash;151, 2006.</p></li>
      <li><p class="text-gray-300">28. National Institute of Standards and Technology (NIST). Nist special publication 800- 57 part 1 (revised) : Recommendation for key management, part 1: General (revised), July 2012. Publication available online at <a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf" target="_blank" rel="noopener noreferrer">http://csrc.nist.gov/publications/</a> <a href="http://csrc.nist.gov/publications/nistpubs/800-57/sp800-57-Part1-revised2_Mar08-2007.pdf" target="_blank" rel="noopener noreferrer">nistpubs/800-57/sp800-57-Part1-revised2\\_Mar08-2007.pdf</a>.</p></li>
      <li><p class="text-gray-300">29. A. M. Odlyzko. The future of integer factorization. CryptoBytes (The technical newsletter of RSA Laboratories), 1(2):5&ndash;12, 1995.</p></li>
      <li><p class="text-gray-300">30. C. Pierrot. The multiple number field sieve with conjugation and generalized Joux-Lercier methods. In Advances in Cryptology - EUROCRYPT 2015, volume 9056 of Lecture Notes in Comput. Sci., pages 156&ndash;170, 2015.</p></li>
      <li><p class="text-gray-300">31. P. Sarkar and S. Singh. New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields. In Advances in Cryptology &ndash; EUROCRYPT 2016, volume 9665 of Lecture Notes in Comput. Sci., 2016.</p></li>
      <li><p class="text-gray-300">32. O. Schirokauer. Discrete logarithms and local units. Philosophical Transactions of the Royal Society of London A: Mathematical, Physical and Engineering Sciences, 345(1676):409&ndash;423, 1993.</p></li>
      <li><p class="text-gray-300">33. O. Schirokauer. Using number fields to compute logarithms in finite fields. Math. Comput., 69(231):1267&ndash;1283, 2000.</p></li>
      <li><p class="text-gray-300">34. D. Wiedemann. Solving sparse linear equations over finite fields. IEEE Trans. Inform. Theory, 32(1):54&ndash;62, 1986.</p></li>
    </ul>

    </section>
`;
---

<BaseLayout title="Extended Tower Number Field Sieve: A New Complexity for the ... (2015/1027)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2015 &middot; eprint 2015/1027
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Extended TNFS</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Setting</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Detailed Descriptions</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-3" class="hover:text-white">Complexity</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-3.3" class="hover:text-white">exTNFS-Conj</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-4" class="hover:text-white">Variants</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-4.1" class="hover:text-white">The case when p has a special form (SexTNFS)</a></li>
            <li><a href="#sec-4.2" class="hover:text-white">The multiple polynomial variants (MexTNFS)</a></li>
          </ol>
        </li>
        <li>
          <a href="#sec-5" class="hover:text-white">Comparison and examples</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-5.1" class="hover:text-white">Precise comparison when p is arbitrary</a></li>
            <li><a href="#sec-5.2" class="hover:text-white">Precise comparison when p is SNFS</a></li>
          </ol>
        </li>
        <li><a href="#sec-6" class="hover:text-white">On the necessity to update key sizes</a></li>
        <li><a href="#sec-7" class="hover:text-white">Cryptologic consequences</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Appendices
      </p>
      <ol class="space-y-1 text-sm text-gray-400
        list-[upper-alpha] list-inside">
        <li><a href="#app-a" class="hover:text-white">Non-linear polynomials</a></li>
        <li><a href="#app-b" class="hover:text-white">Individual Logarithm</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="extended-tower-number-field-sieve-a-new-complexity-for-the-2015" />
  </article>
</BaseLayout>
