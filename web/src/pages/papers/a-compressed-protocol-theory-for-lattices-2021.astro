---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/307';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Compressed $\\Sigma$-Protocol Theory for Lattices';
const AUTHORS_HTML = 'Thomas Attema, Ronald Cramer, Lisa Kohl';

const CONTENT = `    <p class="text-gray-300">A Compressed <span class="math">\\Sigma</span>-Protocol Theory for Lattices</p>

    <p class="text-gray-300">Thomas Attema^{1,2,3,⋆}, Ronald Cramer^{1,2,⋆⋆}, and Lisa Kohl^{1,⋆⋆⋆}</p>

    <p class="text-gray-300">^{1} CWI, Cryptology Group, Amsterdam, The Netherlands</p>

    <p class="text-gray-300">^{2} Leiden University, Mathematical Institute, Leiden, The Netherlands</p>

    <p class="text-gray-300">^{3} TNO, Cyber Security and Robustness, The Hague, The Netherlands</p>

    <p class="text-gray-300">Version 3 - October 14, 2021</p>

    <p class="text-gray-300">Abstract. We show a lattice-based solution for commit-and-prove transparent circuit zero-knowledge (ZK) with polylog-communication, the first not depending on PCPs.</p>

    <p class="text-gray-300">We start from compressed <span class="math">\\Sigma</span>-protocol theory (CRYPTO 2020), which is built around basic <span class="math">\\Sigma</span>-protocols for opening an arbitrary linear form on a long secret vector that is compactly committed to. These protocols are first compressed using a recursive “folding-technique” adapted from Bulletproofs, at the expense of logarithmic rounds. Proving in ZK that the secret vector satisfies a given constraint – captured by a circuit – is then by (blackbox) reduction to the linear case, via arithmetic secret-sharing techniques adapted from MPC. Commit-and-prove is also facilitated, i.e., when commitment(s) to the secret vector are created ahead of any circuit-ZK proof. On several platforms (incl. DL) this leads to logarithmic communication. Non-interactive versions follow from Fiat-Shamir.</p>

    <p class="text-gray-300">This abstract modular theory strongly suggests that it should somehow be supported by a lattice-platform as well. However, when going through the motions and trying to establish low communication (on a SIS-platform), a certain significant lack in current understanding of multi-round protocols is exposed.</p>

    <p class="text-gray-300">Namely, as opposed to the DL-case, the basic <span class="math">\\Sigma</span>-protocol in question typically has poly-small challenge space. Taking into account the compression-step – which yields non-constant rounds – and the necessity for parallelization to reduce error, there is no known tight result that the compound protocol admits an efficient knowledge extractor. We resolve the state of affairs here by a combination of two novel results which are fully general and of independent interest. The first gives a tight analysis of efficient knowledge extraction in case of non-constant rounds combined with poly-small challenge space, whereas the second shows that parallel repetition indeed forces rapid decrease of knowledge error.</p>

    <p class="text-gray-300">Moreover, in our present context, arithmetic secret sharing is not defined over a large finite field but over a quotient of a number ring and this forces our careful adaptation of how the linearization techniques are deployed.</p>

    <p class="text-gray-300">We develop our protocols in an abstract framework that is conceptually simple and can be flexibly instantiated. In particular, the framework applies to arbitrary rings and norms.</p>

    <p class="text-gray-300">Keywords: Zero Knowledge, Circuit ZK, Lattices, <span class="math">\\Sigma</span>-Protocols, Compression, Short Integer Solution Problem.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Compressed <span class="math">\\Sigma</span>-Protocol Theory [AC20] is built around basic <span class="math">\\Sigma</span>-protocols for opening an arbitrary linear form on a long secret vector that is compactly committed to. More precisely, these <span class="math">\\Sigma</span>-protocols allow a prover to prove that a committed vector <span class="math">\\mathbf{x}</span> satifies a constraint <span class="math">L(\\mathbf{x})=y</span> captured by a linear form <span class="math">L</span>. They are first compressed using a recursive “folding-technique” adapted from Bulletproofs [BCC+16, BBB+18]. Compression reduces the communication complexity from linear down to logarithmic in the dimension of the secret</p>

    <p class="text-gray-300">vector <span class="math">\\mathbf{x}</span>, at the expense of a logarithmic number of rounds. Proving in ZK that the secret vector satisfies an arbitrary (non-linear) constraint – captured by an arithmetic circuit – is then by (blackbox) reduction to the linear case, via arithmetic secret-sharing techniques adapted from MPC. It was shown how to instantiate this theory from different hardness assumptions, i.e., the Discrete Logarithm (DL), Strong-RSA and Knowledge-of-Exponent (KEA) assumption. The latter assumption even results in constant communication, instead of logarithmic. Non-interactive versions follow from the Fiat-Shamir transform <em>[x10]</em>.</p>

    <p class="text-gray-300">The starting point is always a compact and homomorphic vector commitment scheme, i.e., commitments should have size constant (or logarithmic) in the dimension of the committed vector. After instantiating such a commitment scheme from any of the aforementioned hardness assumption, compressed <span class="math">\\Sigma</span>-protocol theory can be described in an abstract and modular manner. This strongly suggests that the theory should also be supported by a lattice platform. This belief was further strengthened by the recent lattice-based Bulletproof instantiation for proving knowledge of a SIS preimage <em>[x1]</em>.</p>

    <p class="text-gray-300">However, when going through the motions and trying to establish low communication (on a SIS-platform), a certain significant lack in current understanding of multi-round protocols and several challenges are exposed.</p>

    <h3 id="sec-1" class="text-xl font-semibold mt-8">1.1 Challenges for Lattice Instantiations</h3>

    <p class="text-gray-300">As opposed to the DL-case, the lattice-based <span class="math">\\Sigma</span>-protocol typically has polynomially small challenge space. Taking into account the compression-step – which yields non-constant rounds – there is no known result from which a tight knowledge soundness property can be derived. In prior works, this lack in understanding was handled by an alternative non-tight security analysis <em>[BCC^{+}16]</em>. Recent works, while remaining non-tight, have improved the tightness <em>[x23, x12, x1, x11, x1]</em>.</p>

    <p class="text-gray-300">The situation is further complicated by the necessity for parallelization to reduce the knowledge error. While parallel repetition of interactive proofs has been studied extensively in the context of decreasing the soundness error <em>[x13, x7, x8]</em>, to the best of our knowledge there does not exist a general parallel repetition theorem for decreasing the knowledge error.</p>

    <p class="text-gray-300">Setting aside the knowledge error issues addressed previously, the main difference between the lattice setting and the other settings is a norm bound. Instead of proving knowledge of a preimage for some homomorphism <span class="math">\\Psi</span>, we aim to prove knowledge of a short pre-image. More precisely, for some homomorphism <span class="math">\\Psi</span>, we aim to construct a protocol for the following relation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$R_{\\Psi,\\alpha}=\\{(P;x):P=\\Psi(x),\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\alpha\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">(P;x)\\in R_{\\Psi,\\alpha}</span> is a pair of a public statement <span class="math">P</span> and a secret witness <span class="math">x</span>. The DL-based protocols are designed for exactly the same abstract relation, but without the norm-bound. This minor difference introduces a number of challenges that have been dealt with in the context of plain <span class="math">\\Sigma</span>-protocols for some time now. For example, given a preimage <span class="math">x</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">, a prover is typically only capable of proving knowledge of a preimage </span>y<span class="math"> with </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\alpha\\beta<span class="math">. The factor </span>\\alpha\\geq 1$ is referred to as the soundness slack. In multi-round protocols the soundness slack accumulates and a more careful analysis is warranted.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, in our present lattice context, committed vectors typically have coefficients in the quotient of a number ring <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/(f(X))</span> by a rational prime <span class="math">(p)</span>. However, the structure of the ring <span class="math">\\mathcal{R}_{p}</span> may not readily allow for the large sets with invertible pairwise differences required for Shamir secret sharing.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.2 Contributions</h3>

    <p class="text-gray-300">We show a lattice-based solution for commit-and-prove transparent circuit ZK with polylogarithmic communication, the first not depending on PCPs.</p>

    <p class="text-gray-300">To this end, we resolve the lack in understanding regarding knowledge soundness by a combination of two novel results which are fully general and of independent interest. The first gives a tight analysis of efficient knowledge extraction in case of non-constant rounds, whereas the second shows that parallel repetition indeed forces rapid decrease of knowledge error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By our extractor analysis, we tightly prove that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness implies knowledge soundness, without imposing any restrictions on the size of the challenge sets. In a concurrent and independent work this result was deemed out of reach with current techniques <em>[x1]</em>. More concretely, they apply the non-tight analysis of <em>[x4]</em> and derive a knowledge error $\\kappa\\leq 8.16\\log n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>n<span class="math"> is the size of the input. By contrast, we provide a tight bound and show that </span>\\kappa\\leq 2\\log n/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This inequality contains a simplified expression and is therefore non-tight, for the tight bound we refer to Theorem 1. Furthermore, our result answers an open question regarding knowledge extractors, recently made explicit <em>[x14, Question D.4.]</em>, in the affirmative. It is generally applicable to all aforementioned platforms and therefore improves upon the analyses of <em>[BCC^{+}16, x27, x14, x5, x10]</em>, directly yielding better parameters for multi-round protocols such as Bulletproofs. Towards showing that </span>(k_{1},\\ldots,k_{\\mu})<span class="math">-special soundness tightly implies knowledge soundness, we observe that for the special case of </span>2$-special soundness (where this implication is well-known) we can give a very simple proof that we have not encountered in the literature before. In contrast to standard proof techniques, our extractor can be modeled by a negative hyper geometric distribution. This simplification turns out to be generalizable to the multi-round scenario. Even though the general proof is building on this simplification, its analysis turns out to be quite involved.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By the second result, we show that parallel repetition indeed forces a rapid decrease of knowledge error, explicitly proving a result that is often taken for granted whereas it actually requires a careful analysis. More precisely, it is known that parallel repetition decreases the soundness error. However, knowledge soundness is a strictly stronger notion than soundness. Nevertheless, by a careful analysis, we prove that prior results also apply to knowledge sound protocols and allow for a rapid decrease of knowledge error. The <span class="math">(2,2)</span>-special sound signature scheme MQDSS was already presented with a tight knowledge error analysis <em>[CHR^{+}16]</em>. However, their analysis crucially depends on the fact that this signature scheme has a constant number of rounds and therefore does not apply to our setting. Our techniques are generic and also apply to this protocol, indeed yielding exactly the same knowledge error.</p>

    <p class="text-gray-300">Furthermore, we describe a careful adaptation of the arithmetic secret sharing based linearization strategy from <em>[x2]</em>. First, the evaluation points of Shamir’s secret sharing scheme have to be chosen from an exceptional, instead of an arbitrary, subset of the ring <span class="math">\\mathcal{R}_{p}</span>, i.e., a subset with invertible differences. In many practical scenarios this minor adaptation suffices. However, some rings do not contain “large enough” exceptional subsets. For this reason, we extend the linearization technique to work for small rings <span class="math">\\mathcal{R}_{p}</span> by defining the secret sharing scheme over an appropriately chosen ring extension. Some care is warranted to prevent dishonest provers from choosing secret elements in the extension ring.</p>

    <p class="text-gray-300">Subsequently, we note that working in a lattice-platform is considerably more tedious. Traditionally the security analysis depends strongly on various protocol design choices. Our approach is less sensitive to these choices. This is very convenient when considering variations. More precisely, we develop our protocols in an abstract framework that is conceptually simple and can be flexibly instantiated. In particular, the framework applies to arbitrary rings, challenge sets and norms. Our framework captures general rejection sampling strategies, gives precise bounds on the introduced soundness slack and generalizes beyond factor-<span class="math">2</span> per-round compression.</p>

    <p class="text-gray-300">The communication complexity of our protocols, when instantiated from the Module Short Integer Solution (MSIS) assumption and appropriately chosen rings, is polylogarithmic in the input size. Due to the soundness slack it does not achieve the logarithmic communication of a DL-based instantiation. Our protocols are transparent, i.e., no trusted setup, and easily ported to the commit-and-prove paradigm, where commitment(s) to the secret vector have been created ahead of any circuit-ZK proof. Moreover, various efficiency improvements, developed for DL-based (compressed) <span class="math">\\Sigma</span>-protocol theory, almost directly carry over to the lattice-setting.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.3 Related Work</h3>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Circuit ZK with Polylogarithmic Complexity from PCPs.</h4>

    <p class="text-gray-300">A generic class of (zero-knowledge) proof systems is based on Probabilistically Checkable Proofs (PCPs). The security of these protocols only relies on the existence of collision-resistant hash functions and they achieve polylogarithmic communication complexity. However, large concrete costs have long prevented PCP-based protocols from being deployed in practice. Recent</p>

    <p class="text-gray-300">advances have rendered PCP-based protocols practical <em>[x1, BBC^{+}17, BCR^{+}19]</em>. Still, for small problem instances, PCP-based protocols are often outperformed by other approaches relying on more structured hardness assumptions. In particular, PCP approaches rely on Merkle-tree commitments and therefore have an implicit lower bound in the order of a hundred kilobytes, whereas protocols relying on the compression mechanism such as Bulletproofs can go down to as much as a few kilobytes. Even though the soundness slack introduced by the compression mechanism is currently somewhat limiting in terms of concrete efficiency, we expect that on the long run the non-PCP lattice-based approach will lead to more succinct proofs.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Circuit ZK with Sublinear Complexity from Lattice Assumptions</h4>

    <p class="text-gray-300">The first protocol of this form achieving a sub-linear communication complexity <span class="math">\\widetilde{\\mathcal{O}}(\\sqrt{\\lambda n})</span>, where <span class="math">n</span> is the input size and <span class="math">\\lambda</span> the security parameter, was presented in <em>[BBC^{+}18]</em>. A key component of their protocol is a compact commitment scheme. In our lattice instantiation we use exactly the same compact commitment scheme. While their approach is inherently limited to communication complexity in the order of <span class="math">\\widetilde{\\mathcal{O}}(\\sqrt{\\lambda n})</span>, our approach yields the first lattice-based (non-PCP) protocol that achieves polylogarithmic complexity in the input length. On the other hand, our approach requires a larger number of rounds. Getting a similar communication-complexity/round trade-off as <em>[BBC^{+}18]</em> by using a larger per-round compression seems currently out of reach, due to the large soundness slack introduced (which scales exponentially in the compression factor).</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Lattice-based proof of knowledge of SIS preimages</h4>

    <p class="text-gray-300">The lattice-based Bulletproof instantiation of <em>[x10]</em> is most similar to our compressed <span class="math">\\Sigma</span>-protocol. However, in this work the aforementioned knowledge error issues were overlooked. Moreover, their work only considers proving knowledge of a SIS preimage, i.e., it does not consider generic arithmetic circuit relations. Furthermore, it is not zero-knowledge and it is tailored to a specific lattice-instantiation. By contrast, our protocol is a circuit ZK protocol that can be instantiated from a wide variety of lattices. For the specific scenario of proving knowledge of a SIS preimage, we obtain a comparable communication complexity.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.4 Roadmap</h3>

    <p class="text-gray-300">We start by presenting the general result that <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness tightly implies knowledge soundness in Section 3. We first outline a very simple proof for the special case of 2-special soundness, which is novel to the best of our knowledge. Subsequently, we show how this proof can be generalized to the multi-round setting. Using results from <em>[x13]</em>, we prove that parallel repetition of multi-round public-coin protocols not only reduces the soundness error, but also the knowledge error (see Section 4). In Section 5, we give an abstract theory for lattice-based compressed <span class="math">\\Sigma</span>-protocols. In Section 6, we show how to instantiate our abstract framework from the Module Short Integer Solution (MSIS) problem. We further provide an asymptotic parameter analysis for our instantiation and comparison with <em>[x10]</em>. In Section 7, we show how to adapt the linearization techniques of <em>[x2]</em> to the lattice section, where the arithmetic secret sharing is not defined over a large field but over a quotient of a number ring. Finally, in Section 8, we discuss a number of extensions for amortization over many linear forms, reducing the communication complexity and for obtaining commit-and-prove protocols directly.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Preliminaries</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We typically denote the input by <span class="math">x</span>. We sometimes parametrize security directly by the input length $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and sometimes by an extra security parameter </span>\\lambda\\in\\mathbb{N}<span class="math">, whichever is more convenient in the context. Since we always assume the input length </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to be polynomial in the security parameter </span>\\lambda$, this does not make a difference asymptotically.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say a function <span class="math">f\\colon\\mathbb{N}\\to\\mathbb{R}_{&gt;0}</span> is negligible, if for all <span class="math">c\\in\\mathbb{N}</span>, there exists a <span class="math">\\lambda_{0}\\in\\mathbb{N}</span> such that <span class="math">f(\\lambda)\\leq 1/\\lambda^{c}</span> for all <span class="math">\\lambda\\geq\\lambda_{0}</span>. We write <span class="math">\\text{negl}(\\lambda)</span> for short to denote a negligible function <span class="math">\\text{negl}\\colon\\mathbb{N}\\to\\mathbb{R}_{&gt;0}</span>. We say a function <span class="math">f\\colon\\mathbb{N}\\to\\mathbb{R}_{&gt;0}</span> is noticeable, if there exists a <span class="math">c\\in\\mathbb{N}</span> and a <span class="math">\\lambda_{0}\\in\\mathbb{N}</span>, such that <span class="math">f(\\lambda)\\geq 1/\\lambda^{c}</span> for all <span class="math">\\lambda_{0}\\geq\\lambda</span>.</p>

    <p class="text-gray-300">We use the notation <span class="math">\\mathrm{poly}(\\lambda)</span> for short to denote a function that is <em>polynomially bounded</em> in <span class="math">\\lambda</span>, i.e., there exist <span class="math">c,\\lambda_0\\in \\mathbb{N}</span> such that <span class="math">\\mathrm{poly}(\\lambda)\\leq \\lambda^c</span> for all <span class="math">\\lambda \\geq \\lambda_0</span>.</p>

    <p class="text-gray-300">Let <span class="math">X</span> and <span class="math">Y</span> be discrete random variables over a finite support <span class="math">D</span>. The <em>statistical difference</em> of two distributions <span class="math">X</span> and <span class="math">Y</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta (X, Y) = \\frac {1}{2} \\sum_ {d \\in D}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname <em> {P r} [ X = d ] - \\operatorname </em> {P r} [ Y = d ]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We say two ensembles of random variables <span class="math">\\{X_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}},\\{Y_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> are statistically close if there exists a negligible function <span class="math">\\mathrm{negl}\\colon \\mathbb{N}\\to \\mathbb{R}_{&amp;gt;0}</span> such that <span class="math">\\varDelta(X_{\\lambda},Y_{\\lambda})\\leq\\mathrm{negl}(\\lambda)</span> for all <span class="math">\\lambda \\in \\mathbb{N}</span>. We say two ensembles of random variables <span class="math">\\{X_{x}\\}_{x\\in \\{0,1\\}^{<em>}},\\{Y_{x}\\}_{x\\in \\{0,1\\}^{</em>}}</span> are statistically close if there exists a negligible function <span class="math">\\mathrm{negl}\\colon \\mathbb{N}\\to \\mathbb{R}_{&amp;gt;0}</span> such that $\\varDelta(X_{x},Y_{x})\\leq\\mathrm{negl}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for all </span>x\\in \\{0,1\\}^*$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-9" class="text-2xl font-bold">2.1 Interactive Proofs</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">R \\subset \\{0,1\\}^<em> \\times \\{0,1\\}^</em></span> be a binary relation. If <span class="math">(x; w) \\in R</span>, we say <span class="math">x</span> is a statement and <span class="math">w</span> is a witness for <span class="math">x</span>. We only consider NP relations, i.e., relations <span class="math">R</span> for which a witness <span class="math">w</span> can be verified in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> for all </span>(x; w) \\in R<span class="math">. In particular it follows that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The set of statements </span>x<span class="math"> that admit a witness </span>w<span class="math"> is denoted by </span>L_R<span class="math">, i.e., </span>L_R = \\{x : \\exists w \\text{ s.t. } (x; w) \\in R\\}<span class="math">. The set of witnesses for a statement </span>x<span class="math"> is denoted by </span>R(x)<span class="math">, i.e., </span>R(x) = \\{w : (x; w) \\in R\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 1 (Interactive Proof).</strong> An interactive proof <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span> for relation <span class="math">R</span> is an interactive protocol between two probabilistic polynomial time machines, a prover <span class="math">\\mathcal{P}</span> and a verifier <span class="math">\\mathcal{V}</span>. It allows a prover to convince a verifier to know a witness <span class="math">w</span> for a public statement <span class="math">x</span>. Both <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> take as public input a statement <span class="math">x</span> and, additionally, <span class="math">\\mathcal{P}</span> takes as private input a witness <span class="math">w \\in R(x)</span>, which is written as <span class="math">\\Pi(x;w)</span> or <span class="math">\\mathrm{INPUT}(x;w)</span>. As the output of the protocol, <span class="math">\\mathcal{V}</span> either accepts or rejects the prover's claim of knowing a <span class="math">w \\in R(x)</span>. Accordingly, we say the corresponding transcript (i.e., the set of all messages sent in the protocol execution) is accepting or rejecting.</p>

    <p class="text-gray-300"><strong>Definition 2 (Completeness).</strong> An interactive proof is said to be (perfectly) complete, if <span class="math">\\mathcal{V}</span> accepts after every honest execution that takes as input a public-private pair <span class="math">(x;w)\\in R</span>. We also consider a relaxed notion of completeness, in which an honest execution is allowed to be rejected with some probability called the completeness error.</p>

    <p class="text-gray-300">Intuitively, <span class="math">\\varPi</span> is said to be knowledge sound if any prover that convinces the verifier of knowing a witness for <span class="math">x\\in L_R</span> with large enough probability has to know some witness <span class="math">w</span> with <span class="math">(x;w)\\in R</span>. This is formalized by requiring that there exists an efficient algorithm that allows to extract such a witness from the prover.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3 (Knowledge Soundness).</strong> Let <span class="math">\\Pi = (\\mathcal{P},\\mathcal{V})</span> be an interactive proof for relation <span class="math">R</span>. Let <span class="math">\\kappa \\colon \\mathbb{N}\\to [0,1)</span> be a function. Then <span class="math">\\Pi</span> is said to be knowledge sound with knowledge error <span class="math">\\kappa</span>, if there exists a polynomial <span class="math">q\\colon \\mathbb{N}\\to \\mathbb{N}</span> and an algorithm <span class="math">\\mathcal{E}</span>, called a knowledge extractor, with the following properties: The extractor <span class="math">\\mathcal{E}</span>, given input <span class="math">x</span> and rewindable oracle access to a (potentially dishonest) prover <span class="math">\\mathcal{P}^<em></span>, runs in an expected polynomial number of steps and, whenever <span class="math">(\\mathcal{P}^</em>,\\mathcal{V})(x)</span> outputs accept with probability $\\epsilon(x)\\geq \\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, successfully outputs a witness </span>w\\in R(x)<span class="math"> with probability at least </span>(\\epsilon (x) - \\kappa (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)) / q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 4 (Proof/ Argument of Knowledge).</strong> An interactive proof that is both complete with completeness error <span class="math">\\gamma \\colon \\mathbb{N} \\to [0,1)</span> and knowledge sound with knowledge error <span class="math">\\kappa &amp;lt; 1 - \\gamma</span> is said to be a Proof of Knowledge (PoK). PoKs for which knowledge soundness only holds under computational assumptions are also referred to as Arguments of Knowledge.</p>

    <p class="text-gray-300">5 Note that, originally interactive proofs are required to be complete and knowledge sound by definition [GMR85]. By contrast, we consider these properties separately as desirable properties.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 5 ((Public-coin) <span class="math">\\mu</span>-move protocol).</h6>

    <p class="text-gray-300">An interactive proof with <span class="math">\\mu</span> communication rounds is called a <span class="math">\\mu</span>-move protocol. If additionally all of the verifier’s random coins are made public, <span class="math">\\Pi</span> is said to be a <em>public-coin</em> <span class="math">\\mu</span>-move protocol.</p>

    <p class="text-gray-300">Public-coin protocols can be made non-interactive by the Fiat-Shamir transformation <em>[x10]</em>. For details we refer to Section 5.5. All protocols in this work are public-coin.</p>

    <p class="text-gray-300">Intuitively, an interactive proof is said to be <em>zero-knowledge</em> if a (possibly dishonest) verifier cannot obtain any information about the secret witness <span class="math">w</span> from interacting with an honest prover. For our setting it will be sufficient to only consider honest verifiers, because the randomness will be obtained via applying the Fiat-Shamir transform. Further, for the lattice-based instantiation we will only be able to simulate non-aborting transcripts and therefore can only rely on a relaxed notion of honest verifier zero knowledge. Again, this will not constitute a problem when instantiating the protocols with the Fiat-Shamir transform, because in this case aborting executions are never published.</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 6 ((Special/ Non-abort) Honest-Verifier Zero Knowledge).</h6>

    <p class="text-gray-300">An interactive protocol <span class="math">\\Pi</span> is said to be <em>honest verifier zero-knowledge</em> (HVZK) if there exists a polynomial time simulator that on input <span class="math">x\\in L_{R}</span> outputs an accepting transcript which is distributed statistically close to the transcripts generated by honest executions of <span class="math">\\Pi</span>. If the simulator proceeds by first sampling the verifier’s messages uniformly at random, then <span class="math">\\Pi</span> is said to be <em>special honest verifier zero-knowledge</em> (SHVZK). We say a protocol is <em>non-abort honest-verifier zero knowledge</em>, if the distribution of the transcript produced by the simulator is statistically close to the transcripts generated by an honest execution <em>whenever the honest prover does not abort</em>.</p>

    <p class="text-gray-300">Note that in the literature non-abort (S)HVZK is often simply referred to as (S)HVZK. We use a different notation to highlight that the notion of non-abort (S)HVZK is weaker than (S)HVZK, as in an interactive protocol execution the verifier might learn something from aborting executions.</p>

    <p class="text-gray-300">In the following we introduce the notion of special soundness, which is easier to handle than knowledge soundness.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 7 (<span class="math">k</span>-Special Soundness).</h6>

    <p class="text-gray-300">A <span class="math">3</span>-move public-coin protocol is said to be <em>special sound</em> if there exists a polynomial time algorithm that on input a statement <span class="math">x</span> and two accepting transcripts <span class="math">(a,c,z)</span> and <span class="math">(a,c^{\\prime},z^{\\prime})</span>, with <span class="math">c\\neq c^{\\prime}</span> and common first message <span class="math">a</span>, outputs a witness <span class="math">w\\in R(x)</span>. If the algorithm takes as input <span class="math">k</span> transcripts, with pairwise distinct challenges and a common first message, instead of <span class="math">2</span>, the protocol is said to be <span class="math">k</span>-special sound.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 8 (<span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">A <span class="math">3</span>-move protocol that is public-coin, complete, <span class="math">k</span>-special sound and SHVZK is said to be <span class="math">\\Sigma</span>-*protocol.</p>

    <p class="text-gray-300">In this paper, we will more generally refer to <span class="math">\\Sigma</span>-protocols also for <span class="math">(2\\mu+1)</span>-move protocols that are public-coin, complete (with some completeness error), <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound and (non-abort) SHVZK.</p>

    <p class="text-gray-300">Before extending the definition of special soundness to <span class="math">2\\mu+1</span>-move protocols, we have to introduce the notion of a tree of transcripts.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Definition 9 (Tree of transcripts).</h6>

    <p class="text-gray-300">A <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of transcripts for a <span class="math">(2\\mu+1)</span>-move public-coin protocol is a set of <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span> transcripts arranged in the following tree structure. The nodes in this tree correspond to the prover’s messages and the edges correspond to the verifier’s challenges. Every node at depth <span class="math">i</span> has precisely <span class="math">k_{i}</span> children corresponding to <span class="math">k_{i}</span> pairwise distinct challenges. Every transcript corresponds to exactly one path from the root node to a leaf node. For a graphic representation we refer to Figure 1.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 10 (<span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special Soundness).</h6>

    <p class="text-gray-300">A <span class="math">(2\\mu+1)</span>-move public-coin protocol is <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound if there exists an efficient algorithm that on input a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of accepting transcripts outputs a witness <span class="math">w\\in R(x)</span>.</p>

    <p class="text-gray-300">Note that it is non-trivial to show that special soundness implies knowledge soundness, because in contrast to the extractor <span class="math">\\mathcal{E}</span> of Definition 3 that has only access to the prover, the algorithm for special soundness obtains the transcripts directly. While it is well known that for <span class="math">3</span>-move protocols special soundness implies knowledge soundness, previously there was no known generalization to <span class="math">2\\mu+1</span>-move protocols. We refer to Section 3 for details.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>-tree of transcripts of a <span class="math">(2\\mu +1)</span>-move public-coin protocol.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2.2 Negative Hypergeometric Distribution</h2>

    <p class="text-gray-300">In order to show that <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>-special soundness implies knowledge soundness (see Section 3), we will use the negative hypergeometric distribution. The negative hypergeometric distribution describes the following distribution: Given a bin with <span class="math">N</span> balls of which <span class="math">M</span> are marked, then the number of attempts when drawing from the bin (without replacement) until <span class="math">k\\leq M</span> marked balls are drawn is distributed according to the negative hypergeometric distribution. The expected number of draws equals <span class="math">\\frac{k(N + 1)}{M + 1}</span>.</p>

    <h2 id="sec-17" class="text-2xl font-bold">2.3 Lattices</h2>

    <p class="text-gray-300">A lattice <span class="math">\\varLambda</span> is a discrete additive subgroup of <span class="math">\\mathbb{R}^m</span>. The lattice <span class="math">\\varLambda</span> is said to be <span class="math">q</span>-ary if <span class="math">q\\mathbb{Z}^m \\subset \\varLambda \\subset \\mathbb{Z}^m</span>. Let <span class="math">A \\in \\mathbb{Z}_q^{k \\times m}</span>, then <span class="math">\\varLambda_q^\\perp(A) = \\{\\mathbf{x} \\in \\mathbb{Z}^m : A\\mathbf{x} = 0 \\mod q\\}</span> defines a <span class="math">q</span>-ary lattice in <span class="math">\\mathbb{Z}^m</span>.</p>

    <p class="text-gray-300">We also consider lattices defined over a ring <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / f(X)</span>, where <span class="math">f(X)</span> is a monic irreducible polynomial of degree <span class="math">d</span>. Via the coefficient embedding norms on <span class="math">\\mathbb{C}</span>-vector spaces extend to vectors of ring elements, i.e., for <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{m})\\in \\mathcal{R}^{m}</span> with <span class="math">x_{i} = \\sum_{j = 1}^{d}a_{i,j}X^{j - 1}\\in \\mathcal{R}</span> we define</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(a _ {1, 1}, \\ldots , a _ {m, d}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}, \\quad \\mathrm {a n d} \\quad \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\max _ {i, j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a _ {i, j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For a prime <span class="math">q \\in \\mathbb{N}</span>, we write <span class="math">\\mathcal{R}_q = \\mathbb{Z}[X] / (q, f(X)) = \\mathbb{Z}_q[X] / (f(X))</span>. Let <span class="math">A \\in \\mathcal{R}^{k \\times m}</span>, then <span class="math">\\varLambda_q^\\perp(A) = \\{\\mathbf{x} \\in \\mathcal{R}^m : A\\mathbf{x} = 0 \\mod q\\}</span> defines a <span class="math">q</span>-ary lattice in <span class="math">\\mathbb{Z}^{dm}</span>. Finding a non-zero and short element in a lattice <span class="math">\\varLambda_q^\\perp(A)</span> is referred to as the Module Short Integer Solution (MSIS) problem [LS15]. The MSIS problem is assumed to be a computationally hard problem.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 11 (MSIS<span class="math">_{k,m,\\beta}</span> Problem).</strong> Let <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / f(X)</span> for a monic and irreducible polynomial <span class="math">f(X)</span> and let <span class="math">q \\in \\mathbb{N}</span> be a prime. The MSIS<span class="math">_{k,m,\\beta}</span> problem over <span class="math">\\mathcal{R}_q</span> is defined as follows. Given a matrix <span class="math">A \\gets_R \\mathcal{R}_q^{k \\times m}</span> sampled uniformly at random, find a non-zero vector <span class="math">\\mathbf{s} \\in \\mathcal{R}^m</span> such that <span class="math">A\\mathbf{s} = 0 \\mod q</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Micciancio and Regev [MR09] showed that a MSIS-algorithm is expected to output a MSIS solution with norm</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {s} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\geq \\min  \\left(q, 2 ^ {2 \\sqrt {d k \\log \\delta \\log q}}\\right), \\tag {1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">\\delta</span> is the root Hermite factor of the lattice reduction algorithm that is used. In particular, smaller values of <span class="math">\\delta</span> require better lattice reduction algorithms. In general, <span class="math">\\delta \\approx 1.0045</span> is assumed to achieve 128-bit computational security [APS15, ESS⁺19].</p>

    <p class="text-gray-300">In this work, we will be interested in vectors that are short with respect to the <span class="math">\\ell_{\\infty}</span>-norm. For this reason we also consider the following variant of the MSIS problem, where "shortness" is defined in terms of the <span class="math">\\ell_{\\infty}</span>-norm. Clearly, the hardness of <span class="math">\\mathrm{MSIS}_{k,m,\\beta}^{\\infty}</span> is implied by the hardness of <span class="math">\\mathrm{MSIS}_{k,m,\\sqrt{dm}\\beta}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 12 (MSIS<span class="math">_{k,m,\\beta}^{\\infty}</span> Problem over <span class="math">\\mathcal{R}_q</span>).</strong> Let <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / f(X)</span> for a monic and irreducible polynomial <span class="math">f(X)</span> and let <span class="math">q \\in \\mathbb{N}</span> be a prime. The <span class="math">\\mathrm{MSIS}_{k,m,\\beta}^{\\infty}</span> problem over <span class="math">\\mathcal{R}_q</span> is defined as follows. Given a matrix <span class="math">A \\leftarrow_R \\mathcal{R}_q^{k \\times m}</span> sampled uniformly at random, find a non-zero vector <span class="math">\\mathbf{s} \\in \\mathcal{R}^m</span> such that <span class="math">A\\mathbf{s} = 0 \\mod q</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-18" class="text-2xl font-bold">2.4 Commitment Schemes</h2>

    <p class="text-gray-300">A commitment scheme allows a prover to create a commitment <span class="math">P</span> to an element <span class="math">x</span> such that the prover can later open <span class="math">P</span> to the committed element <span class="math">x</span>. Informally, a commitment scheme is required to be binding, i.e., a prover cannot open a commitment <span class="math">P</span> to two different elements <span class="math">x \\neq y</span>, and hiding, i.e., the commitment <span class="math">P</span> does not reveal any information about the committed vector <span class="math">x</span>. A commitment scheme consists of a setup algorithm, generating the scheme's public parameters, and a commitment function COM. The commitment function takes as input an element <span class="math">x</span> and randomness <span class="math">\\gamma</span> (and public parameters <span class="math">\\mathsf{pp}</span>) and outputs a commitment <span class="math">P</span>, i.e., <span class="math">\\mathrm{COM}(x, \\gamma) = P</span>. To open a commitment a prover reveals <span class="math">(x, \\gamma)</span> such that a verifier can verify that <span class="math">\\mathrm{COM}(x, \\gamma) = P</span>. The commitment scheme is said to be homomorphic if the commitment function COM (considered respective to fixed public parameters) is a group homomorphism.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The primary commitment scheme of interest to us, described in Definition 13, was already implicit in Ajtai's seminal work [Ajt96]. It allows a prover to commit to a short vector $\\mathbf{x} \\in S_{\\eta}^{n} = \\{\\mathbf{y} \\in \\mathcal{R}^{n} : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{y} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\eta\\}<span class="math"> by sampling </span>\\gamma \\gets_{R} S_{\\eta}^{r}<span class="math"> uniformly at random and evaluating the commitment function </span>P = \\mathrm{COM}(x, \\gamma)<span class="math">. Note that, we consider this commitment scheme for secrets and randomness bounded in the </span>\\ell_{\\infty}<span class="math">-norm. We will typically instantiate this commitment scheme with norm bound </span>\\eta = \\lceil (p - 1) / 2 \\rceil<span class="math"> for some prime </span>p &lt; q<span class="math">. This allows a prover to commit to arbitrary vectors in </span>\\mathcal{R}_p^n<span class="math">. The properties of this commitment scheme are summarized in Lemma 1 and Lemma 2. Note in particular that by Equation 1 it follows that the hardness does not depend on the rank </span>n<span class="math">. It follows that the size of a commitment is constant in the rank </span>m = n + r$; we say that this commitment scheme is compact.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 13 (Compact Lattice-Based Commitment Scheme [Ajt96]).</strong> Let <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / f(X)</span> for a monic and irreducible polynomial <span class="math">f(x) \\in \\mathbb{Z}[X]</span> of degree <span class="math">d</span> and let <span class="math">q \\in \\mathbb{N}</span> be a prime. Let <span class="math">\\eta \\in \\mathbb{N}</span> and let $S_{\\eta} = \\{x \\in \\mathcal{R} : \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\eta\\}$. Then, the following setup and commitment algorithms define a commitment scheme:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup: <span class="math">A_{1} \\gets_{R} \\mathcal{R}_{q}^{k \\times r}</span>, <span class="math">A_{2} \\gets_{R} \\mathcal{R}_{q}^{k \\times n}</span>.</li>

      <li>Commit: <span class="math">\\mathrm{COM}: S_{\\eta}^{n} \\times S_{\\eta}^{r} \\to \\mathcal{R}_{q}^{k}</span>, <span class="math">(\\mathbf{x}, \\gamma) \\mapsto A_{1}\\gamma + A_{2}\\mathbf{x} \\mod q</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Lemma 1 (Hiding).</strong> The commitment scheme of Definition 13 is statistically hiding with statistical security parameter <span class="math">\\lambda</span>, where <span class="math">\\lambda \\in \\mathbb{N}</span> is such that <span class="math">r \\geq \\frac{dk\\log q + 2\\lambda}{d\\log(2\\eta + 1)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> The family of functions <span class="math">h_A: \\mathcal{R}_q^r \\to \\mathcal{R}_q^k</span>, <span class="math">\\mathbf{x} \\mapsto A\\mathbf{x}</span>, indexed by <span class="math">A \\in \\mathcal{R}_q^{k \\times r}</span> is a universal hash family. The min-entropy of the uniform distribution over <span class="math">S_{\\eta}^r</span> equals <span class="math">dr\\log (2\\eta + 1) \\geq dk\\log q + 2\\lambda</span>. By the leftover hash lemma it therefore follows that the statistical distance between the distribution <span class="math">\\mathcal{X} = \\{(A, A\\gamma) : A \\gets_R R_q^{k \\times r}, \\gamma \\gets_R S_{\\eta}^r\\}</span> and the uniform distribution <span class="math">\\mathcal{U}</span> over <span class="math">R_q^{k \\times r} \\times R_q^k</span> is at most <span class="math">2^{-\\lambda}</span>, which proves the lemma.</p>

    <p class="text-gray-300"><strong>Lemma 2 (Binding).</strong> The commitment scheme of Definition 13 is binding, conditioned on the hardness of the <span class="math">\\mathrm{MSIS}_{k,n + r,2\\eta}^{\\infty}</span>-problem over <span class="math">\\mathcal{R}_q</span>.</p>

    <p class="text-gray-300">8</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">(\\mathbf{x},\\gamma)\\neq(\\mathbf{x}^{\\prime},\\gamma^{\\prime})</span> are two distinct openings of the same commitment <span class="math">P</span>. Then <span class="math">\\mathbf{s}=(\\mathbf{x}-\\mathbf{x}^{\\prime},\\gamma-\\gamma^{\\prime})\\neq 0</span> satisfies $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2\\eta<span class="math"> and </span>[A_{1},A_{2}]\\mathbf{s}=0<span class="math">, i.e., </span>\\mathbf{s}<span class="math"> is a solution of the </span>\\text{MSIS}^{\\infty}_{k,n+r,2\\eta}$ problem, which completes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is generally hard to construct efficient protocols for proving knowledge of an opening <span class="math">(\\mathbf{x},\\gamma)</span> for a commitment <span class="math">P</span>, i.e., <span class="math">(\\mathbf{x},\\gamma)</span> such that <span class="math">\\textsc{Com}(\\mathbf{x},\\gamma)=P</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{x},\\gamma)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\eta$. For this reason, we introduce the notion of relaxed openings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 14 (<span class="math">(\\beta,\\zeta)</span>-Relaxed Commitment Opening).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\beta\\in\\mathbb{N}</span> and <span class="math">\\zeta\\in\\mathcal{R}</span>. A <span class="math">(\\beta,\\zeta)</span>-relaxed opening of a commitment <span class="math">P</span> is a tuple <span class="math">(\\mathbf{x},\\gamma)\\in\\mathcal{R}^{n+r}</span>, such that <span class="math">\\textsc{Com}(\\mathbf{x},\\gamma)=\\zeta P</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathbf{x},\\gamma)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Hence, a relaxed opening differs in two ways from a standard commitment opening. First, a relaxed opening for <span class="math">P</span> contains an approximation factor <span class="math">\\zeta</span>, such that the opening gives a short preimage for <span class="math">\\zeta P</span> instead of the commitment <span class="math">P</span>. Second, the norm-bound <span class="math">\\beta</span> of relaxed openings can be different from the norm bound <span class="math">\\eta</span> on honestly committed vectors (typically <span class="math">\\beta&gt;\\eta</span>).</p>

    <p class="text-gray-300">As long as it is infeasible to find two distinct relaxed openings <span class="math">(\\mathbf{x},\\gamma)</span> and <span class="math">(\\mathbf{x}^{\\prime},\\gamma^{\\prime})</span> of a commitment <span class="math">P</span> with <span class="math">(\\mathbf{x},\\gamma)\\neq(\\mathbf{x}^{\\prime},\\gamma^{\\prime})</span>, proving knowledge of relaxed opening is sufficient in most practical scenarios. In this case, we say the commitment scheme is binding with respect to relaxed openings.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 3 (Binding with respect to <span class="math">(\\beta,\\zeta)</span>-Relaxed Openings).</h6>

    <p class="text-gray-300">Let <span class="math">\\beta\\in\\mathbb{N}</span> and <span class="math">\\zeta\\in\\mathcal{R}</span>. The commitment scheme of Definition 13 is binding with respect to <span class="math">(\\beta,\\zeta)</span>-relaxed openings, conditioned on the hardness of the <span class="math">\\text{MSIS}^{\\infty}_{k,n+r,2\\beta}</span>-problem over <span class="math">\\mathcal{R}_{q}</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that <span class="math">(\\mathbf{x},\\gamma)</span> and <span class="math">(\\mathbf{x}^{\\prime},\\gamma^{\\prime})</span> are distinct <span class="math">(\\beta,\\zeta)</span>-relaxed openings of a commitment <span class="math">P</span>. Then <span class="math">\\mathbf{s}=(\\mathbf{x}-\\mathbf{x}^{\\prime},\\gamma-\\gamma^{\\prime})\\neq 0</span> satisfies $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2\\beta<span class="math"> and </span>[A_{1},A_{2}]\\mathbf{s}=0<span class="math">, i.e., </span>\\mathbf{s}<span class="math"> is a solution of the </span>\\text{MSIS}^{\\infty}_{k,n+r,2\\beta}$ problem, which completes the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-23" class="text-2xl font-bold">3 Multi-Round Special Soundness Tightly Implies Knowledge Soundness</h2>

    <p class="text-gray-300">In this section we prove that a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol is knowledge sound and give a concrete and tight knowledge error. More precisely, we show the existence of an efficient knowledge extractor. From this it follows that Bulletproofs <em>[BCC^{+}16, BBB^{+}18]</em> and Compressed <span class="math">\\Sigma</span>-Protocols <em>[x1]</em> are Proofs/Arguments of Knowledge (PoKs). We are the first to prove a tight bound on the knowledge error. Prior works mainly relied on the asymptotic extractor analysis of <em>[BCC^{+}16]</em>. This asymptotic analysis results in conservative concrete security estimates. Moreover, the analysis of <em>[BCC^{+}16]</em> is restricted to protocols with exponentially large challenge sets. When the challenge sets are small, such as in lattice based protocols, a refined analysis is required. Our result solves both problems. It gives tight security guarantees resulting in optimal concrete parameters for <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocols and it is applicable to protocols with small challenge sets. The main result of this section is summarized in Theorem 1.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 1 (<span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special Soundness implies Knowledge Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\mu,k_{1},\\ldots,k_{\\mu}\\in\\mathbb{N}</span> be such that <span class="math">K=\\prod_{i=1}^{\\mu}k_{i}</span> can be upper bounded by a polynomial. Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound <span class="math">(2\\mu+1)</span>-move interactive protocol for relation <span class="math">R</span>, where <span class="math">\\mathcal{V}</span> samples each challenge uniformly at random from a challenge set of size <span class="math">N\\geq\\max_{i}(k_{i})</span>. Then <span class="math">(\\mathcal{P},\\mathcal{V})</span> is knowledge sound with knowledge error</p>

    <p class="text-gray-300"><span class="math">\\kappa=\\frac{N^{\\mu}-\\prod_{i=1}^{\\mu}(N-k_{i}+1)}{N^{\\mu}}\\leq\\frac{\\sum_{i=1}^{\\mu}(k_{i}-1)}{N}.</span> (2)</p>

    <p class="text-gray-300">First, in Section 3.1, we considers the special case of <span class="math">2</span>-special soundness (for which the above implication is well-known). We give a very simple proof that we have not encountered in literature before. In contrast to standard proof techniques, this simplification turns out to be generalizable to the multi-round scenario. Second, in Section 3.2, we prove Theorem 1 in its full generality.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 1</h6>

    <p class="text-gray-300">Theorem 1 has a straightforward generalization to multi-round protocols in which challenges are sampled from possibly different challenge sets in every round. The only difference is the slightly different knowledge error expression. Let challenge <span class="math">i</span> be sampled uniformly at random from a set of cardinality <span class="math">N_{i}</span> for <span class="math">1\\leq i\\leq\\mu</span>. Then the knowledge error of a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol equals</p>

    <p class="text-gray-300"><span class="math">\\kappa=\\frac{\\prod_{i=1}^{\\mu}N_{i}-\\prod_{i=1}^{\\mu}(N_{i}-k_{i}+1)}{\\prod_{i=1}^{\\mu}N_{i}}\\leq\\sum_{i=1}^{\\mu}\\frac{k_{i}-1}{N_{i}}.</span> (3)</p>

    <p class="text-gray-300">For simplicity, the proofs are restricted to the case where each challenge is sampled from a challenge set of cardinality <span class="math">N</span>.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">3.1 2-Special Soundness</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This section is a warm up in which we present a novel proof for the well-known result that 2-special soundness implies knowledge soundness. Later we show that our techniques generalize to prove a similar result for <span class="math">2\\mu+1</span>-move protocols that are <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound. We make a minor modification to the “collision-game” defined in <em>[x10]</em>. The knowledge extractor essentially plays this game in order to extract a collision of two accepting transcripts <span class="math">(a,c,z)</span> and <span class="math">(a,c^{\\prime},z^{\\prime})</span> with common first message <span class="math">a</span>. By the special soundness property a witness can be computed efficiently given this collision. Our modification increases the success probability of the knowledge extractor of <em>[x10]</em> from $(\\epsilon(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))^{2}<span class="math"> to </span>\\epsilon(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where </span>\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> is the knowledge error and </span>\\epsilon(x)<span class="math"> the success probability of the prover for a statement </span>x$. In contrast to the extractor of <em>[x10]</em>, which runs in strict polynomial time, our extractor runs in expected polynomial time. However, this is sufficient for proving knowledge soundness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the input <span class="math">x</span> is clear from context, we simply write <span class="math">\\epsilon</span> to denote <span class="math">\\epsilon(x)</span>. All other parameters will implicitly depend on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (e.g., we denote </span>\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> by </span>\\kappa$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A similar result can be found in <em>[x13]</em>. However, our approach significantly simplifies the knowledge extractor and its analysis. For instance, the extractor of <em>[x13]</em> is composed of two algorithms considering different scenarios, whereas this case distinction is not required in our knowledge extractor. This simplification will allow for a generalization to the <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound case.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">The collision game</h4>

    <p class="text-gray-300">Let us now describe the game. We consider a binary matrix <span class="math">H\\in\\{0,1\\}^{R\\times N}</span>. The <span class="math">R</span> rows correspond to the prover’s randomness and the <span class="math">N</span> columns correspond to the verifier’s randomness, i.e., the verifier samples a challenge uniformly at random from a challenge set of size <span class="math">N</span>. An entry of <span class="math">H</span> equals <span class="math">1</span> if and only if the corresponding protocol transcript is accepting.</p>

    <p class="text-gray-300">The idea of the knowledge extractor is to sample elements from <span class="math">H</span> until two <span class="math">1</span>-entries in the same row are found. The <span class="math">ij</span>-th entry of <span class="math">H</span> can be obtained by executing the prover with fixed randomness corresponding to the <span class="math">i</span>-th row and verifier’s challenge corresponding to the <span class="math">j</span>-th column, and checking if the resulting transcript would be accepted. As the prover’s randomness is fixed along one row, finding two <span class="math">1</span>-entries in the same row corresponds to two finding two accepting transcripts <span class="math">(a,c,e)</span> and <span class="math">(a,c^{\\prime},e^{\\prime})</span>, which by the 2-special soundness allows to extract a witness. The difference to the knowledge extractor of <em>[x13]</em> is the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Our knowledge extractor checks one entry of <span class="math">H</span> (for position <span class="math">ij</span> sampled at random), and aborts if this is not a <span class="math">1</span>-entry.</li>

      <li>If the first entry was a <span class="math">1</span>-entry, our knowledge extractor then samples along row <span class="math">i</span> without replacement.</li>

    </ol>

    <p class="text-gray-300">More precisely, the knowledge extractor will play the following collision-game. An entry of <span class="math">H</span> is selected uniformly at random. If this entry equals <span class="math">1</span>, continue sampling different elements from this row (without replacement) until a second <span class="math">1</span>-entry is found or until the row has been exhausted. If the first entry does not equal <span class="math">1</span>, the game aborts. The collision game outputs success if and only if two <span class="math">1</span>-entries in the same row have been found.</p>

    <p class="text-gray-300">In contrast the above collision-game, the collision-game of <em>[x10]</em> simply checks <span class="math">2</span> random entries of <span class="math">H</span> and outputs success if both of them are <span class="math">1</span>-entries.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Lemma 4 (Collision-Game).</h6>

    <p class="text-gray-300">Let <span class="math">H\\in\\{0,1\\}^{R\\times N}</span> and let <span class="math">\\epsilon</span> denote the fraction of <span class="math">1</span>-entries in <span class="math">H</span>. The expected number of <span class="math">H</span>-entries queried in the collision-game defined above is at most <span class="math">2</span>. Moreover, the success probability of the collision-game is greater than or equal to <span class="math">\\epsilon-1/N</span>.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Expected Number of Queries. Let <span class="math">\\epsilon_{i}</span> be the fraction of <span class="math">1</span>-entries in row <span class="math">i</span>. Assuming that the first entry lies in row <span class="math">i</span> and equals <span class="math">1</span>, the remainder of the collision game can be modeled by a negative hypergeometric distribution. Elements from a population of size <span class="math">N-1</span>, containing <span class="math">\\epsilon_{i}N-1</span> <span class="math">1</span>-entries, are drawn (without replacement) until a second <span class="math">1</span>-entry has been found. The expected number of draws equals <span class="math">(N-1+1)/(\\epsilon_{i}N-1+1)=1/\\epsilon_{i}</span> if <span class="math">\\epsilon_{i}&gt;1/N</span> (see Section 2.2).If there is no second <span class="math">1</span>-entry in the row, then the number of draws is always equal to <span class="math">N-1</span>. Hence, the expected number of draws can be upper bounded by <span class="math">1/\\epsilon_{i}</span>. The expected number of <span class="math">H</span>-entries queried is therefore at most</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{R}\\sum_{i=1}^{R}\\left(1+\\epsilon_{i}\\frac{1}{\\epsilon_{i}}\\right)=2,</span></p>

    <p class="text-gray-300">which proves the first part of the lemma.</p>

    <p class="text-gray-300">Success Probability. The collision-game succeeds if the first entry is a <span class="math">1</span> that lies in a row containing at least two <span class="math">1</span>-entries. For <span class="math">0\\leq k\\leq N</span>, let <span class="math">\\delta_{k}</span> be the fraction of rows with exactly <span class="math">k</span> <span class="math">1</span>-entries. Then the success probability equals</p>

    <p class="text-gray-300"><span class="math">\\sum_{k=2}^{N}\\frac{k}{N}\\delta_{k}=\\left(\\sum_{k=0}^{N}\\frac{k}{N}\\delta_{k}\\right)-\\frac{\\delta_{1}}{N}\\geq\\epsilon-1/N,</span></p>

    <p class="text-gray-300">which proves the second part of the lemma.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">From Lemma 4 it immediately follows that <span class="math">2</span>-special soundness implies knowledge soundness with knowledge error <span class="math">1/N</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Corollary 1.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a special sound <span class="math">3</span>-move interactive protocol for relation <span class="math">R</span>, where <span class="math">\\mathcal{V}</span> samples each challenge uniformly at random from a challenge set of size <span class="math">N\\geq k</span>. Then <span class="math">(\\mathcal{P},\\mathcal{V})</span> is knowledge sound with knowledge error <span class="math">\\kappa=1/N</span>.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Lemma 4 has a straightforward generalization to the <span class="math">k</span>-special soundness scenario. In this generalization the collision game draws until it has obtained <span class="math">k</span>, instead of <span class="math">2</span>, <span class="math">1</span>-entries in the same row. Hence, it again involves a negative hypergeometric distribution, but now with different parameters. In this case, the expected number of queries is at most <span class="math">k</span> and the success probability is greater than or equal to <span class="math">\\epsilon-(k-1)/N</span>.</p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">3.2 <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-Special Soundness</h3>

    <p class="text-gray-300">In this section, we generalize the collision-game of Section 3.1 to the <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness scenario.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">The <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-collision game.</h4>

    <p class="text-gray-300">To define the <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-collision-game, let <span class="math">H\\in\\{0,1\\}^{R\\times N\\times\\cdots\\times N}</span> be a <span class="math">(\\mu+1)</span>-dimensional binary matrix. For <span class="math">a\\in\\{1,\\ldots,R\\}</span> and <span class="math">c_{1},\\ldots,c_{i}\\in\\{1,\\ldots,N\\}</span>, we let <span class="math">H(a,c_{1},\\ldots,c_{i})\\in\\{0,1\\}^{N\\times\\cdots\\times N}</span> be the <span class="math">(\\mu-i)</span> dimensional submatrix of <span class="math">H</span> that contains all entries of <span class="math">H</span> for which the first <span class="math">i+1</span> coordinates are equal to <span class="math">(a,c_{1},\\ldots,c_{i})</span>. The first dimension corresponds to the prover’s randomness and the other dimensions correspond to the verifier’s random choices, i.e., we consider protocols in which the verifier samples all <span class="math">\\mu</span> challenges uniformly at random from a challenge set of size <span class="math">N</span>. For a fixed public input <span class="math">x</span>, we define the matrix <span class="math">H</span> such that <span class="math">H(a,c_{1},\\ldots,c_{\\mu})=1</span> if and only if a transcript with prover’s randomness <span class="math">a</span> and verifier’s challenges <span class="math">c_{1},\\ldots,c_{\\mu}</span> will lead to an accepting transcript.</p>

    <p class="text-gray-300">In Section 2, we have defined <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-trees of accepting transcripts for <span class="math">(2\\mu+1)</span>-move protocols. Similarly, we define <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-trees of <span class="math">1</span>-entries in matrix <span class="math">H</span>. Such trees can be defined recursively as follows. For <span class="math">\\mu=0</span>, a tree of <span class="math">1</span>-entries is simply a <span class="math">1</span>-entry in <span class="math">H</span>. For arbitrary <span class="math">\\mu</span>, a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree is the union of <span class="math">k_{1}</span> <span class="math">(k_{2},\\ldots,k_{\\mu})</span>-trees in <span class="math">H(a,c_{1}),\\ldots,H(a,c_{k_{1}})</span>, respectively, for a fixed <span class="math">a</span> and pairwise distinct <span class="math">c_{i}</span>.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. We say a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree as depicted above is a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in  <span class="math">H</span>  , if  <span class="math">H(a,c_1^1,c_2^{1,1},\\dots ,c_\\mu^{1,\\dots ,1}) =</span> <span class="math">H(a,c_1^1,c_2^{1,1},\\dots ,c_\\mu^{1,\\dots ,2}) = \\dots = H(a,c_1^{k_1},c_2^{k_1,k_2},\\dots ,c_\\mu^{k_1,\\dots ,k_\\mu}) = 1.</span></p>

    <p class="text-gray-300">Hence, a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in matrix  <span class="math">H</span>  is a set of  <span class="math">K = \\prod_{i = 1}^{\\mu}k_{i}</span>  1-entries that are in a  <span class="math">(k_{1},\\dots ,k_{\\mu})</span>  tree structure. For a graphic representation see Figure 2.</p>

    <p class="text-gray-300">We define TREE to be the algorithm playing the  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -collision-game. By playing this game TREE aims to find a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in matrix  <span class="math">H</span>  . The algorithm TREE is defined recursively as follows. On input  <span class="math">a\\in \\{1,\\dots ,R\\}</span>  and  <span class="math">c_{1},\\ldots ,c_{\\mu}\\in \\{1,\\ldots ,N\\}</span> <span class="math">\\mathrm{TREE}_{\\mu}(a,c_1,\\ldots ,c_\\mu)</span>  successfully outputs  <span class="math">H(a,c_1,\\ldots ,c_\\mu)</span>  if this entry equals 1 and it aborts otherwise. For  <span class="math">0\\leq i\\leq \\mu -1</span>  and on input  <span class="math">a\\in \\{1,\\dots ,R\\}</span>  and  <span class="math">c_{1},\\ldots ,c_{i}\\in \\{1,\\ldots ,N\\}</span> <span class="math">\\mathrm{TREE}_i(a,c_1,\\ldots ,c_i)</span>  aims to find a  <span class="math">(k_{i + 1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in matrix  <span class="math">H(a,c_1,\\ldots ,c_i)</span>  . The algorithm  <span class="math">\\mathrm{TREE}_i(a,c_1,\\ldots ,c_i)</span>  proceeds by sampling  <span class="math">c_{i + 1}\\in \\{1,\\dots N\\}</span>  uniformly at random and running  <span class="math">\\mathrm{TREE}_{i + 1}(a,c_1,\\ldots ,c_{i + 1})</span>  . If this instantiation of  <span class="math">\\mathrm{TREE}_{i + 1}</span>  aborts the algorithm  <span class="math">\\mathrm{TREE}_i(a,c_1,\\ldots ,c_i)</span>  aborts. Otherwise it continues sampling different  <span class="math">c_{i + 1}</span>  's (i.e., without replacement) until it has found  <span class="math">k_{i + 1}</span> <span class="math">(k_{i + 2},\\ldots ,k_{\\mu})</span>  -trees of 1-entries or until it has exhausted all possible  <span class="math">c_{i + 1}</span>  's. In the latter case  <span class="math">\\mathrm{TREE}_i(a,c_1,\\ldots ,c_i)</span>  aborts, in the former case  <span class="math">\\mathrm{TREE}_i(a,c_1,\\ldots ,c_i)</span>  outputs a  <span class="math">(k_{i + 1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in matrix  <span class="math">H(a,c_1,\\ldots ,c_i)</span></p>

    <p class="text-gray-300">The  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -collision-game samples  <span class="math">a\\in \\{1,\\dots ,R\\}</span>  uniformly at random and runs  <span class="math">\\mathrm{TREE}_0(a)</span> . If  <span class="math">\\mathrm{TREE}_0(a) = \\bot</span>  it aborts and otherwise it outputs a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in  <span class="math">H(a)</span> . The following lemma gives the expected run-time and success probability of the tree finding algorithm TREE.</p>

    <p class="text-gray-300">Lemma 5  <span class="math">((k_{1},\\ldots ,k_{\\mu})</span>  -Tree Finding Algorithm). Let  <span class="math">H\\in \\{0,1\\}^{R\\times N\\times \\dots \\times N}</span>  be a  <span class="math">(\\mu +1)</span>  -dimensional matrix and let  <span class="math">\\epsilon</span>  denote the fraction of 1-entries in  <span class="math">H</span> . The expected number of entries queried by the  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree finding algorithm TREE defined above is at most  <span class="math">K = \\prod_{i = 1}^{\\mu}k_{i}</span> . Moreover, TREE successfully outputs a  <span class="math">(k_{1},\\ldots ,k_{\\mu})</span>  -tree of 1-entries in  <span class="math">H</span>  with probability at least</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon - \\frac {N ^ {\\mu} - \\prod_ {i = 1} ^ {\\mu} (N - k _ {i} + 1)}{N ^ {\\mu}} \\geq \\epsilon - \\frac {\\sum_ {i = 1} ^ {\\mu} (k _ {i} - 1)}{N}.</span></div>

    <p class="text-gray-300">Proof. Expected Number of Queries. Let us first bound the expected run time of TREE. To this end, for any  <span class="math">M</span> , let the random variable  <span class="math">T_{M}</span>  denote the number of  <span class="math">H</span> -entries queried by  <span class="math">\\mathrm{TREE}_M</span> . We aim to find an upper bound for  <span class="math">\\mathbb{E}[T_M]</span>  in terms of  <span class="math">\\mathbb{E}[T_{M + 1}]</span> .</p>

    <p class="text-gray-300">Let  <span class="math">V_{M + 1}</span>  the denote the event that an arbitrary call of  <span class="math">\\mathrm{TREE}_M</span>  to  <span class="math">\\mathrm{TREE}_{M + 1}</span>  is successful. Then,</p>

    <div class="my-4 text-center"><span class="math-block">T _ {M + 1} \\mid V _ {M + 1}</span></div>

    <p class="text-gray-300">denotes the number of <span class="math">H</span>-entries queried by <span class="math">\\textsc{Tree}_{M+1}</span> conditioned on <span class="math">\\textsc{Tree}_{M+1}</span> being successful. Similarly, <span class="math">T_{M+1} \\mid \\neg V_{M+1}</span> denotes the number of <span class="math">H</span>-entries queried by <span class="math">\\textsc{Tree}_{M+1}</span> conditioned on <span class="math">\\textsc{Tree}_{M+1}</span> being unsuccessful. Moreover, let <span class="math">S_{M}</span> denote the number of successful calls of <span class="math">\\textsc{Tree}_{M}</span> to <span class="math">\\textsc{Tree}_{M+1}</span> if it would try all <span class="math">N</span> possibilities. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr (V _ {M + 1} \\mid S _ {M} = \\ell) = \\frac {\\ell}{N}.</span></div>

    <p class="text-gray-300">Conditioned on the event <span class="math">S_{M} = \\ell</span> and the event that the first call to <span class="math">\\mathrm{Tree}_{M + 1}</span> succeeds, the remainder of algorithm <span class="math">\\mathrm{Tree}_M</span> can be modeled by a negative hypergeometric distribution. Namely, we sample (without replacement) from a total population of size <span class="math">N - 1</span> containing <span class="math">\\ell - 1</span> successes until either <span class="math">k_{M + 1} - 1</span> successes are found or until the population has been exhausted. The expected number of samples taken from this distribution equals <span class="math">(k_{M + 1} - 1)(N - 1 + 1) / (\\ell - 1 + 1) = (k_{M + 1} - 1)N / \\ell</span> if <span class="math">\\ell \\geq k_{M + 1}</span> (see Section 2.2) and it equals <span class="math">N - 1 \\leq (k_{M + 1} - 1)N / \\ell</span> otherwise. More precisely, in the first case <span class="math">\\mathrm{Tree}_M</span> will successfully execute <span class="math">\\mathrm{Tree}_{M + 1}</span> exactly <span class="math">k_{M + 1} - 1</span> times and it will unsuccessfully execute <span class="math">\\mathrm{Tree}_{M + 1}</span> an expected number of</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {(k _ {M + 1} - 1) N}{\\ell} - (k _ {M + 1} - 1) = \\frac {(k _ {M + 1} - 1) (N - \\ell)}{\\ell} = \\Pr (\\neg V _ {M + 1} \\mid S _ {M} = \\ell) \\frac {(k _ {M + 1} - 1) N}{\\ell}</span></div>

    <p class="text-gray-300">times. In the second case, i.e., <span class="math">\\ell &amp;lt; k_{M + 1}</span>, <span class="math">\\mathrm{Tree}_M</span> will successfully execute <span class="math">\\mathrm{Tree}_{M + 1}</span> exactly <span class="math">\\ell - 1 &amp;lt; k_{M + 1} - 1</span> times and it will unsuccessfully execute <span class="math">\\mathrm{Tree}_{M + 1}</span> exactly</p>

    <div class="my-4 text-center"><span class="math-block">N - \\ell = \\Pr (\\neg V _ {M + 1} \\mid S _ {M} = \\ell) \\cdot N \\leq \\Pr (\\neg V _ {M + 1} \\mid S _ {M} = \\ell) \\frac {(k _ {M + 1} - 1) N}{\\ell}</span></div>

    <p class="text-gray-300">times. Hence, for both cases we find the same upper bounds on the number of successful and unsuccessful executions of <span class="math">\\mathrm{Tree}_{M + 1}</span> by <span class="math">\\mathrm{Tree}_M</span>.</p>

    <p class="text-gray-300">Moreover, conditioned on <span class="math">S_{M} = \\ell</span>, the first execution of <span class="math">\\mathrm{Tree}_{M + 1}</span> by <span class="math">\\mathrm{Tree}_M</span> is successful with probability <span class="math">\\operatorname<em>{Pr}(V_{M + 1} \\mid S_M = \\ell)</span>, i.e., with probability <span class="math">\\operatorname</em>{Pr}(V_{M + 1} \\mid S_M = \\ell)</span> the subtree extractor <span class="math">\\mathrm{Tree}_{M + 1}</span> enters the negative hypergeometric experiment. Therefore,</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\mathbb {E} \\left[ T _ {M} \\mid S _ {M} = \\ell \\right] \\leq \\mathbb {E} \\left[ T _ {M + 1} \\mid S _ {M} = \\ell \\right] + \\Pr \\left(V _ {M + 1} \\mid S _ {M} = \\ell\\right) \\left(\\left(k _ {M + 1} - 1\\right) \\cdot \\mathbb {E} \\left[ T _ {M + 1} \\mid S _ {M} = \\ell \\wedge V _ {M + 1} \\right] \\right. \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr (\\neg V _ {M + 1} \\mid S _ {M} = \\ell) \\frac {(k _ {M + 1} - 1) N}{\\ell} \\cdot \\mathbb {E} [ T _ {M + 1} \\mid S _ {M} = \\ell \\wedge \\neg V _ {M + 1} ] \\Bigg) \\\\</li>

    </ul>

    <p class="text-gray-300">= \\mathbb {E} \\left[ T _ {M + 1} \\mid S _ {M} = \\ell \\right] + \\left(k _ {M + 1} - 1\\right) \\left(\\Pr \\left(V _ {M + 1} \\mid S _ {M} = \\ell\\right) \\cdot \\mathbb {E} \\left[ T _ {M + 1} \\mid S _ {M} = \\ell \\wedge V _ {M + 1} \\right] \\right. \\\\</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\Pr (\\neg V _ {M + 1} \\mid S _ {M} = \\ell) \\cdot \\mathbb {E} [ T _ {M + 1} \\mid S _ {M} = \\ell \\wedge \\neg V _ {M + 1} ] \\Bigg) \\\\</li>

    </ul>

    <p class="text-gray-300">= k _ {M + 1} \\cdot \\mathbb {E} \\left[ T _ {M + 1} \\mid S _ {M} = \\ell \\right], \\end{array} $$</p>

    <p class="text-gray-300">where we use that <span class="math">\\operatorname*{Pr}(V_{M + 1}\\mid S_M = \\ell) = \\ell /N</span></p>

    <p class="text-gray-300">Hence, <span class="math">\\mathbb{E}[T_M] \\leq k_{M+1} \\cdot \\mathbb{E}[T_{M+1}]</span> and by induction it follows that <span class="math">\\mathbb{E}[T_M] \\leq \\prod_{i=M+1}^{\\mu} k_i</span> for all <span class="math">M</span>. In particular, the expected number of <span class="math">H</span>-entries that are queried by Tree is at most <span class="math">K = \\prod_{i=1}^{\\mu} k_i</span>, which proves the first part of the lemma.</p>

    <p class="text-gray-300">Success Probability. Let us now bound the success probability of Tree. For <span class="math">0 \\leq j &amp;lt; \\mu</span>, let</p>

    <div class="my-4 text-center"><span class="math-block">\\kappa_ {j} = \\frac {N ^ {\\mu - j} - \\prod_ {i = j + 1} ^ {\\mu} (N - k _ {i} + 1)}{N ^ {\\mu - j}},</span></div>

    <p class="text-gray-300">and let <span class="math">\\kappa_{\\mu} = 0</span></p>

    <p class="text-gray-300">For any <span class="math">(a, c_1, \\ldots, c_i)</span>, let <span class="math">\\epsilon(a, c_1, \\ldots, c_i)</span> be the fraction of 1-entries in <span class="math">H(a, c_1, \\ldots, c_i)</span>. We first prove that the following inequality holds, for all <span class="math">i</span> and <span class="math">(a, c_1, \\ldots, c_i)</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\operatorname {T r e e} _ {i} \\left(a, c _ {1}, \\dots , c _ {i}\\right) \\neq \\bot\\right) \\geq \\left(\\prod_ {j = i + 1} ^ {\\mu} \\frac {N}{N - k _ {j} + 1}\\right) \\left(\\epsilon \\left(a, c _ {1}, \\dots , c _ {i}\\right) - \\kappa_ {i}\\right). \\tag {4}</span></div>

    <p class="text-gray-300">The proof of this claim goes by induction on <span class="math">i</span>. For <span class="math">i = \\mu</span> the claim holds trivially, so let's assume the claim holds for all <span class="math">i \\geq M + 1</span>. The algorithm <span class="math">\\mathrm{Tree}_M(a, c_1, \\ldots, c_M)</span> succeeds if at least <span class="math">k_{M+1}</span> out of the <span class="math">N</span> possible calls to <span class="math">\\mathrm{Tree}_{M+1}</span> succeed and the first call to <span class="math">\\mathrm{Tree}_{M+1}</span> succeeds. Let <span class="math">S_M(a, c_1, \\ldots, c_M)</span> denote the number of successful calls of <span class="math">\\mathrm{Tree}_M(a, c_1, \\ldots, c_M)</span> to <span class="math">\\mathrm{Tree}_{M+1}</span> if it would try all <span class="math">N</span> possibilities. For notational convenience, we write <span class="math">S_M = S_M(a, c_1, \\ldots, c_M)</span>, understanding that <span class="math">S_M</span> actually depends on <span class="math">(a, c_1, \\ldots, c_M)</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{Pr}\\left(\\operatorname{Tree}_M(a, c_1, \\ldots, c_M) \\neq \\bot\\right) &amp;amp;= \\sum_{\\ell = k_{M + 1}}^{N} \\frac{\\ell}{N} \\operatorname{Pr}(S_M = \\ell) \\\\ &amp;amp;= \\frac{1}{N} \\left( \\mathbb{E}[S_M] - \\sum_{\\ell = 0}^{k_{M + 1} - 1} \\ell \\operatorname{Pr}(S_M = \\ell) \\right) \\tag{5} \\\\ &amp;amp;\\geq \\frac{1}{N} \\left( \\mathbb{E}[S_M] - (k_{M + 1} - 1) \\sum_{\\ell = 0}^{k_{M + 1} - 1} \\operatorname{Pr}(S_M = \\ell) \\right). \\end{aligned}</span></div>

    <p class="text-gray-300">Moreover,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathbb{E}[S_M] &amp;amp;= \\sum_{\\ell = 0}^{N} \\ell \\operatorname{Pr}(S_M = \\ell) \\\\ &amp;amp;\\leq (k_{M + 1} - 1) \\sum_{\\ell = 0}^{k_{M + 1} - 1} \\operatorname{Pr}(S_M = \\ell) + N \\sum_{\\ell = k_M}^{N} \\operatorname{Pr}(S_M = \\ell) \\\\ &amp;amp;= N - (N - k_{M + 1} + 1) \\sum_{\\ell = 0}^{k_{M + 1} - 1} \\operatorname{Pr}(S_M = \\ell). \\end{aligned}</span></div>

    <p class="text-gray-300">Hence,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\ell = 0}^{k_{M + 1} - 1} \\operatorname{Pr}(S_M = \\ell) \\leq \\frac{N - \\mathbb{E}[S_M]}{N - k_{M + 1} + 1}.</span></div>

    <p class="text-gray-300">Plugging this inequality in Equation 5 shows that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{Pr}\\left(\\operatorname{Tree}_M(a, c_1, \\ldots, c_M) \\neq \\bot\\right) &amp;amp;\\geq \\frac{1}{N} \\left( \\mathbb{E}[S_M] - \\frac{(k_{M + 1} - 1)(N - \\mathbb{E}[S_M])}{N - k_{M + 1} + 1} \\right) \\tag{6} \\\\ &amp;amp;= \\frac{N}{N - k_{M + 1} + 1} \\left( \\frac{\\mathbb{E}[S_M]}{N} - \\frac{k_{M + 1} - 1}{N} \\right). \\end{aligned}</span></div>

    <p class="text-gray-300">By the induction hypothesis, it follows that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\frac{\\mathbb{E}[S_M]}{N} &amp;amp;= \\frac{1}{N} \\sum_{c_{M + 1} = 1}^{N} \\operatorname{Pr}\\left(\\operatorname{Tree}_{M + 1}(a, c_1, \\ldots, c_M, c_{M + 1}) \\neq \\bot\\right) \\\\ &amp;amp;\\geq \\frac{1}{N} \\sum_{c_{M + 1} = 1}^{N} \\left( \\prod_{j = M + 2}^{\\mu} \\frac{N}{N - k_j + 1} \\right) \\left( \\epsilon(a, c_1, \\ldots, c_M, c_{M + 1}) - \\kappa_{M + 1} \\right) \\\\ &amp;amp;= \\left( \\prod_{j = M + 2}^{\\mu} \\frac{N}{N - k_j + 1} \\right) \\left( \\epsilon(a, c_1, \\ldots, c_M) - \\kappa_{M + 1} \\right). \\end{aligned}</span></div>

    <p class="text-gray-300">Further, note that for <span class="math">0\\leq j&lt;\\mu</span> it holds,</p>

    <p class="text-gray-300"><span class="math">\\kappa_{j}=\\frac{N^{\\mu-j}\\kappa_{j+1}+(k_{j+1}-1)\\prod_{i=j+2}^{\\mu}(N-k_{i}+1)}{N^{\\mu-j}}.</span> (7)</p>

    <p class="text-gray-300">Combining these with Equation 6 shows that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left(\\textsc{Tree}_{M}(a,c_{1},\\ldots,c_{M})\\neq\\bot\\right)\\geq\\left(\\prod_{j=M+1}^{\\mu}\\frac{N}{N-k_{j}+1}\\right)\\left(\\epsilon(a,c_{1},\\ldots,c_{M})-\\kappa_{M}\\right).</span></p>

    <p class="text-gray-300">Hence, by induction, it follows that Equation 4 holds for all <span class="math">i</span>.</p>

    <p class="text-gray-300">Therefore, the success probability of the tree finding algorithm Tree equals</p>

    <p class="text-gray-300"><span class="math">\\frac{1}{R}\\sum_{a=1}^{R}\\Pr\\left(\\textsc{Tree}_{0}(a)\\neq\\bot\\right)</span> <span class="math">\\geq\\frac{1}{R}\\sum_{a=1}^{R}\\left(\\prod_{j=M+1}^{\\mu}\\frac{N}{N-k_{j}+1}\\right)\\left(\\epsilon(a)-\\kappa_{0}\\right)</span> <span class="math">=\\epsilon-\\kappa_{0},</span></p>

    <p class="text-gray-300">which proves the remainder of the lemma.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">A knowledge extractor, with rewindable black-box access to a possible dishonest prover <span class="math">\\mathcal{P}^{<em>}</span>, essentially runs this tree finding algorithm to obtain a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of accepting transcripts. It evaluates one protocol interaction with <span class="math">\\mathcal{P}^{</em>}</span> and recursively rewinds <span class="math">\\mathcal{P}^{*}</span>, fixing its internal randomness and following the tree finding strategy of Tree. By the <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special soundness property a witness can then be extracted efficiently from the obtained <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of accepting transcripts. Hence, from Lemma 5 it immediately follows that a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol is knowledge sound with knowledge error <span class="math">\\kappa</span>, where</p>

    <p class="text-gray-300"><span class="math">\\kappa=\\frac{N^{\\mu}-\\prod_{i=1}^{\\mu}(N-k_{i}+1)}{N^{\\mu}}\\leq\\frac{\\sum_{i=1}^{\\mu}(k_{i}-1)}{N}.</span></p>

    <p class="text-gray-300">The latter inequality follows since we have <span class="math">N\\geq\\max_{i}(k_{i})</span> and thus <span class="math">\\prod_{i=1}^{\\mu}(N-k_{i}+1)\\leq N^{\\mu}-N^{\\mu-1}\\sum_{i=1}^{\\mu}(k_{i}-1)</span>. This proves Theorem 1.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">3.3 Tightness of Our Extraction Analysis</h3>

    <p class="text-gray-300">The knowledge error <span class="math">\\kappa</span> of Theorem 1 is optimal, i.e., there exists a dishonest prover that succeeds in cheating with probability <span class="math">\\kappa</span>. Typically a dishonest prover can cheat in a <span class="math">k</span>-special sound protocol by guessing a set of <span class="math">k-1</span> challenges and hoping that the verifier selects one of these challenges. The success probability of this attack is equal to <span class="math">(k-1)/N</span>, where <span class="math">N</span> is the size of the challenge set. More generally, a cheating strategy for a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound <span class="math">(2\\mu+1)</span>-move protocol goes as follows. For every round <span class="math">i</span>, the cheating prover guesses a set of <span class="math">k_{i}-1</span> challenges. The cheating prover succeeds if there exists a round <span class="math">i</span> for which the verifier chooses one of the <span class="math">k_{i}-1</span> challenges guessed by the prover. The success probability of this attack is easily seen to be equal to the knowledge error <span class="math">\\kappa</span>. Hence, this knowledge error is optimal. Alternatively, we observe that there exist matrices <span class="math">H</span> with <span class="math">\\epsilon=\\kappa</span>, i.e., for which the fraction of <span class="math">1</span>-entries equals <span class="math">\\kappa</span>, that do not contain a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-tree of <span class="math">1</span>-entries.</p>

    <p class="text-gray-300">Moreover, the tree finding algorithm is optimal in the following sense. The expected number of <span class="math">H</span>-entries that are queried is exactly equal to the number of entries in a tree. Hence, we can not hope to find a tree faster than this. Moreover, taking a closer look at the proof of Lemma 5 shows that the success probability actually has the following lower bound</p>

    <p class="text-gray-300"><span class="math">f(\\epsilon)=\\left(\\prod_{j=1}^{\\mu}\\frac{N}{N-k_{j}+1}\\right)\\left(\\epsilon-\\kappa\\right).</span></p>

    <p class="text-gray-300">Hence, if <span class="math">\\epsilon=1</span> the success probability of Tree is at least <span class="math">f(1)=1</span>, which is what we would expect.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3.4 A Note on Witness Extended Emulation</p>

    <p class="text-gray-300">Lindell showed that a technical issue arises when using Proofs of Knowledge as subprotocols in larger cryptographic protocols <em>[x11]</em>. To prove security of the compound protocol, a simulator is typically required to run the extractor of the PoK. However, the naive simulation approach does not necessarily run in polynomial time. To this end, Lindell defined the notion of witness-extended emulation (WEE), capturing precisely the properties required when using PoKs as subprotocols. Moreover, he showed that any PoK has WEE, thereby solving this technical issue for all PoKs at once. Hence, from our extraction analysis it follows that any <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol has WEE.</p>

    <p class="text-gray-300">Previously, there was no proof showing that a <span class="math">(k_{1},\\ldots,k_{\\mu})</span>-special sound protocol is knowledge sound. For this reason prior works (e.g., <em>[BCC^{+}16]</em>) resorted to proving witness-extended emulation directly. However, these results are non-tight and only apply to protocols with exponentially large challenge sets.</p>

    <h2 id="sec-35" class="text-2xl font-bold">4 Decreasing the Knowledge Error of Public-Coin Interactive Protocols</h2>

    <p class="text-gray-300">In this section, we establish a novel parallel repetition theorem showing that the knowledge error of a public-coin interactive argument can be decreased by repeating the protocol in parallel.</p>

    <p class="text-gray-300">We want the knowledge error of a PoK to be negligible in the security parameter. If this is not the case the protocol is typically repeated, say <span class="math">t</span> times. The verifier of the composed protocol only accepts if all <span class="math">t</span> instances of the basic protocol are accepted. Ideally, and perhaps intuitively, this approach reduces the knowledge error from <span class="math">\\kappa</span> down to <span class="math">\\kappa^{t}</span>. This is indeed the case if the repetitions are executed sequentially <em>[x10]</em>. However, sequential repetition increases the round complexity. Since the security loss due to the Fiat-Shamir transformation increases exponentially in the number of rounds <em>[x5]</em>, this is unacceptable when considering the non-interactive instantiations of our protocols (see Section 5.5). Further, also in the interactive setting we would like to avoid the additional round complexity introduced by sequential composition.</p>

    <p class="text-gray-300">For this reason, we aim to repeat the protocol in parallel. We write <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> for the <span class="math">t</span>-fold parallel repetition of an interactive argument <span class="math">(\\mathcal{P},\\mathcal{V})</span>. However, it is not true in general that parallel repetition decreases the knowledge error exponentially. There even exist interactive protocols for which parallel repetition does not decrease the success probability of a dishonest prover at all <em>[x2, x25]</em>. Analyzing parallel repetitions is significantly more complicated than analyzing sequential repetitions, because a dishonest prover does not have to treat all <span class="math">t</span> parallel instances independently, i.e., a message corresponding to a specific instance may depend on the messages and challenges of the other parallel instances.</p>

    <p class="text-gray-300">If <span class="math">(\\mathcal{P},\\mathcal{V})</span> is a 2-special sound 3-move protocol, then <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> is 2-special sound too. It therefore follows that the knowledge error of a 2-special sound protocol decreases exponentially in the number of parallel repetitions. However, a similar result does not hold in general, i.e., in general special-soundness is not preserved by parallel repetition (at least not in a non-trivial manner). For example, it is easily seen that the parallel repetition of a <span class="math">k</span>-special sound protocol for <span class="math">k\\neq 2</span> is not <span class="math">k</span>-special-sound.</p>

    <p class="text-gray-300">Several parallel repetition results, considering multi-round public-coin interactive arguments, have been established <em>[x14, x7, x12]</em>, showing that parallel repetition reduces the soundness error. However, “soundness” is a weaker notion than “knowledge soundness”. Informally the soundness error is the success probability of a cheating prover and soundness does not require the existence of a knowledge extractor.</p>

    <p class="text-gray-300">To the best of our knowledge a parallel repetition result for decreasing the knowledge error has not been established yet, even though the lattice-based Bulletproof protocols of <em>[x3]</em> implicitly rely on such a parallel repetition result. In Theorem 3, we show that the knowledge error of a public-coin argument decreases close to exponentially in the number of parallel repetitions. Our proof uses the following result from <em>[x12]</em>. This theorem shows that, given oracle access to a (possibly dishonest) prover <span class="math">\\mathcal{P}^{<em>}</span> that, for statements <span class="math">x</span>, succeeds in convincing <span class="math">\\mathcal{V}^{t}</span> with probability <span class="math">\\epsilon(x)</span>, a prover <span class="math">\\mathfrak{P}^{(\\mathcal{P}^{</em>})}</span> that succeeds in convincing <span class="math">\\mathcal{V}</span> with probability <span class="math">\\approx\\epsilon(x)^{1/t}</span> can be constructed.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 2 (Theorem 2 of <em>[x12]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a public-coin interactive argument for a language <span class="math">L</span>. Let <span class="math">t\\colon\\mathbb{N}\\to\\mathbb{N}</span>, and let <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> be the <span class="math">t</span>-fold parallel repetition of <span class="math">(\\mathcal{P},\\mathcal{V})</span>. There exists an oracle machine <span class="math">\\mathfrak{P}^{(\\cdot)}</span></p>

    <p class="text-gray-300">such that for every <span class="math">\\xi\\colon\\mathbb{N}\\to(0,1)</span>, every <span class="math">\\delta\\colon\\{0,1\\}^{<em>}\\to(0,1)</span>, every <span class="math">x\\in\\{0,1\\}^{</em>}</span>, and every PPT prover <span class="math">\\mathcal{P}^{*}</span>, it holds that if</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\big{(}\\big{(}\\mathcal{P}^{*},\\mathcal{V}^{t}\\big{)}(x)=1\\big{)}\\geq\\underbrace{(1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))\\delta(x)^{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}}_{\\epsilon(x):=},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{(}\\big{(}\\mathfrak{P}^{(\\mathcal{P}^{*})},\\mathcal{V}\\big{)}(x)=1\\Big{)}\\geq\\delta(x).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, <span class="math">\\mathfrak{P}^{(\\mathcal{P}^{*})}</span> runs in time $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{-1},\\epsilon(x)^{-1},(1-\\delta(x))^{-1})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 3 now shows that the <span class="math">t</span>-fold parallel repetition of knowledge sound interactive argument is knowledge sound and that the knowledge error decreases close to exponential in <span class="math">t</span>. More precisely, the theorem shows that if <span class="math">(\\mathcal{P},\\mathcal{V})</span> has knowledge error <span class="math">\\kappa</span>, then <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> has knowledge error <span class="math">\\kappa^{t}+\\nu</span>, for arbitrary noticeable <span class="math">\\nu</span>. Therefore, by choosing <span class="math">t</span> large enough, we can show that <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> has knowledge error $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{c}<span class="math"> for any </span>c\\in\\mathbb{N}<span class="math">. Note though that we cannot show that </span>(\\mathcal{P}^{t},\\mathcal{V}^{t})<span class="math"> has negligible knowledge error </span>\\mathrm{negl}(\\lambda)<span class="math"> for any fixed negligible function </span>\\mathrm{negl}\\colon\\mathbb{N}\\to\\mathbb{N}<span class="math">, because the running time of </span>\\mathfrak{P}^{(\\mathcal{P}^{<em>})}<span class="math"> scales with the inverse success probability of </span>\\mathcal{P}^{</em>}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While it might seem that this barrier is rather an artifact of the proof technique of <em>[x10]</em> on which we build, it was shown by <em>[x13]</em> that Theorem 2 is tight when considering soundness amplification of protocols in general. More precisely, based on some cryptographic assumptions they showed that parallel repetition does not amplify security beyond negligible, meaning that for any negligible function <span class="math">\\mathrm{negl}</span> one can find an instantiation that when starting with non-negligible soundness error, the protocol can always be broken with probability $\\mathrm{negl}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, no matter how many parallel repetitions one runs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-37" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be a public-coin interactive argument for a relation <span class="math">R</span> that is knowledge sound with knowledge error <span class="math">\\kappa\\colon\\mathbb{N}\\to(0,1)</span>. Let <span class="math">t\\colon\\mathbb{N}\\to\\mathbb{N}</span> be upper bounded by a polynomial. Let <span class="math">\\nu\\colon\\mathbb{N}\\to(0,1)</span> be an arbitrary noticeable function. Then, <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> is knowledge sound with knowledge error <span class="math">\\kappa^{\\prime}=\\kappa^{t}+\\nu</span>.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct a knowledge extractor <span class="math">\\mathcal{E}^{\\prime}</span> for <span class="math">(\\mathcal{P}^{t},\\mathcal{V}^{t})</span> as follows. Let <span class="math">\\mathcal{P}^{<em>}</span> be some (potentially dishonest) prover, for which <span class="math">(\\mathcal{P}^{</em>},\\mathcal{V}^{t})</span> outputs <span class="math">1</span> with probability <span class="math">\\epsilon(x)</span>. Let <span class="math">\\xi\\colon\\mathbb{N}\\to(0,1)</span> such that <span class="math">\\xi=\\nu/\\kappa^{t}</span>. Then, by Theorem 2 there exists a prover <span class="math">\\mathfrak{P}^{(\\cdot)}</span> such that <span class="math">\\big{(}\\mathfrak{P}^{(\\mathcal{P}^{*})},\\mathcal{V}\\big{)}\\,(x)=1</span> with probability at least <span class="math">\\delta(x)</span>, where</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta(x)=\\left(\\frac{\\epsilon(x)}{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right)^{1/t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By assumption <span class="math">(\\mathcal{P},\\mathcal{V})</span> is knowledge sound with knowledge error <span class="math">\\kappa</span>, therefore, there exists a knowledge extractor <span class="math">\\mathcal{E}</span> for <span class="math">(\\mathcal{P},\\mathcal{V})</span>. Now, we define <span class="math">\\mathcal{E}^{\\prime}</span> as the algorithm that executes the knowledge extractor <span class="math">\\mathcal{E}</span> on the prover <span class="math">\\mathfrak{P}^{(\\mathcal{P}^{*})}</span>. It is left to show that the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Claim. If $\\epsilon(x)\\geq\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, then </span>\\mathcal{E}^{\\prime}<span class="math"> as defined above runs in an expected polynomial number of steps and there exists a polynomial </span>q\\colon\\mathbb{N}\\to\\mathbb{N}<span class="math"> such that </span>\\mathcal{E}^{\\prime}<span class="math"> is successful at least with probability </span>(\\epsilon(x)-\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))/q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We start proving the claim by showing that <span class="math">\\mathfrak{P}^{(\\mathcal{P}^{<em>})}</span> runs in an expected polynomial number of steps. By Theorem 2, we have that the run-time of <span class="math">\\mathfrak{P}^{(\\mathcal{P}^{</em>})}</span> is in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{-1},\\epsilon(x)^{-1},(1-\\delta(x))^{-1})<span class="math">. By assumption we have that </span>t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\leq\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and further </span>\\xi=\\nu/\\kappa_{t}\\geq\\nu<span class="math"> and </span>\\epsilon(x)\\geq\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\geq\\nu(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> and therefore also </span>\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{-1},\\epsilon(x)^{-1}\\leq\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It is left to show that </span>1-\\delta(x)<span class="math"> is noticeable. Via the Taylor approximation of the function </span>f(a)=a^{1/t}<span class="math"> in </span>a=1$, we obtain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta(x)=\\left(\\frac{\\epsilon(x)}{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right)^{1/t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\leq 1-\\frac{1}{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\left(1-\\frac{\\epsilon(x)}{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Therefore, we also have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$1-\\delta(x)\\geq\\frac{1}{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\left(1-\\frac{\\epsilon(x)}{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right)=\\frac{1}{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\left(\\frac{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)-\\epsilon(x)}{1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right)\\overset{\\xi,\\epsilon\\leq 1}{\\geq}\\frac{\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{2t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\geq\\frac{\\nu(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{2t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as required.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, note that if $\\epsilon(x)\\geq\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, then </span>\\delta(x)\\geq\\kappa(x)<span class="math">. This is a simple consequence of the definition of </span>\\xi<span class="math"> and </span>\\delta<span class="math">, because </span>\\epsilon(x)\\geq\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}+\\nu(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)=\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}(1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> implies </span>\\delta(x)=(\\epsilon(x)/(1+\\xi(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))^{1/t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\geq\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Altogether, this shows that if $\\epsilon(x)\\geq\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, then </span>\\mathcal{E}^{\\prime}<span class="math"> runs in an expected polynomial number of steps and there exists a polynomial </span>p\\colon\\mathbb{N}\\to\\mathbb{N}<span class="math">, such that </span>\\mathcal{E}^{\\prime}<span class="math"> outputs a witness </span>w\\in R(x)<span class="math"> with probability at least </span>(\\delta(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))/p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. It is left to show that if </span>\\epsilon(x)\\geq\\kappa^{\\prime}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, there exists a polynomial </span>q\\colon\\mathbb{N}\\to\\mathbb{N}$ such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{\\delta(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\geq\\frac{\\epsilon(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^{t(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}-\\nu(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}{q(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To express the success probability of <span class="math">\\mathcal{E}^{\\prime}</span> in terms of <span class="math">\\epsilon(x)</span>, let us define the functions <span class="math">f(a)=t(a^{1/t}-b)</span> and <span class="math">g(a)=a-b^{t}</span>, for <span class="math">b\\in[0,1]</span>. Observe that <span class="math">f(a)</span> is concave for <span class="math">a\\geq 0</span>. Moreover, <span class="math">f(b^{t})=g(b^{t})=0</span> and <span class="math">f(1)=t(1-b)\\geq(1-b)\\sum_{i=0}^{t-1}b^{i}=g(1)</span>. Hence <span class="math">\\max(f(a),0)\\geq g(a)</span> for all <span class="math">a\\in[0,1]</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From this inequality we have that whenever $\\delta(x)\\geq\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$, it holds</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> </span>\\geq\\max(\\delta(x)-\\kappa(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">),0)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\geq\\frac{1}{t(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)(1+\\xi(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">))}\\left(\\epsilon(x)-(1+\\xi(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">))\\kappa(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)^{t(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)}\\right)$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">$\\geq\\frac{1}{2t(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)}\\left(\\epsilon(x)-\\kappa(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)^{t(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)}-\\nu(</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)\\right).$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, choosing <span class="math">q=2tp</span> yields the desired result, which proves the claim and completes the proof of the theorem. ∎</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">The properties completeness and special honest verifier zero-knowledge are easily seen to be preserved by parallel repetition, although the completeness error increases in the number parallel repetitions.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Remark 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">M</span> be the total size of the challenge set, i.e., $M=\\prod_{i=1}^{\\mu}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> where the </span>i^{th}<span class="math"> challenge is sampled from challenge set </span>\\mathcal{C}_{i}<span class="math">. If </span>M<span class="math"> is polynomial in the security parameter the analysis can be simplified significantly. In this case the knowledge extractor can query all possible challenges and still run in polynomial time. Both the results from Section 3 and a parallel repetition theorem then follow by a simple counting argument. This is the approach in the analysis of the 5-round </span>(2,2)<span class="math">-special sound signature scheme MQDSS <em>[CHR^{+}16]</em>. It is much more challenging to construct efficient knowledge extractors when </span>M$ is not polynomial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-41" class="text-2xl font-bold">5 A General Framework for Compressed <span class="math">\\Sigma</span>-Protocols over Lattices</h2>

    <p class="text-gray-300">The main pivot of compressed <span class="math">\\Sigma</span>-protocol theory <em>[x1]</em> is a basic <span class="math">\\Sigma</span>-protocol for proving that a committed vector satisfies some linear constraint. Subsequently, a compression mechanism is applied (recursively) to reduce the communication complexity from linear down to polylogarithmic in the input size. The composition of these protocols is referred to as a compressed <span class="math">\\Sigma</span>-protocol. In this section we present a natural abstraction similar to the one presented in <em>[x2, Appendix A]</em> extended to the lattice setting. This requires a number of non-trivial adaptations that are explained in the following. Subsequently, we show how to instantiate this abstraction from a concrete lattice assumption.</p>

    <p class="text-gray-300">In the following we first give an abstraction of the standard <span class="math">\\Sigma</span>-protocol to the lattice setting and then explain how the compression mechanism extends to this setting. Note that we give both protocols in a very abstract fashion, with the goal of allowing to instantiate them from a broad variety of lattice-based assumptions. Note that our abstraction is not restricted to instantiations based on lattices, but is tailored to this setting.</p>

    <p class="text-gray-300">5.1 Standard <span class="math">\\Sigma</span>-Protocol</p>

    <p class="text-gray-300">In this section we recall what we will refer to as <em>standard <span class="math">\\Sigma</span>-protocol</em> for proving knowledge of a preimage of some given module homomorphism <span class="math">\\Psi</span>. This protocol can be viewed as the abstraction of the protocol of Schnorr <em>[x20]</em> to arbitrary module homomorphisms, where we have to build in several relaxations in order to make it compatible with the lattice setting.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, in the lattice setting the witness is required to be small, we therefore define a pair <span class="math">(Y;y)</span> to be in the target relation if <span class="math">Y=\\Psi(y)</span> <em>and</em> $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\alpha<span class="math">, for some </span>\\alpha\\in\\mathbb{N}<span class="math">. Note that this requires to define a norm in the preimage space, we therefore in the following restrict to modules with norm. If the preimage is not required to be small (as, e.g., is the case in the discrete log setting), one does not have to require a norm on the module and can simply ignore the corresponding requirements in the protocols. The requirement of the witness </span>y<span class="math"> to have small norm is also where the main difficulty stems from, because one now has to transform a witness </span>y<span class="math"> into a witness </span>x$, such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the norm of <span class="math">x</span> is not much larger than <span class="math">y</span> (as otherwise the statement becomes meaningless), but</li>

      <li><span class="math">x</span> still hides <span class="math">y</span>.</li>

    </ol>

    <p class="text-gray-300">In order to ensure the second without a too large knowledge error, the relation that one can prove knowledge of does not correspond to the target relation <span class="math">R</span>, but some relaxed relation <span class="math">R^{\\prime}</span>. In this case, we say the protocol is a protocol for the pair of relations <span class="math">(R,R^{\\prime})</span>, i.e., an honest prover knows a witness for <span class="math">R</span> but can only prove knowledge of a witness for <span class="math">R^{\\prime}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In fact, there are two sources introducing “soundness slack”: First, <span class="math">x</span> itself will in general already have larger norm than <span class="math">y</span> (in order to ensure hiding). Second, even worse, extracting a witness <span class="math">\\tilde{y}</span> from two accepting transcripts, introduces additional slack. This slack is more difficult to control, as it depends on the inverse of challenge differences. As challenge differences will not necessarily be invertible over the underlying ring, we introduce an additional relaxation on the relation. Namely, for some fixed element <span class="math">\\zeta</span> (in our examples, we will typically have that <span class="math">\\zeta</span> is a power of two) we will consider relations <span class="math">R^{\\prime}</span>, such that <span class="math">(X;x)\\in R^{\\prime}</span> if <span class="math">\\Psi(x)=\\zeta\\cdot X</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">. We refer to </span>\\zeta$ as an approximation factor.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More formally, let <span class="math">\\mathcal{R}=\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of rings, let <span class="math">M=\\{M_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}},N=\\{N_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be ensembles of <span class="math">\\mathcal{R}</span>-modules, let <span class="math">\\Psi=\\{\\Psi_{\\lambda}\\colon M_{\\lambda}\\to N_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of efficiently computable <span class="math">\\mathcal{R}</span>-module homomorphisms and let <span class="math">\\zeta=\\{\\zeta_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of approximation factors (i.e., <span class="math">\\zeta_{\\lambda}\\in\\mathcal{R}_{\\lambda}</span> for all <span class="math">\\lambda</span>). Let further $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> be a norm on </span>M<span class="math">, let </span>\\alpha,\\beta\\colon\\mathbb{N}\\to\\mathbb{N}<span class="math"> with </span>\\alpha\\leq\\beta<span class="math">. Then, we define the relations </span>R(\\Psi,\\alpha)=\\{R_{\\lambda}(\\Psi,\\alpha)\\}_{\\lambda\\in\\mathbb{N}}<span class="math"> and </span>R(\\Psi,\\beta,\\zeta)=\\{R_{\\lambda}(\\Psi,\\beta,\\zeta)\\}_{\\lambda\\in\\mathbb{N}}$ via</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R_{\\lambda}(\\Psi,\\alpha)</span> $=\\Big{\\{}\\left(Y;y\\right):y\\in M_{\\lambda},Y=\\Psi_{\\lambda}(y),\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\alpha(\\lambda)\\Big{\\}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following we abstract the notion of <em>rejection sampling</em> <em>[x15, x16]</em>, which is used in lattice based cryptography to sample a value, such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the sample algorithm is somewhat norm-preserving, i.e., the norm of the sampled value is not too much larger than the norm of the witness,</li>

      <li>adding this value to the witness statistically hides the witness or the rejection sampling strategy aborts, and, finally,</li>

      <li>the abort probability is essentially independent of the witness.</li>

    </ol>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 15 (<span class="math">V</span>-Hiding and <span class="math">\\beta</span>-Bounded Sampling).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}=\\{\\mathcal{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of rings and let <span class="math">M=\\{M_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of <span class="math">\\mathcal{R}</span>-modules. Let <span class="math">V=\\{V_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> be an ensemble of sets with <span class="math">V_{\\lambda}\\subseteq M_{\\lambda}</span> for all <span class="math">\\lambda</span>. Let <span class="math">(\\mathcal{D},\\mathcal{F})</span> such that <span class="math">\\mathcal{D}</span> is an ensemble of efficiently sampleable distributions <span class="math">\\mathcal{D}=\\{\\mathcal{D}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> over <span class="math">M</span>, and <span class="math">\\mathcal{F}</span> a PPT algorithm. We say <span class="math">(\\mathcal{D},\\mathcal{F})</span>-is <span class="math">V</span>-hiding, if there exists a PPT algorithm <span class="math">\\mathcal{F}^{\\prime}</span> such that for each <span class="math">\\lambda\\in\\mathbb{N}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{F}</span> on input <span class="math">r\\in M_{\\lambda}</span> and <span class="math">v\\in V_{\\lambda}</span>, outputs <span class="math">r+v</span> or <span class="math">\\bot</span>,</li>

      <li><span class="math">\\mathcal{F}^{\\prime}</span> on input <span class="math">1^{\\lambda}</span>, outputs an element <span class="math">z\\in M_{\\lambda}</span> or <span class="math">\\bot</span>,</li>

    </ul>

    <p class="text-gray-300">such that the output distributions of <span class="math">(\\mathcal{D},\\mathcal{F})</span> and <span class="math">\\mathcal{F}^{\\prime}</span> are statistically close. More precisely, there exists a negligible function <span class="math">\\mathrm{negl}\\colon\\mathbb{N}\\to\\mathbb{N}</span> such that for all <span class="math">\\lambda\\in\\mathbb{N}</span> and for all <span class="math">v\\in V_{\\lambda}</span> we have</p>

    <p class="text-gray-300"><span class="math">\\Delta\\left(\\{\\mathcal{F}(r,v)\\mid r\\leftarrow\\mathcal{D}_{\\lambda}\\},\\{\\mathcal{F}^{\\prime}(1^{\\lambda})\\}\\right)\\leq\\mathrm{negl}(\\lambda),</span></p>

    <p class="text-gray-300">where the probability is taken over the randomness of <span class="math">\\mathcal{D}_{\\lambda}</span> and the random coins of <span class="math">\\mathcal{F},\\mathcal{F}^{\\prime}</span>. If the distribution of <span class="math">(\\mathcal{D},\\mathcal{F})</span> and <span class="math">\\mathcal{F}^{\\prime}</span> are equal, we say <span class="math">(\\mathcal{D},\\mathcal{F})</span>-is <em>perfectly</em> <span class="math">V</span>-hiding.</p>

    <p class="text-gray-300">Note that by the above considerations we can upper bound the abort probability of <span class="math">(\\mathcal{D},\\mathcal{F})</span> by</p>

    <p class="text-gray-300"><span class="math">\\delta(\\lambda)=\\Pr[\\mathcal{F}^{\\prime}(1^{\\lambda})=\\bot]+\\mathrm{negl}(\\lambda),</span></p>

    <p class="text-gray-300">for all <span class="math">\\lambda\\in\\mathbb{N}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let further <span class="math">\\beta\\colon\\mathbb{N}\\to\\mathbb{N}</span>. We say that <span class="math">(\\mathcal{D},\\mathcal{F})</span> is <span class="math">\\beta</span>-bounded if for all <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">v\\in V_{\\lambda}</span> and <span class="math">r</span> in the support of <span class="math">\\mathcal{D}_{\\lambda}</span> it holds $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{F}(r,v)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta(\\lambda)<span class="math"> whenever </span>\\mathcal{F}(r,v)\\neq\\bot$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To improve readability, we will in the following omit the security parameter, and, e.g., simply say “Let <span class="math">\\mathcal{R}</span> be a ring…”, or “Let <span class="math">\\alpha\\in\\mathbb{N}.\\ldots</span>”, even though we assume all variables to be parametrized by the security parameter.</p>

    <p class="text-gray-300">Before stating the <span class="math">\\Sigma</span>-protocol, we introduce the notion of an <em><span class="math">\\zeta</span>-exceptional subset</em>, which will ensure that the protocol satisfies special soundness.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 16 (<span class="math">\\zeta</span>-Exceptional Subset).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a ring, <span class="math">\\zeta\\in\\mathcal{R}</span> and <span class="math">\\mathcal{C}\\subseteq\\mathcal{R}</span> be a set. We say <span class="math">\\mathcal{C}</span> is an <span class="math">\\zeta</span>-exceptional subset of <span class="math">\\mathcal{R}</span>, if for all pairs of distinct elements <span class="math">c,c^{\\prime}\\in\\mathcal{C}</span> there exists a non-zero element <span class="math">a\\in\\mathcal{R}</span> such that <span class="math">a(c-c^{\\prime})=\\zeta</span>. If <span class="math">\\mathcal{C}</span> is a <span class="math">1</span>-exceptional subset of <span class="math">\\mathcal{R}</span>, we simply say that <span class="math">\\mathcal{C}</span> is an <em>exceptional subset</em>.</p>

    <p class="text-gray-300">We further need to give bounds on the soundness slack introduced by extraction. To this end, for <span class="math">\\zeta</span>-exceptional subsets <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> we define <span class="math">w(\\mathcal{C})</span> and <span class="math">\\bar{w}(\\mathcal{C},\\zeta)</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">w(\\mathcal{C})</span> $=\\max_{c\\in\\mathcal{C},x\\in\\mathcal{R}\\setminus\\{0\\}}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$ (8)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The value <span class="math">w(\\mathcal{C})</span> gives an upper bound on how much the norm of an element in <span class="math">\\mathcal{R}</span> increases when multiplied by an element in <span class="math">\\mathcal{C}</span>, i.e., <span class="math">w(\\mathcal{C})</span> is such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq w(\\mathcal{C})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all </span>c\\in\\mathcal{C}<span class="math"> and </span>x\\in\\mathcal{R}<span class="math">. Note that if </span>\\mathcal{R}=\\mathbb{Z}<span class="math"> and with absolute value </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, we simply have </span>w(\\mathcal{C})=\\max\\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\colon c\\in\\mathcal{C}\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The value <span class="math">\\bar{w}(\\mathcal{C},1)</span> gives an upper bound on how much the norm of an element in <span class="math">\\mathcal{R}</span> increases when multiplied with the inverse of challenge differences, i.e., <span class="math">\\bar{w}(\\mathcal{C},1)</span> is such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c-c^{\\prime})^{-1}x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bar{w}(\\mathcal{C},1)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all </span>x\\in\\mathcal{R}<span class="math"> and distinct </span>c,c^{\\prime}\\in\\mathcal{C}<span class="math">. In general, the value </span>\\bar{w}(\\mathcal{C},\\zeta)<span class="math"> gives an upper bound on how much the norm of an element in </span>\\mathcal{R}<span class="math"> increases when multiplied with an </span>a<span class="math"> such that </span>a(c-c^{\\prime})=\\zeta<span class="math"> for challenges </span>c\\neq c^{\\prime}<span class="math">. Note that </span>\\bar{w}(\\mathcal{C},\\zeta)<span class="math"> is only well-defined if </span>\\mathcal{C}<span class="math"> is </span>\\zeta$-exceptional.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The maximum over <span class="math">a\\in\\mathcal{R}</span> in Equation 8 can be replaced by a minimum, potentially resulting in tighter norm bounds. More precisely, the extractor can choose the element <span class="math">a</span> that minimizes $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ax\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. However, this requires the minimum to be efficiently computable. To avoid this additional assumption we take the maximum over all </span>a<span class="math">. Moreover, in most practical applications </span>\\mathcal{R}<span class="math"> does not have zero-divisors and </span>a\\in R$ is uniquely defined.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For a module <span class="math">M</span> over <span class="math">\\mathcal{R}</span> with norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, similarly we define</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$w_{M}(\\mathcal{C})=\\max_{c\\in\\mathcal{C},x\\in M\\setminus\\{0\\}}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\text{ and }\\bar{w}_{M}(\\mathcal{C},\\zeta)=\\max_{c\\neq c^{\\prime}\\in\\mathcal{C},x\\in M\\setminus\\{0\\}}\\max_{a\\in\\mathcal{R}:a(c-c^{\\prime})=\\zeta}\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ax\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that for <span class="math">M=\\mathcal{R}^{n}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>M<span class="math"> defined as </span>\\ell_{p}<span class="math">-norm (for </span>p\\in\\mathbb{N}\\cup\\{\\infty\\}<span class="math">), we have </span>w_{M}(\\mathcal{C})=w(\\mathcal{C})<span class="math"> and </span>\\bar{w}_{M}(\\mathcal{C},\\zeta)=\\bar{w}(\\mathcal{C},\\zeta)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now state the standard <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{0}</span> for the pair of relations <span class="math">(R(\\Psi,\\alpha),R(\\Psi,2\\beta,\\zeta))</span> in Protocol 1. Further, we summarize its properties in Theorem 4.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol 1 Standard  <span class="math">\\Sigma</span> -Protocol  <span class="math">\\Pi_0</span>  for the pair of relations  <span class="math">(R(\\varPsi, \\alpha), R(\\varPsi, 2\\beta \\sigma, \\zeta))</span> , where  <span class="math">\\sigma = \\bar{w}_M(\\mathcal{C}, \\zeta)</span> . Here,  <span class="math">(\\mathcal{D}, \\mathcal{F})</span>  is  <span class="math">V</span> -hiding and  <span class="math">\\beta</span> -bounded, where  $V = \\{cy \\mid y \\in M, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha, c \\in \\mathcal{C}\\}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">INPUT(Y; y)Y = Ψ(y)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">w←R D, W = Ψ(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">W→</td>

            <td class="px-3 py-2 border-b border-gray-700">c0←R C ⊂ R</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">If F(w, c0y) = ⊥: Abort Else: x = w + c0y</td>

            <td class="px-3 py-2 border-b border-gray-700">c0←</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">x→</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">? β, Ψ(x) = W + c0Y</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 4 (Standard  <span class="math">\\Sigma</span> -Protocol). Let  <span class="math">\\mathcal{R}</span>  be a ring, let  <span class="math">M, N</span>  be  <span class="math">\\mathcal{R}</span> -modules and let  <span class="math">\\varPsi: M \\to N</span>  be an efficiently computable  <span class="math">\\mathcal{R}</span> -module homomorphism.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, let  <span class="math">\\zeta \\in \\mathcal{R}</span>  and  <span class="math">\\mathcal{C} \\subset R</span>  be a finite  <span class="math">\\zeta</span> -exceptional subset of  <span class="math">\\mathcal{R}</span> , let  <span class="math">\\alpha, \\beta \\in \\mathbb{N}</span>  and  <span class="math">\\delta \\in [0,1)</span> , let  $V = \\{cy \\mid y \\in M, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha, c \\in \\mathcal{C}\\}<span class="math">  and let  </span>(\\mathcal{D}, \\mathcal{F})<span class="math">  be a  </span>\\beta<span class="math"> -bounded  </span>V<span class="math"> -hiding distribution with abort probability  </span>\\delta$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, the protocol  <span class="math">\\Pi_0</span>  (as defined in Protocol 1) is a 3-move protocol for relations  <span class="math">(R(\\varPsi,\\alpha),R(\\varPsi,2\\beta\\sigma,\\zeta))</span>  defined via</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R (\\varPsi , \\alpha) = \\Big \\{(Y; y): y \\in M, Y = \\varPsi (y), \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\alpha \\Big \\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R (\\varPsi , 2 \\beta \\sigma , \\zeta) = \\Big \\{(Y; y): y \\in M, \\zeta \\cdot Y = \\varPsi (y), \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2 \\beta \\sigma \\Big \\},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\sigma = \\bar{w}_M(\\mathcal{C},\\zeta)</span></p>

    <p class="text-gray-300">It is complete with completeness error  <span class="math">\\delta</span> , unconditionally 2-special sound and statistical non-abort special honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Proof. Completeness follows directly, because  <span class="math">(\\mathcal{D},\\mathcal{F})</span>  is  <span class="math">\\beta</span> -bounded and has abort probability  <span class="math">\\delta</span> , and  <span class="math">\\varPsi</span>  is a module homomorphism.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2-Special Soundness: Let  <span class="math">(W, c, x)</span> ,  <span class="math">(W, c&#x27;, x&#x27;)</span>  be two accepting transcripts for  <span class="math">c \\neq c&#x27; \\in \\mathcal{C}</span> . Define  <span class="math">\\tilde{y} = a(x - x&#x27;)</span> , where  <span class="math">a</span>  is such that  <span class="math">a(c - c&#x27;) = \\zeta</span> . Then, we have  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a(x - x') \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\bar{w}_M(\\mathcal{C}, \\zeta)(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x' \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\leq 2\\beta \\bar{w}_M(\\mathcal{C}, \\zeta)<span class="math"> . Further, we have  </span>\\varPsi(\\tilde{y}) = a(\\varPsi(x) - \\varPsi(x')) = a(c - c') \\cdot Y = \\zeta \\cdot Y$  as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Non-abort SHVZK: We simulate a transcript as follows: Let  <span class="math">\\mathcal{F}&#x27;</span>  be the PPT algorithm corresponding to the  <span class="math">V</span> -hiding of  <span class="math">(\\mathcal{D},\\mathcal{F})</span> . Given a challenge  <span class="math">c</span> , the simulator runs  <span class="math">\\mathcal{F}&#x27;</span>  on input  <span class="math">1^{\\lambda}</span> . If  <span class="math">\\mathcal{F}&#x27;</span>  outputs  <span class="math">\\perp</span> , the simulator returns  <span class="math">(\\perp, c, \\perp)</span> . Else, the simulator sets  <span class="math">x \\gets \\mathcal{F}&#x27;(1^{\\lambda})</span> , computes the first message as  <span class="math">W = \\varPsi(x) - cY</span>  and outputs  <span class="math">(W, c, x)</span> . Since by the  <span class="math">V</span> -hiding property the output distributions of  <span class="math">\\mathcal{F}</span>  and  <span class="math">\\mathcal{F}&#x27;</span>  are statistically close, and  <span class="math">W</span>  can be derived deterministically from the values  <span class="math">c, x</span>  and  <span class="math">Y</span> , statistical non-abort SHVZK follows.</p>

    <p class="text-gray-300">Remark 5. In some settings it is beneficial to introduce another relaxation. For example, if  <span class="math">\\zeta = 1</span>  (i.e., if challenge difference are invertible), the aforementioned approach requires inverses of challenge differences to be of small norm. The following relaxed relation only requires challenge differences, and not necessarily their inverses, to be of small norm. It introduces an adapted approximation factor  <span class="math">\\bar{c} \\in \\bar{\\mathcal{C}} = \\{c - c&#x27;; c, c&#x27; \\in \\mathcal{C}, c \\neq c&#x27;\\}</span>  and is defined as follows</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R (\\varPsi , \\beta , \\bar {\\mathcal {C}}) = \\Big \\{(Y; y, \\bar {c}): y \\in M, \\bar {c} \\cdot Y = \\varPsi (y), \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta , \\bar {c} \\in \\bar {\\mathcal {C}} \\Big \\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The approximation factor <span class="math">\\bar{c}</span> is not fixed and part of the secret witness. This relaxation allows for more efficient <span class="math">\\Sigma</span>-protocols. However, when composed with other protocols the fact that the approximation factors are not fixed introduces additional difficulties. These can be handled, but in most settings the required adjustments negate the benefits of this relaxed relation, we therefore do not consider it further.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">From non-abort SHVZK to SHVZK</h4>

    <p class="text-gray-300">Rejection sampling, and therefore also our abstraction of rejection sampling, in general does not allow to simulate the first message for aborting transcripts (see e.g. <em>[x19, x18]</em>). For this reason, the standard <span class="math">\\Sigma</span>-protocol presented above provides only non-abort SHVZK. When applying the Fiat-Shamir transform and using the proof system in the non-interactive setting this is not a problem, because the prover simply does not output aborting transcripts (for more details see Section 5.5). But, when using the <span class="math">\\Sigma</span>-protocol in the interactive setting, we have to apply an additional measure in order to guarantee zero-knowledge also in the cases where the prover has to abort. In <em>[x5]</em> it was recently shown how to deal with this problem for the purpose of constructing lattice-based multi-signature scheme, which is more challenging and therefore requires to either rely on random oracles or trapdoor commitments. We observe that in our case to go from non-abort SHVZK to standard SHVZK it suffices to replace the first message by a statistically hiding commitment, on the cost of going from perfect soundness to computational soundness. Note that replacing the commitment by a trapdoor commitment scheme in the transformation below, one can even achieve standard zero-knowledge.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is a <span class="math">\\Sigma</span> protocol that is complete, <span class="math">2</span>-special sound and non-abort special honest verifier zero-knowledge for the pair of relations <span class="math">(R,R^{\\prime})</span> and <span class="math">\\textsc{Com}</span> is a statistically hiding and computationally binding commitment scheme, then there exists a <span class="math">\\Sigma</span> protocol <span class="math">\\Pi^{\\prime}</span> that is complete, <em>computationally</em> <span class="math">2</span>-special sound and <em>special honest verifier zero knowledge</em>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The idea of the protocol is simply to replace the first message of the protocol by a commitment to the first message. The protocol <span class="math">\\Pi^{\\prime}</span> can be described as follows. First, the prover computes the first message <span class="math">W</span> according to <span class="math">\\Pi</span>. Further, the prover samples randomness <span class="math">\\gamma</span> for the commitment scheme and sends <span class="math">\\textsc{Com}(W;\\gamma)</span> to the Verifier, who responds with a challenge <span class="math">c</span>. In the last round the prover computes <span class="math">x</span> according to the second prover’s message in <span class="math">\\Pi</span> depending on <span class="math">W</span> and the challenge <span class="math">c</span>. If <span class="math">\\Pi</span> does not abort, the prover sends <span class="math">W,\\gamma,x</span> to the verifier. The verifier accepts if <span class="math">W,\\gamma</span> is a valid opening of the commitment sent in the first round, and <span class="math">(W,c,x)</span> is an accepting transcript for <span class="math">\\Pi</span>. It is left to show that <span class="math">\\Pi^{\\prime}</span> indeed satisfies the required properties.</p>

    <p class="text-gray-300">follows directly. Let <span class="math">(C,c,W,\\gamma,x)</span> and <span class="math">(C,c^{\\prime},W^{\\prime},\\gamma^{\\prime},x^{\\prime})</span> be two accepting transcripts. Then, either we have that <span class="math">W^{\\prime}=W</span> and we can rely on the <span class="math">2</span>-Special Soundness of <span class="math">\\Pi</span>, or the prover broke the computational binding property of <span class="math">\\textsc{Com}</span> by finding two valid openings <span class="math">W,\\gamma</span> and <span class="math">W^{\\prime},\\gamma^{\\prime}</span> with <span class="math">W\\neq W^{\\prime}</span>. Given a challenge <span class="math">c</span>, the simulator runs the simulator for the underlying protocol <span class="math">\\Pi</span>. If the underlying simulator returns <span class="math">(\\bot,c,\\bot)</span>, the simulator samples randomness <span class="math">\\gamma</span> and outputs <span class="math">(\\textsc{Com}(0;\\gamma),c,\\bot)</span>. If the underlying simulator returns <span class="math">(W,c,x)</span>, then the simulator samples randomness <span class="math">\\gamma</span> and outputs <span class="math">(\\textsc{Com}(W;\\gamma),c,W,\\gamma,x)</span>. SHVZK follows by the statistical hiding property of <span class="math">\\textsc{Com}</span> and the non-abort SHVZK property of the underlying protocol <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 6.</h6>

    <p class="text-gray-300">Applying this transformation to the standard <span class="math">\\Sigma</span>-protocol, the prover does not have to send <span class="math">W</span>, because the verifier can first compute <span class="math">W</span> as <span class="math">\\Psi(x)-cY</span> and then verify if <span class="math">W,\\gamma</span> is indeed a valid opening. Therefore, instantiating <span class="math">\\textsc{Com}</span> with a compressing commitment scheme leads to an overall improvement in the communication complexity.</p>

    <p class="text-gray-300">Example.</p>

    <p class="text-gray-300">The basic <span class="math">\\Sigma</span>-protocol of <em>[x1]</em>, for proving that a committed vector satisfies a linear constraint, is a special case of protocol <span class="math">\\Pi_{0}</span>. It can be derived by instantiating <span class="math">\\Pi_{0}</span> with</p>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}\\to\\mathbb{G}\\times\\mathbb{Z}_{q},\\quad(\\mathbf{x},\\gamma)\\mapsto\\left(\\operatorname{Com}(\\mathbf{x},\\gamma),L(\\mathbf{x})\\right),</span></p>

    <p class="text-gray-300">for some prime <span class="math">q</span> and where <span class="math">\\mathbb{G}</span> is a group of order <span class="math">q</span>, <span class="math">\\operatorname{Com}</span> is the Pedersen vector commitment scheme and <span class="math">L</span> is a linear form. Both <span class="math">M=\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> and <span class="math">N=\\mathbb{G}\\times\\mathbb{Z}_{q}</span> are <span class="math">\\mathbb{Z}_{q}</span> modules and, since <span class="math">\\mathcal{C}=\\mathbb{Z}_{q}</span> is a field, the subset <span class="math">\\mathcal{C}=\\mathbb{Z}_{q}</span> is exceptional as required. Further, we can choose <span class="math">\\mathcal{D}</span> as the uniform distribution, which is trivially <span class="math">V</span>-hiding for any set <span class="math">V\\subseteq\\mathbb{Z}_{q}</span> without abort, i.e., the resulting protocol is perfectly correct. Finally, note that as this instantiation does not require the witness to be small, we do not need to consider a norm (i.e., the verifier will only check if the equation is satisfied).</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">5.2 Compression Mechanism</h3>

    <p class="text-gray-300">Observe that the final message <span class="math">x</span> of protocol <span class="math">\\Pi_{0}</span> is a witness for statement <span class="math">X:=W+c_{0}Y</span>, i.e., the final message can be viewed as a trivial proof of knowledge for <span class="math">X\\in L_{R(\\Psi,\\beta)}</span>. In the following, we will present a general view on the compression mechanism that allows to replace this trivial PoK by a more efficient one, using Bulletproof’s folding mechanism <em>[BCC^{+}16, BBB^{+}18]</em>. This protocol does not need to be SHVZK, since it is a replacement for the trivial PoK.</p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">Compression function.</h4>

    <p class="text-gray-300">The Bulletproof folding mechanism relies on an compression function that allows to compress the witness iteratively. In the following, we outline the properties the compression function has to satisfy. The main purpose of giving this abstraction is to improve readability of the protocols. In Appendix A, we further give an abstraction generalizing to larger compression rate and the corresponding compression mechanism.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Definition 17 (Extractable compression function).</h6>

    <p class="text-gray-300">Let <span class="math">M,M^{\\prime}</span> be <span class="math">\\mathcal{R}</span>-modules, such that <span class="math">M</span> is of even rank <span class="math">n</span> and <span class="math">M^{\\prime}</span> of rank <span class="math">n/2</span>. Let <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> be an exceptional subset of <span class="math">\\mathcal{R}</span>. Let <span class="math">\\mathsf{Comp}=\\{\\mathsf{Comp}_{c}\\colon M\\to M^{\\prime}\\colon c\\in\\mathcal{C}\\}</span> and <span class="math">\\Phi=\\{\\Phi_{c}\\colon M^{\\prime}\\to M\\colon c\\in\\mathcal{C}\\}</span>, where <span class="math">\\Phi_{c}</span> is an <span class="math">\\mathcal{R}</span>-module homomorphism for each <span class="math">c\\in\\mathcal{C}</span>. Then, we say <span class="math">(\\mathsf{Comp},\\Phi)</span> is an <em>extractable compression function</em> for <span class="math">\\mathcal{C}</span>, if the following holds: There exist maps <span class="math">\\pi_{L},\\pi_{R}\\colon M\\to M</span>, such that for all <span class="math">c\\in\\mathcal{C}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Phi_{c}(\\mathsf{Comp}_{c}(x))=\\pi_{L}(x)+c\\cdot x+c^{2}\\cdot\\pi_{R}(x).</span></p>

    <p class="text-gray-300">We further say that <span class="math">(\\mathsf{Comp},\\Phi)</span> is <span class="math">(\\tau,\\tau^{\\prime})</span>-norm preserving, if for all <span class="math">c\\in\\mathcal{C},x\\in M,z\\in M^{\\prime}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Comp}_{c}(x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ and }\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{c}(z)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau^{\\prime}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The reason why <span class="math">\\Phi_{c}\\circ\\mathsf{Comp}_{c}</span> has to be of this specific form is to allow <em>extractability</em> even if the maps <span class="math">\\pi_{L},\\pi_{R}</span> are not evaluated honestly. More precisely, let <span class="math">\\Psi\\colon M\\to N</span>. Then, given pairwise distinct <span class="math">c_{1},c_{2},c_{3}\\in\\mathcal{C}</span> and <span class="math">z_{1},z_{2},z_{3}\\in M^{\\prime}</span> such that <span class="math">\\Psi\\circ\\Phi_{c_{i}}(z_{i})=A+c_{i}X+c_{i}^{2}B</span> for <span class="math">i\\in[3]</span> (for arbitrary <span class="math">A,B\\in N</span>), it is possible to extract an <span class="math">x\\in M</span> with <span class="math">\\Psi(x)=X</span> (resulting in 3-special soundness of the compression mechanism). In the lattice setting it is further crucial that we can give a meaningful bound on the norm of the extracted <span class="math">x</span>. In the proof of Theorem 5 we will show that this is indeed the case (with bound depending on <span class="math">\\tau</span> and <span class="math">\\tau^{\\prime}</span>).</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Example 1 (Bulletproof compression function <em>[BCC^{+}16, BBB^{+}18]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">M=\\mathcal{R}^{n}</span> and <span class="math">M^{\\prime}=\\mathcal{R}^{n/2}</span>. Then, the Bulletproof compression function is obtained as</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Comp}_{c}((x_{L},x_{R}))</span> <span class="math">=x_{L}+c\\cdot x_{R},</span> <span class="math">\\Phi_{c}(z)</span> <span class="math">=(cz,z),</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\pi_{L}((x_{L},x_{R}))</span> <span class="math">=(0,x_{L}),</span> <span class="math">\\pi_{R}((x_{L},x_{R}))</span> <span class="math">=(x_{R},0).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that  $w(\\mathcal{C}) = \\max_{c \\in \\mathcal{C}, x \\in \\mathcal{R} \\setminus \\{0\\}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} / \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> . The Bulletproof compression function is  </span>(1 + w(\\mathcal{C}), w(\\mathcal{C}))<span class="math"> -norm preserving, as for all  </span>c \\in \\mathcal{C}, x \\in M$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x _ {L} + c \\cdot x _ {R} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} + w (\\mathcal {C}) \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\\\ \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c z, z) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq w (\\mathcal {C}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}, \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">whenever  <span class="math">w(\\mathcal{C}) \\geq 1</span>  (which will be the case for our instantiations).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Using the Bulletproof compression function with the  <span class="math">p</span> -norm  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_p<span class="math">  for arbitrary  </span>p \\in \\mathbb{N} \\cup \\{\\infty\\}<span class="math">  instead of restricting to the infinity norm, we obtain that the Bulletproof compression function is  </span>(1 + w_p(\\mathcal{C}), 1 + w_p(\\mathcal{C}))$ -norm preserving, because in general we can only guarantee</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(c z, z) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {p} \\leq w _ {p} (\\mathcal {C}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {p} + \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {p},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where now  $w_{p}(\\mathcal{C}) = \\max_{c\\in \\mathcal{C},x\\in \\mathcal{R}\\setminus \\{0\\}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{p} / \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{p}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The idea of the compression mechanism is as follows: First the prover commits to  <span class="math">A = \\varPsi(\\pi_L(x))</span>  and  <span class="math">B = \\varPsi(\\pi_R(x))</span> . Next, the verifier sends a challenge  <span class="math">c \\in \\mathcal{C}</span> . Using the compression mechanism, the prover then compresses  <span class="math">x</span>  as  <span class="math">z = \\mathrm{Comp}_c(x)</span> . Now, the verifier can check if indeed  <span class="math">\\varPsi(\\varPhi_c(z)) = A + cX + c^2B</span> . As  <span class="math">\\mathrm{Comp}_c(x)</span>  is 2-compressing, this strategy reduces communication complexity by roughly a factor 2. Note that this factor 2 reduction comes at the cost of sending two elements  <span class="math">A, B \\in N</span> . Hence, in practice the reduction of the communication cost depends on the size of the  <span class="math">\\mathcal{R}</span> -module  <span class="math">N</span> . Finally, by extraity it follows that the compression mechanism is 3-special sound.</p>

    <p class="text-gray-300">The compression mechanism is graphically displayed in Protocol 2 and its properties are summarized in Theorem 5.</p>

    <p class="text-gray-300">Protocol 2 Generic Compression Mechanism  <span class="math">\\varPi_{1}</span>  for relations  <span class="math">(R(\\varPsi,\\beta),R(\\varPsi,\\beta\\sigma,\\zeta^{3}))</span>  , where  <span class="math">\\sigma =</span> <span class="math">6\\tau \\tau^{\\prime}w_{M}(\\mathcal{C})^{2}\\bar{w}_{M}(\\mathcal{C},\\zeta)^{3}</span>  . Recall that  <span class="math">(\\mathsf{Comp},\\varPhi)</span>  is a  <span class="math">(\\tau ,\\tau^{\\prime})</span>  -norm preserving extractable compression map, i.e. for all  <span class="math">c\\in \\mathcal{C}</span>  ..</p>

    <p class="text-gray-300"><span class="math">\\varPhi_{c}(\\mathsf{Comp}_{c}(x))=\\pi_{L}(x)+cx+c^{2}\\pi_{R}(x).</span></p>

    <p class="text-gray-300">|  INPUT(X;x) X = Ψ(x) ∈ N  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  A = Ψ(πL(x)) |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B = Ψ(πR(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A,B</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c←R C ⊂ R</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | ←c |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z = Compc(x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≥ β · τ, Ψ(Φc(z)) = A + cX + c2B</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 5 (Compression Mechanism). Let  <span class="math">M, M&#x27;, N</span>  be  <span class="math">\\mathcal{R}</span> -modules, such that  <span class="math">M</span>  has even rank  <span class="math">n</span>  and  <span class="math">M&#x27;</span>  has rank  <span class="math">n/2</span>  over  <span class="math">\\mathcal{R}</span> , and let  <span class="math">\\varPsi: M \\to N</span>  be an  <span class="math">\\mathcal{R}</span> -module homomorphism. Further, let  <span class="math">\\zeta \\in \\mathcal{R}</span>  and let  <span class="math">\\mathcal{C}</span>  be a finite  <span class="math">\\zeta</span> -exceptional subset of  <span class="math">\\mathcal{R}</span> , let  <span class="math">(\\mathsf{Comp}, \\varPhi)</span>  be a  <span class="math">(\\tau, \\tau&#x27;)</span> -norm preserving extractable compression function for  <span class="math">\\mathcal{C}</span>  with projection maps  <span class="math">\\pi_L, \\pi_R</span> , and let  <span class="math">\\sigma = 6\\tau\\tau&#x27;w_M(\\mathcal{C})^2\\bar{w}_M(\\mathcal{C}, \\zeta)^3</span> . Then,  <span class="math">\\Pi_1</span>  as given in Protocol 2 is a 3-move protocol for relations  <span class="math">(R(\\varPsi, \\beta), R(\\varPsi, \\beta\\sigma, \\zeta^3))</span>  which satisfies perfect completeness and unconditional 3-special soundness.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness follows, because we have <span class="math">\\mathsf{Comp}_{c}</span> is <span class="math">\\tau</span>-preserving for all <span class="math">c\\in\\mathcal{C}</span>, i.e., $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Comp}_{c}(x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, as required. Further, by the considerations above, also the second verification equation will always be true for an honest prover.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">3-Special Soundness: Let <span class="math">(A,B,c_{1},z_{1})</span>, <span class="math">(A,B,c_{2},z_{2})</span> and <span class="math">(A,B,c_{3},z_{3})</span> be three accepting transcripts for pairwise distinct challenges <span class="math">c_{1},c_{2},c_{3}\\in\\mathcal{C}\\subset\\mathcal{R}</span>. Let</p>

    <p class="text-gray-300"><span class="math">(a_{1},a_{2},a_{3})=\\left(c_{3}^{2}-c_{2}^{2},c_{1}^{2}-c_{3}^{2},c_{2}^{2}-c_{1}^{2}\\right).</span></p>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300">\\[ \\begin{pmatrix}1&1&1\\\\ c_{1}&c_{2}&c_{3}\\\\ c_{1}^{2}&c_{2}^{2}&c_{3}^{2}\\end{pmatrix}\\begin{pmatrix}a_{1}\\\\ a_{2}\\\\ a_{3}\\end{pmatrix}=\\tilde{c}\\begin{pmatrix}0\\\\ 1\\\\ 0\\end{pmatrix}, \\]</p>

    <p class="text-gray-300">where <span class="math">\\tilde{c}=(c_{1}-c_{2})(c_{1}-c_{3})(c_{2}-c_{3})\\in\\mathcal{R}^{*}</span>.</p>

    <p class="text-gray-300">Let <span class="math">a</span> such that <span class="math">a\\cdot\\tilde{c}=\\zeta^{3}</span> (such an <span class="math">a</span> exists because <span class="math">\\mathcal{C}</span> is <span class="math">\\zeta</span>-exceptional) and let</p>

    <p class="text-gray-300"><span class="math">\\tilde{x}=a\\cdot\\sum_{i=1}^{3}a_{i}\\cdot\\Phi_{c_{i}}(z_{i})\\in M.</span></p>

    <p class="text-gray-300">Then, we have</p>

    <p class="text-gray-300"><span class="math">\\Psi(\\tilde{x})=a\\cdot\\sum_{i=1}^{3}a_{i}\\cdot\\Psi(\\Phi_{c_{i}}(z_{i}))=a\\cdot\\sum_{i=1}^{3}a_{i}(A+c_{i}X+c_{i}^{2}B)=a\\cdot(0\\cdot A+\\tilde{c}\\cdot X+0\\cdot B)=\\zeta^{3}\\cdot X.</span></p>

    <p class="text-gray-300">Further, we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\bar{w}_{M}(\\mathcal{C},\\zeta)^{3}\\cdot\\sum_{i=1}^{3}2\\cdot w_{M}(\\mathcal{C})^{2}\\cdot\\tau^{\\prime}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 6\\cdot\\bar{w}_{M}(\\mathcal{C},\\zeta)^{3}\\cdot w_{M}(\\mathcal{C})^{2}\\cdot\\tau^{\\prime}\\cdot\\tau\\cdot\\beta=\\beta\\cdot\\sigma,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\sigma=6\\tau\\tau^{\\prime}w_{M}(\\mathcal{C})^{2}\\bar{w}_{M}(\\mathcal{C},\\zeta)^{3}</span>. This completes the proof. ∎</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">5.3 Compressed <span class="math">\\Sigma</span>-Protocol</h3>

    <p class="text-gray-300">In this setting we build on the previous sections in order to present the compressed <span class="math">\\Sigma</span>-Protocol <span class="math">\\Pi_{\\mathrm{comp}}</span>, allowing to reduce complexity to polylogarithmic in the input length (when choosing a suitable instantiation).</p>

    <p class="text-gray-300">The introduced soundness slack makes concatenating protocols a bit more involved than in the plain setting. For more details and a formal treatment of this issue we refer to the Appendix B. Informally</p>

    <p class="text-gray-300"><span class="math">\\Pi_{\\mathrm{comp}}=\\Pi_{1}\\diamond\\cdots\\diamond\\Pi_{1}\\diamond\\Pi_{0},</span></p>

    <p class="text-gray-300">for the appropriate instantiations of <span class="math">\\Pi_{0}</span> and <span class="math">\\Pi_{1}</span>. Recall, that in the composition <span class="math">\\Pi_{b}\\diamond\\Pi_{a}</span>, the final message of protocol <span class="math">\\Pi_{a}</span> is replaced by an execution of <span class="math">\\Pi_{b}</span>.</p>

    <p class="text-gray-300">Building on the composition theorem and the results of the previous sections, where the compression function is instantiated with the Bulletproof compression function, we obtain the following corollary.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Corollary 2 (Generic Compressed <span class="math">\\Sigma</span>-Protocol).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mu\\in\\mathbb{N}</span>. Let <span class="math">M=\\mathcal{R}^{2^{\\mu}}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> the infinity norm on </span>M<span class="math"> (for some underlying norm on </span>\\mathcal{R}<span class="math">). Let </span>\\Psi\\colon M\\to N<span class="math"> be an </span>\\mathcal{R}<span class="math">-module homomorphism, let </span>\\zeta\\in\\mathcal{R}<span class="math"> and let </span>\\mathcal{C}<span class="math"> be a finite </span>\\zeta<span class="math">-exceptional subset of </span>\\mathcal{R}<span class="math">. Let </span>\\alpha,\\beta\\in\\mathbb{N}<span class="math"> and </span>\\delta\\in[0,1)<span class="math">, let </span>V=\\{cy\\mid y\\in M,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\alpha,c\\in\\mathcal{C}\\}<span class="math"> and let </span>(\\mathcal{D},\\mathcal{F})<span class="math"> be a </span>\\beta<span class="math">-bounded </span>V<span class="math">-hiding distribution with abort probability </span>\\delta<span class="math">. Then, there exists a </span>(2\\mu+3)<span class="math">-move public-coin protocol </span>\\Pi_{\\mathsf{comp}}$ for the pair of relations</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\left(R(\\Psi,\\alpha),R(\\Psi,2\\beta\\cdot\\bar{w}(\\mathcal{C},\\zeta)\\cdot\\sigma^{\\mu},\\zeta^{3\\mu+1})\\right),</span></p>

    <p class="text-gray-300">where <span class="math">\\sigma=6\\cdot w(\\mathcal{C})^{3}\\cdot(1+w(\\mathcal{C}))\\cdot\\bar{w}(\\mathcal{C},\\zeta)^{3}</span>.</p>

    <p class="text-gray-300">It is complete with completeness error <span class="math">\\delta</span>, unconditionally <span class="math">(2,3,\\ldots,3)</span>-special sound and non-abort special honest-verifier zero-knowledge. Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\mu+1</span> elements of <span class="math">N</span> and <span class="math">1</span> element of <span class="math">\\mathcal{R}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\mu+1</span> elements of <span class="math">\\mathcal{C}</span>.</li>

    </ul>

    <h6 id="sec-55" class="text-base font-medium mt-4">Remark 7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When instantiating the norm in the corollary above with the <span class="math">p</span>-norm $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{p}<span class="math"> for arbitrary </span>p\\in\\mathbb{N}\\cup\\{\\infty\\}<span class="math"> instead of restricting to the infinity norm, then </span>\\sigma<span class="math"> in the above corollary increases to </span>\\sigma=6\\cdot w(\\mathcal{C})^{2}\\cdot(1+w(\\mathcal{C}))^{2}\\cdot\\bar{w}(\\mathcal{C},\\zeta)^{3}<span class="math">. This is due to the fact that the Bulletproof compression function instantiated with an arbitrary </span>p<span class="math">-norm can only guaranteed to be </span>(w(\\mathcal{C})+1,w(\\mathcal{C})+1)$-norm preserving in general.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">5.4 From Compressed <span class="math">\\mathcal{\\Sigma}</span>-Protocols to Proof of Knowledge</h3>

    <p class="text-gray-300">With our tight knowledge extractor theorem (Theorem 1), we obtain the following corollary.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Corollary 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mu\\in\\mathbb{N}</span>, <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> and <span class="math">\\Pi_{\\mathsf{comp}}</span> as in Corollary 2. Then, the protocol <span class="math">\\Pi_{\\mathsf{comp}}</span> is knowledge sound with knowledge error</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\kappa\\leq\\frac{2\\mu+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to bring the knowledge error down to <span class="math">1/\\lambda^{d}</span> for arbitrary constant <span class="math">d\\in\\mathbb{N}</span>, we can apply the parallel repetition theorem (Theorem 3).</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Corollary 4.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mu\\in\\mathbb{N}</span>, <span class="math">\\delta\\in[0,1)</span>, <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> and <span class="math">\\Pi_{\\mathsf{comp}}</span> as in Corollary 2. Let <span class="math">t\\in\\mathbb{N}</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{t}<span class="math"> is negligible. Let </span>d\\in\\mathbb{N}<span class="math"> be an arbitrary constant. Then, the </span>t<span class="math">-times parallel repetition </span>\\Pi_{\\mathsf{comp}}^{t}<span class="math"> of </span>\\Pi_{\\mathsf{comp}}<span class="math"> is complete with completeness error </span>1-(1-\\delta)^{t}$, knowledge sound with knowledge error</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\kappa\\leq\\frac{1}{\\lambda^{d}}</span></p>

    <p class="text-gray-300">and non-abort honest verifier zero-knowledge.</p>

    <p class="text-gray-300">Note that the above requires that <span class="math">1-(1-\\delta)^{t}</span> is noticeable. This can be achieved by chosing a rejection sampling strategy such that <span class="math">\\delta</span> is constant and <span class="math">t\\in\\mathcal{O}(\\log\\lambda)</span>.</p>

    <p class="text-gray-300">Applying Lemma 6, one can further obtain an interactive protocol that satisfies honest verifier zero-knowledge (or even standard zero-knowledge, when building on trapdoor commitment schemes), at the cost of increasing the knowledge error by the advantage an adversary has to break the binding property of the commitment scheme.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">5.5 From Interactive to Non-Interactive Proofs</h3>

    <p class="text-gray-300">The Fiat-Shamir paradigm <em>[x10]</em> yields a generic conversion from interactive public-coin zero-knowledge proofs to non-interactive zero-knowledge proofs. The idea of the Fiat-Shamir paradigm is that the next challenge is computed as a hash of the statement, together with all previous messages of the protocol. The prover can thus generate a proof without interacting with the verifier, and the verifier check if the challenges were indeed computed correctly and the transcript verifies. The Fiat-Shamir paradigm can be proven secure in the (quantum) random-oracle model <em>[x12, x23, x11]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Unfortunately, when applying the Fiat-Shamir transform in our setting, the following issue arises: For a <span class="math">(2\\mu+3)</span>-move public coin protocol the security loss of the reduction equals <span class="math">Q^{\\mu+1}</span>, where <span class="math">Q</span> is the number of random oracle queries by the adversary, i.e., the security loss is exponential in the number of rounds. Since we have to rely on parallel repetition in order to reduce the soundness error, we are stuck with soundness error $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{c}<span class="math"> (for arbitrary large </span>c$). Therefore, applying Fiat-Shamir to our protocol would result in losing any asymptotic security guarantees.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We still believe that applying Fiat-Shamir does not actually render our protocol insecure. Namely, the parallel repetition result of Section 4 is generically applicable to public-coin interactive arguments, i.e., it does not make use of the fact that a single invocation of protocol <span class="math">\\Pi_{\\mathsf{comp}}</span> is <span class="math">(2,3,\\ldots,3)</span>-special sound. We</p>

    <p class="text-gray-300">believe that parallel repetition of a <span class="math">(2,3,\\ldots,3)</span>-special sound protocol should allow the knowledge error to become negligible. Unfortunately, we do not have a proof for this claim.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that, when choosing concrete parameters, the Bulletproof line of work <em>[BCC^{+}16, BBB^{+}18]</em> implicitly assumes that the Fiat-Shamir security loss is linear in <span class="math">Q</span>, i.e., it does not depend on the number of rounds <span class="math">\\mu</span>. Intuitively, the best strategy of a cheating prover, attacking a single instantiation of <span class="math">\\Pi_{\\mathsf{comp}}</span>, is to decide on one round and query the random oracle until it returns a “good” challenge, i.e., a challenge for which the prover can generate an accepting transcript (in our protocol getting a “good” challenge in one round will indeed be sufficient to generate a complete accepting transcript, independent of future challenges). This attack therefore succeeds with probability at most $Q\\cdot 2/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq Q\\cdot\\kappa<span class="math">, indicating that the security loss might indeed be linear in </span>Q<span class="math">. This belief was only recently supported by <em>[x13]</em>, who gave a proof in the algebraic group model that the loss for <em>[BBB^{+}18]</em> is indeed only in the order of </span>Q$. Unfortunately there are no known similar results in the standard model that would apply to the lattice setting.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, this claim no longer holds if we consider the parallel repetition of protocol <span class="math">\\Pi_{\\mathsf{comp}}</span>. The reason is that a cheating prover does not have to attack every parallel instance simultaneously. For example, it can decide to attack the first instance in the first round of the protocol while attacking the second instance in the second round. This additional degree of freedom implies that the security loss is exponential in the minimum of the number of rounds and the number of parallel repetitions.</p>

    <h2 id="sec-60" class="text-2xl font-bold">6 Compressed <span class="math">\\Sigma</span>-Protocols from the MSIS Assumption</h2>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{comp}}</span> of Corollary 2 is typically instantiated with <span class="math">\\Psi(\\mathbf{x},\\gamma)=(\\mathrm{Com}(\\mathbf{x},\\gamma),L(\\mathbf{x}))</span> for a commitment scheme <span class="math">\\mathrm{Com}</span> and a linear form <span class="math">L</span>, where <span class="math">\\gamma</span> is the commitment randomness. This allows a prover to show that a committed vector <span class="math">\\mathbf{x}</span> satisfies a linear constraint. When instantiated with a compact or compressing commitment scheme, for which the size of a commitment is at most polylogarithmic in the size of the secret vector, protocol <span class="math">\\Pi_{\\mathrm{comp}}</span> achieves communication complexity polylogarithmic in the input size. In Section 7, we show how to linearize non-linear constraints and thereby prove that committed vectors satisfy arbitrary non-linear constraints. Therefore compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{comp}}</span> is only required to handle linear instances.</p>

    <p class="text-gray-300">The generalizations of Section 5 were introduced to handle lattice-based commitment schemes. In this section, we instantiate compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Pi_{\\mathrm{comp}}</span> for the following lattice-based commitment function (Definition 13)</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Com}\\colon\\mathcal{R}^{n}\\times\\mathcal{R}^{r}\\to\\mathcal{R}^{k}_{q},\\quad(\\mathbf{x},\\gamma)\\mapsto A_{1}\\gamma+A_{2}\\mathbf{x}\\mod q.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recall that, <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/f(X)</span> for a monic irreducible polynomial <span class="math">f(X)</span>, <span class="math">\\mathcal{R}_{q}=\\mathcal{R}/(q)</span> for a rational prime <span class="math">q</span>, and <span class="math">A_{1}\\in\\mathcal{R}^{k\\times r}_{q}</span> and <span class="math">A_{2}\\in\\mathcal{R}^{k\\times n}_{q}</span> are sampled uniformly at random in the setup phase. This commitment scheme allows a prover to commit to “short” ring elements. We use it to commit to secret vectors of <span class="math">\\mathcal{R}^{n}_{p}</span> via their unique representation in $\\{x\\in\\mathcal{R}:\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\lceil(p-1)/2\\rceil\\}<span class="math">. Subsequently, we aim to prove that a committed vector </span>\\mathbf{x}\\in\\mathcal{R}^{n}_{p}<span class="math"> satisfies an </span>\\mathcal{R}_{p}<span class="math">-linear constraint </span>L(\\mathbf{x})=y<span class="math"> for a linear form </span>L:\\mathcal{R}^{n}_{p}\\to\\mathcal{R}_{p}<span class="math">. To this end, we instantiate protocol </span>\\Pi_{\\mathrm{comp}}<span class="math"> with </span>\\alpha=\\lceil(p-1)/2\\rceil<span class="math"> for the </span>\\mathcal{R}$-module homomorphism</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathcal{R}^{n}\\times\\mathcal{R}^{r}\\to\\mathcal{R}^{k}_{q}\\times\\mathcal{R}_{p},\\quad(\\mathbf{x},\\gamma)\\mapsto(\\mathrm{Com}(\\mathbf{x},\\gamma),L(\\mathbf{x})\\mod p)\\,.</span></p>

    <p class="text-gray-300">Note that the protocol of Corollary 2 contains an approximation factor <span class="math">\\zeta^{3\\mu+1}</span>. This means that, in the instantiation of this section, a prover claims to know an exact opening <span class="math">(\\mathbf{x},\\gamma)</span> of a commitment <span class="math">P</span> satisfying <span class="math">L(\\mathbf{x})=y</span>, but is only capable of proving knowledge of a relaxed opening <span class="math">(\\mathbf{x}^{\\prime},\\gamma^{\\prime})</span> such that <span class="math">\\mathrm{Com}(\\mathbf{x}^{\\prime},\\gamma^{\\prime})=\\zeta^{3\\mu+1}\\cdot P</span> and <span class="math">L(\\mathbf{x})=\\zeta^{3\\mu+1}\\cdot y\\in\\mathcal{R}_{p}</span>. For this reason, we require the approximation factor <span class="math">\\zeta</span> to be invertible in <span class="math">\\mathcal{R}_{p}</span>. In this case, a commitment to a vector <span class="math">\\mathbf{x}^{\\prime}\\in\\mathcal{R}^{n}_{p}</span> is also a commitment to the vector <span class="math">\\hat{\\mathbf{x}}=\\zeta^{-3\\mu-1}\\mathbf{x}^{\\prime}\\in\\mathcal{R}^{n}_{p}</span> satisfying the linear constraint <span class="math">L(\\hat{\\mathbf{x}})=y</span>. Hence, if <span class="math">\\zeta\\in\\mathcal{R}^{*}_{p}</span>, we derive precisely the desired functionality of proving that a committed vector satisfies a linear constraint.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The lattice instantiation requires a distribution-algorithm pair <span class="math">(\\mathcal{D},\\mathcal{F})</span> that is <span class="math">V</span>-hiding, for $V=\\{cy\\mid y\\in M,\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\alpha,c\\in\\mathcal{C}\\}<span class="math">, and </span>\\beta<span class="math">-bounded for some reasonably small </span>\\beta\\in\\mathbb{N}<span class="math">. We let </span>\\mathcal{D}<span class="math"> be a uniform distribution over an appropriate subset of </span>\\mathcal{R}^{n+r}$. The following lemma shows that this approach gives the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">required properties. The smallest lattice-based signatures take <span class="math">\\mathcal{D}</span> to be a Gaussian distribution. Namely, when the secrets have a bounded <span class="math">\\ell_{2}</span>-norm, the Gaussian distribution results in better protocol parameters. In our scenario this is not the case; our secrets are bounded in the <span class="math">\\ell_{\\infty}</span>-norm. Additionally, uniform sampling is less prone to side-channel attacks. For this reason, the digital signature scheme Dilithium also deploys a uniform rejection sampling approach <em>[DKL^{+}18]</em>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Lemma 7 (Uniform Rejection Sampling).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/f(X)</span> for a monic and irreducible polynomial <span class="math">f(X)\\in\\mathbb{Z}[X]</span> of degree <span class="math">d</span>, <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> and <span class="math">m,\\eta\\in\\mathbb{N}</span>. Let $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> be the </span>\\ell_{\\infty}<span class="math">-norm of the coefficient vector of </span>z\\in\\mathcal{R}^{m}<span class="math"> and let </span>w(\\mathcal{C})=\\max_{c\\in\\mathcal{R},x\\in\\mathcal{R}\\setminus\\{0\\}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}/\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">. Let </span>V=\\{cx\\in\\mathcal{R}^{m}:c\\in\\mathcal{C}\\subset\\mathcal{R},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\lceil(p-1)/2\\rceil\\}<span class="math">. Let </span>\\mathcal{D}<span class="math"> be the uniform distribution over </span>\\{x\\in\\mathcal{R}^{m}:\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\eta\\}$ and let</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\[ \\mathcal{F}(r,v)=\\begin{cases}\\bot,&\\text{if }\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v+r\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}>\\eta-w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil,\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">v+r,&\\text{otherwise.}\\end{cases} \\]</p>

    <p class="text-gray-300">Then <span class="math">(\\mathcal{D},\\mathcal{F})</span> is perfectly <span class="math">V</span>-hiding and <span class="math">(\\eta-w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil)</span>-bounded, with abort probability</p>

    <p class="text-gray-300"><span class="math">\\delta\\leq 1-e^{-\\frac{w(\\mathcal{C})pmd}{2\\eta+1}}.</span></p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that, for all <span class="math">v\\in V</span>, it holds that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil<span class="math">. Hence, the abort probability of the probabilistic algorithm </span>\\{\\mathcal{F}(r,v)\\mid r\\leftarrow\\mathcal{D}\\}$ equals</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\delta</span> <span class="math">=1-\\left(1-\\frac{2w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil}{2\\eta+1}\\right)^{md}</span> <span class="math">\\leq 1-e^{md\\log\\left(1-\\frac{w(\\mathcal{C})p}{2\\eta+1}\\right)}</span> <span class="math">\\leq 1-e^{-\\frac{w(\\mathcal{C})pmd}{2\\eta+1}}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now let <span class="math">\\mathcal{F}^{\\prime}</span> be the algorithm that aborts with probability <span class="math">\\delta</span> and otherwise outputs a $z\\in\\{x\\in\\mathcal{R}^{m}:\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\eta-w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil\\}<span class="math"> sampled uniformly at random. Then it is easily seen that </span>\\{\\mathcal{F}(r,v)\\mid r\\leftarrow\\mathcal{D}\\}<span class="math"> and </span>\\{\\mathcal{F}^{\\prime}\\}<span class="math"> have exactly the same output distributions, i.e., </span>(\\mathcal{D},\\mathcal{F})<span class="math"> is </span>V$-hiding.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, <span class="math">(\\mathcal{D},\\mathcal{F})</span> is clearly <span class="math">(\\eta-w(\\mathcal{C})\\left\\lceil(p-1)/2\\right\\rceil)</span>-bounded. ∎</p>

    <p class="text-gray-300">The resulting instantiation of <span class="math">\\Pi_{\\mathrm{comp}}</span>, denoted by <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span>, is parameterized by <span class="math">\\eta\\in\\mathbb{N}</span> allowing for a trade-off between the abort probability and communication complexity of the protocol. Its properties are summarized in Corollary 5.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Corollary 5 (Lattice-Based Compressed <span class="math">\\Sigma</span>-Protocol).</h6>

    <p class="text-gray-300">Let <span class="math">n,r,\\mu,\\eta\\in\\mathbb{N}</span> such that <span class="math">n+r=2^{\\mu}</span> and let <span class="math">p,q\\in\\mathbb{N}</span> be primes. Let <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/f(X)</span> for a monic and irreducible polynomial <span class="math">f(X)\\in\\mathbb{Z}[X]</span> of degree <span class="math">d</span>. Let <span class="math">\\zeta\\in\\mathcal{R}</span> such that <span class="math">\\zeta\\in\\mathcal{R}_{p}^{*}</span> and let <span class="math">\\mathcal{C}</span> be a <span class="math">\\zeta</span>-exceptional subset of <span class="math">\\mathcal{R}</span>. Let <span class="math">A_{1}\\in\\mathcal{R}_{q}^{k\\times r}</span>, <span class="math">A_{2}\\in\\mathcal{R}_{q}^{k\\times n}</span> and</p>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathcal{R}^{n}\\times\\mathcal{R}^{r}\\to\\mathcal{R}_{q}^{k}\\times\\mathcal{R}_{p},\\quad(\\mathbf{x},\\gamma)\\mapsto\\left(A_{1}\\gamma+A_{2}\\mathbf{x}\\mod q,L(\\mathbf{x})\\mod p\\right).</span></p>

    <p class="text-gray-300">Then, there exists a <span class="math">(2\\mu+3)</span>-move public-coin protocol <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span> for the pair of relations</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">R</span> $=\\Big{\\{}\\left(P;x\\right):P=\\Psi(x),\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\lceil(p-1)/2\\rceil\\Big{\\}},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\sigma=6\\cdot w(\\mathcal{C})^{3}\\cdot(1+w(\\mathcal{C}))\\cdot\\bar{w}(\\mathcal{C},\\zeta)^{3}</span> with <span class="math">w(\\cdot)</span> and <span class="math">\\bar{w}(\\cdot)</span> defined as in Equation 8.</p>

    <p class="text-gray-300">It is unconditionally <span class="math">(2,3,\\ldots,3)</span>-special sound, non-abort special honest-verifier zero-knowledge and complete with completeness error</p>

    <p class="text-gray-300"><span class="math">\\delta\\leq 1-e^{-\\frac{w(\\mathcal{C})p(n+r)d}{2\\eta+1}}.</span></p>

    <p class="text-gray-300">Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}\\to\\mathcal{V}</span>: <span class="math">2\\mu+1</span> elements of <span class="math">\\mathcal{R}_{q}^{k}</span>, <span class="math">2\\mu+1</span> elements of <span class="math">\\mathcal{R}_{p}</span> and <span class="math">1</span> element of <span class="math">\\mathcal{R}</span>.</li>

      <li><span class="math">\\mathcal{V}\\to\\mathcal{P}</span>: <span class="math">\\mu+1</span> elements of <span class="math">\\mathcal{C}</span>.</li>

    </ul>

    <h6 id="sec-64" class="text-base font-medium mt-4">Remark 8.</h6>

    <p class="text-gray-300">Corollary 5 does not require <span class="math">\\zeta</span> to be invertible in <span class="math">\\mathcal{R}_{p}</span>. In particular, this result is still valid for <span class="math">\\zeta=0</span>. However, in this case <span class="math">0</span> is a witness for all statements <span class="math">P\\in L_{R^{\\prime}}</span> and thereby the claim that is being proven becomes vacuous. For this reason, in most practical scenarios we assume that <span class="math">\\zeta\\in\\mathcal{R}_{p}^{*}</span>.</p>

    <h3 id="sec-65" class="text-xl font-semibold mt-8">6.1 Parameters</h3>

    <p class="text-gray-300">In this section, we consider compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span> defined over the cyclotomic number ring <span class="math">\\mathcal{R}=\\mathbb{Z}[X]/(X^{d}+1)</span> with <span class="math">d</span> a power of two and with challenge set <span class="math">\\mathcal{C}=\\{0,\\pm 1,\\pm X,\\ldots,\\pm X^{d-1}\\}</span>. We show that this protocol has communication complexity polylogarithmic in the input size. We only consider the simplified scenario of proving knowledge of a commitment opening.</p>

    <p class="text-gray-300">Power-of-two cyclotomic number rings <span class="math">\\mathcal{R}</span> and their monomial challenge set <span class="math">\\mathcal{C}</span> have certain convenient properties. In particular, <span class="math">w(\\mathcal{C})=1</span> and <span class="math">\\mathcal{C}</span> is a <span class="math">2</span>-exceptional subset of <span class="math">\\mathcal{R}</span>. More precisely, <span class="math">2/(c-c^{\\prime})\\in\\mathcal{R}</span> is a polynomial with coefficients in <span class="math">\\{-1,0,1\\}</span> for all distinct <span class="math">c,c^{\\prime}\\in\\mathcal{C}</span> <em>[BCK^{+}14]</em>. From this it follows that <span class="math">\\bar{w}(\\mathcal{C},2)\\leq d</span>. For a more detailed discussion on optimal challenge sets see <em>[x18, x1]</em>.</p>

    <p class="text-gray-300">Let us now determine the asymptotic communication complexity. First note that, by Theorem 1, <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span> has knowledge error <span class="math">\\kappa\\leq(2\\log(n+r)+1)/(2d+1)\\leq\\log(n+r)/d</span> (assuming that <span class="math">\\log(n+r)&lt;d</span>). For this reason <span class="math">t=\\Theta\\left(\\lambda/(\\log d-\\log\\log(n+r))\\right)</span> parallel repetitions are required, where <span class="math">\\lambda</span> is the security parameter. Note that, in the analysis of the lattice-based Bulletproof folding technique it is incorrectly claimed that their protocol achieves <span class="math">\\mathcal{O}(1/d)</span> knowledge error <em>[x1, p. 20]</em>. However, similar to our protocol, it achieves a <span class="math">\\mathcal{O}(\\log(n+r)/d)</span> knowledge error.</p>

    <p class="text-gray-300">Moreover, we assume <span class="math">\\eta=\\Theta(tdp(n+r))</span>, which by Corollary 5 is enough to achieve a constant completeness error. From Corollary 5 it now follows that the extractor outputs a <span class="math">(B,2^{3\\mu+1})</span>-relaxed commitment opening, where</p>

    <p class="text-gray-300"><span class="math">B=2d\\cdot(12d^{3})^{\\mu}\\left(\\eta-\\left\\lceil\\frac{p-1}{2}\\right\\rceil\\right)=\\Theta(d^{2}tp(n+r)^{3+\\log 3+3\\log d}).</span></p>

    <p class="text-gray-300">Hence, the commitment scheme must be instantiated to be binding with respect to <span class="math">(B,2^{3\\mu+1})</span>-relaxed commitment openings, i.e., the <span class="math">\\mathrm{MSIS}_{k,n+r,2B}^{\\infty}</span> problem over <span class="math">\\mathcal{R}_{q}</span> must be computationally infeasible (Lemma 3). Recall that commitments are vectors in <span class="math">\\mathcal{R}_{q}^{k}</span>. From the Micciancio-Regev bound (Equation 1) it follows that this problem is hard if</p>

    <p class="text-gray-300"><span class="math">dk\\log q\\geq\\frac{\\log^{2}(2B\\sqrt{n+r})}{4\\log\\delta}=\\Theta\\left(\\frac{\\log^{2}d\\log^{2}tdp(n+r)}{\\log\\delta}\\right),</span> (9)</p>

    <p class="text-gray-300">where <span class="math">\\delta</span> is the root Hermite factor. Note that we derive an additional <span class="math">\\sqrt{n+r}</span> factor because we reduce the MSIS-problem from the <span class="math">\\ell_{\\infty}</span>-norm to the <span class="math">\\ell_{2}</span>-norm. When these commitments are considered stand-alone their size is independent of the input rank <span class="math">n</span>, i.e., they are compact. However, the soundness slack of our protocols depends (polynomially) on <span class="math">n</span>. Hence, the commitment scheme must be instantiated such that the bit size <span class="math">dk\\log q</span> of commitments is polylogarithmic.</p>

    <p class="text-gray-300">By Lemma 1 it now follows that <span class="math">r</span> is polylogarithmic in the input size. Together with Corollary 5 and the fact that <span class="math">t=\\Theta\\left(\\lambda/(\\log d-\\log\\log(n+r))\\right)</span>, this shows that the prover has to send</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(\\frac{\\lambda\\log^{2}d\\log n\\log^{2}\\lambda dpn}{\\log\\delta(\\log d-\\log\\log n)}\\right)</span></p>

    <p class="text-gray-300">bits of information to the verifier. Hence, this instantiation of <span class="math">\\Lambda_{\\mathrm{comp}}(\\alpha,\\eta)</span> indeed achieves communication complexity polylogarithmic in the input size.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Remark 9</h6>

    <p class="text-gray-300">The lattice based Bulletproof instantiation of <em>[x1]</em> considers the case <span class="math">k=1</span> and they derive a communication complexity of <span class="math">\\mathcal{O}(d\\lambda\\log n\\log pn/\\log\\delta)</span> (using our notation) under the assumption that <span class="math">\\log q=\\Theta(\\log d\\log pn)</span>. However, to ensure that the underlying commitment scheme is binding they must choose <span class="math">d=\\Theta(\\log q)</span>. Moreover, they incorrectly estimate their knowledge error to be <span class="math">\\mathcal{O}(1/d)</span> instead of <span class="math">\\mathcal{O}(\\log n/d)</span>. Taking these two issues into account gives their protocol a communication complexity of</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}\\left(\\frac{\\lambda\\log^{2}d\\log n\\log^{2}pn}{\\log\\delta(\\log d-\\log\\log n)}\\right).</span></p>

    <p class="text-gray-300">The additional factor <span class="math">\\lambda d</span> inside the logarithm of our communication complexity can be explained by the fact that, in contrast to <em>[x1]</em>, our protocol is zero-knowledge. Besides this factor, our communication complexity is the same.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Remark 10</h6>

    <p class="text-gray-300">Because the security loss of the Fiat-Shamir transform is exponential in the number of rounds, the non-interactive variant of the <span class="math">t</span>-fold parallel repetition of protocol <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span> requires a factor <span class="math">\\mathcal{O}(\\mu)=\\mathcal{O}(\\log n)</span> more parallel repetitions than the interactive variant. Therefore, the communication complexity of the non-interactive variant is a factor <span class="math">\\mathcal{O}(\\log n)</span> larger. This issue has been overlooked in prior works.</p>

    <h2 id="sec-68" class="text-2xl font-bold">7 Proving Non-Linear Relations</h2>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\mathrm{comp}}</span> of Section 6 allows a prover to show that a committed vector <span class="math">\\mathbf{x}\\in\\mathcal{R}_{p}^{n}</span> satisfies an <span class="math">\\mathcal{R}_{p}</span>-linear constraint, i.e., prove that <span class="math">L(\\mathbf{x})=y</span> for a public linear form <span class="math">L:\\mathcal{R}_{p}^{n}\\to\\mathcal{R}_{p}</span> and a public <span class="math">y\\in\\mathcal{R}_{p}=\\mathbb{F}_{p}[X]/(f(X))</span>. We also say that his protocol allows a prover to open a linear form <span class="math">L</span> on a committed vector <span class="math">\\mathbf{x}</span>. It trivially follows that <span class="math">\\Lambda_{\\mathrm{comp}}</span> allows a prover to open affine maps <span class="math">L:\\mathcal{R}_{p}^{n}\\to\\mathcal{R}_{p}^{m}</span> . Our protocols have an approximation factor <span class="math">\\zeta^{\\ell}</span> for some <span class="math">\\ell\\in\\mathbb{N}</span> and <span class="math">\\zeta\\in\\mathcal{R}</span> such that the challenge set <span class="math">\\mathcal{C}</span> is <span class="math">\\zeta</span>-exceptional. Recall that to be able to prove that a committed vector satisfies a linear constraint exactly we must assume that <span class="math">\\zeta</span> is invertible in <span class="math">\\mathcal{R}_{p}</span>.</p>

    <p class="text-gray-300">In this section, we consider non-linear constraints. More precisely, we aim to construct a protocol for proving that a committed vector <span class="math">\\mathbf{x}</span> satisfies <span class="math">C(\\mathbf{x})=0</span> for a circuit <span class="math">C:\\mathcal{R}_{p}^{n}\\to\\mathcal{R}_{p}</span>. We follow the linearization strategy of <em>[x2]</em>. The main idea is to linearize the non-linear multiplication gates of the circuit <span class="math">C</span> by deploying an appropriate arithmetic secret sharing scheme. This explains why <span class="math">\\Lambda_{\\mathrm{comp}}</span> is only required to prove linear relations. The linearization technique reduces the unconditional soundness of protocol <span class="math">\\Lambda_{\\mathrm{comp}}</span> to computational soundness. More precisely, it requires the commitment scheme to be binding. Hence, our protocols for proving non-linear constraints are arguments of knowledge and not proofs of knowledge. We briefly recall the techniques from <em>[x2]</em> and subsequently describe the adaptations required for our lattice instantiation.</p>

    <h3 id="sec-69" class="text-xl font-semibold mt-8">7.1 Discrete-Log Setting</h3>

    <p class="text-gray-300">The protocols of <em>[x2]</em> consider arithmetic circuits <span class="math">C:\\mathbb{F}_{p}^{n}\\to\\mathbb{F}_{p}</span> defined over a finite field <span class="math">\\mathbb{F}_{p}</span>. Let us assume that <span class="math">C</span> has <span class="math">m</span> multiplication gates with two variable inputs. We let <span class="math">\\mathbf{a}=(a_{1},\\ldots,a_{m})</span> denote the left input wires, <span class="math">\\mathbf{b}=(b_{1},\\ldots,b_{m})</span> the right input wires and <span class="math">\\mathbf{c}=(c_{1},\\ldots,c_{m})</span> the output wires of the multiplication gates. For a wire <span class="math">w</span> we write <span class="math">w(\\mathbf{x})\\in\\mathbb{F}_{p}</span> for the value it takes when the circuit <span class="math">C</span> is evaluated in <span class="math">\\mathbf{x}\\in\\mathbb{F}_{p}^{n}</span>. It is easily seen that all wires <span class="math">w</span> of <span class="math">C</span> correspond to an affine form <span class="math">L_{w}:\\mathbb{F}_{p}^{n+m}\\to\\mathbb{F}_{p}</span> such that <span class="math">w(\\mathbf{x})=L_{w}(\\mathbf{x},\\mathbf{c}(\\mathbf{x}))</span> for all <span class="math">\\mathbf{x}\\in\\mathbb{F}_{p}^{n}</span>. A naive protocol for proving knowledge of an <span class="math">\\mathbf{x}</span> such that <span class="math">C(\\mathbf{x})=0</span> therefore goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover commits to the vector <span class="math">(\\mathbf{x},\\mathbf{c}(\\mathbf{x}))\\in\\mathbb{F}_{p}^{n+m}</span>;</li>

      <li>The prover opens the linear forms <span class="math">L_{o}</span> and <span class="math">L_{a_{i}},L_{b_{i}},L_{c_{i}}</span> for <span class="math">1\\leq i\\leq m</span>, where <span class="math">o</span> is the output wire;</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that <span class="math">L_{o}(\\mathbf{x},\\mathbf{c})=0</span> and that <span class="math">L_{a_{i}}(\\mathbf{x},\\mathbf{c})L_{b_{i}}(\\mathbf{x},\\mathbf{c})=L_{c_{i}}(\\mathbf{x},\\mathbf{c})</span> for all <span class="math">1\\leq i\\leq m</span>.</li>

    </ol>

    <p class="text-gray-300">The first verification shows that, on input <span class="math">\\mathbf{x}</span>, the circuit evaluates to <span class="math">0</span>. The second verification shows that the committed vector <span class="math">\\mathbf{c}</span> of auxiliary information has been constructed honestly, i.e., that it equals <span class="math">\\mathbf{c}(\\mathbf{x})</span>.</p>

    <p class="text-gray-300">However, this approach is not zero-knowledge; the input and output wire values of the multiplication gates are revealed. Moreover, the communication complexity is linear in the number of multiplication gates <span class="math">m</span>. To solve these issues, a multiplicative (packed) secret sharing scheme with 1-privacy is used. The secret sharing scheme allows the complexity of the <span class="math">m</span> verifications to be amortized and its 1-privacy guarantees zero-knowledge.</p>

    <p class="text-gray-300">More precisely, the prover samples <span class="math">r_{1},r_{2}\\in\\mathbb{F}_{p}</span> uniformly at random and determines the unique polynomials <span class="math">F(Z),G(Z)\\in\\mathbb{F}_{p}[Z]</span> of degree at most <span class="math">m</span> that satisfy</p>

    <p class="text-gray-300"><span class="math">F(0)</span> <span class="math">=r_{1},F(1)=a_{1}(\\mathbf{x}),\\ldots,F(m)=a_{m}(\\mathbf{x}),</span> <span class="math">G(0)</span> <span class="math">=r_{2},G(1)=b_{1}(\\mathbf{x}),\\ldots,G(m)=b_{m}(\\mathbf{x}).</span></p>

    <p class="text-gray-300">Hence, <span class="math">F(Z)</span> and <span class="math">G(Z)</span> define packed secret sharings (Shamir’s scheme) of the vectors <span class="math">\\mathbf{a}(\\mathbf{x}),\\mathbf{b}(\\mathbf{x})\\in\\mathbb{F}_{p}^{m}</span>, with 1-privacy. Subsequently, the prover computes the product polynomial <span class="math">H(Z)=F(Z)G(Z)</span> of degree at most <span class="math">2m</span>, and commits to the vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\mathbf{x},\\mathbf{c}(\\mathbf{x}),F(0),G(0),H(0),H(m+1),\\ldots,H(2m))\\in\\mathbb{F}_{p}^{n+2m+3}.</span></p>

    <p class="text-gray-300">As before any wire value can be computed as an affine form evaluated in <span class="math">\\mathbf{y}</span>. Note that the “absent” evaluations, <span class="math">F(i)</span>, <span class="math">G(i)</span> and <span class="math">H(i)</span> for <span class="math">1\\leq i\\leq m</span>, can be computed as affine forms evaluated in the committed vector <span class="math">\\mathbf{y}</span>. Hence, by Lagrange interpolation, it is, in addition, possible to compute any evaluation of the polynomials <span class="math">F(Z)</span>, <span class="math">G(Z)</span> and <span class="math">H(Z)</span> as a linear form evaluated in <span class="math">\\mathbf{y}</span>.</p>

    <p class="text-gray-300">Therefore, instead of opening all inputs and outputs of the multiplication gates the prover simply opens <span class="math">F(\\rho)</span>, <span class="math">G(\\rho)</span> and <span class="math">H(\\rho)</span> for an evaluation point <span class="math">\\rho\\in\\mathbb{F}_{p}\\setminus\\{1,\\ldots,m\\}</span> selected uniformly at random by the verifier. Since this secret sharing scheme has 1-privacy, these evaluation points do not reveal any information about the secret vector <span class="math">\\mathbf{x}</span>. The verifier subsequently checks that <span class="math">F(\\rho)G(\\rho)=H(\\rho)</span>. If the committed vector <span class="math">\\mathbf{y}</span> is not created honestly, it follows that the committed polynomials do not satisfy <span class="math">F(Z)G(Z)=H(Z)</span>. In this case, the verification passes with probability at most <span class="math">2m/(p-m)</span>. In the discrete log setting the number of multiplication gates <span class="math">m</span> can be assumed to be polynomial and the prime <span class="math">p</span> is exponential in the security parameter, resulting in a negligible cheating probability.</p>

    <h3 id="sec-70" class="text-xl font-semibold mt-8">7.2 Lattice Setting</h3>

    <p class="text-gray-300">In the lattice setting relations are defined over the ring</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{p}=\\mathbb{Z}[X]/(p,f(X))=\\mathbb{F}_{p}[X]/\\left(\\prod_{i=1}^{g}f_{i}(X)^{e_{i}}\\right),</span></p>

    <p class="text-gray-300">where <span class="math">f_{i}(X)</span> is irreducible modulo <span class="math">p</span> and of degree <span class="math">d_{i}</span> for all <span class="math">i</span>. This introduces two difficulties. First, the ring <span class="math">\\mathcal{R}_{p}</span> is not necessarily a field. Second, the prime <span class="math">p</span> is typically small. Let us now address these issues.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{R}_{p}</span> is not a field, Shamir’s secret sharing scheme has to be instantiated more carefully. Lagrange interpolation requires differences of evaluation points to be invertible. For this reason, the subset <span class="math">\\mathcal{S}_{p}\\subset\\mathcal{R}_{p}</span> of evaluation points has to be exceptional. The largest exceptional subset of <span class="math">\\mathcal{R}_{p}</span> has cardinality <span class="math">p^{D}</span>, where <span class="math">D=\\min_{i}(d_{i})</span> is the minimum of the degrees of the irreducible factors of <span class="math">f(X)</span> modulo <span class="math">p</span>. So let us assume that <span class="math">\\mathcal{S}_{p}=\\{s_{0},\\ldots,s_{p^{D}-1}\\}</span> has cardinality <span class="math">p^{D}</span>.</p>

    <p class="text-gray-300">The secret sharing of the left input wire values <span class="math">\\mathbf{a}(\\mathbf{x})</span> of the multiplication gates is now defined by the unique polynomial <span class="math">F(Z)\\in\\mathcal{R}_{p}[Z]</span> that satisfies</p>

    <p class="text-gray-300"><span class="math">F(s_{0})=r_{1},F(s_{1})=a_{1}(\\mathbf{x}),\\ldots,F(s_{m})=a_{m}(\\mathbf{x}),</span></p>

    <p class="text-gray-300">for an element <span class="math">r_{1}\\in\\mathcal{R}_{p}</span> sampled uniformly at random by the prover. The polynomials <span class="math">G(Z)</span> and <span class="math">H(Z)=F(Z)G(Z)</span> and the vector <span class="math">\\mathbf{y}\\in\\mathcal{R}_{p}^{n+2m+3}</span> are defined as before (now considering evaluation points in <span class="math">\\mathcal{S}_{p}</span>). Subsequently, the prover sends a commitment to <span class="math">\\mathbf{y}</span> to the verifier. The verifier selects a random evaluation <span class="math">\\rho</span> point from <span class="math">\\mathcal{S}_{p}\\setminus\\{s_{1},\\ldots,s_{m}\\}</span>, asks the prover to open <span class="math">F(\\rho)</span>, <span class="math">G(\\rho)</span> and <span class="math">H(\\rho)</span> and checks that <span class="math">F(\\rho)G(\\rho)=H(\\rho)</span>. A dishonest prover succeeds with probability at most <span class="math">2m/(p^{D}-m)</span>. Clearly, this requires <span class="math">p^{D}</span> to be larger than <span class="math">3m</span>. However, note that <span class="math">2m/(p^{D}-m)</span> does not necessarily have to be negligible. Namely, it might very well be the case that the knowledge error of compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\text{comp}}</span> is noticeable and parallel repetitions are required anyway. In practice, we want <span class="math">2m/(p^{D}-m)</span> to be of the same order of magnitude as the knowledge error of <span class="math">\\Lambda_{\\text{comp}}</span> (see Equation 2). In Appendix C.1, a complete protocol description and theorem summarizing the protocol’s properties are given. In Appendix C.2, we show how to handle the situation where <span class="math">p^{D}</span> is too small, e.g., <span class="math">p^{D}\\leq 3m</span>.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Remark 11.</h6>

    <p class="text-gray-300">The protocol for proving non-linear relations described thus far requires the prover to be committed to the secret vector <span class="math">\\mathbf{x}\\in\\mathcal{R}_{p}^{n}</span> and the auxiliary input <span class="math">\\mathsf{aux}=(\\mathbf{c}(\\mathbf{x}),F(s_{0}),\\ldots,H(s_{2m}))\\in\\mathcal{R}_{p}^{2m+3}</span> in a single commitment. It does not allow a prover to prove non-linear relations about a committed vector <span class="math">\\mathbf{x}</span> that has been committed to without the auxiliary input <span class="math">\\mathsf{aux}</span>, i.e., it is not a <em>commit-and-prove</em> protocol. In Section 8.3, it is explained how to transform this approach into a commit-and-prove protocol.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Remark 12.</h6>

    <p class="text-gray-300">Thus far we have considered a somewhat non-standard circuit model, i.e., circuits defined over the ring <span class="math">\\mathcal{R}_{p}</span>. However, our approach is easily adaptable to circuit satisfiability arguments over the field <span class="math">\\mathbb{F}_{p}</span>. For example, by choosing the ring <span class="math">\\mathcal{R}</span> such that <span class="math">p</span> fully splits. In this case, each NTT coefficient can be used to commit to an <span class="math">\\mathbb{F}_{p}</span>-element. Running the <span class="math">\\mathcal{R}_{p}</span>-circuit argument for an <span class="math">\\mathbb{F}_{p}</span>-circuit then corresponds to <span class="math">d</span> simultaneous <span class="math">\\mathbb{F}_{p}</span>-circuit satisfiability arguments, where <span class="math">d</span> is the degree of <span class="math">\\mathcal{R}</span>.</p>

    <h2 id="sec-73" class="text-2xl font-bold">8 Extensions</h2>

    <p class="text-gray-300">In this section we discuss a number of extensions of the techniques presented thus far. These extensions almost directly carry over from the discrete log setting to the lattice setting and demonstrate the plug and play nature of compressed <span class="math">\\Sigma</span>-protocol theory.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">8.1 Amortizing over Many Linear Forms</h3>

    <p class="text-gray-300">The compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\text{comp}}</span> allows a prover to open a linear form on a committed vector. The naive approach for opening <span class="math">s</span> linear form <span class="math">L_{1},\\ldots,L_{s}</span> is to consider the following <span class="math">\\mathcal{R}</span>-module homomorphism:</p>

    <p class="text-gray-300"><span class="math">\\Psi\\colon\\mathcal{R}^{n}\\times\\mathcal{R}^{r}\\to\\mathcal{R}_{q}^{k}\\times\\mathcal{R}_{p}^{s},\\quad(\\mathbf{x},\\gamma)\\mapsto\\left(\\mathrm{Com}(\\mathbf{x},\\gamma),L_{1}(\\mathbf{x}),\\cdots,L_{s}(\\mathbf{x})\\right).</span></p>

    <p class="text-gray-300">However, this requires a prover to send <span class="math">2s</span> elements of <span class="math">\\mathcal{R}_{p}</span> in every round of the compression mechanism <span class="math">\\Lambda_{1}</span>, thereby increasing the communication costs with respect to opening a single linear form. A standard amortization technique, known for example from MPC, allows a prover to open <span class="math">s</span> linear forms for the price of one. Instead of opening all <span class="math">s</span> linear forms separately, the prover opens <em>one</em> linear form <span class="math">L_{\\rho}(\\mathbf{x})=\\sum_{i=1}^{s}L_{i}(\\mathbf{x})\\rho^{i-1}</span>, where <span class="math">\\rho</span> is selected uniformly at random by the verifier from an exceptional subset <span class="math">\\mathcal{S}_{p}\\subset\\mathcal{R}_{p}</span> of size <span class="math">p^{D}</span>. If <span class="math">L_{\\rho}(\\mathbf{x})=\\sum_{i=1}^{s}y_{i}\\rho^{i-1}</span>, for a random <span class="math">\\rho\\leftarrow_{R}\\mathcal{S}_{p}</span>, it follows that <span class="math">L_{i}(\\mathbf{x})=y_{i}</span> for all <span class="math">i</span> with probability at least <span class="math">1-(s-1)/p^{D}</span>, i.e., a dishonest prover succeeds with probability at most <span class="math">(s-1)/p^{D}</span>. If the cheating probability is too large, the techniques from Appendix C.2 can be applied. This amortization technique reduces the unconditional soundness of <span class="math">\\Lambda_{\\text{comp}}</span> to computational soundness, i.e., the amortized protocol is an argument of knowledge and not a proof of knowledge.</p>

    <p class="text-gray-300">As an example, let us consider our protocol for proving non-linear arithmetic circuit relations. This protocol requires the prover to open four linear forms, three corresponding to secret shares and one corresponding to the output of the circuit. These amortization techniques are therefore directly applicable and reduce the communication complexity.</p>

    <p class="text-gray-300">8.2 Reducing the Communication Complexity</p>

    <p class="text-gray-300">Bulletproofs <em>[BBB^{+}18]</em> and the discrete-log based compressed <span class="math">\\Sigma</span>-protocol of <em>[x1]</em> apply an additional reduction to “incorporate” the linear form evaluation into the commitment. More precisely, on input a challenge <span class="math">\\rho</span> from an exceptional subset of <span class="math">\\mathcal{S}_{p}\\subset\\mathcal{R}_{p}</span> sampled uniformly at random by the verifier, the following homomorphism in considered,</p>

    <p class="text-gray-300"><span class="math">\\Psi_{\\rho}\\colon\\mathcal{R}^{n}\\times\\mathcal{R}^{r}\\to\\mathcal{R}^{k}_{q},\\quad(\\mathbf{x},\\gamma)\\mapsto\\operatorname{Com}\\left((\\mathbf{x},\\rho L(\\mathbf{x})),\\gamma\\right).</span></p>

    <p class="text-gray-300">The advantage of this homomorphism is that its codomain is smaller; images of <span class="math">\\Psi_{\\rho}</span> are commitments and do not contain linear form evaluations. For details we refer to <em>[x1, Section 4.1]</em>. Applying the compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\mathrm{comp}}</span> to this homomorphism results in smaller communication costs than directly applying <span class="math">\\Lambda_{\\mathrm{comp}}</span> for the original homomorphism <span class="math">\\Psi</span>. In the discrete log setting, linear form evaluations and commitments have approximately the same size, therefore this improvement reduces the communication costs by roughly a factor <span class="math">2</span>. In the lattice setting, commitments are elements in <span class="math">\\mathcal{R}^{k}_{q}</span> and linear form evaluations are elements in the much smaller ring <span class="math">\\mathcal{R}_{p}</span>, therefore the reduction is less profitable in this setting. For this reason, we have not included this reduction into our main protocol <span class="math">\\Lambda_{\\mathrm{comp}}</span>. Finally, we note that this technique reduces knowledge soundness from unconditional to computational.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">8.3 Commit-and-Prove Protocols</h3>

    <p class="text-gray-300">The linearization approach of Section 7 for proving that a committed vector <span class="math">\\mathbf{x}\\in\\mathcal{R}^{n}_{p}</span> satisfies certain non-linear constraints requires a prover to be committed to the vector <span class="math">\\mathbf{x}</span> together with a vector <span class="math">\\mathsf{aux}=(\\mathbf{c}(\\mathbf{x}),F(s_{0}),\\ldots,H(s_{2m}))</span> of auxiliary information in a single commitment. However, in many practical scenarios, a prover is already committed to the vector <span class="math">\\mathbf{x}</span>, without the auxiliary information <span class="math">\\mathsf{aux}</span>. The secret vector can be contained in a single commitment or it can be dispersed over many different commitments. We wish to construct a protocol for proving non-linear statements about commitments that have been created before the proof of knowledge is evaluated. This is also referred to as commit-and-prove functionality. To achieve this functionality, the secret vector <span class="math">\\mathbf{x}</span> and the auxiliary information <span class="math">\\mathsf{aux}</span> are first compactified into a single (compact) commitment using the compactification techniques from <em>[x1]</em>.</p>

    <p class="text-gray-300">We describe the most straightforward compactification technique, by considering the scenario that <span class="math">P</span> is a commitment to a secret vector <span class="math">\\mathbf{x}\\in\\mathcal{R}^{n}_{p}</span> and <span class="math">\\mathsf{aux}\\in\\mathcal{R}^{t}_{p}</span> is the auxiliary information required to prove a certain non-linear statement about <span class="math">\\mathbf{x}</span>. Note that, the commitment <span class="math">P</span> can also be considered a commitment to the vector <span class="math">(\\mathbf{x},0)\\in\\mathcal{R}^{n+t}_{p}</span>. The compactification now goes as follows. The prover sends a commitment <span class="math">Q</span> to <span class="math">(0,\\mathsf{aux})\\in\\mathcal{R}^{n+t}_{p}</span> to the verifier and, by running <span class="math">\\Lambda_{\\mathrm{comp}}</span> amortized over <span class="math">n</span> linear forms, proves that the first <span class="math">n</span> coefficients of the committed vector are <span class="math">0</span>. Prover and verifier compute a commitment <span class="math">P+Q</span> to the vector <span class="math">(\\mathbf{x},\\mathsf{aux})</span> containing both the secret vector <span class="math">\\mathbf{x}</span> and the auxiliary information. Using <span class="math">P+Q</span> the non-linear statements about <span class="math">\\mathbf{x}</span> can be proven.</p>

    <p class="text-gray-300">This approach increases the communication complexity of by roughly a factor <span class="math">2</span>; the prover has to prove linear constraints for both commitment <span class="math">Q</span> and commitment <span class="math">P+Q</span>. Protocol 9 in the full version of <em>[x1]</em> gives a more advanced protocol for avoiding this factor <span class="math">2</span> loss in communication efficiency in the discrete-log setting. This technique caries over to the lattice setting at the cost of introducing a minor amount of additional soundness slack. This additional slack is caused by the fact that the prover has to commit to two additional <span class="math">\\mathcal{R}_{p}</span> elements.</p>

    <h2 id="sec-76" class="text-2xl font-bold">9 Acknowledgements</h2>

    <p class="text-gray-300">We thank Jelle Don, Serge Fehr, Michael Klooß, Vadim Lyubashevsky and Gregor Seiler for the helpful and insightful discussions. Furthermore, we thank Andrej Bogdanov for pointing out an oversight regarding the composition theorem in the first version of this work.</p>

    <p class="text-gray-300">Thomas Attema has been supported by EU H2020 project No 780701 (PROMETHEUS). Ronald Cramer has been supported by ERC ADG project No 74079 (ALGSTRONGCRYPTO) and by the NWO Gravitation project QSC. Lisa Kohl has been supported by the NWO Gravitation project QSC.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>AC20. Thomas Attema and Ronald Cramer. Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug & play secure algorithmics. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 513–543. Springer, Heidelberg, August 2020.</li>

      <li>ACF20. Thomas Attema, Ronald Cramer, and Serge Fehr. Compressing proofs of <span class="math">k</span>-out-of-<span class="math">n</span> partial knowledge. Cryptology ePrint Archive, Report 2020/753, 2020. https://eprint.iacr.org/2020/753.</li>

      <li>ACX21. Thomas Attema, Ronald Cramer, and Chaoping Xing. A note on short invertible ring elements and applications to cyclotomic and trinomials number fields. Mathematical Cryptology, 1(1):45–70, 2021.</li>

      <li>AHIV17. Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. Ligero: Lightweight sublinear arguments without a trusted setup. In Bhavani M. Thuraisingham, David Evans, Tal Malkin, and Dongyan Xu, editors, ACM CCS 2017, pages 2087–2104. ACM Press, October / November 2017.</li>

      <li>Ajt96. Miklós Ajtai. Generating hard instances of lattice problems (extended abstract). In STOC, pages 99–108. ACM, 1996.</li>

      <li>AL21. Martin R. Albrecht and Russel W.F. Lai. Subtractive sets over cyclotomic rings: Limits of schnorr-like arguments over lattices. IACR Cryptol. ePrint Arch., 2021:202, 2021.</li>

      <li>APS15. Martin R. Albrecht, Rachel Player, and Sam Scott. On the concrete hardness of learning with errors. J. Mathematical Cryptology, 9(3):169–203, 2015.</li>

      <li>BBB^{+}18. Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>BBC^{+}17. Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin, Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran Tromer, and Madars Virza. Computational integrity with a public random string from quasi-linear PCPs. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part III, volume 10212 of LNCS, pages 551–579. Springer, Heidelberg, April / May 2017.</li>

      <li>BBC^{+}18. Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 669–699. Springer, Heidelberg, August 2018.</li>

      <li>BCC^{+}16. Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>BCK^{+}14. Fabrice Benhamouda, Jan Camenisch, Stephan Krenn, Vadim Lyubashevsky, and Gregory Neven. Better zero-knowledge proofs for lattice encryption and their application to group signatures. In Palash Sarkar and Tetsu Iwata, editors, ASIACRYPT 2014, Part I, volume 8873 of LNCS, pages 551–572. Springer, Heidelberg, December 2014.</li>

      <li>BCR^{+}19. Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</li>

      <li>BIN97. Mihir Bellare, Russell Impagliazzo, and Moni Naor. Does parallel repetition lower the error in computationally sound protocols? In 38th FOCS, pages 374–383. IEEE Computer Society Press, October 1997.</li>

      <li>BLNS20. Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. A non-PCP approach to succinct quantum-safe zero-knowledge. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part II, volume 12171 of LNCS, pages 441–469. Springer, Heidelberg, August 2020.</li>

      <li>CHR^{+}16. Ming-Shing Chen, Andreas Hülsing, Joost Rijneveld, Simona Samardjiska, and Peter Schwabe. From 5-pass MQ-based identification to MQ-based signatures. In Jung Hee Cheon and Tsuyoshi Takagi, editors, ASIACRYPT 2016, Part II, volume 10032 of LNCS, pages 135–165. Springer, Heidelberg, December 2016.</li>

      <li>CL10. Kai-Min Chung and Feng-Hao Liu. Parallel repetition theorems for interactive arguments. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 19–36. Springer, Heidelberg, February 2010.</li>

      <li>CP15. Kai-Min Chung and Rafael Pass. Tight parallel repetition theorems for public-coin arguments using KL-divergence. In Yevgeniy Dodis and Jesper Buus Nielsen, editors, TCC 2015, Part II, volume 9015 of LNCS, pages 229–246. Springer, Heidelberg, March 2015.</li>

    </ul>

    <p class="text-gray-300">Cra96. Ronald Cramer. Modular Design of Secure yet Practical Cryptographic Protocols. PhD thesis, CWI and University of Amsterdam, 1996.</p>

    <p class="text-gray-300">DFM20. Jelle Don, Serge Fehr, and Christian Majenz. The measure-and-reprogram technique 2.0: Multi-round fiat-shamir and more. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 602–631. Springer, Heidelberg, August 2020.</p>

    <p class="text-gray-300">DFMS19. Jelle Don, Serge Fehr, Christian Majenz, and Christian Schaffner. Security of the Fiat-Shamir transformation in the quantum random-oracle model. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part II, volume 11693 of LNCS, pages 356–383. Springer, Heidelberg, August 2019.</p>

    <p class="text-gray-300">DJMW12. Yevgeniy Dodis, Abhishek Jain, Tal Moran, and Daniel Wichs. Counterexamples to hardness amplification beyond negligible. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 476–493. Springer, Heidelberg, March 2012.</p>

    <p class="text-gray-300">DKL^{+}18. Léo Ducas, Eike Kiltz, Tancrède Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehlé. CRYSTALS-Dilithium: A lattice-based digital signature scheme. IACR TCHES, 2018(1):238–268, 2018. https://tches.iacr.org/index.php/TCHES/article/view/839.</p>

    <p class="text-gray-300">dLS19. Rafaʿel del Pino, Vadim Lyubashevsky, and Gregor Seiler. Short discrete log proofs for FHE and ring-LWE ciphertexts. In Dongdai Lin and Kazue Sako, editors, PKC 2019, Part I, volume 11442 of LNCS, pages 344–373. Springer, Heidelberg, April 2019.</p>

    <p class="text-gray-300">DOTT20. Ivan Damgård, Claudio Orlandi, Akira Takahashi, and Mehdi Tibouchi. Two-round <span class="math">n</span>-out-of-<span class="math">n</span> and multi-signatures and trapdoor commitment from lattices. Cryptology ePrint Archive, Report 2020/1110, 2020. https://eprint.iacr.org/2020/1110.</p>

    <p class="text-gray-300">ESS^{+}19. Muhammed F. Esgin, Ron Steinfeld, Amin Sakzad, Joseph K. Liu, and Dongxi Liu. Short lattice-based one-out-of-many proofs and applications to ring signatures. In ACNS, volume 11464 of Lecture Notes in Computer Science, pages 67–88. Springer, 2019.</p>

    <p class="text-gray-300">FS86. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In CRYPTO, volume 263 of Lecture Notes in Computer Science, pages 186–194. Springer, 1986.</p>

    <p class="text-gray-300">FS87. Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to identification and signature problems. In Andrew M. Odlyzko, editor, CRYPTO’86, volume 263 of LNCS, pages 186–194. Springer, Heidelberg, August 1987.</p>

    <p class="text-gray-300">GMR85. Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof-systems (extended abstract). In STOC, pages 291–304. ACM, 1985.</p>

    <p class="text-gray-300">Gol01. Oded Goldreich. Foundations of Cryptography: Basic Tools, volume 1. Cambridge University Press, Cambridge, UK, 2001.</p>

    <p class="text-gray-300">GT20. Ashrujit Ghoshal and Stefano Tessaro. Tight state-restoration soundness in the algebraic group model. Cryptology ePrint Archive, Report 2020/1351, 2020. https://eprint.iacr.org/2020/1351.</p>

    <p class="text-gray-300">HKR19. Max Hoffmann, Michael Klooß, and Andy Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2093–2110. ACM Press, November 2019.</p>

    <p class="text-gray-300">HL10. Carmit Hazay and Yehuda Lindell. Efficient Secure Two-Party Protocols - Techniques and Constructions. Information Security and Cryptography. Springer, 2010.</p>

    <p class="text-gray-300">HPWP10. Johan Håstad, Rafael Pass, Douglas Wikström, and Krzysztof Pietrzak. An efficient parallel repetition theorem. In Daniele Micciancio, editor, TCC 2010, volume 5978 of LNCS, pages 1–18. Springer, Heidelberg, February 2010.</p>

    <p class="text-gray-300">JT20. Joseph Jaeger and Stefano Tessaro. Expected-time cryptography: Generic techniques and applications to concrete soundness. In TCC (3), volume 12552 of Lecture Notes in Computer Science, pages 414–443. Springer, 2020.</p>

    <p class="text-gray-300">Lan02. Serge Lang. Algebra, volume 211 of Graduate Texts in Mathematics. Springer-Verlag New York, 3 edition, 2002.</p>

    <p class="text-gray-300">Lin03. Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computation. J. Cryptology, 16(3):143–184, 2003.</p>

    <p class="text-gray-300">LS15. Adeline Langlois and Damien Stehlé. Worst-case to average-case reductions for module lattices. Des. Codes Cryptogr., 75(3):565–599, 2015.</p>

    <p class="text-gray-300">LS18. Vadim Lyubashevsky and Gregor Seiler. Short, invertible elements in partially splitting cyclotomic rings and applications to lattice-based zero-knowledge proofs. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 204–224. Springer, Heidelberg, April / May 2018.</p>

    <p class="text-gray-300">Lyu09. Vadim Lyubashevsky. Fiat-Shamir with aborts: Applications to lattice and factoring-based signatures. In Mitsuru Matsui, editor, ASIACRYPT 2009, volume 5912 of LNCS, pages 598–616. Springer, Heidelberg, December 2009.</p>

    <p class="text-gray-300">Lyu12. Vadim Lyubashevsky. Lattice signatures without trapdoors. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 738–755. Springer, Heidelberg, April 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>LZ19. Qipeng Liu and Mark Zhandry. Revisiting post-quantum Fiat-Shamir. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part II, volume 11693 of LNCS, pages 326–355. Springer, Heidelberg, August 2019.</li>

      <li>MR09. Daniele Micciancio and Oded Regev. Lattice-based Cryptography, pages 147–191. Springer Berlin Heidelberg, 2009.</li>

      <li>PW07. Krzysztof Pietrzak and Douglas Wikström. Parallel repetition of computationally sound protocols revisited. In Salil P. Vadhan, editor, TCC 2007, volume 4392 of LNCS, pages 86–102. Springer, Heidelberg, February 2007.</li>

      <li>Sch90. Claus-Peter Schnorr. Efficient identification and signatures for smart cards. In Gilles Brassard, editor, CRYPTO’89, volume 435 of LNCS, pages 239–252. Springer, Heidelberg, August 1990.</li>

      <li>Wik18. Douglas Wikström. Special soundness revisited. Cryptology ePrint Archive, Report 2018/1157, 2018. https://eprint.iacr.org/2018/1157.</li>

    </ul>

    <p class="text-gray-300">Appendix A Compression Functions</p>

    <p class="text-gray-300">The compression mechanism <span class="math">\\Pi_{2}</span> of Section 5.2 makes uses a specific compression function. This compression allows a prover to reduce the communication complexity and it has certain extractability properties required by the knowledge extractor of <span class="math">\\Pi_{2}</span>. In this section, we generalize the notion of compression functions to large compression rates. Subsequently, we define a class of compression functions and prove that these indeed satisfy the properties required.</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">A.1 Generalized compression functions</h3>

    <h6 id="sec-78" class="text-base font-medium mt-4">Definition 18 (Extractable compression function).</h6>

    <p class="text-gray-300">Let <span class="math">M,M^{\\prime}</span> be <span class="math">\\mathcal{R}</span>-modules, such that <span class="math">M</span> is of rank <span class="math">n</span> and <span class="math">M^{\\prime}</span> of rank <span class="math">n/k</span>. Let <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> be an exceptional subset of <span class="math">\\mathcal{R}</span>. Let <span class="math">\\mathsf{Comp}=\\{\\mathsf{Comp}_{c}\\colon M\\to M^{\\prime}\\colon c\\in\\mathcal{C}\\}</span> and <span class="math">\\Phi=\\{\\Phi_{c}\\colon M^{\\prime}\\to M\\colon c\\in\\mathcal{C}\\}</span>, where <span class="math">\\Phi_{c}</span> is an <span class="math">\\mathcal{R}</span>-module homomorphism for each <span class="math">c\\in\\mathcal{C}</span>. Then, we say <span class="math">(\\mathsf{Comp},\\Phi)</span> is an <em>extractable <span class="math">k</span>-compression function</em> for <span class="math">\\mathcal{C}</span>, if the following holds: There exists maps <span class="math">\\pi_{i}\\colon M\\to M</span> for <span class="math">i\\in[2k-2]</span>, such that for all <span class="math">c\\in\\mathcal{C}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Phi_{c}(\\mathsf{Comp}_{c}(x))=\\sum_{i=1}^{k-1}c^{i-1}\\pi_{i}(x)+c^{k-1}\\cdot x+\\sum_{i=1}^{k-1}c^{k+i-1}\\cdot\\pi_{k+i-1}(x).</span></p>

    <p class="text-gray-300">We further say that <span class="math">(\\mathsf{Comp},\\Phi)</span> is <span class="math">(\\tau,\\tau^{\\prime})</span>-norm preserving, if for all <span class="math">c\\in C,x\\in M,z\\in M^{\\prime}</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Comp}_{c}(x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{ and }\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Phi_{c}(z)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau^{\\prime}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">A.2 Generalized Compression Mechanism</h3>

    <h6 id="sec-80" class="text-base font-medium mt-4">Theorem 6 (Compression Mechanism).</h6>

    <p class="text-gray-300">Let <span class="math">M,M^{\\prime},N</span> be <span class="math">\\mathcal{R}</span>-modules, such that <span class="math">M</span> has rank <span class="math">n</span> and <span class="math">M^{\\prime}</span> has rank <span class="math">n/k</span> over <span class="math">\\mathcal{R}</span>, and let <span class="math">\\Psi\\colon M\\to N</span> be an <span class="math">\\mathcal{R}</span>-module homomorphism. Let <span class="math">\\zeta\\in\\mathcal{R}</span> and let <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> be a finite <span class="math">\\zeta</span>-exceptional subset of <span class="math">\\mathcal{R}</span>, let <span class="math">(\\mathsf{Comp},\\Phi)</span> be a <span class="math">(\\tau,\\tau^{\\prime})</span>-norm preserving <span class="math">k</span>-compressing extractable compression function for <span class="math">\\mathcal{C}</span> with projection maps <span class="math">\\pi_{L},\\pi_{R}</span>, and let <span class="math">\\sigma=\\tau\\tau^{\\prime}(2w_{M}(\\mathcal{C}))^{2k^{2}}\\bar{w}_{M}(\\mathcal{C},\\zeta)^{2k^{2}-3k+1}</span>.</p>

    <p class="text-gray-300">Then, <span class="math">\\Pi_{1}</span> as given in Protocol 3 is a <span class="math">3</span>-move protocol for relations <span class="math">\\left(R(\\Psi,\\beta),R(\\Psi,\\beta\\cdot\\sigma,\\zeta^{2k^{2}-3k+1})\\right)</span> which satisfies perfect completeness and unconditional <span class="math">(2k-1)</span>-special soundness.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Completeness follows, because we have <span class="math">\\mathsf{Comp}_{c}</span> is <span class="math">\\tau</span>-preserving for all <span class="math">c\\in\\mathcal{C}</span>, i.e., $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Comp}_{c}(x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\tau\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, as required. Further, it is easy to verify that also the second verification equation will always be true for an honest prover.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(2k-1)</span>-Special Soundness: Let <span class="math">(\\{A_{i,j}\\}_{i\\in[2k-2]},c_{j},z_{j})</span> be <span class="math">2k-1</span> accepting transcripts for pairwise distinct challenges <span class="math">c_{1},\\ldots,c_{2k-1}\\in\\mathcal{C}\\subset\\mathcal{R}</span>.</p>

    <p class="text-gray-300">Let</p>

    <p class="text-gray-300"><span class="math">\\tilde{c}:=\\prod_{1\\leq j_{1}&lt;j_{2}\\leq 2k-1}(c_{j_{1}}-c_{j_{2}}).</span></p>

    <p class="text-gray-300">For <span class="math">i\\in[2k-1]</span> let</p>

    <p class="text-gray-300"><span class="math">a_{i}=(-1)^{k-1}\\cdot\\tilde{c}\\cdot\\prod_{j=1,j\\neq i}^{2k-1}(c_{i}-c_{j})^{-1}\\cdot\\sum_{1\\leq j_{1}&lt;\\ldots j_{k-1}&lt;2k-1,j_{\\ell}\\neq i}c_{j_{1}}\\cdot\\cdots\\cdot c_{j_{k-1}}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300">Protocol 3 Generic Compression Mechanism  <span class="math">\\varPi_{1}</span>  for relations  <span class="math">\\left(R(\\varPsi,\\beta),R(\\varPsi,\\beta\\cdot\\sigma,\\zeta^{2k^2-3k+1})\\right)</span> , where  <span class="math">\\sigma = \\tau\\tau&#x27;(2w_M(\\mathcal{C}))^{2k^2}\\bar{w}_M(\\mathcal{C},\\zeta)^{2k^2-3k+1}</span> . Recall that  <span class="math">(\\mathsf{Comp},\\varPhi)</span>  is a  <span class="math">(\\tau,\\tau&#x27;)</span> -norm preserving extractable compression map, i.e., for all  <span class="math">c\\in \\mathcal{C}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Phi_ {c} (\\mathsf {C o m p} _ {c} (x)) = \\sum_ {i = 1} ^ {k - 1} c ^ {i - 1} \\pi_ {i} (x) + c ^ {k - 1} \\cdot x + \\sum_ {i = 1} ^ {k - 1} c ^ {k + i - 1} \\cdot \\pi_ {k + i - 1} (x).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">INPUT(X;x) X = Ψ(x) ∈ N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ai = Ψ(πi(x))</td>

            <td class="px-3 py-2 border-b border-gray-700">{Ai}i∈[2k-2]</td>

            <td class="px-3 py-2 border-b border-gray-700">c←R C ⊂ R</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z = Compc(x)</td>

            <td class="px-3 py-2 border-b border-gray-700">←c</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">↓</td>

            <td class="px-3 py-2 border-b border-gray-700">z</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">≦ β · τ, Ψ(Φc(z)) = ∑i=1k-1Ai + ck-1 · X + ∑i=1k-1ck+i-1 · Ak+i-1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c c c c} 1 &amp;amp; 1 &amp;amp; \\ldots &amp;amp; 1 \\\\ c _ {1} &amp;amp; c _ {2} &amp;amp; \\ldots &amp;amp; c _ {2 k - 1} \\\\ c _ {1} ^ {2} &amp;amp; c _ {2} ^ {2} &amp;amp; \\ldots &amp;amp; c _ {2 k - 1} ^ {2} \\\\ \\vdots &amp;amp; \\vdots &amp;amp; &amp;amp; \\vdots \\\\ c _ {1} ^ {2 k - 2} &amp;amp; c _ {2} ^ {2 k - 2} &amp;amp; \\ldots &amp;amp; c _ {2 k - 1} ^ {2 k - 2} \\end{array} \\right) \\left( \\begin{array}{c} a _ {1} \\\\ a _ {2} \\\\ \\vdots \\\\ \\vdots \\\\ a _ {2 k - 1} \\end{array} \\right) = \\tilde {c} \\left( \\begin{array}{c} 0 \\\\ \\vdots \\\\ 1 \\\\ \\vdots \\\\ 0 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Let  <span class="math">a \\in \\mathcal{R}</span>  such that  <span class="math">a \\cdot \\tilde{c} = \\zeta^{2k^2 - 3k + 1}</span> . (Note that such an  <span class="math">a</span>  exist, because  <span class="math">\\tilde{c}</span>  is the product of  <span class="math">\\binom{2k-1}{2} = 2k^2 - 3k + 1</span>  elements in  <span class="math">\\mathcal{C}</span> , and  <span class="math">\\mathcal{C}</span>  is a  <span class="math">\\zeta</span> -exceptional subset of  <span class="math">\\mathcal{R}</span> .) Let us now define</p>

    <div class="my-4 text-center"><span class="math-block">\\bar {x} = a \\cdot \\sum_ {i = 1} ^ {2 k - 1} a _ {i} \\cdot \\Phi_ {c _ {i}} (z _ {i}) \\in M.</span></div>

    <p class="text-gray-300">It is easily seen that  <span class="math">\\varPsi(\\bar{x})=\\zeta^{2k^2-3k+1}\\cdot X</span>  and that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\bar {w} _ {M} (\\mathcal {C}, \\zeta) ^ {2 k ^ {2} - 3 k + 1} \\cdot \\sum_ {i = 1} ^ {2 k - 1} (2 w _ {M} (\\mathcal {C})) ^ {\\binom {2 k - 2} {2} - (2 k - 2)} \\cdot \\binom {2 k - 2} {k - 1} \\cdot w _ {M} (\\mathcal {C}) ^ {k - 1} \\cdot \\tau^ {\\prime} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag {10} \\\\ \\leq \\bar {w} _ {M} (\\mathcal {C}, \\zeta) ^ {2 k ^ {2} - 3 k + 1} \\cdot 2 k \\cdot (2 e) ^ {k - 1} \\cdot (2 w _ {M} (\\mathcal {C})) ^ {2 k ^ {2} - 5 k + 3} \\cdot w _ {M} (\\mathcal {C}) ^ {k - 1} \\cdot \\tau^ {\\prime} \\cdot \\beta \\cdot \\tau \\\\ \\leq \\bar {w} _ {M} (\\mathcal {C}, \\zeta) ^ {2 k ^ {2} - 3 k + 1} \\cdot (2 w (\\mathcal {C})) ^ {2 k ^ {2}} \\cdot \\tau^ {\\prime} \\cdot \\beta \\cdot \\tau , \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">which completes the proof.</p>

    <p class="text-gray-300">Example 2 ([AC20]). Let  <span class="math">M = \\mathcal{R}^n</span> ,  <span class="math">M&#x27; = \\mathcal{R}^{n/k}</span> . Then we can define</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {C o m p} _ {c} \\left(\\left(x _ {1}, \\dots , x _ {k}\\right)\\right) = \\sum_ {i = 1} ^ {k} c ^ {i - 1} x _ {i}</span></div>

    <p class="text-gray-300"><span class="math">\\Phi_{c}(z)=(c^{k-1}\\cdot z,c^{k-2}\\cdot z,\\ldots,cz,z).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If we choose the infinity norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> on </span>\\mathcal{R}<span class="math"> and we have </span>w(C)\\geq 1<span class="math">, then we obtain that </span>(\\mathsf{Comp},\\Phi)<span class="math"> is </span>(\\sum_{i=0}^{k-1}w(C)^{i},w(C)^{k-1})$-norm preserving.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More generally, if we choose the norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{p}<span class="math"> for </span>p\\in\\mathbb{N}\\cup\\{\\infty\\}<span class="math">, then we obtain that </span>(\\mathsf{Comp},\\Phi)<span class="math"> is </span>(\\sum_{i=0}^{k-1}w(C)^{i},\\sum_{i=0}^{k-1}w(C)^{i})$-norm preserving.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The corresponding projection maps can be defined as follows: Let</p>

    <p class="text-gray-300"><span class="math">f(x)=(0,\\ldots,0,x_{1},\\ldots,x_{n-n/k})</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">g(x)=(x_{n/k+1},\\ldots,x_{n},0,\\ldots,0)</span></p>

    <p class="text-gray-300">Then, <span class="math">\\pi_{i}=f^{k-i}</span>, <span class="math">\\pi_{k+i-1}=g^{i}</span> for <span class="math">i\\in[k-1]</span>.</p>

    <p class="text-gray-300">In the following we show that we can generalize this instantiation. Note that we are not aware of any instantiation of <span class="math">f</span> and <span class="math">g</span> that would give an actual efficiency improvement over the choice of <span class="math">f</span> and <span class="math">g</span> above, the abstraction in the following theorem should therefore be viewed as mostly interesting from a theoretical view point.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Proposition 1.</h6>

    <p class="text-gray-300">Let <span class="math">k,n\\in\\mathbb{N}</span> and let <span class="math">M</span> be an <span class="math">\\mathcal{R}</span>-module of rank <span class="math">n</span> and let <span class="math">\\mathcal{C}\\subset\\mathcal{R}</span> be subset of <span class="math">\\mathcal{R}</span>. Suppose <span class="math">f,g\\in\\mathrm{End}(M)</span> are such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f^{k}=g^{k}=0</span>,</li>

      <li>for all <span class="math">\\ell\\in[k-1]\\colon f^{\\ell}\\circ g^{\\ell}+g^{k-\\ell}\\circ f^{k-\\ell}=\\mathrm{Id}</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">M^{\\prime}=g^{k-1}(M)</span>. Then, <span class="math">\\dim_{\\mathcal{R}}M^{\\prime}=n/k</span> and we can obtain a compression function by setting</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Comp}_{c}(x)=g^{k-1}(F_{c}(x))</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Phi_{c}(z)=F_{c}(z),</span></p>

    <p class="text-gray-300">where <span class="math">F_{c}=\\sum_{i=1}^{k}c^{i-1}\\cdot f^{k-i}</span>.</p>

    <p class="text-gray-300">We split the proof of the proposition into a number of intermediary lemmas.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Lemma 8.</h6>

    <p class="text-gray-300">Let <span class="math">k,n\\in\\mathbb{N}</span> and let <span class="math">M</span> be an <span class="math">\\mathcal{R}</span>-module of rank <span class="math">n</span>. Suppose <span class="math">f,g\\in\\mathrm{End}(M)</span> are such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f^{k}=g^{k}=0</span>,</li>

      <li>for all <span class="math">\\ell\\in[k-1]\\colon f^{\\ell}\\circ g^{\\ell}+g^{k-\\ell}\\circ f^{k-\\ell}=\\mathrm{Id}</span>.</li>

    </ol>

    <p class="text-gray-300">Then, it holds that <span class="math">\\dim_{\\mathcal{R}}\\left(g^{k-1}(M)\\right)=n/k</span>.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By 1. it follows <span class="math">\\dim_{\\mathcal{R}}\\left(g^{k-1}(M)\\right)\\leq n/k</span>. By 2. we have <span class="math">f^{k-1}\\circ g^{k-1}+g\\circ f=\\mathrm{Id}</span> and thus <span class="math">\\dim_{\\mathcal{R}}\\left(g^{k-1}(M)\\right)+\\dim_{\\mathcal{R}}\\left(g(M)\\right)\\geq n</span>. As by 1. we also have <span class="math">\\dim_{\\mathcal{R}}\\left(g(M)\\right)\\leq n-n/k</span>, the required follows. ∎</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 9.</h6>

    <p class="text-gray-300">Let <span class="math">k,n\\in\\mathbb{N}</span> and let <span class="math">M</span> be an <span class="math">\\mathcal{R}</span>-module of rank <span class="math">n</span>. Let <span class="math">f,g\\in\\mathrm{End}(M)</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f^{k}=g^{k}=0</span>,</li>

      <li>for all <span class="math">\\ell\\in[k-1]\\colon f^{\\ell}\\circ g^{\\ell}+g^{k-\\ell}\\circ f^{k-\\ell}=\\mathrm{Id}</span>.</li>

    </ol>

    <p class="text-gray-300">Then, for all <span class="math">\\ell\\in[k]</span> :</p>

    <p class="text-gray-300"><span class="math">f^{\\ell}\\circ g^{\\ell}\\circ f^{\\ell}=f^{\\ell}.</span></p>

    <p class="text-gray-300">Proof. For any <span class="math">\\ell \\in [k]</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">f^{\\ell} \\stackrel{2.}{=} f^{\\ell} \\circ (g^{\\ell} \\circ f^{\\ell} + f^{k-\\ell} \\circ g^{k-\\ell}) \\stackrel{1.}{=} f^{\\ell} \\circ g^{\\ell} \\circ f^{\\ell}.</span></div>

    <p class="text-gray-300">Lemma 10. Let <span class="math">k, n \\in \\mathbb{N}</span> and let <span class="math">M</span> be an <span class="math">\\mathcal{R}</span>-module of rank <span class="math">n</span>. Suppose <span class="math">f, g \\in \\operatorname{End}(M)</span> are such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">f^{k} = g^{k} = 0</span></li>

      <li>for all <span class="math">\\ell \\in [k - 1]</span>: <span class="math">f^{\\ell}g^{\\ell} + g^{k - \\ell}f^{k - \\ell} = 1</span>.</li>

    </ol>

    <p class="text-gray-300">Let <span class="math">F_{c} \\coloneqq \\sum_{i=1}^{k} c^{i-1} \\cdot f^{k-i}</span>. Then, for all <span class="math">c \\in \\mathcal{R}</span>, <span class="math">x \\in M</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">F_{c}(g^{k-1}(F_{c}(x))) = \\sum_{i=1}^{k-1} c^{i-1} \\cdot f^{k-i}(x) + c^{k-1} \\cdot x + \\sum_{i=1}^{k-1} c^{k+i-1} \\cdot g^{i}(x).</span></div>

    <p class="text-gray-300">Proof. We start by rewriting the left-hand side of the equation as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} F_{c} \\circ g^{k-1} \\circ F_{c} &amp;amp;= \\sum_{j=1}^{k} c^{j-1} \\cdot f^{k-j} \\circ g^{k-1} \\circ \\left(\\sum_{i=1}^{k} c^{i-1} \\cdot f^{k-i}\\right) \\\\ &amp;amp;= \\sum_{j=1}^{k} \\sum_{i=1}^{k} c^{i+j-2} \\cdot f^{k-j} \\circ g^{k-1} \\circ f^{k-i} \\\\ &amp;amp;= \\sum_{\\ell=1}^{2k-1} c^{\\ell-1} \\cdot \\underbrace{\\sum_{i+j=\\ell+1,1 \\leq i,j \\leq k} f^{k-j} \\circ g^{k-1} \\circ f^{k-i}}_{t_{\\ell} :=} \\\\ &amp;amp;= \\sum_{\\ell=1}^{k-1} c^{\\ell-1} \\cdot t_{\\ell} + c^{k-1} \\cdot t_{k} + \\sum_{\\ell=1}^{k-1} c^{k+\\ell-1} \\cdot t_{k+\\ell}. \\end{aligned}</span></div>

    <p class="text-gray-300">In order to prove the lemma it is therefore left to show the following:</p>

    <p class="text-gray-300">i.) <span class="math">t_{\\ell} = f^{k - \\ell}</span> for <span class="math">\\ell \\in [k - 1]</span>, ii.) <span class="math">t_k = \\mathrm{Id}</span>, iii.) <span class="math">t_{\\ell + k} = g^{\\ell}</span> for <span class="math">\\ell \\in [k - 1]</span>.</p>

    <p class="text-gray-300">We first consider the first two cases, i.e., <span class="math">t_{\\ell}</span> for <span class="math">\\ell \\leq k</span>. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} t_{\\ell} &amp;amp;= \\sum_{i+j=\\ell+1,1 \\leq i,j \\leq k} f^{k-j} \\circ g^{k-1} \\circ f^{k-i} \\\\ &amp;amp;= \\sum_{i=0}^{\\ell-1} f^{k-\\ell+i} \\circ g^{k-1} \\circ f^{k-i-1} \\\\ &amp;amp;= \\sum_{i=0}^{\\ell-1} f^{k-\\ell+i} \\circ g^{i} \\circ g^{k-i-1} \\circ f^{k-i-1} \\\\ &amp;amp;\\stackrel{2.}{=} \\sum_{i=0}^{\\ell-1} f^{k-\\ell+i} \\circ g^{i} \\circ (1 - f^{i+1} \\circ g^{i+1}) \\\\ &amp;amp;\\stackrel{\\text{Lem.}}{=} 9 \\sum_{i=0}^{\\ell-1} f^{k-\\ell+i} \\circ g^{i} - f^{k-\\ell+i+1} \\circ g^{i+1} \\\\ &amp;amp;= f^{k-\\ell} \\circ g^{0} - f^{k} \\circ g^{\\ell} \\\\ &amp;amp;\\stackrel{1.}{=} f^{k-\\ell}. \\end{aligned}</span></div>

    <p class="text-gray-300">It is left to consider the last case <span class="math">t_{k+\\ell}</span> for <span class="math">\\ell \\in [k-1]</span>. Here, it holds</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} t_{k+\\ell} = &amp;amp; \\sum_{i+j=k+\\ell+1,1\\leq i,j\\leq k} f^{k-j} \\circ g^{k-1} \\circ f^{k-i} \\\\ &amp;amp; = \\sum_{i=\\ell}^{k-1} f^{-\\ell+1} \\circ g^{k-1} \\circ f^{k-i-1} \\\\ &amp;amp; \\stackrel{2.}{=} \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i}(1 - f^{i+1} \\circ g^{i+1}) \\\\ &amp;amp; = \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i} - f^{-\\ell+i} \\circ g^{-\\ell+i} \\circ g^{\\ell} \\circ f^{\\ell} \\circ f^{-\\ell+i+1} \\circ g^{i+1} \\\\ &amp;amp; \\stackrel{2.}{=} \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i} - f^{-\\ell+i} \\circ g^{-\\ell+i}(1 - f^{k-\\ell} \\circ g^{k-\\ell}) \\circ f^{-\\ell+i+1} \\circ g^{i+1} \\\\ &amp;amp; \\stackrel{2}{=} \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i} - f^{-\\ell+i+1} \\circ g^{i+1} + f^{k-\\ell} \\circ g^{k-\\ell} f^{-\\ell+i+1} \\circ g^{-\\ell+i+1} \\circ g^{\\ell} \\\\ &amp;amp; \\stackrel{2}{=} \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i} - f^{-\\ell+i+1} \\circ g^{i+1} + f^{k-\\ell} \\circ g^{k} \\\\ &amp;amp; \\stackrel{1}{=} \\sum_{i=\\ell}^{k-1} f^{-\\ell+i} \\circ g^{i} - f^{-\\ell+i+1} \\circ g^{i+1} \\\\ &amp;amp; = f^{0} \\circ g^{\\ell} - f^{k-\\ell} \\circ g^{k} \\\\ &amp;amp; \\stackrel{1}{=} g^{\\ell}, \\end{aligned}</span></div>

    <p class="text-gray-300">as required. This concludes the proof.</p>

    <h2 id="sec-87" class="text-2xl font-bold">B Composition of <span class="math">\\pmb{\\Sigma}</span>-Protocols</h2>

    <p class="text-gray-300">In order to deal with the issues arriving when composing protocols which introduce soundness slack, we separate between the relation for which the honest prover knows a witness in the end of the protocol execution, and the relation for which one can extract a witness via the special soundness.</p>

    <p class="text-gray-300"><strong>Definition 19 (Transforming Protocol).</strong> Let <span class="math">\\mathcal{R}</span> be a ring and let <span class="math">M, N, \\widetilde{M}</span> be <span class="math">\\mathcal{R}</span>-modules, and <span class="math">\\varPsi: M \\to N</span> an <span class="math">\\mathcal{R}</span>-module homomorphism. Let <span class="math">\\Pi</span> be a <span class="math">(2\\mu + 1)</span>-move public-coin protocol with challenge space <span class="math">\\mathcal{C} \\subseteq \\mathcal{R}</span>. Let <span class="math">[\\varPsi&#x27;] = \\{\\varPsi_{\\mathbf{c}}&#x27;: \\widetilde{M} \\to N \\mid \\mathbf{c} \\in \\mathcal{C}^{\\mu}\\}</span> be an ensemble of <span class="math">\\mathcal{R}</span>-module homomorphisms. Further, let <span class="math">\\beta, \\sigma \\in \\mathbb{R}_{&amp;gt;0}</span> and <span class="math">\\mathcal{T} \\in \\mathcal{R}</span>.</p>

    <p class="text-gray-300">We say a protocol <span class="math">\\Pi</span> transforms relation <span class="math">R(\\varPsi, \\alpha)</span> into <span class="math">R([\\varPsi&#x27;], \\beta)</span> and is <span class="math">(k_1, \\ldots, k_\\mu)</span>-special sound with extraction slack <span class="math">(\\sigma, \\mathcal{T})</span>, if the following holds:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A pair of honest prover and verifier <span class="math">(\\mathcal{P}, \\mathcal{V})</span> holding <span class="math">(Y; y) \\in R(\\varPsi, \\alpha)</span>, will hold some output <span class="math">(X; x)</span> with <span class="math">(X; x) \\in R(\\varPsi_{\\mathbf{c}}&#x27;, \\beta)</span> at the end of an execution of <span class="math">\\Pi</span> with challenges <span class="math">\\mathbf{c}</span>, where <span class="math">x</span> is the last message of the protocol.</li>

      <li>The verifier accepts if and only if indeed <span class="math">(X; x) \\in R(\\varPsi_{\\mathbf{c}}&#x27;, \\beta)</span>.</li>

      <li>For any <span class="math">\\beta&#x27; \\in \\mathbb{R}_{&amp;gt;0}</span>, <span class="math">\\mathcal{T}&#x27; \\in \\mathcal{R}</span>, given an <span class="math">(k_1, \\ldots, k_\\mu)</span>-tree of accepting transcripts with corresponding outputs</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(X_i; x_i) \\in R(\\varPsi_{\\mathbf{c}_i}&#x27;, \\beta&#x27;, \\mathcal{T}&#x27;),</span></div>

    <p class="text-gray-300">it is possible to extract a witness <span class="math">\\tilde{y}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">(Y; \\tilde{y}) \\in R(\\varPsi, \\sigma \\cdot \\beta&#x27;, \\mathcal{T} \\cdot \\mathcal{T}&#x27;).</span></div>

    <p class="text-gray-300">Lemma 11. If <span class="math">\\Pi</span> is a <span class="math">(2\\mu + 1)</span>-move protocol transforming relation <span class="math">R(\\Psi, \\alpha)</span> into <span class="math">R([\\Psi&#x27;], \\beta)</span> and is <span class="math">(k_1, \\ldots, k_\\mu)</span>-special sound with extraction slack <span class="math">(\\sigma, \\Upsilon)</span>, then <span class="math">\\Pi</span> is <span class="math">2\\mu + 1</span>-move protocol for relations <span class="math">(R(\\Psi, \\alpha), R(\\Psi, \\beta \\cdot \\sigma, \\Upsilon))</span> that satisfies perfect completeness and <span class="math">(k_1, \\ldots, k_\\mu)</span>-special soundness.</p>

    <p class="text-gray-300">Proof. Perfect completeness follows from the first and second property of a transforming protocol. Further, by the second property of a transforming protocol, at the end of each accepting transcript the verifier will hold a tuple <span class="math">(X; x) \\in R(\\Psi_{\\mathbf{c}}&#x27;, \\beta) = R(\\Psi_{\\mathbf{c}}&#x27;, \\beta, 1)</span>. Now, given a <span class="math">(k_1, \\ldots, k_\\mu)</span>-tree of accepting transcripts with corresponding outputs <span class="math">(X_i; x_i) \\in R(\\Psi_{\\mathbf{c}}&#x27;, \\beta, 1)</span>, by the third property of a transforming protocol, we can extract a witness <span class="math">\\tilde{y}</span> such that <span class="math">(Y; \\tilde{y}) \\in R(\\Psi, \\beta \\cdot \\sigma, \\Upsilon)</span>. This concludes the proof.</p>

    <p class="text-gray-300">Lemma 12. Let all variables be as defined in Theorem 4. Let <span class="math">[\\Psi&#x27;] = \\{\\Psi_c = \\Psi \\colon M \\to N \\mid c \\in \\mathcal{C}\\}</span> (i.e., the constant ensemble of functions <span class="math">\\Psi</span>). Then, protocol <span class="math">\\Pi_0</span> (as defined in Protocol 1) is a protocol transforming relation <span class="math">R(\\Psi, \\alpha)</span> into <span class="math">R([\\Psi&#x27;], \\beta)</span> that is is 2-special sound with extraction slack <span class="math">(2\\bar{w}_M(\\mathcal{C}, \\zeta), \\zeta)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Protocol <span class="math">\\Pi_0</span> (as defined in Protocol 1) transforms a statement <span class="math">Y</span> (with <span class="math">(Y; y) \\in R(\\Psi, \\alpha)</span>) into a statement <span class="math">X = W + cY</span>, where <span class="math">W</span> is the first message of the prover and <span class="math">c</span> is the challenge. By definition, the verifier accepts if and only if for the second prover's message <span class="math">x</span> it holds $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math"> and </span>\\Psi(x) = W + cY<span class="math">, i.e., if and only if </span>(X; x) \\in R(\\Psi, \\beta)$ as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is left to show extractability. Let <span class="math">\\Upsilon&#x27; \\in \\mathcal{R}</span> and <span class="math">\\beta&#x27; \\in \\mathbb{R}_{&amp;gt;0}</span> be arbitrary. Assume to be given <span class="math">c \\neq c&#x27; \\in \\mathcal{C}</span> and tuples <span class="math">(X = W + cY; x)</span> and <span class="math">(X&#x27; = W + c&#x27;Y; x&#x27;)</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta'<span class="math"> and </span>\\Psi(x) = \\Upsilon' \\cdot (W + cY)<span class="math"> and </span>\\Psi(x) = \\Upsilon' \\cdot (W + c'Y)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">a \\in \\mathcal{R}</span> such that <span class="math">a(c - c&#x27;) = \\zeta</span>. (Such an <span class="math">a</span> exists, because <span class="math">\\mathcal{C}</span> is assumed to be a <span class="math">\\zeta</span>-exceptional subspace of <span class="math">\\mathcal{R}</span>.) Let <span class="math">\\tilde{y} = a(x - x&#x27;)</span>. Then we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tilde{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\bar{w}(\\mathcal{C}, \\zeta)(\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x'\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\leq 2\\bar{w}(\\mathcal{C}, \\zeta)\\beta'<span class="math">. Further, we have </span>\\Psi(\\tilde{y}) = \\Psi(a(x - x')) = a \\cdot \\Upsilon' \\cdot (c - c')Y = \\zeta \\cdot \\Upsilon' \\cdot Y$, which concludes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 13. Let all variables be as defined in Theorem 5. Let <span class="math">[\\Psi&#x27;] = \\{\\Psi_c&#x27; = \\Psi \\circ \\Phi_c \\colon M&#x27; \\to N \\mid c \\in \\mathcal{C}\\}</span>. Then, protocol <span class="math">\\Pi_1</span> (as defined in Protocol 2) is a protocol transforming relation <span class="math">R(\\Psi, \\beta)</span> into relation <span class="math">R([\\Psi&#x27;], \\beta \\cdot \\tau)</span> which is 3-special sound with extraction slack <span class="math">(\\sigma&#x27;, \\zeta^3)</span>, where <span class="math">\\sigma&#x27; = 6\\tau&#x27; w_M(\\mathcal{C})^2 \\bar{w}_M(\\mathcal{C}, \\zeta)^3</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Protocol <span class="math">\\Pi_1</span> (as defined in Protocol 2) transforms a statement <span class="math">X</span> (with <span class="math">(X; x) \\in R(\\Psi, \\beta)</span>) into a statement <span class="math">Z = A + cX + c^2 B</span>, where <span class="math">A, B</span> are as defined by the first message of the prover and <span class="math">c</span> is the challenge. By definition, the verifier accepts if and only if for the second prover's message <span class="math">z</span> it holds $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\cdot \\tau<span class="math"> and </span>\\Psi(\\Phi_c(z)) = A + cX + c^2 B<span class="math">, i.e., if and only if </span>(Z; z) \\in R(\\Psi \\circ \\Phi_c, \\beta \\cdot \\tau)$ as required.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is left to show extractability. Let <span class="math">\\Upsilon&#x27; \\in \\mathcal{R}</span> and <span class="math">\\beta&#x27; \\in \\mathbb{R}_{&amp;gt;0}</span> be arbitrary. Assume to be given pairwise distinct challenges <span class="math">c_1, c_2, c_3 \\in \\mathcal{C}</span> and pairs <span class="math">(Z_1 = A + c_1X + c_1^2B; z_1)</span>, <span class="math">(Z_2 = A + c_2X + c_2^2B; z_2)</span> and <span class="math">(Z_3 = A + c_3X + c_3^2B; z_3)</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z_3\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta'<span class="math"> and </span>\\Psi(\\Phi_{c_1}(z_1)) = \\Upsilon' \\cdot (A + c_1X + c_1^2B)<span class="math">, </span>\\Psi(\\Phi_{c_2}(z_1)) = \\Upsilon' \\cdot (A + c_2X + c_2^2B)<span class="math"> and </span>\\Psi(\\Phi_{c_3}(z_1)) = \\Upsilon' \\cdot (A + c_3X + c_3^2B)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let</p>

    <div class="my-4 text-center"><span class="math-block">(a_1, a_2, a_3) = (c_3^2 - c_2^2, c_1^2 - c_3^2, c_2^2 - c_1^2).</span></div>

    <p class="text-gray-300">Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{ccc} 1 &amp;amp; 1 &amp;amp; 1 \\\\ c_1 &amp;amp; c_2 &amp;amp; c_3 \\\\ c_1^2 &amp;amp; c_2^2 &amp;amp; c_3^2 \\end{array} \\right) \\left( \\begin{array}{c} a_1 \\\\ a_2 \\\\ a_3 \\end{array} \\right) = \\tilde{c} \\left( \\begin{array}{c} 0 \\\\ 1 \\\\ 0 \\end{array} \\right),</span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{c} = (c_1 - c_2)(c_1 - c_3)(c_2 - c_3) \\in \\mathcal{R}^*</span>.</p>

    <p class="text-gray-300">Let <span class="math">a</span> such that <span class="math">a \\cdot \\tilde{c} = \\zeta^3</span> (such an <span class="math">a</span> exists because <span class="math">\\mathcal{C}</span> is <span class="math">\\zeta</span>-exceptional) and let</p>

    <div class="my-4 text-center"><span class="math-block">\\tilde{x} = a \\cdot \\sum_{i=1}^{3} a_i \\cdot \\Phi_{c_i}(z_i) \\in M.</span></div>

    <p class="text-gray-300">Then, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\Psi(\\tilde{x}) = a \\cdot \\sum_{i=1}^{3} a_i \\cdot \\Psi(\\Phi_{c_i}(z_i)) = a \\cdot \\sum_{i=1}^{3} a_i (A + c_i X + c_i^2 B) = a \\cdot \\Upsilon&#x27; \\cdot (0 \\cdot A + \\tilde{c} \\cdot X + 0 \\cdot B) = \\zeta^3 \\cdot \\Upsilon&#x27; \\cdot X.</span></div>

    <p class="text-gray-300">Further, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar {x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\bar {w} _ {M} (\\mathcal {C}, \\zeta) ^ {3} \\cdot \\sum_ {i = 1} ^ {3} 2 \\cdot w _ {M} (\\mathcal {C}) ^ {2} \\cdot \\tau^ {\\prime} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 6 \\cdot \\bar {w} _ {M} (\\mathcal {C}, \\zeta) ^ {3} \\cdot w _ {M} (\\mathcal {C}) ^ {2} \\cdot \\tau^ {\\prime} \\cdot \\beta^ {\\prime} = \\beta^ {\\prime} \\cdot \\sigma^ {\\prime},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">\\sigma&#x27; = 6\\tau&#x27;w_{M}(\\mathcal{C})^{2}\\bar{w}_{M}(\\mathcal{C},\\zeta)^{3}</span> . This concludes the proof.</p>

    <p class="text-gray-300">☐</p>

    <p class="text-gray-300"><strong>Definition 20 (Composition of Transforming Protocols).</strong> Let  <span class="math">\\mathcal{R}</span>  be a ring and let  <span class="math">M, N, \\widetilde{M}, \\widetilde{M}&#x27;</span>  be  <span class="math">\\mathcal{R}</span> -modules, and  <span class="math">\\Psi \\colon M \\to N</span>  an  <span class="math">\\mathcal{R}</span> -module homomorphism. Let  <span class="math">\\mathcal{C} \\subseteq \\mathcal{R}</span> . Let  <span class="math">[\\Psi&#x27;] = \\{\\Psi_{\\mathbf{c}}&#x27; \\colon \\widetilde{M} \\to N \\mid \\mathbf{c} \\in \\mathcal{C}^{\\ell}\\}</span> , and for each  <span class="math">\\mathbf{c} \\in \\mathcal{C}^{\\ell}</span>  let  <span class="math">[\\Psi_{\\mathbf{c}}&#x27;&#x27;] = \\{\\Psi_{\\mathbf{c},\\mathbf{c}&#x27;}&#x27; \\colon \\widetilde{M}&#x27; \\to N \\mid \\mathbf{c} \\in \\mathcal{C}^{\\ell&#x27;}\\}</span>  be ensembles of  <span class="math">\\mathcal{R}</span> -module homomorphisms.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pi</span>  be an  <span class="math">(2\\ell + 1)</span> -move public-coin protocol that transforms relation  <span class="math">R(\\Psi, a)</span>  into  <span class="math">R([\\Psi&#x27;], \\beta)</span>  and is  <span class="math">(k_1, \\ldots, k_\\ell)</span> -special sound with extraction slack  <span class="math">(\\sigma, \\Upsilon)</span> . For each  <span class="math">\\mathbf{c} \\in \\mathcal{C}^\\ell</span> , let  <span class="math">\\Pi_{\\mathbf{c}}&#x27;</span>  be a  <span class="math">(2\\ell&#x27; + 1)</span> -move public-coin protocol that transforms relations  <span class="math">R(\\Psi_{\\mathbf{c}}&#x27;, \\beta)</span>  into relation  <span class="math">R([\\Psi_{\\mathbf{c}}&#x27;&#x27;, \\gamma)</span>  and is  <span class="math">(k_1&#x27;, \\ldots, k_{\\ell&#x27;}&#x27;)</span>  sound with extraction slack  <span class="math">(\\sigma&#x27;, \\Upsilon&#x27;)</span> .</p>

    <p class="text-gray-300">Then we define the composition  <span class="math">\\Pi \\circ \\Pi&#x27;</span>  of  <span class="math">\\Pi</span>  and  <span class="math">\\Pi&#x27; = \\{\\Pi_{\\mathbf{c}} \\mid \\mathbf{c} \\in \\mathcal{C}^{\\ell}\\}</span>  as the protocol that is obtained by first running  <span class="math">\\Pi</span>  on input  <span class="math">(Y; y)</span>  and  <span class="math">Y</span> , and then instead of sending the last message  <span class="math">x</span> , running  <span class="math">\\Pi_{\\mathbf{c}}&#x27;</span>  on  <span class="math">(X; x)</span>  and  <span class="math">X</span> , where  <span class="math">\\mathbf{c} \\in \\widetilde{C}^{\\ell}</span>  are the  <span class="math">\\ell</span>  challenges of the first run.</p>

    <p class="text-gray-300"><strong>Theorem 7 (Composition Theorem).</strong> Let all parameters as defined in Definition 20.</p>

    <p class="text-gray-300">Then,  <span class="math">\\Pi \\circ \\Pi&#x27;</span>  is a protocol that transforms relation  <span class="math">R(\\Psi, \\alpha)</span>  into relation  <span class="math">R([\\Psi&#x27;&#x27;, \\gamma)</span>  and is  <span class="math">(k_1, \\ldots, k_\\ell, k_1&#x27;, \\ldots, k_{\\ell&#x27;}&#x27;)</span>  sound with extraction slack  <span class="math">(\\sigma \\cdot \\sigma&#x27;, \\Upsilon \\cdot \\Upsilon&#x27;)</span> .</p>

    <p class="text-gray-300">Further, if  <span class="math">\\Pi</span>  satisfies (non-abort) special honest verifier zero-knowledge, then so does  <span class="math">\\Pi \\circ \\Pi&#x27;</span> .</p>

    <p class="text-gray-300"><strong>Proof.</strong> Transforming Protocol. First, we have to show that the protocol  <span class="math">\\Pi \\circ \\Pi&#x27;</span>  indeed satisfies all three required properties of a transforming protocol. It is easy to see that the first and second property indeed hold: Let  <span class="math">\\mathbf{c} \\in \\mathcal{C}^{\\ell}</span>  and  <span class="math">\\mathbf{c}&#x27; \\in \\mathcal{C}^{\\ell&#x27;}</span>  be the challenges sampled by the verifier. If  <span class="math">(P, V)</span>  in the beginning hold  <span class="math">(Y; y)</span>  and  <span class="math">y</span>  with  <span class="math">(Y; y) \\in R(\\Psi, \\alpha)</span> , then after running  <span class="math">\\Pi</span>  the parties hold  <span class="math">(X; x)</span>  and  <span class="math">X</span>  with  <span class="math">(X; x) \\in R(\\Psi_{\\mathbf{c}}&#x27;, \\beta)</span> . Therefore, after running  <span class="math">\\Pi_{\\mathbf{c}&#x27;}&#x27;</span>  on  <span class="math">(X; x)</span>  and  <span class="math">x</span> , the parties obtain  <span class="math">(X&#x27;; x&#x27;) \\in R(\\Psi_{(\\mathbf{c}, \\mathbf{c}&#x27;)}&#x27;&#x27;, \\gamma)</span> , as required. Further, as  <span class="math">V</span>  will accept the final message if and only if indeed  <span class="math">(X&#x27;; x&#x27;) \\in R(\\Psi_{(\\mathbf{c}, \\mathbf{c}&#x27;)}&#x27;&#x27;, \\gamma)</span> , the second property follows.</p>

    <p class="text-gray-300"><strong>Extractability.</strong> Assume to be given a  <span class="math">(k_{1},\\ldots ,k_{\\ell},k_{1}^{\\prime},\\ldots ,k_{\\ell^{\\prime}}^{\\prime})</span>  -tree of accepting transcripts, i.e., where the leafs correspond to outputs  <span class="math">(X_{i,j}^{\\prime};x_{i,j}^{\\prime})\\in R(\\Psi_{(\\mathbf{c}_{i},\\mathbf{c}_{i,j}^{\\prime})}^{\\prime \\prime},\\gamma)</span>  (for  <span class="math">i\\in [\\prod_{i = 1}^{\\ell}k_i],j\\in [\\prod_{i = 1}^{\\ell &#x27;}k_i&#x27;]</span> ). Then, by the extractability of  <span class="math">\\varPi^{\\prime}</span>  for each  <span class="math">i</span>  one can extract an output  <span class="math">(X_{i};x_{i})\\in R(\\varPsi_{\\mathbf{c}_{i}}^{\\prime},\\sigma^{\\prime}\\cdot \\gamma ,\\varUpsilon^{\\prime})</span>  corresponding to a leaf in the subtree tree of  <span class="math">(k_{1},\\dots ,k_{\\ell})</span>  -accepting transcript. Now, by the extractability of  <span class="math">\\varPi</span> , we can extract an output  <span class="math">(X;x)\\in R(\\varPsi_{\\mathbf{c}_i}^{\\prime},\\sigma \\cdot \\sigma^{\\prime}\\cdot \\gamma ,\\varUpsilon \\cdot \\varUpsilon^{\\prime})</span> , as required.</p>

    <p class="text-gray-300"><strong>SHVZK.</strong> We can simulate a transcript for  <span class="math">\\varPi\\circ\\varPi^{\\prime}</span>  as follows: First, the simulator uses the simulator of  <span class="math">\\varPi</span>  to simulate the first half of the transcript. If the protocol does not abort, by the first property of the protocol this implies that the simulator successfully produced  <span class="math">(X;x)</span>  with  <span class="math">(X;x)\\in R(\\varPsi_{\\mathbf{c}}^{\\prime},\\beta)</span>  (with distribution statistically close to an honest execution). Instead of setting  <span class="math">x</span>  to be the last message of the protocol, the simulator can now proceed like an honest prover with input  <span class="math">(X;x)</span>  to simulate  <span class="math">\\varPi_{\\mathbf{c}}^{\\prime}</span> . Obviously, if the first part of the protocol is statistically close to an honest execution, so is the second. This concludes the proof.</p>

    <p class="text-gray-300">☐</p>

    <h2 id="sec-88" class="text-2xl font-bold">C Lattice-Based Circuit Satisfiability Argument</h2>

    <p class="text-gray-300">In this section, we first give the complete description of the linearization approach presented in Section 7.2. This protocol allows a prover to prove knowledge of a secret vector  <span class="math">\\mathbf{x} \\in \\mathcal{R}_p^n</span>  such that  <span class="math">C(\\mathbf{x}) = 0</span> . The resulting protocol uses compressed  <span class="math">\\Sigma</span> -protocol  <span class="math">\\Lambda_{\\mathrm{comp}}(\\eta)</span>  in a black-box manner. Subsequently, we describe the adaptations required when the largest exceptional subset of  <span class="math">\\mathcal{R}_p</span>  is "too small".</p>

    <p class="text-gray-300">The linearization approach, denoted by  <span class="math">\\varLambda_{cs}(\\eta)</span> , is described in Protocol 4. Its properties are summarized in Theorem 8. As before,  <span class="math">\\eta \\in \\mathbb{N}</span>  is a parameter allowing for a trade-off between the completeness error and the communication complexity. In this circuit satisfiability argument it is crucial that the approximation factor  <span class="math">\\zeta</span>  is invertible in  <span class="math">\\mathcal{R}_p</span> .</p>

    <p class="text-gray-300">Theorem 8 ( <span class="math">\\mathcal{R}_p</span> -Circuit Satisfiability Argument). Let  <span class="math">n, r, m, \\mu, \\eta \\in \\mathbb{N}</span>  such that  <span class="math">n + r + 2m + 3 = 2^{\\mu}</span>  and let  <span class="math">p, q \\in \\mathbb{N}</span>  be primes. Let  <span class="math">\\mathcal{R} = \\mathbb{Z}[X] / f(X)</span>  for a monic and irreducible polynomial  <span class="math">f(X) \\in \\mathbb{Z}[X]</span>  of degree  <span class="math">d</span> . Further, let  <span class="math">\\zeta \\in \\mathcal{R}</span>  such that  <span class="math">\\zeta \\in \\mathcal{R}_p^*</span>  and let  <span class="math">\\mathcal{C}</span>  be a  <span class="math">\\zeta</span> -exceptional subset of  <span class="math">\\mathcal{R}</span> . Let  <span class="math">\\mathrm{COM}: \\mathcal{R}_p^n \\times \\mathcal{R}_p^r \\to \\mathcal{R}_q^k, (\\mathbf{x}, \\gamma) \\mapsto A_1\\gamma + A_2\\mathbf{x}</span>  be the commitment scheme form Definition 13. Then  <span class="math">\\Lambda_{cs}(\\eta)</span>  is a  <span class="math">(2\\mu + 5)</span> -move protocol for relation</p>

    <p class="text-gray-300"><span class="math">R_{cs} = \\{(C;\\mathbf{x}):C:\\mathcal{R}_p^n\\to \\mathcal{R}_p</span>  a circuit with  <span class="math">m</span>  multiplication gates,  <span class="math">C(\\mathbf{x}) = 0\\}</span></p>

    <p class="text-gray-300">It is computationally  <span class="math">(2m + 1,2,3,\\ldots ,3)</span> -special sound, under the assumption that the commitment scheme is binding (with respect to relaxed openings), non-abort special honest-verifier zero-knowledge and complete with completeness error</p>

    <div class="my-4 text-center"><span class="math-block">\\delta \\leq 1 - e ^ {- \\frac {w (\\mathcal {C}) p (n + r + 2 m + 3) d}{2 \\eta + 1}}.</span></div>

    <p class="text-gray-300">Moreover, the communication costs are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P} \\to \\mathcal{V}</span> :  <span class="math">2\\mu + 2</span>  elements of  <span class="math">R_q^k</span> ,  <span class="math">2\\mu + 4</span>  elements of  <span class="math">\\mathcal{R}_p</span>  and  <span class="math">1</span>  element of  <span class="math">\\mathcal{R}</span> .</li>

      <li><span class="math">\\mathcal{V} \\to \\mathcal{P}</span> :  <span class="math">\\mu + 2</span>  elements of  <span class="math">\\mathcal{C}</span> .</li>

    </ul>

    <p class="text-gray-300">Protocol 4  <span class="math">\\mathcal{R}_p</span> -Circuit satisfiability argument  <span class="math">\\varLambda_{cs}(\\eta)</span>  for the relation  <span class="math">R_{cs}</span></p>

    <p class="text-gray-300">The polynomials  <span class="math">F</span>  and  <span class="math">G</span>  are sampled uniformly at random such that their evaluations in  <span class="math">s_1, \\ldots, s_m \\in S_p \\subset \\mathcal{R}_p</span>  coincide with the left and, respectively, right inputs of the  <span class="math">m</span>  multiplication gates of  <span class="math">C</span>  evaluated at  <span class="math">\\mathbf{x}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">C.2 Handling Small Primes when Proving Non-Linear Relations</p>

    <p class="text-gray-300">In Section 7, it was shown how to prove that committed vectors with coefficients in <span class="math">\\mathcal{R}_{p}=\\mathbb{Z}[X]/(p,f(X))</span> satisfy non-linear constraints. However, this approach requires that <span class="math">p^{D}</span> is “large enough”, where <span class="math">D</span> is the minimum of the degrees of the irreducible factors of <span class="math">f(X)</span> modulo <span class="math">p</span>. More precisely, we require <span class="math">2m/(p^{D}-m)</span> to be in the same order of magnitude as the knowledge error of compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\text{comp}}</span>. In this section we consider the case that <span class="math">p^{D}</span> is too small, e.g., <span class="math">p^{D}\\leq 3m</span>. In this case the linearization approach of Section 7 does not work. We show how to handle this scenario by applying Shamir’s secret sharing scheme over an appropriate ring extension.</p>

    <p class="text-gray-300">Let <span class="math">g(Y)\\in\\mathcal{R}[Y]</span> be a polynomial of degree <span class="math">k</span> that is irreducible modulo <span class="math">p</span> and let <span class="math">\\mathcal{R}^{\\prime}=\\mathcal{R}[Y]/(g(Y))</span> be a degree <span class="math">k</span> ring extension of <span class="math">\\mathcal{R}</span>. Then it is easily seen that the largest exceptional subset <span class="math">\\mathcal{S}^{\\prime}_{p}</span> of <span class="math">\\mathcal{R}^{\\prime}_{p}</span> has cardinality <span class="math">p^{kD}</span>. Let us write <span class="math">\\mathcal{S}^{\\prime}_{p}=\\{s^{\\prime}_{0},\\ldots,s^{\\prime}_{p^{kD}-1}\\}</span>. The linearization approach is adapted by defining the packed secret sharings over the ring extension <span class="math">\\mathcal{R}^{\\prime}_{p}</span> instead of over <span class="math">\\mathcal{R}_{p}</span>.</p>

    <p class="text-gray-300">Let us first introduce some notation. For a vector <span class="math">\\mathbf{x}=(x_{1},\\ldots,x_{k+m})\\in\\mathcal{R}^{k+m}_{p}</span>, we let <span class="math">F_{\\mathbf{x}}(Z)\\in\\mathcal{R}^{\\prime}_{p}[Z]</span> be the unique polynomial of degree at most <span class="math">m</span> that satisfies <span class="math">F(s^{\\prime}_{0})=\\sum_{i=1}^{k}x_{i}Y^{i-1}\\in\\mathcal{R}^{\\prime}_{p}</span> and <span class="math">F(s^{\\prime}_{j})=x_{j+k}\\in\\mathcal{R}^{\\prime}_{p}</span> for all <span class="math">1\\leq j\\leq m</span>. Since the set <span class="math">\\mathcal{S}^{\\prime}_{p}</span> is exceptional, this polynomial is well-defined. Moreover, by Lagrange interpolation the following map is <span class="math">\\mathcal{R}_{p}</span>-linear</p>

    <p class="text-gray-300"><span class="math">L_{1}:\\mathcal{R}^{k+m}_{p}\\to\\mathcal{R}^{\\prime}_{p}[Z],\\qquad\\mathbf{x}\\mapsto F_{\\mathbf{x}}(Z).</span></p>

    <p class="text-gray-300">Furthermore, for a polynomial <span class="math">F(Z)\\in\\mathcal{R}^{\\prime}_{p}[Z]</span> evaluated in <span class="math">\\rho\\in\\mathcal{R}^{\\prime}_{p}</span>, we write <span class="math">F(\\rho)=\\sum_{i=1}^{k}F_{i}(\\rho)Y^{i-1}</span> with <span class="math">F_{i}(\\rho)\\in\\mathcal{R}_{p}</span> for all <span class="math">1\\leq i\\leq k</span>.</p>

    <p class="text-gray-300">We continue to describe the linearization approach over the ring extension <span class="math">\\mathcal{R}^{\\prime}_{p}</span>. As before, let <span class="math">\\mathbf{a}(\\mathbf{x}),\\mathbf{b}(\\mathbf{x})\\in\\mathcal{R}^{m}_{p}</span> be the vectors of left and right input values of the <span class="math">m</span> multiplication of the circuit <span class="math">C:\\mathcal{R}^{n}_{p}\\to\\mathcal{R}_{p}</span> evaluated in <span class="math">\\mathbf{x}\\in\\mathcal{R}^{n}_{p}</span>. Similarly, let <span class="math">\\mathbf{c}(\\mathbf{x})\\in\\mathcal{R}^{m}_{p}</span> represent the values of the output wires of the multiplication gates. The generalized linearization strategy now goes as follows. The prover samples <span class="math">r_{1}=\\sum_{i=1}^{k}r_{1,i}Y^{i-1}\\in\\mathcal{R}^{\\prime}_{p}</span> and <span class="math">r_{2}=\\sum_{i=1}^{k}r_{2,i}Y^{i-1}\\in\\mathcal{R}^{\\prime}_{p}</span> uniformly at random, and defines the polynomials</p>

    <p class="text-gray-300"><span class="math">F(Z)</span> <span class="math">=L_{1}(r_{1,1},\\ldots,r_{1,k},\\mathbf{a}(\\mathbf{x}))\\in\\mathcal{R}^{\\prime}_{p}[Z],</span> <span class="math">G(Z)</span> <span class="math">=L_{1}(r_{2,1},\\ldots,r_{2,k},\\mathbf{b}(\\mathbf{x}))\\in\\mathcal{R}^{\\prime}_{p}[Z].</span></p>

    <p class="text-gray-300">As before, <span class="math">F(Z)</span> and <span class="math">G(Z)</span> define packed secret sharings of <span class="math">\\mathbf{a}</span> and <span class="math">\\mathbf{b}</span> with 1-privacy, but now over the ring extension <span class="math">\\mathcal{R}^{\\prime}_{p}</span>. Note that, this approach guarantees the secret vectors <span class="math">\\mathbf{a}(\\mathbf{x})</span> and <span class="math">\\mathbf{b}(\\mathbf{x})</span> to have coefficients in the base ring <span class="math">\\mathcal{R}_{p}</span>. Only the random elements <span class="math">r_{1}</span> and <span class="math">r_{2}</span> are not necessarily contained in <span class="math">\\mathcal{R}_{p}</span>.</p>

    <p class="text-gray-300">Subsequently, the prover defines the product polynomial <span class="math">H(Z)=F(Z)G(Z)\\in\\mathcal{R}^{\\prime}_{p}[Z]</span> of degree at most <span class="math">2m</span>. As before, it follows that <span class="math">H(s^{\\prime}_{i})=\\mathbf{c}(\\mathbf{x})_{i}\\in\\mathcal{R}_{p}</span> for all <span class="math">1\\leq i\\leq m</span>. Then, the prover commits to the vector</p>

    <p class="text-gray-300"><span class="math">\\mathbf{y}=(\\mathbf{x},\\mathbf{c},F_{1}(s^{\\prime}_{0}),\\ldots,H_{k}(s^{\\prime}_{0}),H_{1}(s^{\\prime}_{m+1}),\\ldots,H_{k}(s^{\\prime}_{2m}))\\in\\mathcal{R}^{n+(k+1)m+3k}_{p}.</span></p>

    <p class="text-gray-300">Since the mapping <span class="math">L_{1}</span> is linear, it is easily seen that for any <span class="math">\\rho\\in\\mathcal{R}^{\\prime}_{p}</span> there exist linear mappings <span class="math">L_{F(\\rho)},L_{G(\\rho)},L_{H(\\rho)}:\\mathcal{R}^{n+(k+1)m+3k}_{p}\\to\\mathcal{R}^{k}_{p}</span> such that</p>

    <p class="text-gray-300"><span class="math">F(\\rho)</span> <span class="math">=\\sum_{i=1}^{k}L_{F(\\rho)}(\\mathbf{y})Y^{i-1},</span> <span class="math">G(\\rho)</span> <span class="math">=\\sum_{i=1}^{k}L_{G(\\rho)}(\\mathbf{y})Y^{i-1},</span> <span class="math">H(\\rho)</span> <span class="math">=\\sum_{i=1}^{k}L_{H(\\rho)}(\\mathbf{y})Y^{i-1}.</span></p>

    <p class="text-gray-300">In</p>

    <p class="text-gray-300">By a black-box application of compressed <span class="math">\\Sigma</span>-protocol <span class="math">\\Lambda_{\\mathrm{comp}}</span> and given a commitment to <span class="math">\\mathbf{y}</span>, the prover opens <span class="math">F(\\rho)</span>, <span class="math">G(\\rho)</span> and <span class="math">H(\\rho)</span> for an evaluation point <span class="math">\\rho \\in S_p&#x27; \\setminus \\{s_1&#x27;, \\ldots, s_m&#x27;\\}</span> sampled uniformly at random by the verifier. The verifier checks that <span class="math">H(\\rho) = F(\\rho)G(\\rho)</span>. For a dishonest prover, this verification succeeds with probability at most <span class="math">2m / (p^{kD} - m)</span>. Hence, by choosing the degree <span class="math">k</span> of the ring extension <span class="math">\\mathcal{R}_p&#x27; / \\mathcal{R}_p</span> large enough the success probability of a dishonest prover can be made arbitrarily small.</p>`;
---

<BaseLayout title="A Compressed $\Sigma$-Protocol Theory for Lattices (2021/307)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/307
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
