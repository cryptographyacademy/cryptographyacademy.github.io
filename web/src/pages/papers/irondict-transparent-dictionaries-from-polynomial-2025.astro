---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/1580';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'IronDict: Transparent Dictionaries from Polynomial Commitments';
const AUTHORS_HTML = 'Hossein Hafezi, Alireza Shirzad, Benedikt Bünz, Joseph Bonneau';

const CONTENT = `    <p class="text-gray-300">IRONDICT: Transparent Dictionaries from Polynomial Commitments</p>

    <p class="text-gray-300">Hossein Hafezi<span class="math">^{1}</span>, Alireza Shirzad<span class="math">^{2}</span>, Benedikt Bünz<span class="math">^{3}</span>, and Joseph Bonneau<span class="math">^{4}</span></p>

    <p class="text-gray-300"><span class="math">^{1,3,4}</span>New York University</p>

    <p class="text-gray-300"><span class="math">^{2}</span>University of Pennsylvania</p>

    <h2 id="sec-1" class="text-2xl font-bold">Abstract</h2>

    <p class="text-gray-300">We present IRONDICT, a transparent dictionary construction based on polynomial commitment schemes. Transparent dictionaries enable an untrusted server to maintain a mutable dictionary and provably serve clients lookup queries. A major open challenge is supporting efficient auditing by lightweight clients. Previous solutions either incurred high server costs (limiting throughput) or high client lookup verification costs, hindering them from modern messaging key transparency deployments with billions of users. Our construction makes black-box use of a generic multilinear polynomial commitment scheme and inherits its security notions, i.e. binding and zero-knowledge. We implement our construction with the recent KZH scheme and find that a dictionary with 1 billion entries can be verified on a consumer-grade laptop in 35 ms, a <span class="math">300\\times</span> improvement over the state of the art, while also achieving <span class="math">150,000\\times</span> smaller proofs (8 kB). In addition, our construction ensures perfect privacy with concretely efficient costs for both the client and the server. We also show fast-forwarding techniques based on incremental verifiable computation (IVC) and checkpoints to enable even faster client auditing.</p>

    <p class="text-gray-300"><span class="math">^{1}</span>Equal contribution</p>

    <p class="text-gray-300"><span class="math">^{1}</span>Work primarily conducted at IMDEA Software.</p>

    <p class="text-gray-300"><span class="math">^{2}</span>Work partially conducted at Lagrange Labs.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Many essential services, such as financial systems or messaging platforms, are operated by centralized servers with little accountability. Fully decentralized systems often fall short in practice for performance, cost, privacy or other reasons. As a more pragmatic alternative, some traditionally centralized systems have adopted cryptographic <em>transparency</em> to offer increased assurance to the public that they are operating correctly while maintaining their performance benefits. For example, WhatsApp, an encrypted messaging platform with billions of users, rolled out transparency logs for its key-distribution servers in 2024 <em>[x10]</em>. Transparency systems ensure all actions by a central server are publicly visible and enable clients to monitor these actions. For example, in the secure messaging context <em>[x16]</em>, a transparency log ensures clients can observe all public keys the server has advertised for their username (though it cannot prevent the server from advertising maliciously chosen keys). Implicitly, transparency systems assume a <em>malicious-but-cautious</em> adversary model <em>[x17]</em>. That is, making server misbehavior <em>detectable</em> deters misconduct by imposing the risk of reputation damage or legal liability. Transparency has been proposed in a number of contexts, including public-key distribution in encrypted messaging systems <em>[x17, x1, x11, x12, x3, x1, x13]</em>, distribution of software binaries <em>[x5, x6, x7, x11, x14]</em>, and certificate authorities via the Certificate Transparency (CT) protocol <em>[x15, x4, x9, x10]</em>. All of these applications can utilize a <em>transparent dictionary</em>, a cryptographic data structure that supports verifiable queries over a publicly committed dictionary, i.e. a mapping from a set of labels to a set of values. A transparent dictionary typically involves three logical entities:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <em>Server</em> is a centralized service provider that maintains a mutable dictionary and periodically publishes <em>commitments</em> to a public bulletin board. Publication occurs at regular time period or <em>epochs</em> (e.g., once every hour). The server also responds to client and auditor queries.</li>

      <li><em>Auditors</em> monitor the bulletin board and ensure that the dictionary is well-formed and maintains promised <em>global invariants</em> across epochs.</li>

      <li><em>Clients</em> issue lookup queries to the server to retrieve values associated with labels of interest (e.g. contacts they wish to message). Clients also monitor their own label and may perform auditing of invariants.</li>

    </ul>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Motivating application: key transparency.</h4>

    <p class="text-gray-300">An important application of transparent dictionaries is <em>key transparency</em> <em>[x11]</em>, in which the server maintains a dictionary, mapping user identities—such as email addresses or usernames—to their public keys. Key transparency promises a practical solution to the age-old challenge of key distribution for encrypted communication systems <em>[x16]</em>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">It is vital for security that a user can monitor the dictionary at <em>all</em> epochs. Otherwise, while a user is offline, a malicious server could insert a malicious public key (enabling impersonation) and later revert the change to avoid detection. This is known as an <em>oscillation attack</em> <em>[x19]</em>. Hence, key transparency systems should support an efficient mechanism to verify that their public key has remained unchanged throughout multiple epochs during which they were offline. Another important goal is privacy <em>[x5]</em>. The server’s commitments and proofs should reveal nothing about other users (as an update might indicate a lost device) or system-wide details such as the rate of churn. Note that privacy may not be a concern in other applications, such as software transparency, in which all information is considered public. Scale is another vital concern, as popular platforms are now used by billions of users <em>[x26]</em>.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Constructions based on Merkle trees.</h5>

    <p class="text-gray-300">Most transparent dictionary constructions are based on Merkle trees <em>[x16, x1, x11, x12, x1, x14]</em>. This enables concretely fast operations for both servers and clients, as the only primitive needed is a collision-resistant hash function (typically SHA-256 or SHA-3). However, a major drawback is that auditors’ costs scale linearly with the number of updates per epoch, requiring auditors to perform roughly as much computation as the server itself. As a result, client auditing is infeasible in large deployments. Instead, today’s deployments rely on third-party auditors such as non-profit watchdog organizations <em>[x23]</em>. At current throughput, auditing WhatsApp’s key transparency server requires hashing 200 MB of data every 5 minutes, which is impractical for end users <em>[x6]</em>.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">Constructions from algebraic accumulators.</h5>

    <p class="text-gray-300">Merkle trees are one construction of a cryptographic <em>accumulator</em> or <em>set commitment</em>. Transparent dictionaries can also be built from other cryptographic accumulators. Bilinear accumulators <em>[x27, x11, x12]</em>, for example, offer smaller concrete proof sizes for lookups but are generally impractical due to their high storage and computational overhead. For instance, Tomescu et al. <em>[x27]</em> report that supporting a dictionary of size <span class="math">2^{20}</span> would require hundreds of gigabytes of storage. VeRSA <em>[x28]</em> proposed transparent dictionaries based on RSA accumulators <em>[x3, x29, x28]</em>. Like our approach, VeRSA supports efficiently verifying batches of updates. VeRSA offers attractive features: its audit procedure is independent of the epoch size, enabling self-auditing by clients. However, generating lookup proofs with VeRSA is concretely expensive and scales linearly with the dictionary size, limiting its applicability to dictionaries of size in the millions (such as binary transparency scenarios), not billions. Many algebraic accumulators also require a setup (possibly trusted) with large public parameters. This drawback also applies to IronDict when instantiated with KZH, which requires a linear-sized <em>structured reference string</em>. We discuss this further in Sections 3.1 and 5.4.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Reducing auditing costs. Some works [Che+20; Tzi+22; Ros+24] have attempted to make client-auditing feasible by delegating auditing to an untrusted party—often the server itself—using SNARKs to prove correctness. In practice, the computational cost of generic SNARK-based designs limits throughput. For example, due to the high cost of SHA-256 in zero-knowledge circuits, Hekaton [Ros+24] only achieved a throughput of 10 updates per second on a powerful cluster of 4096 nodes. Verdict [Tzi+22] took a similar approach but, to reduce circuit size, employed a non-standard ZK-friendly hash function [Gra+21]. In contrast, our approach reaches significantly higher throughput using just a single server.</p>

    <p class="text-gray-300">Merkle² [Hu+21] changes the trust model to improve performance. They reduce the auditor's per-epoch workload to logarithmic in the number of key updates by requiring only a single Merkle extension proof per epoch. However, Merkle² relies on the signature chain assumption, that clients maintain a secure key to sign their own key updates, which we consider unrealistic for secure messaging applications as we will discuss in Section 2.</p>

    <p class="text-gray-300">Table of comparison. Figure 1 compares the asymptotic costs of IronDict with prior work. The key advantage of IronDict lies in its audit and update costs, which remain independent of the epoch size. As we will later show in Section 5, IronDict is concretely efficient since its main operations are field operations, which are concretely efficient.</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.2 Our Contributions</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A simple transparent dictionary based on polynomial commitments. Our main contribution is IronDict, a novel transparent dictionary built upon a generic polynomial commitment scheme (PCS) defined over a large field¹, a new paradigm in designing transparent dictionaries. Conceptually, our design is simple, with most of the complexity encapsulated within the underlying PCS scheme. The construction provides (I) low server overhead resulting in a high throughput and (II) low auditing overhead, with the latter being independent of the update batch size. Instantiating IronDict with KZH as the underlying PCS [Kad+25] yields a concretely efficient implementation that enables lightweight auditing: audit proofs for a dictionary supporting 1 billion users are under 8 kB and verifiable in about 35 ms on a personal computer, while sustaining a throughput of more than 1,000 updates (or user enrollments) per second.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Doubly-efficient consistency proofs. We introduce a new approach for verifying consistency in transparent dictionaries; that is, a proof in the common case that an individual label-value mapping was unchanged over many epochs. Unlike prior work, our method eliminates the need to maintain explicit value histories or versioning. We show that consistency can be checked using just two PCS openings (or even a single one if the underlying PCS supports homomorphism), yielding a highly efficient solution for both</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">¹We require the PCS to be defined over a field <span class="math">\\mathbb{F}</span> with sufficiently large cardinality—typically $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{128}<span class="math"> or </span>2^{256}<span class="math">—to ensure that birthday attacks on a hash function </span>H: \\{0,1\\}^* \\to \\mathbb{F}$ are computationally infeasible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lookup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">History</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Auditor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">Upd. & Aud.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SEEMIess [Cha+19]</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">(u + log T) log n</td>

            <td class="px-3 py-2 border-b border-gray-700">(u + log T) log n</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Parakeet [Mal+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">(u + log T) log n</td>

            <td class="px-3 py-2 border-b border-gray-700">(u + log T) log n</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">OPTIKS [Len+24]</td>

            <td class="px-3 py-2 border-b border-gray-700">u log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">u log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">u log n</td>

            <td class="px-3 py-2 border-b border-gray-700">u log n</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(n + b)*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ELEKTRA [Len+23]</td>

            <td class="px-3 py-2 border-b border-gray-700">(u log n + log T)*</td>

            <td class="px-3 py-2 border-b border-gray-700">(u log n + log T)*</td>

            <td class="px-3 py-2 border-b border-gray-700">(u log n + log T)*</td>

            <td class="px-3 py-2 border-b border-gray-700">(u log n + log T)*</td>

            <td class="px-3 py-2 border-b border-gray-700">(b · log(n + b) + log T)*</td>

            <td class="px-3 py-2 border-b border-gray-700">(b · log(n + b) + log T)*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle2 [Hu+21]</td>

            <td class="px-3 py-2 border-b border-gray-700">log n2</td>

            <td class="px-3 py-2 border-b border-gray-700">log n2</td>

            <td class="px-3 py-2 border-b border-gray-700">log n2</td>

            <td class="px-3 py-2 border-b border-gray-700">log n2</td>

            <td class="px-3 py-2 border-b border-gray-700">log n2*</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">VeRSA-IVC [Tya+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">(n/m + log m)*</td>

            <td class="px-3 py-2 border-b border-gray-700">u</td>

            <td class="px-3 py-2 border-b border-gray-700">(n/m + log m)*</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">log T</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CONIKS [Mel+15]</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">log n*</td>

            <td class="px-3 py-2 border-b border-gray-700">naive</td>

            <td class="px-3 py-2 border-b border-gray-700">naive</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(N + b)*</td>

            <td class="px-3 py-2 border-b border-gray-700">b · log(N + b)*</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">IRONDICTk</td>

            <td class="px-3 py-2 border-b border-gray-700">k · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">u · k · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">u · O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">index assignment: N value update: b</td>

            <td class="px-3 py-2 border-b border-gray-700">k · N1/k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zk-IRONDICTk</td>

            <td class="px-3 py-2 border-b border-gray-700">k · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">(k2 + k) · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">u · k · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">u · (k2 + k) · N1/k</td>

            <td class="px-3 py-2 border-b border-gray-700">index assignment: N value update: b</td>

            <td class="px-3 py-2 border-b border-gray-700">k · N1/k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">b</span>  : the number of elements added per epoch</p>

    <p class="text-gray-300"><span class="math">N</span>  : maximum dictionary's capacity</p>

    <p class="text-gray-300"><span class="math">u</span>  : value's version</p>

    <p class="text-gray-300">naive indicates that verifying history requires performing a lookup for each epoch.</p>

    <p class="text-gray-300">Complexities with star  <span class="math">(\\star)</span>  indicate the average case.</p>

    <p class="text-gray-300"><span class="math">n</span>  : the number of items in the dictionary</p>

    <p class="text-gray-300"><span class="math">T</span>  : the number of epochs since the operation was last invoked</p>

    <p class="text-gray-300"><span class="math">m</span>  : batch size (in case of VeRSA supporting batch lookups)</p>

    <p class="text-gray-300">Figure 1: Asymptotic efficiency of transparent dictionary schemes: We denote our scheme as  <span class="math">\\mathrm{IRONDICT}_k</span>  when our construction is concretely initiated with KZH-k and zk-IRONDICT <span class="math">_k</span>  our privacy-preserving variant. Since KZH-k uses precomputed arrays for PCS openings at Boolean points, the server cost is  <span class="math">O(1)</span> . Update cost includes two terms:  <span class="math">N</span>  (index assignment via cheap field operations) and  <span class="math">b</span>  (value updates using group operations). The lookup (and history) cost for the server is  <span class="math">(k^2 + k) \\cdot N^{1/k}</span> , in which a large portion of that can be precomputed by the server since it is independent of the client query. We later expand on it in Section 4.6.</p>

    <p class="text-gray-300">the server and the client. Concretely, the server can produce a consistency proof with size  <span class="math">5\\mathrm{kB}</span>  in under  <span class="math">35~\\mathrm{ms}</span> , while the client can verify it in under  <span class="math">30~\\mathrm{ms}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Concretely efficient fast-forwarding for auditors via IVC. Fast-forwarding is the ability for a new auditor—or an auditor who has been offline for  <span class="math">n</span>  epochs—to verify the current state by checking only a sublinear number of proofs, rather than auditing all  <span class="math">n</span>  epochs individually. We introduce an IVC [Val08] scheme for fast-forwarding auditors for IRONDICT, such that the IVC cost is independent of the size of the update batch. When IRONDICT is concretely instantiated with KZH, we estimate to achieve  <span class="math">1000 \\times</span>  prover performance improvement in practice compared to VeRSA [Tya+22], which also proposed using an IVC scheme with constant circuit size per step.</li>

      <li>Checkpoints for efficient self-auditing by clients. Inspired by VeRSA, we propose an alternative to IVC that allows clients to fast-forward through updates using lightweight checkpoints. When a client comes online, it only requires verifying a short (sublinear-length) sequence of checkpoint proofs spanning from its last known state to the current</li>

    </ul>

    <p class="text-gray-300">one. This approach enables efficient self-auditing without incurring the computational overhead associated with IVC-based methods.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A stronger definition of privacy. Prior works define privacy in transparent dictionaries by requiring (I) the commitment to the dictionary to be hiding (II) the client queries and audit proofs reveal no more information than what is permitted by a predefined <em>leakage function</em>. These leakage functions are typically tailored to specific constructions and do not offer strong cryptographic guarantees. For example, in SEEMless <em>[x10]</em>, lookup queries additionally reveal the last epoch during which a value was updated—a non-standard and unintended leakage arising from their design. In this work, we propose zk-IronDict with a strong, zero-knowledge-based notion of privacy: clients and auditors learn <em>nothing</em> beyond the correctness of their queries and (an upper bound on) the dictionary’s size. Our definition is generic and applies to any PCS that satisfies the hiding property and supports zero-knowledge openings <em>[B+21]</em>.</li>

      <li>A zero-knowledge variant of KZH. To meet the privacy requirements, the underlying PCS must have a hiding commitment and a zero-knowledge opening protocol. KZH lacks these properties natively. Prior work <em>[B+21]</em> proposes a generic compiler that transforms a homomorphic PCS to one that has a zero-knowledge opening protocol. There are two downsides to this approach: (I) it is expensive, and (II) it lacks a formal proof of the zero-knowledge property. In this work, we formally prove the security of this compiler and show that, when applied to KZH, only a sublinear amount of randomness suffices, which makes the compiler lightweight. This contribution can be of independent interest.</li>

      <li>Memory optimizations. By taking advantage of the homomorphic properties of KZH, when IronDict is initiated with KZH, we introduce a trade-off between computation and memory. Specifically, at each epoch, the server only needs to store the difference between the current and previous epoch, reducing the memory overhead. However, when the server needs to <em>open</em> a value later, it incurs a computational cost, performing a number of field operations proportional to the size of the epoch.</li>

      <li>Implementation. We implement IronDict and demonstrate that it scales to dictionaries with billions of entries, matching the demands of modern secure messaging applications, while supporting update rates of up to thousands per second. We conduct our experiments on a Google c4-highmem-144-lssd instance, equipped with 144 CPU cores and 1116 GB of memory. For a dictionary supporting 1 billion users, our system achieves an epoch interval of nearly 15 minutes while sustaining a throughput of over 1000 updates per second. Auditor proofs remain under 8 kB and can be verified in under 35 ms on a consumer-grade laptop. Client queries—including lookups and consistency checks—produce proofs of approximately 6 kB, which can be verified in less than 30 ms.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 System model</p>

    <p class="text-gray-300">We outline the basic roles in our system here, which is consistent with prior work on key transparency <em>[x13]</em>:</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Server.</h4>

    <p class="text-gray-300">The main entity in our system is a <em>server</em> that provides access to a queryable dictionary (a label-value map) and periodically updates it (once per <em>epoch</em>) while maintaining some invariants. With each update, the server publishes a new commitment to the dictionary. We expect the server to provide verifiable answers to two types of queries:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lookup: What value is assigned to label <span class="math">\\ell</span> in epoch <span class="math">i</span>?</li>

      <li>Consistency: Has the value assigned to the label <span class="math">\\ell</span> changed between epochs <span class="math">i</span> and <span class="math">j</span>?</li>

    </ul>

    <p class="text-gray-300">Note that simply performing lookups on the values mapped to label <span class="math">\\ell</span> at epochs <span class="math">i</span> and <span class="math">j</span> does not suffice as a consistency proof between <span class="math">i</span> and <span class="math">j</span>. The server might attempt an <em>oscillation attack</em> <em>[x14]</em> by changing the mapping for a targeted label at one epoch and then switching it back in the next epoch. Hence, a consistency proof must rule out changes in any epoch between <span class="math">i</span> and <span class="math">j</span>. In some systems, the server commits to maintaining additional invariants. For example, a version invariant <em>[x13, x3]</em> attaches a version number <span class="math">v</span> to each value and requires that this is incremented in any epoch in which the value changes. Given this invariant, checking that a value has the same version number in epochs <span class="math">i</span> and <span class="math">j</span> is equivalent to a consistency proof. A stronger invariant ensures that each value is append-only—that is, the dictionary retains all historical versions of a value, so that a lookup at epoch <span class="math">i</span> reveals the entire version history up to that point. Other invariants are application-specific, for example, CONIKs <em>[x13]</em> proposed marking some labels as <em>strict</em>, meaning any changes must be authorized by a signature. In our work, we don’t adopt any such special invariants and instead build efficient consistency proofs directly.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Client.</h4>

    <p class="text-gray-300">A set of <em>clients</em> (or users) are able to query the dictionary via the server. Typically, each client is represented by a label <span class="math">\\ell</span>, which is a human-readable identifier such as a username, email address, or phone number. The client will typically <em>monitor</em> this label by requesting consistency proofs between epochs and manually verifying any changes to the value mapped to their label. Clients will also request lookup proofs of other labels of interest, such as peers in a secure messaging system that they wish to communicate with. However, the clients <em>do not</em> monitor other labels over time. The assumption is that the label’s owner will monitor and detect any unauthorized changes. There may be restrictions on which labels a user can look up; for example, rate limits or a requirement to be marked as contacts within the system. We leave these out of scope. Clients can also request updates to the value mapped to their label (for example, to change their public key after losing a device). Notably,</p>

    <p class="text-gray-300">we do not assume any cryptographic authentication (such as a signature) is required to update any mapping, as some prior work does <em>[x10]</em>. The downside of such assumptions is that they require users to maintain uninterrupted access to cryptographic keys over time. In practice, users often lose their devices or reinstall applications, thereby losing access to previous secret keys. Recovering from such scenarios inherently requires the server to update any label’s value based on non-cryptographic authentication (e.g. passwords or 2FA). This has important implications for monitoring in that surreptitious updates by the server are <em>detectable</em> but not <em>provable</em>. The server can always claim that a legitimate user requested an update, even if they did not. Conversely, any user could falsely accuse the server of making an unauthorized update, even if they approved it. Such disputes must be resolved through non-technical means. If a significant number of reputable users publicly allege that the server is misbehaving, this could serve as compelling, if not conclusive, evidence.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Auditors</h5>

    <p class="text-gray-300"><em>Auditors</em> monitor the server’s updates and verify the correctness of a proof of invariance at each epoch. At a high level, this proof ensures that the transition from one epoch to the next preserves the desired invariants. For example, under the versioning invariant described previously, a valid transition requires that if a value is modified, its version number must also be incremented accordingly. Importantly, the auditors only check for the server’s <em>detectable</em> and <em>provable</em> misbehaviour, such as an incorrect proof of invariance. Some <em>whistle-blowing procedure</em> must be in place to broadcast evidence of misconduct, which we leave out of scope. The efficiency of auditing depends directly on the size and verification cost of invariance proofs. For example, consider the simple case where the server publishes all value updates directly on the bulletin board. In this setting, auditors must be <em>almost</em> as powerful as the server to recompute the updates and verify their correctness. However, the assumption of such powerful auditors means most clients will be incapable of auditing and must rely on a quorum of third parties to audit. While any one correct auditor can broadcast proofs of misbehaviour, the incentives for performing expensive auditing remain unclear. Instead, we aim to make <em>self-auditing</em> possible, where even lightweight clients are capable of performing auditing. As in prior work <em>[x17, x11, x12]</em>, we assume the server facilitates this by publishing additional cryptographic proof with each update.</p>

    <p class="text-gray-300">A special case of this is using IVC, in which verifying a proof for any epoch ensures the correctness of all previous updates. This is useful for <em>fast-forwarding</em>, allowing a new auditor, or one who comes online after an extended time, to verify a single proof rather than checking proofs for many missed epochs. We discuss this approach further in Section 6.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Bulletin board.</h5>

    <p class="text-gray-300">Like prior work, we assume a public bulletin board, e.g. a publicly accessible and append-only ledger that allows parties to publish arbitrary strings along with authentication tags for verification. We treat the bulletin board as a black box with the following basic functionality: (I) post operation: A party can publish a string on the bulletin board, and (II) retrieve operation: Anyone can query the bulletin board. The use</p>

    <p class="text-gray-300">of a bulletin board prevents split-view attacks, where a malicious server provides different clients with inconsistent states of the dictionary at the same epoch <span class="math">i</span>. The bulletin board abstraction can be realised in various ways, e.g. a public blockchain <em>[x21]</em> or a gossip protocol <em>[x24, Mei+20]</em>. We leave the details out of scope, as they do not affect the design of our dictionary. We denote the public bulletin board via BB.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 Preliminaries and building blocks</h2>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Notation.</h4>

    <p class="text-gray-300">We denote vectors using bold letters, such as <span class="math">\\mathbf{w}</span>, and use <span class="math">w_{i}</span> to refer to the <span class="math">i</span>-th entry of the vector. Let <span class="math">\\mathbb{F}</span> be a finite field and <span class="math">\\mathbb{G}</span> a group with scalars in <span class="math">\\mathbb{F}</span>, with additive notation. For <span class="math">a\\in\\mathbb{F}</span> and <span class="math">\\mathsf{G}\\in\\mathbb{G}</span>, the scalar multiplication of <span class="math">\\mathsf{G}</span> by <span class="math">a</span> is denoted as <span class="math">a\\times\\mathsf{G}</span>. A function <span class="math">f(x)</span> is negligible if, for any polynomial <span class="math">p(x)</span>, there exists a positive integer <span class="math">N</span> such that for all <span class="math">x&gt;N</span>, we have <span class="math">f(x)&lt;\\frac{1}{p(x)}</span>. When we say an event happens with overwhelming probability, we mean it occurs with a probability of <span class="math">1-\\epsilon(\\lambda)</span>, where <span class="math">\\epsilon(\\lambda)</span> is a negligible function.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Dictionary.</h4>

    <p class="text-gray-300">We denote by a dictionary <span class="math">\\mathsf{Dict}</span> as a set of label-value pairs <span class="math">\\{(\\mathsf{label}_{i},\\mathsf{value}_{i})\\}_{i=1}^{m}</span> with <em>unique</em> label values. For a dictionary <span class="math">\\mathsf{Dict}</span>, we denote by <span class="math">\\mathsf{Dict}[\\mathsf{label}]</span> the value corresponding to <span class="math">\\mathsf{label}</span> in the dictionary <span class="math">\\mathsf{Dict}</span>; i.e.,</p>

    <p class="text-gray-300">\\[ \\mathsf{Dict}[\\mathsf{label}]:=\\begin{cases}\\mathsf{value}&\\text{ if }(\\mathsf{label},\\mathsf{value})\\in\\mathsf{Dict}\\\\ \\perp&\\text{ otherwise.}\\end{cases} \\]</p>

    <p class="text-gray-300">When we refer to a dictionary as <span class="math">\\mathsf{Dict}:A\\rightarrow B</span>, it means its labels are in set <span class="math">A</span> and its values are in set <span class="math">B</span>.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Multilinear polynomials.</h4>

    <p class="text-gray-300">A multivariate polynomial is said to be <em>multilinear</em> if the individual degree of any variable <span class="math">X_{i}</span> is at most <span class="math">1</span>. We use <span class="math">\\mathbb{F}_{\\mu}^{\\leq 1}[\\mathbf{X}]</span> to denote the space of all <span class="math">\\mu</span>-variate multilinear polynomials. A multilinear polynomial <span class="math">\\overline{p}\\in\\mathbb{F}_{\\mu}^{\\leq 1}[\\mathbf{X}]</span> of size <span class="math">N=2^{\\mu}</span> is uniquely defined by (or uniquely extends) its <span class="math">N</span> evaluations on the Boolean hypercube. We denote by <span class="math">\\mathsf{L}_{\\mathbf{w}}(\\mathbf{X})</span> a multilinear Lagrange polynomial that vanishes all over the Boolean hypercube <span class="math">\\{0,1\\}^{\\mu}</span> except on <span class="math">\\mathbf{w}\\in\\{0,1\\}^{\\mu}</span>. It can be computed as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{L}_{\\mathbf{w}}(\\mathbf{X})=\\prod_{i=1}^{\\mu}(X_{i}w_{i}+(1-X_{i})(1-w_{i}))</span></p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Multilinear polynomial commitment scheme (PCS).</h4>

    <p class="text-gray-300">PCS is a cryptographic primitive that enables a prover to <em>commit</em> to a multilinear polynomial succinctly and later prove the correctness of its evaluation at some chosen points from the domain, without revealing</p>

    <p class="text-gray-300">the full polynomial. When a verifier requests an opening at a point <span class="math">\\vec{x}</span>, the prover returns both the claimed evaluation <span class="math">y=p(\\vec{x})</span> and a proof <span class="math">\\pi</span> attesting to its correctness. The verifier can efficiently check that <span class="math">y</span> is the correct value of the committed polynomial at <span class="math">\\vec{x}</span> using the proof <span class="math">\\pi</span>. A formal definition of PCS and its required properties is provided in Appendix A.</p>

    <h5 id="sec-16" class="text-base font-semibold mt-4">Sumcheck.</h5>

    <p class="text-gray-300">The <em>sumcheck protocol</em> <em>[x10]</em> is an interactive proof between a prover and a verifier for verifying claims of the form</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\mathbf{x}\\in\\{0,1\\}^{\\mu}}p(\\mathbf{x})=s,</span></p>

    <p class="text-gray-300">where <span class="math">p(\\mathbf{X})\\in\\mathbb{F}_{\\mu}^{\\leq d}[\\mathbf{X}]</span>. The protocol reduces this claim to checking the evaluation of <span class="math">p</span> at a randomly chosen point <span class="math">\\mathbf{r}</span>. It achieves communication complexity <span class="math">O(\\mu)</span>, prover time <span class="math">O(N)</span> where <span class="math">N=2^{\\mu}</span> which mostly consists of field operations, and verifier time <span class="math">O(\\mu)</span>.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Zerocheck.</h5>

    <p class="text-gray-300">A <em>zerocheck</em> <em>[x4]</em>, similar to sumcheck, is an interactive protocol between a prover and a verifier, wherein the verifier—given oracle access to a multivariate polynomial <span class="math">p(\\mathbf{X})\\in\\mathbb{F}_{\\mu}^{\\leq d}[\\mathbf{X}]</span>—checks that <span class="math">p</span> evaluates to zero on all points of the Boolean hypercube. A zerocheck protocol has the same asymptotic complexity as the sumcheck protocol, since the prover and verifier internally invoke a sumcheck on the polynomial <span class="math">p(\\mathbf{X})\\cdot\\mathsf{L}_{\\mathbf{r}}(\\mathbf{X})</span>, where <span class="math">\\mathbf{r}</span> is a random challenge selected by the verifier.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.1 KZH: PCS with optimal opening</h3>

    <p class="text-gray-300">In this paper, we choose KZH <em>[x13]</em> to instantiate the PCS for our construction. KZH is a family of multilinear PCS built on a pairing-friendly elliptic curve. A key feature of KZH is that it has a sublinear opening proof size and a sublinear opening time for both the prover and the verifier, similar to Hyrax <em>[x20]</em>. However, unlike Hyrax and similar to KZG <em>[x12]</em>, KZH has a commitment of constant size, consisting of a single group element. KZH (more precisely KZH-2) has an opening size and verifier time of <span class="math">O(N^{\\frac{1}{2}})</span> and is generalized to a family of schemes called KZH-k for <span class="math">k\\geq 2</span>, which achieves an opening size and verifier time of <span class="math">O(k\\cdot N^{\\frac{1}{k}})</span> for a constant <span class="math">k</span>. A description of KZH-k can be found in Appendix E. A comparison of different variants of KZH can be seen in Table 1. In this paper, when we mention KZH, we refer to the entire KZH-k family. If we are specifically discussing one, we specify it with the index k. KZH is secure in the AGM under the <span class="math">(q_{1},q_{2})</span>-<em>dlog</em> and <em>setup-find-rep</em> assumptions.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Advantages of KZH for our scheme.</h5>

    <p class="text-gray-300">Apart from sublinear proof and verifier time, the KZH family has two key advantages that make it particularly well-suited as the underlying PCS for our construction:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Free opening at Boolean points. Opening Boolean points using KZH-k is essentially <em>free</em>, meaning the server is only required to read <span class="math">k</span> <em>arrays</em> of size <span class="math">N^{1/k}</span> from memory. The term <em>free</em> here refers to the fact that the server does not need to perform any computation to generate the proof; rather, it only needs to read and return the relevant auxiliary data. This is analogous to Merkle trees, where the opening of a leaf involves no computation and consists solely of reading and returning internal nodes. As we will see in the next section, the server only needs to open the polynomial at Boolean points in response to client requests. Therefore, the efficiency of openings at Boolean points—compared to non-Boolean points—is especially important in our setting.</li>

      <li>Homomorphic commitments and auxiliary input. KZH family is homomorphic, and its auxiliary input used for opening is homomorphic as well. Homomorphism here refers that, let <span class="math">(\\mathsf{com}_{1},\\mathsf{aux}_{1})</span> be a commitment and its corresponding auxiliary input for a polynomial <span class="math">f_{1}</span>, and <span class="math">(\\mathsf{com}_{2},\\mathsf{aux}_{2})</span> be a commitment and auxiliary input for a polynomial <span class="math">f_{2}</span>. Then, for any scalar <span class="math">\\alpha\\in\\mathbb{F}</span>, the following pair <span class="math">(\\alpha\\cdot\\mathsf{com}_{1}+\\mathsf{com}_{2},\\ \\alpha\\cdot\\mathsf{aux}_{1}+\\mathsf{aux}_{2})</span> is a valid commitment and auxiliary input for the polynomial <span class="math">\\alpha\\cdot f_{1}+f_{2}</span>, where <span class="math">\\cdot</span> denotes scalar multiplication. This means that updating <span class="math">n</span> evaluation points of a polynomial only requires <span class="math">k\\cdot n</span> group operations to update both the commitment and the auxiliary data of KZH-k. Although our scheme does not necessarily require homomorphism, homomorphism significantly improves the efficiency of our protocol for value consistency.</li>

    </ul>

    <h5 id="sec-20" class="text-base font-semibold mt-4">Which variant of KZH to use?</h5>

    <p class="text-gray-300">The choice of the KZH variant for our scheme depends primarily on the size of the dictionary and the specific application, e.g. constraints by the participants. For example, assume we aim for an opening size that is smaller than <span class="math">1\\text{\\,}\\mathrm{MB}</span> and can be verified in under one second on a consumer-grade laptop. As a concrete example, consider a multilinear polynomial with hypercube size of <span class="math">N=2^{31}</span>, roughly corresponding to the number of WhatsApp users <em>[x10]</em>. Using KZH-2 in this setting results in a proof size of approximately <span class="math">2.6\\text{\\,}\\mathrm{MB}</span>, due to the <span class="math">O(N^{\\frac{1}{2}})</span> scaling. Such a large proof imposes unnecessary client overhead, which can be mitigated, e.g. by using KZH-4 or KZH-8 as the underlying PCS. These variants shift computation to the server and, for a dictionary of size <span class="math">2^{31}</span>, reduce proof size and verification time by about <span class="math">100\\times</span> and <span class="math">1000\\times</span>, respectively, at the cost of higher server-side commitment and opening costs (see Table 1).</p>

    <h5 id="sec-21" class="text-base font-semibold mt-4">KZH setup.</h5>

    <p class="text-gray-300">One limitation of KZH is its requirement for a <em>linear-sized</em> SRS, similar to the trusted setup used in the KZG scheme based on powers-of-tau. The SRS must be generated via a <em>trusted setup</em>, which introduces important security considerations. In practice, such setups are typically carried out using multi-party computation (MPC) ceremonies, where multiple participants sequentially contribute randomness to the SRS. As long as *at least</p>

    <p class="text-gray-300">one participant acts honestly, the resulting SRS remains secure. This approach has been successfully employed by real-world systems such as Zcash <em>[BGG+16]</em> and Filecoin <em>[x20]</em>. A summary of current best practices for MPC ceremonies is provided in <em>[x25]</em>. Concrete numbers of the KZH setup are provided in Section 5.4.</p>

    <p class="text-gray-300">While our concrete construction currently relies on KZH, which requires a trusted setup, it is possible to instantiate IronDict with alternative PCSs. For example, one might consider PCSs with <em>transparent setup</em> <em>[x24, BS+19]</em>, or those with <em>sublinear-sized SRSs</em> <em>[B+21, B+22]</em>. However, such alternatives often come with trade-offs, including increased proof sizes, higher opening times, or higher costs to make them zero-knowledge. Choosing the right PCS is therefore a delicate balance between trust assumptions and efficiency. Identifying suitable alternatives to KZH that offer efficient performance and either a transparent setup or a sublinear trusted setup remains an open direction. We leave this to future work.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.2 Transparent dictionary (TD)</h3>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 1 (Transparent dictionary).</h6>

    <p class="text-gray-300">A <em>transparent dictionary protocol</em> is defined with respect to three parties: Server, Auditor, and Client, all of whom have access to a public bulletin board BB. Because of the existence of BB, we assume all parties know the current epoch number <span class="math">i</span>. Each party supports the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\lambda,\\mu)\\to(\\mathsf{key}_{\\mathsf{Server}};\\mathsf{key}_{\\mathsf{Auditor}},\\mathsf{key}_{\\mathsf{Client}})</span>: Given a security parameter <span class="math">\\lambda</span> and log of maximum supported size <span class="math">\\mu</span>, this algorithm respectively outputs participants’ keys, namely: <span class="math">\\mathsf{key}_{\\mathsf{Server}}</span>, <span class="math">\\mathsf{key}_{\\mathsf{Auditor}}</span> and <span class="math">\\mathsf{key}_{\\mathsf{Client}}</span>. We assume algorithms corresponding to each party take their corresponding key as an implicit input; we omit it for brevity. If the setup requires secret randomness, we assume it is executed by a trusted party (e.g., implemented via a ceremony).</li>

      <li><span class="math">\\mathsf{Server.Init}()\\to(\\mathsf{state}_{0},\\mathsf{com}_{0})</span>: Initializes the dictionary state as <span class="math">\\mathsf{state}_{0}</span> and computes a succinct commitment <span class="math">\\mathsf{com}_{0}</span> to this state. The commitment <span class="math">\\mathsf{com}_{0}</span> is then published on the bulletin board BB.</li>

      <li><span class="math">\\mathsf{Server.Update}(\\mathsf{state}_{i-1},\\Delta)\\to(\\mathsf{state}_{i},\\mathsf{com}_{i},\\pi_{i})</span>: Updates the current state <span class="math">\\mathsf{state}_{i-1}</span> using a set of changes <span class="math">\\Delta</span> to obtain a new state <span class="math">\\mathsf{state}_{i}</span>. It then computes and publishes a new commitment <span class="math">\\mathsf{com}_{i}</span> to BB, along with invariance proof <span class="math">\\pi_{i}</span>.</li>

      <li><span class="math">\\mathsf{Server.Lookup}(\\ell,\\mathsf{state}_{i})\\to(\\mathsf{value},\\pi_{\\mathsf{Lookup}})</span>: Given a label <span class="math">\\ell</span> and epoch state <span class="math">\\mathsf{state}_{i}</span>, returns the value <span class="math">\\mathsf{value}</span> associated with <span class="math">\\ell</span> in state <span class="math">\\mathsf{state}_{i}</span>, along with a lookup proof <span class="math">\\pi_{\\mathsf{Lookup}}</span>. If <span class="math">\\mathsf{state}_{i}</span> does not exist or <span class="math">\\ell</span> is invalid, the algorithm returns <span class="math">\\bot</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Client.VerifyLookup( <span class="math">\\ell, \\mathsf{com}_i</span> , value,  <span class="math">\\pi_{\\text{Lookup}}</span> )  <span class="math">\\rightarrow 0/1</span> : Given a label  <span class="math">\\ell</span> , epoch commitment  <span class="math">\\mathsf{com}_i</span> , value value, and a lookup proof  <span class="math">\\pi_{\\text{Lookup}}</span> , this algorithm verifies the lookup and returns 1 (accept) or 0 (reject).</li>

      <li>Auditor.VerifyInvariance  <span class="math">(\\mathsf{com}_i,\\mathsf{com}_{i + 1},\\pi_{i + 1})\\to 0 / 1</span>  : Given commitments  <span class="math">\\mathsf{com}_i</span>  and  <span class="math">\\mathsf{com}_{i + 1}</span>  for epochs  <span class="math">i</span>  and  <span class="math">i + 1</span>  along with proof of invariance  <span class="math">\\pi_{i + 1}</span> , verifies its validity and returns 1 (accept) or 0 (reject).</li>

      <li>Server. Consistency  <span class="math">(\\ell, \\text{state}_i, \\text{state}_j) \\to \\pi_{\\text{consis}}</span> : Given a label  <span class="math">\\ell</span>  and two states  <span class="math">\\text{state}_i</span>  and  <span class="math">\\text{state}_j</span>  corresponding to epochs  <span class="math">i</span>  and  <span class="math">j</span>  with  <span class="math">i &amp;lt; j</span> , the server returns a proof  <span class="math">\\pi_{\\text{consis}}</span>  attesting that the value associated with  <span class="math">\\ell</span>  remained unchanged throughout epochs  <span class="math">i</span>  to  <span class="math">j</span> . If the value changed during this interval, it returns  <span class="math">\\perp</span> .</li>

      <li>Client. VerConsistency  <span class="math">(\\ell, \\mathsf{com}_i, \\mathsf{com}_j, \\pi_{\\mathrm{consis}}) \\to 0/1</span> : Client verifies validity of a consistency proof  <span class="math">\\pi_{\\mathrm{consis}}</span>  for the label  <span class="math">\\ell</span>  between epochs  <span class="math">i</span>  and  <span class="math">j</span> , returning 1 if the proof is accepted, and 0 otherwise.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Open Time (Random)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Open Time (Boolean)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZH-2</td>

            <td class="px-3 py-2 border-b border-gray-700">2·MSM(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">2·N1/2G1</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/2P+2·MSM(N1/2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZH-k</td>

            <td class="px-3 py-2 border-b border-gray-700">k·MSM(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N1/2)G1, O(N)F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">k·N1/kG1</td>

            <td class="px-3 py-2 border-b border-gray-700">N1/kP+k·MSM(N1/k)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">P: pairing ops  <span class="math">\\mathbb{G}_1</span> : base group ops  <span class="math">\\mathbb{F}</span> : field ops  <span class="math">\\mathrm{MSM}(n)</span> : multi-scalar multiplication of size  <span class="math">n</span></p>

    <p class="text-gray-300">Table 1: Comparison of KZH- <span class="math">k</span>  variants for  <span class="math">k = 2</span>  and  <span class="math">k &amp;gt; 2</span>  over a polynomial on a Boolean hypercube of size  <span class="math">N</span> . Here, we distinguish between the opening time of a Boolean and a non-Boolean point.</p>

    <p class="text-gray-300">Comparison to [Cha+19]. Our definition is an adaptation of [Cha+19] with the following minor differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce an additional algorithm, Setup. The Setup algorithm outputs keys for the participating parties. In a tree-based solution, this could be as simple as specifying a hash function. However, since we work in the setting of polynomial commitment schemes, we explicitly include Setup to emphasize that it differs from Server.Init—for example, it may involve secret randomness and thus is not necessarily executed by the server.</li>

      <li>To verify the invariance proof, we assume the verification happens step by step, which is necessary for stateless auditors. In contrast, in [Cha+19], the auditor functionality starts from epoch 0 and verifies to the last epoch.</li>

      <li>We generalize the definition by assuming that the server stores a state  <span class="math">\\text{state}_i</span>  at each step, which may include some data structure enabling the server to store the keys for each epoch. The simplest form would be  <span class="math">\\text{state}_i = \\text{Dict}_i</span>  at each epoch.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We simplify the history-related functions from previous definitions of TDs by focusing solely on consistency. Whereas earlier formulations returned the entire change history, including all values and their corresponding epochs, our approach replaces this with a single functionality that merely checks whether a value has changed within a given epoch range. This streamlined version is more practical and sufficient for most client applications.</li>

    </ul>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Completeness.</h5>

    <p class="text-gray-300">Intuitively, completeness guarantees that if the setup is performed honestly and the server behaves honestly, then the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency correctness: When the client requests a value consistency check between epochs <span class="math">i</span> to <span class="math">j</span> such that the value has not changed, running Client.VerConsistency on the proof leads to acceptance. When the client queries a value at any time within the epoch interval <span class="math">[i,j)</span>, the returned value is the same.</li>

      <li>Audit correctness: At each epoch, any honest auditor running Auditor.VerifyInvariance obtains output 1.</li>

    </ul>

    <h5 id="sec-25" class="text-base font-semibold mt-4">Soundness.</h5>

    <p class="text-gray-300">Except with negligible probability, the following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lookup soundness (binding): Given a commitment <span class="math">\\mathsf{com}_{i}</span> to an epoch and a single label <span class="math">\\ell</span>, it is computationally infeasible for the server to produce two distinct values, each accompanied by a valid proof, such that both pass verification under Client.VerifyLookup for the same commitment.</li>

      <li>Consistency soundness: Assume at each epoch there is at least one honest auditor that accepts the epoch proof. For any two epochs <span class="math">i</span> and <span class="math">j</span>, if the value changes during the interval <span class="math">[i,j]</span>, then the server cannot generate a proof of the consistency of the value that will be accepted by the client.</li>

    </ul>

    <p class="text-gray-300">Formal definitions of completeness and soundness can be found in Appendix B.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 IronDict</h2>

    <p class="text-gray-300">In this section, we describe our construction, which is based on a generic PCS. In Section 4.1, we introduce how a restricted class of dictionaries can be modeled using a single multilinear polynomial, and we explain why this approach fails for general string-to-string dictionaries. In Section 4.2, we extend the previous idea and show how to construct general dictionaries—mapping arbitrary strings to arbitrary strings—using two multilinear polynomials, referred to as Index and Value polynomials. We also specify the required properties of each polynomial. Section 4.3 focuses on Index polynomial and its append-only property, discussing associated design trade-offs. Then, in Section 4.4, we present how Value polynomial is</p>

    <p class="text-gray-300">used to support <em>value consistency</em> proofs. Finally, in Section 4.5, we describe the complete construction using a generic PCS. In Section 4.6, we describe our notion of privacy and introduce our privacy-preserving variant zk-IronDict. Finally, we provide a cost overview of the construction instantiated with the KZH family. This includes the additional costs incurred to make the scheme privacy-preserving—that is, to transform KZH zero-knowledge.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.1 Polynomial Encodings for Dictionaries</h3>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Modeling a restricted class of dictionaries.</h4>

    <p class="text-gray-300">Given two natural numbers <span class="math">m</span> and <span class="math">N</span>, such that we assume <span class="math">N</span> is a power of two, consider a dictionary represented as a set of pairs of labels <span class="math">\\mathsf{index}_{i}</span> and values <span class="math">\\mathsf{value}_{i}</span>:</p>

    <p class="text-gray-300">\\[ \\{(\\mathsf{index}_{i},\\mathsf{value}_{i})\\}_{i\\in[m]}:\\begin{cases}\\mathsf{index}_{i}\\in\\{0,1\\}^{\\log_{2}N}\\\\ \\mathsf{value}_{i}\\in\\mathbb{F}\\setminus\\{0\\}\\end{cases} \\]</p>

    <p class="text-gray-300">We model this dictionary as a multilinear polynomial <span class="math">\\overline{p}\\in\\mathbb{F}_{\\log_{2}N}^{\\leq 1}</span>, where <span class="math">\\overline{p}(\\mathsf{index}_{i})=\\mathsf{value}_{i}</span> for each stored index-value pair, and <span class="math">\\overline{p}(\\mathbf{x})=0</span> for all indices <span class="math">\\mathbf{x}</span> that do not appear in the dictionary, in other words:</p>

    <p class="text-gray-300">\\[ \\overline{p}(\\mathbf{X})=\\begin{cases}\\mathsf{value}_{i}&:\\mathbf{X}=\\mathsf{index}_{i}\\\\ 0&:\\mathbf{X}\\in\\{0,1\\}^{\\log_{2}N}\\setminus\\{\\mathsf{index}_{i}\\}_{i\\in[m]}\\end{cases} \\]</p>

    <p class="text-gray-300">We are implicitly using the fact that given multilinear polynomial evaluations over the Boolean hypercube, it determines a single unique polynomial.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">One-to-one mapping from <span class="math">\\{0,1\\}^{*}</span> to <span class="math">\\mathbb{F}</span>.</h4>

    <p class="text-gray-300">The dictionary described above represents a restricted type: it maps non-zero elements from a finite field <span class="math">\\mathbb{F}</span> to binary strings of fixed length <span class="math">\\{0,1\\}^{\\log_{2}N}</span>. In contrast, we are interested in a more general setting of dictionaries that map arbitrary strings to arbitrary strings. To handle such general dictionaries, we adopt the common approach of hashing arbitrary strings into a fixed domain. Consider a collision-resistant hash function <span class="math">H:\\{0,1\\}^{<em>}\\to\\mathbb{F}</span>. We can treat <span class="math">H</span> as a one-to-one mapping from <span class="math">\\{0,1\\}^{</em>}</span> to <span class="math">\\mathbb{F}\\setminus\\{0\\}</span>, as (1) collision resistance implies it’s infeasible to find two distinct inputs with the same output, and (2) oneway-ness (implied by collision resistance) implies it is hard to find an input that maps to <span class="math">0</span>.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Modeling general dictionaries (strawman approach).</h4>

    <p class="text-gray-300">As explained above, in practice, transparent dictionaries often operate over domains and ranges in <span class="math">\\{0,1\\}^{*}</span>, or equivalently in <span class="math">\\mathbb{F}</span> or <span class="math">\\mathbb{F}\\setminus\\{0\\}</span>, as discussed earlier. A naive approach to modeling such dictionaries is to hash a user label (e.g., an email address) to a point <span class="math">\\mathbf{x}\\in\\{0,1\\}^{\\log_{2}N}</span> on the Boolean hypercube and assign the corresponding value to <span class="math">p(\\mathbf{x})</span>. However, for the construction to be both correct and sound, different labels must be mapped to distinct points on the hypercube. A naive</p>

    <p class="text-gray-300">use of a hash function does not ensure this uniqueness. To minimize collisions, the target space <span class="math">\\{0,1\\}^{\\log_{2}N}</span> must be exponentially large; typically larger than <span class="math">2^{256}</span>, to ensure collision resistance. Otherwise, collisions become feasible. Supporting such an enormous domain would require operating on a sparse polynomial of size <span class="math">2^{256}</span>. This would be infeasible with current polynomial commitments, including KZH or Hyrax, since even a square-root-sized SRS is too large to be materialised. Using sparse to dense techniques such as Spark <em>[x23]</em>, while feasible, suffers from inefficient openings since the opening requires an argument of knowledge, making them unsuitable for our needs. Given these limitations, we adopt a different strategy: modeling the general dictionary using two dense polynomials instead of a single sparse one.</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.2 Modeling dictionaries with two polynomials</h3>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Modeling dictionaries.</h4>

    <p class="text-gray-300">To model a dictionary with domain <span class="math">\\mathsf{Dict}:\\{0,1\\}^{<em>}\\to\\{0,1\\}^{</em>}</span>, we build it by composing two different dictionaries <span class="math">\\mathsf{Index}</span> and <span class="math">\\mathsf{Value}</span> as described:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Index}:\\mathbb{F}\\setminus\\{0\\}\\to\\{0,1\\}^{\\log_{2}N},\\,\\mathsf{Value}:\\{0,1\\}^{\\log_{2}N}\\to\\mathbb{F}\\setminus\\{0\\}</span></p>

    <p class="text-gray-300">which, by composability, implies that:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Dict}=(\\mathsf{Index},\\mathsf{Value}):\\mathbb{F}\\setminus\\{0\\}\\to\\mathbb{F}\\setminus\\{0\\}</span></p>

    <p class="text-gray-300">To retrieve the value associated with <span class="math">\\mathsf{label}</span> from <span class="math">\\mathsf{Dict}=(\\mathsf{Index},\\mathsf{Value})</span>, the user first looks up the corresponding index in <span class="math">\\mathsf{Index}</span>, then uses this index to query <span class="math">\\mathsf{Value}</span>. Assume a user wants to obtain value <span class="math">\\upsilon</span>, corresponding to label <span class="math">\\ell</span>. The procedure is intuitively described in Figure 2. Here is a quick overview of the <span class="math">\\mathsf{Index}</span> and <span class="math">\\mathsf{Value}</span> dictionaries (polynomials). We’ll explore them in depth in the next subsections.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Index dictionary.</h4>

    <p class="text-gray-300">An append-only dictionary, denoted as <span class="math">\\mathsf{Index}:\\mathbb{F}\\setminus\\{0\\}\\to\\{0,1\\}^{\\log_{2}N}</span>, we exclusively use it for assigning a fixed point on the Boolean hypercube to a label. This dictionary maps labels (e.g., email addresses) to a <em>unique index</em> within <span class="math">\\{0,1\\}^{\\log_{2}N}</span>, where <span class="math">N</span> represents the system’s capacity, i.e., the maximum number of values it can support. The index corresponding to a label is sometimes referred to in prior work, e.g. <em>[Len+24]</em> as a Uniquely Universal Identifier (UUID)—an internal, immutable representation of the label. In our system, this index corresponds to a point on the Boolean hypercube, which determines the evaluation point of the associated label. When adding a new label, the server must assign the label a fresh index. The server does so by applying <em>open addressing</em> <em>[x26]</em>. Note that the uniqueness of indexes implies that their inverse dictionary is also a dictionary.</p>

    <p class="text-gray-300">Remark 1. Open addressing is a collision resolution technique used in hash tables to handle situations where two keys hash to the same index. Instead of using separate data structures (like linked lists), open addressing stores all entries directly in the table itself. When a collision occurs, the algorithm searches for the next available slot using a defined probing sequence. This means that each label-value pair is stored at a unique index, and the table is probed until an empty slot is found.</p>

    <p class="text-gray-300">Value dictionary. A dictionary  <span class="math">\\mathsf{Value}:\\{0,1\\}^{\\log_2N}\\to \\mathbb{F}\\setminus \\{0\\}</span>  that maps user indices to their values. Unlike Index, which is append-only and maintains user indices, this dictionary allows updates to values. Maintaining two separate dictionaries allows the system to accommodate different update rates in practice since their updating procedure is different, as we will see—for instance, values might be updated more frequently than new users are registered (assigned new indexes). We construct a transparent dictionary Dict with a pair of multilinear polynomials encoding the dictionaries Index and Value separately; namely index and value. We refer to the indexed version of these polynomials,  <span class="math">(\\overline{\\mathrm{index}}_i,\\overline{\\mathrm{value}}_i)</span> , as the state of the dictionary at epoch  <span class="math">i</span> . The server uses a PCS to commit to these polynomials and publish the commitments on the bulletin board BB.</p>

    <p class="text-gray-300">(1) Server returns an index (some point  <span class="math">\\mathbf{y} \\in \\{0, 1\\}^{\\log_2 N}</span>  on the boolean hypercube) along with a proof  <span class="math">\\pi_{\\mathrm{index}}</span> , which proves that  <span class="math">\\overline{\\mathrm{index}}_i(\\mathbf{y}) = H(\\ell)</span>  and  <span class="math">\\mathbf{y}</span>  is the unique index corresponding to  <span class="math">\\ell</span> . In the next subsection, we explain the details of  <span class="math">\\pi_{\\mathrm{index}}</span> . (2) Server returns value  <span class="math">\\upsilon</span>  with proof  <span class="math">\\pi_{\\mathrm{value}}</span>  which essentially shows  <span class="math">\\overline{\\mathrm{value}}_i(\\mathbf{y}) = H(\\upsilon)</span> .</p>

    <p class="text-gray-300">Figure 2: Description of obtaining value corresponding to a label</p>

    <p class="text-gray-300">As previously mentioned, the server must prove the correctness of the index dictionary at every step to prevent attacks that exploit inconsistent indexing. For each user, the client must accept a single, unique index on the Boolean hypercube  <span class="math">\\{0,1\\}^{\\log_2N}</span> . If the server provides multiple indexes corresponding to the same label  <span class="math">\\ell</span> , a split-view attack can occur. Specifically, consider the case where the server assigns two different indexes  <span class="math">\\mathbf{y}_1,\\mathbf{y}_2\\in \\{0,1\\}^{\\log_2N}</span>  to the same label  <span class="math">\\ell</span> . If these indexes produce different evaluations under the value function, i.e.,  <span class="math">\\overline{\\mathrm{value}} (\\mathbf{y}_1)\\neq \\overline{\\mathrm{value}} (\\mathbf{y}_2)</span> , then the server can take advantage of this mapping to present different values to different clients. Ensuring correctness means proving that each label is consistently assigned to a single index in all interactions. To assign indices to other labels, we employ an open addressing strategy inspired by sparse Merkle trees [DPP16]. In addition to the hash function  <span class="math">H:\\{0,1\\}^{<em>}\\to \\mathbb{F}</span> , we also introduce another hash function  <span class="math">\\mathcal{H}:\\{0,1\\}^{</em>}\\to \\{0,1\\}^{\\log_2N}</span> . The server assigns an index to a label</p>

    <p class="text-gray-300"><span class="math">\\ell</span>  using the algorithm described in Figure 3. The server is only allowed to assign one of the indexes  <span class="math">\\mathcal{H}(0,\\ell),\\mathcal{H}(1,\\ell),\\ldots</span>  to the user in sequential order. Any deviation from this order renders the index invalid. Now, suppose that the server assigns  <span class="math">\\mathcal{H}(m_0,\\ell)</span>  to the user. When the server opens the index to the client, it must also prove that all previous indexes  <span class="math">\\mathcal{H}(m,\\ell)</span>  for  <span class="math">m &amp;lt; m_0</span>  were occupied and are not equal to  <span class="math">H(\\ell)</span> . Note that the server might arbitrarily set  <span class="math">\\overline{\\mathrm{index}} (\\mathbf{y}) = H(\\ell)</span>  for some point  <span class="math">\\mathbf{y}</span> . However, since the client requires an identifier  <span class="math">m_0\\in \\mathbb{N}</span>  such that  <span class="math">\\mathbf{y} = \\mathcal{H}(m_0,\\ell)</span> , it would not affect the client. The verification procedure is described in Figure 4.</p>

    <p class="text-gray-300">(1) Set  <span class="math">m \\coloneqq 0</span> , now given label  <span class="math">\\ell</span> , the server computes  <span class="math">\\mathbf{y} \\coloneqq \\mathcal{H}(m, \\ell)</span>  and checks if the index  <span class="math">\\mathbf{y}</span>  is not already assigned, in other words,  <span class="math">\\overline{\\mathrm{index}}(\\mathbf{y}) = 0</span> . If so, it sets  <span class="math">\\overline{\\mathrm{index}}(\\mathbf{y}) = H(\\ell)</span>  and returns  <span class="math">\\mathbf{y}</span>  as the assigned index. (2) If  <span class="math">\\overline{\\mathrm{index}} (\\mathbf{y})\\neq 0</span>  , the server updates  <span class="math">m\\coloneqq m + 1</span>  and then recompute  <span class="math">\\mathbf{y}\\coloneqq \\mathcal{H}(m,\\ell)</span>  and repeats the procedure. This continues until an unassigned index is found.</p>

    <p class="text-gray-300">Figure 3: Index assignment procedure by the server</p>

    <p class="text-gray-300">(1) The client wishes to verify that a given index  <span class="math">\\mathbf{y}</span>  corresponds to a label  <span class="math">\\ell</span> . (2) The client receives an identifier  <span class="math">m_0 \\in \\mathbb{N}</span>  and the index proof, which consists of the corresponding PCS openings of  <span class="math">\\overline{\\mathrm{index}}</span>  at points  <span class="math">\\mathbf{y}_m \\coloneqq \\mathcal{H}(m,\\ell)</span>  for all  <span class="math">m \\leq m_0</span> . (3) The client runs PCS verification to validate the correctness of PCS openings. (4) The client for  <span class="math">m &amp;lt; m_0</span> , checks that  <span class="math">\\overline{\\mathrm{index}}(\\mathbf{y}_m) \\neq 0</span> ,  <span class="math">\\overline{\\mathrm{index}}(\\mathbf{y}_m) \\neq H(\\ell)</span> . Finally, it verifies that  <span class="math">\\mathbf{y} = \\mathbf{y}_{m_0}</span> .</p>

    <p class="text-gray-300">Figure 4: Verification of index assignment by the client</p>

    <p class="text-gray-300">Epoch consistency proof. We require Index dictionary to be append-only, meaning that all indexes in the previous state must be included in the current state. Assume  <span class="math">\\overline{\\mathrm{index}}_i</span>  and  <span class="math">\\overline{\\mathrm{index}}_{i + 1}</span>  are the states of the index dictionary in epochs  <span class="math">i</span>  and  <span class="math">i + 1</span> . The server must prove that:  <span class="math">\\overline{\\mathrm{index}}_i\\subseteq \\overline{\\mathrm{index}}_{i + 1}</span> , which means that the new dictionary  <span class="math">\\mathsf{Index}_{i + 1}</span>  includes all the previous indexes from  <span class="math">\\mathsf{Index}_i</span> . This condition is expressed as, for all  <span class="math">\\mathbf{x}\\in \\{0,1\\}^{\\log_2N}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">Z (\\mathbf {x}) := \\overline {{\\operatorname {i n d e x} _ {i}}} (\\mathbf {x}) \\cdot \\left(\\overline {{\\operatorname {i n d e x}}} _ {i + 1} (\\mathbf {x}) - \\overline {{\\operatorname {i n d e x}}} _ {i} (\\mathbf {x})\\right) = 0 \\Rightarrow \\sum_ {\\mathbf {w} \\in \\{0, 1 \\} ^ {\\log_ {2} N}} \\mathsf {L} _ {\\mathbf {w}} (\\mathbf {X}) \\cdot Z (\\mathbf {w}) = 0</span></div>

    <p class="text-gray-300">The condition above corresponds to a zerocheck [Che+23]. At a high level, it requires the server to publish a sumcheck proof along with openings of the polynomials  <span class="math">\\overline{\\mathrm{index}}_i</span>  and  <span class="math">\\overline{\\mathrm{index}}_{i + 1}</span>  at a random challenge point  <span class="math">\\mathbf{r}</span> . Crucially, since both polynomials are opened at the same point, a homomorphic PCS enables these openings to be batched into a single one by verifying a random linear combination of the two commitments, thereby reducing the verification cost and the communication on the bulletin board. Since the sumcheck</p>

    <p class="text-gray-300">proof is relatively inexpensive in practice, the auditor’s cost is primarily dominated by the PCS verification(s), e.g. a multi-pairing of size <span class="math">k\\cdot N^{1/k}</span> when using KZH-k, where <span class="math">N</span> denotes the size of the dictionary. Our index dictionary can be thought of as an append-only zero-knowledge set (aZKS) as described in <em>[Cha+19]</em>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Overhead of index proof.</h4>

    <p class="text-gray-300">One potential issue with this approach arises when the identifier <span class="math">m_{0}</span> is large. In such cases, the server must open <span class="math">m_{0}</span> points on <span class="math">\\overline{\\text{index}}_{i}</span>, increasing both communication and computation for the server and client. To address this, we overprovision the dictionary capacity. This over-provisioning is necessary because labels are mapped to indexes using a random mapping, e.g. a hash fucntion. As the number of labels approaches the dictionary’s capacity <span class="math">N</span>, the probability of hash collisions increases. By setting the nominal capacity to a higher number than the expected number of labels, we significantly reduce the likelihood of such collisions, ensuring that the mapping remains efficient. Specifically, if we expect <span class="math">N</span> users, we set the capacity to be <span class="math">\\alpha\\times N</span> for <span class="math">2\\leq\\alpha</span>. This setup ensures that a fraction <span class="math">\\frac{\\alpha-1}{\\alpha}</span> of the dictionary remains deliberately unoccupied. Given that the hash function behaves like a random oracle, the probability that a new label <span class="math">\\ell</span> maps to an unassigned index <span class="math">\\mathcal{H}(0,\\ell)</span> is exactly <span class="math">\\frac{\\alpha-1}{\\alpha}</span>. Consequently, the likelihood that an identifier takes the value <span class="math">m_{0}</span> is given by:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{identifier}=m_{0}]=\\frac{\\alpha-1}{\\alpha^{m_{0}}}\\implies</span> <span class="math">\\mathbb{E}[\\text{Number of openings}]=\\sum_{m_{0}=1}^{\\infty}\\frac{\\alpha-1}{\\alpha^{m_{0}}}\\cdot m_{0}=\\frac{\\alpha}{\\alpha-1}</span></p>

    <p class="text-gray-300">For instance, setting <span class="math">\\alpha=4</span> results in the expected number of openings to be <span class="math">\\approx 1.33</span>. This indicates that, on average, the server must open approximately <span class="math">1.33</span> proofs, rather than just one. Setting <span class="math">\\alpha=4</span> increases the SRS size by a factor of <span class="math">4</span> and the verifier’s cost by <span class="math">2\\times</span>. While it increases the prover’s cost for opening the polynomial at random points, it does not impact the polynomial evaluation time, since evaluations at zero points do not contribute to the computation. Interestingly, when we instantiate IronDict with KZH, the number of group operations does not increase. This is because committing to zeros is essentially free in Pedersen-like commitment schemes.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Worst-case analysis.</h4>

    <p class="text-gray-300">Similar to most prior works <em>[Mel+15, Cha+19, Len+24]</em>, we employ an asymmetric, keyed Verifiable Random Function (VRF) <em>[MRV99]</em> instead of a simple hash function <span class="math">\\mathcal{H}</span> to assign indices to users. This choice enhances both security and privacy because the output of a hash function is deterministic and publicly computable, allowing adversaries to precompute hashes offline and potentially link dictionary entries to known labels—enabling various attacks <em>[Mel+15]</em>. Specifically, if <span class="math">\\mathcal{H}</span> were directly evaluable by an adversary, they could craft labels that produce large identifiers <span class="math">m_{0}</span>, increasing the computational burden of the server. In contrast, the output of a VRF cannot be computed</p>

    <p class="text-gray-300">by clients themselves, effectively preventing brute-force attempts. As a result, we can assume that the output of <span class="math">\\mathcal{H}</span> is uniformly random and has not been precomputed by the adversary. This allows our worst-case analysis to align closely with the average-case scenario.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Comparison to cuckoo hashing.</h4>

    <p class="text-gray-300">A related strategy to open addressing for handling collisions in a hash table is cuckoo hashing <em>[x21, x13]</em>. In open addressing, when a collision occurs, the algorithm searches for the next available slot (using linear, quadratic, or double hashing), but already-inserted elements remain untouched. In contrast, cuckoo hashing uses multiple hash functions and allows each key to occupy one of several candidate positions. When a collision occurs, the new key displaces the existing key, which must then be reinserted into the table, potentially triggering a chain of displacements. This key feature of displacing previously assigned elements makes cuckoo hashing more dynamic but can also lead to more complex insertions, including occasional full rehashing. While cuckoo hashing can more efficiently utilize available slots, open addressing is a more natural fit for our purposes as previously inserted elements are never displaced. This lets us take advantage of the append-only property, which can be naturally and simply expressed using polynomial equations. We leave an investigation of cuckoo hashing-based index polynomial to future work.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">4.4 Value consistency</h3>

    <p class="text-gray-300">An important feature of a transparent dictionary is <em>value consistency</em>, a resource-constrained client should be able to succinctly verify that its value has not changed over a specific period. This translates to checking whether the value corresponding to a specific label has remained unchanged from epoch <span class="math">i</span> to epoch <span class="math">j</span>. A naive approach would involve opening all commitments <span class="math">\\overline{\\text{value}}_{i}</span>, <span class="math">\\overline{\\text{value}}_{i+1}</span>, <span class="math">\\ldots</span>, <span class="math">\\overline{\\text{value}}_{j}</span>, at the index corresponding to the client and verifying that the value has not changed. However, this would be inefficient for both the client and the server since on each consistency check, the server computation, the client computation and the communication complexity are linear in the number of epochs. Our solution leverages randomness and is concretely more efficient when using a homomorphic PCS; we refer to this approach as <em>RLC (random linear combination) based approach</em>. In the RLC-based approach, when the PCS is homomorphic such as KZH, the server performs <span class="math">O(n)</span> group operations per epoch, where <span class="math">n</span> is the number of updated entries. This yields constant-sized communication on <span class="math">\\mathsf{BB}</span> and constant auditor verification time. The server simply publishes a few PCS commitments on <span class="math">\\mathsf{BB}</span>, and the auditor checks a homomorphic relation between them, i.e. equation (1). However, if the PCS is not homomorphic, non-homomorphically evaluating the same check requires four polynomial openings—due to the four distinct polynomials in equation (1)—and publishing their openings at a random point on <span class="math">\\mathsf{BB}</span>.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">In our approach, retrieving the full value history requires work linear in the number of value changes. However, most clients are primarily interested in value consistency:</p>

    <p class="text-gray-300">verifying that their value has remained unchanged over a given period. In this common use case, both the server’s and verifier’s proofs are independent of the number of value changes or the number of intermediate epochs.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">RLC-based approach.</h4>

    <p class="text-gray-300">We define the difference polynomial <span class="math">\\overline{\\Delta_{i}}(\\mathbf{X})</span>, which is essentially the polynomial corresponding to the update at epoch <span class="math">i</span>, as below:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\Delta_{i}}(\\mathbf{X})=\\overline{\\mathrm{value}}_{i}(\\mathbf{X})-\\overline{\\mathrm{value}}_{i-1}(\\mathbf{X})</span> <span class="math">\\implies\\overline{\\mathrm{value}}_{j}(\\mathbf{X})=\\overline{\\mathrm{value}}_{i}(\\mathbf{X})+\\sum_{t=i+1}^{j}\\overline{\\Delta_{t}}(\\mathbf{X})</span></p>

    <p class="text-gray-300">The naive approach to verifying whether a value remains unchanged between two epochs <span class="math">i</span> and <span class="math">j</span> is to simply open the value at both epochs and compare the values for equality. However, this method is vulnerable to a ghost-value attack, in which the server temporarily modifies the value during some intermediate epoch and later reverts it to its original value. To prevent such attacks, we introduce randomness in a way that ensures changes to a value–even if reverted–cannot cancel each other out. Strawman fix would be for the client to send randomness <span class="math">r_{i+1}</span>, <span class="math">r_{r+2},\\ldots,r_{j}</span> to the server, server computes</p>

    <p class="text-gray-300"><span class="math">\\overline{\\mathrm{rand}}(\\mathbf{X})=\\overline{\\mathrm{value}}_{i}(\\mathbf{X})+\\sum_{t=i+1}^{j}r_{t}\\cdot\\overline{\\Delta_{t}}(\\mathbf{X}),</span></p>

    <p class="text-gray-300">and client given commitments to <span class="math">\\overline{\\mathrm{value}}_{i}(\\mathbf{x})</span> and the random coefficients can compute commitment to polynomial <span class="math">\\overline{\\mathrm{rand}}(\\mathbf{X})</span> through homomorphism. Now that the value hasn’t changed in the epochs <span class="math">i</span> to <span class="math">j</span> with an overwhelming probability, we have <span class="math">\\overline{\\mathrm{rand}}(\\mathbf{X})</span> and <span class="math">\\overline{\\mathrm{value}}_{i}(\\mathbf{X})</span> open to the same value at the index corresponding to the user. Client checks that by requesting the server to open both commitments at the user index and verifying their equality. However, the above solution is too costly both for the server and the client. Each consistency check requires both the server and the client to perform linear computation and communication in the number of epochs. Another issue arises because the client sends the randomness directly to the server. The server must recompute all relevant operations using the new random value for each client request, leading to significant computational overhead. We address all of these inefficiencies by applying the Fiat-Shamir transform <em>[x10]</em>, replacing interactive randomness exchange with a non-interactive mechanism, e.g. derive the randomness by hashing the current state of the <span class="math">\\mathsf{BB}</span>. Consider the following polynomial, which is recursively defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\mathrm{rand}}_{i}(\\mathbf{X})=\\overline{\\mathrm{value}}_{0}(\\mathbf{X})+\\sum_{t=1}^{i}r_{t}\\cdot\\overline{\\Delta_{t}}(\\mathbf{X})=\\overline{\\mathrm{rand}}_{i-1}(\\mathbf{X})+r_{i}\\cdot\\overline{\\Delta_{i}}(\\mathbf{X})</span></p>

    <p class="text-gray-300">At each epoch, the server publishes a commitment to <span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{X})</span>, where correctness can be verified by auditors using the homomorphism through the equation</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{X})</span> <span class="math">=\\overline{\\text{rand}}_{i-1}(\\mathbf{X})+r_{i}\\cdot\\overline{\\Delta_{i}}(\\mathbf{X})</span> <span class="math">=\\overline{\\text{rand}}_{i-1}(\\mathbf{X})+r_{i}\\cdot\\left(\\overline{\\text{value}}_{i}(\\mathbf{X})-\\overline{\\text{value}}_{i-1}(\\mathbf{X})\\right)</span> (1)</p>

    <p class="text-gray-300">It requires the auditors to ensure that randomness <span class="math">r_{i}</span> is derived correctly through the Fiat-Shamir transformation. To verify the consistency of a value at index <span class="math">\\mathbf{x}</span> from epoch <span class="math">i</span> to epoch <span class="math">j</span>, the client simply queries the openings of <span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{X})</span> and <span class="math">\\overline{\\text{rand}}_{j}(\\mathbf{X})</span> at <span class="math">\\mathbf{x}</span>. If <span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{x})=\\overline{\\text{rand}}_{j}(\\mathbf{x})</span>, then with overwhelming probability, the value at index <span class="math">\\mathbf{x}</span> has remained unchanged between epochs <span class="math">i</span> and <span class="math">j</span>. On the client side, the computational complexity of the consistency check amounts to two PCS verifications—independent of the number of epochs—which can be further reduced to a single opening if the underlying PCS supports homomorphism. On the server side, only two PCS openings at a Boolean point are required. Finally, the auditor’s task is limited to verifying a single homomorphic relation and checking that the randomness <span class="math">r_{i}</span> is correctly derived.</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Adapting the approach to non-homomorphic PCS.</h4>

    <p class="text-gray-300">While the homomorphic relation can be directly verified using homomorphic PCS, it is also possible to check such equalities non-homomorphically by evaluating both sides at a random point. Specifically, auditors verify equation (1) as follows: Given commitments to <span class="math">\\overline{\\text{rand}}_{i-1}(\\mathbf{X})</span>, <span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{X})</span>, <span class="math">\\overline{\\text{value}}_{i-1}(\\mathbf{X})</span>, and <span class="math">\\overline{\\text{value}}_{i}(\\mathbf{X})</span>, this equality can be verified non-homomorphically by evaluating all polynomials at a random point <span class="math">\\mathbf{r}</span> and checking:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i}(\\mathbf{r})=\\overline{\\text{rand}}_{i-1}(\\mathbf{r})+r_{i}\\cdot\\left(\\overline{\\text{value}}_{i}(\\mathbf{r})-\\overline{\\text{value}}_{i-1}(\\mathbf{r})\\right).</span></p>

    <p class="text-gray-300">Such a random evaluation point <span class="math">\\mathbf{r}</span> can be derived via a hash of the commitments. This method requires the server to publish four PCS openings at the point <span class="math">\\mathbf{r}</span> on <span class="math">\\mathsf{BB}</span>, which the auditors must verify.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">Equivalence of value consistency and value history.</h4>

    <p class="text-gray-300">We note that value consistency and value history, a concept primarily used in tree-based approaches, refer to the same underlying idea. However, since value consistency aligns more closely with user interests, we adopt it in our setting. To see the equivalence, consider that given the value history <span class="math">\\{(n_{i},\\upsilon_{i})\\}_{i\\in[m]}</span>, where <span class="math">n_{i}</span> denotes the epoch at which the value changes to <span class="math">\\upsilon_{i}</span>, it is straightforward to verify whether the value remained unchanged between any two epochs. Conversely, if a value has changed at epochs <span class="math">n_{1},\\ldots,n_{m}</span>, the server can prove the full value history by showing that the value did not change within each interval <span class="math">[n_{i},n_{i+1})</span> and by revealing the value at each epoch <span class="math">n_{i}</span>. This requires a linear number of lookups and consistency checks proportional to the number of value changes.</p>

    <p class="text-gray-300">4.5 Transparent dictionary construction</p>

    <p class="text-gray-300">We generically present IronDict construction over a PCS in Figures 5, 6, and 7. For simplicity, we assume the PCS supports homomorphic operations; if not, these operations can instead be carried out by having the auditor receive polynomial openings at a random evaluation point, as discussed in Section 4.4.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let PCS be a secure multilinear polynomial commitment scheme. Then, the IronDict construction—outlined in Figures 5, 6, and 7—achieves completeness and soundness in the random oracle model, as formalized in Appendix B.</p>

    <p class="text-gray-300">We defer a formal proof of security to Appendix C.</p>

    <h5 id="sec-44" class="text-base font-semibold mt-4">Cost overview of IronDict.</h5>

    <p class="text-gray-300">Table 8 presents an overview of the costs for each party in IronDict when initialized with KZH, with the additional costs for zk-IronDict highlighted in blue.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">4.6 zk-IronDict</h3>

    <p class="text-gray-300">The goal of a <em>privacy-preserving</em> transparent dictionary <em>[x14, x10]</em> is to ensure that commitments to the dictionary reveal no information about its underlying contents and that proofs provided by the server disclose only what is strictly necessary. This aligns with the notion of metadata privacy, as distinguished in prior work <em>[x11]</em>, which identifies two categories of privacy: (1) content privacy and (2) metadata privacy. Content privacy refers to access control policies enforced by the server—for instance, allowing users to retrieve only the public keys of their contacts, thereby mitigating spam (when the transparent dictionary is used as a PKI). These policies are external to the design of the transparent dictionary. In contrast, metadata privacy, which is the focus of a privacy-preserving transparent dictionary, aims to prevent leakage of information by the server, for example, as a result of publishing commitments on the bulletin board. Privacy is essential in settings such as secure messaging. If the server leaked patterns of value updates, a malicious party could infer which users frequently rotate their keys and which do not, potentially identifying less cautious users or rarely used devices. In another case, if an attacker compromises a device’s value and observes that it remains unchanged in the next epoch, they can conclude that the device owner is unaware of the breach.</p>

    <h5 id="sec-46" class="text-base font-semibold mt-4">Privacy in previous work.</h5>

    <p class="text-gray-300">CONIKs <em>[x14]</em> described a notation of privacy which was later formalized by SEEMless <em>[x10]</em> that defined privacy through a formal leakage function, ensuring that the information published by the server, namely, commitments posted on the bulletin board and accompanying proofs, reveals no more than what the leakage function allows. For instance, in SEEMless, the leakage function for value queries unnecessarily reveals the value’s version number and the epoch of its last update. A further</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(\\lambda, \\mu) \\to (\\text{key}_{\\text{Server}}; \\text{key}_{\\text{Auditor}}, \\text{key}_{\\text{Client}})</span> : Given a security parameter  <span class="math">\\lambda</span>  and logarithmic of maximum supported size  <span class="math">\\mu^a</span> , this algorithm runs SetupPCS  <span class="math">(\\lambda, \\mu)</span>  and output (vk, pk). Algorithm sets keyServer := pk, keyAuditor := vk and keyClient := vk and outputs these.</li>

      <li>Server. Init()  <span class="math">\\rightarrow</span>  (state0, com0): Given the dictionary size  <span class="math">N := 2^{\\mu}</span>  and the PCS prover key, the server initializes three zero multilinear polynomials  <span class="math">\\overline{\\text{index}_0}</span> ,  <span class="math">\\overline{\\text{value}_0}</span>  and  <span class="math">\\overline{\\text{rand}_0}</span> , computes commitments to these polynomials and sets the tuple as  <span class="math">\\text{com}_0</span>  and publishes  <span class="math">\\text{com}_0</span>  on BB. At each epoch,  <span class="math">\\text{state}_i</span>  consists of the latest polynomials  <span class="math">\\overline{\\text{index}_i}</span> ,  <span class="math">\\overline{\\text{value}_i}</span> , and  <span class="math">\\overline{\\text{rand}_i}</span> . The commitment state,  <span class="math">\\text{com}_i</span> , includes the PCS commitments to these polynomials, which may not be explicitly described later.</li>

      <li>Server.Update(statei,  <span class="math">\\Delta</span> )  <span class="math">\\rightarrow</span>  (statei+1, comi+1,  <span class="math">\\pi_{i+1}</span> ): Parse  <span class="math">\\Delta</span>  as  <span class="math">(\\Delta_{\\mathrm{index}}, \\Delta_{\\mathrm{value}})</span>  and perform the update for each of them as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Index dictionary: Parse  <span class="math">\\Delta_{\\mathrm{index}} = \\{\\ell_j\\}_{j\\in [n_1]}</span>  and ensure all labels  <span class="math">\\ell_j</span>  are not previously assigned indexes. Assign index  <span class="math">\\mathbf{x}_j</span>  to each  <span class="math">\\ell_j</span>  according to Figure 3 and define:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\operatorname {i n d e x}}} _ {i + 1} (\\mathbf {x}) = \\left\\{ \\begin{array}{l l} H (\\ell_ {j}) &amp;amp; : \\mathbf {x} = \\mathbf {x} _ {j} \\\\ \\overline {{\\operatorname {i n d e x}}} _ {i} (\\mathbf {x}) &amp;amp; : \\text {o t h e r w i s e} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Compute commitment to  <span class="math">\\overline{\\mathrm{index}}_{i + 1}</span>  (possibly homomorphically) and run a zero-check for  <span class="math">\\overline{\\mathrm{index}}_i(\\mathbf{x})\\cdot \\left(\\overline{\\mathrm{index}}_{i + 1}(\\mathbf{x}) - \\overline{\\mathrm{index}}_i(\\mathbf{x})\\right)</span> , and output  <span class="math">\\pi_{\\mathrm{register}}</span>  which is essentially the zero-check proof.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Value dictionary: Parse  <span class="math">\\Delta_{\\mathrm{value}} = \\{(\\ell_j, v_j)\\}_{j \\in [n_2]}</span> , retrieve indices  <span class="math">\\mathbf{x}_j</span>  and define:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\Delta_ {i} (\\mathbf {x}) = \\left\\{ \\begin{array}{l l} v _ {j} &amp;amp; : \\mathbf {x} = \\mathbf {x} _ {j} \\\\ 0 &amp;amp; : \\text {o t h e r w i s e} \\end{array} \\right.</span></div>

    <p class="text-gray-300">Update  <span class="math">\\overline{\\mathrm{value}}_{i + 1} = \\overline{\\mathrm{value}}_i + \\overline{\\Delta_i}</span>  and compute its commitment (possibly homomorphically), derive  <span class="math">r_i</span>  and set  <span class="math">\\overline{\\mathrm{rand}}_{i + 1} = \\overline{\\mathrm{rand}}_i + r_i\\cdot \\overline{\\Delta_i}</span>  and again compute polynomial commitment to  <span class="math">\\overline{\\mathrm{rand}}_{i + 1}</span>  too.</p>

    <p class="text-gray-300">It outputs new state  <span class="math">\\mathsf{state}_{i + 1}</span> , commitment  <span class="math">\\mathsf{com}_{i + 1}</span>  and proof of epoch  <span class="math">\\pi_{i + 1} = (\\pi_{\\mathrm{register}},\\pi_{\\mathrm{value}})</span>  where  <span class="math">\\pi_{\\mathrm{value}}</span>  is empty is the PCS is homomorphic, otherwise it contains PCS openings at a random point, used to evaluate the homomorphic relation, non-homomorphically.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Server.Lookup  <span class="math">(\\ell, \\text{state}_i) \\to (\\text{value}, \\pi_{\\text{Lookup}})</span> : Retrieve index  <span class="math">\\mathbf{x}</span>  corresponding to  <span class="math">\\ell</span>  along with proof  <span class="math">\\pi_{\\text{index}}</span>  that proves  <span class="math">\\mathbf{x}</span>  is the valid index for label  <span class="math">\\ell</span>  according to Figure 4. Generate PCS opening  <span class="math">\\pi_{\\text{PCS}}</span>  that opens value =  <span class="math">\\overline{\\text{value}}_i(\\mathbf{x})</span>  and finally output  <span class="math">(\\mathbf{x}, \\pi_{\\text{index}}, \\pi_{\\text{PCS}})</span> .</li>

      <li>Client.VerifyLookup  <span class="math">(\\ell, \\mathsf{com}_i, \\mathsf{value}, \\pi_{\\mathsf{Lookup}}) \\to 0/1</span> : Verify index proof using  <span class="math">\\pi_{\\mathsf{index}}</span>  as described in Figure 4 and value using PCS opening  <span class="math">\\pi_{\\mathsf{PCS}}</span> , which essentially verifies that value =  <span class="math">\\overline{\\mathsf{value}}_i(\\mathbf{x})</span> .</li>

      <li>Server. Consistency  <span class="math">(\\ell, \\text{state}_i, \\text{state}_j) \\to \\pi_{\\text{consis}}</span> : This is similar to a lookup operation, but instead of opening  <span class="math">\\overline{\\text{value}}_i</span> , we open  <span class="math">\\overline{\\text{rand}}_i</span>  and  <span class="math">\\overline{\\text{rand}}_j</span>  at the index. More precisely, retrieve index  <span class="math">\\mathbf{x}</span>  corresponding to  <span class="math">\\ell</span>  along with proof  <span class="math">\\pi_{\\text{index}}</span>  that proves  <span class="math">\\mathbf{x}</span>  is the valid index for label  <span class="math">\\ell</span>  according to Figure 4. Generate PCS opening  <span class="math">\\pi_{\\text{PCS},i}</span>  and  <span class="math">\\pi_{\\text{PCS},j}</span>  that opens  <span class="math">\\overline{\\text{rand}}_i</span>  and  <span class="math">\\overline{\\text{rand}}_j</span>  at index  <span class="math">\\mathbf{x}</span>  and finally output  <span class="math">(\\mathbf{x}, \\pi_{\\text{index}}, \\pi_{\\text{PCS},i}, \\pi_{\\text{PCS},j})</span> .</li>

      <li>Client. VerConsistency  <span class="math">(\\ell, \\mathsf{com}_i, \\mathsf{com}_j, \\pi_{\\mathrm{consis}}) \\to 0/1</span> : Verify index proof using  <span class="math">\\pi_{\\mathrm{index}}</span>  as described in Figure 4 and value using PCS openings  <span class="math">\\pi_{\\mathsf{PCS},i}</span>  and  <span class="math">\\pi_{\\mathsf{PCS},j}</span> . Finally check that openings values are equal which essentially proves  <span class="math">\\overline{\\mathrm{rand}}_i(\\mathbf{x}) = \\overline{\\mathrm{rand}}_j(\\mathbf{x})</span> .</li>

    </ul>

    <p class="text-gray-300">Figure 6: IRONDICT lookup and proof of consistency functionalities</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Auditor.VerifyInvariance  <span class="math">(\\mathsf{com}_i,\\mathsf{com}_{i + 1},\\pi_{i + 1})\\to 0 / 1</span>  : Parse  <span class="math">\\pi_{i + 1}</span>  as  <span class="math">(\\pi_{\\mathrm{register}},\\pi_{\\mathrm{value}})</span>  now the auditor checks the two following checks: (1) verify  <span class="math">\\pi_{\\mathrm{register}}</span>  which is essentially verifying the zerocheck, and (2) recompute  <span class="math">r_i</span>  through Fiat-Shamir heuristic and check that the following relations hold between polynomials underlying commitments  <span class="math">\\mathrm{com}(\\overline{\\mathrm{value}}_i)</span> <span class="math">\\mathrm{com}(\\overline{\\mathrm{value}}_{i + 1})</span> <span class="math">\\mathrm{com}(\\overline{\\mathrm{rand}}_i)</span>  and  <span class="math">\\mathrm{com}(\\overline{\\mathrm{rand}}_i)</span>  ..</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\operatorname {r a n d}}} _ {i + 1} (\\mathbf {X}) = \\overline {{\\operatorname {r a n d}}} _ {i} (\\mathbf {X}) + r _ {i} \\cdot \\left(\\overline {{\\operatorname {v a l u e}}} _ {i + 1} (\\mathbf {X}) - \\overline {{\\operatorname {v a l u e}}} _ {i} (\\mathbf {X})\\right)</span></div>

    <p class="text-gray-300">This identity can be checked, for example, via homomorphism. Otherwise, it can be checked non-homomorphically by  <span class="math">\\pi_{\\mathrm{value}}</span> , which includes opening of all four polynomials at a random point, as explained in Section 4.4.</p>

    <p class="text-gray-300">Figure 7: IRONDICT auditor functionality</p>

    <p class="text-gray-300">limitation of defining privacy through a leakage function is its fragility: the leakage must be carefully specified, and even minor changes to the system can alter it, requiring new proofs.</p>

    <h5 id="sec-47" class="text-base font-semibold mt-4">zk-IronDict’s notion of privacy.</h5>

    <p class="text-gray-300">IronDict is generically built on a PCS. The server reveals three main components: PCS commitments, PCS openings, and sumcheck proofs. Suppose the underlying PCS provides hiding commitments and zero-knowledge openings <em>[B+21, B+21]</em>, and the sumcheck protocol is also zero-knowledge. In that case, each piece of published information proves only what is intended–nothing more. Specifically, hiding commitments protect the contents of the committed dictionary with no leakage, while zero-knowledge openings and sumcheck proofs ensure that the verifier learns only the claimed evaluation results and nothing beyond. There are general compilers <em>[CFS17, BS+19]</em> that can make sumcheck protocols zero-knowledge with minimal overhead. Our construction is concretely based on KZH, which by default does not support hiding. One could apply generic compilers designed to make homomorphic commitments hiding <em>[B+21]</em>, but they involve generating and committing to randomness linear in the size of the polynomial. In Appendix D, we present a <em>zero-knowledge variant of KZH</em>, which may be of independent interest. This construction requires only <span class="math">k^{2}\\cdot N^{1/k}+k\\cdot N^{1/k}</span> random scalars per opening on the server side. Specifically, <span class="math">k^{2}\\cdot N^{1/k}</span> scalars are needed to construct random polynomial <span class="math">r</span> with <span class="math">k\\cdot N^{1/k}</span> non-zero values together with its auxiliary inputs. Since there are <span class="math">k-1</span> auxiliary inputs, and each requires <span class="math">k\\cdot N^{1/k}</span> scalar multiplications, the total cost amounts to <span class="math">k^{2}\\cdot N^{1/k}</span> for generating the polynomial commitment along with its auxiliary inputs. Importantly, this cost is independent of the opening point and can therefore be precomputed by the server. The remaining term, <span class="math">k\\cdot N^{1/k}</span>, corresponds to taking a random linear combination of the random polynomial with another polynomial and computing its opening at the client’s desired point; this cost arises in the online phase. When applying zk-KZH, homomorphic relations over blinded commitments cannot be verified directly as in the unblinded case. Instead, they require an additional sigma protocol, which introduces only a small overhead for both the server and auditors wishing to verify such relations. We describe this procedure in more detail in Appendix D.3.</p>

    <h5 id="sec-48" class="text-base font-semibold mt-4">Size leakage.</h5>

    <p class="text-gray-300">Our privacy definition ensures that all public information posted by the server—such as commitments, sumcheck proofs, etc.—is zero-knowledge and reveals nothing beyond what it is intended to convey. Similarly, client queries (e.g., lookups and consistency proofs) reveal only the requested value in the dictionary. However, our construction leaks information about the <em>size</em> of the dictionary. In particular, the SRS inherently reveals an <em>upper bound</em> on the number of users, and the frequency of collisions in open-addressing leaks information about the current number of users. An adversary seeking information on the number of users could conduct probing attacks, registering multiple labels and, based on their identifiers (e.g., the number of hashes required to find an empty slot), infer statistical information on the current number of users. We leave analysis of such attacks to</p>

    <p class="text-gray-300">future work, noting that they do not contradict our zero-knowledge-based privacy definition. Furthermore, similar size information is leaked by Merkle-tree-based implementations. We consider it out of scope of our privacy definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Party</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Computation Cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication on BB</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Index Assignment</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) G: compute new PCS commitment O(N) F: zerocheck and polynomial eval O(n) VRF P: open addressing (expected) ≈ √N G: KZH-k opening with k > 2 O(k2·Nk) G: only for zk-IRONDICT</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Auditor</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) H: zerocheck verification O(log N) F: zerocheck verification k·N1/k P: PCS opening verification</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Epoch Update</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n) G: compute new PCS commitment O(1) H: compute Fiat-Shamir challenge</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Auditor</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1) H: compute Fiat-Shamir challenge O(1) G: homomorphic check of (1)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lookup</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1): PCS opening (Boolean point) O((k2+k)·Nk) G: only for zk-IRONDICT</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">k·N1/k P: PCS verification O(1) VRF V: open addressing (expected)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Value Consistency</td>

            <td class="px-3 py-2 border-b border-gray-700">Server</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1): two PCS openings (Boolean point) O((k2+k)·Nk) G: only for zk-IRONDICT</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Client</td>

            <td class="px-3 py-2 border-b border-gray-700">2k·N1/k P: two PCS verifications O(1) VRF V: open addressing (expected)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 8: Summary of IRONDICT costs when using the KZH-k scheme: Here  <span class="math">N</span>  is the maximum capacity of the dictionary (including the a constant over-provisioning factor) and  <span class="math">n</span>  is the number of updates in the epoch.  <span class="math">\\mathbb{G}</span>  denotes a group scalar multiplication,  <span class="math">\\mathbb{F}</span>  a field operation,  <span class="math">\\mathbb{H}</span>  a hash function, and  <span class="math">\\mathbb{P}</span>  a pairing.  <span class="math">\\mathrm{VRF}_{\\mathcal{P}}</span>  and  <span class="math">\\mathrm{VRF}_{\\mathcal{V}}</span>  denote VRF proof generation and verification, i.e. we assume the server uses a verifiable pseudorandom function instead of the hash function  <span class="math">\\mathcal{H}</span>  to assign indexes. Parameter  <span class="math">k</span>  is the KZH-k variant. Red-highlighted costs apply only for  <span class="math">k &amp;gt; 2</span> , as KZH-2 avoids group operations for opening random points. PCS verification also includes an MSM, but its cost is omitted as negligible compared to pairings. Blue-highlighted costs apply for the privacy-preserving variant zk-IRONDICT as described in Section 4.6.</p>

    <p class="text-gray-300">Remark 3. The proof of invariance or correctness—namely the zerocheck proof—does not necessarily need to be published on the bulletin board (BB), as long as the corresponding polynomial commitments are made public. Instead, these proofs can be communicated directly between the server and auditors upon request. For this reason, we state that the communication cost on BB is  <span class="math">O(1)</span>  for both index assignment and value updates, since we assume only the new polynomial commitments are posted on BB.</p>

    <p class="text-gray-300">5 Implementation and Evaluation</p>

    <p class="text-gray-300">We implement and benchmark zk-IronDict in 4000 lines of Rust code. Our implementation is built atop the arkworks <em>[x10]</em> framework, and also uses the Hyperplonk <em>[Che+23]</em> repository for the multivariate zerocheck and sumcheck implementations. For our PCS instantiation, we implement KZH-k <em>[Kad+25]</em> from scratch, with a tunable parameter k, in additional 2500 lines of Rust code, inspired by the original KZH implementation. In our experiments, we set <span class="math">k=(\\log N)/2</span> where <span class="math">N</span> is the polynomial size. All server measurements are performed on a Google c4-highmem-144-lssd instance with 144 CPU cores and 1116 GB of memory. Client and auditor measurements are performed single-threaded on a MacBook Pro with 18 GB of RAM and a 12-core Apple M3 Pro CPU. We use the curve Bn254 for all our measurements, which is a standard pairing-friendly curve used in industry <em>[x2]</em>. We employ a Schnorr signature-based VRF <em>[x24]</em> in place of a hash function mapping arbitrary strings to points on the Boolean hypercube. All measurements are done over two dictionary sizes: (a) a small dictionary with <span class="math">2^{24}</span> (over 10 million) entries for light-weight use cases such as software distribution (b) a large dictionary with <span class="math">2^{30}</span> (over 1 billion) entries for large-scale use cases such as messaging applications. Also, we report the numbers with an overprovisioning factor of <span class="math">\\alpha=4</span>; meaning that the reported capacity utilizes <span class="math">\\frac{1}{4}</span> of the implemented data structure, e.g. the polynomial underlying the dictionary of size <span class="math">2^{30}</span> is of size <span class="math">2^{32}</span>.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Remark 4.</h6>

    <p class="text-gray-300">All reported numbers in this section, for both small and large dictionaries, correspond to zk-IronDict. While privacy is unnecessary for applications such as software distribution, we present the privacy-preserving results to illustrate how performance scales from 10 million to 1 billion entries. The main impact of adding privacy to IronDict is on server lookup and consistency proofs—for example, using IronDict instead of zk-IronDict with the small dictionary reduces server time for lookups and consistency proofs from 10ms to under 1ms, yielding a <span class="math">10\\times</span> improvement.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">5.1 Server costs</h3>

    <p class="text-gray-300">We benchmark four important server operations: Index assignment, value update, lookups and consistency proofs. Also, we measure the size of the server key, which persistently resides in memory.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Index assignment time.</h5>

    <p class="text-gray-300">We evaluate the time and communication cost (message size) incurred by the server when posting to the bulletin board to register a batch of new indices.</p>

    <p class="text-gray-300">We are primarily interested in the operational range under 1000 updates per second <span class="math">^{12}</span> , and we mark this threshold in Figure 9. Within this range, the index assignment time is dominated by the time required to run a sumcheck prover on a polynomial of the dictionary size, which scales linearly with the dictionary size. After a certain point—outside the operational region—the cost of PCS opening begins to affect the overall registration cost which we can ignore. Figure 9 shows that for the small dictionary, the index assignment time is at around 10 seconds, while for the large dictionary, it is around 15 minutes.</p>

    <p class="text-gray-300">Value dictionary update. Unlike the index dictionary, where update costs scale with the full dictionary size, updates to the value dictionary depend only on the batch size. The update time mainly reflects the cost of committing to a highly sparse update polynomial, which requires an MSM proportional to the batch size. As shown in Figure 9, for batches of hundreds to thousands, updates take around 2 seconds for the small dictionary and around 2 minutes for the large dictionary. The corresponding bulletin board message remains a small constant as well, under  <span class="math">1\\mathrm{kB}</span>  per batch.</p>

    <p class="text-gray-300">Lookups and consistency. Both lookup and consistency queries involve opening two polynomials at a point on the Boolean hypercube: value and index for lookups, and rand <span class="math">_i</span>  and rand <span class="math">_j</span>  for consistency. As a result, their server costs are nearly the same. Section 5.1 shows that for the small dictionary, the server time is around 15 milliseconds, while for the large dictionary it doubles to 30 milliseconds.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 9: Server performance</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a></p>

    <p class="text-gray-300">We evaluate the cost of two types of client-side queries, namely: lookup and value consistency. As mentioned in Section 5.1, these operations have similar costs. In both cases, the cost is dominated by two PCS verifications. This results in nearly identical performance for both query types. Figure 10 illustrates that for both small and large dictionaries, the lookup verification time is under  <span class="math">30\\mathrm{ms}</span> . Also, the client key size is less than  <span class="math">1\\mathrm{MB}</span> . The communication cost for the lookup query, as illustrated in Figure 10 remains under  <span class="math">5\\mathrm{kB}</span> .</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Figure 10: Client performance</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">The auditor cost is dominated by the time taken to verify a PCS opening at a random point. There is also a logarithmic field operation cost for verifying the sumcheck proof, which is negligible compared to the PCS opening time. Figure 11 shows that for small and large dictionaries, the auditor can verify a single epoch less than  <span class="math">35\\mathrm{ms}</span> . This allows light-weight auditors, without needing to outsource the verification to a third party. Also Figure 11 shows that the audit proof size is less than  <span class="math">8\\mathrm{kB}</span> .</p>

    <p class="text-gray-300">A crucial consideration in our scheme is the size and nature of the structured reference string (SRS). The small dictionary requires an srs of size less than 6 Gigabytes, while the large dictionary requires an SRS of size less than 350 Gigabytes. In practice, such SRSs are typically generated via multi-party ceremonies [WCB25] that require at least one party to remain honest. The largest SRS generated that we are aware of has been done by Filecoin with a size of approximately 12GB [Pro20]. The ceremony is designed to minimize communication among participants. Specifically, each participant obtains the</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Figure 11: Auditor performance</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">current SRS state from the previous one, verifies its correctness via pairing checks, updates it, and then forwards it to the next participant. On Google c4-highmem-144-lssd with a cost rate of 11.36 USD per hour, generating the SRS for our large dictionary with  <span class="math">2^{30}</span>  users (i.e. the underlying polynomial of size  <span class="math">2^{32}</span> ) takes almost 1 hour, highlighting the practicality of the approach. For example, if 10 servers jointly perform the generation, the total cost would be about 110 USD and it takes around 10 hours because of the sequential nature of the ceremony. Finally, we emphasize that the KZH SRS is updateable, allowing it to be periodically refreshed through new ceremonies.</p>

    <p class="text-gray-300">A key design parameter in transparent dictionaries is the delay between consecutive epochs. This delay determines how quickly a client's value update is reflected publicly. For example, assume that a client requests to change their value; however, until the next epoch, the server may either continue responding with a stale value or respond with a value that is not yet consistent with the published commitment, updating it in the subsequent epoch. The latter approach is taken by CONIKS [Mel+15], but it is unclear how a client can verify the correctness of such intermediate responses. In contrast, schemes like SEEMless [Cha+19] achieve very short epoch intervals (e.g., under one minute) to avoid this issue entirely. In our scheme, updates fall into two categories: (1) assigning indexes to new labels and (2) updating values for existing labels. The second type of update requires only  <span class="math">n</span>  group operations, where  <span class="math">n</span>  is the number of labels in an epoch, whereas the first requires a linear number of field operations in the dictionary size. Importantly, these two updates rely on separate underlying polynomials, allowing us to perform them asynchronously. As a result, we can adopt short delays for value updates—similar to SEEMless—thereby preventing stale value responses, while using longer intervals for assigning new indexes to users, which is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lookup time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consistency check time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Auditor</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Client (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Server (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Client (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Server (ms)</td>

            <td class="px-3 py-2 border-b border-gray-700">Server time (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Client time (s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof Size (MB)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">WhatsApp AKD</td>

            <td class="px-3 py-2 border-b border-gray-700">0.5</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">13</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700">1200</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">zk-IRONDICTk</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">900</td>

            <td class="px-3 py-2 border-b border-gray-700">0.035</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison of WhatsApp AKD over a dictionary of size 100 million and zk-IRONDICT over a dictionary of size more than 1 billion  <span class="math">(2^{30})</span> . For the consistency check of WhatsApp AKD, we assume that the key has been changed 10 times, i.e. its consistency check scales linearly with this number, while the consistency check of IRONDICT is independent.</p>

    <p class="text-gray-300">computationally more expensive. This separation avoids introducing inconsistencies due to stale values. Specifically, our index assignment time for dictionaries with fewer than 100 million entries is under a minute, comparable to SEEMless. This allows us to support short epoch durations. However, for a dictionary with a capacity of 1 billion, the index assignment takes approximately 15 minutes. Given recent advancements in hardware acceleration for cryptographic operations [Daf+25], we believe this time can be significantly reduced.</p>

    <p class="text-gray-300">In early systems like CONIKS, the delay between epochs was a critical parameter due to a trade-off between epoch frequency and the cost of consistency proofs. These systems lacked dedicated support for proving consistency, requiring the client to naively check all states between epochs  <span class="math">i</span>  and  <span class="math">j</span>  to verify that their value had not changed. Consequently, shorter epoch durations resulted in more epochs between two fixed points in time, making consistency proofs more expensive—and conversely, longer epochs reduced this cost. However, this limitation does not apply to subsequent systems, including ours, as we support an explicit and efficient functionality for consistency proofs.</p>

    <p class="text-gray-300">To provide a concrete comparison with a state-of-the-art real-world system, we benchmark WhatsApp's authenticated key directory (AKD)—built on SEEMLESS [Cha+19] and Parakeet [Mal+23]—using their akd crate <span class="math">^{13}</span>  on the same hardware. Despite using a machine with over a terabyte of memory, we were unable to scale the AKD implementation to one billion entries due to memory exhaustion; we therefore restricted our benchmarks to 100 million entries, which already places the evaluation in favor of WhatsApp. <span class="math">^{14}</span>  We set throughput for both WhatsApp AKD and IRONDICT to 1000 new users and 1000 updates per second.</p>

    <p class="text-gray-300">Our results in table 2 demonstrate that zk-IRONDICT has  <span class="math">150000 \\times</span>  smaller audit proof size and  <span class="math">300 \\times</span>  faster audit verification time compared to WhatsApp AKD, effectively</p>

    <p class="text-gray-300">transforming WhatsApp’s heavy server-driven auditing into a lightweight, self-auditable process for clients. This considerable improvement does increase the cost of lookups and consistency checks for both client and server, but all remain on the order of 30 ms, which constitutes an acceptable performance trade-off.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">WhatsApp, being based on SEEMLESS and Parakeet, client ensures value consistency by retrieving the entire value history. In contrast, we compare our proof of consistency against WhatsApp’s value-history approach. Unlike WhatsApp, IronDict’s value history requires only a linear number of lookups and consistency proofs with respect to the number of value changes (see Remark 2).</p>

    <h2 id="sec-58" class="text-2xl font-bold">6 Fast-Forwarding Proofs</h2>

    <p class="text-gray-300">Fast-forwarding techniques are general methods that allow auditors or clients to verify a specific state—or more generally, all states leading up to a given state in the dictionary—without checking each proof individually. Traditionally, the main approach to fast-forwarding was via IVC, where verifying a single IVC proof suffices to ensure the correctness of all previous steps. IVC is appealing because the proof size and verification time are independent of the number of epochs. However, it imposes a heavy computational burden on the server, as discussed in Section 6.1. An alternative approach, introduced in VeRSA, is <em>checkpoints</em>, which enable a client to verify that a specific state is correctly derived from the genesis state by checking only a logarithmic number of intermediate epochs. For instance, to verify the correctness of epoch <span class="math">n</span>, it suffices to examine a sublinear sequence of epochs <span class="math">i_{1},i_{2},\\ldots,i_{\\log n}</span>, where <span class="math">i_{1}=1</span> and <span class="math">i_{\\log n}=n</span>, and ensure that an invariant—such as monotonically increasing version numbers—holds at epoch <span class="math">n</span>. The client then checks that the invariant holds between each consecutive pair <span class="math">(i_{m},i_{m+1})</span> in the sequence. If all checks succeed, the invariant is guaranteed to hold at epoch <span class="math">n</span>. However, in contrast to IVC, this approach offers a weaker guarantee, as it does not ensure the correctness of all intermediate epochs.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">6.1 Fast-forwarding auditors with IVC</h3>

    <p class="text-gray-300">Fast-forwarding is a technique that allows a new auditor joining the system to audit it more efficiently than starting from the genesis epoch and verifying all consecutive epoch proofs. One general solution applied by pervious work <em>[Che+20, Tzi+22, Tya+22]</em>, is to use IVC. At each step, the IVC circuit receives the commitment to the previous step, the commitment to the current step, and a proof of invariance (i.e., the proof auditors are supposed to check) and verifies the correctness of the proof within the circuit. With an IVC scheme, the auditor only needs to verify the IVC proof for the final step. However, auditors must still verify a hash chain at each step. An IVC proof guarantees that updates across a sequence of intermediate states maintain an invariant, leading to a final state. However, there are multiple sequences of intermediate states that could lead to a valid final state. To</p>

    <p class="text-gray-300">address this, the bulletin board can store commitments to the intermediate states along with a hash chain <span class="math">h_{0},h_{1},h_{2},\\ldots</span>, where <span class="math">h_{i}=H(h_{i-1},d_{i})</span> for some hash function <span class="math">H</span>. The IVC additionally verifies the correctness of this hash chain. Using IVC generically also has its drawbacks. Typically, IVC solutions place a heavy computational burden on the server, as verifying the auditor’s proof can be expensive to implement in the circuit. However, we estimate our IVC scheme in practice is 2-3 orders of magnitude more efficient for the server than previous work, VeRSA. We describe how the IVC circuit in IronDict is concretely initiated with KZH. Note that the IVC scheme remains efficient for other PCS constructions, as long as they either support an accumulation scheme with low concrete overhead when the accumulation verifier is implemented inside the circuit, or their PCS verification is already inexpensive enough to be directly implemented in the circuit.</p>

    <h5 id="sec-60" class="text-base font-semibold mt-4">IVC with sublinear proofs and decider (verifier).</h5>

    <p class="text-gray-300">An IVC scheme is called sublinear <em>[Kad+25]</em> if the proofs of correctness for each step and their verification are sublinear in the size of the IVC circuit. This property is crucial in applications such as applying IVC for fast-forwarding auditors, where, unlike the traditional IVC model that focuses only on the final step, we care about proofs for every step due to the ongoing, perpetual nature of the computation—there is no “last” step. Concretely, if the IVC is not sublinear, even moderately sized circuits with 1 million constraints can result in proofs as large as 80 MB <em>[Zha+24, Kad+25]</em>. To provide some context, IVC can generally be constructed in two ways: (1) using SNARKs <em>[Bit+13]</em>, where the SNARK verifier must be embedded inside the circuit; or (2) using accumulation schemes <em>[Bü+20, B+20, KST22, Kad+25]</em>. SNARK-based IVCs naturally offer succinct proofs and verification at every step. However, embedding the SNARK verifier inside the circuit is concretely very expensive, often dominating the prover’s cost. In contrast, accumulation-based IVCs feature a recursion overhead that is much cheaper than the SNARK-based ones. Whether the resulting IVC is sublinear depends on the underlying accumulation scheme: if the accumulation scheme is a <em>sublinear accumulation scheme</em> <em>[Kad+25]</em>, then the resulting IVC will also be sublinear, e.g. the IVC scheme based on KZH-fold. A key drawback of SNARK-based IVC that relies on pairing-based SNARKs—such as the one used in VeRSA—is the requirement for a pairing-friendly cycle of elliptic curves. In contrast, accumulation-based IVC, such as KZH-fold, can be initiated based on a <em>half-pairing-friendly</em> cycle, where just one of the two curves supports pairings. Importantly, known pairing-friendly cycles that achieve 128-bit security require curves of approximately 768 bits, while non-recursive constructions typically use 384-bit curves—resulting in an estimated 10<span class="math">\\times</span> performance overhead in practice <em>[SCI19]</em>.</p>

    <h5 id="sec-61" class="text-base font-semibold mt-4">IVC circuit description for auditor checks.</h5>

    <p class="text-gray-300">For simplicity, in this section, we assume the use of KZH, leveraging both its homomorphic properties and the existence of an accumulation scheme for its verification function, namely KZH-fold. At a high level, accumulation reduces the verification of two polynomial openings to the verification of</p>

    <p class="text-gray-300">a single opening, which can then be checked by the IVC verifier outside the circuit. An overview of the IVC circuit costs can be seen in Table 3.</p>

    <p class="text-gray-300">Similar to VeRSA and unlike Merkle tree-based approaches, our IVC circuit has a constant size. The IVC circuit used in VeRSA reportedly has  <span class="math">\\approx 20M</span>  constraints, making ours  <span class="math">\\approx 100\\times</span>  smaller. Additionally, our scheme can be instantiated with a half-pairing-friendly curve such as Grumpkin-BN254, while VeRSA requires a pairing-friendly cycle of MNT4-753 and MNT6-753 curves, which introduces an additional  <span class="math">10\\times</span>  efficiency loss in practice [SCI19].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sumcheck verification</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recursive overhead</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PCS accumulation verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Homomorphic operation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cost</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N) F, O(log N) H</td>

            <td class="px-3 py-2 border-b border-gray-700">(k1+1) G1</td>

            <td class="px-3 py-2 border-b border-gray-700">(k2+1) G1 + 2 G1 (required for xk-KZH)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbb{G}_1</span>  : base group ops  <span class="math">\\mathbb{G}</span>  : group ops  <span class="math">\\mathbb{F}</span>  : field ops  <span class="math">\\mathcal{H}</span>  : hash ops</p>

    <p class="text-gray-300">Table 3: Overview of the IVC circuit cost: We assume the IVC circuit is using KZH- <span class="math">k_{1}</span>  fold, while the dictionary is instantiated with KZH- <span class="math">k_{2}</span> ; note that these parameters need not be equal. According to [Kad+25], a single scalar multiplication requires approximately 15,000 constraints; nevertheless, even for  <span class="math">k_{2} = 8</span> , the circuit size is expected to remain well below 250,000 constraints. In practice, because the circuit size is relatively small,  <span class="math">k_{1} = 2</span>  is sufficient. For example, even for a circuit of size 1 million constraints, it results in a proof size of  <span class="math">300\\mathrm{kB}</span>  that can be generated under 5s on an everyday laptop that can be verified in under a second (see Table 5 in [Kad+25]).</p>

    <p class="text-gray-300">Checkpoints are proposed in VeRSA as an alternative approach to IVC, specifically designed to reduce the verification overhead for clients that go offline and later come back online. At a high level, consider a client that was last online at epoch  <span class="math">i</span>  and reconnects at a later epoch  <span class="math">j</span> . In traditional systems, such a client would need to verify the correctness of every state transition between epochs  <span class="math">i</span>  and  <span class="math">j</span> , which means checking each intermediate proof individually - an approach that incurs linear cost in the number of skipped epochs. The idea behind checkpoints is to reduce this overhead by enabling the client to validate state transitions more efficiently. Instead of requiring verification of all intermediate epochs, the system introduces special proofs - called checkpoints - that allow clients to skip over multiple epochs at once. For instance, rather than verifying every inclusion  <span class="math">\\widetilde{\\mathrm{index}}_k \\subseteq \\widetilde{\\mathrm{index}}_{k+1}</span>  for all  <span class="math">k \\in [i,j)</span> , the client can verify a smaller number of inclusion proofs, such as  <span class="math">\\widetilde{\\mathrm{index}}_i \\subseteq \\widetilde{\\mathrm{index}}_{i+4}</span> ,  <span class="math">\\widetilde{\\mathrm{index}}_{i+4} \\subseteq \\widetilde{\\mathrm{index}}_{i+8}</span> , and so on, depending on the availability of these long-range proofs. This optimization effectively reduces the number of verifications from linear in  <span class="math">j - i</span>  to logarithmic.</p>

    <p class="text-gray-300">In our work, we propose to apply a similar idea to enable fast self-auditing for clients. Auditing involves of two parts: the index dictionary and the value dictionary. Among</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Figure 12: Consider an example with 16 epochs. Apart from proofs  <span class="math">\\overline{\\mathrm{index}}_i \\subseteq \\overline{\\mathrm{index}}_{i+1}</span>  published on BB, the server precomputes and stores checkpoint proofs for longer-range transitions with step sizes of 2, 4, 8, and 16. Suppose a client goes offline at epoch 3 and returns at epoch 14. Instead of verifying all 11 intermediate updates, the client can use a minimal set of checkpoint proofs:  <span class="math">\\overline{\\mathrm{index}}_3 \\subseteq \\overline{\\mathrm{index}}_4</span> ,  <span class="math">\\overline{\\mathrm{index}}_4 \\subseteq \\overline{\\mathrm{index}}_8</span> ,  <span class="math">\\overline{\\mathrm{index}}_8 \\subseteq \\overline{\\mathrm{index}}_{12}</span> , and  <span class="math">\\overline{\\mathrm{index}}_{12} \\subseteq \\overline{\\mathrm{index}}_{14}</span> .</p>

    <p class="text-gray-300">these, the index dictionary proof is significantly more expensive - it requires a multi-pairing and has a proof size of  <span class="math">k \\cdot N^{1/k}</span> , whereas auditing the value dictionary only involves a small number of hashes and group operations. Therefore, reducing the number of index dictionary proofs a client needs to check is particularly beneficial. To achieve this, we introduce checkpoints specifically for index dictionary proofs. The idea is based on the fact that the index dictionary proof establishes that it is append-only, i.e.  <span class="math">\\overline{\\mathrm{index}}_i \\subseteq \\overline{\\mathrm{index}}_{i+1}</span> . By generalizing this, the server can also produce proofs that cover larger steps - for example,  <span class="math">\\overline{\\mathrm{index}}_i \\subseteq \\overline{\\mathrm{index}}_{i+2}</span> ,  <span class="math">\\overline{\\mathrm{index}}_i \\subseteq \\overline{\\mathrm{index}}_{i+4}</span> , and so on. More precisely, for every  <span class="math">k \\in \\mathbb{N}</span> , the server maintains a proof that  <span class="math">\\overline{\\mathrm{index}}_{m \\cdot 2^k} \\subseteq \\overline{\\mathrm{index}}_{(m+1) \\cdot 2^k}</span> , without publishing them on BB. When a client returns after being offline, it can use these precomputed proofs to validate the state by following a path defined by a binary decomposition of  <span class="math">j - i</span> , skipping over epochs in powers of two. This reduces both the computational and communication costs of verification, enabling much faster auditing without compromising soundness. We illustrate the approach with an example in Figure 12. While this approach still requires the client to perform linear work to verify the correctness of the commitments to the value dictionary, this verification involves only a constant number of hashes and group operations per epoch, making it lightweight and not a computational bottleneck.</p>

    <p class="text-gray-300">Checkpoints are specifically designed to support self-auditing by clients, rather than external auditing. This distinction arises because when a client uses checkpoints to skip from epoch  <span class="math">i</span>  to epoch  <span class="math">i + 2</span> , it may never verify whether the intermediate transition  <span class="math">\\overline{\\mathrm{index}}_i \\subseteq \\overline{\\mathrm{index}}_{i + 1}</span>  holds. As a result, if epoch  <span class="math">i + 1</span>  is incorrect, a self-auditing client might never detect it (note that epoch  <span class="math">i + 2</span>  is still correct). However, this is not a concern for the client, since its goal is to ensure the correctness of the current epoch rather than validating the integrity of all prior epochs. In contrast, the IVC-based approach is designed</p>

    <p class="text-gray-300">so that checking the correctness of a given epoch also guarantees the validity of all preceding epochs. This property makes IVC suitable for fast-forwarding <em>auditors</em>, while the checkpoint mechanism is more appropriate for clients performing lightweight self-auditing.</p>

    <h2 id="sec-63" class="text-2xl font-bold">7 Memory optimizations</h2>

    <p class="text-gray-300">An important aspect of designing transparent dictionaries is optimizing the server’s memory usage. For instance, if the server stores a full copy of the dictionary at every epoch, the storage cost increases swiftly. We present a strategy to reduce memory consumption without imposing a heavy computational burden. This strategy is tailored to IronDict when instantiated with KZH, leveraging homomorphic properties of the KZH construction.</p>

    <h4 id="sec-64" class="text-lg font-semibold mt-6">Memory optimization via difference vectors.</h4>

    <p class="text-gray-300">A key optimization for reducing server-side memory usage is to <em>store only the difference vectors between adjacent epochs</em> rather than the full dictionary at each epoch. We demonstrate the idea in the setting where IronDict is instantiated with KZH-2; the case for KZH-<span class="math">k</span> with <span class="math">k&gt;2</span> is similar. In KZH-2, the dictionary values are organized as a <span class="math">\\sqrt{N}\\times\\sqrt{N}</span> matrix. In each epoch, the server computes row commitments <span class="math">\\{D_{i}\\}</span>, which serve as auxiliary inputs during openings. An opening for any value in the dictionary consists of the row commitments <span class="math">\\{D_{i}\\}</span> and one of the rows from the matrix. Let the changes in the next epoch be represented by <span class="math">\\Delta=\\{(x_{i},y_{i},\\delta_{i})\\}_{i\\in[n]}</span>, where <span class="math">(x_{i},y_{i})</span> denotes a matrix position and <span class="math">\\delta_{i}</span> is the updated value at that position. Instead of storing the entire updated matrix, the server only keeps the difference vector <span class="math">\\Delta</span>. When an opening is needed, the server reconstructs the target row by applying <span class="math">\\Delta</span> to the corresponding row from the previous epoch, requiring at most <span class="math">\\min\\{\\sqrt{N},n\\}</span> value replacements. However, recomputing the updated row commitments <span class="math">\\{D_{i}\\}</span> from scratch would still involve <span class="math">O(n)</span> group operations. To avoid this, the server precomputes and stores the updated row commitments once per epoch, which adds only <span class="math">O(\\sqrt{N})</span> storage overhead. This technique naturally generalizes to multiple epochs. By maintaining the difference vectors <span class="math">\\Delta_{1},\\ldots,\\Delta_{k}</span> for the past <span class="math">k</span> epochs, the server can reconstruct any row in the current dictionary from the snapshot stored <span class="math">k</span> epochs ago using at most <span class="math">O(k\\cdot n)</span> value replacements—without performing any additional group operations or storing full copies of the dictionary for each intermediate epoch.</p>

    <h2 id="sec-65" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">Hossein Hafezi conducted this work while hosted by Dario Fiore at IMDEA Software. Joseph Bonneau was supported by a16z crypto, NSF grant CNS-2239975, and gifts from Google, Meta, and Handshake Labs. The authors are grateful to Michael Rosenberg for his insightful feedback and valuable suggestions. We also thank Nirvan Tyagi for clarifying a detail</p>

    <p class="text-gray-300">related to VeRSA, and Pratyush Mishra for his assistance with questions regarding the implementation.</p>

    <h2 id="sec-66" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[42m25] 42matters. <em>Google Play vs iOS App Store: App stats and trends</em>. Accessed: 2025-08-30. Aug. 2025. url: https://42matters.com/stats.</li>

      <li>[AFK23] T. Attema, S. Fehr, and M. Klooß. “Fiat–Shamir Transformation of Multi-Round Interactive Proofs (Extended Version)”. In: <em>Journal of Cryptology</em> 36 (Aug. 2023). doi: 10.1007/s00145-023-09478-y.</li>

      <li>[AlS+17] M. AlSabah, A. Tomescu, I. Lebedev, D. Serpanos, and S. Devadas. “PriviPK: Certificate-less and secure email communication”. In: <em>Computers & Security</em> 70 (2017), pp. 1–15. issn: 0167-4048. doi: https://doi.org/10.1016/j.cose.2017.04.008. url: https://www.sciencedirect.com/science/article/pii/S0167404817300834.</li>

      <li>[AM17] M. Al-Bassam and S. Meiklejohn. “Contour: A Practical System for Binary Transparency”. In: <em>CoRR</em> abs/1712.08427 (2017). arXiv: 1712.08427. url: http://arxiv.org/abs/1712.08427.</li>

      <li>[B+20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. “Recursive Proof Composition from Accumulation Schemes”. In: <em>Theory of Cryptography: 18th International Conference, TCC 2020, Durham, NC, USA, November 16–19, 2020, Proceedings, Part II</em>. Springer-Verlag, 2020, 1–18. isbn: 978-3-030-64377-5. doi: 10.1007/978-3-030-64378-2_1. url: https://doi.org/10.1007/978-3-030-64378-2_1.</li>

      <li>[B+21] B. Bünz, M. Maller, P. Mishra, N. Tyagi, and P. Vesely. “Proofs for Inner Pairing Products and its Applications”. In: <em>Advances in Cryptology – ASIACRYPT 2021: 27th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 6–10, 2021, Proceedings, Part III</em>. Springer-Verlag, 2021, 65–97. isbn: 978-3-030-92077-7. doi: 10.1007/978-3-030-92078-4_3. url: https://doi.org/10.1007/978-3-030-92078-4_3.</li>

      <li>[Bas+14] D. Basin, C. Cremers, T. H.-J. Kim, A. Perrig, R. Sasse, and P. Szalachowski. “ARPKI: Attack Resilient Public-Key Infrastructure”. In: <em>Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security</em>. CCS ’14. Association for Computing Machinery, 2014, 382–393. isbn: 9781450329576. doi: 10.1145/2660267.2660298. url: https://doi.org/10.1145/2660267.2660298.</li>

    </ul>

    <p class="text-gray-300">[BBF19] D. Boneh, B. Bünz, and B. Fisch. “Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains”. In: <em>Advances in Cryptology – CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part I</em>. Springer-Verlag, 2019, 561–586. ISBN: 978-3-030-26947-0. DOI: 10.1007/978-3-030-26948-7_20. URL: https://doi.org/10.1007/978-3-030-26948-7_20.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BGG+16] S. Bowe, A. Gabizon, M. Green, et al. <em>mpc: zk-SNARK parameter multi-party computation protocol</em>. https://github.com/zcash/mpc. Accessed: 2025-07-18. Oct. 2016.</li>

      <li>[Bit+13] N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. “Recursive composition and bootstrapping for SNARKS and proof-carrying data”. In: <em>Proceedings of the Forty-Fifth Annual ACM Symposium on Theory of Computing</em>. STOC ’13. Association for Computing Machinery, 2013, 111–120. ISBN: 9781450320290. DOI: 10.1145/2488608.2488623. URL: https://doi.org/10.1145/2488608.2488623.</li>

      <li>[Bon16] J. Bonneau. “EthIKS: Using Ethereum to Audit a CONIKS Key Transparency Log”. In: vol. 9604. Feb. 2016, pp. 95–105. ISBN: 978-3-662-53356-7. DOI: 10.1007/978-3-662-53357-4_7.</li>

      <li>[BS+19] E. Ben-Sasson, A. Chiesa, M. Riabzev, N. Spooner, M. Virza, and N. P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: <em>Advances in Cryptology – EUROCRYPT 2019</em>. Ed. by Y. Ishai and V. Rijmen. Springer International Publishing, 2019, pp. 103–128. ISBN: 978-3-030-17653-2.</li>

      <li>[But14] V. Buterin. “Ethereum: A next-generation smart contract and decentralized application platform”. In: White Paper. 2014.</li>

      <li>[Bü+20] B. Bünz, A. Chiesa, P. Mishra, and N. Spooner. <em>Proof-Carrying Data from Accumulation Schemes</em>. Cryptology ePrint Archive, Paper 2020/499. 2020. URL: https://eprint.iacr.org/2020/499.</li>

      <li>[CFS17] A. Chiesa, M. A. Forbes, and N. Spooner. <em>A Zero Knowledge Sumcheck and its Applications</em>. Cryptology ePrint Archive, Paper 2017/305. 2017. URL: https://eprint.iacr.org/2017/305.</li>

      <li>[Cha+19] M. Chase, A. Deshpande, E. Ghosh, and H. Malvai. “SEEMless: Secure End-to-End Encrypted Messaging with less Trust”. In: <em>Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security</em>. CCS ’19. Association for Computing Machinery, 2019, 1639–1656. ISBN: 9781450367479. DOI: 10.1145/3319535.3363202. URL: https://doi.org/10.1145/3319535.3363202.</li>

    </ul>

    <p class="text-gray-300">[Che+20] W. Chen, A. Chiesa, E. Dauterman, and N. P. Ward. Reducing Participation Costs via Incremental Verification for Ledger Systems. Cryptology ePrint Archive, Paper 2020/1522. 2020. url: https://eprint.iacr.org/2020/1522.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Che+22] B. Chen, Y. Dodis, E. Ghosh, E. Goldin, B. Kesavan, A. Marcedone, and M. E. Mou. “Rotatable Zero Knowledge Sets: Post Compromise Secure Auditable Dictionaries with Application to Key Transparency”. In: Advances in Cryptology – ASIACRYPT 2022: 28th International Conference on the Theory and Application of Cryptology and Information Security, Taipei, Taiwan, December 5–9, 2022, Proceedings, Part III. Springer-Verlag, 2022, 547–580. isbn: 978-3-031-22968-8. doi: 10.1007/978-3-031-22969-5_19. url: https://doi.org/10.1007/978-3-031-22969-5_19.</li>

      <li>[Che+23] B. Chen, B. Bünz, D. Boneh, and Z. Zhang. “HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates”. In: Advances in Cryptology - EUROCRYPT 2023 - 42nd Annual International Conference on the Theory and Applications of Cryptographic Techniques, Lyon, France, April 23-27, 2023, Proceedings, Part II. Ed. by C. Hazay and M. Stam. Vol. 14005. Lecture Notes in Computer Science. Springer, 2023, pp. 499–530. doi: 10.1007/978-3-031-30617-4\\_17. url: https://doi.org/10.1007/978-3-031-30617-4\\_17.</li>

      <li>[Clo25] Cloudflare. Key Transparency Dashboard. https://dash.key-transparency.cloudflare.com. Accessed: 2025-08-01. 2025.</li>

      <li>[con22] arkworks contributors. arkworks zkSNARK ecosystem. 2022. url: https://arkworks.rs.</li>

      <li>[Daf+25] A. Daftardar, J. Mo, J. Ah-kiow, B. Bünz, R. Karri, S. Garg, and B. Reagen. Need for zkSpeed: Accelerating HyperPlonk for Zero-Knowledge Proofs. Cryptology ePrint Archive, Paper 2025/620. 2025. url: https://eprint.iacr.org/2025/620.</li>

      <li>[Dat24] Datareportal. Digital 2024 Global Statshot (October): Worldwide Digital Overview. Accessed: 2025-XX-XX. 2024. url: https://datareportal.com/reports/digital-2024-october-global-statshot.</li>

      <li>[DPP16] R. Dahlberg, T. Pulls, and R. Peeters. Efficient Sparse Merkle Trees: Caching Strategies and Secure (Non-)Membership Proofs. Cryptology ePrint Archive, Paper 2016/683. 2016. url: https://eprint.iacr.org/2016/683.</li>

      <li>[Fac20] Facebook News. Facebook Reaches Two Billion Users. Accessed: 2025-06-01. Feb. 2020. url: https://about.fb.com/news/2020/02/two-billion-users/.</li>

      <li>[Fah+14] S. Fahl, S. Dechand, H. Perl, F. Fischer, J. Smrcek, and M. Smith. “Hey, NSA: Stay Away from my Market! Future Proofing App Markets against Powerful Attackers”. In: Proceedings of the 2014 ACM SIGSAC Conference</li>

    </ul>

    <p class="text-gray-300">on Computer and Communications Security. CCS ’14. 2014, 1143–1155. url: https://doi.org/10.1145/2660267.2660311.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[FKP23] D. Fiore, D. Kolonelos, and P. d. Perthuis. “Cuckoo Commitments: Registration-Based Encryption and Key-Value Map Commitments for Large Spaces”. In: Advances in Cryptology – ASIACRYPT 2023: 29th International Conference on the Theory and Application of Cryptology and Information Security, Guangzhou, China, December 4–8, 2023, Proceedings, Part V. Springer-Verlag, 2023, 166–200. isbn: 978-981-99-8732-0. doi: 10.1007/978-981-99-8733-7_6. url: https://doi.org/10.1007/978-981-99-8733-7_6.</li>

      <li>[FS87] A. Fiat and A. Shamir. “How To Prove Yourself: Practical Solutions to Identification and Signature Problems”. In: Advances in Cryptology — CRYPTO’ 86. 1987, pp. 186–194. isbn: 978-3-540-47721-1.</li>

      <li>[GPBL20] A. Garba Ph.D., A. Bochem, and B. Leiding. “BlockVoke -Fast, Blockchain-Based Certificate Revocation for PKIs and the Web of Trust”. In: Nov. 2020. isbn: 978-3-030-62973-1. doi: 10.1007/978-3-030-62974-8_18.</li>

      <li>[Gra+21] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. “Poseidon: A New Hash Function for Zero-Knowledge Proof Systems”. In: 30th USENIX Security Symposium (USENIX Security 21). USENIX Association, Aug. 2021, pp. 519–535. isbn: 978-1-939133-24-3. url: https://www.usenix.org/conference/usenixsecurity21/presentation/grassi.</li>

      <li>[HC17] B. Hof and G. Carle. “Software Distribution Transparency and Auditability”. In: abs/1711.07278 (2017). arXiv: 1711.07278. url: http://arxiv.org/abs/1711.07278.</li>

      <li>[HKR19] M. Hoffmann, M. Klooß, and A. Rupp. “Efficient Zero-Knowledge Arguments in the Discrete Log Setting, Revisited”. In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. CCS ’19. Association for Computing Machinery, 2019, 2093–2110. isbn: 9781450367479. doi: 10.1145/3319535.3354251. url: https://doi.org/10.1145/3319535.3354251.</li>

      <li>[Hu+21] Y. Hu, K. Hooshmand, H. Kalidhindi, S. Yang, and R. A. Popa. “Merkle2 : A Low-Latency Transparency Log System”. In: May 2021, pp. 285–303. doi: 10.1109/SP40001.2021.00088.</li>

      <li>[Kad+25] G. Kadianakis, A. Zapico, H. Hafezi, and B. Bünz. KZH-Fold: Accountable Voting from Sublinear Accumulation. Cryptology ePrint Archive, Paper 2025/144. 2025. url: https://eprint.iacr.org/2025/144.</li>

      <li>[KC21] N. Korzhitskii and N. Carlsson. “Revocation Statuses on the Internet”. In: abs/2102.04288 (2021). arXiv: 2102.04288. url: https://arxiv.org/abs/2102.04288.</li>

    </ul>

    <p class="text-gray-300">[Kim+13] T. H.-J. Kim, L.-S. Huang, A. Perrig, C. Jackson, and V. Gligor. “Accountable key infrastructure (AKI): a proposal for a public-key validation infrastructure”. In: <em>Proceedings of the 22nd International Conference on World Wide Web</em>. WWW ’13. Association for Computing Machinery, 2013, 679–690. isbn: 9781450320351. doi: 10.1145/2488388.2488448. url: https://doi.org/10.1145/2488388.2488448.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[KNC22] N. Korzhitskii, M. Nemec, and N. Carlsson. <em>Postcertificates for Revocation Transparency</em>. 2022. arXiv: 2203.02280 [cs.CR]. url: https://arxiv.org/abs/2203.02280.</li>

      <li>[KST22] A. Kothapalli, S. Setty, and I. Tzialla. “Nova: Recursive Zero-Knowledge Arguments from Folding Schemes”. In: <em>Advances in Cryptology – CRYPTO 2022</em>. Ed. by Y. Dodis and T. Shrimpton. Springer Nature Switzerland, 2022, pp. 359–388. isbn: 978-3-031-15985-5.</li>

      <li>[KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg. “Constant-Size Commitments to Polynomials and Their Applications”. In: <em>Advances in Cryptology - ASI-ACRYPT 2010 - 16th International Conference on the Theory and Application of Cryptology and Information Security, Singapore, December 5-9, 2010. Proceedings</em>. Vol. 6477. Lecture Notes in Computer Science. 2010, pp. 177–194. doi: 10.1007/978-3-642-17373-8\\_11.</li>

      <li>[Lau] B. Laurie. “Certificate transparency”. In: (). url: https://doi.org/10.1145/2659897.</li>

      <li>[Lei+21] H. Leibowitz, H. Ghalwash, E. Syta, and A. Herzberg. <em>CTng: Secure Certificate and Revocation Transparency</em>. Cryptology ePrint Archive, Paper 2021/818. 2021. url: https://eprint.iacr.org/2021/818.</li>

      <li>[Len+23] J. Len, M. Chase, E. Ghosh, D. Jost, B. Kesavan, and A. Marcedone. “ELEK-TRA: Efficient Lightweight multi-dEvice Key TRAnsparency”. In: <em>Proceedings of the 2023 ACM SIGSAC Conference on Computer and Communications Security, CCS 2023, Copenhagen, Denmark, November 26-30, 2023</em>. 2023, pp. 2915–2929. doi: 10.1145/3576915.3623161. url: https://doi.org/10.1145/3576915.3623161.</li>

      <li>[Len+24] J. Len, M. Chase, E. Ghosh, K. Laine, and R. C. Moreno. “OPTIKS: an optimized key transparency system”. In: <em>Proceedings of the 33rd USENIX Conference on Security Symposium</em>. SEC ’24. USENIX Association, 2024. isbn: 978-1-939133-44-1.</li>

      <li>[Leu+22] D. Leung, Y. Gilad, S. Gorbunov, L. Reyzin, and N. Zeldovich. “Aardvark: An Asynchronous Authenticated Dictionary with Applications to Account-based Cryptocurrencies”. In: <em>31st USENIX Security Symposium (USENIX Security 22)</em>. USENIX Association, Aug. 2022, pp. 4237–4254. isbn: 978-1-939133-31-1. url:</li>

    </ul>

    <p class="text-gray-300">https://www.usenix.org/conference/usenixsecurity22/presentation/leung.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LL23] S. Lawlor and K. Lewi. <em>Deploying Key Transparency at WhatsApp</em>. https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/. Engineering at Meta Blog. Apr. 2023. url: https://engineering.fb.com/2023/04/13/security/whatsapp-key-transparency/.</li>

      <li>[Lun+92] C. Lund, L. Fortnow, H. J. Karloff, and N. Nisan. “Algebraic Methods for Interactive Proof Systems”. In: <em>J. ACM</em> 39.4 (1992), pp. 859–868. doi: 10.1145/146585.146605. url: https://doi.org/10.1145/146585.146605.</li>

      <li>[Mal+23] H. Malvai, L. Kokoris-Kogias, A. Sonnino, E. Ghosh, E. Oztürk, K. Lewi, and S. Lawlor. “Parakeet: Practical Key Transparency for End-to-End Encrypted Messaging”. In: Jan. 2023. doi: 10.14722/ndss.2023.24545.</li>

      <li>[Mei+20] S. Meiklejohn, P. Kalinnikov, C. S. Lin, M. Hutchinson, G. Belvin, M. Raykova, and A. Cutter. <em>Think Global, Act Local: Gossip and Client Audits in Verifiable Data Structures</em>. 2020. arXiv: 2011.04551 [cs.CR].</li>

      <li>[Mel+15] M. S. Melara, A. Blankstein, J. Bonneau, E. W. Felten, and M. J. Freedman. “CONIKS: Bringing Key Transparency to End Users”. In: <em>24th USENIX Security Symposium, USENIX Security 15, Washington, D.C., USA, August 12-14, 2015</em>. Ed. by J. Jung and T. Holz. USENIX Association, 2015, pp. 383–398. url: https://www.usenix.org/conference/usenixsecurity15/technical-sessions/presentation/melara.</li>

      <li>[MRV99] S. Micali, M. Rabin, and S. Vadhan. “Verifiable random functions”. In: <em>40th Annual Symposium on Foundations of Computer Science (Cat. No.99CB37039)</em>. 1999, pp. 120–130. doi: 10.1109/SFFCS.1999.814584.</li>

      <li>[Nik+17] K. Nikitin, E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, I. Khoffi, J. Cappos, and B. Ford. “CHAINIAC: proactive software-update transparency via collectively signed skipchains and verified builds”. In: <em>Proceedings of the 26th USENIX Conference on Security Symposium</em>. SEC’17. USENIX Association, 2017, 1271–1287. isbn: 9781931971409.</li>

      <li>[PR04] R. Pagh and F. F. Rodler. “Cuckoo hashing”. In: <em>J. Algorithms</em> 51.2 (May 2004), 122–144. issn: 0196-6774. doi: 10.1016/j.jalgor.2003.12.002. url: https://doi.org/10.1016/j.jalgor.2003.12.002.</li>

      <li>[Pro20] Protocol Labs. <em>Trusted Setup Complete</em>. https://filecoin.io/blog/posts/trusted-setup-complete/. Accessed: 2025-05-04. Aug. 2020. url: https://filecoin.io/blog/posts/trusted-setup-complete/.</li>

      <li>[Repnd] Repology. <em>Raw repository package counts</em>. https://repology.org/repositories/packages. Accessed: 2025-08-30. n.d.</li>

    </ul>

    <p class="text-gray-300">[Reu21] Reuters. <em>Telegram Founder Says Over 70 Million New Users Joined During Facebook Outage</em>. Accessed: 2025-XX-XX. Oct. 2021. URL: https://www.reuters.com/technology/telegram-founder-says-over-70-mln-new-users-joined-during-facebook-outage-2021-10-05/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Ros+24] M. Rosenberg, T. Mopuri, H. Hafezi, I. Miers, and P. Mishra. “Hekaton: Horizontally-Scalable zkSNARKs Via Proof Aggregation”. In: <em>Proceedings of the 2024 on ACM SIGSAC Conference on Computer and Communications Security</em>. CCS ’24. Association for Computing Machinery, 2024, 929–940. isbn: 9798400706363. doi: 10.1145/3658644.3690282. URL: https://doi.org/10.1145/3658644.3690282.</li>

      <li>[Rya14] M. Ryan. “Enhanced Certificate Transparency and End-to-End Encrypted Mail”. In: Jan. 2014. isbn: 1-891562-35-5. doi: 10.14722/ndss.2014.23379.</li>

      <li>[Sch80] J. T. Schwartz. “Fast probabilistic algorithms for verification of polynomial identities”. In: <em>Journal of the ACM (JACM)</em> 27.4 (1980), pp. 701–717.</li>

      <li>[Sch90] C. P. Schnorr. “Efficient Identification and Signatures for Smart Cards”. In: <em>Advances in Cryptology — CRYPTO’ 89 Proceedings</em>. Ed. by G. Brassard. Springer New York, 1990, pp. 239–252. isbn: 978-0-387-34805-6.</li>

      <li>[SCI19] SCIPR Lab. <em>zexe: a Rust library for decentralized private computation</em>. https://github.com/sciprlab/zexe. [SCI]. 2019.</li>

      <li>[SDS20] T. Smith, L. Dickinson, and K. Seamons. “Let’s Revoke: Scalable Global Certificate Revocation”. In: Jan. 2020. doi: 10.14722/ndss.2020.24084.</li>

      <li>[Set20] S. Setty. “Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup”. In: <em>Advances in Cryptology – CRYPTO 2020: 40th Annual International Cryptology Conference, CRYPTO 2020, Santa Barbara, CA, USA, August 17–21, 2020, Proceedings, Part III</em>. Springer-Verlag, 2020, 704–737. isbn: 978-3-030-56876-4. doi: 10.1007/978-3-030-56877-1_25. URL: https://doi.org/10.1007/978-3-030-56877-1_25.</li>

      <li>[Syt+16] E. Syta, I. Tamas, D. Visher, D. I. Wolinsky, P. Jovanovic, L. Gasser, N. Gailly, I. Khoffi, and B. Ford. <em>Keeping Authorities "Honest or Bust" with Decentralized Witness Cosigning</em>. 2016. arXiv: 1503.08768 [cs.CR]. URL: https://arxiv.org/abs/1503.08768.</li>

      <li>[TD17] A. Tomescu and S. Devadas. “Catena: Efficient Non-equivocation via Bitcoin”. In: <em>2017 IEEE Symposium on Security and Privacy (SP)</em>. 2017, pp. 393–409. doi: 10.1109/SP.2017.19.</li>

      <li>[Tec] Techi. <em>Pavel Durov said Telegram hits 1 billion users</em>. URL: https://www.techi.com/pavel-durov-said-telegram-hits-1-billion-users/.</li>

    </ul>

    <p class="text-gray-300">[TM24] Thibault Meunier and Mari Galicer. Cloudflare helps verify the security of end-to-end encrypted messages by auditing Key Transparency for WhatsApp. Blog post on the Cloudflare Blog. Accessed 2025-07-31. Sept. 2024. URL: https://blog.cloudflare.com/key-transparency/.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Tom15] A. Tomescu. “PowMail: want to fork?: do some work”. PhD thesis. Massachusetts Institute of Technology, 2015.</li>

      <li>[Tom+19] A. Tomescu, V. Bhupatiraju, D. Papadopoulos, C. Papamanthou, N. Triandopoulos, and S. Devadas. “Transparency Logs via Append-Only Authenticated Dictionaries”. In: <em>Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security</em>. CCS ’19. Association for Computing Machinery, 2019, 1299–1316. isbn: 9781450367479. doi: 10.1145/3319535.3345652. URL: https://doi.org/10.1145/3319535.3345652.</li>

      <li>[TXN20] A. Tomescu, Y. Xia, and Z. Newman. <em>Authenticated Dictionaries with Cross-Incremental Proof (Dis)aggregation</em>. Cryptology ePrint Archive, Paper 2020/1239. 2020. URL: https://eprint.iacr.org/2020/1239.</li>

      <li>[Tya+22] N. Tyagi, B. Fisch, A. Zitek, J. Bonneau, and S. Tessaro. “VeRSA: Verifiable Registries with Efficient Client Audits from RSA Authenticated Dictionaries”. In: <em>Proceedings of the 2022 ACM SIGSAC Conference on Computer and Communications Security, CCS 2022, Los Angeles, CA, USA, November 7-11, 2022</em>. Ed. by H. Yin, A. Stavrou, C. Cremers, and E. Shi. ACM, 2022, pp. 2793–2807. doi: 10.1145/3548606.3560605. URL: https://doi.org/10.1145/3548606.3560605.</li>

      <li>[Tzi+22] I. Tzialla, A. Kothapalli, B. Parno, and S. Setty. “Transparency Dictionaries with Succinct Proofs of Correct Operation”. In: <em>NDSS 2022</em>. July 2022. URL: https://www.microsoft.com/en-us/research/publication/transparency-dictionaries-with-succinct-proofs-of-correct-operation/.</li>

      <li>[Ung+15] N. Unger, S. Dechand, J. Bonneau, S. Fahl, H. Perl, I. Goldberg, and M. Smith. “SoK: secure messaging”. In: <em>2015 IEEE Symposium on Security and Privacy</em>. 2015, pp. 232–249.</li>

      <li>[Val08] P. Valiant. “Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency”. In: <em>Theory of Cryptography</em>. 2008, pp. 1–18. isbn: 978-3-540-78524-8.</li>

      <li>[Wah+18] R. S. Wahby, I. Tzialla, A. Shelat, J. Thaler, and M. Walfish. “Doubly-Efficient zkSNARKs Without Trusted Setup”. In: <em>2018 IEEE Symposium on Security and Privacy (SP)</em>. 2018, pp. 926–943. doi: 10.1109/SP.2018.00060.</li>

      <li>[WCB25] F. Wang, S. Cohney, and J. Bonneau. <em>SoK: Trusted setups for powers-of-tau strings</em>. Cryptology ePrint Archive, Paper 2025/064. 2025. URL: https://eprint.iacr.org/2025/064.</li>

    </ul>

    <p class="text-gray-300">[Wik25] Wikipedia contributors. Open addressing. Accessed: 2025-08-18. 2025. URL: https://en.wikipedia.org/wiki/Open_addressing.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Zha+24] J. Zhao, S. Setty, W. Cui, and G. Zaverucha. MicroNova: Folding-based arguments with efficient (on-chain) verification. Cryptology ePrint Archive, Paper 2024/2099. 2024. URL: https://eprint.iacr.org/2024/2099.</li>

      <li>[Zip79] R. Zippel. “Probabilistic algorithms for sparse polynomials”. In: EUROSAM 1979. Springer. 1979, pp. 216–226.</li>

    </ul>

    <p class="text-gray-300">Definition 2. [Multilinear Polynomial Commitment Scheme] A Multilinear Polynomial Commitment Scheme is a tuple of algorithms (Setup, Commit, Open, Verify) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathsf{vk},\\mathsf{pk})\\gets \\mathsf{Setup}(\\lambda ,k)</span> : On input the security parameter  <span class="math">\\lambda</span>  and the number of variables  <span class="math">k</span> , this algorithm outputs a pair of verifier key  <span class="math">(\\mathsf{vk})</span>  and prover key  <span class="math">(\\mathsf{pk})</span> . This algorithm might require randomness as nondeterministic input too.</li>

      <li><span class="math">\\mathsf{C} \\gets \\mathsf{Commit}(\\mathsf{pk}, p(\\vec{X}))</span> : On input pk and a multilinear polynomial  <span class="math">p(\\vec{X})</span> , it outputs a commitment C. This algorithm might take randomness as non-deterministic input too, but for simplicity, we don't consider it here.</li>

      <li><span class="math">\\pi \\gets \\operatorname{Open}(\\mathsf{pk}, p(\\vec{X}), \\vec{x})</span> : On input pk,  <span class="math">p(\\vec{X})</span> , and vector  <span class="math">\\vec{x} \\in \\mathbb{F}^k</span> , outputs an evaluation proof  <span class="math">\\pi</span>  that  <span class="math">y = p(\\vec{x})</span> .</li>

      <li><span class="math">1/0 \\gets \\text{Verify}(\\mathsf{vk}, \\mathsf{C}, \\vec{x}, \\pi, y)</span> : On input vk, the commitment C, vector of evaluations  <span class="math">\\vec{x}</span> ,  <span class="math">y \\in \\mathbb{F}</span> , and the proof of the correct evaluation, it outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">A polynomial commitment scheme is said to be secure if it is complete and knowledge-sound as defined below:</p>

    <p class="text-gray-300">Completeness. It captures the fact that an honest prover will always convince the verifier. Formally, for any efficient adversary  <span class="math">\\mathcal{A}</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left[ \\operatorname {V e r i f y} _ {\\mathsf {P C S}} \\big (\\mathsf {v k}, \\mathsf {C}, \\vec {x}, \\pi_ {\\mathsf {P C S}}, p (\\vec {x}) \\big) = 1 \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} (\\mathsf {v k}, \\mathsf {p k}) \\leftarrow \\operatorname {S e t u p} _ {\\mathsf {P C S}} \\big (\\lambda , k \\big), \\\\ p (\\vec {X}) \\leftarrow \\mathcal {A} (\\mathsf {s r s} _ {\\mathsf {P C S}}), \\\\ \\mathsf {C} \\leftarrow \\operatorname {C o m m i t} \\big (\\mathsf {p k}, p (\\vec {X}) \\big), \\\\ \\pi_ {\\mathsf {P C S}} \\leftarrow \\operatorname {O p e n} \\big (\\mathsf {p k}, p (\\vec {X}), \\vec {x} \\big) \\end{array} \\right. \\right] = 1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Extractability. Captures the fact that whenever the prover provides a valid opening, it knows a valid pair  <span class="math">(p(\\vec{X}),y)</span> , where  <span class="math">p(\\vec{x}) = y</span> . Formally, for all PPT adversaries  <span class="math">\\mathcal{A}</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that the probability of the following event is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathsf {V e r i f y} _ {\\mathsf {P C S}} \\big (\\mathsf {v k}, \\mathsf {C}, \\vec {x}, \\pi_ {\\mathsf {P C S}}, y \\big) = 1 &amp;amp; \\begin{array}{l} (\\mathsf {v k}, \\mathsf {p k}) \\leftarrow \\mathsf {S e t u p} _ {\\mathsf {P C S}} \\big (\\lambda , k \\big), \\\\ \\mathsf {C} \\leftarrow \\mathcal {A} \\big (\\mathsf {v k}, \\mathsf {p k} \\big), \\\\ p (\\vec {X}) \\leftarrow \\mathcal {E} \\big ((\\mathsf {v k}, \\mathsf {p k}), \\mathsf {C}, k \\big), \\\\ \\vec {x} \\leftarrow \\mathcal {A} \\big ((\\mathsf {v k}, \\mathsf {p k}), \\mathsf {C} \\big), \\\\ (y, \\pi_ {\\mathsf {P C S}}) \\leftarrow \\mathcal {A} \\big ((\\mathsf {v k}, \\mathsf {p k}), p (\\vec {X}), \\vec {x} \\big) \\end{array} \\end{array} \\right]</span></div>

    <p class="text-gray-300">B Transparent Security Definition</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">B.1 Completeness</h3>

    <p class="text-gray-300">A transparent dictionary construction is said to be <em>complete</em> if the following holds with probability 1 over the randomness of the honest server and honest setup:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency correctness. Let <span class="math">\\ell</span> be a label and <span class="math">v</span> be its corresponding label at epoch <span class="math">i</span>, and assume the value does not change until epoch <span class="math">j</span>, now the following always holds:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Client.VerConsistency}(\\ell,\\text{com}_{i},\\text{com}_{j},\\pi_{\\text{consis}})=1</span> <span class="math">\\mid\\text{Server.Consistency}(\\ell,\\text{state}_{i},\\text{state}_{j})\\rightarrow\\pi_{\\text{consis}}]=1</span></p>

    <p class="text-gray-300">Additionally, we require that for every <span class="math">i\\leq k\\leq j</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Client.VerifyLookup}(\\ell,\\text{com}_{k},\\text{value},\\pi_{\\text{Lookup}})=1\\text{, value}=v</span> <span class="math">\\mid\\text{Server.Lookup}(\\ell,\\text{state}_{k})\\rightarrow(\\text{value},\\pi_{\\text{Lookup}})]=1</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Audit correctness For all epochs <span class="math">i=0,1,2,\\dots</span>, given the epoch proof <span class="math">\\pi_{i+1}</span>, the following holds:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\text{Auditor.VerifyInvariance}(\\text{com}_{i},\\text{com}_{i+1},\\pi_{i+1})=1.</span></p>

    <h3 id="sec-69" class="text-xl font-semibold mt-8">B.2 Soundness</h3>

    <p class="text-gray-300">Soundness guarantees that, if there is at least one honest auditor in each round and the auditor accepts the new epoch along with its accompanying proof, then the following properties hold, except with negligible probability:</p>

    <h4 id="sec-70" class="text-lg font-semibold mt-6">Lookup soundness (binding).</h4>

    <p class="text-gray-300">Given a commitment <span class="math">\\text{com}_{i}</span> to an epoch and a single label <span class="math">\\ell</span>, the following probability is negligible:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{l}\\text{Client.VerifyLookup}(\\ell,\\text{com}_{i},v_{0},\\pi_{0})=1\\wedge\\\\ \\text{Client.VerifyLookup}(\\ell,\\text{com}_{i},v_{1},\\pi_{1})=1\\wedge\\\\ v_{0}\\neq v_{1}\\end{array}\\right](v_{0},\\pi_{0}),(v_{1},\\pi_{1})\\leftarrow\\text{Server} \\]</p>

    <h4 id="sec-71" class="text-lg font-semibold mt-6">Consistency soundness.</h4>

    <p class="text-gray-300">For any two epochs <span class="math">i</span> and <span class="math">j</span> such that the value corresponding to label <span class="math">\\ell</span> changes during the interval <span class="math">[i,j]</span>, the prover cannot generate a consistency proof <span class="math">\\pi_{\\text{consist}}</span> that</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Client.VerConsistency}(\\ell,\\text{com}_{i},\\text{com}_{j},\\pi_{\\text{consis}})=1,</span></p>

    <p class="text-gray-300">except with negligible probability.</p>

    <p class="text-gray-300">C Formal Proofs</p>

    <p class="text-gray-300">We prove that our construction provided in 4.5, satisfies the completeness and soundness definitions as defined in B.</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">C.1 Proof of completeness</h3>

    <h4 id="sec-73" class="text-lg font-semibold mt-6">Consistency correctness.</h4>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be any label with corresponding binary index <span class="math">\\mathbf{x}\\in\\{0,1\\}^{\\log_{2}N}</span>. Suppose this label has held the same value <span class="math">v</span> during all epochs from <span class="math">i</span> to <span class="math">j</span>, where <span class="math">i&lt;j</span>. Assume that:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Server. Consistency}(\\ell,\\mathsf{state}_{i},\\mathsf{state}_{j})\\to\\pi_{\\mathrm{consist}},</span></p>

    <p class="text-gray-300">where <span class="math">\\pi_{\\mathrm{consist}}</span> is a proof consisting of a PCS opening of <span class="math">\\overline{\\mathrm{rand}}_{i}</span> and <span class="math">\\overline{\\mathrm{rand}}_{j}</span> at point <span class="math">\\mathbf{x}</span>. The client verifies this proof by checking:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Client. Ver Consistency}(\\ell,\\mathsf{com}_{i},\\mathsf{com}_{j},\\pi_{\\mathrm{consist}}),</span></p>

    <p class="text-gray-300">which internally ensures that both openings of <span class="math">\\overline{\\mathrm{rand}}_{i}</span> and <span class="math">\\overline{\\mathrm{rand}}_{i+1}</span> at <span class="math">\\mathbf{x}</span> are valid and satisfy: <span class="math">\\overline{\\mathrm{rand}}_{i}(\\mathbf{x})=\\overline{\\mathrm{rand}}_{j}(\\mathbf{x})</span>. Assuming the server behaves honestly and all PCS verifications pass, to prove that the value corresponding to label <span class="math">\\ell</span> (or index <span class="math">\\mathbf{x}</span>) has not changed, it suffices to show that <span class="math">\\overline{\\mathrm{rand}}_{i}(\\mathbf{x})=\\overline{\\mathrm{rand}}_{j}(\\mathbf{x})</span>. We prove this inductively over the epochs from <span class="math">i</span> to <span class="math">j</span>. Define the difference polynomial: <span class="math">\\overline{\\Delta_{k}}:=\\overline{\\mathrm{value}}_{k+1}-\\overline{\\mathrm{value}}_{k}</span>. Since the value has not changed at <span class="math">\\mathbf{x}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\mathrm{value}}_{k+1}(\\mathbf{x})=\\overline{\\mathrm{value}}_{k}(\\mathbf{x})\\quad\\Rightarrow\\quad\\overline{\\Delta_{k}}(\\mathbf{x})=0.</span></p>

    <p class="text-gray-300">By definition of the random polynomial, we have: <span class="math">\\overline{\\mathrm{rand}}_{k+1}=\\overline{\\mathrm{rand}}_{k}+r_{k}\\cdot\\overline{\\Delta_{k}}</span>, where <span class="math">r_{k}</span> is derived via the Fiat-Shamir heuristic. Since <span class="math">\\overline{\\Delta_{k}}(\\mathbf{x})=0</span>, it follows that: <span class="math">\\overline{\\mathrm{rand}}_{k+1}(\\mathbf{x})=\\overline{\\mathrm{rand}}_{k}(\\mathbf{x})</span>. Applying this inductively for each <span class="math">i\\leq k\\leq j-1</span>, we conclude: <span class="math">\\overline{\\mathrm{rand}}_{i}(\\mathbf{x})=\\overline{\\mathrm{rand}}_{i+1}(\\mathbf{x})=\\cdots=\\overline{\\mathrm{rand}}_{j}(\\mathbf{x})</span>. Hence, we’ve shown that the value at index <span class="math">\\mathbf{x}</span> (corresponding to label <span class="math">\\ell</span>) hasn’t changed between epochs <span class="math">i</span> to <span class="math">j</span>: <span class="math">\\overline{\\mathrm{rand}}_{i}(\\mathbf{x})=\\overline{\\mathrm{rand}}_{j}(\\mathbf{x})</span>.</p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Audit correctness.</h4>

    <p class="text-gray-300">Let epoch <span class="math">i</span> be associated with a set of updates <span class="math">\\Delta_{i}=(\\Delta_{\\mathrm{index}},\\Delta_{\\mathrm{value}})</span>. Running the update procedure:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Server. Update}(\\mathsf{state}_{i},\\Delta_{i})\\to(\\mathsf{state}_{i+1},\\mathsf{com}_{i+1},\\pi_{i+1}),</span></p>

    <p class="text-gray-300">we prove that the auditor accepts the new state, i.e.,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Auditor. VerifyInvariance}(\\mathsf{com}_{i},\\mathsf{com}_{i+1},\\pi_{i+1})=1.</span></p>

    <p class="text-gray-300">The proof <span class="math">\\pi_{i+1}</span> consists of two components: <span class="math">\\pi_{i+1}=(\\pi_{\\mathrm{register}},\\pi_{\\mathrm{value}})</span>. Note that if the underlying PCS is homomorphic, then <span class="math">\\pi_{\\mathrm{value}}</span> is empty. The auditor’s verification process consists of two main checks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness of the randomized value polynomial <span class="math">\\overline{\\text{rand}}_{i+1}</span>: The auditor first recomputes the randomness <span class="math">r_{i}</span> using the Fiat-Shamir heuristic and verifies the following relationship between the polynomials:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i+1}=\\overline{\\text{rand}}_{i}+r_{i}\\cdot\\overline{\\Delta_{i}},</span></p>

    <p class="text-gray-300">where <span class="math">\\overline{\\Delta_{i}}:=\\overline{\\text{value}}_{i+1}-\\overline{\\text{value}}_{i}</span>. This expands to:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i+1}=\\overline{\\text{rand}}_{i}+r_{i}\\cdot(\\overline{\\text{value}}_{i+1}-\\overline{\\text{value}}_{i}).</span></p>

    <p class="text-gray-300">Now, if the PCS is homomorphic, the auditor directly verifies this identity using linearity, and if the PCS is non-homomorphic, the auditor checks the openings of the following polynomials at a random point: <span class="math">\\overline{\\text{rand}}_{i},\\overline{\\text{rand}}_{i+1},\\overline{\\text{value}}_{i},\\overline{\\text{value}}_{i+1}</span>, using the proof <span class="math">\\pi_{\\text{value}}</span>. In either case, due to the definition:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i+1}=\\overline{\\text{rand}}_{i}+r_{i}\\cdot(\\overline{\\text{value}}_{i+1}-\\overline{\\text{value}}_{i}),</span></p>

    <p class="text-gray-300">the check passes if the server is honest.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness of the Index Assignment in <span class="math">\\overline{\\text{index}}_{i+1}</span>: The index polynomial <span class="math">\\overline{\\text{index}}_{i+1}</span> updates entries corresponding to the new label indexes. Formally:</li>

    </ul>

    <p class="text-gray-300">\\[ \\overline{\\text{index}}_{i+1}(\\mathbf{x})=\\begin{cases}H(\\ell_{j})&\\text{if }\\mathbf{x}=\\mathbf{x}_{j},\\\\ \\overline{\\text{index}}_{i}(\\mathbf{x})&\\text{otherwise},\\end{cases} \\]</p>

    <p class="text-gray-300">where <span class="math">\\mathbf{x}_{j}</span> are the indices of new labels in <span class="math">\\Delta_{\\text{index}}</span>. Define the difference polynomial:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\delta_{i}}:=\\overline{\\text{index}}_{i+1}-\\overline{\\text{index}}_{i}.</span></p>

    <p class="text-gray-300">We now establish the key identity: If <span class="math">\\overline{\\delta_{i}}(\\mathbf{x})\\neq 0</span>, then <span class="math">\\overline{\\text{index}}_{i}(\\mathbf{x})=0</span>, because new labels are only assigned to previously unassigned indices. This implies:</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{index}}_{i}(\\mathbf{x})\\cdot(\\overline{\\text{index}}_{i+1}(\\mathbf{x})-\\overline{\\text{index}}_{i}(\\mathbf{x}))=0\\,:\\,\\forall\\mathbf{x}\\in\\{0,1\\}^{\\log N}</span></p>

    <p class="text-gray-300">This implies the zerocheck will pass and hence the auditor accepts <span class="math">\\pi_{\\text{register}}</span>.</p>

    <p class="text-gray-300">Both auditor checks succeed; hence, we conclude:</p>

    <p class="text-gray-300"><span class="math">\\text{Auditor.VerifyInvariance}(\\text{com}_{i},\\text{com}_{i+1},\\pi_{i+1})=1.</span></p>

    <p class="text-gray-300">C.2 Proof of Soundness</p>

    <h4 id="sec-75" class="text-lg font-semibold mt-6">Lookup soundness.</h4>

    <p class="text-gray-300">Lookup soundness has two parts: (1) proving a client only accepts a unique index <span class="math">\\mathbf{x}</span> per label <span class="math">\\ell</span> and (2) for each index <span class="math">\\mathbf{x}</span>, the state commitment only opens to one single value.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li><em>Uniqueness of index:</em> According to the index verification procedure (Algorithm 4), the client receives an identifier <span class="math">n</span> and the opening of the polynomial <span class="math">\\overline{\\mathrm{index}}_{i}</span> at the point <span class="math">\\mathcal{H}(n,\\ell)</span>. The client then performs the following checks:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For all <span class="math">m&lt;n</span>, it verifies that: <span class="math">\\overline{\\mathrm{index}}_{i}(\\mathcal{H}(m,\\ell))\\neq H(\\ell)</span></li>

      <li>It also checks that <span class="math">\\overline{\\mathrm{index}}_{i}(\\mathcal{H}(n,\\ell))=H(\\ell)</span>.</li>

    </ul>

    <p class="text-gray-300">Assuming the PCS is sound—i.e., the adversarial server cannot open the same point to two different values and given the hash function <span class="math">\\mathcal{H}</span> is deterministic, the client can’t accept two different indices <span class="math">\\mathbf{x}_{1}:=\\mathcal{H}(n_{1},\\ell)</span> and <span class="math">\\mathbf{x}_{2}:=\\mathcal{H}(n_{2},\\ell)</span> for the same label <span class="math">\\ell</span>. Without loss of generality, assume <span class="math">n_{1}&lt;n_{2}</span>. For the client to accept index <span class="math">n_{2}</span>, it must verify that <span class="math">\\overline{\\mathrm{index}}_{i}(\\mathbf{x}_{1})\\neq H(\\ell)</span>; however, accepting index <span class="math">n_{1}</span> requires verifying that <span class="math">\\overline{\\mathrm{index}}_{i}(\\mathbf{x}_{1})=H(\\ell)</span>. This is a contradiction, violating the binding property of the underlying PCS. It remains to argue that the client continues to accept the same index in all future states. This follows trivially from the append-only nature of the index dictionary. Specifically, once a label <span class="math">\\ell</span> is assigned to an index <span class="math">\\mathbf{x}:=\\mathcal{H}(n,\\ell)</span>, all subsequent index polynomials <span class="math">\\overline{\\mathrm{index}}_{j}</span> for <span class="math">j&gt;i</span> must preserve the values at <span class="math">\\mathbf{x}_{m}:=\\mathcal{H}(m,\\ell)</span> for all <span class="math">m\\leq n</span>. Therefore, the verification procedure remains unchanged in future epochs.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Uniqueness of value:</em> We have established that the client only accepts a single unique index <span class="math">\\mathbf{x}</span> per label <span class="math">\\ell</span>. Opening the value of a label is thus equivalent to opening the polynomial <span class="math">\\overline{\\mathrm{value}}_{i}</span> at the corresponding index <span class="math">\\mathbf{x}</span> and checking that <span class="math">H(v)\\stackrel{{\\scriptstyle?}}{{=}}\\overline{\\mathrm{value}}_{i}(\\mathbf{x})</span>. Due to the binding property of the PCS, it is impossible to open <span class="math">\\overline{\\mathrm{value}}_{i}(\\mathbf{x})</span> to two different values. Additionally, finding two distinct values <span class="math">v_{1}</span> and <span class="math">v_{2}</span> such that <span class="math">H(v_{1})=H(v_{2})</span> violates the one-to-one mapping described in Section 4.1 and contradicts the collision resistance of the hash function <span class="math">H</span>. Hence, the value corresponding to a label is also unique.</li>

    </ul>

    <p class="text-gray-300">Overall, we conclude it’s not possible—but with negligible probability—that the clients accept two different values for one label and hence lookup soundness holds.</p>

    <h4 id="sec-76" class="text-lg font-semibold mt-6">Consistency soundness.</h4>

    <p class="text-gray-300">Before proving consistency soundness, we first prove the following lemma:</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Lemma 1.</h6>

    <p class="text-gray-300">Consider a constant-round interactive protocol by a prover and verifier such that at each round <span class="math">i</span> the prover sends a value <span class="math">a_{i}\\in\\mathbb{F}</span> and receives a uniform randomness</p>

    <p class="text-gray-300"><span class="math">r_{i}\\in\\mathbb{F}</span>. Now, if at least one <span class="math">a_{i}\\neq 0</span>, we have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[\\sum_{i=0}^{t-1}a_{i}r_{i}=0\\right]\\leq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">i^{<em>}</span> be the largest index such that <span class="math">a_{i^{</em>}}\\neq 0</span>. Then we can write:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{t-1}a_{i}r_{i}=\\sum_{i=0}^{i^{<em>}}a_{i}r_{i}=C+a_{i^{</em>}}r_{i^{*}},</span></p>

    <p class="text-gray-300">where <span class="math">C=\\sum_{i=0}^{i^{<em>}-1}a_{i}r_{i}</span> is fixed before the verifier samples <span class="math">r_{i^{</em>}}</span>, since it depends only on <span class="math">r_{0},\\ldots,r_{i^{<em>}-1}</span>. Because <span class="math">r_{i^{</em>}}</span> is sampled uniformly at random from <span class="math">\\mathbb{F}</span>, and <span class="math">a_{i^{<em>}}\\neq 0</span>, the term <span class="math">a_{i^{</em>}}r_{i^{<em>}}</span> is uniformly random in <span class="math">\\mathbb{F}</span>. Therefore, <span class="math">C+a_{i^{</em>}}r_{i^{*}}</span> is also uniformly random, and so:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left[C+a_{i^{<em>}}r_{i^{</em>}}=0\\right]=\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hence, the probability that <span class="math">\\sum_{i=0}^{t-1}a_{i}r_{i}=0</span> is at most $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$, completing the proof. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We prove that the construction in Section 4.5 satisfies consistency soundness, based on the lemma above. Consider the interactive protocol underlying the construction: in each round, the prover sends the polynomials <span class="math">\\overline{\\text{index}}_{i+1}</span> and <span class="math">\\overline{\\text{value}}_{i+1}</span>, and receives a random field element <span class="math">r_{i}</span> from the verifier. The prover then computes</p>

    <p class="text-gray-300"><span class="math">\\overline{\\text{rand}}_{i+1}:=\\overline{\\text{rand}}_{i}+r_{i}\\cdot(\\overline{\\text{value}}_{i+1}-\\overline{\\text{value}}_{i}).</span></p>

    <p class="text-gray-300">Let <span class="math">\\ell</span> be a label, and let <span class="math">\\mathbf{x}</span> denote its corresponding index. Suppose that between epochs <span class="math">n</span> and <span class="math">m</span>, the value associated with <span class="math">\\ell</span> changes at least once. To prove consistency soundness, it suffices to show that <span class="math">\\overline{\\text{rand}}_{n}(\\mathbf{x})\\neq\\overline{\\text{rand}}_{m}(\\mathbf{x})</span> except with negligible probability. The reason is sufficient is that the server has to open these values <span class="math">\\overline{\\text{rand}}_{n}(\\mathbf{x})</span> and <span class="math">\\overline{\\text{rand}}_{m}(\\mathbf{x})</span> to the client. Since the underlying PCS is binding and sound, the server cannot cheat and therefore opens the correct values. Define:</p>

    <p class="text-gray-300"><span class="math">\\delta(\\mathbf{x}):=\\overline{\\text{rand}}_{m}(\\mathbf{x})-\\overline{\\text{rand}}_{n}(\\mathbf{x})=\\sum_{i=n}^{m-1}r_{i}\\cdot\\overline{\\Delta_{i}}(\\mathbf{x}),</span></p>

    <p class="text-gray-300">where <span class="math">\\overline{\\Delta_{i}}:=\\overline{\\text{value}}_{i+1}-\\overline{\\text{value}}_{i}</span>. By assumption, at least one <span class="math">\\overline{\\Delta_{i}}(\\mathbf{x})\\neq 0</span>. From the lemma above, we know that a non-trivial linear combination of independent random field elements is non-zero with all but negligible probability. Since each <span class="math">r_{i}</span> is sampled independently of <span class="math">\\overline{\\Delta_{i}}</span>, and at least one coefficient is non-zero, we conclude:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr[\\delta(\\mathbf{x})=0]\\leq 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, <span class="math">\\overline{\\text{rand}}_{n}(\\mathbf{x})=\\overline{\\text{rand}}_{m}(\\mathbf{x})</span> only with negligible probability. Finally, since the protocol involves a constant number of rounds and the verifier’s challenges are random field elements, it can be compiled into a non-interactive protocol using the Fiat–Shamir heuristic with soundness error remaining negligible <em>[x10, x2]</em>.</p>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{zkSetup}_{\\mathrm{KZH - k}}(\\lambda, k)</span> : This algorithm runs  <span class="math">\\mathrm{Setup}_{\\mathrm{KZH - k}}(\\lambda, k)</span>  and outputs verifier key  <span class="math">\\mathsf{vk}</span>  and prover key  <span class="math">\\mathsf{pk}</span> . It also outputs a new generator  <span class="math">h \\in \\mathbb{G}_1</span> , and we assume its Dlog is not known with respect to other generators.</li>

      <li><span class="math">\\mathrm{zkCommit}_{\\mathrm{KZH - k}}(\\mathsf{pk},f(\\mathbf{X}))</span>  :</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples randomness  <span class="math">\\tau \\gets \\mathbb{F}</span></li>

      <li>Then computes the commitment  <span class="math">C \\gets \\mathsf{Commit}_{\\mathsf{KZH - k}}(\\mathsf{pk}, f(\\vec{X}))</span> , and outputs  <span class="math">C_{\\mathrm{hide}} \\coloneqq C + \\tau \\cdot h</span> .</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{zkOpen}_{\\mathrm{KZH - k}}(\\mathsf{pk},f(\\mathbf{X}),\\vec{x},\\langle C_{\\mathrm{hide}},\\tau)\\rangle</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples  <span class="math">r(\\mathbf{X})</span>  which has the same size as  <span class="math">f(\\mathbf{X})</span>  and samples randomness  <span class="math">\\rho \\gets \\mathbb{F}</span> .</li>

      <li>The prover runs  <span class="math">R_{\\mathrm{hide}} \\gets \\mathrm{zkCommit}_{\\mathrm{KZH - k}}(\\mathsf{pk}, r(\\mathbf{X}); \\rho)</span> .</li>

      <li>The prover computes  <span class="math">y_{R} \\gets r(\\vec{x})</span>  and then sends  <span class="math">(R_{\\mathrm{hide}}, y_{R})</span>  to the verifier.</li>

      <li>The prover receives challenge  <span class="math">\\alpha</span>  and computes  <span class="math">\\rho&#x27; \\gets \\alpha \\cdot \\tau + \\rho</span>  and sends it to the verifier.</li>

      <li>The prover computes  <span class="math">C_{\\mathrm{lin}} \\coloneqq \\alpha \\times C_{\\mathrm{hide}} + R_{\\mathrm{hide}} - \\rho&#x27; \\times h</span> .</li>

      <li>Finally the prover runs  <span class="math">\\pi \\gets \\mathrm{Open}_{\\mathrm{KZH - k}}(\\mathsf{pk},\\alpha \\times f(\\mathbf{X}) + r(\\mathbf{X}),C_{\\mathrm{lin}},\\vec{x})</span>  and outputs proof  <span class="math">\\pi</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{zkVerify}_{\\mathrm{KZH - k}}(\\mathsf{vk},C_{\\mathrm{hide}},\\vec{x},y,\\pi)</span></li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier receives  <span class="math">(R_{\\mathrm{hide}},y_R)</span>  from the prover and sends challenge  <span class="math">\\alpha</span>  and receives  <span class="math">\\rho^{\\prime}</span></li>

      <li>The verifier computes  <span class="math">C_{\\mathrm{lin}} \\coloneqq \\alpha \\times C_{\\mathrm{hide}} + R_{\\mathrm{hide}} - \\rho&#x27; \\times h</span> .</li>

      <li>The verifier computes  <span class="math">y_{\\mathrm{lin}} \\coloneqq \\alpha \\times y + y_R</span> .</li>

      <li>The verifier runs  <span class="math">\\mathrm{Verify}_{\\mathrm{KZH - k}}(\\mathsf{vk},C_{\\mathrm{lin}},\\vec{x},y_{\\mathrm{lin}},\\pi)</span>  and outputs its result.</li>

    </ol>

    <p class="text-gray-300">Figure 13: zk-friendly variant of KZH- <span class="math">k</span>  commitment and opening scheme. To simplify the protocol, we assume the auxiliary input of KZH is part of the opening and is generated while opening, while in reality, the prover can compute it during commitment and store it as cache.</p>

    <p class="text-gray-300">A general technique for transforming a homomorphic PCS to be hiding is using a sigma protocol (see [B+21]). The key idea is to blind the original commitment  <span class="math">C</span>  to a polynomial  <span class="math">f(\\mathbf{X})</span>  to achieve hiding. During evaluation, the prover sends the evaluation  <span class="math">f(\\vec{x})</span>  along with a commitment  <span class="math">R</span>  to a fully random polynomial  <span class="math">r(\\mathbf{X})</span>  of the same degree as  <span class="math">f(\\mathbf{X})</span> , and the evaluation  <span class="math">r(\\vec{x})</span>  to the verifier. The verifier then samples a random challenge  <span class="math">\\alpha \\in \\mathbb{F}</span> , and the prover proves that the combined and unblinded commitment  <span class="math">\\alpha \\times C + R</span>  opens to  <span class="math">\\alpha \\cdot f(\\vec{x}) + r(\\vec{x})</span>  at  <span class="math">\\vec{x}</span> . Prior work [HKR19] showed that for Bulletproofs, it suffices for  <span class="math">r(\\mathbf{X})</span>  to have only a logarithmic number of non-zero coefficients, significantly reducing the prover's computational overhead. We make a similar observation in the context of the KZH-  <span class="math">k</span>  scheme, where it is sufficient for  <span class="math">r(\\mathbf{X})</span>  to have only  <span class="math">k \\cdot N^{1 / k}</span>  non-zero terms, as established in Lemmas 4 and 5. Let</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathrm{Setup}_{\\mathrm{KZH - k}}, \\mathrm{Commit}_{\\mathrm{KZH - k}}, \\mathrm{Open}_{\\mathrm{KZH - k}}, \\mathrm{Verify}_{\\mathrm{KZH - k}}\\right)</span></p>

    <p class="text-gray-300">be the PCS algorithms for KZH-k. We define the algorithms</p>

    <p class="text-gray-300"><span class="math">\\left(\\text{zkSetup}_{\\text{KZH-k}},\\&gt;\\text{zkCommit}_{\\text{KZH-k}},\\&gt;\\text{zkOpen}_{\\text{KZH-k}},\\&gt;\\text{zkVerify}_{\\text{KZH-k}}\\right)</span></p>

    <p class="text-gray-300">as the corresponding hiding (zero-knowledge) variant of KZH-k in Figure 13 which can be defined by using a sparse random polynomial <span class="math">r(\\mathbf{X})</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 2 (Zero-knowledge).</h6>

    <p class="text-gray-300">The hiding polynomial commitment protocol described in Figure 13 is zero-knowledge in the honest verifier model. That is, there exists a simulator which, given only the public input <span class="math">C_{hide},\\vec{x},y</span>, produces a transcript <span class="math">(R_{hide},y_{R},\\alpha,\\rho^{\\prime},C_{lin},\\pi)</span> that is identically distributed to one generated by interacting with an honest prover on input <span class="math">f(\\mathbf{X})</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We construct a simulator <span class="math">\\mathsf{Sim}</span> that outputs a transcript indistinguishable from a real execution, without access to the witness polynomial <span class="math">f(\\mathbf{X})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The simulator samples a random polynomial <span class="math">s(\\mathbf{X})</span> of the same degree as the (unknown) polynomial <span class="math">f(\\mathbf{X})</span>.</li>

      <li>It runs the commitment algorithm:</li>

    </ol>

    <p class="text-gray-300"><span class="math">C_{\\text{lin}}\\leftarrow\\texttt{Commit}_{\\text{KZH-k}}(\\text{pk},s(\\mathbf{X})).</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It runs the opening algorithm to produce a proof: <span class="math">\\pi:=\\textsf{Open}_{\\text{KZH-k}}(\\text{pk},s(\\mathbf{X}),C_{\\text{lin}},\\vec{x})</span>.</li>

      <li>It samples a random scalars <span class="math">\\alpha,\\rho^{\\prime}\\leftarrow\\mathbb{F}</span>.</li>

      <li>It computes: <span class="math">R_{\\text{hide}}:=C_{\\text{lin}}-\\alpha\\times C_{\\text{hide}}+\\rho^{\\prime}\\cdot h</span>.</li>

      <li>It computes <span class="math">y_{R}\\leftarrow s(\\vec{x})-\\alpha\\cdot y</span></li>

      <li>The simulator outputs the full transcript:</li>

    </ol>

    <p class="text-gray-300"><span class="math">(R_{\\text{hide}},y_{R},\\alpha,\\rho^{\\prime},C_{\\text{lin}},\\pi).</span></p>

    <p class="text-gray-300">This transcript is identically distributed to the output of a real prover since <span class="math">R_{\\text{hide}}</span> is a hiding commitment to a random polynomial, <span class="math">y_{R}</span> is the evaluation of the polynomial inside <span class="math">R_{\\text{hide}}</span>, <span class="math">\\alpha</span> is a random challenge and <span class="math">\\rho^{\\prime}</span> is the hiding factor of <span class="math">C_{\\text{lin}}</span>. Finally <span class="math">\\pi</span> is the non-zero knowledge proof for a random polynomial <span class="math">r(\\mathbf{X})+\\alpha\\cdot f(\\mathbf{X})</span> in both the simulated and real proofs. Thus, the protocol has perfect simulation and is honest-verifier zero-knowledge. ∎</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Lemma 3 (2-Special Soundness).</h6>

    <p class="text-gray-300">The hiding polynomial commitment protocol satisfies 2-special soundness: given two accepting transcripts</p>

    <p class="text-gray-300"><span class="math">\\left((C_{hide},\\vec{x},y),(R_{hide},y_{R}),\\alpha_{1},(\\rho_{1}^{\\prime},C_{lin,1},\\pi_{1})\\right)</span> <span class="math">\\left((C_{hide},\\vec{x},y),(R_{hide},y_{R}),\\alpha_{2},(\\rho_{2}^{\\prime},C_{lin,2},\\pi_{2})\\right),</span></p>

    <p class="text-gray-300">with the same first-round message <span class="math">(R_{hide},r)</span>, same commitment <span class="math">C_{hide}</span>, and same evaluation point <span class="math">\\vec{x}</span>, but different challenges <span class="math">\\alpha_{1}\\neq\\alpha_{2}</span>, one can extract the polynomial <span class="math">f</span>, such that <span class="math">f(\\vec{x})=y</span>.</p>

    <p class="text-gray-300">.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The prover produces valid opening proofs <span class="math">\\pi_{i}</span> at point <span class="math">\\vec{x}</span> to the evaluation <span class="math">\\alpha_{i}\\cdot y+y_{R}</span> for the commitments:</p>

    <p class="text-gray-300"><span class="math">C_{\\text{lin},i}:=\\alpha_{i}\\times C_{\\text{hide}}+R_{\\text{hide}}-\\rho^{\\prime}_{i}\\cdot h.</span></p>

    <p class="text-gray-300">Using extractability of the PCS, we can extract the polynomial <span class="math">g_{i}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}_{\\text{KZH-k}}(\\mathsf{pk},g_{i}(\\vec{X}))=C_{\\text{lin},i},</span></p>

    <p class="text-gray-300">and <span class="math">g_{i}(\\vec{x})=y+\\alpha_{i}y_{R}</span>. Using the homomorphism of the commitment scheme we get that <span class="math">\\mathsf{Commit}_{\\text{KZH-k}}(g_{1}-g_{2})+(\\rho^{\\prime}_{1}-\\rho^{\\prime}_{2})\\cdot h=(\\alpha_{1}-\\alpha_{2})C_{\\text{hide}}</span> Since <span class="math">\\alpha_{1}\\neq\\alpha_{2}</span>, we can solve for <span class="math">f,\\rho</span>:</p>

    <p class="text-gray-300"><span class="math">f=\\frac{g_{1}-g_{2}}{\\alpha_{1}-\\alpha_{2}},\\,\\rho=\\frac{\\rho^{\\prime}_{1}-\\rho^{\\prime}_{2}}{\\alpha_{1}-\\alpha_{2}}</span></p>

    <p class="text-gray-300">Finally, we need show that <span class="math">f(\\vec{x})=y</span>. This is the case as:</p>

    <p class="text-gray-300"><span class="math">f(\\vec{x})=\\frac{g_{1}(\\vec{x})-g_{2}(\\vec{x})}{\\alpha_{1}-\\alpha_{2}}=\\frac{\\alpha_{1}y-\\alpha_{2}y}{\\alpha_{1}-\\alpha_{2}}=y</span></p>

    <p class="text-gray-300">This completes the proof of 2-special soundness. ∎</p>

    <h3 id="sec-85" class="text-xl font-semibold mt-8">D.2 KZH requiring sublinear randomness</h3>

    <h6 id="sec-86" class="text-base font-medium mt-4">Lemma 4.</h6>

    <p class="text-gray-300">Let the multilinear polynomial <span class="math">r</span> be defined as:</p>

    <p class="text-gray-300"><span class="math">r(\\underbrace{X_{1},\\ldots,X_{n}}_{\\mathbf{X}},\\underbrace{Y_{1},\\ldots,Y_{n}}_{\\mathbf{Y}})=\\sum_{i\\in[n]}r_{i}\\cdot\\text{eq}(\\mathbf{X},\\vec{x})+r^{*}(\\mathbf{Y}),</span></p>

    <p class="text-gray-300">such that <span class="math">r_{i}</span>’s and polynomial <span class="math">r^{*}(\\mathbf{X})</span> are uniformly random. Using such randomized polynomial <span class="math">r</span> is sufficient such that opening to <span class="math">f(\\mathbf{X},\\mathbf{Y})</span> at the point <span class="math">(\\vec{x},\\vec{y})</span> remains hiding (i.e., zero-knowledge), when KZH-2 scheme is transformed to be hiding and zero-knowledge as outlined in Figure 13.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The hiding property is straightforward, as it is ensured by the hiding factor <span class="math">\\tau</span>, which remains unchanged. To establish that the opening is zero-knowledge, it suffices to show that the distribution of the proof vector generated for a specific <span class="math">r</span> is indistinguishable from the distribution of a proof vector generated using a fully random polynomial, as required by the original compiler. Formally, we show that the transcript generated by the simulator in Lemma 2, is identical to an honest transcript using limited randomness for <span class="math">r</span>. We prove the statement assuming <span class="math">f=0</span>. By linearity of the commitment and proof, the same holds for an arbitrary <span class="math">f</span>. First, we define the multilinear polynomial <span class="math">r(\\mathbf{X},\\mathbf{Y})</span> as:</p>

    <p class="text-gray-300"><span class="math">r(\\mathbf{X},\\mathbf{Y})=\\sum_{i\\in[n]}r_{i}\\cdot\\text{eq}(\\mathbf{X},\\vec{i})+r^{*}(\\mathbf{Y}),</span></p>

    <p class="text-gray-300"><span class="math">r(\\vec{i},\\mathbf{Y})=r_{i}+r^{<em>}(\\mathbf{Y})\\quad\\implies\\quad D_{i}:=\\mathrm{com}(r_{i}+r^{</em>}(\\mathbf{Y})).</span></p>

    <p class="text-gray-300">The partial evaluation at a fixed input <span class="math">\\vec{x}</span> becomes:</p>

    <p class="text-gray-300"><span class="math">r(\\vec{x},\\mathbf{Y})=\\sum_{i\\in[n]}r_{i}\\cdot\\mathrm{eq}(\\vec{x},\\vec{i})+r^{<em>}(\\mathbf{Y})\\implies\\pi=\\left(\\{\\mathrm{com}(r_{i}+r^{</em>}(\\mathbf{Y}))\\}_{i\\in[n]}\\,,\\;r(\\vec{x},\\mathbf{Y})\\right)</span></p>

    <p class="text-gray-300">Since each commitment <span class="math">D_{i}</span> contains a unique random term <span class="math">r_{i}</span>, the commitments are independent and uniformly distributed. Moreover, the term <span class="math">r(\\vec{x},\\mathbf{Y})</span> is identical to a partial evaluation of a random polynomial and the direct linear combination of the polynomials within the <span class="math">D_{i}</span>s, just as in the simulated proof. Thus, the entire proof vector <span class="math">\\pi</span> is distributed identically to the case when <span class="math">r(\\mathbf{X},\\mathbf{Y})</span> is sampled as a fully random polynomial, ensuring zero-knowledge. ∎</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 5.</h6>

    <p class="text-gray-300">Let <span class="math">r</span> be a multilinear polynomial defined as follows, where each <span class="math">\\mathbf{X}_{i}</span> consists of <span class="math">n</span> variables. Thus, <span class="math">r</span> has a total of <span class="math">k\\cdot n</span> variables:</p>

    <p class="text-gray-300"><span class="math">r(\\mathbf{X}_{1},\\ldots,\\mathbf{X}_{k}):=\\sum_{j\\in[k]}\\sum_{i\\in[n]}r_{i,j}\\cdot\\mathsf{eq}(\\mathbf{X}_{j},\\vec{i}),</span></p>

    <p class="text-gray-300">where each <span class="math">r_{i,j}</span> is sampled uniformly at random. Using such a randomized polynomial <span class="math">r</span> is sufficient to ensure that the opening to <span class="math">f(\\mathbf{X},\\mathbf{Y})</span> at the point <span class="math">(\\vec{x},\\vec{y})</span> remains hiding (i.e., zero-knowledge), when the KZH-<span class="math">k</span> scheme is transformed to be hiding and zero-knowledge as described in Figure 13.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Similar to the KZH-2 case, we show that the opening proof for such a polynomial <span class="math">r</span> is distributed identically to that of a truly random polynomial. This implies that the opening reveals no additional information, thereby preserving zero-knowledge. Given <span class="math">r</span> and how the <span class="math">\\vec{D_{i}}</span> vectors are computed in KZH-k opening, we see that</p>

    <p class="text-gray-300"><span class="math">D_{j^{\\prime}}[i^{\\prime}]=r_{i^{\\prime},j^{\\prime}}+\\sum_{j^{\\prime}\\leq j}\\sum_{i\\in[n]}r_{i,j}\\cdot\\mathsf{eq}(\\mathbf{X}_{j},\\vec{i})</span></p>

    <p class="text-gray-300">Using reasoning similar to the proof of Lemma 4, each <span class="math">D_{j}[i]</span> contains independent randomness <span class="math">r_{i,j}</span> and as a result, all <span class="math">D_{j}[i]</span> are independently and uniformly distributed. The final opening message is</p>

    <p class="text-gray-300"><span class="math">r(\\vec{x}_{1},\\ldots,\\vec{x}_{k-1},X_{k})=r_{k}(\\vec{X}_{k})+\\sum_{\\stackrel{{\\scriptstyle j\\in[k-1]}}{{i\\in[n]}}}r_{i,j}\\cdot\\mathsf{eq}(x_{j},\\vec{i}),</span></p>

    <p class="text-gray-300">and is a random univariate degree <span class="math">n</span> polynomial, that is homomorphically consistent with all <span class="math">D_{j}[i]</span> terms. The resulting proof is indistinguishable from one generated using a truly random polynomial <span class="math">r</span>. ∎</p>

    <p class="text-gray-300">D.3 Checking homomorphic relations over blinded commitments</p>

    <p class="text-gray-300">A drawback of using blinded commitments is that we can no longer check homomorphic relations directly, since the hiding parameters on the two sides of the relation may differ. The problem reduces to verifying that two PCS commitments, <span class="math">\\mathsf{com}_{1}</span> and <span class="math">\\mathsf{com}_{2}</span>, which use different hiding factors, correspond to the same polynomial. A straightforward approach is to open both commitments at a random evaluation point and check whether they yield the same value; by the Schwartz–Zippel lemma <em>[Sch80, Zip79]</em>, this guarantees that the underlying polynomials are equal with high probability. However, this requires two PCS openings, which is expensive. A more efficient approach is to check whether <span class="math">\\mathsf{com}_{1}-\\mathsf{com}_{2}</span> opens to the zero polynomial, i.e., that it equals <span class="math">h^{c}</span> for some <span class="math">c\\in\\mathbb{F}</span>, where <span class="math">h</span> is the hiding generator. This can be done using a simple sigma protocol requiring only a constant number of operations. In conclusion, checking homomorphic identities with blinded commitments requires a sigma protocol, which incurs only a constant overhead for both the server and the auditor.</p>

    <h2 id="sec-90" class="text-2xl font-bold">Appendix E KZH-k description</h2>

    <p class="text-gray-300">Description of KZH-k can be seen in Figure 14. We define an asymmetric pairing group as a tuple <span class="math">(p,g_{1},g_{2},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e)</span>, where <span class="math">p</span> denotes the order of the groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>, and <span class="math">e</span> is an efficiently computable, non-degenerate bilinear map. Let <span class="math">\\mathbb{F}</span> be the finite field such that the scalars of <span class="math">\\mathbb{G}_{1}</span> lie in <span class="math">\\mathbb{F}</span>. We adopt additive notation: for any <span class="math">a\\in\\mathbb{F}</span> and <span class="math">\\mathsf{G}\\in\\mathbb{G}_{1}</span>, scalar multiplication is written as <span class="math">a\\times\\mathsf{G}.</span> We assume <span class="math">\\mathsf{G}</span> is a generator of <span class="math">\\mathbb{G}_{1}</span>, and <span class="math">\\mathsf{V}</span> is a generator of <span class="math">\\mathbb{G}_{2}</span>. For a multilinear polynomial <span class="math">f(\\vec{X}_{1},\\vec{X}_{2},\\ldots,\\vec{X}_{k})</span>, we denote <span class="math">f_{\\vec{b}_{1},\\vec{b}_{2},\\ldots,\\vec{b}_{i}}</span> as the partial evaluation</p>

    <p class="text-gray-300"><span class="math">f(\\vec{b}_{1},\\vec{b}_{2},\\ldots,\\vec{b}_{i},\\vec{X}_{i+1},\\ldots,\\vec{X}_{k}).</span></p>

    <h4 id="sec-91" class="text-lg font-semibold mt-6">Free Boolean opening.</h4>

    <p class="text-gray-300">A subtle point in Figure 14 is that although the auxiliary inputs are computed during the commitment phase for all <span class="math">j=1</span> to <span class="math">k-1</span>, only those with <span class="math">j\\leq\\lfloor k/2\\rfloor</span> are actually used in the opening phase. This is because the opening procedure in Figure 14 is designed for the general case of evaluating at a random point <span class="math">(\\vec{x}_{1},\\vec{x}_{2},\\ldots,\\vec{x}_{k})</span>. To allow for free Boolean opening, we compute the full auxiliary input. In the special case of Boolean points, the summation in Equation (2) reduces to selecting a single value <span class="math">\\mathrm{aux}_{\\vec{b}_{1},\\ldots,\\vec{b}_{j-1},\\vec{b}}</span>. This is due to the fact that <span class="math">\\mathrm{eq}((\\vec{x}_{1},\\ldots,\\vec{x}_{j-1}),(\\vec{b}_{1},\\ldots,\\vec{b}_{j-1}))</span> vanishes everywhere on the Boolean hypercube except at <span class="math">(\\vec{b}_{1},\\ldots,\\vec{b}_{j-1})=(\\vec{x}_{1},\\ldots,\\vec{x}_{j-1})</span>. Consequently, openings at Boolean points come essentially for free.</p>

    <p class="text-gray-300">KZH-k.Setup(λ,(d1,d2,...,dk),k):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample  <span class="math">\\mathsf{G} \\gets \\mathbb{G}_1, \\mathsf{V} \\gets \\mathbb{G}_2</span>  and  <span class="math">[\\left[\\mu_{\\vec{b},j}\\right]_{\\vec{b} \\in \\{0,1\\}^{d_j}}]_{j=1}^k \\gets \\mathbb{F}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{H}_1 = \\{\\mathsf{H}_{\\vec{b}_1,\\dots,\\vec{b}_i}\\gets (\\prod_{j = 1}^k\\mu_{\\vec{b}_j,j})\\times \\mathsf{G}:\\forall \\vec{b}_1\\in \\{0,1\\}^{d_1},\\dots ,\\vec{b}_k\\in \\{0,1\\}^{d_k}\\}</span> <span class="math">\\mathbf{H}_2 = \\{\\mathsf{H}_{\\vec{b}_2,\\dots,\\vec{b}_k}\\gets (\\prod_{j = 2}^k\\mu_{\\vec{b}_j,j})\\times \\mathsf{G}:\\forall \\vec{b}_2\\in \\{0,1\\}^{d_2},\\dots ,\\vec{b}_k\\in \\{0,1\\}^{d_k}\\}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{H}_k = \\{\\mathsf{H}_{\\vec{b}_k}\\gets \\mu_{\\vec{b}_k,k}\\times \\mathsf{G}:\\forall \\vec{b}_k\\in \\{0,1\\}^{d_k}\\}</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{V} = \\{\\mathsf{V}_{\\vec{b}_j,j}\\gets \\mu_{\\vec{b}_j,j}\\times \\mathsf{V}:\\forall j\\in [k],\\vec{b_j}\\in \\{0,1\\}^{d_j}\\}</span> Output  <span class="math">(\\mathsf{G},\\mathsf{V},\\mathbf{H}_1,\\mathbf{H}_2,\\dots ,\\mathbf{H}_k,\\mathbf{V})</span></p>

    <p class="text-gray-300">KZH-k.commit(srs,  <span class="math">f</span> ): For  <span class="math">f(\\vec{X}_1,\\vec{X}_2,\\dots,\\vec{X}_k)</span> , compute the commitment as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output  <span class="math">\\mathsf{C} \\gets \\langle f, \\mathbf{H}_1 \\rangle = \\sum_{\\vec{b}_1 \\in \\{0,1\\}^{d_1}, \\dots, \\vec{b}_k \\in \\{0,1\\}^{d_k}} f_{\\vec{b}_1, \\vec{b}_2, \\dots, \\vec{b}_k} \\times \\mathsf{H}_{\\vec{b}_1, \\vec{b}_2, \\dots, \\vec{b}_k}</span></li>

      <li>For  <span class="math">j = 1, \\dots, k - 1</span>  compute  <span class="math">\\max_{\\vec{b}_1, \\dots, \\vec{b}_j} := \\langle f(\\vec{b}_1, \\dots, \\vec{b}_j, \\vec{X}_{j+1}, \\dots, \\vec{X}_k), \\mathbf{H}_{j+1} \\rangle</span> , for each  <span class="math">\\vec{b}_i \\in \\{0,1\\}^{d_i}</span> . The open algorithm takes the auxiliary input implicitly.</li>

    </ul>

    <p class="text-gray-300">KZH-k.open(srs, C,  <span class="math">f, \\vec{x}_1, \\ldots, \\vec{x}_k</span> ): Given commitment  <span class="math">C \\in \\mathbb{G}_1</span> , polynomial  <span class="math">f(\\vec{X}_1, \\vec{X}_2, \\ldots, \\vec{X}_k)</span>  and inputs  <span class="math">\\vec{x}_j \\in \\mathbb{F}^{d_j}</span> , compute opening as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">j = 1, \\dots, k - 1</span> :</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">f_{\\vec{x}_1,\\vec{x}_2,\\dots,\\vec{x}_{j-1}}</span>  efficiently from previous partial evaluation.</li>

      <li>Compute vector  <span class="math">\\vec{\\mathsf{D}}_j\\coloneqq \\{\\mathsf{D}_{j,\\vec{b}}\\coloneqq \\langle f_{\\vec{x}_1,\\vec{x}_2,\\dots ,\\vec{x}_{j - 1},\\vec{b}},\\mathbf{H}_{j + 1}\\rangle :\\vec{b}\\in \\{0,1\\}^{d_j}\\}</span></li>

    </ul>

    <p class="text-gray-300">We observe Equation 2. For  <span class="math">j \\leq \\lfloor k / 2 \\rfloor</span> , computing  <span class="math">\\vec{\\mathsf{D}}_j</span>  via this identity requires  <span class="math">O(N^{1/2})</span>  operations, where  <span class="math">N</span>  denotes the overall size of the polynomial. For  <span class="math">j &amp;gt; \\lfloor k / 2 \\rfloor</span> , it is more efficient to compute directly, since the size of partially-evaluated polynomial  <span class="math">f_{\\vec{x}_1, \\vec{x}_2, \\dots, \\vec{x}_j}</span>  is already smaller than  <span class="math">O(N^{1/2})</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\langle f _ {\\vec {x} _ {1}, \\dots , \\vec {x} _ {j - 1}, \\vec {b}}, \\mathbf {H} _ {j + 1} \\rangle = \\sum_ {\\substack {\\vec {b} _ {1} \\in \\{0, 1 \\} ^ {d _ {1}} \\\\ \\vec {b} _ {j - 1} \\in \\{0, 1 \\} ^ {d _ {j - 1}}}} \\operatorname {eq} \\left(\\left(\\vec {x} _ {1}, \\dots , \\vec {x} _ {j - 1}\\right), \\left(\\vec {b} _ {1}, \\dots , \\vec {b} _ {j - 1}\\right)\\right) \\times \\operatorname {aux} _ {\\vec {b} _ {1}, \\dots , \\vec {b} _ {j - 1}, \\vec {b}} \\tag{2}</span></div>

    <p class="text-gray-300">Output  <span class="math">\\pi \\gets \\{[\\vec{D}_j]_{j\\in [k - 1]},f_{\\vec{x}_1,\\dots ,\\vec{x}_{k - 1}}\\}</span></p>

    <p class="text-gray-300">KZH-k. verify(srs, C,  <span class="math">[\\vec{x}_j]_{j\\in [k]},y,\\pi)</span> : Given commitment  <span class="math">\\mathsf{C}\\in \\mathbb{G}_1</span> , inputs  <span class="math">\\vec{x}_j\\in \\mathbb{F}^d</span> , output  <span class="math">y\\in \\mathbb{F}</span>  and opening proof  <span class="math">\\pi</span> , does as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\{[\\vec{D}_j]_{j\\in [k - 1]},f_{\\vec{x}_1,\\dots ,\\vec{x}_{k - 1}}\\} \\gets \\pi</span></li>

      <li>Set  <span class="math">\\mathsf{C}_0 = \\mathsf{C}</span>  and for  <span class="math">j\\in 1,\\ldots ,k - 1</span>  , do the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">e(\\mathsf{C}_{j - 1},\\mathsf{V}) = \\sum_{\\vec{b}\\in \\{0,1\\}^{d_j}}e(\\mathsf{D}_{j,\\vec{b}},\\mathsf{V}_{i,j})</span></li>

      <li>Compute  <span class="math">\\mathsf{C}_j = \\sum_{\\vec{b}\\in \\{0,1\\}^{d_j}}\\mathrm{eq}(\\vec{x}_j,\\vec{b})\\times \\mathsf{D}_{j,\\vec{b}}</span></li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">\\mathsf{C}_{k - 1} = \\langle f_{\\vec{x}_1,\\vec{x}_2,\\dots,\\vec{x}_{k - 1}},\\mathbf{H}_k\\rangle</span></li>

      <li>Check that  <span class="math">f_{\\vec{x}_1,\\vec{x}_2,\\dots,\\vec{x}_{k-1}}(\\vec{x}_k) = y</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 14: (non-zk) KZH-k description to commit to a multilinear polynomial  <span class="math">f(\\vec{X}_1, \\vec{X}_2, \\ldots, \\vec{X}_k)</span>  such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{X}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= d_i$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="IronDict: Transparent Dictionaries from Polynomial Commitmen... (2025/1580)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/1580
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
