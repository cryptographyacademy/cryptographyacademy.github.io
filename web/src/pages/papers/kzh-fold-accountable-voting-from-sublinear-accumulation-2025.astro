---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2025/144';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'KZH-Fold: Accountable Voting from Sublinear Accumulation';
const AUTHORS_HTML = 'George Kadianakis, Arantxa Zapico, Hossein Hafezi, Benedikt Bünz';

const CONTENT = `    <p class="text-gray-300">George Kadianakis<sup>1</sup> , Arantxa Zapico<sup>2</sup> , Hossein Hafezi<sup>3</sup> , and Benedikt Bünz<sup>4</sup></p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>1,2Ethereum Foundation 3,4New York University</p>
    </blockquote>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Accumulation schemes are powerful primitives that enable distributed and incremental verifiable computation with less overhead than recursive SNARKs. However, most existing schemes with constant-size accumulation verifiers suffer from linear-sized accumulators and deciders, leading to unsuitable linear-sized proofs in distributed settings such as accountable voting protocols. Our contributions are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We introduce KZH, a novel multilinear polynomial commitment scheme (PCS) with sublinear opening and KZH-fold, a polynomial accumulation (PA) scheme where the verifier only does 3 group scalar multiplications and O(n 1/2 ) accumulator size and decider time. Our scheme generalizes to achieve accumulator and decider complexity of O(k · n <sup>1</sup>/k) while a verifier complexity O(k).</li>

      <li>As an orthogonal contribution to KZH-fold, we build an IVC (PCD) scheme for R1CS via Spartan+PA, in which instantiated with KZH-fold, i.e. Spartan+KZHfold results in a sublinear proof and decider. With the recipe of Spartan+PA, we build non-uniform IVC and non-uniform PCD. Our non-uniform PCD is the first approach in which the prover's computation and communication at each step and grow sublinearly with the combined circuit size of all instructions. This approach can be instantiated with any PA and doesn't depend on KZH-fold.</li>

      <li>We demonstrate the power of Spartan+KZH-fold by implementing an accountable voting scheme using a novel signature aggregation protocol supporting millions of participants, significantly reducing communication overhead and verifier time compared to BLS-based aggregation. We implemented and benchmarked our protocols, Spartan+KZH-fold achieves a 2000x reduction in communication and a 50x improvement in decider time over Nova when proving 2000 Poseidon hashes, at the cost of 3x the prover time.</li>

    </ul>

    <p class="text-gray-300">{asn, arantxa}@ethereum.org, {h.hafezi, bb}@nyu.edu The order of authors is arbitrary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Introduction</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.1</td>

            <td class="px-3 py-2 border-b border-gray-700">KZH<br>multilinear polynomial commitment scheme<br></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Sublinear accumulation schemes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Signature aggregation in consensus<br></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Contributions<br></td>

            <td class="px-3 py-2 border-b border-gray-700">10</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">Additional related work<br></td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Technical Overview</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Preliminaries</td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Notation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">14</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Polynomial commitment schemes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">15</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Accumulators<br></td>

            <td class="px-3 py-2 border-b border-gray-700">16</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Incrementally verifiable computation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">17</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3.5</td>

            <td class="px-3 py-2 border-b border-gray-700">IVC from accumulators<br></td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">KZH: An efficiently aggregatable polynomial commitment</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4.1</td>

            <td class="px-3 py-2 border-b border-gray-700">KZH-fold: Accumulator with sublinear size<br></td>

            <td class="px-3 py-2 border-b border-gray-700">19<br>21</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PIOP+PA: IVC/PCD from Polynomial Accumulation</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.1</td>

            <td class="px-3 py-2 border-b border-gray-700">PIOP Accumulation: accumulating Spartan PIOP<br></td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Uniform IVC/PCD from polynomial accumulation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5.3</td>

            <td class="px-3 py-2 border-b border-gray-700">N-IVC and N-PCD from polynomial accumulation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">PIOP for signature aggregation protocol</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Implementation and efficiency</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Efficiency of<br>KZH<br></td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Comparison with Halo Infinite<br></td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.3</td>

            <td class="px-3 py-2 border-b border-gray-700">Comparison with Nova<br></td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">7.4</td>

            <td class="px-3 py-2 border-b border-gray-700">Comparison with BLS aggregation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Deferred definitions</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">A.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Signature schemes<br></td>

            <td class="px-3 py-2 border-b border-gray-700">45<br>45</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">B</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Deferred proofs</td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.1</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of theorem<br>3<br></td>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">B.2</td>

            <td class="px-3 py-2 border-b border-gray-700">Proof of theorem<br>4<br></td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Higher dimension PCS for smaller deciders</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C.1<br>KZH-k<br></td>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">C.2<br>KZH-k accumulation<br></td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">D</td>

            <td class="px-3 py-2 border-b border-gray-700">Non-Uniformity from Polynomial Accumulation</td>

            <td class="px-3 py-2 border-b border-gray-700">65</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Distributed verifiable computation (also known as proof-carrying-data or PCD) [CT10] is a powerful primitive that allows a distributed set of parties to jointly perform a computation such that each intermediate step and the result can be efficiently verified. This is useful for computations that are performed by distributed and distrusting parties. Each party can perform a step of the computation and then forward their output, along with a PCD proof that asserts the correctness of the computation up to this point. Examples of these computations are map-reduce systems DG08; CTV15, where nodes jointly compute on large data sets, distributed rollups [Her24; KB23] where nodes compute joined transaction blocks, and distributed voting, where participants jointly compute a quorum certificate on a set of nodes. PCD can be built from recursive SNARKs; however, this approach has high overhead, requiring implementing the SNARK verifier inside of the proof circuit [Ben+14]. A promising recent line of work [KST22; Bün+21; KS24; BC23] showed how to construct PCD from so-called accumulation schemes. An accumulation scheme iteratively accumulates proofs into an accumulator. The accumulator is valid if and only if the input proofs are all valid. Importantly, checking the validity of the accumulation is much simpler than checking all the original proofs. PCD built from the most efficient accumulation schemes [KST22; Bün+21; KS24; BC23] only requires proving a constant number of group operations as overhead.</p>

    <p class="text-gray-300">IVC/PCD built from linear-sized accumulation schemes face significant challenges in distributed settings. To illustrate, the communication in distributed PCD is mainly dominated by an accumulator, in which is the size of the computation step and requires substantial time to decide by the receiving party. To demonstrate with numbers, assume we are using Nova, a linear-sized accumulation scheme, with a step computation of 1 million R1CS constraints. It results in a communication size of 80MB and a decider time of  <span class="math">\\approx</span> 5s on a moderate laptop, for the receiving party to ensure the receiving accumulator is correct before continuing the computation.</p>

    <p class="text-gray-300">In this work, we present KZH, a multilinear polynomial commitment scheme with efficient opening times. KZH, like the famous KZG polynomial commitment [KZG10], is secure in a pairing-friendly group, leverages a universal, upgradable structured reference string, and is secure in the algebraic group model. We also design KZH-fold, an efficient accumulation scheme for KZH. KZH-fold has a sublinear-sized accumulator that can be efficiently verified while retaining the constant size and concretely efficient accumulation verifier of prior works, such as Nova or Protostar. To illustrate sublinearity, if the original polynomials are of degree n, the resulting accumulator has a size sublinear in n, e.g.  <span class="math">O(n^{\\frac{1}{2}})</span> . Concretely, we present an accumulation scheme where the accumulator for computations of size n is  <span class="math">O(n^{\\frac{1}{2}})</span> , compared to O(n) for Nova, and the accumulation verifier performs 3 group</p>

    <p class="text-gray-300"><span id="page-3-1"></span><sup>&</sup>lt;sup>a</sup>Decider algorithm for an accumulation scheme checks if an accumulator is valid which results in all the accumulated proofs being valid, i.e. it is equivalent to IVC/PCD verifier in the context of IVC/PCD.</p>

    <p class="text-gray-300">scalar multiplications to add a fresh proof to the accumulator (compared to 2 for Nova, 3 for Protostar and 1 for HyperNova). The decider runtime is dominated by a pairing product of size  <span class="math">n^{\\frac{1}{2}}</span> . We also generalize the scheme to KZH-k such that the accumulator and decider are only  <span class="math">O(k \\cdot n^{\\frac{1}{k}})</span> , with an O(k) accumulation verifier for an arbitrary constant k. Using the compilers from [Bün+20; Bün+21; BC23], we construct an accumulation scheme for KZH. Given the general recipe of accumulation of polynomial checks in a polynomial interactive oracle proof (PIOP) or as we will refer to it as PIOP+PA, we build an accumulation scheme for R1CS (and hence IVC/PCD), by combining a variant Spartan [Set20] with a PA, and we refer to this as Spartan+PA. We then show that our scheme has significant benefits in an important application: accountable voting for large-scale consensus.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.1 KZH multilinear polynomial commitment scheme</h3>

    <p class="text-gray-300">Extending ideas from Hyrax, we design KZH (KZG + Hyrax) with the following appealing features: Given a log n-variate multilinear polynomial, KZH has a linear-time commitment phase, primarily dominated by an MSM of size n directly to the witness, resulting in fast commitment when the witness consists of small field elements. The commitment is a single  <span class="math">\\mathbb{G}_1</span>  element. The opening and verification times are both  <span class="math">O(n^{\\frac{1}{2}})</span> , and the proof size is also  <span class="math">O(n^{\\frac{1}{2}})</span> . The core idea of KZH is to represent polynomial evaluation as a matrix operation, reducing it to matrix-vector multiplication. We extend this concept to tensors, where a matrix is a tensor of dimension 2, and introduce KZH-k for a constant number k. KZH-k has linear commitment time, and the opening time remains  <span class="math">O(n^{\\frac{1}{2}})</span>  through preprocessing, but the verifier time and proof size are both changed to  <span class="math">O(k \\cdot n^{\\frac{1}{k}})</span> .</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{KZH}\\text{-}\\mathsf{log}(n)</span>  is of independent interest as a standalone commitment scheme. Like the multivariate commitment scheme from [PST13], it has  <span class="math">O(\\log(n))</span>  group elements proof size, and verifier time. Its key advantage is that computing an opening proof can be done using only  <span class="math">n^{\\frac{1}{2}}</span>  group operations (not including polynomial evaluation). KZH-log(n) unlike similar schemes like Dory [Lee21], the proof does not consist of target group elements and subsequently the verifier does not do target group operations which limits its application to smart contracts not supporting such operations. However, KZH-log n suffers from quasilinear commitment time, which is acceptable for applications where the polynomial is committed once and then opened frequently, as in <em>index-efficient PIOPs</em>, demonstrated in a recent work [Cam+25]. This includes applications where the polynomial is part of the index in a relation, such as committing to a table in a lookup relation. However, for applications like committing to the polynomial witness in a PIOP, such as Spartan, where the prover must commit to the polynomial and open it at a single point, KZH-k with a small constant k (e.g., 3 or 4) is more efficient. That is because in practice a verifier time of  <span class="math">O(4 \\cdot n^{\\frac{1}{4}})</span>  does not differ from  <span class="math">O(\\log n)</span>  for reasonable polynomial degree n, and our evaluations confirm this. We emphasize again that both the committing and opening algorithms of KZH and KZH-k benefit from a witness consisting of small field elements. For example, it is very efficient to commit and open a polynomial when the evaluation points are 0s and 1s, as is the case in our demonstrated signature aggregation scheme. In Table 1, we compare various polynomial commitment schemes with  <span class="math">\\mathsf{KZH}</span>  and  <span class="math">\\mathsf{KZH}\\text{-}\\mathsf{log}(n)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Supports</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Opening time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZH</td>

            <td class="px-3 py-2 border-b border-gray-700">Multilinear</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n^{\\frac{1}{2}}\\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2n^{\\frac{1}{2}}\\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n^{\\frac{1}{2}} \\; \\mathrm{P} + 2 \\cdot \\mathrm{MSM}(n^{\\frac{1}{2}})</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">KZH\\text{-}\\mathrm{log}(n)</span></td>

            <td class="px-3 py-2 border-b border-gray-700">Multilinear</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n^{\\frac{1}{2}}\\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2\\log(n)\\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2\\log(n)</span> P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[PST13]</td>

            <td class="px-3 py-2 border-b border-gray-700">Multivariate</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\log(n) \\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\log(n) P</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[KZG10]</td>

            <td class="px-3 py-2 border-b border-gray-700">Univariate</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">1\\mathbb{G}_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700">2 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Lee21]</td>

            <td class="px-3 py-2 border-b border-gray-700">Multilinear</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">n^{\\frac{1}{2}}P</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">3\\log(n)\\mathbb{G}_T</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\log(n) \\mathbb{G}_T</span> , P</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-5-1"></span>Table 1: Comparison for KZH, KZH- <span class="math">\\log(n)</span> , KZG, PST and Dory. For the multivariate scheme  <span class="math">\\log(n)</span>  is the number of variables, for KZG n is the degree. P stands for pairing operations,  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_T</span>  for base and target group operations respectively. Commitment time for all schemes is dominated by an MSM of size n.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.2 Sublinear accumulation schemes</h3>

    <p class="text-gray-300">As our core technical contribution, we design KZH-fold, an accumulation scheme<sup>b</sup> with a sublinear accumulator and decider (including the accumulator witness) and a constant-sized accumulation verifier. Concretely, the accumulation verifier performs only 3 group scalar multiplications and has an accumulator consisting of  <span class="math">O(n^{\\frac{1}{2}})</span>  elements. In the same manner as KZH polynomial commitment scheme, we generalize KZH-fold to KZH-k fold, an accumulation scheme of KZH-k with an accumulator of size  <span class="math">k \\cdot n^{\\frac{1}{k}}</span>  and an accumulation verifier of size O(k). Through the compilers of [Bün+21; KS23a], we get a PCD scheme with minimal overhead and significantly smaller and faster to verify PCD proofs compared to PCD from linear-sized accumulation schemes.</p>

    <p class="text-gray-300">The accumulator witness in KZH-fold consists of  <span class="math">n^{\\frac{1}{2}}</span>  group elements and  <span class="math">5 \\times n^{\\frac{1}{2}}</span>  field elements and is thus significantly smaller than the original polynomial. Subsequently, the decider runs in time  <span class="math">O(n^{\\frac{1}{2}})</span> , dominated by a pairing-product of that size. We combine KZH-fold with a PIOP [BFS20; Set20], to get an accumulation scheme for R1CS. This R1CS accumulation scheme yields an IVC (PCD) scheme through the BCLMS [Bün+21] and Cyclefold [KS23b] compilers. The accumulator size directly corresponds to the IVC (PCD) proof size, and the decider to the IVC (PCD) verifier time.</p>

    <p class="text-gray-300">The sublinear accumulator - which results in IVC/PCD with sublinear proofs - is advantageous in distributed applications of PCD, such as prover networks or accountable voting, as PCD proofs, which turn out to be accumulators, must be passed from node to node. For this reason, most prior applications of accumulation-based PCD, which were based on linear</p>

    <p class="text-gray-300"><span id="page-5-2"></span><sup>&</sup>lt;sup>b</sup>Technically, any SNARK yields an accumulation scheme. However, no SNARK exists where the verification only requires a constant and small number of group operations.</p>

    <p class="text-gray-300">accumulation schemes were mainly limited to single-prover scenarios. Nova [\\[KST22\\]](#page-39-6), previously proposed compressing the proof via outsourcing the decider. However, computing this proof has a 24x<a href="#page-6-0">c</a> prover overhead and a 2x decider overhead, compared to the accumulation step without compression. Even in the compressed setting, the decider remains linear and inefficient. Using Spartan+KZH-fold this additional compression step is unnecessary, as the decider is already efficient. Concurrent work, MicroNova [\\[ZSC24\\]](#page-40-7), modifies Nova's compression phase to achieve sublinear decider time. However, this improvement comes at an even higher prover cost than Nova's compression phase, plus a trusted KZG setup (similar to ours). The compressed proofs in Nova and MicroNova are no longer incrementally updateable with an accumulation scheme. While this may be acceptable in a single-prover setting for applications like rollups, it is problematic in distributed settings or applications with an ongoing computation such as building light clients from IVC [\\[Che+20\\]](#page-40-8), constant-sized blockchains [\\[Bon+20\\]](#page-40-9), verifiable key directories [\\[Tya+21\\]](#page-40-10) or verifiable virtual machines (e.g. zkVM).</p>

    <p class="text-gray-300">KZH-fold retains many of the benefits of previous accumulation schemes, shown in Table <a href="#page-6-1">2.</a> It only requires a single commitment to the witness and can take advantage of sparse and small-weight witnesses. The accumulation verifier only performs a small (3) number of group scalar multiplications in group one of a pairing-friendly group. KZH-fold requires a trusted setup, but that setup is universal and updatable. It is possible to reuse a powers-of-τ [\\[Gro+18\\]](#page-40-11) setup, commonly used for the KZG polynomial commitment. We implement IVC circuits of Spartan+KZH2-fold and Spartan+KZH3-fold, and show that even our unoptimized implementation has a 200-2000x times smaller accumulator than Nova for reasonable computations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Recursive Overhead</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Decider</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">acc</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 SM</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Protostar</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 SM</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">HyperNova</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 SM</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZH2-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">2MSM(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">3 SM</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2 P<br>n</td>

            <td class="px-3 py-2 border-b border-gray-700">1/2<br>O(n<br>)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZH-k fold</td>

            <td class="px-3 py-2 border-b border-gray-700">2MSM(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">k<br>+ 1<br>SM</td>

            <td class="px-3 py-2 border-b border-gray-700">1/k P<br>k<br>·<br>n</td>

            <td class="px-3 py-2 border-b border-gray-700">1/k)<br>O(k<br>·<br>n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Halo</td>

            <td class="px-3 py-2 border-b border-gray-700">2MSM(w)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 log<br>n<br>SM</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log<br>n)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BCMS (KZG)</td>

            <td class="px-3 py-2 border-b border-gray-700">MSM(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">5 SM</td>

            <td class="px-3 py-2 border-b border-gray-700">2 P</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-6-1"></span>Table 2: Comparison of group-based accumulation schemes. SM refers to group scalar multiplication, MSM(n) is a multi-scalar multiplication of size n, the length of the witness vs. MSM(w), which refers to a multi-scalar multiplication of the weight of the witness. For sparse or low-weight witnesses, this is significantly less. P is a pairing operation.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-6-0"></span><sup>c</sup>We inferred this from Nova, in Section 1.3 it is mentioned that "When</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2<sup>20</sup> constraints, the prover's per-step cost to produce an IVC proof is ≈ 1µs/constraint. For the same F, the cost to produce a compressed IVC proof is ≈ 24µs/constraint."</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Signature aggregation in consensus</h3>

    <p class="text-gray-300">Voting protocols, especially accountable open-ballot systems, require robust yet efficient methods to aggregate and verify votes from a large participant base. These protocols depend on mechanisms that ensure each participant's vote is accurately recorded and that the overall results remain transparent and verifiable. A prominent application of accountable voting principles can be found in blockchain consensus protocols. In decentralized networks like Ethereum, over 1 million validators must attest to each block by signing it, collectively establishing consensus on network state changes<a href="#page-7-1">d</a> . With such a high volume of participants, bandwidth efficiency becomes critical, not only due to the redundancy and overhead inherent in decentralized P2P networking but also to support the participation of low-end machines as validators.</p>

    <p class="text-gray-300">In consensus protocols, a block is considered finalized when a supermajority of validators vote for it, ensuring it cannot be reverted. Currently, Ethereum limits itself to aggregating 32,768 signatures per slot [\\[Resb\\]](#page-41-0), which delays finality to 15 minutes. Reducing the cost of signature aggregation could simultaneously improve finality time to just a few seconds, which refers to the speed at which transactions become irreversible [\\[Sin\\]](#page-41-1), while also enhancing Ethereum's decentralization by enabling a higher validator count [\\[But\\]](#page-41-2). Furthermore, efficient aggregation could facilitate the adoption of advanced consensus protocols, designed explicitly for Ethereum <a href="#page-41-3">\\[D'A+24b;</a> <a href="#page-41-4">DZ23;</a> [D'A+24a\\]](#page-41-5), which aim to provide faster finality, strengthen protocol security [\\[D'A+22\\]](#page-41-6), and improve resilience to MEV.</p>

    <p class="text-gray-300">Current state-of-the-art consensus protocols, such as Ethereum, Chia, Algorand [\\[Gil+17\\]](#page-41-7) and Hotstuff [\\[Yin+19\\]](#page-41-8) employ aggregatable signature schemes like BLS signatures [\\[BLS04\\]](#page-41-9). BLS signatures allow multiple validators to merge their signatures on the same message, e.g. a block, into a single, compact, aggregated message, reducing both transmission and verification overhead. To achieve accountability, Blockchain protocols [\\[BDN18\\]](#page-41-10) pair BLS aggregates with a bit vector indicating who has signed. This enables slashing validators who sign conflicting proposals. To add redundancy and improve communication, consensus protocols can use multiple layers of recursive aggregation, aggregating already aggregated signatures into one. In proposed designs [\\[Resa\\]](#page-41-11), the signatures are aggregated in multiple layers, and each aggregation layer has between r = 16 and r = 32 aggregators. Figure <a href="#page-8-1">1</a> depicts such a tree-based aggregation mechanism.</p>

    <p class="text-gray-300">Limitations of signature aggregation. In this work, we are interested in accountable signature aggregation schemes with minimal communication and verification overhead. Regarding communication, an accountable aggregation scheme such as the one depicted in Figure <a href="#page-8-1">1,</a> requires nodes to transmit, at minimum, a compact bit vector (i.e. a bitfield) indicating who signed. For verification, nodes must scan the bitfield to identify the signers while ensuring that verification complexity remains independent of the number of signers. BLS aggregation, while yielding a small aggregate signature, does not achieve this optimal</p>

    <p class="text-gray-300"><span id="page-7-1"></span>d <https://beaconcha.in/charts/validators></p>

    <p class="text-gray-300"><img src="_page_8_Picture_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 1: A tree-based aggregation scheme with a single layer of recursive aggregation.</p>

    <p class="text-gray-300"><span id="page-8-1"></span>design in either dimension: Each recursive aggregation layer incurs an O(log r) communication overhead, where r is the total number of aggregators. This overhead arises because aggregating bitfields with overlapping signers requires each aggregator to track multiplicities, i.e. the number of times each signature appears across overlapping bitfields. If r aggregators combine their bitfields then log(r) bits are necessary to indicate the multiplicity for each signer. BLS aggregate verification is dominated by the computation of the aggregate public key. This is done through a multi-scalar multiplication (MSM) between the multiplicities and the list of public keys. For n signers the MSM has length n and log(r)-bit scalars. For n = 2 million and r = 16 the verification time of a BLS aggregate signature, is 0.7 seconds (See Table <a href="#page-37-0">6\\)</a>. Every validator incurs this cost before checking the correctness of a consensus proposal and moving on to the next block.</p>

    <p class="text-gray-300">Additionally, transmitting these multiplicity lists introduces a k · log r multiplicative factor communication costs, where k is the number of aggregation layers. Even with a single layer of recursion and r = 16, the multiplicities have a 1 MB representation. For 4 million validators, 4 levels of recursion and r = 32, the multiplicities require 10MB to represent. Today, the average Ethereum block is less than 1MB, and is published every 12 seconds. This demonstrates how even the constant factor overhead of aggregate BLS can become a significant bottleneck in consensus.</p>

    <p class="text-gray-300"><span id="page-8-0"></span>Signature aggregation using PCD. Our work examines the use of distributed verifiable computing for signature aggregation, leveraging its expressiveness to union bitfields directly within the proof. Unlike BLS, which requires multiplicities, SNARKs enable a compact bitfield to represent validator participation, reducing communication overhead. Effectively, the PCD proves that the signature was correctly aggregated and that the bitfields were correctly unioned. This approach offers a more bandwidth-efficient solution for accountable voting in P2P protocols with a large number of participants.</p>

    <p class="text-gray-300">We make theoretical and systems contributions that advance the state of the art for distributed proving:</p>

    <p class="text-gray-300">KZH polynomial commitment scheme. In Section <a href="#page-17-1">4,</a> we introduce KZH, a multilinear polynomial commitment scheme that has sublinear verification, sublinear proof size, and efficient opening proof generation, and the commitment consists of a single group element. KZH takes advantage of small witness size, e.g. to commit and open, the prover commits to small field elements.</p>

    <p class="text-gray-300">KZH-fold accumulation scheme. In Section <a href="#page-20-0">4.1,</a> we design KZH-fold, an accumulation scheme for the previously designed KZH polynomial commitment scheme. KZH-fold is an accumulation scheme in which the verifier has a constant number of group operations while the accumulator size and decider time are sublinear in the size of the original statement (polynomial degree). In Appendix <a href="#page-53-0">C</a> we generalize KZH and KZH-fold to polynomial commitments of dimension k.</p>

    <p class="text-gray-300">First efficient non-uniform PCD scheme. Orthogonal to KZH-fold and building on the BCLMS compiler, we design Spartan+PA an IVC/PCD scheme for R1CS, built generically upon a polynomial accumulation scheme PA. Spartan+KZH-fold is an IVC (PCD) scheme with a sublinear proof size and decider, as described in Section <a href="#page-24-0">5.</a> In Section <a href="#page-27-0">5.3,</a> we propose new approaches to non-uniform IVC (N-IVC) [\\[KS22\\]](#page-41-12) and non-uniform PCD (N-PCD) [\\[Zhe+23\\]](#page-42-0) respectively. Both schemes are generic over a PCS accumulation scheme. Our N-PCD, is the first efficient N-PCD scheme, in the sense that the prover's cost per step is sublinear in the combined size of all instructions, and the decider requires a sublinear number of group operations in the combined size of all instructions.</p>

    <p class="text-gray-300">Signature aggregation protocol. We design and optimize an accountable signature aggregation protocol in Section <a href="#page-30-0">6,</a> using our IVC scheme, Spartan+KZH-fold. The protocol supports unlimited aggregations with optimal communication and verification time. The communication is dominated by a bitvector indicating the signers. The verification is dominated by just one field multiplication per signer.</p>

    <p class="text-gray-300">Implementation and evaluation. We implement<a href="#page-9-0">e</a> and evaluate Spartan+KZH2-fold and Spartan+KZH3-fold and compare it against Nova in Section <a href="#page-33-0">7.</a> Spartan+KZH3-fold at the expense of only 3x prover cost, achieves a 2000x reduction in communication overhead and a 50x slimmer verifier time. We also implement our accountable voting protocol using Spartan+KZH3-fold, demonstrating its effectiveness and practical applicability. For four</p>

    <p class="text-gray-300"><span id="page-9-0"></span>e <a href="https://github.com/h-hafezi/kzh_fold">https://github.com/h-hafezi/kzh\\\\_fold</a></p>

    <p class="text-gray-300">million signatures, our scheme reduces the communication cost by more than 10x and the verifier time by 4x compared to an accountable voting protocol using BLS signatures.</p>

    <p class="text-gray-300">Accumulation. The Halo protocol [\\[BGH19\\]](#page-42-1) was the first accumulation protocol; it has a succinct accumulator of O(log n) size and an accumulation verifier with O(log n) group operations, but the decider runs in time O(n). In contrast, KZH-fold only has a constantsize accumulation verifier, as well as an accumulator and decider of size O(k · n <sup>k</sup> ).</p>

    <p class="text-gray-300">Distributed proving. Most prior works on distributed zkSNARKs <a href="#page-42-2">\\[Wu+18;</a> <a href="#page-42-3">Liu+23;</a> <a href="#page-42-4">Ros+24;</a> [Wan+24\\]](#page-42-5) rely on a coordinator that receives the circuit C, the public input x, and the witness w, then distributes these to worker nodes and aggregates their outputs into a single proof. This centralized approach introduces a significant vulnerability: the coordinator represents a single point of failure and carries substantial responsibility, making it unsuitable for fully decentralized systems. Another limitation is that aggregated proofs cannot be further aggregated. An alternative approach involves using proof-carrying data (PCD) [\\[CT10\\]](#page-39-0), where each node performs a portion of the computation, and these partial proofs are aggregated (accumulated) hierarchically in a tree-like structure. However, decentralized PCD requires each aggregator to verify the validity of incoming partial proofs using a decider, which cannot trust other nodes by default. In previous schemes, this verification step was a bottleneck because the decider's complexity is linear with respect to the original statement. Additionally, the witness size also grows linearly with the statement, leading to substantial peer-to-peer (P2P) communication overhead. Spartan+KZH-k fold addresses these issues by reducing both communication complexity and witness size to O(k · n <sup>k</sup> ), significantly enhancing the efficiency and scalability of decentralized proving systems.</p>

    <p class="text-gray-300">Signature aggregation. Several works have studied signature aggregation for consensus. Handel shows how to build aggregation structures, in the face of adversarial corruptions [\\[Bé+19\\]](#page-42-6). Their work is largely orthogonal and should be compatible with arbitrary aggregate signature schemes. <a href="#page-42-7">\\[Kha+21;</a> [Aar+24\\]](#page-42-8) provide aggregation schemes for hash and lattice-based signature schemes, respectively. However, their constructions only support one level of aggregation, whereas our construction is focused on aggregating already aggregated signatures.</p>

    <p class="text-gray-300">Overview of Hyrax. At the core of our construction is KZH, a multilinear polynomial commitment scheme, combining ideas from the Hyrax polynomial commitment [\\[Wah+18\\]](#page-42-9) and KZG [\\[KZG10\\]](#page-39-10). Similar to Hyrax, we are building a commitment for a matrix M ∈  <span class="math">\\mathbb{F}^{m \\times n}</span> , such that we can open a bilinear vector matrix-vector product, for vectors  <span class="math">\\vec{a} \\in \\mathbb{F}^m</span>  and  <span class="math">\\vec{b} \\in \\mathbb{F}^n</span> , i.e. prove that  <span class="math">y = \\vec{a}^T \\times M \\times \\vec{b}</span> . This is general enough to construct both univariate and multilinear polynomial commitments, i.e.  <span class="math">\\vec{a}</span>  and  <span class="math">\\vec{b}</span>  are extensions of the evaluation point.</p>

    <p class="text-gray-300">In Hyrax, each row of M is committed using a Pedersen commitment [Ped92]. The resulting commitment vector,  <span class="math">\\vec{\\mathsf{D}} = [\\mathsf{D}_1, \\dots, \\mathsf{D}_m] \\in \\mathbb{G}^m</span> , consists of m group elements, with each element corresponding to a row of M. Due to the homomorphic properties of the commitment scheme, the verifier can validate an opening efficiently. To verify, the verifier first computes  <span class="math">\\mathsf{C} = \\langle \\vec{a}, \\vec{\\mathsf{D}} \\rangle</span> . The prover then opens  <span class="math">\\mathsf{C}</span>  to a vector  <span class="math">\\vec{r} \\in \\mathbb{F}^n</span>  and claims  <span class="math">y = \\langle \\vec{r}, \\vec{b} \\rangle</span> . The verifier checks two conditions:  <span class="math">\\mathsf{C} = \\mathsf{Commit}(\\vec{r})</span> , and  <span class="math">y = \\langle \\vec{r}, \\vec{b} \\rangle</span> . These checks involve two inner products, one of size n and the other of size m. For a matrix with  <span class="math">\\ell</span>  entries, setting  <span class="math">n = m = \\ell^{\\frac{1}{2}}</span>  yields a verification time of  <span class="math">O(\\ell^{\\frac{1}{2}})</span> .</p>

    <p class="text-gray-300">Moreover, efficient accumulation schemes for inner products are known [Bün+21; BC23], suggesting that it may be feasible to construct an accumulation scheme for Hyrax. However, Hyrax has a significant limitation: its commitment consists of m group elements, and while the commitment is homomorphic, performing homomorphic operations requires m group additions. The primary method for constructing accumulation schemes relies on homomorphically combining commitments. In the case of Hyrax, this approach leads to an accumulation verifier with size  <span class="math">O(m) = O(\\ell^{\\frac{1}{2}})</span> , which is notably larger than the constant-size accumulation verifiers achievable with other group-based constructions.</p>

    <p class="text-gray-300">Our key insight is that we can modify Hyrax, such that the commitment only consists of a single group element, and the homomorphism can be performed efficiently, using only a single group addition. A strawman approach here, would be to commit to  <span class="math">\\vec{\\mathsf{D}} \\in \\mathbb{G}^m</span>  using a structure-preserving commitment to group elements [Abe+16]. While these commitments, preserve the homomorphism, the commitment to a vector of group elements will be a target group element in a pairing-based group. Target group operations are significantly more expensive, especially when implemented as an arithmetic circuit. A single target group scalar multiplication takes tens of thousands of R1CS constraints.</p>

    <p class="text-gray-300">KZH polynomial commitment scheme. We aim to design a commitment scheme where the homomorphism only requires a single  <span class="math">\\mathbb{G}_1</span>  operation, in a pairing-friendly group. To do this, we utilize a common reference string, similar to KZG. Let  <span class="math">\\vec{\\mathsf{G}} = (\\mathsf{G}_1, \\ldots, \\mathsf{G}_n)</span>  be the generators for the Pedersen commitment. We now construct  <span class="math">\\vec{\\mathsf{H}}^{(i)} = \\tau^{(i)} \\times \\vec{\\mathsf{G}}</span> , for each  <span class="math">i \\in [m]</span>  and a secret trapdoor  <span class="math">\\tau^{(i)}</span> . We first commit to the matrix M by computing the commitment  <span class="math">\\mathsf{C} = \\sum_{i \\in [m], j \\in [n]} M_{i,j} \\times \\mathsf{H}^{(i)}_j</span> , where  <span class="math">\\mathsf{C} \\in \\mathbb{G}_1</span>  is a single group element. Next, we compute commitments to each individual row of the matrix using the vector  <span class="math">\\vec{\\mathsf{G}}</span> , where each row commitment is given by  <span class="math">\\mathsf{D}_i = \\sum_j M_{i,j} \\times \\mathsf{G}_j</span> . During the opening phase, the prover sends  <span class="math">[\\mathsf{D}_i]_{i=1}^m</span> , and the verifier ensures consistency between the  <span class="math">\\mathsf{D}_i</span> s commitments and  <span class="math">\\mathsf{C}</span>  using a pairing-based check. Specifically, a generator  <span class="math">\\mathsf{V} \\in \\mathbb{G}_2</span>  is sampled, and the verifier is given  <span class="math">\\mathsf{V}_i = \\tau^{(i)} \\times \\mathsf{V}</span>  for all  <span class="math">i \\in [m]</span> . The correctness of the decomposition is verified</p>

    <p class="text-gray-300">by checking the equality  <span class="math">e(C, V) = \\sum_{i=1}^{m} e(D_i, V_i)</span> . Here,  <span class="math">[D_i]_{i=1}^{m}</span>  corresponds exactly to the Hyrax commitment, allowing us to reuse Hyrax's opening algorithm with the added decomposition check. Furthermore, C is a homomorphic commitment to both the  <span class="math">D_i</span>  values and the matrix M, represented compactly as a single element in  <span class="math">\\mathbb{G}_1</span> .</p>

    <p class="text-gray-300">KZH-fold, a sublinear accumulation scheme for KZH. Next, we leverage the Protostar [BC23] compiler to design an efficient accumulation scheme for KZH, referred to as KZH-fold. The verifier's structure in KZH enables a highly efficient scheme. Specifically, the Hyrax checks, namely multi-scalar multiplications (MSMs), can be efficiently accumulated using existing techniques. Additionally, the KZH verifier validates a pairing product:  <span class="math">e(C, V) = \\sum_{i=1}^{m} e(D_i, V_i)</span> . Notably, one side of all pairings remains fixed. When combining two equations, we derive:  <span class="math">e(C+X\\times C&#x27;, V) = \\sum_{i=1}^{m} e(D_i+X\\times D&#x27;_i, V_i)</span> , with an overwhelming probability for a random  <span class="math">X \\in \\mathbb{F}</span> , if and only if the pairing check holds for both  <span class="math">(C, [D_i]_{i=1}^m)</span>  and  <span class="math">(C&#x27;, [D&#x27;_i]_{i=1}^m)</span> . The linearity of this check ensures no additional error terms (which would belong to the target group  <span class="math">\\mathbb{G}_T</span> ) are introduced. The final accumulation verifier thus performs only 3  <span class="math">\\mathbb{G}_1</span>  scalar multiplications when combining an accumulator with a fresh proof, or 4 scalar multiplications when accumulating two accumulators. The accumulator size matches the size of PCS proof, i.e.  <span class="math">O(\\ell^{\\frac{1}{2}})</span> . The decider - equivalent to the PCS verifier - is dominated by  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  pairings.</p>

    <p class="text-gray-300">KZH-k, generalization of KZH to achieve smaller proofs. We generalize KZH to KZH-k, to further improve the proof size and verifier efficiency, which yields KZH-k fold, an accumulation scheme with a smaller accumulator and more efficient decider. The key insight is that instead of committing to a two-dimensional matrix, we can commit to a k-dimensional tensor. The matrix vector-matrix product turns into a k-dimensional tensor product, between the tensor and k matrices of size  <span class="math">n^{\\frac{1}{k}}</span> . We first commit to the entire tensor using a structured reference string. Then we use the same technique to open commitments to all k-1 dimensional slices of the tensor. If the full tensor has n entries, then there are  <span class="math">n^{\\frac{1}{k}}</span> such slices. We use a pairing check and the reference string to check the consistency between the slices and the full commitment. Then we can evaluate the slices homomorphically with the first of k vectors. This yields a single k-1 dimensional commitment. At this point, we proceed recursively, until we reach a one-dimensional vector that can be opened in  <span class="math">O(n^{\\frac{1}{k}})</span> . Since each dimension consists of  <span class="math">n^{\\frac{1}{k}}</span>  slices, and there are k slices, the overall proof size and verification time is  <span class="math">O(k \\cdot n^{\\frac{1}{k}})</span> . The resulting accumulation verifier increases slightly to k+1 <span class="math">\\mathbb{G}_1</span>  scalar multiplication.</p>

    <p class="text-gray-300">Accumulation scheme for NP from polynomial accumulation. To go from accumulation of polynomials to accumulation for all of NP, we leverage the Spartan PIOP for R1CS. Spartan translates an R1CS instance into a number of polynomial checks. Accumulating Spartan checks requires accumulating a witness polynomial evaluation plus three</p>

    <p class="text-gray-300">multilinear extensions of the R1CS matrices A, B and C. Accumulation of witness polynomial can happen with any PA including KZH-fold and we observe that evaluations of multilinear extensions of the R1CS matrices can be efficiently accumulated, requiring only a logarithmic number of additional field operations for the accumulation verifier and prover. We highlight that this approach works with any other PIOP based on multilinear polynomials such as HyperPlonk [Che+23] and CCS [STW23], but we leave its details to future work.</p>

    <p class="text-gray-300">Distributed signature aggregation via PCD. To build a signature aggregation based on IVC/PCD, communication size is crucial in such a P2P setting. We use Spartan+KZHfold with sublinear proofs to construct an aggregate accountable signature scheme. The IVC aggregates the public key signatures and signer bitfields of a BLS accountable aggregate signature. The key challenge is ensuring accountability by proving that the output bitfield is equivalent to the or of the input bitfields. Let  <span class="math">\\vec{b}^{(1)}, \\vec{b}^{(2)}</span>  and  <span class="math">\\vec{c}</span>  be three bitfields such that  <span class="math">\\vec{c} = \\vec{b}^{(1)} \\vee \\vec{b}^{(2)}</span> . Naively putting this statement into the circuit would make the IVC circuit linear in the number of signers and possibly increase the verification cost. Instead at each aggregation step, we define multilinear extensions of these vectors  <span class="math">\\tilde{b}_1(\\vec{X}), \\tilde{b}_2(\\vec{X}), \\text{ and } c(\\vec{X})</span> and commit to them using a multilinear polynomial commitment. In order to prove that  <span class="math">\\vec{c} = \\vec{b}^{(1)} \\vee \\vec{b}^{(2)}</span> , we can show that  <span class="math">\\tilde{b}_1(\\vec{x}) + \\tilde{b}_2(\\vec{x}) - \\tilde{b}_1(\\vec{x}) \\cdot \\tilde{b}_2(x) = \\tilde{c}(\\vec{x}) \\, \\forall \\vec{x} \\in \\{0,1\\}^{\\mu}</span> . This is a zerocheck and can be proven using a simple sumcheck protocol as in HyperPlonk [Che+23]. The sumcheck requires evaluating the polynomial commitments to  <span class="math">b_1, b_2, \\tilde{c}</span>  at a random point. We can instantiate the PCS with KZH and accumulate the opening proofs as part of the IVC. One important consideration is that we are committing to a boolean vector of size millions. Therefore, for efficiency reasons, it is crucial to leverage a PCS such as KZH that takes advantage of the small size of the witness elements for both opening and committing. We detail the scheme and further optimizations in Section 6.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.1 Notation</h4>

    <p class="text-gray-300">Let  <span class="math">\\mathbb{F}</span>  be a finite field and  <span class="math">\\mathbb{G}</span>  a group with scalars in  <span class="math">\\mathbb{F}</span> , with additive notation. For  <span class="math">a \\in \\mathbb{F}</span>  and  <span class="math">G \\in \\mathbb{G}</span> , the scalar multiplication of G by a is denoted as  <span class="math">a \\times G</span> . For an asymmetric pairing group, we define it as a tuple  <span class="math">(p, g_1, g_2, \\mathbb{G}_1, \\mathbb{G}_2, \\mathbb{G}_T, e)</span> , where p is the order of groups  <span class="math">\\mathbb{G}_1</span>  and  <span class="math">\\mathbb{G}_2</span> , and e is an efficiently computable, non-degenerate bilinear map. Let GGen be a deterministic polynomial-time algorithm that takes as input a security parameter  <span class="math">\\lambda</span>  and outputs a such a group description. A function f(x) is negligible if, for any polynomial p(x), there exists a positive integer N such that for all x > N, we have  <span class="math">f(x) &lt; \\frac{1}{p(x)}</span> . When we say an event happens with overwhelming probability, we mean it occurs with a probability of  <span class="math">1 - \\epsilon(\\lambda)</span> , where  <span class="math">\\epsilon(\\lambda)</span>  is a negligible function. We use  <span class="math">\\langle \\vec{a}, \\vec{b} \\rangle</span>  to denote the inner product between two vectors  <span class="math">\\vec{a}, \\vec{b} \\in \\mathbb{F}^n</span> , and extend this notation for  <span class="math">\\vec{a} \\in \\mathbb{F}^n</span>  and  <span class="math">\\vec{G} \\in \\mathbb{G}^n</span></p>

    <p class="text-gray-300">as  <span class="math">\\langle \\vec{a}, \\vec{\\mathsf{G}} \\rangle = \\sum_{i=1}^{n} a_i \\times \\mathsf{G}_i</span> . Additionally, we use  <span class="math">\\mathsf{MLP}(\\mathbb{F}, d)</span>  to denote the set of multilinear polynomials with d variables over the field  <span class="math">\\mathbb{F}</span> , which we abbreviate as  <span class="math">\\mathsf{MLP}(d)</span>  when  <span class="math">\\mathbb{F}</span>  is understood from the context. Any polynomial in  <span class="math">\\mathsf{MLP}(\\mathbb{F}, d)</span>  can be expressed as:</p>

    <div class="my-4 text-center"><span class="math-block">P(X_1, X_2, \\dots, X_d) = \\sum_{S \\subseteq [d]} c_S \\prod_{i \\in S} X_i, \\text{ where } c_S \\in \\mathbb{F}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Here, the sum is taken over all subsets S of the index set  <span class="math">[d] = \\{1, 2, ..., d\\}</span> , and  <span class="math">c_S</span>  are coefficients from  <span class="math">\\mathbb{F}</span> . Operator  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  represents concatenation, e.g.  </span>\\vec{x} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{y}<span class="math">  is the concatenation of vectors  </span>\\vec{x}<span class="math">  and  </span>\\vec{y}<span class="math"> . To indicate equality on vectors, we define  </span>\\operatorname{eq}(\\vec{X}, \\vec{Y})<span class="math">  as  </span>\\operatorname{eq}(\\vec{X}, \\vec{Y}) = \\prod_{i=1}^k \\left( (1-X_i) \\cdot (1-Y_i) + X_i \\cdot Y_i \\right)<span class="math"> , so that for  </span>\\vec{x}, \\vec{y} \\in \\{0,1\\}^k<span class="math"> ,  </span>\\operatorname{eq}(\\vec{x}, \\vec{y}) = 1<span class="math">  if and only if  </span>\\vec{x} = \\vec{y}<span class="math"> . We denote a complete binary tree of depth n with node values in  </span>\\mathbb{F}<span class="math">  as  </span>\\mathcal{T}(\\mathbb{F}, n)<span class="math"> . For brevity, we will refer to complete binary trees simply as trees. Given a vector  </span>\\vec{x} \\in \\mathbb{F}^k<span class="math"> , the equality tree  </span>\\operatorname{EqTree}(\\vec{x})<span class="math">  is a tree of depth k. The root node is initialized with 1. At depth i, the left child of a node v is  </span>v \\cdot (1-x_i)<span class="math"> , and the right child is  </span>v \\cdot x_i<span class="math"> . The leaves of the tree correspond to the equality function  </span>\\operatorname{eq}(\\vec{x}, \\vec{y})<span class="math">  for all  </span>\\vec{y} \\in \\{0,1\\}^k<span class="math"> . For any tree  </span>\\mathcal{T}<span class="math"> , we denote the set of its leaf nodes by  </span>\\mathcal{T}$ .leaves.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Cryptographic Assumptions.</strong> We prove security of our protocols in the Algebraic Group Model (AGM) of Fuchsbauer et al. [FKL18], using the <em>bilinear</em> version of the q-dlog assumption and quadratic CDH. In the AGM, adversaries are restricted to be <em>algebraic</em> algorithms, namely, whenever  <span class="math">\\mathcal{A}</span>  outputs a group element [y] in a cyclic group  <span class="math">\\mathbb{G}</span>  of order p, it also outputs its representation as a linear combination of all previously received group elements. In other words, if  <span class="math">[y] \\leftarrow \\mathcal{A}([x_1], \\ldots, [x_m])</span> ,  <span class="math">\\mathcal{A}</span>  must also provide  <span class="math">\\vec{z}</span>  such that  <span class="math">[y] = \\sum_{j=1}^m z_j[x_j]</span> . This definition generalizes naturally in asymmetric bilinear groups with a pairing  <span class="math">e: \\mathbb{G}_1 \\times \\mathbb{G}_2 \\to \\mathbb{G}_T</span> , where for  <span class="math">i \\in 1, 2</span> , the adversary must construct  <span class="math">\\mathbb{G}_i</span>  elements as linear combinations of received  <span class="math">\\mathbb{G}_i</span>  elements.</p>

    <p class="text-gray-300">We denote a random oracle using H that we assume is randomly sampled from the random oracle space  <span class="math">\\mathcal{H}</span>  and initialize it in practice using a secure hash function.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">3.2 Polynomial commitment schemes</h4>

    <p class="text-gray-300"><span id="page-14-1"></span><strong>Definition 1.</strong> [Multilinear Polynomial Commitment Scheme] A Multilinear Polynomial Commitment Scheme is a tuple of algorithms (Setup<sub>PC</sub>, Commit<sub>PC</sub>, Open<sub>PC</sub>, Verify<sub>PC</sub>) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>srs<sub>PC</sub> ← Setup<sub>PC</sub>(pp<sub>PC</sub>, k): On input the system parameters and number of variables k, it outputs a structured reference string.</li>

      <li>C  <span class="math">\\leftarrow</span>  Commit<sub>PC</sub>(srs<sub>PC</sub>,  <span class="math">p(\\vec{X})</span> ): On input srs<sub>PC</sub> and a polynomial  <span class="math">p(\\vec{X}) \\in MLP(\\mathbb{F}, k)</span> , it outputs a commitment C.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{PC} \\leftarrow \\mathsf{Open}_{PC}\\big(\\mathsf{srs}_{PC}, p(\\vec{X}), \\vec{x}\\big)</span> : On input  <span class="math">\\mathsf{srs}_{PC}, p(\\vec{X}), k</span> , and vector  <span class="math">\\vec{x} \\in \\mathbb{F}^k</span> , outputs an evaluation proof  <span class="math">\\pi_{PC}</span>  that  <span class="math">y = p(\\vec{x})</span> .</li>

      <li><span class="math">1/0 \\leftarrow \\text{Verify}_{PC}(\\text{srs}_{PC}, C, \\vec{x}, \\pi_{PC}, y)</span> : On input  <span class="math">\\text{srs}_{PC}</span> , the commitment C, k, vector of evaluations  <span class="math">\\vec{x}, y \\in \\mathbb{F}</span> , and the proof of the correct evaluation, it outputs a bit indicating acceptance or rejection.</li>

    </ul>

    <p class="text-gray-300">and satisfies the following properties:</p>

    <p class="text-gray-300"><strong>Completeness.</strong> It captures the fact that an honest prover will always convince the verifier. Formally, for any efficient adversary A, we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left[\\begin{array}{c} \\mathsf{Verify}_{\\mathsf{PC}}\\big(\\mathsf{srs}_{\\mathsf{PC}},\\mathsf{C},\\vec{x},\\pi_{\\mathsf{PC}},y\\big) = 1 &amp; \\begin{vmatrix} \\mathsf{srs}_{\\mathsf{PC}} \\leftarrow \\mathsf{Setup}_{\\mathsf{PC}}\\big(\\mathsf{pp}_{\\mathsf{PC}},k\\big) \\\\ p(\\vec{X}) \\leftarrow \\mathcal{A}(\\mathsf{srs}_{\\mathsf{PC}}) \\\\ \\mathsf{C} \\leftarrow \\mathsf{Commit}\\big(\\mathsf{srs}_{\\mathsf{PC}},p(\\vec{X})\\big) \\\\ \\pi_{\\mathsf{PC}} \\leftarrow \\mathsf{Open}\\big(\\mathsf{srs}_{\\mathsf{PC}},p(\\vec{X}),\\vec{x}\\big) \\end{vmatrix} = 1 \\right]</span></div>

    <p class="text-gray-300"><strong>Extractability:</strong> Captures the fact that whenever the prover provides a valid opening, it knows a valid pair  <span class="math">(p(\\vec{X}), y) \\in \\mathbb{F}[\\vec{X}] \\times \\mathbb{F}</span> , where  <span class="math">p(\\vec{x}) = y</span> . Formally, for all PPT adversaries  <span class="math">\\mathcal{A}</span>  there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that the probability of the following event is negligible:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c} \\mathsf{Verify}_{\\mathsf{PC}}\\big(\\mathsf{srs}_{\\mathsf{PC}},\\mathsf{C},\\vec{x},y,\\pi_{\\mathsf{PC}}\\big) = 1 \\\\ \\wedge p(\\vec{x}) \\neq y \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{srs}_{\\mathsf{PC}} \\leftarrow \\mathsf{Setup}_{\\mathsf{PC}}\\big(\\mathsf{pp}_{\\mathsf{PC}},k\\big) \\\\ \\mathsf{C} \\leftarrow \\mathcal{A}\\big(\\mathsf{srs}_{\\mathsf{PC}}\\big) \\\\ p(\\vec{X}) \\leftarrow \\mathcal{E}\\big(\\mathsf{srs}_{\\mathsf{PC}},\\mathsf{C},k\\big) \\\\ \\vec{x} \\leftarrow \\mathcal{A}\\big(\\mathsf{srs}_{\\mathsf{PC}},\\mathsf{C}\\big) \\\\ (y,\\pi_{\\mathsf{PC}}) \\leftarrow \\mathcal{A}\\big(\\mathsf{srs}_{\\mathsf{PC}},p(\\vec{X}),\\vec{x}\\big) \\end{array}\\right]$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">3.3 Accumulators</h4>

    <p class="text-gray-300"><span id="page-15-1"></span><strong>Definition 2.</strong> [Accumulation Scheme] An accumulation scheme [Bün+21; BC23] for a predicate  <span class="math">\\phi: X \\to \\{0,1\\}</span>  is a tuple of algorithms  <span class="math">\\Pi_{\\mathsf{acc}} = (\\mathsf{Setup}_{\\mathsf{acc}}, \\mathsf{P}_{\\mathsf{acc}}, \\mathsf{V}_{\\mathsf{acc}}, \\mathsf{D}_{\\mathsf{acc}})</span> , all of which have access to the same random oracle  <span class="math">\\mathcal{O}_{\\mathsf{acc}}</span> , such that:</p>

    <p class="text-gray-300"> <span class="math">\\begin{aligned} \\mathsf{Setup}_{\\mathsf{acc}}(1^\\lambda) \\to \\mathsf{srs}_{\\mathsf{acc}}: \\ On \\ input \\ the \\ security \\ parameter, \\ outputs \\ public \\ parameters \\ \\mathsf{srs}_{\\mathsf{acc}}. \\\\ For \\ simplicity, \\ we \\ assume \\ that \\ all \\ functions \\ implicitly \\ take \\ \\mathsf{srs}_{\\mathsf{acc}} \\ as \\ input. \\end{aligned}</span></p>

    <p class="text-gray-300"> <span class="math">\\mathsf{P}_{\\mathsf{acc}}(\\mathsf{st},\\pi,\\mathsf{acc}_1) \\to (\\mathsf{acc},\\mathsf{pf})</span> : The accumulation prover implicitly given  <span class="math">\\mathsf{srs}_{\\mathsf{acc}}</span> , statement  <span class="math">\\mathsf{st}</span> , predicate inputs  <span class="math">\\pi = (\\pi.x,\\pi.w)</span> , and an accumulator  <span class="math">\\mathsf{acc}_1 = (\\mathsf{acc}_1.x,\\mathsf{acc}_1.w)</span> , outputs a new accumulator  <span class="math">\\mathsf{acc}</span>  and corrections terms  <span class="math">\\mathsf{pf}</span> .</p>

    <p class="text-gray-300"> <span class="math">V_{acc}(acc_1.x,acc_2.x,pf) \\rightarrow acc.x</span> : The accumulation verifier implicitly given  <span class="math">srs_{acc}</span> , and on input the instances of two accumulators, and the accumulation proof outputs a new accumulator instance acc.x.</p>

    <p class="text-gray-300"> <span class="math">D_{acc}(acc) \\rightarrow 1/0</span> : The decider takes as input acc and accepts or rejects. and satisfies completeness and soundness as defined below:</p>

    <p class="text-gray-300">Completeness. For all fresh proofs  <span class="math">\\pi</span>  such that  <span class="math">\\phi(\\pi) = 1</span>  and accumulator acc such that  <span class="math">\\mathsf{D}_{\\mathsf{acc}}(\\mathsf{acc}) = 1</span> , the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{V}_{\\mathsf{acc}}\\big(\\mathsf{acc}_1.x,\\mathsf{acc}_2.x,\\mathsf{pf}\\big) = \\mathsf{acc}.x & \\mathsf{srs} \\leftarrow \\mathsf{Setup}(1^\\lambda) \\\\ \\land \\mathsf{D}_{\\mathsf{acc}}\\big(\\mathsf{acc}\\big) = 1 & \\mathsf{(acc},\\mathsf{pf}\\big) \\leftarrow \\mathsf{P}_{\\mathsf{acc}}\\big(\\mathsf{st},\\pi,\\mathsf{acc}_1\\big) \\end{array}\\right] = 1$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Knowledge-soundness.</strong> For every PT adversary A, there exists a polynomial-time extractor Ext such that the following probability is negligible:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} (D_{\\mathsf{acc}}(\\mathsf{acc}_1) \\neq 1 \\lor \\ D_{\\mathsf{acc}}(\\mathsf{acc}_2) \\neq 1) \\ \\land \\\\ \\mathsf{V}_{\\mathsf{acc}}\\big(\\mathsf{srs}, \\mathsf{acc}_1.x, \\mathsf{acc}_2.x, \\mathsf{pf}\\big) = \\mathsf{acc}.x \\\\ \\land \\ \\mathsf{D}_{\\mathsf{acc}}\\big(\\mathsf{acc}\\big) = 1 \\end{array} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{srs} \\leftarrow \\mathsf{Setup}(1^\\lambda) \\\\ (\\mathsf{acc}, \\mathsf{acc}_1.x, \\mathsf{acc}_2.x, \\mathsf{pf}) \\leftarrow \\mathcal{A}(\\mathsf{srs}) \\\\ (\\mathsf{acc}_1.w, \\mathsf{acc}_2.w) \\leftarrow \\mathsf{Ext}(\\mathsf{acc}, \\mathsf{acc}_1.x, \\mathsf{acc}_2.x, \\mathsf{pf}) \\end{array} \\right] = 1$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 3.</strong> (IVC) An IVC scheme is a tuple of efficient algorithms ( <span class="math">Setup_{IVC}, P_{IVC}, V_{IVC}</span> ) with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup<sub>IVC</sub> <span class="math">(\\lambda, S) \\to pp</span> : Given a security parameter  <span class="math">\\lambda</span> , a poly-size bound  <span class="math">S \\in \\mathbb{N}</span> , outputs public parameters pp.</li>

      <li><span class="math">\\mathsf{P}_{\\mathsf{IVC}}(\\mathsf{pp}, F, F.x_i, F.w_i, \\pi_i) \\to \\pi_{i+1}</span> : Given public parameters  <span class="math">\\mathsf{pp}</span> , a function  <span class="math">F: \\{0,1\\}^a \\times \\{0,1\\}^b \\to \\{0,1\\}^a</span>  computable by a circuit of size at most S, an initial state and claimed output  <span class="math">F.x_i \\in \\{0,1\\}^a</span> , advice  <span class="math">F.w_i \\in \\{0,1\\}^b</span> , and an IVC proof  <span class="math">\\pi_i</span> , outputs a new IVC proof  <span class="math">\\pi_{i+1}</span> .</li>

      <li><span class="math">V_{IVC}(pp, F, F.x_i, \\pi_i) \\rightarrow 0/1</span> : Given public parameters pp, a function F, a claimed output  <span class="math">F.x_i</span> , and an IVC proof  <span class="math">\\pi_i</span> , outputs 0 (reject) or 1 (accept).</li>

    </ul>

    <p class="text-gray-300">An IVC scheme satisfies the following properties:</p>

    <p class="text-gray-300">Completeness. For every poly-size bound  <span class="math">S \\in \\mathbb{N}</span> , pp in the output space of  <span class="math">\\mathsf{Setup}_{\\mathsf{IVC}}(\\lambda, S)</span> , function  <span class="math">F : \\{0,1\\}^a \\times \\{0,1\\}^b \\to \\{0,1\\}^a</span>  computable by a circuit within bound S, collection of elements  <span class="math">F.x_i \\in \\{0,1\\}^a</span> ,  <span class="math">F.w_i \\in \\{0,1\\}^b</span>  and IVC proof  <span class="math">\\pi_i</span> , the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{V}_{\\mathsf{IVC}}(\\mathsf{pp}, F, F.x_i, \\pi_i) = 1 \\\\ \\Downarrow \\\\ \\mathsf{V}_{\\mathsf{IVC}}(\\mathsf{pp}, F, F.x_{i+1}, \\pi_{i+1}) = 1 \\end{array} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\pi_{i+1} \\leftarrow \\mathsf{P}_{\\mathsf{IVC}}(\\mathsf{pp}, F, F.x_i, F.w_i, \\pi_i), \\\\ F.x_{i+1} \\leftarrow F(F.x_i, F.w_i) \\end{array} \\right] = 1$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Let  <span class="math">S \\in \\mathbb{N}</span>  be a poly-size bound and  <span class="math">\\ell(\\lambda)</span>  be a polynomial in the security parameter. Let  <span class="math">\\mathcal{F}</span>  be an efficient function sampling adversary that outputs a function  <span class="math">F: \\{0,1\\}^a \\times \\{0,1\\}^b \\to \\{0,1\\}^a</span>  computable by a circuit within the poly-size bound S. We say that an IVC scheme is knowledge sound if there exists an efficient extractor Ext such that for every efficient IVC prover  <span class="math">\\mathsf{P}^*_{\\mathsf{IVC}}</span>  the probability of the following event is greater than  <span class="math">1 - \\mathsf{negl}(\\lambda)</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{V}_{\\mathsf{IVC}}(\\mathsf{pp},F,F.x_i,\\pi_i) = 1 \\, \\wedge \\\\ F.x_i = F(F.x_{i-1},F.w_{i-1}) \\, \\wedge \\\\ (i = 1 \\implies F.x_{i-1} = F.x_0) \\, \\wedge \\\\ (i > 1 \\implies \\mathsf{V}_{\\mathsf{IVC}}(\\mathsf{pp},F,F.x_{i-1},\\pi_{i-1}) = 1) \\end{array}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{Setup}_{\\mathsf{IVC}}(\\lambda,S) \\\\ \\rho \\leftarrow \\{0,1\\}^{\\ell(\\lambda)} \\\\ F \\leftarrow \\mathcal{F}(\\mathsf{pp};\\rho) \\\\ (F.x_i,\\pi_i) \\leftarrow \\mathsf{P}^*_{\\mathsf{IVC}}(\\mathsf{pp},\\rho) \\\\ (F.x_{i-1},F.w_{i-1}),\\pi_{i-1} \\leftarrow \\mathsf{Ext}(\\mathsf{pp},\\rho) \\end{array}\\right]$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">3.5 IVC from accumulators</h3>

    <p class="text-gray-300"><span id="page-17-2"></span><strong>Theorem 1.</strong> Let NARK be a non-interactive argument that is (T-t)-predicate-efficient with respect to  <span class="math">\\Phi</span> . If  <span class="math">(\\Phi, \\mathsf{Setup}_{\\mathsf{NARK}})</span>  has an accumulation scheme  <span class="math">\\mathsf{acc}_{\\Phi}</span>  then NARK has an accumulation scheme  <span class="math">\\mathsf{acc}_{\\mathsf{NARK}}</span>  with the efficiency properties below:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">P_{acc}</span>  runs in time  $\\sum_{i=1}^{n} T(N,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  plus the time taken to run  </span>P_{acc,\\Phi}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bullet</span>   <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  takes time equal to  <span class="math">\\mathsf{D}_{\\mathsf{acc},\\Phi}</span></li>

    </ul>

    <p class="text-gray-300"><span id="page-17-3"></span><strong>Theorem 2.</strong> There exists a polynomial time transformation T such that if NARK = (Setup<sub>NARK</sub>, P<sub>NARK</sub>, V<sub>NARK</sub>) is a NARK for circuit satisfiability and AS is an accumulation scheme for NARK, then IVC = (Setup<sub>IVC</sub>, P<sub>IVC</sub>, V<sub>IVC</sub>) = T(NARK, AS) is an IVC scheme for constant-depth compliance predicates, provided  <span class="math">\\exists \\epsilon \\in (0,1)</span>  and a polynomial  <span class="math">\\alpha</span>  s.t.  <span class="math">v^*(\\lambda, m, N, \\ell) = O(N^{1-\\epsilon}.\\alpha(\\lambda, m, \\ell))</span> . Moreover, if the size of the predicate  <span class="math">\\Phi : \\mathbb{F}^{(m+2)\\ell} \\to \\mathbb{F}</span>  is  <span class="math">f = \\omega(\\alpha(\\lambda, m, \\ell)^{1/\\epsilon})</span> , then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The cost of running  <span class="math">Setup_{IVC}</span>  is the cost of running  <span class="math">Setup_{NARK}</span>  and  <span class="math">Setup_{acc}</span>  on an index of size f + o(f).</li>

      <li>The cost of running  <span class="math">P_{IVC}</span>  is the cost of accumulating m instance-proof pairs using  <span class="math">P_{acc}</span> , and running  <span class="math">P_{NARK}</span>  on an index of size f + o(f) and instance of size o(f).</li>

      <li><span id="page-17-1"></span>• The cost of running  <span class="math">V_{IVC}</span>  is equal to the cost of running  <span class="math">V_{NARK}</span>  and  <span class="math">D_{acc}</span>  on an index of size f + o(f) and an instance of size o(f).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We present KZH in Figure 2. For a multilinear polynomial  <span class="math">f(\\vec{X})</span> , where  <span class="math">\\vec{X} \\in \\mathbb{F}^k</span> , which interpolates a vector in  <span class="math">\\mathbb{F}^{2^k}</span> , we set  $\\ell = 2^k =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . We can select any  </span>\\nu, \\mu<span class="math">  such that  </span>k = \\nu + \\mu$  and the following costs apply:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Committing to f costs  <span class="math">O(\\ell)</span>  group operations.</li>

      <li>Proof consists of  <span class="math">2^{\\nu}</span>   <span class="math">\\mathbb{G}_1</span>  elements and  <span class="math">2^{\\mu}</span>  field elements.</li>

      <li>Opening requires  <span class="math">2^{\\nu}</span>  field operations.</li>

      <li>Verifier requires  <span class="math">2^{\\nu}</span>  pairings, multi-exponentiations of size  <span class="math">2^{\\nu}+2^{\\mu}</span> , and  <span class="math">2^{\\mu}</span>  field operations.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We can set  <span class="math">\\nu = \\mu = \\frac{k}{2}</span>  so  <span class="math">2^{\\nu} = 2^{\\mu} = 2^{\\frac{k}{2}}</span> , or choose a trade-off between prover and verifier work based on convenience. For example, when the verifier workload or proof size is more critical, selecting a lower  <span class="math">\\nu</span>  results in fewer pairings and smaller proof size, but at the expense of more multi-exponentiations by the prover to open the commitment. The polynomial commitment scheme has two key properties: The opening proof can be precomputed during the commitment phase and is  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  in size. Secondly, it can be accumulated efficiently using only  <span class="math">\\mathbb{G}_1</span>  operation and has an  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  accumulator witness. More precisely, the prover commits to the multilinear commitment  <span class="math">f(\\vec{X}, \\vec{Y})</span>  with  <span class="math">\\vec{X} \\in \\mathbb{F}^{\\nu}</span>  and  <span class="math">\\vec{Y} \\in \\mathbb{F}^{\\mu}</span>  as a matrix of evaluation points. During the opening at point  <span class="math">(\\vec{x}_0, \\vec{y}_0)</span> , the prover decomposes the matrix into row commitments. The correctness of this decomposition can be checked using pairings. Intuitively, KZH is a proof of correct partial evaluation at point  <span class="math">X = \\vec{x}_0</span> . Once the verifier is convinced about the correctness of  <span class="math">f^<em>(\\vec{Y}) = f(\\vec{x}_0, \\vec{Y})</span> , it can evaluate  <span class="math">f^</em>(\\vec{Y})</span> at  <span class="math">y_0</span>  on its own. We can then use the technique from Hyrax to evaluate the bivariate commitment as a vector, matrix, or vector product. The technique extends to more variables as presented in Appendix C (which reduces the verification cost). KZH is not inherently hiding; however, by utilizing the general compiler described in [Bü+19] for homomorphic polynomial commitments, it can be transformed to achieve hiding. However, the general compiler requires committing to a fully random polynomial, which forces the prover to perform a linear-sized MSM during the opening phase. Recent work, IronDict [Haf+25], building on KZH, demonstrates that it suffices to use a sparse random polynomial with only  $\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  non-zero coefficients. They further generalize this result to  </span>k \\cdot \\sqrt[k]{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  for the KZH-k setting. In brief, IronDict builds a hiding version of KZH (zk-KZH) in which the opening remains sublinear and hence efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Below we state a theorem proving the security of KZH under the  <span class="math">\\mathcal{D}_n</span> -find-rep [DRZ20], for a distribution  <span class="math">\\mathcal{D}_n</span> . We instantiate  <span class="math">\\mathcal{D}_n</span>  with our setup Setup<sub>KZH</sub> algorithm. All the secret trapdoors in our setup appear up to m times in exponents of  <span class="math">\\mathbb{G}_1</span>  generators and once in the exponent of an  <span class="math">\\mathbb{G}_2</span>  generator. [DRZ20]'s proof suggests that this should be equivalent to the m, 1-dlog assumption [BFL20]. We leave this reduction as an open problem.</p>

    <p class="text-gray-300">SetupKZH(λ, k) :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose µ, ν such that k = 2ν+<sup>µ</sup>. Let n = 2<sup>ν</sup> and m = 2<sup>µ</sup> and define the boolean cubes as B<sup>n</sup> = {0, 1} <sup>ν</sup> and B<sup>m</sup> = {0, 1} µ.</li>

      <li>Sample {G (⃗i) <sup>←</sup>\\<span class="math"> &lt;sup&gt;G&lt;/sup&gt;1}⃗i∈B&lt;sup&gt;m&lt;/sup&gt; , V ←\\</span> G<sup>2</sup> and sample trapdoor {τ (⃗j)}⃗j∈B<sup>n</sup> , α ←\\$ F <a href="#page-0-0">f</a> .</li>

      <li>For ⃗i ∈ Bn, ⃗j ∈ Bm, define:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">- \\ \\mathsf{H}^{(\\vec{i},\\,\\vec{j})} \\leftarrow \\tau^{(\\vec{i})} \\times \\mathsf{G}^{(\\vec{j})}</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\ \\mathsf{H}^{(\\vec{j})} \\leftarrow \\alpha \\times \\mathsf{G}^{(\\vec{j})}</span></div>

    <div class="my-4 text-center"><span class="math-block">- \\mathsf{V}^{(\\vec{i})} \\leftarrow \\tau^{(\\vec{i})} \\times \\mathsf{V} \\in \\mathbb{G}_2</span></div>

    <div class="my-4 text-center"><span class="math-block">- V&#x27; \\leftarrow \\alpha \\times V</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let srs ← [G (⃗i) , H (⃗i,⃗j) , H (⃗j) , V ′ , V (⃗i) ]⃗i∈Bn,⃗j∈B<sup>m</sup> .</li>

      <li>Output srs.</li>

    </ul>

    <p class="text-gray-300">CommitKZH(srs, f(X, ⃗ Y⃗ )): For f ∈ MLP(ν + µ) and X⃗ ∈ F ν , Y⃗ ∈ F µ</p>

    <p class="text-gray-300">• Output <span class="math-block">\\mathsf{C} \\leftarrow \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}</span> .</p>

    <p class="text-gray-300">• Let <span class="math-block">\\mathsf{D}^{(\\vec{x})} \\leftarrow \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} \\ \\forall \\ \\vec{x} \\in B_n.</span></p>

    <p class="text-gray-300">• Output C and aux = {D (⃗x)}⃗x∈B<sup>n</sup> as cache.</p>

    <p class="text-gray-300">OpenKZH(srs, f(X, ⃗ Y⃗ ), ⃗x0, ⃗y0, aux):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let f ∗ (Y⃗ ) ← f( ⃗x0, Y⃗ ), f <sup>∗</sup> ∈ MLP(F, µ).</li>

      <li>Let z<sup>0</sup> ← f ∗ ( ⃗y0).</li>

      <li>Output π ← f ∗ (Y⃗ ), aux = {D (⃗x)}⃗x∈B<sup>n</sup> , z0.</li>

    </ul>

    <p class="text-gray-300">VerifyKZH(srs, C, ⃗x0, ⃗y0, π, z0): Accept if and only if all checks below pass:</p>

    <p class="text-gray-300">1. <span class="math-block">e(C, V&#x27;) = \\sum_{\\vec{x} \\in B_n} e(D^{(\\vec{x})}, V^{(\\vec{x})}),</span></p>

    <p class="text-gray-300">2. <span class="math-block">\\textstyle\\sum_{\\vec{y}\\in B_m} f^*(\\vec{y})\\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x}\\in B_n} \\mathsf{eq}(\\vec{x},\\,\\vec{x_0})\\times \\mathsf{D}^{(\\vec{x})},</span></p>

    <p class="text-gray-300"><span id="page-19-0"></span>3. <span class="math-block">f^*(\\vec{y_0}) = z_0</span> .</p>

    <p class="text-gray-300">Figure 2: KZH polynomial commitment scheme</p>

    <p class="text-gray-300"><span id="page-20-1"></span>Theorem 3. The protocol in Fig. <a href="#page-19-0">2</a> is a complete and knowledge-sound polynomial commitment scheme as defined in Definition <a href="#page-14-1">1,</a> in the AGM under the (q1, q2) − dlog and Setup-find-rep assumptions.</p>

    <p class="text-gray-300">The proof is deferred to Appendix <a href="#page-45-1">B.1</a></p>

    <p class="text-gray-300">Dual polynomials. A dual polynomial [\\[GNS24\\]](#page-43-6) is a recent primitive that allows us to link a witness committed to using a univariate polynomial commitment scheme with a witness inside a multilinear polynomial commitment scheme. KZH, when the SRS is initialized with the powers of τ , acts both as a univariate KZG commitment and as a multilinear KZH commitment. To be more precise, in Figure <a href="#page-19-0">2,</a> when G (⃗i) is initialized with τ <sup>i</sup>×<sup>m</sup> × g, and τ (⃗j) is equal to τ <sup>j</sup>—i.e., we assume i and j are the decimal values corresponding to ⃗i and ⃗j—we observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\{H^{(\\vec{i},\\vec{j})}: \\vec{i} \\in B_n, \\ \\vec{j} \\in B_m\\} = \\{g^{\\tau^i}: i \\in [n \\times m]\\}.</span></div>

    <p class="text-gray-300">Since the commitment C in KZH is an MSM between {H(⃗i,⃗j)} and the values f(⃗x, ⃗y) (i.e., the evaluations of the polynomial on the boolean hypercube), it follows that C is also a KZG commitment to a univariate polynomial g(X) defined as:</p>

    <div class="my-4 text-center"><span class="math-block">g(X) = \\sum_{i \\in [n], j \\in [m]} f(\\vec{i}, \\vec{j}) \\cdot X^{i \\times m + j}.</span></div>

    <p class="text-gray-300">This duality with KZH comes for free; for example, the same group element serves as both a KZG and KZH commitment. We defer the security proof of this modification of KZH to future work.</p>

    <p class="text-gray-300">Free opening on the boolean hypercube for KZH. As previously mentioned, KZH takes advantage of the low-weight witness in both the commitment and opening phases. However, in the special case of the opening function at points on the Boolean hypercube, it is essentially free. Given boolean input vectors ⃗x<sup>0</sup> and ⃗y0, let f ∗ (Y⃗ ) = f(⃗x0, Y⃗ ) denote the restriction of f to a fixed ⃗x0. This corresponds to a row in the matrix of evaluation points, indexed by ⟨⃗x0⟩—i.e., the decimal value of ⃗x0. Since this row is already stored, the prover only needs to read it from the matrix. Next, the evaluation point z<sup>0</sup> = f ∗ (⃗y0) lies on the boolean hypercube and is already stored, so it does not require any additional computation. We also extend this property to KZH-k for k > 2 in Appendix <a href="#page-53-1">C.1.</a></p>

    <p class="text-gray-300">Applying the Protostar compiler, we build an accumulator for KZH, the polynomial commitment scheme described in Section <a href="#page-17-1">4.</a> For the polynomial evaluation predicate, we have that the instance π.x and witness π.w are as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi.x = \\{\\mathsf{C}, \\vec{x}_0, \\vec{y}_0, z_0\\}, \\pi.w = \\{\\vec{\\mathsf{D}} := [\\mathsf{D}^{(\\vec{x})}]_{\\vec{x} \\in B_n}, f^*(\\vec{Y})\\}</span></div>

    <p class="text-gray-300">where C is the commitment to  <span class="math">f(\\vec{X}, \\vec{Y})</span> ,  <span class="math">(\\vec{x}_0, \\vec{y}_0) \\in \\mathbb{F}^{\\nu+\\mu}</span>  is the opening value,  <span class="math">z_0</span>  is claimed to be  <span class="math">z_0 = f(\\vec{x}_0, \\vec{y}_0)</span> , and  <span class="math">\\pi.w</span>  is the output of  <span class="math">\\mathsf{Open}_{\\mathsf{KZH}}</span> . The accumulator instance and witness are defined as follows, where the red elements only appear in the accumulator and not in a proof:<sup>g</sup></p>

    <div class="my-4 text-center"><span class="math-block">acc.x = \\{C, T, \\vec{x}_0, \\vec{y}_0, z_0, E\\},\\</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{acc.} w = \\{\\vec{\\mathsf{D}} := [\\mathsf{D}^{(\\vec{x})}]_{\\vec{x} \\in B_n}, \\vec{f}^*, \\, \\textcolor{red}{\\mathcal{T}^{(x)}}, \\textcolor{red}{\\mathcal{T}^{(y)}}\\}</span></div>

    <p class="text-gray-300">for  <span class="math">T \\in \\mathbb{G}_1</span> ,  <span class="math">\\mathcal{T}^{(x)} \\in \\mathcal{T}(\\mathbb{F}, \\nu)</span> ,  <span class="math">\\mathcal{T}^{(y)} \\in \\mathcal{T}(\\mathbb{F}, \\mu)</span> , and  <span class="math">\\vec{f}^<em></span>  which is the vector of the evaluation of  <span class="math">f^</em>(\\vec{Y})</span>  on the boolean hypercube. We also define the function Dec to represent the checks performed by Verify<sub>KZH</sub>. This function computes the error term in the verifier equations, which should evaluate to 0 when evaluated in a fresh proof. Given a tree  <span class="math">\\mathcal{T}</span>  of depth n and a vector  <span class="math">\\vec{x} = (x_1, x_2, \\dots, x_n)</span> , the error tree  <span class="math">\\overline{\\mathsf{EqTree}}(\\mathcal{T}, \\vec{x})</span>  is another tree of depth n constructed as follows: The root node of the error tree is initialized to 0; for each node in  <span class="math">\\mathcal{T}</span>  at depth i with value t, having left and right children with values  <span class="math">\\ell</span>  and r, respectively, the corresponding nodes in the error tree have left and right child values  <span class="math">\\ell - t \\times (1 - x_i)</span>  and  <span class="math">r - t \\times x_i</span> , respectively. Now given the following values,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{T}_x^{(\\text{error})} \\leftarrow \\overline{\\mathsf{EqTree}}(\\mathcal{T}^{(x)}, \\, \\vec{x}_0)</span></li>

      <li><span class="math">\\mathcal{T}_{y}^{(\\text{error})} \\leftarrow \\overline{\\mathsf{EqTree}}(\\mathcal{T}^{(y)}, \\, \\vec{y}_{0})</span></li>

      <li><span class="math">e&#x27;&#x27; \\leftarrow \\langle f^*, \\mathcal{T}^{(y)}. \\text{leaves} \\rangle z</span></li>

      <li><span class="math">\\mathsf{E}_{\\mathbb{G}} \\leftarrow \\langle \\vec{f^*}, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle \\langle \\mathcal{T}^{(x)}. \\text{leaves}, \\vec{\\mathsf{D}} \\rangle</span></li>

    </ul>

    <p class="text-gray-300">Dec is defined as it follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\mathsf{Dec}(\\vec{x}_0,\\vec{y}_0,z_0,\\vec{f}^*,\\mathcal{T}^{(x)},\\mathcal{T}^{(y)},\\vec{\\mathsf{D}}) \\ = \\langle \\mathcal{T}_x^{(\\mathsf{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_y^{(\\mathsf{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e'',\\vec{\\mathsf{K}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{K}' \\rangle + \\mathsf{E}_{\\mathbb{G}}.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The algorithms  <span class="math">\\mathsf{Setup}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span>  are described in Figure 3 whereas  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  are in Figure 4. In Figure 3, in fact challenge  <span class="math">\\beta</span>  is the random challenge coming from the verifier in an interactive accumulation protocol, but we directly apply Fiat-Shamir heuristic to make the protocol non-interactive, deriving the random challenge through a random oracle initialized with a hash function. We present an overview of the efficiency of the accumulation scheme below:</p>

    <p class="text-gray-300"><strong>Communication.</strong> The size of the accumulation witness is  <span class="math">O(n+m) = O(\\ell^{\\frac{1}{2}})</span> . The accumulator instance is constant in size. The communication is significantly lower than Nova, Halo Infinite, HyperNova and Protostar, where it is  <span class="math">\\Theta(\\ell)</span> . Using the generalization to multivariate polynomial commitments in Appendix C, we can reduce the communication to  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}})</span></p>

    <p class="text-gray-300"><span id="page-21-0"></span>gHere, proof refers to a fresh accumulator in the context of an accumulator.</p>

    <p class="text-gray-300"><span id="page-21-1"></span><sup>&</sup>lt;sup>h</sup>Optimized as  <span class="math">E&#x27;&#x27; \\leftarrow E + \\beta \\times (E - E&#x27;) + (1 - \\beta)\\beta \\times Q</span></p>

    <pre><code class="language-text">Setup&lt;sub&gt;acc&lt;/sub&gt;(1^{\\lambda}, k):</code></pre>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\operatorname{srs}_{\\mathsf{K7H}} \\leftarrow \\operatorname{Setup}_{\\mathsf{K7H}}(\\lambda, k)</span> .</li>

      <li>Parse n,m from  <span class="math">\\mathsf{srs}_{\\mathsf{KZH}}</span>  and generate  <span class="math">\\vec{\\mathsf{K}} = (\\mathsf{K}_1,\\dots,\\mathsf{K}_{2\\cdot(n+m-1)}) \\in \\mathbb{G}_1^{2\\cdot(n+m-1)}</span>  and  <span class="math">\\mathsf{K}&#x27; \\leftarrow \\mathbb{G}_1</span>  (unknown DLOG from all other generators).</li>

      <li>Output srs =  <span class="math">(srs_{KZH}, \\vec{K}, K&#x27;)</span> .</li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathsf{P}_{\\mathsf{acc}}(\\mathsf{srs},\\mathsf{st},(\\pi.x,\\pi.w),(\\mathsf{acc}_1.x,\\mathsf{acc}_1.w))</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Build accumulator ( <span class="math">acc_2.x, acc_2.w</span> ) from  <span class="math">(\\pi.x, \\pi.w)</span> :</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\begin{array}{l} \\ \\operatorname{Parse} \\ (\\mathsf{C}_2, \\vec{x}_2, \\vec{y}_2, z_2) \\leftarrow \\pi.x \\ \\operatorname{and} \\ (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, f_2^*(\\vec{Y})) \\leftarrow \\pi.w \\\\ \\ \\operatorname{Let} \\ \\mathcal{T}_2^{(x)} \\leftarrow \\operatorname{EqTree}(\\vec{x}_2), \\mathcal{T}_2^{(y)} \\leftarrow \\operatorname{EqTree}(\\vec{y}_2) \\\\ \\ \\operatorname{Parse} \\ \\mathcal{T}_2^{(x)} \\in \\mathbb{F}^{2n-1}, \\ \\mathcal{T}_2^{(y)} \\in \\mathbb{F}^{2m-1} \\ \\operatorname{and} \\ \\operatorname{compute} \\ T_2 \\leftarrow \\langle \\mathcal{T}_2^{(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_2^{(y)}, \\vec{\\mathsf{K}} \\rangle \\\\ \\ \\operatorname{Output} \\ \\operatorname{acc}_2.x = \\{\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2, 0_{\\mathbb{G}}\\}, \\ \\operatorname{acc}_2.w = (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_2^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)}\\} \\end{array}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute proof pf:</li>

      <li>Parse  <span class="math">(\\mathsf{C}_1,\\,T_1,\\,\\vec{x}_1,\\vec{y}_1,z_1,\\mathsf{E}_1) \\leftarrow \\mathsf{acc}_1.x</span>  and  <span class="math">(\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x}\\in B_n},\\,\\vec{f}_1^*,\\mathcal{T}_1^{(x)},\\mathcal{T}_1^{(y)}) \\leftarrow \\mathsf{acc}.w</span></li>

      <li>Set pf = Q for  <span class="math">Q \\in \\mathbb{G}_1</span>  such that,</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{Dec}((1-X)\\cdot(\\vec{x}_1,\\vec{y}_1,z_1,\\vec{f}_1^*,\\mathcal{T}_1^{(x)},\\mathcal{T}_1^{(y)},\\vec{\\mathsf{D}}_1) + X\\cdot(\\vec{x}_2,\\vec{y}_2,z_2,\\vec{f}_2^*,\\mathcal{T}_2^{(x)},\\mathcal{T}_2^{(y)},\\vec{\\mathsf{D}}_2)) \\\\ = (1-X)\\times\\mathsf{E}_1 + X\\times\\mathsf{E}_2 + (1-X)\\cdot X\\times\\mathsf{Q} \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accumulate  <span class="math">(acc_1.x, acc_1.w)</span>  and  <span class="math">(acc_2.x, acc_2.w)</span>  into (acc.x, acc.w):</li>

      <li>Generate challenge  <span class="math">\\beta \\leftarrow H(\\mathsf{acc}_1.x, \\mathsf{acc}_2.x, \\mathsf{Q})</span>  through Fiat-Shamir.</li>

      <li>Compute new error term</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{E} \\leftarrow (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q}^{\\mathrm{h}}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the following linear combinations:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span></div>

    <p class="text-gray-300">and set  <span class="math">acc.x = (C, T, \\vec{x}, \\vec{y}, z, E)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the new accumulator witness</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{acc.} w \\leftarrow (1-\\beta) \\cdot (\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f_1}^*, \\mathcal{T}_1^{(x)}, \\mathcal{T}_1^{(y)}) + \\beta \\cdot (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f_2}^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)})</span></div>

    <p class="text-gray-300"><span id="page-22-0"></span>- Output (acc.x, acc.w, pf)</p>

    <p class="text-gray-300">Figure 3: Setup and prover algorithms for KZH-fold</p>

    <p class="text-gray-300">Vacc(srs, acc.x1, acc.x2, pf):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse (C1, T1, ⃗x1, ⃗y1, z1, E1) ← acc1.x and (C2, T2, ⃗x2, ⃗y2, z2, E2) ← acc2.x</li>

      <li>Parse Q ← pf</li>

      <li>Regenerate challenge β ← H(acc1.x, acc2.x, Q)</li>

      <li>Compute E ← (1 − β) × E<sup>1</sup> + β × E<sup>2</sup> + (1 − β) · β × Q and</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span></div>

    <p class="text-gray-300">• Output acc.x = (C, T, ⃗x, ⃗y, z, E)</p>

    <p class="text-gray-300">Dacc(srs, acc.x, acc.w):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse (C, T, ⃗x0, ⃗y0, z0, E) ← acc.x and ({D (⃗x)}⃗x∈B<sup>n</sup> , ⃗f ∗ , T (x) , T (y) ) ← acc.w</li>

      <li>Output 1 if and only if all following checks pass, otherwise output 0.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(i) \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\stackrel{?}{=} e(\\mathsf{C}, \\mathsf{V}&#x27;)</span></div>

    <p class="text-gray-300">(ii)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\langle (\\mathcal{T}^{(x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}^{(y)}), \\vec{\\mathsf{K}} \\rangle \\stackrel{?}{=} T$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-23-0"></span> <span class="math-block">(iii) \\ \\operatorname{Dec}(\\vec{x}_0,\\vec{y}_0,z_0,\\vec{f^*},\\mathcal{T}^{(x)},\\mathcal{T}^{(y)},\\vec{\\mathsf{D}}) \\stackrel{?}{=} \\mathsf{E}</span></p>

    <p class="text-gray-300">Figure 4: Verifier and decider algorithms in KZH-fold</p>

    <p class="text-gray-300"><strong>Decider complexity.</strong> The decider is essentially has the same characteristic of KZH verifier, and thus runs in time  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  or  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}})</span>  in the generalized case.</p>

    <p class="text-gray-300"><strong>Prover complexity.</strong> The accumulation prover performs  <span class="math">O(n+m) = O(\\ell^{\\frac{1}{2}})</span>  operations to combine the two witnesses and compute the cross-term  <span class="math">\\mathbb{Q}</span> . This contrasts with previous approaches - namely Nova, Halo Infinite, and Protostar - which require a linear number of operations.</p>

    <p class="text-gray-300"><strong>Verifier complexity.</strong> The accumulation verifier performs 3-4  <span class="math">\\mathbb{G}_1</span>  exponentiations, along with a constant number of field operations, which is consistent with schemes like Nova (requiring 2-3  <span class="math">\\mathbb{G}_1</span>  operations) and Protostar (requiring 3-4  <span class="math">\\mathbb{G}_1</span>  operations).</p>

    <p class="text-gray-300"><span id="page-24-2"></span><strong>Theorem 4.</strong> The protocol in Figures 3 and 4 is an accumulator scheme satisfying completeness and knowledge soundness as in Definition 2, in the AGM under the dlog assumption.</p>

    <p class="text-gray-300">The proof is deferred to Appendix B.2. Intuitively, correctness follows since  <span class="math">V_{acc}</span>  and  <span class="math">D_{acc}</span>  together go through the same computations as  <span class="math">P_{acc}</span> , and thus the outputs are the same. For soundness, note that if decider's first check passes, since  <span class="math">\\beta</span>  is computed after the prover outputs  <span class="math">acc_1</span>  and  <span class="math">acc_2</span> , it implies the first check of the KZH verifier is satisfied for  <span class="math">C_1</span> ,  <span class="math">\\{D_1^{(\\vec{x})}\\}</span>  and for  <span class="math">C_2</span> ,  <span class="math">\\{D_2^{(\\vec{x})}\\}</span> . For the other two KZH verifier checks, the decider computes the error terms and verifies their consistency with the error term computed by  <span class="math">P_{acc}</span> . Again, since  <span class="math">\\beta</span>  depends on the outputs of  <span class="math">P_{acc}</span> , the error terms of  <span class="math">acc_1</span>  and  <span class="math">acc_2</span>  are correctly computed and thus the KZH checks are satisfied.</p>

    <p class="text-gray-300">In the previous section, we designed a polynomial accumulation scheme (KZH-fold). Next, using that, we aim to build an accumulation scheme for the NP-complete language of R1CS. Our strategy is to translate R1CS via Spartan PIOP into polynomial checks and then accumulate those polynomial evaluations with PA. Specifically, when we translate R1CS with Spartan, we obtain an evaluation for the witness polynomial and three evaluation for the multilinear extension of the R1CS matrices. Let  <span class="math">A, B, C \\in \\mathbb{F}^{n \\times m}</span>  be the R1CS matrices and subsequently define  <span class="math">\\mu_n = \\log_2(n)</span>  and  <span class="math">\\mu_m = \\log_2(m)</span> . Further, let  <span class="math">\\tilde{A}(X,Y) \\in \\mathbb{F}[X_1,\\ldots,X_{\\mu_n},Y_1,\\ldots,Y_{\\mu_m}]</span>  be the multilinear extension of A and similarly define  <span class="math">\\tilde{B}</span>  and  <span class="math">\\tilde{C}</span> . In Spartan [Set20], the prover and verifier compute a random challenge  <span class="math">\\vec{r}</span>  via Fiat-Shamir and run a sumcheck protocol for the following equation</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in \\{0,1\\}^{\\mu_n}} \\operatorname{eq}(\\vec{r},\\vec{x}) \\cdot \\left( \\tilde{A}z(\\vec{x}) \\cdot \\tilde{B}z(\\vec{x}) - \\tilde{C}z(\\vec{x}) \\right) = 0</span></div>

    <p class="text-gray-300">in which Az˜ (⃗x) = P ⃗y∈{0,1} µm A˜(⃗x, ⃗y) · z˜(⃗y). Now to accumulate the equation above, we need to accumulate the evaluations of A, ˜ B, ˜ C˜ and z˜ (witness polynomial). We can directly accumulate the witness polynomial with an PA such as KZH-fold. However, the same strategy cannot be applied to the multilinear extension of matrices since these polynomials are sparse and interpolating them directly with KZH-fold will result in a large SRS, hence we take a different strategy. For extension polynomials A˜, B˜ and C˜, note that we need to accumulate the evaluations of the same multilinear polynomial at multiple evaluation points, i.e. A˜(r (1) <sup>x</sup> , r (1) <sup>y</sup> ) = z (1) and A˜(r (2) <sup>x</sup> , r (2) <sup>y</sup> ) = z (2). This can be done easily using a simple random linear combination. We present an accumulation scheme in Figure <a href="#page-26-0">5</a> for relation <sup>R</sup>A˜, i.e. <sup>A</sup>˜ <sup>∈</sup> MLP(F, µ<sup>n</sup> <sup>+</sup> <sup>µ</sup>m) as defined below:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\tilde{A}} = \\{ (r_x \\in \\mathbb{F}^{\\mu_n}, r_y \\in \\mathbb{F}^{\\mu_m}, z \\in \\mathbb{F}) : \\tilde{A}(r_x, r_y) = z \\}</span></div>

    <p class="text-gray-300">Given a polynomial accumulation scheme (e.g., KZH-fold) and the accumulation of sparse matrix evaluations described in Figure <a href="#page-26-0">5,</a> we can now accumulate the polynomial checks produced by the Spartan PIOP. This enables us to construct an accumulation scheme for R1CS, as we describe in detail in the next subsection.</p>

    <p class="text-gray-300">In the previous section, we introduced a polynomial commitment scheme and built an accumulation scheme for its verifier, i.e. the polynomial evaluation predicate in Section <a href="#page-20-0">4.1.</a> Notably, many modern NARK constructions have succinct verifiers when given oracle access to a polynomial commitment scheme capable of proving polynomial evaluations. In Subsection <a href="#page-24-1">5.1,</a> we introduce a PIOP for R1CS inspired by Spartan with these characteristics. Thus, from Theorem <a href="#page-17-2">1</a> in Section <a href="#page-17-0">3.5,</a> an accumulation scheme for PCS (e.g. KZH) implies an accumulation scheme for R1CS. Next, from Theorem <a href="#page-17-3">2</a> there exists an efficient transformation that takes the NARK and its accumulation scheme and constructs an IVC (PCD) scheme IVC = (SetupIVC, PIVC, VIVC) which we just refer to as Spartan+PA. According to Theorem <a href="#page-17-3">2,</a> this IVC (PCD) scheme for a step function with size n (i.e. the step function represented as R1CS has size n) has the following efficiency properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>PIVC time = the prover time of PA.</li>

      <li>VIVC time = the decider time of PA.</li>

      <li>Proof size of IVC = the accumulator size of PA.</li>

    </ul>

    <p class="text-gray-300">For example when PA=KZH-fold, it implies the prover cost per step is O(n) while the verifier time and proof size are O(n 1 <sup>2</sup> ). This is in contrast with IVC schemes from Nova, HyperNova and Protostar which have O(n) prover time, verifier time and proof size. An overview of Spartan+PA's step function initiated with KZH-fold can be seen in Figure <a href="#page-27-1">6.</a></p>

    <p class="text-gray-300"><span class="math-block">\\mathsf{P}_{\\mathsf{ABC}}(\\tilde{A}, (r_x^{(1)}, r_y^{(1)}, z^{(1)}), (r_x^{(2)}, r_y^{(2)}, z^{(2)}))</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given two satisfying instances  <span class="math">(r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),\\,(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)})\\in\\mathcal{R}_{\\tilde{A}}</span></li>

      <li>Prover computes q(X) in the following polynomial identity where q(x) is a polynomial of degree  <span class="math">\\mu + \\nu 2</span> .</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\tilde{A}((1-X) \\cdot r_x + X \\cdot r_x&#x27;, (1-X) \\cdot r_y + X \\cdot r_y&#x27;) = (1-X) \\cdot z + X \\cdot z&#x27; + (1-X) \\cdot X \\cdot q(X)</span></div>

    <p class="text-gray-300">Note q(X) can be computed directly through polynomial interpolation by evaluating the identity above with different X values.</p>

    <p class="text-gray-300">• Derive challenge</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\leftarrow H((r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)}),q(X))</span></div>

    <p class="text-gray-300">• Compute the accumulated instances as follows:</p>

    <div class="my-4 text-center"><span class="math-block">r_x \\leftarrow (1 - \\alpha) \\cdot r_x^{(1)} + \\alpha \\cdot r_x^{(2)} \\quad r_y \\leftarrow (1 - \\alpha) \\cdot r_y^{(1)} + \\alpha \\cdot r_y^{(2)}</span></div>

    <p class="text-gray-300"> <span class="math">z \\leftarrow (1 - \\alpha) \\cdot z^{(1)} + \\alpha \\cdot z^{(2)} + \\alpha \\cdot (1 - \\alpha) \\cdot q(\\alpha)</span></p>

    <p class="text-gray-300">• Output accumulated instance  <span class="math">(r_x, r_y, z)</span>  along with accumulation proof q(x)</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{V}_{\\mathsf{ABC}}((r_x^{(1)}, r_y^{(1)}, z^{(1)}), (r_x^{(2)}, r_y^{(2)}, z^{(2)}), q(X)) \\mathbf{:}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derive challenge  <span class="math">\\alpha \\leftarrow H((r_x^{(1)},\\,r_y^{(2)},\\,z^{(1)}),(r_x^{(2)},\\,r_y^{(2)},\\,z^{(2)}),q(X))</span></li>

      <li>Compute the accumulated instances as it follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">r_x \\leftarrow (1 - \\alpha) \\cdot r_x^{(1)} + \\alpha \\cdot r_x^{(2)} \\quad r_y \\leftarrow (1 - \\alpha) \\cdot r_y^{(1)} + \\alpha \\cdot r_y^{(2)}</span></div>

    <p class="text-gray-300"> <span class="math">z \\leftarrow (1 - \\alpha) \\cdot z^{(1)} + \\alpha \\cdot z^{(2)} + \\alpha \\cdot (1 - \\alpha) \\cdot q(\\alpha)</span></p>

    <p class="text-gray-300">• Output accumulated instance  <span class="math">(r_x, r_y, z)</span></p>

    <p class="text-gray-300"><span id="page-26-0"></span> <span class="math-block">\\mathsf{D}_{\\mathsf{ABC}}(\\tilde{A},(r_x,r_y,z))</span> : Compute  <span class="math">z&#x27; \\leftarrow \\tilde{A}(r_x,r_y)</span>  and assert  <span class="math">z \\stackrel{?}{=} z&#x27;</span></p>

    <p class="text-gray-300">Figure 5: Matrix evaluation accumulation description</p>

    <p class="text-gray-300"><img src="_page_27_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-27-1"></span>Figure 6: Spartan+PA step (augmented) circuit initiated with KZH-fold</p>

    <p class="text-gray-300">This construction works with any other PCS accumulation scheme too as long as the accumulation verifier is sublinear. In the next section, we will use Spartan+KZH-fold to build an efficient signature aggregation scheme. Our Spartan+PA construction is not zero knowledge; however, we believe that one can use the techniques presented in HyperNova [KS23c] to make our IVC scheme zero knowledge, we leave this to future work.</p>

    <p class="text-gray-300">Review on previous work. N-IVC [KS22] extends traditional IVC by allowing each step to execute one of several predefined instructions  <span class="math">F_1, F_2, \\ldots, F_k</span>  rather than a single instruction F. Earlier implementations relied on a universal circuit that computes all instructions and selects the output based on the program counter, resulting in inefficiency as the prover computes every instruction, even when only one is needed. SuperNova improves this by maintaining a running accumulator for each instruction and using memory techniques (e.g., Merkle trees) to select and accumulate only the relevant accumulator at each step, reducing he per-step computation cost of the prover to align with the step circuit cost. However, the witness size grows linearly with the combined sizes of all instruction witnesses. Protostar [BC23] offers a similar improvement, leveraging the fact that committing to zeros incurs no additional cost. While it also reduces the per-step computation cost of the prover to the cost of the step circuit for N-IVC, like SuperNova, it still requires the prover to manage a witness size that scales linearly with the sum of all instruction witnesses.</p>

    <p class="text-gray-300">Similar to N-IVC, N-PCD [Zhe+23] extends the definition of PCD to support multiple instruction circuits instead of a single instruction. Constructing N-PCD using previous approaches results in both the prover's computation and witness size being linear in the combined size of all instructions. Intuitively, SuperNova maintains a set of running ac-</p>

    <p class="text-gray-300">cumulator, one for each instruction. Accumulating this running accumulator with a fresh accumulator can be done efficiently by selecting the correct running accumulator. However, to construct N-PCD, it must accumulate two sets of running accumulators, leading to a prover time that is linear in the combined size of all instruction circuits, along with the size of the circuit growing linearly with k, i.e. the number of instructions. Protostar follows a similar paradigm, building a universal circuit and maintaining a Pedersen commitment to it. To execute one of the instruction circuits, the wires of the other instructions are set to zero. Since these zeroed wires do not contribute to the commitment, the cost of committing to the wires of this universal circuit to run a single instruction matches the step circuit cost. However, accumulating two running accumulators requires computing a new commitment that is linear in the size of the universal circuit. However, the circuit size remains constant, since it requires taking a linear combination between two Pederson commitments.</p>

    <p class="text-gray-300">KiloNova [\\[Zhe+23\\]](#page-42-0) naively builds non-uniform PCD based on HyperNova and results in the same issue as SuperNova. Their construction relies on the ability to efficiently fold commitments to sparse CCS matrices, which is necessary for IVC/PCD. Unfortunately, folding different sparse matrices does not necessarily preserve sparseness as demonstrated in Appendix <a href="#page-64-0">D</a> and that is the reason, in this work we avoid folding sparse matrices with different structures.</p>

    <p class="text-gray-300">N-IVC and N-PCD from Spartan+PA. We propose an alternative approach to achieve N-IVC and N-PCD via Spartan+PA with appealing efficiency and communication features. Our N-PCD is the first N-PCD scheme in which the prover is efficient, i.e. the prover time is not linear in the combined size of all instructions and the decider algorithm only requires group operations proportional to the maximum instruction size, while it needs a linear number of field operations in the combined size of all instructions. This is in contrast to SuperNova and Protostar, where the decider requires linear group operations in the combined size of all circuits. Given that group scalar multiplication is 100x-1000x more expensive than a field operation<a href="#page-28-0">i</a> , the decider's cost in these schemes is dominated by the number of group operations, making our decider far more efficient. Let F1, F2, ..., F<sup>k</sup> be the instruction circuits. An overview and comparison of our approach to N-IVC and N-PICD can be seen in Tables <a href="#page-29-0">3</a> and <a href="#page-29-1">4</a> respectively. The high-level idea is to accumulate polynomials corresponding to F<sup>i</sup> rather than accumulating the circuit F<sup>i</sup> (i.e. its R1CS representation) directly. The key insight is that any polynomial of degree d<sup>i</sup> < D can be padded to become a polynomial of degree D, allowing it to be accumulated with a running polynomial of degree D. To be more precise, to build N-IVC and N-PCD from Spartan+PA, we maintain a running accumulator corresponding to a polynomial of degree D and use it to accumulate PCS opening statements of degree d<sup>i</sup> (e.g., opening a witness commitment at a random point) required by the Spartan verifier. This strategy is compatible with any polynomial accumulation scheme with a sublinear accumulation verifier. We</p>

    <p class="text-gray-300"><span id="page-28-0"></span>i <https://zka.lc/></p>

    <p class="text-gray-300">defer its details to Appendix D.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperNova</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O( F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sum_{i} F_{i} \\right)\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sum_{i} F_{i} \\right)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Protostar</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O( F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sum_{i} F_{i} \\right)\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sum_{i} F_{i} \\right)</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+PA</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathcal{P}_{\\mathrm{acc}}(\\max_i  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathcal{D}_{\\mathrm{acc}}(\\max_{i} F_{i} ) + O\\left(\\sum_{i} F_{i} \\right)\\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O( \\mathrm{acc}  + \\sum_{i} \\log  F_i )</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH-fold</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\max_i  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sqrt{\\max_{i} F_{i} }\\right) + O\\left(\\sum_{i} F_{i} \\right)\\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O\\left(\\sqrt{\\max_i  F_i } + \\sum_i \\log  F_i \\right)</span></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-29-0"></span>Table 3: Comparison of different N-IVC approaches based on prover/verifier time and witness size. We assume SuperNova is working over Nova and Protostar is working over Pedersen commitment, while we describe our approach as generic over a polynomial accumulation scheme PA, where  $\\mathcal{P}_{acc}(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  denotes the time for the accumulation prover to accumulate two accumulators of size  </span>\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , which is  </span>O(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  for KZH-fold. Similarly,  </span>\\mathcal{D}_{acc}(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  represents the decider time for an accumulator of size  </span>\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , given by  </span>O(\\sqrt{\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$  for KZH-fold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Witness Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SuperNova</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum_{i}  F_{i} )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Protostar</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum_{i}  F_{i} )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KiloNova</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum  F_i )\\mathbb{G}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sum_{i}  F_{i} )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+PA</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathcal{P}_{\\rm acc}(\\max_i  F_i ) + \\sum_i \\log  F_i </span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">\\mathcal{D}_{\\mathrm{acc}}(\\max_{i} F_{i} ) + O(\\sum_{i} F_{i} )\\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O( \\mathrm{acc}  + \\sum_{i} \\log  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH-fold</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\max_i  F_i ) + \\sum_i \\log  F_i </span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sqrt{\\max_i  F_i }) + O(\\sum_i  F_i )\\mathbb{F}</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">O(\\sqrt{\\max_i  F_i } + \\sum_i \\log  F_i )</span></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-29-1"></span>Table 4: Comparison of different N-PCD approaches based on prover/verifier time and witness size. We assume SuperNova is working over Nova and Protostar is working over Pedersen commitment, while we describe our approach as generic over a polynomial accumulation scheme PA where  $\\mathcal{P}_{acc}(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  denotes the time for the accumulation prover to accumulate two accumulators of size  </span>\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , which is  </span>O(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  for KZH-fold. Similarly,  </span>\\mathcal{D}_{acc}(\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  represents the decider time for an accumulator of size  </span>\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , given by  </span>O(\\sqrt{\\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$  for KZH-fold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Figure 7 and 8, we provide a protocol enabling bandwidth-efficient recursive aggregation of accountable signatures. A distinctive feature of our protocol is that the circuit size remains independent of the number of signers, made possible by the homomorphic properties of our KZH commitment scheme. Our protocol uses - as building blocks - an aggregate signature scheme (KGen<sub>ss</sub>, Sign<sub>ss</sub>, Verify<sub>ss</sub>) (Definition 4), the IVC scheme ( <span class="math">Setup_{IVC}</span> ,  <span class="math">P_{IVC}</span> ,  <span class="math">V_{IVC}</span> ) of Section 5, and our polynomial commitment scheme KZH =(Setup<sub>KZH</sub>, Commit<sub>KZH</sub>, Open<sub>KZH</sub>, Verify<sub>KZH</sub>). Our scheme also uses the famous sumcheck protocol (P<sub>smck</sub>, V<sub>smck</sub>) [Lun+90]. We implement our signature aggregation protocol using BLS as the signature scheme [BLS04], and present its efficiency, along with a comparison to the state of the art, in Section 7. To track the signers, we use a bitvector: a vector bwith a size equal to the number of validators such that  <span class="math">b_k = 1</span>  if user k has signed, and 0 otherwise. Here  <span class="math">\\langle k \\rangle</span>  is the  <span class="math">\\mu</span> -bit binary representation of k. The circuit size of the scheme is constant, independent of the number of validators, enabling the recursive aggregation of signatures for millions of validators with minimal overhead. This is achieved via utilizing the IVC scheme from Section 5. The scheme proves the union of the bitvector by relying on the fact that  <span class="math">\\vec{b}_1 \\vee \\vec{b}_2 = \\vec{b}_1 + \\vec{b}_2 - \\vec{b}_1 \\circ \\vec{b}_2</span> . In Figure 8, we build a simple sumcheck-based PIOP for this statement. We compile this PIOP into a proof system using KZH, and accumulate the resulting evaluation checks.</p>

    <p class="text-gray-300">The Setup algorithm of the signature aggregation scheme initializes the IVC scheme. Users use KGen to generate their public and signing key pair (sk, pk). Initalize initializes the vector of all public keys from the users in the system. To sign, users run Sign<sub>ss</sub>. Next, user k runs SigToAggSig to convert their signature into aggregated form. Aggregate is similar to an accumulation scheme and is run by a prover and a verifier: it takes two aggregated signatures as input and outputs a new one. The aggregated signature includes an IVC proof  <span class="math">\\pi_{\\text{IVC}}</span>  for the function F, which is the KZH verifier. That is,  <span class="math">\\pi_{\\text{IVC}}.x</span>  consists of the polynomial evaluation claims (including F and F.x) whereas  <span class="math">\\pi_{\\text{IVC}}.w</span>  is a proof that they have been aggregated correctly. Finally, Verify (intuitively, the decider of the accumulation scheme) is run to check the validity of aggregated signatures. We provide an overview of the resulting IVC circuit in Figure 9.</p>

    <p class="text-gray-300">Efficiency. The aggregate signature consists of the public key, the signature and a polynomial that interpolates the bitvector of signers, as well as an IVC proof (which contains PCS evaluation claims). Using Spartan+KZH-fold from Section 4.1, the IVC proof is  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  in size. Thus the aggregate, accountable signature size is dominated by the bitvector of signers  <span class="math">\\vec{c}</span> , which contains at most  <span class="math">\\ell</span>  bits. This is the minimal information that can be transmitted for an accountable signature. The aggregator's work consists of computing and committing to  <span class="math">\\vec{c}</span>  which takes at most  <span class="math">\\ell</span>  group additions (not scalar multiplications as  <span class="math">\\vec{c}</span>  consists of bits), as well as the work of running the sumcheck prover and the accumulation prover. Both of these are linear prover time and do not require additional commitments.</p>

    <pre><code class="language-text">Setup(1λ
         , n):
    • Sample {(p, g1, g2, G1, G2, GT , e)} ←$ GGen(1λ
    • G ←$ G1
    • srsIVC ← SetupIVC(λ)</code></pre>

    <p class="text-gray-300">• Output <span class="math-block">srs = (srs_{IVC}, G)</span></p>

    <p class="text-gray-300"> <span class="math">KGen(\\lambda)</span> :  <span class="math">(sk, pk) \\leftarrow KGen_{ss}(1^{\\lambda}, n)</span></p>

    <p class="text-gray-300">Intialize(srsPC, [pk<sup>i</sup> n <sup>i</sup>=1):</p>

    <p class="text-gray-300">Compute vector commitment VC such that VC[k] = pk<sup>k</sup> .</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Sign}(\\mathsf{pk}, M \\in \\{0,1\\}^*) \\ : \\ \\sigma \\leftarrow \\mathsf{Sign}_{\\mathsf{ss}}(\\mathsf{sk}, M)</span></div>

    <p class="text-gray-300">SigToAggSig(k ∈ [n · m], pk<sup>k</sup> , σk): user k prepares its signature to aggregate</p>

    <p class="text-gray-300">• Set <span class="math-block">\\vec{b} = \\langle k \\rangle \\in \\{0, 1\\}^{\\mu}</span></p>

    <p class="text-gray-300">• <span class="math-block">\\mathsf{B}_k \\leftarrow \\mathsf{Commit}_{\\mathsf{KZH}}(\\mathsf{srs}_{\\mathsf{KZH}}, b(\\vec{X}))</span></p>

    <p class="text-gray-300">• Set IVC proof <span class="math-block">\\pi_{\\mathsf{IVC}}^{(k)} = \\bot</span></p>

    <p class="text-gray-300">• Output:</p>

    <div class="my-4 text-center"><span class="math-block">A_k = (\\mathsf{pk}_k, \\mathsf{B}_k, \\pi_{\\mathsf{IVC},k}.x, b_k(\\vec{X}), \\sigma_k, \\pi_{\\mathsf{IVC}}^{(k)}.w)</span></div>

    <p class="text-gray-300">)</p>

    <p class="text-gray-300">Verify(srs, Ak): Verify an aggregated signature</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check B = CommitKZH(srsKZH, b(X⃗ )).</li>

      <li>Check Vss(pk, M, σ) = 1</li>

      <li><span id="page-31-0"></span>• Check VerifyIVC(srsIVC, F, F.x, πIVC) = 1</li>

    </ul>

    <p class="text-gray-300">Figure 7: Signature aggregation protocol - 1</p>

    <p class="text-gray-300">Aggregate <span class="math">(A_{k_1}, A_{k_2})</span> :</p>

    <p class="text-gray-300">Aggregate the signatures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bullet \\ \\ A_{k_1} = (\\mathsf{pk}_{k_1}, \\mathsf{B}_{k_1}, \\pi_{\\mathsf{IVC}}^{(k_1)}.x, \\sigma_{k_1}, b_{k_1}(\\vec{X}), \\pi_{\\mathsf{IVC}}^{(k_1)}.w)</span></li>

      <li><span class="math">\\bullet \\ \\ A_{k_2} = (\\mathsf{pk}_{k_2}, \\mathsf{B}_{k_2}, \\pi_{\\mathsf{IVC}}^{(k_2)}.x, \\sigma_{k_2}, b_{k_2}(\\vec{X}), \\pi_{\\mathsf{IVC}}^{(k_2)}.w)</span></li>

      <li>Set  <span class="math">\\mathsf{pk&#x27;} \\leftarrow \\mathsf{pk}_{k_1} + \\mathsf{pk}_{k_2}</span></li>

      <li>Set  <span class="math">\\sigma&#x27; \\leftarrow \\sigma_{k_1} + \\sigma_{k_2}</span></li>

    </ul>

    <p class="text-gray-300">Proof of well-formedness of new bitvector</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute  <span class="math">c(\\vec{X})</span>  such that  <span class="math">c(\\vec{x}) = b_{k_1}(\\vec{x}) \\vee b_{k_2}(\\vec{x}) \\ \\forall \\vec{x} \\in \\{0,1\\}^{\\mu}</span></li>

      <li>Send C  <span class="math">\\leftarrow</span>  Commit<sub>KZH</sub>(srs<sub>KZH</sub>,  <span class="math">c(\\vec{X})</span> )</li>

      <li>Verifier sends challenge  <span class="math">\\vec{r} \\leftarrow \\mathbb{F}^{\\mu}</span></li>

      <li>Define  <span class="math">c(\\vec{X}) = b_{k_1}(\\vec{X}) + b_{k_2}(\\vec{X}) b_{k_1}(\\vec{X}) \\cdot b_{k_2}(\\vec{X})</span>  and run the sumcheck to prove that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in \\{0,1\\}^{\\mu}} eq(\\vec{x}, \\vec{r}) (b_{k_1}(\\vec{x}) + b_{k_2}(\\vec{x}) - b_{k_1}(\\vec{x}) \\cdot b_{k_2}(\\vec{x}) - c(\\vec{x})) = 0</span></div>

    <p class="text-gray-300">Output  <span class="math">b_{k_1}(\\vec{\\rho})</span> ,  <span class="math">b_{k_2}(\\vec{\\rho})</span> ,  <span class="math">\\vec{c}(\\vec{\\rho})</span>  where  <span class="math">\\vec{\\rho} \\in \\mathbb{F}^k</span>  is the vector of randomness sampled by the verifier during the sumcheck.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier sends random challenges  <span class="math">\\alpha_1</span> ,  <span class="math">\\alpha_2</span>  from  <span class="math">\\mathbb{F}</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Prover computes the polynomial  <span class="math">p(\\vec{X}) = b_{k_1}(\\vec{X}) + \\alpha_1 b_{k_2}(\\vec{X}) + \\alpha_2 c(\\vec{X})</span> , runs  <span class="math">(\\pi, z_0) \\leftarrow \\mathsf{Open}_{\\mathsf{KZH}}(\\mathsf{srs}_{\\mathsf{KZH}}, p(\\vec{X}), \\vec{x}_0, \\vec{y}_0, \\mathsf{aux})</span> , for  $\\vec{x}_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{y}_0 = \\vec{\\rho}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier adds evaluation claim  <span class="math">(P = B_{k_1} + \\alpha_1 B_{k_2} + \\alpha_2 C, \\vec{x}_0, \\vec{y}_0, \\pi, z_0)</span>  to  <span class="math">\\pi&#x27;_{IVC}.x</span></li>

    </ul>

    <p class="text-gray-300">New Aggregated Signature:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi&#x27;_{IVC} \\leftarrow \\mathsf{P}_{IVC}(\\mathsf{srs}_{IVC}, F, F.x, F.w, \\pi_{IVC})</span></li>

      <li>Let  <span class="math">A&#x27; = (\\mathsf{pk}&#x27;, \\sigma&#x27;, \\mathsf{C}, \\pi&#x27;_{\\mathsf{IVC}}.x; \\sigma&#x27;, c(\\vec{X}), \\pi&#x27;_{\\mathsf{IVC}}.w)</span></li>

      <li><span id="page-32-0"></span>• Output A'</li>

    </ul>

    <p class="text-gray-300">Figure 8: Signature aggregation protocol - 2</p>

    <p class="text-gray-300"><img src="_page_33_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-33-1"></span>Figure 9: Signature aggregation augmented circuit</p>

    <p class="text-gray-300">The aggregation verifier, which is implemented as a recursive circuit in the IVC protocol, consists of a constant number of group operations and  <span class="math">\\log(\\ell)</span>  native field operations and hashes. These are mostly used to verify the accumulation of PCS evaluation claims. The recursive circuit for each leaf also needs to check that the signer polynomial  <span class="math">\\vec{b}</span>  is instantiated correctly and that the correct public key is being aggregated. This consists of a single vector commitment check (can be outsourced using a PC) and an evaluation of two Lagrange polynomials. Using the extension from Section C, the communication cost can be lowered to  <span class="math">O(k \\cdot \\ell^{\\frac{1}{k}}) + \\ell</span>  bits, however, the aggregator's computation overhead is dominated by opening a KZH-k polynomial commitment of size  <span class="math">\\ell</span> , which still costs  <span class="math">O(\\ell^{\\frac{1}{2}})</span>  group scalar multiplications.</p>

    <p class="text-gray-300">We implement all our subprotocols in Rust, by leveraging the arkworks library<sup>j</sup>. Our CycleFold [KS23a] module builds on the implementation from the Nexus zkVM project<sup>k</sup>, and our Spartan PIOP module builds on the original Spartan codebase<sup>l</sup>. We made our implementation publicly available as an open-source library<sup>m</sup>.</p>

    <p class="text-gray-300">The accumulation verifier circuit for PCD (accumulating two accumulators) in KZH2-fold and KZH3-fold schemes, respectively requires four and five scalar multiplications, implemented using CycleFold and Ova [Ova]. The total circuit size for KZH2-fold and KZH3-fold verifiers are approximately 60k and 73k constraints on the primary curve and 12k and 15k</p>

    <p class="text-gray-300"><span id="page-33-2"></span>jhttps://arkworks.rs</p>

    <p class="text-gray-300"><span id="page-33-3"></span>khttps://nexus-xyz.github.io/assets/nexus\\_whitepaper.pdf</p>

    <p class="text-gray-300"><span id="page-33-4"></span>https://github.com/microsoft/Spartan</p>

    <p class="text-gray-300"><span id="page-33-5"></span>mhttps://github.com/h-hafezi/kzh\\_fold</p>

    <p class="text-gray-300">on the secondary curve, with about 40% of constraint on the primary curve dedicated to hashing non-native field elements. Our implementation is not highly optimized. Inspired by Nexus, we also implemented a Nova circuit for IVC, accumulating one fresh proof with a running accumulation, resulting in a circuit size of 35k constraints on the primary curve and 6k on the secondary curve<a href="#page-34-3">n</a> . This comparison aligns with expectations, for example, KZH2-fold verifier is naturally larger, requiring three to four group scalar multiplications compared to two to three for Nova.</p>

    <p class="text-gray-300">As part of our implementation, we built an augmented circuit for our signature aggregation protocol as seen in Figure <a href="#page-33-1">9,</a> along with a smaller augmented circuit for our KZH-based folding scheme for NP. We used the R1CS PIOP from Section <a href="#page-24-1">5.1</a> to prove our circuits. We ran our benchmarks on a laptop with an Intel i7-1370 CPU and 32GB of RAM and 16 cores. We used the half-pairing cycles of BN254 and Grumpkin as our primary and secondary curves. We present our results in the following sections.</p>

    <p class="text-gray-300">In Figure <a href="#page-35-0">10,</a> we provide benchmarks for our variants of KZH2, KZH3 and KZH4 polynomial commitment schemes and compare them with the celebrated KZG scheme. KZG is efficient and offers constant verification time, while KZH benefits from faster opening times and supports a natural accumulation scheme.</p>

    <p class="text-gray-300">Halo Infinite [\\[Bon+21\\]](#page-43-10) (HI) presents an accumulation scheme for arbitrary homomorphic polynomial opening aggregation schemes. The prover aggregates n polynomial openings taking the polynomials themselves as input. In this section, we compare the efficiency of KZH2-fold, KZH3-fold and HI by implementing all three schemes in our codebase.</p>

    <p class="text-gray-300">In Figure <a href="#page-36-1">11,</a> we observe that KZH-fold's prover is significantly faster than HI's. For large witness sizes, HI spends most of its time committing to the polynomial q(x). On the other hand, we also see that HI's accumulation verifier is significantly faster compared to KZH-fold. Finally, we see how KZH-fold's communication overhead scales far more efficiently as the polynomial's size increases, since in HI's private aggregation scheme the prover must transmit the entire polynomial to the aggregator.</p>

    <p class="text-gray-300"><span id="page-34-3"></span><span id="page-34-2"></span><sup>n</sup>Unlike our implementation and Nexus, the original Nova implementation by Microsoft does not use Arkworks. We believe a primary reason for our circuit's inefficiency is likely due to inefficiencies in Arkworks' implementation of group operations and non-native field arithmetic in R1CS. For example, a group scalar multiplication by Nova reportedly takes 1k constraints while it takes 3k with Arkworks.</p>

    <p class="text-gray-300"><img src="_page_35_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-35-0"></span>Figure 10: KZH benchmarks and comparison with KZG. KZH polynomial degree n refers to a multilinear polynomial with n variables and hence  <span class="math">2^n</span>  size of evaluations over boolean hypercube. The polynomial coefficients for KZG and evaluation points over the boolean hypercube are selected randomly. i.e. not small field elements. When polynomial evaluation points in KZH family are set to value < 1024, we realize a 10-20x improvement in the commitment time.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">7.3 Comparison with Nova</h3>

    <p class="text-gray-300">We have implemented our IVC schemes Spartan+KZH2-fold and Spartan+KZH3-fold and compared it to our implementation of Nova<sup>o</sup> using different-sized F circuits in Table 5. For the purposes of IVC, we use a circuit F that iteratively computes Poseidon hashes, and the first column contains the number of Poseidon invocations. At the end of the R1CS PIOP protocol, the decider must evaluate the R1CS matrices A, B and C at a random point. We outsource this computation by having the prover provide an opening proof. This outsourcing is independent of the rest of the protocol, allowing any polynomial commitment scheme to be used, e.g. SPARK compiler. The commitment to the matrices, which the costly part, can be performed during the setup phase.</p>

    <p class="text-gray-300">As expected, Spartan+KZH-fold prover is slower than Nova, with a factor of almost 3 for moderate computations. However, Spartan+KZH-fold accumulator size is more compact and its verifier times are faster. Spartan+KZH-fold prover is slower for two reasons. First, Nova's prover cost is essentially two MSMs, whereas Spartan+KZH-fold prover uses KZH to commit to the witness. Furthermore, Spartan+KZH-fold's augmented circuit must partially</p>

    <p class="text-gray-300"><span id="page-35-1"></span><sup>°</sup>Primarily borrowed from Nexus zkVM project</p>

    <p class="text-gray-300"><img src="_page_36_Figure_0.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300"><span id="page-36-1"></span>Figure 11: KZH-fold performance and communication cost, along with a comparison with Halo Infinite private aggregation</p>

    <p class="text-gray-300">verify the Spartan proof's sumcheck and the accumulation of the matrix evaluations (Section 5.1). We believe that a large part of the slowdown is due to unoptimized code, which can be improved.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">7.4 Comparison with BLS aggregation</h4>

    <p class="text-gray-300">We implemented our accountable signature aggregation scheme based on Spartan+KZH3-fold from Figure 8 and compared it to the accountable BLS signature aggregation scheme in Table 6. In the BLS scheme, communication cost scales with the size of the multiplicity vector, which incurs a redundancy overhead of  <span class="math">r \\cdot \\log d</span> , where r is the number of recursive aggregation layers and d is the number of aggregators per layer. For an aggregation scheme with a single layer (r=1) with 1 million validators, the multiplicity vector requires 128 kB multiplied by  <span class="math">\\log d</span> . With additional recursive layers, this cost increases linearly with r, further exacerbating bandwidth requirements for larger validator sets. Verification involves a multiscalar multiplication (MSM) to compute the aggregated public key, using the multiplicity vector and validators' public keys.</p>

    <p class="text-gray-300">In contrast, approach based on Spartan+KZH3-fold, eliminates the need for multiplicity vectors, making its communication cost independent of the number of recursive layers and the number of aggregators. The communication cost of our scheme is dominated by the participation bitfield, whereas the recursive proof itself is less than 40% of the overall size. Our signature aggregation augmented circuit is described in approximately  <span class="math">2^{19}</span>  constraints.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># of H</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># Constraints</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH2-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">1.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">103 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">74 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">17 ≈<br>2<br>131k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH3-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">0.87 s</td>

            <td class="px-3 py-2 border-b border-gray-700">62 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">16 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">17 ≈<br>2<br>131k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">157 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">250 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">35k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH2-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">4.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">133 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">148 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">19 ≈<br>2<br>524k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">150</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH3-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">3.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">63 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">25 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">19 ≈<br>2<br>524k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">447 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">704 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">9.6 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">165k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH2-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">7.2 s</td>

            <td class="px-3 py-2 border-b border-gray-700">193 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">197 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">20 ≈<br>2<br>1048k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1000</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH3-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">6.68 s</td>

            <td class="px-3 py-2 border-b border-gray-700">93 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">31 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">20 ≈<br>2<br>1048k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">2.0 s</td>

            <td class="px-3 py-2 border-b border-gray-700">3.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">42 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">675k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH2-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">23.1 s</td>

            <td class="px-3 py-2 border-b border-gray-700">256 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">295 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">21 ≈<br>2<br>2097k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2000</td>

            <td class="px-3 py-2 border-b border-gray-700">Spartan+KZH3-fold</td>

            <td class="px-3 py-2 border-b border-gray-700">16.5 s</td>

            <td class="px-3 py-2 border-b border-gray-700">135 ms</td>

            <td class="px-3 py-2 border-b border-gray-700">37 KB</td>

            <td class="px-3 py-2 border-b border-gray-700">21 ≈<br>2<br>2097k</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Nova</td>

            <td class="px-3 py-2 border-b border-gray-700">4.8 s</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6 s</td>

            <td class="px-3 py-2 border-b border-gray-700">80.8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1185k</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Comparison of IVC schemes Spartan+KZH2-fold, Spartan+KZH3-fold and Nova</p>

    <p class="text-gray-300"><span id="page-37-1"></span><span id="page-37-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># of validators</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Communication</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 1, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">512 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">338 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">340 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 32)</td>

            <td class="px-3 py-2 border-b border-gray-700">4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">342 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">205 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">226 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 1, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">1 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">669 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">4 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">670 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 32)</td>

            <td class="px-3 py-2 border-b border-gray-700">8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">673 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">333 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">276 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 1, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">2 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.29 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 16)</td>

            <td class="px-3 py-2 border-b border-gray-700">8 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS (r = 4, d = 32)</td>

            <td class="px-3 py-2 border-b border-gray-700">16 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 s</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Ours</td>

            <td class="px-3 py-2 border-b border-gray-700">589 kB</td>

            <td class="px-3 py-2 border-b border-gray-700">322 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Comparison of BLS and Spartan+KZH3-fold based accountable signature aggregation schemes</p>

    <p class="text-gray-300">We find that the witness for this circuit is low-weight (with about 33% of the entries being zero or one). As a result, committing to this low-weight witness is significantly more efficient compared to committing to a random vector of the same size. To exploit this property, we pair KZH3-fold with the Spartan PIOP, which only requires computing a single commitment to the witness vector. Table <a href="#page-37-0">6</a> highlights the communication and verification costs of both schemes across different validator counts and recursive layers. Our approach maintains consistent communication costs regardless of r, while BLS incurs significant growth due to the r · log d multiplicative factor.</p>

    <p class="text-gray-300">We would like to thank Alireza Shirzad and Yue Zhang for pointing out small mistakes in a previous version. We would like to thank anonymous reviewers who helped us to improve the paper. This work was supported by Chaincode, Alpen Labs, Google and the Sui Foundation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-39-0"></span>[CT10] Alessandro Chiesa and Eran Tromer. "Proof-Carrying Data and Hearsay Arguments from Signature Cards". In: 2010, pp. 310–331.</li>

      <li><span id="page-39-1"></span>[DG08] Jeffrey Dean and Sanjay Ghemawat. "MapReduce: simplified data processing on large clusters". In: Commun. ACM 51.1 (Jan. 2008), 107–113. issn: 0001- 0782. doi: <a href="https://doi.org/10.1145/1327452.1327492">10.1145/1327452.1327492</a>. url: <a href="https://doi.org/10.1145/1327452.1327492">https://doi.org/10.1145/</a> <a href="https://doi.org/10.1145/1327452.1327492">1327452.1327492</a>.</li>

      <li><span id="page-39-2"></span>[CTV15] Alessandro Chiesa, Eran Tromer, and Madars Virza. "Cluster Computing in Zero Knowledge". In: 2015, pp. 371–403. doi: <a href="https://doi.org/10.1007/978-3-662-46803-6_13">10.1007/978-3-662-46803-</a> <a href="https://doi.org/10.1007/978-3-662-46803-6_13">6\\\\_13</a>.</li>

      <li><span id="page-39-3"></span>[Her24] Polygon Hermez. Polygon zkevm: Recursion, aggregation and composition of proofs. <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf">https : / / github . com / 0xPolygonHermez / zkevm - techdocs / blob /</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf">main/docs/proof-recursion.pdf</a>. Accessed: 2024-11-15. 2024. url: <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf">https:</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf">/ / github . com / 0xPolygonHermez / zkevm - techdocs / blob / main / docs /</a> <a href="https://github.com/0xPolygonHermez/zkevm-techdocs/blob/main/docs/proof-recursion.pdf">proof-recursion.pdf</a>.</li>

      <li><span id="page-39-4"></span>[KB23] Assimakis Kattis and Joseph Bonneau. "Proof of Necessary Work: Succinct State Verification with Fairness Guarantees". In: 2023, pp. 18–35. doi: <a href="https://doi.org/10.1007/978-3-031-47751-5_2">10.</a> <a href="https://doi.org/10.1007/978-3-031-47751-5_2">1007/978-3-031-47751-5\\\\_2</a>.</li>

      <li><span id="page-39-5"></span>[Ben+14] Eli Ben-Sasson et al. "Scalable Zero Knowledge via Cycles of Elliptic Curves". In: 2014, pp. 276–294. doi: <a href="https://doi.org/10.1007/978-3-662-44381-1_16">10.1007/978-3-662-44381-1\\\\_16</a>.</li>

      <li><span id="page-39-6"></span>[KST22] Abhiram Kothapalli, Srinath Setty, and Ioanna Tzialla. "Nova: Recursive Zero-Knowledge Arguments from Folding Schemes". In: 2022, pp. 359–388. doi: <a href="https://doi.org/10.1007/978-3-031-15985-5_13">10.1007/978-3-031-15985-5\\\\_13</a>.</li>

      <li><span id="page-39-7"></span>[Bün+21] Benedikt Bünz et al. "Proof-Carrying Data Without Succinct Arguments". In: 2021, pp. 681–710. doi: <a href="https://doi.org/10.1007/978-3-030-84242-0_24">10.1007/978-3-030-84242-0\\\\_24</a>.</li>

      <li><span id="page-39-8"></span>[KS24] Abhiram Kothapalli and Srinath T. V. Setty. "HyperNova: Recursive Arguments for Customizable Constraint Systems". In: 2024, pp. 345–379. doi: <a href="https://doi.org/10.1007/978-3-031-68403-6_11">10.1007/978-3-031-68403-6\\\\_11</a>.</li>

      <li><span id="page-39-9"></span>[BC23] Benedikt Bünz and Binyi Chen. "Protostar: Generic Efficient Accumulation/Folding for Special-Sound Protocols". In: 2023, pp. 77–110. doi: <a href="https://doi.org/10.1007/978-981-99-8724-5_3">10.1007/978-981-</a> <a href="https://doi.org/10.1007/978-981-99-8724-5_3">99-8724-5\\\\_3</a>.</li>

      <li><span id="page-39-10"></span>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. "Constant-Size Commitments to Polynomials and Their Applications". In: 2010, pp. 177–194. doi: <a href="https://doi.org/10.1007/978-3-642-17373-8_11">10.1007/978-3-642-17373-8\\\\_11</a>.</li>

      <li><span id="page-39-11"></span>[Bün+20] Benedikt Bünz et al. "Recursive Proof Composition from Accumulation Schemes". In: 2020, pp. 1–18. doi: <a href="https://doi.org/10.1007/978-3-030-64378-2_1">10.1007/978-3-030-64378-2\\\\_1</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-40-0"></span>[Set20] Srinath Setty. "Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup". In: 2020, pp. 704–737. doi: <a href="https://doi.org/10.1007/978-3-030-56877-1_25">10.1007/978-3-030-56877-1\\\\_25</a>.</li>

      <li><span id="page-40-1"></span>[PST13] Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. "Signatures of Correct Computation". In: 2013, pp. 222–242. doi: <a href="https://doi.org/10.1007/978-3-642-36594-2_13">10.1007/978-3-642-</a> <a href="https://doi.org/10.1007/978-3-642-36594-2_13">36594-2\\\\_13</a>.</li>

      <li><span id="page-40-2"></span>[Lee21] Jonathan Lee. "Dory: Efficient, Transparent Arguments for Generalised Inner Products and Polynomial Commitments". In: 2021, pp. 1–34. doi: <a href="https://doi.org/10.1007/978-3-030-90453-1_1">10.1007/</a> <a href="https://doi.org/10.1007/978-3-030-90453-1_1">978-3-030-90453-1\\\\_1</a>.</li>

      <li><span id="page-40-3"></span>[Cam+25] Matteo Campanelli et al. On the Power of Polynomial Preprocessing: Proving Computations in Sublinear Time, and More. Cryptology ePrint Archive, Paper 2025/238. 2025. url: <https://eprint.iacr.org/2025/238>.</li>

      <li><span id="page-40-4"></span>[KS23a] Abhiram Kothapalli and Srinath Setty. CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Report 2023/1192. 2023. url: <https://eprint.iacr.org/2023/1192>.</li>

      <li><span id="page-40-5"></span>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. "Transparent SNARKs from DARK Compilers". In: 2020, pp. 677–706. doi: <a href="https://doi.org/10.1007/978-3-030-45721-1_24">10.1007/978-3-030-45721-</a> <a href="https://doi.org/10.1007/978-3-030-45721-1_24">1\\\\_24</a>.</li>

      <li><span id="page-40-6"></span>[KS23b] Abhiram Kothapalli and Srinath Setty. CycleFold: Folding-scheme-based recursive arguments over a cycle of elliptic curves. Cryptology ePrint Archive, Paper 2023/1192. 2023. url: <https://eprint.iacr.org/2023/1192>.</li>

      <li><span id="page-40-7"></span>[ZSC24] Jiaxing Zhao, Srinath Setty, and Weidong Cui. MicroNova: Folding-based arguments with efficient (on-chain) verification. Cryptology ePrint Archive, Paper 2024/2099. 2024. url: <https://eprint.iacr.org/2024/2099>.</li>

      <li><span id="page-40-8"></span>[Che+20] Weikeng Chen et al. Reducing Participation Costs via Incremental Verification for Ledger Systems. Cryptology ePrint Archive, Paper 2020/1522. 2020. url: <https://eprint.iacr.org/2020/1522>.</li>

      <li><span id="page-40-9"></span>[Bon+20] Joseph Bonneau et al. Coda: Decentralized Cryptocurrency at Scale. Cryptology ePrint Archive, Paper 2020/352. 2020. url: <a href="https://eprint.iacr.org/2020/352">https://eprint.iacr.org/</a> <a href="https://eprint.iacr.org/2020/352">2020/352</a>.</li>

      <li><span id="page-40-10"></span>[Tya+21] Nirvan Tyagi et al. VeRSA: Verifiable Registries with Efficient Client Audits from RSA Authenticated Dictionaries. Cryptology ePrint Archive, Paper 2021/627. 2021. doi: <a href="https://doi.org/10.1145/3548606.3560605">10.1145/3548606. 3560605</a>. url: <a href="https://eprint.iacr.org/2021/627">https://eprint.</a> <a href="https://eprint.iacr.org/2021/627">iacr.org/2021/627</a>.</li>

      <li><span id="page-40-11"></span>[Gro+18] Jens Groth et al. "Updatable and Universal Common Reference Strings with Applications to zk-SNARKs". In: 2018, pp. 698–728. doi: <a href="https://doi.org/10.1007/978-3-319-96878-0_24">10.1007/978- 3-</a> <a href="https://doi.org/10.1007/978-3-319-96878-0_24">319-96878-0\\\\_24</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-41-0"></span>[Resb] Ethereum Research. Sticking to 8192 Signatures per Slot Post-SSF: How and Why. <a href="https://ethresear.ch/t/sticking-to-8192-signatures-per-slot-post-ssf-how-and-why/">https : / / ethresear . ch / t / sticking - to - 8192 - signatures - per</a>  <a href="https://ethresear.ch/t/sticking-to-8192-signatures-per-slot-post-ssf-how-and-why/">slot-post-ssf-how-and-why/</a>. Accessed: 2024-11-15.</li>

      <li><span id="page-41-1"></span>[Sin] Single Slot Finality. <a href="https://ethereum.org/en/roadmap/single-slot-finality/">https : / /ethereum .org / en / roadmap / single - slot</a>  <a href="https://ethereum.org/en/roadmap/single-slot-finality/">finality/</a>. Accessed: 2024-11-15.</li>

      <li><span id="page-41-2"></span>[But] Vitalik Buterin. Possible futures of the Ethereum protocol, part 1: The Merge. <https://vitalik.eth.limo/general/2024/10/14/futures1.html>. Accessed: 2024-11-15.</li>

      <li><span id="page-41-3"></span>[D'A+24b] Francesco D'Amato et al. TOB-SVD: Total-Order Broadcast with Single-Vote Decisions in the Sleepy Model. 2024. arXiv: [2310.11331 \\[cs.DC\\]](https://arxiv.org/abs/2310.11331). url: <a href="https://arxiv.org/abs/2310.11331">https:</a> <a href="https://arxiv.org/abs/2310.11331">//arxiv.org/abs/2310.11331</a>.</li>

      <li><span id="page-41-4"></span>[DZ23] Francesco D'Amato and Luca Zanolini. A Simple Single Slot Finality Protocol For Ethereum. Cryptology ePrint Archive, Report 2023/280. 2023. url: <https://eprint.iacr.org/2023/280>.</li>

      <li><span id="page-41-5"></span>[D'A+24a] Francesco D'Amato et al. 3-Slot-Finality Protocol for Ethereum. 2024. arXiv: [2411.00558 \\[cs.DC\\]](https://arxiv.org/abs/2411.00558). url: <https://arxiv.org/abs/2411.00558>.</li>

      <li><span id="page-41-6"></span>[D'A+22] Francesco D'Amato et al. No More Attacks on Proof-of-Stake Ethereum? Cryptology ePrint Archive, Report 2022/1171. 2022. url: <a href="https://eprint.iacr.org/2022/1171">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2022/1171">org/2022/1171</a>.</li>

      <li><span id="page-41-7"></span>[Gil+17] Yossi Gilad et al. Algorand: Scaling Byzantine Agreements for Cryptocurrencies. Cryptology ePrint Archive, Report 2017/454. 2017. url: <a href="https://eprint.iacr.org/2017/454">https://</a> <a href="https://eprint.iacr.org/2017/454">eprint.iacr.org/2017/454</a>.</li>

      <li><span id="page-41-8"></span>[Yin+19] Maofan Yin et al. "HotStuff: BFT Consensus with Linearity and Responsiveness". In: 2019, pp. 347–356. doi: <a href="https://doi.org/10.1145/3293611.3331591">10.1145/3293611.3331591</a>.</li>

      <li><span id="page-41-9"></span>[BLS04] Dan Boneh, Ben Lynn, and Hovav Shacham. "Short Signatures from the Weil Pairing". In: 17.4 (Sept. 2004), pp. 297–319. doi: <a href="https://doi.org/10.1007/s00145-004-0314-9">10.1007/s00145-004-0314-</a> <a href="https://doi.org/10.1007/s00145-004-0314-9">9</a>.</li>

      <li><span id="page-41-10"></span>[BDN18] Dan Boneh, Manu Drijvers, and Gregory Neven. "Compact Multi-signatures for Smaller Blockchains". In: 2018, pp. 435–464. doi: <a href="https://doi.org/10.1007/978-3-030-03329-3_15">10.1007/978-3-030-</a> <a href="https://doi.org/10.1007/978-3-030-03329-3_15">03329-3\\\\_15</a>.</li>

      <li><span id="page-41-11"></span>[Resa] Ethereum Research. Signature Merging for Large-Scale Consensus. <a href="https://ethresear.ch/t/signature-merging-for-large-scale-consensus/17386">https://</a> <a href="https://ethresear.ch/t/signature-merging-for-large-scale-consensus/17386">ethresear.ch/t/signature-merging-for-large-scale-consensus/17386</a>. Accessed: 2024-11-15.</li>

      <li><span id="page-41-12"></span>[KS22] Abhiram Kothapalli and Srinath Setty. SuperNova: Proving universal machine executions without universal circuits. Cryptology ePrint Archive, Paper 2022/1758. 2022. url: <https://eprint.iacr.org/2022/1758>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-42-0"></span>[Zhe+23] Tianyu Zheng et al. KiloNova: Non-Uniform PCD with Zero-Knowledge Property from Generic Folding Schemes. Cryptology ePrint Archive, Paper 2023/1579. 2023. url: <https://eprint.iacr.org/2023/1579>.</li>

      <li><span id="page-42-1"></span>[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive Proof Composition without a Trusted Setup. Cryptology ePrint Archive, Report 2019/1021. 2019. url: <https://eprint.iacr.org/2019/1021>.</li>

      <li><span id="page-42-2"></span>[Wu+18] Howard Wu et al. DIZK: A Distributed Zero Knowledge Proof System. Cryptology ePrint Archive, Paper 2018/691. 2018. url: <a href="https://eprint.iacr.org/2018/691">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2018/691">org/2018/691</a>.</li>

      <li><span id="page-42-3"></span>[Liu+23] Tianyi Liu et al. Pianist: Scalable zkRollups via Fully Distributed Zero-Knowledge Proofs. Cryptology ePrint Archive, Paper 2023/1271. 2023. url: <a href="https://eprint.iacr.org/2023/1271">https://</a> <a href="https://eprint.iacr.org/2023/1271">eprint.iacr.org/2023/1271</a>.</li>

      <li><span id="page-42-4"></span>[Ros+24] Michael Rosenberg et al. Hekaton: Horizontally-Scalable zkSNARKs via Proof Aggregation. Cryptology ePrint Archive, Paper 2024/1208. 2024. url: <a href="https://eprint.iacr.org/2024/1208">https:</a> <a href="https://eprint.iacr.org/2024/1208">//eprint.iacr.org/2024/1208</a>.</li>

      <li><span id="page-42-5"></span>[Wan+24] Wenhao Wang et al. Cirrus: Performant and Accountable Distributed SNARK. Cryptology ePrint Archive, Paper 2024/1873. 2024. url: <a href="https://eprint.iacr.org/2024/1873">https://eprint.</a> <a href="https://eprint.iacr.org/2024/1873">iacr.org/2024/1873</a>.</li>

      <li><span id="page-42-6"></span>[Bé+19] Olivier Bégassat et al. Handel: Practical Multi-Signature Aggregation for Large Byzantine Committees. 2019. arXiv: [1906 . 05132 \\[cs.DC\\]](https://arxiv.org/abs/1906.05132). url: <a href="https://arxiv.org/abs/1906.05132">https : / /</a> <a href="https://arxiv.org/abs/1906.05132">arxiv.org/abs/1906.05132</a>.</li>

      <li><span id="page-42-7"></span>[Kha+21] Irakliy Khaburzaniya et al. Aggregating hash-based signatures using STARKs. Cryptology ePrint Archive, Report 2021/1048. 2021. url: <a href="https://eprint.iacr.org/2021/1048">https://eprint.</a> <a href="https://eprint.iacr.org/2021/1048">iacr.org/2021/1048</a>.</li>

      <li><span id="page-42-8"></span>[Aar+24] Marius A. Aardal et al. "Aggregating Falcon Signatures with LaBRADOR". In: 2024, pp. 71–106. doi: <a href="https://doi.org/10.1007/978-3-031-68376-3_3">10.1007/978-3-031-68376-3\\\\_3</a>.</li>

      <li><span id="page-42-9"></span>[Wah+18] Riad S. Wahby et al. "Doubly-Efficient zkSNARKs Without Trusted Setup". In: 2018, pp. 926–943. doi: <a href="https://doi.org/10.1109/SP.2018.00060">10.1109/SP.2018.00060</a>.</li>

      <li><span id="page-42-10"></span>[Ped92] Torben P. Pedersen. "Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing". In: 1992, pp. 129–140. doi: <a href="https://doi.org/10.1007/3-540-46766-1_9">10.1007/3-540-46766-1\\\\_9</a>.</li>

      <li><span id="page-42-11"></span>[Abe+16] Masayuki Abe et al. "Structure-Preserving Signatures and Commitments to Group Elements". In: 29.2 (Apr. 2016), pp. 363–421. doi: <a href="https://doi.org/10.1007/s00145-014-9196-7">10.1007/s00145-</a> <a href="https://doi.org/10.1007/s00145-014-9196-7">014-9196-7</a>.</li>

      <li><span id="page-42-12"></span>[Che+23] Binyi Chen et al. "HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates". In: 2023, pp. 499–530. doi: <a href="https://doi.org/10.1007/978-3-031-30617-4_17">10.1007/978- 3- 031-</a> <a href="https://doi.org/10.1007/978-3-031-30617-4_17">30617-4\\\\_17</a>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-43-0"></span>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, Paper 2023/552. 2023. url: <https://eprint.iacr.org/2023/552>.</li>

      <li><span id="page-43-1"></span>[FKL18] Georg Fuchsbauer, Eike Kiltz, and Julian Loss. "The Algebraic Group Model and its Applications". In: 2018, pp. 33–62. doi: <a href="https://doi.org/10.1007/978-3-319-96881-0_2">10.1007/978-3-319-96881-</a> <a href="https://doi.org/10.1007/978-3-319-96881-0_2">0\\\\_2</a>.</li>

      <li><span id="page-43-2"></span>[Bü+19] Benedikt Bünz et al. Proofs for Inner Pairing Products and Applications. Cryptology ePrint Archive, Paper 2019/1177. 2019. url: <a href="https://eprint.iacr.org/2019/1177">https://eprint.iacr.</a> <a href="https://eprint.iacr.org/2019/1177">org/2019/1177</a>.</li>

      <li><span id="page-43-3"></span>[Haf+25] Hossein Hafezi et al. IronDict: Transparent Dictionaries from Polynomial Commitments. Cryptology ePrint Archive, Paper 2025/1580. 2025. url: <a href="https://eprint.iacr.org/2025/1580">https:</a> <a href="https://eprint.iacr.org/2025/1580">//eprint.iacr.org/2025/1580</a>.</li>

      <li><span id="page-43-4"></span>[DRZ20] Vanesa Daza, Carla Ràfols, and Alexandros Zacharakis. "Updateable Inner Product Argument with Logarithmic Verifier and Applications". In: 2020, pp. 527–557. doi: <a href="https://doi.org/10.1007/978-3-030-45374-9_18">10.1007/978-3-030-45374-9\\\\_18</a>.</li>

      <li><span id="page-43-5"></span>[BFL20] Balthazar Bauer, Georg Fuchsbauer, and Julian Loss. "A Classification of Computational Assumptions in the Algebraic Group Model". In: 2020, pp. 121– 151. doi: <a href="https://doi.org/10.1007/978-3-030-56880-1_5">10.1007/978-3-030-56880-1\\\\_5</a>.</li>

      <li><span id="page-43-6"></span>[GNS24] Chaya Ganesh, Vineet Nair, and Ashish Sharma. Dual Polynomial Commitment Schemes and Applications to Commit-and-Prove SNARKs. Cryptology ePrint Archive, Paper 2024/943. 2024. url: <a href="https://eprint.iacr.org/2024/943">https : / / eprint . iacr . org /</a> <a href="https://eprint.iacr.org/2024/943">2024/943</a>.</li>

      <li><span id="page-43-7"></span>[KS23c] Abhiram Kothapalli and Srinath Setty. HyperNova: Recursive arguments for customizable constraint systems. Cryptology ePrint Archive, Paper 2023/573. 2023. url: <https://eprint.iacr.org/2023/573>.</li>

      <li><span id="page-43-8"></span>[Lun+90] Carsten Lund et al. "Algebraic Methods for Interactive Proof Systems". In: 1990, pp. 2–10. doi: <a href="https://doi.org/10.1109/FSCS.1990.89518">10.1109/FSCS.1990.89518</a>.</li>

      <li><span id="page-43-9"></span>[Ova] Ova: A slightly better Nova. <https://hackmd.io/V4838nnlRKal9ZiTHiGYzw>. Accessed: 2024-11-15.</li>

      <li><span id="page-43-10"></span>[Bon+21] Dan Boneh et al. "Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments". In: 2021, pp. 649–680. doi: <a href="https://doi.org/10.1007/978-3-030-84242-0_23">10.1007/978-3-030-84242-</a> <a href="https://doi.org/10.1007/978-3-030-84242-0_23">0\\\\_23</a>.</li>

      <li><span id="page-43-11"></span>[Blu+91] M. Blum et al. "Checking the correctness of memories". In: [1991] Proceedings 32nd Annual Symposium of Foundations of Computer Science. 1991, pp. 90– 99. doi: <a href="https://doi.org/10.1109/SFCS.1991.185352">10.1109/SFCS.1991.185352</a>.</li>

    </ul>

    <p class="text-gray-300"><span id="page-44-2"></span><strong>Definition 4.</strong> A signature scheme is parametrized by a message space  <span class="math">\\mathcal{M}</span>  and consists on a tuple of PPT algorithms (KGen<sub>ss</sub>, Sign<sub>ss</sub>, Verify<sub>ss</sub>) such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{KGen}_{\\mathsf{ss}}(n) \\to (\\mathsf{sk}, \\mathsf{pk})</span> : On input security parameter n, outputs public parameters  <span class="math">\\mathsf{pp}</span> , signing key  <span class="math">\\mathsf{pk}</span>  and verification key  <span class="math">\\mathsf{pk}</span> .</li>

      <li><span class="math">\\mathsf{Sign}_{\\mathsf{ss}}(\\mathsf{sk}, m) \\to \\sigma_m</span> : On input  <span class="math">\\mathsf{sk}</span>  and  <span class="math">m \\in \\mathcal{M}</span> , outputs a signature  <span class="math">\\sigma_M</span>  on M.</li>

      <li>Verify<sub>ss</sub>(pk, m,  <span class="math">\\sigma_m</span> )  <span class="math">\\rightarrow 0/1</span> : takes as input pk, m and signature  <span class="math">\\sigma_m</span>  and produces a bit expressing acceptance (1), or rejection (0);</li>

    </ul>

    <p class="text-gray-300"> <span class="math">That \\ must \\ satisfy \\ correctness \\ and \\ unforgeability:</span></p>

    <p class="text-gray-300"><strong>Correctness.</strong> For all  <span class="math">m \\in \\mathcal{M}</span>  the following holds:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c} \\mathsf{Verify_{ss}}(\\mathsf{pk}, m, \\sigma_m) = 1 & \\left(\\begin{array}{c} (\\mathsf{pk}, \\mathsf{sk}) \\leftarrow \\mathsf{KGen_{ss}}(n) \\\\ \\sigma_m \\leftarrow \\mathsf{Sign_{ss}}(\\mathsf{sk}, m) \\end{array}\\right] = 1$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Unforgeability.</strong> For all PPT adversaries A, the following probability is negligible:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr\\left[\\begin{array}{c} (m,\\sigma_m) \\notin \\mathcal{Q} \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{c} (\\mathsf{pk},\\mathsf{pk}) \\leftarrow \\mathsf{KGen_{ss}}(n) \\\\ (m,\\sigma_m) \\leftarrow \\mathcal{A}^{\\mathcal{O}}(\\mathsf{pk},\\mathsf{sk}) \\\\ \\mathsf{Verify_{ss}}(\\mathsf{pk},m,\\sigma_m) = 1 \\end{array}\\right]$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where Q is a list of all the queries A makes to the signing oracle O.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">B.1 Proof of theorem 3</h4>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. The commitment C to  <span class="math">f(\\vec{X})</span>  is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x}, \\vec{y}) \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}.</span></div>

    <p class="text-gray-300">Since nm=k, this can be computed from the structured reference string (srs). The opening proof  <span class="math">\\pi</span>  for  <span class="math">(\\vec{x}_0,\\vec{y}_0)</span>  is defined as:  <span class="math">\\pi=\\left(f^<em>(\\vec{Y}), \\mathsf{aux}=\\{\\mathsf{D}^{(\\vec{x})}\\}_{\\vec{x}\\in B_n}\\right)</span> , where  <span class="math">f^</em>(\\vec{Y})=f(\\vec{x}_0,\\vec{Y})</span> , and  <span class="math">\\mathsf{D}^{(\\vec{x})}=\\sum_{\\vec{y}\\in B_m}f(\\vec{x},\\vec{y})\\times\\mathsf{H}^{(\\vec{y})}</span> . We see that  <span class="math">\\mathsf{Verify}_{\\mathsf{KZH}}(\\mathsf{C},(\\vec{x}_0,\\vec{y}_0),\\pi)=1</span> :</p>

    <p class="text-gray-300">(I) Check that  <span class="math">e(\\mathsf{C},\\mathsf{V}&#x27;) = \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})})</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} e(\\mathsf{C},\\mathsf{V}&#x27;) &amp;\\stackrel{(1)}{=} e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(2)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\cdot \\tau^{(\\vec{x})} \\times \\mathsf{G}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(3)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\cdot \\alpha \\times \\mathsf{G}^{(\\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;\\stackrel{(4)}{=} \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} f(\\vec{x},\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}, \\mathsf{V}^{(\\vec{x})}) \\\\ &amp;\\stackrel{(5)}{=} \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\end{split}</span></div>

    <p class="text-gray-300">(1) and (2) is exploding terms  <span class="math">\\mathsf{C},\\mathsf{H}^{(\\vec{x},\\vec{y})},\\mathsf{V}&#x27;</span>  and using the bilinearity property, (3) is using property  <span class="math">e(g^a,g^b)=e(g^b,g^a)</span>  by interchanging the exponents  <span class="math">\\alpha</span>  and  <span class="math">\\tau^{(\\vec{x})}</span> . (4) is replaying  <span class="math">\\alpha\\times\\mathsf{G}^{(\\vec{y})}</span>  with the equivalent value  <span class="math">\\mathsf{H}^{(\\vec{y})}</span>  and finally (5) follows from the definition of  <span class="math">\\mathsf{D}^{(\\vec{x})}</span> .</p>

    <p class="text-gray-300">(II) Check that <span class="math-block">\\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\times \\mathsf{D}^{(\\vec{x})}.</span></p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}) \\times \\mathsf{D}^{(\\vec{x})} \\stackrel{(1)}{=} \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\cdot f(\\vec{x}, \\, \\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(2)}{=} \\sum_{\\vec{y} \\in B_m} \\left( \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\, \\vec{x}_0) \\cdot f(\\vec{x}, \\, \\vec{y}) \\right) \\times \\mathsf{H}^{(\\vec{y})}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(3)}{=} \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}</span></div>

    <p class="text-gray-300">Finally, (III) checking that  <span class="math">f^*(\\vec{y_0}) = z_0</span> , follows from the definition of  <span class="math">z_0</span> .</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PPT adversary that, on input srs outputs a commitment  <span class="math">\\mathsf{C}</span> . We define an extractor  <span class="math">\\mathcal{E}</span>  that outputs  <span class="math">p(\\vec{X},\\vec{Y})</span>  such that, for any  <span class="math">((\\vec{x}_0,\\vec{y}_0),z_0,\\pi)</span> , if the verifier accepts then  <span class="math">p(\\vec{x}_0,\\vec{y}_0)=z_0</span>  with overwhelming probability. Given  <span class="math">\\mathsf{C}</span>  and  <span class="math">\\{c_{\\vec{x},\\vec{y}},\\hat{c}_{\\vec{y}}\\}_{\\vec{x}\\in B_n,\\vec{y}\\in B_m}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})} + \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})},</span></div>

    <p class="text-gray-300"> <span class="math">\\mathcal{E}</span>  outputs  <span class="math">f(\\vec{X}, \\vec{Y}) = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\vec{X}^{\\vec{x}} \\vec{Y}^{\\vec{y}}</span> . Under the AGM,  <span class="math">\\mathcal{E}</span>  does not abort. Similarly, under the AGM we have that all the  <span class="math">\\mathsf{D}^{(\\vec{x})}</span>  are represented as a linear combination of the srs elements, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{D}^{(\\vec{x})} = \\sum_{\\vec{y} \\in B_m} d_{\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\hat{d}_{\\vec{x},\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}</span></div>

    <p class="text-gray-300">The following conditions are satisfied:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\text{(I)} \\ &amp; e(\\mathsf{C},\\mathsf{V}&#x27;) = \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})}), \\, \\text{we first consider each side separately:} \\\\ &amp; e(\\mathsf{C},\\mathsf{V}&#x27;) = e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})} + \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp; = e(\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\times \\mathsf{H}^{(\\vec{x},\\vec{y})}, \\alpha \\times \\mathsf{V}) + e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}}(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})}, \\alpha \\times \\mathsf{V}) \\\\ &amp; = \\alpha \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x},\\vec{y}} \\cdot \\tau^{(\\vec{x})} \\times e(\\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) + \\alpha^2 \\times e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\times \\mathsf{H}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} e(\\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\cdot \\alpha \\times \\mathsf{G}^{(\\vec{y})} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\cdot \\tau^{(\\vec{x})} \\times \\mathsf{G}^{(\\vec{y})}, \\tau^{(\\vec{x})} \\times \\mathsf{V}) \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} \\tau^{(\\vec{x})} \\cdot \\left(\\alpha \\cdot \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} + \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{x}, \\vec{y}} \\cdot \\tau^{(\\vec{x})}\\right) \\times e(G^{(\\vec{y})}, \\mathsf{V}) \\end{split}</span></div>

    <p class="text-gray-300">Now the difference  <span class="math">e(\\mathsf{C},\\mathsf{V}&#x27;) - \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})})</span>  can be seen as degree 2 polynomial of  <span class="math">\\alpha</span> , then the coefficients of 1,  <span class="math">\\alpha</span> ,  <span class="math">\\alpha^2</span>  on the two terms are equal or we can break quadratic CDH, which implies:</p>

    <p class="text-gray-300">• Coefficient 1.</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\hat{d}_{\\vec{x}, \\vec{y}}^{(\\vec{x})} \\cdot \\tau^{(\\vec{x})} \\times e(G^{(\\vec{y})}, \\mathsf{V}) = 0 \\implies \\sum_{\\vec{x}, \\vec{y}} \\hat{d}_{\\vec{x}, \\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{x}, \\vec{y})} = 0</span></div>

    <p class="text-gray-300">This implies  <span class="math">\\hat{d}_{\\vec{x},\\vec{y}}^{(\\vec{x})} = 0</span>  for all  <span class="math">\\vec{x}, \\vec{y}</span> , or we found a multivariate polynomial that vanishes at  <span class="math">\\mathsf{H}^{(\\vec{x},\\vec{y})}</span>  and thus break the setup-find-rep assumption.</p>

    <p class="text-gray-300">• Coefficient  <span class="math">\\alpha</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} \\tau^{(\\vec{x})} \\cdot c_{\\vec{x}, \\vec{y}} \\times e(G^{(\\vec{y})}, \\mathsf{V}) = \\sum_{\\vec{x} \\in B_n} \\tau^{(\\vec{x})} \\cdot \\sum_{\\vec{y} \\in B_m} d^{(\\vec{x})}_{\\vec{y}} \\times e(G^{(\\vec{y})}, \\mathsf{V})</span></div>

    <p class="text-gray-300">Then we have that  <span class="math">c_{\\vec{x},\\vec{y}} = d_{\\vec{y}}^{(\\vec{x})}</span>  for all  <span class="math">\\vec{x},\\vec{y}</span>  or we can break the find-rep assumption as above.</p>

    <p class="text-gray-300">• Coefficient  <span class="math">\\alpha^2</span> .</p>

    <div class="my-4 text-center"><span class="math-block">e(\\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})}, \\mathsf{V}) = 0 \\implies \\sum_{\\vec{y} \\in B_m} \\hat{c}_{\\vec{y}} \\times \\mathsf{G}^{(\\vec{y})} = 0</span></div>

    <p class="text-gray-300">We then have:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{C} = \\sum_{\\vec{x} \\in B_n} \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{x}, \\, \\vec{y})}, \\quad \\mathsf{D}^{(\\vec{x})} = \\sum_{\\vec{y} \\in B_m} d_{\\vec{y}}^{(\\vec{x})} \\times \\mathsf{H}^{(\\vec{y})}</span></div>

    <p class="text-gray-300">(II) <span class="math-block">\\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{x} \\in B_n} \\mathsf{eq}(\\vec{x}, \\vec{x}_0) \\times \\mathsf{D}^{(\\vec{x})}</span> , we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathbf{H}^{(\\vec{y})} &amp;= \\sum_{\\vec{x} \\in B_n} \\operatorname{eq}(\\vec{x}, \\, \\vec{x_0}) \\times \\mathbf{D}^{(\\vec{x})} \\\\ &amp;= \\sum_{\\vec{x} \\in B_n} \\operatorname{eq}(\\vec{x}, \\, \\vec{x_0}) \\times \\sum_{\\vec{y} \\in B_m} c_{\\vec{x}, \\vec{y}} \\times \\mathbf{H}^{(\\vec{y})} \\\\ &amp;= \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\times \\mathbf{H}^{(\\vec{y})} \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\implies \\sum_{\\vec{y} \\in B_m} f^*(\\vec{y}) \\times \\mathsf{H}^{(\\vec{y})} = \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\times \\mathsf{H}^{(\\vec{y})}</span></div>

    <p class="text-gray-300">Now note that:</p>

    <div class="my-4 text-center"><span class="math-block">f^*(\\vec{y}) = \\sum_{\\vec{y} \\in B_m} c_{\\vec{x_0}, \\vec{y}} \\mathsf{H}^{(\\vec{x}_0, \\vec{y})} = f(\\vec{x}_0, \\vec{Y})</span></div>

    <p class="text-gray-300">or we can break the (1,1) – dlog assumption by finding the roots of</p>

    <div class="my-4 text-center"><span class="math-block">P(Y) = \\sum_{\\vec{y} \\in B_m} (f^*(\\vec{y}) - c_{\\vec{x_0}, \\vec{y}}) \\times (Y \\times \\mathsf{G}^{(\\vec{y})})</span></div>

    <p class="text-gray-300">and give trapdoor  <span class="math">\\alpha</span>  as output. Finally, the extractor outputs polynomial  <span class="math">f(\\vec{x}, \\vec{y})</span> . Since  <span class="math">f^*(\\vec{y}_0) = z_0</span> , and C commits to  <span class="math">f(\\vec{x}, \\vec{y})</span> , we have the construction is knowledge sound.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">B.2 Proof of theorem 4</h4>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Consider the following two satisfying accumulators:</p>

    <p class="text-gray-300">• acc. <span class="math-block">x_1 = \\{C_1, T_1, E_1, \\vec{x}_1, \\vec{y}_1, z_1\\}</span></p>

    <p class="text-gray-300">• <span class="math-block">\\operatorname{acc.} w_1 = \\{ [\\mathsf{D}_1^{(\\vec{i})}]_{\\vec{i} \\in B_n}, \\vec{f_1^*}, \\, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)} \\}</span></p>

    <p class="text-gray-300">• acc. <span class="math-block">x_2 = \\{C_2, T_2, E_2, \\vec{x}_2, \\vec{y}_2, z_2\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\bullet \\ \\text{acc.} w_2 = \\{ [\\mathsf{D}_2^{(\\vec{i})}]_{\\vec{i} \\in B_n}, \\vec{f_2}^*, \\, \\mathcal{T}_x{}^{(2)}, \\mathcal{T}_y{}^{(2)} \\}</span></div>

    <p class="text-gray-300">As they are valid accumulators, the following hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\bullet & \\quad -\\sum_{i=0}^n e(\\mathsf{D}_1^{(i)},\\mathsf{V}_i) = e(\\mathsf{C}_1,\\mathsf{V}) \\\\ & \\quad - \\langle (\\mathcal{T}_x^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_y^{(1)}), \\vec{\\mathsf{K}} \\rangle = T_1 \\\\ & \\quad - E_1 = \\mathsf{Dec}(\\vec{x_1},\\vec{y_1},z_1,\\vec{f_1^*},\\mathcal{T}_x^{(1)},\\mathcal{T}_y^{(1)},\\vec{\\mathsf{D}_1}) \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\bullet & \\quad -\\sum_{i=0}^n e(\\mathsf{D}_2^{(i)},\\mathsf{V}_i) = e(\\mathsf{C}_2,\\mathsf{V}) \\\\ & \\quad - \\langle (\\mathcal{T}_x^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_y^{(2)}), \\vec{\\mathsf{K}} \\rangle = T_2 \\\\ & \\quad - E_2 = \\mathsf{Dec}(\\vec{x_2},\\vec{y_2},z_2,\\vec{f_2^*},\\mathcal{T}_x^{(2)},\\mathcal{T}_y^{(2)},\\vec{\\mathsf{D}_2}) \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now let acc.x, acc.w be the accumulated instance/witness computed as follows.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp; \\mathsf{acc.} x \\leftarrow ((1-\\beta) \\cdot [\\mathsf{C}_1, T_1, \\vec{x_1}, \\vec{y_1}, z_1] + \\beta \\cdot [\\mathsf{C}_2, T_2,, \\vec{x_2}, \\vec{y_2}, z_2]), \\ \\mathsf{E} \\\\ &amp; \\mathsf{acc.} w \\leftarrow (1-\\beta) \\cdot [\\vec{\\mathsf{D}}_1, \\vec{f}_1^*, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)}] + \\beta \\cdot [\\vec{\\mathsf{D}}_2, \\vec{f}_2^*, \\mathcal{T}_x^{(2)}, \\mathcal{T}_y^{(2)}], \\ \\mathsf{E} \\end{aligned}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathsf{E} \\leftarrow (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q}</span> . Below, we show acc is also a satisfying accumulator:</p>

    <p class="text-gray-300">• First condition</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{n} e(\\mathsf{D}^{(i)}, \\mathsf{V}_i) \\stackrel{(1)}{=} \\sum_{i=0}^{n} e\\left((1-\\beta) \\times \\mathsf{D}_1^{(i)} + \\beta \\times \\mathsf{D}_2^{(i)}, \\mathsf{V}_i\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(2)}{=} (1-\\beta) \\times \\sum_{i=0}^{n} e(\\mathsf{D}_1^{(i)}, \\mathsf{V}_i) + \\beta \\times \\sum_{i=0}^{n} e(\\mathsf{D}_2^{(i)}, \\mathsf{V}_i)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(3)}{=} (1-\\beta) \\times e(\\mathsf{C}_1, \\mathsf{V}) + \\beta \\times e(\\mathsf{C}_2, \\mathsf{V})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(4)}{=} e\\left((1-\\beta) \\times \\mathsf{C}_1 + \\beta \\times \\mathsf{C}_2, \\mathsf{V}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(5)}{=} e(\\mathsf{C}, \\mathsf{V})</span></div>

    <p class="text-gray-300">Where (1) holds by expanding  <span class="math">D^{(i)}</span>  terms, (2), (4) because of bilinearity property, (3) holds because the first condition was satisfied for the underlying instances, and finally (5) holds because of the definition of C.</p>

    <p class="text-gray-300">• Second condition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\langle (\\mathcal{T}_{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}), \\vec{\\mathsf{K}} \\rangle \\stackrel{(1)}{=} \\left\\langle (1-\\beta) \\cdot (\\mathcal{T}_{x}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(1)}) + \\beta \\cdot (\\mathcal{T}_{x}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(2)}), \\vec{\\mathsf{K}} \\right\\rangle$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\stackrel{(2)}{=} (1-\\beta) \\cdot \\left\\langle \\mathcal{T}_{x}^{(1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(1)}, \\vec{\\mathsf{K}} \\right\\rangle + \\beta \\cdot \\left\\langle \\mathcal{T}_{x}^{(2)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(2)}, \\vec{\\mathsf{K}} \\right\\rangle$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(3)}{=} (1-\\beta) \\times T_{2} + \\beta \\times T_{2}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\stackrel{(4)}{=} T</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(1) holds by definition, whereas (2) is implied by bilinearity of the inner product. (3) and (4) follow by definition.</li>

      <li>Third condition.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{Dec}(\\vec{x}, \\vec{y}, z, \\vec{f}^*, \\mathcal{T}_x, \\mathcal{T}_y, \\vec{\\mathsf{D}}) &amp; \\stackrel{(1)}{=} \\mathsf{Dec}((1 - \\beta) \\cdot [\\vec{x_1}, \\vec{y_1}, z_1, \\vec{f_1}^*, \\mathcal{T}_x^{(1)}, \\mathcal{T}_y^{(1)}, \\vec{\\mathsf{D}_1}] \\\\ &amp; + \\beta \\cdot [\\vec{x_2}, \\vec{y_2}, z_2, \\vec{f_2}^*, \\mathcal{T}_x^{(2)}, \\mathcal{T}_y^{(2)}, \\vec{\\mathsf{D}_2}]) \\\\ &amp; \\stackrel{(2)}{=} (1 - \\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1 - \\beta) \\cdot \\beta \\times \\mathsf{Q} \\\\ &amp; \\stackrel{(3)}{=} \\mathsf{E} \\end{split}</span></div>

    <p class="text-gray-300">by definition of E.</p>

    <p class="text-gray-300">Knowledge soundness. Consider an adversary  <span class="math">\\mathcal{A}</span>  that outputs  <span class="math">\\hat{\\pi} = (\\pi.x, \\pi.w)</span> , acc = (acc.x, acc.w),  <span class="math">\\hat{\\mathsf{pf}} \\in \\mathbb{G}_1</span>  and acc<sub>1</sub>.x, acc<sub>2</sub>.x. We build an extractor  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  that if  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  accept, extracts valid witnesses  <span class="math">\\mathsf{acc}_1.w</span> ,  <span class="math">\\mathsf{acc}_2.w</span>  for  <span class="math">\\mathsf{acc}_1.x</span> ,  <span class="math">\\mathsf{acc}_2.x</span> . Since  <span class="math">\\mathsf{acc}.w</span>  is an equation of degree one, given two accepting transcripts for different challenges  <span class="math">\\beta_1, \\beta_2</span> ,  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  can use the Vandermonde matrix to extract</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp; \\mathsf{acc}_1.w = (\\{\\mathsf{D}_1^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_1^*, \\mathcal{T}_1^{(x)}, \\mathcal{T}_1^{(y)}), \\\\ &amp; \\mathsf{acc}_2.w = (\\{\\mathsf{D}_2^{(\\vec{x})}\\}_{\\vec{x} \\in B_n}, \\vec{f}_2^*, \\mathcal{T}_2^{(x)}, \\mathcal{T}_2^{(y)}). \\end{split}</span></div>

    <p class="text-gray-300">We now prove that the extracted witnesses are valid. First, note that since the verifier accepts,  <span class="math">E = (1 - \\beta) \\times E_1 + \\beta \\times E_2 + (1 - \\beta) \\cdot \\beta \\times Q</span>  and</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathsf{C}, T, \\vec{x}, \\vec{y}, z) = (1 - \\beta) \\cdot (\\mathsf{C}_1, T_1, \\vec{x}_1, \\vec{y}_1, z_1) + \\beta \\cdot (\\mathsf{C}_2, T_2, \\vec{x}_2, \\vec{y}_2, z_2)</span></div>

    <p class="text-gray-300">The left side of Eq.(i) of the decider is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp; \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = \\sum_{\\vec{x} \\in B_n} e\\Big((1-\\beta) \\times \\mathsf{D}_1^{(\\vec{x})} + \\beta \\times \\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}\\Big) \\\\ &amp; = (1-\\beta) \\times \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) + \\beta \\times \\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) \\end{split}</span></div>

    <p class="text-gray-300">Whereas the right side equals</p>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{C},\\mathsf{V}) = e((1-\\beta) \\times \\mathsf{C}_1 + \\beta \\times \\mathsf{C}_2,\\mathsf{V}) = (1-\\beta) \\times e(\\mathsf{C}_1,\\mathsf{V}) + \\beta \\times e(\\mathsf{C}_2,\\mathsf{V})</span></div>

    <p class="text-gray-300">Since  <span class="math">\\beta</span>  is computed as a hash of  <span class="math">\\mathsf{acc}_1.x</span>  and  <span class="math">\\mathsf{acc}_2.x</span> , except with negligible probability  <span class="math">\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_1, \\mathsf{V})</span>  and</p>

    <p class="text-gray-300"><span class="math-block">\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_2^{(\\vec{x})}, \\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_2, \\mathsf{V})</span> . Similarly, Eq.(ii) holds if and only if</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\left( (1-\\beta)\\mathcal{T}_{1}^{(x)} + \\beta\\mathcal{T}_{2}^{(x)} \\parallel (1-\\beta)\\mathcal{T}_{1}^{(y)} + \\beta\\mathcal{T}_{2}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle</span></div>

    <div class="my-4 text-center"><span class="math-block">= (1-\\beta)\\langle \\left( \\mathcal{T}_{1}^{(x)} \\parallel \\mathcal{T}_{1}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle + \\beta\\langle \\left( \\mathcal{T}_{2}^{(x)} \\parallel \\mathcal{T}_{2}^{(y)} \\right), \\vec{\\mathsf{K}} \\rangle</span></div>

    <div class="my-4 text-center"><span class="math-block">= (1-\\beta)T_{1} + \\beta T_{2}</span></div>

    <div class="my-4 text-center"><span class="math-block">= T.</span></div>

    <p class="text-gray-300">Thus the equation holds for  <span class="math">acc_1.w</span>  and  <span class="math">acc_2.w</span> . Finally, replacing the accumulation witness by the extracted ones, we have that Eq.(iii) is</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp; \\mathsf{Dec}((1-\\beta)\\vec{x}_1 + \\beta\\vec{x}_2, (1-\\beta)\\vec{y}_1 + \\beta\\vec{y}_2, (1-\\beta)z_1 + \\beta z_2, (1-\\beta)\\vec{f}_1^* + \\beta\\vec{f}_2^*, \\\\ &amp; (1-\\beta)\\mathcal{T}_{x,1} + \\beta\\mathcal{T}_{x,2}, (1-\\beta)\\mathcal{T}_{y,1} + \\beta\\mathcal{T}_{y,2}, (1-\\beta)\\vec{D}_1 + \\beta\\vec{D}_2) \\\\ &amp; = (1-\\beta) \\times \\mathsf{E}_1 + \\beta \\times \\mathsf{E}_2 + (1-\\beta)\\beta \\times \\mathsf{Q} \\end{aligned}</span></div>

    <p class="text-gray-300">The left side of the equation equals</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\left\\langle \\mathcal{T}_{x}^{(\\mathrm{err})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(\\mathrm{err})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{f}^{*}, \\mathcal{T}_{\\mathrm{leaves}}^{(y)} \\rangle - z, \\vec{\\mathsf{K}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{K}' \\right\\rangle + \\langle \\vec{f}^{*}, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_{n}} \\rangle - \\langle \\mathcal{T}_{\\mathrm{leaves}}^{(x)}, \\vec{\\mathsf{D}} \\rangle.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{T}_{x}^{(\\text{err})} := (1 - \\beta)\\mathcal{T}_{x_{1}}^{(\\text{error})} + \\beta\\mathcal{T}_{x_{2}}^{(\\text{error})}, \\quad \\mathcal{T}_{y}^{(\\text{err})} := (1 - \\beta)\\mathcal{T}_{y_{1}}^{(\\text{error})} + \\beta\\mathcal{T}_{y_{2}}^{(\\text{error})},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vec{f}^{*} := (1 - \\beta)\\vec{f}_{1}^{*} + \\beta\\vec{f}_{2}^{*}, \\quad \\mathcal{T}_{\\text{leaves}}^{(y)} := (1 - \\beta)\\mathcal{T}^{(y_{1})}.\\text{leaves} + \\beta\\mathcal{T}^{(y_{2})}.\\text{leaves},</span></div>

    <div class="my-4 text-center"><span class="math-block">z := (1 - \\beta)z_{1} + \\beta z_{2}, \\quad \\mathcal{T}_{\\text{leaves}}^{(x)} := (1 - \\beta)\\mathcal{T}^{(x_{1})}.\\text{leaves} + \\beta\\mathcal{T}^{(x_{2})}.\\text{leaves},</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vec{\\mathsf{D}} := (1 - \\beta)\\vec{\\mathsf{D}}_{1} + \\beta\\vec{\\mathsf{D}}_{2}.</span></div>

    <p class="text-gray-300">Term  <span class="math">\\beta</span>  contains equation (iii) of the Decider for  <span class="math">\\operatorname{acc}_1</span> , whereas term  <span class="math">\\beta(1-\\beta)</span>  contains the one for  <span class="math">\\operatorname{acc}_2</span> . Cross terms are in the coefficient of  <span class="math">\\beta(1-\\beta)</span> . Then, except with negligible probability,  <span class="math">\\operatorname{D}_{\\operatorname{acc}}(\\operatorname{acc}_1) = \\operatorname{D}_{\\operatorname{acc}}(\\operatorname{acc}_2) = 1</span>  and the extractor succeeds. We now prove that if  <span class="math">\\mathsf{E}_1 = 0</span> , we can extract a valid opening to  <span class="math">\\vec{C}_1</span> . That is,  <span class="math">(\\operatorname{acc}_1.x,\\operatorname{acc}_1.w)</span>  is a valid pair for the predicate  <span class="math">\\Phi</span> . From term  <span class="math">(1-\\beta)</span>  in the equation above we have that, except with negligible probability,  <span class="math">\\operatorname{Dec}(\\vec{x}_1,\\vec{y}_1,z_1,\\vec{f}_1^*,\\mathcal{T}^{(x_1)i},\\mathcal{T}^{(x_2)},\\vec{\\mathsf{D}}) = 0</span> . That is,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$0 = \\langle \\mathcal{T}_x^{(\\text{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_y^{(\\text{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{f}_1^*, \\mathcal{T}^{(y)}. \\text{leaves} \\rangle - z_1, \\vec{\\mathsf{K}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{K}' \\rangle + \\langle \\vec{f}_1^*, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle - \\langle \\mathcal{T}^{(x)}. \\text{leaves}, \\vec{\\mathsf{D}}_1 \\rangle$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Claim:  <span class="math">\\vec{\\mathsf{D}}_1</span>  is base  <span class="math">(\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n}</span>  We first show that in the algebraic group model, we can write  <span class="math">\\vec{\\mathsf{D}}_1</span>  base  <span class="math">\\mathsf{H}^{(\\vec{y})}</span> . Consider the following check:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\vec{x} \\in B_n} e(\\mathsf{D}_1^{(\\vec{x})},\\mathsf{V}^{(\\vec{x})}) = e(\\mathsf{C}_1,\\mathsf{V}&#x27;)</span></div>

    <p class="text-gray-300">Note that,  <span class="math">V^{(\\vec{x})}</span>  contains a factor of  <span class="math">\\tau^{(\\vec{x})}</span> . The only elements that contain this factor in  <span class="math">\\mathbb{G}_1</span>  are the  <span class="math">\\mathsf{H}^{((\\vec{i}),(\\vec{j}))}</span>  generators. Thus,  <span class="math">\\mathsf{C}_1</span>  can only be written base  <span class="math">\\mathsf{H}^{(\\vec{i},\\vec{j})}</span> . Otherwise, we can break the discrete logarithm assumption. Conversely, this implies that each  <span class="math">\\mathsf{D}_1^{(\\vec{x})}</span>  must be written base  <span class="math">\\mathsf{H}^{(\\vec{i})}</span> , i.e.  <span class="math">\\mathsf{D}_1^{(\\vec{x})} = \\langle \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_n} \\rangle</span> . This proves the claim. Given this, we can write</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\begin{split} \\langle \\mathcal{T}^{(x)}.\\text{leaves}, \\vec{\\mathsf{D}}_{1} \\rangle &= \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\langle \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\\\ &= \\langle \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\\\ 0 &= \\langle \\mathcal{T}_{x}^{(\\text{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{y}^{(\\text{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{f}_{1}^{*}, \\mathcal{T}^{(y)}.\\text{leaves} \\rangle - z_{1}, \\vec{\\mathsf{K}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{K}' \\rangle + \\\\ &\\qquad \\langle \\vec{f}_{1}^{*} - \\sum_{\\vec{x} \\in B_{n}} \\mathcal{T}^{(x)}.\\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_{n}} \\rangle \\end{split}$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can split this equation into</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\langle \\mathcal{T}_x^{(\\mathrm{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_y^{(\\mathrm{error})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle \\vec{f_1}^*, \\, \\mathcal{T}^{(y)}. \\mathrm{leaves} \\rangle - z_1, \\vec{\\mathsf{K}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{K}' \\rangle = 0$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\vec{f}_1^* - \\sum_{\\vec{x} \\in B_n} \\mathcal{T}^{(x)}. \\text{leaves} \\cdot \\vec{f}^{(x)}, (\\mathsf{H}^{(\\vec{i})})_{\\vec{i} \\in B_n} \\rangle = 0</span></div>

    <p class="text-gray-300">or we can break the  <span class="math">\\mathcal{U}</span> -find-rep assumption as the left side of the product is a polynomial that vanishes at the logarithms of the group elements in  <span class="math">\\vec{K}</span> . Then, we have that that Eq.(3) in Fig. 2 is satisfied since  <span class="math">f^<em>(\\vec{y}_1) = \\langle \\vec{f}_1^</em>, \\mathcal{T}^{(y_1)}.</span> leaves <span class="math">\\rangle = z_1</span> . Also,  <span class="math">\\langle \\vec{f}_1^*, (\\mathsf{H}^{(\\vec{y})})_{\\vec{y} \\in B_n} \\rangle = \\langle \\mathcal{T}^{(x)}.</span> leaves,  <span class="math">\\vec{\\mathsf{D}}_1 \\rangle = 0</span> , representing Eq.(2) in Figure 2. Finally, from above we have that Eq.(1) is also satisfied. Then, it is enough for Ext<sub>acc</sub> to run Ext<sub>KZH</sub>.</p>

    <p class="text-gray-300">We extend KZH-2 to a higher dimensional polynomial commitment which has a more efficient verifier and smaller proof size. This results in a smaller accumulator and a more efficient decider. In particular, we generalize the 2-dimensional KZH-2, which can be viewed as a vector-matrix-vector product, to higher-dimensional tensor products. This reduces the PC verifier from  <span class="math">\\sqrt{n}</span>  to  <span class="math">n^{1/k}</span> . Note that in order to build efficient accumulation for a multilinear PCS, we need to expand a <em>short</em> evaluation point  <span class="math">\\vec{x}</span>  into <em>long</em> vectors, which correspond to  <span class="math">\\operatorname{eq}(\\vec{x}, \\vec{b})</span>  for  <span class="math">\\vec{b} \\in H \\subset \\mathbb{F}</span> . This transformation is equivalent to the one in KZH-2, and we omit it here for ease of presentation.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">C.1 KZH-k</h3>

    <p class="text-gray-300"><strong>Notation.</strong> We denote the space of n dimensional tensors with dimensions  <span class="math">(d_1, d_2, \\ldots, d_n)</span>  on field  <span class="math">\\mathbb{F}</span>  with  <span class="math">\\mathbb{F}^{d_1 \\times d_2 \\times \\cdots \\times d_n}</span> . For  <span class="math">\\mathbf{T} \\in \\mathbb{F}^{d_1 \\times d_2 \\times \\cdots \\times d_k}</span>  and  <span class="math">\\vec{x}_1 \\in \\mathbb{F}^{d_1}</span> , we denote tensor inner product as</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf{T}, \\vec{x}_1 \\rangle = \\langle \\mathbf{T}_1, \\vec{x}_1 \\rangle \\otimes \\mathbf{T}_2 \\otimes \\ldots \\otimes \\mathbf{T}_k.</span></div>

    <p class="text-gray-300">Note that the result is a tensor in  <span class="math">\\mathbb{F}^{d_2 \\times \\cdots \\times d_k}</span> . Similarly for  <span class="math">\\vec{x}_1 \\in \\mathbb{F}^{d_1}</span>  and  <span class="math">\\vec{x}_2 \\in \\mathbb{F}^{d_2}</span> ,  <span class="math">\\langle \\mathbf{T}, \\vec{x}_1 \\otimes \\vec{x}_2 \\rangle = \\langle \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle \\in \\mathbb{F}^{d_3 \\times \\cdots \\times d_k}</span> .</p>

    <p class="text-gray-300"><strong>Protocol description.</strong> We construct a commitment scheme for such tensors, where <strong>T</strong> represents the polynomial that can be opened at evaluation point  <span class="math">(\\vec{x}_1, \\ldots, \\vec{x}_k)</span>  for  <span class="math">\\vec{x}_j \\in \\mathbb{F}^{d_j}</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\langle \\langle \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle, \\dots, \\vec{x}_{k-1} \\rangle, \\vec{x}_k \\rangle = y \\in \\mathbb{F}.</span></div>

    <p class="text-gray-300">The scheme admits an efficient accumulation scheme and is general enough to support multilinear and univariate polynomial commitments. Compared to two-dimensional KZH, the tradeoff is that the accumulator instance and verifier are of size k, but the accumulation witness is of size  <span class="math">n^{\\frac{1}{k}}</span> . The core insight is that we commit to  <span class="math">\\mathsf{C} = \\langle \\mathbf{T}, \\vec{\\mu}_1 \\otimes \\vec{\\mu}_2 \\cdots \\otimes \\vec{\\mu}_k \\rangle \\times \\mathsf{G}</span> , for secret elements  <span class="math">\\vec{\\mu}_1, \\ldots, \\vec{\\mu}_k</span>  and group generator  <span class="math">\\mathsf{G}</span> , and open  <span class="math">[\\mathsf{C}_i]_{i=1}^k</span> , commitments to all k-1 dimensional slices of  <span class="math">\\mathbf{T}</span> . The verifier can check that these slices are correct using a pairing with  <span class="math">\\vec{\\mu}_1</span>  and compute  <span class="math">\\mathsf{C}&#x27; = \\langle (\\mathsf{C}_1, \\ldots, \\mathsf{C}_k), \\vec{x}_1, \\rangle</span> .  <span class="math">\\mathsf{C}&#x27;</span>  is now a commitment to the k-1 dimensional tensor  <span class="math">\\mathbf{T}_1 = \\langle \\mathbf{T}, \\vec{x}_1 \\rangle</span>  and we can recursively apply the scheme. We present the full protocol for degree  <span class="math">[d]^k := (d, d, \\ldots, d)</span>  tensor in Figure 12.</p>

    <p class="text-gray-300">Efficiency. The commitment size is a single  <span class="math">\\mathbb{G}_1</span>  element. The commitment time is dominated by an MSM of size n for tensors of size n. Part of the opening can be preprocessed, as with KZH-2, reducing the opening time to the tensor product plus  <span class="math">O(n^{1/2})</span>  group operations. Concretely, the prover will compute commitments to  <span class="math">f(\\vec{X}, \\vec{b})</span>  for all  <span class="math">\\vec{b} \\in \\{0, 1\\}^{\\log(n)/2}</span> . Using these the first  <span class="math">\\log(n)/2</span>  steps of the opening proof can be computed in time  <span class="math">O(\\sqrt{n})</span> . The second half of the opening proof can also be computed efficiently using  <span class="math">f(\\vec{\\alpha}, \\vec{X})</span>  for the</p>

    <p class="text-gray-300">partial evaluation point ⃗α ∈ F log(n)/2 . The proof size is (k − 1) · n <sup>1</sup>/k G<sup>1</sup> elements, as well as n <sup>1</sup>/k field elements. The verification time is O(k · n <sup>1</sup>/k) and dominated by k − 1 pairing products of size n 1/k .</p>

    <p class="text-gray-300">Preprocessing for free Boolean openings. As in KZH-2, we can preprocess so that openings at Boolean points are essentially free: the opening reduces to retrieving a precomputed commitment. Let</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{T}_{\\vec{x}_1,\\dots,\\vec{x}_i} := \\langle \\dots \\langle \\mathbf{T}, \\vec{x}_1 \\rangle, \\vec{x}_2 \\rangle, \\dots, \\vec{x}_i \\rangle</span></div>

    <p class="text-gray-300">denote the sequential multilinear evaluation of T at Boolean points ⃗x1, . . . , ⃗x<sup>i</sup> . During setup, for each 1 ≤ i < k, we precompute all commitments of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\vec{x}_1 \\in \\{0,1\\}^{d_1}, \\dots, \\vec{x}_i \\in \\{0,1\\}^{d_i} : \\langle \\mathbf{T}_{\\vec{x}_1,\\dots,\\vec{x}_i}, \\mathbf{H}_{j+1} \\rangle.</span></div>

    <p class="text-gray-300">For each i, this takes O(n) time, so the total preprocessing cost is O(nk). Once preprocessing is done, any Boolean opening (⃗x1, . . . , ⃗xk) can be resolved without extra computation. In the online phase, the usual computation D<sup>j</sup> [i] ← ⟨⟨i⟩⊗T<sup>j</sup> , Hj+1⟩, where T<sup>j</sup> = T⃗x1,...,⃗xj−<sup>1</sup> , is already precomputed, since all the points ⃗x<sup>t</sup> and ⟨i⟩ are Boolean points. Thus, the opening step reduces to simply selecting the corresponding precomputed commitment.</p>

    <p class="text-gray-300"> <span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Setup}(\\lambda,d,k)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\bullet \\ \\ \\text{Sample} \\ \\mathsf{G} \\leftarrow \\!\\!\\!\\! \\</span> \\, \\mathbb{G}_1, \\mathsf{V} \\leftarrow \\!\\!\\!\\! \\<span class="math"> \\, \\mathbb{G}_2 \\ \\text{and} \\ [[\\mu_{i,j}]_{i=1}^d]_{i=1}^k \\leftarrow \\!\\!\\!\\! \\</span> \\, \\mathbb{F}$</li>

      <li><span class="math">\\mathbf{H}_1 = \\{ \\mathsf{H}_{i_1,...,i_k} \\leftarrow (\\prod_{i=1}^k \\mu_{i_s,j}) \\times \\mathsf{G} : \\forall i_1,...,i_k \\in [d] \\}</span></li>

      <li><span class="math">\\mathbf{H}_2 = \\{ \\mathsf{H}_{i_2,...,i_k} \\leftarrow (\\prod_{i=2}^k \\mu_{i_j,j}) \\times \\mathsf{G} : \\forall i_2,...,i_k \\in [d] \\}</span></li>

      <li>...</li>

      <li><span class="math">\\mathbf{H}_k = \\{ \\mathsf{H}_{i_k} \\leftarrow \\mu_{i_k,k} \\times \\mathsf{G} : \\forall i_k \\in [d] \\}</span></li>

      <li><span class="math">\\mathbf{V} = \\{ V_{i,j} \\leftarrow \\mu_{i,j} \\times V : \\forall i \\in [d], j \\in [k] \\}</span></li>

      <li>Output  <span class="math">(G, V, \\mathbf{H}_1, \\mathbf{H}_2, \\dots, \\mathbf{H}_k, \\mathbf{V})</span></li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Commit}(\\mathsf{srs},\\mathbf{T})</span> : For  <span class="math">\\mathbf{T}\\in\\mathbb{F}^{d\\times d\\times \\cdots \\times d}</span> , compute the commitment as it follows:</p>

    <p class="text-gray-300">• Output <span class="math-block">\\mathsf{C} \\leftarrow \\langle \\mathbf{T}, \\mathbf{H}_1 \\rangle = \\sum_{(i_1,i_2,\\dots,i_k) \\in [d]^k} \\mathbf{T}_{i_1,i_2,\\dots,i_k} \\times \\mathsf{H}_{i_1,i_2,\\dots,i_k}</span></p>

    <p class="text-gray-300"> <span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Open}(\\mathsf{srs},\\mathsf{C},\\mathbf{T},\\vec{x}_1,\\ldots,\\vec{x}_k)</span> : Given commitment  <span class="math">\\mathsf{C}\\in\\mathbb{G}_1</span> , tensor  <span class="math">\\mathbf{T}\\in\\mathbb{F}^{d\\times d\\times \\cdots \\times d}</span>  and inputs  <span class="math">\\vec{x}_i\\in\\mathbb{F}^d</span> , compute opening as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let  <span class="math">\\mathbf{T}_1 = \\mathbf{T}</span></li>

      <li>For j = 1, ..., k 1:</li>

      <li>Set  <span class="math">\\mathbf{T}_{i+1} \\leftarrow \\langle \\mathbf{T}_i, \\vec{x_i} \\rangle</span></li>

      <li>Compute vector  <span class="math">\\vec{\\mathsf{D}}_j</span>  e.g.  <span class="math">\\mathsf{D}_j[i] \\leftarrow \\langle \\langle i \\rangle \\otimes \\mathbf{T}_j, \\mathbf{H}_{j+1} \\rangle</span>  for all  <span class="math">i \\in [d]</span> , where  <span class="math">\\langle i \\rangle</span>  represents decomposition of i into d bits.</li>

      <li>Output  <span class="math">\\pi \\leftarrow \\{ [\\vec{\\mathsf{D}}_j]_{j \\in [k-1]}, \\, \\mathbf{T}_k \\}</span></li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathsf{KZH}^{(k)}.\\mathsf{Verify}(\\mathsf{srs},\\mathsf{C},[\\vec{x}_j]_{j\\in[k]},y,\\pi)</span> : Given commitment  <span class="math">\\mathsf{C}\\in\\mathbb{G}_1</span> , inputs  <span class="math">\\vec{x}_j\\in\\mathbb{F}^d</span> , output  <span class="math">y\\in\\mathbb{F}</span>  and opening proof  <span class="math">\\pi</span> , does as it follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse  <span class="math">\\{[\\vec{\\mathsf{D}}_j]_{j\\in[k-1]},\\,\\mathbf{T}_k\\}\\leftarrow\\pi</span></li>

      <li>Set  <span class="math">C_0 = C</span></li>

      <li>For  <span class="math">j \\in 1, ..., k-1</span></li>

      <li>1. Check that  <span class="math">e(C_{j-1}, V) = \\sum_{i=0}^{d} e(D_{j}[i], V_{i,j})</span></li>

      <li>2. Compute  <span class="math">C_j \\leftarrow \\langle \\vec{x}_j, \\vec{\\mathsf{D}}_i \\rangle</span></li>

      <li>Check that  <span class="math">C_{k-1} = \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle</span></li>

      <li><span id="page-55-0"></span>• Check that  <span class="math">\\langle \\mathbf{T}_k, \\vec{x}_k \\rangle = y</span></li>

    </ul>

    <p class="text-gray-300">Figure 12: KZH-k description</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> The protocol in Figure 12 is a complete and knowledge-sound polynomial commitment scheme in the AGM under  <span class="math">(q_1, q_2)</span> -dlog and Setup-find-rep assumption in the algebraic group model.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300"><strong>Completeness.</strong> Consider honestly generated C,  <span class="math">[C_j]_{j=1}^k</span> . For the first check, note that  <span class="math">e(C_0, V) = e(\\langle \\mathbf{T}, \\mathbf{H}_1 \\rangle, V)</span>  by construction of C. On the other hand,</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=0}^{d} e(\\mathsf{D}_{1}[i], \\mathsf{V}_{i,1}) = \\sum_{i=0}^{d} e(\\langle \\langle i \\rangle \\otimes \\mathbf{T}_{1}, \\mathbf{H}_{2} \\rangle, \\mu_{i,1} \\times \\mathsf{V}) = \\sum_{i=0}^{d} e(\\langle \\langle i \\rangle \\otimes \\mathbf{T}_{1}, \\mu_{i,1} \\times \\mathbf{H}_{2} \\rangle, \\mathsf{V})</span></div>

    <div class="my-4 text-center"><span class="math-block">= e(\\langle \\mathbf{T}_{1}, \\mathbf{H}_{1} \\rangle, \\mathsf{V})</span></div>

    <p class="text-gray-300">and since  <span class="math">T_1 = T</span> , the verifier accepts. For the general case,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} e(\\mathsf{C}_{j-1},\\mathsf{V}) &amp;= e(\\langle \\vec{\\mathsf{D}}_{j-1}, \\vec{x}_{j-1} \\rangle, \\mathsf{V}) = e(\\sum_{i=1}^d \\vec{\\mathsf{D}}_{j-1}[i] \\vec{x}_{j-1}[i], \\mathsf{V}) \\\\ &amp;= e(\\sum_{i=1}^d \\langle \\langle i \\rangle \\otimes \\mathbf{T}_{j-1}, \\, \\mathbf{H}_j \\rangle \\vec{x}_{j-1}[i], \\mathsf{V}) = e(\\sum_{i=1}^d \\langle \\langle \\vec{x}_{j-1}, \\mathbf{T}_{j-1} \\rangle, \\, \\mathbf{H}_j \\rangle, \\mathsf{V}) \\\\ &amp;= e(\\langle \\mathbf{T}_j, \\, \\mathbf{H}_j \\rangle, \\mathsf{V}) = \\sum_{i=1}^d e(\\langle \\mathbf{T}_j, \\, \\mathbf{H}_{j+1} \\rangle, \\mathsf{V}_{i,j}) \\\\ &amp;= \\sum_{i=1}^d e(\\mathsf{D}_j[i], \\mathsf{V}_{i,j}). \\end{split}</span></div>

    <p class="text-gray-300">In the second verification equation we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathsf{C}_{k-1} &amp;= \\langle \\vec{x}_{k-1}, \\vec{\\mathsf{D}}_{k-1} \\rangle = \\sum_{i=1}^d \\vec{\\mathsf{D}}_{k-1}[i] \\vec{x}_{k-1}[i] \\\\ &amp;= \\sum_{i=1}^d \\langle \\langle i \\rangle \\otimes \\mathbf{T}_{k-1}, \\, \\mathbf{H}_k \\rangle \\vec{x}_{k-1}[i] = \\sum_{i=1}^d \\langle \\langle \\mathbf{T}_{k-1}, \\vec{x}_{k-1} \\rangle, \\, \\mathbf{H}_k \\rangle \\\\ &amp;= \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle. \\end{aligned}</span></div>

    <p class="text-gray-300">And since the third check follows directly, we have that the verifier accepts.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Let  <span class="math">\\mathcal{A}</span>  be a PPT adversary that on input srs outputs a commitment  <span class="math">\\mathsf{C}</span> . We define an extractor  <span class="math">\\mathcal{E}</span>  that outputs  <span class="math">p(\\vec{X}_1,\\ldots,\\vec{X}_k)</span>  such that, for any tuple  <span class="math">((\\vec{x}_1,\\ldots,\\vec{x}_k),y,\\pi)</span> , accepted by the verifier,  <span class="math">p(\\vec{x}_1,\\ldots,\\vec{x}_k)=y</span>  with overwhelming probability. Under the AGM, we assume  <span class="math">\\mathcal{A}</span>  is algebraic and thus  <span class="math">\\mathcal{A}</span>  outputs  <span class="math">\\mathsf{C}</span>  along with  <span class="math">\\{\\vec{c}^r\\}_{r=1}^k</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{C} = \\sum_{r=1}^k \\langle \\vec{c}^r, \\mathbf{H}_r \\rangle</span></div>

    <p class="text-gray-300"> <span class="math">\\mathcal{E}</span>  outputs  <span class="math">p(\\vec{X}_1, \\dots, \\vec{X}_k) = (\\vec{c}_1, \\dots, \\vec{c}_k) \\otimes (\\vec{X}_1, \\dots, \\vec{X}_k)</span> . Under the AGM,  <span class="math">\\mathcal{E}</span>  does not abort. Similarly, under the AGM we have that there exist  <span class="math">[\\vec{d}_{i,j}^r]_{r=1}^k</span>  such that for all i, j:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{D}_{j}[i] = \\sum_{r=1}^{k} \\langle \\vec{d}_{i,j}^{r}, \\mathbf{H}_{r} \\rangle</span></div>

    <p class="text-gray-300">Because the verifier accepts, we have that all their checks are satisfied. In particular, for C and all  <span class="math">[D_1[i]]_{i=0}^d</span> :</p>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{C},\\mathsf{V}) = \\sum_{i=1}^d e(\\mathsf{D}_1[i],\\mathsf{V}_{i,1})</span></div>

    <p class="text-gray-300">Replacing by the extracted  <span class="math">C, D_1[i]</span>  and the form of  <span class="math">V_{i,1}</span> , we have</p>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\sum_{r=1}^{k}\\langle \\vec{c}^r, \\mathbf{H}_r \\rangle, \\mathsf{V}\\right) = \\sum_{i=1}^{d} e\\left(\\sum_{r=1}^{k}\\langle \\vec{d}_{i,1}^r, \\mathbf{H}_r \\rangle, \\mu_{i,1} \\times \\mathsf{V}\\right)</span></div>

    <p class="text-gray-300">Then,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(1) It must be the case that  <span class="math">\\vec{c}^r = 0</span>  for all  <span class="math">r \\neq 1</span>  or we can calculate the discrete logarithm relation between  <span class="math">\\mathbf{H}_2, \\ldots, \\mathbf{H}_k</span>  and  <span class="math">[\\mathsf{V}_{i,1}]_{i=1}^d</span> , breaking the dlog assumption. Similarly, we have  <span class="math">\\vec{d}_{i,1}^r = 0</span>  for all r > 2 or we can find the discrete log relation between  <span class="math">\\mathbf{H}_2</span>  and  <span class="math">\\mathbf{H}_3, \\ldots, \\mathbf{H}_k</span> .</li>

      <li>(2) Also,  <span class="math">\\vec{d}_{i,1}^1=0</span>  or we can extract  <span class="math">(\\mu_{i,1}^2\\prod_{j\\neq 1}\\mu_{i,j})\\times\\mathsf{G},</span>  breaking CDH.</li>

      <li>(3) Finally, we have that each  <span class="math">\\mathsf{D}_1[i]</span>  is base  <span class="math">[\\mathsf{H}_{ii_3...i_k}]_{i_3,...,i_k\\in[d]}</span> , i.e.,  <span class="math">\\mathsf{D}_1[i]=\\langle \\vec{d}_{i,1}^2,\\mu_{i,2}\\times\\mathbf{H}_3\\rangle</span> , or we can find the discrete log relation between  <span class="math">\\mu_{i,1}\\times\\mu_{s,2}\\times\\mathbf{H}_3</span>  and  <span class="math">\\mathbf{H}_1</span>  for  <span class="math">s\\neq i</span> . This implies  <span class="math">(\\vec{d}_{i,1}^2)_s=0</span>  for all  <span class="math">s\\neq i</span> .</li>

    </ul>

    <p class="text-gray-300">The equation then is</p>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\langle \\vec{c}^1, \\mathbf{H}_1 \\rangle, \\mathsf{V}\\right) = \\sum_{i=1}^d e\\left(\\langle \\vec{d}_{i,1}^2, \\mathbf{H}_{2,i} \\rangle, \\mu_{i,1} \\times \\mathsf{V}\\right)</span></div>

    <p class="text-gray-300">which implies  <span class="math">\\vec{c}_1 = \\sum_{i=1}^d \\vec{d}_{i,1}^2</span> . Indeed, if there exists  <span class="math">s \\in [k]</span>  such that  <span class="math">c_s \\neq d_{s,1}^2</span> ,  <span class="math">\\mu_{s,1}</span>  is a root of the polynomial  <span class="math">c_s X - d_{s,1}^2 X</span>  and we can find it, breaking dlog. In the general case, for every  <span class="math">j = 2, \\ldots, k</span>  we have:</p>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\mathsf{C}_{j},\\mathsf{V}\\right) = \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{j+1}[i], \\mu_{i,j+1} \\times \\mathsf{V}\\right)</span></div>

    <p class="text-gray-300">for  <span class="math">C_j = \\langle \\vec{x}_j, \\vec{\\mathsf{D}}^j \\rangle</span> . Then, if  <span class="math">\\mathsf{D}^j = \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle</span> , it must be the case that  <span class="math">\\mathsf{D}^{j+1} = \\langle \\vec{d}^{j+1}, \\mathbf{H}_{j+1} \\rangle</span> , with  <span class="math">\\vec{d}_s^{j+1} = 0</span>  fro all  <span class="math">s \\neq j+1</span>  or we break dlog as in item (1) and (3), and CDH as in (2) above. By induction, we have  <span class="math">\\mathsf{D}^j = \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle</span>  for all  <span class="math">j = 1, \\ldots, k</span> ., Finally, we have</p>

    <div class="my-4 text-center"><span class="math-block">e\\left(\\langle \\vec{x}_j, \\vec{\\mathsf{D}}^j \\rangle, \\mathsf{V}\\right) = \\sum_{i=0}^d e\\left(\\langle \\vec{d}_i^{\\vec{\\jmath}+1}, \\mathbf{H}_{j+1} \\rangle, \\mu_{i,j+1} \\times \\mathsf{V}\\right)</span></div>

    <p class="text-gray-300">And thus</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\vec{x}_j, \\langle \\vec{d}^j, \\mathbf{H}_j \\rangle \\rangle = \\langle \\sum_{i=0}^d \\vec{d}_i^{j+1}, \\mathbf{H}_{j+1} \\rangle</span></div>

    <p class="text-gray-300">So  <span class="math">\\sum_{i=0}^{d} \\vec{d}_{i}^{j+1} = \\vec{x}_{j} \\otimes \\vec{d}^{j}</span> , This implies  <span class="math">\\mathbf{T}_{k} = \\vec{x}_{k-1} \\otimes \\ldots \\otimes \\vec{x}_{1} \\otimes \\vec{c}</span>  and thus  <span class="math">y = \\vec{x}_{k} \\otimes \\mathbf{T}_{k}</span>  implies  <span class="math">y = p(\\vec{x}_{1}, \\ldots, \\vec{x}_{k})</span>  for the polynomial  <span class="math">p(\\vec{X}_{1}, \\ldots, \\vec{X}_{k})</span>  encoded in C and we conclude the proof.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">C.2 KZH-k accumulation</h4>

    <p class="text-gray-300">We now construct an accumulation scheme for KZH-k. In particular, we focus on the case where the tensor  <span class="math">\\mathbf{T}</span>  is a multilinear polynomial. At a high level, the KZH-k verifier is still low degree and algebraic, and therefore, we can apply the same accumulation strategy as in the two-dimensional case. Importantly, the accumulator size and the decider time are reduced to  <span class="math">O(k \\cdot n^{\\frac{1}{k}})</span> . The accumulation verifier performs O(k)  <span class="math">\\mathbb{G}_1</span>  operations. For a  <span class="math">k \\cdot d</span> -linear polynomial, the accumulator instance and witness can be described as it follows: (red terms only appear in accumulators not proofs)</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathsf{acc}.x &amp;= \\{\\mathsf{C},\\, \\mathsf{C}_1, \\dots, \\mathsf{C}_{k-1} \\in \\mathbb{G},\\, \\vec{x}_1, \\dots, \\vec{x}_k \\in \\mathbb{F}^d, y \\in \\mathbb{F},\\, \\underline{E_{\\mathbb{G}}} \\in \\mathbb{G}, e_{\\mathbb{F}} \\in \\mathbb{F} \\} \\\\ \\\\ \\mathsf{acc}.w &amp;= \\{ [\\mathsf{D}_{i,j}]_{j \\in [k-1],\\, i \\in [0,d]}, \\mathbf{T}_k \\in \\mathbb{F}^d \\} \\end{aligned}</span></div>

    <p class="text-gray-300">The accumulation prover, verifier and decider of KZH-k are respectively defined in Figures 13 and 14.</p>

    <p class="text-gray-300"><strong>Efficiency.</strong> The accumulator consists of the PCS proof and is of size  <span class="math">O(k \\cdot n^{1/k})</span> . The accumulation decider runs the PCS verifier and is dominated by k-1  <span class="math">n^{1/k}</span>  pairing products and the accumulation verifier is dominated by k+1  <span class="math">\\mathbb{G}_1</span>  operations.</p>

    <p class="text-gray-300"> <span class="math">P_{acc}(srs, (acc.x, acc.w), (acc&#x27;.x, acc&#x27;.w))</span> :</p>

    <p class="text-gray-300">• Parse acc.x, acc.w and acc'.x, acc'.w as below:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - \\ \\{\\mathsf{C},\\mathsf{C}_1,\\ldots,\\mathsf{C}_{k-1},\\ (\\vec{x}_1,\\ldots,\\vec{x}_k,y),\\ (E_{\\mathbb{G}},e_{\\mathbb{F}})\\} \\leftarrow \\mathsf{acc}.x \\\\ - \\ \\{\\{[\\mathsf{D}_{i,j}]_{j\\in[k-1],\\,i\\in[0,d]},\\ \\mathbf{T}_k\\} \\leftarrow \\mathsf{acc}.w \\\\ - \\ \\{\\mathsf{C}&#x27;,\\mathsf{C}&#x27;_1,\\ldots,\\mathsf{C}&#x27;_{k-1},\\ (\\vec{x}&#x27;_1,\\ldots,\\vec{x}&#x27;_k,y&#x27;),\\ (E&#x27;_{\\mathbb{G}},e&#x27;_{\\mathbb{F}})\\} \\leftarrow \\mathsf{acc}&#x27;.x \\\\ - \\ \\{\\{[\\mathsf{D}&#x27;_{i,j}]_{j\\in[k-1],\\,i\\in[0,d]},\\mathbf{T}&#x27;_k\\} \\leftarrow \\mathsf{acc}&#x27;.w \\end{array}</span></div>

    <p class="text-gray-300">• Let  <span class="math">\\mathsf{Dec}_{\\mathbb{G}}</span>  and  <span class="math">\\mathsf{Dec}_{\\mathbb{F}}</span>  be the verification checks as defined in Figure ??. Compute  <span class="math">Q \\in \\mathbb{G}</span>  such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathsf{Dec}_{\\mathbb{G}} \\big( (1-X) \\cdot (\\vec{x}_j, \\mathsf{C}_j, [\\mathsf{D}_{i,j}]_{i=0}^d) + X \\cdot (\\vec{x}_j&#x27;, \\mathsf{C}_j&#x27;, [\\mathsf{D}_{i,j}&#x27;]_{i=0}^{d_j}) \\big) \\\\ &amp;= (1-X) \\times E_j + X \\times E_j&#x27; + (1-X) \\cdot X \\times Q. \\end{split}</span></div>

    <p class="text-gray-300">and  <span class="math">q \\in \\mathbb{F}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\mathsf{Dec}_{\\mathbb{F}} \\Big( (1-X) \\cdot (\\mathbf{T}_k, \\vec{x}_k, y) + X \\cdot (\\mathbf{T}_k&#x27;, \\vec{x}_k&#x27;, y&#x27;) \\Big) \\\\ &amp;= (1-X) \\cdot e_{\\mathbb{F}} + X \\cdot e_{\\mathbb{F}}&#x27; + (1-X) \\cdot X \\cdot q. \\end{aligned}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Derive challenge  <span class="math">\\alpha \\leftarrow H(\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x, Q, q)</span>  through Fiat-Shamir.</li>

      <li>Compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;- \\mathsf{C}&#x27;&#x27; \\leftarrow (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27; \\\\ &amp;- \\vec{x_i}&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot \\vec{x_i} + \\alpha \\cdot \\vec{x_i}&#x27; \\text{ for } i \\in [k] \\\\ &amp;- y&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot y + \\alpha \\cdot y&#x27; \\\\ &amp;- \\mathsf{C}&#x27;&#x27;_j \\leftarrow (1-\\alpha) \\times \\mathsf{C}_j + \\alpha \\times \\mathsf{C}&#x27;_j \\text{ for } j \\in [1, k-1] \\\\ &amp;- \\mathsf{D}&#x27;&#x27;_{i,j} \\leftarrow (1-\\alpha) \\times \\mathsf{D}_{i,j} + \\alpha \\times \\mathsf{D}&#x27;_{i,j} \\text{ for each } j, i \\text{ for } i \\in [k] \\text{ and } j \\in [k-1] \\\\ &amp;- E&#x27;&#x27;_{\\mathbb{G}} \\leftarrow (1-\\alpha) \\times E_{\\mathbb{G}} + \\alpha \\times E&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times Q \\\\ &amp;- e&#x27;&#x27;_{\\mathbb{F}} \\leftarrow (1-\\alpha) \\cdot e_{\\mathbb{F}} + \\alpha \\cdot e&#x27;_{\\mathbb{F}} + (1-\\alpha) \\cdot \\alpha \\cdot q \\\\ &amp;- \\mathbf{T}&#x27;&#x27;_k \\leftarrow (1-\\alpha) \\times \\mathbf{T}_k + \\alpha \\times \\mathbf{T}&#x27;_k \\end{aligned}</span></div>

    <p class="text-gray-300"><span id="page-59-0"></span>• Output the new accumulator  <span class="math">\\mathsf{acc}&#x27;&#x27; = (\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span>  and  <span class="math">\\mathsf{pf} = \\{Q, q\\}</span>  as the accumulation proof.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp; \\mathsf{acc&#x27;&#x27;}.x = \\{\\mathsf{C&#x27;&#x27;},\\, [\\mathsf{C}&#x27;&#x27;_j]_{j \\in [k-1]}, [\\vec{x}&#x27;&#x27;_i]_{i \\in [k]}, y&#x27;&#x27;, [E&#x27;&#x27;_{\\mathbb{G}}, e_{\\mathbb{F}}\\} \\\\ &amp; \\mathsf{acc&#x27;&#x27;}.w = \\{\\{[\\mathsf{D}&#x27;&#x27;_{i,j}]_{j \\in [k-1],\\, i \\in [0,d_j]}, \\mathbf{T}&#x27;&#x27;_k\\} \\end{split}</span></div>

    <p class="text-gray-300">Figure 13: KZH-k accumulation prover</p>

    <p class="text-gray-300"> <span class="math">V_{acc}(srs, acc.x, acc&#x27;.x, pf = \\{Q \\in \\mathbb{G}, q \\in \\mathbb{F}\\})</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input acc.x, acc'.x and pf =  <span class="math">\\{Q, q\\}</span> .</li>

      <li>Regenerate challenge  <span class="math">\\alpha \\leftarrow H(A.X, A&#x27;.X, \\mathsf{pf})</span></li>

      <li>Compute</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} &amp;-\\mathsf{C}&#x27;&#x27; \\leftarrow (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27; \\\\ &amp;-\\vec{x_i}&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot \\vec{x_i} + \\alpha \\cdot \\vec{x_i}&#x27; \\text{ for } i \\in [k] \\\\ &amp;-y&#x27;&#x27; \\leftarrow (1-\\alpha) \\cdot y + \\alpha \\cdot y&#x27; \\\\ &amp;-\\mathsf{C}&#x27;&#x27;_j \\leftarrow (1-\\alpha) \\times \\mathsf{C}_j + \\alpha \\times \\mathsf{C}&#x27;_j \\text{ for } j \\in [1,k-1] \\\\ &amp;-E&#x27;&#x27;_{\\mathbb{G}} \\leftarrow (1-\\alpha) \\times E_{\\mathbb{G}} + \\alpha \\times E&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times Q \\\\ &amp;-e&#x27;&#x27;_{\\mathbb{F}} \\leftarrow (1-\\alpha) \\cdot e_{\\mathbb{F}} + \\alpha \\cdot e&#x27;_{\\mathbb{F}} + (1-\\alpha) \\cdot \\alpha \\times q \\end{split}</span></div>

    <p class="text-gray-300">• Output the new accumulator instance acc".x.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{acc}&#x27;&#x27;.x = \\{\\mathsf{C}&#x27;&#x27;,\\, [\\mathsf{C}&#x27;&#x27;_j]_{j \\in [k-1]}, [\\vec{x}&#x27;&#x27;_i]_{i \\in [k]}, y&#x27;&#x27;, E&#x27;&#x27;_{\\mathbb{G}}, e&#x27;&#x27;_{\\mathbb{F}} \\}</span></div>

    <p class="text-gray-300"> <span class="math">D_{acc}(srs, acc.x, acc.w)</span> :</p>

    <p class="text-gray-300">• Parse instance and witness as it follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - \\ \\{\\mathsf{C}, \\ (\\mathsf{C}_1, \\dots, \\mathsf{C}_{k-1}), \\ (\\vec{x}_1, \\dots, \\vec{x}_k, y), \\ E_{\\mathbb{G}}, e_{\\mathbb{F}}\\} \\leftarrow \\mathsf{acc}.x \\\\ - \\ \\{ [\\vec{\\mathsf{D}}_j = [\\mathsf{D}_{i,j}]_{i \\in [0,d]}]_{j=1}^{k-1}, \\ \\mathbf{T}_k \\} \\leftarrow \\mathsf{acc}.w \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set  <span class="math">C_0 \\leftarrow C</span></li>

      <li>For each  <span class="math">j \\in [1, k-1]</span>  check that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{C}_{j-1},\\mathsf{V}) - \\sum_{i=0}^d e(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}) = 0</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Check that  <span class="math">\\mathsf{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k\\mathsf{C},[\\mathsf{C}_i]_{i=1}^{k-1},[\\vec{\\mathsf{D}_j}\\in\\mathbb{G}^d]_{j=1}^{k-1}) = \\sum_{j=1}^{k-1}(\\mathsf{C}_j-\\langle\\vec{x}_j,\\vec{\\mathsf{D}_j}\\rangle) = E_{\\mathbb{G}}</span></li>

      <li>Check that  <span class="math">\\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle = \\mathsf{C}_{k-1}</span></li>

      <li>Check that  <span class="math">\\mathsf{Dec}_{\\mathbb{F}}(\\vec{x}_k, \\mathbf{T}_k, y) = \\langle \\mathbf{T}_k, \\vec{x}_k \\rangle y = e_{\\mathbb{F}}</span></li>

    </ul>

    <p class="text-gray-300">Figure 14: KZH-k accumulation verifier and decider</p>

    <p class="text-gray-300"><span id="page-60-0"></span><strong>Theorem 6.</strong> KZH-k-fold is a secure accumulation scheme, also under the dlog-assumption in the algebraic group model.</p>

    <p class="text-gray-300">Proof.</p>

    <p class="text-gray-300">Completeness. Consider the following two satisfying accumulator instances:</p>

    <p class="text-gray-300">• <span class="math-block">acc.x = \\{C, C_1, \\dots, C_{k-1}, (\\vec{x}_1, \\dots, \\vec{x}_k, y), (E_{\\mathbb{G}}, e_{\\mathbb{F}})\\}</span></p>

    <p class="text-gray-300">• <span class="math-block">acc.w = \\{\\{[D_{i,j}]_{j \\in [k-1], i \\in [0,d]}, T_k\\}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\bullet \\ \\operatorname{acc}&#x27;.x = \\{\\mathsf{C}&#x27;,\\mathsf{C}_1&#x27;,\\dots,\\mathsf{C}_{k-1}&#x27;,\\, (\\vec{x}_1&#x27;,\\dots,\\vec{x}_k&#x27;,y&#x27;),\\, (E_{\\mathbb{G}}&#x27;,e_{\\mathbb{F}}&#x27;)\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\bullet \\ \\operatorname{acc}&#x27;.w = \\{ \\{ [\\mathsf{D}&#x27;_{i,j}]_{j \\in [k-1], \\, i \\in [0,d]}, \\mathbf{T}&#x27;_k \\}</span></div>

    <p class="text-gray-300">It is straightforward to see that honest  <span class="math">\\mathsf{P}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  output the same  <span class="math">\\mathsf{acc}&#x27;&#x27;.x</span>  as they follow the same instructions. Then it is left to see that on input  <span class="math">(\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span>  computed by an honest prover,  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  always accepts. For each  <span class="math">j \\in [1, k-1]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) &amp;= e\\left((1-\\alpha)\\times\\mathsf{C}_{j-1} + \\alpha\\times\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) = (1-\\alpha)\\times e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) + \\alpha\\times e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\\\ &amp;= (1-\\alpha)\\times\\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}\\right) + \\alpha\\times\\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}\\right) \\\\ &amp;= \\sum_{i=0}^d e\\left((1-\\alpha)\\times\\mathsf{D}_{i,j} + \\alpha\\times\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}\\right) \\\\ &amp;= \\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;&#x27;,\\mathsf{V}_{i,j}\\right) \\end{split}</span></div>

    <p class="text-gray-300">so the first equation holds. For the second check, we have:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\operatorname{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k, \\mathsf{C}&#x27;&#x27;, [\\mathsf{C}_i&#x27;&#x27;]_{i=1}^{k-1}, [\\vec{\\mathsf{D}}_j&#x27;&#x27;]_{j=1}^{k-1}) \\\\ &amp;= \\operatorname{Dec}_{\\mathbb{G}}([\\vec{x}_i]_{i=1}^k, (1-\\alpha) \\times \\mathsf{C} + \\alpha \\times \\mathsf{C}&#x27;, [(1-\\alpha) \\times \\mathsf{C}_i + \\alpha \\times \\mathsf{C}_i&#x27;]_{i=1}^{k-1}, [(1-\\alpha) \\times \\vec{\\mathsf{D}}_j + \\alpha \\times \\vec{\\mathsf{D}}_j&#x27;]_{j=1}^{k-1}) \\\\ &amp;= (1-\\alpha) \\times \\mathsf{E}_{\\mathbb{G}} + \\alpha \\times \\mathsf{E}_{\\mathbb{G}}&#x27; + (1-\\alpha)\\alpha \\times \\mathsf{Q} = \\mathsf{E}_{\\mathbb{G}}&#x27;&#x27; \\end{split}</span></div>

    <p class="text-gray-300">by construction of Q. The third equation verifies as</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf{T}_{k}&#x27;&#x27;, \\mathbf{H}_{k} \\rangle = \\langle (1 - \\alpha) \\times \\mathbf{T}_{k} + \\alpha \\times \\mathbf{T}_{k}&#x27;, \\mathbf{H}_{k} \\rangle = (1 - \\alpha) \\times \\langle \\mathbf{T}_{k}, \\mathbf{H}_{k} \\rangle + \\alpha \\times \\langle \\mathbf{T}_{k}&#x27;, \\mathbf{H}_{k} \\rangle$$ $$= (1 - \\alpha) \\times \\mathsf{C}_{k-1} + \\alpha \\times \\mathsf{C}_{k-1}&#x27; = \\mathsf{C}_{k-1}&#x27;&#x27;.</span></div>

    <p class="text-gray-300">Finally, by definition of  <span class="math">e_{\\mathbb{F}}&#x27;&#x27;</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\operatorname{Dec}_{\\mathbb{F}}(\\vec{x}_k&#x27;&#x27;, \\mathbf{T}_k&#x27;&#x27;, y&#x27;&#x27;) &amp;= \\langle \\mathbf{T}_k&#x27;&#x27;, \\vec{x}_k&#x27;&#x27; \\rangle - y&#x27;&#x27; \\\\ &amp;= \\langle (1 - \\alpha)e_{\\mathbb{F}} + \\alpha e_{\\mathbb{F}}&#x27; + (1 - \\alpha) + (1 - \\alpha)\\alpha q \\\\ &amp;= e_{\\mathbb{F}}&#x27;&#x27;, \\end{aligned}</span></div>

    <p class="text-gray-300">and  <span class="math">D_{\\mathsf{acc}}</span>  outputs 1, concluding the proof of completeness.</p>

    <p class="text-gray-300"><strong>Knowledge soundness.</strong> Consider an adversary  <span class="math">\\mathcal{A}</span>  that outputs  <span class="math">\\hat{\\pi} = (\\pi.x, \\pi.w)</span> ,  <span class="math">\\mathsf{acc}&#x27;&#x27; = (\\mathsf{acc}&#x27;&#x27;.x, \\mathsf{acc}&#x27;&#x27;.w)</span> ,  <span class="math">\\mathsf{pf} \\in \\mathbb{G}_1 \\times \\mathbb{F}</span>  and  <span class="math">\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x</span> . We build an extractor  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  such that if  <span class="math">\\mathsf{V}_{\\mathsf{acc}}</span>  and  <span class="math">\\mathsf{D}_{\\mathsf{acc}}</span>  accept, extracts valid witnesses  <span class="math">\\mathsf{acc}.w, \\mathsf{acc}&#x27;.w</span>  for  <span class="math">\\mathsf{acc}.x, \\mathsf{acc}&#x27;.x</span> . Since  <span class="math">\\mathsf{acc}&#x27;&#x27;.w</span>  is an equation of degree one, given two accepting transcripts for different challenges  <span class="math">\\alpha_1, \\alpha_2</span> ,  <span class="math">\\mathsf{Ext}_{\\mathsf{acc}}</span>  can use the Vandermonde matrix to extract</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{acc}.w = \\{\\{[\\mathsf{D}_{i,j}]_{j \\in [k-1],\\, i \\in [0,d]},\\, \\mathbf{T}_k\\}, \\quad \\mathsf{acc}&#x27;.w = \\{\\{[\\mathsf{D}_{i,j}&#x27;]_{j \\in [k-1],\\, i \\in [0,d]}, \\mathbf{T}_k&#x27;\\}.</span></div>

    <p class="text-gray-300">Since  <span class="math">\\mathsf{D}_{\\mathsf{acc}}(\\mathsf{acc&#x27;&#x27;}.x,\\mathsf{acc&#x27;&#x27;}.w)</span>  accepts, we have the first check passes, i.e.,</p>

    <div class="my-4 text-center"><span class="math-block">e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) = \\sum_{i=0}^d e\\left(\\mathsf{D}_{i,j}&#x27;&#x27;,\\mathsf{V}_{i,j}\\right).</span></div>

    <p class="text-gray-300">We analyze each side of the equation independently:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} e(\\mathsf{C}_{j-1}&#x27;&#x27;,\\mathsf{V}) &amp;= e\\left((1-\\alpha)\\times\\mathsf{C}_{j-1} + \\alpha\\times\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\\\ &amp;= (1-\\alpha)\\times e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) + \\alpha\\times e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) \\end{split}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}^{\\prime\\prime}, \\mathsf{V}_{i,j}\\right) &amp;= \\sum_{i=0}^{d} e\\left((1-\\alpha) \\times \\mathsf{D}_{i,j} + \\alpha \\times \\mathsf{D}_{i,j}^{\\prime}, \\mathsf{V}_{i,j}\\right) \\\\ &amp;= (1-\\alpha) \\times \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}, \\mathsf{V}_{i,j}\\right) + \\alpha \\times \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}^{\\prime}, \\mathsf{V}_{i,j}^{\\prime}\\right) \\end{split}</span></div>

    <p class="text-gray-300">Since  <span class="math">\\alpha</span>  is computed as a hash of acc.x and acc'.x, except with negligible probability  <span class="math">e\\left(\\mathsf{C}_{j-1},\\mathsf{V}\\right) - \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j},\\mathsf{V}_{i,j}\\right) = 0</span>  and  <span class="math">e\\left(\\mathsf{C}_{j-1}&#x27;,\\mathsf{V}\\right) - \\sum_{i=0}^{d} e\\left(\\mathsf{D}_{i,j}&#x27;,\\mathsf{V}_{i,j}&#x27;\\right) = 0</span> . Similarly, replacing the accumulation witness by the extracted ones, we have that Eq.(ii)'s left side is</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=1}^{k-1} (\\mathsf{C}&#x27;&#x27;_j - \\langle \\vec{x}&#x27;&#x27;_j, \\vec{\\mathsf{D}}&#x27;&#x27;_j \\rangle) = \\sum_{j=1}^{k-1} ((1-\\alpha)\\mathsf{C}_j + \\alpha\\mathsf{C}&#x27;_k - \\langle (1-\\alpha)\\vec{x}_j + \\alpha\\vec{x}&#x27;_j, (1-\\alpha)\\vec{\\mathsf{D}}_j + \\alpha\\vec{\\mathsf{D}}&#x27;_j \\rangle)</span></div>

    <p class="text-gray-300">whereas from the verifier's output we have that the right side equals  <span class="math">(1-\\alpha) \\times \\mathsf{E}_{\\mathbb{G}} + \\alpha \\times \\mathsf{E}&#x27;_{\\mathbb{G}} + (1-\\alpha) \\cdot \\alpha \\times \\mathsf{Q}</span> . Because  <span class="math">\\alpha</span>  is computed as a hash of  <span class="math">\\mathsf{acc}.x</span>  and  <span class="math">\\mathsf{acc}&#x27;.x</span>  we have that except with negligible probability the equation hold for any X and, in particular, when X=1 we got  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}_j - \\langle \\vec{x}_j, \\vec{\\mathsf{D}}_j \\rangle = \\mathsf{E}_{\\mathbb{G}}</span>  and for X=0,  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}&#x27;_j - \\langle \\vec{x}&#x27;_j, \\vec{\\mathsf{D}}&#x27;_j \\rangle = \\mathsf{E}&#x27;_{\\mathbb{G}}</span> . With identical reasoning, we have that  <span class="math">\\langle \\mathbf{T}_k, \\vec{x}_k \\rangle - y = e_{\\mathbb{F}}</span>  and  <span class="math">\\langle \\mathbf{T}&#x27;_k, \\vec{x}&#x27;_k \\rangle - y&#x27; = e&#x27;_{\\mathbb{F}}</span> . Finally,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf{T}_k&#x27;&#x27;, \\mathbf{H}_k \\rangle = \\langle (1 - \\alpha)\\mathbf{T}_k + \\alpha\\mathbf{T}_k, \\mathbf{H}_k \\rangle = (1 - \\alpha)\\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle + \\alpha\\langle \\mathbf{T}_k&#x27;, \\mathbf{H}_k \\rangle</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{C}_{k-1}&#x27;&#x27; = (1-\\alpha)\\mathsf{C}_{k-1} + \\alpha\\mathsf{C}_{k-1}&#x27;</span></div>

    <p class="text-gray-300">which, as above, implies  <span class="math">C_{k-1} = \\langle \\mathbf{T}_k, \\mathbf{H}_k \\rangle</span> , and  <span class="math">C&#x27;_{k-1} = \\langle \\mathbf{T}&#x27;_k, \\mathbf{H}&#x27;_k \\rangle</span>  except with negligible probability. We conclude the extracted acc. w and acc'. w are valid witnesses. We now</p>

    <p class="text-gray-300">prove that if  <span class="math">\\mathsf{E}_\\mathbb{G} = e_\\mathbb{F} = 0</span> , we can extract a valid opening to  <span class="math">\\vec{c}</span> . That is,  <span class="math">(\\mathsf{acc}.x, \\mathsf{acc}.w)</span>  is a valid pair for the predicate  <span class="math">\\Phi</span> . Note that the first check by the decider is the same as  <span class="math">\\mathsf{KZH}&#x27;s</span>  verifier first check. Following above, from the second check we can extract that  <span class="math">\\sum_{j=1}^{k-1} \\mathsf{C}_j - \\langle \\vec{x}_j, \\mathsf{D}_j \\rangle = \\mathsf{E}_\\mathbb{G} = 0</span> . Since  <span class="math">\\mathsf{D}_j</span>  is base  <span class="math">\\mathsf{H}_j</span> , we have that  <span class="math">\\mathsf{C}_j - \\langle \\vec{x}_j, \\mathsf{D}_j \\rangle = 0</span>  for all  <span class="math">j \\in [k]</span> . Finally, the last check is  <span class="math">\\langle \\mathsf{T}_k, \\vec{x}_k \\rangle = y</span> , and we have extracted satisfying  <span class="math">\\mathsf{KZH}</span>  verifier checks, and thus can extract  <span class="math">p(\\vec{X}_1, \\ldots, \\vec{X}_k)</span>  such that  <span class="math">p(\\vec{x}_1, \\ldots, \\vec{x}_k) = y</span> .</p>

    <p class="text-gray-300">Background. Non-uniform IVC (N-IVC) [\\[KS22\\]](#page-41-12) extends the definition of IVC by allowing each step to execute one of several predefined instructions F1, F2, . . . , F<sup>k</sup> instead of a single instruction F. Previously, non-uniform IVC was implemented using a universal circuit that contains subcircuits for all instructions F<sup>i</sup> . This circuit evaluates all subcircuits and selects the correct output based on the program counter. However, this approach is inefficient because the prover must perform computations for every instruction, even though only one instruction is needed at each step, and the witness size of the universal circuit scales linearly with the sum of the witness sizes of all instructions, making it non-ideal both computation-wise and memory-wise. Non-uniform PCD (N-PCD) [\\[Zhe+23\\]](#page-42-0) is a similar work which extends the definition of PCD to support multiple instructions in the leaves instead of a single instruction.</p>

    <p class="text-gray-300">Previous work on non-uniform IVC. SuperNova [\\[KS22\\]](#page-41-12) introduced a more efficient method for N-IVC where the step circuit maintains a running accumulator U<sup>i</sup> (a relaxed committed R1CS instance) for each instruction F<sup>i</sup> . When receiving a new, fresh accumulator instance u<sup>i</sup> , the prover uses memory techniques (e.g. a Merkle tree or offline memory techniques [\\[Blu+91\\]](#page-43-11)) to select the appropriate running accumulator U<sup>i</sup> . Next, the prover accumulates U<sup>i</sup> with u<sup>i</sup> . This approach ensures the computational effort corresponds only to the selected instruction, but the witness size grows linearly with the sum of the witness sizes for all instructions F<sup>i</sup> .</p>

    <p class="text-gray-300">Protostar [\\[BC23\\]](#page-39-9) offers a similar improvement to construct N-IVC, leveraging the fact that committing to zeros with Pederson commitment incurs no additional cost. While it also reduces computational overhead, like SuperNova, it still requires the prover to manage a witness size that scales linearly with the sum of all instruction witnesses. Another drawback, Protostar's approach, unlike SuperNova, is dependent on Pederson being homomorphic and may not be compatible with hash-based polynomial commitment schemes.</p>

    <p class="text-gray-300">N-IVC and N-PCD from PA. We observe that polynomial accumulation offers more flexibility than circuit-specific accumulation. For example, each polynomial of degree d < D, can be seen as a polynomial of degree D by simply assuming the coefficients of x <sup>d</sup>+1, xd+2, . . . , x<sup>D</sup> are zero. As a result, given an accumulation scheme for a polynomial of degree D, different polynomials of degree d<sup>i</sup> < D can be accumulated by considering them as degree D. Supernova directly translates each circuit as an R1CS instance and since two different R1CS instances cannot be accumulated, the prover must keep one running accumulator for each instruction F<sup>i</sup> . However, similar to IVC from Spartan+PA in Section <a href="#page-24-0">5,</a> we leverage Spartan PIOP to translate each instruction F<sup>i</sup> as polynomials. Recalling Section <a href="#page-24-1">5.1,</a> to accumulate circuit F<sup>i</sup> , we need to accumulate polynomial ωi(·) corresponding to the R1CS witness and matrix evaluations of A<sup>i</sup> , B<sup>i</sup> and C<sup>i</sup> , corresponding to the R1CS construction of F<sup>i</sup> . Similar to Section <a href="#page-24-0">5,</a> we take two different strategies to handle the accumulation of witness polynomial ωi(·) and matrices evaluations. For each F<sup>i</sup> , assume its witness polynomial is of degree d<sup>i</sup> . We consider a running polynomial of degree d<sup>i</sup> < D, and in each step accumulate ωi(·) with this running PCS accumulator. However, the same strategy cannot be applied to matrix evaluations. Accumulating different A<sup>i</sup> , B<sup>i</sup> , and C<sup>i</sup> evaluations via PCS accumulation is impractical because the resulting accumulated matrices may not be sparse. This would lead to matrices with O(kn) non-zero elements instead of O(n), where k is the number of instructions. To address this, we adopt an approach similar to SuperNova's to handle matrix evaluations efficiently. To elaborate further, the prover maintains a separate running accumulator for each matrix evaluation. Using memory techniques, the prover dynamically selects the appropriate running accumulator at each step and updates it with fresh matrix evaluations. Notably, these matrix evaluations scale logarithmically with the size of the original circuit, which is a key factor in the efficiency of our N-IVC and N-PCD schemes compared to SuperNova.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our N-PCD approach, apart from witness size and decider time, also improves the prover's time. As previously mentioned in Section <a href="#page-27-0">5.3,</a> both SuperNova and Protostar approaches fail to work for N-PCD since accumulating two sets of running accumulators takes linear time in the combined size of all instructions. However, this is not the case for us, a running accumulator in our N-PCD approach based on Spartan+PA, similar to N-IVC, consists of a single PCS accumulator and k instances of the matrix evaluation accumulator, i.e. one per instruction. Accumulating two running accumulators requires accumulating the two corresponding PCS accumulators, plus accumulating each instance of the matrix evaluation accumulator with its corresponding instance. The initial task requires Pacc(max<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) computation and the latter takes P i log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. To conclude, each step of our N-PCD prover costs Pacc(max<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + P i log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. For example, when instantiated with a linear prover time accumulator such as KZH-fold, the prover time is max<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ P i log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, which is much smaller than P i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">compared to the previous approaches of building N-PCD. The decider algorithm for both N-IVC and N-PCD requires running the decider algorithm for the PCS accumulator, plus evaluating all polynomial extensions of A, B and C matrices. The former requires running Dacc on a polynomial of degree max<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">and the latter requires O( P i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F<sup>i</sup></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) field operations. Given that field operations are much less expensive than group operations, we expect the cost of the decider to be dominated by Dacc and hence our scheme has a much faster decider time than SuperNova and Protostar, which requires a linear number of scalar multiplications in the combined size of all circuits. We leave formalization and proofs to future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>`;
---

<BaseLayout title="KZH-Fold: Accountable Voting from Sublinear Accumulation (2025/144)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2025 &middot; eprint 2025/144
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="kzh-fold-accountable-voting-from-sublinear-accumulation-2025" />
  </article>
</BaseLayout>
