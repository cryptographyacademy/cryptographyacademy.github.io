---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1536';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Halo Infinite: Recursive zk-SNARKs from any Additive Polynomial Commitment Scheme';
const AUTHORS_HTML = 'Dan Boneh, Justin Drake, Ben Fisch, Ariel Gabizon';

const CONTENT = `    <p class="text-gray-300">Halo Infinite: Proof-Carrying Data from Additive Polynomial Commitments</p>

    <p class="text-gray-300">Dan Boneh^{1} Justin Drake^{2} Ben Fisch^{1} Ariel Gabizon^{3}</p>

    <p class="text-gray-300">^{1}Stanford University ^{2}Ethereum Foundation ^{3}AZTEC Protocol</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Polynomial commitment schemes (PCS) have recently been in the spotlight for their key role in building SNARKs. A PCS provides the ability to commit to a polynomial over a finite field and prove its evaluation at points. A succinct PCS has commitment and evaluation proof size sublinear in the degree of the polynomial. An efficient PCS has sublinear proof verification. Any efficient and succinct PCS can be used to construct a SNARK with similar security and efficiency characteristics (in the random oracle model).</p>

    <p class="text-gray-300">Proof-carrying data (PCD) enables a set of parties to carry out an indefinitely long distributed computation where every step along the way is accompanied by a proof of correctness. It generalizes incrementally verifiable computation and can even be used to construct SNARKs. Until recently, however, the only known method for constructing PCD required expensive SNARK recursion. A system called Halo first demonstrated a new methodology for building PCD without SNARKs, exploiting an aggregation property of the Bulletproofs inner-product argument. The construction was heuristic because it makes non-black-box use of a concrete instantiation of the Fiat-Shamir transform. We expand upon this methodology to show that PCD can be (heuristically) built from any homomorphic polynomial commitment scheme (PCS), even if the PCS evaluation proofs are neither succinct nor efficient. In fact, the Halo methodology extends to any PCS that has an even more general property, namely the ability to aggregate linear combinations of commitments into a new succinct commitment that can later be opened to this linear combination. Our results thus imply new constructions of SNARKs and PCD that were not previously described in the literature and serve as a blueprint for future constructions as well.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A polynomial commitment scheme (PCS) enables a prover to commit to a polynomial <span class="math">f\\in\\mathbb{F}[X]</span> of degree at most <span class="math">d</span>. Later, given two public values <span class="math">x,y\\in\\mathbb{F}</span>, the prover can convince a verifier that the committed polynomial <span class="math">f</span> satisfies <span class="math">y=f(x)</span> and that <span class="math">f</span> has degree at most <span class="math">d</span>. This is done using a public coin evaluation protocol called Eval. The PCS is said to be efficient if the verifier runs in time $o(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, and is said to be succinct if the commitment string and the communication complexity of Eval is </span>o(d\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This important concept was first introduced by Kate, Zaverucha, and Goldberg (KZG) <em>[x10]</em>, and has emerged as a key tool for building succinct and efficient non-interactive argument systems called SNARKs <em>[x2]</em>. A succinct and efficient PCS can be used to compile an information theoretic interactive proof system known as a Polynomial Interactive Oracle Proof <em>[x3]</em> (PIOP),</p>

    <p class="text-gray-300">or equivalently <em>Algebraic Holographic Proofs</em> <em>[CHM^{+}20]</em>), into a SNARK. There are many examples of <em>efficient</em> PIOPs for NP languages, where the verifier complexity is logarithmic or even constant in the size of the statement being proven. This construction paradigm led to several recent SNARK systems with improved characteristics, including very efficient pre-processing SNARKs with a universal trusted setup <em>[x11, CHM^{+}20, x10]</em> or no trusted setup <em>[x2, x12, x23, x16]</em>.</p>

    <p class="text-gray-300">The original PCS, called the KZG PCS <em>[x15]</em>, is both efficient and succinct. It is based on pairings and requires a linear size reference string generated by a trusted setup (a recent improvement shrinks the size of the reference string <em>[x3]</em>). Another PCS, called the Bulletproofs PCS <em>[BCC^{+}16, BBB^{+}18]</em>, does not require pairings or a trusted setup, and is succinct, but is not efficient. Some schemes are both efficient and succinct and do not require a trusted setup: DARK <em>[x2]</em> is based on groups of unknown order, and very recently Dory <em>[x14]</em> uses pairing-based commitments and generalized inner-product arguments <em>[x3]</em>. A post-quantum efficient and succinct PCS without trusted setup can be built using FRI <em>[x24, x16, x3]</em>. In practice, these schemes all have very different performance profiles and properties.</p>

    <p class="text-gray-300">A proof-carrying data (PCD) system <em>[x7, x4]</em> is a powerful primitive that is more general than a SNARK. Consider a distributed computation that runs along a path of <span class="math">t</span> ordered nodes. The computation is defined by a function <span class="math">F:\\mathbb{F}^{\\ell_{1}}\\times\\mathbb{F}^{\\ell_{2}}\\to\\mathbb{F}^{\\ell_{1}}</span> in which node <span class="math">i</span> takes two inputs: the output <span class="math">z_{i-1}\\in\\mathbb{F}^{\\ell_{1}}</span> of node <span class="math">(i-1)</span>, and a local input <span class="math">\\mathsf{loc}_{i}\\in\\mathbb{F}^{\\ell_{2}}</span>. The node outputs <span class="math">z_{i}=F(z_{i-1},\\mathsf{loc}_{i})\\in\\mathbb{F}^{\\ell_{1}}</span>. A PCD system enables each node to provide a proof to the next node which attests not only to the correctness of its local computation, but also to the correctness of all prior computations along the path. The work to produce/verify each local proof is proportional to the size of the local computation and is independent of the length of the path. A PCD system can be more generally applied to any distributed computation over a directed acyclic graph of nodes. An important performance metric of a PCD system is its <em>recursion threshold</em>: the minimum size complexity of <span class="math">F</span> for which recursion is possible. PCD is currently being used in practice to construct a “constant-size blockchain” system <em>[x13, x2]</em>, where the latest proof attests to the validity of all state transitions (i.e., transactions) in the blockchain history.</p>

    <p class="text-gray-300">PCD systems generalize <em>incrementally verifiable computation</em> (IVC), proposed by Valiant <em>[x21]</em>, where a machine outputs a proof after each step of computation that attests to the correct history of computation steps. This can be used to construct SNARKs for <em>succinct bounded RAM programs</em>, which captures many programs in practice that have a small memory footprint relative to their running time. It is also theoretically sufficient for constructing preprocessing SNARKs for arithmetic circuits <em>[x3]</em>.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Contributions</h3>

    <p class="text-gray-300">We define several abstract properties of a PCS and show that these abstract properties are sufficient to construct powerful proof systems, including PCD and IVC. These abstract constructions give a general and unified approach to understanding recent PCD constructions. We show that the PCS schemes mentioned above satisfy some or all of our abstract properties. In some cases, instantiating our abstract proof systems with these PCS schemes leads to new proof systems that were not previously known. In fact, we could instantiate the PCS in two different ways from <em>any</em> collision-resistant linear hash function <span class="math">h:\\mathbb{F}^{d}\\to\\mathbb{G}</span>, one that optimizes for the size of proofs passed along nodes of the PCD, and the other that optimizes for prover time (i.e., the size of the recursive</p>

    <p class="text-gray-300">statement).¹</p>

    <p class="text-gray-300">We begin by defining an additive PCS as a simple refinement of a PCS, where the space of commitment strings form a computational group <span class="math">\\mathbb{G}</span> under some binary operation add. Group elements must have representation size <span class="math">\\mathrm{poly}(\\lambda)</span> in terms of the security parameter <span class="math">\\lambda</span> of the PCS and add must run in time <span class="math">\\mathrm{poly}(\\lambda)</span>. This means that it is possible to efficiently compute integer linear combinations of commitments. Moreover, a second requirement is that the prover can efficiently derive a valid opening string to open the linear combination of commitments to the same linear combination of the underlying committed polynomials. Because <span class="math">\\mathbb{G}</span> is finite, the size of the linearly combined commitments is bounded, independent of the number of summands or sizes of the integer coefficients. A trivial way to impose a group structure on the commitment space of any PCS is to define <span class="math">\\mathbb{G}</span> as the group of formal linear combinations of commitment strings, however, this trivial group is not bounded and therefore does not qualify the PCS as additive.</p>

    <p class="text-gray-300">A useful property of an additive PCS is the ability to aggregate PCS evaluations, akin to signature aggregation. We define two flavors of PCS aggregation schemes: private and public. First, consider a tuple <span class="math">(C,x,y)\\in \\mathbb{G}\\times \\mathbb{F}^2</span>, where <span class="math">C</span> is a commitment to some polynomial <span class="math">f\\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>. We say that the prover has a witness for this tuple, if when the prover runs the Eval protocol with the verifier on input <span class="math">(C,x,y)</span>, the verifier accepts with probability one. A (private) aggregation scheme is an interactive protocol between a prover and a verifier where the public input known to both is <span class="math">\\ell</span> tuples <span class="math">(C_1,x_1,y_1),\\ldots ,(C_\\ell ,x_\\ell ,y_\\ell)\\in \\mathbb{G}\\times \\mathbb{F}^2</span>, and the public output is a single tuple <span class="math">(C^{<em>},x^{</em>},y^{<em>})\\in \\mathbb{G}\\times \\mathbb{F}^{2}</span>. At the end of the protocol, the verifier is convinced that if the prover has a witness for <span class="math">(C^{</em>},x^{<em>},y^{</em>})</span>, then it must also have witnesses for <span class="math">(C_i,x_i,y_i)</span> for all <span class="math">i\\in [\\ell]</span>. A private aggregation scheme is non-trivial if it is more efficient than running the Eval protocol on the <span class="math">\\ell +1</span> tuples. It is efficient if the verifier complexity is sublinear in the degree of the committed polynomials.</p>

    <p class="text-gray-300">A public aggregation scheme enables a prover who does not know the witnesses for the <span class="math">\\ell</span> input tuples to aggregate the non-interactive proofs for these tuples. This is also a two-party protocol where, for each <span class="math">i\\in [\\ell]</span>, both parties receive a tuple <span class="math">(C_i,x_i,y_i)\\in \\mathbb{G}\\times \\mathbb{F}^2</span> and a corresponding non-interactive proof <span class="math">\\pi_{i}</span>. The common output is a tuple <span class="math">(C^{<em>},x^{</em>},y^{*})\\in \\mathbb{G}\\times \\mathbb{F}^{2}</span> for which the prover has a witness. The prover can subsequently produce a non-interactive proof for this output tuple. Informally, a valid proof for the output tuple demonstrates the validity of each input proof for the input tuples. As there is no information asymmetry between the two parties, the protocol is only interesting if the verifier does significantly less work than the prover.</p>

    <p class="text-gray-300">A key theorem of this paper is that every additive PCS has an efficient private aggregation scheme. In fact, the theorem is more general. It is possible that a PCS is not additive, but there is still an efficient algorithm that takes as input a list of <span class="math">\\ell</span> commitments along with <span class="math">\\ell</span> integer coefficient weights, and outputs a new <span class="math">\\mathrm{poly}(\\lambda)</span>-size commitment in <span class="math">\\mathbb{G}</span> to the linear combination of the underlying committed input polynomials, along with a proof of correctness. We call this a linear combination scheme (LCS). The LCS is efficient if the verifier is sublinear in the degree of the committed polynomials. Moreover, if the LCS verifier complexity is asymptotically faster than running the Eval verifier <span class="math">\\ell</span> times, then we call the PCS linearly amortizable because it allows for opening linear combinations of commitments with amortized efficiency gains. If the PCS is additive it suffices to compute linear combinations of commitments over <span class="math">\\mathbb{G}</span> and no additional proof is required, hence every additive PCS is linearly amortizable. We prove that:</p>

    <p class="text-gray-300">¹A homomorphism <span class="math">h:\\mathbb{Z}^d\\to \\mathbb{G}</span> that is collision-resistant modulo <span class="math">p</span> suffices, i.e. finding collisions where <span class="math">\\mathbf{x}\\neq \\mathbf{y}</span> mod <span class="math">p</span> is intractable.</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1 (informal).</h6>

    <p class="text-gray-300">Every PCS that has an efficient linear combination scheme has an efficient private aggregation scheme. Every <em>succinct</em> additive PCS has an efficient public aggregation scheme.</p>

    <p class="text-gray-300">The formal statement of this result is in Theorem 3 and Theorem 6. As a concrete implication, we can take any linear collision-resistant hash function <span class="math">h:\\mathbb{F}^{d}\\to\\mathbb{G}</span> and build a trivial PCS where the evaluation proof outputs the entire polynomial. Although this is not succinct, it is still additive and thus, as the theorem states, it has an efficient private aggregation scheme. Additionally, combining this hash function with a succinct protocol for proving pre-images of <span class="math">h</span> would give a succinct additive PCS, which has an efficient public aggregation scheme. In fact, there exists a generic succinct protocol for proving pre-images of <span class="math">h</span> (Section 5).</p>

    <p class="text-gray-300">The first part of the result (private aggregation, Theorem 3) is based on a novel batched evaluation protocol for opening commitments to distinct polynomials at distinct points. Previously, standard batched evaluation techniques for homomorphic polynomial commitments included: (1) opening distinct commitments at the same point, and (2) opening a single commitment at multiple points. The first is accomplished by opening a random linear combination of the original commitments. The second is accomplished by interpolating a degree-<span class="math">n</span> polynomial <span class="math">t</span> over the <span class="math">n</span> opening points such that the committed polynomial <span class="math">f</span> is equal to <span class="math">t</span> over the domain <span class="math">H</span> of these points, and proving that <span class="math">f-t</span> is divisible by the zero polynomial <span class="math">z_{H}</span> over this domain. The prover computes a commitment <span class="math">C_{q}</span> to the quotient polynomial <span class="math">q:=\\frac{f-t}{z_{H}}</span> and proves that <span class="math">q\\cdot Z_{H}=(f-t)</span> by opening <span class="math">C_{q}</span> and <span class="math">C_{f}</span> at a random challenge point. Both of these standard batch evaluation protocols are single-round. We elegantly compose these two approaches to get a two-round protocol for batch opening <em>multiple</em> polynomials at <em>multiple</em> points. While the analysis of the standard batch evaluation protocol for a multiple commitments at a common point is based on the invertibility of a Vandermonde matrix, the analysis of our protocol relies on the invertibility of the Hadamard product of a random Vandermonde matrix with a square matrix of non-zero field elements (Lemma 8). The KZG instantiation of this protocol was presented in an earlier manuscript of our work <em>[x1]</em>.</p>

    <p class="text-gray-300">Our result for public aggregation (Theorem 6) leverages the generic private aggregation scheme from Theorem 3 combined with a generic succinct proof of knowledge of the classical homomorphism pre-image problem (Section 5), which has its roots in the Bulletproofs protocol. Public aggregation is a factor <span class="math">O(\\log d)</span> more costly (in communication size) than private aggregation.</p>

    <p class="text-gray-300">Aggregation schemes have a number of important applications to constructing PCS-based SNARKs. First, aggregation schemes can be used for batch evaluation of polynomial commitments in order to reduce the work of the verifier (Section 4). Second, in Section 6 we discuss a fascinating and powerful application of PCS aggregation to recursive proof systems. This application generalizes a construction by Bowe, Grigg, and Hopwood called Halo <em>[x2]</em>, which was also formalized and generalized by Bünz et. al. <em>[x3]</em>.</p>

    <h5 id="sec-5" class="text-base font-semibold mt-4">PCD and IVC from PCS aggregation</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose <span class="math">F:\\mathbb{F}^{\\ell}\\to\\mathbb{F}^{\\ell}</span> and we wish to prove the correctness of <span class="math">t</span> iterations of <span class="math">F</span>, i.e. that <span class="math">F^{(t)}(z_{0})=z_{t}</span>. It turns out that given any succinct PCS with an efficient aggregation scheme, it is possible to construct an efficient non-interactive proof system for this type of statement whose proof size and verification complexity is proportional to the size and verification complexity of the PCS on polynomials of degree $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, completely independent of </span>t$. As our results have shown, this includes any additive PCS and even non-additive schemes that have an efficient linear combination scheme. Most significantly, the PCS itself does not need to have efficient verification.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In fact, a PCS with an efficient aggregation scheme can be used to construct a PCD system. Not only does this mean that PCD, IVC, and preprocessing SNARKs can be constructed from any PCS with an efficient linear combination scheme, but we also expect this should lead to practical improvements over the prior proof bootstrapping techniques <em>[x1, x10]</em> whenever the verification complexity of the private aggregation is smaller than the verification complexity of Eval. We leave concrete performance analysis for future work, although follow up work <em>[BCL^{+}20]</em> has already shown that the instantiation of PCD based on our private aggregation scheme using a simple Pedersen hash function achieves an order-of-magnitude reduction in the size of the recursive statement (reducing the recursion threshold accordingly).</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 2 (informal).</h6>

    <p class="text-gray-300">PCD with proofs linear in the predicate size can be constructed from any PCS that has an efficient linear combination scheme. PCD with sublinear proofs can be constructed from any PCS with an efficient public aggregation scheme.</p>

    <p class="text-gray-300">In summary, our results pave the way for novel constructions of PCD, IVC, and SNARKs with new efficiency and security characteristics by directing the research effort towards PCS constructions that have the simple abstract additivity properties formalized in this paper. The constructions of PCD/IVC following this methodology do require a heuristic security assumption because they involve instantiating random oracles (more specifically, the Fiat-Shamir transform) with concrete hash functions. All known constructions of PCD/IVC require heuristic security (i.e., knowledge assumptions or concrete instantiations of random oracles) and there is evidence that this is inherent <em>[x7]</em>.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">Zero-knowledge compiler</h4>

    <p class="text-gray-300">In Appendix B we show that every additive PCS that additionally satisfies a technical condition we call <span class="math">m</span>-spanning, can be compiled into a hiding PCS with a zero-knowledge Eval protocol. <span class="math">m</span>-spanning means that commitments to polynomials of degree at most <span class="math">m</span> generate <span class="math">\\mathbb{G}</span>. Our compilation is generic, relying only on the additive property. Four of the aforementioned examples (Bulletproofs, Dory, KZG, and DARK) are 1-spanning. Our compiler is a generalization of the technique used to make the DARK PCS zero-knowledge <em>[x2]</em>, and also has its roots in Zero-Knowledge Sumcheck <em>[x6]</em>.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Batch evaluation for the KZG scheme and applications to pairing based zkSNARKs</h4>

    <p class="text-gray-300">In Appendix C, we focus specifically on the original PCS of Kate, Zaverucha and Goldberg <em>[x11]</em>. As our results apply to all additive schemes, one can naturally instantiate the batch evaluation scheme described in Section 4 for KZG. We show that for KZG, a more efficient batch evaluation in terms of prover communication in the Eval procedure is possible, at the expense of extra verifier operations. This exploits the “multiplicative” nature of KZG that makes it possible to check, given commitments to four polynomials <span class="math">f,g,h,z</span>, whether <span class="math">f\\cdot g\\equiv h\\cdot z</span>. This check is done using a single pairing computation over the given commitments. As an application of this batch evaluation, we reduce the proof length and prover run time of the PLONK zk-SNARK <em>[x12]</em>, at the expense of one extra verifier pairing.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.2 Related work</h3>

    <p class="text-gray-300">The construction of general purpose efficient SNARK systems is a hotly pursued topic. There are many examples of such proof systems that work for any NP relation *[x10, x16, x3, x</p>

    <p class="text-gray-300">GPR13, PHGR13, BCI+13, Gro16a, GM17, MBKM19, GWC19, CHM+20, BBHR19, BFS20, COS20, BGH19, Set20]. In addition to the PCS constructions mentioned earlier, there is also a scheme by Bootle et. al. <em>[BCC+16]</em> that achieves <span class="math">\\sqrt{n}</span> commitment size and Eval complexity based on any additively homomorphic commitment, and a similar lattice-based construction by Baum et. al. <em>[x1, BBC+18]</em>. In Section 5 we describe a construction of a PCS from any collision-resistant homomorphism based on our succinct proof of homomorphism pre-images (HPI) that has constant size commitment, logarithmic size proofs and linear verification time. Attema and Cramer <em>[x1]</em> described a generalization of Bulletproofs to proving linear forms of Pedersen committed vectors, which is a special case of our HPI protocol.</p>

    <p class="text-gray-300">Constructions of IVC/PCD use <em>recursive composition</em>, which enables the prover to prove knowledge of a proof that the verification algorithm would accept. Until recently, constructions following this paradigm placed a complete description of the proof verifier inside the recursive statement. Thus, PCD was limited to proof systems where the verifier description is sublinear in the statement being proven (i.e., SNARKs) <em>[x27, x3, x4, x10]</em>. The Halo protocol <em>[x2, x3]</em> was the first construction of PCD from an underlying inefficient proof system (combining the Sonic PIOP <em>[x15]</em> and the Bulletproofs PCS). There were two key ideas. The first was, in our terminology, a public aggregation scheme for the Bulletproofs PCS. The second was that the recursive statement can omit the inefficient portion of the proof system’s verifier, i.e. the Eval verifier. The Eval proof inputs to a PCD step are aggregated along with the output Eval proofs, and the recursive statement only checks that aggregation was done correctly. This aggregates all Eval proofs into a single evaluation proof that is checked once at the end, amortizing the cost of Eval verification over the distributed computation length (i.e., recursion depth). Bünz et. al. <em>[x2]</em> generalize this proof technique further using a primitive they call SNARK <em>accumulation schemes</em>. They also define PCS accumulation schemes, which can be combined with PIOP-based SNARKs to get a SNARK accumulation scheme. Our notion of public aggregation coincides with PCS accumulation. A small tweak to the definition of PCS accumulation we call <em>private</em> accumulation coincides with private aggregation and can be used to construct PCD with larger proofs (linear in the predicate size). Our results are thus perfectly complementary.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Basic notations</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an integer <span class="math">n\\geq 1</span>, we write <span class="math">[n]</span> to denote the set of integers <span class="math">\\{1,\\ldots,n\\}</span>. For any mathematical set <span class="math">\\mathcal{S}</span> the notation $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes the cardinality of </span>\\mathcal{S}<span class="math">. Unless specified otherwise, we use </span>\\lambda<span class="math"> to denote the security parameter. We say a function </span>f(\\lambda)<span class="math"> is negligible in </span>\\lambda<span class="math">, denoted by </span>\\mathsf{negl}(\\lambda)<span class="math">, if </span>f(\\lambda)=o(1/\\lambda^{c})<span class="math"> for all </span>c\\in\\mathbb{N}<span class="math">. We say an algorithm is efficient if it runs in probabilistic polynomial time in the length of its input. We use </span>\\mathsf{poly}(\\lambda)<span class="math"> to denote a quantity whose value is bounded by a fixed polynomial in </span>\\lambda<span class="math">. For a field </span>\\mathbb{F}<span class="math">, we use </span>\\mathbb{F}^{(<d)}[X]<span class="math"> for the set of polynomials in </span>\\mathbb{F}[X]<span class="math"> of degree at most </span>d<span class="math">. We use </span>\\{0,1\\}^{*}<span class="math"> to denote binary strings of arbitrary length and </span>\\varepsilon<span class="math"> to denote the empty string. We may use the notations </span>\\mathbb{F}_{p}<span class="math"> and </span>\\mathbb{Z}_{p}<span class="math"> interchangeably to denote the unique prime field of characteristic </span>p<span class="math">. For modular arithmetic, we use the notation </span>a\\equiv b\\ (\\bmod\\ n)<span class="math"> to denote that integers </span>a,b\\in\\mathbb{Z}<span class="math"> are equivalent modulo </span>n\\in\\mathbb{Z}<span class="math">. The notation </span>a\\bmod n<span class="math"> denotes the unique integer </span>b\\in[0,n)<span class="math"> such that </span>a\\equiv b\\ (\\bmod\\ n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For an abstract group, <span class="math">\\mathbb{G}</span> denotes the set of elements in the group, and for any <span class="math">g_1, g_2 \\in \\mathbb{G}</span> the element <span class="math">g_1 + g_2</span> is the result of applying the binary operation to <span class="math">g_1</span> and <span class="math">g_2</span>. The inverse of <span class="math">g \\in \\mathbb{G}</span> is denoted <span class="math">-g</span> and <span class="math">g_1 - g_2 := g_1 + (-g_2)</span>. For any <span class="math">n \\in \\mathbb{N}</span> and <span class="math">g \\in \\mathbb{G}</span> the element <span class="math">n \\cdot g</span> is defined as adding <span class="math">n</span> copies of <span class="math">g</span>. For <span class="math">n \\in \\mathbb{Z}</span>, <span class="math">n &amp;lt; 0</span>, then <span class="math">n \\cdot g</span> is defined as $-(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot g)<span class="math">. The group </span>\\mathbb{G}$ is called a computational group if there exist efficient algorithms for implementing the addition and inversion operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See §A.1 for the formal definition.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.1 Interactive proofs of knowledge</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">An NP relation <span class="math">\\mathcal{R}</span> is a subset of strings <span class="math">x, w \\in \\{0,1\\}^*</span> such that there is a decision algorithm to decide <span class="math">(x, w) \\in \\mathcal{R}</span> that runs in time polynomial in $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The language of </span>\\mathcal{R}<span class="math">, denoted </span>\\mathcal{L}_R<span class="math">, is the set </span>\\{x \\in \\{0,1\\}^<em> : \\exists w \\in \\{0,1\\}^</em> \\text{ s.t. } (x, w) \\in \\mathcal{R}\\}<span class="math">. The string </span>w<span class="math"> is called the witness and </span>x<span class="math"> the instance. An interactive proof of knowledge for an NP relation </span>\\mathcal{R}<span class="math"> is a special kind of two-party interactive protocol between a prover denoted </span>\\mathcal{P}<span class="math"> and a verifier denoted </span>\\mathcal{V}<span class="math">, where </span>\\mathcal{P}<span class="math"> has a private input </span>w<span class="math"> and both parties have a common public input </span>x<span class="math"> such that </span>(x, w) \\in \\mathcal{R}<span class="math">. Informally, the protocol is complete if </span>\\mathcal{P}(w)<span class="math"> always causes </span>\\mathcal{V}(pp, x)<span class="math"> to output 1 for any </span>(x, w) \\in \\mathcal{R}<span class="math">. The protocol is knowledge sound if there exists an extraction algorithm </span>\\mathcal{E}<span class="math"> called the extractor such that for every </span>x<span class="math"> and adversarial prover </span>\\mathcal{A}<span class="math"> that causes </span>\\mathcal{V}(pp, x)<span class="math"> to output 1 with non-negligible probability, </span>\\mathcal{E}<span class="math"> outputs </span>w<span class="math"> such that </span>(x, w) \\in \\mathcal{R}<span class="math"> with overwhelming probability given access to </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See §A.3 for the formal definitions of interactive proofs of knowledge with efficient provers.</p>

    <p class="text-gray-300"><strong>Fiat-Shamir transform</strong> The Fiat-Shamir transform preserves knowledge soundness for any constant-round public-coin interactive proof in the random oracle model, i.e. when the “hash function” is modeled as a random oracle [GK96, PS96]. The interactive protocol must have a negligible soundness error. More generally, Fiat-Shamir preserves knowledge soundness for multi-round interactive proofs that satisfy a property called state restoration soundness [BCS16], also equivalent to round-by-round soundness [CCH⁺19, Hol19]. There are also special classes of constant-round protocols for which the Fiat-Shamir transform can be instantiated using correlation-intractable hash functions [KRR17, CCRR18, CCH⁺19], or even simpler non-cryptographic hash functions [CLMQ20]. In general, the security of the Fiat-Shamir transform applied to a knowledge-sound interactive proof system using a concrete hash function is heuristic. There are known examples where the transform fails to preserve soundness.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> A knowledge-sound interactive proof system <span class="math">(\\mathcal{P},\\mathcal{V})</span> is FS compatible if there exists a hash family <span class="math">\\mathcal{H}</span> such that the non-interactive proof system <span class="math">(\\mathcal{P}_{FS},\\mathcal{V}_{FS})</span> obtained from applying Fiat-Shamir using an explicit hash sampled from <span class="math">\\mathcal{H}</span> is knowledge-sound.</p>

    <p class="text-gray-300"><strong>Zero Knowledge</strong> An interactive proof satisfies honest verifier zero-knowledge (HVZK) if there exists a simulator that does not have access to the prover’s private witness yet can produce convincing transcripts between the prover and an honest verifier that are statistically indistinguishable from real transcripts. The Fiat-Shamir transform compiles public-coin proofs that have</p>

    <p class="text-gray-300">7</p>

    <p class="text-gray-300">HVZK into non-interactive proofs that have statistical zero-knowledge (for possibly malicious verifiers). See §A.3 for the formal definition of HVZK and §A.2 for relevant background on probability distributions.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2.2 Hash functions</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 2 (Collision-resistant hashing).</strong> A hash function family <span class="math">\\mathcal{H} = \\{H_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> is a collection of functions such that <span class="math">H_{\\lambda} : \\mathcal{K}_{\\lambda} \\times \\mathcal{X}_{\\lambda} \\to \\mathcal{T}_{\\lambda}</span> where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}_{\\lambda}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\mathcal{A}<span class="math"> denote an algorithm that takes inputs </span>k \\in \\mathcal{K}_{\\lambda}<span class="math"> and let </span>\\mathsf{CR}<a href="\\lambda">\\mathcal{A}, \\mathcal{H}</a><span class="math"> denote the probability over </span>k \\in \\mathcal{K}_{\\lambda}<span class="math"> that </span>\\mathcal{A}<span class="math"> outputs a pair </span>(x, y) \\in \\mathcal{X}_{\\lambda}^{2}<span class="math"> such that </span>H_{\\lambda}(k, x) = H_{\\lambda}(k, y)<span class="math"> and </span>x \\neq y<span class="math">. </span>\\mathcal{H}<span class="math"> is a collision-resistant hash function (CRHF) family if </span>\\mathsf{CR}<a href="\\lambda">\\mathcal{A}, \\mathcal{H}</a><span class="math"> is a negligible function of </span>\\lambda<span class="math"> for all </span>\\mathcal{A}<span class="math"> with runtime polynomial in </span>\\lambda$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The above definition is asymptotic. As a more concrete way to define collision-resistance, we may say that <span class="math">H: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{T}</span> is a “<span class="math">\\lambda</span>-bit secure CRHF” if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{X}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and there is no probabilistic algorithm </span>\\mathcal{A}<span class="math"> that runs on input </span>k \\in \\mathcal{K}<span class="math"> and returns a collision </span>x \\neq y<span class="math"> such that </span>h(x) = h(y)<span class="math"> in expected time </span>2^{\\lambda}<span class="math"> steps. The probability is over the randomness of </span>h<span class="math"> and internal randomness of the algorithm. This precludes attacks that always find a collision in less than </span>2^{\\lambda}<span class="math"> steps, or that find a collision with probability </span>\\epsilon<span class="math"> in less than </span>\\epsilon \\cdot 2^{\\lambda}$ steps.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Whenever we informally refer to a hash function <span class="math">h: \\mathcal{X} \\to \\mathcal{T}</span> as collision-resistant, it is understood that <span class="math">h</span> is sampled from a family of keyed hash functions, i.e. <span class="math">h := H_{\\lambda}(k, \\cdot)</span> for <span class="math">k \\in \\mathcal{K}</span> and a chosen security level <span class="math">\\lambda \\in \\mathbb{N}</span>, where either <span class="math">\\{H_{\\lambda}\\}_{\\lambda \\in \\mathbb{N}}</span> is a CRHF family as in Definition 2 or a concrete <span class="math">\\lambda</span>-bit secure CRHF as defined above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 3 (Universal hashing).</strong> A family of keyed hash functions <span class="math">H: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{T}</span> is 2-universal if for all <span class="math">(x, y) \\in \\mathcal{X}^2</span> such that <span class="math">x \\neq y</span>, the probability over <span class="math">k \\in \\mathcal{K}</span> that <span class="math">H(k, x) = H(k, y)</span> is $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The classical Leftover Hash Lemma [HILL99] expresses how a 2-universal hash family can be used as randomness extractors to obtain an element distributed close to uniform over <span class="math">\\mathcal{T}</span> from any non-uniform random variable <span class="math">X</span> over <span class="math">\\mathcal{X}</span> that has more than $\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> bits of min-entropy. The min-entropy of </span>X<span class="math"> is defined as </span>\\mathbb{H}_{\\infty}(X) := -\\log \\max_{x \\in \\mathcal{X}} Pr[X = x]$. See §A.2 for relevant background on probability distributions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 1 (Leftover Hash Lemma).</strong> If <span class="math">H: \\mathcal{K} \\times \\mathcal{X} \\to \\mathcal{T}</span> is a 2-universal hash family, <span class="math">X</span> is a random variable over <span class="math">\\mathcal{X}</span>, <span class="math">Y := H(k, X)</span> is the random variable over <span class="math">\\mathcal{T}</span> for <span class="math">k \\in \\mathcal{K}</span>, and <span class="math">U_{\\mathcal{T}}</span> is the uniform distribution over <span class="math">\\mathcal{T}</span>, then $SD((Y, k), (U_{\\mathcal{T}}, k)) \\leq \\frac{1}{2} \\cdot \\sqrt{\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{2^{\\mathbb{H}_{\\infty}}(X)}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-14" class="text-2xl font-bold">2.3 Polynomial Commitment Scheme (PCS)</h2>

    <p class="text-gray-300">A polynomial commitment scheme, or PCS, is a triple of PPT algorithms, Setup, Commit, and Verify along with an evaluation protocol Eval, where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\lambda, d) \\to pp</span> a deterministic algorithm that outputs public parameters <span class="math">pp</span> for committing to polynomials of degree <span class="math">d</span>. The parameters <span class="math">pp</span> include a specification of an abelian commitment group <span class="math">\\mathbb{G}</span>, as defined below.</li>

      <li><span class="math">\\mathsf{Commit}(pp, f) \\to (\\mathsf{C}, \\mathsf{open})</span> outputs a commitment <span class="math">\\mathsf{C} \\in \\mathbb{G}</span> to the polynomial <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> and an opening "hint" <span class="math">\\mathsf{open} \\in \\{0,1\\}^*</span>.</li>

    </ul>

    <p class="text-gray-300">8</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verify  <span class="math">(pp, f, \\text{open}, \\mathsf{C})</span>  checks the validity of an opening hint open for a commitment  <span class="math">\\mathsf{C} \\in \\mathbb{G}</span>  to the polynomial  <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>  and outputs 1 (accept) or 0 (reject).</li>

      <li>Eval <span class="math">\\left(\\mathcal{P}(f, \\text{open}), \\mathcal{V}(pp, \\mathsf{C}, z, y)\\right) \\to (\\bot, b)</span>  is a public-coin interactive protocol between a prover who has the private input  <span class="math">(f, \\text{open})</span>  for  <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>  and a verifier who has the common public input  <span class="math">pp</span>  and  <span class="math">(\\mathsf{C}, z, y) \\in \\mathbb{G} \\times \\mathbb{F}^2</span> . The verifier outputs  <span class="math">b \\in \\{0, 1\\}</span>  and the prover has no output. The purpose of the protocol is to convince the verifier that  <span class="math">f(z) = y</span>  and  <span class="math">\\deg(f) &amp;lt; d</span> .</li>

    </ul>

    <p class="text-gray-300">All the algorithms run in time polynomial in  <span class="math">\\lambda</span>  and  <span class="math">d</span> . Furthermore, a scheme is correct if for all polynomials  <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>  and all points  <span class="math">z \\in \\mathbb{F}</span> , with probability 1 the verification  <span class="math">\\text{Verify}(pp, f, \\text{open}, \\mathsf{C})</span>  outputs 1 and likewise  <span class="math">\\mathcal{V}</span>  outputs 1 in interaction with  <span class="math">\\mathcal{P}</span>  in the Eval protocol on valid inputs. The formal correctness requirement is:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} &amp;amp; p p \\leftarrow \\text {S e t u p} (\\lambda , d) \\\\ b _ {1} \\wedge b _ {2} = 1: &amp;amp; (\\mathsf {C}, \\mathsf {o p e n}) \\leftarrow \\mathsf {C o m m i t} (p p, f) \\\\ &amp;amp; b _ {1} \\leftarrow \\text {V e r i f y} (p p, f, \\mathsf {o p e n}, \\mathsf {C}) \\\\ &amp;amp; y \\leftarrow f (z) \\\\ &amp;amp; (\\bot , b _ {2}) \\leftarrow \\mathsf {E v a l} \\big (\\mathcal {P} (f, \\mathsf {o p e n}), \\mathcal {V} (p p, \\mathsf {C}, z, y) \\big) \\end{array} \\right] = 1.</span></div>

    <p class="text-gray-300"><strong>Commitment group</strong> A commitment group  <span class="math">\\mathbb{G}</span>  is a computational group accompanied by two PPT algorithms: if  <span class="math">\\text{open}_f</span>  and  <span class="math">\\text{open}_g</span>  are opening hints for commitments  <span class="math">C_f</span>  and  <span class="math">C_g</span>  to polynomials  <span class="math">f, g \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> , then  <span class="math">\\text{add}^<em>(\\text{open}_f, \\text{open}_g)</span>  outputs an opening for  <span class="math">C_f + C_g</span>  to the polynomial  <span class="math">f + g</span>  and  <span class="math">\\text{invert}^</em>(\\text{open}_f)</span>  outputs an opening for  <span class="math">-C_f</span>  to the polynomial  <span class="math">-f</span> . This is a non-standard part of the PCS definition and may appear overly restrictive. However, it does not reduce the generality of a PCS. The default way to define  <span class="math">\\mathbb{G}</span>  is the space of formal linear combinations of commitments to elements of  <span class="math">\\mathbb{F}^{(&amp;lt;d)}[X]</span> . The default  <span class="math">\\text{add}^*</span>  would simply be concatenation.</p>

    <p class="text-gray-300">Explicit specification of  <span class="math">\\mathbb{G}</span> ,  <span class="math">\\mathsf{add}^<em></span> , and  <span class="math">\\mathsf{invert}^</em></span>  is convenient for defining the additivity properties of a PCS discussed in Section 3. This also serves to highlight how additivity is merely a refinement on  <span class="math">\\mathbb{G}</span> . The existence of  <span class="math">\\mathbb{G}</span> ,  <span class="math">\\mathsf{add}^<em></span> , and  <span class="math">\\mathsf{invert}^</em></span>  is not a distinguished property on its own.</p>

    <p class="text-gray-300"><strong>Efficiency/Succinctness</strong> If the Eval verifier runs in time  <span class="math">o(d)</span> , i.e. sublinear in the degree of the committed polynomial, then the PCS is called <strong>efficient</strong>. If both the size of commitments and communication complexity of the Eval protocol are  <span class="math">o(d)</span>  then the scheme is called <strong>succinct</strong>.</p>

    <p class="text-gray-300">A PCS could be succinct and not efficient. One example is a PCS based on the Bulletproofs system  <span class="math">\\left[\\mathrm{BCC}^{+}16, \\mathrm{BBB}^{+}18\\right]</span> . Some PCS applications may have stricter efficiency/succinctness requirements (e.g.,  <span class="math">\\mathsf{polylog}(d)</span>  length or run time). A non-succinct PCS is only interesting if it is hiding, and only distinguished from a regular hiding commitment scheme if it has a zero-knowledge evaluation protocol (defined below).</p>

    <p class="text-gray-300"><strong>Non-interactive Eval</strong> An interactive PCS Eval protocol may be compiled into a non-interactive Eval proof via the Fiat-Shamir transform. We use the notation  <span class="math">\\pi \\gets \\mathsf{NI - Eval}(pp,f,\\mathsf{open},C,x,y)</span>  and  <span class="math">b\\gets \\mathcal{V}_{\\mathsf{Eval}}(pp,\\pi ,C,x,y)</span> . The PCS Eval may already be non-interactive (e.g., KZG [KZG10]) in which case Fiat-Shamir is not needed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Security properties The scheme's algorithms (Setup, Commit, Verify) must be binding as a standard commitment scheme. Furthermore, the protocol Eval should be complete and a proof of knowledge. Informally, this means that any successful prover in the Eval protocol on common input  <span class="math">(\\mathsf{C},z,y)</span>  must know a polynomial  <span class="math">f(X)\\in \\mathbb{F}^{(&lt;d)}[X]</span> <span class="math">\\mathcal{C}</span>="" <span class="math">\\mathcal{c}</span>="" <span class="math">f(z)=&quot;y</span>" <span class="math">f\\in\\mathbb{f}^{(&lt;d)}[x]</span>="" <span class="math">f(z)=&quot;y</span>" <span class="math">g\\in\\mathbb{n}</span>="" <span class="math">h_0=&quot;b_1&quot; </span>i.e.<span class="math">=&quot;&quot; </span>i.e.<span class="math">=&quot;&quot; </span>j\\in\\mathbb{f}^{(<d)}[x]<span class="math">=&quot;&quot; </span>p_{eval}(pp,d)="\\left\\{\\langle" <span class="math">pp\\leftarrow=&quot;&quot; </span>pp\\leftarrow<span class="math">=&quot;&quot; </span>r<span class="math">=&quot;&quot; </span>r_{eval}(pp,d)<span class="math">=&quot;&quot; </span>x<span class="math">=&quot;&quot; </span>x<span class="math">:=&quot;&quot; </span>x^{i}<span class="math">=&quot;&quot; </span>x^{i}<span class="math">:=&quot;&quot; (</span>\\mathsf{c},z,y)<span class="math">=&quot;&quot; (binding=&quot;&quot; (knowledge=&quot;&quot; (knoting=&quot;&quot; (knoting,=&quot;&quot; (see=&quot;&quot; (see,=&quot;&quot; (see,=&quot;&quot; (see).=&quot;&quot; +=&quot;&quot; ,=&quot;&quot; -=&quot;&quot; .=&quot;&quot; 0</span>="" 1="" 1.="" 2="" 4="" 5="" \\lambda="" \\lambda<span class="math">=&quot;&quot; \\lambda)</span>="" \\lambda)<span class="math">=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)$:="" \\lambda)="" \\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math">=&quot;&quot; \\lambda)</span>="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)<span class="math">:=&quot;&quot; \\lambda)</span>:="" \\lambda)="" \\lambda)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">parameter <span class="math">B \\in \\mathbb{R}</span>. A PCS satisfies bounded witness zero-knowledge for <span class="math">\\mathcal{N}</span> if <span class="math">\\operatorname{Eval}(B)</span> is a public-coin HVZK interactive proof for the modified relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\mathsf{Eval}}(pp, d, \\mathcal{N}, B) = \\left\\{ \\begin{array}{l l} \\langle (\\mathsf{C}, z, y), (f, \\mathsf{open}) \\rangle : &amp;amp; f \\in \\mathbb{F}^{(&amp;lt;d)}[X] \\wedge f(z) = y \\wedge \\mathcal{N}(\\mathsf{open}) \\leq B \\\\ &amp;amp; \\mathsf{Verify}(pp, f, \\mathsf{open}, \\mathsf{C}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">"Relaxed" PCS openings For any PCS scheme, the Verify function can be relaxed such that it will accept an opening of the commitment <span class="math">t \\cdot \\mathsf{C}_f</span> to the polynomial <span class="math">h = t \\cdot f</span> for a integer <span class="math">t \\in \\mathbb{Z}</span> as a valid opening of <span class="math">\\mathsf{C}_f</span> to the polynomial <span class="math">f</span>.</p>

    <p class="text-gray-300">Lemma 2. Let <span class="math">\\mathcal{PCS} = (\\text{Setup}, \\text{Commit}, \\text{Verify}, \\text{Eval})</span> denote a PCS for polynomials over a field <span class="math">\\mathbb{F}</span> of characteristic <span class="math">p</span>. If the algorithm <span class="math">\\text{Verify}</span> is replaced with an algorithm <span class="math">\\text{Verify}^*</span> that accepts <span class="math">(f, (t, \\text{open}), \\mathsf{C})</span> if and only if <span class="math">t \\neq 0 \\mod p</span> and <span class="math">\\text{Verify}</span> accepts <span class="math">(h, \\text{open}, t \\cdot \\mathsf{C})</span> where <span class="math">h = t \\cdot f</span>, then the new PCS is still binding.</p>

    <p class="text-gray-300">Proof. Suppose an adversary outputs openings <span class="math">(f_1, (t_1, \\mathsf{open}_1))</span> and <span class="math">(f_2, (t_2, \\mathsf{open}_2))</span> to a commitment <span class="math">\\mathsf{C}</span> such that <span class="math">\\mathsf{Verify}^<em></span> accepts both and <span class="math">f_1 \\neq f_2</span>. This implies that <span class="math">\\mathsf{Verify}</span> accepts both <span class="math">(h_1, \\mathsf{open}_1, t_1 \\cdot \\mathsf{C})</span> and <span class="math">(h_2, \\mathsf{open}_2, t_2 \\cdot \\mathsf{C})</span> where <span class="math">h_1 = t_1 \\cdot f_1</span> and <span class="math">h_2 = t_2 \\cdot f_2</span>. Using the <span class="math">\\mathsf{add}^</em></span> operation, it would be possible to compute valid openings of <span class="math">t_1 t_2 \\cdot \\mathsf{C}</span> to both <span class="math">t_1 h_2 = t_1 t_2 \\cdot f_2</span> and <span class="math">t_2 h_1 = t_1 t_2 \\cdot f_1</span>. Since <span class="math">f_1 \\neq f_2</span> it follows that <span class="math">t_1 h_2 \\neq t_2 h_1</span>. Thus, this would contradict the binding property of the original PCS. <span class="math">\\square</span></p>

    <h2 id="sec-15" class="text-2xl font-bold">2.4 Module equations for PCS</h2>

    <p class="text-gray-300">The following lemmas are useful for knowledge soundness analysis (i.e., extraction) for protocols involving a PCS. Let <span class="math">\\mathbb{G}</span> denote an abelian group We first prove an elementary linear algebraic fact.</p>

    <p class="text-gray-300">Lemma 3. Let <span class="math">\\mathbb{G}</span> be a <span class="math">\\mathbb{Z}</span>-module. Let <span class="math">p</span> be a prime and <span class="math">\\mathbb{F} = \\mathbb{Z}_p</span>. Given two vectors <span class="math">\\mathbf{x},\\mathbf{y} \\in \\mathbb{G}^n</span> and a system of equations <span class="math">\\mathbf{A}\\mathbf{x} = \\mathbf{y}</span> for a matrix <span class="math">\\mathbf{A} \\in \\mathbb{Z}^{n \\times n}</span> that is invertible over <span class="math">\\mathbb{F}</span>, there is an efficient algorithm to derive a diagonal integer matrix <span class="math">\\mathbf{D}</span> with diagonal entries all non-zero modulo <span class="math">p</span> and a matrix <span class="math">\\mathbf{L}</span> such that <span class="math">\\mathbf{D} \\cdot \\mathbf{x} = \\mathbf{L} \\cdot \\mathbf{y}</span>. In particular, <span class="math">\\mathbf{L}\\mathbf{A} = \\mathbf{D}</span>.</p>

    <p class="text-gray-300">Proof. Since <span class="math">\\det(\\mathbf{A}) \\neq 0</span>, the matrix <span class="math">\\mathbf{A}</span> is invertible over the rationals <span class="math">\\mathbb{Q}</span>. Let <span class="math">\\mathbf{A}^{-1}</span> denote the inverse of <span class="math">\\mathbf{A}</span> over <span class="math">\\mathbb{Q}</span> and let <span class="math">\\mathbf{I}</span> denote the identity matrix over <span class="math">\\mathbb{Z}</span>. Set <span class="math">\\mathbf{L}</span> to be the matrix obtained by clearing the denominators of <span class="math">\\mathbf{A}^{-1}</span>, i.e. <span class="math">\\mathbf{L} = x \\cdot \\mathbf{A}^{-1}</span> where <span class="math">x \\neq 0</span> is the least common multiple of all denominators of the rational entries of <span class="math">\\mathbf{A}^{-1}</span>. The matrix <span class="math">\\mathbf{L} \\cdot \\mathbf{A} = x \\cdot \\mathbf{A}^{-1} \\cdot \\mathbf{A} = x \\cdot \\mathbf{I}</span> is a diagonal integer matrix. <span class="math">\\square</span></p>

    <p class="text-gray-300">The next lemma is a direct result of this fact. Suppose that <span class="math">\\mathbb{G}</span> is the abelian group for a PCS.</p>

    <p class="text-gray-300">Lemma 4. Given two vectors of commitments <span class="math">\\mathbf{C},\\mathbf{C}^{<em>}\\in \\mathbb{G}^{n}</span>, a system of equations <span class="math">\\mathbf{A}\\mathbf{C} = \\mathbf{C}^{</em>}</span> for an integer matrix <span class="math">\\mathbf{A}\\in \\mathbb{Z}^{n\\times n}</span> that is invertible over <span class="math">\\mathbb{F}_p</span>, and a vector of openings of <span class="math">\\mathbf{C}^<em></span> to a vector of polynomials <span class="math">\\mathbf{f}^{</em>} = (f_{1}^{<em>},...,f_{n}^{</em>})\\in (\\mathbb{F}^{(&amp;lt;d)}[X])^{n}</span>, there is an efficient algorithm to derive polynomials <span class="math">\\mathbf{f} = (f_1,\\dots,f_n)\\in (\\mathbb{F}^{(&amp;lt;d)}[X])^n</span>, integer vector <span class="math">\\mathbf{t}\\in \\mathbb{Z}^n</span> such that <span class="math">t_i\\neq 0\\bmod p</span>, and openings for each <span class="math">t_i\\cdot \\mathbf{C}_i</span> to the polynomial <span class="math">t_i\\cdot f_i\\bmod p</span> such that <span class="math">\\mathbf{A}\\cdot \\mathbf{f}\\equiv \\mathbf{f}^{*}</span> (mod <span class="math">p</span>).</p>

    <p class="text-gray-300">Proof. By Lemma 3, there exists a diagonal matrix <span class="math">\\mathbf{T}</span> with integer entries <span class="math">t_1, \\ldots, t_n \\neq 0 \\mod p</span> and a matrix <span class="math">\\mathbf{L}</span> such that <span class="math">\\mathbf{T} \\cdot \\mathbf{C} = \\mathbf{L} \\cdot \\mathbf{C}^<em></span> and <span class="math">\\mathbf{L} \\cdot \\mathbf{A} = \\mathbf{T}</span>. From each linear combination of <span class="math">\\mathbf{C}^</em></span>, we use <span class="math">\\mathsf{add}^*</span></p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">to derive an opening of <span class="math">t_i \\cdot \\mathbf{C}_i</span> to a polynomial <span class="math">g_i = \\langle \\mathbf{L}_i, \\mathbf{f}^<em> \\rangle \\in \\mathbb{F}[X]</span>. Let <span class="math">\\mathbf{g} = (g_1, \\dots, g_n)</span>. Finally, solve for the vector of polynomials <span class="math">\\mathbf{f}</span> such that <span class="math">\\mathbf{A} \\cdot \\mathbf{f} = \\mathbf{f}^</em></span> by computing <span class="math">\\mathbf{A}^{-1} \\bmod p</span>. Note that <span class="math">\\mathbf{L} \\cdot \\mathbf{A} \\cdot \\mathbf{f} = \\mathbf{T} \\cdot \\mathbf{f} = \\mathbf{L} \\cdot \\mathbf{f}^*</span> where <span class="math">\\mathbf{T}</span> is a diagonal matrix with entries <span class="math">t_i \\neq 0 \\bmod p</span>. Thus, <span class="math">t_i f_i = g_i</span>, for which we have a valid opening of <span class="math">t_i \\cdot \\mathbf{C}_i</span>. <span class="math">\\square</span></p>

    <p class="text-gray-300">This section defines an additive PCS as a simple refinement of a PCS, where the group of commitments is a computational group of bounded size. Recall that in our definition from Section 2.3, a PCS includes a specification of a family of commitment groups indexed by the parameters <span class="math">(\\lambda, d)</span>. We remarked that this is without loss of generality.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 6.</strong> A PCS is additive if every abelian commitment group <span class="math">\\mathbb{G}_{\\lambda,d}</span> determined by the public parameters <span class="math">pp \\stackrel{\\lambda}{\\leftarrow} \\text{Setup}(\\lambda, d)</span> is a computational group of size at most <span class="math">2^{\\text{poly}(\\lambda)}</span>. An additive PCS for polynomials in <span class="math">\\mathbb{F}^{(&amp;lt;d)}[X]</span> is additively succinct if the size of <span class="math">\\mathbb{G}_{\\lambda,d}</span> is $o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^d)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">There may be a group <span class="math">\\mathbb{G}</span> that satisfies the size constraints of Definition 6 but does not qualify as a commitment group but the <span class="math">\\mathsf{add}^*</span> operation only works for a bounded number of operations. Examples include DARK and lattice-based schemes [BFS20, BBC⁺18]. We call them bounded additive.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> A PCS over a field <span class="math">\\mathbb{F}</span> is homomorphic if for any <span class="math">\\lambda, d \\in \\mathbb{N}</span> the parameters <span class="math">pp \\gets \\text{Setup}(\\lambda, d)</span> determine two computational groups <span class="math">(\\mathbb{G}, \\mathbb{H})</span> and two polynomial time computable homomorphisms <span class="math">\\phi: \\mathbb{H} \\to \\mathbb{G}</span> and <span class="math">\\chi: \\mathbb{H} \\to \\mathbb{F}^{(&amp;lt;d)}[X]</span> such that the algorithm <span class="math">\\text{Verify}(pp, f, \\mathsf{C}, \\mathsf{open})</span> returns 1 if and only if <span class="math">\\phi(\\mathsf{open}) = \\mathsf{C}</span> and <span class="math">\\chi(\\mathsf{open}) = f</span>.</p>

    <p class="text-gray-300">We call <span class="math">\\mathbb{H}</span> the "hint" group. For a homomorphic PCS to be binding, the homomorphism <span class="math">\\phi : \\mathbb{H} \\to \\mathbb{G}</span> must be collision resistant over equivalence classes in <span class="math">\\mathbb{H}/ker(\\chi)</span> (i.e., finding <span class="math">x_1, x_2 \\in \\mathbb{H}</span> such that <span class="math">\\chi(x_1) \\neq \\chi(x_2)</span> and <span class="math">\\phi(x_1) = \\phi(x_2)</span> must be hard).</p>

    <p class="text-gray-300"><strong>An additive PCS gives a homomorphic PCS.</strong> Any additive PCS over a prime field <span class="math">\\mathbb{F} = \\mathbb{F}_p</span> and commitment group <span class="math">\\mathbb{G}</span>, can be efficiently transformed into a non-hiding homomorphic PCS with the same commitment group <span class="math">\\mathbb{G}</span>. The transformation maintains succinctness if the PCS is additively succinct. The new commitment algorithm will give a homomorphism <span class="math">\\phi : \\mathbb{Z}^d \\to \\mathbb{G}</span>. This is described in Appendix B. In fact, we further show how an additive PCS may be transformed into a hiding homomorphic PCS provided that commitments to the first <span class="math">m &amp;lt; d</span> monomials generate <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> A PCS is called <span class="math">m</span>-spanning if for any <span class="math">\\lambda, d \\in \\mathbb{N}</span> and <span class="math">pp \\gets \\text{Setup}(\\lambda, d)</span> the commitments <span class="math">(\\mathsf{C}_i, \\mathsf{open}_i) \\gets \\text{Commit}(pp, X^{i-1})</span> for <span class="math">i \\in [1, m]</span> generate <span class="math">\\mathbb{G}</span>, i.e. <span class="math">\\langle \\mathsf{C}_1, \\dots, \\mathsf{C}_m \\rangle = \\mathbb{G}</span>. A spanning PCS is <span class="math">m</span>-spanning for some <span class="math">m &amp;gt; 0</span>.</p>

    <p class="text-gray-300">It is possible that a PCS is not additive, yet there is still an efficient scheme to linearly combine polynomial commitments into a succinct aggregate commitment and later open this at points.</p>

    <p class="text-gray-300">Definition 9 (Linear Combination Scheme). A linear combination scheme for a PCS with commitment group <span class="math">\\mathbb{G}</span> is a public-coin interactive protocol LinCombine defined as follows. Given any <span class="math">\\mathbf{f} \\in \\mathbb{F}^{(&lt;d)}[X]^{\\ell}</span>, <span class="math">\\alpha \\in \\mathbb{F}^{\\ell}</span>, <span class="math">\\vec{C} \\in \\mathbb{G}^{\\ell}</span>, and a vector of openings <span class="math">\\text{open} = (\\text{open}_1, \\dots, \\text{open}_{\\ell})</span> such that <span class="math">\\text{Verify}(pp, f_i, \\text{open}_i, C_i) = 1</span> for all <span class="math">i \\in [\\ell]</span>, the protocol LinCombine does:</p>

    <div class="my-4 text-center"><span class="math-block">\\text{LinCombine}\\big(\\mathcal{P}(\\mathbf{f}, \\text{open}), \\mathcal{V}(pp, \\vec{C}, \\boldsymbol{\\alpha})\\big) \\to (\\text{open}^{*}, (C^{*}, b)\\big).</span></div>

    <p class="text-gray-300">The public output is <span class="math">(C^{<em>}, b) \\in \\mathbb{G} \\times \\{0, 1\\}</span> where <span class="math">b \\in \\{0, 1\\}</span> indicates success or failure. The private output is an opening <span class="math">\\text{open}^{</em>}</span> for <span class="math">C^{<em>}</span> to the polynomial <span class="math">\\sum_{i=1}^{\\ell} \\alpha_{i} \\cdot f_{i}</span>. As for the security, LinCombine composed with Eval on the output <span class="math">C^{</em>}</span> is a proof of knowledge for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{LinComb}}(pp, d) = \\left\\{ \\begin{array}{l l} \\big\\langle (\\vec{C}, C^{*}, \\boldsymbol{\\alpha}), (f, \\text{open}, \\text{open}^{*}) \\big\\rangle : &amp;amp; \\begin{array}{l} (C^{*}, (f, \\text{open}^{*})) \\in \\mathcal{R}_{\\text{Eval}}(pp, d) \\\\ (C, (f, \\text{open})) \\in \\mathcal{R}_{\\text{Eval}}(pp, d) \\\\ C = \\sum_{i} \\alpha_{i} \\cdot C_{i} \\end{array} \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">The trivial linear combination scheme simply returns the linear combination of the input commitments over the commitment group. This clearly satisfies the security definition because <span class="math">C^<em> = C</span> in this case. When a scheme is additively succinct then the trivial linear combination scheme is the most natural to use. The purpose of a non-trivial LinCombine is to return a <span class="math">C^</em></span> that is more succinct than <span class="math">C</span>. We call the scheme size-optimal if the aggregate commitment size is bounded by the worst case size of commitments to polynomials of degree <span class="math">d</span>.</p>

    <p class="text-gray-300">We remark that every PCS has a relatively uninteresting generic size-optimal linear combination protocol. The prover can simply compute a fresh commitment <span class="math">C^<em></span> to <span class="math">f = \\sum_{i=1}^{\\ell} \\alpha_i \\cdot f_i</span> and run <span class="math">\\ell + 1</span> instances of Eval on <span class="math">C^</em></span> and each <span class="math">C_i</span> at a common random point <span class="math">\\rho</span> selected by the verifier. The verifier can check the linear relation between the opening value of <span class="math">C^<em></span> at <span class="math">\\rho</span> and opening values of the list of <span class="math">C_i</span> at <span class="math">\\rho</span>. This satisfies the security definition simply because the LinCombine protocol itself is a proof of knowledge of an opening of <span class="math">C^</em></span> to <span class="math">f</span> and each <span class="math">C_i</span> to <span class="math">f_i</span> such that <span class="math">f = \\sum \\alpha_i \\cdot f_i</span>. A linear combination scheme is interesting when it is more efficient than this generic one.</p>

    <p class="text-gray-300">We say that a linear combination scheme is efficient if the verifier complexity in the protocol LinCombine is sublinear in the maximum degree of the input polynomials.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3.2 PCS examples and their additive properties</h2>

    <p class="text-gray-300">The table below summarizes the properties of several schemes. All major PCS constructions have efficient linear combination schemes, which beat the generic one. The linear combination scheme (LCS) amortization ratio (column 3) indicates the ratio of the communication/verification complexity of using the LCS to prove the evaluation of a linear combination (i.e. run Eval on the output of the LCS) versus the generic protocol of running <span class="math">\\ell</span> separate instances of Eval. This ratio is most relevant for the efficiency of batch evaluation (Section 4). The complexity ratio of the LCS verifier to the Eval verifier (column 5) is most relevant for the efficiency<span class="math">^4</span> of proof recursion (i.e., IVC/PCD) discussed in Section 6. The parameter <span class="math">\\ell</span> is the number of polynomial commitments being linearly combined and <span class="math">d</span> is their maximum degree.</p>

    <p class="text-gray-300"><span class="math">^4</span>The asymptotic ratio for KZG hides the fact that <span class="math">\\mathcal{V}_{\\text{Eval}}</span> involves a pairing operation while <span class="math">\\mathcal{V}_{\\text{LinCombine}}</span> has only <span class="math">\\ell \\cdot \\lambda</span> curve additions and thus is cheaper for small <span class="math">\\ell</span>.</p>

    <p class="text-gray-300">13</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">additive</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">LCS amortization</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VLinCombine</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VLinCombine</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VReal</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Bulletproofs</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">1/ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ/Ω(d)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Dory</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">1/ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ/Ω(log d)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG</td>

            <td class="px-3 py-2 border-b border-gray-700">yes</td>

            <td class="px-3 py-2 border-b border-gray-700">1/ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ/Ω(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DARK</td>

            <td class="px-3 py-2 border-b border-gray-700">bounded</td>

            <td class="px-3 py-2 border-b border-gray-700">1/ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">Oλ(ℓ)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ/Ω(log d)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">See §A.4 for an overview of the schemes.</p>

    <p class="text-gray-300">FRI: a non-additive PCS The Fast Reed-Solomon IOP of Proximity (FRI) [BBHR18] is a protocol for proving that a committed vector in  <span class="math">\\mathbb{F}^n</span>  is  <span class="math">\\delta</span> -close (in relative Hamming distance) to a Reed-Solomon (RS) codeword. FRI can be used to construct a PCS that is post-quantum. See §A.5 for more background on FRI.</p>

    <p class="text-gray-300">The FRI PCS is not additive by Definition 6, but it does have a protocol for opening a random linear combination that achieves amortized efficiency ratio of  <span class="math">\\frac{1}{\\ell} + \\frac{1}{\\Omega(\\log d)}</span>  over  <span class="math">\\ell</span>  commitments, which can also be extended to achieve amortized batch evaluation (e.g., Algorithm 8.2 of Aurora  <span class="math">[\\mathrm{BCR}^{+}19]</span> ).</p>

    <p class="text-gray-300">For the purpose of this section  <span class="math">\\mathbb{F} \\coloneqq \\mathbb{F}_p</span> , for some prime number  <span class="math">p</span> . It may be possible to generalize our results to work over extension fields, but that is beyond scope.</p>

    <p class="text-gray-300">The batch evaluation problem Let  <span class="math">f_{1}, \\ldots, f_{\\ell} \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>  and let  <span class="math">\\mathsf{C}_i</span>  be a commitment to  <span class="math">f_{i}</span>  for  <span class="math">i \\in [\\ell]</span> . The verifier has  <span class="math">pp</span>  and  <span class="math">\\mathsf{C}_1, \\ldots, \\mathsf{C}_{\\ell}</span> . For each  <span class="math">i \\in [\\ell]</span>  the verifier also has  <span class="math">(z_{i,1}, y_{i,1}), \\ldots, (z_{i,\\ell_i}, y_{i,\\ell_i}) \\in \\mathbb{F}^2</span> . The prover wants to convince the verifier that  <span class="math">f_{i}(z_{i,j}) = y_{i,j}</span>  for all  <span class="math">i \\in [\\ell]</span>  and  <span class="math">j \\in [\\ell_i]</span> .</p>

    <p class="text-gray-300">An alternative formulation of the batch evaluation problem is as follows. For each  <span class="math">i \\in [\\ell]</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let  <span class="math">\\Omega_{i} = \\{z_{i,1},\\ldots ,z_{i,\\ell_{i}}\\} \\subseteq \\mathbb{F}</span> , and</li>

      <li>let  <span class="math">t_i</span>  be the unique degree- <span class="math">(\\ell_i - 1)</span>  polynomial that satisfies  <span class="math">t_i(z_{i,j}) = y_{i,j}</span>  for all  <span class="math">j \\in [\\ell_i]</span> .</li>

    </ul>

    <p class="text-gray-300">The verifier has  <span class="math">(\\mathsf{C}_i,\\Omega_i,t_i)</span>  for  <span class="math">i\\in [\\ell ]</span>  . The batch evaluation problem is for the prover to convince the verifier that  <span class="math">f_{i}(x) = t_{i}(x)</span>  for all  <span class="math">i\\in [\\ell ]</span>  and  <span class="math">x\\in \\Omega_{i}</span>  . We will use this formulation of the problem from now on.</p>

    <p class="text-gray-300">When all the polynomials  <span class="math">t_i</span>  in the batch evaluation problem are identically zero (i.e.,  <span class="math">t_i \\equiv 0</span>  for all  <span class="math">i \\in [\\ell]</span> ) then the problem is called batch zero testing.</p>

    <p class="text-gray-300">We will present a black-box protocol for batch evaluation that saves on communication and verification complexity when the PCS has a linear combination protocol with an amortization ratio less than 1. The protocol invokes the evaluation protocol Eval of the PCS only once, no matter the number of input commitments  <span class="math">k</span> . Before presenting this protocol, we define a more powerful primitive that we call PCS aggregation.</p>

    <p class="text-gray-300">Aggregation scheme We define PCS proof aggregation, akin to signature aggregation. The aggregation of tuples  <span class="math">(C_1, x_1, y_1), \\ldots, (C_\\ell, x_\\ell, y_\\ell)</span>  is a single tuple  <span class="math">(C^<em>, x^</em>, y^<em>)</span>  such that running Eval to open  <span class="math">C^</em> \\in \\mathbb{G}</span>  at point  <span class="math">x^<em> \\in \\mathbb{F}</span>  to  <span class="math">y^</em> \\in \\mathbb{F}</span>  suffices to open each  <span class="math">C_i \\in \\mathbb{G}</span>  at  <span class="math">x_i \\in \\mathbb{F}</span>  to  <span class="math">y_i \\in \\mathbb{F}</span> . Aggregation enables batch evaluation, as shown in Figure 1.</p>

    <p class="text-gray-300">Figure 1: A batch evaluation protocol for multiple commitments at multiple points based on a PCS aggregation scheme.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(C, z, y, open, f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(C, z, y)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">((open<em>, f</em>), (C<em>, z</em>, y*, b1)) ← Aggregate(P(f, open), V(C, z, y))</td>

            <td class="px-3 py-2 border-b border-gray-700">Reject if b1 = 0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(⊥, b2) ← Eval(P(f<em>, open</em>), V(pp, C<em>, z</em>, y*))</td>

            <td class="px-3 py-2 border-b border-gray-700">Accept if b2 = 1</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Definition 10 (Aggregation). Let  <span class="math">\\mathcal{PCS} = (\\text{Setup}, \\text{Commit}, \\text{Verify}, \\text{Eval})</span>  denote a PCS with commitment group  <span class="math">\\mathbb{G}</span> . An aggregation scheme for  <span class="math">\\mathcal{PCS}</span>  is a public-coin interactive protocol Aggregate with public inputs  <span class="math">\\mathbf{C} = (C_1, \\dots, C_\\ell) \\in \\mathbb{G}^\\ell</span> ,  <span class="math">\\mathbf{x} \\in \\mathbb{F}^\\ell</span> ,  <span class="math">\\mathbf{y} \\in \\mathbb{F}^\\ell</span> , and private inputs  <span class="math">\\mathbf{f} \\in \\mathbb{F}^{(&amp;lt;d)}[X]^\\ell</span>  and  <span class="math">\\text{open} = (\\text{open}_1, \\dots, \\text{open}_\\ell)</span>  such that  <span class="math">\\text{Verify}(pp, f_i, \\text{open}_i, \\mathsf{C}_i) = 1</span>  for all  <span class="math">i \\in [\\ell]</span> :</p>

    <div class="my-4 text-center"><span class="math-block">A g g r e g a t e \\big (\\mathcal {P} (\\mathbf {f}, \\text {o p e n}), \\mathcal {V} (\\mathbf {C}, \\mathbf {x}, \\mathbf {y}) \\big) \\rightarrow ((\\text {o p e n} ^ {*}, f ^ {*}), (C ^ {*}, x ^ {*}, y ^ {*}, b))</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The public output is a tuple in  <span class="math">\\mathbb{G} \\times \\mathbb{F}^2 \\times \\{0,1\\}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\text{poly}(\\lambda)<span class="math">  independent of  </span>\\ell$ . The security requirement is that the batch evaluation protocol shown in Figure 1 is a proof of knowledge for the relation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {B a t c h E v a l}} (p p, d) = \\left\\{\\left\\langle (\\mathbf {C}, \\mathbf {x}, \\mathbf {y}), (\\mathbf {f}, \\text {o p e n}) \\right\\rangle : \\left(\\left(\\mathrm {C} _ {i}, x _ {i}, y _ {i}\\right), \\left(f _ {i}, \\text {o p e n} _ {i}\\right)\\right) \\in \\mathcal {R} _ {\\text {E v a l}} (p p, d) \\right\\}</span></div>

    <p class="text-gray-300">As for correctness, if the inputs to  <span class="math">\\mathcal{P}</span>  satisfy  <span class="math">\\mathcal{R}_{\\mathrm{BatchEval}}(pp,d)</span>  then  <span class="math">\\mathcal{V}</span>  outputs  <span class="math">b = 1</span>  and the private output  <span class="math">(\\mathrm{open}^<em>,f^</em>)</span>  satisfies  <span class="math">\\mathrm{Verify}(pp,f^{<em>},\\mathrm{open}^{</em>},C^{*}) = 1</span> .</p>

    <p class="text-gray-300">Theorem 3. Any PCS that has a linear combination scheme LinCombine (Definition 9) also has an aggregation scheme Aggregate (Definition 10) that on  <span class="math">\\ell</span>  input commitments makes a single call to LinCombine on  <span class="math">\\ell + 2</span>  commitments with  <span class="math">\\lambda</span> -bit integer coefficients. Both the prover and verifier do an additional  <span class="math">O(\\ell \\log \\ell)</span>  operations in  <span class="math">\\mathbb{F}</span> , and the prover makes one call to Commit on a polynomial of degree  <span class="math">\\max_i\\{\\deg(f_i)\\}</span> . The additional communication is one  <span class="math">\\mathbb{G}</span>  element and two  <span class="math">\\mathbb{F}</span>  elements.</p>

    <p class="text-gray-300">Corollary 1. Every additive PCS (Definition 6) has an aggregation scheme with prover complexity  <span class="math">O(\\ell \\log \\ell)</span>  operations in  <span class="math">\\mathbb{F}</span>  plus one Commit to a polynomial of degree  <span class="math">\\max_i\\{\\deg(f_i)\\}</span> , verifier complexity  <span class="math">O(\\ell \\log \\ell)</span>  operations in  <span class="math">\\mathbb{F}</span>  plus  <span class="math">O(\\ell \\cdot \\lambda)</span>  operations in  <span class="math">\\mathbb{G}</span> , and communication of one  <span class="math">\\mathbb{G}</span>  element plus two  <span class="math">\\mathbb{F}</span>  elements.</p>

    <p class="text-gray-300">We will say that an aggregation scheme is efficient if the verifier complexity of the protocol Aggregate is sublinear in the maximum degree of the input polynomials. By Corollary 1, every additive PCS, and more generally any PCS with an efficient linear combination scheme, has an efficient aggregation scheme.</p>

    <p class="text-gray-300">Corollary 2. If a PCS has an efficient linear combination scheme then it has an efficient aggregation scheme.</p>

    <p class="text-gray-300">We first construct a general protocol for batch zero testing. Batch evaluation is a simple generalization. The entire protocol is shown in Figure 2. The communication is comprised of one extra commitment and one evaluation protocol, independent of the number of input polynomials  <span class="math">k</span> . In Theorem 4 we show that the protocol is knowledge-sound.</p>

    <p class="text-gray-300">The protocol preserves zero-knowledge. The zero-knowledge simulator for this protocol samples  <span class="math">\\tilde{\\rho},\\tilde{r}\\gets \\mathbb{F}</span> , computes an integer representative  <span class="math">\\hat{z}\\in [0,p)</span>  for  <span class="math">z(\\tilde{r})^{-1}</span> , sets  <span class="math">\\tilde{\\mathbf{C}}_q\\coloneqq \\sum_{i = 1}^k\\tilde{\\rho}^{i - 1}z_i(\\tilde{r})\\cdot \\hat{z}\\cdot \\mathbf{C}_i</span>  and sets  <span class="math">\\tilde{\\mathbf{C}}_g\\coloneqq \\sum_{i = 1}^k\\tilde{\\rho}^{i - 1}z_i(\\tilde{r})\\cdot \\mathbf{C}_i - z(\\tilde{r})\\cdot \\tilde{\\mathbf{C}}_q</span> . If there exists an opening for each  <span class="math">\\mathbf{C}_i</span>  then there exists an opening of  <span class="math">\\mathbf{C}_i - z(\\tilde{r})\\cdot (\\hat{z}\\cdot \\mathbf{C}_i)</span>  to the zero-polynomial, and thus there exists an opening of  <span class="math">\\tilde{\\mathbf{C}}_g</span>  to the zero-polynomial. The simulator calls the Eval simulator on public input  <span class="math">(\\tilde{\\mathbf{C}}_g,\\tilde{r},0)</span>  to get a simulated transcript  <span class="math">\\tilde{\\pi}</span> . It output the final simulated transcript  <span class="math">(\\tilde{\\rho},\\tilde{\\mathbf{C}}_q,\\tilde{r},\\tilde{\\pi})</span> .</p>

    <p class="text-gray-300">Figure 2: A zero test for multiple polynomials on distinct sets: <span class="math">(\\mathsf{C}_i,\\mathsf{open}_i)\\gets \\mathsf{Commit}(pp,f_i)</span>  and  <span class="math">\\Omega_{i}</span>  is a non-empty subset of  <span class="math">\\mathbb{F}</span>  for all  <span class="math">i\\in [k]</span> . The prover computes  <span class="math">\\mathsf{open}_g</span>  from  <span class="math">\\rho ,r,\\mathsf{open}_1,\\ldots ,\\mathsf{open}_k</span>  (not shown).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P((f1, open1, Ω1), ..., (fk, openk, Ωk))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V((C1, Ω1), ..., (Ck, Ωk))</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ω := ∪k i=1 Ωi</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω := ∪k i=1 Ωi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z(X) := ∏ω∈Ω(X - ω)</td>

            <td class="px-3 py-2 border-b border-gray-700">z(X) := ∏ω∈Ω(X - ω)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i Ωi := Ω \\ Ωi</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i Ωi := Ω \\ Ωi</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i zi(X) := ∏ω∈Ωi(X - ω)</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i zi(X) := ∏ω∈Ωi(X - ω)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q(X) := ∑i=1k ρi-1zi fi/z</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ ←$ [0,p)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(Cq, openq) ← Commit(pp, q)</td>

            <td class="px-3 py-2 border-b border-gray-700">Cq → r ←$ [0,p)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g(X) := ∑i=1k ρi-1zi(r) fi(X) - z(r)q(X)</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i compute zi(r) ∈ F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(if all is valid then g(r) = 0)</td>

            <td class="px-3 py-2 border-b border-gray-700">C' := ∑i=1k ρi-1zi(r) · Ci</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   | Cg := C' - z(r) · Cq  |</p>

    <p class="text-gray-300">|  Eval(P(g, openg), V(Cg, r, 0))  |   |</p>

    <p class="text-gray-300">Theorem 4. If Eval is knowledge sound, then the protocol in Figure 2 is a proof of knowledge for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {Z T e s t} (p p, d) := \\left\\{\\left\\langle (\\mathsf {C}, \\Omega), (\\mathbf {f}, \\mathsf {o p e n}) \\right\\rangle : \\begin{array}{l} \\mathbf {f} = (f _ {1}, \\dots , f _ {k}) s. t. f _ {i} \\in \\mathbb {F} ^ {(&amp;lt;   d)} [ X ] \\\\ \\forall i \\in [ k ] \\forall_ {\\omega \\in \\Omega_ {i}} f _ {i} (\\omega) = 0 \\\\ \\forall i \\in [ k ] V e r i f y (p p, \\mathsf {C} _ {i}, \\mathsf {o p e n} _ {i}, f _ {i}) = 1 \\end{array} \\right\\}</span></div>

    <p class="text-gray-300">See §A.6 for the proof.</p>

    <p class="text-gray-300">17</p>

    <h2 id="sec-21" class="text-2xl font-bold">4.2 Batch evaluation protocol</h2>

    <p class="text-gray-300">The protocol for batch evaluation is a small generalization of the zero-testing protocol in Figure 2. Here, for <span class="math">i \\in [k]</span>, the verifier has <span class="math">(\\mathsf{C}_i, \\Omega_i, t_i)</span> where <span class="math">t_i \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>, and needs to be convinced that <span class="math">f_i(x) = t_i(x)</span> for all <span class="math">i \\in [k]</span> and all <span class="math">x \\in \\Omega_i</span>. This is the same as proving that every polynomial <span class="math">\\hat{f}_i := f_i - t_i</span> is zero on all of <span class="math">\\Omega_i</span>. Thus, we can apply the protocol in Figure 2 to <span class="math">\\hat{f}_1, \\dots, \\hat{f}_k</span>.</p>

    <p class="text-gray-300">Naively, the verifier would need to compute a commitment to each <span class="math">\\hat{f}_i</span>, which it can do from <span class="math">\\mathsf{C}_i</span> and <span class="math">t_i</span>. However, we can optimize the verifier by observing that the verifier only uses <span class="math">t_i(X)</span> to compute <span class="math">t_i(r)</span> for some random <span class="math">r \\in \\mathbb{F}</span>. Hence, we can replace the verifier's computation of <span class="math">\\mathsf{C}&#x27;</span> in Figure 2 by instead computing <span class="math">\\mathsf{C}&#x27; := \\sum_{i=1}^{k} \\rho^{i-1} z_i(r) \\cdot (\\mathsf{C}_i - t_i(r) \\cdot \\mathsf{C}^{(1)})</span> where <span class="math">\\mathsf{C}^{(1)}</span> is a commitment to the polynomial <span class="math">f \\equiv 1</span>. In doing so, we save the verifier the work to compute commitments to <span class="math">\\hat{f}_1, \\dots, \\hat{f}_k</span>.</p>

    <p class="text-gray-300"><strong>Theorem 5.</strong> If <em>Eval</em> is knowledge sound, then the batch evaluation protocol based on Figure 2 is a proof of knowledge for the relation <span class="math">\\mathcal{R}_{\\text{BatchEval}}(pp,d)</span>.</p>

    <p class="text-gray-300">See §A.6 for the proof.</p>

    <p class="text-gray-300">The protocol is still zero-knowledge if the PCS is hiding and Eval is zero-knowledge. The description of the simulator is nearly identical to the simulator for the protocol in Figure 2 so we will not repeat the details.</p>

    <h2 id="sec-22" class="text-2xl font-bold">4.3 Aggregation scheme (proof of Theorem 3)</h2>

    <p class="text-gray-300">When the PCS has a linear combination scheme (Definition 9), then the protocol from Section 4.2 together with the linear aggregation protocol LinCombine results in an aggregation scheme for the PCS. Concretely, the protocol on public inputs <span class="math">\\mathbf{C} = (C_1,\\dots,C_k)\\in \\mathbb{G}^k</span>, <span class="math">\\mathbf{x} = (x_{1},\\ldots ,x_{k})\\in \\mathbb{F}^{k}</span>, and <span class="math">\\mathbf{y} = (y_{1},\\dots,y_{k})\\in \\mathbb{F}^{k}</span> with prover private inputs <span class="math">\\mathbf{f} = (f_{1},\\dots,f_{k})\\in \\mathbb{F}^{(&amp;lt;d)}[X]^{k}</span> and <span class="math">\\text{open} = (\\text{open}_1,\\dots,\\text{open}_k)</span> operates as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Aggregate} \\left(\\mathcal {P} (\\mathbf {f}, \\text {open}), \\mathcal {V} (\\mathbf {C}, \\mathbf {x}, \\mathbf {y})\\right)\\rightarrow \\left(\\left(\\text {open} ^ {*}, f ^ {*}\\right), \\left(C ^ {*}, x ^ {*}, y ^ {*}, b\\right)\\right)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Omega_{i} = \\{x_{i}\\}</span> for <span class="math">i\\in [1,k]</span>, and let <span class="math">t_i\\coloneqq y_i</span>.</li>

      <li>Run the protocol in Section 4.2 with public inputs <span class="math">\\{(C_i,\\Omega_i,t_i)\\}_{i\\in [k]}</span> and prover private inputs <span class="math">\\{(f_i,\\mathrm{open}_i)\\}_{i\\in [k]}</span> up until the point that <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span> derive <span class="math">C_g</span>, the prover <span class="math">\\mathcal{P}</span> has privately derived <span class="math">g(X)</span>, and the verifier <span class="math">\\mathcal{V}</span> has sent the challenge <span class="math">r\\in \\mathbb{F}</span>. Note that <span class="math">C_g</span> is a linear combination of the input commitments <span class="math">\\mathbf{C}</span>, the <span class="math">C_q</span> sent during the protocol, and <span class="math">C^{(1)}</span> (the commitment to 1).</li>

      <li>The prover and verifier will run LinCombine to produce a succinct commitment <span class="math">\\mathsf{C}^*</span> to the same polynomial as <span class="math">\\mathsf{C}_g</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{C}&#x27; := (\\mathsf{C}_1, \\dots, \\mathsf{C}_k, \\mathsf{C}^{(1)}, \\mathsf{C}_q)</span></li>

      <li>Let <span class="math">\\mathbf{f}&#x27; := (f_1, \\dots, f_k, 1, q)</span> and let <span class="math">\\text{open}&#x27; = (\\text{open}_1, \\dots, \\text{open}_k, \\text{open}^{(1)}, \\text{open}_q)</span></li>

      <li>For <span class="math">i \\in [k]</span> let <span class="math">\\alpha_{i} := \\rho^{i - 1} \\cdot z_{i}(r) \\cdot f_{i}</span>, let <span class="math">\\alpha_{k + 1} := -\\sum_{i = 1}^{k}\\rho^{i - 1} \\cdot z_{i}(r) \\cdot y_{i}</span>, and let <span class="math">\\alpha_{k + 2} := -z(r)</span>. Let <span class="math">\\alpha := (\\alpha_{1}, \\dots, \\alpha_{k + 2})</span>.</li>

      <li>Run the protocol LinCombine <span class="math">(\\mathcal{P}(\\mathbf{f}&#x27;, \\mathrm{open}&#x27;), \\mathcal{V}(pp, \\mathbf{C}&#x27;, \\boldsymbol{\\alpha}) \\to (\\mathrm{open}^<em>, (C^</em>, b))</span>.</li>

      <li>The prover's private output is <span class="math">(\\mathrm{open}^{<em>},g)</span> and the verifier's public output is <span class="math">(C^{</em>},r,0,b)</span>.</li>

    </ul>

    <p class="text-gray-300">In the case that <span class="math">(C^{<em>},\\mathsf{open}^{</em>}) = (\\mathsf{C}_{g},\\mathsf{open}_{g})</span>, i.e. the PCS is additive, then composing this protocol with an Eval on <span class="math">\\mathsf{C}_g</span> is a special case of the batch evaluation protocol in Section 4.2, which by Theorem 5 is a proof of knowledge for relation <span class="math">\\mathcal{R}_{\\mathrm{BatchEval}}(pp,d)</span>. More generally, by the security property of the linear combination scheme LinCombine, composing the protocol with an Eval on <span class="math">(\\mathsf{C}^*,r,0)</span> is equivalent to running Eval on <span class="math">(\\mathsf{C}_g,r,0)</span>, i.e. it is a proof of knowledge of an opening for <span class="math">\\mathsf{C}_g</span> at the pair <span class="math">(r,0)</span>. Thus, this provides the extractor from Theorem 5 with the same information it needs to extract an <span class="math">\\mathcal{R}_{\\mathrm{BatchEval}}(pp,d)</span> witness.</p>

    <p class="text-gray-300">The prover complexity in the aggregation protocol is <span class="math">O(k\\log k)</span> operations in <span class="math">\\mathbb{F}</span> using FFTs plus the complexity of a single call to Commit on a polynomial of degree at most <span class="math">d</span>. The verifier complexity is <span class="math">O(k\\log k)</span> operations in <span class="math">\\mathbb{F}</span> and <span class="math">O(k\\cdot \\lambda)</span> operations in <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">The aggregation scheme in Definition 10 requires the aggregator, who plays the role of a prover, to know openings of all the input commitments. In a public aggregation scheme, the aggregator isn't required to know the openings of the input commitments but performs more work than the verifier. We define public aggregation only for a PCS with a non-interactive evaluation protocol NI-Eval.</p>

    <p class="text-gray-300">The verifier in the Aggregate protocol receives NI-Eval proofs <span class="math">\\pi_{i}</span> for each <span class="math">(C_i, x_i, y_i)</span> input tuple. The prover's output is <span class="math">(\\mathsf{open}^<em>, f^</em>)</span> and the verifier's output is <span class="math">(C^<em>, x^</em>, y^<em>, b)</span>. If the prover succeeds in the aggregation protocol (i.e., the verifier outputs <span class="math">b = 1</span>) and the verifier separately verifies the membership of <span class="math">(C^</em>, x^<em>, y^</em>)</span> in <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(pp, d)</span> then it should be convinced that each input tuple is also in <span class="math">\\mathcal{R}_{\\mathrm{Eval}}(pp, d)</span> with overwhelming probability.</p>

    <p class="text-gray-300"><strong>Definition 11 (Public Aggregation).</strong> Let <span class="math">\\mathcal{PCS} = (\\text{Setup}, \\text{Commit}, \\text{Verify}, \\text{NI-Eval})</span> denote a PCS with commitment group <span class="math">\\mathbb{G}</span> and a non-interactive evaluation protocol. A public aggregation scheme for <span class="math">\\mathcal{PCS}</span> is a public-coin interactive protocol Aggregate that has public inputs <span class="math">\\mathbf{C} = (C_1, \\dots, C_\\ell) \\in \\mathbb{G}^\\ell</span>, <span class="math">\\mathbf{x} \\in \\mathbb{F}^\\ell</span>, <span class="math">\\mathbf{y} \\in \\mathbb{F}^\\ell</span>, and <span class="math">\\boldsymbol{\\pi} = (\\pi_1, \\dots, \\pi_\\ell)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\text{Aggregate}(\\mathcal{P}, \\mathcal{V}(pp, \\pi, \\mathbf{C}, \\mathbf{x}, \\mathbf{y})) \\rightarrow ((\\mathsf{open}^*, f^*), (C^*, x^*, y^*, b))</span></div>

    <p class="text-gray-300">In a correct scheme, if the inputs satisfy <span class="math">\\mathcal{V}_{\\text{Eval}}(\\pi_i, C_i, x_i, y_i) = 1</span> for all <span class="math">i \\in [\\ell]</span>, then the outputs satisfy <span class="math">b = 1</span> and <span class="math">\\text{Verify}(pp, f^<em>, \\text{open}^</em>, C^*) = 1</span>. The soundness requirement is that the following probability is negligible:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} &amp;amp; \\text{pp} \\leftarrow \\text{Setup}(\\lambda, d) \\\\ b \\wedge \\mathcal{V}_{\\text{Eval}}(\\pi^*, C^*, x^*, y^*) = 1 &amp;amp; (\\mathbf{C}, \\mathbf{x}, \\mathbf{y}, \\boldsymbol{\\pi}) \\leftarrow \\mathcal{A}(pp) \\\\ \\exists_i \\mathcal{V}_{\\text{Eval}}(pp, \\pi_i, C_i, x_i, y_i) \\neq 1 \\\\ &amp;amp; ((\\mathsf{open}^*, f^*), (C^*, x^*, y^*, b)) \\leftarrow \\text{Aggregate}(\\mathcal{P}, \\mathcal{V}(pp, \\pi, \\mathbf{C}, \\mathbf{x}, \\mathbf{y})) \\\\ &amp;amp; \\pi^* \\leftarrow \\text{NI-Eval}(pp, f^*, \\mathsf{open}^*, C^*, x^*, y^*) \\end{array} \\right]</span></div>

    <p class="text-gray-300">A public aggregation scheme is <strong>efficient</strong> if the verifier complexity of the protocol Aggregate is sublinear in the maximum degree of the input polynomials.</p>

    <p class="text-gray-300"><strong>Theorem 6.</strong> There is a black-box compilation from any additive PCS over a prime field <span class="math">\\mathbb{F} = \\mathbb{F}_p</span> and commitment group <span class="math">\\mathbb{G}</span> into a publicly aggregatable homomorphic PCS with the same commitment group <span class="math">\\mathbb{G}</span>. The overhead of the new Eval is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Communication: <span class="math">O(\\log d)</span> additional elements of <span class="math">\\mathbb{G} \\times \\mathbb{F}</span></li>

      <li>Communication: <span class="math">O(\\log d)</span> additional elements of <span class="math">\\mathbb{G} \\times \\mathbb{F}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prover: <span class="math">O((\\log p + \\lambda) \\cdot n)</span> additional operations in <span class="math">\\mathbb{G}</span></li>

      <li>Verifier: <span class="math">O(\\log d)</span> additional operations in <span class="math">\\mathbb{G} \\times \\mathbb{F}</span></li>

    </ul>

    <p class="text-gray-300">The public aggregation scheme complexity for <span class="math">\\ell</span> commitments is:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Communication: One <span class="math">\\mathbb{G}</span> element and two <span class="math">\\mathbb{F}</span> elements.</li>

      <li>Prover: <span class="math">O(\\ell \\log \\ell)</span> operations in <span class="math">\\mathbb{F}</span>, <span class="math">O(\\log p \\cdot n)</span> operations in <span class="math">\\mathbb{G}</span>, and <span class="math">O(\\ell \\cdot n)</span> multiplications of <span class="math">\\lambda</span>-bit integers</li>

      <li>Verifier: <span class="math">O(\\ell \\log \\ell)</span> operations in <span class="math">\\mathbb{F}</span> and <span class="math">O(\\ell \\cdot \\lambda)</span> operations in <span class="math">\\mathbb{G}</span>.</li>

    </ul>

    <p class="text-gray-300">Theorem 6 is proven in two parts. First, there is a simple transformation from any additive PCS into a homomorphic PCS with the same commitment group and opening group <span class="math">\\mathbb{H} = \\mathbb{Z}^n</span>. Second, we present a compiler from any homomorphic PCS with opening group <span class="math">\\mathbb{H} = \\mathbb{Z}^n</span> into a new homomorphic PCS together with a public aggregation scheme that meets the performance requirements of the theorem. A key ingredient is a protocol for succinct proof of knowledge of homomorphism pre-image, which we present next.</p>

    <h2 id="sec-24" class="text-2xl font-bold">5.1 A Succinct PoK for Homomorphism Pre-image</h2>

    <p class="text-gray-300">Let <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> be any homomorphism where <span class="math">\\mathbb{G}</span> is an abelian computational group. We will present a succinct public-coin interactive proof of knowledge for the following relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {H P I}} ^ {*} (\\phi , \\mathbb {G}, p) = \\left\\{\\left(\\left(\\mathbf {x} \\in \\mathbb {Z} ^ {n}, t \\in \\mathbb {Z}\\right), y \\in \\mathbb {G}\\right): \\phi (\\mathbf {x}) = t \\cdot y \\wedge t \\neq 0 \\bmod p \\right\\}</span></div>

    <p class="text-gray-300">In the special case that <span class="math">p\\mathbb{Z} \\subseteq \\ker(\\phi)</span>, e.g. when <span class="math">\\mathbb{G}</span> has order <span class="math">p</span> or is an <span class="math">\\mathbb{F}_p</span>-vector space, a proof of knowledge for this relation is equivalent to a proof of knowledge for the standard homomorphism pre-image relation. In this case, given a witness <span class="math">(\\mathbf{x}, t)</span> for <span class="math">\\mathcal{R}_{\\mathrm{HPI}}^*</span> it is possible to efficiently compute an integer vector <span class="math">\\mathbf{x}&#x27;</span> such that <span class="math">\\phi(\\mathbf{x}&#x27;) = y</span> by computing <span class="math">\\hat{t} \\in \\mathbb{Z}</span> such that <span class="math">\\hat{t} \\equiv t^{-1} \\bmod p</span> and setting <span class="math">\\mathbf{x}&#x27; := \\hat{t} \\cdot x</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\{e_i\\}_{i\\in [n]}</span> denote the standard basis of <span class="math">\\mathbb{Z}^n</span> and define <span class="math">g_{i}\\coloneqq \\phi (e_{i})</span>. The homomorphism <span class="math">\\phi</span> may be rewritten as the <span class="math">\\mathbb{Z}</span>-linear map <span class="math">\\phi (\\mathbf{x}) = \\langle \\mathbf{x},\\mathbf{g}\\rangle = \\sum_{i = 1}^{n}x_{i}\\cdot g_{i}</span>. We will use <span class="math">\\llbracket \\mathbf{x}\\rrbracket_{\\mathbf{g}}</span> as a shorthand notation for <span class="math">\\langle \\mathbf{x},\\mathbf{g}\\rangle</span> given <span class="math">\\mathbf{x}\\in \\mathbb{Z}^n</span> and <span class="math">\\mathbf{g}\\in \\mathbb{G}^n</span>.</p>

    <p class="text-gray-300">Note the following two properties of <span class="math">\\llbracket \\cdot \\rrbracket</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Decomposition If <span class="math">\\mathbf{x} = (\\mathbf{x}_L, \\mathbf{x}_R)</span> for <span class="math">\\mathbf{x}_L \\in \\mathbb{Z}^{n_1}</span> and <span class="math">\\mathbf{x}_R \\in \\mathbb{Z}^{n_2}</span> such that <span class="math">n_1 + n_2 = n</span> and <span class="math">\\mathbf{g} = (\\mathbf{g}_L, \\mathbf{g}_R)</span> for <span class="math">\\mathbf{g}_L \\in \\mathbb{G}^{n_1}</span> and <span class="math">\\mathbf{g}_R \\in \\mathbb{G}^{n_2}</span>, then <span class="math">\\llbracket \\mathbf{x} \\rrbracket_{\\mathbf{g}} = \\llbracket \\mathbf{x}_L \\rrbracket_{\\mathbf{g}_L} + \\llbracket x_R \\rrbracket_{\\mathbf{g}_R}</span>.</li>

      <li>Bilinearity If <span class="math">\\alpha, \\beta \\in \\mathbb{Z}</span>, <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>, and <span class="math">\\mathbf{g}, \\mathbf{h} \\in \\mathbb{G}^n</span> then <span class="math">\\alpha[\\mathbf{x}]_{\\mathbf{g}} + \\beta[\\mathbf{x}]_{\\mathbf{h}} = [\\alpha \\mathbf{x}]_{\\mathbf{g}} + [\\beta \\mathbf{x}]_{\\mathbf{h}} = [\\alpha \\mathbf{g} + \\beta \\mathbf{h}]</span></li>

    </ol>

    <p class="text-gray-300">The public coin interactive proof is illustrated in Figure 3. The verifier's public-coin challenges are sampled uniformly from the set <span class="math">\\mathcal{X} \\coloneqq [0,2^{\\lambda})</span>.</p>

    <p class="text-gray-300">19</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 3: A succinct interactive protocol for HPI. For simplicity  <span class="math">n</span>  is a power of 2.</p>

    <p class="text-gray-300">Correctness If the prover follows the protocol honestly, then  <span class="math">\\llbracket \\mathbf{x}\\rrbracket_{\\mathbf{g}} = \\llbracket \\mathbf{x}_L\\rrbracket_{\\mathbf{g}_L} + \\llbracket \\mathbf{x}_R\\rrbracket_{\\mathbf{g}_R}</span> , and:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} y ^ {\\prime} = y _ {L} + \\alpha^ {2} y _ {R} + \\alpha y = [   [ \\mathbf {x} _ {L} ]   ] _ {\\mathbf {g} _ {R}} + [   [ \\alpha^ {2} \\mathbf {x} _ {R} ]   ] _ {\\mathbf {g} _ {L}} + [   [ \\alpha \\mathbf {x} _ {L} ]   ] _ {\\mathbf {g} _ {L}} + [   [ \\alpha \\mathbf {x} _ {R} ]   ] _ {\\mathbf {g} _ {R}} \\\\ = \\llbracket \\mathbf {x} ^ {\\prime} \\rrbracket_ {\\mathbf {g} _ {R}} + \\llbracket \\alpha \\mathbf {x} ^ {\\prime} \\rrbracket_ {\\mathbf {g} _ {L}} = \\llbracket \\mathbf {x} ^ {\\prime} \\rrbracket_ {\\mathbf {g} _ {R} + \\alpha \\mathbf {g} _ {L}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Thus, in each recursive round, if  <span class="math">\\mathbf{x}</span>  is a valid witness for  <span class="math">(y,n,\\mathbf{g})</span>  then  <span class="math">\\mathbf{x}&#x27;</span>  is a valid witness for  <span class="math">(y&#x27;,n&#x27;,\\mathbf{g}&#x27;)</span> .</p>

    <p class="text-gray-300">We include in Appendix A.8 a detailed discussion of the proof communication size, prover complexity, verifier complexity, and in particular, the capability for batch verification.</p>

    <p class="text-gray-300">Theorem 7. The protocol in Figure 3 is a proof of knowledge for the relation  <span class="math">\\mathcal{R}_{HPI}^{*}(\\phi, \\mathbb{G}, p)</span> .</p>

    <p class="text-gray-300">Proof. Our analysis will show the protocol is a proof of knowledge for the relation  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^* ([\\cdot ]],\\mathbb{G},p)</span> . For simplicity we assume  <span class="math">n</span>  is a power of 2. We define a knowledge extractor  <span class="math">\\mathcal{E}</span>  that runs with an adversary  <span class="math">\\mathcal{A}</span>  who succeeds for public input  <span class="math">(\\mathbf{x},y,\\mathbf{g})</span>  with probability  <span class="math">\\epsilon = 1 / \\mathrm{poly}(\\lambda)</span> .  <span class="math">\\mathcal{E}</span>  begins by invoking the forking lemma (Lemma 6) to generate a tree of accepting transcripts with the following characteristics:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The tree has depth  <span class="math">\\log n</span>  and branching factor 3. We will index nodes by  <span class="math">v \\in [0, n^{\\log 3})</span> .</li>

      <li>The root is labeled with the verifier's input  <span class="math">(y, \\mathbf{g})</span> .</li>

      <li>Each non-leaf node  <span class="math">v</span>  distinct from the root is labeled with a challenge  <span class="math">\\alpha_v</span>  and a prover message  <span class="math">(y_{v,0}, y_{v,1})</span> .</li>

      <li>Each non-leaf node  <span class="math">v</span>  has three children each labeled with three distinct verifier challenges.  <span class="math">\\alpha_{v,1} \\neq \\alpha_{v,2} \\neq \\alpha_{v,3}</span> .</li>

    </ul>

    <p class="text-gray-300">Each leaf node  <span class="math">v</span>  is labeled with a prover message  <span class="math">x_{v} \\in \\mathbb{Z}</span> .</p>

    <p class="text-gray-300">Since the probability of collision on a pair of challenges sampled uniformly from  <span class="math">\\mathcal{X}</span>  is  <span class="math">1 / 2^{\\lambda}</span> , by the forking lemma (Lemma 6) this tree-finding algorithm runs for time polynomial in  <span class="math">\\lambda</span>  and succeeds excepts with negligible probability in  <span class="math">\\lambda</span> .</p>

    <p class="text-gray-300">For any non-leaf node  <span class="math">v</span>  with parent  <span class="math">w</span>  and message pair  <span class="math">(y_{v,0}, y_{v,1})</span>  and challenge  <span class="math">\\alpha_v</span>  define  <span class="math">y_v := y_{w,0} + \\alpha_v^2 \\cdot y_{w,1} + \\alpha_v \\cdot y_w</span> . For any leaf node  <span class="math">v</span>  the value of  <span class="math">y_v</span>  is already defined by the transcript. For the root node  <span class="math">\\mathsf{rt}</span>  define  <span class="math">y_{\\mathsf{rt}} := y</span> , where  <span class="math">y</span>  is the input. We also define a value  <span class="math">\\mathbf{g}_v</span>  for every node  <span class="math">v</span>  as follows: if  <span class="math">v</span>  is the root then  <span class="math">\\mathbf{g}_v := \\mathbf{g}</span> , else if  <span class="math">v</span>  has a parent  <span class="math">w</span>  then  <span class="math">\\mathbf{g}_v := \\mathbf{g}_{w,0} + \\alpha_v \\cdot \\mathbf{g}_{w,1}</span>  where  <span class="math">\\mathbf{g}_w = (\\mathbf{g}_{w,0}, \\mathbf{g}_{w,1})</span>  is the concatenation of equal length vectors  <span class="math">\\mathbf{g}_{w,0}, \\mathbf{g}_{w,1}</span> . If  <span class="math">v</span>  is a node on the  <span class="math">i</span> th level up from the leaves then  <span class="math">\\mathbf{g}_v \\in \\mathbb{G}^{2^i}</span> . Every component of  <span class="math">\\mathbf{g}_v</span>  is a linear combination of the elements in  <span class="math">\\mathbf{g}</span>  derived from challenges along a path up the tree. Thus, for each  <span class="math">\\mathbf{g}_v</span>  the extractor also knows a matrix  <span class="math">\\mathbf{U}_v \\in \\mathbb{Z}^{2^i \\times n}</span>  such that  <span class="math">\\mathbf{U}_v \\cdot \\mathbf{g} = \\mathbf{g}_v</span> . By construction, for every root to leaf path of nodes  <span class="math">v_1, \\ldots, v_{\\log n}</span>  the sequence of values  <span class="math">(\\alpha_{v_i}, y_{v_i,0}, y_{v_i,1})</span>  form an accepting transcript between the prover and verifier where  <span class="math">(\\mathbf{g}_{v_i}, y_{v_i})</span>  are the verifier's local inputs in the  <span class="math">i</span> th round. Moreover, the leaf node labels satisfy  <span class="math">x_v \\cdot \\mathbf{g}_v = y_v</span> .</p>

    <p class="text-gray-300">We will show that given this tree, the extractor can compute  <span class="math">(t_v,\\mathbf{x}_v)\\in \\mathbb{Z}\\times \\mathbb{Z}^n</span>  for each node  <span class="math">v</span>  such that  <span class="math">\\llbracket \\mathbf{x}_v\\rrbracket_{\\mathbf{g}} = t_v\\cdot y_v</span> . In particular, this means that the extractor obtains a witness  <span class="math">(t_{\\mathsf{rt}},\\mathbf{x}_{\\mathsf{rt}})\\in \\mathbb{Z}\\times \\mathbb{Z}^n</span>  for  <span class="math">y\\in \\mathbb{G}</span>  such that  <span class="math">\\llbracket \\mathbf{x}_{\\mathsf{rt}}\\rrbracket_{\\mathbf{g}} = t_{\\mathsf{rt}}\\cdot y</span> . This is a valid pair for the relation  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^{*}([\\cdot ]\\cdot ,\\mathbb{Z}^{n},\\mathbb{G})</span> . The extractor begins at the leaves. Every leaf node is already labeled with  <span class="math">x_{v}\\in \\mathbb{Z}</span>  such that  <span class="math">x_{v}\\cdot \\mathbf{g}_{v} = x_{v}\\cdot \\mathbf{U}_{v}\\cdot \\mathbf{g} = y_{v}</span>  where  <span class="math">\\mathbf{U}_v\\in \\mathbb{Z}^{1\\times n}</span> . The extractor sets  <span class="math">\\mathbf{x}_v\\coloneqq x_v\\cdot \\mathbf{U}_v</span> . Next, suppose the extractor has already successfully computed an  <span class="math">(t_v,\\mathbf{x}_v)</span>  pair for all children nodes of a node  <span class="math">w</span> . For ease of notation, temporarily let  <span class="math">y_{1},y_{2},y_{3}</span>  denote the  <span class="math">y_{v}</span>  values for the three children and  <span class="math">\\alpha_{1},\\alpha_{3},\\alpha_{3}</span>  denote their respective challenge labels. Similarly, let  <span class="math">(\\mathbf{x}_i,t_i)\\in \\mathbb{Z}^n\\times \\mathbb{Z}</span>  for  <span class="math">i\\in [3]</span>  denote the extracted labels for the children nodes. By construction,  <span class="math">y_{i} = y_{w} + \\alpha_{i}^{2}y_{w,0} + \\alpha_{i}y_{w,1}</span>  for  <span class="math">i\\in [3]</span> . Defining  <span class="math">\\mathbf{A}\\in \\mathbb{Z}^{3\\times 3}</span>  to be the matrix with rows  <span class="math">(1,\\alpha_i^2,\\alpha_i)</span> ,  <span class="math">\\mathbf{T}</span>  the diagonal matrix with diagonal entries  <span class="math">t_1,t_2,t_3\\neq 0</span>  mod  <span class="math">p</span> , and  <span class="math">\\mathbf{X}\\in \\mathbb{Z}^{3\\times n}</span>  the integer matrix with rows  <span class="math">\\mathbf{x}_1,\\mathbf{x}_2,\\mathbf{x}_3</span> , we can summarize the relations:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {A} \\cdot \\left[ \\begin{array}{c} y _ {w} \\\\ y _ {w, 0} \\\\ y _ {w, 1} \\end{array} \\right] = \\left[ \\begin{array}{c} y _ {1} \\\\ y _ {2} \\\\ y _ {3} \\end{array} \\right] \\qquad \\mathbf {T} \\cdot \\left[ \\begin{array}{c} y _ {1} \\\\ y _ {2} \\\\ y _ {3} \\end{array} \\right] = \\left[ \\begin{array}{c} [   [ \\mathbf {x} _ {1} ]   ] _ {\\mathbf {g}} \\\\ [   [ \\mathbf {x} _ {2} ]   ] _ {\\mathbf {g}} \\\\ [   [ \\mathbf {x} _ {3} ]   ] _ {\\mathbf {g}} \\end{array} \\right] = \\mathbf {X} \\cdot \\mathbf {g}</span></div>

    <p class="text-gray-300"><span class="math">\\mathbf{T}</span>  is invertible over  <span class="math">\\mathbb{F}</span> . Since  <span class="math">\\mathbf{A}</span>  is Vandermonde it is also invertible over  <span class="math">\\mathbb{F}</span> . Therefore  <span class="math">\\mathbf{T} \\cdot \\mathbf{A}</span>  is invertible over both  <span class="math">\\mathbb{F}</span>  and  <span class="math">\\mathbb{Q}</span> . Setting  <span class="math">d</span>  to be the least common multiple of the denominators of all entries in  <span class="math">(\\mathbf{T} \\cdot \\mathbf{A})^{-1}</span>  over  <span class="math">\\mathbb{Q}</span> , there exists an integer matrix  <span class="math">\\mathbf{P}</span>  such that  <span class="math">\\mathbf{P} \\cdot \\mathbf{T} \\cdot \\mathbf{A} = d \\cdot \\mathbf{I}</span> , where  <span class="math">\\mathbf{I}</span>  is the identity matrix. In particular, we obtain  <span class="math">d \\cdot y_w = \\langle \\mathbf{P}_1, \\mathbf{X} \\cdot \\mathbf{g} \\rangle</span> . The extractor sets  <span class="math">\\mathbf{x}_w := \\langle \\mathbf{P}_1, \\mathbf{X} \\rangle</span>  and  <span class="math">t_w := d</span> , which now satisfies  <span class="math">[\\mathbf{x}_w]_{\\mathbf{g}} = \\langle \\mathbf{x}_w, \\mathbf{g} \\rangle = t_w \\cdot y_w</span> .</p>

    <h2 id="sec-25" class="text-2xl font-bold">5.2 Zero knowledge</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The protocol in Figure 3 is not zero-knowledge. There is a simple transformation that compiles any interactive proof for  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^{*}</span>  into a zero-knowledge proof while preserving knowledge-soundness. Technically, the transformed protocol constrains the max norm of the prover's witness. For  <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span>  define  $\\mathcal{N}(x) :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ . The transformed protocol is an HVZK interactive proof for the modified relation:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {B o u n d e d - H P I}} (\\phi , \\mathbb {G}, B) = \\left\\{\\left(\\mathbf {x} \\in \\mathbb {Z} ^ {n}, y \\in \\mathbb {G}\\right): \\phi (\\mathbf {x}) = y \\wedge \\mathcal {N} (\\mathbf {x}) &amp;lt;   B \\right\\}</span></div>

    <p class="text-gray-300">The transformation adds one extra round and increases communication by just  <span class="math">O(\\lambda)</span>  bits.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover samples random <span class="math">\\mathbf{r} \\in [-2^{3\\lambda-1}, 2^{3\\lambda-1}]^n</span> and sends <span class="math">h := \\llbracket \\mathbf{r} \\rrbracket_{\\mathbf{g}}</span> to the verifier.</li>

      <li>The verifier samples a challenge <span class="math">c \\in [0, 2^\\lambda)</span></li>

      <li>The prover and verifier run the proof of knowledge protocol for <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^*</span> where the prover's witness is <span class="math">\\mathbf{r} + c \\cdot \\mathbf{x}</span> and the common input is <span class="math">h + c \\cdot y</span>.</li>

    </ol>

    <p class="text-gray-300"><strong>Lemma 5.</strong> The transformed protocol is an <span class="math">n \\cdot 2^{-\\lambda}</span>-statistical HVZK interactive protocol for relation <span class="math">\\mathcal{R}_{\\text{Bounded-HPI}}(\\phi, \\mathbb{G}, 2^{\\lambda})</span>, and a proof of knowledge for relation <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^*(\\phi, \\mathbb{G}, p)</span>.</p>

    <p class="text-gray-300">See §A.7 for the proof.</p>

    <p class="text-gray-300"><strong>HPI proof aggregation</strong> It is possible to aggregate <span class="math">k</span> non-interactive HPI proofs (i.e., FS transform of Figure 3) for <span class="math">k</span> HPI instances into a single HPI instance and aggregate proof, without knowing the witnesses for the <span class="math">k</span> initial HPI statements. Verifying the aggregate proof convinces a verifier of the <span class="math">k</span> initial proofs. It is knowledge-sound in the sense that there is an extractor that gets the states of both the initial provers and the aggregation prover and can extract witnesses for the <span class="math">k</span> initial statements. Computing the aggregate proof costs <span class="math">O(kn)</span> work. The aggregate proof incurs only <span class="math">O(\\log n)</span> extra communication and combined with the initial proofs requires only <span class="math">O(k \\log n + n)</span> work to verify. The amortized verification time per proof is thus <span class="math">O(\\log n + n / k)</span>.</p>

    <p class="text-gray-300">Verification of the HPI protocol in Figure 3 is dominated by the cost of deriving the final base element <span class="math">g&#x27; \\in \\mathbb{G}</span> as an integer linear combination of the input bases <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> in order to check <span class="math">x&#x27; \\cdot g&#x27; = y&#x27;</span> (see discussion of batch verification in Appendix A.8). The key observation behind the aggregation protocol is that the verifier does not actually need to compute <span class="math">g&#x27;</span> as long as it is given a proof of knowledge that <span class="math">y&#x27;</span> is some linear combination of <span class="math">\\mathbf{g}</span>. The protocol is presented in Figure 4.</p>

    <p class="text-gray-300">The aggregation protocol in Figure 4 is also compatible with the zero-knowledge HPI protocol (Section 5.2). The zero-knowledge protocol reduces the HPI statement about a pre-image of <span class="math">y \\in \\mathbb{G}</span> to an HPI statement about a pre-image of some <span class="math">y + c \\cdot h \\in \\mathbb{G}</span>. The aggregation verifier must check the first round of the protocol to verify the reduction is correct, but otherwise the protocol in Figure 4 is used to aggregate the reduced statements.</p>

    <p class="text-gray-300"><strong>Theorem 8.</strong> For any <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> given by <span class="math">\\phi(\\mathbf{x}) = \\llbracket \\mathbf{x} \\rrbracket_{\\mathbf{g}}</span>, the composed protocol in which <span class="math">(\\mathcal{P}_{\\mathsf{HPI}}, \\mathcal{V}_{\\mathsf{HPI}})</span> run the protocol in Figure 3 on <span class="math">k</span> instances to generate <span class="math">k</span> (unchecked) transcripts and <span class="math">(\\mathcal{P}_{\\mathsf{agg}}, \\mathcal{V}_{\\mathsf{agg}})</span> run the protocol in Figure 4 on these transcripts, is a proof of knowledge for the relation:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R}_{\\text{MultiHPI}}^*(\\phi, \\mathbb{G}, p) = \\left\\{ \\left( \\left( \\mathbf{X} \\in \\mathbb{Z}^{n \\times k}, \\mathbf{t} \\in \\mathbb{Z}^k \\right), \\mathbf{y} \\in \\mathbb{G}^k \\right) : \\forall_{i \\in [k]} \\left( (t_i, \\mathbf{X}_i), y_i \\right) \\in \\mathcal{R}_{\\mathsf{HPI}}^*(\\phi, \\mathbb{G}, p) \\right\\}</span></div>

    <p class="text-gray-300"><strong>Proof Sketch</strong> We only provide a sketch of this proof. First, observe that in the analysis of Theorem 7 the extractor does not strictly need the labels <span class="math">(x_v, g_v)</span> such that <span class="math">x_v \\cdot g_v = y_v</span> at the leaves of the tree, which corresponds to the final round HPI instance for the normal HPI protocol in Figure 3. Rather, it simply uses these values as a way to derive a pre-image <span class="math">\\mathbf{x}_v</span> of <span class="math">y_v</span> such that <span class="math">\\phi(\\mathbf{x}_v) = y_v</span>. In fact, the extractor succeeds assuming it has any labels <span class="math">(t_v, \\mathbf{x}_v, y_v)</span> at the leaves of the tree such that <span class="math">\\phi(\\mathbf{x}_v) = t_v \\cdot y_v</span>. By the standard forking analysis, if <span class="math">\\mathcal{P}_{\\mathrm{agg}}</span> succeeds with non-negligible probability in the <span class="math">\\mathcal{P}_{\\mathrm{HPI}}</span> subroutine on HPI instance <span class="math">y^* = \\sum_{i=1}^k \\tau^{i-1} y_i</span>, then assuming knowledge-soundness of this subroutine there is an extractor that obtains witnesses <span class="math">(t_i, \\mathbf{w}_i)</span> for each <span class="math">y_i</span> such that <span class="math">\\phi(\\mathbf{w}_i) = t_i \\cdot y_i</span>. (This is based on the invertibility of a Vandermonde matrix). These are fed to the extractor for <span class="math">\\mathcal{P}_{\\mathrm{HPI}}</span> instead of <span class="math">(x_i&#x27;, g_i&#x27;)</span> for each <span class="math">i \\in [k]</span>, because the verifier <span class="math">\\mathcal{V}_{\\mathrm{agg}}</span> never checks that <span class="math">x_i&#x27; \\cdot g_i&#x27; = y_i&#x27;</span>.</p>

    <p class="text-gray-300">22</p>

    <p class="text-gray-300">Figure 4: Public aggregation for HPI with amortized verifier efficiency. The HPI instance is defined by  <span class="math">y \\in \\mathbb{G}</span>  and  <span class="math">\\mathbf{g} \\in \\mathbb{G}^n</span> . The public inputs are proof transcripts  <span class="math">(\\pi_1, \\dots, \\pi_k)</span>  where  <span class="math">\\pi_i</span>  consists of  <span class="math">r = \\log n</span>  prover messages  <span class="math">\\{(y_L^{(ij)}, y_R^{(ij)})\\}_{j=1}^r</span>  and the prover's final message  <span class="math">x_i&#x27; \\in \\mathbb{Z}</span> . The algorithm  <span class="math">(y&#x27;, b) \\gets \\mathcal{V}_{\\mathsf{HPI}}^*(n, y_i, \\pi_i)</span>  denotes a modification of the non-interactive verifier  <span class="math">\\mathcal{V}_{\\mathsf{HPI}}</span>  which only partially verifies the transcript  <span class="math">\\pi_i</span> . It derives the FS simulated challenges  <span class="math">\\{\\alpha_{ij}\\}_{j=1}^r</span>  for each round, checks the correctness of the prover messages  <span class="math">\\{(y_L^{(ij)}, y_R^{(ij)})\\}_{j=1}^r</span> , and derives the final round  <span class="math">y_i&#x27;</span> . It does not derive the final round  <span class="math">g_i&#x27;</span>  nor check that  <span class="math">x_i&#x27; \\cdot g_i&#x27; = y_i&#x27;</span> . It returns  <span class="math">(y_i&#x27;, 1)</span>  if these checks pass and  <span class="math">(\\bot, 0)</span>  otherwise.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pagg(y ∈ Gk, (π1, ..., πk), g)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Vagg(y ∈ Gk, (π1, ..., πk), g)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i∈[k] ui(X) := ∏j=1 log n(αij + X2j-1)</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i∈[k] (yi', bi) ← V*HPI(n, yi, πi)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ui ∈ Zn coeff. of ui(X)</td>

            <td class="px-3 py-2 border-b border-gray-700">If ∃i bi = 0 fail</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">←τ</td>

            <td class="px-3 py-2 border-b border-gray-700">τ ←(0, 2λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">u* := ∑i=1 k τi-1 · xi · ui</td>

            <td class="px-3 py-2 border-b border-gray-700">y* := ∑i=1 k τi-1 · yi'</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">PHPI(n, u<em>, y</em>)</td>

            <td class="px-3 py-2 border-b border-gray-700">←Protocol in Figure 3 VHPI(n, y*, g)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A collision-resistant homomorphism  <span class="math">h: \\mathbb{Z}^d \\to \\mathbb{G}</span>  and a succinct proof of knowledge for  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^*(h, \\mathbb{G}, p)</span>  can be used to construct a homomorphic PCS over  <span class="math">\\mathbb{F}_p</span> . The homomorphism  <span class="math">h</span>  can only be collision resistant if the order of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is computationally difficult to find. In the case that  </span>p =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is known and  </span>h: \\mathbb{Z}_p^d \\to \\mathbb{G}<span class="math">  is collision-resistant then the resulting PCS commits to polynomials over  </span>\\mathbb{F}_p[X]$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Additionally, in the case that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q<span class="math">  is known, the resulting PCS can still be used to commit to polynomials over  </span>\\mathbb{F}_p<span class="math">  for  </span>p &lt; q<span class="math"> , however, the PCS will not be strictly homomorphic. It will still satisfy the property that there is a homomorphism mapping open  </span>\\mapsto \\mathbb{C}<span class="math"> , but no surjective homomorphism  </span>\\chi : \\mathbb{Z}_q^d \\to \\mathbb{F}_p<span class="math">  exists for  </span>p \\neq q<span class="math"> . A PCS of this kind may still have interesting additivity properties, such as supporting a bounded number of commitment additions using the group operations in  </span>\\mathbb{G}<span class="math"> . This category also includes constructions from a homomorphism that is only collision-resistant over a constrained subset of  </span>\\mathbb{Z}_q^d<span class="math">  that includes  </span>[0, p)^d$ , such as lattice constructions based on Integer SIS [BBC+18]. A study of somewhat homomorphic PCS schemes is beyond the scope of this work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">More precisely, this section shows how to construct a homomorphic PCS for polynomials over a field  <span class="math">\\mathbb{F}_p</span>  given a homomorphism  <span class="math">h: \\mathbb{Z}^d \\to \\mathbb{G}</span>  that is collision resistant (i.e., sampled from a CRHF family) for any group such that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq p<span class="math"> , and a proof of knowledge for  </span>\\mathcal{R}_{\\mathsf{HPI}}^*(h, \\mathbb{Z}^d, \\mathbb{G})<span class="math"> . The construction is the same for the case that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p<span class="math">  and  </span>h: \\mathbb{Z}_p^d \\to \\mathbb{G}<span class="math">  is collision-resistant. The commitment is a single element in  </span>\\mathbb{G}$  and the evaluation protocol inherits the communication complexity of the HPI proof of knowledge protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For a point  <span class="math">\\alpha \\in \\mathbb{F}</span> , let  <span class="math">\\pmb{\\alpha} \\coloneqq (1, \\alpha, \\alpha^2, \\dots, \\alpha^{d-1})</span>  and define the homomorphism  <span class="math">\\phi_{\\alpha}: \\mathbb{Z}^d \\to \\mathbb{G} \\times \\mathbb{F}</span>  as  <span class="math">\\phi_{\\alpha}(\\mathbf{x}) = (h(\\mathbf{x}), \\langle \\mathbf{x}, \\pmb{\\alpha} \\rangle \\bmod p)</span> . The following is a construction of a non-hiding PCS over  <span class="math">\\mathbb{F}_p[X]</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup  <span class="math">(\\lambda, d) \\to pp</span> : output the group  <span class="math">\\mathbb{G}</span>  and the  <span class="math">\\lambda</span> -bit secure CRHF  <span class="math">h</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}(pp, f) \\to (\\mathsf{C}, \\mathsf{open})</span>: For <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> with coefficient vector <span class="math">\\mathbf{f} \\in \\mathbb{Z}^d</span>, set <span class="math">\\mathsf{open} := (1, \\mathbf{f})</span> and output the commitment <span class="math">\\mathsf{C} := h(\\mathbf{f})</span>.</li>

      <li><span class="math">\\mathsf{Verify}(pp, f, \\mathsf{open}, \\mathsf{C})</span>: parse <span class="math">\\mathsf{open} = (t, \\mathbf{f}^<em>) \\in \\mathbb{Z} \\times \\mathbb{Z}^d</span>, check that <span class="math">t \\neq 0 \\mod p</span>, <span class="math">h(\\mathbf{f}^</em>) = t \\cdot \\mathsf{C}</span>, and <span class="math">\\mathbf{f}^* \\mod p</span> is the coefficient vector of <span class="math">t \\cdot f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>.</li>

      <li><span class="math">\\mathsf{Eval}\\big(\\mathcal{P}(f,\\mathsf{open}),\\mathcal{V}(\\mathsf{C},\\alpha ,\\beta)\\big)</span>: Run the HPI protocol for relation <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^{*}(\\phi_{\\alpha},\\mathbb{Z}^{d},\\mathbb{G})</span>. This shows knowledge of a witness <span class="math">(t,\\mathbf{x})\\in \\mathbb{Z}\\times \\mathbb{Z}^d</span> such that <span class="math">\\phi_{\\alpha}(\\mathbf{x}) = (t\\cdot \\mathsf{C},t\\cdot \\beta)</span> and hence that <span class="math">\\mathsf{Verify}(pp,f,(t,\\mathbf{x}),\\mathsf{C}) = 1</span> and <span class="math">f(\\alpha) = \\beta</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To see that this is homomorphic, every opening string is in the group <span class="math">\\mathbb{H} \\coloneqq \\mathbb{Z} \\times \\mathbb{Z}^d</span>, every <span class="math">(\\mathsf{C}, \\mathsf{open})</span> pair is related by the homomorphism <span class="math">\\phi: \\mathbb{H} \\to \\mathbb{G}</span> that maps <span class="math">(t, \\mathbf{x}) \\mapsto h(\\mathbf{x})</span>, and <span class="math">\\chi: \\mathbb{H} \\to \\mathbb{F}_p</span> maps <span class="math">(t, \\mathbf{x}) \\mapsto t^{-1} \\cdot f \\bmod p</span> where <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> is the unique polynomial with coefficient vector <span class="math">t \\cdot \\mathbf{x} \\bmod p</span>. In the case that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p<span class="math"> and </span>h: \\mathbb{Z}_p^d \\to \\mathbb{G}<span class="math"> the scheme can be simplified to omit </span>t<span class="math"> from the opening string: any valid opening </span>(t, \\mathbf{f}^<em>)<span class="math"> can be converted to </span>(1, t^{-1} \\cdot \\mathbf{f}^</em> \\bmod p)<span class="math">, which satisfies </span>h(t^{-1} \\cdot \\mathbf{f}^*) = \\mathsf{C}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-27" class="text-2xl font-bold">5.4 Publicly aggregatable PCS (proof of Theorem 6)</h2>

    <p class="text-gray-300">The Halo [BGH19] protocol contains a public aggregation protocol for the Bulletproofs PCS. Inspired by this idea, we show how the HPI protocol of Figure 3 can be used to compile any homomorphic PCS with opening group <span class="math">\\mathbb{H} = \\mathbb{Z}^n</span> and commitment group <span class="math">\\mathbb{G}</span> into a publicly aggregatable homomorphic PCS with the same commitment group <span class="math">\\mathbb{G}</span>. Compared with the commitment size and Eval complexity of the original PCS, the commitment size of the transformed PCS is the same, the new Eval communication has an extra <span class="math">O(\\log d)</span> elements of <span class="math">\\mathbb{G}</span>, and the verification overhead is <span class="math">O(\\log d)</span> operations in <span class="math">\\mathbb{G}</span>. Running the public aggregation protocol on <span class="math">k</span> commitments and evaluation points together with an Eval on the aggregate commitment achieves an amortized verification complexity of <span class="math">O(\\log k + \\lambda + \\frac{V_{\\mathrm{Eval}}(\\lambda, d)}{k})</span> where <span class="math">V_{\\mathrm{Eval}}(\\lambda, d)</span> is the Eval verifier complexity. Any additive/homomorphic scheme can first be compiled into a homomorphic PCS with opening group <span class="math">\\mathbb{Z}^n</span>, using the simple compiler described next.</p>

    <p class="text-gray-300"><strong>Compiler 1: From Additive to Homomorphic</strong> Given a non-hiding <span class="math">^5</span> additive PCS (Setup, Commit, Verify, Eval) the new homomorphic non-hiding PCS uses the same Setup, Verify, and Eval protocols, but commits to polynomials using the pre-computed "basis" commitments <span class="math">(\\mathsf{C}_i,\\mathsf{open}_i)\\gets \\mathsf{Commit}(pp,X^{i - 1})</span> for <span class="math">i\\in [1,d]</span>. The commitment to <span class="math">f\\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> with coefficient vector representation <span class="math">\\mathbf{f} = (\\hat{f}_0,\\dots,\\hat{f}_{d - 1})\\in [0,p)^d</span> is the group element <span class="math">\\mathsf{C}\\coloneqq \\sum_{i = 0}^{d - 1}\\hat{f}_i\\cdot \\mathsf{C}_i</span>. The opening string open for <span class="math">\\mathsf{C}</span> is the coefficient vector <span class="math">\\mathbf{f}</span>.</p>

    <p class="text-gray-300">By definition, <span class="math">\\mathsf{C}</span> is a valid commitment to the polynomial <span class="math">f</span> under the original scheme with opening string <span class="math">\\mathsf{open}&#x27;</span> derived from the "basis" openings <span class="math">\\mathsf{open}_i</span> using <span class="math">\\mathsf{add}^*</span> and the coefficients <span class="math">\\mathbf{f}</span>. The evaluation protocol runs the original Eval using <span class="math">\\mathsf{open}&#x27;</span>. For some schemes (e.g., KZG and Bulletproofs) that are already homomorphic, the linear combination <span class="math">\\mathsf{C}</span> would be identical to a fresh commitment to <span class="math">f</span> and thus <span class="math">\\mathsf{open}&#x27; = \\mathsf{open}</span>. In other words, the transformation described above would have no effect.</p>

    <p class="text-gray-300"><span class="math">^5</span>Since the PCS is non-hiding we may assume, without loss of generality, that the commitment algorithm Commit is a deterministic function.</p>

    <p class="text-gray-300">The transformed scheme is a homomorphic PCS because <span class="math">\\mathsf{C} = \\phi(\\mathsf{open})</span> where <span class="math">\\phi : \\mathbb{Z}^d \\to \\mathbb{G}</span> is the homomorphism that maps <span class="math">\\mathbf{v} \\in \\mathbb{Z}^d</span> to <span class="math">\\sum_{i=1}^{d} v_i \\cdot \\mathsf{C}_i</span> and <span class="math">\\chi(\\mathsf{open}) = \\mathsf{open} \\bmod p</span> is the unique coefficient vector of <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>. The new scheme is also binding: given a collision <span class="math">\\mathbf{f}&#x27; \\neq \\mathbf{f} \\bmod p</span> such that <span class="math">\\mathsf{C} = \\phi(\\mathbf{f}) = \\phi(\\mathbf{f}&#x27;)</span>, the algorithm <span class="math">\\mathsf{add}^*</span> could be used to derive openings of <span class="math">\\mathsf{C}</span> to either <span class="math">f</span> or <span class="math">f&#x27;</span> from the <span class="math">\\mathsf{open}_i</span> values, which contradicts the binding property of Commit.</p>

    <h2 id="sec-28" class="text-2xl font-bold">Compiler 2: Homomorphic to publicly aggregatable</h2>

    <p class="text-gray-300">Denote the input homomorphic PCS by <span class="math">\\mathcal{PCS} = (\\text{Setup},\\text{Commit},\\text{Verify},\\text{Eval})</span>. The output of the compiler will be a scheme denoted <span class="math">\\mathcal{PCS}^<em> = (\\text{Setup}^</em>,\\text{Commit}^<em>,\\text{Verify}^</em>,\\text{Eval}^*)</span> that will support public aggregation. Let <span class="math">\\mathbb{H} = \\mathbb{Z}^n</span> for some <span class="math">n &amp;gt; d</span>. By definition, there are efficiently computable homomorphisms <span class="math">\\phi : \\mathbb{Z}^n \\to \\mathbb{G}</span> and <span class="math">\\chi : \\mathbb{Z}^n \\to \\mathbb{F}^{(&amp;lt;d)}[X]</span> such that the output <span class="math">(\\mathsf{C},\\mathsf{open}) \\gets \\text{Commit}(pp,f)</span> for any <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> satisfies <span class="math">\\mathsf{C} = \\phi(\\mathsf{open})</span> and <span class="math">f = \\chi(\\mathsf{open})</span>.</p>

    <p class="text-gray-300">For any <span class="math">\\mathbf{v} \\in \\mathbb{Z}^n</span> let <span class="math">f_{\\mathbf{v}} \\coloneqq \\chi(\\mathbf{v})</span>. Let <span class="math">\\hat{\\mathbb{G}} \\coloneqq \\mathbb{G} \\times \\mathbb{F}</span>. For a point <span class="math">x \\in \\mathbb{F}</span>, define the homomorphism <span class="math">\\phi_x: \\mathbb{Z}^n \\to \\hat{\\mathbb{G}}</span> as <span class="math">\\phi_x(\\mathbf{v}) \\coloneqq (\\phi(\\mathbf{v}), f_{\\mathbf{v}}(x))</span>. The new PCS algorithms <span class="math">(\\text{Setup}^<em>, \\text{Commit}^</em>)</span> are identical to <span class="math">(\\text{Setup}, \\text{Commit})</span>. The algorithm <span class="math">\\text{Verify}^<em></span> is the standard "relaxation" of Verify from Section 2.3: it accepts tuples <span class="math">(f, (t, \\text{open}))</span> such that <span class="math">\\phi(\\text{open}) = t \\cdot \\mathsf{C}</span> and <span class="math">\\chi(\\text{open}) = t \\cdot f</span> where <span class="math">t \\neq 0</span> is an integer. The protocol <span class="math">\\text{Eval}^</em></span> is transformed as follows:</p>

    <p class="text-gray-300"><span class="math">\\text{Eval}^* \\big(\\mathcal{P}(f, \\text{open}), \\mathcal{V}(\\mathsf{C}, x, y)\\big)</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover/verifier run a modification of the HPI protocol from Figure 3 with <span class="math">\\mathcal{P}_{\\mathsf{HPI}}(n, \\mathsf{open}, (\\mathsf{C}, y))</span> and <span class="math">\\mathcal{V}_{\\mathsf{HPI}}(n, (\\mathsf{C}, y))</span> for the homomorphism <span class="math">\\phi_x: \\mathbb{Z}^n \\to \\hat{\\mathbb{G}}</span>. The verifier stores the output <span class="math">(x&#x27;, (\\mathsf{C}&#x27;, y&#x27;)) \\in \\mathbb{Z} \\times \\hat{\\mathbb{G}}</span> and performs all verification steps except for deriving <span class="math">g&#x27; \\in \\hat{\\mathbb{G}}</span> or checking <span class="math">x&#x27; \\cdot g&#x27; = (\\mathsf{C}&#x27;, y&#x27;)</span>. The prover derives the coefficient vector <span class="math">\\mathbf{u}</span> of the polynomial <span class="math">u(X) = \\prod_{i=1}^{\\log n} (\\alpha_i + X^{2^{i-1}})</span> defined by the verifier challenges, which satisfies <span class="math">\\phi_x(\\mathbf{u}) = g&#x27;</span> and <span class="math">\\phi_x(x&#x27; \\cdot \\mathbf{u}) = x&#x27; \\cdot g&#x27; = (\\mathsf{C}&#x27;, y&#x27;)</span>.</li>

      <li>Run <span class="math">\\text{Eval}\\big(\\mathcal{P}(f_{x&#x27; \\cdot \\mathbf{u}}, x&#x27; \\cdot \\mathbf{u}), \\mathcal{V}(\\mathsf{C}&#x27;, x, y&#x27;)\\big)</span>, where <span class="math">\\mathsf{C}&#x27;</span> is interpreted as a polynomial commitment to <span class="math">f_{x&#x27; \\cdot \\mathbf{u}}</span> with opening <span class="math">x&#x27; \\cdot \\mathbf{u}</span>.</li>

    </ol>

    <p class="text-gray-300">We provide only a sketch of the knowledge soundness analysis. Recall that the extractor in the analysis of Theorem 7 succeeds assuming it has any labels <span class="math">(t_v, \\mathbf{x}_v, y_v)</span> at the leaves of the tree such that <span class="math">\\mathbf{x}_{v\\mathbf{g}} = t_v \\cdot y_v</span>, i.e. <span class="math">\\phi_s(\\mathbf{x}_v) = t_v \\cdot y_v</span> in this case. The knowledge extractor for <span class="math">\\text{Eval}^<em></span> begins by running the usual extractor for <span class="math">\\mathcal{P}_{\\mathsf{HPI}}</span>, but calls the extractor for <span class="math">\\text{Eval}</span> to obtain a <span class="math">\\phi_x</span> homomorphism pre-image of <span class="math">(\\mathsf{C}&#x27;, y&#x27;)</span>. This is passed to the extractor for <span class="math">\\mathcal{P}_{\\mathsf{HPI}}</span>, which in turn outputs a witness <span class="math">(t, \\mathbf{v}) \\in \\mathbb{Z} \\times \\mathbb{Z}^n</span> such that <span class="math">((\\mathbf{v}, t), (\\mathsf{C}, y)) \\in \\mathcal{R}_{\\mathsf{HPI}}^</em>(\\phi_x, \\mathbb{Z}^n, \\hat{\\mathbb{G}})</span>, i.e. <span class="math">\\phi_x(\\mathbf{v}) = (t \\cdot \\mathsf{C}, t \\cdot y)</span> and <span class="math">t \\neq 0</span>. Thus, <span class="math">\\phi(\\mathbf{v}) = t \\cdot \\mathsf{C}</span> and <span class="math">f_{\\mathbf{v}}(x) = t \\cdot y</span>, so <span class="math">\\text{Verify}^*</span> accepts <span class="math">(t^{-1}f_{\\mathbf{v}}, (t, \\mathbf{v}))</span> and <span class="math">t^{-1}f_{\\mathbf{v}}(x) = y</span>, i.e. <span class="math">(t^{-1}f_{\\mathbf{v}}, (t, \\mathbf{v}))</span> is an <span class="math">\\mathcal{R}_{\\text{Eval}}</span> witness for <span class="math">(\\mathsf{C}, x, y)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The compiled PCS has the same commitment size since the commitment algorithm is unchanged. The overhead in the <span class="math">\\text{Eval}^*</span> communication is <span class="math">O(\\log d)</span> elements of <span class="math">\\hat{\\mathbb{G}} = \\mathbb{G} \\times \\mathbb{F}</span> and the overhead in verification is <span class="math">O(\\log d)</span> operations in <span class="math">\\hat{\\mathbb{G}}</span> (from Step 1). The prover overhead is <span class="math">O((\\lambda + \\log B) \\cdot n)</span> operations in <span class="math">\\hat{\\mathbb{G}}</span> assuming $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{open}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} &lt; B<span class="math"> (in Step 1) and </span>O(n)<span class="math"> integer multiplications to derive </span>\\mathbf{u}<span class="math"> (also from Step 1). In the case that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p<span class="math"> the integer multiplications become field multiplication modulo </span>p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If the input PCS Eval protocol is zero-knowledge and the prover/verifier run the zero-knowledge variation of the HPI protocol between <span class="math">\\mathcal{P}_{\\mathrm{init}}</span> and <span class="math">\\mathcal{V}_{\\mathrm{init}}</span> then <span class="math">\\text{Eval}^<em></span> is also zero-knowledge. If Eval is already non-interactive (or public-coin and FS compatible) then <span class="math">\\text{Eval}^</em></span> is still public-coin and can be</p>

    <p class="text-gray-300">made non-interactive by applying the Fiat-Shamir transform. We conjecture that the transformed protocol is sound, which is true in the random oracle model for constant <span class="math">n</span> <em>[x10]</em>.:</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Conjecture 1.</h6>

    <p class="text-gray-300">If Eval is FS compatible then protocol Eval^{∗} is FS compatible.</p>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Comparison to Halo aggregation</h5>

    <p class="text-gray-300">The Halo aggregation protocol for the Bulletproofs PCS uses the fact that the expensive part of verification is deriving <span class="math">g^{\\prime}=\\phi(\\mathbf{u})</span> and <span class="math">u(X)</span> can be evaluated in time <span class="math">O(\\log d)</span>. The aggregator proves correctness of <span class="math">g^{\\prime}</span> (interpreted as a commitment to <span class="math">u</span>) by running the Bulletproofs Eval to open it to <span class="math">u(s)</span> at a random point <span class="math">s</span> chosen by the verifier. Multiple instances can be batched using private Eval aggregation. This works only because <span class="math">\\mathbf{u}\\in\\mathbb{Z}_{p}</span> and <span class="math">\\phi:\\mathbb{Z}_{p}^{n}\\to\\mathbb{G}</span> is collision-resistant. In a more general homomorphic PCS with <span class="math">\\mathbf{u}\\in\\mathbb{Z}^{n}</span>, <span class="math">\\phi</span> might only be collision-resistant over <span class="math">\\mathbb{Z}^{n}/ker(\\chi)</span> and it may be possible to open <span class="math">g^{\\prime}</span> to <span class="math">u(X)</span> even when <span class="math">\\phi(\\mathbf{u})\\neq g^{\\prime}</span>. The key observation that allows us to generalize the aggregation protocol for any PCS is our novel analysis of the HPI protocol (Theorem 7) which shows that the verifier does not need to compute <span class="math">g^{\\prime}</span>; it only needs a proof of knowledge that <span class="math">y^{\\prime}</span> is some linear combination of <span class="math">\\mathbf{g}</span>.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Public aggregation scheme</h5>

    <p class="text-gray-300">Each non-interactive proof returned by <span class="math">\\mathsf{NI\\text{-}Eval}^{*}</span> has the form <span class="math">(\\pi_{\\mathsf{HPI}},x^{\\prime},y^{\\prime},\\pi_{\\mathsf{eval}})</span> where <span class="math">\\pi_{\\mathsf{HPI}}</span> is the transcript from the first step, <span class="math">(x^{\\prime},y^{\\prime})=(x^{\\prime},(\\mathsf{C}^{\\prime},t^{\\prime}))\\in\\mathbb{Z}\\times(\\mathbb{G}\\times\\mathbb{F})</span> is the verifier’s intermediate output in the first step, and <span class="math">\\pi_{\\mathsf{Eval}}</span> is the non-interactive Eval proof from the second step for the commitment <span class="math">\\mathsf{C}^{\\prime}</span> to the polynomial <span class="math">f_{x^{\\prime}\\cdot\\mathbf{u}}</span>. The vector <span class="math">x^{\\prime}\\cdot\\mathbf{u}</span> can be computed from the transcript <span class="math">\\pi_{\\mathsf{HPI}}</span>.</p>

    <p class="text-gray-300">The public aggregation scheme Aggregate takes public inputs <span class="math">\\mathbf{C}=(\\mathsf{C}_{1},...,\\mathsf{C}_{k})\\in\\mathbb{G}^{k}</span>, <span class="math">\\mathbf{s}\\in\\mathbb{F}^{k}</span>, <span class="math">\\mathbf{t}\\in\\mathbb{F}^{k}</span>, and a vector of <span class="math">\\mathsf{NI\\text{-}Eval}^{*}</span> proofs <span class="math">\\boldsymbol{\\pi}=(\\pi_{1},...,\\pi_{k})</span> where <span class="math">\\pi_{i}=(\\pi_{\\mathsf{HPI}}^{(i)},x^{\\prime}_{i},y^{\\prime}_{i},\\pi_{\\mathsf{eval}}^{(i)})</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Aggregate}\\big{(}\\mathcal{P},\\mathcal{V}(pp,\\boldsymbol{\\pi},\\mathbf{C},\\mathbf{s},\\mathbf{t})\\big{)}\\to((\\mathsf{open}^{<em>},f^{</em>}),(C^{<em>},s^{</em>},t^{*},b))</span></p>

    <p class="text-gray-300">The verifier does not check <span class="math">\\pi_{\\mathsf{Eval}}^{(i)}</span> for each <span class="math">i\\in[k]</span>, and therefore is not yet convinced that <span class="math">\\phi_{s_{i}}(x^{\\prime}_{i}\\cdot\\mathbf{u}_{i})=y^{\\prime}_{i}</span>. Instead, the aggregation prover/verifier run the private aggregation protocol from Section 4.3 where the prover has private inputs <span class="math">\\{f_{x^{\\prime}\\cdot\\mathbf{u}_{i}}\\}_{i=1}^{k}</span> and opening strings <span class="math">\\{x^{\\prime}\\cdot\\mathbf{u}_{i}\\}_{i=1}^{k}</span> for each commitment <span class="math">\\mathsf{C}^{\\prime}_{i}</span> such that <span class="math">f_{x^{\\prime}\\cdot\\mathbf{u}_{i}}(s_{i})=t^{\\prime}_{i}</span>. The output of this private aggregation protocol determine the prover’s outputs <span class="math">(\\mathsf{open}^{<em>},f^{</em>})</span> and the verifier’s outputs <span class="math">(C^{<em>},s^{</em>},t^{*},b)</span>.</p>

    <p class="text-gray-300">By the soundness definition of the private aggregation scheme, if the prover can succeed in the Eval protocol on public inputs <span class="math">(C^{<em>},s^{</em>},t^{*})</span> with non-negligible probability then there exists a polynomial time knowledge extractor that obtains an <span class="math">\\mathcal{R}_{\\mathsf{Eval}}</span> witness for each <span class="math">(\\mathsf{C}^{\\prime}_{i},s_{i},t^{\\prime}_{i})</span>, which includes a <span class="math">\\phi_{s_{i}}</span> pre-image of <span class="math">y^{\\prime}_{i}=(\\mathsf{C}^{\\prime}_{i},t^{\\prime}_{i})</span>. These witnesses are then used to extract <span class="math">\\mathcal{R}_{\\mathsf{Eval}}</span> witnesses for each <span class="math">(\\mathsf{C}_{i},s_{i},t_{i})</span> as described above in the knowledge-soundness analysis for Eval^{∗}.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The public aggregation scheme verification and communication inherits the same complexity as the private aggregation protocol. From Theorem 3, the generic scheme from Section 4.3 has verifier complexity <span class="math">O(k\\log k)</span> operations in <span class="math">\\mathbb{F}</span> plus <span class="math">O(k\\cdot\\lambda)</span> operations in <span class="math">\\mathbb{G}</span> and communication of one <span class="math">\\mathbb{G}</span> element plus two <span class="math">\\mathbb{F}</span> elements. The prover complexity of the private aggregation subprotocol is <span class="math">O(k\\log k)</span> operations in <span class="math">\\mathbb{F}</span> plus one Commit to a polynomial of degree at most <span class="math">d</span>. In addition, the prover must derive each integer vector <span class="math">\\mathbf{u}_{i}</span>, which requires <span class="math">O(k\\cdot n)</span> integer multiplications. In the case that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=p<span class="math"> the integer multiplications become field multiplication modulo </span>p$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Bünz et. al. [BCMS20] formally show how a concept they define called PCS accumulation schemes can be used to construct a PCD system, generalizing the Halo protocol [BGH19]. We show that a PCS public aggregation scheme satisfies the definition of a PCS accumulation scheme [BCMS20].</p>

    <p class="text-gray-300">A PCS accumulation scheme enables PCD from plain-model "predicate-efficient" SNARKs, defined as a SNARK with a polylogarithmic verifier that is given an oracle for checking PCS Eval proofs. The PCD transformation does not work if the SNARK involves calls to a random oracle, as it would require concretely instantiating the random oracle. Unfortunately, we only know how to construct "predicate-efficient" SNARKs in the random oracle model (e.g.,  <span class="math">\\mathrm{[CHM^{+}19}</span> , GWC19]). Hence, this result gives a heuristic construction of PCD from PCS accumulation.</p>

    <p class="text-gray-300">PCS accumulation scheme We show that a public aggregation scheme for a PCS (Definition 11) satisfies the definition of an accumulation scheme for a non-interactive PCS from [BCMS20]. We first review the definition of an accumulation scheme. The definition has small syntactic differences from [BCMS20] due to syntactic differences in our PCS definition.</p>

    <p class="text-gray-300">Definition 12 (PCS accumulation). Let  <span class="math">\\mathcal{PCS} = (\\text{Setup}, \\text{Commit}, \\text{Verify}, \\text{Eval})</span>  denote a PCS with a non-interactive Eval protocol given by a prover algorithm  <span class="math">\\mathcal{P}_{\\text{Eval}}</span>  and verifier algorithm  <span class="math">\\mathcal{V}_{\\text{Eval}}</span> . An accumulation scheme for  <span class="math">\\mathcal{PCS}</span>  has algorithms  <span class="math">(G, I, P, V, D)</span>  with the syntax:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} G (\\lambda) \\rightarrow p p _ {a c} \\quad P (a p k, [ \\{X _ {i} \\} _ {i = 1} ^ {k}, \\{a c c _ {i} \\} _ {i = 1} ^ {\\ell}) \\rightarrow (a c c, \\pi_ {V}) \\\\ I \\left(p p _ {a c}, p p _ {p c}\\right)\\rightarrow (a p k, a v k, d k) \\quad V (a v k, \\{X _ {i} \\} _ {i = 1} ^ {k}, \\{a c c _ {i} \\} _ {i = 1} ^ {\\ell}, a c c, \\pi_ {V}) \\rightarrow b _ {V} \\\\ D (d k, a c c) \\rightarrow b _ {D} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The scheme is complete if for any  <span class="math">pp_{pc}</span>  and  <span class="math">(apk, avk, dk) \\gets I(pp_{ac}, pp_{pc})</span>  and inputs  <span class="math">(\\{X_i\\}_{i=1}^k, [acc_i]_{i=1}^\\ell)</span>  that satisfy  <span class="math">\\mathcal{V}_{Eval}(pp_{pc}, X_i) = 1</span>  for  <span class="math">i \\in [k]</span>  and  <span class="math">D(dk, acc_i) = 1</span>  for all  <span class="math">i \\in [\\ell]</span> , the accumulation scheme prover  <span class="math">P(apk, \\{X_i\\}_{i=1}^k, \\{acc_i\\}_{i=1}^\\ell)</span>  outputs  <span class="math">(acc, \\pi_V)</span>  such that  <span class="math">D(dk, acc) = 1</span>  and  <span class="math">V(avk, \\{X_i\\}_{i=1}^k, \\{acc_i\\}_{i=1}^\\ell, acc, \\pi_V) = 1</span> . For soundness, the following probability is negligible in  <span class="math">\\lambda</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{l l} V (a v k, \\{X _ {i} \\} _ {i = 1} ^ {k}, \\{a c c _ {i} \\} _ {i = 1} ^ {\\ell}, a c c, \\pi_ {V}) = 1 &amp;amp; p p _ {p c} \\gets S e t u p (\\lambda , d), p p _ {a c} \\gets G (\\lambda) \\\\ D (d k, a c c) = 1 &amp;amp; : (a p k, a v k, d k) \\gets I (p p _ {a c}, p p _ {p c}) \\\\ \\exists_ {i \\in [ k ]} \\mathcal {V} _ {E v a l} (p p _ {p c}, X _ {i}) \\neq 1 \\lor \\exists_ {i \\in [ \\ell ]} D (d k, a c c _ {i}) \\neq 1 &amp;amp; \\{X _ {i} \\} _ {i = 1} ^ {k}, \\{a c c _ {i} \\} _ {i = 1} ^ {\\ell}, a c c, \\pi_ {V} \\gets \\mathcal {A} (p p _ {a c}, p p _ {p c}) \\end{array} \\right]</span></div>

    <p class="text-gray-300">The fact that a non-interactive public aggregation scheme gives an accumulation scheme is an immediate consequence of the definitions. The algorithms  <span class="math">G</span>  and  <span class="math">I</span>  are trivial, setting all parameters to  <span class="math">pp_{\\mathsf{pc}}</span> . Each  <span class="math">acc = (\\mathsf{C}, x, y, \\pi)</span>  is an Eval tuple. The prover  <span class="math">P(pp_{\\mathsf{pc}}, \\{X_i\\}_{i=1}^k, \\{acc_i\\}_{i=1}^\\ell)</span>  first sets  <span class="math">\\mathbf{C} \\in \\mathbb{G}^{k+\\ell}</span>  so that  <span class="math">\\mathsf{C}_i = X_i</span>  for  <span class="math">i \\in [k]</span>  and  <span class="math">\\mathsf{C}_i = acc_{i-k}</span>  for  <span class="math">i &amp;gt; k</span> , sets  <span class="math">\\pi</span>  so that the  <span class="math">i</span> th and  <span class="math">(i+k)</span> th components are the Eval proofs in  <span class="math">X_i</span>  and  <span class="math">acc_i</span>  respectively, and sets  <span class="math">(\\mathbf{s}, \\mathbf{t}) \\in \\mathbb{F}^{k+\\ell} \\times \\mathbb{F}^{k+\\ell}</span>  so that  <span class="math">(s_i, t_i) = (x_i, y_i)</span>  from  <span class="math">X_i</span>  for  <span class="math">i \\in [k]</span>  and from  <span class="math">acc_i</span>  for  <span class="math">i &amp;gt; k</span> . It runs Aggregate  <span class="math">(pp_{\\mathsf{pc}}, \\pi, \\mathbf{C}, \\mathbf{s}, \\mathbf{t})</span>  to get  <span class="math">(\\mathsf{open}^<em>, f^</em>, \\mathsf{C}^<em>, s^</em>, t^<em>, \\pi_{\\mathsf{agg}})</span>  and Eval  <span class="math">(\\mathsf{open}^</em>, f^<em>, \\mathsf{C}^</em>, s^<em>, t^</em>)</span>  to get  <span class="math">\\pi^<em></span> . It returns  <span class="math">\\pi_V := \\pi_{\\mathsf{agg}}</span>  and  <span class="math">acc := (\\mathsf{C}^</em>, s^<em>, t^</em>, \\pi^<em>)</span> .  <span class="math">D(pp_{\\mathsf{pc}}, acc)</span>  calls the Eval verifier. Finally,  <span class="math">V(pp_{\\mathsf{pc}}, \\{X_i\\}_{i=1}^k, \\{acc_i\\}_{i=1}^\\ell, acc, \\pi_{\\mathsf{agg}})</span>  derives the tuples  <span class="math">(\\pi, \\mathbf{C}, \\mathbf{s}, \\mathbf{t})</span> , parses  <span class="math">acc = (\\mathsf{C}^</em>, s^<em>, t^</em>, \\pi^<em>)</span> , and runs the aggregation verifier  <span class="math">\\mathcal{V}_{\\mathsf{Aggregate}}(pp_{\\mathsf{pc}}, \\pi, \\mathbf{C}, \\mathbf{s}, \\mathbf{t}, \\mathsf{C}^</em>, s^<em>, t^</em>, \\pi_{\\mathsf{agg}})</span> .</p>

    <h5 id="sec-33" class="text-base font-semibold mt-4">Private accumulation</h5>

    <p class="text-gray-300">A small tweak to Definition 12 would make it compatible with private aggregation. The accumulation prover is additionally given as inputs a vector of private states <span class="math">\\{st_{i}\\}_{i=1}^{k+\\ell}</span> and outputs <span class="math">(st,acc,\\pi_{V})</span>. The other algorithms and the security definition are unchanged. Constructing this from a private aggregation scheme, the state <span class="math">st</span> will contain the prover’s private outputs <span class="math">(\\mathsf{open}^{<em>},f^{</em>})</span> and each <span class="math">st_{i}</span> contains an <span class="math">(\\mathsf{open}_{i},f_{i})</span> pair.</p>

    <p class="text-gray-300">The PCD compiler of <em>[x1]</em> can be adapted to work with private aggregation schemes as well. This only affects the proof size which has size <span class="math">O(N)</span> because it includes the “private” states (openings for polynomials of degree <span class="math">N</span>). Intuitively, the construction of PCD from <em>[x1]</em> is not materially affected by using private accumulation because each prover node in the DAG distributed computation simply passes its private state to its target nodes as “advice”. The advice does not impact the size of the recursive statement, which is only dependent on the size of the accumulation verifier. This variation of the compiler was formally proven in follow-up work <em>[BCL^{+}20]</em>. To do so they formally define a “split-accumulation” scheme, which coincides with our informal tweak.</p>

    <p class="text-gray-300">This work was funded by NSF, DARPA, a grant from ONR, and the Simons Foundation. Opinions, findings and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</p>

    <h2 id="sec-34" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AC20] Thomas Attema and Ronald Cramer. Compressed <span class="math">\\Sigma</span>-protocol theory and practical application to plug & play secure algorithmics. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 513–543. Springer, Heidelberg, August 2020.</li>

      <li>[Ajt96] Miklós Ajtai. Generating hard instances of lattice problems (extended abstract). In STOC, pages 99–108, 1996.</li>

      <li>[Bab91] László Babai. Local expansion of vertex-transitive graphs and random generation in finite groups. In 23rd ACM STOC, pages 164–174. ACM Press, May 1991.</li>

      <li>[BBB^{+}18] Benedikt Bünz, Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and Greg Maxwell. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy, pages 315–334. IEEE Computer Society Press, May 2018.</li>

      <li>[BBC^{+}18] Carsten Baum, Jonathan Bootle, Andrea Cerulli, Rafaël del Pino, Jens Groth, and Vadim Lyubashevsky. Sub-linear lattice-based zero-knowledge arguments for arithmetic circuits. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 669–699. Springer, Heidelberg, August 2018.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Fast reed-solomon interactive oracle proofs of proximity. In Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella, editors, ICALP 2018, volume 107 of LIPIcs, pages 14:1–14:17. Schloss Dagstuhl, July 2018.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BBHR19] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable zero knowledge with no trusted setup. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part III, volume 11694 of LNCS, pages 701–732. Springer, Heidelberg, August 2019.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BCC^{+}16] Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit. Efficient zero-knowledge arguments for arithmetic circuits in the discrete log setting. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 327–357. Springer, Heidelberg, May 2016.</li>

      <li>[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In Shafi Goldwasser, editor, ITCS 2012, pages 326–349. ACM, January 2012.</li>

      <li>[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for SNARKS and proof-carrying data. In Dan Boneh, Tim Roughgarden, and Joan Feigenbaum, editors, 45th ACM STOC, pages 111–120. ACM Press, June 2013.</li>

      <li>[BCGT13] Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, and Eran Tromer. Fast reductions from RAMs to delegatable succinct constraint satisfaction problems: extended abstract. In Robert D. Kleinberg, editor, ITCS 2013, pages 401–414. ACM, January 2013.</li>

      <li>[BCI^{+}13] Nir Bitansky, Alessandro Chiesa, Yuval Ishai, Rafail Ostrovsky, and Omer Paneth. Succinct non-interactive arguments via linear interactive proofs. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 315–333. Springer, Heidelberg, March 2013.</li>

      <li>[BCL^{+}20] Benedikt Bünz, Alessandro Chiesa, William Lin, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data without succinct arguments. Cryptology ePrint Archive, Report 2020/1618, 2020. https://eprint.iacr.org/2020/1618.</li>

      <li>[BCMS20] Benedikt Bünz, Alessandro Chiesa, Pratyush Mishra, and Nicholas Spooner. Proof-carrying data from accumulation schemes. Cryptology ePrint Archive, Report 2020/499, 2020.</li>

      <li>[BCR^{+}19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Heidelberg, May 2019.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Heidelberg, October / November 2016.</li>

      <li>[BCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable zero knowledge via cycles of elliptic curves. In Juan A. Garay and Rosario Gennaro, editors, CRYPTO 2014, Part II, volume 8617 of LNCS, pages 276–294. Springer, Heidelberg, August 2014.</li>

    </ul>

    <p class="text-gray-300">[BDFG20] Dan Boneh, Justin Drake, Ben Fisch, and Ariel Gabizon. Efficient polynomial commitment schemes for multiple points and polynomials. Cryptology ePrint Archive, Report 2020/081, 2020. https://eprint.iacr.org/2020/081.</p>

    <p class="text-gray-300">[BDLN16] Carsten Baum, Ivan Damgård, Kasper Green Larsen, and Michael Nielsen. How to prove knowledge of small secrets. In Matthew Robshaw and Jonathan Katz, editors, CRYPTO 2016, Part III, volume 9816 of LNCS, pages 478–498. Springer, Heidelberg, August 2016.</p>

    <p class="text-gray-300">[BEG⁺⁹¹] Manuel Blum, William S. Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. Checking the correctness of memories. In 32nd FOCS, pages 90–99. IEEE Computer Society Press, October 1991.</p>

    <p class="text-gray-300">[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Heidelberg, May 2020.</p>

    <p class="text-gray-300">[BG93] Mihir Bellare and Oded Goldreich. On defining proofs of knowledge. In Ernest F. Brickell, editor, CRYPTO’92, volume 740 of LNCS, pages 390–420. Springer, Heidelberg, August 1993.</p>

    <p class="text-gray-300">[BGH19] Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019. https://eprint.iacr.org/2019/1021.</p>

    <p class="text-gray-300">[BGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. DEEP-FRI: Sampling outside the box improves soundness. Cryptology ePrint Archive, Report 2019/336, 2019. https://eprint.iacr.org/2019/336.</p>

    <p class="text-gray-300">[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable multi-party computation for zk-SNARK parameters in the random beacon model. Cryptology ePrint Archive, Report 2017/1050, 2017. http://eprint.iacr.org/2017/1050.</p>

    <p class="text-gray-300">[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Coda: Decentralized cryptocurrency at scale. Cryptology ePrint Archive, Report 2020/352, 2020. https://eprint.iacr.org/2020/352.</p>

    <p class="text-gray-300">[BMV19] Benedikt Bünz, Mary Maller, and Noah Vesely. Efficient proofs for pairing-based languages. Cryptology ePrint Archive, Report 2019/1177, 2019. https://eprint.iacr.org/2019/1177.</p>

    <p class="text-gray-300">[CCH⁺¹⁹] Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N. Rothblum, Ron D. Rothblum, and Daniel Wichs. Fiat-Shamir: from practice to theory. In Moses Charikar and Edith Cohen, editors, 51st ACM STOC, pages 1082–1090. ACM Press, June 2019.</p>

    <p class="text-gray-300">[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D. Rothblum. Fiat-Shamir and correlation intractability from strong KDM-secure encryption. In Jesper Buus Nielsen and Vincent Rijmen, editors, EUROCRYPT 2018, Part I, volume 10820 of LNCS, pages 91–122. Springer, Heidelberg, April / May 2018.</p>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">[CFS17] Alessandro Chiesa, Michael A. Forbes, and Nicholas Spooner. A zero knowledge sumcheck and its applications. Cryptology ePrint Archive, Report 2017/305, 2017. http://eprint.iacr.org/2017/305.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CHM^{+}19] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. Cryptology ePrint Archive, Report 2019/1047, 2019. https://eprint.iacr.org/2019/1047.</li>

      <li>[CHM^{+}20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Heidelberg, May 2020.</li>

      <li>[CL20] Alessandro Chiesa and Siqi Liu. On the impossibility of probabilistic proofs in relativized worlds. In Thomas Vidick, editor, ITCS 2020, volume 151, pages 57:1–57:30. LIPIcs, January 2020.</li>

      <li>[CLMQ20] Yilei Chen, Alex Lombardi, Fermi Ma, and Willy Quach. Does fiat-shamir require a cryptographic hash function? Cryptology ePrint Archive, Report 2020/915, 2020.</li>

      <li>[Coo02] Gene Cooperman. Towards a practical, theoretically sound algorithm for random generation in finite groups, 2002.</li>

      <li>[COS20] Alessandro Chiesa, Dev Ojha, and Nicholas Spooner. Fractal: Post-quantum and transparent recursive proofs from holography. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 769–793. Springer, Heidelberg, May 2020.</li>

      <li>[CT10] Alessandro Chiesa and Eran Tromer. Proof-carrying data and hearsay arguments from signature cards. In Andrew Chi-Chih Yao, editor, Innovations in Computer Science - ICS 2010, Tsinghua University, Beijing, China, January 5-7, 2010. Proceedings, pages 310–331. Tsinghua University Press, 2010.</li>

      <li>[Dix08] John Dixon. Generating random elements in finite groups. The Electronic Journal of Combinatorics [electronic only], 15, 07 2008.</li>

      <li>[Dra] J. Drake. https://ethresear.ch/t/slonk-a-simple-universal-snark/6420.</li>

      <li>[FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. The algebraic group model and its applications. In Advances in Cryptology - CRYPTO 2018 - 38th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 19-23, 2018, Proceedings, Part II, pages 33–62, 2018.</li>

      <li>[Gab19] Ariel Gabizon. AuroraLight: Improved prover efficiency and SRS size in a sonic-like system. Cryptology ePrint Archive, Report 2019/601, 2019. https://eprint.iacr.org/2019/601.</li>

      <li>[GGH96] Oded Goldreich, Shafi Goldwasser, and Shai Halevi. Collision-free hashing from lattice problems. IACR Cryptology ePrint Archive, 1996.</li>

    </ul>

    <p class="text-gray-300">[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic span programs and succinct NIZKs without PCPs. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 626–645. Springer, Heidelberg, May 2013.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[GK96] Oded Goldreich and Hugo Krawczyk. On the composition of zero-knowledge proof systems. SIAM Journal on Computing, 9:169–192, 1996.</li>

      <li>[GKM^{+}18] Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Up-datable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Heidelberg, August 2018.</li>

      <li>[GM17] Jens Groth and Mary Maller. Snarky signatures: Minimal signatures of knowledge from simulation-extractable SNARKs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 581–612. Springer, Heidelberg, August 2017.</li>

      <li>[Gro10] Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 321–340. Springer, Heidelberg, December 2010.</li>

      <li>[Gro16a] Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Heidelberg, May 2016.</li>

      <li>[Gro16b] Jens Groth. On the size of pairing-based non-interactive arguments. Cryptology ePrint Archive, Report 2016/260, 2016. http://eprint.iacr.org/2016/260.</li>

      <li>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019. https://eprint.iacr.org/2019/953.</li>

      <li>[HILL99] Johan Håstad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. SIAM Journal on Computing, 28(4):1364–1396, 1999.</li>

      <li>[Hol19] Justin Holmgren. On round-by-round soundness and state restoration attacks. Cryptology ePrint Archive, Report 2019/1261, 2019. https://eprint.iacr.org/2019/1261.</li>

      <li>[KPV19] Assimakis Kattis, Konstantin Panarin, and Alexander Vlasov. RedShift: Transparent SNARKs from list polynomial commitment IOPs. Cryptology ePrint Archive, Report 2019/1400, 2019. https://eprint.iacr.org/2019/1400.</li>

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum. From obfuscation to the security of Fiat-Shamir for proofs. In Jonathan Katz and Hovav Shacham, editors, CRYPTO 2017, Part II, volume 10402 of LNCS, pages 224–251. Springer, Heidelberg, August 2017.</li>

    </ul>

    <p class="text-gray-300">[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Heidelberg, December 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Lab18] <span class="math">O(1)</span> Labs. Coda protocol, 2018. https://codaprotocol.com/.</li>

      <li>[Lee20] Jonathan Lee. Dory: Efficient, transparent arguments for generalised inner products and polynomial commitments. Cryptology ePrint Archive, Report 2020/1274, 2020. https://eprint.iacr.org/2020/1274.</li>

      <li>[Lip12] Helger Lipmaa. Progression-free sets and sublinear pairing-based non-interactive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, Heidelberg, March 2012.</li>

      <li>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. Sonic: Zero-knowledge SNARKs from linear-size universal and updatable structured reference strings. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2111–2128. ACM Press, November 2019.</li>

      <li>[PHGR13] Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy, pages 238–252. IEEE Computer Society Press, May 2013.</li>

      <li>[Pip80] Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on Computing, 9:230–250, 1980.</li>

      <li>[PS96] David Pointcheval and Jacques Stern. Security proofs for signature schemes. In Ueli M. Maurer, editor, EUROCRYPT’96, volume 1070 of LNCS, pages 387–398. Springer, Heidelberg, May 1996.</li>

      <li>[Set20] Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Heidelberg, August 2020.</li>

      <li>[Val08] Paul Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. In Ran Canetti, editor, TCC 2008, volume 4948 of LNCS, pages 1–18. Springer, Heidelberg, March 2008.</li>

      <li>[VP19] Alexander Vlasov and Konstantin Panarin. Transparent polynomial commitment scheme with polylogarithmic communication complexity. Cryptology ePrint Archive, Report 2019/1020, 2019. https://eprint.iacr.org/2019/1020.</li>

    </ul>

    <h2 id="sec-35" class="text-2xl font-bold">Appendix A Appendices</h2>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">A.1 Computational group</h3>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 13.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A computational group is a finite group <span class="math">\\mathbb{G}</span> whose elements are represented as bit strings of length $\\mathsf{poly}(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">, where the identity element has a special string </span>\\mathsf{id}<span class="math">, together with polynomial time algorithms </span>\\mathsf{add}<span class="math">, </span>\\mathsf{invert}<span class="math">, and </span>\\mathsf{equal}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{add}(g_1, g_2) \\to g_3</span> takes as input the bit string representations of two group elements <span class="math">g_1, g_2 \\in \\mathbb{G}</span> and outputs the bit string representation of the element <span class="math">g_1 + g_2</span>, or <span class="math">\\perp</span> if either input is not a representation of a group element.</li>

      <li><span class="math">\\mathsf{invert}(g) \\to -g</span> takes as input the bit string representation of an element <span class="math">g \\in \\mathbb{G}</span> and outputs the bit string representation of its inverse <span class="math">-g \\in \\mathbb{G}</span>, or <span class="math">\\perp</span> if the input is not a representation of a group element.</li>

      <li><span class="math">\\mathsf{equal}(g_1, g_2)</span> takes as input two bit strings, it outputs 1 if they are both valid representations of the same element in <span class="math">\\mathbb{G}</span>, and otherwise outputs 0.</li>

    </ul>

    <p class="text-gray-300">Our definition is not explicit about how group elements are sampled in the first place, other than the bit string <span class="math">\\mathsf{id}</span> that is part of the definition of the group. Clearly, a computational group is only useful if there is a way to generate at least one initial group element other than the identity. However, this can be specified by the application. For example, our definition of polynomial commitments (Section 2.3) includes a commitment algorithm that outputs elements in a computational group.</p>

    <h2 id="sec-38" class="text-2xl font-bold">A.2 Probability distributions</h2>

    <p class="text-gray-300">For a distribution <span class="math">\\mathcal{D}</span>, we write <span class="math">x \\xleftarrow{\\mathrm{s}} \\mathcal{D}</span> to denote that <span class="math">x</span> is sampled from <span class="math">\\mathcal{D}</span>; for a finite set <span class="math">S</span>, we write <span class="math">x \\xleftarrow{\\mathrm{s}} S</span> to denote that <span class="math">x</span> is sampled uniformly from <span class="math">S</span>.</p>

    <p class="text-gray-300">For two discrete random variables <span class="math">X</span> and <span class="math">Y</span> that take on values in the same set <span class="math">\\mathcal{U}</span>, we denote by <span class="math">SD(X,Y)</span> the statistical distance between <span class="math">X</span> and <span class="math">Y</span>, also known as the total variation distance defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SD(X, Y) := \\max_{S \\subseteq \\mathcal{U}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[X \\in S] - Pr[Y \\in S] \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\frac{1}{2} \\sum_{u \\in \\mathcal{U}} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pr[X = u] - Pr[Y = u] \\right</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Two random variables <span class="math">X</span> and <span class="math">Y</span> over <span class="math">\\mathcal{U}</span> are <span class="math">\\delta</span>-close if <span class="math">SD(X,Y) \\leq \\delta</span>.</p>

    <p class="text-gray-300"><strong>Fact 1.</strong> If <span class="math">\\mathbf{X} = (X_1, \\ldots, X_n)</span> and <span class="math">\\mathbf{Y} = (Y_1, \\ldots, Y_n)</span> are each vectors of <span class="math">n</span> independent discrete random variables, then <span class="math">\\mathbf{X}</span> and <span class="math">\\mathbf{Y}</span> are random variables such that <span class="math">SD(\\mathbf{X}, \\mathbf{Y}) \\leq \\sum_{i=1}^{n} SD(X_i, Y_i)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Fact 2.</strong> If <span class="math">X</span> is a random variable uniformly distributed over the interval <span class="math">[-A, A]</span> for <span class="math">A \\in \\mathbb{Z}</span> and <span class="math">Y = X + z</span> for a fixed <span class="math">z \\in \\mathbb{Z}</span> with bounded absolute value $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; B<span class="math">, then </span>SD(X, Y) &lt; \\frac{B}{2A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-39" class="text-2xl font-bold">A.3 Interactive proofs of knowledge</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 14 (Interactive Proof with Efficient<span class="math">^6</span> Prover).</strong> Let <span class="math">\\mathsf{Setup}(\\lambda)</span> denote a non-interactive setup algorithm that outputs public parameters <span class="math">pp</span> given a security parameter <span class="math">\\lambda</span>. Let <span class="math">\\Pi\\big(\\mathcal{P}(w), \\mathcal{V}(pp, x)\\big)</span> denote a two-party interactive protocol between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>, where <span class="math">\\mathcal{P}</span> has private input <span class="math">w</span> and <span class="math">\\mathcal{V}</span> has the common public input <span class="math">(pp, x)</span>. Let <span class="math">\\langle \\mathcal{P}(w), \\mathcal{V}(pp, x) \\rangle</span> be a random variable that is the output of <span class="math">\\mathcal{V}</span>. All algorithms run in time $\\mathsf{poly}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">pp</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. The pair </span>(\\mathsf{Setup}, \\Pi)<span class="math"> is called a proof of knowledge for relation </span>\\mathcal{R}<span class="math"> if for all non-uniform adversaries </span>\\mathcal{A}$ the following properties hold:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^6</span>A classical interactive proof does not require the prover to be efficient. However, our definition of an interactive proof with efficient prover should also not be confused with an interactive argument, which only requires soundness against efficient adversaries. In our definition, the prover is required to be efficient for correctness, but soundness must hold against adversaries with unbounded running time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Perfect Completeness.</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr} \\left[ \\begin{array}{c c c} &amp;amp; (x, w) \\notin \\mathcal{R} \\text{ or} &amp;amp; \\text{pp} \\leftarrow \\text{Setup}(\\lambda) \\\\ \\langle \\mathcal{P}(w), \\mathcal{V}(pp, x) \\rangle = 1 &amp;amp; : &amp;amp; (x, w) \\leftarrow \\mathcal{A}(pp) \\end{array} \\right] = 1</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Knowledge soundness [BG93] There exists a probabilistic oracle machine <span class="math">\\mathcal{E}</span> called the extractor such that for every adversarial interactive prover algorithm <span class="math">\\mathcal{A}</span> that is only given the public inputs <span class="math">(pp, x)</span> and every <span class="math">x \\in \\mathcal{L}_R</span> the following holds: if <span class="math">\\langle \\mathcal{A}(\\cdot), \\mathcal{V}(pp, x) \\rangle = 1</span> with probability <span class="math">\\epsilon(x) &amp;gt; \\text{negl}(\\lambda)</span> then <span class="math">\\mathcal{E}^{\\mathcal{A}}(pp, x)</span> with oracle access to <span class="math">\\mathcal{A}</span> runs in time $\\text{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, \\lambda)<span class="math"> and outputs </span>w<span class="math"> such that </span>(x, w) \\in R<span class="math"> with probability </span>1 - \\text{negl}(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Forking lemmas The following "forking lemma" is helpful for proving knowledge soundness of multi-round public coin interactive protocols over an exponentially large challenge space (i.e., where each verifier message is a uniform sample from a space <span class="math">\\mathcal{X}</span> that has size at least <span class="math">2^{\\lambda}</span>). It says that if the adversary succeeds with non-negligible probability <span class="math">\\epsilon = 1 / \\mathrm{poly}(\\lambda)</span>, then there is an <span class="math">O(\\mathrm{poly}(\\lambda))</span>-time algorithm for generating a tree of accepting transcripts defined as follows. For an <span class="math">r</span>-round protocol, an <span class="math">(n_{1}, \\dots, n_{r})</span>-tree of accepting transcripts for <span class="math">n_{i} \\geq 0</span> is a tree where (i) every node <span class="math">v</span> of the tree corresponds to a partial transcript <span class="math">\\operatorname{tr}_{v}</span>, (ii) every level-<span class="math">i</span> node <span class="math">v</span> has <span class="math">n_{i}</span> children nodes that correspond to continuations of <span class="math">\\operatorname{tr}_{v}</span> with distinct <span class="math">i</span>th round challenges, and (iii) every leaf node corresponds to a full transcript in which the verifier accepts. More generally, the property that each pair of challenges on sibling nodes are distinct can be replaced with any property <span class="math">\\pi : \\mathcal{X}^2 \\to \\{0,1\\}</span> which outputs 1 on a random pair of challenges with overwhelming probability.</p>

    <p class="text-gray-300">Lemma 6 (Forking Lemma). Let <span class="math">(\\mathcal{P},\\mathcal{V})</span> be an <span class="math">r</span>-round public-coin interactive proof system and <span class="math">\\mathcal{A}</span> an adversary that runs in expected time <span class="math">t_{\\mathcal{A}}</span> such that <span class="math">\\langle \\mathcal{A}(\\cdot),\\mathcal{V}(pp,x)\\rangle = 1</span> with probability <span class="math">\\epsilon</span> on public input <span class="math">x</span> and public parameters <span class="math">pp</span>. Let <span class="math">\\{\\pi_i\\}_{i=1}^r</span> be a set of properties <span class="math">\\pi_i:\\mathcal{X}^2\\to \\{0,1\\}</span> such that <span class="math">\\forall_i Pr[\\pi(x_1,x_2) = 1 : x_1,x_2 \\stackrel{\\epsilon}{\\leftarrow} \\mathcal{X}] &amp;gt; 1 - \\text{negl}(\\lambda)</span>. If <span class="math">r \\in O(\\log \\lambda)</span> then for any constants <span class="math">n_1,\\ldots,n_r \\in \\mathbb{N}</span> there exists an algorithm <span class="math">\\mathcal{T}</span> that runs in time <span class="math">\\text{poly}(\\lambda) \\cdot (t_{\\mathcal{A}} / \\epsilon)</span> and with probability at least <span class="math">1 - \\text{negl}(\\lambda) / \\epsilon^2</span> outputs an <span class="math">(n_1,\\ldots,n_r)</span>-tree of accepting transcripts such that for <span class="math">i \\in [1,r]</span> all pairs of sibling-node challenges <span class="math">x_1,x_2 \\in \\mathcal{X}</span> at level <span class="math">i</span> satisfy <span class="math">\\pi_i(x_1,x_2) = 1</span>.</p>

    <p class="text-gray-300">The forking lemma is used to prove knowledge soundness of <span class="math">(\\mathcal{P},\\mathcal{V})</span> in combination with a deterministic extraction algorithm that outputs a witness given an <span class="math">(n_{1},\\dots,n_{r})</span>-tree of accepting transcripts satisfying properties <span class="math">\\pi_1,\\ldots ,\\pi_r</span>. The proof of our Lemma 6 is nearly identical to the proof in [BCC+16]. The tree-finding algorithm in [BCC+16] is an adaptive rejection sampling algorithm which samples at most <span class="math">\\mathrm{poly}(\\lambda) / \\epsilon</span> challenges overall from the uniform distribution over <span class="math">\\mathcal{X}</span>, and outputs a subset of these challenges. They show that all sibling challenges are unique with overwhelming probability by a union bound over the probability of a collision between any pair of challenges sampled by the algorithm. This union bound argument can be extended to any property of challenge pairs that holds with overwhelming probability <span class="math">1 - \\mathrm{negl}(\\lambda)</span> for a randomly sampled pair.</p>

    <p class="text-gray-300">Lemma 7 provides another helpful fact about partial transcripts in the tree returned by the algorithm of Lemma 6. If <span class="math">\\mathbf{tr}</span> is a partial transcript of the protocol interaction between <span class="math">\\mathcal{A}</span> and a verifier on the first <span class="math">i</span> round challenges <span class="math">(x_{1},\\ldots ,x_{i})</span> and <span class="math">\\mathbf{st}</span> is the internal state of <span class="math">\\mathcal{A}</span> after generating <span class="math">\\mathbf{tr}</span>, then "running <span class="math">\\mathcal{A}</span> on partial transcript <span class="math">\\mathbf{tr}</span>" means that the internal state of <span class="math">\\mathcal{A}</span> is restored to <span class="math">\\mathbf{st}</span>, and the protocol is continued on uniform random challenges for the remaining rounds. <span class="math">\\mathcal{A}</span> "succeeds" on <span class="math">\\mathbf{tr}</span> if it causes the verifier to accept when it is run on <span class="math">\\mathbf{tr}</span>.</p>

    <p class="text-gray-300">35</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Lemma 7.</h6>

    <p class="text-gray-300">Fix any <span class="math">\\delta\\in[0,1]</span>. With probability at least <span class="math">1-\\frac{\\delta}{\\epsilon}\\cdot\\mathsf{poly}(\\lambda)</span>, every partial transcript <span class="math">\\mathsf{tr}</span> in the transcript tree output by the algorithm <span class="math">\\mathcal{T}</span> in Lemma 6 with adversary <span class="math">\\mathcal{A}</span> has the property that <span class="math">\\mathcal{A}</span> succeeds on <span class="math">\\mathsf{tr}</span> with probability at least <span class="math">\\delta</span>.</p>

    <p class="text-gray-300">This lemma holds because the transcripts that appear in the tree are the result of rejection sampling. In the course of the tree finding algorithm, at most <span class="math">\\mathsf{poly}(\\lambda)/\\epsilon</span> partial transcripts are “tested” and the probability a given partial transcript is <em>not rejected</em> is bounded by the probability <span class="math">\\mathcal{A}</span> succeeds on it. By a union bound, there is a probability at most <span class="math">\\mathsf{poly}(\\lambda)\\cdot\\delta/\\epsilon</span> that the output tree contains a partial transcript that <span class="math">\\mathcal{A}</span> succeeds on it with probability less than <span class="math">\\delta</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 15 (HVZK for interactive proofs).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{View}_{\\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle}</span> denote the view of the verifier in an interactive protocol described in Definition 14 on common input <span class="math">x</span> and prover witness input <span class="math">w</span>. It is a random variable over the randomness of <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>. The interactive protocol has <span class="math">\\delta</span>-statistical honest verifier zero-knowledge (HVZK) if there exists a probabilistic polynomial time algorithm <span class="math">\\mathcal{S}</span> such that for every <span class="math">(x,w)\\in\\mathcal{R}</span>, the random variable <span class="math">\\mathcal{S}(x)</span> is <span class="math">\\delta</span>-close to the random variable <span class="math">\\mathsf{View}_{\\langle\\mathcal{P}(x,w),\\mathcal{V}(x)\\rangle}</span>. The protocol has perfect HVZK when <span class="math">\\delta=0</span>.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">A.4 Additive PCS examples</h3>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">Bulletproofs</h4>

    <p class="text-gray-300">The polynomial commitment is a Pedersen hash function over a prime order group <span class="math">\\mathbb{G}_{p}</span>. The setup parameters includes <span class="math">d</span> randomly sampled generators <span class="math">g_{0},...,g_{d-1}</span>. In additive group notation, the commitment to <span class="math">f\\in\\mathbb{F}</span> with coefficient vector <span class="math">(f_{0},...,f_{d-1})</span> is <span class="math">C_{f}\\coloneqq\\sum_{i=0}^{d-1}f_{i-1}\\cdot g_{i}</span>. There is no special opening string. The commitment function is a group homomorphism from <span class="math">\\mathbb{F}^{d}\\to\\mathbb{G}_{p}</span>. The evaluation protocol is based on the inner-product argument of Bootle et. al. <em>[BCC^{+}16]</em>, improved upon by Bünz et. al. <em>[BBB^{+}18]</em>. The PCS evaluation requires opening a linear form, and therefore is slightly simpler than the original version for inner-products (e.g., see <em>[x1]</em> or our homomorphism pre-image protocol in Section 5). The communication complexity of <span class="math">\\mathsf{Eval}</span> is <span class="math">O(\\log d)</span> group elements and the verification complexity is <span class="math">O(d)</span> group operations. Neither communication nor verification complexity increase when applied to a linear combination of two commitments.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">KZG</h4>

    <p class="text-gray-300">The KZG <em>[x12]</em> polynomial commitment uses a triple of groups <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t})</span> that have an efficiently computable non-degenerate bilinear pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>. The groups have the same prime order <span class="math">p</span> as the field <span class="math">\\mathbb{F}</span> over which the polynomials are defined. A trusted setup generates additional public parameters <span class="math">(g,g_{1},...,g_{d-1},h,h_{1})</span> where <span class="math">g\\in\\mathbb{G}_{1}</span> and <span class="math">h\\in\\mathbb{G}_{2}</span> are generators, <span class="math">s\\in\\mathbb{F}</span> is sampled uniformly, <span class="math">g_{i}=s^{i}\\cdot g</span> and <span class="math">h_{1}=s\\cdot h</span>. The value of <span class="math">s</span> must remain secret. Similar to the Bulletproof PCS, a commitment to a polynomial <span class="math">f\\in\\mathbb{F}</span> with coefficient vector <span class="math">(f_{0},...,f_{d-1})</span> is <span class="math">C_{f}\\coloneqq\\sum_{i=0}^{d-1}f_{i-1}\\cdot g_{i}</span>. Note that <span class="math">C_{f}=g^{f(s)}</span>. There is no special opening string. The commitment function is a group homomorphism from <span class="math">\\mathbb{F}^{d}\\to\\mathbb{G}_{1}</span>. To prove that <span class="math">f(z)=y</span>, the prover simply outputs a commitment <span class="math">C_{q}</span> to the quotient polynomial <span class="math">q\\coloneqq\\frac{f-y}{X-z}</span>. A correctly generated <span class="math">C_{q}=g^{q(s)}</span> will satisfy <span class="math">e(C_{q},h_{1}\\cdot h^{-z})=e(g^{q(s)},h^{s-z})=e(g^{f(s)},h)</span>. The proof is accepted by the verifier if and only if <span class="math">e(C_{f},h)=e(C_{q},h_{1}\\cdot h^{-z})</span>. Neither communication nor verification complexity increase when applied to a linear combination of two commitments.</p>

    <h4 id="sec-45" class="text-lg font-semibold mt-6">DARK</h4>

    <p class="text-gray-300">The DARK <em>[x3]</em> polynomial commitment uses a cyclic group of unknown order <span class="math">\\mathbb{G}</span> with a generator <span class="math">g</span>. If <span class="math">\\mathbb{G}</span> can be instantiated without trusted setup (e.g., the class group of a quadratic number field), then the scheme does not require trusted setup. To support commitments</p>

    <p class="text-gray-300">to <span class="math">\\mathbb{F}^{(&lt;d)}[X]</span>, an integer <span class="math">q</span> of size <span class="math">O(\\log d\\cdot\\log p)</span> bits is fixed. A commitment to the integer coefficient vector <span class="math">(f_{0},...,f_{d-1})\\in[0,p)^{d}</span> is <span class="math">C_{f}:=\\sum_{i=0}^{d-1}f_{i-1}\\cdot q^{i-1}\\cdot g</span>. Equivalently, <span class="math">C_{f}=f(q)\\cdot g</span> where <span class="math">f(q)</span> is evaluated over <span class="math">\\mathbb{Z}</span>. This commitment function is a homomorphism from <span class="math">\\mathbb{Z}^{d}\\to\\mathbb{G}</span>. However, since the commitment is only binding as long as <span class="math">q&gt;p/2</span>, the scheme only supports a bounded number of homomorphic additions of commitments. The evaluation proof is a recursive protocol that has the same flavor as Bulletproofs, but additionally requires the verifier to check an integer bound on the final message sent by the prover. The extracted witness are the integer coefficients of a polynomial <span class="math">f^{<em>}</span> such that <span class="math">C_{f}=f^{</em>}(q)\\cdot g</span>. Due to technicalities of the analysis, the extracted coefficients may have size <span class="math">p^{O(\\log d)}</span>. This is the reason why <span class="math">q</span> must be substantially larger than <span class="math">p</span>.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">A.5 FRI</h3>

    <p class="text-gray-300">Reed-Solomon codes over <span class="math">\\mathbb{F}</span> are parametrized by a rate parameter <span class="math">\\rho</span> and subset <span class="math">D\\subseteq\\mathbb{F}</span> of size <span class="math">n</span> and are defined as the set <span class="math">RS[D,\\rho]:=\\{f(D):f\\in\\mathbb{F}^{(&lt;\\rho n)}[X]\\}</span>. The notation <span class="math">f(D)</span> denotes the vector of evaluations of <span class="math">f</span> on all points in <span class="math">D</span> in some canonical order. Two vectors <span class="math">\\mathbf{u},\\mathbf{v}\\in\\mathbb{F}^{n}</span> are considered <span class="math">\\delta</span>-close if their relative Hamming distance, denoted <span class="math">\\Delta(\\mathbf{u},\\mathbf{v})</span>, is at most <span class="math">\\delta</span>. (The relative Hamming distance between vectors in <span class="math">\\mathbb{F}^{n}</span> is defined as the number of components in which <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span> are different divided by <span class="math">n</span>). For any <span class="math">\\mathbf{u}\\in\\mathbb{F}^{n}</span> and <span class="math">\\delta\\in[0,1]</span>, let <span class="math">B_{\\delta}(\\mathbf{u})</span> denote the ball of vectors that are <span class="math">\\delta</span>-close to <span class="math">\\mathbf{u}</span>. If <span class="math">\\mathbf{u}\\in RS[D,\\rho]</span>, then the unique decoding radius of <span class="math">\\mathbf{u}</span> is <span class="math">\\delta_{0}:=\\frac{1-\\rho}{2}</span>. This is due to the fact that the evaluations of any two distinct polynomials of degree less than <span class="math">\\rho n</span> agree in less than <span class="math">\\rho n</span> points of <span class="math">D</span>. Equivalently, if <span class="math">\\mathbf{u},\\mathbf{v}\\in RS[D,\\rho]</span> are distinct codewords then <span class="math">\\Delta(\\mathbf{u},\\mathbf{v})&gt;1-\\rho</span>. Thus, by the triangle inequality no <span class="math">\\mathbf{w}</span> can simultaneously have distance less than or equal to <span class="math">\\frac{1-\\rho}{2}</span> to both <span class="math">\\mathbf{u}</span> and <span class="math">\\mathbf{v}</span>. Given <span class="math">\\mathbf{w}\\in B_{\\delta_{0}}(\\mathbf{u})</span> for <span class="math">u\\in RS[D,\\rho]</span> with <span class="math">\\delta=\\delta_{0}</span>, the Berlekamp-Welch algorithm can be used to recover <span class="math">\\mathbf{u}</span> in time <span class="math">O(n^{3})</span>. More generally, for <span class="math">\\delta&lt;1-\\sqrt{\\rho}</span>, the Guruswami-Sudan algorithm may be used to recover from <span class="math">\\mathbf{w}\\in\\mathbb{F}^{n}</span> all <span class="math">\\mathbf{u}\\in RS[D,\\rho]</span> such that <span class="math">\\Delta(\\mathbf{w},\\mathbf{u})\\leq\\delta</span> in time <span class="math">O(n^{3})</span>.</p>

    <p class="text-gray-300">Setting <span class="math">d=\\lceil\\rho n\\rceil</span>, the FRI protocol requires only <span class="math">O(\\log d)</span> oracle queries to locations of a vector in order to prove with overwhelming probability that the vector is in <span class="math">B_{\\delta}(\\mathbf{u})</span> for some <span class="math">\\mathbf{u}\\in RS[D,\\rho]</span>. The value of <span class="math">\\delta</span> affects the concrete efficiency (a smaller <span class="math">\\delta</span> requires more queries to maintain the same error probability). Equating vectors in <span class="math">\\mathbb{F}^{n}</span> with polynomials <span class="math">\\mathbb{F}^{(&lt;n)}[X]</span>, given an oracle for <span class="math">f\\in\\mathbb{F}^{(&lt;n)}[X]</span> the FRI protocol with <span class="math">\\delta</span> set to the unique decoding radius <span class="math">\\delta_{0}</span> proves that <span class="math">f</span> has degree at most <span class="math">d</span>. The FRI protocol can also be applied to rational functions implicitly defined by several oracles. For example, if the verifier has oracle access to <span class="math">f,g,h\\in\\mathbb{F}^{(&lt;n)}[X]</span> then FRI can be used to prove that <span class="math">\\frac{f+g}{h}</span> has degree at most <span class="math">d</span>.</p>

    <p class="text-gray-300">FRI can be used as the evaluation protocol for a polynomial commitment scheme <em>[x21, x13, x1]</em>. The commitment <span class="math">\\mathsf{C}_{f}</span> to <span class="math">f\\in\\mathbb{F}^{(&lt;d)}[X]</span> is a vector commitment to the codeword <span class="math">f(D)\\in RS[D,\\rho]</span>. An opening is simply an opening of the vector commitment. To open an evaluation of <span class="math">\\mathsf{C}_{f}</span> to <span class="math">f(z)=y</span> for <span class="math">z\\not\\in D</span>, the prover runs FRI for the codewords <span class="math">f(D)</span> and <span class="math">q(D)</span> for <span class="math">q:=\\frac{f-y}{X-z}</span>, simulating oracle access to <span class="math">f(D)</span> and <span class="math">q(D)</span> by opening locations of the vector commitment <span class="math">\\mathsf{C}_{f}</span>. Abusing notation, we may denote the “virtual” commitment to <span class="math">q(D)</span> as a rational polynomial over formal group element variables: <span class="math">\\frac{\\mathsf{C}_{f}-y}{X-z}</span>. In fact, it suffices to run FRI on a random linear combination of <span class="math">f(D)</span> and <span class="math">q(D)</span>. For <span class="math">z\\in D</span> the prover runs FRI just on <span class="math">f(D)</span> and opens the appropriate location of the commitment to <span class="math">f(D)</span>.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">FRI batch evaluation</h4>

    <p class="text-gray-300">FRI can be applied directly to a linear combination codeword commitments (i.e., virtual codeword commitment) with additive as opposed to multiplicative overhead</p>

    <p class="text-gray-300">(see Protocol 8.2 of Aurora <em>[BCR^{+}19]</em>). FRI involves <span class="math">2\\log d</span> codewords in addition to the input codeword and <span class="math">\\kappa</span> queries to each codeword, where <span class="math">\\kappa</span> depends on both the decoding radius <span class="math">\\delta_{0}</span> and a statistical security parameter. The total number of queries is <span class="math">2\\kappa\\log d+\\kappa</span>, however only <span class="math">\\kappa</span> of these queries are made to the input codeword. Thus, the number of queries in FRI applied to a formal linear combination of <span class="math">\\ell</span> committed codewords of equal rate is only <span class="math">\\kappa\\cdot(\\ell-1)</span> larger than applying FRI to a single codeword. As a result, the communication/verification complexity of FRI Eval on a linear combination of <span class="math">\\ell</span> equal rate commitments is less than a factor <span class="math">1+\\frac{\\ell}{2\\log d}</span> larger than on a single commitment. Moreover, to simultaneously demonstrate proximity of multiple committed vectors to RS codewords it suffices to run FRI on a random linear combination of the commitments (see Section 8 of Aurora <em>[BCR^{+}19]</em>). This means that <span class="math">\\ell</span> commitments may be opened at <span class="math">\\ell</span> distinct points with complexity similar to a single Eval.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">A.6 Batch evaluation protocol</h3>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">A.6.1 Proof of Theorem 4</h4>

    <p class="text-gray-300">If Eval is knowledge sound, then the protocol in Figure 2 is a proof of knowledge for the relation:</p>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\texttt{ZTest}}(pp,d):=\\left\\{\\left\\langle(\\texttt{C},\\bm{\\Omega}),(\\texttt{f},\\texttt{op}\\overline{\\texttt{en}})\\right\\rangle:\\begin{array}[]{l}\\texttt{f}=(f_{1},...,f_{k})\\ s.t.f_{i}\\in\\mathbb{F}^{(<d)}[X]\\\\ \\forall i\\in[k]\\forall_{\\omega\\in\\Omega_{i}}f_{i}(\\omega)=0\\\\ \\forall i\\in[k]\\texttt{Verify}(pp,\\texttt{C}_{i},\\texttt{open}_{i},f_{i})=1\\end{array}\\right\\} \\]</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be an adversary that succeeds in the protocol with non-negligible probability. We define a knowledge extractor <span class="math">\\mathcal{E}</span> which will call the knowledge extractor <span class="math">\\mathcal{E}_{\\texttt{Eval}}</span> for Eval as a black box.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Step 1:</h5>

    <p class="text-gray-300"><span class="math">\\mathcal{E}</span> runs with an adversary <span class="math">\\mathcal{A}</span> and begins by using the tree-finding algorithm of Lemma 6 to generate a tree of <span class="math">2k</span> accepting transcripts that has the following properties:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There are <span class="math">k</span> distinct first-round challenges <span class="math">\\rho_{1}\\neq\\cdots\\neq\\rho_{k}\\neq 0\\bmod p</span></li>

      <li>For all <span class="math">i\\in[k]</span>, two transcripts share the first-round challenge <span class="math">\\rho_{i}</span> and have distinct second-round challenges <span class="math">r_{i}</span> and <span class="math">r^{\\prime}_{i}</span> such that <span class="math">z(r_{i})\\neq z(r^{\\prime}_{i})\\neq 0</span>.</li>

      <li>Let <span class="math">\\mathbf{V}\\in\\mathbb{Z}^{k\\times k}</span> denote the Vandermonde matrix with <span class="math">j</span>th row <span class="math">(1,\\rho_{j},...,\\rho_{j}^{k-1})</span> and let <span class="math">\\mathbf{R}\\in\\mathbb{Z}^{k\\times k}</span> be the matrix with <span class="math">(i,j)</span>th coordinate <span class="math">z_{i}(r_{j})</span>. The Hadamard product of these matrices <span class="math">\\mathbf{A}:=\\mathbf{V}\\circ\\mathbf{R}</span> is invertible over <span class="math">\\mathbb{F}_{p}</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will first show that the property <span class="math">z(r)\\neq z(r^{\\prime})\\neq 0</span> holds with overwhelming probability over <span class="math">r,r^{\\prime}\\xleftarrow{\\mathbb{\\scriptsize s}}\\mathbb{F}</span>. Let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Omega</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m>0<span class="math">. Since </span>z\\neq 0<span class="math"> for non-empty </span>\\Omega<span class="math"> and </span>deg(z)\\leq m<span class="math">, by the fundamental theorem of algebra the probability that </span>z(r)=0<span class="math"> is at most </span>\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Similarly, define the non-zero polynomial </span>z^{\\prime}(X):=z(X)-z(r)<span class="math">, then </span>r^{\\prime}<span class="math"> is a root of </span>z^{\\prime}(X)<span class="math"> with probability at most </span>\\frac{m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. By a union bound </span>z(r)\\neq z(r^{\\prime})\\neq 0<span class="math"> with probability at least </span>1-\\frac{3m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we will show that the third property holds with overwhelming probability. By Lemma 8, if every entry of <span class="math">\\mathbf{R}</span> is non-zero over <span class="math">\\mathbb{F}_{p}</span>, then for <span class="math">\\{\\rho_{j}\\}</span> sampled uniformly and independently the matrix <span class="math">\\mathbf{A}</span> is invertible except with probability $\\frac{k^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Moreover, for </span>\\{r_{j}\\}<span class="math"> sampled uniformly and independently, </span>z_{i}(r_{j})\\neq 0\\bmod p<span class="math"> except with probability </span>\\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Thus, </span>\\mathbf{A}<span class="math"> is invertible for random </span>\\{\\rho_{j},r_{j}\\}$ with overwhelming probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Having established these facts, by Lemma 6 there is an algorithm that runs in time <span class="math">\\mathrm{poly}(\\lambda)/\\epsilon</span> and with overwhelming probability generates a transcript tree satisfying the three properties above.</p>

    <p class="text-gray-300">Step 2: For <span class="math">j \\in [k]</span> let <span class="math">\\mathsf{C}_j^* := \\sum_{i=1}^k \\rho_j^{i-1} z_i(r_j) \\cdot \\mathsf{C}_i</span> and let <span class="math">\\mathsf{C}_{q_j}</span> denote the commitment sent by the prover in the transcript starting with <span class="math">\\rho_j</span>. The next step is to show that there exists a deterministic extraction algorithm that is given the transcript tree from Step 1 and succeeds with non-negligible probability to extract:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Valid openings of <span class="math">\\mathsf{C}_1^<em>, \\dots, \\mathsf{C}_k^</em></span> to a vector of polynomials <span class="math">\\mathbf{f}^<em> = (f_1^</em>, \\dots, f_k^*) \\in \\mathbb{F}^{(&amp;lt;d)}[X]^k</span></li>

      <li>Valid openings of <span class="math">\\mathsf{C}_{q_1}, \\dots, \\mathsf{C}_{q_k}</span> to polynomials <span class="math">\\mathbf{q} = (q_1, \\dots, q_k) \\in \\mathbb{F}[X]^k</span> such that <span class="math">f_i^*(r_i) = q_i(r_i)z(r_i)</span> for all <span class="math">i \\in [k]</span></li>

    </ul>

    <p class="text-gray-300">The success probability of the deterministic extractor will be over the randomness of the transcript tree output. By repeating the transcript tree generation <span class="math">\\mathrm{poly}(\\lambda)</span> times we can amplify the probability of success to <span class="math">1 - \\mathrm{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">We will describe the algorithm to extract <span class="math">f_1^<em></span> and <span class="math">q_1</span> such that <span class="math">f_1^</em>(r_1) = q_1(r_1) \\cdot z(r_1)</span>; the algorithm will be symmetric for all other <span class="math">j \\in [k]</span>. Let <span class="math">\\mathsf{C}_g := \\mathsf{C}_1^<em> - z(r_1) \\cdot \\mathsf{C}_{q_1}</span> and <span class="math">\\mathsf{C}_{g&#x27;} := \\mathsf{C}_1^</em> - z(r_1&#x27;) \\cdot \\mathsf{C}_{q_1}</span>. Set any non-negligible <span class="math">\\delta &amp;lt; \\epsilon / \\mathrm{poly}(\\lambda)</span>. By Lemma 7, with probability at least <span class="math">1 - \\frac{\\delta}{\\epsilon} \\mathrm{poly}(\\lambda)</span>, if <span class="math">\\mathcal{A}</span> is rerun on partial transcripts in the tree it succeeds with probability at least <span class="math">\\delta</span>. In particular, this means there is an Eval adversary <span class="math">\\mathcal{A}_{\\mathrm{Eval}}</span> that uses <span class="math">\\mathcal{A}</span> to succeed in the evaluation protocol on public inputs <span class="math">(\\mathsf{C}_g, r_1, 0)</span> and <span class="math">(\\mathsf{C}_g, r_1&#x27;, 0)</span> with probability at least <span class="math">\\delta</span>. Therefore, with probability <span class="math">1 - \\frac{\\delta}{\\epsilon} \\mathrm{poly}(\\lambda)</span>, there exists <span class="math">\\mathcal{E}_{\\mathrm{Eval}}</span> that runs for time <span class="math">\\mathrm{poly}(\\lambda) / \\delta</span> and with overwhelming probability succeeds in extracting valid openings of <span class="math">\\mathsf{C}_g</span> and <span class="math">\\mathsf{C}_{g&#x27;}</span> to polynomials <span class="math">g(X)</span> and <span class="math">g&#x27;(X)</span> such that <span class="math">g(r_1) = g&#x27;(r_1&#x27;) = 0</span>.</p>

    <p class="text-gray-300">Assuming these steps have succeeded, let <span class="math">\\mathbf{M}</span> be the <span class="math">2 \\times 2</span> integer matrix with columns <span class="math">(1, -z(r_1))</span> and <span class="math">(1, -z(r_1&#x27;))</span> so that <span class="math">(\\mathsf{C}_g, \\mathsf{C}_{g&#x27;}) \\cdot \\mathbf{M} = (\\mathsf{C}_1^<em>, \\mathsf{C}_{q_1})</span>. Applying Lemma 4, the extractor obtains polynomials <span class="math">f_1^</em>, q_1 \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> such that <span class="math">f_1^<em> - z(r_1)q_1 = g \\bmod p</span> and <span class="math">f_1^</em> - z(r_1&#x27;)q_1 = g&#x27; \\bmod p</span>, integers <span class="math">t, t&#x27; \\neq 0</span>, and openings of <span class="math">t \\cdot \\mathsf{C}_1^<em></span> to <span class="math">t \\cdot f_1^</em> \\bmod p</span> and of <span class="math">t&#x27; \\cdot \\mathsf{C}_{q_1}</span> to <span class="math">t&#x27; \\cdot q \\bmod p</span>. These are valid openings of <span class="math">\\mathsf{C}_1^<em></span> to <span class="math">f_1^</em></span> and <span class="math">\\mathsf{C}_{q_1}</span> to <span class="math">q_1</span>. Moreover, <span class="math">f_1^*(r_1) = z(r_1)q(r_1) \\bmod p</span> and <span class="math">f(r_1&#x27;) = z(r_1&#x27;)q(r_1&#x27;) \\bmod p</span>.</p>

    <p class="text-gray-300">Step 3: Finally, we show there is an algorithm that takes the information extracted in Step 2 and with overwhelming probability outputs valid openings of <span class="math">\\mathsf{C}_1, \\dots, \\mathsf{C}_k</span> to a list of polynomials <span class="math">f_1, \\dots, f_k \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span> such that <span class="math">z</span> divides <span class="math">z_i \\cdot f_i</span> for each <span class="math">i \\in [k]</span>. This implies that <span class="math">f_i(\\Omega_i) = 0</span> for each <span class="math">i \\in [k]</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{C}^<em> = (\\mathsf{C}_1^</em>, \\dots, \\mathsf{C}_k^<em>)</span> and <span class="math">\\mathbf{C} = (\\mathsf{C}_1, \\dots, \\mathsf{C}_k)</span>. We have that <span class="math">\\mathbf{A} \\cdot \\mathbf{C} = \\mathbf{C}^</em></span> for <span class="math">\\mathbf{A} = \\mathbf{V} \\circ \\mathbf{R}</span>. If <span class="math">\\mathbf{A}</span> is invertible, then by Lemma 4 there is an efficient algorithm to compute valid openings of the components of <span class="math">\\mathbf{C}</span> to a vector of polynomials <span class="math">\\mathbf{f} = (f_1, \\dots, f_k) \\in (\\mathbb{F}^{(&amp;lt;d)}[X])^k</span> such that <span class="math">\\mathbf{A}\\mathbf{f} = \\mathbf{f}^<em></span>. This implies that <span class="math">\\sum_{i=1}^{k} \\rho_j^{i-1} z_i(r_j) f_i(r_j) = f_j^</em>(r_j) = q_j(r_j) \\cdot z(r_j)</span> for each <span class="math">j \\in [k]</span>. We can now argue that if <span class="math">\\sum_{i=1}^{k} \\rho_j^{i-1} z_i \\cdot f_i \\neq q_i \\cdot z</span> then this contradicts the binding property of the PCS.</p>

    <p class="text-gray-300">Let <span class="math">h_j \\coloneqq \\sum_{i=1}^k \\rho_j^{i-1} z_i \\cdot f_i - q_j \\cdot z</span>. If <span class="math">h \\neq 0</span> for <span class="math">j \\in [k]</span>, then based on Lemma 7 and Lemma 6, there is an efficient algorithm to generate a fresh transcript tree with the same fixed challenges <span class="math">\\rho_j</span> but fresh subtrees with new challenges <span class="math">\\{r_j&#x27;\\}</span> with the property that <span class="math">h_j(r_j&#x27;) \\neq 0</span>. Repeating the extraction process above, with non-negligible probability this algorithm succeeds in computing openings of each <span class="math">\\mathsf{C}_{q_j}</span> to a polynomial <span class="math">q_j&#x27;</span> and an opening of each <span class="math">\\mathsf{C}_i</span> to a polynomial <span class="math">f_i&#x27;</span> such that</p>

    <p class="text-gray-300">39</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j}^{\\prime})f_{i}^{\\prime}(r_{j}^{\\prime})=q_{j}^{\\prime}(r_{j})\\cdot z(r_{j}^{\\prime})</span>. Yet, since <span class="math">h_{j}(r_{j}^{\\prime})\\neq 0</span> for all <span class="math">j</span>, this implies that either <span class="math">f_{i}^{\\prime}\\neq f_{i}</span> for some <span class="math">i\\in[k]</span>, or <span class="math">q_{j}^{\\prime}\\neq q_{j}</span> for some <span class="math">j\\in[k]</span>. This would contradict the binding property of the PCS.</p>

    <p class="text-gray-300">We conclude that with overwhelming probability <span class="math">h_{j}=0</span> for all <span class="math">j\\in[k]</span>. Setting <span class="math">\\mathbf{z}:=(z_{1},...,z_{k})</span> so that <span class="math">\\mathbf{z}\\circ\\mathbf{f}=(z_{1}\\cdot f_{1},...,z_{k}\\cdot f_{k})</span>, we have <span class="math">\\mathbf{V}\\cdot(\\mathbf{z}\\circ\\mathbf{f})=z\\cdot\\mathbf{q}</span> mod <span class="math">p</span>. Since <span class="math">\\mathbf{V}</span> is invertible, this shows that <span class="math">\\mathbf{z}\\circ\\mathbf{f}=z\\cdot\\mathbf{V}^{-1}\\mathbf{q}</span>. Therefore, every <span class="math">z_{i}\\cdot f_{i}</span> is a multiple of <span class="math">z</span>. <span class="math">\\square</span></p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{M}</span> be an <span class="math">n\\times n</span> matrix over <span class="math">\\mathbb{F}_{p}^{\\times}</span>. Let <span class="math">\\mathbf{V}</span> be a random Vandermonde matrix over <span class="math">\\mathbb{F}_{p}</span>, sampled uniformly and independent of <span class="math">\\mathbf{A}</span>. Their Hadamard product <span class="math">\\mathbf{V}\\circ\\mathbf{M}</span> is invertible with probability at least $1-\\frac{n^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathbf{V}(\\mathbf{X})</span> denote the Vandermonde matrix over formal variables <span class="math">X_{1},...,X_{n}</span>. Using the Leibnitz formula, <span class="math">det(\\mathbf{V}(\\mathbf{X}))</span> is an <span class="math">n</span>-variate polynomial, which is an alternating sum of <span class="math">n!</span> distinct monomials. The determinant of the Hadamard product, <span class="math">det(\\mathbf{V}(\\mathbf{X})\\circ\\mathbf{M})</span> is also an alternating sum of <span class="math">n!</span> distinct monomials where the coefficient on each distinct monomial is a distinct summand of the Leibnitz formula for <span class="math">det(\\mathbf{M})</span>. All coefficients are non-zero since all entries of <span class="math">\\mathbf{A}</span> are non-zero. Therefore, this <span class="math">n</span>-variate polynomial is not identically zero. Let <span class="math">p(X_{1},...,X_{n})</span> denote this polynomial, which has total degree less than <span class="math">n^{2}</span>. A random Vandermonde matrix <span class="math">\\mathbf{V}</span> is a random assignment <span class="math">\\mathbf{x}=(x_{1},...,x_{n})</span> to the <span class="math">n</span> variables <span class="math">X_{1},...,X_{n}</span> and thus <span class="math">det(\\mathbf{V}\\circ\\mathbf{M})=p(x_{1},...,x_{n})</span>. By the Schwartz-Zippel lemma, the probability that <span class="math">p(x_{1},...,x_{n})=0</span> is at most $\\frac{n^{2}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">A.6.2 Proof of Theorem 5</h4>

    <p class="text-gray-300">If <span class="math">\\mathsf{Eval}</span> is knowledge sound, then the batch evaluation protocol in Figure 5 is a proof of knowledge for the relation <span class="math">\\mathcal{R}_{\\mathsf{BatchEval}}(pp,d)</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The extractor requires only a one line change to the extractor in the analysis of Theorem 4. Once the extractor obtains an opening for <span class="math">\\mathsf{C}_{j}^{<em>}</span> to <span class="math">f_{j}^{</em>}\\in\\mathbb{F}^{(&amp;lt;d)}[X]</span> for each <span class="math">j\\in[k]</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{C}_{j}^{*}=\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j})\\cdot(\\mathsf{C}_{i}-t_{i}(r_{j}))\\cdot\\mathsf{C}_{1}</span></li>

      <li><span class="math">f_{j}^{*}(r_{j})=q_{j}(r_{j})\\cdot z(r_{j})</span></li>

    </ul>

    <p class="text-gray-300">it derives the commitments <span class="math">\\tilde{\\mathsf{C}}_{j}:=\\mathsf{C}_{j}^{<em>}+\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j})\\cdot t_{i}(r_{j})\\cdot\\mathsf{C}_{1}</span> and an opening of each <span class="math">\\tilde{\\mathsf{C}}_{j}</span> to the polynomial <span class="math">\\tilde{f}:=f^{</em>}+\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j})\\cdot t_{i}(r_{j})</span>. Since <span class="math">\\tilde{\\mathsf{C}}_{j}=\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j})\\cdot\\mathsf{C}_{i}</span>, the extractor can proceed in exactly the same way replacing each <span class="math">\\mathsf{C}_{j}^{*}</span> with <span class="math">\\tilde{\\mathsf{C}}_{j}</span>. The extractor obtains <span class="math">f_{1},...,f_{k}</span> such that <span class="math">\\sum_{i=1}^{k-1}\\rho_{j}^{i-1}z_{i}(r_{j})f_{i}(r_{j})=\\tilde{f}_{j}(r_{j})</span>. Since <span class="math">\\tilde{f}_{j}=q_{j}(r_{j})\\cdot z(r_{j})+\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}(r_{j})\\cdot t_{i}(r_{j})</span>, the remainder of the analysis shows that <span class="math">\\sum_{i=1}^{k}\\rho_{j}^{i-1}z_{i}\\cdot(f_{i}-t_{i})=q_{i}\\cdot z</span> with overwhelming probability. Finally, this implies that each <span class="math">z_{i}\\cdot(f_{i}-t_{i})</span> is a multiple of <span class="math">z</span>, by inverting the Vandermonde matrix defined by the challenges <span class="math">\\rho_{j}</span>. In conclusion, <span class="math">f_{i}(\\Omega_{i})=t_{i}(\\Omega_{i})</span> for all <span class="math">i\\in[k]</span>. <span class="math">\\square</span></p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">A.7 Zero knowledge HPI protocol</h3>

    <p class="text-gray-300">Lemma 5 stated:</p>

    <p class="text-gray-300">The transformed protocol is an <span class="math">n\\cdot 2^{-\\lambda}</span>-statistical HVZK interactive protocol for relation <span class="math">\\mathcal{R}_{\\mathsf{Bounded-HPI}}(\\phi,\\mathbb{G},2^{\\lambda})</span>, and a proof of knowledge for relation <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^{*}(\\phi,\\mathbb{G},p)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Figure 5: A protocol for simultaneously proving equality of multiple committed polynomials with multiple public polynomials on distinct sets:  <span class="math">\\mathsf{C}_i = \\mathsf{Commit}(pp, f_i)</span> ,  <span class="math">\\Omega_i</span>  is a non-empty subset of  <span class="math">\\mathbb{F}</span> , and  <span class="math">t_i \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>  for all  <span class="math">i \\in [k]</span> . The protocol shows that  <span class="math">f_i(\\Omega_i) = t_i(\\Omega_i)</span> . The pair  <span class="math">(\\mathsf{C}^{(1)}, \\mathsf{open}^{(1)}) \\gets \\mathsf{Commit}(pp, 1)</span>  is a deterministic commitment to the constant polynomial  <span class="math">f \\equiv 1</span>  that can be publicly derived. The prover's derivation of the opening string open for  <span class="math">\\mathsf{C}_f</span>  from  <span class="math">o_1, \\ldots, o_k, \\mathsf{open}_q</span>  and  <span class="math">\\mathsf{open}^{(1)}</span>  using  <span class="math">\\mathsf{add}^*</span>  is not shown.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P({fi, o_i, ti, Ω_i}i∈[k])</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V({Ci, ti, Ω_i}i∈[k])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Ω := ∪k i=1 Ω_i</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω := ∪k i=1 Ω_i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">z := ∏ω∈Ω(X - ω)</td>

            <td class="px-3 py-2 border-b border-gray-700">z := ∏ω∈Ω(X - ω)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i Ω_i := Ω \\ Ω_i</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i Ω_i := Ω \\ Ω_i</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">∀i zi := ∏ω∈Ω_i(X - ω)</td>

            <td class="px-3 py-2 border-b border-gray-700">∀i zi := ∏ω∈Ω_i(X - ω)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ρ</td>

            <td class="px-3 py-2 border-b border-gray-700">ρ ∈ F</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  q(X) := ∑i=1 k ρi-1 zi(f_i - ti)/z |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(Cq, open_q) ← Commit(pp, q)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r ∈ F</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  g_i := zi(r) · (fi - ti(r)) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g := ∑i=1 k ρi-1 gi - z(r) · q</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∀i compute zi(r)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (if all is valid then g(r) = 0) |   |</p>

    <p class="text-gray-300">|   | C_i' := C_i - ti(r) · C(1)  |</p>

    <p class="text-gray-300">|   | C* := ∑i=1 k ρi-1 zi(r) · C_i'  |</p>

    <p class="text-gray-300">|   | C_g := C* - z(r) · C_q  |</p>

    <p class="text-gray-300">|  Eval(P(g, open_g, r), V(C_g, r, 0))  |   |</p>

    <p class="text-gray-300">Proof. The simulator samples an element  <span class="math">\\tilde{z}</span>  of  <span class="math">\\mathbb{G}</span>  by sampling a uniform random vector  <span class="math">\\mathbf{z} \\gets [0, 2^{2\\lambda})^n</span>  and setting  <span class="math">\\tilde{z} \\gets [[\\mathbf{z}]]_{\\mathbb{R}}</span> . It samples  <span class="math">\\tilde{c} \\gets [0, 2^{\\lambda})</span> . It sets  <span class="math">\\tilde{h} \\gets \\tilde{z} - \\tilde{c} \\cdot y</span> . It generates a simulated transcript  <span class="math">\\tilde{\\pi}</span>  of the honest protocol for  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^*</span>  playing the roles of both prover/verifier on witness  <span class="math">\\mathbf{z}</span>  and verifier input  <span class="math">\\tilde{z}</span> . It outputs the simulated transcript  <span class="math">(\\tilde{h}, \\tilde{c}, \\tilde{z}, \\tilde{\\pi})</span> .</p>

    <p class="text-gray-300">The challenges  <span class="math">\\tilde{c}</span>  and  <span class="math">c</span>  are identically distributed and sampled independently from all other components of the transcripts. If the prover's witness  <span class="math">\\mathbf{x}</span>  is in the bounded set  <span class="math">(-2^{\\lambda}, 2^{\\lambda})^{n}</span>  then by Fact 1 and Fact 2 the statistical distance between  <span class="math">\\mathbf{z}</span>  and  <span class="math">\\mathbf{r} + c \\cdot \\mathbf{x}</span>  is at most  <span class="math">n \\cdot 2^{-\\lambda}</span> . The distributions of the transcripts  <span class="math">\\pi</span>  and  <span class="math">\\tilde{\\pi}</span>  are fully determined by witnesses  <span class="math">\\mathbf{r} + c \\cdot \\mathbf{x}</span>  and  <span class="math">\\mathbf{z}</span>  respectively, and thus  <span class="math">(\\mathbf{z}, \\tilde{\\pi})</span>  and  <span class="math">(\\mathbf{r} + c \\cdot \\mathbf{x}, \\pi)</span>  have distance at most  <span class="math">n \\cdot 2^{-\\lambda}</span> . Finally, since  <span class="math">\\tilde{z} = \\phi(\\mathbf{z})</span> ,  <span class="math">h + c \\cdot y = \\phi(\\mathbf{r} + c \\cdot \\mathbf{x})</span> , and  <span class="math">\\tilde{h} = \\tilde{z} - \\tilde{c} \\cdot y</span> , it follows that  <span class="math">(\\tilde{h}, \\tilde{c}, \\tilde{z}, \\tilde{\\pi})</span>  and  <span class="math">(h, c, h + c \\cdot y, \\pi)</span>  have distance at most  <span class="math">n \\cdot 2^{-\\lambda}</span> .</p>

    <p class="text-gray-300">As for soundness, the extractor  <span class="math">\\mathcal{E}</span>  invokes the tree-finding algorithm (Lemma 6) to get two accepting transcripts that share the same first message  <span class="math">h</span>  but have distinct challenges  <span class="math">c, c&#x27;</span> , which define  <span class="math">z = h + c \\cdot y</span>  and  <span class="math">z&#x27; = h + c&#x27; \\cdot y</span> . By Lemma 7, with high probability the transcript has the property that the adversary succeeds in the subroutine for  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^<em></span>  on both partial transcripts with non-negligible probability. In this case, the extractor  <span class="math">\\mathcal{E}&#x27;</span>  for the  <span class="math">\\mathcal{R}_{\\mathsf{HPI}}^</em></span>  subprotocol outputs witnesses  <span class="math">(t, s) \\in \\mathbb{Z} \\times \\mathbb{G}_1</span>  such that  <span class="math">\\phi(s) = t \\cdot z</span>  and  <span class="math">(t&#x27;, s&#x27;) \\in \\mathbb{Z} \\times \\mathbb{G}_2</span>  such that  <span class="math">\\phi(s&#x27;) = t&#x27; \\cdot z&#x27;</span> , where  <span class="math">t \\neq 0 \\mod p</span></p>

    <p class="text-gray-300">and <span class="math">t&#x27; \\neq 0 \\mod p</span>. If it does not succeed this step is repeated up to <span class="math">\\lambda</span> times. The probability none succeed is negligible in <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{T} \\in \\mathbb{Z}^{2 \\times 2}</span> be the diagonal matrix with entries <span class="math">t</span> and <span class="math">t&#x27;</span>. Let <span class="math">\\mathbf{A} \\in \\mathbb{Z}^{2 \\times 2}</span> be the matrix with rows <span class="math">(1, c)</span> and <span class="math">(1, c&#x27;)</span> so that <span class="math">\\langle \\mathbf{TA}, (h, y) \\rangle = \\langle \\mathbf{T}, (z, z&#x27;) \\rangle</span>. Since <span class="math">det(\\mathbf{T}) = t \\cdot t&#x27; \\neq 0 \\mod p</span> and <span class="math">det(\\mathbf{A}) = c - c&#x27; \\neq 0 \\mod p</span>, both <span class="math">\\mathbf{T} \\cdot \\mathbf{A}</span> is invertible over <span class="math">\\mathbb{F}</span>. There is a matrix <span class="math">\\mathbf{L} \\in \\mathbb{Z}^{2 \\times 2}</span> such that <span class="math">\\mathbf{L} \\cdot \\mathbf{T} \\cdot \\mathbf{A} = \\mathbf{D}</span> is diagonal with entries <span class="math">d_1, d_2</span> such that <span class="math">d_1 \\neq 0 \\mod p</span> and <span class="math">d_2 \\neq 0 \\mod p</span>. Let <span class="math">\\mathbf{L}_2</span> denote the second row of <span class="math">\\mathbf{L}</span>, let <span class="math">\\mathbf{s} := (s, s&#x27;)</span>, and let <span class="math">\\phi(\\mathbf{s}) := (\\phi(s), \\phi(s&#x27;))</span>. The extractor obtains the witness <span class="math">(d_2, \\langle \\mathbf{L}_2, \\mathbf{s} \\rangle) \\in \\mathbb{Z} \\times \\mathbb{G}_2</span>, which satisfies <span class="math">d_2 \\cdot y = \\langle \\mathbf{L}_2 \\cdot \\mathbf{T}, (z, z&#x27;) \\rangle = \\langle \\mathbf{L}_2, \\phi(\\mathbf{s}) \\rangle = \\phi(\\langle \\mathbf{L}_2, \\mathbf{s} \\rangle)</span>. □</p>

    <h2 id="sec-57" class="text-2xl font-bold">A.8 HPI protocol performance</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof communication size</strong> The proof size is two <span class="math">\\mathbb{G}</span> elements per round for <span class="math">\\log n</span> rounds, and then additionally a single integer <span class="math">x&#x27; \\in \\mathbb{Z}</span> sent in the final round. In the case that <span class="math">p\\mathbb{Z} \\subseteq \\ker(\\phi)</span> then only the value <span class="math">x&#x27; \\mod p</span> needs to be communicated. More generally, if all coordinates of the witness <span class="math">\\mathbf{x}</span> have absolute value at most <span class="math">2^{\\lambda}</span> then <span class="math">x&#x27;</span> is an integer of absolute value at most <span class="math">2^{\\lambda (\\log n + 1)}</span>. Letting <span class="math">\\Delta</span> denote the size (in bit-length) of the final integer sent and $S_{\\mathbb{G}} \\in O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> the representation size of group elements, then the total communication size is </span>2\\log n \\cdot S_{\\mathbb{G}} + \\Delta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Prover complexity</strong> Suppose that the prover's witness <span class="math">\\mathbf{x} \\in \\mathbb{Z}^n</span> has bounded norm $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq B<span class="math">. In the </span>i<span class="math">th round of the protocol, for </span>i \\in [1, \\log n]<span class="math">, the prover&#x27;s work is dominated by computing two linear combinations over </span>\\mathbb{G}<span class="math"> each of length </span>n/2^i<span class="math"> with integer coefficients of size at most </span>2^{(i-1)\\lambda} \\cdot B<span class="math">. In total, these linear combinations naively cost at most </span>2(\\lambda + \\log B) \\cdot n<span class="math"> operations in </span>\\mathbb{G}<span class="math">. Fast algorithms for linear combinations over groups (e.g., Pippenger [Pip80]) may give up to a factor </span>\\log n<span class="math"> speedup. In the case that </span>\\mathbb{G}<span class="math"> has known order </span>q<span class="math">, then the coefficients do not exceed </span>q<span class="math"> as they can first be reduced modulo </span>q<span class="math">. In this case the total number of group operations is </span>O(\\log q \\cdot n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Verifier complexity</strong> The verifier's work is <span class="math">O(\\lambda \\cdot n)</span> operations in <span class="math">\\mathbb{G}</span> overall. The main cost is deriving the group vectors <span class="math">\\mathbf{g}&#x27; \\gets \\mathbf{g}_R + \\alpha \\mathbf{g}_L</span> for each round. As an optimization, since the <span class="math">\\mathbf{g}</span> vectors are not used explicitly by the verifier until the last round where <span class="math">d&#x27; = 1</span>, the verifier does not need to output the intermediate values of <span class="math">\\mathbf{g}&#x27;</span> for rounds where <span class="math">d&#x27; &amp;gt; 1</span>. It may derive the final <span class="math">g&#x27; \\in \\mathbb{G}</span> as a single linear combination of <span class="math">n</span> group vectors in <span class="math">\\mathbb{G}</span> with coefficients of size <span class="math">O(\\lambda \\log n)</span>-bits from <span class="math">\\mathbb{Z}</span>. The verifier additionally computes a linear combination of 3 elements in <span class="math">\\mathbb{G}</span> with scalars at most <span class="math">2\\lambda</span>-bits per round to derive the final round <span class="math">y&#x27; \\in \\mathbb{G}</span> and check that <span class="math">x&#x27; \\cdot g&#x27; = y&#x27;</span>.</p>

    <p class="text-gray-300"><strong>Batch verification</strong> Extending ideas from Bulletproofs [BBB+18] and Halo [BGH19], there is a way to amortize the cost of verifying proofs in a batch. The <span class="math">\\mathbf{g}</span> vectors are not used explicitly by the verifier until the last round. Moreover, the final <span class="math">g&#x27; = \\llbracket \\mathbf{u} \\rrbracket_{\\mathbf{g}} = \\phi(\\mathbf{u})</span> where each <span class="math">\\mathbf{u} = (u_1, \\dots, u_n) \\in \\mathbb{Z}^n</span> is defined as follows. Given challenges <span class="math">\\{\\alpha_i\\}</span> for an execution of the protocol, for each <span class="math">i \\in [d]</span> let <span class="math">u_i = \\prod_{j=1}^{\\log n} v_{ij}</span> where the value <span class="math">v_{ij} = \\alpha_j</span> if the <span class="math">j</span>th bit of <span class="math">i</span> is 0 and <span class="math">v_{ij} = 1</span> if the <span class="math">j</span>th bit of <span class="math">i</span> is 1. Equivalently, <span class="math">\\mathbf{u}</span> is the coefficient vector of the degree <span class="math">n - 1</span> polynomial <span class="math">u(X) = \\prod_{i=1}^{\\log n} (\\alpha_i + X^{2^{i-1}})</span>.</p>

    <p class="text-gray-300">Suppose the verifier receives <span class="math">k</span> proofs with final round pre-images <span class="math">x_1&#x27;, \\ldots, x_k&#x27;</span> and targets <span class="math">y_1&#x27;, \\ldots, y_k&#x27;</span>. Let <span class="math">\\mathbf{u}_i</span> be defined by the challenges of the <span class="math">i</span>th proof as described above. Rather than computing <span class="math">g_i&#x27; \\gets \\phi(\\mathbf{u}_i)</span> for each <span class="math">i \\in [k]</span> and checking that <span class="math">y_i&#x27; = x_i&#x27; \\cdot g_i&#x27;</span> individually, the verifier instead samples <span class="math">r_1, \\ldots, r_k \\stackrel{\\mathrm{s}}{\\leftarrow} [0, 2^{\\lambda})</span>, computes <span class="math">\\mathbf{u}^<em> := \\sum_{i=1}^{k} r_i \\cdot x_i&#x27; \\cdot \\mathbf{u}_i</span>, <span class="math">y^</em> = \\sum_{i=1}^{k} y_i&#x27;</span>, and checks that <span class="math">y^<em> = \\phi(\\mathbf{u}^</em>)</span>.</p>

    <p class="text-gray-300">42</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While deriving <span class="math">\\mathbf{u}^*</span> still requires <span class="math">\\Omega(kn)</span> integer multiplications<span class="math">^7</span>, the verifier evaluates <span class="math">\\phi</span> only once. This is advantageous when evaluating <span class="math">\\phi</span> is more expensive than computing linear combinations of vectors in <span class="math">\\mathbb{Z}^n</span> (e.g., when operations in <span class="math">\\mathbb{G}</span> are slower than integer multiplications). There are also algorithms to amortize the cost of large linear combinations of group elements (such as Pippenger's "multiexponentiation" algorithms [Pip80]), which may help for speeding up the evaluation of <span class="math">\\phi</span>. Moreover, when the verifier knows $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= q<span class="math"> then all the scalar multiplications can be taken over </span>\\mathbb{Z}_q$, which is more efficient.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-58" class="text-2xl font-bold">A.9 Halo proof recursion from PCS aggregation</h2>

    <p class="text-gray-300"><strong>Proof bootstrapping</strong> The construction we will describe is based on the recursive proving paradigm of Bitansky et. al. [BCCT13], also known as "proof bootstrapping", combined with a generalization of a technique described in the Halo protocol [BGH19]. A <em>recursive proof system</em> <span class="math">(S, P, V)</span> for a path distributed computation with predicate <span class="math">F: \\mathbb{F}^{\\ell_1} \\times \\mathbb{F}^{\\ell_2} \\to \\mathbb{F}^{\\ell_1}</span> (informally) provides the ability to prove the statements <span class="math">\\phi(i, z_0, z_i)</span> defined recursively, given <span class="math">\\mathsf{loc}_1, \\ldots, \\mathsf{loc}_i</span>, as:</p>

    <p class="text-gray-300">“there exists <span class="math">z_{i-1} \\in \\mathbb{F}^{\\ell_1}</span>, <span class="math">\\mathsf{loc}_i \\in \\mathbb{F}^{\\ell_2}</span>, and a proof <span class="math">\\pi_{i-1}</span> such that <span class="math">F(z_{i-1}, \\mathsf{loc}_i) = z_i</span> and the verification <span class="math">V(\\phi(i-1, z_0, z_{i-1}), \\pi_{i-1})</span> accepts”</p>

    <p class="text-gray-300">Bitansky et. al. showed that starting from a SNARK system that has sublinear time verification it is possible to build a recursive proof system for path distributed computations, where the size and verification time of proofs, as well as the complexity of generating a proof for the incremental statement <span class="math">\\phi(i, z_0, z_i)</span> given <span class="math">w_i</span> and <span class="math">\\pi_{i-1}</span> are all independent of the recursion depth. Recently, Chiesa et. al. [COS20] improved upon this construction for the case of preprocessing SNARKs. A prover can use the recursive proof system to incrementally generate proofs for each step of the path distributed computation and publish only the last proof. This not only achieves a proof size and verification time independent of the depth, but also the prover's space complexity is independent of the depth <span class="math">t</span> and its time complexity is linear in <span class="math">t</span>. Bitansky et. al. call this a <em>complexity-preserving</em> SNARK, which was a primary motivation behind their recursive proof system. The system is used to "bootstrap" a normal SNARK (which may have expensive preprocessing, inefficient space complexity proportional to <span class="math">t</span>, or a superlinear proving time) into a complexity-preserving one.</p>

    <p class="text-gray-300">The main significance of the construction we will describe, which is based on the Halo protocol, is that we do not even start from an efficiently verifiable SNARK. Rather, we start with a succinct PCS, an efficient aggregation scheme for the PCS, and a Polynomial IOP (PIOP) for general programs (i.e., NP languages). Any PCS that is both succinct and <em>efficient</em> can be combined with any Polynomial IOP (PIOP) to build a SNARK [BFS20, <span class="math">\\mathrm{CHM}^{+}20</span>], in which case the classical bootstrapping method works. However, in our case, it is ok for the PCS to have inefficient verification as long as it has an efficient aggregation scheme (i.e., with a good amortization ratio). Thus, the construction can be used to "bootstrap" this special class of PIOP-based SNARKs with inefficient verification into complexity-preserving SNARKs with efficient verification. Furthermore, in addition to enabling bootstrapping for a wider class of proof systems, the technique is also a practical improvement on the classical proof recursion method of Bitansky et. al. applied to PIOP-based SNARKs, when the underlying PCS has an efficient aggregation scheme. Based on the results of the prior sections, this includes any additive PCS, and even some non-additive schemes such as the FRI-based PCS.</p>

    <p class="text-gray-300"><span class="math">^7</span>Computing all <span class="math">\\mathbf{u}_i</span> naively requires <span class="math">O(n \\log n)</span> multiplications, but due to the overlapping structure of the vector components it is possible to derive all <span class="math">\\mathbf{u}_i</span> with <span class="math">O(n)</span> multiplications overall using dynamic programming.</p>

    <p class="text-gray-300">43</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">Proof carrying data</h4>

    <p class="text-gray-300">A recursive proof system has applications beyond bootstrapping. For example, it can be used inside the path distributed computation itself so that each node receives a proof along with the output of the previous node that attests to the correctness of all prior computations along the distributed path. Each node verifies this proof, performs its local computation, and produces an output along with a proof that it both verified the previous proof and performed the local computation correctly. This is called a <em>proof carrying data</em> (PCD) <em>[x10, x1]</em> system and generalizes to any DAG distributed computation. PCD systems also generalize <em>incrementally verifiable computation</em> (IVC), proposed by Valiant <em>[x29]</em>, where a machine outputs a proof after each step of computation that attests to the correct history of computation steps.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">Private vs public aggregation</h4>

    <p class="text-gray-300">An important distinction between the needs of proof bootstrapping and IVC versus PCD is that in the former the prover can retain an additional private state that helps it produce the next incremental proof whereas in the latter it cannot. In PCD any additional state must be included as a part of the proof because the next node/prover must be able to produce the next proof. In other words, PCD is sufficient but not necessary for proof bootstrapping, while a bootsrapping system is insufficient for PCD. This is relevant to our generalized Halo protocol: we present two variations of the protocol, one that uses public PCS aggregation and one that uses private PCS aggregation. Public PCS aggregation achieves a smaller communication between nodes of the PCD computation compared with private PCS aggregation. However, in our general constructions public aggregation is computationally more expensive than private aggregation. Private aggregation is superior for the purpose of constructing efficient SNARKs or IVC.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">Bounded RAM programs</h4>

    <p class="text-gray-300">A bounded RAM program is specified as a tuple <span class="math">(P,\\ell,m,t)</span>, where <span class="math">P</span> is a program with a fixed-size read/write memory array of length <span class="math">\\ell</span>, called the <em>work tape</em>, and <span class="math">t</span> is an upper bound on the maximum number of steps for which <span class="math">P</span> runs any input. The program is modeled as having a separate read-only memory array of length at most <span class="math">m</span> that holds the inputs, called the <em>input tape</em>. In the context of a proof system, the input may be split into <span class="math">m_{1}</span> <em>public inputs</em> <span class="math">\\mathbf{x}</span> and <span class="math">m_{2}</span> <em>private inputs</em> <span class="math">\\mathbf{w}</span>, where <span class="math">m_{1}+m_{2}=m</span>. The verifier only receives <span class="math">\\mathbf{x}</span> and the prover demonstrates existence/knowledge of <span class="math">\\mathbf{w}</span> (also called the <em>witness</em>) such that the RAM program has a specified output (included as part of <span class="math">\\mathbf{x}</span>).</p>

    <h4 id="sec-62" class="text-lg font-semibold mt-6">Bounded RAM computational reduction</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A proof system for bounded RAM programs <span class="math">(P,\\ell,m,t)</span> that achieves verification time $\\mathsf{poly}(m_{1},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell,\\log t)<span class="math"> for </span>m_{1}<span class="math"> public inputs is sufficient to construct a computationally-sound proof system that achieves verification time </span>\\mathsf{poly}(m_{1},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log t)<span class="math"> regardless of the memory bound <em>[BEG^{+}91, x1]</em>. Moreover, it is sufficient if the proof system assumes the bounded RAM program reads sequentially from the witness portion of the input. This construction uses Merkle trees. Any RAM computation </span>P<span class="math"> that runs for </span>t<span class="math"> steps using </span>O(t)<span class="math"> space can be verified by a RAM program </span>P^{\\prime}<span class="math">, which uses only </span>O(\\log t)<span class="math"> space and runs for </span>O(t\\log t)<span class="math"> steps, provided a witness that contains Merkle proofs for the authenticated read/write operations of </span>P$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-63" class="text-lg font-semibold mt-6">Path distributed computation</h4>

    <p class="text-gray-300">The iterated function <span class="math">F:\\mathbb{F}^{\\ell}\\rightarrow\\mathbb{F}^{\\ell}</span> corresponds to a special case of a bounded RAM program that initially copies <span class="math">\\ell</span> inputs to its work tape, and iterates for <span class="math">t</span> steps on the work tape, never reading any more inputs. A more general bounded RAM program that reads sequentially from its input tape may be represented as a path distributed computation where each</p>

    <p class="text-gray-300">ode along the path has <span class="math">\\ell_1</span> local inputs (coming from the input tape), <span class="math">\\ell_2</span> inputs that were outputs of the prior node, and <span class="math">\\ell_2</span> outputs. Each node computes the same function <span class="math">F: \\mathbb{F}^{\\ell_1 + \\ell_2} \\to \\mathbb{F}^{\\ell_2}</span>.</p>

    <h2 id="sec-64" class="text-2xl font-bold">Preprocessing arithmetic circuits</h2>

    <p class="text-gray-300">Theoretically, a proof system with these characteristics for bounded RAM programs making sequential witness reads is also sufficient to construct a preprocessing SNARK for arithmetic circuits. The preprocessing step produces a Merkle tree commitment to the wiring description of the circuit. A satisfying assignment to the circuit wires can be verified by a bounded RAM program that is provided an additional witness containing authenticated descriptions of each gate, which it verifies against the Merkle tree commitment.</p>

    <h2 id="sec-65" class="text-2xl font-bold">Preprocessing SNARKs in the URS Model</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A preprocessing SNARK in the URS model consists of three algorithms <span class="math">(S, P, V)</span>. The URS is first sampled uniformly <span class="math">urs \\stackrel{\\lambda}{\\leftarrow} \\{0, 1\\}^{\\mathrm{poly}(\\lambda)}</span>. This <span class="math">urs</span> is an implicit input to <span class="math">S</span>, <span class="math">P</span>, and <span class="math">V</span>, but we will drop it to avoid notational clutter. The setup algorithm <span class="math">S</span> takes as input the description of any circuit <span class="math">C</span> and outputs a verification key <span class="math">vk_{C}</span>, a proving key <span class="math">pk_{C}</span>. The prover algorithm <span class="math">P</span> receives <span class="math">pk_{C}</span>, <span class="math">\\mathbf{x}</span>, and <span class="math">\\mathbf{w}</span> as input such that <span class="math">C(\\mathbf{x}, \\mathbf{w}) = 1</span> and outputs a proof <span class="math">\\pi</span>. The verification algorithm <span class="math">V</span> receives <span class="math">vk_{C}</span>, <span class="math">\\mathbf{x}</span>, and <span class="math">\\pi</span> as inputs and returns a binary output. There are two security properties, completeness and knowledge-soundness. The system is complete if with overwhelming probability in <span class="math">\\lambda</span>, over the randomness of the <span class="math">urs</span> and keys returned by <span class="math">S</span>, <span class="math">P</span> will always succeed in creating a valid proof that <span class="math">V</span> will accept when run on valid inputs. The system is knowledge-sound if for any circuit <span class="math">C</span>, the non-interactive proof with the setup procedure that calls <span class="math">S</span> on <span class="math">C</span> is a proof of knowledge (Definition 14) for the relation of pairs <span class="math">(\\mathbf{x}, \\mathbf{w})</span> accepted by <span class="math">C</span>. Technically, a SNARK is only required to be an argument of knowledge, which means that soundness holds only against efficient adversaries. We refer the reader to [COS20, BCI+13] for formal definitions of preprocessing SNARK completeness and knowledge-soundness properties. Preprocessing SNARKs also have complexity requirements. The algorithms <span class="math">S, P</span>, and <span class="math">V</span> are polynomial time. Let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the length of the description of the circuit </span>C<span class="math"> that is an input to </span>S<span class="math">, which returns </span>(pk_{C}, vk_{C})<span class="math">. The size of proofs returned by the prover algorithm </span>P<span class="math"> running with </span>pk_{C}<span class="math"> must be </span>o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. Some authors also require that the verifier algorithm </span>V<span class="math"> running with </span>vk_{C}<span class="math"> runs in time </span>o(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$. However, we will distinguish such systems as efficient preprocessing SNARKs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-66" class="text-2xl font-bold">Proof recursion with preprocessing SNARKs</h2>

    <p class="text-gray-300">Formally describing the proof system and a circuit that itself calls the code of the verifier requires care, especially since the setup procedure may need to preprocess the circuit. Proving the statements <span class="math">\\phi(i, z_0, z_i)</span> for a path distributed computation, which were described informally in the introduction to this section, can be realized via a proof system for the following recursive program defined with respect to an efficient preprocessing SNARK <span class="math">(S, P, V)</span> [COS20]:</p>

    <p class="text-gray-300">Program <span class="math">R(\\mathbf{x}, \\mathbf{w})</span>:</p>

    <p class="text-gray-300">Public Input: Tuple <span class="math">\\mathbf{x} = (vk, i, z_i, z_0)</span> where <span class="math">vk</span> is a verification key and <span class="math">i</span> is a counter.</p>

    <p class="text-gray-300">Private Input: Tuple <span class="math">\\mathbf{w} = (z_{i-1}, \\pi_{i-1}, \\mathrm{loc}_i)</span> where <span class="math">\\pi_{i-1}</span> is a SNARK proof.</p>

    <p class="text-gray-300">Code: Output 1 if <span class="math">i = 1</span> and <span class="math">z_1 = F(z_0, \\mathrm{loc}_1)</span>, or if <span class="math">i &amp;gt; 1</span> and <span class="math">z_i = F(z_{i-1}, \\mathrm{loc}_i)</span> and <span class="math">V(vk, \\mathbf{x}_{i-1}, \\pi_{i-1}) = 1</span>, where <span class="math">\\mathbf{x}_{i-1} = (vk, i-1, z_{i-1}, z_0)</span>. Otherwise output 0.</p>

    <p class="text-gray-300">The recursive proof system <span class="math">(S&#x27;, P&#x27;, V&#x27;)</span> for <span class="math">t</span> steps of the path distributed computation <span class="math">F</span> with local inputs <span class="math">(\\mathsf{loc}_1, \\dots, \\mathsf{loc}_t)</span> operates as follows. <span class="math">S&#x27;</span> runs <span class="math">S</span> to preprocess a circuit description of <span class="math">R(\\mathbf{x}, \\mathbf{w})</span> to generate <span class="math">(pk_R, vk_R)</span>. The prover <span class="math">P&#x27;</span> starts by computing <span class="math">\\pi_0 \\gets P(pk_R, (vk_R, 1, z_1, z_0), \\bot)</span>. Then, given a valid proof <span class="math">\\pi_{i-1}</span> for the input <span class="math">(vk_R, i-1, z_{i-1})</span>, and local input <span class="math">\\mathsf{loc}_i</span>, <span class="math">P</span> runs <span class="math">P(pk_R, (vk_R, i, z_i, z_0), (z_{i-1}, \\pi_{i-1}, \\mathsf{loc}_i))</span>, which outputs a proof <span class="math">\\pi_i</span>. It does this for <span class="math">i = 2, \\dots, t</span>. To verify the proof <span class="math">\\pi_t</span>, <span class="math">V&#x27;</span> runs <span class="math">V(vk_R, (vk_R, t, z_0, z_t), \\pi_t)</span>. In the special case with no local inputs, the proof <span class="math">\\pi_t</span> attests to <span class="math">F^{(t)}(z_0) = z_t</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There remains a subtle catch. The circuit description of <span class="math">R</span> requires a circuit description of the programs <span class="math">F</span> and <span class="math">V</span>. As the program <span class="math">V</span> accepts arbitrarily large inputs, it cannot be described as a single circuit. Rather, <span class="math">V</span> may be represented as a family of circuits <span class="math">\\{V_N : N \\in \\mathbb{N}\\}</span> where <span class="math">V_N</span> runs on verification keys for circuits of size as most <span class="math">N</span>. (The circuit size bound <span class="math">N</span> also implicitly places an upper bound on the sizes of the verification key, input <span class="math">\\mathbf{x}</span>, and proof <span class="math">\\pi</span>). Finally, in order to successfully implement the proof recursion method above, <span class="math">S&#x27;</span> must preprocess a circuit description of <span class="math">R</span> using some <span class="math">V_N</span> (for sufficiently large <span class="math">N \\in \\mathbb{N}</span>) such that the resulting circuit size is smaller than <span class="math">N</span>. Otherwise, <span class="math">V_N</span> would not accept <span class="math">vk_R</span> as input. The size of <span class="math">R</span> is approximately $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; N<span class="math"> only if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since the size of </span>V_N<span class="math"> is asymptotically </span>o(N)<span class="math">, there exists sufficiently large </span>N<span class="math"> such that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; N -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This is captured in the following theorem. Let <span class="math">V_{N,\\lambda,\\ell}</span> denote the verification circuit of the proof system <span class="math">(S,P,V)</span> for security parameter <span class="math">\\lambda</span>, which accepts verification keys for circuits of size at most <span class="math">N</span> and input instances of size at most <span class="math">\\ell</span>. Given <span class="math">F:\\mathbb{F}^{2\\ell}\\to \\mathbb{F}^{\\ell}</span>, define the binary relation <span class="math">\\mathsf{PDC}(F,t)</span> over instances <span class="math">\\mathbf{x} = (z_0,z_t)\\in \\mathbb{F}^{2\\ell}</span> paired with witnesses <span class="math">\\mathbf{w} = ((z_1,w_1),\\dots,(z_{t - 1},w_{t - 1}))\\in \\mathbb{F}^{2\\ell (t - 1)}</span> satisfying <span class="math">\\forall_{i &amp;gt; 0}F(z_{i - 1},w_i) = z_i</span>. Given a preprocessing SNARK <span class="math">(S,P,V)</span> in the URS model, let <span class="math">(S&#x27;,P&#x27;,V&#x27;)\\gets \\mathbb{T}(S,P,V)</span> denote the transformed proof system described above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 9 ([COS20]). If <span class="math">(S, P, V)</span> is a preprocessing SNARK for binary relations in the URS model then for any function <span class="math">F: \\mathbb{F}^{2\\ell} \\to \\mathbb{F}^{\\ell}</span> and constant <span class="math">t \\in \\mathbb{N}</span> the proof system <span class="math">(S&#x27;, P&#x27;, V&#x27;) = \\mathbb{T}(S, P, V)</span> is a preprocessing non-interactive argument of knowledge for the binary relation <span class="math">PDC(F, t)</span>. If $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{N,\\lambda,\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; N^{1 - \\epsilon} \\cdot \\text{poly}(\\lambda, \\ell)<span class="math"> for some </span>\\epsilon \\in (0,1)<span class="math">, then </span>S', P'<span class="math">, and </span>V'<span class="math"> run in time equal to </span>S<span class="math">, </span>P<span class="math">, and </span>V<span class="math"> respectively on circuits of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ O(\\text{poly}(\\lambda, \\ell)^{1/\\epsilon})<span class="math"> with inputs of size </span>O(\\lambda + \\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In particular, if the preprocessing SNARK has a polylogarithmic verifier, i.e., $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V_{N,\\lambda,\\ell}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; \\log^c N \\cdot \\text{poly}(\\lambda, \\ell)<span class="math">, then for any </span>\\delta &gt; 0<span class="math"> the running times of </span>S'<span class="math">, </span>P'<span class="math">, and </span>V'<span class="math"> are upper bounded by the running times of </span>S<span class="math">, </span>P<span class="math">, and </span>V<span class="math"> respectively on circuits of size </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ o(\\text{poly}(\\lambda, \\ell)^{1 + \\delta})<span class="math"> with inputs of size </span>O(\\lambda + \\ell)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We are now ready to describe how the Halo construction may be generalized to combine any Polynomial IOP (PIOP) with any aggregatable PCS.</p>

    <p class="text-gray-300">There are two essential building blocks to Halo proof recursion. The first building block is a PIOP-based preprocessing SNARK <span class="math">(\\mathcal{S},\\mathcal{P},\\mathcal{V})</span>. This SNARK must be succinct, but is not strictly required to have efficient verification as we will see. A PIOP-based preprocessing SNARK compiles</p>

    <p class="text-gray-300">8Technically, for the proof system described here to be provably secure, the number of steps <span class="math">t</span> must be a constant independent of the security parameter. This restriction comes from the security analysis in which the extractor requires a number of transcripts from the prover that grows exponentially in the recursion depth. This issue can be sidestepped by constructing a binary (or constant-arity) tree of recursive proofs where the leaves correspond to steps of the path distributed computation [BCCT13]. This way the recursion depth grows as <span class="math">O(\\log t)</span>, and is secure against sub-exponential adversaries (the extractor runs in superlinear time <span class="math">\\mathsf{poly}(\\lambda, N)^{\\log t}</span>). No known attacks exist on arbitrary depth recursion.</p>

    <p class="text-gray-300">9The theorem quoted here is a special case of the more general theorem by Chiesa et. al. [COS20] for proof carrying data (PCD) systems.</p>

    <p class="text-gray-300">46</p>

    <p class="text-gray-300">a preprocessing PIOP with a non-interactive polynomial commitment scheme <span class="math">\\mathcal{PCS}</span>. Let <span class="math">\\mathbb{G}</span> denote the commitment group of <span class="math">\\mathcal{PCS}</span>. The SNARK proofs of <span class="math">(\\mathcal{S},\\mathcal{P},\\mathcal{V})</span> have the form <span class="math">(\\boldsymbol{\\rho},\\pi=(\\mathbf{C},\\mathbf{u},\\mathbf{v},\\alpha))</span> where <span class="math">\\mathbf{C}\\in\\mathbb{G}^{k}</span> is a vector of polynomial commitments for a PCS scheme with commitment group <span class="math">\\mathbb{G}</span> to polynomials <span class="math">f_{1},...,f_{k}\\in\\mathbb{F}^{(&lt;d)}[X]</span>, <span class="math">\\mathbf{u}\\in\\mathbb{F}^{k}</span>, <span class="math">\\mathbf{v}\\in\\mathbb{F}^{k}</span>, <span class="math">f_{i}(u_{i})=v_{i}</span> for all <span class="math">i\\in[k]</span>, <span class="math">\\rho=(\\rho_{1},...,\\rho_{k})</span> is a vector of non-interactive evaluation proofs for <span class="math">\\mathcal{PCS}</span> where <span class="math">\\rho_{i}</span> is an evaluation proof opening <span class="math">C_{i}</span> at <span class="math">u_{i}\\in\\mathbb{F}</span> to <span class="math">v_{i}\\in\\mathbb{F}</span>, and finally <span class="math">\\alpha</span> is additional auxiliary content. Moreover, the verifier <span class="math">\\mathcal{V}=(\\mathcal{V}_{1},\\mathcal{V}_{2})</span> running on a public input <span class="math">\\mathbf{x}</span>, an input polynomial commitment <span class="math">vk</span> called the verification key, and a proof <span class="math">\\pi</span> consists of two parts:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}_{1}(vk,\\mathbf{x},\\pi)</span> runs in time sublinear in the size of the circuit corresponding to the preprocessed verification key <span class="math">vk</span>. It may also run in time linear in the size of the inputs <span class="math">(vk,\\mathbf{x},\\pi)</span>.</li>

      <li><span class="math">\\mathcal{V}_{2}(\\boldsymbol{\\rho},\\mathbf{C},\\mathbf{u},\\mathbf{v})</span> verifies each <span class="math">\\mathsf{NI\\text{-}Eval}</span> proof <span class="math">\\rho_{i}</span> with <span class="math">(C_{i},u_{i},v_{i})</span> for each <span class="math">i\\in[k]</span>.</li>

    </ol>

    <p class="text-gray-300">The second building block is a non-interactive efficient aggregation scheme for <span class="math">\\mathcal{PCS}</span> (Definitions 10-11). We will discuss the implications of using a private vs public aggregation scheme later. Given that we require an aggregation scheme, we may actually assume that the proofs of <span class="math">(\\mathcal{S},\\mathcal{P},\\mathcal{V})</span> consist of only one <span class="math">\\mathsf{NI\\text{-}Eval}</span> at a single point (i.e., <span class="math">k=1</span>) because otherwise the aggregation scheme can first be applied to achieve this. Letting <span class="math">\\mathsf{open}=(\\mathsf{open}_{1},...,\\mathsf{open}_{k})</span> denote <span class="math">\\mathcal{P}</span>’s opening strings for commitments <span class="math">\\mathbf{C}</span>, the new prover <span class="math">\\mathcal{P}^{\\prime}</span> would do the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Run <span class="math">\\mathcal{P}</span> to get the original proof <span class="math">(\\boldsymbol{\\rho},\\pi=(\\mathbf{C},\\mathbf{u},\\mathbf{v},\\alpha))</span>.</li>

      <li>Run <span class="math">((\\mathsf{open}^{\\prime},f^{\\prime}),(C^{\\prime},u^{\\prime},v^{\\prime}),\\mathsf{tr})\\leftarrow\\mathsf{NI\\text{-}Aggregate}(\\mathbf{f},\\mathsf{open},\\mathbf{C},\\mathbf{u},\\mathbf{v})</span></li>

      <li>Compute the aggregate opening <span class="math">\\rho^{\\prime}\\leftarrow\\mathsf{NI\\text{-}Eval}((\\mathsf{open}^{\\prime},f^{\\prime}),(C^{\\prime},u^{\\prime},v^{\\prime}))</span>.</li>

      <li>Modify the SNARK proof by replacing the original commitments/openings with the aggregate commitment <span class="math">C^{\\prime}</span> and opening <span class="math">\\rho^{\\prime}</span>, and appending the original commitments, openings, along with the aggregation transcript to the auxiliary string. The new proof is <span class="math">(\\rho^{\\prime},\\pi^{\\prime})</span> where <span class="math">\\pi^{\\prime}=(C^{\\prime},u^{\\prime},v^{\\prime},\\alpha^{\\prime})</span> where <span class="math">\\alpha^{\\prime}=(\\alpha,\\mathbf{C},\\mathbf{u},\\mathbf{v},\\mathsf{tr})</span>.</li>

    </ol>

    <p class="text-gray-300">The new verification algorithm <span class="math">\\mathcal{V}_{1}^{\\prime}</span> would still run <span class="math">\\mathcal{V}_{1}(vk,\\mathbf{x},(\\mathbf{C},\\mathbf{u},\\mathbf{v},\\alpha))</span> and additionally run the aggregation protocol verification of <span class="math">(C^{\\prime},u^{\\prime},v^{\\prime},\\mathsf{tr})</span>. <span class="math">\\mathcal{V}_{2}^{\\prime}</span> receives <span class="math">(\\rho^{\\prime},C^{\\prime},u^{\\prime},v^{\\prime})</span> and verifies the single <span class="math">\\mathsf{NI\\text{-}Eval}</span> proof <span class="math">\\rho^{\\prime}</span>.</p>

    <h4 id="sec-67" class="text-lg font-semibold mt-6">Protocol overview</h4>

    <p class="text-gray-300">Given these two building blocks, the main idea in Halo is to only include <span class="math">\\mathcal{V}_{1}</span>, the sublinear component of <span class="math">\\mathcal{V}</span>, inside the recursion circuit, and to pass the “unverified” polynomial commitment evaluation tuple <span class="math">(C,\\mathsf{pt})\\in\\mathbb{G}\\times\\mathbb{F}^{2}</span> as an additional public input to the external verifier. Let us revisit the task of proving the iterated function <span class="math">F^{(t)}(z_{0})=z_{t}</span> where <span class="math">F:\\mathbb{F}^{\\ell}\\to\\mathbb{F}^{\\ell}</span>. Consider first a strawman construction: at each <span class="math">i</span>th step in the recursion chain the prover generates a new proof <span class="math">(\\rho_{i},\\pi_{i})=(\\rho_{i},(C_{i},\\mathsf{pt}_{i},\\alpha_{i}))</span> attesting to the next incremental step of the computation and knowledge of the last recursive proof <span class="math">(\\rho_{i-1},\\pi_{i-1})=(\\rho_{i-1},(C_{i-1},\\mathsf{pt}_{i-1},\\alpha_{i-1}))</span> such that <span class="math">\\mathcal{V}_{1}</span> accepts the proof component <span class="math">(C_{i-1},\\mathsf{pt}_{i-1},\\alpha_{i-1})</span>. This proof alone is not a sound proof of the computation’s integrity. However, if the verifier were additionally provided <span class="math">(\\rho_{i-1},C_{i-1},\\mathsf{pt}_{i-1})</span>, then it could run <span class="math">\\mathcal{V}_{1}</span> verification of <span class="math">\\pi_{i}</span> along with the <span class="math">\\mathsf{Eval}</span> verifications <span class="math">\\mathcal{V}_{2}(\\rho_{i-1},C_{i-1},\\mathsf{pt}_{i-1})</span> and <span class="math">\\mathcal{V}_{2}(\\rho_{i},C_{i},\\mathsf{pt}_{i})</span>. This would complete verification of the inner proof that is part of the witness and also the incremental</p>

    <p class="text-gray-300">step. Moreover, the two required Eval verifications could be combined using the aggregation scheme. Let <span class="math">\\mathsf{pt}_{i}=(u_{i},v_{i})</span> for each <span class="math">i\\in\\mathbb{N}</span>, the prover runs:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{NI-Aggregate}((f_{i-1},f_{i}),(\\mathsf{open}_{i-1},\\mathsf{open}_{i}),(C_{i-1},C_{i}),(u_{i-1},u_{i}),(v_{i-1},v_{i}))</span></p>

    <p class="text-gray-300">The output to the prover is <span class="math">(\\mathsf{open}^{<em>},f^{</em>})</span> and the public output is <span class="math">(C^{<em>},\\mathsf{pt}^{</em>},\\mathsf{tr})</span>. If the prover includes <span class="math">(C^{<em>},\\mathsf{pt}^{</em>},\\mathsf{tr})</span> in its incremental proof and additionally provides an <span class="math">\\mathsf{NI}</span>-Eval proof <span class="math">\\rho^{<em>}</span> for <span class="math">(C^{</em>},\\mathsf{pt}^{<em>})</span>, then the verifier could check that <span class="math">V_{1}</span> accepts <span class="math">(C_{i},\\mathsf{pt}_{i},\\alpha_{i})</span>, check that <span class="math">V_{2}</span> accepts <span class="math">(\\rho^{</em>},C^{<em>},\\mathsf{pt}^{</em>})</span>, and run the aggregation verification given <span class="math">\\mathsf{tr}</span>. This leads to the following strategy. The tuple <span class="math">(C^{<em>},\\mathsf{pt}^{</em>})</span>, which is necessary for completing the verification of the <span class="math">i</span>th computation transition, will be a public input to the proof for the <span class="math">(i+1)</span>st transition. The next proof <span class="math">\\pi_{i+1}</span> will also prove (i.e., include as a part of the circuit) the verifier <span class="math">\\mathcal{V}_{\\mathsf{agg}}</span> of the aggregation step that produces the tuple <span class="math">(C^{<em>},\\mathsf{pt}^{</em>})</span>. The values <span class="math">\\mathsf{tr},C_{i},C_{i-1},\\mathsf{pt}_{i}</span>, and <span class="math">\\mathsf{pt}_{i-1}</span> are witnesses. The circuit for <span class="math">\\pi_{i+1}</span> also includes the <span class="math">\\mathcal{V}_{1}</span> verification of <span class="math">(C_{i},\\mathsf{pt}_{i},\\alpha_{i})</span>. This requires the prover to save <span class="math">(C_{i-1},\\mathsf{pt}_{i-1})</span> as part of the witness in addition to <span class="math">\\pi_{i}</span>. Likewise, both <span class="math">(C^{<em>},\\mathsf{pt}^{</em>})</span> and <span class="math">\\pi_{i+1}</span> will become part of the witness for the next proof, and so on and so forth.</p>

    <h5 id="sec-68" class="text-base font-semibold mt-4">Efficiency</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If <span class="math">\\mathcal{V}_{1}</span> and <span class="math">\\mathcal{V}_{\\mathsf{agg}}</span> are together sublinear in the size of circuits preprocessed by <span class="math">S</span>, then by Theorem 9 the recursion circuit is well defined. This is guaranteed by the efficiency requirements on <span class="math">\\mathcal{V}_{1}</span> and the aggregation scheme so long as the PIOP-based SNARK commits to polynomials of maximum degree linear in the size of the preprocessed circuit. (This is the case in all practical PIOP constructions as otherwise the prover time is impractical). Moreover, if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{\\mathsf{agg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is poly-logarithmic in the size of preprocessed circuit then the recursion circuit has size approximately </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+O(\\mathsf{poly}(\\lambda,\\ell))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The prover only needs to derive the <span class="math">\\mathsf{NI}</span>-Eval proof for the last polynomial commitment output at the end of the recursive proof chain. This commitment is a single element in <span class="math">\\mathbb{G}</span>. The <span class="math">\\mathsf{NI}</span>-Eval proofs for other intermediate commitments are never actually used. The verifier only needs to check this one final <span class="math">\\mathsf{NI}</span>-Eval proof for the entire proof recursion, which is for a polynomial of degree proportional to $N=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{\\mathsf{agg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The verifier also runs </span>\\mathcal{V}_{1}<span class="math"> once on the recursion circuit. Let </span>S_{\\mathsf{agg}}(\\lambda,d,k)<span class="math"> denote the worst case size complexity of the aggregation protocol’s output commitment given </span>k<span class="math"> input commitments to polynomials of degree </span>d<span class="math"> with </span>\\mathcal{PCS}<span class="math"> security parameter </span>\\lambda<span class="math">. This is at most the maximum representation size of a single group element in </span>\\mathbb{G}<span class="math">. In the special case that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{V}_{\\mathsf{agg}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is poly-logarithmic, the final proof size is </span>\\mathsf{polylog}(\\lambda,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\ell)+S_{\\mathsf{agg}}(\\lambda,d,2)<span class="math">. For any PCS that has a size-optimal linear combination scheme, there is an aggregation scheme with </span>S_{\\mathsf{agg}}(\\lambda,d,k)\\leq S_{\\mathsf{Eval}}(\\lambda,d)<span class="math">, where </span>S_{\\mathsf{Eval}}(\\lambda,d)<span class="math"> denotes the maximum size of commitments to polynomials of degree </span>d$ (Theorem 3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-69" class="text-base font-semibold mt-4">When does Halo help?</h5>

    <p class="text-gray-300">The generalized Halo technique we have described improves over the standard method of proof recursion, reducing the circuit complexity of the recursive statement, when <span class="math">\\mathcal{V}_{\\mathsf{agg}}</span> is smaller than <span class="math">\\mathcal{V}_{2}</span> (i.e., the <span class="math">\\mathsf{NI}</span>-Eval verifier). As a special case, in the case that <span class="math">\\mathcal{V}_{2}</span> is inefficient (i.e, is not sublinear in the statement size) any efficient aggregation scheme will have this property. In such cases the classical proof recursion method does not work.</p>

    <h5 id="sec-70" class="text-base font-semibold mt-4">Halo without succinct Eval</h5>

    <p class="text-gray-300">Since the evaluation proofs are not included inside the recursion and only produced in the last step, the protocol still works if <span class="math">\\mathcal{PCS}</span> does not have a succinct evaluation protocol. The prover only needs to open the coefficients of one degree <span class="math">N</span> polynomial</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for the entire proof chain. The final proof size will be both asymptotically and concretely larger than with a succinct PCS, but still proportional to  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">F</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ O(\\mathsf{poly}(\\lambda ,\\ell))$  rather than the depth of the recursion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Detailed construction In more detail, can rewrite the recursive program  <span class="math">R(\\mathbf{x},\\mathbf{w})</span>  for the program  <span class="math">F:\\mathbb{F}^{2\\ell}\\to \\mathbb{F}^{\\ell}</span>  as follows:</p>

    <p class="text-gray-300">Program  <span class="math">R^{\\prime}(\\mathbf{x},\\mathbf{w})</span></p>

    <p class="text-gray-300">Public Input: Tuple  <span class="math">\\mathbf{x} = (vk, i, \\mathrm{tr}_i, C_i^<em>, \\mathrm{pt}_i^</em>, z_i, z_0)</span>  where  <span class="math">vk</span>  is a verification key (a polynomial commitment),  <span class="math">i \\in \\mathbb{N}</span>  is a counter,  <span class="math">C_i^<em></span>  is a polynomial commitment,  <span class="math">\\mathrm{pt}_i^</em> = (u_i, v_i) \\in \\mathbb{F}^2</span> , and  <span class="math">\\mathrm{tr}_i</span>  is a NI-Aggregate transcript. Missing components of  <span class="math">\\mathbf{x}</span>  are allowed and are indicated with  <span class="math">\\perp</span> .</p>

    <p class="text-gray-300">Private Input: Tuple  <span class="math">\\mathbf{w} = (C_{i-1}^<em>, \\mathsf{pt}_{i-1}^</em>, z_{i-1}, \\pi_{i-1}, \\mathsf{loc}_i)</span>  where  <span class="math">\\pi_{i-1} = (C_{i-1}, \\mathsf{pt}_{i-1}, \\alpha_{i-1})</span>  is a SNARK proof,  <span class="math">C_{i-1}^<em></span>  is a polynomial commitment, and  <span class="math">\\mathsf{pt}_{i-1}^</em> \\in \\mathbb{F}^2</span> . Missing components of  <span class="math">\\mathbf{w}</span>  are indicated with  <span class="math">\\perp</span> .</p>

    <p class="text-gray-300">Code: Output 1 if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">i = 1</span>  and  <span class="math">z_{1} = F(z_{0},\\mathsf{loc}_{1})</span></li>

      <li><span class="math">i = 2</span>  and  <span class="math">z_{2} = F(z_{1},\\mathsf{loc}_{2})</span>  and  <span class="math">(C_2^<em>,\\mathsf{pt}_2^</em>) = (C_1,\\mathsf{pt}_1)</span> , and  <span class="math">V_{1}(vk,(vk,1,\\bot ,\\bot ,\\bot ,z_{2},z_{0}),(C_{1},\\mathsf{pt}_{1},\\alpha_{1})) = 1</span> .</li>

      <li><span class="math">i = 3</span>  and  <span class="math">z_{3} = F(z_{2},\\mathsf{loc}_{3})</span>  and  <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathrm{tr}_3,C_3^<em>,\\mathrm{pt}_3^</em>,C_2,\\mathrm{pt}_2,C_1,\\mathrm{pt}_1) = 1</span> , and  <span class="math">V_{1}(vk,(vk,2,\\bot ,C_{1},\\mathrm{pt}_{1},z_{2},z_{0}),(C_{2},\\mathrm{pt}_{2},\\alpha_{2})) = 1</span> .</li>

      <li><span class="math">i &amp;gt; 3</span>  and  <span class="math">z_{i} = F(z_{i - 1},\\mathsf{loc}_{i})</span>  and  <span class="math">V_{1}(vk,\\mathbf{x}_{i - 1},\\pi_{i - 1}) = 1</span> , where  <span class="math">\\mathbf{x}_{i - 1} = (vk,i - 1,\\mathsf{tr}_{i - 1},C_{i - 1}^{<em>},\\mathsf{pt}_{i - 1}^{</em>},z_{i - 1},z_{0})</span> , and  <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathrm{tr}_i,C_i^<em>,\\mathrm{pt}_i^</em>,C_{i - 1}^<em>,\\mathrm{pt}_{i - 1}^</em>,C_{i - 1},\\mathrm{pt}_{i - 1}) = 1</span> .</li>

    </ul>

    <p class="text-gray-300">Otherwise output 0.</p>

    <p class="text-gray-300">The proof system  <span class="math">(\\mathcal{S}&#x27;,\\mathcal{P}&#x27;,\\mathcal{V}&#x27;)</span>  operates as follows.  <span class="math">\\mathcal{S}&#x27;</span>  runs  <span class="math">\\mathcal{S}</span>  to preprocess a circuit description of  <span class="math">R(\\mathbf{x},\\mathbf{w})</span>  and outputs  <span class="math">(pk_R,vk_R)</span> . The prover proceeds according to the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P&#x27;</span>  starts by computing  <span class="math">z_1 \\gets F(z_0, \\mathsf{loc}_1)</span>  and  <span class="math">(C_1, \\mathsf{pt}_1, \\alpha_1) \\gets P(pk_R, \\mathbf{x}_1, \\mathbf{w}_1)</span>  where  <span class="math">\\mathbf{x}_1 = (vk_R, 1, \\bot, \\bot, \\bot, z_1, z_0)</span>  and  <span class="math">\\mathbf{w}_1 = (\\bot, \\bot, \\bot, \\bot, \\mathsf{loc}_1)</span> . It sets  <span class="math">\\pi_1 := (C_1, \\mathsf{pt}_1, \\alpha_1)</span> .</li>

    </ol>

    <p class="text-gray-300">Intermediate verification: Given additionally a NI-Eval proof  <span class="math">\\rho_{1}</span>  for  <span class="math">(C_1,\\mathsf{pt}_1)</span> , the proof  <span class="math">\\pi_0</span>  for the public inputs  <span class="math">(z_{1},z_{0})</span>  could be verified using  <span class="math">V_{1}(vk_{R},\\mathbf{x}_{1},\\pi_{1})</span>  and  <span class="math">V_{2}(\\rho_{1},C_{1},\\mathsf{pt}_{1})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">P&#x27;</span>  computes  <span class="math">z_2 \\gets F(z_1, \\mathsf{loc}_2)</span>  and  <span class="math">(C_2, \\mathsf{pt}_2, \\alpha_2) \\gets P(pk_R, \\mathbf{x}_2, \\mathbf{w}_2)</span>  where  <span class="math">\\mathbf{x}_2 = (vk_R, 2, \\bot, C_1, \\mathsf{pt}_1, z_2, z_0)</span>  and  <span class="math">\\mathbf{w}_2 = (\\bot, \\bot, z_1, \\pi_1, \\mathsf{loc}_2)</span> . It sets  <span class="math">\\pi_2 = (C_2, \\mathsf{pt}_2, \\alpha_2)</span> .</li>

    </ol>

    <p class="text-gray-300">Intermediate verification: Given additionally an aggregate NI-Eval tuple  <span class="math">(C_3^<em>,\\mathsf{pt}_3^</em>,\\rho_3^<em>)</span>  and aggregation transcript  <span class="math">\\mathsf{tr}_3</span> , the proof  <span class="math">\\pi_{2}</span>  for public inputs  <span class="math">(C_1,r_1,z_2,z_0)</span>  may be verified by running  <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathsf{tr},C_3^</em>,\\mathsf{pt}_3^<em>,C_2,\\mathsf{pt}_2,C_1,\\mathsf{pt}_1)</span> , running  <span class="math">V_{1}(vk_{R},\\mathbf{x}_{2},\\pi_{2})</span> , and running  <span class="math">V_{2}(\\rho_{3}^{</em>},C_{3}^{<em>},\\mathsf{pt}_{3}^{</em>})</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}&#x27;</span> computes the aggregation:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\text{open}_3^*, f_3^*, C_3^*, \\mathfrak{pt}_3^*, \\mathfrak{tr}_3) \\leftarrow \\text{NI-Aggregate}(f_1, f_2, \\text{open}_1, \\text{open}_2, C_1, C_2, u_1, u_2, v_1, v_2)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathfrak{pt}_i = (u_i, v_i)</span> and <span class="math">\\text{open}_i</span> is an opening of <span class="math">C_i</span> to <span class="math">f_i</span> such that <span class="math">f_i(u_i) = v_i</span> for <span class="math">i \\in \\{1, 2\\}</span>. It also computes <span class="math">z_3 \\gets F(z_2, \\text{loc}_3)</span> and <span class="math">(C_3, \\mathfrak{pt}_3, \\alpha_3) \\gets P(pk_R, \\mathbf{x}_3, \\mathbf{w}_3)</span> where <span class="math">\\mathbf{x}_3 = (vk_R, 3, C_3^<em>, r_3^</em>, z_3, z_0)</span> and <span class="math">\\mathbf{w}_3 = (C_1, \\mathfrak{pt}_1, z_2, \\pi_2, \\text{loc}_3)</span>. It sets <span class="math">\\pi_3 := (C_3, \\mathfrak{pt}_3, \\alpha_3)</span>.</p>

    <p class="text-gray-300"><strong>Intermediate verification:</strong> Given <span class="math">(C_4^<em>, \\mathfrak{pt}_4^</em>, \\rho_4^<em>, \\mathfrak{tr}_4)</span>, the verifier checks the proof <span class="math">\\pi_3</span> for public inputs <span class="math">(C_3^</em>, \\mathfrak{pt}_3^<em>, z_3, z_0)</span> by running <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathfrak{tr}_4, C_4^</em>, \\mathfrak{pt}_4^<em>, C_3^</em>, \\mathfrak{pt}_3^<em>, C_3, \\mathfrak{pt}_3)</span>, running <span class="math">V_1(vk_R, \\mathbf{x}_3, \\pi_3)</span>, and running <span class="math">V_2(\\rho_4^</em>, C_4^<em>, \\mathfrak{pt}_4^</em>)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i \\geq 4</span>: given <span class="math">\\pi_{i-1} = (C_{i-1}, r_{i-1}, \\alpha_{i-1})</span> for the public input <span class="math">(vk_R, i-1, C_{i-1}^<em>, \\mathfrak{pt}_{i-1}^</em>, z_{i-1}, z_0)</span>, <span class="math">\\mathcal{P}&#x27;</span> computes:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\text{open}_i^*, f_i^*, C_i^*, \\mathfrak{pt}_i^*, \\mathfrak{tr}_i) \\leftarrow \\text{NI-Aggregate}(f_{i-1}^*, f_{i-1}, \\text{open}_{i-1}^*, \\text{open}_{i-1}, C_{i-1}^*, C_i, u_{i-1}^*, u_i, v_{i-1}^*, v_i)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathfrak{pt}_i = (u_i, v_i)</span> and <span class="math">\\text{open}_i</span> is an opening of <span class="math">C_i</span> to <span class="math">f_i</span> such that <span class="math">f_i(u_i) = v_i</span>. It also computes <span class="math">z_i = F(z_{i-1}, \\text{loc}_i)</span> and <span class="math">\\pi_i \\gets P(pk_R, \\mathbf{x}_i, \\mathbf{w}_i)</span> where <span class="math">\\mathbf{x}_i = (vk_R, i, C_i^<em>, \\mathfrak{pt}_i^</em>, z_i, z_0)</span> and <span class="math">\\mathbf{w}_i = (C_{i-1}^<em>, \\mathfrak{pt}_{i-1}^</em>, z_{i-1}, \\pi_{i-1}, \\text{loc}_i)</span>.</p>

    <p class="text-gray-300"><strong>Intermediate verification:</strong> Given <span class="math">(C_{i+1}^<em>, \\mathfrak{pt}_{i+1}^</em>, \\rho_{i+1}^<em>, \\mathfrak{tr}_{i+1})</span>, the verifier checks the proof <span class="math">\\pi_i</span> with public inputs <span class="math">(C_i^</em>, \\mathfrak{pt}_i^<em>, z_i, z_0)</span> by running <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathfrak{tr}_{i+1}, C_{i+1}^</em>, \\mathfrak{pt}_{i+1}^<em>, C_i^</em>, \\mathfrak{pt}_i^<em>, C_i, \\mathfrak{pt}_i)</span>, running <span class="math">\\mathcal{V}_1(vk_R, x_i, \\pi_i)</span> and <span class="math">\\mathcal{V}_2(\\rho_{i+1}^</em>, C_{i+1}^<em>, \\mathfrak{pt}_{i+1}^</em>)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Final proof:</strong> <span class="math">P</span> outputs both <span class="math">\\pi_t = (C_t, \\mathfrak{pt}_t, \\alpha_t)</span> and <span class="math">(C_t^<em>, \\mathfrak{pt}_t^</em>)</span> along with a batch evaluation proof for both <span class="math">C_t</span> and <span class="math">C_t^<em></span>, i.e., a NI-Eval proof <span class="math">\\rho_{t+1}^</em></span> for the aggregate tuple:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">(\\text{open}_{t+1}^*, f_{t+1}^*, C_{t+1}^*, \\mathfrak{pt}_{t+1}^*, \\mathfrak{tr}_{t+1}) \\leftarrow \\text{NI-Aggregate}(f_t^*, f_t, \\text{open}_t^*, \\text{open}_t, C_t^*, C_i, u_t^*, u_t, v_t^*, v_t)</span></div>

    <p class="text-gray-300"><strong>Final verification:</strong> Run <span class="math">\\mathcal{V}_1(vk_R, \\mathbf{x}_t, \\pi_t)</span>, run <span class="math">\\mathcal{V}_{\\mathrm{agg}}(\\mathfrak{tr}_{t+1}, C_{t+1}^<em>, \\mathfrak{pt}_{t+1}^</em>, C_t^<em>, \\mathfrak{pt}_t^</em>, C_t, \\mathfrak{pt}_t)</span>, and lastly run <span class="math">\\mathcal{V}_2(\\rho_{t+1}^<em>, C_{t+1}^</em>, \\mathfrak{pt}_{t+1}^*)</span>.</p>

    <p class="text-gray-300"><strong>Stateless Halo for Proof Carrying Data</strong> In the original Halo protocol the prover was <em>stateless</em>. In other words, the prover could output the proof <span class="math">\\pi_i</span> for <span class="math">i &amp;lt; t</span>, and another prover could produce <span class="math">\\pi_{i+1}</span> without knowing anything about the first prover's internal state. This property is not critical when applying this protocol to obtain SNARKs for bounded RAM programs. However, this property is critical for PCD and its many applications.</p>

    <p class="text-gray-300">The simplest solution is to include the prover's private state as part of the proof. This consists of two polynomial commitment openings. Specifically, the prover for the <span class="math">i</span>th incremental statement receives the proof <span class="math">\\pi_{i-1} = (C_{i-1}, \\mathfrak{pt}_{i-1}, \\alpha_{i-1})</span>, the values <span class="math">(C_{i-1}^<em>, \\mathfrak{pt}_{i-1}^</em>, z_{i-1}, \\text{loc}_i)</span>, and additionally the previously private polynomials and opening strings <span class="math">(f_{i-1}^<em>, f_{i-1}, \\text{open}_{i-1}^</em>, \\text{open}_{i-1})</span> for the commitments <span class="math">C_{i-1}^*</span> and <span class="math">C_{i-1}</span> respectively.</p>

    <p class="text-gray-300">The proof sizes are now linear in the predicate <span class="math">F</span>, but still independent of the computation depth. This achieves the same proof size as implementing Halo without a succinct PCS (i.e., a PCS with succinct commitments but linear size evaluation proofs). In fact, there is little benefit to using a PCS with a sublinear evaluation proof when employing this trivial method for stateless proving. An PCS with an efficient aggregation protocol would suffice (e.g., using any homomorphic hash function).</p>

    <p class="text-gray-300">However, there is a more efficient method of achieving stateless proving, which uses a public aggregation scheme instead of a private aggregation scheme.</p>

    <h5 id="sec-71" class="text-base font-semibold mt-4">Public aggregation method</h5>

    <p class="text-gray-300">Recall (from Theorem 6) that if the PCS is additively succinct then its private aggregation scheme can be efficiently compiled into a public aggregation scheme with only a small additive overhead, logarithmic in the maximum degree of the committed polynomials. This includes all the additive schemes in Section 3.2, but excludes FRI.</p>

    <p class="text-gray-300">Replacing the private non-interactive aggregation scheme with a public non-interactive aggregation scheme in the protocol described above is straightforward. The main difference is that the public aggregation algorithm requires as input NI-Eval proofs instead of commitment openings. Instead of running the private aggregation algorithm, which requires <span class="math">(f_{i-1}^{<em>},f_{i-1},\\mathsf{open}_{i-1}^{</em>},\\mathsf{open}_{i-1})</span>, at each step <span class="math">i\\in\\mathbb{N}</span> the <span class="math">i</span>th prover runs the public aggregation algorithm:</p>

    <p class="text-gray-300"><span class="math">(\\mathsf{open}_{i}^{<em>},f_{i}^{</em>},C_{i}^{<em>},\\mathsf{pt}_{i}^{</em>},\\mathsf{tr}_{i})\\leftarrow\\mathsf{NI-Aggregate}(C_{i-1}^{<em>},C_{i},u_{i-1}^{</em>},u_{i},v_{i-1}^{<em>},v_{i},\\rho_{i-1}^{</em>},\\rho_{i})</span></p>

    <p class="text-gray-300">where <span class="math">\\rho_{i-1}^{<em>}</span> is an NI-Eval proof for the tuple <span class="math">(C_{i-1}^{</em>},u_{i-1}^{<em>},v_{i-1}^{</em>})</span> and <span class="math">\\rho_{i-1}</span> is an NI-Eval proof for the tuple <span class="math">(C_{i-1},u_{i-1},v_{i-1})</span>. The value <span class="math">\\rho_{i-1}</span> is already part of <span class="math">\\pi_{i-1}</span> and <span class="math">\\rho_{i-1}^{<em>}</span> is included in the output of the <span class="math">i-1</span>st prover. The <span class="math">i</span>th prover uses <span class="math">(\\mathsf{open}_{i}^{</em>},f_{i}^{<em>})</span> to produce the evaluation proof <span class="math">\\rho_{i}^{</em>}</span> for <span class="math">(C_{i}^{<em>},\\mathsf{pt}_{i}^{</em>})</span>. The public output of the <span class="math">i</span>th prover is <span class="math">(\\rho_{i}^{<em>},C_{i}^{</em>},\\mathsf{pt}_{i}^{<em>},z_{i},\\pi_{i})</span>. Crucially, the prover does not need to include <span class="math">(\\mathsf{open}_{i}^{</em>},f_{i}^{*})</span> as part of the public output.</p>

    <h2 id="sec-72" class="text-2xl font-bold">Appendix B Zero knowledge compiler for an additive PCS over <span class="math">\\mathbb{F}_{p}</span></h2>

    <p class="text-gray-300">In this section we describe a generic compiler for transforming any <span class="math">m</span>-spanning additive PCS over <span class="math">\\mathbb{F}_{p}</span> (Definition 8) into a hiding PCS with a zero-knowledge <span class="math">\\mathsf{Eval}</span>. For the remainder of this section <span class="math">\\mathbb{F}:=\\mathbb{F}_{p}</span>, for some prime number <span class="math">p</span>. It may be possible to generalize our results to work over extension fields, but that is beyond scope.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Theorem 10.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There is a generic compiler that takes any <span class="math">m</span>-spanning additive PCS over <span class="math">\\mathbb{F}_{p}</span> and transforms it into a statistically-hiding homomorphic PCS whose evaluation protocol satisfies bounded witness zero-knowledge. The new PCS commitment group <span class="math">\\mathbb{G}</span> on setup parameters <span class="math">(\\lambda,d)</span> is equal to the original input PCS group for parameters <span class="math">(\\lambda,d+m)</span>. The new evaluation protocol has the following efficiency, with $\\Delta:=max(m,\\lambda+\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The communication overhead is <span class="math">O(\\Delta)</span>, consisting of an integer vector of size at most <span class="math">\\Delta</span> bits and a constant number of elements in <span class="math">\\mathbb{G}</span> and <span class="math">\\mathbb{F}</span>.</li>

      <li>The verification overhead is <span class="math">O(\\Delta)</span> group operations in <span class="math">\\mathbb{G}</span>.</li>

      <li>The prover overhead is <span class="math">O(\\Delta+d)</span> group operations in <span class="math">\\mathbb{G}</span> and a constant number of field operations in <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">The proof of Theorem 10 is covered by Lemma 9 and Lemma 10.</p>

    <h3 id="sec-74" class="text-xl font-semibold mt-8">B.1 Compiler I: From Additive to Homomorphic</h3>

    <p class="text-gray-300">The first step is to transform the non-hiding additive PCS into a homomorphic PCS. The steps of this transformation were explained briefly in Section 3. Let <span class="math">(\\mathsf{Setup}</span>, <span class="math">\\mathsf{Commit}</span>, <span class="math">\\mathsf{Verify}</span>, <span class="math">\\mathsf{Eval})</span> denote the protocols of the non-hiding additive PCS. Since the PCS is non-hiding we assume (without loss of generality) that the commitment algorithm <span class="math">\\mathsf{Commit}</span> is a deterministic function. The new</p>

    <p class="text-gray-300">homomorphic non-hiding PCS has the same <span class="math">\\mathsf{Setup},\\mathsf{Verify}</span>, and <span class="math">\\mathsf{Eval}</span> protocols and only modifies the commitment algorithm <span class="math">\\mathsf{Commit}^*</span> as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Commit}^*(pp, f) \\to (\\mathsf{C}, \\mathsf{open})</span>: on inputs <span class="math">pp</span> and <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>, finds the integer coefficient vector representation <span class="math">(\\hat{f}_0, \\dots, \\hat{f}_{d-1}) \\in [0, p)^d</span> of <span class="math">f</span> and</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Runs <span class="math">(\\mathsf{C}_i, \\mathsf{open}_i) \\gets \\mathsf{Commit}(pp, X^{i-1})</span> for <span class="math">i \\in [1, d]</span></li>

      <li>Sets <span class="math">\\mathsf{C} := \\sum_{i=0}^{d-1} \\hat{f}_i \\cdot \\mathsf{C}_i</span> and <span class="math">\\mathsf{open} := (\\hat{f}_0, \\dots, \\hat{f}_{d-1})</span>.</li>

    </ol>

    <p class="text-gray-300">By definition, <span class="math">\\mathsf{C}</span> is also a valid commitment to the polynomial <span class="math">f</span> under the original scheme. The prover uses the algorithm <span class="math">\\mathsf{add}^<em></span> to derive a valid opening string <span class="math">\\mathsf{open}&#x27;</span> for <span class="math">\\mathsf{C}</span> to <span class="math">f</span>, i.e., such that <span class="math">\\mathsf{Verify}(pp, f, \\mathsf{open}&#x27;, \\mathsf{C}) = 1</span>. For the evaluation protocol, the prover uses <span class="math">\\mathsf{open}&#x27;</span> and runs the <span class="math">\\mathsf{Eval}</span> protocol of the original scheme. Note that <span class="math">\\mathsf{open}&#x27;</span> may not be the same as <span class="math">\\mathsf{open}</span>, but can always be computed from <span class="math">\\mathsf{open}</span> using <span class="math">\\mathsf{add}^</em></span>. For some schemes (e.g., KZG and Bulletproofs) that are already homomorphic, the linear combination <span class="math">\\mathsf{C}</span> would be identical to a fresh commitment to <span class="math">f</span> and <span class="math">\\mathsf{open}&#x27; = \\mathsf{open}</span>. In other words, the transformation described above has no effect.</p>

    <p class="text-gray-300">The transformed scheme is a homomorphic PCS because <span class="math">\\mathsf{C} = \\phi(\\mathsf{open})</span> where <span class="math">\\phi : \\mathbb{Z}^d \\to \\mathbb{G}</span> is the homomorphism that maps <span class="math">\\mathbf{v} \\in \\mathbb{Z}^d</span> to <span class="math">\\sum_{i=1}^{d} v_i \\cdot \\mathsf{C}_i</span> and <span class="math">\\chi(\\mathsf{open}) = \\mathsf{open} \\mod p</span> is the unique coefficient vector of <span class="math">f \\in \\mathbb{F}^{(&amp;lt;d)}[X]</span>. If the additive PCS is <span class="math">m</span>-spanning then the homomorphism <span class="math">\\phi_m : \\mathbb{Z}^m \\to \\mathbb{G}</span> given by <span class="math">\\mathbf{v} \\mapsto \\sum_{i=1}^{m} v_i \\cdot \\mathsf{C}_i</span> is surjective. The new scheme is binding: given a collision <span class="math">\\hat{\\mathbf{f}}&#x27; \\neq \\hat{\\mathbf{f}} \\mod p</span> such that <span class="math">\\mathsf{C} = \\phi(\\hat{\\mathbf{f}}) = \\phi(\\hat{\\mathbf{f}}&#x27;)</span>, the algorithm <span class="math">\\mathsf{add}^*</span> could be used to derive openings of <span class="math">\\mathsf{C}</span> to either <span class="math">f</span> or <span class="math">f&#x27;</span> from the <span class="math">\\mathsf{open}_i</span> values, which contradicts the binding property of <span class="math">\\mathsf{Commit}</span>.</p>

    <h2 id="sec-75" class="text-2xl font-bold">B.2 Compiler II: From Homomorphic to Hiding</h2>

    <p class="text-gray-300">The parameters of the compilation are <span class="math">(m, \\kappa) \\in \\mathbb{N}</span>. The input to the compiler is a non-hiding <span class="math">m</span>-spanning homomorphic PCS with the following characteristics for any <span class="math">pp \\gets \\mathsf{Setup}(\\lambda, d)</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Commit}(pp, f)</span> is deterministic (w.l.o.g., since it is non-hiding).</li>

      <li><span class="math">\\mathbb{H} = \\mathbb{Z}^d</span> and <span class="math">\\chi(\\mathbf{f})</span> returns the unique polynomial in <span class="math">\\mathbb{F}^{(&amp;lt;d)}[X]</span> with coefficient vector <span class="math">\\mathbf{f} \\mod p</span>.</li>

      <li><span class="math">(g_i, e_i) \\gets \\mathsf{Commit}(pp, X^i)</span> where <span class="math">e_i</span> is the <span class="math">i</span>th standard basis vector in <span class="math">\\mathbb{Z}^D</span>. For all <span class="math">\\mathbf{f} \\in \\mathbb{Z}^d</span>, <span class="math">\\phi(\\mathbf{f}) = \\sum_{i=1}^{d} f_i \\cdot g_i</span>.</li>

    </ul>

    <p class="text-gray-300">Any <span class="math">m</span>-spanning additive PCS that is first passed through Compiler I has these characteristics.</p>

    <h3 id="sec-76" class="text-xl font-semibold mt-8">Hiding: 1-spanning case</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a warm-up, we first describe a simple transformation that works when <span class="math">\\mathbb{G}</span> is cyclic, $m = \\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\kappa<span class="math">, and </span>g_{1},\\ldots ,g_{m}<span class="math"> are each generators of </span>\\mathbb{G}<span class="math">. The new setup </span>\\mathsf{Setup}^{<em>}(\\lambda ,d)<span class="math"> will run </span>\\mathsf{Setup}(\\lambda ,d + m)<span class="math">, which defines </span>\\phi :\\mathbb{Z}^{d + m}\\to \\mathbb{G}<span class="math">. The new hiding commitment to </span>\\mathbf{f} = (f_0,\\dots,f_{d - 1})\\in [0,p)^d<span class="math"> samples a random degree </span>m<span class="math"> blinding polynomial </span>r\\in \\mathbb{F}^{(&lt;m)}[X]<span class="math"> and outputs a non-hiding commitment to the polynomial </span>f^{\\prime}\\coloneqq r + X^{m}f<span class="math"> using the original commitment algorithm. More precisely, it samples a random integer vector </span>\\mathbf{r}\\in [0,2^{\\kappa})^{m}<span class="math">, sets </span>\\mathsf{open}\\coloneqq (\\mathbf{r},\\mathbf{f})\\in \\mathbb{Z}^{d + m}<span class="math">, and returns </span>\\mathsf{C}\\coloneqq \\phi (\\mathsf{open})<span class="math">. The new scheme is still homomorphic with </span>\\mathbb{H} = \\mathbb{Z}^{d + m}<span class="math">, the same homomorphism </span>\\phi<span class="math">, and a new homomorphism </span>\\chi^{</em>}:\\mathbb{H}\\to \\mathbb{F}^{d}<span class="math"> such that </span>\\chi (\\mathbf{x}_1,\\mathbf{x}_2) = \\mathbf{x}_2\\bmod p<span class="math"> for any </span>\\mathbf{x}_1\\in \\mathbb{Z}^m<span class="math"> and </span>\\mathbf{x}_2\\in \\mathbb{Z}^d$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The commitment is hiding if the random variable <span class="math">Z(r_{1},\\dots,r_{m}) = \\sum_{i = 1}^{m}r_{i}\\cdot g_{i}</span> is indistinguishable from uniform <span class="math">\\mathbb{G}</span> when <span class="math">\\mathbf{r}</span> is sampled uniformly from <span class="math">[0,2^{\\kappa})^{m}</span>. By a classical theorem, when <span class="math">g_{i}</span></p>

    <p class="text-gray-300">52</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">are generators of  <span class="math">\\mathbb{G}</span>  and  <span class="math">r_i \\in [0, 2^\\kappa]</span> , the random variable  <span class="math">Z(r_1, \\dots, r_m)</span>  converges to uniform for  $m \\in O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/ \\kappa)$  [Bab91, Coo02, Dix08]. This is the case in all the examples of additive schemes from Section 3.2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hiding:  <span class="math">m</span> -spanning case In the more general case of an  <span class="math">m</span> -spanning scheme (i.e., where  <span class="math">g_{i}</span>  are not necessarily generators but  <span class="math">\\langle g_1, \\dots, g_m \\rangle = \\mathbb{G}</span> ), it suffices to use commitments to a random polynomial basis of  <span class="math">\\mathbb{F}^{(&lt;m)}[x]</span> <span class="math">f=&quot;&quot; </span>\\mathbf{a}="" <span class="math">\\mathbf{a} \\in=&quot;&quot; </span>\\mathbf{f}="" <span class="math">\\mathbf{f}(0,=&quot;&quot; </span>\\mathbf{f}(x)="y<span class="math">&quot; </span>\\mathbf{f}_1="" <span class="math">\\mathbf{f}_2</span>="" <span class="math">\\mathbf{f}_2 ==&quot;&quot; </span>\\mathbf{f}_2<span class="math">=&quot;&quot; </span>\\mathbf{f}_2<span class="math">),=&quot;&quot; </span>\\mathbf{f}_n<span class="math">=&quot;&quot; </span>\\mathbf{f}_n<span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; </span>\\mathbf{f}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 6: Compiler III (hiding) Parameters  <span class="math">m = m(\\lambda)</span>  and  <span class="math">\\kappa = \\kappa(\\lambda)</span>  are functions. The compiler uses a sampling algorithm  <span class="math">\\mathbf{A} \\gets \\mathsf{Sample}(\\lambda, m)</span>  that returns a matrix in  <span class="math">\\mathbb{Z}^{m \\times m}</span> . By default  <span class="math">\\mathbf{A}</span>  is sampled uniformly over  <span class="math">[0, q)^{m \\times m}</span>  where  $q =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . When  </span>q<span class="math">  is unknown  </span>\\mathbf{A}<span class="math">  may be sampled such that  </span>\\mathbf{A} \\mod q<span class="math">  is statistically close to uniform. In special cases  </span>\\mathbf{A}$  may be the identity matrix.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Setup\\*  <span class="math">(\\lambda ,d)\\to pp</span>  sets  <span class="math">\\kappa = \\kappa (\\lambda)</span> <span class="math">m = m(\\lambda)</span> <span class="math">D\\gets d + m</span> <span class="math">pp^{\\prime}\\gets \\mathsf{Setup}(\\lambda ,D)</span> <span class="math">\\mathbf{A}\\gets \\mathsf{Sample}(\\lambda ,m)</span>  and outputs  <span class="math">(pp^{\\prime},\\mathbf{A})</span>  . For all  <span class="math">j\\in [1,D]</span>  , compute  <span class="math">(g_{j},e_{j})\\gets \\mathsf{Commit}(pp^{\\prime},X^{j})</span>  and for  <span class="math">i\\in [1,m]</span>  compute  <span class="math">\\tilde{g}_j\\gets \\sum_{i = 1}^m a_{ij}\\cdot g_i</span>  where  <span class="math">a_{ij}</span>  is the  <span class="math">(i,j)</span>  th entry of A. For  <span class="math">\\mathbf{x}\\in \\mathbb{Z}^{D}</span>  let  <span class="math">\\phi (\\mathbf{x}) = \\sum_{i = 1}^{D}x_{i}\\cdot g_{i}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{Commit}^* (pp,f)\\to (\\mathsf{C},\\mathsf{open})</span>  receives the coefficient vector  <span class="math">\\mathbf{f}</span>  of  <span class="math">f\\in \\mathbb{F}^{(&lt;d)}[x]</span> <span class="math">\\mathbf{f}</span>="" <span class="math">\\mathbf{f}</span>="" <span class="math">\\mathbf{f}</span>="" <span class="math">\\mathbf{f})=&quot;\\mathbf{C}</span>" <span class="math">\\mathbf{f})</span>="" <span class="math">\\mathbf{f}</span>="" <span class="math">\\mathbf{f})=&quot;\\mathbf{C}</span>" <span class="math">\\mathbf{f})</span>="" <span class="math">\\mathbf{f})_{\\mathrm{com}}=&quot;(\\mathbf{r},\\mathbf{f})</span>" <span class="math">\\mathbf{f}</span>="" <span class="math">\\mathbf{f}</span>="" $\\mathbf{f})_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}="(\\mathbf{r},\\mathbf{f})<span class="math">&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f})_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}<span class="math">=&quot;&quot; </span>\\mathbf{f})_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f})_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f})_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{com}}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}<span class="math">=&quot;&quot; </span>\\mathbf{f}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">with non-negligible probability on each of these evaluation points. By evaluation binding of the PCS, this implies that <span class="math">f^{\\prime}(\\rho_{i})=\\rho_{i}^{m}\\cdot f(\\rho_{i})</span> for each <span class="math">i\\in[1,D+m]</span>. Since <span class="math">deg(f^{\\prime}-X^{m}\\cdot f)&lt;D+m</span> this implies <span class="math">f^{\\prime}=X^{m}\\cdot f</span> and <span class="math">deg(f)&lt;d</span>. Finally, using the additive property of the PCS the extractor can derive from <span class="math">\\mathbf{r}</span> and <span class="math">\\mathsf{open}^{\\prime}</span> an opening of <span class="math">\\mathsf{C}</span> to the polynomial with coefficient vector <span class="math">(\\mathbf{r},\\mathbf{f})</span>.</p>

    <h4 id="sec-77" class="text-lg font-semibold mt-6">Hiding</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let $q=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>\\phi_{m}:\\mathbb{Z}^{m}\\to\\mathbb{G}<span class="math"> be defined as </span>\\phi_{m}(\\mathbf{x})=\\sum_{i=1}^{m}x_{i}\\cdot g_{i}<span class="math">. It suffices prove that </span>\\mathsf{C}_{r}=\\phi(\\mathbf{A}\\cdot\\mathbf{r})<span class="math"> for </span>\\mathbf{r}\\stackrel{{\\scriptstyle\\scriptscriptstyle\\scriptscriptstyle\\lambda}}{{=}}[0,2^{\\kappa})^{m}<span class="math"> has negligible distance to uniform over </span>\\mathbb{G}<span class="math">. The min-entropy of </span>\\mathbf{r}<span class="math"> is </span>m\\kappa<span class="math">. Due to the fact that the PCS is </span>m<span class="math">-spanning </span>\\phi_{m}<span class="math"> is surjective. We will show that </span>\\phi_{m}(\\mathbf{A}\\cdot\\mathbf{r})$ is a good randomness extractor using the Leftover Hash Lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Define the keyed hash family <span class="math">\\mathcal{H}:\\mathbb{Z}_{q}^{m\\times m}\\times\\mathbb{Z}^{m}\\to\\mathbb{G}</span> such that <span class="math">\\mathcal{H}(\\mathbf{A},\\mathbf{x})=\\phi_{m}(\\mathbf{A}\\cdot\\mathbf{x})</span>. For uniform <span class="math">\\mathbf{y}\\in\\mathbb{Z}_{q}^{m}</span> the element <span class="math">\\phi_{m}(\\mathbf{y})</span> is uniformly distributed over <span class="math">\\mathbb{G}</span>. Moreover, for <span class="math">\\mathbf{A}</span> sampled uniformly and <span class="math">\\mathbf{x}\\neq 0</span> the vector <span class="math">\\mathbf{y}=\\mathbf{A}\\cdot\\mathbf{x}\\bmod q</span> is uniformly distributed over <span class="math">\\mathbb{Z}_{q}^{m}</span>. Thus, <span class="math">\\mathcal{H}</span> is <span class="math">2</span>-universal (Definition 3) because for any <span class="math">\\mathbf{x}\\neq\\mathbf{y}</span> and uniformly distributed <span class="math">\\mathbf{A}</span> the element <span class="math">\\mathcal{H}(\\mathbf{A},\\mathbf{x})-\\mathcal{H}(\\mathbf{A},\\mathbf{y})</span> is uniformly distributed in <span class="math">\\mathbb{G}</span> and the probability of a collision is $1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Let </span>U_{\\mathbb{G}}<span class="math"> denote an independent random variable from the uniform distribution over </span>\\mathbb{G}<span class="math">. Since </span>H_{\\infty}(\\mathbf{r})\\geq m\\kappa<span class="math"> and </span>\\mathbf{A}<span class="math"> is independently uniform over </span>\\mathbb{G}$, by the Leftover Hash Lemma (Lemma 1):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">SD((\\mathcal{H}(\\mathbf{A},\\mathbf{r}),\\mathbf{A}),(U_{\\mathbb{G}},\\mathbf{A}))\\leq\\frac{1}{2}\\sqrt{2^{\\log q-m\\kappa}}</span></p>

    <p class="text-gray-300">Thus, for <span class="math">m\\kappa\\geq\\lambda+\\log q</span>, the distribution of <span class="math">\\mathsf{C}_{r}</span> has negligible distance at most <span class="math">2^{-\\lambda}</span> from uniform over <span class="math">\\mathbb{G}</span>. <span class="math">\\square</span></p>

    <h4 id="sec-78" class="text-lg font-semibold mt-6">Examples</h4>

    <p class="text-gray-300">The following examples of this transformation cover the common cases of homomorphic commitment schemes. In all these examples, no basis transformation is necessary (i.e., the matrix <span class="math">\\mathbf{A}</span> is the identity matrix).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbb{G}</span> is any group of order $p=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. In this case the scheme is perfectly hiding for </span>m=1<span class="math"> and </span>2^{\\kappa}=p<span class="math"> because </span>g_{1}<span class="math"> is a generator and </span>r_{1}\\cdot g_{1}<span class="math"> is uniformly distributed in </span>\\mathbb{G}$. This is the case for several PCS schemes including Bulletproofs and KZG <em>[BCC^{+}16, BBB^{+}18, 10]</em>.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- If <span class="math">\\mathbb{G}</span> is a group of unknown order, <span class="math">g_{1}</span> is a generator of <span class="math">\\mathbb{G}</span>, and $2^{\\kappa}>2^{\\lambda}\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbb{G}</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">, then the scheme is statistically hiding for </span>m=1$. This is the case in DARK.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathbb{G}</span> is the group <span class="math">\\mathbb{Z}_{q}^{n}</span> for <span class="math">q&gt;p</span> and all <span class="math">g_{i}</span> are sampled independently from the uniform distribution over <span class="math">\\mathbb{Z}_{q}^{n}</span> then the scheme is statistically hiding for <span class="math">m=n\\log_{p}q</span> and <span class="math">2^{\\kappa}=p</span> by the leftover hash lemma. This is known as Ajtai’s hash function <em>[1, 2]</em> and is the commitment function for a PCS based on the Integer-SIS problem <em>[BBC^{+}18]</em>.</li>

    </ul>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">B.3 Compiler III: From Hiding to Zero Knowledge Eval</h3>

    <p class="text-gray-300">Lastly, we describe a generic compiler that takes any homomorphic hiding PCS with an Eval that is not zero-knowledge and transforms it into a PCS with a zero-knowledge Eval^{∗}. The idea</p>

    <p class="text-gray-300">is similar to the sigma protocol for homomorphism pre-images and is a generalization of known techniques [CFS17, BCC+16, BFS20].</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{PCS} = (\\text{Setup}, \\text{Commit}, \\text{Verify}, \\text{Eval})</span> denote the input PCS. By definition there are efficiently computable homomorphisms <span class="math">\\phi : \\mathbb{Z}^D \\to \\mathbb{G}</span> and <span class="math">\\chi : \\mathbb{Z}^D \\to \\mathbb{F}^{(&lt;d)}[X]</span> <span class="math">f=&quot;\\chi(\\text{open})</span>" <span class="math">f</span>="" <span class="math">f</span>),="" <span class="math">f\\in=&quot;&quot; </span>f(x)="y \\mod" <span class="math">y_{\\alpha}=&quot;&quot; </span>y_{\\alpha} :=="" <span class="math">y_{\\alpha} +=&quot;&quot; </span>z<span class="math">=&quot;&quot; </span>z<span class="math">=&quot;&quot; </span>z<span class="math">=&quot;&quot; </span>z_{\\alpha}="" (<span class="math">\\alpha</span>,="" (<span class="math">\\alpha</span>),="" (<span class="math">\\alpha</span>),="" (<span class="math">\\alpha</span>.="" (<span class="math">\\alpha_{\\alpha}=&quot;&quot; (</span>\\alpha_{\\alpha}<span class="math">),=&quot;&quot; (</span>\\mathcal{c}="\\phi(\\text{open}_{f})<span class="math">&quot; (</span>\\mathcal{c}_{s}="\\phi(\\mathbf{s})" (<span class="math">\\mathcal{c}_{s},=&quot;&quot; (p,=&quot;&quot; (s,=&quot;&quot; (s,=&quot;&quot; ,=&quot;&quot; -=&quot;&quot; .=&quot;&quot; 10.=&quot;&quot; 11.=&quot;&quot; 12.=&quot;&quot; 13.=&quot;&quot; 14.=&quot;&quot; 2.=&quot;&quot; 2.1=&quot;&quot; 2keval(b)</span>="" 2keval(b)<span class="math">=&quot;&quot; 3,=&quot;&quot; 3.=&quot;&quot; 4.=&quot;&quot; 5.=&quot;&quot; a=&quot;&quot; and=&quot;&quot; any=&quot;&quot; are=&quot;&quot; as=&quot;&quot; at=&quot;&quot; be=&quot;&quot; both=&quot;&quot; bound=&quot;&quot; bounded=&quot;&quot; both=&quot;&quot; by=&quot;&quot; can=&quot;&quot; chain=&quot;&quot; change=&quot;&quot; chain.=&quot;&quot; coin=&quot;&quot; coefficient=&quot;&quot; committment=&quot;&quot; committment,=&quot;&quot; compute=&quot;&quot; compute).=&quot;&quot; compute.=&quot;&quot; compute. Given=&quot;&quot; compute.=&quot;&quot; compute.=&quot;&quot; compute.=&quot;&quot; d</span>,="" define="" defined="" derive="" derived="" derive.="" different="" directed="" each="" effect="" efficient="" efficiently="" equivalent="" evaluation="" evaluation-proof="" evaluation.="" eval="" each="" easily="" equal="" equivalent.="" equivalent.="" f(x)]="" f(x)]<span class="math">=&quot;&quot; f(x)]</span>.="" f(x)]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">=&quot;&quot; f(x))</span>="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$,="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$.="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\geq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\geq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$="" f(x))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As for soundness, the extractor <span class="math">\\mathcal{E}</span> invokes tree-finding algorithm (Lemma 6) to get two accepting transcripts that share the same first message <span class="math">\\mathsf{C}_{\\alpha},\\alpha(z)</span> but have distinct challenges <span class="math">c,c^{\\prime}</span>, which define <span class="math">\\mathsf{C}_{s},\\mathsf{C}_{s}^{\\prime}</span>. <span class="math">\\mathcal{E}</span> then invokes <span class="math">\\mathcal{E}_{\\mathsf{Eval}}</span> for <span class="math">(\\mathsf{C}_{s},z,\\alpha(z))</span> and <span class="math">(\\mathsf{C}_{s}^{\\prime},z,\\alpha(z))</span> respectively. By Lemma 7, with high probability the transcript has the property that the adversary succeeds in <span class="math">\\mathsf{Eval}</span> on both <span class="math">(\\mathsf{C}_{\\alpha},c)</span> and <span class="math">(\\mathsf{C}_{\\alpha},c^{\\prime})</span> with non-negligible probability. In this case, <span class="math">\\mathcal{E}_{\\mathsf{Eval}}</span> outputs openings of <span class="math">\\mathsf{C}_{s}</span> to <span class="math">s\\in\\mathbb{F}^{(&lt;d)}[X]</span> such that <span class="math">s(z)=\\alpha(z)+c\\cdot y</span> and of <span class="math">\\mathsf{C}_{s}^{\\prime}</span> to <span class="math">s^{\\prime}\\in\\mathbb{F}^{(&lt;d)}[X]</span> such that <span class="math">s^{\\prime}(z)=\\alpha^{\\prime}(z)+c^{\\prime}\\cdot y</span> with overwhelming probability. If it does not succeed this step is repeated up to <span class="math">\\lambda</span> times, and the probability none succeeds is negligible.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbf{A}\\in\\mathbb{Z}^{2\\times 2}</span> be the matrix with rows <span class="math">(1,c)</span> and <span class="math">(1,c^{\\prime})</span>, which is invertible over <span class="math">\\mathbb{F}_{p}</span> because <span class="math">c\\neq c^{\\prime}</span>. Since <span class="math">\\mathsf{C}_{\\alpha}+c\\cdot\\mathsf{C}_{f}=\\mathsf{C}_{s}</span> and <span class="math">\\mathsf{C}_{\\alpha}+c^{\\prime}\\cdot\\mathsf{C}_{f}=\\mathsf{C}_{s}^{\\prime}</span>, by Lemma 4 the extractor can efficiently compute openings of <span class="math">\\mathsf{C}_{\\alpha}</span> to <span class="math">\\alpha</span> and <span class="math">\\mathsf{C}_{f}</span> to <span class="math">f</span> such that <span class="math">\\langle\\mathbf{A},(\\alpha,f)\\rangle=(s,s^{\\prime})^{\\intercal}</span>. This implies <span class="math">\\alpha(z)+c\\cdot f(z)=s(z)=\\alpha(z)+c\\cdot y\\bmod p</span>, i.e. <span class="math">f(z)=y\\bmod p</span>.</p>

    <p class="text-gray-300">∎</p>

    <h2 id="sec-80" class="text-2xl font-bold">Appendix C Our results for the KZG scheme and applications to pairing-based SNARKs</h2>

    <p class="text-gray-300">In this section, we focus on batch evaluation for the original PCS of Kate, Zaverucha and Goldberg <em>[x13]</em> and its implications for the PLONK zk-SNARK <em>[x10]</em>. <em>[x13]</em> presented a pairing-based scheme where an opening proof <span class="math">\\pi</span> consists of a single <span class="math">\\mathbb{G}_{1}</span> group element.</p>

    <h4 id="sec-81" class="text-lg font-semibold mt-6">Related previous results</h4>

    <p class="text-gray-300"><em>[x16]</em>, who introduced the use of <em>[x13]</em> for universal and updatable SNARKs, modified the PCS of <em>[x13]</em> in the random oracle model, so that a single <span class="math">\\mathbb{G}_{1}</span> element can be an opening proof for several polynomials <em>at the same point</em> <span class="math">z\\in\\mathbb{F}</span>. <em>[x12, CHM^{+}20, x10]</em> followed and used similar single-point multi-polynomial batching protocols.</p>

    <p class="text-gray-300"><em>[x13]</em> give in their paper a less known version of their scheme allowing for a one <span class="math">\\mathbb{G}_{1}</span> element opening proof for <em>one</em> polynomial at several evaluation points.</p>

    <p class="text-gray-300">For the case of multiple polynomials and evaluation points, <em>[CHM^{+}20, x10]</em> use randomized techniques for batching pairing equations to improve verification efficiency; however opening proof size and prover computation still grow linearly with the number of distinct points.</p>

    <h4 id="sec-82" class="text-lg font-semibold mt-6">Our results</h4>

    <p class="text-gray-300">In this section, we give two extensions of KZG for multiple evaluation points and polynomials.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In our first scheme the opening proof is only a single <span class="math">\\mathbb{G}_{1}</span> element, but verifier operations are considerably heavier than previous variants of <em>[x13]</em> when the number of distinct evaluation points is large (cf. Lemma 16).</li>

      <li>In our second scheme the opening proof is two <span class="math">\\mathbb{G}_{1}</span> elements, and the verifier complexity is somewhat better than previous multipoint variants of <em>[x13]</em> (cf. Lemma 17). This scheme is simply the instantiation for KZG of our private aggregation for any additive PCS; however, we give a simplified proof for this instance using the algebraic group model of <em>[x11]</em> (which is needed in any case to prove the basic PCS of <em>[x13]</em> is secure).</li>

    </ul>

    <p class="text-gray-300">We compare the performance of our PCS to a more straightforward batched version of the <em>[x13]</em> scheme as in <em>[x10]</em>. For simplicity, we look at the restricted case where we want to</p>

    <p class="text-gray-300">open  <span class="math">t</span>  polynomials all with the same degree bound  <span class="math">n</span> , each at one distinct point. See Lemma 16 and 17 for the more detailed efficiency properties in the general case (where each polynomial is opened at a subset of points, and the subsets may repeat).</p>

    <p class="text-gray-300">Table 1: Comparison of opening complexity for  <span class="math">t</span>  polynomials on  <span class="math">t</span>  distinct points. In prover/verifier work columns  <span class="math">\\mathbb{G}_i</span>  means scalar multiplication in  <span class="math">\\mathbb{G}_i</span> ,  <span class="math">\\mathbb{F}</span>  means addition or multiplication in  <span class="math">\\mathbb{F}</span> , and  <span class="math">\\mathbf{P}</span>  means pairing.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KZG as in [GWC19]</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, 2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">t · n G1, O(t · n log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">t G1</td>

            <td class="px-3 py-2 border-b border-gray-700">3t - 2 G1, 2 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work, ver. 1</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, t + 1 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, O(t · n + n log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">1 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">t - 1 G1, t2 G2, t + 1 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work, ver. 2</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, 2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">2n G1, O(t · n + n log n) F</td>

            <td class="px-3 py-2 border-b border-gray-700">2 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">t + 3 G1, 2 P</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Application to PLONK: The PLONK proving system [GWC19] allows generating proofs of knowledge for assignments to fan-in two arithmetic circuits with a universal and updatable SRS (see the paragraph on this topic in Section C.1.1). Most of the prover computation involves committing to several polynomials and opening them at two distinct evaluation points. Plugging in our first PCS to PLONK allows saving in proof length and prover work related to the opening proof of the second evaluation point (we do not give full details, but all that is needed is repeating the transformation of Lemma 4.7 in [GWC19] using the PCS of Lemma 16 instead of the PCS used there to obtain the new result).</p>

    <p class="text-gray-300">We compare the PLONK scheme when using the [KZG10]-based PCS in [GWC19] and the first PCS of this paper in Table 2. As in [GWC19] we present two versions of PLONK where one optimizes fast proving, and the other small proof length.</p>

    <p class="text-gray-300">Table 2: Comparison of PLONK efficiency for fan-in two circuit with  <span class="math">n</span>  gates.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SRS size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover group exponentations</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof length</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GWC19] (fast)</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, 2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">9n G1 exp</td>

            <td class="px-3 py-2 border-b border-gray-700">9 G1, 7 F</td>

            <td class="px-3 py-2 border-b border-gray-700">18 G1, 2 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work (fast)</td>

            <td class="px-3 py-2 border-b border-gray-700">n G1, 3 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">8n G1 exp</td>

            <td class="px-3 py-2 border-b border-gray-700">8 G1 7 F</td>

            <td class="px-3 py-2 border-b border-gray-700">18 G1, 4 G2, 3 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GWC19] (small)</td>

            <td class="px-3 py-2 border-b border-gray-700">3n G1, 2 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">11n G1 exp</td>

            <td class="px-3 py-2 border-b border-gray-700">7 G1, 7 F</td>

            <td class="px-3 py-2 border-b border-gray-700">16 G1, 2 P</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work (small)</td>

            <td class="px-3 py-2 border-b border-gray-700">3n G1, 3 G2</td>

            <td class="px-3 py-2 border-b border-gray-700">10n G1 exp</td>

            <td class="px-3 py-2 border-b border-gray-700">6 G1 7 F</td>

            <td class="px-3 py-2 border-b border-gray-700">16 G1, 4 G2, 3 P</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">SHPLONK? Our second PCS does not give interesting tradeoffs for PLONK as two evaluation points are not enough for its advantages to "kick in". However, in a scenario where constraints between more than two evaluation points are used, e.g. [Dra], the advantages of both of our new schemes will become more prominent. Thus, the PCS of this paper encourage designing constraint systems using multiple SHifts and Permutations over Largange bases for Oecumenical Noninteractive arguments of Knowledge.</p>

    <p class="text-gray-300">C.1 Additonal Preliminaries</p>

    <p class="text-gray-300">We introduce additional terminology and material convenient for our analysis in the algebraic group model.</p>

    <h4 id="sec-83" class="text-lg font-semibold mt-6">C.1.1 Terminology and conventions</h4>

    <p class="text-gray-300">We assume our field <span class="math">\\mathbb{F}</span> is of prime order. We denote by <span class="math">\\mathbb{F}_{&lt;d}[X]</span> the set of univariate polynomials over <span class="math">\\mathbb{F}</span> of degree smaller than d. In expressions involving both polynomials and constants, we will write <span class="math">f(X)</span> instead of <span class="math">f</span> for to help distinguish the two; but in contexts where it is clear <span class="math">f</span> is a polynomial, we will simply write <span class="math">f</span> for brevity.</p>

    <p class="text-gray-300">We assume all algorithms described receive as an implicit parameter the security parameter <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300">Whenever we use the term “efficient”, we mean an algorithm running in time <span class="math">\\mathsf{poly}(\\lambda)</span>. Furthermore, we assume an “object generator” <span class="math">\\mathcal{O}</span> that is run with input <span class="math">\\lambda</span> before all protocols, and returns all fields and groups used. Specifically, in our protocol <span class="math">\\mathcal{O}(\\lambda)=(\\mathbb{F},\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t},e,g_{1},g_{2},g_{t})</span> where</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbb{F}</span> is a prime field of super-polynomial size <span class="math">r=\\lambda^{\\omega(1)}</span> .</li>

      <li><span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{t}</span> are all groups of size <span class="math">r</span>, and <span class="math">e</span> is an efficiently computable non-degenerate pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>.</li>

      <li><span class="math">g_{1},g_{2}</span> are uniformly chosen generators such that <span class="math">e(g_{1},g_{2})=g_{t}</span>.</li>

    </ul>

    <p class="text-gray-300">We usually let the <span class="math">\\lambda</span> parameter be implicit, i.e. write <span class="math">\\mathbb{F}</span> instead of <span class="math">\\mathbb{F}(\\lambda)</span>. We write <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> additively. We use the notations <span class="math">[x]_{1}:=x\\cdot g_{1}</span> and <span class="math">[x]_{2}:=x\\cdot g_{2}</span>.</p>

    <p class="text-gray-300">We often denote by <span class="math">[n]</span> the integers <span class="math">\\{1,\\ldots,n\\}</span>. We use the acronym e.w.p for “except with probability”; i.e. e.w.p <span class="math">\\gamma</span> means with probability <em>at least</em> <span class="math">1-\\gamma</span>.</p>

    <h5 id="sec-84" class="text-base font-semibold mt-4">Universal SRS-based public-coin protocols</h5>

    <p class="text-gray-300">We describe public-coin (meaning the verifier messages are uniformly chosen) interactive protocols between a prover and verifier; when deriving results for non-interactive protocols, we implicitly assume we can get a proof length equal to the total communication of the prover, using the Fiat-Shamir transform/a random oracle. Using this reduction between interactive and non-interactive protocols, we can refer to the “proof length” of an interactive protocol.</p>

    <p class="text-gray-300">We allow our protocols to have access to a structured reference string (SRS) that can be derived in deterministic <span class="math">\\mathsf{poly}(\\lambda)</span>-time from an “SRS of monomials” of the form <span class="math">\\left\\{\\left[x^{i}\\right]_{1}\\right\\}_{a\\leq i\\leq b},\\left\\{\\left[x^{i}\\right]_{2}\\right\\}_{c\\leq i\\leq d}</span>, for uniform <span class="math">x\\in\\mathbb{F}</span>, and some integers <span class="math">a,b,c,d</span> with absolute value bounded by <span class="math">\\mathsf{poly}(\\lambda)</span>. It then follows from Bowe et al. <em>[x1]</em> that the required SRS can be derived in a universal and updatable setup<em>[GKM^{+}18]</em> requiring only one honest participant; in the sense that an adversary controlling all but one of the participants in the setup does not gain more than a <span class="math">\\mathsf{negl}(\\lambda)</span> advantage in its probability of producing a proof of any statement.</p>

    <p class="text-gray-300">For notational simplicity, we sometimes use the SRS <span class="math">\\mathsf{srs}</span> as an implicit parameter in protocols, and do not explicitly write it.</p>

    <h4 id="sec-85" class="text-lg font-semibold mt-6">C.1.2 Analysis in the AGM model</h4>

    <p class="text-gray-300">For security analysis we will use the Algebraic Group Model of Fuchsbauer, Kiltz and Loss <em>[x11]</em>. In our protocols, by an <em>algebraic adversary</em> <span class="math">\\mathcal{A}</span> in an SRS-based protocol we mean a <span class="math">\\mathsf{poly}(\\lambda)</span>-time algorithm which satisfies the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in\\{1,2\\}</span>, whenever <span class="math">\\mathcal{A}</span> outputs an element <span class="math">A\\in\\mathbb{G}_{i}</span>, it also outputs a vector <span class="math">v</span> over <span class="math">\\mathbb{F}</span> such that <span class="math">A=&lt;v,\\mathsf{srs}_{i}&gt;</span>.</li>

    </ul>

    <h5 id="sec-86" class="text-base font-semibold mt-4">Idealized verifier checks for algebraic adversaries</h5>

    <p class="text-gray-300">We introduce some terminology to capture the advantage of analysis in the AGM.</p>

    <p class="text-gray-300">First we say our <span class="math">\\mathsf{srs}</span> <em>has degree</em> <span class="math">Q</span> if all elements of <span class="math">\\mathsf{srs}_{i}</span> are of the form <span class="math">[f(x)]_{i}</span> for <span class="math">f\\in\\mathbb{F}_{&lt;Q}[X]</span> and uniform <span class="math">x\\in\\mathbb{F}</span>. In the following discussion let us assume we are executing a protocol with a degree <span class="math">Q</span> SRS, and denote by <span class="math">f_{i,j}</span> the corresponding polynomial for the <span class="math">j</span>’th element of <span class="math">\\mathsf{srs}_{i}</span>.</p>

    <p class="text-gray-300">Denote by <span class="math">a,b</span> the vectors of <span class="math">\\mathbb{F}</span>-elements whose encodings in <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> an algebraic adversary <span class="math">\\mathcal{A}</span> outputs during a protocol execution; e.g., the <span class="math">j</span>’th <span class="math">\\mathbb{G}_{1}</span> element output by <span class="math">\\mathcal{A}</span> is <span class="math">[a_{j}]_{1}</span>.</p>

    <p class="text-gray-300">By a “real pairing check” we mean a check of the form</p>

    <p class="text-gray-300"><span class="math">(a\\cdot T_{1})\\cdot(T_{2}\\cdot b)=0</span></p>

    <p class="text-gray-300">for some matrices <span class="math">T_{1},T_{2}</span> over <span class="math">\\mathbb{F}</span>. Note that such a check can indeed be done efficiently given the encoded elements and the pairing function <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{t}</span>.</p>

    <p class="text-gray-300">Given such a “real pairing check”, and the adversary <span class="math">\\mathcal{A}</span> and protocol execution during which the elements were output, define the corresponding “ideal check” as follows. Since <span class="math">\\mathcal{A}</span> is algebraic when he outputs <span class="math">[a_{j}]_{i}</span> he also outputs a vector <span class="math">v</span> such that, from linearity, <span class="math">a_{j}=\\sum v_{\\ell}f_{i,\\ell}(x)=R_{i,j}(x)</span> for <span class="math">R_{i,j}(X):=\\sum v_{\\ell}f_{i,\\ell}(X)</span>. Denote, for <span class="math">i\\in\\{1,2\\}</span> the vector of polynomials <span class="math">R_{i}=(R_{i,j})_{j}</span>. The corresponding ideal check, checks as a polynomial identity whether</p>

    <p class="text-gray-300"><span class="math">(R_{1}\\cdot T_{1})\\cdot(T_{2}\\cdot R_{2})\\equiv 0</span></p>

    <p class="text-gray-300">The following lemma is inspired by <em>[x11]</em>’s analysis of <em>[x14]</em>, and tells us that for soundness analysis against algebraic adversaries it suffices to look at ideal checks. Before stating the lemma we define the <span class="math">Q</span>-DLOG assumption similarly to <em>[x11]</em>.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Definition 11.</h6>

    <p class="text-gray-300">Fix an integer <span class="math">Q</span>. The <span class="math">Q</span>-DLOG assumption for <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span> states that given</p>

    <p class="text-gray-300"><span class="math">[1]_{1},[x]_{1},\\ldots,\\left[x^{Q}\\right]_{1},[1]_{2},[x]_{2},\\ldots,\\left[x^{Q}\\right]_{2}</span></p>

    <p class="text-gray-300">for uniformly chosen <span class="math">x\\in\\mathbb{F}</span>, the probability of an efficient <span class="math">\\mathcal{A}</span> outputting <span class="math">x</span> is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">The following lemma is proved in <em>[x16]</em>-based on the arguments of <em>[x11]</em>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 12.</h6>

    <p class="text-gray-300">Assume the <span class="math">Q</span>-DLOG for <span class="math">(\\mathbb{G}_{1},\\mathbb{G}_{2})</span>. Given an algebraic adversary <span class="math">\\mathcal{A}</span> participating in a protocol with a degree <span class="math">Q</span> SRS, the probability of any real pairing check passing is larger by at most an additive <span class="math">\\mathsf{negl}(\\lambda)</span> factor than the probability the corresponding ideal check holds.</p>

    <h5 id="sec-89" class="text-base font-semibold mt-4">Knowlege soundness in the Algebraic Group Model</h5>

    <p class="text-gray-300">We say a protocol <span class="math">\\mathscr{P}</span> between a prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span> for a relation <span class="math">\\mathcal{R}</span> has <em>Knowledge Soundness in the Algebraic Group Model</em> if there exists an efficient <span class="math">E</span> such that the probability of any algebraic adversary <span class="math">\\mathcal{A}</span> winning the following game is <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> chooses input <span class="math">\\mathsf{x}</span> and plays the role of <span class="math">\\mathbf{P}</span> in <span class="math">\\mathscr{P}</span> with input <span class="math">\\mathsf{x}</span>.</li>

      <li><span class="math">E</span> given access to all of <span class="math">\\mathcal{A}</span>’s messages during the protocol (including the coefficients of the linear combinations) outputs <span class="math">\\omega</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> wins if</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\mathbf{V}</span> outputs <span class="math">\\mathsf{acc}</span> at the end of the protocol, and (b) <span class="math">(\\mathsf{x},\\omega)\\notin \\mathcal{R}</span></p>

    <h2 id="sec-90" class="text-2xl font-bold">C.1.3 Polynomial commitment schemes in the algebraic group model</h2>

    <p class="text-gray-300">For a simple presentation of our schemes in the context of KZG, it will be convenient to define polynomial commitment schemes similarly to [GWC19]. Specifically</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We define the open procedure analogously to the Eval procedure from the definition in Section 2.3, and it directly deals with the batch evaluation setting.</li>

      <li>We define knowledge soundness specifically against “algebraic” adversaries.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On advantage of using the same definition as in [GWC19], is that it enables directly plugging in our batch evaluation result into the machinery of [GWC19] to obtain the improved prover time stated above. In the context of multiple points, it will be more convenient to assume the alleged evaluations of a polynomial <span class="math">f</span> on a set <span class="math">S \\subset \\mathbb{F}</span> are given as a polynomial $r \\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]<span class="math"> with </span>r(z) = f(z)<span class="math"> for each </span>z \\in S<span class="math">. Under this convention, the condition that the evaluations are correct; i.e. </span>r(z) = f(z)<span class="math"> for each </span>z \\in S<span class="math">, is equivalent to </span>f(X) - r(X)<span class="math"> being divisible by </span>Z_S(X)<span class="math">; where </span>Z_S(X) := \\prod_{z \\in S} (X - z)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Definition 13.</strong> A polynomial commitment scheme is a triplet <span class="math">\\mathcal{S} = (\\text{gen}, \\text{com}, \\text{open})</span> such that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\text{gen}(d)</span> - is a randomized algorithm that given positive integer <span class="math">d</span> outputs a structured reference string (SRS) srs.</li>

      <li><span class="math">\\text{com}(f, \\text{srs})</span> - is an algorithm that given a polynomial <span class="math">f \\in \\mathbb{F}_{&amp;lt;d}[X]</span> and an output srs of <span class="math">\\text{gen}(d)</span> returns a commitment cm to <span class="math">f</span>.</li>

      <li>open is a public coin protocol between parties <span class="math">\\mathrm{P_{PC}}</span> and <span class="math">\\mathrm{V_{PC}}</span>. <span class="math">\\mathrm{P_{PC}}</span> is given <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{&amp;lt;d}[X]</span>. <span class="math">\\mathrm{P_{PC}}</span> and <span class="math">\\mathrm{V_{PC}}</span> are both given</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>positive integers <span class="math">d, t = \\text{poly}(\\lambda)</span>,</li>

      <li><span class="math">\\mathsf{srs} = \\mathsf{gen}(d)</span>,</li>

      <li>a subset <span class="math">T = \\{z_1, \\ldots, z_t\\} \\subset \\mathbb{F}</span>,</li>

      <li>subsets <span class="math">S_1, \\ldots, S_k \\subset T</span>,</li>

      <li><span class="math">\\mathsf{cm}_1, \\ldots, \\mathsf{cm}_k</span> - the alleged commitments to <span class="math">f_1, \\ldots, f_k</span>,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6. $\\{r_i \\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]\\}_{i \\in [k]}<span class="math"> - the polynomials describing the alleged correct openings, i.e. having </span>r_i(z) = f_i(z)<span class="math"> for each </span>i \\in [k], z \\in S_i$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">At the end of the protocol <span class="math">\\mathrm{V_{PC}}</span> outputs <span class="math">\\mathsf{acc}</span> or <span class="math">\\mathsf{rej}</span>; such that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <strong>Completeness:</strong> Fix any <span class="math">k, t = \\text{poly}(\\lambda)</span>, <span class="math">T = \\{z_1, \\ldots, z_t\\} \\subset \\mathbb{F}</span>, <span class="math">S_1, \\ldots, S_k \\subset T</span>, <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{&amp;lt;d}[X]</span>, $\\{r_i \\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]\\}_{i \\in [k]}<span class="math">. Suppose that for each </span>i \\in [k]<span class="math">, </span>\\mathsf{cm}_i = \\mathsf{com}(f_i, \\mathsf{srs})<span class="math">, and for each </span>i \\in [k]<span class="math"> we have </span>Z_{S_i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(f_i - r_i)<span class="math">. Then if </span>\\mathrm{P_{PC}}<span class="math"> follows open correctly with these values, </span>\\mathrm{V_{PC}}<span class="math"> outputs </span>\\mathsf{acc}$ with probability one.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">61</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Knowledge soundness in the algebraic group model: There exists an efficient <span class="math">E</span> such that for any algebraic adversary <span class="math">\\mathcal{A}</span> and any choice of <span class="math">d = \\mathrm{poly}(\\lambda)</span> the probability of <span class="math">\\mathcal{A}</span> winning the following game is <span class="math">\\mathrm{negl}(\\lambda)</span> over the randomness of <span class="math">\\mathcal{A}</span>, <span class="math">\\mathrm{V}_{\\mathrm{PC}}</span> and <span class="math">\\mathrm{gen}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">d</span> and <span class="math">\\mathbf{srs} = \\mathrm{gen}(d)</span>, <span class="math">\\mathcal{A}</span> outputs <span class="math">\\mathsf{cm}_1, \\ldots, \\mathsf{cm}_k \\in \\mathbb{G}_1</span>.</li>

      <li><span class="math">E</span>, given access to the messages of <span class="math">\\mathcal{A}</span> during the previous step, outputs <span class="math">f_{1},\\ldots ,f_{k}\\in \\mathbb{F}_{&amp;lt; d}[X]</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. <span class="math">\\mathcal{A}</span> outputs <span class="math">T = \\{z_{1},\\ldots ,z_{t}\\} \\subset \\mathbb{F}</span>, $S_{1},\\ldots ,S_{k}\\subset T,\\left\\{r_{i}\\in \\mathbb{F}_{&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}[X]\\right\\}_{i\\in [k]}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}</span> takes the part of <span class="math">\\mathrm{P_{PC}}</span> in the protocol open with the inputs <span class="math">\\mathsf{cm}_1, \\ldots, \\mathsf{cm}_k</span>, <span class="math">T, S_1, \\ldots, S_k</span>, <span class="math">\\{r_i\\}</span>.</li>

      <li><span class="math">\\mathcal{A}</span> wins if</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathrm{PC}}</span> outputs <span class="math">\\mathsf{acc}</span> at the end of the protocol.</li>

      <li>For some <span class="math">i \\in [k]</span>, <span class="math">Z_{S_i} \\nmid (f_i - r_i)</span>.</li>

    </ul>

    <h2 id="sec-91" class="text-2xl font-bold">C.2 Our first scheme</h2>

    <p class="text-gray-300">We first state the following straightforward claim that will allow us to efficiently "uniformize" checks on different evaluation points.</p>

    <p class="text-gray-300"><strong>Claim 14.</strong> Fix subsets <span class="math">S \\subset T \\subset \\mathbb{F}</span>, and a polynomial <span class="math">g \\in \\mathbb{F}_{&amp;lt;d}[X]</span>. Then <span class="math">Z_S(X)</span> divides <span class="math">g(X)</span> if and only if <span class="math">Z_T(X)</span> divides <span class="math">Z_{T \\setminus S}(X) \\cdot g(X)</span>.</p>

    <p class="text-gray-300">We also use the following claim, which is part of Claim 4.6 in [GWC19] where a proof of it can be found.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 15.</strong> Fix <span class="math">F_{1},\\ldots ,F_{k}\\in \\mathbb{F}_{&amp;lt; n}[X]</span>. Fix <span class="math">Z\\in \\mathbb{F}_{&amp;lt; n}[X]</span> that decomposes to distinct linear factors over <span class="math">\\mathbb{F}</span>. Suppose that for some <span class="math">i\\in [k]</span>, <span class="math">Z\\nmid F_i</span>. Then, e.w.p $k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over uniform </span>\\gamma \\in \\mathbb{F}<span class="math">, </span>Z$ does not divide</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">G := \\sum_{j = 1}^{k} \\gamma^{j - 1} \\cdot F_{j}.</span></div>

    <p class="text-gray-300">We present our first PCS.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{gen}(d)</span> - choose uniform <span class="math">x\\in \\mathbb{F}</span>. Output <span class="math">\\mathsf{srs} = ([1]_1,[x]_1,\\ldots ,[x^{d - 1}]_1,[1]_2,[x]_2,\\ldots ,[x^t]_2)</span>.</li>

      <li><span class="math">\\mathsf{com}(f, \\mathsf{srs}) := [f(x)]_1</span>.</li>

      <li><span class="math">\\mathsf{open}\\left(d,t,\\{\\mathsf{cm}_i\\}_{i\\in [k]},T = \\{z_1,\\ldots ,z_t\\} \\subset \\mathbb{F},\\{S_i\\subset T\\}_{i\\in [k]},\\{r_i\\}_{i\\in [k]}\\right)</span>:</li>

    </ol>

    <p class="text-gray-300">(a) <span class="math">\\mathrm{V}_{\\mathrm{PC}}</span> sends a random <span class="math">\\gamma \\in \\mathbb{F}</span>.</p>

    <p class="text-gray-300">(b) <span class="math">\\mathrm{P}_{\\mathrm{PC}}</span> computes the polynomial</p>

    <div class="my-4 text-center"><span class="math-block">h (X) := \\sum_{i \\in [ k ]} \\gamma^{i - 1} \\cdot \\frac{f_{i} (X) - r_{i} (X)}{Z_{S_{i} (X)}}</span></div>

    <p class="text-gray-300">and using <span class="math">\\mathsf{srs}</span> computes and sends <span class="math">W \\coloneqq [h(x)]_1</span>.</p>

    <p class="text-gray-300">(c) <span class="math">\\mathrm{V}_{\\mathrm{PC}}</span> computes for each <span class="math">i \\in [k]</span>, <span class="math">Z_i := \\left[Z_{T \\setminus S_i}(x)\\right]_2</span>.</p>

    <p class="text-gray-300">62</p>

    <p class="text-gray-300">(d) <span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> computes</p>

    <div class="my-4 text-center"><span class="math-block">F := \\prod_{i \\in [k]} e \\left(\\gamma^{i-1} \\cdot \\left(\\operatorname{cm}_i - [r_i(x)]_1\\right), Z_i\\right).</span></div>

    <p class="text-gray-300">(e) <span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> outputs <span class="math">\\mathsf{acc}</span> if and only if</p>

    <div class="my-4 text-center"><span class="math-block">F = e \\left(W, \\left[ Z_T(x) \\right]_2\\right).</span></div>

    <p class="text-gray-300">We argue knowledge soundness for the above protocol. More precisely, we argue the existence of an efficient <span class="math">E</span> such that an algebraic adversary <span class="math">\\mathcal{A}</span> can only win the KS game described in Section C.1.3 w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be such an algebraic adversary.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> begins by outputting <span class="math">\\mathsf{cm}_1, \\ldots, \\mathsf{cm}_k \\in \\mathbb{G}_1</span>. Each <span class="math">\\mathsf{cm}_i</span> is a linear combination <span class="math">\\sum_{j=0}^{d-1} a_{i,j} [x^j]_1</span>. <span class="math">E</span>, who is given the coefficients <span class="math">\\{a_{i,j}\\}</span>, simply outputs the polynomials</p>

    <div class="my-4 text-center"><span class="math-block">f_i(X) := \\sum_{j=0}^{d-1} a_{i,j} \\cdot X^j.</span></div>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> now outputs <span class="math">T = \\{z_1, \\ldots, z_t\\} \\subset \\mathbb{F}</span>, <span class="math">\\{S_i \\subset T\\}_{i \\in [k]}</span>, <span class="math">\\{r_i\\}_{i \\in [k]}</span>. Assume that for some <span class="math">i^<em> \\in [k]</span>, we have <span class="math">Z_{S_{i^</em>}} \\nmid (f_{i^<em>} - r_{i^</em>})</span>. We show that for any strategy of <span class="math">\\mathcal{A}</span> from this point, <span class="math">\\mathrm{V}_{\\mathrm{poly}}</span> outputs <span class="math">\\mathsf{acc}</span> w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">In the first step of <span class="math">\\mathsf{open}</span>, <span class="math">\\mathrm{V}_{\\mathrm{poly}}</span> chooses a random <span class="math">\\gamma \\in \\mathbb{F}</span>. Let</p>

    <div class="my-4 text-center"><span class="math-block">f(X) := \\sum_{i \\in [t]} \\gamma^{i-1} \\cdot Z_{T \\setminus S_i}(X) \\cdot \\left(f_i(X) - r_i(X)\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We know from Claim 14 that <span class="math">F_{i^<em>} := Z_{T \\setminus S_{i^</em>}} \\cdot (f_{i^<em>} - r_{i^</em>})</span> is not divisible by <span class="math">Z_T</span>. Thus, using Claim 15, we know that e.w.p $k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\gamma<span class="math">, </span>f<span class="math"> is not divisible by </span>Z_T<span class="math">. Now </span>\\mathcal{A}<span class="math"> outputs </span>W = [H(x)]_1<span class="math"> for some </span>H \\in \\mathbb{F}_{&lt;d}[X]$. According to Lemma 12, it suffices to upper bound the probability that the ideal check corresponding to the real pairing check in the protocol passes. It has the form</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">f(X) \\equiv H(X) Z_T(X).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The check passing implies that <span class="math">f(X)</span> is divisible by <span class="math">Z_T</span>. Thus the ideal check can only pass w.p. $k /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathsf{negl}(\\lambda)<span class="math"> over the randomness of </span>\\mathrm{V}_{\\mathrm{poly}}$, which implies the same thing for the real check according to Lemma 12.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We summarize the efficiency properties of the scheme.</p>

    <p class="text-gray-300"><strong>Lemma 16.</strong> There is a PCS <span class="math">\\mathcal{S} = (\\mathsf{gen}, \\mathsf{com}, \\mathsf{open})</span> such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For positive integer <span class="math">d</span>, <span class="math">\\mathsf{srs} = \\mathsf{gen}(d)</span> consists of <span class="math">d</span> <span class="math">\\mathbb{G}_1</span> elements and <span class="math">t + 1</span> <span class="math">\\mathbb{G}_2</span> elements.</li>

      <li>For integer <span class="math">n \\leq d</span> and <span class="math">f \\in \\mathbb{F}_{&amp;lt;n}[X]</span>, computing <span class="math">\\mathsf{com}(f, \\mathsf{srs})</span> requires <span class="math">n</span> <span class="math">\\mathbb{G}_1</span>-exponentiations.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3. Given <span class="math">T := (z_1, \\ldots, z_t) \\in \\mathbb{F}^t</span>, <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{&amp;lt;d}[X]</span>, <span class="math">\\{S_i\\}_{i \\in [k]}</span>, denote by <span class="math">k^<em></span> the number of distinct subsets <span class="math">\\{S_1^</em>, \\ldots, S_{k^<em>}^</em>\\}</span> in <span class="math">\\{S_i\\}</span>; and let $K := t + \\sum_{i \\in [k^*]}(t -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S_i^*</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">. and denote </span>n := \\max \\{\\deg(f_i)\\}_{i \\in [k]}<span class="math">. Let </span>\\mathsf{cm}_i = \\mathsf{com}(f_i)<span class="math">. Then </span>\\mathsf{open}(\\{\\mathsf{cm}_i\\}, \\{f_i\\}, T, \\{S_i \\subset T\\}, \\{r_i\\}, \\mathsf{srs})$ requires</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">63</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A single <span class="math">\\mathbb{G}_{1}</span> element to be passed from <span class="math">\\mathrm{P}_{\\mathsf{poly}}</span> to <span class="math">\\mathrm{V}_{\\mathsf{poly}}</span>.</li>

      <li>At most <span class="math">n</span> <span class="math">\\mathbb{G}_{1}</span>-exponentiations of <span class="math">\\mathrm{P}_{\\mathsf{poly}}</span>.</li>

      <li><span class="math">k-1</span> <span class="math">\\mathbb{G}_{1}</span>-exponentiations, <span class="math">K</span> <span class="math">\\mathbb{G}_{2}</span>-exponentiations and <span class="math">k^{*}+1</span> pairings of <span class="math">\\mathrm{V}_{\\mathsf{poly}}</span>.</li>

    </ol>

    <h3 id="sec-92" class="text-xl font-semibold mt-8">C.3 Reducing verifier operations at the expense of proof length</h3>

    <p class="text-gray-300">We describe a variant of the scheme of Section C.2 where we eliminate the verifier’s <span class="math">\\mathbb{G}_{2}</span> operations and reduce the number of pairings to two. This comes at the cost of an extra <span class="math">\\mathbb{G}_{1}</span> element sent by the prover. Roughly speaking, while in Section C.2 <span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> used <span class="math">\\mathbb{G}_{2}</span> and pairing operations to compute the evaluation of a certain polynomial <span class="math">f</span> encoded in the target group <span class="math">\\mathbb{G}_{t}</span>, in this protocol <span class="math">\\mathrm{P}_{\\mathsf{PC}}</span> gives <span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> this evaluation encoded in <span class="math">\\mathbb{G}_{1}</span>, accompanied by a proof that it is correct. As mentioned, this is simply an instantiation of our general private aggregation scheme in the context of the KZG PCS. However, we will take advantage of the algebraic group model to simplify the security proof. We first describe the PCS, and end the section by stating the obtained final result.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{gen}(d)</span> outputs <span class="math">\\mathsf{srs}=([1]_{1}\\,,[x]_{1}\\,,\\ldots,\\left[x^{d-1}\\right]_{1}\\,,[1]_{2}\\,,[x]_{2})</span> for a random <span class="math">x\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathsf{com}(f_{i})=[f_{i}(x)]_{1}</span>.</li>

      <li>We describe the open procedure twice below. First, in a way that will be convenient for the security analysis, and later in an equivalent more concise way that also optimizes verifier operations, .e.g. moves operations from <span class="math">\\mathbb{G}_{2}</span> into <span class="math">\\mathbb{G}_{1}</span> when possible.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{open}(\\{\\mathsf{cm}_{i}\\}\\,,T,\\{S_{i}\\}\\,,\\{r_{i}\\})</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> sends random <span class="math">\\gamma\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathrm{P}_{\\mathsf{PC}}</span> computes the polynomial</li>

    </ol>

    <p class="text-gray-300"><span class="math">f(X):=\\sum_{i\\in[k]}\\gamma^{i-1}\\cdot Z_{T\\setminus S_{i}}(X)\\cdot(f_{i}(X)-r_{i}(X)).</span></p>

    <p class="text-gray-300">Recall that <span class="math">f</span> is divisible by <span class="math">Z_{T}</span> according to Claim 15, and define <span class="math">h(X):=f(X)/Z_{T}(X)</span>. Using <span class="math">\\mathsf{srs}</span>, <span class="math">\\mathrm{P}_{\\mathsf{PC}}</span> computes and sends <span class="math">W:=[h(x)]_{1}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> sends random <span class="math">z\\in\\mathbb{F}</span>.</li>

      <li><span class="math">\\mathrm{P}_{\\mathsf{PC}}</span> computes the polynomial</li>

    </ol>

    <p class="text-gray-300"><span class="math">L(X):=f_{z}(X)-Z_{T}(z)\\cdot h(X),</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">f_{z}(X):=\\sum_{i\\in[k]}\\gamma^{i-1}\\cdot Z_{T\\setminus S_{i}}(z)\\cdot(f_{i}(X)-r_{i}(z))</span></p>

    <p class="text-gray-300">Note that <span class="math">L(z)=f(z)-Z_{T}(z)\\cdot h(z)=0</span>, and thus <span class="math">(X-z)</span> divides <span class="math">L</span>. <span class="math">\\mathrm{P}_{\\mathsf{PC}}</span> sends <span class="math">W^{\\prime}:=\\left[\\frac{L(x)}{x-z}\\right]_{1}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> computes:</li>

    </ol>

    <p class="text-gray-300"><span class="math">F:=\\sum_{i\\in[k]}\\gamma^{i-1}\\cdot Z_{T\\setminus S_{i}}(z)\\cdot(\\mathsf{cm}_{i}-[r_{i}(z)]_{1})-Z_{T}(z)\\cdot W</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathsf{PC}}</span> outputs acc if and only if</li>

    </ol>

    <p class="text-gray-300"><span class="math">e(F,[1]_{2})=e(W^{\\prime},[x-z]_{2}).</span></p>

    <p class="text-gray-300">We argue knowledge soundness for the above protocol. More precisely, we argue the existence of an efficient <span class="math">E</span> such that an algebraic adversary <span class="math">\\mathcal{A}</span> can only win the KS game w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>. The proof begins identically to the previous one.</p>

    <p class="text-gray-300">Let <span class="math">\\mathcal{A}</span> be such an algebraic adversary.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> begins by outputting <span class="math">\\mathsf{cm}_{1},\\ldots,\\mathsf{cm}_{k}\\in\\mathbb{G}_{1}</span>. Each <span class="math">\\mathsf{cm}_{i}</span> is a linear combination <span class="math">\\sum_{j=0}^{d-1}a_{i,j}\\left[x^{j}\\right]_{1}</span>. <span class="math">E</span>, who is given the coefficients <span class="math">\\{a_{i,j}\\}</span>, simply outputs the polynomials</p>

    <p class="text-gray-300"><span class="math">f_{i}(X):=\\sum_{j=0}^{d-1}a_{i,j}\\cdot X^{j}.</span></p>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> now outputs <span class="math">T=\\{z_{1},\\ldots,z_{t}\\}\\subset\\mathbb{F},\\{S_{i}\\subset T\\}_{i\\in[k]}\\,,\\{r_{i}\\}_{i\\in[k]}</span>. Assume that for some <span class="math">i^{<em>}\\in[k]</span>, we have <span class="math">Z_{S_{i^{</em>}}}\\nmid(f_{i^{<em>}}-r_{i^{</em>}})</span>. We show that for any strategy of <span class="math">\\mathcal{A}</span> from this point, <span class="math">\\mathrm{V}_{\\mathsf{poly}}</span> outputs acc w.p. <span class="math">\\mathsf{negl}(\\lambda)</span>.</p>

    <p class="text-gray-300">In the first step of <span class="math">\\mathsf{open}</span>, <span class="math">\\mathrm{V}_{\\mathsf{poly}}</span> chooses a random <span class="math">\\gamma\\in\\mathbb{F}</span>. Let</p>

    <p class="text-gray-300"><span class="math">f(X):=\\sum_{i\\in[k]}\\gamma^{i-1}\\cdot Z_{T\\setminus S_{i}}\\cdot(f_{i}(X)-r_{i}(X)).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We know from Claim 14 that <span class="math">F_{i^{<em>}}:=Z_{T\\setminus S_{i^{</em>}}}(f_{i^{<em>}}-r_{i^{</em>}})</span> is not divisible by <span class="math">Z_{T}</span>. Thus, using Claim 15, we know that e.w.p $k/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>\\gamma<span class="math">, </span>f<span class="math"> is not divisble by </span>Z_{T}<span class="math">. Assume we are in this case. Now </span>\\mathcal{A}<span class="math"> outputs </span>W=\\left[H(x)\\right]_{1}<span class="math"> for some </span>H\\in\\mathbb{F}_{<d}[X]<span class="math">, followed by </span>\\mathrm{V}_{\\mathsf{PC}}<span class="math"> sending uniform </span>z\\in\\mathbb{F}<span class="math">. Since we are in the case that </span>f<span class="math"> is not divisble by </span>Z_{T}<span class="math">, we know there are at most </span>2d<span class="math"> values </span>z\\in\\mathbb{F}<span class="math"> such that </span>f(z)=H(z)\\cdot Z_{T}(z)<span class="math">; and thus </span>z<span class="math"> chosen by </span>\\mathrm{V}_{\\mathsf{PC}}<span class="math"> is of this form only w.p. </span>\\mathsf{negl}(\\lambda)<span class="math">. Assume we are in the case that </span>z<span class="math"> sent by </span>\\mathrm{V}_{\\mathsf{PC}}<span class="math"> is not of this form. </span>\\mathrm{P}_{\\mathsf{PC}}<span class="math"> now outputs </span>W^{\\prime}=\\left[H^{\\prime}(x)\\right]_{1}<span class="math"> for some </span>H^{\\prime}\\in\\mathbb{F}_{<d}[X]$. According to Lemma 12, it suffices to upper bound the probability that the ideal check corresponding to the real pairing check in step 6 passes. Denoting</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">L^{\\prime}(X):=\\sum_{i\\in[k]}\\gamma^{i-1}Z_{T\\setminus S_{i}}(z)\\cdot(f_{i}(X)-r_{i}(z))-Z_{T}(z)\\cdot H(X),</span></p>

    <p class="text-gray-300">the ideal check has the form</p>

    <p class="text-gray-300"><span class="math">L^{\\prime}(X)\\equiv H^{\\prime}(X)\\cdot(X-z),</span></p>

    <p class="text-gray-300">and thus can pass for some <span class="math">H^{\\prime}\\in\\mathbb{F}_{&lt;d}[X]</span> only if <span class="math">L^{\\prime}</span> is divisible by <span class="math">(X-z)</span>, which means <span class="math">L^{\\prime}(z)=0</span>. However</p>

    <p class="text-gray-300"><span class="math">L^{\\prime}(z)=\\sum_{i\\in[k]}\\gamma^{i-1}Z_{T\\setminus S_{i}}(z)\\cdot(f_{i}(z)-r_{i}(z))-Z_{T}(z)\\cdot H(z)=f(z)-Z_{T}(z)\\cdot H(z),</span></p>

    <p class="text-gray-300">and we are in the case where <span class="math">f(z)\\neq Z_{T}(z)\\cdot H(z)</span>. In summary, the ideal check can only pass w.p. <span class="math">\\mathsf{negl}(\\lambda)</span> over the randomness of <span class="math">\\mathrm{V}_{\\mathsf{PC}}</span>, which implies the same thing for the real check according to Lemma 12.</p>

    <p class="text-gray-300">C.4 The open procedure, "cleaned up" and optimized</p>

    <p class="text-gray-300">open( <span class="math">\\{\\com(f_i)\\}, \\{S_i\\}, \\{r_i\\}</span> ):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathrm{PC}}</span>  sends a random challenge  <span class="math">\\gamma \\in \\mathbb{F}</span> .</li>

      <li><span class="math">\\mathrm{P_{PC}}</span>  sends  <span class="math">W\\coloneqq [(f / Z_T)(x)]_1</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">f := \\sum_ {i \\in [ k ]} \\gamma^ {i - 1} \\cdot Z _ {T \\backslash S _ {i}} (f _ {i} - r _ {i}).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathrm{PC}}</span>  sends a random evaluation point  <span class="math">z \\in \\mathbb{F}</span></li>

      <li><span class="math">\\mathrm{P_{PC}}</span>  sends  <span class="math">W^{\\prime}\\coloneqq [(L(x) / (x - z)]_{1}</span>  where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">L := \\sum_ {i \\in [ k ]} \\gamma^ {i - 1} Z _ {T \\backslash S _ {i}} (z) \\cdot \\left(f _ {i} - r _ {i} (z)\\right) - Z _ {T} (z) \\cdot \\left(f / Z _ {T}\\right).</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{V}_{\\mathrm{PC}}</span>  outputs acc iff  <span class="math">e(F + zW&#x27;, [1]_2) = e(W&#x27;, [x]_2)</span> , where</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">F := \\sum_ {i \\in [ k ]} \\gamma^ {i - 1} Z _ {T \\backslash S _ {i}} (z) \\cdot \\mathsf {c m} _ {i} - \\left[ \\sum_ {i \\in [ k ]} \\gamma^ {i - 1} Z _ {T \\backslash S _ {i}} (z) r _ {i} (z) \\right] _ {1} - Z _ {T} (z) W.</span></div>

    <p class="text-gray-300">From the description and analysis we obtain</p>

    <p class="text-gray-300">Lemma 17. There is a PCS  <span class="math">\\mathcal{S} = (\\mathrm{gen},\\mathrm{com},\\mathrm{open})</span>  such that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For positive integer  <span class="math">d</span> ,  <span class="math">\\mathsf{srs} = \\mathsf{gen}(d)</span>  consists of  <span class="math">d \\mathbb{G}_1</span>  elements and  <span class="math">2 \\mathbb{G}_2</span>  elements.</li>

      <li>For integer  <span class="math">n \\leq d</span>  and  <span class="math">f \\in \\mathbb{F}_{&amp;lt;n}[X]</span> , computing  <span class="math">\\operatorname{com}(f, \\operatorname{srs})</span>  requires  <span class="math">n</span> <span class="math">\\mathbb{G}_1</span> -exponentiations.</li>

      <li>Given  <span class="math">T \\coloneqq (z_1, \\ldots, z_t) \\in \\mathbb{F}^t</span> ,  <span class="math">f_1, \\ldots, f_k \\in \\mathbb{F}_{&amp;lt;d}[X]</span> ,  <span class="math">\\{S_i\\}_{i \\in [k]}</span>  and denote  <span class="math">n \\coloneqq \\max \\{\\deg(f_i)\\}_{i \\in [k]}</span> . Let  <span class="math">\\mathsf{cm}_i = \\mathsf{com}(f_i)</span> . Then open  <span class="math">(\\{\\mathsf{cm}_i\\}, \\{f_i\\}, T, \\{S_i \\subset T\\}, \\{r_i\\}, \\mathsf{srs})</span>  requires</li>

    </ol>

    <p class="text-gray-300">(a)  <span class="math">2\\mathbb{G}_1</span>  elements sent from  <span class="math">\\mathrm{P_{PC}}</span>  to  <span class="math">\\mathrm{V_{PC}}</span> (b) at most  <span class="math">2n + 1</span> <span class="math">\\mathbb{G}_1</span> -exponentiations of  <span class="math">\\mathrm{P_{PC}}</span> . (c)  <span class="math">k + 3\\mathbb{G}_1</span>  -exponentiations and 2 pairings of  <span class="math">\\mathrm{V_{PC}}</span></p>`;
---

<BaseLayout title="Halo Infinite: Recursive zk-SNARKs from any Additive Polynom... (2020/1536)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1536
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
