---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/765';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Bitcoin Backbone Protocol: Analysis and Applications';
const AUTHORS_HTML = 'Juan Garay, Aggelos Kiayias, Nikos Leonardos';

const CONTENT = `    <p class="text-gray-300">The Bitcoin Backbone Protocol: Analysis and Applications*</p>

    <p class="text-gray-300">Juan A. Garay Texas A&amp;M University garay@tamu.edu</p>

    <p class="text-gray-300">Aggelos Kiayias†‡ University of Edinburgh, IOHK akiayias@inf.ed.ac.uk</p>

    <p class="text-gray-300">Nikos Leonardos†§ National and Kapodistrian University of Athens. nikos.leonardos@gmail.com</p>

    <p class="text-gray-300">August 14, 2020</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">Bitcoin is the first and most popular decentralized cryptocurrency to date. In this work, we extract and analyze the core of the Bitcoin protocol, which we term the Bitcoin backbone, and prove two of its fundamental properties which we call common prefix and chain quality in the static setting where the number of players remains fixed. Our proofs hinge on appropriate and novel assumptions on the “hashing power” of the adversary relative to network synchronicity; we show our results to be tight under high synchronization.</p>

    <p class="text-gray-300">Next, we propose and analyze applications that can be built “on top” of the backbone protocol, specifically focusing on Byzantine agreement (BA) and on the notion of a public transaction ledger. Regarding BA, we observe that Nakamoto’s suggestion falls short of solving it, and present a simple alternative which works assuming that the adversary’s hashing power is bounded by 1/3. The public transaction ledger captures the essence of Bitcoin’s operation as a cryptocurrency, in the sense that it guarantees the liveness and persistence of committed transactions. Based on this notion we describe and analyze the Bitcoin system as well as a more elaborate BA protocol, proving them secure assuming high network synchronicity and that the adversary’s hashing power is strictly less than 1/2, while the adversarial bound needed for security decreases as the network desynchronizes.</p>

    <p class="text-gray-300">Finally, we extend our analysis of the Bitcoin backbone protocol for synchronous networks with relative ease to the partially synchronous model, where the upper bound in the delay of messages is unknown to the honest parties, showing its security for a suitable range of parameter values.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Bitcoin, introduced in [Nak08a], is a decentralized payment system that is based on maintaining a public transaction ledger in a distributed manner. The ledger is maintained by anonymous participants (“players”) called miners, executing a protocol that maintains and extends a distributed</p>

    <p class="text-gray-300">*An abridged version of this paper appears in Proc. Eurocrypt 2015. †Research partly supported by ERC project CODAMODA, # 259152. ‡Work partly done while at the National and Kapodistrian University of Athens §Work partly done while at LIAFA, Université Paris Diderot–Paris 7.</p>

    <p class="text-gray-300">data structure called the blockchain. The protocol requires from miners to solve a “proof of work” (POW, aka “cryptographic puzzle” — see, e.g., [DN92, RSW96, Bac97, JB99]), which essentially amounts to brute-forcing a hash inequality based on SHA-256, in order to generate new blocks for the blockchain. The blocks that comprise the blockchain contain sets of transactions that are generated at will by owners of bitcoins, who issue transactions that credit any entity of their choice who accepts payments in bitcoin. Payers broadcast transactions and miners include the transactions they receive into the blocks they generate. Miners are rewarded for maintaining the blockchain by receiving bitcoins; it is in this manner bitcoins are created and distributed among the miners who are the first recipients of newly minted bitcoins.</p>

    <p class="text-gray-300">An important concern in Bitcoin (or any e-payment system for that matter) is the prevention of double-spending attacks. Specifically, in the context of Bitcoin, a double-spending attack can occur when the attacker initially credits an account, receives service or goods by the account holder, but then manages to reorganize the transaction ledger so that the transaction that credits the account holder is reverted. In this way, the attacker keeps her bitcoin while receiving services and thus she is able to spend it again somewhere else.</p>

    <p class="text-gray-300">In [Nak08a], Nakamoto provides an initial set of arguments of why the Bitcoin system will prevent double-spending attacks. Specifically, he argues that if a payee waits for the transaction that gives her credit to advance into the blockchain a number of <span class="math">k</span> blocks, then the probability that an attacker can build an alternative blockchain that “reorganizes” the public blockchain (which contains the credit transaction) drops exponentially with <span class="math">k</span>. Nakamoto argues this by modeling the attacker and the set of honest players as two competing actors performing a random walk moving toward a single direction with probabilistic steps. He demonstrates that the <span class="math">k</span> blocks the payee waits are enough to ensure a negligible (in <span class="math">k</span>) probability of the attacker catching up with the honest players.</p>

    <p class="text-gray-300">Nevertheless, the above analysis can be easily seen to be oversimplified: in particular, it does not account for the fact that in Bitcoin’s decentralized setting the attacker may attempt to introduce disagreement between the honest miners, thus splitting their hashing power on different POW instances. Nakamoto himself appeared to recognize the relevance of agreement in the context of Bitcoin, arguing in a forum post [Nak08b] that actually “Bitcoin’s basic concept” of building and exchanging a blockchain is capable of solving Byzantine agreement (BA) [PSL80, LSP82] in the presence of an actively malicious adversary. However a thorough analysis establishing the exact security properties of the Bitcoin system has yet to appear.</p>

    <p class="text-gray-300">Our results. In this paper we extract, formally describe, and analyze the core of the Bitcoin protocol. We call this protocol the Bitcoin backbone, as we describe it in a way that is versatile and extensible and can be used to solve other problems as well — not just the problem of maintaining a public transaction ledger. The Bitcoin backbone protocol is executed by players that build a blockchain following the Bitcoin source code [Nak09] and allows a set of players to maintain a blockchain in a distributed fashion. The protocol is parameterized by three external functions <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span> which we call the content validation predicate, the input contribution function, and the chain reading function, respectively. At a high level, <span class="math">V(\\cdot)</span> determines the proper structure of the information that is stored into the blockchain, <span class="math">I(\\cdot)</span> specifies how the contents of the blocks are formed by the players, and <span class="math">R(\\cdot)</span> determines how a blockchain is supposed to be interpreted in the</p>

    <p class="text-gray-300">context of the application. Note that the structure, contents, and interpretation of the blockchain are not important for the description of the backbone protocol and are left to be specified by the three external functions above, which are application-specific (we provide examples of these functions in Section 5).</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Analysis of the Bitcoin backbone protocol</h4>

    <p class="text-gray-300">We analyze the protocol in a static setting when the participants operate in a synchronous communication network (more details below and in Section 2; see also Section 7 for an extension of the analysis to the partially synchronous model <em>[x10, x35]</em>) in the presence of an adversary that controls a subset of the players. We assume that the protocol is executed by a fixed number <span class="math">n</span> of players; note, however, that this number is not necessarily known to the protocol participants. The players themselves cannot authenticate each other and therefore there is no way to know the source of a message; we capture this by allowing the adversary to “spoof” the source address of any message that is delivered. We assume that messages are eventually delivered and all parties in the network are able to synchronize in the course of a “round.” The notion of round is not important for the description of the backbone protocol (which can also be executed in a loose and asynchronous fashion in the same way that Bitcoin works), however, it is important in terms of Bitcoin’s inherent computational assumption regarding the players’ ability to produce POWs.</p>

    <p class="text-gray-300">Specifically, we assume that in a single round, all parties involved are allowed the same number of queries to a cryptographic hash function, as well as to communicate with the other participants. The hash function is modeled as a random oracle <em>[x4]</em>. For simplicity we assume a “flat model,” where all parties have the same quota of hashing queries per round, say <span class="math">q</span>; the non-flat model where parties have differing hashing power capabilities can be easily captured by clustering the flat-model parties into larger virtual entities that are comprised by more than one flat-model player. In fact “mining pools” in Bitcoin can be thought of such aggregations of flat-model players. The adversary itself represents such pool as it controls <span class="math">t&lt;n</span> players; for this reason, the adversary’s quota per round is <span class="math">t\\cdot q</span> hashing queries. Note that in this setting, the fact <span class="math">t&lt;n/2</span> directly corresponds to the adversary controlling strictly less than half of the system’s total “hashing power” that all players collectively harness, thus, we will use terms such as “honest majority” and “(<span class="math">1/2</span>)-bounded adversary” interchangeably.</p>

    <p class="text-gray-300">In our analysis of the Bitcoin backbone protocol we formalize and prove two fundamental properties it possesses. The properties are quantified by parameter <span class="math">f</span> that represents the probability of a successful POW calculation by an honest party during a round of protocol execution.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The common prefix property. We prove that if <span class="math">\\frac{t}{n-t}</span> is suitably bounded below <span class="math">1</span>, then the blockchains maintained by the honest players will possess a large common prefix. More specifically, if an honest party “prunes” (i.e., cuts off) <span class="math">k</span> blocks from the end of its local chain, the probability that the resulting pruned chain will not be a prefix of another honest party’s chain drops exponentially in the security parameter (see Definition 3 for the precise formulation of the property and Theorem 15 for the precise statement). The parameter <span class="math">f</span> plays a critical role in the analysis of the property and should be small in order to approximate honest majority, i.e., allowing <span class="math">t</span> to be close to <span class="math">n/2</span>. A small choice for <span class="math">f</span>, suggests also that the network synchronizes significantly faster than the rate of finding POW’s. On the other hand, when the network “desynchronizes” and <span class="math">f</span> gets closer to <span class="math">1</span>, achieving provably a common prefix requires almost all parties to be honest.</li>

      <li>The chain quality property. We prove that the ratio of blocks in the chain of any honest player that are contributed by malicious players is bounded by <span class="math">\\frac{t}{n-t}</span>. Again observe that in an honest majority setting, i.e., allowing <span class="math">t</span> is bounded below <span class="math">n/2</span>, we obtain that the blockchain maintained by honest players is guaranteed to have few, but still some, blocks contributed by</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: An overview of the backbone protocol's applications: Nakamoto's BA protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{nak}}</span> , our BA protocols  <span class="math">\\Pi_{\\mathsf{BA}}^{1/3}</span>  and  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span> , and the public ledger protocol  <span class="math">\\Pi_{\\mathsf{PL}}</span> . All properties must be satisfied with overwhelming probability. In each box we state the name of the property as well as the maximum ratio of the adversarial hashing power that we can prove the protocol withstands (based on the corresponding backbone property). The value  <span class="math">\\epsilon</span>  stands for a negligible quantity.</p>

    <p class="text-gray-300">honest players; a higher ratio would be necessary to guarantee bigger percentages of blocks contributed by honest players in the blockchain. We also observe that this result is basically tight, i.e., that the adversary is capable of following a strategy (that deviates from the strategy of honest players) that enables the introduction of that many blocks in the blockchain, under a favorable (for the adversary) assumption on the propagation of adversarial blocks in the network.</p>

    <p class="text-gray-300">While the above two security properties may seem rather abstract since they refer to properties of the data structure that is maintained distributedly by the parties, we demonstrate that they are in fact quite powerful and show that the Bitcoin backbone protocol armed with the above properties can be used as a basis for solving other problems, including the problem of distributively maintaining a "robust" public transaction ledger. In Figure 1 we show how the two properties relate to the properties of the applications that are explained below and is provided in order to assist the reader in conceptualizing the logic behind the security proofs of the applications.</p>

    <p class="text-gray-300">In fact, a third property that is convenient to consider explicitly in conjunction with the above two and was introduced in follow-up work [KP15] is chain growth, which, at a high level, quantifies the number of blocks that are added to the blockchain during any given number of rounds. In our original exposition [GKL15], this property was not identified explicitly but rather proven and used directly in the form of a lemma. Nevertheless, identifying it as a separate property allows making more modular our proof arguments and for this reason we make it explicit in this version of the paper (cf. Section 3.2).</p>

    <p class="text-gray-300">Byzantine agreement for (1/3)-bounded adversaries. As a first application, we show how a randomized BA protocol can be built on top of the Bitcoin backbone protocol more or less directly, and based solely on the POW assumption. We instantiate the  <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span>  functions so that parties form blockchains and act according to the following rules: each party  <span class="math">i</span>  attempts to insert its own input  <span class="math">v_{i} \\in \\{0,1\\}</span>  into the blockchain; a blockchain is valid only if blocks contain elements in  <span class="math">\\{0,1\\}</span> ; the protocol terminates when the blockchain has reached a sufficient length; and, the blockchain is read by the honest parties by pruning  <span class="math">k</span>  elements from its end and returning the majority bit appearing in the resulting blockchain's prefix. We show how the common prefix property and</p>

    <p class="text-gray-300">the chain quality property of the backbone protocol ensure Agreement and Validity (BA’s basic properties; see Section 2) with high probability, thus turning the Bitcoin backbone protocol into a probabilistic BA protocol.</p>

    <p class="text-gray-300">Observe that for the above protocol to work the chain quality property should ensure that a majority of blocks in the blockchain originate from the honest players (otherwise Validity is lost). Our chain quality property enables this with overwhelming probability assuming the adversarial power is bounded by <span class="math">1/3</span>. This approach is different from Nakamoto’s proposal <em>[x20]</em> for BA, which, as we also show, only guarantees Validity with overwhelming probability if the adversary has a negligible amount of hashing power. On the positive side, we stress that Nakamoto’s protocol fails gracefully when the adversarial power gets close to <span class="math">50\\%</span> as Validity can be shown with constant probability (but not overwhelming).</p>

    <h5 id="sec-2" class="text-base font-semibold mt-4">Public transaction ledgers and BA for honest majority</h5>

    <p class="text-gray-300">Next, we focus on how a “robust public transaction ledger” can be built on top of the Bitcoin backbone. We instantiate the <span class="math">V(\\cdot),I(\\cdot),R(\\cdot)</span> functions so that parties form blockchains and act according to the following rules: each party (which in this context is called a “miner”) receives a set <span class="math">S</span> of transactions on its input tape and attempts to insert those in its blockchain, omitting any transactions in <span class="math">S</span> that are already included in it. (A Bitcoin transaction is, for example, a statement of the type “account <span class="math">A</span> credits account <span class="math">B</span> a <span class="math">z</span> number of bitcoins,” which is signed using the secret key that corresponds to account <span class="math">A</span>’s Bitcoin address; each account has a unique Bitcoin address.) Reading a blockchain, on the other hand, amounts to returning the total sequence of transactions that is contained in the blockchain of the miner (and note that miners may disagree about the chain they report).</p>

    <p class="text-gray-300">We show how the common prefix property and the chain quality property ensure two properties needed by the ledger, which we call <em>Persistence</em> and <em>Liveness</em>, assuming an honest majority and arbitrary adversarial behavior. Persistence states that once a transaction goes more than <span class="math">k</span> blocks “deep” into the blockchain of one honest player, then it will be included in <em>every honest player</em>’s blockchain with overwhelming probability, and it will be assigned a permanent position in the ledger. On the other hand, Liveness says that all transactions originating from honest account holders will eventually end up at a depth more than <span class="math">k</span> blocks in an honest player’s blockchain, and hence the adversary cannot perform a selective denial of service attack against honest account holders. For both properties to hold we require an honest majority (i.e., that the adversary’s hashing power is strictly less than <span class="math">50\\%</span>) assuming high network synchronicity (i.e., the duration of a round in terms of the number of computational steps the parties take towards finding a POW is close to <span class="math">0</span>). If this is violated, Persistence requires stricter bounds on adversarial hashing power in order to be preserved following the bounds of the common prefix property.</p>

    <p class="text-gray-300">In the context of Bitcoin, our analysis implies that the Bitcoin backbone provides an operational transaction ledger under the assumptions: (i) the adversary controls less than half of the total hashing power, and (ii) the network synchronizes much faster relative to the POW solution rate, (iii) digital signatures cannot be forged. On the other hand, when the network desynchronizes our results cannot support that the ledger is maintained by assuming an honest majority. This negative result is consistent with the experimental analysis provided by Decker and Wattenhoffer <em>[x11]</em>, who predicted a drop below <span class="math">50\\%</span> in the required adversarial bound for any setting when information propagation is problematic. Our result also provides some justification for the “slow” rate of 10-minute increments used in Bitcoin block generation. Specifically, information propagation in the Bitcoin network is on the order of seconds so the ratio (essentially <span class="math">f</span>) of this time window over the average 10-minute period is reasonably close to “small” and thus transaction persistence can be shown for roughly an honest majority. On the other hand, cryptocurrencies including Litecoin,</p>

    <p class="text-gray-300">Primecoin and others, reacting to the demand to offer faster transaction processing, opted for a faster response rate (some as small as 1 minute), which results in more precarious situations, e.g., <span class="math">f&gt;0.1</span>, which is far from being sufficiently close to 0 and thus cannot support our analysis that a common prefix would be guaranteed by merely assuming an honest majority. We finally note that the Persistence and Liveness properties we put forth and prove should not be interpreted as proofs that all Bitcoin’s objectives are met. In particular, they do not guarantee that miners are properly incentivized to carry out the backbone protocol, and they can only offer guarantees in a setting of an honest majority amongst a fixed number of players as opposed to a setting where there is an ever changing population of parties acting rationally; see related work below as well as Section 8 for further discussion.</p>

    <p class="text-gray-300">Next, we present a BA protocol assuming an honest majority, by suitably exploiting the properties of the robust transaction ledger above. The protocol substitutes Bitcoin’s transactions with a type of transactions that are themselves based on POWs, and hence uses POWs in two distinct ways: for the maintenance of the ledger and for the generation of the transactions. We show that the ledger’s Persistence implies Agreement, and that Liveness implies Validity, because assuming the ledger is maintained for long enough, a majority of transactions originating from the honest parties will be included (despite the fact that honest parties may control a minority of blocks in the blockchain). The protocol requires special care in the way it employs POWs since the adversary should be incapable of “shifting” work between the two POW tasks that it faces in each round. To solve this problem, we introduce a special strategy for POW-based protocol composition which we call “2-for-1 POWs.”</p>

    <h5 id="sec-3" class="text-base font-semibold mt-4">The Bitcoin backbone in the bounded-delay model.</h5>

    <p class="text-gray-300">In this version of the paper, we extend our analysis for the synchronous model with relative ease to the partially synchronous model <em>[x10, x35]</em>, where, in a nutshell, instead of messages sent in a round being guaranteed to arrive by the end of the round, there is an upper bound of <span class="math">\\Delta</span> rounds for each message delivery event that is unknown to the honest parties. This new analysis is presented in Section 7. The analysis shows that the protocol is secure provided the difficulty level is in a favorable relation with respect to <span class="math">\\Delta</span>. Treating <span class="math">\\Delta</span> as a separate parameter bounding the message passing delay enables to express the honest majority assumption also as a function of <span class="math">\\Delta</span> showing how approaching the 50% bound hinges on <span class="math">\\Delta</span> being sufficiently small.</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Related work.</h5>

    <p class="text-gray-300">Realizing a digital currency with a centralized entity but while achieving strong privacy was proposed early on by Chaum in <em>[x11]</em>. A number of other works improved various aspects of this concept, however the approach remained centralized. Nakamoto <em>[x24]</em> proposed the first decentralized currency system based on POWs while relaxing the anonymity property of the payment system to mere pseudonymity. This work was followed by a multitude of other related proposals including Litecoin, Ethereum, to mention a few. Our analysis of the Bitcoin backbone covers all these works as well, since they are based on exactly the same protocol.</p>

    <p class="text-gray-300">It is interesting to juxtapose our positive results to the results of Eyal and Sirer <em>[x16]</em>, who introduce an attack strategy called “selfish mining” that shows how the number of blocks contributed to the blockchain by an adversary can exceed the percentage of the hashing power the adversary possesses. Their results are consistent and complementary to ours. The crux of the issue is (in our terminology) in terms of the chain quality property, as its formulation is quite permissive: in particular we show that if the adversary controls a suitably bounded amount of hashing power, then it is also suitably bounded in terms of the number of blocks it has managed to insert in the blockchain that honest players maintain. Specifically, recall that we prove that the adversary may</p>

    <p class="text-gray-300">control at most a <span class="math">\\frac{t}{n-t}</span> percentage of the blocks in the chain. For instance, if the adversary has less than <span class="math">1/3</span> of the hashing power, then it will provably control less than <span class="math">50\\%</span> of the blocks in the honest players’ blockchain. As it can be easily seen, this does not guarantee that the rate of a party’s hashing power translates to an equal rate of rewards (recall that in Bitcoin the rewards are linearly proportional to the number of blocks that a party contributes in the chain). We define as ideal chain quality the property that for any coalition of parties (following any mining strategy) the percentage of blocks in the blockchain is exactly proportional to their collective hashing power, i.e. <span class="math">\\frac{t}{n}</span>. The chain quality property that we prove is not ideal and the results of [ES14] show that in fact there is a strategy that magnifies the percentage of a malicious coalition. Still, their mining attack does much worse than our bound. To close the gap, we sketch (cf. Remark 4) a simple selfish mining strategy that matches our upper bound and hence our chain quality result is tight in our model assuming the number of honest parties is large.</p>

    <p class="text-gray-300">Byzantine agreement (BA, aka “consensus”) [PSL80, LSP82] considers a set of <span class="math">n</span> parties connected by reliable and authenticated pair-wise communication links and with possible conflicting initial inputs that wish to agree on a common output in the presence of the disruptive (even malicious) behavior of some of them. The problem has received a considerable amount of attention under various models. In this paper we are interested in randomized solutions to the problem (e.g., [BO83, Rab83, BG93, FM97, FG03, KK09]) as in the particular setting we are in, deterministic BA algorithms are not possible. In more detail, we consider BA in the anonymous synchronous setting, i.e., when processors do not have identifiers and cannot correlate messages to their sources, even across rounds, and, further, there is no trusted setup nor a limit to the number of messages delivered per round. Okun, motivated by earlier work <em>[BSV+96]</em>, considered a slightly weaker model called “anonymous model without port awareness,” which matches the above except for imposing a limit on the number of messages per round and proved the aforementioned impossibility result, that deterministic algorithms are impossible for even a single failure [Oku05b, Oku05a]. In addition, Okun showed that probabilistic BA is feasible in his setting by suitably adapting Ben-Or’s protocol [BO83] for the standard, non-anonymous setting (cf. [Oku05b]) ; the protocol, however, takes exponentially many rounds. It turns out that by additionally assuming that the parties are “port-aware” (i.e., they can correlate messages to sources across rounds), deterministic protocols are possible and some more efficient solutions were proposed in [OB08].</p>

    <p class="text-gray-300">The anonymous synchronous setting for BA without limits on messages per round and hence prone to Sybil attacks [Dou02], was considered by Aspnes et al. [AJK05] who pointed to the potential usefulness of proofs of work (e.g., [DN92, RSW96, Bac97, JB99]) as an identity assignment tool, in such a way that the number of identities assigned to the honest and adversarial parties can be made proportional to their aggregate computational power, respectively. For example, by assuming that the adversary’s computational power is less than <span class="math">50\\%</span>, one of the algorithms in [AJK05] results in a number of adversarial identities less than half of that obtained by the honest parties. By running this procedure in a pre-processing stage, it is then suggested that a standard authenticated BA protocol could be run. Such protocols, however, would require the establishment of a consistent PKI (as well as of digital signatures), details of which are not laid out in [AJK05].</p>

    <p class="text-gray-300">In contrast, and as mentioned above, building on our analysis of the Bitcoin backbone proto</p>

    <p class="text-gray-300">col, we propose two BA protocols solely based on POWs that operate in <span class="math">O(k)</span> rounds with error probability <span class="math">e^{-\\Omega(k)}</span>. The protocols solve BA with overwhelming probability under the assumption that the adversary controls less than <span class="math">1/3</span> and <span class="math">1/2</span> of the computational power, respectively.</p>

    <p class="text-gray-300">The connection between Bitcoin and probabilistic BA was also considered by Miller and LaViola in <em>[x14]</em> where they take a different approach compared to ours, by not formalizing how Bitcoin works, but rather only focusing on Nakamoto’s suggestion for BA <em>[x15]</em> as a standalone protocol. As we observe here, and also recognized in <em>[x14]</em>, Nakamoto’s protocol does not quite solve BA since it does not satisfy Validity with overwhelming probability. The exact repercussions of this fact are left open in <em>[x14]</em>, while with our analysis, we provide explicit answers regarding the transaction ledger’s actual properties and the level of security that the Bitcoin backbone realization can offer.</p>

    <p class="text-gray-300">We refer to <em>[x6]</em> for a systematized overview of the consensus problem in the context of blockchain protocols.</p>

    <p class="text-gray-300">Finally, related to the anonymous setting, the feasibility of secure computation without authenticated links was considered by Barak et al. in <em>[BCL^{+}11]</em> in a more extreme model where all messages sent by the parties are controlled by the adversary and can be tampered with and modified (i.e., not only source addresses can be “spoofed,” but also messages’ contents can be altered and messages may not be delivered). It is shown in <em>[BCL^{+}11]</em> that it is possible to limit the adversary so that all he can do is to partition the network into disjoint sets, where in each set the computation is secure, and also independent of the computation in the other sets. Evidently, in such system, one cannot hope to build a global ledger.</p>

    <p class="text-gray-300">Summary of differences with <em>[x5]</em>. The most important difference in the current version of the paper compared to the original one <em>[x5]</em> is the complete rewrite of all our proofs, which now follow a much more streamlined and easier presentation. In particular, this version incorporates the concept of a typical execution that we have in fact introduced in <em>[x5, x6]</em> (analysis of the backbone protocol with chains of variable difficulty) and which greatly simplifies our probabilistic analysis, concentrating it on a single theorem (specifically, Theorem 10, showing that most executions are typical).</p>

    <p class="text-gray-300">The present version also includes the explicit treatment of security against adaptive adversaries, showing how to reduce the analysis to the case of static adversaries (Section 4.4). We also present an analysis of the Bitcoin backbone protocol in the partially synchronous model <em>[x2]</em> against static adversaries, where an unknown upper bound is imposed on message delivery (cf. Section 7). This model was considered by Pass et al. <em>[x13]</em>; nevertheless, here we show how our model can also extend to the bounded-delay setting and our proof strategy using typical executions can provide a simple security proof. This suggests that the notion of typical executions of <em>[x5, x6]</em> and the associated analysis approach are useful tools with the potential of wider applicability in the analysis of blockchain protocols.</p>

    <p class="text-gray-300">In the current version we refer to the length of the hash function output <span class="math">\\kappa</span> as the (sole) security parameter, and refer to <span class="math">\\lambda</span>—typically the number of consecutive rounds for which a statement would hold—as the tail-bounds parameter. This way, making <span class="math">\\lambda</span> polylogarithmic in the security parameter (e.g., <span class="math">\\Omega(\\log^{2}(\\kappa))</span>) allows us to clearly express how blockchain properties and applications (e.g., consensus) are satisfied except with negligible probability after that many rounds.</p>

    <p class="text-gray-300">Organization of the paper. The rest of the paper is organized as follows. In Section 2 we present our model within which we formally express the Bitcoin backbone protocol and prove its basic properties. The backbone protocol builds “blockchains” based on a cryptographic hash function; we introduce notation for this data structure as well as the backbone protocol itself in Section 3, followed by its analysis in Section 4. Sections 5 and 6 are dedicated to the applications</p>

    <p class="text-gray-300">built on top of the backbone protocol—(simple) BA protocols and a robust transaction ledger, respectively. Specifically, Section 5 covers Nakamoto’s (insufficient) suggestion for BA as well as our solution for 1/3 adversarial power, while in Section 6 we present our treatment of a robust public ledger (Section 6.1) formalizing the properties of Persistence and Liveness and how they apply to Bitcoin (Section 6.2). We also include in this section (Section 6.3) our BA protocol for 1/2 adversarial power. The extension of our analysis to the partially synchronous model is presented in Section 7, while some directions for future research are offered in Section 8.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Model and Definitions</h2>

    <p class="text-gray-300">In this section we define our notion of protocol execution and provide a definition of Byzantine agreement in our model. We will describe and analyze our protocols in a multiparty setting that employs elements from previous formulations of secure multiparty computation (specifically, Canetti’s formulation of “real world” execution as in <em>[x1]</em> and <em>[x2, x3]</em>). We adopt the notation and definitions of <em>[x1, x2]</em> while we also employ ideas regarding the formulation of synchronous, proceeding in rounds, multiparty computation from <em>[x10]</em>.</p>

    <p class="text-gray-300">Programs involved in a protocol execution. The execution of a protocol <span class="math">\\Pi</span> is driven by an “environment” program <span class="math">\\mathcal{Z}</span> that may spawn multiple instances running the protocol <span class="math">\\Pi</span>. The programs in question can be thought of as “interactive Turing machines” (ITM) that have communication, input and output tapes. An instance of an ITM running a certain program will be referred to as an interactive Turing machine instance or ITI. The spawning of new ITI’s by an existing ITI as well as the interaction between them is at the discretion of a control program which is also an ITM and is denoted by <span class="math">C</span>. The pair <span class="math">(\\mathcal{Z},C)</span> is called a system of ITM’s, cf. <em>[x1]</em>. As in this latter paper we will be restricting our exposition to “locally polynomial-bounded” systems of ITM’s which ensures a polynomial-time execution overall <em>[x1, Proposition 3]</em>. Moreover, we will be using a more stringent control program <span class="math">C</span> that will be forcing the environment to perform a “round-robin” participant execution sequence for a fixed set of parties.</p>

    <p class="text-gray-300">Specifically, the execution driven by <span class="math">\\mathcal{Z}</span> is defined with respect to a protocol <span class="math">\\Pi</span>, an adversary <span class="math">\\mathcal{A}</span> (also an ITM) and a set of parties <span class="math">P_{1},\\ldots,P_{n}</span>; these are hardcoded in the control program <span class="math">C</span>. The protocol <span class="math">\\Pi</span> is defined in a “hybrid” setting and has access to two “ideal functionalities,” which are two other ITM’s to be defined below, called the random oracle and the diffusion channel. They are used as subroutines by the programs involved in the execution (the ITI’s of <span class="math">\\Pi</span> and <span class="math">\\mathcal{A}</span>) and they are accessible by all parties once they are spawned.</p>

    <p class="text-gray-300">Initially, the environment <span class="math">\\mathcal{Z}</span> is restricted by <span class="math">C</span> to spawn the adversary <span class="math">\\mathcal{A}</span>. Each time the adversary is activated, it may send one or more messages of the form <span class="math">(\\mathsf{Corrupt},P_{i})</span> to <span class="math">C</span>. The control program <span class="math">C</span> will register party <span class="math">P_{i}</span> as corrupted, only provided that the environment has previously given an input of the form <span class="math">(\\mathsf{Corrupt},P_{i})</span> to <span class="math">\\mathcal{A}</span> and that the number of corrupted parties is less or equal <span class="math">t</span>, a bound that is also hardcoded in <span class="math">C</span>. The first ITI party to be spawned running protocol <span class="math">\\Pi</span> is restricted by <span class="math">C</span> to be party <span class="math">P_{1}</span>. After a party <span class="math">P_{i}</span> is activated, the environment is restricted to activate party <span class="math">P_{i+1}</span>, except when <span class="math">P_{n}</span> is activated in which case the next ITI to be activated is always the adversary <span class="math">\\mathcal{A}</span>. Note that when a corrupted party <span class="math">P_{i}</span> is activated the adversary <span class="math">\\mathcal{A}</span> is activated instead.</p>

    <p class="text-gray-300">Communication and “hashing power.” We describe next the two functionalities that are accessible to the parties. These functionalities will reflect the parties’ ability (i) to communicate with each other and (ii) to calculate values of a hash function <span class="math">H(\\cdot):\\{0,1\\}^{*}\\to\\{0,1\\}^{\\kappa}</span> concurrently. We note that they share a state and thus they can be viewed as a single functionality, nevertheless it is convenient to describe them as separate entities.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The random oracle (RO) functionality. When queried by honest party <span class="math">P_{i}</span> with a value <span class="math">x</span> marked for “calculation” for the function <span class="math">H(\\cdot)</span>, assuming <span class="math">x</span> has not been queried before, it returns a value <span class="math">y</span> which is selected at random from <span class="math">\\{0,1\\}^{\\kappa}</span>; furthermore, it stores the pair <span class="math">(x,y)</span> in the table of <span class="math">H(\\cdot)</span>. Each honest party <span class="math">P_{i}</span> is allowed to ask <span class="math">q</span> queries in each round as determined by the “diffuse” functionality (see below). On the other hand, each honest party is given unlimited queries for “verification” for the function <span class="math">H(\\cdot)</span>. In a similar vein, the adversary <span class="math">\\mathcal{A}</span> is given <span class="math">t^{\\prime}\\cdot q</span> queries in each round as determined by the diffuse functionality where <span class="math">t^{\\prime}</span> is the number of corrupted parties. No verification queries are provided to <span class="math">\\mathcal{A}</span>. Note that <span class="math">q</span> is a function of <span class="math">\\kappa</span>. We note that the functionality may maintain tables for functions other than <span class="math">H(\\cdot)</span> as well (for instance, in our protocol descriptions, we will utilise a function <span class="math">G(\\cdot)</span>), but, by convention the functionality will impose query quotas to function <span class="math">H(\\cdot)</span> only.</li>

      <li>The diffuse functionality. Initially, the functionality sets a variable <span class="math">round</span> to be <span class="math">1</span>. It also maintains a Receive() string defined for each party <span class="math">P_{i}</span>. A party is allowed at any moment to fetch the contents of its personal Receive() string. Moreover, when the functionality receives an instruction to diffuse a message <span class="math">m</span> from party <span class="math">P_{i}</span> it marks the party as complete for the current round; note that <span class="math">m</span> is allowed to be empty. At any moment, the adversary <span class="math">\\mathcal{A}</span> is allowed to receive the contents of all messages for the round and specify the contents of the Receive() string for each party <span class="math">P_{i}</span>. The adversary has to specify when it is complete for the current round. When all parties are complete for the current round, the functionality inspects the contents of all Receive() strings and includes any messages <span class="math">m</span> that were diffused by the parties in the current round but not contributed by the adversary to the Receive() tapes. The variable <span class="math">round</span> is then incremented.</li>

    </ul>

    <p class="text-gray-300">We note that by adopting the resource bounded computation modeling of systems of ITM’s by <em>[x10, x11]</em> we obviate the need of imposing a strict upper bound on the number of messages that may be transmitted by the adversary in each activation. In our setting, honest parties, at the discretion of the environment, are given sufficient time to process all messages delivered via the diffuse functionality including all messages that are injected by the adversary. This is also facilitated by the fact that the <span class="math">q</span> bound that is imposed on queries to <span class="math">H(\\cdot)</span> is not imposed for hash verification (with foresight, the <span class="math">q</span>-bound will be only imposed for hash computations during the proof of work stage of the protocol).</p>

    <p class="text-gray-300">Note that the above formulation also reflects the fact that the communication graph is not fully connected and messages are delivered through “diffusion”, a communication means that reflects Bitcoin’s peer-to-peer structure. As evidenced by the above, our adversarial model in the network is “adaptive,” meaning that the adversary is allowed to take control of parties on the fly, and “rushing,” meaning that in any given round the adversary gets to see all honest players’ messages before deciding his strategy, and, furthermore, there is no definite source information that can be guaranteed for each delivered message. Note that the adversary cannot change the contents of the messages sent by honest parties nor prevent them from being delivered as restricted by the diffuse functionality. Effectively, this parallels communication over TCP/IP in the Internet where messages between parties are delivered reliably, but nevertheless malicious parties may “spoof” the source of a message they transmit and make it appear as originating from an arbitrary party (including another honest party) in the view of the receiver. Note that the adversary is permitted to abuse the diffusion mechanism and attempt to confuse honest parties by sending and delivering inconsistent messages to them (thus diffuse does not constitute a reliable broadcast).</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The parties’ inputs are provided by the environment <span class="math">\\mathcal{Z}</span> which also receives the parties’ outputs. Parties that receive no input from the environment remain inactive, in the sense that they will not act when their turn comes in each round. The environment activates parties in each round by writing to their input tape. Note that <span class="math">C</span> forces the environment to give all parties an activation in round-robin fashion. In our exposition we will denote by Input() the input tape of each party.</p>

    <p class="text-gray-300">The <span class="math">q</span>-bounded synchronous setting. Based on the above, we can now use the notation <span class="math">\\{\\mathrm{exec}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}(z)\\}_{z\\in\\{0,1\\}^{<em>}}</span> to denote the random variable ensemble that determines the output of the environment <span class="math">\\mathcal{Z}</span> on input <span class="math">z</span> for a protocol <span class="math">\\Pi</span> that uses the two functionalities of random oracle and diffuse (we will only be concerned with such protocols). Moreover, we will use the notation <span class="math">\\{\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}(z)\\}_{z\\in\\{0,1\\}^{</em>}}</span> to denote the random variable ensemble describing the view of party <span class="math">P</span> after the completion of an execution with environment <span class="math">\\mathcal{Z}</span>, running protocol <span class="math">\\Pi</span>, and adversary <span class="math">\\mathcal{A}</span>, on auxiliary input <span class="math">z\\in\\{0,1\\}^{*}</span>.</p>

    <p class="text-gray-300">In our exposition we are concerned with a “stand-alone” execution of <span class="math">\\Pi</span> and thus we will consider <span class="math">z</span> to be fixed to <span class="math">1^{\\kappa}</span> for <span class="math">\\kappa\\in\\mathbb{N}</span>. For this reason we will simply refer to the ensemble by <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P,t,n}</span>. If <span class="math">n</span> parties <span class="math">P_{1},\\ldots,P_{n}</span> execute <span class="math">\\Pi</span>, the concatenation of the view of all parties <span class="math">\\langle\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{P_{i},t,n}\\rangle_{i=1,\\ldots,n}</span> is denoted by <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span>. With foresight, we note that, in contrast to the standard setting where parties are aware of the number of parties executing the protocol, we are interested in protocols <span class="math">\\Pi</span> that do not make explicit use of the number of parties <span class="math">n</span> or their identities. Further, note that because of the unauthenticated nature of the communication model the parties may never be certain about the number of participants in a protocol execution. Nonetheless note that the number of parties is fixed during the course of the protocol execution, as this is hardcoded in the control program <span class="math">C</span>.</p>

    <p class="text-gray-300">The parties’ limited ability to produce POWs is reflected in the limit imposed to all parties in their access of the function <span class="math">H(\\cdot)</span>. Parties are allowed to perform a number of queries <span class="math">q</span> per round. We remark that this is a “flat-model” interpretation of the parties’ computation power, where all parties are assumed equal. In the real world, different honest parties may have different “hashing power;” nevertheless, our flat-model does not sacrifice generality since one can imagine that real honest parties are simply clusters of some arbitrary number of honest flat-model parties. The adversary <span class="math">\\mathcal{A}</span> is allowed to perform <span class="math">t^{\\prime}\\cdot q</span> queries per round, where <span class="math">t^{\\prime}\\leq t</span> is the number of corrupted parties. The environment <span class="math">\\mathcal{Z}</span>, on the other hand, is not permitted any queries to <span class="math">H(\\cdot)</span>. The rationale for this, is that we would like to bound the “CPU power” <em>[x20]</em> of the adversary to be proportionate to the number of parties it controls while making it infeasible for them to be aided by external sources or by transferring the hashing power potentially invested in concurrent or previous protocol executions. This underscores the fact that our analysis is in the standalone setting, where a single protocol instance is executed in isolation.</p>

    <p class="text-gray-300">We will refer to all the above restrictions on the environment, the parties and the adversary as the <span class="math">q</span>-bounded synchronous setting.</p>

    <p class="text-gray-300">Properties of protocols. In our theorems we will be concerned with properties of protocols <span class="math">\\Pi</span> in the <span class="math">q</span>-bounded synchronous setting. Such properties will be defined as predicates over the random variable <span class="math">\\mathrm{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n}</span> by quantifying over all possible adversaries <span class="math">\\mathcal{A}</span> and environments <span class="math">\\mathcal{Z}</span> that are polynomially bounded. Note that all our protocols will only satisfy properties with a small probability of error in <span class="math">\\kappa</span> as well as in potentially other parameters. The probability space is determined by the random choices of the random oracle functionality as well as the private coins of all ITI’s.</p>

    <p class="text-gray-300">##</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">Given a predicate <span class="math">Q</span> and a bound <span class="math">q,t,n\\in\\mathbb{N}</span> with <span class="math">t&lt;n</span>, we say that <em>the protocol</em> <span class="math">\\Pi</span> <em>satisfies property <span class="math">Q</span> in the <span class="math">q</span>-bounded setting for <span class="math">n</span> parties assuming the number of corruptions is bounded by <span class="math">t</span>,</em> provided that for all polynomial-time <span class="math">\\mathcal{Z},\\mathcal{A}</span>, the probability that <span class="math">Q(\\textsc{view}_{\\Pi,\\mathcal{A},\\mathcal{Z}}^{t,n})</span> is false is negligible in <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300">Note that we will only consider properties that are polynomial-time computable predicates.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Byzantine agreement.</h6>

    <p class="text-gray-300">As a simple illustration of the formulation above we define the properties of a Byzantine agreement (BA) protocol.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> solves BA in the <span class="math">q</span>-bounded synchronous setting provided it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Agreement.</em> There is a round after which all honest parties return the same output if queried by the environment.</li>

      <li><em>Validity.</em> The output returned by an honest party <span class="math">P</span> equals the input of some party <span class="math">P^{\\prime}</span> at round <span class="math">1</span> that is honest at the round <span class="math">P</span>’s output is produced.</li>

    </ul>

    <p class="text-gray-300">We note that in our protocols, the participants are capable of detecting agreement and furthermore they can also detect whether other parties detect agreement, thus <em>termination</em> can be easily achieved by all honest parties. In the traditional cryptographic setting with no trusted setup, it is known that the problem does not have a solution if <span class="math">t\\geq\\frac{n}{3}</span> <em>[x1]</em>. Interestingly, one of our POW-based BA protocols works for <span class="math">t&lt;\\frac{n}{2}</span>, assuming only a simultaneous start without a PKI, the same bound that is achievable when a PKI is available.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The formulation of Validity above is intended to capture security/correctness against adaptive adversaries. The notion (specifically, the requirement that the output value be one of the honest parties’ inputs) has also been called “Strong Validity” <em>[x12]</em>, but the distinction is only important in the case of non-binary inputs. In either case, it is known that in the synchronous cryptographic setting with trusted setup the problem has a solution if and only if $n></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t<span class="math">, where </span>V$ is the input/decision domain <em>[x5]</em>. Our POW-based protocol also achieves this bound.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">One may consider a model where a certain percentage of the honest parties is not always able to receive all messages broadcast on the network. We point out that such a situation is subsumed by our adversarial model: simply we let the adversary control these players and simulate them honestly while dropping messages from their incoming tape arbitrarily. Of course, to apply the theorems we prove, one should adjust the total power of the adversary accordingly and add these parties to the adversarial ones.</p>

    <h2 id="sec-10" class="text-2xl font-bold">3 The Bitcoin Backbone Protocol</h2>

    <p class="text-gray-300">We start by introducing blockchain notation. Let <span class="math">G(\\cdot),H(\\cdot)</span> be cryptographic hash functions with output in <span class="math">\\{0,1\\}^{\\kappa}</span>. A <em>block</em> is any triple of the form <span class="math">B=\\langle s,x,ctr\\rangle</span> where <span class="math">s\\in\\{0,1\\}^{\\kappa},x\\in\\{0,1\\}^{*},ctr\\in\\mathbb{N}</span> are such that satisfy predicate <span class="math">\\textsf{validblock}_{q}^{T}(B)</span> defined as</p>

    <p class="text-gray-300"><span class="math">(H(ctr,G(s,x))&lt;T)\\wedge(ctr\\leq q).</span></p>

    <p class="text-gray-300">The parameter <span class="math">T\\in\\mathbb{N}</span> is also called the block’s <em>difficulty level</em>. The parameter <span class="math">q\\in\\mathbb{N}</span> is a bound that in the Bitcoin implementation determines the size of the register <span class="math">ctr</span>; in our treatment we allow this to be arbitrary, and use it to denote the maximum allowed number of hash queries in a round. We do this for convenience and our analysis applies in a straightforward manner to the case that <span class="math">ctr</span> is restricted to the range <span class="math">0\\leq ctr&lt;2^{32}</span> and <span class="math">q</span> is independent of <span class="math">ctr</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">A blockchain, or simply a chain is a sequence of blocks. The rightmost block is the head of the chain, denoted <span class="math">\\mathrm{head}(\\mathcal{C})</span>. Note that the empty string <span class="math">\\varepsilon</span> is also a chain; by convention we set <span class="math">\\mathrm{head}(\\varepsilon) = \\varepsilon</span>. A chain <span class="math">\\mathcal{C}</span> with <span class="math">\\mathrm{head}(\\mathcal{C}) = \\langle s&#x27;, x&#x27;, c t r&#x27; \\rangle</span> can be extended to a longer chain by appending a valid block <span class="math">B = \\langle s, x, c t r \\rangle</span> that satisfies <span class="math">s = H(ctr&#x27;, G(s&#x27;, x&#x27;))</span>. In case <span class="math">\\mathcal{C} = \\varepsilon</span>, by convention any valid block of the form <span class="math">\\langle s, x, c t r \\rangle</span> may extend it. In either case we have an extended chain <span class="math">\\mathcal{C}_{\\mathrm{new}} = \\mathcal{C}B</span> that satisfies <span class="math">\\mathrm{head}(\\mathcal{C}_{\\mathrm{new}}) = B</span>.</p>

    <p class="text-gray-300">The length of a chain <span class="math">\\mathrm{len}(\\mathcal{C})</span> is its number of blocks. Given a chain <span class="math">\\mathcal{C}</span> that has length <span class="math">\\mathrm{len}(\\mathcal{C}) = n &amp;gt; 0</span> we can define a vector <span class="math">\\mathbf{x}_{\\mathcal{C}} = \\langle x_1, \\ldots, x_n \\rangle</span> that contains all the <span class="math">x</span>-values that are stored in the chain such that <span class="math">x_i</span> is the value of the <span class="math">i</span>-th block.</p>

    <p class="text-gray-300">Consider a chain <span class="math">\\mathcal{C}</span> of length <span class="math">m</span> and any nonnegative integer <span class="math">k</span>. We denote by <span class="math">\\mathcal{C}^{\\lceil k \\rceil}</span> the chain resulting from the "pruning" the <span class="math">k</span> rightmost blocks. Note that for <span class="math">k \\geq \\mathrm{len}(\\mathcal{C})</span>, <span class="math">\\mathcal{C}^{\\lceil k \\rceil} = \\varepsilon</span>. If <span class="math">\\mathcal{C}_1</span> is a prefix of <span class="math">\\mathcal{C}_2</span> we write <span class="math">\\mathcal{C}_1 \\preceq \\mathcal{C}_2</span>.</p>

    <p class="text-gray-300">We note that Bitcoin uses chains of variable difficulty, i.e., the value <span class="math">T</span> may change across different blocks within the same chain according to some rule that is determined by the <span class="math">x</span> values stored in the chain<span class="math">^9</span>. This is done to account for the fact that the number of parties (and hence the total hashing power of the system) is variable from round to round (as opposed to the unknown but fixed number of parties <span class="math">n</span> we assume). See Section 8 for further discussion. We are now ready to describe the protocol.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.1 The backbone protocol</h2>

    <p class="text-gray-300">The Bitcoin backbone protocol is executed by an arbitrary number of parties over an unauthenticated network. For concreteness, we assume that the number of parties running the protocol is <span class="math">n</span>; however, parties need not be aware of this number when they execute the protocol. As mentioned in Section 2, communication over the network is achieved by utilizing a send-to-all BROADCAST functionality that is available to all parties (and maybe abused by the adversary in the sense of delivering different messages to different parties). Each party maintains a blockchain, as defined above, starting from the empty chain and mining a block that contains the value <span class="math">s = 0</span> (by convention this is the "genesis block")<span class="math">^{10}</span>. Each party's chain may be different, but, as we will prove, under certain well-defined conditions, the chains of honest parties will share a large common prefix. (Figure 2 depicts the local view of each party as well as the shared portion of their chains.)</p>

    <p class="text-gray-300">In the protocol description we intentionally avoid specifying the type of values that parties try to insert in the chain, the type of chain validation they perform (beyond checking for its structural properties with respect to the hash functions <span class="math">G(\\cdot), H(\\cdot)</span>), and the way they interpret the chain. In our description, these actions are abstracted by the external functions <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span> which are specified by the application that runs "on top" of the backbone protocol. We will purposely leave these functions undetermined in our description assuming they conform to the following specifications. We will provide explicit instantiations of them in Section 5. Briefly, they are described as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Content validation predicate <span class="math">V(\\cdot)</span>. The content validation predicate receives as input the content of a chain <span class="math">\\mathcal{C}</span>, denoted by <span class="math">\\mathbf{x}_{\\mathcal{C}}</span>, and will return 1 if and only if the contents are consistent with the intended application implemented on top of the chain. In its simplest form, <span class="math">V(\\cdot)</span> can ensure that the elements of <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> are of the proper type.</li>

    </ul>

    <p class="text-gray-300"><span class="math">^9</span>In Bitcoin every 2016 blocks the difficulty is recalibrated according to the time-stamps stored in the blocks so that the block generation rate remains at approximately 10 minutes per block.</p>

    <p class="text-gray-300"><span class="math">^{10}</span>Alternatively, <span class="math">s</span> can point to an actual block that contains some trusted setup information (in the case of Bitcoin the genesis block contains the string "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"). Our analysis however is in the standalone setting and thus we choose the simplest possible genesis block.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 2: Overview of the basic operation of the Bitcoin backbone protocol. Miner  <span class="math">M_1</span>  receives from the environment a READ instruction that results in the application of the  <span class="math">R(\\cdot)</span>  function on the contents of its chain which are equal to the vector  <span class="math">\\langle x_1, x_2, x_3, x_4, x_5 \\rangle</span> . Miner  <span class="math">M_2</span>  receives from the environment an INSERT instruction and uses the function  <span class="math">I(\\cdot)</span>  to determine the value  <span class="math">y_5</span>  that it subsequently successfully inserts in its local block chain by solving a proof of work; this results in a broadcast of the newly extended chain. Finally miner  <span class="math">M_3</span>  receives the newly extended chain and validates it both structurally as well as using the content validation predicate  <span class="math">V(\\cdot)</span> .  <span class="math">M_3</span>  will adopt this chain if  <span class="math">M_3</span>  deems it better than its local chain as specified by the backbone protocol. Note that the joint view of  <span class="math">M_1, M_2, M_3</span>  is inconsistent but there is agreement on the prefix  <span class="math">\\langle x_1, x_2, x_3 \\rangle</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input contribution function  <span class="math">I(\\cdot)</span> . It receives as input a tuple,  <span class="math">(st, \\mathcal{C}, \\text{round}, \\text{INPUT}()</span> , RECEIVE()) that stands respectively for state data  <span class="math">st</span> , current chain  <span class="math">\\mathcal{C}</span> , current round round, contents of input tape INPUT() and contents of network tape RECEIVE(). Given these, it will produce an updated state  <span class="math">st&#x27;</span>  as well as an input  <span class="math">x</span>  that should be the next input to be inserted in a block. For instance,  <span class="math">I(\\cdot)</span>  can be as simple as copying the contents of the input tape into  <span class="math">x</span>  and keeping  <span class="math">st = \\epsilon</span> , or performing a more complex operation that involves parsing  <span class="math">\\mathcal{C}</span>  or even maintaining old input values that have not yet been processed as part of the state  <span class="math">st</span> .</li>

      <li>Chain reading function  <span class="math">R(\\cdot)</span> . It receives as input a chain  <span class="math">\\mathcal{C}</span>  and provides an interpretation of it. In the simplest case it can be just returning  <span class="math">x_{\\mathcal{C}}</span>  and leaving it to the callee to process the contents of the chain.</li>

    </ul>

    <p class="text-gray-300">In general our treatment will be independent of the exact operation of  <span class="math">V, I, R</span>  apart from requiring the following minimal set of conditions.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input Validity. The input contribution function should produce values that are deemed acceptable by the content validation predicate. Formally, for any chain  <span class="math">\\mathcal{C}</span>  with  <span class="math">\\mathbf{x}_{\\mathcal{C}} = \\langle x_1,\\ldots ,x_n\\rangle</span>  the value  <span class="math">x</span>  produced by an invocation of  <span class="math">I(\\cdot ,\\mathcal{C},\\cdot ,\\cdot ,\\cdot)</span>  should satisfy  <span class="math">V(\\langle x_{1},\\dots,x_{n},x\\rangle) = 1</span>  By convention,  <span class="math">V(\\varepsilon) = 1</span></li>

    </ol>

    <p class="text-gray-300">Algorithm 1 The chain validation predicate, parameterized by  <span class="math">q, T</span> , the hash functions  <span class="math">G(\\cdot), H(\\cdot)</span>  and the content validation predicate  <span class="math">V(\\cdot)</span> . The input is  <span class="math">\\mathcal{C}</span> .</p>

    <p class="text-gray-300">|  1: function validate(C)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: b← V(xC)  |   |</p>

    <p class="text-gray-300">|  3: if b ∧ (C ≠ ε) then ▷ The chain is non-empty and meaningful w.r.t. V(·)  |   |</p>

    <p class="text-gray-300">|  4: ⟨s, x, ctr⟩ ← head(C)  |   |</p>

    <p class="text-gray-300">|  5: s' ← H(ctr, G(s, x))  |   |</p>

    <p class="text-gray-300">|  6: repeat  |   |</p>

    <p class="text-gray-300">|  7: ⟨s, x, ctr⟩ ← head(C)  |   |</p>

    <p class="text-gray-300">|  8: if validblockqT(⟨s, x, ctr⟩) ∧ (H(ctr, G(s, x)) = s') then  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: s' ← s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Retain hash value</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  11: else  |   |</p>

    <p class="text-gray-300">|  12: b ← False  |   |</p>

    <p class="text-gray-300">|  13: end if  |   |</p>

    <p class="text-gray-300">|  14: until (C = ε) ∨ (b = False)  |   |</p>

    <p class="text-gray-300">|  15: end if  |   |</p>

    <p class="text-gray-300">|  16: return (b)  |   |</p>

    <p class="text-gray-300">|  17: end function  |   |</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input Entropy. The probability of the event that two independent invocations of  <span class="math">I(st, \\mathcal{C}, \\text{round}, v, w)</span> , where  <span class="math">st, \\mathcal{C}, \\text{round}, v, w</span>  are arbitrary values consistent with the input of  <span class="math">I(\\cdot)</span> , result in the same output value  <span class="math">x</span>  is negligible in  <span class="math">\\kappa</span> .</li>

    </ol>

    <p class="text-gray-300">The Bitcoin backbone protocol is specified as Algorithm 4. Before describing it in detail we first introduce the protocol's three supporting algorithms.</p>

    <p class="text-gray-300">Chain validation. The first algorithm, called validate performs a validation of the structural properties of a given chain  <span class="math">\\mathcal{C}</span> , cf. Algorithm 1. It is given as input the values  <span class="math">q</span>  and  <span class="math">T</span> , as well as a hash function  <span class="math">H(\\cdot)</span> . It is parameterized by the content validation predicate  <span class="math">V(\\cdot)</span> . For each block of the chain, the algorithm checks that the proof of work is properly solved, that the counter  <span class="math">ctr</span>  does not exceed  <span class="math">q</span>  and that the hash of the previous block is properly included in the block. It further collects all the inputs from the chain's blocks and assembles them into a vector  <span class="math">\\mathbf{x}_{\\mathcal{C}}</span> . If all blocks verify and  <span class="math">V(\\mathbf{x}_{\\mathcal{C}})</span>  is true then the chain is valid; otherwise it is rejected. As mentioned we purposely leave the predicate  <span class="math">V(\\cdot)</span>  undetermined.</p>

    <p class="text-gray-300">Chain comparison. The objective of the second algorithm, called maxvalid, is to find the "best possible" chain when given a set of chains, cf. Algorithm 2. The algorithm is straightforward and is parameterized by a  <span class="math">\\max(\\cdot)</span>  function that applies some ordering in the space of chains. The most important aspect is the chains' length, in which case  <span class="math">\\max(\\mathcal{C}_1, \\mathcal{C}_2)</span>  will return the longest of the two. In case  <span class="math">\\mathrm{len}(\\mathcal{C}_1) = \\mathrm{len}(\\mathcal{C}_2)</span> , some other characteristic can be used to break the tie. In our case,  <span class="math">\\max(\\cdot, \\cdot)</span>  will always return the first operand <span class="math">^{11}</span> ; alternatively, other options exist, such as</p>

    <p class="text-gray-300">Algorithm 2 The function that finds the "best" chain, parameterized by function  <span class="math">\\max(\\cdot)</span> . The input is  <span class="math">\\{\\mathcal{C}_1, \\ldots, \\mathcal{C}_k\\}</span> .</p>

    <p class="text-gray-300">1: function maxvalid  <span class="math">(\\mathcal{C}_1,\\dots ,\\mathcal{C}_k)</span> 2: temp  <span class="math">\\leftarrow \\varepsilon</span> 3: for  <span class="math">i = 1</span>  to  <span class="math">k</span>  do 4: if validate  <span class="math">(\\mathcal{C}_i)</span>  then 5: temp  <span class="math">\\leftarrow</span>  max  <span class="math">(\\mathcal{C}_i, temp)</span> 6: end if 7: end for 8: return temp 9: end function</p>

    <p class="text-gray-300">lexicographic order or picking a chain at random. The analysis we will perform will essentially be independent of the tie-breaking rule <span class="math">^{12}</span> .</p>

    <p class="text-gray-300">Proof of work. The third algorithm, called pow, is the main "workhorse" of the backbone protocol, cf. Algorithm 3. It takes as input a chain and attempts to extend it via solving a proof of work. This algorithm is parameterized by two hash functions  <span class="math">H(\\cdot), G(\\cdot)</span>  (which in our analysis will be modeled as random oracles),[13] as well as two positive integers  <span class="math">q, T</span> ;  <span class="math">q</span>  represents the number of times the algorithm is going to attempt to brute-force the hash function inequality that determines the POW instance, and  <span class="math">T</span>  determines the "difficulty" of the POW. The algorithm works as follows. Given a chain  <span class="math">\\mathcal{C}</span>  and a value  <span class="math">x</span>  to be inserted in the chain, it hashes these values to obtain  <span class="math">h</span>  and initializes a counter  <span class="math">ctr</span> . Subsequently, it increments  <span class="math">ctr</span>  and checks to see whether  <span class="math">H(ctr, h) &amp;lt; T</span> ; this is the only invocation of  <span class="math">H(\\cdot)</span>  that is subject to the bound  <span class="math">q</span> . If a suitable  <span class="math">ctr</span>  is found then the algorithm succeeds in solving the POW and extends chain  <span class="math">\\mathcal{C}</span>  by one block inserting  <span class="math">x</span>  as well as  <span class="math">ctr</span>  (which serves as the POW). If no suitable  <span class="math">ctr</span>  is found, the algorithm simply returns the chain unaltered. (See Algorithm 3.)</p>

    <p class="text-gray-300">The backbone protocol. Given the three algorithms above, we are now ready to describe the Bitcoin backbone protocol, cf. Algorithm 4. This is the protocol that is executed by the miners and which is assumed to run "indefinitely" (our security analysis will apply when the total running time is polynomial in  <span class="math">\\kappa</span> ). It is parameterized by two functions, the input contribution function  <span class="math">I(\\cdot)</span>  and the chain reading function  <span class="math">R(\\cdot)</span> , which is applied to the values stored in the chain.</p>

    <p class="text-gray-300">Each miner starts a round with a local chain  <span class="math">\\mathcal{C}</span>  (we say that the miner has chain  <span class="math">\\mathcal{C}</span>  at this round) and checks its communication tape RECEIVE() to see whether a "better" chain has been received and in such case it adopts it resulting in chain  <span class="math">\\tilde{\\mathcal{C}}</span>  (we say that the miner adopts chain  <span class="math">\\tilde{\\mathcal{C}}</span>  at this round). Choosing the chain  <span class="math">\\tilde{\\mathcal{C}}</span>  is done using the maxvalid function; note that it could be that  <span class="math">\\mathcal{C} = \\tilde{\\mathcal{C}}</span> . Then, the miner attempts to extend  <span class="math">\\tilde{\\mathcal{C}}</span>  by running the POW algorithm pow described above.</p>

    <p class="text-gray-300">The value that the miner attempts to insert in the chain is determined by function  <span class="math">I(\\cdot)</span> . The input to  <span class="math">I(\\cdot)</span>  is the state  <span class="math">st</span> , the current chain  <span class="math">\\mathcal{C}</span> , the contents of the miner's input tape INPUT() (recall that they can be written by the environment  <span class="math">\\mathcal{Z}</span>  at the beginning of any round) and commu</p>

    <p class="text-gray-300">|  Algorithm 3 The proof of work function, parameterized by q, T and hash functions H(·), G(·). The input is (x, C).  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  1: function pow(x, C) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: if C = ε then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Determine proof of work instance</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: s ← 0 |   |</p>

    <p class="text-gray-300">|  4: else |   |</p>

    <p class="text-gray-300">|  5: ⟨s', x', ctr'⟩ ← head(C) |   |</p>

    <p class="text-gray-300">|  6: s ← H(ctr', G(s', x')) |   |</p>

    <p class="text-gray-300">|  7: end if |   |</p>

    <p class="text-gray-300">|  8: ctr ← 1 |   |</p>

    <p class="text-gray-300">|  9: B ← ε |   |</p>

    <p class="text-gray-300">|  10: h ← G(s, x) |   |</p>

    <p class="text-gray-300">|  11: while (ctr ≤ q) do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">12: if (H(ctr, h) < T) then</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ This H(·) invocation subject to the q-bound</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  13: B ← ⟨s, x, ctr⟩ |   |</p>

    <p class="text-gray-300">|  14: break |   |</p>

    <p class="text-gray-300">|  15: end if |   |</p>

    <p class="text-gray-300">|  16: ctr ← ctr + 1 |   |</p>

    <p class="text-gray-300">|  17: end while |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">18: C ← CB</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Extend chain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  19: return C |   |</p>

    <p class="text-gray-300">|  20: end function |   |</p>

    <p class="text-gray-300">nication tape RECEIVE(), as well as the current round number round. The protocol expects two types of entries in the input tape, READ and (INSERT, value); other inputs are ignored.</p>

    <p class="text-gray-300">As mentioned, we purposely leave the functions  <span class="math">I(\\cdot), R(\\cdot)</span>  undetermined in the description of the backbone protocol, as their specifics will vary according to the application. When the input  <span class="math">x</span>  is determined by  <span class="math">I(\\cdot)</span> , the protocol attempts to insert it into the chain  <span class="math">\\mathcal{C}</span>  by invoking pow. In case the local chain  <span class="math">\\mathcal{C}</span>  is modified during the above steps, the protocol transmits ("broadcasts") the new chain to the other parties. Finally, in case a READ symbol is present in the communication tape, the protocol applies function  <span class="math">R(\\cdot)</span>  to its current chain and writes the result onto the output tape OUTPUT(). The round ends when the algorithm diffuses a message (⊥ in case no message is to be diffused).</p>

    <p class="text-gray-300">We next define the two main properties of the backbone protocol that we will prove. The first property is called the common prefix property and is parameterized by a value  <span class="math">k \\in \\mathbb{N}</span> . It considers an arbitrary environment and adversary in the  <span class="math">q</span> -bounded setting, and it holds as long as removing  <span class="math">k</span>  blocks from an honest party's chain results to a prefix of another honest party's chain.</p>

    <p class="text-gray-300">Definition 3 (Common Prefix Property). The common prefix property  <span class="math">Q_{\\mathsf{cp}}</span>  with parameter  <span class="math">k \\in \\mathbb{N}</span>  states that for any pair of honest players  <span class="math">P_1, P_2</span>  adopting the chains  <span class="math">\\mathcal{C}_1, \\mathcal{C}_2</span>  at rounds  <span class="math">r_1 \\leq r_2</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, \\mathcal{A}, \\mathcal{Z}}^l, n</span>  respectively, it holds that  <span class="math">\\mathcal{C}_1^{\\lceil k \\rceil} \\preceq \\mathcal{C}_2</span> .</p>

    <p class="text-gray-300">Algorithm 4 The Bitcoin backbone protocol, parameterized by the input contribution function  <span class="math">I(\\cdot)</span>  and the chain reading function  <span class="math">R(\\cdot)</span> . At the onset it is assumed "init= True".</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">if (init) then</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2:</td>

            <td class="px-3 py-2 border-b border-gray-700">C← ε</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3:</td>

            <td class="px-3 py-2 border-b border-gray-700">st← ε</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4:</td>

            <td class="px-3 py-2 border-b border-gray-700">round← 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5:</td>

            <td class="px-3 py-2 border-b border-gray-700">init← False</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">6:</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">7:</td>

            <td class="px-3 py-2 border-b border-gray-700">ˆ← maxvalid(C, any chain C' found in RECEIVE())</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8:</td>

            <td class="px-3 py-2 border-b border-gray-700">if INPUT() contains READ then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">9:</td>

            <td class="px-3 py-2 border-b border-gray-700">write R(ˆ) to OUTPUT() ▷ Produce necessary output before the POW stage.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">10:</td>

            <td class="px-3 py-2 border-b border-gray-700">end if</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11:</td>

            <td class="px-3 py-2 border-b border-gray-700">⟨st,x⟩ ← I(st,ˆ, round, INPUT(), RECEIVE()) ▷ Determine the x-value.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">12:</td>

            <td class="px-3 py-2 border-b border-gray-700">Cnew← pow(x,ˆ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">13:</td>

            <td class="px-3 py-2 border-b border-gray-700">if C ≠ Cnew then</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">14:</td>

            <td class="px-3 py-2 border-b border-gray-700">C← Cnew</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15:</td>

            <td class="px-3 py-2 border-b border-gray-700">DIFFUSE(C) ▷ Broadcast the chain in case of adoption/extension.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">16:</td>

            <td class="px-3 py-2 border-b border-gray-700">else</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">17:</td>

            <td class="px-3 py-2 border-b border-gray-700">DIFFUSE(⊥) ▷ Signals the end of the round to the diffuse functionality.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">18:</td>

            <td class="px-3 py-2 border-b border-gray-700">end if</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">19:</td>

            <td class="px-3 py-2 border-b border-gray-700">round← round + 1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">20:</td>

            <td class="px-3 py-2 border-b border-gray-700">end if</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that this is a stronger version of the common prefix property compared to the one originally considered in [GKL15], where the property was stated for  <span class="math">r_1 = r_2</span> . The stronger formulation enables a more modular proof of the persistence property in Section 6.1 and for this reason we opt for it here. This was observed in [PSS16]. Note also that  <span class="math">P_1</span>  and  <span class="math">P_2</span>  could be the same party.</p>

    <p class="text-gray-300">The second property, which we call the chain quality property, aims at expressing the number of honest-player contributions that are contained in a sufficiently long and continuous part of an honest player's chain. Specifically, for parameters  <span class="math">\\ell \\in \\mathbb{N}</span>  and  <span class="math">\\mu \\in (0,1)</span> , the rate of adversarial block contributions in a continuous part of an honest party's chain of length at least  <span class="math">\\ell</span>  is bounded by  <span class="math">1 - \\mu</span> . This is intended to capture that at any moment that an honest player looks at a sufficiently long part of its blockchain, that part will be of sufficient "quality," i.e., the number of adversarial blocks present in that portion of the chain will be suitably bounded.</p>

    <p class="text-gray-300">Definition 4 (Chain Quality Property). The chain quality property  <span class="math">Q_{\\mathrm{cq}}</span>  with parameters  <span class="math">\\mu \\in \\mathbb{R}</span>  and  <span class="math">\\ell \\in \\mathbb{N}</span>  states that for any honest party  <span class="math">P</span>  with chain  <span class="math">\\mathcal{C}</span>  in  <span class="math">\\mathrm{VIEW}_{\\Pi, A, \\mathcal{Z}}^{t,n}</span> , it holds that for any  <span class="math">\\ell</span>  consecutive blocks of  <span class="math">\\mathcal{C}</span>  the ratio of honest blocks is at least  <span class="math">\\mu</span> .</p>

    <p class="text-gray-300">It is easy to see that, in the absence of an adversary, any set of, say,  <span class="math">h</span>  honest parties, obtain as many blocks as their proportion of the total hashing power, i.e.,  <span class="math">h / n</span> . We say that a protocol  <span class="math">\\Pi</span>  satisfies ideal chain quality if this is the case for adversarial parties as well, i.e.,  <span class="math">\\mu = 1 - t / n</span>  with</p>

    <p class="text-gray-300">respect to those parties. The ideal chain quality is not achieved by the Bitcoin backbone protocol, cf. Remark 4.</p>

    <p class="text-gray-300">A third property that is convenient to consider in conjunction to the above two and was introduced in follow up work, <em>[x13]</em>, to our original exposition is <em>chain growth</em>.</p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 5 (Chain Growth Property).</h6>

    <p class="text-gray-300">The chain growth property <span class="math">Q_{\\mathsf{cg}}</span> with parameters <span class="math">\\tau\\in\\mathbb{R}</span> and <span class="math">s\\in\\mathbb{N}</span> states that for any honest party <span class="math">P</span> that has a chain <span class="math">\\mathcal{C}</span> in <span class="math">\\operatorname{view}^{t,n}_{\\Pi,\\mathcal{A},\\mathcal{Z}}</span>, it holds that after any <span class="math">s</span> consecutive rounds it adopts a chain that is at least <span class="math">\\tau\\cdot s</span> blocks longer than <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">In our original exposition <em>[x11]</em> this property was not identified explicitly but rather proven and used directly in the form of a lemma. Nevertheless, as observed in <em>[x13]</em>, identifying it as a separate property, allows making more modular our proof arguments and for this reason we adopt it here as well.</p>

    <h2 id="sec-14" class="text-2xl font-bold">4 Analysis of the Bitcoin Backbone</h2>

    <p class="text-gray-300">In this section we perform the analysis of the protocol presented in the previous section. We will first consider the case of static adversaries; then, in Section 4.4, we will show how an adaptive adversary reduces to a static one.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.1 Definitions and Preliminary Lemmas</h3>

    <p class="text-gray-300">Let <span class="math">\\{0,1\\}^{\\kappa}</span> be the range of <span class="math">H(\\cdot)</span>. Recall that <span class="math">n</span> is the number of parties, <span class="math">t</span> of which can be corrupted by the adversary. In the analysis we are going to assume that the honest parties are sufficiently greater in number than the parties the adversary controls. In particular, we are going to require the following (cf. Table 1 for the definition all of the relevant parameters).</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Honest Majority Assumption. A number of <span class="math">t</span> out of <span class="math">n</span> parties are corrupted such that <span class="math">t\\leq(1-\\delta)(n-t)</span>, where <span class="math">3f+3\\epsilon&lt;\\delta\\leq 1</span>.</p>
    </blockquote>

    <p class="text-gray-300">It will be useful for verifying some calculations to note that <span class="math">3f+3\\epsilon&lt;\\delta</span> implies <span class="math">(1+\\epsilon)(1+f)&lt;(1-\\epsilon)(1-f)(1+\\delta)&lt;(1-\\epsilon)(1-f)/(1-\\delta)</span> and <span class="math">f,\\epsilon&lt;\\frac{1}{3}</span>.</p>

    <p class="text-gray-300">We will call a query of a party <em>successful</em> if it submits a pair <span class="math">(ctr,h)</span> such that <span class="math">H(ctr,h)\\leq T</span>. For each round <span class="math">i</span>, <span class="math">j\\in[q]</span>, and <span class="math">k\\in[t]</span>, we define Boolean random variables <span class="math">X_{i},Y_{i}</span> and <span class="math">Z_{ijk}</span> as follows. If at round <span class="math">i</span> an honest party obtains a POW, then <span class="math">X_{i}=1</span>, otherwise <span class="math">X_{i}=0</span>. If at round <span class="math">i</span> exactly one honest party obtains a POW, then <span class="math">Y_{i}=1</span>, otherwise <span class="math">Y_{i}=0</span>. Regarding the adversary, if at round <span class="math">i</span>, the <span class="math">j</span>-th query of the <span class="math">k</span>-th corrupted party is successful, then <span class="math">Z_{ijk}=1</span>, otherwise <span class="math">Z_{ijk}=0</span>. Define also <span class="math">Z_{i}=\\sum_{k=1}^{t}\\sum_{j=1}^{q}Z_{ijk}</span>. For a set of rounds <span class="math">S</span>, let <span class="math">X(S)=\\sum_{r\\in S}X_{r}</span> and similarly define <span class="math">Y(S)</span> and <span class="math">Z(S)</span>. Further, if <span class="math">X_{i}=1</span>, we call <span class="math">i</span> a <em>successful round</em> and if <span class="math">Y_{i}=1</span>, a <em>uniquely successful round</em>. Uniquely successful rounds have the following important property.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Lemma 6.</h6>

    <p class="text-gray-300">Suppose the <span class="math">k</span>-th block <span class="math">B</span> of a chain <span class="math">\\mathcal{C}</span> was computed by an honest party in a uniquely successful round. Then the <span class="math">k</span>-th block a chain <span class="math">\\mathcal{C}^{\\prime}</span> either is <span class="math">B</span> or has been computed by the adversary.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose <span class="math">B^{\\prime}</span> is the <span class="math">k</span>-th block of a chain <span class="math">\\mathcal{C}^{\\prime}</span> that has been computed by an honest party and <span class="math">B^{\\prime}</span> is not <span class="math">B</span>. Since <span class="math">B</span> was computed in a uniquely successful round, <span class="math">B</span> and <span class="math">B^{\\prime}</span> cannot have been computed in the same round. Let <span class="math">r</span> be the earliest round on which <span class="math">B</span> or <span class="math">B^{\\prime}</span> was computed. Since it was computed by an honest party, every other honest party will receive it in the next round and so will adopt a chain of length at least <span class="math">k</span>. It follows that every block computed after round <span class="math">r</span> will be extending a chain of length more than <span class="math">k</span>. ∎</p>

    <p class="text-gray-300"><span class="math">\\kappa</span>  : security parameter; length of the hash function output <span class="math">\\lambda</span>  : tail-bounds parameter <span class="math">n</span>  : number of parties mining;  <span class="math">t</span>  out of which are controlled by the adversary <span class="math">T</span>  : the target hash value used by parties for solving POW's <span class="math">t</span>  : number of parties controlled by the adversary <span class="math">\\delta</span>  : advantage of honest parties,  <span class="math">(t / (n - t)\\leq 1 - \\delta)</span> <span class="math">f</span>  : probability at least one honest party succeeds in finding a POW in a round <span class="math">\\epsilon</span>  : quality of concentration of random variables in typical executions, cf. Definition 9 <span class="math">k</span>  : number of blocks for the common prefix property <span class="math">\\ell</span>  : number of blocks for the chain quality property <span class="math">\\mu</span>  : chain quality parameter <span class="math">s</span>  : number of rounds for the chain growth property <span class="math">\\tau</span>  : chain growth parameter <span class="math">L</span>  : the total run-time of the system <span class="math">Q</span>  : the total number of queries to the RO oracle  <span class="math">(Q = qnL)</span></p>

    <p class="text-gray-300">Table 1: The parameters in our analysis. Positive integers  <span class="math">n, t, L, s, \\ell, T, k, \\kappa</span>  where  <span class="math">\\log T</span>  is linearly related to  <span class="math">\\kappa</span> ; positive reals  <span class="math">f, \\epsilon, \\delta, \\mu, \\tau, \\lambda</span> , where  <span class="math">f, \\epsilon, \\delta, \\mu \\in (0,1)</span> .</p>

    <p class="text-gray-300">An important parameter of the protocol is the probability that at least one honest party computes a solution at given round. We denote this parameter by  <span class="math">f</span>  and we have</p>

    <div class="my-4 text-center"><span class="math-block">(1 - f) p q (n - t) &amp;lt;   f = \\mathbb {E} [ X _ {i} ] = 1 - (1 - p) ^ {q (n - t)} &amp;lt;   p q (n - t), \\tag {1}</span></div>

    <p class="text-gray-300">where  <span class="math">p = T / 2^{\\kappa}</span>  is the probability of success of a single query. For the inequalities we used  <span class="math">1 + x \\leq e^{x}</span>  (for all real  <span class="math">x</span> ) and Bernoulli's inequality  <span class="math">(1 + x)^{\\alpha} &amp;gt; 1 + \\alpha x</span>  (for reals  <span class="math">x &amp;gt; -1</span>  and  <span class="math">\\alpha &amp;gt; 1</span> ). For example,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {f}{1 - f} = \\frac {1 - (1 - p) ^ {q (n - t)}}{(1 - p) ^ {q (n - t)}} = (1 - p) ^ {- q (n - t)} - 1 &amp;gt; (1 + p) ^ {q (n - t)} - 1 &amp;gt; p q (n - t).</span></div>

    <p class="text-gray-300">We now provide bounds for the random variables defined above, <span class="math">^{15}</span>  which relate their expectations to  <span class="math">f</span> . With respect to the honest parties we have</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ Y _ {i} ] \\geq q (n - t) p (1 - p) ^ {q (n - t) - 1} &amp;gt; p q (n - t) [ 1 - p q (n - t) ] \\geq f (1 - f) &amp;gt; \\left(1 - \\frac {\\delta}{3}\\right) f.</span></div>

    <p class="text-gray-300">For the first inequality we estimate from below pretending that honest parties make all  <span class="math">q</span>  queries even after a successful one and summing over all queries the probability that it is the only successful one. The last inequality follows from the fact that  <span class="math">x \\mapsto x(1 - x)</span>  is increasing in  <span class="math">(0, \\frac{1}{2})</span> , since  <span class="math">f &amp;lt; pq(n - t) &amp;lt; f(1 - f)^{-1} &amp;lt; \\frac{\\delta}{3}(1 - \\frac{\\delta}{3})^{-1} \\leq \\frac{1}{2}</span>  (we used the bounds on  <span class="math">f</span>  above and the assumption  <span class="math">3\\epsilon + 3f &amp;lt; \\delta \\leq 1</span> ). With respect to the expected number of blocks the adversary can compute in a single round we note the bound</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb {E} [ Z _ {i} ] = p q t = \\frac {t}{n - t} \\cdot p q (n - t) &amp;lt;   \\frac {t}{n - t} \\cdot \\frac {f}{1 - f} &amp;lt;   \\left(1 + \\frac {\\delta}{2}\\right) \\cdot f \\cdot \\frac {t}{n - t}.</span></div>

    <p class="text-gray-300">20</p>

    <p class="text-gray-300">The inequality follows from the bounds on <span class="math">f</span> above.</p>

    <p class="text-gray-300">We next prove the Chain Growth Lemma. It states that, at any round, the length of any honest party's chain will be at least as large as the number of successful rounds. As a consequence, the chain of honest parties will grow at least at the rate of successful rounds, no matter what strategy the adversary employs.</p>

    <p class="text-gray-300"><strong>Lemma 7 (Chain Growth Lemma).</strong> Suppose that at round <span class="math">r</span> an honest party has a chain of length <span class="math">\\ell</span>. Then, by round <span class="math">s \\geq r</span>, every honest party has adopted a chain of length at least <span class="math">\\ell + \\sum_{i=r}^{s-1} X_i</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By induction on <span class="math">s - r \\geq 0</span>. For the basis <span class="math">(s = r)</span>, observe that if at round <span class="math">r</span> an honest party has<span class="math">^{16}</span> a chain <span class="math">\\mathcal{C}</span> of length <span class="math">\\ell</span>, then that party broadcast <span class="math">\\mathcal{C}</span> at a round earlier than <span class="math">r</span>. It follows that every honest party will receive <span class="math">\\mathcal{C}</span> by round <span class="math">r</span>.</p>

    <p class="text-gray-300">For the inductive step, note that by the inductive hypothesis every honest party has received a chain of length at least <span class="math">\\ell&#x27; = \\ell + \\sum_{i=r}^{s-2} X_i</span> by round <span class="math">s-1</span>. When <span class="math">X_{s-1} = 0</span> the statement follows directly, so assume <span class="math">X_{s-1} = 1</span>. Observe that every honest party queried the oracle with a chain of length at least <span class="math">\\ell&#x27;</span> at round <span class="math">s-1</span>. If follows that all honest parties successful at round <span class="math">s-1</span> broadcast a chain of length at least <span class="math">\\ell&#x27; + 1</span>. Since <span class="math">\\ell&#x27; + 1 = \\ell + \\sum_{i=r}^{s-1} X_i</span>, this completes the proof.</p>

    <p class="text-gray-300">We now define our typical set of executions. Informally, this set consists of those executions with polynomially many rounds and with the property that the sum of the <span class="math">X,Y,Z</span> variables over any <span class="math">\\lambda = \\Omega(\\kappa)</span> consecutive rounds does not deviate too much from its expectation.</p>

    <p class="text-gray-300">First, we define a few bad events relevant to the properties of the hash function. In the random oracle model (as long as the execution is polynomially bounded in <span class="math">\\kappa</span>), these events occur with probability exponentially small in <span class="math">\\kappa</span>.</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> An insertion occurs when, given a chain <span class="math">\\mathcal{C}</span> with two consecutive blocks <span class="math">B</span> and <span class="math">B&#x27;</span>, a block <span class="math">B^<em></span> created after <span class="math">B&#x27;</span> is such that <span class="math">B, B^</em>, B&#x27;</span> form three consecutive blocks of a valid chain. A copy occurs if the same block exists in two different positions. A prediction occurs when a block extends one which was computed at a later round.</p>

    <p class="text-gray-300"><strong>Definition 9 (Typical execution).</strong> An execution is <span class="math">(\\epsilon, \\lambda)</span>-typical (or just typical), for <span class="math">\\epsilon \\in (0,1)</span> and integer <span class="math">\\lambda \\geq 2/f</span>, if, for any set <span class="math">S</span> of at least <span class="math">\\lambda</span> consecutive rounds, the following hold.</p>

    <p class="text-gray-300">(a) <span class="math">(1 - \\epsilon)\\mathbb{E}[X(S)] &amp;lt; X(S) &amp;lt; (1 + \\epsilon)\\mathbb{E}[X(S)]</span> and <span class="math">(1 - \\epsilon)\\mathbb{E}[Y(S)] &amp;lt; Y(S).</span> (b) <span class="math">Z(S) &amp;lt; \\mathbb{E}[Z(S)] + \\epsilon \\mathbb{E}[X(S)].</span> (c) No insertions, no copies, and no predictions occurred.</p>

    <p class="text-gray-300"><strong>Theorem 10.</strong> An execution is typical with probability <span class="math">1 - e^{-\\Omega \\left(\\epsilon^2\\lambda f + \\kappa - \\log (L)\\right)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> First we note that the input entropy requirement on the input contribution function <span class="math">I(\\cdot)</span>, allows us to condition our probability space on the event that no two honest parties in a polynomially bounded execution queried the <span class="math">H(\\cdot)</span> oracle with the same input. In this space, the variables <span class="math">X_{i}</span> (and similarly <span class="math">Y_{i}</span> and <span class="math">Z_{ijk}</span>) are independent Bernoulli trials. Since each trial is successful with probability <span class="math">\\Theta(f)</span>, the result follows from the standard Chernoff bound. (Note also that <span class="math">\\mathbb{E}[Z(S)] &amp;lt; \\mathbb{E}[X(S)]</span>.)</p>

    <p class="text-gray-300">For part (c) and <span class="math">i \\in \\{1,2,3\\}</span>, let <span class="math">B_{i} = \\langle st_{i}, x_{i}, c t r_{i} \\rangle</span> and <span class="math">g_{i} = G(st_{i}, x_{i})</span>. If the total number of rounds is <span class="math">L</span> then it holds that there are at most <span class="math">Q = q n L</span> queries posed to <span class="math">G</span> and <span class="math">H</span>. It follows that the probability of a collision occurring is <span class="math">Q^{2} / 2^{\\kappa} = e^{-\\Omega (\\kappa - \\log Q)}</span>. We observe now that if a</p>

    <p class="text-gray-300"><span class="math">^{16}</span>Recall that we say a party “has” a chain <span class="math">\\mathcal{C}^<em></span> at round <span class="math">r</span>, if the value of variable <span class="math">\\mathcal{C}</span> at line 7 of Algorithm 4 is <span class="math">\\mathcal{C}^</em></span>, while it “adopts” a chain <span class="math">\\mathcal{C}^<em></span> if the value of variable <span class="math">\\tilde{\\mathcal{C}}</span> is equal to <span class="math">\\mathcal{C}^</em></span>.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">block extends two distinct blocks, then a collision has occurred. To see this, suppose block <span class="math">B_{3}</span> extents two distinct blocks <span class="math">B_{1}</span> and <span class="math">B_{2}</span>. Then <span class="math">st_{3}=H(ctr_{1},g_{1})=H(ctr_{2},g_{2})</span>; implying a collision either in <span class="math">H</span> or in <span class="math">G</span>, since <span class="math">B_{1}</span> and <span class="math">B_{2}</span> are distinct. It is not hard to see that an insertion or a copy imply the existence of a block that extends two distinct blocks (consider the first time such an event occurs). Finally, suppose a prediction occurs and block <span class="math">B_{2}</span> extends a block <span class="math">B_{3}</span> computed at a later round. This means that the hash value the oracle assigned <span class="math">B_{3}</span> equals <span class="math">st_{2}</span>, which should be an answer of the oracle to a previous query. It follows that the probability a prediction occurs is at most <span class="math">Q^{2}/2^{\\kappa}=e^{-\\Omega(\\kappa-\\log Q)}</span>. ∎</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Remark 2.</h6>

    <p class="text-gray-300">Choosing <span class="math">\\lambda=\\Omega(\\log^{2}\\kappa)</span>, the execution fails to be typical with negligible probability in the security parameter <span class="math">\\kappa</span>. We are going to show that all the properties required for our applications hold for a typical execution.</p>

    <p class="text-gray-300">The next two Lemmas are simple, but will make convenient the appeal to the properties of a typical execution.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">The following hold for any set <span class="math">S</span> of at least <span class="math">\\lambda</span> consecutive rounds in a typical execution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $(1-\\epsilon)f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><X(S)<(1+\\epsilon)f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\;\\;\\;\\mbox{and}\\;\\;\\;(1-\\frac{\\delta}{3})f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><(1-\\epsilon)f(1-f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><Y(S)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. $Z(S)<(1+\\frac{\\delta}{2})\\cdot\\frac{t}{n-t}\\cdot X(S)+\\epsilon f</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700"><(1-\\frac{\\delta}{2})X(S)<span class="math"> and </span>Z(S)<Y(S)$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Parts (a) and (b) follow easily from the bounds shown in the beginning of this subsection. Part (c) uses the bounds of parts (a) and (b) and the assumption <span class="math">3f+3\\epsilon&lt;\\delta\\leq 1</span>. ∎</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">From the above relations, one can see the importance of the parameter <span class="math">f</span> and the way that the moderate hardness of proof of work is relevant to the analysis. In particular <span class="math">f</span> should be large enough so that <span class="math">\\mathbb{E}[X(S)]</span> becomes sufficiently bigger than <span class="math">0</span> to be useful. If <span class="math">f</span> is too small, (i.e., producing PoW’s is too hard) the honest participants will produce too few PoW’s for the system to make progress (with foresight, chain growth will be hurt, which in turn will hurt the liveness of the transaction ledger). On the other hand, <span class="math">f</span> cannot be too large, because then the lower bound on <span class="math">Y</span> will be too small (as it depends multiplicatively on <span class="math">(1-f)</span> as well as <span class="math">f</span>). This means that uniquely successful rounds will not produce sufficiently many PoW’s to overcome the PoW’s produced by the adversary. In practice, this underscores the importance of calibrating the difficulty of the proof of work to maintain a suitable value of <span class="math">f</span> within the range <span class="math">(0,1)</span>. Such calibration takes place in the Bitcoin system every 2016 blocks and attempts to keep <span class="math">f</span> somewhere between 2–3% (assuming a full communication round takes place every up to 20 seconds).</p>

    <p class="text-gray-300">A corollary of this lemma and the Chain Growth Lemma (Lemma 7) is the following theorem concerning the chain growth property.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Theorem 12 (Chain Growth).</h6>

    <p class="text-gray-300">In a typical execution the chain growth property holds with parameters <span class="math">\\tau=(1-\\epsilon)f</span> and <span class="math">s\\geq\\lambda</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that at a round <span class="math">r</span> and honest party <span class="math">P</span> has a chain <span class="math">\\mathcal{C}</span> of length <span class="math">\\ell</span>. By the Chain Growth Lemma (Lemma 7), after <span class="math">s</span> rounds, <span class="math">P</span> has adopted a chain <span class="math">\\mathcal{C}^{\\prime}</span> of length at least <span class="math">\\ell+X(S)</span>, where <span class="math">S=\\{i:r\\leq i&lt;r+s\\}</span>. By assumption, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\lambda<span class="math"> and Lemma 11(a) applies. Thus, in a typical execution, </span>X(S)>(1-\\epsilon)f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\tau\\cdot s$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-24" class="text-base font-medium mt-4">Lemma 13.</h6>

    <p class="text-gray-300">In a typical execution, any <span class="math">k\\geq 2\\lambda f</span> consecutive blocks of a chain have been computed in more than <span class="math">\\frac{k}{2f}</span> consecutive rounds.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume there is a set of consecutive rounds <span class="math">S^{\\prime}</span> in which the <span class="math">k</span> blocks were computed and $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{k}{2f}<span class="math">. Then, there is a set </span>S<span class="math"> of consecutive rounds with </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lceil\\frac{k}{2f}\\rceil+1<span class="math"> such that </span>X(S)+Z(S)\\geq k<span class="math"> (adding rounds to </span>S^{\\prime}$ favors the upper bound that follows). However,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$X(S)+Z(S)<(2+\\epsilon-\\frac{2\\delta}{3})f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(2-2f)f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq(1-f)(k+4f)<k,$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the first inequality uses Lemma 11(a) and (b) (note that <span class="math">\\lceil\\frac{k}{2f}\\rceil\\geq\\lambda</span>), the second <span class="math">3f+3\\epsilon\\leq\\delta</span>, and the third $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\lceil\\frac{k}{2f}\\rceil+1\\leq\\frac{k}{2f}+2<span class="math"> and </span>k\\geq 4<span class="math"> (recall </span>\\lambda\\geq 2/f$). ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">4.2 Common Prefix Property</h3>

    <h6 id="sec-27" class="text-base font-medium mt-4">Lemma 14 (Common Prefix Lemma).</h6>

    <p class="text-gray-300">Suppose that at round <span class="math">r</span> of a typical execution an honest party has a chain <span class="math">\\mathcal{C}_{1}</span>, while a chain <span class="math">\\mathcal{C}_{2}</span> of length at least <span class="math">\\mathrm{len}(\\mathcal{C}_{1})</span> is adopted by an honest party, then <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\preceq\\mathcal{C}_{2}</span> and <span class="math">\\mathcal{C}_{2}^{\\lceil k}\\preceq\\mathcal{C}_{1}</span> for <span class="math">k\\geq 2\\lambda f</span>.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume, towards a contradiction, an execution in which the assumptions of the lemma hold, but either <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\not\\preceq\\mathcal{C}_{2}</span> or <span class="math">\\mathcal{C}_{2}^{\\lceil k}\\not\\preceq\\mathcal{C}_{1}</span> for some <span class="math">k\\geq 2\\lambda f</span>. Consider the last block on the common prefix of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> that was computed by an honest party and let <span class="math">r^{<em>}</span> be the round at which it was computed; if no such block exists let <span class="math">r^{</em>}=0</span>. Define the set of rounds <span class="math">S=\\{i:r^{*}&lt;i&lt;r\\}</span>. We claim that</p>

    <p class="text-gray-300"><span class="math">Z(S)\\geq Y(S).</span></p>

    <p class="text-gray-300">We show this by pairing each uniquely successful round in <span class="math">S</span> with an adversarial block computed in <span class="math">S</span>. Note that if the block computed at round <span class="math">r^{*}</span> was at position <span class="math">\\ell</span>, then each of these blocks will be extending a chain of length at least <span class="math">\\ell</span>. For a uniquely successful round <span class="math">u\\in S</span>, let <span class="math">j_{u}</span> be the position of the corresponding block. Consider the set</p>

    <p class="text-gray-300"><span class="math">J=\\{j_{u}:u\\text{ is a uniquely successful round in }S\\}.</span></p>

    <p class="text-gray-300">Note that both chains have length at least <span class="math">\\max J</span>, because the honest party that computed the chain which corresponds to <span class="math">\\max J</span> has diffused it and any chain adopted at any later round should be at least as long. It follows that for every <span class="math">j\\in J</span> there is a block in position <span class="math">j</span> of either chain. We now argue that for every <span class="math">j\\in J</span> there is an adversarial block in the <span class="math">j</span>-th position either in <span class="math">\\mathcal{C}_{1}</span> or in <span class="math">\\mathcal{C}_{2}</span>. If <span class="math">j</span> lies on the common prefix of <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span>, then the corresponding block is adversarial by the definition of <span class="math">r^{*}</span>. Otherwise, there is one block in <span class="math">\\mathcal{C}_{1}</span> and another one in <span class="math">\\mathcal{C}_{2}</span>, and by Lemma 6 they cannot both be honest. An illustration of this argument is shown in Figure 3(a). This completes the proof of the claim.</p>

    <p class="text-gray-300">To finish the proof, note that by Lemma 13 the properties of a typical execution apply to the set of rounds <span class="math">S</span>. But then <span class="math">Z(S)\\geq Y(S)</span> contradicts Lemma 11, which establishes the set of conditions that hold for a typical execution. ∎</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 15 (Common Prefix).</h6>

    <p class="text-gray-300">In a typical execution the common prefix property holds with parameter <span class="math">k\\geq 2\\lambda f</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Refer to Definition 3, and consider chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> adopted by parties <span class="math">P_{1}</span> and <span class="math">P_{2}</span> in rounds <span class="math">r_{1}</span> and <span class="math">r_{2}</span>, in violation of the common prefix property, i.e., <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\not\\preceq\\mathcal{C}_{2}</span>. It is not hard to see that there must be a round <span class="math">r\\geq r_{1}</span> in which an honest party <span class="math">P</span> has a chain <span class="math">\\mathcal{C}</span> containing <span class="math">\\mathcal{C}_{1}^{\\lceil k}</span> and adopts another chain <span class="math">\\mathcal{C}^{\\prime}</span> such that <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\not\\preceq\\mathcal{C}^{\\prime}</span>. Clearly, <span class="math">\\mathcal{C}^{\\lceil k}\\not\\preceq\\mathcal{C}^{\\prime}</span> and <span class="math">\\mathrm{len}(\\mathcal{C}^{\\prime})\\geq\\mathrm{len}(\\mathcal{C})</span>, contradicting Lemma 14. An illustration of this argument is shown in Figure 3(b). ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 3: Illustration of proofs of Lemma 14 and Theorem 15.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <p class="text-gray-300">Theorem 16 (Chain Quality). In a typical execution the chain quality property holds with parameters  <span class="math">\\ell \\geq 2\\lambda f</span>  and  <span class="math">\\mu = 1 - (1 + \\frac{\\delta}{2}) \\cdot \\frac{t}{n - t} - \\frac{\\epsilon}{1 - \\epsilon} &amp;gt; 1 - (1 + \\frac{\\delta}{2}) \\cdot \\frac{t}{n - t} - \\frac{\\delta}{2}</span> .</p>

    <p class="text-gray-300">Proof. Let us denote by  <span class="math">B_i</span>  the  <span class="math">i</span> -th block of the chain  <span class="math">\\mathcal{C}</span>  of an honest party  <span class="math">P</span>  at some round  <span class="math">r</span>  so that  <span class="math">\\mathcal{C} = B_1 \\ldots B_{\\mathrm{len}(\\mathcal{C})}</span>  and consider some  <span class="math">\\ell</span>  consecutive blocks  <span class="math">B_u, \\ldots, B_v</span> . Define  <span class="math">L</span>  as the least number of consecutive blocks  <span class="math">B_{u&#x27;}, \\ldots, B_{v&#x27;}</span>  that include the  <span class="math">\\ell</span>  given ones (i.e.,  <span class="math">u&#x27; \\leq u</span>  and  <span class="math">v \\leq v&#x27;</span> ) and have the properties (1) that the block  <span class="math">B_{u&#x27;}</span>  was computed by an honest party or is  <span class="math">B_1</span>  in case such block does not exist, and (2) that there exists a round at which an honest party was trying to extend the chain ending at block  <span class="math">B_{v&#x27;}</span> . Observe that number  <span class="math">L</span>  is well defined since  <span class="math">B_{\\mathrm{len}(\\mathcal{C})}</span>  is at the head of a chain that an honest party is trying to extend. Define also  <span class="math">r_1</span>  as the round that  <span class="math">B_{u&#x27;}</span>  was created ( <span class="math">r_1 = 0</span>  if  <span class="math">B_{u&#x27;}</span>  is the genesis block),  <span class="math">r_2</span>  as the first round that an honest party attempts to extend  <span class="math">B_{v&#x27;}</span> , and let  <span class="math">S = \\{r : r_1 \\leq r &amp;lt; r_2\\}</span> .</p>

    <p class="text-gray-300">Now, define  <span class="math">\\mu</span>  as in the statement and let  <span class="math">x</span>  denote the number of blocks from honest parties that are included in the  <span class="math">\\ell</span>  blocks and, towards a contradiction, assume that</p>

    <div class="my-4 text-center"><span class="math-block">x &amp;lt;   \\mu \\ell \\leq \\mu L.</span></div>

    <p class="text-gray-300">Suppose first that all the  <span class="math">L</span>  blocks  <span class="math">\\{B_j : u&#x27; \\leq j \\leq v&#x27;\\}</span>  have been computed during the rounds in the set  <span class="math">S</span> . Then</p>

    <div class="my-4 text-center"><span class="math-block">Z (S) \\geq L - x &amp;gt; (1 - \\mu) L \\geq (1 - \\mu) X (S) \\geq \\left(\\left(1 + \\frac {\\delta}{2}\\right) \\cdot \\frac {t}{n - t} + \\frac {\\epsilon}{1 - \\epsilon}\\right) X (S).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first inequality comes from the fact that the adversary computed  <span class="math">L - x</span>  of the  <span class="math">L</span>  blocks. The second one comes from the postulated relation between  <span class="math">x</span>  and  <span class="math">L</span> . The last inequality follows from Lemma 7 and the properties (1) and (2) of the  <span class="math">L</span>  blocks. To show this, we assume  <span class="math">X(S) &amp;gt; L</span>  and contradict property (2). Note that at round  <span class="math">r_1</span>  an honest party has produced block  <span class="math">B_{u&#x27;}</span>  and has a chain of length  <span class="math">u&#x27;</span> . By Lemma 7, every honest party at round  <span class="math">r_2</span>  will have a chain of length at least  <span class="math">u&#x27; + X(S) &amp;gt; u&#x27; + L = v&#x27; + 1 &amp;gt; v&#x27;</span> . On the other hand,  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\lambda<span class="math">  by Lemma 13. The properties of a typical execution apply for the set of rounds  </span>S<span class="math">  and using Lemma 11 on the lower bound for  </span>Z(S)$  above gives the following contradiction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z (S) \\geq \\left(1 + \\frac {\\delta}{2}\\right) \\cdot \\frac {t}{n - t} \\cdot X (S) + \\epsilon f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; Z (S).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We used part (a) of Lemma 11 for the first inequality and part (c) for the second.</p>

    <p class="text-gray-300">To finish the proof we need to consider the case in which these  <span class="math">L</span>  blocks contain blocks that the adversary computed in rounds outside  <span class="math">S</span> . It is not hard to see that this implies an insertion, a copy, or a prediction, and cannot occur in a typical execution.</p>

    <p class="text-gray-300">We now observe that <span class="math">\\mu = 1 - (1 + \\frac{\\delta}{2}) \\cdot \\frac{t}{n - t} - \\frac{\\epsilon}{1 - \\epsilon} &amp;gt; 1 - \\left(1 + \\frac{\\delta}{2}\\right) \\cdot \\frac{t}{n - t} - \\frac{\\delta}{2} \\geq \\frac{n - 2t}{n - t} - \\delta + \\frac{\\delta^2}{2} \\geq \\frac{\\delta^2}{2} &amp;gt; 0</span>. Since <span class="math">\\mu &amp;gt; 0</span> we have the following.</p>

    <p class="text-gray-300">Corollary 17. Any <span class="math">\\lceil 2\\lambda f\\rceil</span> consecutive blocks in the chain of an honest party during a typical execution contain at least one honest block.</p>

    <p class="text-gray-300">Remark 4. We are able to argue that Theorem 16 is tight under the simplification that ties between blockchains of equal length always favor the adversary. In particular, we assume that the function maxvalid at line 5 of Algorithm 4, in case of chains of equal length, will always return the suggestion of the adversary if there is one. This simplification is made without loss of generality in our model since the adversary is rushing and hence in case two chains are transmitted in a single round the adversary can always arrange it so that its own solution arrives first<span class="math">^{17}</span>. Furthermore, if the number of honest parties is large, when an honest party discovers a solution in a round, all other honest parties will prefer the one transmitted by the adversary and thus the effect of a single honest party opting for its own block will be negligible.</p>

    <p class="text-gray-300">The attack below is a type of "selfish mining" attack (it is a variation of the one in [ES14] and appears to be folklore in bitcoin circles) that accomplishes the stated bound. The attack is as follows. Initially, the adversary works on the same chain as every honest party. However, whenever it finds a solution it keeps it private and keeps on extending a private chain. Whenever an honest party finds a solution, the (rushing) adversary releases one block from the private chain; if the private chain is depleted the adversary returns to the public chain. We now argue (informally) that this strategy exploits the conditions stated above and maximizes the adversarial blocks in the blockchain up to the upper bound of Theorem 16.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a set <span class="math">S</span> of consecutive rounds. With constant probability, in this set of rounds, the adversary will obtain more than $z = pqt</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> solutions, while the honest parties at most </span>x = pq(n - t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The adversary, by announcing each one of his blocks simultaneously with a block announced by an honest party, he manages to leave (with high probability) </span>z<span class="math"> honest blocks out of the </span>x<span class="math"> blocks unused. Now, for the smallest sequence of blocks that include the </span>z<span class="math"> blocks of the adversary, </span>\\mu &lt; (x - z) / x = (n - 2t) / (n - t)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">From the above, it follows that in order to obtain better chain quality one should consider mechanisms that result in more favorable (for the honest parties) behavior in the function maxvalid.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4.4 Adaptive Adversaries</h2>

    <p class="text-gray-300">In this section we show that the ability to corrupt parties adaptively does not provide any advantage to the adversary. We perform this via reduction to a static adversary and environment. We will in fact reduce the adaptive security of the backbone protocol <span class="math">\\Pi_{\\mathsf{bb}}</span> to the static security of a variant of the protocol, <span class="math">\\Pi_{\\mathsf{bb}}^{\\prime}</span>, which behaves identically with the sole difference that parties instead of adopting the first chain of a certain length they become aware of, they adopt the most recent one. It is straightforward to see that all the results of this section apply to <span class="math">\\Pi_{\\mathsf{bb}}^{\\prime}</span> as well (in fact all our proofs are independent of any chain "tie-breaking" performed by honest parties).</p>

    <p class="text-gray-300">Proposition 18. For any <span class="math">q, t, n \\in \\mathbb{N}</span> with <span class="math">t &amp;lt; n</span>, consider any adaptive adversary and environment pair <span class="math">\\mathcal{A}, \\mathcal{Z}</span> as well as an event <span class="math">E \\in \\{B_{\\mathrm{cp}}, B_{\\mathrm{cq}}, B_{\\mathrm{cg}}\\}</span> over the view <span class="math">\\mathrm{EXEC}_{\\Pi_{\\mathrm{bb}}, \\mathcal{A}, \\mathcal{Z}}^{t, n}</span>, corresponding to the failure of one of the three properties defined in Section 3.2, respectively. Then, there is a static adversary and environment pair <span class="math">\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;</span> such that it holds that <span class="math">E</span> has the same probability over <span class="math">\\mathrm{EXEC}_{\\Pi_{\\mathrm{bb}}&#x27;, \\mathcal{A}&#x27;, \\mathcal{Z}&#x27;}^{t, n}</span>.</p>

    <p class="text-gray-300"><span class="math">^{17}</span>In fact, this rushing capability was argued to be realistic in [ES14] through the dispersion of sybil nodes in the Bitcoin peer-to-peer network that echo the adversary's messages.</p>

    <p class="text-gray-300">Proof. We describe <span class="math">\\mathcal{A}&#x27;</span>, <span class="math">\\mathcal{Z}&#x27;</span> that simulate <span class="math">\\mathcal{A}</span>, <span class="math">\\mathcal{Z}</span>. <span class="math">\\mathcal{A}&#x27;</span> keeps a counter <span class="math">c</span>, initially set to 0, and initializes a mapping <span class="math">F: \\{P_1, \\ldots, P_n\\} \\to \\{P_1, \\ldots, P_n\\}</span> to the identity mapping. <span class="math">\\mathcal{A}&#x27;</span> keeps <span class="math">\\mathcal{Z}&#x27;</span> up to date about <span class="math">F</span>. <span class="math">\\mathcal{A}&#x27;</span> and <span class="math">\\mathcal{Z}&#x27;</span> use the correspondence <span class="math">F</span> to route the party activations initiated by <span class="math">\\mathcal{A}</span> and <span class="math">\\mathcal{Z}</span>. At the onset, <span class="math">\\mathcal{A}&#x27;</span> corrupts all parties with identities <span class="math">\\{P_1, \\ldots, P_t\\}</span>. From this point on it simulates all parties, running the honest protocol until a corruption by <span class="math">\\mathcal{A}</span> occurs. Moreover <span class="math">\\mathcal{A}&#x27;</span> keeps track of the state of all honest parties and orders the messages in all incoming tapes so that any chains of the same length are sequenced with the one possessed by the honest party last (in this way <span class="math">\\mathcal{A}&#x27;</span> ensures that honest parties' state in the <span class="math">\\Pi_{\\mathrm{bb}}&#x27;</span> execution matches that of <span class="math">\\Pi_{\\mathrm{bb}}</span> execution).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">When <span class="math">\\mathcal{A}</span> corrupts a party <span class="math">P_i</span>, <span class="math">\\mathcal{A}&#x27;</span> increments <span class="math">c</span>, and updates <span class="math">F</span> with the correspondence <span class="math">i \\leftrightarrow c</span>. Let <span class="math">\\mathcal{C}</span> be the chain of party <span class="math">P_i</span> and <span class="math">\\mathcal{C}&#x27;</span> the chain of party <span class="math">P_c</span> at the time of corruption. <span class="math">\\mathcal{A}&#x27;</span> delivers <span class="math">\\mathcal{C}</span> as the internal state of <span class="math">P_i</span> to <span class="math">\\mathcal{A}</span> (despite the fact that <span class="math">P_i</span> remains uncorrupted in the static execution). <span class="math">\\mathcal{A}&#x27;</span> also copies all messages directed to <span class="math">P_c</span> to the incoming tape of <span class="math">P_i</span>. Furthermore, in case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, </span>\\mathcal{A}'<span class="math"> delivers to party </span>P_i<span class="math"> the chain </span>\\mathcal{C}'<span class="math"> as the last message in the upcoming round (so that party </span>P_i<span class="math"> adopts it). Next, we argue that the divergence by the above actions is not detectable by </span>\\mathcal{A}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, this could only be caused by the fact that </span>P_c<span class="math"> updated his state in the current round and hence a message containing </span>\\mathcal{C}'<span class="math"> is on its way. As a result, during the next activation of party </span>P_c<span class="math"> by </span>\\mathcal{A}<span class="math">, party </span>P_i<span class="math"> will be activated instead by </span>\\mathcal{A}'<span class="math"> and they would become up to date having received </span>\\mathcal{C}'<span class="math">, and thus </span>P_i<span class="math"> will behave identically to the way party </span>P_c<span class="math"> would have. In case </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, this similarly means that the message containing </span>\\mathcal{C}<span class="math"> originating from </span>P_i<span class="math"> is on its way; as a result, the next time </span>\\mathcal{A}<span class="math"> activates party </span>P_c<span class="math">, it is an </span>\\mathcal{A}<span class="math">&#x27;s expectation that the update of party </span>P_i<span class="math"> would be in its incoming tape, and thus party </span>P_c<span class="math">&#x27;s expected behavior matches party </span>P_i<span class="math">&#x27;s. Finally, in case </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the substitution of the state of party </span>P_i<span class="math"> with that of party </span>P_c<span class="math"> guarantees that party </span>P_i<span class="math"> will behave identically to party </span>P_c<span class="math">, and hence will be undetectable in the view of </span>\\mathcal{Z}, \\mathcal{A}<span class="math"> (recall that in both protocols </span>\\Pi_{\\mathrm{bb}}, \\Pi_{\\mathrm{bb}}'$ all parties run exactly the same code and ignore their identity).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Based on the above it is easy to see that the probability of the events <span class="math">B_{\\mathrm{cp}}, B_{\\mathrm{cg}}</span> remain the same in both executions as they refer to purely structural aspects of the honest parties' state. The event <span class="math">B_{\\mathrm{cq}}</span> relates to the contents of an honest party's state; to see that this is also unaffected observe that an adaptive corruption at any point of the execution does not change the honest/adversarial designation of any block produced prior to that point.</p>

    <p class="text-gray-300">We now turn to applications of the Bitcoin backbone protocol, showing how it can be used as a basis to solve other problems. We start in this section by analyzing Nakamoto's suggestion for solving BA, observing that it falls short of satisfying Definition 2; we then present our simple instantiation which solves BA. This protocol, however, only tolerates an adversarial hashing power less than <span class="math">1/3</span>, which takes us to the next section, where we present Bitcoin's essential task, namely, distributively maintaining a public transaction ledger, as well as a more elaborate BA protocol tolerating an adversarial power strictly less than <span class="math">1/2</span>. An overview of our applications and the way their properties depend on those of the backbone protocol was already presented in Figure 1.</p>

    <p class="text-gray-300">As our first illustration of how the Bitcoin backbone can be used we present Nakamoto's suggestion for solving BA, as presented in a forum post [Nak08b]. We describe his solution (call it <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{nak}}</span>) via</p>

    <p class="text-gray-300">18Note that Nakamoto's description is quite informal. We make the most plausible interpretation of it in our formal framework.</p>

    <p class="text-gray-300">the backbone protocol by specifying the functions  <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span>  in a suitable way (see Figure 4). The content validation predicate  <span class="math">V(\\cdot)</span>  will be defined to require that all valid chains contain the same input value together with a nonce. The chain reading function  <span class="math">R(\\cdot)</span>  simply returns this value (ignoring the nonce) in case the chain has length at least  <span class="math">k</span>  (which is the security parameter); otherwise it is undefined. The input contribution function  <span class="math">I(\\cdot)</span>  examines the contents of the current chain  <span class="math">\\mathcal{C}</span>  and the contents of the input tape INPUT(). In case  <span class="math">\\mathcal{C} = \\varepsilon</span>  the input contribution for the next block is taken verbatim from the input tape; otherwise, the input contribution is determined as the (unique) value that is already present in  <span class="math">\\mathcal{C}</span>  (and in this case the local input is ignored). Note that we will only consider environments  <span class="math">\\mathcal{Z}</span>  that provide an input symbol to all parties. Note that the nonce is added to ensure "work independence": the parties need to introduce a fresh random  <span class="math">\\kappa</span> -bit nonce at each block (cf. the beginning of Sec. 4).</p>

    <p class="text-gray-300">It follows that initially the protocol builds various chains all containing the same value. The intuition is that Agreement will follow from the fact that the honest players will eventually agree on a single chain, as long as the majority of the hashing power lies with the honest parties. While this is true, as we will demonstrate, the second necessary property does not hold: this protocol cannot provide Validity (with high probability).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation predicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(⟨x1, ...,xn⟩) is true if and only if it holds that v1 = ... = vn ∈ {0,1}, ρ1, ..., ρn ∈ {0,1}κ where xi = ⟨vi, ρi⟩, or n = 0.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·) (parameterized by k)</td>

            <td class="px-3 py-2 border-b border-gray-700">If V(xC) = True and len(C) > k, the value of R(C) is the (unique) value v that is present in each block of C, while it is undefined if V(xC) = False or len(C) ≤ k.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution function I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">If C = ∅ and (INSERT, v) is in the input tape then I(st, C, round, INPUT()) is equal to ⟨v, ρ⟩ where ρ ∈ {0,1}κ is a random value; otherwise (i.e., the case C ≠ ∅), it is equal to ⟨v, ρ⟩ where v is the unique v ∈ {0,1} value that is present in C and ρ ∈ {0,1}κ is a random value. The state st always remains ε.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Expressing Nakamoto's BA protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{nak}}</span>  over the Bitcoin backbone protocol via the specification of  <span class="math">V(\\cdot), R(\\cdot), I(\\cdot)</span> .</p>

    <p class="text-gray-300">As we now show, Agreement follows easily from the common prefix property. Indeed, as long as there is a common prefix (irrespective of its length), it is ensured that when  <span class="math">R(\\cdot)</span>  becomes defined, all honest parties will produce the same output.</p>

    <p class="text-gray-300">Lemma 19 (Agreement). Under the Honest Majority Assumption, it holds that  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{nak}}</span>  from Fig. 4 parameterized with  <span class="math">k = \\lceil 2f\\lambda \\rceil</span>  running for a total number of rounds  <span class="math">L \\geq 2k / f</span> , satisfies Agreement (cf. Definition 2) with probability at least  <span class="math">1 - e^{-\\Omega (\\epsilon^2 f\\lambda)}</span> .</p>

    <p class="text-gray-300">Proof. First note that after  <span class="math">L</span>  rounds every honest party has a chain with more than  <span class="math">k</span>  blocks. This follows from chain growth property (see Theorem 12), since  <span class="math">\\tau L \\geq 2(1 - \\epsilon)k &amp;gt; k</span>  (where  <span class="math">\\epsilon &amp;lt; 1/2</span>  follows from the Honest Majority Assumption).</p>

    <p class="text-gray-300">Observe that chains contain unique values (ignoring the nonces), therefore a disagreement between honest parties implies that two parties have disjoint chains (essentially, this is equivalent to a fork that happens at the onset). It follows from the common prefix property (Theorem 15) that two chains of length more than  <span class="math">k</span>  that are completely disjoint do not exist in a typical execution.</p>

    <p class="text-gray-300">On the other hand, it is easy to see that Validity cannot be guaranteed with overwhelming probability unless the hashing power of the adversary is negligible compared to the honest players,</p>

    <p class="text-gray-300">i.e.,  <span class="math">t / n</span>  is negligible. This is because in case the adversary finds a solution first, then every honest player will extend the adversary's solution and switch to the adversarial input hence abandoning the original input. While one can still show that Validity can be ensured with non-zero probability (and thus the protocol fails gracefully assuming honest majority),  <span class="math">\\Pi_{\\mathsf{BA}}^{\\mathsf{nak}}</span>  falls short from providing a solution to BA. Interestingly, by appropriately modifying the way the backbone protocol is used, we show in the next section how a solution can be derived.</p>

    <p class="text-gray-300">We now show that the Bitcoin backbone can be directly used to satisfy BA's properties with an error that decreases exponentially in the length of the chain, assuming however that the adversary's hashing power is less than  <span class="math">1/3</span> . There are two important differences with respect to the approach in the previous section: (i) parties never abandon their original input but instead they do insist in inserting it into the blockchain, and (ii) after round  <span class="math">L</span>  they output the majority of their local length- <span class="math">k</span>  prefix (note that here we consider binary BA). The protocol (i.e., the specification of the functions  <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span> ) is presented in Figure 5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation predicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(⟨x1, ..., xn⟩) is true if and only if v1, ..., vn ∈ {0,1}, ρ1, ..., ρn ∈ {0,1}κ where vi, ρi are the values from the pair xi = ⟨vi, ρi⟩, or n = 0.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·) (parameterized by k)</td>

            <td class="px-3 py-2 border-b border-gray-700">If V(⟨x1, ..., xn⟩) = True and n ≥ 2k, the value R(C) is the majority bit of v1, ..., vk where xi = ⟨vi, ρi⟩; otherwise (i.e., the case V(⟨x1, ..., xn⟩) = False or n < 2k) the output value is undefined.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution function I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">I(st, C, round, INPUT()) is equal to ⟨v, ρ⟩ if the input tape contains (INSERT, v); ρ is a random κ-bit string. The state st remains always ε.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 5: Protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  over the Bitcoin backbone via the specification of  <span class="math">V(\\cdot), R(\\cdot), I(\\cdot)</span> .</p>

    <p class="text-gray-300">Lemma 20 (Agreement). Under the Honest Majority Assumption, it holds that  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  from Fig. 5 parameterized with  <span class="math">k = \\lceil 2f\\lambda \\rceil</span>  running for a total number of rounds  <span class="math">L \\geq 4k/f</span> , satisfies Agreement with probability at least  <span class="math">1 - e^{-\\Omega(\\epsilon^2 f\\lambda)}</span> .</p>

    <p class="text-gray-300">Proof. In order for agreement to be satisfied, it suffices to argue that the chains of all honest parties begin with the same  <span class="math">k</span>  blocks. Note that in a typical execution, by Lemma 11 and the Chain-Growth Lemma, upon termination (i.e., after  <span class="math">L</span>  rounds) the chain of every honest party has more than  <span class="math">(1 - \\epsilon)fL \\geq 4(1 - \\epsilon)k &amp;gt; 2k</span>  blocks (for the inequality note that  <span class="math">\\epsilon \\leq \\delta / 3 &amp;lt; 1/2</span> ). Therefore, disagreement in the first  <span class="math">k</span>  blocks among two chains  <span class="math">\\mathcal{C}_1</span>  and  <span class="math">\\mathcal{C}_2</span>  implies  <span class="math">\\mathcal{C}_1^{\\lceil k \\rceil} \\not\\leq \\mathcal{C}_2</span> , in violation of the common prefix property. The statement follows by Theorem 15, assuming a typical execution.</p>

    <p class="text-gray-300">We now turn to the Validity property. In order to prove it we need to show that, upon termination of the protocol, the chain of any honest party will contain among the first  <span class="math">k</span>  inputs more inputs from honest players than provided by the adversary. As we will see, this is a consequence of the chain quality property.</p>

    <p class="text-gray-300">Lemma 21 (Validity). Under the Honest Majority Assumption strengthened so that  <span class="math">t \\leq \\frac{1 - \\delta}{2} \\cdot (n - t)</span> , it holds that  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  from Fig. 5 parameterized with  <span class="math">k = \\lceil 2f\\lambda \\rceil</span>  running for a total number of rounds  <span class="math">L \\geq 4k/f</span> , satisfies Validity (cf. Definition 2) with probability at least  <span class="math">1 - e^{-\\Omega(\\epsilon^2 f\\lambda)}</span> .</p>

    <p class="text-gray-300">roof.</p>

    <p class="text-gray-300">For the property to be satisfied we only need to ensure that among the first <span class="math">k</span> blocks of any chain <span class="math">\\mathcal{C}</span> that belongs to an honest party upon termination, the majority of the inputs was computed by the honest parties. Assuming a typical execution, Theorem 16 applies <span class="math">k\\geq 2f\\lambda</span> and the fraction of adversarial blocks is less than <span class="math">\\frac{t}{n-t}+\\frac{\\delta}{2}\\leq\\frac{1}{2}</span>. ∎</p>

    <p class="text-gray-300">Note that <span class="math">\\Pi_{\\text{BA}}^{1/3}</span> solves BA only in case the adversary’s hashing power is bounded by <span class="math">1/3</span>. In case adversarial blocks win all head-to-head races within a round (as it is the case with a rushing adversary), the result is tight, as argued in Remark 4. In the next section we show a more elaborate construction based on a transaction ledger which can tolerate an adversary with hashing power bounded by <span class="math">1/2</span>.</p>

    <p class="text-gray-300">We can thus state the following.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Theorem 22.</h6>

    <p class="text-gray-300">Under the Honest Majority Assumption strengthened so that <span class="math">t\\leq\\frac{1-\\delta}{2}\\cdot(n-t)</span>, it holds that protocol <span class="math">\\Pi_{\\text{BA}}^{1/3}</span> parameterized with <span class="math">k=2f\\lambda</span> running for a total number of rounds <span class="math">L\\geq 4k/f</span>, satisfies Agreement and Validity (cf. Definition 2) with probability at least <span class="math">1-e^{-\\Omega(\\epsilon^{2}f\\lambda)}</span>.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Remark 5.</h6>

    <p class="text-gray-300">In particular, setting <span class="math">\\lambda=\\Theta(\\log^{2}\\kappa)</span>, we can achieve negligible probability of error in <span class="math">O(\\log^{2}\\kappa)</span> rounds.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Remark 6.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As mentioned in Section 2, “Strong Validity” refers to the requirement that the output value be one of the honest parties’ inputs, and the distinction is relevant in the case of non-binary inputs, i.e., coming from an arbitrary set <span class="math">V</span>, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>2<span class="math">. It is easy to modify the above algorithm to also satisfy this property by making the chain reading function the element with highest plurality in the chain (ties broken favoring the lexicographically smallest element in </span>V<span class="math">), as opposed to majority, and by imposing a more stringent bound on the adversary, namely, by bounding the hashing power of the adversary by </span>(1-\\delta)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. This ensures that the expected number of blocks in the blockchain that are controlled by the adversary is less than </span>\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, and maintains validity even in the worst case that the honest parties’ inputs are equally split among all possible values but one (i.e., there are </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1$ inputs equally proportioned among the honest parties). Agreement is ensured in the same way as before via the common prefix property.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 7.</h6>

    <p class="text-gray-300">It is interesting to note that to successfully solve consensus with protocol <span class="math">\\Pi_{\\text{BA}}^{1/3}</span>, we do not need to know the precise number of parties before hand. A crude estimate <span class="math">\\frac{N}{c}\\leq n\\leq N</span> for some constant <span class="math">c</span>, suffices to obtain the same results. In particular, we may state the following.</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Theorem 23.</h6>

    <p class="text-gray-300">Under the Honest Majority Assumption strengthened so that <span class="math">t\\leq\\frac{1-\\delta}{2}\\cdot(n-t)</span> and assuming <span class="math">\\frac{N}{c}\\leq n\\leq N</span> for some constant <span class="math">c</span>, it holds that protocol <span class="math">\\Pi_{\\text{BA}}^{1/3}</span> parameterized with <span class="math">k=\\lceil 2f\\lambda\\rceil</span> running for a total number of rounds <span class="math">L\\geq 4ck/f</span>, satisfies Agreement and Validity (cf. Definition 2) with probability at least <span class="math">1-e^{-\\Omega(\\epsilon^{2}f\\lambda)}</span>.</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The parameter of interest is <span class="math">f</span>, which depends on the values of <span class="math">n</span> and <span class="math">T</span>. We may run the protocol with the parameters chosen for the extreme case <span class="math">n=N</span>. Note that this implies that the probability of a successful round <span class="math">f^{\\prime}</span> will be less than <span class="math">f</span>. It is not hard to verify, however, that <span class="math">f^{\\prime}\\geq f/c</span>. Allowing the protocol to run <span class="math">c</span> times longer, the same analysis holds. ∎</p>

    <h2 id="sec-42" class="text-2xl font-bold">6 Public Transaction Ledgers</h2>

    <p class="text-gray-300">We now come to the application which the Bitcoin backbone was designed to solve: maintaining a public transaction ledger. We first formally introduce this object — a “book” where transactions are recorded — and its properties, and then we show how it can be used to implement the Bitcoin ledger and BA in the honest majority setting by properly instantiating the notion of a transaction.</p>

    <p class="text-gray-300">A public transaction ledger is defined with respect to a set of valid ledgers  <span class="math">\\mathcal{L}</span>  and a set of valid transactions  <span class="math">\\mathcal{T}</span> , each one possessing an efficient membership test. A ledger  <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>  is a vector of sequences of transactions  <span class="math">\\mathrm{tx} \\in \\mathcal{T}</span> . Each transaction  <span class="math">\\mathrm{tx}</span>  may be associated with one or more accounts, denoted  <span class="math">a_1, a_2, \\ldots</span>  etc.</p>

    <p class="text-gray-300">The backbone protocol parties, called miners in the context of this section, process sequences of transactions of the form  <span class="math">x = \\mathrm{tx}_1 \\ldots \\mathrm{tx}_e</span>  that are supposed to be incorporated into their local chain  <span class="math">\\mathcal{C}</span> . The input inserted at each block of the chain  <span class="math">\\mathcal{C}</span>  is the sequence  <span class="math">x</span>  of transactions. Thus, a ledger is a vector of transaction sequences  <span class="math">\\langle x_1, \\ldots, x_m \\rangle</span> , and a chain  <span class="math">\\mathcal{C}</span>  of length  <span class="math">m</span>  contains the ledger  <span class="math">\\mathbf{x}_{\\mathcal{C}} = \\langle x_1, \\ldots, x_m \\rangle</span>  if the input of the  <span class="math">j</span> -th block in  <span class="math">\\mathcal{C}</span>  is  <span class="math">x_j</span> . The position of transaction  <span class="math">\\mathrm{tx}_j</span>  in the ledger  <span class="math">\\mathbf{x}_{\\mathcal{C}}</span>  is the pair  <span class="math">(i,j)</span>  where  <span class="math">x_i = \\mathrm{tx}_1 \\ldots \\mathrm{tx}_e</span> .</p>

    <p class="text-gray-300">The description and properties of the ledger protocol will be expressed relative to an oracle Txgen which will control a set of accounts by creating them and issuing transactions on their behalf. In an execution of the backbone protocol, the environment  <span class="math">\\mathcal{Z}</span>  as well as the miners will have access to Txgen. Specifically, Txgen is a stateful oracle that responds to two types of queries (which we purposely only describe at a high level):</p>

    <p class="text-gray-300">GenAccount  <span class="math">(1^{\\kappa})</span>  : It generates an account  <span class="math">a</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IssueTrans  <span class="math">(1^{\\kappa},\\hat{\\mathrm{tx}})</span> : It returns a transaction tx provided that  <span class="math">\\hat{\\mathrm{tx}}</span>  is some suitably formed string, or  <span class="math">\\perp</span> .</li>

    </ul>

    <p class="text-gray-300">We also consider a symmetric relation on  <span class="math">\\mathcal{T}</span> , denoted by  <span class="math">C(\\cdot, \\cdot)</span> , which indicates when two transactions  <span class="math">\\mathrm{tx}_1, \\mathrm{tx}_2</span>  are conflicting. Valid ledgers  <span class="math">\\mathbf{x} \\in \\mathcal{L}</span>  can never contain two conflicting transactions. We call oracle Txgen unambiguous if it holds that for all PPT  <span class="math">\\mathcal{A}</span> , the probability that  <span class="math">\\mathcal{A}^{\\mathrm{Txgen}}</span>  produces a transaction  <span class="math">\\mathrm{tx}&#x27;</span>  such that  <span class="math">C(\\mathrm{tx}&#x27;, \\mathrm{tx}) = 1</span> , for a tx issued by Txgen, is negligible in  <span class="math">\\kappa</span> . We only consider unambiguous Txgen oracles. Moreover, to simplify the exposition of this section, we will assume that any sequence of non-conflicting transactions constitutes a valid ledger (our results, however, hold for even more constrained ledger languages — cf. Section 6.2).</p>

    <p class="text-gray-300">Finally, a transaction tx is called neutral if  <span class="math">C(\\mathrm{tx},\\mathrm{tx}^{\\prime}) = 0</span>  for any other transaction  <span class="math">\\mathrm{tx}^{\\prime}</span> . The presence of neutral transactions in the ledger can be helpful for a variety of purposes, as we will see next and in the BA protocol that we build on top of the ledger. For convenience we will assume that a single random nonce  <span class="math">\\rho \\in \\{0,1\\}^{\\kappa}</span>  is also a valid transaction. Nonces will be neutral transactions and may be included in the ledger for the sole purpose of ensuring independence between the POW instances solved by the honest parties.</p>

    <p class="text-gray-300">Next, we determine the three functions  <span class="math">V(\\cdot), I(\\cdot), R(\\cdot)</span>  that will turn the backbone protocol into  <span class="math">\\Pi_{\\mathsf{PL}}</span> , a protocol realizing a public transaction ledger. See Figure 6.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Content validation predicate V(·)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V(⟨x1, ..., xm⟩) is true if and only if the vector ⟨x1, ..., xm⟩ is a valid ledger, i.e., ⟨x1, ..., xm⟩ ∈ L.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Chain reading function R(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">If V(⟨x1, ..., xm⟩) = True, the value R(C) is equal to ⟨x1, ..., xm⟩; undefined otherwise.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Input contribution function I(·)</td>

            <td class="px-3 py-2 border-b border-gray-700">I(st, C, round, INPUT()) operates as follows: if the input tape contains (INSERT, v), it parses v as a sequence of transactions and retains the largest subsequence x' ≤ v that is valid with respect to xC (and whose transactions are not already included in xC). Finally, x = tx0x' where tx0 is a neutral random nonce transaction. The state st remains always ε.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 6: The public transaction ledger protocol  <span class="math">\\Pi_{\\mathsf{PL}}</span> , built on the Bitcoin backbone.</p>

    <p class="text-gray-300">We now introduce two essential properties for a protocol maintaining a public transaction ledger: (i) Persistence and (ii) Liveness. In a nutshell, Persistence states that once an honest player reports a transaction "deep enough" in the ledger, then all other honest players will report it indefinitely whenever they are asked, and at exactly the same position in the ledger (essentially, this means that all honest players agree on all the transactions that took place and in what order). In a more concrete Bitcoin-like setting, Persistence is essential to ensure that credits are final and that they happened at a certain "time" in the system's timeline (which is implicitly defined by the ledger itself).</p>

    <p class="text-gray-300">Note that Persistence is useful but not enough to ensure that the ledger makes progress, i.e., that transactions are eventually inserted in a chain. This is captured by the Liveness property, which states that as long as a transaction comes from an honest account holder and is provided by the environment to all honest players, then it will be inserted into the honest players' ledgers, assuming the environment keeps providing it as an input for a sufficient number of rounds.[19]</p>

    <p class="text-gray-300">We define the two properties below.[20]</p>

    <p class="text-gray-300">Definition 24. A protocol  <span class="math">\\Pi</span>  implements a robust public transaction ledger in the  <span class="math">q</span> -bounded synchronous setting if it organizes the ledger as a hashchain of blocks of transactions and it satisfies the following two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Persistence: Parameterized by  <span class="math">k \\in \\mathbb{N}</span>  (the "depth" parameter), if in a certain round an honest player reports a ledger that contains a transaction tx in a block more than  <span class="math">k</span>  blocks away from the end of the ledger (such transaction will be called "stable"), then tx will be reported by any honest player in the same position in the ledger, from this round on.</li>

      <li>Liveness: Parameterized by  <span class="math">u, k \\in \\mathbb{N}</span>  (the "wait time" and "depth" parameters, resp.), provided that a transaction either (i) issued by Txgen, or (ii) is neutral, is given as input to all honest players continuously for  <span class="math">u</span>  consecutive rounds, then all honest parties will report this transaction more than  <span class="math">k</span>  blocks from the end of the ledger, i.e., all report it as stable.</li>

    </ul>

    <p class="text-gray-300">Remark 8. Since in our model we abstract the transaction transmission to happen within the environment program  <span class="math">\\mathcal{Z}</span> , we require that all honest parties should be given as input (from  <span class="math">\\mathcal{Z}</span> ) each transaction so that the liveness property will guarantee its inclusion to the ledger. An alternate formulation of the liveness property that would require transaction exchange between parties is possible, in which case a single honest party would suffice to receive it as input.</p>

    <p class="text-gray-300">We prove the two properties separately, starting with Persistence. We note first that it is essential to require that the stability of the transaction is reported from the "next round on" from the time that an honest party reports it as stable. Indeed, it is not guaranteed that parties simultaneously report a transaction as stable: the adversary may advance the chain of a certain player at a specific round and thus make the transaction appear as stable when the environment checks it; nevertheless at that round other honest parties may still have chains that have not advanced sufficiently enough and thus report the transaction as not stable. This is akin to the lack of simultaneous termination in early-stopping consensus protocols (cf. [DRS90]).</p>

    <p class="text-gray-300">The proof is essentially based on the common prefix property of the backbone protocol (recall Definition 3 and Theorem 15).</p>

    <p class="text-gray-300"><strong>Lemma 25 (Persistence).</strong> Under the Honest Majority Assumption, it holds that <span class="math">\\Pi_{\\mathsf{PL}}</span> from Fig. 6 parameterized with <span class="math">k = \\lceil 2\\lambda f\\rceil</span> satisfies Persistence (cf. Definition 24) with probability at least <span class="math">1 - e^{-\\Omega (\\epsilon^2\\lambda f)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider a typical execution and let <span class="math">\\mathcal{C}_1</span> be the chain of honest player <span class="math">P_1</span> at round <span class="math">r_1</span>. Suppose a transaction tx is included in <span class="math">\\mathcal{C}_1^{\\lceil k\\rceil}</span> at round <span class="math">r_1</span> (i.e., it is stable). Consider the chain <span class="math">\\mathcal{C}_2</span> of an honest party <span class="math">P_2</span> at a round <span class="math">r_2 \\geq r_1</span>. By the common prefix property, <span class="math">\\mathcal{C}_1^{\\lceil k\\rceil} \\preceq \\mathcal{C}_2</span>. The statement follows.</p>

    <p class="text-gray-300">We next prove Liveness, which is based on the chain quality property (recall Definition 4 and Theorem 16) and the fact that the chain of honest parties grows at least as fast as the number of blocks they produce (proven in Chain Growth Lemma 7).</p>

    <p class="text-gray-300"><strong>Lemma 26 (Liveness).</strong> Under the Honest Majority Assumption, it holds that <span class="math">\\Pi_{\\mathsf{PL}}</span> from Fig. 6 parameterized with <span class="math">u = \\lceil 4\\lambda /(1 - \\epsilon)\\rceil</span> rounds and <span class="math">k = \\lceil 2\\lambda f\\rceil</span> satisfies Liveness (cf. Definition 24) with probability at least <span class="math">1 - e^{-\\Omega (\\epsilon^2\\lambda f)}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> We prove that assuming all honest players receive as input the transaction tx for at least <span class="math">u</span> rounds, then in a typical execution there exists an honest party with chain <span class="math">\\mathcal{C}</span> such that tx is included in <span class="math">\\mathcal{C}^{\\lceil k\\rceil}</span>. Indeed, in a typical execution, after <span class="math">u</span> rounds the honest parties have at least <span class="math">4\\lambda f = 2k</span> successful rounds. Invoking Chain Growth Lemma (Lemma 7), we infer that the chain's length of any honest party has increased by at least <span class="math">2k</span> blocks.</p>

    <p class="text-gray-300">Finally, the chain quality property (Theorem 16) implies that at least one of the blocks in the length-<span class="math">k</span> suffix of <span class="math">\\mathcal{C}^{\\lceil k\\rceil}</span> was computed by an honest party. Such a block would include tx since it is infeasible for adversarial <span class="math">\\mathcal{Z},\\mathcal{A}</span> to produce a conflicting transaction <span class="math">\\mathrm{tx}&#x27;</span> (which would be the only event making an honest player drop tx from the sequence of transactions <span class="math">x</span> that it attempts to insert in the blockchain). Thus, the lemma follows.</p>

    <h2 id="sec-44" class="text-2xl font-bold">6.2 Bitcoin-like transactions and ledger</h2>

    <p class="text-gray-300">Next, we show how to instantiate the public transaction ledger for Bitcoin, by defining the sets of transactions and valid ledgers.</p>

    <p class="text-gray-300">Transactions and accounts are defined with respect to a digital signature scheme that is comprised of three algorithms <span class="math">\\langle \\text{KeyGen}, \\text{Sign}, \\text{Verify} \\rangle</span>. An account will be a pair <span class="math">a = (vk, G(vk))</span> where <span class="math">G(\\cdot)</span> is a hash function and <span class="math">G(vk)</span> is the "address" corresponding to the account.</p>

    <p class="text-gray-300">A transaction tx is of the form “ <span class="math">\\{a_1, a_2, \\ldots, a_i\\} \\to (\\sigma, \\{(a_1&#x27;, b_1&#x27;), \\ldots, (a_o&#x27;, b_o&#x27;)\\})</span> ” where <span class="math">a_1, \\ldots, a_i</span> are the accounts to be debited, <span class="math">a_1&#x27;, \\ldots, a_o&#x27;</span> are the addresses of the accounts to be credited with funds <span class="math">b_1&#x27;, \\ldots, b_o&#x27;</span>, respectively, and <span class="math">\\sigma</span> is a vector <span class="math">\\langle (vk_1, \\sigma_1), \\ldots, (vk_i, \\sigma_i) \\rangle</span> of verification keys and digital signatures issued under them, on the same message <span class="math">\\{(a_1&#x27;, b_1&#x27;), \\ldots, (a_o&#x27;, b_o&#x27;)\\}</span>. (We note that Bitcoin transactions can be more expressive but the above description is sufficient for the purpose of our analysis).</p>

    <p class="text-gray-300">Next, we specify the Txgen oracle, which in the context of our analysis abstracts transaction generation on behalf of the honest users.</p>

    <p class="text-gray-300">21 In bitcoin terminology every account has an address that is used to uniquely identify it. Payments directed to an account require only this "bitcoin address." The actual verification key corresponding to the account will be revealed only when the account makes a payment.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>GenAccount(1^κ): It generates an account a by running KeyGen and computing the hash G(·) on the verification key. The account is the pair (vk, G(vk)), where G(vk) is the account's address. The corresponding secret key, sk, is kept in the state of Txgen.</li>

      <li>IssueTrans(1^κ, t̂x): It returns a transaction tx provided that t̂x is a transaction that is only missing the signatures by accounts that are maintained by Txgen. (Recall the format of transactions above.) Each account is only allowed a single transaction.</li>

    </ul>

    <p class="text-gray-300">Note that the above restriction on IssueTrans is without loss of generality, as in Bitcoin, entities typically maintain a number of accounts and are allowed (although not forced) to move their balances forward to a new account as they make new transactions. The conflict relation C(·, ·) over T satisfies that C(tx1, tx2) = 1 if and only if tx1 ≠ tx2 and tx1, tx2 have an input account in common²². Thus, we can easily prove the unambiguity of the Txgen oracle based on the unforgeability of the underlying digital signature.</p>

    <p class="text-gray-300"><strong>Lemma 27.</strong> Assume that ⟨KeyGen, Sign, Verify⟩ is an existentially unforgeable signature scheme. Then oracle Txgen is unambiguous.</p>

    <p class="text-gray-300">In order to define the set of valid Bitcoin ledgers we first need to determine in what sense a transaction may be valid with respect to a ledger. Then we will define the set of valid ledgers recursively as the maximal set of vectors of sequences of transactions that satisfy this condition. So here it goes.</p>

    <p class="text-gray-300">A transaction tx is valid with respect to a Bitcoin ledger x = ⟨x1, ..., xm⟩ provided that all digital signatures verify and ∑j=1^i b_j ≥ ∑j=1^o b_j', where b_j is the balance that was credited to account a_j in the latest transaction involving a_j in x. In case e = ∑j=1^i b_j - ∑j=1^o b_j' &gt; 0, then e is a transaction fee that may be claimed separately in a special transaction of the form “∅ → ...,” called a coinbase transaction. In more detail, a coinbase transaction has no inputs and its purpose is to enable miners to be rewarded for maintaining the legder. The transaction is of the form “∅ → {(a1, b1), ..., (a0, b0)},” and ∑j=1^o b_j is determined based on the other transactions that are “bundled” in the block as well as a flat reward fee, as explain below.</p>

    <p class="text-gray-300">A sequence of transactions x = ⟨∅ → {(a1, b1), ..., (a0, b0)}, tx1, ..., txl⟩ is said to be valid with respect to a ledger x = ⟨x1, ..., xm⟩, if each transaction tx_j is valid with respect to the ledger x extended by the transactions tx1, ..., tx_{j-1}. I.e., for all j = 1, ..., l the transaction tx_j should be valid with respect to ledger</p>

    <p class="text-gray-300">⟨x1, ..., xm, tx1 ... tx_{j-1}⟩,</p>

    <p class="text-gray-300">and furthermore, the total fee e = ∑j=1^o b_j collected in the transaction ∅ → {(a1, b1), ..., (a0, b0)} does not exceed r_m + ∑j=1^m e_j, which includes all the individual fees corresponding to transactions tx1, ..., tx_e, plus a value r_m that is the flat reward given for extending a ledger of length m to a ledger of length m + 1.²³</p>

    <p class="text-gray-300">The set of valid ledgers ℓ with respect to a reward progression {r_j}_{j ∈ ℕ} contains ε (the empty ledger), and any ledger x which extends a ledger in ℓ by a valid sequence of transactions. Note that the first transaction sequence of any ledger x ∈ ℓ contains a single transaction of the form ∅ → {(a1, b1), ..., (a0, b0)} that satisfies ∑j=1^o b_j = r_0, where r_0 is the initial flat reward. This first transaction “distributes an initial amount of money” to the ledger’s initiator(s).²⁴ It is easy to see that ℓ has an efficient membership test.</p>

    <p class="text-gray-300">²²The conflict relation is more permissive in the actual Bitcoin ledger. We adopt the more simplified version given above as it does not change the gist of the analysis.</p>

    <p class="text-gray-300">²³Originally, the flat reward for extending the Bitcoin chain was 50 BTC. The sequence r_0, r_1, ... for Bitcoin follows a geometric progression with large constant intervals.</p>

    <p class="text-gray-300">²⁴In the case of Bitcoin, it was supposedly Nakamoto himself who collected this first reward of 50 BTC.</p>

    <p class="text-gray-300">33</p>

    <p class="text-gray-300">Given the existence of coinbase transactions in this application we can do away with random nonces as standalone transactions and the description of the input contribution function <span class="math">I</span> in Fig. 6, is modified to include their generation each time an input sequence of transactions is determined to be inserted in the ledger. Specifically, <span class="math">I(\\cdot)</span> will form a <em>coinbase transaction</em> <span class="math">\\emptyset\\to\\{(a,b)\\}</span>, where <span class="math">b=r_{\\mathrm{len}(\\mathcal{C})}+\\sum_{j=1}^{m}e_{j}</span> and <span class="math">e_{j}</span> is the fee corresponding to <span class="math">x</span>’s <span class="math">j</span>-th transaction. Account <span class="math">a</span> is a freshly created account that is obtained via running KeyGen. <span class="math">I(\\cdot)</span> will append account <span class="math">a</span> and the corresponding <span class="math">(vk,sk)</span> to its private state <span class="math">st</span>.</p>

    <p class="text-gray-300">We will refer to the modified <span class="math">\\Pi_{\\mathsf{PL}}</span> protocol by the moniker <span class="math">\\Pi_{\\mathsf{BTC}}</span>. <span class="math">\\Pi_{\\mathsf{BTC}}</span> inherits from <span class="math">\\Pi_{\\mathsf{PL}}</span> the properties of Persistence and Liveness which will ensure the following with overwhelming probability in <span class="math">k</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Apart from its latest <span class="math">k</span> blocks, the transaction ledger is fixed and immutable for all honest miners.</li>

      <li>If a majority of miners receive an honest transaction and attempt to insert it following the protocol for a sufficient number of rounds (equal to parameter <span class="math">u</span>, the “wait time”), it will become a permanent entry in the ledger (no matter the adversarial strategy of the remaining miners).</li>

    </ul>

    <h6 id="sec-45" class="text-base font-medium mt-4">Remark 9.</h6>

    <p class="text-gray-300">We remark that in the adaptive corruption setting, the Txgen oracle would safeguard the keys of honest parties from the adversary.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">6.3 Byzantine agreement for honest majority</h3>

    <p class="text-gray-300">We now use the public transaction ledger formulation to achieve POW-based BA for an honest majority by properly instantiating the notion of a transaction, thus improving on the simple BA protocol tolerating a <span class="math">(1/3)</span>-bounded adversary presented in Section 5.</p>

    <p class="text-gray-300">Here we consider a set of valid ledgers <span class="math">\\mathcal{L}</span> that contain sequences of transactions of the form <span class="math">\\langle nonce,v,ctr\\rangle</span>, and satisfy the predicate:</p>

    <p class="text-gray-300"><span class="math">(H_{1}(ctr,G(nonce,v))&lt;T)\\wedge(ctr\\leq q),</span> (2)</p>

    <p class="text-gray-300">where <span class="math">H_{1}(\\cdot),G(\\cdot)</span> are two hash functions as in the definition of the backbone protocol, and <span class="math">v\\in\\{0,1\\}</span> is a party’s input. (Recall that <span class="math">T</span> is the difficulty level and <span class="math">q</span> determines how many calls to <span class="math">H_{1}(\\cdot)</span> a party is allowed to make per round.) To distinguish the oracles, in this section we will use <span class="math">H_{0}(\\cdot)</span> to refer to the oracle used in the backbone protocol.</p>

    <p class="text-gray-300">For the ledger we consider in this section, there will be no accounts and all transactions will be neutral — i.e., the conflict predicate <span class="math">C(\\cdot,\\cdot)</span> will be false for all pairs of transactions.</p>

    <p class="text-gray-300">We first provide a high level description of the BA protocol assuming parties have <span class="math">q</span> queries per round to each oracle <span class="math">H_{0}(\\cdot),H_{1}(\\cdot)</span>. We then show how to use a single oracle <span class="math">H(\\cdot)</span> to achieve the combined functionality of both of them while only using <span class="math">q</span> queries per round.</p>

    <p class="text-gray-300">At a high level, the protocol, <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>, works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Operation:</em> In each round, parties run two protocols in parallel. The first protocol is protocol <span class="math">\\Pi_{\\mathsf{PL}}</span> (Fig. 6), which maintains the transaction ledger and requires <span class="math">q</span> queries to the oracle <span class="math">H_{0}(\\cdot)</span>. The second process is a “transaction production” protocol <span class="math">\\Pi_{\\mathsf{tx}}</span> (Fig. 7), which continuously generates transactions satisfying predicate (2). The protocol makes <span class="math">q</span> queries to the <span class="math">H_{1}(\\cdot)</span> oracle.</li>

      <li><em>Termination:</em> After (a predetermined) round <span class="math">L</span>, a party collects all the unique POW transactions that are present in the first <span class="math">\\lceil\\frac{9k}{\\delta}\\rceil+k</span> blocks and returns the majority bit from the bits</li>

    </ul>

    <p class="text-gray-300">Algorithm 5 The POW-based transaction production protocol  <span class="math">\\Pi_{\\mathrm{tx}}</span> , parameterized by  <span class="math">q</span> ,  <span class="math">T</span>  and hash functions  <span class="math">H_{1}(\\cdot), G(\\cdot)</span> . 1:  <span class="math">v\\gets \\mathrm{INPUT}()</span> 2:  <span class="math">ctr\\gets 1</span> 3:  <span class="math">\\mathrm{tx}\\gets \\varepsilon</span> 4:  <span class="math">h\\gets G(nonce,v)</span> <span class="math">\\triangleright</span>  nonce is a random  <span class="math">\\kappa</span>  -bit string 5: while  <span class="math">(ctr\\leq q)</span>  do 6: if  <span class="math">(H_{1}(ctr,h) &amp;lt;   T)</span>  then  <span class="math">\\triangleright</span>  Proof of work succeeded 7:  <span class="math">\\mathrm{tx}\\gets \\langle nonce,v,ctr\\rangle</span> 8: break 9: end if 10:  <span class="math">ctr\\gets ctr + 1</span> 11: end while 12: BROADCAST(tx)</p>

    <p class="text-gray-300">Figure 7: The transaction production protocol  <span class="math">\\Pi_{\\mathrm{tx}}</span></p>

    <p class="text-gray-300">occurring in these transactions (note that uniqueness takes also the nonce of each transaction into account).</p>

    <p class="text-gray-300">As described, protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  does not conform to the  <span class="math">q</span> -bounded setting since parties require  <span class="math">q</span>  queries to oracle  <span class="math">H_0(\\cdot)</span>  and  <span class="math">q</span>  queries to oracle  <span class="math">H_1(\\cdot)</span>  to perform the computation of a single round (the setting imposes a bound of  <span class="math">q</span>  queries to a single oracle for all parties). Note that a naive simulation of  <span class="math">H_0(\\cdot), H_1(\\cdot)</span>  by a single oracle  <span class="math">H(\\cdot)</span>  in the  <span class="math">(2q)</span> -bounded setting (e.g., by setting  <span class="math">H_b(x) = H(b,x)</span> ) would violate the restriction imposed on each oracle individually, since nothing would prevent the adversary, for example, from querying  <span class="math">H_0(\\cdot)</span> <span class="math">2q</span>  times. Next, we show how we can combine the two protocols into a single protocol that utilizes at most  <span class="math">q</span>  queries to a single random oracle in a way that the adversary will remain  <span class="math">q</span> -bounded for each oracle. This transformation, explained below, completes the description of  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span> .</p>

    <p class="text-gray-300">2-for-1 POWs. We now tackle the problem of how to turn a protocol operation that uses two separate POW subprocedures involving two distinct and independent oracles  <span class="math">H_0(\\cdot), H_1(\\cdot)</span>  into a protocol that utilizes a single oracle  <span class="math">H(\\cdot)</span>  for a total number of  <span class="math">q</span>  queries per round. Our transformation is general and works for any pair of protocols that utilize  <span class="math">H_0(\\cdot), H_1(\\cdot)</span> , provided that certain conditions are met (which are satisfied by protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  above). In more detail, we consider two protocols  <span class="math">\\Pi_0, \\Pi_1</span>  that utilize a POW step as shown in Algorithm 6 in Figure 8.</p>

    <p class="text-gray-300">In order to achieve composition of the two protocols  <span class="math">\\Pi_0, \\Pi_1</span>  in the  <span class="math">q</span> -bounded setting with access to a single oracle  <span class="math">H(\\cdot)</span> , we will substitute steps 2-11 in both protocols with a call to a new function, double-pow, defined below. First, observe that in  <span class="math">\\Pi_b</span> ,  <span class="math">b \\in \\{0,1\\}</span> , the POW steps 2-11 operate with input  <span class="math">w_b</span>  and produce output in  <span class="math">B_b</span>  if the POW succeeds. The probability of obtaining a solution is  <span class="math">T \\cdot 2^{-\\kappa}</span> .</p>

    <p class="text-gray-300">The modification consists in changing the structure of the POWs from pairs of the form  <span class="math">(w,ctr)</span>  to triples of the form  <span class="math">(w,ctr,label)</span> , where  <span class="math">label</span>  is a  <span class="math">\\kappa</span> -bit string that is neutral from the point of view of the proof. This will further require the modification of the verification step for POWs in both protocols  <span class="math">\\Pi_0,\\Pi_1</span>  in the following manner.</p>

    <p class="text-gray-300">Algorithm 6 POW-based protocol fragment of  <span class="math">\\Pi_b</span> ,  <span class="math">b \\in \\{0,1\\}</span>  parameterized by  <span class="math">q</span> ,  <span class="math">T</span>  and hash functions  <span class="math">H_{b}(\\cdot), G(\\cdot)</span> ,  <span class="math">b \\in \\{0,1\\}</span> . The value  <span class="math">w_{b}</span>  is determined from the protocol's context.</p>

    <p class="text-gray-300">1: ... ▷ Value  <span class="math">w_{b}</span>  is determined 2:  <span class="math">ctr \\gets 1</span> 3:  <span class="math">B_{b}\\gets \\varepsilon</span> 4:  <span class="math">h_b\\gets G(w_b)</span> 5: while  <span class="math">(ctr\\leq q)</span>  do 6: if  <span class="math">(H(ctr,h_b) &amp;lt;   T)</span>  then 7:  <span class="math">B_{b}\\gets \\langle w_{b},ctr\\rangle</span> 8: break 9: end if 10:  <span class="math">ctr\\gets ctr + 1</span> 11: end while 12: ... ▷ The POW  <span class="math">B</span>  is exploited here</p>

    <p class="text-gray-300">Algorithm 7 The double proof of work function, parameterized by  <span class="math">q</span> ,  <span class="math">T</span>  and hash functions  <span class="math">H(\\cdot), G(\\cdot)</span>  that substitutes steps 2-11 of two POW-based protocols.</p>

    <p class="text-gray-300">1: function double-pow  <span class="math">(w_0, w_1)</span> 2:  <span class="math">B_0, B_1 \\gets \\varepsilon</span> 3:  <span class="math">ctr \\gets 1</span> 4:  <span class="math">h \\gets \\langle G(w_0), G(w_1) \\rangle</span> 5: while  <span class="math">(ctr \\leq q)</span>  do 6:  <span class="math">u \\gets H(ctr, h)</span> 7: if  <span class="math">(u &amp;lt; T) \\land (B_0 = \\varepsilon)</span>  then 8:  <span class="math">B_0 \\gets \\langle w_0, ctr, G(w_1) \\rangle</span> 9: end if 10: if  <span class="math">([u]^{\\mathsf{R}} &amp;lt; T) \\land (B_1 = \\varepsilon)</span>  then 11:  <span class="math">B_1 \\gets \\langle w_1, ctr, G(w_0) \\rangle</span> 12: end if 13:  <span class="math">ctr \\gets ctr + 1</span> 14: end while 15: return  <span class="math">\\langle B_0, B_1 \\rangle</span> 16: end function</p>

    <p class="text-gray-300">Figure 8: The 2-for-1 POW transformation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any verification step in  <span class="math">\\Pi_0</span>  of a POW  <span class="math">\\langle w_0, ctr \\rangle</span>  which is of the form  <span class="math">H(ctr, G(w_0)) &amp;lt; T</span> , will now operate with a POW of the form  <span class="math">\\langle w_0, ctr, label \\rangle</span>  and will verify the relation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">H (c t r, \\langle G (w _ {0}), l a b e l \\rangle) &amp;lt;   T.</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any verification step in  <span class="math">\\Pi_1</span>  of a POW  <span class="math">\\langle w_1, ctr \\rangle</span>  which is of the form  <span class="math">H(ctr, G(w_1)) &amp;lt; T</span> , will now operate with a POW of the form  <span class="math">\\langle w_1, ctr, label \\rangle</span>  and will verify the relation</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\left[ H (c t r, \\langle l a b e l, G (w _ {1}) \\rangle) \\right] ^ {\\mathsf {R}} &amp;lt;   T,</span></div>

    <p class="text-gray-300">where  <span class="math">[a]^{\\mathsf{R}}</span>  denotes the reverse of the bitstring  <span class="math">a</span> .</p>

    <p class="text-gray-300">This parallel composition strategy in the form of function double-pow is shown in Algorithm 7. Either or both the solutions it returns,  <span class="math">B_0, B_1</span> , may be empty if no solution is found.</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathsf{BA}}^{1/2}</span>  will employ double-pow, which will substitute the individual POW operation of the two underlying protocols  <span class="math">\\Pi_0, \\Pi_1</span>  as defined in lines 2-11 of Algorithm 6. The correctness of the above composition strategy follows from the following simple observation.</p>

    <p class="text-gray-300">Lemma 28. Consider a uniform random variable  <span class="math">U</span>  over the integers in  <span class="math">[0,2^{\\kappa})</span>  and an integer  <span class="math">T</span>  such that  <span class="math">T = 2^{t}</span>  for some positive integer  <span class="math">t &amp;gt; \\kappa /2</span> . Then, the events  <span class="math">(U &amp;lt; T)</span>  and  <span class="math">([U]^{\\mathsf{R}} &amp;lt; T)</span>  are independent and they both occur with probability  <span class="math">T \\cdot 2^{-\\kappa}</span> .</p>

    <p class="text-gray-300">Proof. It is easy to see that each event happens with probability  <span class="math">T \\cdot 2^{-\\kappa}</span> . The conjunction of the two events involves the choice of an integer  <span class="math">U</span>  which satisfies  <span class="math">U &amp;lt; T</span>  and  <span class="math">[U]^{\\mathsf{R}} &amp;lt; T</span> . Observe that because  <span class="math">T = 2^{t}</span> , it follows that the conditioning on  <span class="math">U &amp;lt; T</span>  leaves the  <span class="math">t</span>  least significant bits</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">of <span class="math">U</span> uniformly random while fixing the remaining <span class="math">\\kappa-t</span> bits. Consider the space conditioned on the event <span class="math">U&lt;t</span>. <span class="math">1-e^{-\\Omega(\\epsilon^{2}\\lambda=&quot;&quot; </span>\\lambda="\\Theta(\\log^{2}\\kappa)<span class="math">&quot; </span>\\kappa<span class="math">=&quot;&quot; </span>\\kappa-t<span class="math">=&quot;&quot; </span>\\kappa<span class="math">)=&quot;&quot; </span>\\l\\geq\\frac{12k}{(1-\\epsilon)\\delta="" <span class="math">\\lvert=&quot;&quot; </span>k="\\lvert" <span class="math">k</span>="" <span class="math">l\\geq\\frac{12k}{(1-\\epsilon)\\delta=&quot;&quot; </span>t<span class="math">=&quot;&quot; </span>u\\lvert^{\\mathsf{r}}<t<span class="math">=&quot;&quot; </span>u\\lvert^{\\mathsf{r}}<t<span class="math">=&quot;&quot; </span>u\\lvert^{\\mathsf{r}}<t\\cdot="" (cf.="" <em>[10]</em>.="" 0<span class="math">.=&quot;&quot; 10.=&quot;&quot; 12)=&quot;&quot; 12,=&quot;&quot; 13,=&quot;&quot; 2=&quot;&quot; 2</span>="" 22,="" 29.="" 3.="" 4.="" a="" achieve="" achieved="" after="" an="" and="" as="" assume="" assumption,="" be="" block="" blocks="" by="" chain="" considered="" consensus="" condition="" condition.="" conditions="" conditionally="" considered.="" consens="" contains="" continuous="" d<span class="math">=&quot;&quot; definition=&quot;&quot; directly=&quot;&quot; discussion=&quot;&quot; due=&quot;&quot; e^{-\\Omega(\\epsilon^{2}\\lambda=&quot;&quot; each=&quot;&quot; either=&quot;&quot; end=&quot;&quot; every=&quot;&quot; except=&quot;&quot; except,=&quot;&quot; except.=&quot;&quot; e}^{\\frac{9k}{\\delta}}\\rvert+k</span>="" fact="" few="" finally="" follows="" for="" focus="" following,="" follows.="" for="" form="" from="" growth="" has="" honest="" if="" in="" independent.="" independent.="" input="" is="" it="" k<span class="math">=&quot;&quot; least=&quot;&quot; let=&quot;&quot; let’s=&quot;&quot; length=&quot;&quot; let’s,=&quot;&quot; most=&quot;&quot; m}</span>="" n}<span class="math">),=&quot;&quot; n})</span>.="" n})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">=&quot;&quot; next=&quot;&quot; not=&quot;&quot; note=&quot;&quot; of=&quot;&quot; on=&quot;&quot; optimal=&quot;&quot; optimal,=&quot;&quot; optimal.=&quot;&quot; or=&quot;&quot; other=&quot;&quot; part=&quot;&quot; party’s=&quot;&quot; probability=&quot;&quot; prune=&quot;&quot; prune.=&quot;&quot; prune.=&quot;&quot; prune.=&quot;&quot; prune.=&quot;&quot; random,=&quot;&quot; random.=&quot;&quot; re=&quot;&quot; re,=&quot;&quot; remaining=&quot;&quot; result=&quot;&quot; results=&quot;&quot; round=&quot;&quot; rounds.=&quot;&quot; running=&quot;&quot; same=&quot;&quot; satisfy=&quot;&quot; setting=&quot;&quot; setting,=&quot;&quot; since=&quot;&quot; so=&quot;&quot; solve=&quot;&quot; space,=&quot;&quot; standard=&quot;&quot; states=&quot;&quot; such=&quot;&quot; t</span>="" t\\cdot="" that="" the="" theorem="" these.="" this="" thus="" thus,="" to="" total="" two="" typical="" u\\rvert^{\\mathsf{r}}="" u\\rvert^{\\mathsf{r}}}<t<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}&lt;t\\cdot=&quot;&quot; u\\lvert^{\\mathsf{r}}}&lt;t\\cdot</span>="" u\\lvert^{\\mathsf{r}}}.<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}.</span>="" u\\lvert^{\\mathsf{r}}}.<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}.</span>="" u\\lvert^{\\mathsf{r}}}.<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}.</span>="" u\\lvert^{\\mathsf{r}}}.<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}.</span>="" u\\lvert^{\\mathsf{r}}}.<span class="math">=&quot;&quot; u\\lvert^{\\mathsf{r}}}.</span>="" until="" up="" upper="" v="" we="" where="" with="" work="" z$="" z)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$="" z)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">.=&quot;&quot;&gt;\\lambda</span>. By the chain quality property (see Corollary 17), the last <span class="math">k</span> blocks of <span class="math">\\mathcal{C}</span> do contain an honest block. Thus, for <span class="math">S</span> the set of all the rounds up to the round that this block was computed, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq\\frac{9k}{2\\delta f}<span class="math"> and there are at least </span>X(S)<span class="math"> honest inputs in </span>\\mathcal{C}<span class="math">. On the other hand, the adversarial blocks in </span>\\mathcal{C}<span class="math"> are less than </span>Z(S)+k$. The following sequence of inequalities shows that the majority of inputs are honest.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\frac{Z(S)+k}{X(S)}&lt;\\frac{(1-\\frac{\\delta}{2})X(S)+k}{X(S)}&lt;1-\\frac{\\delta}{2}+\\frac{k}{(1-\\epsilon)f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}&lt;1-\\frac{\\delta}{2}+\\frac{2\\delta fk}{9(1-\\epsilon)fk}&lt;1.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first and second inequality use Lemma 11, the third the lower bound on $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and the fourth </span>\\epsilon&lt;1/3$. Validity follows. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-47" class="text-base font-medium mt-4">Remark 11.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Regarding Strong Validity in the multivalued BA setting, i.e., where the input domain is <span class="math">V</span> and has a constant cardinality strictly larger than <span class="math">2</span> we can adapt the above protocol to return the plurality from the values stored in the transactions that are found in the ledger. In order to ensure strong Validity by this modification we restrict the hashing power of the adversary to $(1-\\delta)/(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1)<span class="math"> since this will ensure that the adversary’s number of transactions cannot overturn the plurality value as defined by the honest parties’ inputs (even if those are evenly distributed amongst them). The bound is in-line with the known bounds for the computational setting with trusted setup, </span>n&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t$, cf. <em>[x11]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-48" class="text-2xl font-bold">7 The Bitcoin Backbone in the Bounded-Delay Model</h2>

    <p class="text-gray-300">We now show how, with relative ease, we can extend our analysis to the bounded delay model with static adversaries. The bounded delay model is identical to the model of Section 2 with the following modifications: (1) the parameter <span class="math">q</span> is fixed to be <span class="math">1</span>, (2) the diffuse functionality allows for <span class="math">\\Delta</span>-delays, i.e., when it inspects the contents of all Receive() strings, it will only include messages that were omitted if they are <span class="math">\\Delta</span> rounds old. Note that <span class="math">\\Delta</span> is a parameter of the execution that is unknown to the honest protocol participants (in contrast to <span class="math">q</span>). Observe that “rounds” still exist in the model, but now these are not synchronization rounds where messages are supposed to be delivered to honest parties.</t$.></p>

    <p class="text-gray-300">We now describe how to extend our analysis in the bounded delay setting. The most crucial observation is in the notion of uniquely successful round: specifically, while in the synchronous setting we were counting uniquely successful rounds, now we need to count <span class="math">\\Delta</span>-isolated uniquely successful rounds, where isolated means that there is a window of <span class="math">\\Delta</span> rounds before and after where no other successful round took place for the honest parties. (This notion is analogous to the definition of convergence opportunity in <em>[x20]</em>.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In more details, we will replace the <span class="math">Y_{i}</span> random variable by <span class="math">Y_{i}^{\\prime}</span> defined as follows. It takes values in <span class="math">\\{0,1\\}</span> and <span class="math">Y_{i}^{\\prime}=1</span> when round <span class="math">i</span> was uniquely successful (i.e., <span class="math">Y_{i}=1</span>) and <span class="math">X_{j}=0</span> for each <span class="math">j\\neq i</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">j-i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\Delta<span class="math">. When </span>Y_{i}^{\\prime}=1<span class="math">, we call </span>i<span class="math"> a </span>\\Delta<span class="math">-isolated uniquely successful round (we may drop </span>\\Delta$ if it is clear from the context). We have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[Y_{i}^{\\prime}]\\geq f(1-f)^{2\\Delta-1}\\geq f[1-(2\\Delta-1)f].</span></p>

    <p class="text-gray-300">We remark that the definition of isolated successful round is adopted with the goal that the (easy but crucial) observation of Lemma 6 still holds. This is the main difference with the <span class="math">q</span>-bounded model; in what follows we will argue that the same lemmas and theorems still hold, with small modifications of proofs and parameters.</p>

    <p class="text-gray-300">To obtain a Chain Growth Lemma, cf. Lemma 7, although we could use the isolated uniquely successful rounds, it is more natural and gives slightly better results if we use a new Boolean variable <span class="math">X_{i}^{\\prime}</span>. For a round <span class="math">i</span>, we define <span class="math">X_{i}^{\\prime}=1</span>, if <span class="math">X_{i}=1</span> and <span class="math">X_{j}=0</span> for each <span class="math">j</span> such that <span class="math">i-\\Delta&lt;j&lt;i</span>. When <span class="math">X_{i}^{\\prime}=1</span>, we call <span class="math">i</span> an isolated successful round. We have</p>

    <p class="text-gray-300"><span class="math">\\mathbb{E}[X_{i}^{\\prime}]=f(1-f)^{\\Delta-1}\\geq f[1-(\\Delta-1)f].</span></p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Lemma 30 (Chain Growth Lemma in the bounded-delay model).</h6>

    <p class="text-gray-300">Suppose that at round <span class="math">u</span> an honest party has a chain of length <span class="math">\\ell</span>. Then, by round <span class="math">v\\geq r+\\Delta-1</span>, every honest party has adopted a chain of length at least</p>

    <p class="text-gray-300"><span class="math">\\ell+\\sum_{u\\leq r\\leq v-\\Delta}X_{r}^{\\prime}.</span></p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By induction on <span class="math">v</span>. For the basis <span class="math">(v=u+\\Delta-1)</span>, observe that if at round <span class="math">u</span> an honest party has a chain <span class="math">\\mathcal{C}</span> of length <span class="math">\\ell</span>, then that party broadcast <span class="math">\\mathcal{C}</span> at a round earlier than <span class="math">u</span>. It follows that every honest party will receive <span class="math">\\mathcal{C}</span> by round <span class="math">u-1+\\Delta=v</span>.</p>

    <p class="text-gray-300">For the inductive step, assume the inductive hypothesis for <span class="math">v-1</span> and consider two cases. First, consider <span class="math">X_{v-\\Delta}^{\\prime}=0</span>, in which case we have</p>

    <p class="text-gray-300"><span class="math">\\ell+\\sum_{u\\leq r\\leq v-\\Delta}X_{r}^{\\prime}=\\ell+\\sum_{u\\leq r&lt;v-\\Delta}X_{r}^{\\prime}=\\ell^{\\prime}.</span></p>

    <p class="text-gray-300">By the inductive hypothesis every honest party has received a chain of length at least <span class="math">\\ell^{\\prime}</span> by round <span class="math">v-1</span>.</p>

    <p class="text-gray-300">For the second case, <span class="math">X_{v-\\Delta}^{\\prime}=1</span>. By the inductive hypothesis, by round <span class="math">v-\\Delta</span>, every honest party has adopted a chain of length at least</p>

    <p class="text-gray-300"><span class="math">\\ell^{\\prime}=\\ell+\\sum_{u\\leq r\\leq v-2\\Delta}X_{r}^{\\prime}=\\ell+\\sum_{u\\leq r&lt;v-\\Delta}X_{r}^{\\prime},</span></p>

    <p class="text-gray-300">where the second equality holds because <span class="math">X_{v-\\Delta}^{\\prime}=1</span> implies <span class="math">X_{r}^{\\prime}=0</span> for all <span class="math">v-2\\Delta&lt;r&lt;v-\\Delta</span>. It follows that every honest party queried the oracle with a chain of length at least <span class="math">\\ell^{\\prime}</span> at round <span class="math">v-\\Delta</span>. Hence, all honest parties successful at round <span class="math">v-\\Delta</span> broadcast a chain of length at least <span class="math">\\ell^{\\prime}+X_{v-\\Delta}</span>.</p>

    <p class="text-gray-300">This chain will be received by every honest party by round <span class="math">v</span>. Since <span class="math">X_{v-\\Delta}^{\\prime}=1</span>, using the expression for <span class="math">\\ell^{\\prime}</span> displayed above, we have</p>

    <p class="text-gray-300"><span class="math">\\ell^{\\prime}+X_{v-\\Delta}=\\ell^{\\prime}+X_{v-\\Delta}^{\\prime}=\\ell+\\sum_{u\\leq r\\leq v-\\Delta}X_{r}^{\\prime}</span></p>

    <p class="text-gray-300">and this completes the case and the proof.</p>

    <p class="text-gray-300">∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Definition 31 (Typical execution in the bounded-delay model).</h6>

    <p class="text-gray-300">An execution is <span class="math">(\\epsilon,\\lambda,\\Delta)</span>-typical, with <span class="math">\\epsilon\\in(0,1)</span>, <span class="math">\\lambda\\geq 2/f</span>, and integer <span class="math">\\Delta</span>, if, for any set <span class="math">S</span> of at least <span class="math">\\lambda</span> consecutive rounds, the following hold.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(1-\\epsilon)\\mathbb{E}[X^{\\prime}(S)]&lt;X^{\\prime}(S),\\;\\;X(S)&lt;(1+\\epsilon)\\mathbb{E}[X(S)],\\;\\;\\text{and}\\;\\;(1-\\epsilon)\\mathbb{E}[Y^{\\prime}(S)]&lt;Y^{\\prime}(S)</span>.</li>

      <li><span class="math">Z(S)&lt;\\mathbb{E}[Z(S)]+\\epsilon\\mathbb{E}[X^{\\prime}(S)]</span>.</li>

      <li>No insertions, no copies, and no predictions occurred.</li>

    </ol>

    <h6 id="sec-52" class="text-base font-medium mt-4">Theorem 32.</h6>

    <p class="text-gray-300">An execution is typical with probability <span class="math">1-e^{-\\Omega\\left(\\epsilon^{2}f^{2}(1-f)^{4\\Delta-2}\\lambda+\\kappa-\\log(L)\\right)}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that <span class="math">Y_{i}^{\\prime}</span> and <span class="math">Y_{j}^{\\prime}</span> are not independent anymore when $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i-j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><2\\Delta<span class="math"> and the standard Chernoff bound does not apply. (Similarly for </span>X_{i}^{\\prime}<span class="math"> and </span>X_{j}^{\\prime}<span class="math">.) However, it is not hard to verify that </span>Y^{\\prime}(S)<span class="math"> is </span>2<span class="math">-Lipschitz with respect to the independent (pairs of) variables </span>\\{(X_{i},Y_{i}):i\\in S\\}<span class="math">. This is because </span>X_{i}<span class="math"> affects </span>Y_{j}^{\\prime}<span class="math"> if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i-j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\Delta<span class="math"> and there can be at most two </span>Y_{j}^{\\prime}<span class="math">’s equal to </span>1<span class="math"> in an interval of length </span>2\\Delta-1$. The statement then follows by Theorem 40. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The honest majority assumption needs to be strengthened to accommodate the decreased value of <span class="math">\\mathbb{E}[Y_{i}^{\\prime}]</span>.</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Honest Majority Assumption (Bounded Delay). A number of <span class="math">t</span> out of <span class="math">n</span> parties are corrupted such that <span class="math">t\\leq(1-\\delta)(n-t)</span>, with <span class="math">\\delta</span> such that <span class="math">\\epsilon+2\\Delta f+\\frac{2\\Delta}{\\lambda}\\leq\\frac{\\delta}{5}</span>.</p>
    </blockquote>

    <h6 id="sec-54" class="text-base font-medium mt-4">Lemma 33.</h6>

    <p class="text-gray-300">Let <span class="math">S,S^{\\prime}=\\{r,\\ldots,r^{\\prime}\\}</span> be sets of at least <span class="math">\\lambda</span> consecutive rounds in a typical execution.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. $(1-\\epsilon)f(1-f)^{\\Delta-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><X^{\\prime}(S)\\;\\;\\;\\text{and}\\;\\;(1-\\frac{\\delta}{3})f</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><(1-\\epsilon)f(1-f)^{2\\Delta-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><Y^{\\prime}(S)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. For <span class="math">S=\\{r,\\ldots,r^{\\prime}+\\Delta\\}</span>, $Z(S)<\\frac{1+\\Delta/\\lambda}{(1-\\epsilon)(1-f)^{\\Delta}}\\cdot\\frac{t}{n-t}\\cdot X^{\\prime}(S^{\\prime})+\\epsilon f(1-f)^{\\Delta-1}</td>

            <td class="px-3 py-2 border-b border-gray-700">S</td>

            <td class="px-3 py-2 border-b border-gray-700"><(1-\\frac{\\delta}{2})X^{\\prime}(S^{\\prime})$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">S=\\{r-\\Delta,\\ldots,r^{\\prime}+\\Delta\\}</span>, <span class="math">Z(S)&lt;Y^{\\prime}(S^{\\prime})</span>.</li>

    </ol>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Part (a) uses the bounds on the <span class="math">\\mathbb{E}[X_{i}^{\\prime}]</span> and <span class="math">\\mathbb{E}[Y_{i}^{\\prime}]</span> mentioned in the beginning of this section. Part (b) is the same as in the <span class="math">q</span>-bounded model. Parts (c) and (d), using parts (a) and (b), both follow from the Honest Majority Assumption. ∎</p>

    <p class="text-gray-300">Note that Lemma 13 holds as is, since its proof relies only on the bounds for <span class="math">X(S)</span> and <span class="math">Z(S)</span>. Combining with the Chain Growth Lemma (Lemma 30) for this model, we obtain the following theorem with respect to the chain growth property.</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Theorem 34.</h6>

    <p class="text-gray-300">In a typical execution in the bounded-delay model, the chain growth property holds with parameters <span class="math">\\tau=(1-\\epsilon)f(1-f)^{\\Delta-1}</span> and <span class="math">s\\geq\\lambda</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">7.1 Common Prefix and Chain Quality in the Bounded-Delay Model</p>

    <p class="text-gray-300">We prove now a Common-Prefix Lemma that corresponds to Lemma 14. It holds with the depth parameter slightly increased.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 35.</h6>

    <p class="text-gray-300">Assume a typical execution and consider two chains <span class="math">\\mathcal{C}_{1}</span> and <span class="math">\\mathcal{C}_{2}</span> at round <span class="math">r</span> as in Lemma 14. Then, <span class="math">\\mathcal{C}_{1}^{\\lceil k}\\preceq\\mathcal{C}_{2}</span> and <span class="math">\\mathcal{C}_{2}^{\\lceil k}\\preceq\\mathcal{C}_{1}</span> for <span class="math">k\\geq 2f\\lambda+4\\Delta f</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proof is basically the same as the proof of Lemma 14. The difference is that with respect to the honest parties we consider the set of rounds <span class="math">S^{\\prime}=\\{i:r^{*}+\\Delta&lt;i&lt;r-\\Delta\\}</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-2\\Delta\\geq\\lambda$, by Lemma 13. One then argues that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">Z(S)\\geq Y^{\\prime}(S^{\\prime})</span></p>

    <p class="text-gray-300">as in Lemma 14, pairing each isolated uniquely successful round in <span class="math">S^{\\prime}</span> with an adversarial block computed in <span class="math">S</span>. The contradiction is obtained due to Lemma 33(d). ∎</p>

    <p class="text-gray-300">Then, the common-prefix property for a typical execution follows with exactly the same proof as that of Theorem 15 stated as follows:</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Theorem 36 (Common Prefix).</h6>

    <p class="text-gray-300">In a typical execution the common-prefix property holds with parameter <span class="math">k\\geq 2\\lambda f+2\\Delta</span>.</p>

    <p class="text-gray-300">Finally, chain quality is also easy to prove.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Theorem 37 (Chain Quality).</h6>

    <p class="text-gray-300">In a typical execution the chain quality property holds with parameters <span class="math">\\ell\\geq 2\\lambda f+2\\Delta f</span> and <span class="math">\\mu=1-\\frac{1}{(1-\\epsilon)(1-f)^{\\Delta}}\\cdot\\frac{t}{n-t}-\\frac{\\epsilon}{1-\\epsilon}\\cdot(1+\\frac{\\Delta}{\\lambda})</span>.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S^{\\prime}=\\{r:r_{1}\\leq r&lt;r_{2}-\\Delta\\}</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta\\geq\\lambda$, by Lemma 13. It can be argued as in Theorem 16 that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">Z(S)\\geq(1-\\mu)X^{\\prime}(S^{\\prime})\\geq\\big{(}\\tfrac{1}{(1-\\epsilon)(1-f)^{\\Delta}}\\cdot\\tfrac{t}{n-t}+\\tfrac{\\epsilon}{1-\\epsilon}\\cdot(1+\\tfrac{\\Delta}{\\lambda})\\big{)}X^{\\prime}(S^{\\prime}).</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By Lemma 33(a), $X^{\\prime}(S^{\\prime})>(1-\\epsilon)f(1-f)^{\\Delta-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1+\\tfrac{\\Delta}{\\lambda})\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, Lemma 33(c) is contradicted. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-62" class="text-base font-medium mt-4">Remark 12.</h6>

    <p class="text-gray-300">Given the above results on the three basic properties, chain growth, chain quality and common prefix, it follows in a straightforward manner that all our applications from Sections 5 and 6 can be ported to the bounded-delay setting. With respect to the consensus protocols in particular, if parameter <span class="math">k</span> is sufficiently large to absorb an additive term <span class="math">2\\Delta</span> (see chain quality and common prefix properties) and parameter <span class="math">L</span> is sufficiently large to incorporate a multiplicative factor <span class="math">(1-f)^{1-\\Delta}</span> (see chain growth property), then the same arguments carry over. Note that this does not contradict the impossibility result of <em>[x10]</em> as the security of the resulting consensus protocols cannot be inferred for any choice of <span class="math">\\Delta</span> but only hold if <span class="math">\\Delta,L,k,f</span> satisfy the above relations.</p>

    <h2 id="sec-63" class="text-2xl font-bold">8 Summary and Directions for Future Work</h2>

    <p class="text-gray-300">In this paper we presented a formal treatment of the Bitcoin backbone, the protocol used at the core of Bitcoin’s transaction ledger. We identified and proved basic properties of the backbone protocol — “common prefix,” “chain quality,” “chain growth” — and showed how they can be used as foundations for designing Byzantine agreement and robust public transaction ledger protocols. Our</p>

    <p class="text-gray-300">results show that an honest majority among the (equally equipped) participants suffices, assuming the network synchronizes much faster than the proof of work rate (<span class="math">f</span> is relatively small in our notation), the proper inputs (e.g., transactions) are available to the honest majority<span class="math">^{26}</span>, while the bound on the adversary for honest parties to reach agreement degenerates as <span class="math">f</span> gets larger.</p>

    <p class="text-gray-300">While these are encouraging results, we have demonstrated deviations that are of concern for the proper operation of Bitcoin. Importantly, we show that as the network ceases to synchronize fast enough compared to the proof-of-work rate (i.e., the worst-case time that takes honest players to “hear” each other becomes substantial compared to the time it takes to solve a proof of work), the honest majority property ceases to hold and the bound offered by our analysis that is required to obtain a robust transaction ledger approaches 0 as <span class="math">f</span> approaches 1. Note that the effects of bad synchronization is in the maintenance of the common-prefix property, which is the critical property for showing agreement.</p>

    <p class="text-gray-300">A second important concern is regarding the chain quality property, where our results show that if an adversary controls a hashing power ratio corresponding to some <span class="math">\\beta</span> then the ratio of the blocks it can contribute to the blockchain is bounded but can be strictly bigger than <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">The above caveats in the two basic properties of the backbone protocol have repercussions on the Persistence and Liveness properties of the Bitcoin ledger. Firstly, they illustrate that fast information propagation amongst honest players (in relation to proof of work) is essential for transaction persistence. Secondly, they show that transaction liveness becomes more fragile as the relative adversarial power <span class="math">\\frac{t}{n-t}</span>, gets close to 1. Note that we achieve Liveness for any relative power less than 1 but we do not assume any upper bound on the number of transactions that may be inserted in a block<span class="math">^{27}</span>; it is obvious that the fewer blocks the honest miners get into the blockchain the harder may be for a transaction to get through. Furthermore, the fact that chain quality demonstrably fails to preserve a one-to-one correspondence between a party’s hashing power and the ratio of its contributions to the ledger point to the fact that Bitcoin’s rewarding mechanism is not incentive compatible (cf. [ES14]). In fact we show that the relative hashing power <span class="math">\\frac{t}{n-t}</span> is the essential upper bound on chain quality for the Bitcoin backbone — a result we show also to be tight in our rushing adversary model. In this way, our results flesh out the incentive compatibility problems of the Bitcoin backbone, but, on a more positive note, they also point to the fact that honest hashing-power majority is sufficient to maintain the public ledger (under favorable network conditions), and hence suggest that the Bitcoin protocol can work as long as the majority of the miners want it to work (without taking into account the rationality of their decision — see below for follow-up work in this direction).</p>

    <p class="text-gray-300">The above observations apply to the setting where the number of participants is fixed. In the dynamic setting (where the number of parties running the protocol may change from round to round), given the flat model that we consider, the difficulty of the blockchain, determined by the target <span class="math">T</span>, may be calibrated according to the number of players <span class="math">n</span> that are active in the system. If <span class="math">T</span> is set by an omniscient trusted party then the analysis carries in a straightforward way but otherwise, if <span class="math">T</span> is somehow calculated by the parties themselves, the adversary can try to exploit its calculation. Note that in this case the maxvalid function would need to take the difficulty’s variability into account and thus choose the “most difficult” chain (as opposed to the longest). Comparing chains based on difficulty is simply done by computing the length of a chain by counting blocks proportionally to how difficult they are (for example, a block whose difficulty is two times larger than a given difficulty value would contribute twice as much in “length”). The analysis of</p>

    <p class="text-gray-300">the Bitcoin backbone protocol with chains of variable of difficulty is the subject of our follow-up work <em>[x11]</em>.</p>

    <p class="text-gray-300">Our security analysis is property-based, and holds for stand-alone executions. A follow-up work, which offers a simulation-based, composable treatment of the Bitcoin backbone protocol was recently presented by Badertscher et al. in <em>[x1]</em>. Further, we mentioned above incentive compatibility and majority of miners wanting the protocol to work. Recent follow-up work has focused on the security analysis of the Bitcoin backbone protocol in a rational setting as opposed to our cryptographically standard honest/malicious ssetting. In particular, in <em>[BGM^{+}18]</em> Badertscher et al. formally show that assuming a natural class of incentives for the miners’ behavior — i.e., rewarding them for adding blocks to the blockchain but having them pay for mining — one can reserve the honest-majority assumption as a fallback, or even, depending on the application, completely replace it by the assumption that the miners aim to maximize their revenue.</p>

    <p class="text-gray-300">Other interesting open questions include the substitution of the random oracle assumption with a suitable computational assumption, as well as the development of backbone modifications that improve its characteristics in terms of common prefix and chain quality; see <em>[x12, x13]</em> for recent work in this direction. In terms of the ledger application, transaction processing times (i.e., reducing the wait time parameter <span class="math">u</span> in the Liveness property) is also an interesting question with implications to practice (since real-world payment systems benefit greatly from fast transaction confirmation and verification — see, e.g., <em>[CDE^{+}16]</em> for scalability issues and suggestions). In all these cases, our work offers a formal foundation that allows analyzing the security properties of “tweaks” on the backbone protocol (such as the randomization rule of <em>[x10]</em> or the “GHOST” rule in <em>[x29]</em> used in Ethereum) towards meeting the above goals.</p>

    <p class="text-gray-300">We remark that follow-up work to the present paper has examined additional backbone protocol properties, protocols and model extensions. For instance, we have already mentioned the chain growth property, explicitly introduced in <em>[x20]</em> and now also stated in the current version of this paper, which enables one to abstract the blockchain feature of being able to grow unhindered by the adversary. While this is a quite simple property to prove for the Bitcoin backbone, it becomes far more complex in alternative blockchain protocols such as those using the GHOST rule <em>[x29]</em>; see <em>[x21]</em> for an analysis of such protocols. In <em>[x26]</em>, Pass et al. put forth a property called self-consistency, which refers to the inability of the adversary to make honest parties disagree with themselves as the protocol advances. Chain growth and self-consistency are useful if one wants to do a black-box reduction of Persistence and Liveness of the ledger to the underlying properties of the blockchain, an approach also fulfilled in the current version of this paper, where the common prefix property in Section 3.2 captures self-consistency and chain growth is explicitly treated. Further, <em>[x26]</em> also studied the robustness of transaction ledger in the partially synchronous model, where messages may not be delivered at the end of a round, but there is still a certain bound within which all messages are eventually delivered, see <em>[x8]</em>. This version of the paper also shows how the analysis for the synchronous model extends to that setting, cf. Section 7.</p>

    <p class="text-gray-300">Another set of interesting directions include the development of other applications that may be built on top of the Bitcoin backbone protocol. A notable example is secure multiparty computation (MPC) <em>[x30, x14]</em> with properties such as fairness and guaranteed output delivery (current works in this direction, e.g., <em>[x1, x2, x15, x16, x22, x17, x23]</em> assume an idealized version of the Bitcoin system).</p>

    <p class="text-gray-300">Recently, further contrast between the solvability of “classical” BA and POW-based BA in terms of setup assumptions has been established in works such as <em>[x1, x12]</em>, where it established</p>

    <p class="text-gray-300">how the latter can be achieved “from scratch” — i.e., with no trusted setup, as opposed to the classical setting, where a PKI is required. We refer to <em>[x12]</em> for a more detailed treatment of this subject.</p>

    <p class="text-gray-300">The core protocol construct for BA introduced in Section 6.3 (namely composing two POW sub-protocols, one maintaining a blockchain and the other creating POWs to enter inputs in the blockchain that are provably in proportion to the honest parties’ computational power) has found further applications in designing blockchain protocols. Specifically, in <em>[x23]</em> it was shown that it can be used to achieve a type of fairness in terms of rewards while in <em>[BKT^{+}18]</em> it was shown that it can be used to increase transaction throughput. In <em>[x21]</em> and later in <em>[x11]</em> a “proof-of-stake” equivalent concept was developed that was shown it can be used to achieve similar objectives.</p>

    <h2 id="sec-64" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">The authors are grateful to Peter Gaži, Giorgos Panagiotakos, Sergio Rajsbaum and Hong-Sheng Zhou for helpful comments and discussions.</p>

    <h2 id="sec-65" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AD15] Marcin Andrychowicz and Stefan Dziembowski. Pow-based distributed cryptography with no trusted setup. In Rosario Gennaro and Matthew Robshaw, editors, Advances in Cryptology - CRYPTO 2015 - 35th Annual Cryptology Conference, Santa Barbara, CA, USA, August 16-20, 2015, Proceedings, Part II, volume 9216 of Lecture Notes in Computer Science, pages 379–399. Springer, 2015.</li>

      <li>[ADMM14] Marcin Andrychowicz, Stefan Dziembowski, Daniel Malinowski, and Łukasz Mazurek. Secure multiparty computations on bitcoin. IEEE Security and Privacy, 2014.</li>

      <li>[AJK05] James Aspnes, Collin Jackson, and Arvind Krishnamurthy. Exposing computationally-challenged Byzantine impostors. Technical Report YALEU/DCS/TR-1332, Yale University Department of Computer Science, July 2005.</li>

      <li>[Bac97] Adam Back. Hashcash. http://www.cypherspace.org/hashcash, 1997.</li>

      <li>[BCL^{+}11] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. J. Cryptology, 24(4):720–760, 2011.</li>

      <li>[BDOZ12] Moshe Babaioff, Shahar Dobzinski, Sigal Oren, and Aviv Zohar. On bitcoin and red balloons. In Boi Faltings, Kevin Leyton-Brown, and Panos Ipeirotis, editors, EC, pages 56–73. ACM, 2012.</li>

      <li>[BG93] Piotr Berman and Juan A. Garay. Randomized distributed agreement revisited. In Digest of Papers: FTCS-23, The Twenty-Third Annual International Symposium on Fault-Tolerant Computing, Toulouse, France, June 22-24, 1993, pages 412–419. IEEE Computer Society, 1993.</li>

      <li>[BGM^{+}18] Christian Badertscher, Juan A. Garay, Ueli Maurer, Daniel Tschudi, and Vassilis Zikas. But why does it work? A rational protocol design treatment of bitcoin. In Jesper Buus Nielsen and Vincent Rijmen, editors, Advances in Cryptology - EUROCRYPT 2018 - 37th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Tel Aviv, Israel, April 29 - May 3, 2018 Proceedings, Part II, volume 10821 of Lecture Notes in Computer Science, pages 34–65. Springer, 2018.</li>

      <li>[BK14a] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to design fair protocols. In Advances in Cryptology - CRYPTO 2014 - 34th Annual Cryptology Conference, Santa Barbara, CA, USA, August 17-21, 2014, Proceedings, Part II, pages 421–439, 2014.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BK14b] Iddo Bentov and Ranjit Kumaresan. How to use bitcoin to incentivize correct computations. ACM CCS 2014, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BKT^{+}18] Vivek Kumar Bagaria, Sreeram Kannan, David Tse, Giulia C. Fanti, and Pramod Viswanath. Deconstructing the blockchain to approach physical limits. IACR Cryptology ePrint Archive, 2018:992, 2018.</li>

      <li>[BMTZ17] Christian Badertscher, Ueli Maurer, Daniel Tschudi, and Vassilis Zikas. Bitcoin as a transaction ledger: A composable treatment. IACR Cryptology ePrint Archive, 2017:149, 2017.</li>

      <li>[BO83] Michael Ben-Or. Another advantage of free choice: Completely asynchronous agreement protocols (extended abstract). In Robert L. Probert, Nancy A. Lynch, and Nicola Santoro, editors, PODC, pages 27–30. ACM, 1983.</li>

      <li>[Bor96] Malte Borderding. Levels of authentication in distributed agreement. In Özalp Babaoglu and Keith Marzullo, editors, Distributed Algorithms, 10th International Workshop, WDAG ’96, Bologna, Italy, October 9-11, 1996, Proceedings, volume 1151 of Lecture Notes in Computer Science, pages 40–55. Springer, 1996.</li>

      <li>[BR93] Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In CCS ’93, Proceedings of the 1st ACM Conference on Computer and Communications Security, Fairfax, Virginia, USA, November 3-5, 1993., pages 62–73, 1993.</li>

      <li>[BSV^{+}96] Paolo Boldi, Shella Shammah, Sebastiano Vigna, Bruno Codenotti, Peter Gemmell, and Janos Simon. Symmetry breaking in anonymous networks: Characterizations. In Fourth Israel Symposium on Theory of Computing and Systems, ISTCS 1996, Jerusalem, Israel, June 10-12, 1996, Proceedings, pages 16–26. IEEE Computer Society, 1996.</li>

      <li>[Can00a] Ran Canetti. Security and composition of multiparty cryptographic protocols. J. Cryptology, 13(1):143–202, 2000.</li>

      <li>[Can00b] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. Cryptology ePrint Archive, Report 2000/067, 2000. http://eprint.iacr.org/2000/067.</li>

      <li>[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd Annual Symposium on Foundations of Computer Science, FOCS 2001, 14-17 October 2001, Las Vegas, Nevada, USA, pages 136–145. IEEE Computer Society, 2001.</li>

      <li>[CDE^{+}16] Kyle Croman, Christian Decker, Ittay Eyal, Adem Efe Gencer, Ari Juels, Ahmed E. Kosba, Andrew Miller, Prateek Saxena, Elaine Shi, Emin Gün Sirer, Dawn Song, and Roger Wattenhofer. On scaling decentralized blockchains - (A position paper). In Jeremy Clark, Sarah Meiklejohn, Peter Y. A. Ryan, Dan S. Wallach, Michael Brenner, and Kurt Rohloff, editors, Financial Cryptography and Data Security - FC 2016 International Workshops, BITCOIN, VOTING, and WAHC, Christ Church, Barbados, February 26, 2016, Revised Selected Papers, volume 9604 of Lecture Notes in Computer Science, pages 106–125. Springer, 2016.</li>

      <li>[Cha82] David Chaum. Blind signatures for untraceable payments. pages 199–203, 1982.</li>

      <li>[Cun13] Cunicula. Why doesn’t bitcoin use a tiebreaking rule when comparing chains of equal length? https://bitcointalk.org/index.php?topic=355644.0. 2013.</li>

      <li>[DLS88] Cynthia Dwork, Nancy A. Lynch, and Larry J. Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 35(2):288–323, 1988.</li>

      <li>[DN92] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In Ernest F. Brickell, editor, CRYPTO, volume 740 of Lecture Notes in Computer Science, pages 139–147. Springer, 1992.</li>

      <li>[Dou02] John R. Douceur. The sybil attack. In Peter Druschel, M. Frans Kaashoek, and Antony I. T. Rowstron, editors, Peer-to-Peer Systems, First International Workshop, IPTPS 2002, Cambridge, MA, USA, March 7-8, 2002, Revised Papers, volume 2429 of Lecture Notes in Computer Science, pages 251–260. Springer, 2002.</li>

    </ul>

    <p class="text-gray-300">[DP12] Devdatt P. Dubhashi and Alessandro Panconesi. Concentration of Measure for the Analysis of Randomized Algorithms. Cambridge University Press, New York, NY, USA, 2012.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DRS90] Danny Dolev, Rüdiger Reischuk, and H. Raymond Strong. Early stopping in byzantine agreement. J. ACM, 37(4):720–741, 1990.</li>

      <li>[DW13] Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin network. In P2P, pages 1–10. IEEE, 2013.</li>

      <li>[ES14] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In Financial Cryptography, 2014.</li>

      <li>[FG03] Matthias Fitzi and Juan A. Garay. Efficient player-optimal protocols for strong and differential consensus. In Elizabeth Borowsky and Sergio Rajsbaum, editors, PODC, pages 211–220. ACM, 2003.</li>

      <li>[FGKR18] Matthias Fitzi, Peter Gazi, Aggelos Kiayias, and Alexander Russell. Parallel chains: Improving throughput and latency of blockchain protocols via parallel composition. IACR Cryptology ePrint Archive, 2018:1119, 2018.</li>

      <li>[FLP85] Michael J. Fischer, Nancy A. Lynch, and Mike Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, 1985.</li>

      <li>[FM97] Pesech Feldman and Silvio Micali. An optimal probabilistic protocol for synchronous byzantine agreement. SIAM J. Comput., 26(4):873–933, 1997.</li>

      <li>[GK18] Juan Garay and Aggelos Kiayias. Sok: A consensus taxonomy in the blockchain era. Cryptology ePrint Archive, Report 2018/754, 2018. https://eprint.iacr.org/2018/754.</li>

      <li>[GKKZ11] Juan A. Garay, Jonathan Katz, Ranjit Kumaresan, and Hong-Sheng Zhou. Adaptively secure broadcast, revisited. In Cyril Gavoille and Pierre Fraigniaud, editors, Proceedings of the 30th Annual ACM Symposium on Principles of Distributed Computing, PODC 2011, San Jose, CA, USA, June 6-8, 2011, pages 179–186. ACM, 2011.</li>

      <li>[GKL15] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol: Analysis and Applications. In Advances in Cryptology - EUROCRYPT 2015 - 34th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Sofia, Bulgaria, April 26-30, 2015, Proceedings, Part II, pages 281–310, 2015.</li>

      <li>[GKL16] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol with Chains of Variable Difficulty. IACR Cryptology ePrint Archive, 2016:1048, 2016.</li>

      <li>[GKL17] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The Bitcoin Backbone Protocol with Chains of Variable Difficulty, 2017.</li>

      <li>[GKLP18] Juan A. Garay, Aggelos Kiayias, Nikos Leonardos, and Giorgos Panagiotakos. Bootstrapping the blockchain, with applications to consensus and fast PKI setup. In Michel Abdalla and Ricardo Dahab, editors, Public-Key Cryptography - PKC 2018 - 21st IACR International Conference on Practice and Theory of Public-Key Cryptography, Rio de Janeiro, Brazil, March 25-29, 2018, Proceedings, Part II, volume 10770 of Lecture Notes in Computer Science, pages 465–495. Springer, 2018.</li>

      <li>[GKP17] Juan A. Garay, Aggelos Kiayias, and Giorgos Panagiotakos. Consensus from signatures of work. Cryptology ePrint Archive, Report 2017/775, 2017. https://eprint.iacr.org/2017/775.</li>

      <li>[GKP19] Juan A. Garay, Aggelos Kiayias, and Giorgos Panagiotakos. Iterated search problems and blockchain security under falsifiable assumptions. Cryptology ePrint Archive, Report 2019/315, 2019. https://eprint.iacr.org/2019/315.</li>

      <li>[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game or a completeness theorem for protocols with honest majority. In STOC, pages 218–229. ACM, 1987.</li>

    </ul>

    <p class="text-gray-300">[HZ10] Martin Hirt and Vassilis Zikas. Adaptively secure broadcast. In Henri Gilbert, editor, Advances in Cryptology - EUROCRYPT 2010, 29th Annual International Conference on the Theory and Applications of Cryptographic Techniques, French Riviera, May 30 - June 3, 2010. Proceedings, volume 6110 of Lecture Notes in Computer Science, pages 466–485. Springer, 2010.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[JB99] Ari Juels and John G. Brainard. Client puzzles: A cryptographic countermeasure against connection depletion attacks. In NDSS. The Internet Society, 1999.</li>

      <li>[KB16] Ranjit Kumaresan and Iddo Bentov. Amortizing secure computation with penalties. In Weippl et al. [WKK^{+}16], pages 418–429.</li>

      <li>[KK09] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. Journal of Computer and System Sciences, 75(2):91 – 112, 2009.</li>

      <li>[KMTZ13] Jonathan Katz, Ueli Maurer, Björn Tackmann, and Vassilis Zikas. Universally composable synchronous computation. In TCC, pages 477–498, 2013.</li>

      <li>[KP15] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive, 2015:1019, 2015.</li>

      <li>[KP16] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. IACR Cryptology ePrint Archive, 2016:545, 2016.</li>

      <li>[KRDO17] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. In Katz and Shacham [KS17], pages 357–388.</li>

      <li>[KS17] Jonathan Katz and Hovav Shacham, editors. Advances in Cryptology - CRYPTO 2017 - 37th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 20-24, 2017, Proceedings, Part I, volume 10401 of Lecture Notes in Computer Science. Springer, 2017.</li>

      <li>[KVV16] Ranjit Kumaresan, Vinod Vaikuntanathan, and Prashant Nalini Vasudevan. Improvements to secure computation with penalties. In Weippl et al. [WKK^{+}16], pages 406–417.</li>

      <li>[KZZ16] Aggelos Kiayias, Hong-Sheng Zhou, and Vassilis Zikas. Fair and robust multi-party computation using a global transaction ledger. In Marc Fischlin and Jean-Sébastien Coron, editors, Advances in Cryptology - EUROCRYPT 2016 - 35th Annual International Conference on the Theory and Applications of Cryptographic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II, volume 9666 of Lecture Notes in Computer Science, pages 705–734. Springer, 2016.</li>

      <li>[LSP82] Leslie Lamport, Robert E. Shostak, and Marshall C. Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, 1982.</li>

      <li>[ML14] Andrew Miller and Joseph J. LaViola. Anonymous byzantine consensus from moderately-hard puzzles: A model for bitcoin. University of Central Florida. Tech Report, CS-TR-14-01, April 2014.</li>

      <li>[Nak08a] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[Nak08b] Satoshi Nakamoto. “the proof-of-work chain is a solution to the byzantine generals’ problem”. The Cryptography Mailing List, https://www.mail-archive.com/cryptography@metzdowd.com/msg09997.html, November 2008.</li>

      <li>[Nak09] Satoshi Nakamoto. Bitcoin open source implementation of p2p currency. http://p2pfoundation.ning.com/forum/topics/bitcoin-open-source, February 2009.</li>

      <li>[Nei94] Gil Neiger. Distributed consensus revisited. Inf. Process. Lett., 49(4):195–201, 1994.</li>

      <li>[OB08] Michael Okun and Amnon Barak. Efficient algorithms for anonymous byzantine agreement. Theor. Comp. Sys., 42(2):222–238, January 2008.</li>

      <li>[Oku05a] Michael Okun. Agreement among unacquainted byzantine generals. In Pierre Fraigniaud, editor, DISC, volume 3724 of Lecture Notes in Computer Science, pages 499–500. Springer, 2005.</li>

    </ul>

    <p class="text-gray-300">[Oku05b] Michael Okun. Distributed computing among unacquainted processors in the presence of byzantine distributed computing among unacquainted processors in the presence of byzantine failures. Ph.D. Thesis Hebrew University of Jerusalem, 2005.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[PS17] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. In Elad Michael Schiller and Alexander A. Schwarzmann, editors, Proceedings of the ACM Symposium on Principles of Distributed Computing, PODC 2017, Washington, DC, USA, July 25-27, 2017, pages 315–324. ACM, 2017.</li>

      <li>[PSL80] Marshall C. Pease, Robert E. Shostak, and Leslie Lamport. Reaching agreement in the presence of faults. J. ACM, 27(2):228–234, 1980.</li>

      <li>[PSS16] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. IACR Cryptology ePrint Archive, 2016:454, 2016.</li>

      <li>[Rab83] Michael O. Rabin. Randomized byzantine generals. In FOCS, pages 403–409. IEEE Computer Society, 1983.</li>

      <li>[RSW96] R. L. Rivest, A. Shamir, and D. A. Wagner. Time-lock puzzles and timed-release crypto. Technical report, Cambridge, MA, USA, 1996.</li>

      <li>[SZ13] Yonatan Sompolinsky and Aviv Zohar. Accelerating bitcoin’s transaction processing. fast money grows on trees, not chains. IACR Cryptology ePrint Archive, 2013:881, 2013.</li>

      <li>[WKK^{+}16] Edgar R. Weippl, Stefan Katzenbeisser, Christopher Kruegel, Andrew C. Myers, and Shai Halevi, editors. Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October 24-28, 2016. ACM, 2016.</li>

      <li>[Yao82] Andrew Chi-Chih Yao. Protocols for secure computations (extended abstract). In FOCS, pages 160–164. IEEE, 1982.</li>

    </ul>

    <h2 id="sec-66" class="text-2xl font-bold">Appendix A Useful Inequalities</h2>

    <p class="text-gray-300">We will require the following inequalities.</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Fact 1 (Bernoulli’s inequality).</h6>

    <p class="text-gray-300">For <span class="math">q\\geq 1</span> and <span class="math">0\\leq p\\leq 1</span>, <span class="math">(1-p)^{q}\\geq 1-pq</span>.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Fact 2.</h6>

    <p class="text-gray-300">For any real <span class="math">\\alpha&gt;0</span>, <span class="math">1-\\alpha&lt;e^{-\\alpha}&lt;1-\\alpha+\\frac{\\alpha^{2}}{2}</span>.</p>

    <p class="text-gray-300">We provide here the form of the Chernoff bound we use in the proofs.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Theorem 38 (Chernoff bounds).</h6>

    <p class="text-gray-300">Suppose <span class="math">\\{X_{i}:i\\in[n]\\}</span> are mutually independent Boolean random variables, with <span class="math">\\Pr[X_{i}=1]=p</span>, for all <span class="math">i\\in[n]</span>. Let <span class="math">X=\\sum_{i=1}^{n}X_{i}</span> and <span class="math">\\mu=pn</span>. Then, for any <span class="math">\\delta\\in(0,1]</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[X\\leq(1-\\delta)\\mu]\\leq e^{-\\delta^{2}\\mu/2}\\ \\ \\text{and}\\ \\ \\Pr[X\\geq(1+\\delta)\\mu]\\leq e^{-\\delta^{2}\\mu/3}.</span></p>

    <p class="text-gray-300">Also, for all <span class="math">t&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[X\\geq\\mu+t]\\leq e^{-2t^{2}/n}.</span></p>

    <p class="text-gray-300">In Section 7 we need more general concentration bounds. We provide here the relevant definition and bounds. (See <em>[x10, Corollary 5.2]</em>)</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 39.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A function <span class="math">f(x_{1},\\ldots,x_{n})</span> is <span class="math">k</span>-Lipschitz if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(x)-f(x^{\\prime})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq k<span class="math">, whenever </span>x<span class="math"> and </span>x^{\\prime}$ differ in at most one coordinate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 40.</h6>

    <p class="text-gray-300">If <span class="math">f</span> is <span class="math">k</span>-Lipschitz and <span class="math">X_{1},\\ldots,X_{n}</span> are independent random variables, then</p>

    <p class="text-gray-300"><span class="math">\\Pr[f&gt;\\mathbb{E}f+t]\\leq\\exp\\Bigl{(}-\\frac{2t^{2}}{nk^{2}}\\Bigr{)}\\quad\\text{and}\\quad\\Pr[f&lt;\\mathbb{E}f-t]\\leq\\exp\\Bigl{(}-\\frac{2t^{2}}{nk^{2}}\\Bigr{)}.</span></p>`;
---

<BaseLayout title="The Bitcoin Backbone Protocol: Analysis and Applications (2014/765)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/765
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
