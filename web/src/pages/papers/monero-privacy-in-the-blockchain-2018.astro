---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/535';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Monero - Privacy in the Blockchain';
const AUTHORS_HTML = 'Kurt M.  Alonso, Jordi Herrera Joancomartí';

const CONTENT = `    <p class="text-gray-300">UAB Universitat Autònoma de Barcelona UOC Universitat de les Illes Balears Universität Oberta de Catalunya www.uoc.edu UNIVERSITAT ROVIRA I VIRGILI</p>

    <h2 id="sec-2" class="text-2xl font-bold">PRIVACY IN THE BLOCKCHAIN</h2>

    <p class="text-gray-300">v1.0</p>

    <p class="text-gray-300">KURT M. ALONSO (kurt@oktav.se) JORDI HERRERA JOANCOMARTÍ (jordi.herrera@uab.cat)</p>

    <p class="text-gray-300">Universitat Autònoma de Barcelona</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">A cryptocurrency blockchain is commonly understood as a public distributed ledger containing transactions verifiable by third parties, be it the mining community or the public in general. It would seem that transactions would need to be sent and stored in clear text format in order to make them publicly verifiable.</p>

    <p class="text-gray-300">As we will show in this report, this is an incorrect assumption. It is indeed possible to use cryptographic artifacts to conceal participants of transactions as well as the amounts involved. And yet, allow the mining community to come to a consensus on verified transactions.</p>

    <p class="text-gray-300">Contents</p>

    <p class="text-gray-300">1.1 Objectives 2 1.2 Readership 2 1.3 Origins of the Monero cryptocurrency 2 1.4 Outline 3</p>

    <p class="text-gray-300">2.1 A few words about notation 4 2.2 Elliptic curve cryptography 5</p>

    <p class="text-gray-300">2.2.1 What are elliptic curves 5 2.2.2 Public key cryptography with elliptic curves 6 2.2.3 Diffie-Hellman key exchange with elliptic curves 6 2.2.4 DSA signatures with elliptic curves (ECDSA) 7</p>

    <p class="text-gray-300">2.3 Curve Ed25519 8</p>

    <p class="text-gray-300">2.3.1 Binary representation 9 2.3.2 Point compression 9 2.3.3 EdDSA signature algorithm 9</p>

    <p class="text-gray-300">3 Ring signatures 11</p>

    <p class="text-gray-300">3.1 Linkable Spontaneous Anonymous Group Signatures (LSAG) 12 3.2 Back Linkable Spontaneous Anonymous Group Signatures (bLSAG) 13 3.3 Multilayer Linkable Spontaneous Anonymous Group Signatures (MLSAG) 14 3.4 Borromean Ring Signatures 16</p>

    <p class="text-gray-300">4 Pedersen commitments 19</p>

    <p class="text-gray-300">4.1 Pedersen commitments 19 4.2 Monero commitments 20 4.3 Range proofs 21 4.4 Range proofs in a blockchain 22</p>

    <p class="text-gray-300">5 Monero Transactions 23</p>

    <p class="text-gray-300">5.1 User keys 23 5.2 One-time addresses 23</p>

    <p class="text-gray-300">5.2.1 Multi-output transactions 24</p>

    <p class="text-gray-300">5.3 Transaction types 25 5.4 Ring Confidential Transactions of type RCTTypeFull 25</p>

    <p class="text-gray-300">5.4.1 Amount Commitments 26 5.4.2 Commitments to zero 26 5.4.3 Signature 27 5.4.4 Transaction fees 28 5.4.5 Avoiding double-spending 28 5.4.6 Space requirements 29</p>

    <p class="text-gray-300">5.5 Ring Confidential Transactions of type RCTTypeSimple 29</p>

    <p class="text-gray-300">5.5.1 Amount Commitments 30 5.5.2 Signature 31 5.5.3 Space Requirements 32</p>

    <p class="text-gray-300">Bibliography 33</p>

    <p class="text-gray-300">Appendices 34</p>

    <p class="text-gray-300">A RCTTypeFull Transaction structure 36 B RCTTypeSimple Transaction structure 40</p>

    <p class="text-gray-300">The purpose of blockchains is to furnish trust to operations between unrelated parties, without requiring the collaboration of a trusted third party.</p>

    <p class="text-gray-300">Trust is attained through the use of cryptographic artifacts which cater for virtual immutability and non-falsifiability of data registered in a readily accessible database — the blockchain. In other words, a blockchain is a public distributed database, containing data whose legitimacy cannot be disputed by any party.</p>

    <p class="text-gray-300">Cryptocurrencies store transactions in the blockchain. The latter acts as a public ledger of all the verified currency operations. Most cryptocurrencies store transactions in clear text, to facilitate the verification of transactions by the community.</p>

    <p class="text-gray-300">Clearly, an open blockchain defies any basic understanding of privacy, since it virtually <em>publicizes</em> complete transaction histories of its users.</p>

    <p class="text-gray-300">To address the lack of privacy, users of cryptocurrencies such as Bitcoin can obfuscate transactions by using temporary intermediate addresses <em>[16]</em>. However, in spite of such measures, with appropriate tools it is possible to analyze flows and to a large extent link true senders with receivers <em>[21, 8, 19]</em>.</p>

    <p class="text-gray-300">In contrast, the cryptocurrency Monero, attempts to tackle the issue of privacy by storing only stealth, single-use addresses in a blockchain, and authenticating transactions with ring signatures. In this manner, there will be no effective way of linking senders with receivers nor tracing the origins of funds <em>[1]</em>.</p>

    <p class="text-gray-300">Additionally, transaction amounts in the Monero blockchain are concealed behind cryptographic constructions, so as to complicate the task of inferringr currency flows.</p>

    <p class="text-gray-300">The result is a cryptocurrency with a high level of privacy.</p>

    <p class="text-gray-300">1.1 Objectives</p>

    <p class="text-gray-300">Monero is a cryptocurrency of recent creation, yet it displays a steady growth in popularity. Unfortunately, there is little comprehensive documentation available describing the mechanisms it uses. Even worse, important parts of the theoretical framework in the currency have been published in non peer-reviewed papers which are incomplete and/or contain errors. For significant parts of the theoretical framework of Monero, only the source code is reliable enough as source of information.</p>

    <p class="text-gray-300">We intend to palliate this situation by collecting in-depth information about Monero’s inner workings, reviewing algorithms and cryptographic schemes, and by discussing the degree to which they might afford sufficient transaction privacy and security to its users.</p>

    <p class="text-gray-300">We have centered our attention on release 0.11.1.0 of the Monero software suite, the most recent release at the moment this is written. All transaction related mechanisms described here belong to this version. Deprecated transaction schemes have not been explored to any extent, even if they may be partially supported for backward compatibility reasons.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Readership</h3>

    <p class="text-gray-300">We expect the reader to possess a basic understanding of discrete mathematics and algebraic structures, but possibly only fundamental insights in the field of cryptography. We also expect the reader to have a basic understanding of how a cryptocurrency like Bitcoin works.</p>

    <p class="text-gray-300">A reader with this background should be able to follow our constructive, step-by-step description of the elements of the Monero cryptocurrency.</p>

    <p class="text-gray-300">We have omitted on purpose some mathematical technicalities, when they would be in the way of clarity. We have also omitted concrete implementation details where we thought they were not essential. Our objective has been to present the subject half-way between mathematical cryptography and computer programming, aiming at completeness and conceptual clarity.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Origins of the Monero cryptocurrency</h3>

    <p class="text-gray-300">The cryptocurrency Monero, originally known as BitMonero, was created in April, 2014, as a derivative of the proof-of-concept currency CryptoNote.</p>

    <p class="text-gray-300">The latter was devised by various individuals. A landmark whitepaper describing the cryptocurrency was published under the pseudonym of Nicolas van Saberhagen in October 2013<em>[22]</em>. It offered sender and receiver anonymity through by employing one-time addresses, together with ring signatures to make flows untraceable.</p>

    <p class="text-gray-300">Since its inception, Monero has further strengthened its privacy aspects by implementing amount hiding as described by Greg Maxwell, among others in <em>[15]</em>, as well as Shen Noether’s improvements on ring signatures <em>[18]</em>.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.4 Outline</h3>

    <p class="text-gray-300">As hinted earlier, our aim has been to deliver a self-contained and step-by-step description of the Monero cryptocurrency. This report has been structured to fulfill this objective and lead the reader through all elements needed to describe the inner workings of the currency.</p>

    <p class="text-gray-300">In our quest for comprehensiveness, we have chosen to present all the basic elements of cryptography needed to understand the complexities of Monero. In Chapter 2 we develop essential aspects of Elliptic Curve cryptography.</p>

    <p class="text-gray-300">Chapter 3 outlines the ring signature related algorithms that will be applied to achieve confidential but linkable transactions.</p>

    <p class="text-gray-300">In Chapter 4 we introduce the cryptographic mechanisms used to conceal amounts.</p>

    <p class="text-gray-300">Finally, with all the components in place we will be able to expose the transaction schemes used in Monero in Chapter 5.</p>

    <p class="text-gray-300">Appendices A and B describe the structure of sample transactions in the blockchain, providing a connection between the theoretical elements described in earlier sections with their real-life implementation.</p>

    <p class="text-gray-300">Chapter 2 Basic concepts</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 A few words about notation</h3>

    <p class="text-gray-300">One main objective in this report has been to collect, review, correct and homogenize all existing information concerning the inner workings of the Monero cryptocurrency. And at the same time supply all the necessary details to present all this material in a constructive and single-threaded manner.</p>

    <p class="text-gray-300">An important instrument to achieve this has been to settle for a number of notational conventions that we think contribute to make this material more readable.</p>

    <p class="text-gray-300">Among others, we have used</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>lower case letters to denote simple values, integers, strings, bit representations, etc</li>

      <li>upper case letters to denote curve points and complex constructs</li>

    </ul>

    <p class="text-gray-300">For items with a special meaning, we have tried to use in as much as possible the same symbols throughout the whole document. For instance, a curve generator is always denoted by <span class="math">G</span>, its order is <span class="math">N</span>, private/public keys are denoted whenever possible by <span class="math">k/K</span> respectively, etc.</p>

    <p class="text-gray-300">Beyond that, we have aimed at being conceptual in our presentation of algorithms and schemes. A reader with a computer science background could consider that we have neglected questions like the bit representation of items, or in some cases, how to carry out concrete operations.</p>

    <p class="text-gray-300">However, this does not entail any loss. A simple object such as an integer or a string can always be represented by a bit string. So-called <em>endianness</em> is rarely relevant, and is mostly a matter of convention for our algorithms.</p>

    <p class="text-gray-300">Elliptic curve points would normally be represented by pairs <span class="math">(x,y)</span> of integers. However, in the world of cryptography it is common to apply <em>point compression</em> techniques, which allow representing a point using only the space of one coordinate. For our conceptual approach it is quite often accessory whether point compression is used or not. But most of the times it is implicitly assumed.</p>

    <p class="text-gray-300">We have also used freely hash functions without specifying any concrete algorithms. In the case of Monero, it will typically be a <em>Keccak</em> variant, but if not explictly mentioned then it’s not important to the theory.</p>

    <p class="text-gray-300">These hash functions will be applied to any objects, integers, strings, curve points, or combinations of these objects. These occurrences should be interpreted as hashes of bit representations, or the concatenation of such representations. Depending on context, the result of a hash will be numeric, a bit string or even a curve point. Further details in this respect will be given when needed in this report.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.2 Elliptic curve cryptography</h3>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">2.2.1 What are elliptic curves</h4>

    <p class="text-gray-300">A finite field <span class="math">\\mathbb{F}_{p}</span> where <span class="math">p</span> is a prime number, is the field formed by the set <span class="math">\\{0,1,2,...,p-1\\}</span>. with arithmetic operations <span class="math">(+,\\cdot)</span> calculated <span class="math">\\pmod{p}</span>.</p>

    <p class="text-gray-300">Typically, elliptic curves are defined as the set of points <span class="math">(x,y)</span> satisfying a <em>Weierstraß</em> equation:</p>

    <p class="text-gray-300"><span class="math">y^{2}=x^{3}+ax+b\\quad\\text{where}\\quad a,b,x,y\\in\\mathbb{F}_{p}</span></p>

    <p class="text-gray-300">However, the cryptocurrency Monero uses a special curve known to offer improved security over other commonly used <em>NIST</em> curves, as well as excellent performance of cryptographic primitives. The curve used belongs to the category of s.c. <em>Twisted Edwards</em> curves, which are commonly expressed as:</p>

    <p class="text-gray-300"><span class="math">ax^{2}+y^{2}=1+dx^{2}y^{2}\\quad\\text{where}\\quad a,d,x,y\\in\\mathbb{F}_{p}</span></p>

    <p class="text-gray-300">In what follows we will prefer this second form. The advantage it offers over the previously mentioned Weierstraß form is that basic cryptographic primitives require less arithmetic operations. This results in faster cryptographic algorithms, see Bernstein et al. in <em>[6]</em> for details.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">CHAPTER 2. BASIC CONCEPTS</p>

    <p class="text-gray-300">Let <span class="math">P_{1} = (x_{1},y_{1})</span> and <span class="math">P_{2} = (x_{2},y_{2})</span> be 2 points belonging to an elliptic curve. We can proceed to define the addition operation <span class="math">P_{1} + P_{2} = P_{3}</span> in the following manner</p>

    <div class="my-4 text-center"><span class="math-block">x _ {3} = \\frac {x _ {1} y _ {2} + y _ {1} x _ {2}}{1 + d x _ {1} x _ {2} y _ {1} y _ {2}} \\quad (\\mathrm {m o d} p)</span></div>

    <div class="my-4 text-center"><span class="math-block">y _ {3} = \\frac {y _ {1} y _ {2} - a x _ {1} x _ {2}}{1 - d x _ {1} x _ {2} y _ {1} y _ {2}} \\quad (\\mathrm {m o d} p)</span></div>

    <p class="text-gray-300">These formulas for addition will also apply for point doubling, that is, when <span class="math">P_{1} = P_{2}</span>.</p>

    <p class="text-gray-300">It turns out that elliptic curves have abelian group structure under the addition operation described².</p>

    <p class="text-gray-300">The order <span class="math">N</span> of an elliptic curve <span class="math">EC</span> can be loosely defined as the number of points in the curve. Clearly, by the definition of addition above it follows that an elliptic curve over a finite field will also be finite.</p>

    <p class="text-gray-300">A generator <span class="math">G</span> of <span class="math">EC</span> is a point in the curve such that for every other point <span class="math">P</span> in <span class="math">EC</span> there exists <span class="math">n</span> satisfying that <span class="math">P = nG</span>.</p>

    <p class="text-gray-300">Calculating the scalar product <span class="math">nP</span> can be done without difficulties. However, given two arbitrary points <span class="math">P_{1}</span> and <span class="math">P_{2}</span>, finding <span class="math">n</span> such that <span class="math">P_{1} = nP_{2}</span> is known to be computationally hard. By analogy to modular arithmetic, this problem is often called the discrete logarithm problem (DLP). In other words, scalar multiplication can be seen as a one-way function, which paves the way for using elliptic curves for cryptography.</p>

    <h2 id="sec-11" class="text-2xl font-bold">2.2.2 Public key cryptography with elliptic curves</h2>

    <p class="text-gray-300">Public key cryptography algorithms can be devised in an analogous way as with modular arithmetic.</p>

    <p class="text-gray-300">Let <span class="math">k</span> be a randomly selected number satisfying <span class="math">1 &amp;lt; k &amp;lt; N</span>, and call it private key. Calculate the corresponding public key <span class="math">K = kG</span>.</p>

    <p class="text-gray-300">Due to the hardness of the discrete logarithm problem (DLP) we can not easily deduce the value <span class="math">k</span> from <span class="math">K</span> alone. This property allows us to use the values in <span class="math">(k, K)</span> in common public key cryptography algorithms.</p>

    <h2 id="sec-12" class="text-2xl font-bold">2.2.3 Diffie-Hellman key exchange with elliptic curves</h2>

    <p class="text-gray-300">A basic Diffie-Hellman exchange of a shared secret between Alice and Bob could take place in the following manner:</p>

    <p class="text-gray-300">²A concise definition of this notion can be found under https://brilliant.org/wiki/abelian-group/</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alice and Bob generate their own private/public keys <span class="math">(k_{A},K_{A})</span> and <span class="math">(k_{B},K_{B})</span>. Both publish or exchange their public keys, and keep the private keys for themselves.</li>

      <li>Clearly, it holds that</li>

    </ol>

    <p class="text-gray-300"><span class="math">S=k_{A}K_{B}=k_{A}k_{B}G=k_{B}k_{A}G=k_{B}K_{A}</span></p>

    <p class="text-gray-300">Therefore, Alice could calculate <span class="math">S=k_{A}K_{B}</span> and Bob <span class="math">S=k_{B}K_{A}</span>, and use this single value as a shared secret.</p>

    <p class="text-gray-300">An external observer would not be able to calculate easily the shared secret due to the hardness of the DLP.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">2.2.4 DSA signatures with elliptic curves (ECDSA)</h4>

    <p class="text-gray-300">Typically, a cryptographic signature is performed on a cryptographic hash of a message rather than the message itself. However, in this whole report we will loosely use the term message indistinctly to refer to the message properly speaking and/or its hash value.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Signature</h5>

    <p class="text-gray-300">Assume that Alice has the private/public key pair <span class="math">(k,K)</span>. To sign univocally an arbitrary message <span class="math">\\mathfrak{m}</span>, she could execute the following steps <em>[11]</em>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate a hash of the message using a cryptographically secure hash function, <span class="math">h=\\mathcal{H}(\\mathfrak{m})</span></li>

      <li>Generate a random integer <span class="math">r</span> such that <span class="math">1&lt;r&lt;N</span> and compute <span class="math">P=(x,y)=rG</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">x=0</span> generate another random integer.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate <span class="math">s=r^{-1}(h+xk)\\pmod{N}</span>. If <span class="math">s=0</span> then go to previous step and repeat</li>

      <li>The signature is <span class="math">(x,s)</span></li>

    </ol>

    <h5 id="sec-15" class="text-base font-semibold mt-4">Verification</h5>

    <p class="text-gray-300">Any third party can verify the signature by calculating</p>

    <p class="text-gray-300"><span class="math">u_{1}</span> <span class="math">=s^{-1}h</span> <span class="math">u_{2}</span> <span class="math">=s^{-1}x</span> <span class="math">Q</span> <span class="math">=u_{1}G+u_{2}K</span></p>

    <p class="text-gray-300">The signature will be valid if and only if the first coordinate of <span class="math">Q=(x_{Q},y_{Q})</span> satisfies that</p>

    <p class="text-gray-300"><span class="math">x_{Q}=x\\pmod{p}</span></p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">#####</p>

    <p class="text-gray-300">Correctness</p>

    <p class="text-gray-300">The correctness of the scheme can be derived from the fact that</p>

    <p class="text-gray-300"><span class="math">Q</span> <span class="math">=u_{1}G+u_{2}K</span> <span class="math">=s^{-1}hG+s^{-1}xkG</span> <span class="math">=s^{-1}(h+xk)G</span></p>

    <p class="text-gray-300">Since <span class="math">s=r^{-1}(h+xk)</span>, it follows that <span class="math">r=s^{-1}(h+xk)</span>, whereby it becomes proved that</p>

    <p class="text-gray-300"><span class="math">Q=rG</span></p>

    <p class="text-gray-300">.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.3 Curve Ed25519</h3>

    <p class="text-gray-300">Monero uses a particular Twisted Edwards elliptic curve for cryptographic operations, Ed25519, birational equivalent of the Montogomery curve Curve25519.</p>

    <p class="text-gray-300">Both Curve25519 and Ed25519 were released by Bernstein et al. <em>[4, 5, 7]</em>.</p>

    <p class="text-gray-300">The curve is defined over the prime field <span class="math">\\mathbb{F}_{2^{255}-19}</span> by means of the following equation:</p>

    <p class="text-gray-300"><span class="math">-x^{2}+y^{2}=1-\\frac{121665}{121666}x^{2}y^{2}</span></p>

    <p class="text-gray-300">This curve addresses many concerns raised by the cryptography community. It is well known that NIST standard algorithms have issues. In recent times it has become clear that the random number generation algorithm PNRG is flawed and contains a potential backdoor<em>[10]</em>. Seen from a broader perspective, curves endorsed by the NIST, are also indirectly endorsed by the NSA, something that the cryptography community sees with suspicion. It is well known that NSA has at times used its power over the NIST to weaken cryptographic algorithms<em>[2]</em>.</p>

    <p class="text-gray-300">Curve Ed25519 is not subject to any patents (see <em>[13]</em> for a discussion on this subject), and the team behind it has developed and adapted basic cryptographic algorithms with efficiency in mind <em>[7]</em>. More importantly, it is currently thought to be secure.</p>

    <p class="text-gray-300">Twisted Edwards curves have order expressable as <span class="math">2^{c}q</span>, where <span class="math">q</span> is a prime number and <span class="math">c</span> a positive integer. In the case of curve Ed25519, its order is a 76 decimal digit number:</p>

    <p class="text-gray-300"><span class="math">2^{3}\\cdot 7237005577332262213973186563042994240857116359379907606001950938285454250989</span></p>

    <p class="text-gray-300">2.3.1 Binary representation</p>

    <p class="text-gray-300">Elements of <span class="math">\\mathbb{F}_{2^{255}-19}</span> are 256-bit integers. In other words, they can be represented using 32 bytes.</p>

    <p class="text-gray-300">Consequently, any point in Ed25519 could be represented using 64 bytes. Applying Point compression techniques, described here below, however, it is possible to reduce this amount by half, to 32 bytes.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">2.3.2 Point compression</h4>

    <p class="text-gray-300">The Ed25519 curve has the property that its points can be easily compressed, so that representing a point will consume only the space of one coordinate. We will not delve into the mathematics necessary to justify this, but we can give a brief insight into how it works.</p>

    <p class="text-gray-300">Assume that we want to compress a point <span class="math">(x,y)</span>. We will employ a little-endian representation of integers.</p>

    <p class="text-gray-300">The most significant bit of the <span class="math">y</span> coordinate will always be 0. We set this bit to 0 if <span class="math">x</span> is even, and 1 if it is odd. The resulting value <span class="math">y</span> will represent the curve point. Retrieve and clear the most significant bit of the stored value and that will be <span class="math">y</span>.</p>

    <p class="text-gray-300">Let <span class="math">u=y^{2}-1</span> and <span class="math">v=dy^{2}+1</span>.</p>

    <p class="text-gray-300">Compute <span class="math">x=uv^{3}(uv^{7})^{(p-5)/8}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">vx^{2}=u\\pmod{p}</span> then keep <span class="math">x</span></li>

      <li>Else set <span class="math">x=x2^{(p-1)/4}\\pmod{p}</span></li>

      <li>Use the parity bit <span class="math">b</span> retrieved in the first step, if <span class="math">b\\neq x\\pmod{p}</span> then return <span class="math">p-x</span>, otherwise return <span class="math">x</span></li>

    </ol>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">2.3.3 EdDSA signature algorithm</h4>

    <p class="text-gray-300">Bernstein and his team have developed a number of basic algorithms based on curve Ed25519. For illustration purposes we will describe here a highly optimized and secure alternative to the ECDSA signature scheme which according to the authors allows producing over 100 000 signatures per second using a commodity Intel Xeon processor <em>[5]</em>. The algorithm can also be found described in Internet RFC8032 <em>[12]</em>.</p>

    <p class="text-gray-300">Among other things, instead of generating random integers every time, it uses a hash value derived from the private key of the signer, and the message itself. This circumvents security flaws related to the implementation of random number generators. Also, another goal of the algorithm is to avoid accessing secret or unpredictable memory locations to prevent so-called cache timing attacks,</p>

    <p class="text-gray-300">We provide here an outline of the steps performed by the algorithm for illustration purposes only. A complete description and sample implementation in the Python language can be found in <em>[12]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">CHAPTER 2. BASIC CONCEPTS</p>

    <h2 id="sec-19" class="text-2xl font-bold">Signature</h2>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">h_k</span> be a hash <span class="math">\\mathcal{H}(k)</span> of the signer's private key <span class="math">k</span>. Compute <span class="math">r</span> as a hash <span class="math">r = \\mathcal{H}(h_k, \\mathfrak{m})</span> of the hashed private key and message.</li>

      <li>Calculate <span class="math">R = rG</span> and <span class="math">s = (r + \\mathcal{H}(R, K, \\mathfrak{m}) \\cdot k)</span></li>

      <li>the signature is the pair <span class="math">(R, s)</span></li>

    </ol>

    <h2 id="sec-20" class="text-2xl font-bold">Verification</h2>

    <p class="text-gray-300">Verification is performed as follows</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">h = \\mathcal{H}(R, K, \\mathfrak{m})</span></li>

      <li>If the equality <span class="math">(2^c s)G = 2^c R + 2^c\\mathcal{H}(R,K,\\mathfrak{m})K</span> holds then the signature is valid</li>

    </ol>

    <h2 id="sec-21" class="text-2xl font-bold">Correctness</h2>

    <p class="text-gray-300">Why the signature verification works can be derived from the following equality:</p>

    <div class="my-4 text-center"><span class="math-block">2^c s G = 2^c \\left( (r + \\mathcal{H}(R, K, \\mathfrak{m}) \\cdot k) \\cdot G = 2^c R + 2^c \\mathcal{H}(R, K, \\mathfrak{m}) \\cdot K \\right)</span></div>

    <h2 id="sec-22" class="text-2xl font-bold">Binary representation</h2>

    <p class="text-gray-300">By default, an EdDSA signature would need <span class="math">64 + 32</span> bytes to be represented. However, RFC8032 assumes that point <span class="math">R</span> is compressed, whereby space requirements become reduced to <span class="math">32 + 32</span> bytes only.</p>

    <p class="text-gray-300">Chapter 3 Ring signatures</p>

    <p class="text-gray-300">Ring signatures are signatures generated with a single private key and a set of unrelated public keys. The whole set of public keys, including the one corresponding to the private key at hand, is usually called a <em>ring</em>. Somebody verifying the signature would not be able to tell which private key from the ring was used to produce the signature.</p>

    <p class="text-gray-300">Ring signatures were originally called <em>Group Signatures</em> in that they were thought of as a way of proving that a signer belongs to a group, without necessarily identifying the individual at hand. In the context of Monero transactions, they will help making currency flows untraceable.</p>

    <p class="text-gray-300">Ring signature schemes can display a number of properties that will be useful for producing confidential transactions:</p>

    <p class="text-gray-300">An observer should not be able to determine the identity of the true signer of the message. Only that the private key used corresponds to one of the public keys in the ring. If a private key is used to sign two different messages, then the messages will become linked and the duplicity will be uncovered. In the case of Monero, this property will help preventing double-spending attacks. A ring member whose public key has been used twice in two ring signatures, but is not the true signer for both, will not be linked.</p>

    <p class="text-gray-300">3.1 Linkable Spontaneous Anonymous Group Signatures (LSAG)</p>

    <p class="text-gray-300">Originally (for instance in <em>[9]</em>), group signature schemes required trusted group members to manage the collective signatures, who had the theoretical possibility of disclosing the original signer.</p>

    <p class="text-gray-300">Relying on a single signature manager is not at all desirable, since it causes a dependency on a single group member, something that translates into a disclosure risk</p>

    <p class="text-gray-300">A more interesting scheme was presented by Liu et al. in <em>[14]</em>. The authors detailed an algorithm to cater for Linkable and Spontaneous group signatures, not requiring the collaboration of any possible co-signers. In other words, the signer could select any set of involuntary co-signers to anonymize his own signature.</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">Signature</h3>

    <p class="text-gray-300">Let <span class="math">\\mathfrak{m}</span> be the message to sign, <span class="math">\\mathcal{R}=\\{K_{1},K_{2},...,K_{n}\\}</span> a set of distinct public keys (a group/ring), <span class="math">k_{\\pi}</span> the private key corresponding to <span class="math">K_{\\pi}\\in\\mathcal{R}</span>. Assume also the existence of two hash functions, <span class="math">\\mathcal{H}_{n}</span> and <span class="math">\\mathcal{H}_{p}</span>, mapping to integers <span class="math">\\pmod{N}</span>, and curve points respectively.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\tilde{K}=k_{\\pi}\\mathcal{H}_{p}(\\mathcal{R})</span></li>

      <li>Generate random numbers <span class="math">\\alpha\\in_{R}\\mathbb{Z}_{q}</span> and <span class="math">r_{i}\\in_{R}\\mathbb{Z}_{q}</span> for <span class="math">i\\in\\{0,1,...,n\\}</span> and <span class="math">i\\neq\\pi</span></li>

      <li>Calculate</li>

    </ol>

    <p class="text-gray-300"><span class="math">c_{\\pi+1}=\\mathcal{H}_{n}(\\mathcal{R},\\tilde{K},\\mathfrak{m},\\alpha G,\\alpha\\tilde{K})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=\\pi+1,\\pi+2,...,n,1,2,...,\\pi-1</span> calculate, replacing <span class="math">n+1\\to 1</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">c_{i+1}=\\mathcal{H}_{n}(\\mathcal{R},\\tilde{K},\\mathfrak{m},r_{i}G+c_{i}K_{i},r_{i}\\mathcal{H}_{p}(R)+c_{i}\\tilde{K})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>define <span class="math">r_{\\pi}=\\alpha-k_{\\pi}c_{\\pi}\\pmod{N}</span></li>

    </ol>

    <p class="text-gray-300">The signature will be <span class="math">\\sigma(\\mathfrak{m})=(c_{1},r_{1},...,r_{n},\\tilde{K})</span></p>

    <h3 id="sec-24" class="text-xl font-semibold mt-8">Verification</h3>

    <p class="text-gray-300">The verification of a signature is done in the following manner</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i=1,2,...,n</span> compute, replacing <span class="math">n+1\\to 1</span></li>

    </ol>

    <p class="text-gray-300"><span class="math">z_{i}^{\\prime}</span> <span class="math">=r_{i}G+c_{i}K_{i}</span> <span class="math">z_{i}^{\\prime\\prime}</span> <span class="math">=r_{i}\\mathcal{H}_{p}(\\mathcal{R})+c_{i}\\tilde{K}</span> <span class="math">c_{i+1}^{\\prime}</span> <span class="math">=\\mathcal{H}_{n}(\\mathcal{R},\\tilde{K},\\mathfrak{m},z_{i}^{\\prime},z_{i}^{\\prime\\prime})</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">c_{1}^{\\prime}=c_{1}</span> then the signature is valid</li>

    </ol>

    <p class="text-gray-300">Correctness</p>

    <p class="text-gray-300">We can convince ourselves that the algorithm works by observing the following:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>If <span class="math">i\\neq\\pi</span> then <span class="math">c^{\\prime}_{i+1}</span> is defined as in the signature algorithm.

If <span class="math">i=\\pi</span> then

<span class="math">z^{\\prime}_{i}=r_{i}G+c_{i}K_{i}=(\\alpha-k_{\\pi}c_{\\pi})G+c_{\\pi}K_{\\pi}=\\alpha G</span>

<span class="math">z^{\\prime\\prime}_{i}=r_{i}\\mathcal{H}_{p}(\\mathcal{R})+c_{i}\\tilde{K}=(\\alpha-k_{\\pi}c_{\\pi})\\mathcal{H}_{p}(\\mathcal{R})+c_{\\pi}k_{\\pi}\\mathcal{H}_{p}(\\mathcal{R})=\\alpha\\tilde{K}</span></p>
    </blockquote>

    <p class="text-gray-300">So even in this case the expression <span class="math">c^{\\prime}_{i+1}=\\mathcal{H}_{n}(\\mathcal{R},\\tilde{K},\\mathfrak{m},z_{n}{}^{\\prime},z_{n}{}^{\\prime\\prime})</span> will equal <span class="math">c_{i+1}</span></p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">Linkability</h3>

    <p class="text-gray-300">Given a fixed set of public keys <span class="math">\\mathcal{R}</span>, and two valid signatures for different messages,</p>

    <p class="text-gray-300"><span class="math">\\sigma</span> <span class="math">=(c_{1},s_{1},...,s_{n},\\tilde{K})</span> <span class="math">\\sigma^{\\prime}</span> <span class="math">=(c^{\\prime}_{1},s^{\\prime}_{1},...,s^{\\prime}_{n},\\tilde{K}^{\\prime})</span></p>

    <p class="text-gray-300">if <span class="math">\\tilde{K}=\\tilde{K}^{\\prime}</span> then clearly both signatures come from the same signing ring and private key</p>

    <p class="text-gray-300">In other words, the LSAG signature scheme yields mutually linkable signatures in the case a ring and a private key would be re-used.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">Exculpability</h3>

    <p class="text-gray-300">At the same time, given that <span class="math">\\tilde{K}=k_{\\pi}\\mathcal{H}_{p}(\\mathcal{R})</span>, we can readily see that linkability would only apply if private key <span class="math">k_{\\pi}</span> were re-used. Hence, no other group/ring member could be accused of signing twice.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2 Back Linkable Spontaneous Anonymous Group Signatures (bLSAG)</h3>

    <p class="text-gray-300">In the LSAG signature scheme, linkability of signatures can only be guaranteed if the ring is constant. This can be seen by looking at the definition of <span class="math">\\tilde{K}</span>.</p>

    <p class="text-gray-300">In this section we present an enhanced version of the LSAG algorithm that provides linkability of the private key used, allowing the ring to contain different spurious keys.</p>

    <p class="text-gray-300">The modification was unraveled in <em>[17]</em>. It is based on a publication by A. Back regarding the CryptoNote ring signature algorithm, see <em>[3]</em> for details.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">CHAPTER 3. RING SIGNATURES 14</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate <span class="math">\\tilde{K} = k_{\\pi}\\mathcal{H}_p(K_{\\pi})</span></li>

      <li>Generate random numbers <span class="math">\\alpha \\in_{R} \\mathbb{Z}_{q}</span> and <span class="math">r_{i} \\in_{R} \\mathbb{Z}_{q}</span> for <span class="math">i \\in \\{0, 1, \\dots, n\\}</span> and <span class="math">i \\neq \\pi</span></li>

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c_{\\pi + 1} = \\mathcal{H}_n(\\mathfrak{m}, \\alpha G, \\alpha \\mathcal{H}_p(K_{\\pi}))</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = \\pi + 1, \\pi + 2, \\dots, n, 1, 2, \\dots, \\pi - 1</span> calculate, replacing <span class="math">n + 1 \\rightarrow 1</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c_{i + 1} = \\mathcal{H}_n(\\mathfrak{m}, r_i G + c_i K_i, r_i \\mathcal{H}_p(K_i) + c_i \\tilde{K})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">r_{\\pi} = \\alpha - k_{\\pi}c_{\\pi} \\pmod{N}</span></li>

    </ol>

    <p class="text-gray-300">The signature will be <span class="math">\\sigma(\\mathfrak{m}) = (c_1, r_1, \\dots, r_n, \\tilde{K})</span>.</p>

    <p class="text-gray-300">As in the original LSAG scheme, verification takes place by recalculating the value <span class="math">c_1</span>.</p>

    <p class="text-gray-300">Correctness of the approach can be verified in a similar way.</p>

    <p class="text-gray-300">The alert reader will no doubt notice that the value <span class="math">\\tilde{K}</span> depends only on the keys of the true signer. In other words, two signatures will now be linkable if and only if the same private key was used to create the signature, independently of the ring used to anonymize the signer.</p>

    <p class="text-gray-300">This notion of linkability will prove to be more useful for Monero than the one offered by the LSAG algorithm, as it will allow detecting double-spending attempts without putting constraints on the ring members used.</p>

    <p class="text-gray-300">In order to be able to sign multi-input transactions, one has to be able to sign with <span class="math">m</span> private keys. In [17, 18], Noether S. et al. describe a multi-layered generalization of the bLSAG signature scheme applicable when we have a set of <span class="math">n \\cdot m</span> keys, that is, the set</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R} = \\{K_{i,j}\\} \\quad \\text{for} \\quad i \\in \\{1, 2, \\dots, n\\} \\quad \\text{and} \\quad j \\in \\{1, 2, \\dots, m\\}</span></div>

    <p class="text-gray-300">for which we know the private keys <span class="math">\\{k_{\\pi,j}\\}</span> corresponding to the subset <span class="math">\\{K_{\\pi,j}\\}</span> for some index <span class="math">\\pi</span>.</p>

    <p class="text-gray-300">Such an algorithm would indeed address our multi-input needs, provided we generalize the notion of linkability.</p>

    <p class="text-gray-300"><strong>Linkability</strong>: if any of private keys <span class="math">k_{\\pi,j}</span> would be used in 2 different signatures, then these signatures would be automatically linked.</p>

    <p class="text-gray-300">CHAPTER 3. RING SIGNATURES 15</p>

    <p class="text-gray-300">The MLSAG algorithm would be described by the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Calculate <span class="math">\\tilde{K}_j = k_{\\pi,j}\\mathcal{H}_p(K_{\\pi,j})</span> for all <span class="math">j \\in \\{1,2,\\dots,m\\}</span></li>

      <li>Generate random numbers <span class="math">\\alpha_{j}\\in_{R}\\mathbb{Z}_{q}</span>, and <span class="math">r_{i,j}\\in_{R}\\mathbb{Z}_q</span> (excluding all <span class="math">r_{\\pi ,j}</span>) for <span class="math">j\\in \\{1,2,\\ldots ,m\\}</span></li>

      <li>Compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c _ {\\pi + 1} = \\mathcal {H} _ {n} (\\mathfrak {m}, \\alpha_ {1} G, \\alpha_ {1} \\mathcal {H} _ {p} (K _ {\\pi , 1}), \\dots , \\alpha_ {n} G, \\alpha_ {n} \\mathcal {H} _ {p} (K _ {\\pi , m}))</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = \\pi + 1, \\pi + 2, \\dots, n, 1, 2, \\dots, \\pi - 1</span> calculate, replacing <span class="math">n + 1 \\to 1</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c _ {i + 1} = \\mathcal {H} _ {n} (\\mathfrak {m}, \\\\ r _ {i, 1} G + c _ {i} K _ {i, 1}, \\\\ r _ {i, 1} \\mathcal {H} _ {p} (K _ {i, 1}) + c _ {i} \\tilde {K} _ {1}, \\\\ \\dots , \\\\ r _ {i, m} G + c _ {i} K _ {i, m}, \\\\ r _ {i, m} \\mathcal {H} _ {p} (K _ {i, m}) + c _ {i} \\tilde {K} _ {m}) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">r_{\\pi ,j} = \\alpha_j - k_{\\pi ,j}c_\\pi</span> (mod <span class="math">N</span>)</li>

    </ol>

    <p class="text-gray-300">The signature will be <span class="math">\\sigma(\\mathfrak{m}) = (c_1, r_{1,1}, \\dots, r_{n,1}, \\dots, r_{1,m}, \\dots, r_{n,m}, \\tilde{K}_1, \\dots, \\tilde{K}_m)</span>.</p>

    <p class="text-gray-300">The verification of a signature is done in the following manner</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = 1, \\dots, n</span> compute, replacing <span class="math">n + 1 \\to 1</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} c _ {i + 1} ^ {\\prime} = \\mathcal {H} _ {n} (\\mathfrak {m}, \\\\ r _ {i, 1} G + c _ {i} K _ {i, 1}, \\\\ r _ {i, 1} \\mathcal {H} _ {p} (K _ {i, 1}) + c _ {i} \\tilde {K} _ {1}, \\\\ \\dots , \\\\ r _ {i, m} G + c _ {i} K _ {i, m}, \\\\ r _ {i, m} \\mathcal {H} _ {p} (K _ {i, m}) + c _ {i} \\tilde {K} _ {m}) \\\\ \\end{array}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">c_1&#x27; = c_1</span> then the signature is valid</li>

    </ol>

    <p class="text-gray-300">Correctness</p>

    <p class="text-gray-300">Just as with the original LSAG algorithm, we can readily observe that</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>if <span class="math">i\\neq\\pi</span> then clearly the values <span class="math">c^{\\prime}_{i+1}</span> are calculated as described in the signature algorithm

if <span class="math">i=\\pi</span> then, since <span class="math">r_{\\pi,j}=\\alpha_{j}-k_{\\pi,j}c_{\\pi}</span>

<span class="math">r_{\\pi,j}G+c_{\\pi}K_{\\pi,j}=(\\alpha_{j}-k_{\\pi,j}c_{\\pi})G+c_{\\pi}K_{\\pi,j}=\\alpha_{j}G</span>
<span class="math">r_{\\pi,j}\\mathcal{H}_{p}(K_{\\pi,j})+c_{\\pi}\\tilde{K}_{j}=(\\alpha_{j}-k_{\\pi,j}c_{\\pi})\\mathcal{H}_{p}(K_{\\pi,j})+c_{\\pi}\\tilde{K}_{j}=\\alpha_{j}\\mathcal{H}_{p}(K_{\\pi,j})</span></p>
    </blockquote>

    <p class="text-gray-300">In other words, it holds also that <span class="math">c^{\\prime}_{\\pi+1}=c_{\\pi+1}</span></p>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">Linkability</h3>

    <p class="text-gray-300">In case a private key <span class="math">k_{\\pi,j}</span> would be re-used, then the corresponding value <span class="math">\\tilde{K}_{j}</span> supplied in the signature would reveal it. This observation matches our generalized definition of linkability.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">Space requirements</h3>

    <p class="text-gray-300">Assuming point compression, an MLSAG signature would clearly consume a total of</p>

    <p class="text-gray-300"><span class="math">(1+nm+m)\\cdot 32\\quad\\text{bytes}</span></p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">3.4 Borromean Ring Signatures</h3>

    <p class="text-gray-300">We will see in later sections of this report that it will be necessary to prove that transaction amounts are within expected ranges. This can be acomplished with ring signatures. However, to this particular end it is not necessary that signatures be linkable, which allows us to select more efficient algorithms in terms of space consumed.</p>

    <p class="text-gray-300">In this context, and for the specific purpose of proving amount ranges, Monero uses a signature scheme developed by G. Maxwell, which he described in <em>[15]</em>. We present here a simplified version of the scheme, in that we will assume that we have the same number of keys for any value of the first index <span class="math">i</span>.</p>

    <p class="text-gray-300">In our case, range proofs will require exactly 2 keys for each digit, so this simplification will not have any negative impact.</p>

    <p class="text-gray-300">Assume that we have a set of public keys <span class="math">\\{K_{i,j}\\}</span> for <span class="math">i\\in\\{1,2,...,n\\}</span> and <span class="math">j\\in\\{1,2,...,m\\}</span>.</p>

    <p class="text-gray-300">Furthermore, we assume also that for each <span class="math">i</span> there is an index <span class="math">\\pi_{i}</span> such that signer knows the private key <span class="math">k_{i,\\pi_{i}}</span> corresponding to <span class="math">K_{i,\\pi_{i}}</span>.</p>

    <p class="text-gray-300">In what follows we will use <span class="math">\\mathfrak{m}</span> for the hash of the message concatenated with keys <span class="math">\\{K_{i,j}\\}</span>.</p>

    <p class="text-gray-300">CHAPTER 3. RING SIGNATURES 17</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each <span class="math">i = 1, ..., n</span>:</li>

    </ol>

    <p class="text-gray-300">(a) generate a random value <span class="math">\\alpha_{i} \\in_{R} \\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300">(b) set <span class="math">c_{i,\\pi_i} = \\mathcal{H}_n(\\mathfrak{m},\\alpha_iG,i,\\pi_i)</span></p>

    <p class="text-gray-300">(c) for <span class="math">j = \\pi_i + 1, \\dots, m - 1</span> generate random numbers <span class="math">r_{i,j} \\in_{R} \\mathbb{Z}_q</span> and compute,</p>

    <div class="my-4 text-center"><span class="math-block">c_{i,j+1} = \\mathcal{H}_n(\\mathfrak{m}, r_{i,j}G - c_{i,j}K_{i,j}, i, j)</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = 1, \\dots, n</span> generate random numbers <span class="math">r_{i,m} \\in_{R} \\mathbb{Z}_q</span> and compute</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">c_1 = \\mathcal{H}_n(r_{1,m}G - c_{1,m}K_{1,m}, \\dots, r_{n,m}G - c_{n,m}K_{i,m})</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = 1, \\dots, n</span>:</li>

    </ol>

    <p class="text-gray-300">(a) for <span class="math">j = 1, \\dots, \\pi_i - 1</span> generate random numbers <span class="math">r_{i,j} \\in_{R} \\mathbb{Z}_q</span> and compute</p>

    <div class="my-4 text-center"><span class="math-block">c_{i,j+1} = \\mathcal{H}_n(\\mathfrak{m}, r_{i,j}G - c_{i,j}K_{i,j}, i, j)</span></div>

    <p class="text-gray-300">Here we interpret references to <span class="math">c_{i,1}</span> as <span class="math">c_1</span>, see previous step</p>

    <p class="text-gray-300">(b) set <span class="math">r_{i,\\pi_i} = \\alpha_i + k_{i,\\pi_i}c_{i,\\pi_i}</span></p>

    <p class="text-gray-300">The signature will be</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma = (c_1, r_{1,1}, r_{1,2}, \\dots, r_{1,m}, \\dots, r_{n,m})</span></div>

    <p class="text-gray-300">As before, let <span class="math">\\mathfrak{m}</span> be the hash of the message to sign and the set of signing keys.</p>

    <p class="text-gray-300">The verification of a given signature is performed as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i = 1, \\dots, n</span> and <span class="math">j = 1, \\dots, m</span> compute:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} R&#x27;_{i,j+1} = r_{i,j}G - c&#x27;_{i,j}K_{i,j} \\\\ c&#x27;_{i,j+1} = \\mathcal{H}_n(\\mathfrak{m}, R&#x27;_{i,j+1}, i, j) \\end{array}</span></div>

    <p class="text-gray-300">Interpret any <span class="math">c_{i,1}&#x27;</span> as <span class="math">c_1</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">c_1&#x27; = \\mathcal{H}(R&#x27;_{1,m}, \\dots, R&#x27;_{n,m})</span></li>

    </ol>

    <p class="text-gray-300">The signature will be valid if <span class="math">c_1&#x27; = c_1</span>.</p>

    <p class="text-gray-300">CHAPTER 3. RING SIGNATURES 18</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">j \\neq \\pi_i</span> and for all <span class="math">i</span> we can readily see that <span class="math">c_{i,j+1}&#x27; = c_{i,j+1}</span></li>

      <li>When <span class="math">j = \\pi_i</span>, for all <span class="math">i</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} R_{i,j+1}&#x27; = r_{i,j} G - c_{i,j}&#x27; K_{i,j} \\\\ = (\\alpha_i + k_{i,\\pi_i} c_{i,\\pi_i}&#x27;) G - c_{i,\\pi_i}&#x27; K_{i,\\pi_i} \\\\ = \\alpha_i G + k_{i,\\pi_i} c_{i,\\pi_i}&#x27; G - c_{i,\\pi_i}&#x27; k_{i,\\pi_i} G \\\\ = \\alpha_i G \\end{array}</span></div>

    <p class="text-gray-300">In other words, <span class="math">c_{i,\\pi_i}&#x27; = \\mathcal{H}_n(\\mathfrak{m}, \\alpha_i G, i, \\pi_i) = c_{i,\\pi+1}</span>.</p>

    <p class="text-gray-300">Therefore we can conclude that the verification step identifies correctly valid signatures.</p>

    <p class="text-gray-300">Chapter 4 Pedersen commitments</p>

    <p class="text-gray-300">Generally speaking, a cryptographic commitment scheme is a way of publishing a commitment to a value without revealing the value itself.</p>

    <p class="text-gray-300">As an example, in a flip-coin game, Alice could commit to one outcome before Bob flips the coin, by publishing the value hashed with secret data. After flipping the coin, Alice could prove which value she committed to by publishing her secret data, so that Bob could verify that she did indeed hash the outcome she later declared.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In other words, assume that Alice has a secret string <span class="math">b</span> and that the value she wants to commit to is <span class="math">v</span>. She could simply hash $\\mathcal{H}(b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v)<span class="math"> and tell the result to Bob. Bob flips the coin and then Alice could prove that she guessed the right outcome </span>v<span class="math"> by telling Bob what the secret string </span>b<span class="math"> was. Bob would then recalculate </span>\\mathcal{H}(b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v)$ and verify that Alice did indeed guess right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">4.1 Pedersen commitments</h3>

    <p class="text-gray-300">A Pedersen commitment <em>[20]</em> is a commitment that has the property of being additive. In other words, if <span class="math">C(a)</span> and <span class="math">C(b)</span> denote the commitments for amounts <span class="math">a</span> and <span class="math">b</span> respectively, then <span class="math">C(a+b)=C(a)+C(b)</span> is a commitment for <span class="math">a+b</span>. This property is useful when committing transaction amounts, as one could prove, for instance, that inputs equal outputs, without unveiling the amounts at hand.</p>

    <p class="text-gray-300">Fortunately, Pedersen commitments are easy to implement with elliptic curve cryptography, as the following holds trivially</p>

    <p class="text-gray-300"><span class="math">aG+bG=(a+b)G</span></p>

    <p class="text-gray-300">Clearly, with a simple definition of commitment like <span class="math">C(a)=aG</span>, we would recognize immediately commitments to <span class="math">0</span>. We could also end up creating cheat tables of commitments to help us recognize common amounts.</p>

    <p class="text-gray-300">To attain information-theoretical privacy, one needs to add a secret blinding factor and another generator <span class="math">H</span>, such that it is unknown for which value of <span class="math">\\gamma</span> the following holds <span class="math">H=\\gamma G</span>. The hardness of the discrete logarithm problem ensures the unfeasibility of calculating this value.</p>

    <p class="text-gray-300">We can then define the commitment of an amount <span class="math">a</span> as <span class="math">C(x,a)=xG+aH</span>, where <span class="math">x</span> is a blinding factor.</p>

    <p class="text-gray-300">In the case of Monero, <span class="math">H=to\\_point(\\text{\\emph{Keccak}}(G))</span>, where Keccak stands for the novel hashing algorithm of the same name, and <span class="math">to\\_point</span> is a function mapping scalars to curve points.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.2 Monero commitments</h3>

    <p class="text-gray-300">A transaction in a cryptocurrency is a collection of inputs and outputs, which must balance. That is, if Alice spends 100 units of the currency (the inputs), then the receiver(s) should receive exactly 100 units in total. In case the payment to Bob is of 50 units only, then a second output of 50 units back to Alice should be added.</p>

    <p class="text-gray-300">In other words, if we had a transaction with inputs <span class="math">a_{1},...,a_{n}</span> and outputs <span class="math">b_{1},...,b_{m}</span>, then an observer would justifiably expect that:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i}a_{i}-\\sum_{j}b_{j}=0</span></p>

    <p class="text-gray-300">Since commitments are additive, then their sum would also equal zero:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i}C_{i,in}-\\sum_{j}C_{j,out}=0</span></p>

    <p class="text-gray-300">This fact would be used by the network to verify that the sender of the transaction is not spending more money than he has previously received.</p>

    <p class="text-gray-300">However, to avoid identifiability of a sender, Shen Noether proposes in <em>[17]</em> verifying instead that the commitments sum to certain non-zero value:</p>

    <p class="text-gray-300"><span class="math">\\sum_{i}C_{i,in}-\\sum_{j}C_{j,out}=zG</span> <span class="math">\\sum_{i}\\left(x_{i}G+a_{i}H\\right)-\\sum_{j}\\left(y_{j}G+b_{j}H\\right)=zG</span> <span class="math">\\sum_{i}x_{i}-\\sum_{j}y_{j}=z</span></p>

    <p class="text-gray-300">The reasons why this is useful will become clear later, when we discuss the structure of transactions.</p>

    <p class="text-gray-300">Nevertheless, while not really summing up to <span class="math">0</span>, we will still refer to valid transaction commitments as Commitments to zero, as long as the private key <span class="math">z</span> is known to the committer.</p>

    <h3 id="sec-40" class="text-xl font-semibold mt-8">4.3 Range proofs</h3>

    <p class="text-gray-300">One problem with additive commitments is that, if we have commitments for <span class="math">a</span>, <span class="math">b</span> and <span class="math">z</span> and we intend to use them to prove that <span class="math">a+b=z</span>, then those commitments would also apply if we replace each value in the equation by its additive inverse <span class="math">\\pmod{q}</span>.</p>

    <p class="text-gray-300">For instance, if our base field were <span class="math">\\mathbb{Z}_{7}</span> and <span class="math">a=3</span>, <span class="math">b=2</span>, <span class="math">z=5</span>, then the equation would also hold for <span class="math">a=4</span>, <span class="math">b=5</span> and <span class="math">z=2\\pmod{7}</span>.</p>

    <p class="text-gray-300">Therefore, any commitments we could create for the amounts at hand would also apply to the inverses of the amounts. So we could effectively claim later that the amounts were different, whereby we would be creating money!</p>

    <p class="text-gray-300">The solution used in Monero to address this issue is to sign the ranges of the numbers at hand using a Borromean signature scheme described in Section 3.4, in the manner described here.</p>

    <p class="text-gray-300">For any amount <span class="math">a</span>, use its binary representation <span class="math">(a_{0},a_{1},...,a_{k})</span> such that</p>

    <p class="text-gray-300"><span class="math">a=a_{0}2^{0}+a_{1}2^{1}+...+a_{k}2^{k}</span></p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Generate random numbers <span class="math">x_{1},...,x_{k}\\in_{R}\\mathbb{Z}</span> to be used as blinding factors. Define also Pedersen commitments for each <span class="math">a_{i}</span>, <span class="math">C_{i}=x_{i}G+a_{i}2^{i}H</span>, and derive public keys <span class="math">\\{C_{i},C_{i}-2^{i}H\\}</span>.</p>

    <p class="text-gray-300">Clearly one of those public keys will equal <span class="math">x_{i}G</span>:</p>

    <p class="text-gray-300">if <span class="math">a_{i}=0</span> then <span class="math">C_{i}=x_{i}G+0H=x_{i}G</span> if <span class="math">a_{i}=1</span> then <span class="math">C_{i}-2^{i}H=x_{i}G+2^{i}H-2^{i}H=x_{i}G</span></p>

    <p class="text-gray-300">In other words, a blinding factor <span class="math">x_{i}</span> will always be the private key corresponding to one of <span class="math">\\{C_{i},C_{i}-2^{i}H\\}</span>. Therefore we will be able to sign an amount <span class="math">a</span> in a transaction using the Borromean Ring Signature scheme of Section 3.4 with the ring:</p>

    <p class="text-gray-300"><span class="math">\\{\\{C_{0},C_{0}-2^{0}H\\},...,\\{C_{k},C_{k}-2^{k}H\\}\\}</span></p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">4.4 Range proofs in a blockchain</h3>

    <p class="text-gray-300">In the context of Monero we will use range proofs to commit to individual bit components and to prove that their sum equals the total amount committed. Therefore, it will not be necessary for the receiver nor any other party to know the blinding factors <span class="math">x_{i}G</span>. In other words, it is sufficient to know that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i=0}^{k}C_{i}=C</span></p>

    <p class="text-gray-300">In the blockchain we will store only the commitments/keys <span class="math">C_{i}</span>. The mining community will have to check that the equation above holds and that the private key of either <span class="math">C_{i}</span> or <span class="math">C_{i}-2^{i}H</span> has been used to sign the amount.</p>

    <p class="text-gray-300">The Borromean signature scheme requires knowledge of <span class="math">x_{i}</span> to produce a signature. In consequence, upon verifying this relationship between keys, any third party will be able to convince himself that amounts fall within ranges and that money is not being artificially created.</p>

    <p class="text-gray-300">Chapter 5 Monero Transactions</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">5.1 User keys</h3>

    <p class="text-gray-300">Unlike Bitcoin, Monero users have two sets of private/public keys. <span class="math">(k_{1},K_{1})</span> and <span class="math">(k_{2},K_{2})</span>, generated as described in Section 2.2.2.</p>

    <p class="text-gray-300">The address of a user is the pair of public keys <span class="math">(K_{1},K_{2})</span>. Her private keys will be the corresponding pair <span class="math">(k_{1},k_{2})</span>.</p>

    <p class="text-gray-300">Using two sets of keys allows segregation of functions. The rationale will become clear later in this report, but for the moment being let us advance that private key <span class="math">k_{1}</span> will be called view key whereas <span class="math">k_{2}</span> will be the spend key. The former key will be used to determine whether an output is addressed to the user at hand, and the second one will be necessary to use the output in a spend transaction.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">5.2 One-time addresses</h3>

    <p class="text-gray-300">As described, every Monero user has a pair of public keys as public address. However, this address is never used directly. Instead, new addresses based on a Diffie-Hellman-like exchange are created every time an amount is to be paid to a user. In this way, external observers will not be able to identify receivers in transactions.</p>

    <p class="text-gray-300">Imagine a very simple transaction, containing exactly one input and one output — a payment from Alice to Bob.</p>

    <p class="text-gray-300">CHAPTER 5. MONERO TRANSACTIONS</p>

    <p class="text-gray-300">Bob has private/public keys <span class="math">(k_{B_1}, k_{B_2})</span> and <span class="math">(K_{B_1}, K_{B_2})</span>. To create one-time keys, Alice would proceed as depicted here (see <em>[22]</em>):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Alice generates a random number <span class="math">r</span> such that <span class="math">1 &amp;lt; r &amp;lt; N</span>, and calculates the output public key <span class="math">K_{o} = \\mathcal{H}_{n}(rK_{B_{1}})G + K_{B_{2}}</span></li>

      <li>Alice sets <span class="math">K_{o}</span> as the addressee of the payment, adds the value <span class="math">rG</span> to the transaction data and submits it to the network. The value <span class="math">rG</span> will be used by the receiver to calculate a Diffie-Hellman-like shared secret.</li>

      <li>Bob receives the data and sees the value <span class="math">rG</span>. Hence, he can calculate <span class="math">k_{B_1}rG = rK_{B_1}</span>. Therefore, he will also be able to calculate <span class="math">K_{o} = \\mathcal{H}_{n}(rK_{B_{1}})G + K_{B_{2}}</span>. When he sees the addressee of the output he will know that it is addressed to him.</li>

      <li>The one-time keys for the output are</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} K_{o} = \\mathcal{H}_{n}(rK_{B_{1}})G + k_{B_{2}}G = (\\mathcal{H}_{n}(rK_{B_{1}}) + k_{B_{2}})G \\\\ k_{o} = \\mathcal{H}_{n}(rK_{B_{1}}) + k_{B_{2}} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">While Alice can calculate the public key for the address, she can not compute the corresponding private key, since it would require either knowing Bob's second private key, or solving the discrete logarithm problem for <span class="math">K_{B_2} = k_{B_2}G</span>, which we assume to be hard.</p>

    <p class="text-gray-300">As mentioned earlier, the private key <span class="math">k_{B_1}</span> is often called the view key. The reason is that it allows a third party to verify if an output is addressed to Bob, and yet, without the knowledge of the other private key, <span class="math">k_{B_2}</span>, this third party would not be able to spend the amount, as he would not be able to sign with the private key of the one-time address.</p>

    <p class="text-gray-300">Such a third party could be a trusted custodian, an auditor, a tax authority, etc. Somebody who would have read access to the user's transaction history, without any further rights. This third party would also be able to decrypt the amounts of Section 5.4.1.</p>

    <p class="text-gray-300">The private key <span class="math">k_{o}</span> can only be calculated with knowledge of <span class="math">k_{B_2}</span>. As we will see, spending an output will require calculating <span class="math">k_{o}</span>, which in turn entails knowing the spend key <span class="math">k_{B_2}</span>.</p>

    <h2 id="sec-44" class="text-2xl font-bold">5.2.1 Multi-output transactions</h2>

    <p class="text-gray-300">Most transactions will contain more than one output. If nothing else, to transfer back any change to the sender himself.</p>

    <p class="text-gray-300">Monero senders generate only one random value <span class="math">r</span>. The value <span class="math">rG</span> is normally known as the Transaction public key and is published in the blockchain.</p>

    <p class="text-gray-300">To ensure that all output addresses in a transaction are different even in cases where the same addressee is used twice, Monero uses the output index. Every output will have an index <span class="math">l \\in \\{0,1\\}</span></p>

    <p class="text-gray-300"><span class="math">\\{1,...,s\\}</span>. By appending this value to the shared secret before hashing it, one can ensure that the resulting addresses will be unique:</p>

    <p class="text-gray-300"><span class="math">K_{o}</span> <span class="math">=\\mathcal{H}_{n}(rK_{B_{1}},l)G+k_{B_{2}}G=(\\mathcal{H}_{n}(rK_{B_{1}},l)+k_{B_{2}})G</span> <span class="math">k_{o}</span> <span class="math">=\\mathcal{H}_{n}(rK_{B_{1}},l)+k_{B_{2}}</span></p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">5.3 Transaction types</h3>

    <p class="text-gray-300">Monero is a cryptocurrency under steady development. Transaction structures, protocols and cryptographic schemes are always prone to evolve to meet new objectives, or to avoid newly discovered threats.</p>

    <p class="text-gray-300">In this report we have focused our attention on Ring Confidential Transactions as they are implemented in the current version of Monero. Therefore we will not describe here any other transaction types, even if they are still partially supported,</p>

    <p class="text-gray-300">The transaction types we will describe in this section are RCTTypeFull and RCTTypeSimple. The former category follows closely the ideas exposed by S.Noether at al. in <em>[18]</em>. At the time the paper was written, the intention was most likely to replace fully the original CryptoNote transaction scheme by the new scheme.</p>

    <p class="text-gray-300">However, for multi-input transactions and with the formulation used in the paper mentioned, the signature scheme used was thought to entail a risk on traceability. This will become clear when we supply technical details, but as it stands let us advance that if one spent output would become identifiable, then the rest of the spent outputs would also become identifiable. This would have an impact on the traceability of currency flows, not only for the transaction originator affected, but also for the rest of the blockchain.</p>

    <p class="text-gray-300">To mitigate this risk, the Monero Research Lab decided to use a related, yet different signature scheme for multi-input transactions. The transaction type RCTTypeSimple is the one used in these occasions. The main difference, as we will see later, is that each input will be signed independently.</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">5.4 Ring Confidential Transactions of type RCTTypeFull</h3>

    <p class="text-gray-300">By default, the current code base applies this type of signature scheme when transactions have only one input. The scheme itself allows multi-input transactions, but when it was introduced, the Monero Research Lab decided that it would be advisable to use it only on single-input transactions. For multi-input transactions, existing Monero wallets use the RCTTypeSimple scheme described later.</p>

    <p class="text-gray-300">Our perception is that the decision of doing so was rather hastily taken, and that it might change in the future, perhaps if the algorithm to select additional mix-in outputs is improved and the ring sizes are increased. Also, S. Noether’s original description in <em>[18]</em> did not envision constraints of this type. At any rate, this is not a hard constraint. An alternative wallet might indeed choose to sign transactions using either scheme, independently of the number of inputs involved.</p>

    <p class="text-gray-300">We have therefore chosen to describe the scheme as if it were meant also for multi-input transactions.</p>

    <p class="text-gray-300">An actual example of transactions of this type, with all its components, can be inspected in Appendix A.</p>

    <h4 id="sec-47" class="text-lg font-semibold mt-6">5.4.1 Amount Commitments</h4>

    <p class="text-gray-300">Recall from Section 4.2 that we had defined a commitment to an amount <span class="math">b</span> as:</p>

    <p class="text-gray-300"><span class="math">C(b)=xG+bH</span></p>

    <p class="text-gray-300">In the context of Monero, it is necessary that the receiver can verify that the amount in an output is the one promised. This means that the blinding factor <span class="math">xG</span> must be somehow communicated to the receiver.</p>

    <p class="text-gray-300">The solution adopted in Monero is to transmit this value to the receiver by using the Diffie-Hellman shared secret <span class="math">rK_{B_{1}}</span>. For each transaction output in the blockchain there will be 2 values called <span class="math">mask</span> and <span class="math">amount</span> satisfying</p>

    <p class="text-gray-300"><span class="math">mask</span> <span class="math">=x+\\mathcal{H}_{n}(rK_{B_{1}})</span> <span class="math">amount</span> <span class="math">=b+\\mathcal{H}_{n}(\\mathcal{H}_{n}(rK_{B_{1}}))</span></p>

    <p class="text-gray-300">The receiver will be able to calculate backwards the blinding factor <span class="math">x</span> and the amount <span class="math">b</span>. He will also be able to check that the commitment provided in the transaction corresponds to the amount at hand.</p>

    <p class="text-gray-300">Furthermore, a third party with access to the view key mentioned earlier would also be able to decrypt the amount at hand.</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">5.4.2 Commitments to zero</h4>

    <p class="text-gray-300">Assume that the sender of the transaction has previously received amounts <span class="math">a_{1},...,a_{m}</span> from various outputs, addressed to one-time addresses <span class="math">K_{\\pi,1},...,K_{\\pi,m}</span> and with commitments <span class="math">C_{\\pi,1}^{a},...,C_{\\pi,m}^{a}</span>.</p>

    <p class="text-gray-300">This sender knows the private keys <span class="math">k_{\\pi,1},...,k_{\\pi,m}</span> corresponding to the one-time addresses. The sender knows also the blinding factors used in commitments <span class="math">C_{\\pi,i}^{a}</span>.</p>

    <p class="text-gray-300">A transaction consists of inputs <span class="math">a_{1},...,a_{m}</span> and outputs <span class="math">b_{1},...,b_{s}</span> such that <span class="math">\\sum\\limits_{j}a_{j}-\\sum\\limits_{i}b_{i}=0</span>.</p>

    <p class="text-gray-300">The sender re-uses the commitments from the previous outputs, <span class="math">C^{a}_{\\pi,1},...,C^{a}_{\\pi,m}</span>, and creates commitments for <span class="math">b_{1},...,b_{s}</span>. Let these commitments be <span class="math">C^{b}_{\\pi,1},...,C^{b}_{\\pi,s}</span></p>

    <p class="text-gray-300">As hinted in Section 4.2, the sum of the commitments will not be truly <span class="math">0</span>, but a curve point <span class="math">zG</span>:</p>

    <p class="text-gray-300"><span class="math">\\sum\\limits_{j}C^{a}_{\\pi,j}-\\sum\\limits_{i}C^{b}_{\\pi,i}=zG</span></p>

    <p class="text-gray-300">It is precisely the knowledge of value <span class="math">z</span> by the sender what characterizes this equation as a <em>commitment to zero</em>. Indeed, it will be the case that</p>

    <p class="text-gray-300"><span class="math">\\sum\\limits_{j}C^{a}_{\\pi,j}-\\sum\\limits_{i}C^{b}_{\\pi,i}</span> <span class="math">=</span> <span class="math">\\sum\\limits_{j}x_{j}G-\\sum\\limits_{i}y_{i}G+(\\sum\\limits_{j}a_{j}-\\sum\\limits_{i}b_{i})H</span> <span class="math">=</span> <span class="math">\\sum\\limits_{j}x_{j}G-\\sum\\limits_{i}y_{i}G</span> <span class="math">=</span> <span class="math">zG</span></p>

    <h4 id="sec-49" class="text-lg font-semibold mt-6">5.4.3 Signature</h4>

    <p class="text-gray-300">The sender selects <span class="math">q</span> sets of size <span class="math">m</span>, of additional unrelated addresses from the blockchain, corresponding to apparently unspent outputs. She mixes the addresses in a <em>ring</em>, adding false commitments to zero, as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}=</span> <span class="math">\\{\\{K_{1,1},...,K_{1,m},(\\sum\\limits_{j}C_{1,j}-\\sum\\limits_{i}C^{b}_{\\pi,i})\\},</span> <span class="math">\\ldots</span> <span class="math">\\{K_{\\pi,1},...,K_{\\pi,m},(\\sum\\limits_{j}C^{a}_{\\pi,j}-\\sum\\limits_{i}C^{b}_{\\pi,i})\\},</span> <span class="math">\\ldots</span> <span class="math">\\{K_{q+1,1},...,K_{q+1,m},(\\sum\\limits_{j}C_{q+1,j}-\\sum\\limits_{i}C^{b}_{\\pi,i})\\}\\}</span></p>

    <p class="text-gray-300">Looking at the structure of the key ring, we see that if it were the case that</p>

    <p class="text-gray-300"><span class="math">\\sum\\limits_{j}C^{a}_{\\pi,j}-\\sum\\limits_{i}C^{b}_{\\pi,i}=0</span></p>

    <p class="text-gray-300">then any observer would recognize the set of addresses</p>

    <p class="text-gray-300"><span class="math">\\{K_{\\pi,1},...,K_{\\pi,m}\\}</span></p>

    <p class="text-gray-300">as the ones in use as inputs, and therefore currency flows would be traceable.</p>

    <p class="text-gray-300">With this observation made we can see why commitments to zero means in reality that they sum to a value <span class="math">zG</span>.</p>

    <p class="text-gray-300">The private keys for <span class="math">\\{K_{\\pi,1},...,K_{\\pi,m},(\\sum_{j}C_{\\pi,j}-\\sum_{i}C_{\\pi,i}^{b})\\}</span> are <span class="math">k_{\\pi,1},...,k_{\\pi,m},z</span>, which are known to the sender. Hence, he will be able to apply the MLSAG signature scheme to sign the set of outputs/commitments <span class="math">\\{(K_{t,1},C_{b,1}),...,(K_{t,s},C_{b,s})\\}</span> with the whole ring. To avoid the amount ambiguity of outputs described in Section 4.3, the sender must also employ the Borromean signature scheme of Section 3.4 to sign ranges.</p>

    <p class="text-gray-300">The corresponding inputs do not need to be signed explicitly, since the commitments stem from previously signed outputs.</p>

    <p class="text-gray-300">In the current version of the Monero software, each amount is expressed as a fixed point number of 64 bits. Hence the ring will contain <span class="math">2\\cdot 64</span> keys.</p>

    <h4 id="sec-50" class="text-lg font-semibold mt-6">5.4.4 Transaction fees</h4>

    <p class="text-gray-300">Transaction fees are stored in clear in the data transmitted to the network. Miners must be able to verify that <span class="math">zG</span> includes a transaction fee, in order to add the corresponding additional output to themselves. In turn, this means that this amount must also be turned into a commitment.</p>

    <p class="text-gray-300">The solution is to calculate the commitment of the fee <span class="math">f</span> without the masking effect of any blinding factor. That is <span class="math">C(f)=fH</span>.</p>

    <p class="text-gray-300">To verify the correctness of <span class="math">zG</span>, the network can therefore compute</p>

    <p class="text-gray-300"><span class="math">(\\sum_{j}C_{\\pi,j}^{a}-\\sum_{i}C_{\\pi,i}^{b})-fH=zG</span></p>

    <p class="text-gray-300">.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">5.4.5 Avoiding double-spending</h4>

    <p class="text-gray-300">An MLSAG signature contains images <span class="math">\\tilde{K}_{\\pi,j}</span> of private keys <span class="math">k_{\\pi,j}</span>. An important property in any cryptographic signature scheme is that it should not be forgeable with non-negligible probability. Therefore, to all practical effects, we can assume that the key images must have been deterministically produced from the private keys at hand.</p>

    <p class="text-gray-300">The network needs only verify that these key images included in MLSAG signatures have not appeared before in other transactions. If they have, then we can be sure that we are witnessing an attempt to spend twice a previously received output <span class="math">C_{\\pi,j}^{a}</span>, addressed to <span class="math">K_{\\pi,j}</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.4.6 Space requirements</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">MLSAG signature</h4>

    <p class="text-gray-300">From Section 3.3 we recall that an MLSAG signature would be expressed as</p>

    <p class="text-gray-300"><span class="math">\\sigma(\\mathfrak{m})=(c_{1},r_{1,1},...,r_{q+1,1},...,r_{1,m+1},...,r_{q+1,m+1},\\tilde{K}_{1},...,\\tilde{K}_{m})</span></p>

    <p class="text-gray-300">As a result of the heritage from CryptoNote the values <span class="math">\\tilde{K}_{j}</span> are not referred to as part of the signature, but rather as images of the private keys <span class="math">k_{\\pi,j}</span> (and <span class="math">z</span>). These values are normally stored separately in the transaction structure as they are used to detect double-spending attacks.</p>

    <p class="text-gray-300">With this in mind and assuming point compression, an MLSAG signature will require <span class="math">((q+1)\\cdot(m+1)+1)\\cdot 32</span> bytes of storage. In other words, a transaction with 1 input and a ring size of 32 would consume <span class="math">(32\\cdot 2+1)\\cdot 32=2080</span> bytes.</p>

    <p class="text-gray-300">To this value we would add 32 bytes to store the key image of an input, and additional space to store the ring member offsets in the blockchain. These offsets are stored as variable length integers, hence we can not quantify exactly the space needed.</p>

    <p class="text-gray-300">The Monero Research Lab is currently developing an alternative signature algorithm to MLSAG. In its current version, space requirements for signatures with the new scheme are logarithmic, or in big-O notation, <span class="math">\\mathcal{O}(\\log n)</span>. We are not able to provide references, as no information has yet been published concerning this new signature scheme.</p>

    <h4 id="sec-53" class="text-lg font-semibold mt-6">Range proofs</h4>

    <p class="text-gray-300">From Section 3.4 and Section 4.3 we obtain that a Borromean signature takes the form of an n-tuple</p>

    <p class="text-gray-300"><span class="math">\\sigma=(c_{1},r_{1,1},r_{1,2},r_{2,1}...,r_{64,2})</span></p>

    <p class="text-gray-300">In the case of Borromean signatures, the ring keys are considered part of the signature. However, for verifiability it is only necessary to store the commitments <span class="math">C_{j}</span>, as the ring key counterparts can be derived as <span class="math">C_{j}-2^{j}H</span>.</p>

    <p class="text-gray-300">Respecting this convention, a range proof will require <span class="math">(1+64\\cdot 2+64)32=6176</span> bytes for each output.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">5.5 Ring Confidential Transactions of type RCTTypeSimple</h3>

    <p class="text-gray-300">In the current Monero code base, transactions having more than one input are signed using a different scheme, referred to as RCTTypeSimple.</p>

    <p class="text-gray-300">The main characteristic of this approach is that instead of signing the entire set of inputs as a whole, the sender signs each of the inputs individually.</p>

    <p class="text-gray-300">Among other things, this has the consequence that one can not use commitments to zero in the same way as for RCTTypeFull transactions. The rationale is that a public key <span class="math">zG</span> is a commitment to zero if and only if the sender knows the corresponding private key <span class="math">z</span>. If the amounts alone do not sum to zero, then due to the hardness of determining <span class="math">\\gamma</span> such that <span class="math">H=\\gamma G</span>, it would not be possible to know <span class="math">z</span>.</p>

    <p class="text-gray-300">In more detail, assume that Alice wants to sign input <span class="math">j</span>. Imagine for a moment that we could sign with an expression like the following</p>

    <p class="text-gray-300"><span class="math">C_{j}^{a}-\\sum_{i}C_{i}^{b}=x_{j}G-\\sum_{i}y_{i}G+(a_{j}-\\sum_{i}b_{i})H</span></p>

    <p class="text-gray-300">Since <span class="math">a_{j}-\\sum_{i}b_{i}\\neq 0</span>, Alice would have to solve the DLP for <span class="math">H=\\gamma G</span> in order to obtain the private key of the expression, something we have assumed to be a computationally difficult problem.</p>

    <h4 id="sec-55" class="text-lg font-semibold mt-6">5.5.1 Amount Commitments</h4>

    <p class="text-gray-300">As explained, the sender is not able to sign against the outputs of the current transaction. On the other hand, the sender is spending previous outputs addressed to him, whose amounts are equal the current inputs. Therefore, the sender could create new commitments to the input amounts and commit to zero respect to each of the previous outputs being spent. In this way, the sender would be proving that the transaction spends exactly the outputs from previous transactions being used.</p>

    <p class="text-gray-300">In other words, assume that the amounts being spent are <span class="math">a_{1},...,a_{m}</span>. These amounts were outputs in previous transactions, in which they had commitments</p>

    <p class="text-gray-300"><span class="math">C_{j}=x_{j}G+a_{i}H</span></p>

    <p class="text-gray-300">The sender can create new commitments to the same amounts but using different blinding factors, that is</p>

    <p class="text-gray-300"><span class="math">C_{j}^{\\prime}=x_{j}^{\\prime}G+a_{i}H</span></p>

    <p class="text-gray-300">Clearly, she would know the private key of the difference between the two commitments:</p>

    <p class="text-gray-300"><span class="math">C_{j}-C_{j}^{\\prime}=(x_{j}-x_{j}^{\\prime})G</span></p>

    <p class="text-gray-300">hence, she would be able to use this value as a commitment to zero.</p>

    <p class="text-gray-300">Similarly to RCTTypeFull transactions, the sender can include the encoded blinding factor and amount in the transaction (see Section 5.4.1), which will allow the receiver to decode the corresponding values using the shared secret.</p>

    <p class="text-gray-300">Before committing a transaction to the blockchain, the network will want to verify that the transaction balances. In the case of RCTTypeFull transactions, this was simple, as the signature scheme implied that the sender had signed with the private key of a commitment to zero.</p>

    <p class="text-gray-300">For RCTTypeSimple transactions, the solution used by Monero is to select blinding factors for input and output commitments such that</p>

    <p class="text-gray-300"><span class="math">\\sum_{i}x_{i}-\\sum_{j}y_{j}=0</span></p>

    <p class="text-gray-300">This will have the effect that</p>

    <p class="text-gray-300"><span class="math">(\\sum_{j}C_{j}^{a}-\\sum_{i}C_{i}^{b})-fH=0</span></p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Fortunately, choosing such blinding factors is simple. In the current version of Monero, <span class="math">x_{m}</span> will be simply set to</p>

    <p class="text-gray-300"><span class="math">x_{m}=\\sum_{i}y_{i}-\\sum_{j=1}^{m-1}x_{j}</span></p>

    <h4 id="sec-56" class="text-lg font-semibold mt-6">5.5.2 Signature</h4>

    <p class="text-gray-300">As we advanced earlier, in transactions of type RCTTypeSimple each input is signed individually. Furthermore, the signature scheme employed will be the same as for RCTTypeFull transactions, except that the signing keys will be different.</p>

    <p class="text-gray-300">Assume that Alice is signing input <span class="math">j</span>. This input spends a previous output with key <span class="math">K_{\\pi,j}</span> that had commitment <span class="math">C_{\\pi,j}</span>. Let <span class="math">C^{\\prime}_{\\pi,j}</span> be a new commitment for the same amount but with a different blinding factor.</p>

    <p class="text-gray-300">Similarly to the previous scheme, the sender selects <span class="math">q</span> unrelated outputs and their respective commitments from the blockchain, to mix with the real output</p>

    <p class="text-gray-300"><span class="math">K_{1,j},...,K_{\\pi-1,j},K_{\\pi+1,j},...,K_{q+1,j}</span> <span class="math">C_{1,j},...,C_{\\pi-1,j},C_{\\pi+1,j},...,C_{q+1,j}</span></p>

    <p class="text-gray-300">She can then sign using the following ring:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{j}=\\{\\{K_{1,j},C_{1,j}-C^{\\prime}_{\\pi,j}\\},</span> <span class="math">\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~{}~</span> <span class="math">\\{K_{q+1,j},C_{q+1,j}-C^{\\prime}_{q+1,j}\\}\\}</span></p>

    <p class="text-gray-300">Indeed, Alice will know the private key for <span class="math">K_{\\pi,j}</span> as well as the one for the commitment to zero <span class="math">C_{\\pi,j}-C^{\\prime}_{\\pi,j}</span>. Therefore she will be able to sign the input with the ring at hand.</p>

    <p class="text-gray-300">Each input in RCTTypeSimple transactions is signed individually, applying the scheme described in Section 5.4.3, but using rings like <span class="math">\\mathcal{R}_{j}</span> as defined above.</p>

    <p class="text-gray-300">The advantage of signing inputs individually is that the set of real inputs and commitments to zero are not placed at the same index, according to the formulation of the MLSAG algorithm. Therefore, even if the origin of one input became traceable, the rest of the inputs would not.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">5.5.3 Space Requirements</h4>

    <h5 id="sec-58" class="text-base font-semibold mt-4">MLSAG signature</h5>

    <p class="text-gray-300">Each ring <span class="math">\\mathcal{R}_{j}</span> contains <span class="math">(q+1)\\cdot 2</span> keys. From Section 3.3 we then derive that using point compression, an input signature will require <span class="math">(2(q+1)+1)\\cdot 32</span> bytes.</p>

    <p class="text-gray-300">A transaction with 20 inputs using rings with 32 members will need <span class="math">((32\\cdot 2+1)\\cdot 32)20=41600</span> bytes.</p>

    <p class="text-gray-300">For the sake of comparison, if we were to apply the RCTTypeFull scheme to the same transaction, the MLSAG signature itself would require <span class="math">(32\\cdot 21+1)\\cdot 32=21536</span> bytes.</p>

    <h5 id="sec-59" class="text-base font-semibold mt-4">Range proofs</h5>

    <p class="text-gray-300">The size of range proofs is constant for each output. As we calculated for RCTTypeFull transactions, a single proof will require 6176 bytes of storage.</p>

    <p class="text-gray-300">Bibliography</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] How does monero’s privacy work? https://www.monero.how/how-does-monero-privacy-work.</li>

      <li>[2] Trust the math? an update. http://www.math.columbia.edu/~woit/wordpress/?p=6522.</li>

      <li>[3] Adam Back. Ring signature efficiency. BitcoinTalk, 2015. https://bitcointalk.org/index.php?topic=972541.msg10619684#msg10619684.</li>

      <li>[4] Daniel J. Bernstein, Peter Birkner, Marc Joye, Tanja Lange, and Christiane Peters. Twisted Edwards Curves, pages 389–405. Springer Berlin Heidelberg, Berlin, Heidelberg, 2008.</li>

      <li>[5] Daniel J. Bernstein, Niels Duif, Tanja Lange, Peter Schwabe, and Bo-Yin Yang. High-speed high-security signatures. Journal of Cryptographic Engineering, 2(2):77–89, Sep 2012.</li>

      <li>[6] Daniel J. Bernstein and Tanja Lange. Faster Addition and Doubling on Elliptic Curves, pages 29–50. Springer Berlin Heidelberg, Berlin, Heidelberg, 2007.</li>

      <li>[7] Daniel J. Bernstein and Tanja Lange. Faster addition and doubling on elliptic curves. Cryptology ePrint Archive, Report 2007/286, 2007. http://eprint.iacr.org/2007/286.</li>

      <li>[8] Karina Bjørnholdt. Dansk politi har knækket bitcoin-koden, May 2017. http://www.dansk-politi.dk/artikler/2017/maj/dansk-politi-har-knaekket-bitcoin-koden.</li>

      <li>[9] David Chaum and Eugène Van Heyst. Group signatures. In Proceedings of the 10th Annual International Conference on Theory and Application of Cryptographic Techniques, EUROCRYPT’91, pages 257–265, Berlin, Heidelberg, 1991. Springer-Verlag.</li>

      <li>[10] Thomas C Hales. The NSA back door to NIST. Notices of the AMS, 61(2):190–192.</li>

      <li>[11] Darrel Hankerson, Alfred J. Menezes, and Scott Vanstone. Guide to Elliptic Curve Cryptography. Springer-Verlag New York, Inc., Secaucus, NJ, USA, 2003.</li>

      <li>[12] Simon Josefsson and Ilari Liusvaara. Edwards-Curve Digital Signature Algorithm (EdDSA). RFC 8032, January 2017.</li>

      <li>[13] Alexander Klimov. ECC patents?, October 2005. http://article.gmane.org/gmane.comp.encryption.general/7522.</li>

      <li>[14] Joseph K. Liu, Victor K. Wei, and Duncan S. Wong. Linkable Spontaneous Anonymous Group Signature for Ad Hoc Groups, pages 325–335. Springer Berlin Heidelberg, Berlin, Heidelberg, 2004.</li>

      <li>[15] Gregory Maxwell and Andrew Poelstra. Borromean ring signatures *. 2015.</li>

      <li>[16] Arvind Narayanan and Malte Möser. Obfuscation in bitcoin: Techniques and politics. CoRR, abs/1706.05432, 2017.</li>

    </ul>

    <p class="text-gray-300">[17] Shen Noether. Ring signature confidential transactions for monero. Cryptology ePrint Archive, Report 2015/1098, 2015. http://eprint.iacr.org/2015/1098.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] Shen Noether, Adam Mackenzie, and the Monero Research Lab. Ring confidential transactions. Ledger, 1(0):1–18, 2016.</li>

      <li>[19] Michael Padilla. Beating bitcoin bad guys, August 2016. http://www.sandia.gov/news/publications/labnews/articles/2016/19-08/bitcoin.html.</li>

      <li>[20] Torben Pryds Pedersen. Non-Interactive and Information-Theoretic Secure Verifiable Secret Sharing, pages 129–140. Springer Berlin Heidelberg, Berlin, Heidelberg, 1992.</li>

      <li>[21] QingChun ShenTu and Jianping Yu. Research on anonymization and de-anonymization in the bitcoin system. CoRR, abs/1510.07782, 2015.</li>

      <li>[22] Nicolas van Saberhagen. Cryptonote v2.0.</li>

    </ul>

    <p class="text-gray-300">35</p>

    <p class="text-gray-300">Appendix A RCTTypeFull Transaction structure</p>

    <p class="text-gray-300">We present in this chapter a dump from a real Monero transaction of type RCTTypeFull, together with explanatory notes for relevant fields.</p>

    <p class="text-gray-300">The dump was obtained executing command print_tx <transactionID> in the monerod daemon run in non-detached mode. The first line printed shows the actual command run, which the interested reader can use to replicate our results.</p>

    <p class="text-gray-300">For editorial reasons we have shortened long hexadecimal chains, presenting only the beginning and end as in 0200010c7f[…]409.</p>

    <p class="text-gray-300">Component rctsig_prunable, as indicated by its name, is in theory prunable from the blockchain. That is, once a block has been consensuated and the current chain length rules out all possibilities of double-spending attacks, this whole field could be pruned. This is something that has not yet been done in the Monero blockchain, but it is nevertheless a possibility. This would yield considerable space savings.</p>

    <p class="text-gray-300">Key images and ring keys are stored separately, in the non-prunable area of transactions. Indeed, these components are essential for detecting double-spend attacks and can not be pruned away.</p>

    <p class="text-gray-300">Our sample transaction has 1 input and 2 outputs.</p>

    <p class="text-gray-300">print_tx b43a7ac21e1b60ad748ec905d6e03cf3165e5d8c9e1c61c263d328118c42eaa6 Found in blockchain at height 1467685</p>

    <p class="text-gray-300">0200010c7f[...]409 { "version": 2, "unlock_time": 0, "vin": [ { "key": { "amount": 0, "key_offsets": [ 799048, 782511, 1197717, 216704, 841722 ], "k_image": "595a612d0df27181c46a8af70a9bd682f2a000124b873ba5d2b9f4b4e4efd672" } }, "vout": [ { "amount": 0, "target": { "key": "aa9595f55f2cfaed3bd2a67453bb064dc7fd454a09c2418d7338782790185fe3" } }, { "amount": 0, "target": { "key": "0ccb48ed2ebbcaa8e8831111029f3300069cff0d1408acffbfc3810b362ea217" } }, { "extra": [ 2, 33, 0, 129, 70, 77, 194, 248, 93, 24, 94, 15, 107, 233, 0, 229, 82, 175, 243, 123, 58, 204, 135, 171, 100, 101, 192, 42, 187, 157, 168, 222, 98, 192, 110, 1, 1, 185, 87, 22, 38, 116, 81, 124, 85, 68, 36, 44, 229, 235, 46, 159, 139, 114, 234, 211, 50, 41, 28, 92, 26, 249, 184, 228, 197, 64, 139, 5 ], "rct_signatures": { "type": 1, "txnFee": 26000000000, "ecdhInfo": [ { "mask": "68f508c5515694ce5a33b316b990e8b67a944725c93d806767e61b2e0b13d300", "amount": "913372a2424b22bd9712183f5a7c8027c8d9af89b52d1e7d06fd1f87a1e5d20d" }, { "mask": "fbc3e5bdb36fc58e5800ffc549ab7bd533fadb7e6b64898c82ea620d749fc80e", "amount": "b9335c3dc0afb774f812f9f58a412c849f3c828d873f1c16ab102963799d9809" }], "outPk": [ "cf141f5dfe04df14afad6b451d600aa5826a9be44a76a1630850c1d5951d482e", "e10bb69b66af5dabec765c7f5f7528926088877fa36746833828a0575896ae57"] }, "rctsig_prunable": {</p>

    <p class="text-gray-300">"rangeSigs": [ { "asig": "b9b544a7[...]d4c5726e81c4c4b6205dacc05208", "Ci": "bc7ae457[...]fe490458" }, { "asig": "9c457b41[...]545b60c", "Ci": "ce9b4d8e[...]03a6752" }], "MGs": [ { "ss": [["a8120b96f5f2ac5bceab37f7d6bf8d86554d87c4af3441007cad92f54a24d908", "2e6bc016297a5d398936c9f45e7a80215138f69e55179b337922e2d51c1a9f00"], ["1e1052a68c38bb88b6e8f257d999c13f1d5f4fa219cc23479ccbfa6b14b5960a", "e914d35eed0d27344fbc3a89b91bd445d433b561efc844c9f466a61ebb5f6d09"], ["e04d011f515461fdbd8d13536c23143dc365d87dd323defb1af834e540a8fc0e", "f9b41a117a1415fec54f1cc16aeef859b2cab1494b9e26a95fc9eaf4f571fa00"], ["de7a7b30795cab310b632f708c6c2546847a5cbcc27ff48e75c1556c3f6f180c", "6218695558359d115e308b008d9aa368c38672732d2fc21c6317ad7d15918c05"], ["0ca70bbdea0e391b1e24e2540f33b48dd9dc554c61ebf23bb3691aab5094e40f", "dafecd436b2448504c0a3a1997b356c141f1d4b5977cc66e5f55592f13731501"]], "cc": "5059757cf06216215955aaa108e8dd40be157856749a9d883bcac611e395a409" }]} }</p>

    <h2 id="sec-61" class="text-2xl font-bold">Transaction components</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>vin (line 7-14) - List of inputs</li>

      <li>amount (line 9) - Deprecated amount field for type 1 transactions</li>

      <li>key_offset (line 10) - Relative offsets respect to previous block of ring components, spent output and mixin outputs. As an illustration, 799048 is to be interpreted as the 799048^{th} transaction counting backwards from the current transaction and starting from the previous block</li>

      <li>k_image (line 12) - Key image <span class="math">\\tilde{K_{j}}</span> from Section 3.3</li>

      <li>vout (lines 16-27) - List of outputs</li>

      <li>amount (line 17) - Deprecated amount field for type 1 transactions</li>

      <li>key (line 19) - One-time destination key as described in Section 5.2</li>

      <li>extra (lines 28-32) - Miscellaneous data, including the Transaction key, or share secret <span class="math">rG</span> of Section 5.2</li>

      <li>rct_signatures (lines 33-45) - First part of signature data</li>

    </ul>

    <p class="text-gray-300">APPENDIX A. RCTTYPEFULL TRANSACTION STRUCTURE</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>type (line 34) - Signature type, in this case RCTTypeFull</li>

      <li>txnFee (line 35) - Transaction fee in clear, in this case 0.026 XMR</li>

      <li>ecdhInfo (lines 36-42) - Encrypted mask and amount of each of the outputs</li>

      <li>mask (line 37) - Field mask as described in Section 5.4.1</li>

      <li>amount (line 38) - Field amount as described in Section 5.4.1</li>

      <li>outPk (lines 43-44) - Output commitments</li>

      <li>rctsig_prunable (lines 46-67) - Second part of signatures</li>

      <li>rangeSigs (lines 47-53) - Range proofs for output commitments</li>

      <li>asig (line 48) - Borromean signature of the amount, see Section 5.4.6</li>

      <li>Ci (line 49) - Borromean commitments (ring keys), as described in Section 5.4.3. As hinted in Section 5.4.6 only the <span class="math">K_{j}</span> need to be stored, as the values <span class="math">K_{j}-2^{j}H</span> can be easily derived by the network.</li>

      <li>MGs (lines 54-66) - Remaining elements of the MLSAG signature</li>

      <li>ss (lines 55-64) - Components <span class="math">r_{i,j}</span> from the MLSAG signature</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\sigma(\\mathfrak{m})=(c_{1},r_{1,1},...,r_{n,1},...,r_{1,m},...,r_{n,m},\\tilde{K}_{1},...,\\tilde{K}_{m})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>cc (line 65) - Component <span class="math">c_{1}</span> from aforementioned MLSAG signature</li>

    </ul>

    <p class="text-gray-300">APPENDIX B</p>

    <p class="text-gray-300">In this section we show the structure of a sample transaction of type RCTTypeSimple. The transaction has 4 inputs and 2 outputs.</p>

    <pre><code class="language-r">1 print_tx 3ebf45fc5f8fd683037807384122817d5debfa762c7a7845cb7ccfe9ee20940b
2 Found in blockchain at height 1469563
3 020004[...]923b3d70d
4 {
5 &quot;version&quot;: 2,
6 &quot;unlock_time&quot;: 0,
7 &quot;vin&quot;: [ {
8 &quot;key&quot;: {
9 &quot;amount&quot;: 0,
10 &quot;key_offset&quot;: [ 1567249, 1991110, 349235, 15551, 3620
11 ],
12 &quot;k_image&quot;: &quot;9661119b4b54529e1be14ef97fbdc0504d17a6c8dfedd55d2455b93a6336bb41&quot;
13 }
14 }, {
15 &quot;key&quot;: {
16 &quot;amount&quot;: 0,
17 &quot;key_offset&quot;: [ 2502375, 650851, 337433, 396459, 39529
18 ],
19 &quot;k_image&quot;: &quot;2102414d8edfa229f9ebf32ab90acd9cf23963a8c3b6ba0e181fc1d5782c046c&quot;
20 }
21 }, {
22 &quot;key&quot;: {

APPENDIX B. RCTTYPESIMPLE TRANSACTION STRUCTURE
</code></pre>

    <p class="text-gray-300">"amount": 0, "key_offsets": [1907097, 696508, 806254, 510195, 6709], "k_image": "de14ec8958b311bd38a05aa3fb08fdd360001f1b9c060264eecdd8c08c9e83c4" }, { "key": { "amount": 0, "key_offsets": [1150236, 1943388, 788506, 37175, 7462], "k_image": "e470f77dd5a4149210cb61ee107e73caea1ef9f61d05384e3bd4372fdc85bf17" } }, "vout": [ { "amount": 0, "target": { "key": "787cad1ebb181e1fc04b24d4d06c3d2882c38b262a7635de8ad487c536e40a12" }, { "amount": 0, "target": { "key": "faf4137928392b39ccf0a830c0261573009959787697f9d4fb769c25781fb911" } }, "extra": [1, 20, 56, 120, 111, 89, 89, 64, 10, 98, 96, 255, 202, 235, 203, 255, 2, 197, 176, 147, 61, 60, 41, 145, 207, 178, 212, 71, 37, 69, 19, 147, 205], "rct_signatures": { "type": 2, "txnFee": 558805800000, "pseudoOuts": [ "64dea29ac5560f93773240d58ca5768b879fd3c95e0b3b50a80ec36a6ff3a6da", "a60e7a00e65ff2a6299b92b166a629e9b0d62f6df50e40535140716757efe4c0", "4c67403adbc9dc0ca5a1a6abc846ab6d232dc3fa295099b3c7a9d005bac60eba", "635b26d78117d77899859ecb61e10125c3956a5c113b932f33c92c561acddaa3"] "ecdhInfo": [ { "mask": "ccffac42a86bec7b36ce9957cbdfe481d419bc5353335d0c236c347aea758d0c", "amount": "c0d6cf3e1db55dd459b73faf34d7339c3fa1b3d3356cfb2adc3faf798264b00e" }, { "mask": "62cc846003d9c5425c6cf33b30754a4c044f5d9d02621460e45664b886673109", "amount": "726dbacad62022bf0f5af05c72482b3f040d631d3f576b5e2615ea72f84c5f06" }], "outPk": [ "cb3b729b4fca6e66736666201633e3f905c367a2f3d18e31fe3d3c18d2be93fd",</p>

    <p class="text-gray-300">APPENDIX B. RCTTYPESIMPLE TRANSACTION STRUCTURE</p>

    <pre><code class="language-txt">67 &quot;1e8c86b7f211a99e1762bf62254efe65ea5c5328b62b0ea8d679b2e52800f633&quot;]
68 },
69 &quot;rctsig_prunable&quot;: {
70 &quot;rangeSigs&quot;: [ {
71 &quot;asig&quot;: &quot;9bb7cce09[...]61de7ce0a&quot;,
72 &quot;Ci&quot;: &quot;50dfd2e8[...]b3a7c8fca1b1&quot;
73 }，
74 &quot;asig&quot;: &quot;e3905fa5c[...]b5213444908&quot;,
75 &quot;Ci&quot;: &quot;595c2cec5f2[...]72a628ab5c&quot;
76 }],
77 &quot;MGs&quot;: [ {
78 &quot;ss&quot;: [ [ &quot;3b2d26ea7628015fd8317e4e298ceda6b534ac894b83f7b6190a353cee6ec702&quot;,
79 &quot;2d772ad7b7ff2ba8a1a66c8d69c0a0d49d72808eaf803c59f13c3d78b653440c&quot;]
80 [ &quot;c188891fb37d76305f0209222f52d22ede43018facfe91f949ecb8dcf709b30a&quot;,
81 &quot;303896ca67ea7969544641d5bb94a436558bcf6522bb9bc77bd1abb5f2146c08&quot;]
82 [ &quot;e01c88b7308403a9dd023d9eacf1ade17ab0fa54250148431b5a33c98e636100&quot;,
83 &quot;ba36e34e5245e89c7c21af845b949cf3e82188df639390f094e31c9ba773060c&quot;]
84 [ &quot;37175d72d2bef3f8bd9e65fb2861f7bce91e3b1e30278b2dcf26112831ac9405&quot;,
85 &quot;8e77a5dd641a89e86dbe0708e8f59d0e2dc9fe4ddfd9b367c3a93522198a4706&quot;]
86 [ &quot;fbb4f94f9ce0f081421e63677a63d5914f0536a481d57b6e5fc5379c84dfbcb05&quot;,
87 &quot;1ec40aa3c8a94c6b1915b7796423b0d7d6011aa2d6af636aff309b832f193408&quot;]
88 &quot;cc&quot;: &quot;a03119e4257cca37f89ac3e97f0598b712c79162c73932d58ab4ce08c4ad6709&quot;
90 }，
91 &quot;ss&quot;: [ [ &quot;f7aedeec462d7588330c71589fde5f0f234a627a6e5ed72cff34825a04d41707&quot;,
92 &quot;31d7a5ba4e782db5c0704ab751a2ef8c4732f3cf699bc8f9994e79a97cd3190e&quot;]
93 [ &quot;00e1d1ecdf31fdf7d57661f2234bfc859cfdc4dbfdfd0f5eec0576ef22592203&quot;,
94 &quot;fdf08b803fa6de18bf0e0dc6855e877877bda0101eceb81e2223fe0175606300&quot;]
95 [ &quot;3397ba3f9e8db066e3c4911b896debefbc73efbac4988e6aff5731ff8db15405&quot;,
96 &quot;43d2b03d5263de99f56c256e646be503edd63dd03d377a469379fbf487e8600e&quot;]
97 [ &quot;31afd1d5c3b07170ac127605fc35cbcc19cf963a35b2ff8f804e17e3b804000d&quot;,
98 &quot;3a3bc124a10b0cf416656f8f682a427445140895440cca644c6aa38966399f0c&quot;]
99 [ &quot;f499f0e4922d5cba35e3cc033489b60ec7ea26ff19cc9dd29357670f4bf8790b&quot;,
100 &quot;1a4732b31f0f1a7d3322be5c4baca098f0a032c192bf9f8a6b5fd83cbdd9d401&quot;]
101 &quot;cc&quot;: &quot;095fcab7ebf64c2ffecdacf11b70f97f0e709de0a84b3a13abca627f9df2c901&quot;
102 }，
103 &quot;ss&quot;: [ [ &quot;1808924b4154118c48f0b305562b6ffba86f38c64d4d8a087823f3383cddd006&quot;,
104 &quot;4b18544be50aee8c4594b568d6be741c155a132cb83392d9b1a4cf35c3d5760c&quot;,
105 [ &quot;9a95eeecf3c3a48c43873a372c263357ff5f258a7bf8ed29a767237b0b0f202&quot;,
106 &quot;4f1ea4d9d4b56db780dd078a3e8219d0f54eaccc197901671002a206f063cb0e&quot;,
107 [ &quot;2c800017cab2b8388f58fed0d61a46570f64cacd8fabc4e84ddee735b3135f0a&quot;,
108 &quot;458016f6fdf58b329fae0f929226ee2b8e410a14db8c6ede9b74fb718de71507&quot;,
109 [ &quot;ea0fcaf793602dce25c8b2c4d17163f4298933b3fb09874307d8cde9a63c2c0c&quot;,
110 &quot;df76fbcd336c07f37e90e1a0d0db1ba49519ba4325062228bc9242af2c525703&quot;,
111 [ &quot;e3a7a0477eeb602a9a8203a6a496cca90c4769d57410246c4c8d665df34df900&quot;,

APPENDIX B. RCTTYPESIMPLE TRANSACTION STRUCTURE
</code></pre>

    <p class="text-gray-300">111 "44d206154f0ca85e12a92eefdbc3784e17e701a32ff93b550467679f67500c0d"]], 112 "cc": "6f80de1c1d566776d2831f15c9a85fb1d8e8cecfd0d2753b318f0e84d89d3b08" 113 }, { 114 "ss": [ [ "5b82b4644b57e3d623de7c72c6ebd52959815c12c80b479e4cbe5437cf67640c", 115 "b70e0b69c75faba6a1630429f9f497db351347c210467f69e1b1c5f1a72afe02"]], 116 [ "f25a93a98f980cf489eb8f69369f4ec63eaea91fd677decab9b6ca0fe2feb606", 117 "124536c374cb6023a6aa6f22ae6e115a1ba12cb36c48f5f5ad43ce90f471da02"]], 118 [ "151ddc82322456d7f31b8b4b2290098c3bf2428370c7ef325660b5463ff26404", 119 "2fb9d2979e16c2b1131686bb85068ec559f9c6c64581e609b451bb2cd9d5740d"]], 120 [ "c03bed01d6ad60b3da5d2c88cf2e5023b51133c37e4917511715a11f09d8740d", 121 "432e01c2075ab6361af8636cc1c9254e12db98f5c323088792dfb42a1c894401"]], 122 [ "52206d801214e70d20ee7ca53823c143aa06c3d1b22b118cc8a15c9f861f0102", 123 "563c134f56f7a290e0980877e93bc4b08651e53dade079b1e6c066b70fb81406"]], 124 "cc": "4102cd245db3e0d7c0e2280cfdba38b9b7a7ad8715b8fe68c1170cf923b3d70d" 125 }] 126 } 127 } 128 129 130</p>

    <pre><code>
# Transaction components

What follows is a short explanation of most important elements in transactions. We do only mention components that are specific or differ from the previous RCTTypeFull transaction type.

- type (line 53) - Signature type, in this case the value 2, corresponding to RCTTypeSimple transactions
- pseudoOuts (lines 55-58) - Pseudo-outputs used for commitments to zero against the real previous outputs, as described in Section 5.5.1. Please recall that the sum of these commitments will equal the sum of the 2 output commitments of the transaction.</code></pre>`;
---

<BaseLayout title="Monero - Privacy in the Blockchain (2018/535)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/535
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
