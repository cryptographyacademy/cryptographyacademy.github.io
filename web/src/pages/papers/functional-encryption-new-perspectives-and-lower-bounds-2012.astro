---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/468';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
---

<BaseLayout title="Functional Encryption: New Perspectives and Lower Bounds (2012/468)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        Functional Encryption: New Perspectives and Lower Bounds
      </h1>
      <p class="text-gray-400 mb-2">
        Shweta Agrawal, Sergey Gorbunov, Vinod Vaikuntanathan, Hoeteck Wee
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; Full Version &middot; eprint 2012/468
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
        &middot; 156s on modal (Tesla T4)
        &middot; sha256:2b8b7f6f2d047a9a...
      </p>
    </header>

    <section class="paper-content">
      <p class="text-gray-300">Shweta Agrawal <em><sup>∗</sup></em> Sergey Gorbunov<em>†</em> Vinod Vaikuntanathan<em>‡</em> Hoeteck Wee<em>§</em></p>
      <h4 id="abstract" class="text-lg font-semibold mt-6 mb-2">Abstract</h4>
      <p class="text-gray-300">Functional encryption is an emerging paradigm for public-key encryption that enables finegrained control of access to encrypted data. In this work, we present new perspectives on security definitions for functional encryption, as well as new lower bounds on what can be achieved. Our main contributions are as follows:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*•* We show a lower bound for functional encryption that satisfies a weak (non-adaptive) simulation-based security notion, via pseudo-random functions. This is the *first* lower bound that exploits *unbounded* collusions in an essential way.</li>
        <li>*•* We put forth and discuss a simulation-based notion of security for functional encryption, with an unbounded simulator (called USIM). We show that this notion interpolates indistinguishability and simulation-based security notions, and has strong correlations to results and barriers in the zero-knowledge and multi-party computation literature.</li>
      </ul>
      <p class="text-gray-300"><strong>Keywords</strong>: Functional encryption, Lower Bounds, Pseudo-Random Functions, Simulationbased Definitions.</p>
      <p class="text-gray-300"><em><sup>∗</sup></em>UCLA. Email: shweta@cs.ucla.edu. Research supported in part from a DARPA/ONR PROCEED award, NSF grants 1136174, 1118096, 1065276, 0916574 and 0830803, a Xerox Faculty Research Award, a Google Faculty Research Award, an equipment grant from Intel, and an Okawa Foundation Research Grant (Amit Sahai). This material is based upon work supported by the Defense Advanced Research Projects Agency through the U.S. Office of Naval Research under Contract N00014-11-1-0389. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.</p>
      <p class="text-gray-300"><em><sup>†</sup></em>University of Toronto. Email: sgorbunov@cs.toronto.edu. Supported by NSERC Alexander Graham Bell Graduate Scholarship.</p>
      <p class="text-gray-300"><em><sup>‡</sup></em>University of Toronto. Email: vinodv@cs.toronto.edu. Supported by an NSERC Discovery Grant and by DARPA under Agreement number FA8750-11-2-0225. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the author and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.</p>
      <p class="text-gray-300"><em><sup>§</sup></em>George Washington University. Email: hoeteck@alum.mit.edu. Supported by NSF CAREER Award CNS-1237429.</p>
      <h3 id="1-introduction" class="text-xl font-semibold mt-8 mb-3">1 Introduction</h3>
      <p class="text-gray-300">Functional encryption [[SW05,](#page-16-0) [SW08\]](#page-16-1) is a new paradigm for public-key encryption that enables fine-grained control of access to encrypted data. It extends several previous notions, most notably identity-based encryption [[Sha84](#page-16-2), [BF01](#page-14-0), [Coc01](#page-14-1)], and provides, for instance, the ability to generate and release secret keys associated with a keyword that can decrypt only those documents that contain the keyword. More generally, functional encryption allows the owner of a "master" secret key to release restricted secret keys that reveal a specific function of encrypted data. This stands in stark contrast to traditional encryption, where access to the encrypted data is all or nothing: namely, given the secret key, one can decrypt and read the entire plaintext, but without it, nothing about the plaintext is revealed at all (other than its length).</p>
      <p class="text-gray-300"><strong>Functional Encryption.</strong> A functional encryption scheme for a circuit family [\[BSW11](#page-14-2), [O'N10\]](#page-15-0) <em>C</em>, associates secret keys SK<em><sup>C</sup></em> with every circuit <em>C ∈ C</em> and ciphertext CT with every input message <em>x</em>. 1</p>
      <p class="text-gray-300">In broad terms, functional encryption requires that the owner of a secret key SK<em><sup>C</sup></em> and a ciphertext CT (corresponding to an input message <em>x</em>) be able to compute <em>C</em>(<em>x</em>), but learn nothing else about <em>x</em> itself. (Typically, and throughout this work, we assume that the circuit family <em>C</em> as well as the circuit queries <em>C</em> are public.)</p>
      <p class="text-gray-300">Moreover, security should hold in the presence of collusions amongst "key holders", that is, malicious users should not be able to combine their secret keys to learn unauthorized information. More formally, a collusion of users that hold secret keys SK<em>C</em><sup>1</sup> <em>, . . . ,</em> SK<em>C<sup>q</sup></em> and an encryption of <em>x</em> should learn nothing else about <em>x</em> apart from <em>C</em>1(<em>x</em>)<em>, . . . , Cq</em>(<em>x</em>), for any polynomial <em>q</em>.</p>
      <p class="text-gray-300">An important subclass of functional encryption is that of public-index predicate encryption. Here, the input <em>x</em> is a pair (ind<em>, µ</em>) where ind is an index and <em>µ</em> the payload message. Let <em>P</em> be a Boolean predicate defined on indices, the circuit family <em>C</em> is given by:</p>
      <div class="math-block">C_P(\mathsf&#123;ind&#125;, \mu) = \left\&#123; \begin&#123;array&#125;&#123;ll&#125; (\mathsf&#123;ind&#125;, \mu) & \mathrm&#123;if&#125;\ P(\mathsf&#123;ind&#125;) = 1 \\ (\mathsf&#123;ind&#125;, \bot) & \mathrm&#123;otherwise&#125; \end&#123;array&#125; \right.</div>
      <p class="text-gray-300">Even though public index predicate encryption seems like a weak object, it already captures identity-based encryption, and is also very useful in constructing protocols for verifiably delegating computation as shown recently by Parno, Raykova and Vaikuntanathan [[PRV12\]](#page-16-3).</p>
      <p class="text-gray-300">Predicate encryption captures and generalizes a large number of previous constructions, including identity-based encryption (IBE) [[Sha84](#page-16-2), [BF01,](#page-14-0) [Coc01,](#page-14-1) [BW06](#page-14-3)], fuzzy IBE [\[SW05](#page-16-0), [ABV](#page-14-4)+12], attribute-based encryption (ABE) [[GPSW06](#page-15-1), [LOS](#page-15-2)+10], and inner product encryption [\[KSW08,](#page-15-3) [LOS](#page-15-2)+10, [AFV11\]](#page-14-5). Specifically, IBE corresponds to <em>P</em> encoding a point function. Moreover, essentially all known constructions are examples of public-index predicate encryption schemes or its variants, with a few exceptions – constructions in [[BF01](#page-14-0), [BW06,](#page-14-3) [KSW08\]](#page-15-3) achieve a stronger private-index security notion in which the index ind also remains hidden from the adversary.</p>
      <p class="text-gray-300"><strong>Recent Work.</strong> Boneh, Sahai and Waters [\[BSW11](#page-14-2)] and O'Neill [\[O'N10\]](#page-15-0) were the first to put forth a general definitional framework for functional encryption. They considered two security notions for functional encryption, namely: <em>indistinguishability</em> (IND) based security and <em>simulation</em> (SIM) based security. The former stipulates that it is infeasible to distinguish encryptions of any two</p>
      <sup>1</sup>An alternative approach is associate secret keys to inputs and ciphertexts to circuits. This is equivalent to our approach by taking a new "universal" family *U<sup>x</sup>* that on input *C* outputs *C*(*x*).
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">realizable for public-index</td><td class="border border-gray-700 px-3 py-1">realizable for all circuits</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">xx-yy-IND</td><td class="border border-gray-700 px-3 py-1">open</td><td class="border border-gray-700 px-3 py-1">open</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">xx-yy-SIM<br>(xx = 1 OR yy =<br>NA)</td><td class="border border-gray-700 px-3 py-1">open</td><td class="border border-gray-700 px-3 py-1">no<br>(Section<br>4)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">many-AD-SIM</td><td class="border border-gray-700 px-3 py-1">no [BSW11]</td><td class="border border-gray-700 px-3 py-1">no<br>←</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">xx-yy-USIM<br>(xx = 1 OR yy =<br>NA)</td><td class="border border-gray-700 px-3 py-1">open</td><td class="border border-gray-700 px-3 py-1">open</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">many-AD-USIM</td><td class="border border-gray-700 px-3 py-1">no<br>[BSW11]<br>♯</td><td class="border border-gray-700 px-3 py-1">no<br>←</td></tr>
      </tbody></table></div>
      <span id="page-2-0"></span>Figure 1: Summary of results and open problems. Results from this work are marked with boldface. Results implicit in previous works are marked with *♯*. Results that are trivially implied by results in a previous column are marked with *←*. The second and third columns indicate whether the definition is realizable for all public-index predicate encryption schemes (e.g. IBE) and for all circuits respectively. USIM refers to the notion of unbounded simulation discussed in Section [1.2.](#page-4-0)
      <p class="text-gray-300">messages, without getting a secret key that decrypts the ciphertexts to distinct values; the latter stipulates the existence of an efficient simulator that given <em>C</em>1(<em>x</em>)<em>, . . . , Cq</em>(<em>x</em>), outputs the view of the colluders that are given an encryption of <em>x</em> as well as secret keys SK<em>C</em><sup>1</sup> <em>, . . . ,</em> SK<em>C<sup>q</sup></em> .</p>
      <p class="text-gray-300">Both of these notions may be further refined in two ways: <em>adaptive</em> (AD) versus <em>non-adaptive</em> (NA) which capture whether the adversary's queries to the key derivation oracle may or may not depend on the challenge ciphertext; and <em>one</em> versus <em>many</em>, referring to whether the adversary receives a single or multiple challenge ciphertexts. Together, these give rise to eight security notions xx-yy-zzz, where xx <em>∈ &#123;</em>1<em>,</em> many<em>&#125;</em>, yy <em>∈ &#123;</em>NA<em>,</em> AD<em>&#125;</em>, and zzz <em>∈ &#123;</em>IND<em>,</em> SIM<em>&#125;</em>.</p>
      <p class="text-gray-300">We note that in general, indistinguishability based security provides a weaker guarantee than simulation based security (that is, xx-yy-SIM implies xx-yy-IND and xx-yy-IND does not imply xx-yy-SIM in general); on the other hand, we have that 1-yy-IND implies many-yy-IND. Boneh, et al. [[BSW11\]](#page-14-2) pointed out that indistinguishability based security is vacuous and inadequate for certain circuit families, which indicate that we should opt for simulation-based security whenever possible.<sup>2</sup> O'Neill [\[O'N10\]](#page-15-0) showed that NA-IND and NA-SIM are equivalent for some subclass of circuit families that are roughly speaking, "easy to invert".</p>
      <p class="text-gray-300">All prior positive results achieve many-AD-IND security or relaxations there-of.<sup>3</sup> The only known impossibility result we have for general functional encryption is that of Boneh et al. [[BSW11\]](#page-14-2) for realizing the IBE functionality under many-AD-SIM security. In particular, in light of known results, it is entirely conceivable that we can realize functional encryption for all poly-size circuits under either 1-AD-SIM security (thus 1-AD-IND and many-AD-IND security) or many-NA-SIM security.</p>
      <p class="text-gray-300">In this work, we narrow the gap between existing security definitions for functional encryption, as well as that between existing constructions and impossibility results. Our results are as follows.</p>
      <sup>2</sup> [\[BSW11](#page-14-2), Section 5.3] presents an "equivalence" between many-AD-IND and many-AD-SIM in the *programmable* random oracle model for public-index predicate encryption. For this work, we consider only the standard model.
      <sup>3</sup>A commonly used relaxation of AD-IND security for predicate encryption is that of "selective security" [[CHK03\]](#page-14-6).
      <h4 id="1-1-new-lower-bound-impossibility-for-simulation-based-definitions" class="text-lg font-semibold mt-6 mb-2">1.1 New Lower Bound: Impossibility for Simulation-based Definitions</h4>
      <p class="text-gray-300">Our main result rules out general functional encryption under the one message secure, non-adaptive simulation definition (1-NA-SIM). In particular, this rules out both of the scenarios presented at the end of the preceding section (i.e. 1-AD-SIM or many-NA-SIM for all circuits) in a strong sense. This is the <em>first</em> lower bound that exploits <em>unbounded</em> collusions in an essential way. We compare the impossibility result from [[BSW11\]](#page-14-2) with ours in Figure [2.](#page-6-0)</p>
      <p class="text-gray-300"><strong>Theorem 1.1</strong> (Informal)<strong>.</strong> <em>There exists a circuit family C for which there is no</em> 1-NA-SIM<em>-secure function encryption scheme.</em></p>
      <p class="text-gray-300">Specifically, assuming the existence of a family of weak pseudo-random function wPRF(<em>·, ·</em>), we show that there does not exist a functional encryption scheme for the family:</p>
      <div class="math-block">C_d(x) = \mathsf&#123;wPRF&#125;(x, d)</div>
      <p class="text-gray-300">, where the input message  <span class="math">x</span>  is the PRF seed</p>
      <p class="text-gray-300">We show that the ciphertext size in a 1-NA-SIM-secure scheme realizing this circuit family must grow with the size of the collusion; this yields a contradiction, since the scheme must handle unbounded collusions. In fact, the result is unconditional since any non-trivial functional encryption scheme gives rise to a one-way function and thus pseudo-random functions.</p>
      <p class="text-gray-300">The key observation is as follows. Suppose the adversary requests for <em>q</em> secret keys corresponding to random inputs <em>Cd</em><sup>1</sup> <em>, . . . , Cd<sup>q</sup></em> and then requests for an encryption of a random <em>x</em>. Then, the simulated ciphertext together with the <em>q</em> simulated secret keys constitute a description of the values wPRF(<em>x, d</em>1)<em>, . . . ,</em> wPRF(<em>x, dq</em>), which is essentially a sequence of <em>q</em> truly random bits via pseudo-randomness. By a standard information-theoretic argument, this means that the length of the ciphertext plus the secret keys must grow with <em>q</em>. To obtain a lower bound on the ciphertext size, we carefully exploit the fact that the simulator has to generate the secret keys before it sees the output of wPRF(<em>x, ·</em>). Then, the simulator has to generate a small ciphertext that "explains" all these pseudorandom values which is impossible using a compressibility argument. More generally, we show that (1) weak pseudo-random family is "incompressible", and (2) NA-SIM-secure functional encryption only exists for "compressible" circuit families. (In particular, the circuit family for all <em>public-index</em> predicate encryption is compressible.)</p>
      <p class="text-gray-300">This idea is reminiscent of the obfuscation impossibility result of Goldwasser and Kalai [[GK05\]](#page-15-4), although the precise settings are quite different (in particular, functional encryption and program obfuscation seem incomparable, although related, objects).</p>
      <p class="text-gray-300"><strong>Implications.</strong> The basic idea described above can be extended to a lower bound for even weaker forms of the simulation-based definition, including (a non-adaptive variant of) the definition of Boneh, Sahai and Waters [[BSW11\]](#page-14-2). Here, we mention yet another implication of this idea.</p>
      <p class="text-gray-300">Gorbunov, Vaikuntanathan and Wee [\[GVW12](#page-15-5)] recently presented a 1-AD-SIM-secure functional encryption scheme for all circuits, assuming that the adversary can only corrupt an a-priori bounded number of users (and thus, get the corresponding secret keys). One of the shortcomings of their bounded-collusion security notion as well as their construction is that the parameters of the system, and especially the size of the ciphertext depends on the collusion bound <em>q</em>. A natural question is whether their ciphertexts can be made to have size independent of <em>q</em> (or, at the very least, <em>o</em>(<em>q</em>)).<sup>4</sup> Indeed, in light of the results of Dodis, Katz, Xu and Yung [[DKXY02\]](#page-15-6) and most recently,</p>
      <sup>4</sup>The previous lower bound for many-AD-SIM IBE in [\[BSW11\]](#page-14-2) (which says that the secret key size must grow with the number of challenge ciphertexts) is not applicable here as the [[GVW12\]](#page-15-5) construction considers only a single challenge ciphertext.
      <p class="text-gray-300">Goldwasser, Lewko and Wilson [\[GLW12\]](#page-15-7) in the context of bounded-collusion IBE, one might expect that achieving "short" ciphertexts is actually be possible in general.</p>
      <p class="text-gray-300">Unfortunately, our techniques result in a strong negative answer to this question.</p>
      <p class="text-gray-300"><strong>Corollary 1.2.</strong> <em>There exists a family of circuits C such that for every q</em> = <em>q</em>(<em>κ</em>)<em>, there are no q-collusion resistant 1-</em>NA<em>-</em>SIM<em>-secure functional encryption schemes with ciphertexts of size o</em>(<em>q</em>)<em>.</em></p>
      <h4 id="span-id-page-4-0-span-1-2-new-perspectives-unbounded-simulation" class="text-lg font-semibold mt-6 mb-2"><span id="page-4-0"></span>1.2 New Perspectives: Unbounded Simulation</h4>
      <p class="text-gray-300">The preceding lower bound together with those of Boneh, Sahai and Waters [[BSW11](#page-14-2)] show that even fairly weak simulation-based definitions of functional encryption are unachievable for a large and natural class of circuits. This state of affairs begs the question:</p>
      <p class="text-gray-300"><em>What is a</em> meaningful <em>and</em> generally realizable <em>security notion for functional encryption?</em></p>
      <p class="text-gray-300">While we do not provide a definitive answer to this question in our work, we firmly believe that the quest for the right definition should incorporate insights from secure computation and zero knowledge. Indeed, several recent works [[GVW12,](#page-15-5) [SS10](#page-16-4)] exploited techniques and insights from secure computation [[Yao86,](#page-16-5) [BGW88](#page-14-7), [BMR90\]](#page-14-8) to derive general feasibility results for functional encryption with bounded collusions.</p>
      <p class="text-gray-300">We put forth USIM security, where the simulator has unbounded computational power. In particular, this would allow us to circumvent our lower bound in the previous section. Similar notions have been considered for zero knowledge and secure computation [[Pas03,](#page-15-8) [PS04,](#page-16-6) [BS05\]](#page-14-9).<sup>5</sup></p>
      <p class="text-gray-300">Before presenting our results for USIM security, we first provide an intuitive interpretation of what USIM security buys us, via the real/ideal paradigm. Recall that polynomial-time simulationbased security for functional encryption guarantees that against a computational bounded adversary holding a secret key SK<em>C</em>, an encryption of <em>x</em> leaks no more information about <em>x</em> than what an efficient adversary can deduce given <em>C</em>(<em>x</em>) (and <em>C</em>); allowing unbounded simulation means that an encryption of <em>x</em> leaks no more information about <em>x</em> than what a computationally unbounded adversary can deduce given <em>C</em>(<em>x</em>) (and <em>x</em>). Indeed, in the case of public-index predicate encryption, <em>C</em>(<em>x</em>) does hide <em>x</em> completely against a computationally unbounded adversary that only holds keys for which the predicate is false. One could even make the case that for public-index predicate encryption, USIM security is "as good as" SIM security!<sup>6</sup> On the other hand, for circuits that only hide information about <em>x</em> computationally, USIM security would be inadequate and SIM security remains the desirable notion.</p>
      <p class="text-gray-300">Next, we establish basic relations between USIM security and SIM, IND security, namely it is "sandwiched" between the two, that is, for yy <em>∈ &#123;</em>NA<em>,</em> AD<em>&#125;</em>:</p>
      <div class="math-block">yy-IND \Leftarrow yy-USIM \Leftarrow yy-SIM</div>
      <p class="text-gray-300">This inclusion yields a simple "litmus test" for checking if IND security is inadequate for a circuit family <em>C</em>: IND security is inadequate whenever USIM security is inadequate, namely <em>C</em>(<em>x</em>) reveals more information about <em>x</em> to an unbounded adversary than an efficient adversary.</p>
      <p class="text-gray-300">Furthermore, with this notion in mind, we refine and further clarify two results in [[BSW11](#page-14-2)]:</p>
      <sup>5</sup>The works on zero knowledge and secure computation focus on quasi-polynomial-time simulators. We observe that our lower bound also rules out quasi-polynomial-time simulators assuming the existence of one-way functions with sub-exponential hardness.
      <sup>6</sup>O'Neill [\[O'N10](#page-15-0), Section 4] showed that NA-IND and NA-SIM are equivalent for public-index predicate encryption. This does not subsume the point we are making because our argument applies also to the adaptive setting. Indeed, AD-IND and AD-SIM are provably *not* equivalent for public-index predicate encryption; under standard assumptions, we have AD-IND-secure IBE, whereas AD-SIM-secure IBE do not exist.
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*•* the counter-example separating indistinguishability and simulation-based notion (which encodes a one-way permutation into the circuit family) in fact separates efficient and unbounded simulation; there, the circuit inherently leaks more information to an unbounded adversary than an efficient adversary. That is, the result really points to the inadequacy of the unbounded simulation security (and not indistinguishability-based notion) for certain families.</li>
        <li>*•* the lower bound for IBE under many-AD-SIM security extends to many-AD-USIM; that is, the result is fundamentally about a simulation-based security notion, and not about efficiency.</li>
      </ul>
      <p class="text-gray-300">The reader is referred to Figure [1](#page-2-0) for a survey of our results and open problems, and to Appendix [C](#page-18-0) for results on the unbounded simulator definition.</p>
      <h4 id="1-3-discussion" class="text-lg font-semibold mt-6 mb-2">1.3 Discussion</h4>
      <p class="text-gray-300"><strong>FunctoMania.</strong> Let's be wishful thinkers for a minute – suppose we can have whatever we hope for in functional encryption, call this world "Functomania". What does Functomania look like? In light of the existing (im)possibilities, there will be two incomparable "dream results":</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*•* 1-AD-SIM secure public index predicate encryption for all efficient predicates; such schemes also satisfy 1-AD-IND, 1-AD-USIM, and many-AD-IND security.</li>
        <li>*•* 1-AD-USIM secure functional encryption for all poly-size circuits; such schemes also satisfy 1-AD-IND and many-AD-IND security.</li>
      </ul>
      <p class="text-gray-300">Given the current state of affairs in functional encryption, establishing either result in the affirmative (or even under the weaker 1-AD-IND security) will be considered a major break-through.</p>
      <p class="text-gray-300"><strong>The</strong> IND<strong>-</strong>(U)SIM <strong>Conundrum.</strong> From a definitional stand-point, SIM/USIM-based security notions are preferable to IND-based security notion, as they offer a stronger security guarantee that has a natural, intuitive and aesthetically pleasing interpretation via the real/ideal paradigm. On the other hand, IND-based security notion allows us to bypass the impossibility results given in [\[BSW11](#page-14-2)] and in this work; in addition, they guarantee message <em>composability</em> in that security with a single ciphertext implies security for multiple ciphertexts (and so does NA-SIM considered in [\[GVW12](#page-15-5)]). We do not offer a complete answer to this conundrum; instead, we point out that 1-AD-SIM and 1-AD-USIM appear to be an adequate compromise for predicate encryption and general functional encryption respectively. We also note that such a conundrum is not unique to functional encryption, and has indeed previously surfaced and widely studied in the context of zero knowledge [[FS90,](#page-15-9) [Pas03](#page-15-8)] and secure multi-party computation [[PS04](#page-16-6), [BS05,](#page-14-9) [MPR06\]](#page-15-10). One notable difference is that in zero knowledge and secure computation, super-polynomial time simulation offers concurrency; this is not the case for functional encryption. (The lower bound for many-AD-USIM-secure IBE indicates that even unbounded-time simulation does not help with message composability.)</p>
      <p class="text-gray-300"><strong>Beyond Black-Box Simulation?</strong> In an independent work, Bellare and O'Neill [[BO12](#page-14-10)] put forth simulation-based definitions for functional encryption with non-black-box simulators. (The definitions we study in this work are "inherently black-box" since the simulator must explicitly provide the adversary with secret keys and ciphertexts.) In addition, they extended the [[BSW11\]](#page-14-2) lower bound for IBE to the setting of efficient, non-black-box simulators, assuming the existence of collision-resistant hash functions. This leaves as an open problem the question of realizing (or ruling out) many-AD-USIM IBE with a non-black-box simulator.</p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1"></td><td class="border border-gray-700 px-3 py-1">Our impossibility result (Theorem 4.2)</td><td class="border border-gray-700 px-3 py-1">Boneh, Sahai and Waters ([BSW11, Theorem 2])</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">adaptive vs. non-adaptive</td><td class="border border-gray-700 px-3 py-1">non-adaptive</td><td class="border border-gray-700 px-3 py-1">adaptive</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">one vs. many messages</td><td class="border border-gray-700 px-3 py-1">one message</td><td class="border border-gray-700 px-3 py-1">many messages</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">one vs. many secret-key queries</td><td class="border border-gray-700 px-3 py-1">many queries</td><td class="border border-gray-700 px-3 py-1">one query</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">class of circuits</td><td class="border border-gray-700 px-3 py-1">weak PRFs</td><td class="border border-gray-700 px-3 py-1">&lt;u&gt;IBE&lt;/u&gt;</td></tr>
      </tbody></table></div>
      <span id="page-6-0"></span>Figure 2: A comparison between the BSW lower bound (see also Section C.2) and ours for functional encryption. The underlines indicates the stronger result. For example, the first row says that our impossibility result rules out even a non-adaptive notion of security and is thus, stronger than the BSW result that rules out an adaptive notion.
      <h3 id="span-id-page-6-1-span-2-functional-encryption" class="text-xl font-semibold mt-8 mb-3"><span id="page-6-1"></span>2 Functional Encryption</h3>
      <p class="text-gray-300">Let  <span class="math">\mathcal&#123;X&#125; = \&#123;\mathcal&#123;X&#125;_&#123;\kappa&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</span>  and  <span class="math">\mathcal&#123;Y&#125; = \&#123;\mathcal&#123;Y&#125;_&#123;\kappa&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</span>  denote ensembles where each  <span class="math">\mathcal&#123;X&#125;_&#123;\kappa&#125;</span>  and  <span class="math">\mathcal&#123;Y&#125;_&#123;\kappa&#125;</span>  is a finite set. Let  <span class="math">\mathcal&#123;C&#125; = \&#123;\mathcal&#123;C&#125;_&#123;\kappa&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</span>  denote an ensemble where each  <span class="math">\mathcal&#123;C&#125;_&#123;\kappa&#125;</span>  is a finite collection of circuits, and each circuit  <span class="math">C \in \mathcal&#123;C&#125;_&#123;\kappa&#125;</span>  takes as input a string  <span class="math">x \in \mathcal&#123;X&#125;_&#123;\kappa&#125;</span>  and outputs  <span class="math">C(x) \in \mathcal&#123;Y&#125;_&#123;\kappa&#125;</span> .</p>
      <p class="text-gray-300">A functional encryption scheme  <span class="math">\mathcal&#123;FE&#125;</span>  for  <span class="math">\mathcal&#123;C&#125;</span>  consists of four algorithms  <span class="math">\mathcal&#123;FE&#125; = (\mathsf&#123;FE.Setup&#125;, \mathsf&#123;FE.Keygen&#125;, \mathsf&#123;FE.Enc&#125;, \mathsf&#123;FE.Dec&#125;)</span>  defined as follows.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>**Setup** FE.Setup( <span class="math">1^&#123;\kappa&#125;</span> ) is a p.p.t. algorithm takes as input the unary representation of the security parameter and outputs the master public and secret keys (MPK, MSK).</li>
        <li>Key Generation FE.Keygen(MSK, C) is a p.p.t. algorithm that takes as input the master secret key MSK and a circuit  <span class="math">C \in \mathcal&#123;C&#125;_&#123;\kappa&#125;</span>  and outputs a corresponding secret key SK<sub>C</sub>.</li>
        <li>Encryption FE.Enc(MPK, x) is a p.p.t. algorithm that takes as input the master public key MPK and an input message  <span class="math">x \in \mathcal&#123;X&#125;_&#123;\kappa&#125;</span>  and outputs a ciphertext CT.</li>
        <li>**Decryption** FE.Dec( <span class="math">SK_C</span> , CT) is a deterministic algorithm that takes as input the secret key  <span class="math">SK_C</span>  and a ciphertext CT and outputs C(x).</li>
      </ul>
      <p class="text-gray-300"><strong>Definition 2.1</strong> (Correctness). A functional encryption scheme  <span class="math">\mathcal&#123;FE&#125;</span>  is correct if for all  <span class="math">C \in \mathcal&#123;C&#125;_&#123;\kappa&#125;</span>  and all  <span class="math">x \in \mathcal&#123;X&#125;_&#123;\kappa&#125;</span> ,</p>
      <div class="math-block">\Pr\left[\begin&#123;array&#125;&#123;c&#125; (\mathsf&#123;MPK&#125;,\mathsf&#123;MSK&#125;) \leftarrow \mathsf&#123;FE&#125;.\mathsf&#123;Setup&#125;(1^\kappa); \\ \mathsf&#123;FE&#125;.\mathsf&#123;Dec&#125;(\mathsf&#123;FE&#125;.\mathsf&#123;Keygen&#125;(\mathsf&#123;MSK&#125;,C),\mathsf&#123;FE&#125;.\mathsf&#123;Enc&#125;(\mathsf&#123;MPK&#125;,x)) \neq C(x) \end&#123;array&#125;\right] = \operatorname&#123;negl&#125;(\kappa)</div>
      <p class="text-gray-300">where the probability is taken over the coins of FE.Setup, FE.Keygen, and FE.Enc.</p>
      <h4 id="2-1-a-simulation-based-definition-of-security" class="text-lg font-semibold mt-6 mb-2">2.1 A Simulation-based Definition of Security</h4>
      <p class="text-gray-300">In this section, we present a simulation-based definition of functional encryption, similar in spirit to the way one defines security for secure computation via the ideal/real paradigm. We define the security game for a single message since our lower bounds apply to this weaker setting. However, this definition can be easily extended to many messages setting (see Appendix B).</p>
      <span id="page-7-0"></span>**Definition 2.2** (1-NA-SIM- and 1-AD-SIM- Security)**.** *Let FE be a functional encryption scheme for a circuit family C. Consider a p.p.t. adversary A* = (*A*1*, A*2) *and a stateful p.p.t. simulator* Sim*.* <sup>7</sup> *Let Ux*(*·*) *denote a universal oracle, such that Ux*(*C*) = *C*(*x*)*. Consider the following two experiments:*
      <p class="text-gray-300">Expreal <em>FE,A</em>(1<em><sup>κ</sup></em> )<strong>:</strong> Expideal <em>FE,</em>Sim(1<em><sup>κ</sup></em> )<strong>:</strong> <em>1:</em> (MPK<em>,</em> MSK) <em>←</em> FE<em>.</em>Setup(1<em><sup>κ</sup></em> ) <em>2:</em> (<em>x, st</em>) <em>←A</em> FE<em>.</em>Keygen(MSK<em>,·</em>) 1 (MPK) <em>3:</em> CT <em>←</em> FE<em>.</em>Enc(MPK<em>, x</em>) <em>4: α ← A O</em>(MSK<em>,·</em>) 2 (MPK<em>,</em> CT<em>, st</em>) <em>5: Output</em> (<em>x, α</em>) <em>1:</em> MPK <em>←</em> Sim(1<em><sup>κ</sup></em> ) <em>2:</em> (<em>x, st</em>) <em>← A</em> Sim(<em>·</em>) 1 (MPK) <em>3:</em> CT <em>←</em> Sim<em>Ux</em>(<em>·</em>) (1<em><sup>κ</sup> ,</em> 1 <em>|x|</em> ) <em>4: α ← A O′</em> (<em>·</em>) 2 (MPK<em>,</em> CT<em>, st</em>) <em>5: Output</em> (<em>x, α</em>)</p>
      <p class="text-gray-300"><em>We distinguish between two cases of the above experiment:</em></p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*1.* The adaptive experiment*, where:*</li>
        <li>*• the oracle O*(MSK*, ·*) = FE*.*Keygen(MSK*, ·*) *and*</li>
        <li>*• the oracle O′* (*·*) *is the simulator, namely* Sim*Ux*(*·*) (*·*)</li>
      </ul>
      <p class="text-gray-300"><em>We call a stateful simulator algorithm</em> Sim admissible <em>if, on each input C,</em> Sim <em>makes just a single query to its oracle Ux</em>(<em>·</em>) <em>on C itself.</em></p>
      <p class="text-gray-300"><em>The functional encryption scheme FE is then said to be</em> simulation-secure for one message against adaptive adversaries (1-AD-SIM-secure, for short) <em>if there is an</em> admissible <em>stateful p.p.t. simulator</em> Sim <em>such that for every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the following two distributions are computationally indistinguishable:</em></p>
      <div class="math-block">\left\&#123;\mathsf&#123;Exp&#125;^&#123;\mathsf&#123;real&#125;&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;(1^\kappa)\right\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125; \overset&#123;c&#125;&#123;\approx&#125; \left\&#123;\mathsf&#123;Exp&#125;^&#123;\mathsf&#123;ideal&#125;&#125;_&#123;\mathcal&#123;FE&#125;,\mathrm&#123;Sim&#125;&#125;(1^\kappa)\right\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</div>
      <p class="text-gray-300"><em>2.</em> The non-adaptive experiment<em>, where the oracles O</em>(MSK<em>, ·</em>) <em>and O′</em> (<em>·</em>) <em>are both the "empty oracles" that return nothing.</em></p>
      <p class="text-gray-300"><em>The functional encryption scheme FE is then said to be</em> simulation-secure for one message against non-adaptive adversaries (1-NA-SIM-secure, for short) <em>if there is an</em> admissible <em>stateful p.p.t. simulator</em> Sim <em>such that for every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the two distributions above are computationally indistinguishable.</em></p>
      <p class="text-gray-300"><strong>Remarks on the Definition.</strong> Our definition is stronger than that in [[BSW11\]](#page-14-2) but weaker than that in [\[GVW12](#page-15-5)]; our lower bound in Section [4](#page-9-0) holds for all three definitions. Amongst the three, the one in [\[GVW12](#page-15-5)] is the only for which we know a composition theorem where security for one message implies security for many messages, in the non-adaptive setting. Note that composition in the non-adaptive setting is the "best" we can hope for; composition in the adaptive setting is essentially impossible by many-AD-SIM lower bound for IBE [[BSW11\]](#page-14-2). In more detail:</p>
      <sup>7</sup>One can replace a stateful simulator can be replaced by a regular (stateless) simulator that outputs a state *st<sup>s</sup>* upon each invocation which is carried over to its next invocation.
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>In [BSW11], the simulator is given oracle access to  <span class="math">A_2</span> , which it can call on any ciphertext. Therefore, it can "rewind" the adversary  <span class="math">A_2</span>  and adaptively reconstruct the view, which is problematic for composition [PRS02, Lin04, BMQU07]. We call this a "rewinding" definition. In our "straight-line" definition, the simulator must commit to a ciphertext once and for all, which makes it stronger.</li>
        <li>Unlike our definition, the [GVW12] definition does not allow the simulator to fake or "program" the setup parameters and the secret keys. The difficulty in proving a composition theorem for our definition lies in that the simulator may use "trapdoor" information from faking the setup parameters and secret keys while simulating the ciphertext.</li>
      </ul>
      <p class="text-gray-300">We note that in the equivalence of NA-IND and NA-SIM under pre-image sampleability in [O'N10, Section 4], the NA-SIM-simulator actually satisfies the stronger definition in [GVW12].</p>
      <p class="text-gray-300">The Indistinguishability-based Definition of Security. We define the non-adaptive NA-IND and the adaptive AD-IND notions of security in Appendix A.</p>
      <h4 id="3-preliminaries" class="text-lg font-semibold mt-6 mb-2">3 Preliminaries</h4>
      <p class="text-gray-300"><strong>Notations.</strong> Let  <span class="math">\mathcal&#123;D&#125;</span>  denote a distribution over some finite set S. Then,  <span class="math">x \leftarrow \mathcal&#123;D&#125;</span>  is used to denote the fact that x is chosen from the distribution  <span class="math">\mathcal&#123;D&#125;</span> . When we say  <span class="math">x \leftarrow S</span> , we simply mean that x is chosen from the uniform distribution over S. Unless explicitly mentioned, all logarithms are to base 2. For  <span class="math">n \in \mathbb&#123;N&#125;</span> , let [n] denote the set of numbers  <span class="math">1, \ldots, n</span> . Let  <span class="math">\kappa</span>  denote the security parameter.</p>
      <p class="text-gray-300"><strong>Definition 3.1</strong> (wPRF). Let wPRF = &#123;wPRF&#125;\_&#123;\kappa&#125;\_&#123;\kappa \in \mathbb&#123;N&#125;&#125; denote a family of efficiently computable functions where wPRF <span class="math">_&#123;\kappa&#125;</span> :  <span class="math">\&#123;0,1\&#125;^&#123;n(\kappa)&#125; \times \&#123;0,1\&#125;^&#123;m(\kappa)&#125; \to \&#123;0,1\&#125;^&#123;k(\kappa)&#125;</span> , the first argument of which is called the seed to the wPRF and the second argument is the input.</p>
      <p class="text-gray-300">For every probabilistic polynomial time oracle distinguisher Dist, consider the following two experiments:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>Real<sub>Dist</sub>(1<sup>\kappa</sup>): Choose  <span class="math">x \stackrel&#123;\</span>&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;^&#123;n(\kappa)&#125;<span class="math">  and run Dist with access to a probabilistic oracle  </span>\mathcal&#123;O&#125;_&#123;real&#125;(x)<span class="math">  which, when invoked, chooses a uniformly random  </span>d \leftarrow \&#123;0,1\&#125;^&#123;m(\kappa)&#125;<span class="math">  and returns the pair  </span>(d, \mathsf&#123;wPRF&#125;_&#123;\kappa&#125;(x,d))$ . This experiment outputs whatever Dist outputs.</li>
        <li>Rand<sub>Dist</sub>(1<sup>\kappa</sup>): Choose a uniformly random function  <span class="math">R: \&#123;0,1\&#125;^&#123;m(\kappa)&#125; \to \&#123;0,1\&#125;^&#123;k(\kappa)&#125;</span>  and run Dist with access to a probabilistic oracle  <span class="math">\mathcal&#123;O&#125;_&#123;rand&#125;(R)</span>  which, when invoked, chooses a uniformly random  <span class="math">d \leftarrow \&#123;0,1\&#125;^&#123;m(\kappa)&#125;</span>  and returns the pair (d,R(d)). This experiment outputs whatever Dist outputs.</li>
      </ul>
      <p class="text-gray-300">We say wPRF is a weak pseudo-random function if for all p.p.t. distinguishers Dist,</p>
      <div class="math-block">\big|\Pr[\mathsf&#123;Real&#125;_&#123;\mathrm&#123;Dist&#125;&#125;(1^\kappa) = 1] - \Pr[\mathsf&#123;Rand&#125;_&#123;\mathrm&#123;Dist&#125;&#125;(1^\kappa) = 1]\big| = \mathrm&#123;negl&#125;(\kappa)</div>
      <p class="text-gray-300">where the probabilities are over the choice of x and R, as well as the coin-tosses of Dist and the oracles  <span class="math">\mathcal&#123;O&#125;_&#123;real&#125;</span>  and  <span class="math">\mathcal&#123;O&#125;_&#123;rand&#125;</span> .</p>
      <p class="text-gray-300">In our impossibility result, we will use a weak pseudo-random function with seed length  <span class="math">n(\kappa) = \kappa</span>  and output length  <span class="math">k(\kappa) = 1</span> .</p>
      <h3 id="span-id-page-9-0-span-4-impossibility-results-for-functional-encryption" class="text-xl font-semibold mt-8 mb-3"><span id="page-9-0"></span>4 Impossibility Results for Functional Encryption</h3>
      <p class="text-gray-300">In this section, we present our main lower bound for 1-NA-SIM-secure functional encryption. We begin with a notion of "incompressible" circuits. Then, we show that (1) weak pseudo-random functions are "incompressible", and (2) 1-NA-SIM-secure functional encryption only exists for "compressible" circuits. Putting the two together yields our lower bound.</p>
      <h3 id="4-1-incompressible-circuits" class="text-xl font-semibold mt-8 mb-3">4.1 Incompressible Circuits</h3>
      <p class="text-gray-300">We first define a family of compressible circuits. Informally, we say that a family of circuits <em>&#123;Gκ&#125;</em> is (<em>ℓ, t</em>)-compressible if for a list of uniformly random circuit descriptions <em>G</em>1<em>, . . . , G<sup>ℓ</sup> ∈ G<sup>κ</sup></em> and a uniformly chosen input <em>x</em>, there is some efficiently computable description of <em>G</em>1(<em>x</em>)<em>, . . . , Gℓ</em>(<em>x</em>) of size <em>t</em>. Note that if there is no efficiency requirement, then any family is (<em>ℓ, |s|</em>)-compressible.</p>
      <span id="page-9-1"></span>**Definition 4.1** (Incompressible Circuits)**.** *Let ℓ* = *ℓ*(*κ*) *and t* = *t*(*κ*) *be functions of the security parameter κ. A family of circuits G* = *&#123;Gκ&#125;κ∈*<sup>N</sup> *is* (*ℓ, t*)-compressible *if there exist a family of (deterministic) compressor circuits &#123;***C***κ&#125;κ∈*<sup>N</sup> *and a family of decompressor circuits &#123;***D***κ&#125;κ∈*<sup>N</sup> *such that:*
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*• (polynomial size) the circuits* **C***<sup>κ</sup> and* **D***<sup>κ</sup> have size* poly(*κ, ℓ*)*.*</li>
        <li>*• (mild compression) for sufficiently large κ,* **C***κ*(*G*1*, . . . , G<sup>ℓ</sup> , y*1*, . . . , yℓ*)  = *t, where y<sup>i</sup>* = *Gi*(*x*)*.*</li>
        <li>*• (correctness) there is a polynomial p* = *p*(*κ*) *such that*</li>
      </ul>
      <div class="math-block">\Pr[x \stackrel&#123;\<span class="math">&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;^&#123;\kappa&#125;, G_1, \dots, G_&#123;\ell&#125; \stackrel&#123;\</span>&#125;&#123;\leftarrow&#125; \mathcal&#123;G&#125;_&#123;\kappa&#125;, y_i = G_i(x) :</div>
      <div class="math-block">\mathbf&#123;D&#125;_&#123;\kappa&#125;(G_1, \dots, G_&#123;\ell&#125;, \mathbf&#123;C&#125;_&#123;\kappa&#125;(G_1, \dots, G_&#123;\ell&#125;, y_1, \dots, y_&#123;\ell&#125;)) = (y_1, \dots, y_&#123;\ell&#125;)] \ge 1/p(\kappa)</div>
      <p class="text-gray-300"><em>where the probability is taken over the choice of x as well as the circuits G</em>1<em>, . . . , G<sup>ℓ</sup> .</em></p>
      <p class="text-gray-300"><em>The family G is</em> (<em>ℓ, t</em>)-incompressible <em>if it is not</em> (<em>ℓ, t</em>)<em>-compressible.</em></p>
      <p class="text-gray-300">We now give examples of (in)compressible circuits. First, consider the notion of preimage samplable family of circuits introduced by O'Neill [[O'N10](#page-15-0)] which requires that given <em>G</em>1(<em>x</em>)<em>, . . . , Gℓ</em>(<em>x</em>), there is a polynomial-time algorithm that returns an arbitrary <em>x ′</em> such that <em>Gi</em>(<em>x ′</em> ) = <em>Gi</em>(<em>x</em>) for all <em>i</em>. In our language, this says that the family <em>G</em> is (<em>ℓ, |x ′ |</em>)-compressible; the compression algorithm simply outputs <em>x ′</em> .</p>
      <p class="text-gray-300">Next, consider an arbitrary public-index circuit family parametrized by predicates <em>P</em> and given by:</p>
      <div class="math-block">G_P(\mathsf&#123;ind&#125;, \mu) = \left\&#123; \begin&#123;array&#125;&#123;ll&#125; (\mathsf&#123;ind&#125;, \mu) & \mathrm&#123;if&#125;\ P(\mathsf&#123;ind&#125;) = 1 \\ (\mathsf&#123;ind&#125;, \bot) & \mathrm&#123;otherwise&#125; \end&#123;array&#125; \right.</div>
      <p class="text-gray-300">It is easy to see that this circuit family is (<em>ℓ, |</em>(ind<em>, µ</em>)<em>|</em>)-compressible. On input</p>
      <div class="math-block">G_&#123;P_1&#125;(\mathsf&#123;ind&#125;,\mu),\ldots,G_&#123;P_\ell&#125;(\mathsf&#123;ind&#125;,\mu)</div>
      <p class="text-gray-300">If <em>Pi</em>(ind) = 1 for some <em>i</em>, then the compression algorithm outputs (ind<em>, µ</em>). If <em>Pi</em>(ind) = 0 for all <em>i</em>, then the algorithm outputs (ind<em>, ⊥</em>).</p>
      <p class="text-gray-300">On the other hand, as we show below (see Lemma [4.1\)](#page-10-0), any family of (weak) pseudorandom functions is incompressible in a strong sense. More precisely, consider a family of circuits  <span class="math">\mathcal&#123;G&#125; = \&#123;G_&#123;d_i&#125;(\cdot) = \mathsf&#123;wPRF&#125;(\cdot, d_i)\&#125;</span>  where  <span class="math">d_i</span>  serves as the input to the pseudo-random function. Informally, the incompressibility is due to the fact that a sequence  <span class="math">(G_&#123;d_1&#125;(x), \ldots, G_&#123;d_\ell&#125;(x)) = (\mathsf&#123;wPRF&#125;(x, d_1), \ldots, \mathsf&#123;wPRF&#125;(x, d_\ell))</span>  is indistinguishable from a sequence of uniformly random bits, which are clearly incompressible.</p>
      <span id="page-10-0"></span>**Lemma 4.1** (weak PRFs are  $(\ell, \ell - \kappa)$ -incompressible). Let wPRF = &#123;wPRF $_&#123;\kappa&#125;$  :  $\&#123;0,1\&#125;^&#123;\kappa&#125; \times \&#123;0,1\&#125;^&#123;m(\kappa)&#125; \to \&#123;0,1\&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;$  be a family of weak pseudo-random functions, where  $m(\kappa) = \omega(\log \kappa)$ . Define  $G_d(x) = \text&#123;wPRF&#125;(x,d)$ . Consider a family  $\mathcal&#123;G&#125; = \&#123;\mathcal&#123;G&#125;_&#123;\kappa&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;$  defined as
      <div class="math-block">\mathcal&#123;G&#125;_&#123;\kappa&#125; = \left\&#123; G_d(\cdot) : |d| = m(\kappa) \right\&#125;</div>
      <p class="text-gray-300">Then,  <span class="math">\mathcal&#123;G&#125;</span>  is  <span class="math">(\ell, \ell - \kappa)</span> -incompressible.</p>
      <p class="text-gray-300"><em>Proof.</em> Assume, for the sake of contradiction, that  <span class="math">\mathcal&#123;G&#125;</span>  is  <span class="math">(\ell, \ell - \kappa)</span> -compressible. Namely, there are families of compressor and decompressor circuits  <span class="math">(\mathbf&#123;C&#125;, \mathbf&#123;D&#125;)</span>  that satisfy Definition 4.1. We show how to construct a distinguisher  <span class="math">\mathrm&#123;Dist&#125;^&#123;\mathcal&#123;O&#125;&#125;</span>  that distinguishes between the case where  <span class="math">\mathcal&#123;O&#125; = \mathsf&#123;wPRF&#125;(x, \cdot)</span>  is a pseudo-random oracle that outputs pairs  <span class="math">(d_i, y_i = \mathsf&#123;wPRF&#125;_&#123;\kappa&#125;(x, d_i))</span>  where  <span class="math">d_i</span>  are uniformly random, and the case where  <span class="math">\mathcal&#123;O&#125;</span>  outputs strings  <span class="math">(d_i, y_i = R(d_i))</span>  where  <span class="math">d_i</span>  and R are uniformly random strings and function, respectively. Dist  <span class="math">\mathcal&#123;O&#125;</span>  proceeds as follows.</p>
      <p class="text-gray-300">• Choose a sufficiently large  <span class="math">\kappa</span>  such that</p>
      <div class="math-block">|\mathbf&#123;C&#125;_&#123;\kappa&#125;(G_1,\ldots,G_&#123;\ell&#125;,y_1,\ldots,y_&#123;\ell&#125;)| = \ell - \kappa</div>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>Query the oracle  <span class="math">\mathcal&#123;O&#125;</span>  to obtain pairs of strings of the form  <span class="math">(d_i \stackrel&#123;\</span>&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;^&#123;m(\kappa)&#125;, y_i)<span class="math"> . Define the circuit  </span>G_&#123;d_i&#125;(\cdot) := \mathsf&#123;wPRF&#125;(\cdot, d_i)$ .</li>
        <li>Run the compressor  <span class="math">\mathbf&#123;C&#125;_&#123;\kappa&#125;</span>  to get a string</li>
      </ul>
      <div class="math-block">\gamma \leftarrow \mathbf&#123;C&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;, \dots, G_&#123;d_\ell&#125;, y_1, \dots, y_\ell)</div>
      <p class="text-gray-300">• Outputs 1 if and only if</p>
      <div class="math-block">\mathbf&#123;D&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;,\ldots,G_&#123;d_&#123;\ell&#125;&#125;,\gamma)=(y_1,\ldots,y_&#123;\ell&#125;)</div>
      <p class="text-gray-300">We now show that the distinguisher succeeds with non-negligible advantage  <span class="math">1/p(\kappa) - 2^&#123;-\kappa&#125;</span>  in breaking the weak pseudo-random function family wPRF.</p>
      <p class="text-gray-300">If  <span class="math">\mathcal&#123;O&#125;</span>  is the pseudo-random oracle, then the samples  <span class="math">\mathrm&#123;Dist&#125;^&#123;\mathcal&#123;O&#125;&#125;</span>  gets are of the form  <span class="math">(d_i, y_i \leftarrow \mathsf&#123;wPRF&#125;(x, d_i))</span> . Hence, by correctness of  <span class="math">\mathbf&#123;C&#125;</span>  and  <span class="math">\mathbf&#123;D&#125;</span> ,</p>
      <div class="math-block">\mathbf&#123;D&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;,\ldots,G_&#123;d_&#123;\ell&#125;&#125;,\mathbf&#123;C&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;,\ldots,G_&#123;d_&#123;\ell&#125;&#125;,y_1,\ldots,y_&#123;\ell&#125;))=(y_1,\ldots,y_&#123;\ell&#125;)</div>
      <p class="text-gray-300">with probability at least  <span class="math">1/p(\kappa)</span> . Thus, the distinguisher in this case outputs 1 with probability at least  <span class="math">1/p(\kappa)</span>  as well.</p>
      <p class="text-gray-300">On the other hand, if  <span class="math">\mathcal&#123;O&#125;</span>  outputs pairs of strings of the form  <span class="math">(d_i, y_i \leftarrow R(d_i))</span>  for a randomly chosen function mapping R, we now show that the distinguisher above outputs 1 with probability at most  <span class="math">2^&#123;-\kappa&#125;</span> . In the analysis below, we assume that  <span class="math">d_1, \ldots, d_\ell</span>  are distinct, for which we need to pay a price of an additive  <span class="math">\ell^2 \cdot 2^&#123;-m(\kappa)&#125; = \text&#123;negl&#125;(\kappa)</span>  term in the distinguishing error.</p>
      <p class="text-gray-300">Pr[Dist<sup>O</sup> outputs 1]</p>
      <div class="math-block">\leq \Pr_&#123;\substack&#123;d_1, \dots, d_\ell \overset&#123;\<span class="math">&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;^&#123;m(\kappa)&#125; \\ y_1, \dots, y_\ell \overset&#123;\</span>&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;&#125;&#125; \left[ \exists \gamma : |\gamma| = \ell - \kappa \text&#123; and &#125; \mathbf&#123;D&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;, \dots, G_&#123;d_\ell&#125;, \gamma) = (y_1, \dots, y_\ell) \right]</div>
      <div class="math-block">\leq \sum_&#123;\substack&#123;\gamma \in \&#123;0,1\&#125;^&#123;\ell-\kappa&#125; \\ y_1, \dots, y_\ell \overset&#123;\<span class="math">&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;&#125;&#125; \Pr_&#123;\substack&#123;\&#123;0,1\&#125;^&#123;m(\kappa)&#125; \\ y_1, \dots, y_\ell \overset&#123;\</span>&#125;&#123;\leftarrow&#125; \&#123;0,1\&#125;&#125;&#125; \left[ \mathbf&#123;D&#125;_&#123;\kappa&#125;(G_&#123;d_1&#125;, \dots, G_&#123;d_\ell&#125;, \gamma) = (y_1, \dots, y_\ell) \right] \text&#123; (via a union bound)&#125;</div>
      <div class="math-block">= \sum_&#123;\substack&#123;\gamma \in \&#123;0,1\&#125;^&#123;\ell-\kappa&#125; \\ \gamma \in \&#123;0,1\&#125;^&#123;\ell-\kappa&#125;&#125;&#125; 2^&#123;-\ell&#125; \text&#123; (since &#125; y_1, \dots, y_\ell \text&#123; are random and independent of &#125; d_1, \dots, d_\ell, \gamma)</div>
      <div class="math-block">\leq 2^&#123;\ell-\kappa&#125; \cdot 2^&#123;-\ell&#125; = 2^&#123;-\kappa&#125;</div>
      <p class="text-gray-300">This yields the required contradiction to the security of wPRF.</p>
      <h4 id="4-2-the-impossibility-result" class="text-lg font-semibold mt-6 mb-2">4.2 The Impossibility Result</h4>
      <p class="text-gray-300">We are now ready to state and prove our main theorem.</p>
      <span id="page-11-0"></span>**Theorem 4.2.** *There exists a family of circuits G for which there are no* 1*-*NA*-*SIM*-secure functional encryption schemes.*
      <p class="text-gray-300"><em>Proof.</em> We consider two cases.</p>
      <p class="text-gray-300"><strong>Case 1</strong>: Assume there exists a circuit family of weak pseudo-random functions</p>
      <div class="math-block">\mathsf&#123;wPRF&#125; = \&#123;\mathsf&#123;wPRF&#125;_\kappa : \&#123;0,1\&#125;^\kappa \times \&#123;0,1\&#125;^&#123;m(\kappa)&#125; \to \&#123;0,1\&#125;\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</div>
      <p class="text-gray-300">where <em>m</em>(<em>κ</em>) = <em>ω</em>(log <em>κ</em>). Let <em>Gd</em>(<em>x</em>) = wPRF(<em>x, d</em>) and consider a family <em>G</em> = <em>&#123;Gκ&#125;κ∈</em><sup>N</sup> defined as</p>
      <div class="math-block">\mathcal&#123;G&#125;_&#123;\kappa&#125; = \left\&#123; G_d(\cdot) : |d| = m(\kappa) \right\&#125;</div>
      <p class="text-gray-300">Assume, for the sake of contradiction, there exist a 1-NA-SIM-secure function encryption scheme <em>FE</em> for <em>G</em>, and let <em>|</em>CT<em>|</em> denote the length of a ciphertext in the scheme. Let <em>ℓ</em> = <em>ℓ</em>(<em>κ</em>) = <em>|</em>CT<em>|</em> + <em>κ</em>.</p>
      <p class="text-gray-300">From Lemma [4.1](#page-10-0), we know that <em>G</em> is (<em>|</em>CT + <em>κ, |</em>CT<em>|</em>)-incompressible. However, Lemma [4.3](#page-11-1) below tells us that since there is a 1-NA-SIM secure scheme for <em>G</em>, the family <em>G</em> is (<em>|</em>CT<em>|</em> + <em>κ, |</em>CT<em>|</em>) compressible. This gives us the desired contradiction, and therefore, there cannot exist a 1-NA-SIMsecure functional encryption scheme for <em>G</em>.</p>
      <p class="text-gray-300"><strong>Case 2</strong>: Assume there does not exist a family of weak pseudo-random functions. Also, for the sake of contradiction, assume there exists a 1-NA-SIM-secure function encryption scheme for all families of circuits <em>G</em>.</p>
      <p class="text-gray-300">In particular, this means that there is a functional encryption scheme for the empty circuit family (namely, a family <em>G</em> that does not contain any circuits at all). A 1-NA-SIM-secure scheme <em>FE</em> for <em>G</em> is also a secure public-key encryption scheme. Since public-key encryption implies one-way functions, which in turn imply pseudo-random functions [[GGM86](#page-15-13), [HILL99](#page-15-14)], we obtain the desired contradiction.</p>
      <span id="page-11-1"></span>**Lemma 4.3** (1-NA-SIM *⇒* (*ℓ, |*CT*|*)-compressibility)**.** *Let G* = *&#123;Gκ&#125;κ∈*<sup>N</sup> *be a family of circuits. Suppose there exists a* 1*-*NA*-*SIM*-secure functional encryption scheme for the G. Then, the family G is* (*ℓ, |*CT*|*)*-compressible for any polynomially bounded ℓ* = *ℓ*(*κ*)*, where |*CT*| denotes size of the encryption of input x.*
      <p class="text-gray-300">Informally, the compression algorithm works as follows: on input <em>G</em>1<em>, . . . , G<sup>ℓ</sup></em> and <em>G</em>1(<em>x</em>)<em>, . . . , Gℓ</em>(<em>x</em>), the output is the simulated ciphertext corresponding to an encryption of <em>x</em>. The decompression algorithm then evaluates the decryption algorithm, which is guaranteed to produce <em>G</em>1(<em>x</em>)<em>, . . . , Gℓ</em>(<em>x</em>).</p>
      <p class="text-gray-300"><em>Proof.</em> Let (FE<em>.</em>Setup<em>,</em> FE<em>.</em>Keygen<em>,</em> FE<em>.</em>Enc<em>,</em> FE<em>.</em>Dec) denote the encryption scheme for the family <em>G</em>. Consider the adversary <em>A</em> = (<em>A</em>1<em>, A</em>2) in the 1-NA-SIM security experiment that acts as follows:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*• A*<sup>1</sup> chooses *G*1*, . . . , G<sup>ℓ</sup>* \<span class="math">*← G* independently at random and requests for the corresponding secret keys SK1*, . . . ,* SK*&lt;sup&gt;ℓ&lt;/sup&gt;* . In addition, it chooses *x* \</span>*← &#123;*0*,* 1*&#125; <sup>m</sup>*(*κ*) and outputs *x* as the challenge message, and (*G*1*, . . . , G<sup>ℓ</sup> ,* SK1*, . . . ,* SK*ℓ*) as the state.</li>
        <li>*• A*<sup>2</sup> outputs *α* composed of the challenge ciphertext and the state (*G*1*, . . . , G<sup>ℓ</sup> ,* SK1*, . . . ,* SK*ℓ*).</li>
      </ul>
      <p class="text-gray-300">Let Sim denote the (admissible) stateful p.p.t. simulator guaranteed by 1-NA-SIM security. We show how to use the simulator to construct a family of (deterministic) compressor and decompressor circuits <strong>C</strong><em><sup>ρ</sup></em> and <strong>D</strong><em>ρ</em>, indexed by a random string <em>ρ</em> corresponding to the random tape for the simulator:</p>
      <p class="text-gray-300"><em>•</em> The compressor <strong>C</strong><em>ρ</em>, on input <em>G</em>1<em>, . . . , G<sup>ℓ</sup></em> and <em>y</em>1<em>, . . . , y<sup>ℓ</sup></em> works as follows: first, compute MPK <em>←</em> Sim(1<em><sup>κ</sup></em> ; <em>ρ</em>) and secret keys <em>&#123;</em>SK<em><sup>i</sup></em> : SK<em><sup>i</sup> ←</em> Sim(<em>G<sup>i</sup></em> ; <em>ρ</em>)<em>&#125;i∈</em>[<em>ℓ</em>] . Then compute and output CT as the compressed string, where queries <em>Gi</em>(<em>x</em>) are answered with <em>y<sup>i</sup></em> :</p>
      <div class="math-block">\mathsf&#123;CT&#125; \leftarrow \mathsf&#123;Sim&#125;^&#123;U_x(\cdot)&#125;(1^&#123;|m(\kappa)|&#125;)</div>
      <p class="text-gray-300"><em>•</em> The decompressor <strong>D</strong><em>ρ</em>, on input <em>G</em>1<em>, . . . , G<sup>ℓ</sup></em> and CT first reconstructs the master public key MPK <em>←</em> Sim(1<em><sup>κ</sup></em> ; <em>ρ</em>) and the set of secret keys:</p>
      <div class="math-block">\&#123;\mathsf&#123;SK&#125;_i : \mathsf&#123;SK&#125;_i \leftarrow \mathrm&#123;Sim&#125;(G_i; \ \rho)\&#125;_&#123;i \in [\ell]&#125;</div>
      <p class="text-gray-300">Note that <strong>D</strong><em><sup>ρ</sup></em> has the same randomness <em>ρ</em> hard-wired, and so the secret keys SK<em><sup>i</sup></em> are exactly the same as those used by <strong>C</strong><em>ρ</em>. Finally, it computes and outputs:</p>
      <div class="math-block">\left\&#123;y_i \leftarrow \mathsf&#123;FE.Dec&#125;(\mathsf&#123;SK&#125;_i, \mathsf&#123;CT&#125;)\right\&#125;_&#123;i \in [\ell]&#125;</div>
      <p class="text-gray-300">Formally, we output (<strong>C</strong><em>ρ,</em> <strong>D</strong><em>ρ</em>) for a random <em>ρ</em>, which is a pair of polynomial-size circuits. Clearly, we achieve (<em>ℓ, |</em>CT<em>|</em>)-compressibility, since the size of CT is determined by the functional encryption scheme and independent of <em>ℓ</em>. To establish correctness, it suffices to show that:</p>
      <div class="math-block">\Pr_&#123;\rho, x, G_1, \dots, G_&#123;\ell&#125;&#125; [\mathbf&#123;D&#125;_&#123;\rho&#125;(G_1, \dots, G_&#123;\ell&#125;, \mathbf&#123;C&#125;_&#123;\rho&#125;(G_1, \dots, G_&#123;\ell&#125;, G_1(x), \dots, G_&#123;\ell&#125;(x))) = (G_1(x), \dots, G_&#123;\ell&#125;(x))] \ge 1 - \operatorname&#123;negl&#125;(\kappa)</div>
      <p class="text-gray-300">Here, we will rely on the correctness of the functional encryption scheme as well as 1-NA-SIMsecurity. First, consider the distinguisher Dist that given the output (<em>x,</em> CT<em>, G</em>1<em>, . . . , G<sup>ℓ</sup> ,</em> SK1<em>, . . . ,</em> SK<em>ℓ</em>) of the adversary <em>A</em><sup>2</sup> proceeds as follows:</p>
      <p class="text-gray-300">Output 1 iff for all</p>
      <div class="math-block">i \in [\ell]</div>
      <p class="text-gray-300">, FE.Dec( <span class="math">SK_i</span> ,  <span class="math">CT</span> ) =  <span class="math">G_i(x)</span> .</p>
      <p class="text-gray-300">Observe that by correctness of the encryption scheme, Dist outputs 1 with probability 1 <em>−</em> negl(<em>κ</em>) given the output of the adversary <em>A</em><sup>2</sup> in the 1-NA-SIM experiment. Therefore, by 1-NA-SIM-security, Dist also outputs 1 with probability 1 <em>−</em> negl(<em>κ</em>) given the output of the (admissible) simulator, where the randomness is taken over the coin tosses <em>ρ</em> of the simulator, along with the random choices of <em>x, G</em>1<em>, . . . , G<sup>ℓ</sup></em> .</p>
      <p class="text-gray-300">This shows that the pair of circuits (<strong>C</strong><em>ρ,</em> <strong>D</strong><em>ρ</em>) for a uniformly random <em>ρ</em> is a correct compressordecompressor pair, establishing the lemma.</p>
      <p class="text-gray-300">We point out here that our lower bound extends to the setting where the simulator is not required to be admissible, by using a family of (standard) pseudo-random functions.</p>
      <p class="text-gray-300">Finally, the argument here generalizes to showing that functional encryption secure against an a-priori bounded number <em>q</em> = <em>q</em>(<em>κ</em>) of collusions is impossible if one insists on small ciphertexts (namely, ciphertexts with much fewer than <em>q</em> bits). This matches the recent result of [[GVW12\]](#page-15-5) who construct such functional encryption schemes with ciphertexts of size polynomial in <em>q</em>.</p>
      <p class="text-gray-300"><strong>Corollary 4.4.</strong> <em>There exists a family of circuits G such that for every q</em> = <em>q</em>(<em>κ</em>)<em>, there are no q-collusion resistant 1-</em>NA<em>-</em>SIM<em>-secure functional encryption schemes. with ciphertexts of size o</em>(<em>q</em>)<em>.</em></p>
      <h4 id="4-3-extensions-impossibility-of-weaker-simulation-based-definitions" class="text-lg font-semibold mt-6 mb-2">4.3 Extensions: Impossibility of Weaker Simulation-based Definitions</h4>
      <p class="text-gray-300">The idea behind our impossibility result is robust enough to apply to various relaxations of the simulation-based security definition. In this section, we describe a number of such extensions of our result.</p>
      <p class="text-gray-300"><strong>Impossibility for the selective and random-input definitions.</strong> In the selective model, the adversary is required to commit to the secret key queries <em>G</em>1<em>, . . . , G<sup>q</sup></em> as well as the challenge input <em>x</em> before the setup phase. In particular, this means that the adversary will not be able to pick up the circuits or the challenge input depending on the system parameters. Variants of the selective security model are frequently considered in the literature as a relaxations of regular security notions (see, e.g., [[BB11,](#page-14-12) [GPSW06](#page-15-1), [AFV11\]](#page-14-5)). Another relaxation one can consider is one where the adversary is not allowed to choose the circuits or the challenge, but instead, they are chosen uniformly at random.</p>
      <p class="text-gray-300">Our lower bound easily extends to these weaker notions, simply because the adversary we consider in the proof of Lemma [4.3](#page-11-1) chooses the circuits and the challenge uniformly at random, and independent of the system parameters.</p>
      <p class="text-gray-300"><strong>Impossibility for the non-adaptive BSW Definition (the "Rewinding Definition").</strong> The main difference between the definition proposed by [[BSW11\]](#page-14-2) and our definition in Section [2](#page-6-1) is that whereas our definition restricts the simulator to be "straight-line", the BSW definition allows the simulator to "rewind" the adversary and interact with it in order to generate the view. For more details, we direct the reader to the discussion after Definition [2.2.](#page-7-0)</p>
      <p class="text-gray-300">The proof of Lemma [4.3](#page-11-1) transparently extends to the BSW definition. The adversary <em>A</em> is the same as in the proof. The compressor <strong>C</strong> runs the simulator, executing the code of the designated adversary <em>A</em> to compute the response whenever the simulator queries ("rewinds") <em>A</em>. Also, since the simulator is admissible, the queries it makes are exactly the ones that the compressor knows the answer to. As before, we can make the impossibility result work for even non-admissible simulators by appealing to regular (rather than weak) PRFs.</p>
      <p class="text-gray-300"><strong>Impossibility for Secret-key Functional Encryption.</strong> In the setting of secret-key functional encryption (first considered by Shi, Shen and Waters [[SSW09](#page-16-8)] in its predicate encryption variant), the encryption algorithm relies on the master secret key to produce the ciphertext for an input <em>x</em>.</p>
      <p class="text-gray-300">All our impossibility results carry over to the setting of secret key functional encryption since in the proof of Lemma [4.3](#page-11-1), neither the compressor nor the decompressor needs to run the encryption algorithm and generate ciphertexts.</p>
      <h4 id="acknowledgments" class="text-lg font-semibold mt-6 mb-2">Acknowledgments</h4>
      <p class="text-gray-300">We thank Shafi Goldwasser, Yael Kalai, Raluca Ada Popa and Charles Rackoff for a number of insightful conversations that helped improve the presentation of the impossibility result. We would also like to thank Adam O'Neill and Amit Sahai for helpful pointers and discussions.</p>
      <h3 id="references" class="text-xl font-semibold mt-8 mb-3">References</h3>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li><span id="page-14-4"></span>[ABV+12] Shweta Agrawal, Xavier Boyen, Vinod Vaikuntanathan, Panagiotis Voulgaris, and Hoeteck Wee. Functional encryption for threshold functions (or fuzzy IBE) from lattices. In *PKC*, 2012.</li>
        <li><span id="page-14-5"></span>[AFV11] Shweta Agrawal, David Mandell Freeman, and Vinod Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In *Asiacrypt*, 2011.</li>
        <li><span id="page-14-12"></span>[BB11] Dan Boneh and Xavier Boyen. Efficient selective identity-based encryption without random oracles. *J. Cryptology*, 24(4):659–693, 2011.</li>
        <li><span id="page-14-0"></span>[BF01] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. In *CRYPTO*, pages 213–229, 2001.</li>
        <li><span id="page-14-7"></span>[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In *Proceedings of the twentieth annual ACM symposium on Theory of computing*, STOC '88, pages 1–10, New York, NY, USA, 1988. ACM.</li>
        <li><span id="page-14-11"></span>[BMQU07] Michael Backes, J¨orn M¨uler-Quade, and Dominique Unruh. On the necessity of rewinding in secure multiparty computation. In *Proceedings of the 4th conference on Theory of cryptography*, TCC'07, pages 157–173, Berlin, Heidelberg, 2007. Springer-Verlag.</li>
        <li><span id="page-14-8"></span>[BMR90] Donald Beaver, Silvio Micali, and Phillip Rogaway. The round complexity of secure protocols (extended abstract). In *STOC*, pages 503–513, 1990.</li>
        <li><span id="page-14-10"></span>[BO12] Mihir Bellare and Adam O'Neill. Semantically-secure functional encryption: Possibility results, impossibility results and the quest for a general definition. Cryptology ePrint Archive, Report 2012/515, 2012.</li>
        <li><span id="page-14-9"></span>[BS05] Boaz Barak and Amit Sahai. How to play almost any mental game over the net concurrent composition via super-polynomial simulation. In *FOCS*, pages 543–552, 2005.</li>
        <li><span id="page-14-2"></span>[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In *TCC*, pages 253–273, 2011.</li>
        <li><span id="page-14-3"></span>[BW06] Xavier Boyen and Brent Waters. Anonymous hierarchical identity-based encryption (without random oracles). In *CRYPTO*, pages 290–307, 2006.</li>
        <li><span id="page-14-6"></span>[CHK03] Ran Canetti, Shai Halevi, and Jonathan Katz. A forward-secure public-key encryption scheme. In *EUROCRYPT*, pages 255–271, 2003.</li>
        <li><span id="page-14-1"></span>[Coc01] Clifford Cocks. An identity based encryption scheme based on quadratic residues. In *IMA Int. Conf.*, pages 360–363, 2001.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li><span id="page-15-6"></span>[DKXY02] Yevgeniy Dodis, Jonathan Katz, Shouhuai Xu, and Moti Yung. Key-insulated public key cryptosystems. In *In EUROCRYPT*, pages 65–82. Springer-Verlag, 2002.</li>
        <li><span id="page-15-9"></span>[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In *STOC*, pages 416–426, 1990.</li>
        <li><span id="page-15-13"></span>[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. *J. ACM*, 33(4):792–807, 1986.</li>
        <li><span id="page-15-4"></span>[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In *FOCS*, pages 553–562, 2005.</li>
        <li><span id="page-15-7"></span>[GLW12] Shafi Goldwasser, Allison B. Lewko, and David A. Wilson. Bounded-collusion IBE from key homomorphism. In *TCC*, pages 564–581, 2012.</li>
        <li><span id="page-15-1"></span>[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In *ACM Conference on Computer and Communications Security*, pages 89–98, 2006.</li>
        <li><span id="page-15-5"></span>[GVW12] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Functional encryption with bounded collusions from multiparty computation. In *CRYPTO*, 2012. To appear.</li>
        <li><span id="page-15-14"></span>[HILL99] Johan H˚astad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. *SIAM J. Comput.*, 28(4):1364– 1396, 1999.</li>
        <li><span id="page-15-3"></span>[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In *EUROCRYPT*, pages 146– 162, 2008.</li>
        <li><span id="page-15-12"></span>[Lin04] Yehuda Lindell. Lower bounds and impossibility results for concurrent self composition. *the Journal of Cryptology*, 2004.</li>
        <li><span id="page-15-2"></span>[LOS+10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In *EUROCRYPT*, pages 62–91, 2010.</li>
        <li><span id="page-15-10"></span>[MPR06] Silvio Micali, Rafael Pass, and Alon Rosen. Input-indistinguishable computation. In *FOCS*, pages 367–378, 2006.</li>
        <li><span id="page-15-15"></span>[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In *CRYPTO*, pages 111–126, 2002.</li>
        <li><span id="page-15-0"></span>[O'N10] Adam O'Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. &lt;http://eprint.iacr.org/&gt;.</li>
        <li><span id="page-15-8"></span>[Pas03] Rafael Pass. Simulation in quasi-polynomial time and its application to protocol composition. In *EUROCRYPT*, pages 160–176, 2003.</li>
        <li><span id="page-15-11"></span>[PRS02] Manoj Prabhakaran, Alon Rosen, and Amit Sahai. Concurrent zero knowledge with logarithmic round-complexity. In *In 43rd FOCS*, pages 366–375, 2002.</li>
      </ul>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li><span id="page-16-3"></span>[PRV12] Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, *TCC*, volume 7194 of *Lecture Notes in Computer Science*, pages 422– 439. Springer, 2012.</li>
        <li><span id="page-16-6"></span>[PS04] Manoj Prabhakaran and Amit Sahai. New notions of security: achieving universal composability without trusted setup. In *STOC*, pages 242–251, 2004.</li>
        <li><span id="page-16-2"></span>[Sha84] Adi Shamir. Identity-based cryptosystems and signature schemes. In *CRYPTO*, pages 47–53, 1984.</li>
        <li><span id="page-16-4"></span>[SS10] Amit Sahai and Hakan Seyalioglu. Worry-free encryption: functional encryption with public keys. In *ACM Conference on Computer and Communications Security*, pages 463–472, 2010.</li>
        <li><span id="page-16-8"></span>[SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In *TCC*, pages 457–473, 2009.</li>
        <li><span id="page-16-0"></span>[SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In *EUROCRYPT*, pages 457–473, 2005.</li>
        <li><span id="page-16-1"></span>[SW08] Amit Sahai and Brent Waters. Slides on functional encryption. Power Point Presentation, 2008. http://www.cs.utexas.edu/~ bwaters/presentations/ files/functional.ppt, 2008.</li>
        <li><span id="page-16-5"></span>[Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In *FOCS*, pages 162–167, 1986.</li>
      </ul>
      <p class="text-gray-300"><strong>Definition A.1</strong> (NA-IND- and AD-IND-Security)<strong>.</strong> <em>Let FE be a functional encryption scheme for a family of circuits C. For every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, consider the following two experiments:</em></p>
      <div class="overflow-x-auto my-4"><table class="text-sm text-gray-300 border-collapse w-full"><tbody>
        <tr><td class="border border-gray-700 px-3 py-1">Exp(0)</td><td class="border border-gray-700 px-3 py-1">Exp(1)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">FE,A(1κ</td><td class="border border-gray-700 px-3 py-1">FE,A(1κ</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">):</td><td class="border border-gray-700 px-3 py-1">):</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">FE.Setup(1κ</td><td class="border border-gray-700 px-3 py-1">FE.Setup(1κ</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">1: (MPK,</td><td class="border border-gray-700 px-3 py-1">1: (MPK,</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">MSK)</td><td class="border border-gray-700 px-3 py-1">MSK)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">)</td><td class="border border-gray-700 px-3 py-1">)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">←</td><td class="border border-gray-700 px-3 py-1">←</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">FE.Keygen(MSK,·)</td><td class="border border-gray-700 px-3 py-1">FE.Keygen(MSK,·)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">2: (x0, x1, st)</td><td class="border border-gray-700 px-3 py-1">2: (x0, x1, st)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">A</td><td class="border border-gray-700 px-3 py-1">A</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">(MPK)</td><td class="border border-gray-700 px-3 py-1">(MPK)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">←</td><td class="border border-gray-700 px-3 py-1">←</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">1</td><td class="border border-gray-700 px-3 py-1">1</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">3: CT</td><td class="border border-gray-700 px-3 py-1">3: CT</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">FE.Enc(MPK, x0)</td><td class="border border-gray-700 px-3 py-1">FE.Enc(MPK, x1)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">←</td><td class="border border-gray-700 px-3 py-1">←</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">O(MSK,·)</td><td class="border border-gray-700 px-3 py-1">O(MSK,·)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">4: b</td><td class="border border-gray-700 px-3 py-1">4: b</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">A</td><td class="border border-gray-700 px-3 py-1">A</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">(MPK,</td><td class="border border-gray-700 px-3 py-1">(MPK,</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">CT, st)</td><td class="border border-gray-700 px-3 py-1">CT, st)</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">←</td><td class="border border-gray-700 px-3 py-1">←</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">2</td><td class="border border-gray-700 px-3 py-1">2</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">5: Output</td><td class="border border-gray-700 px-3 py-1">5: Output</td></tr>
        <tr><td class="border border-gray-700 px-3 py-1">b</td><td class="border border-gray-700 px-3 py-1">b</td></tr>
      </tbody></table></div>
      <p class="text-gray-300">Define an <em>admissible adversary A</em> = (<em>A</em>1<em>, A</em>2) as one such that for each oracle query <em>C</em> of <em>A</em>, <em>C</em>(<em>x</em>0) = <em>C</em>(<em>x</em>1). <em>We distinguish between two cases of the above experiment:</em></p>
      <p class="text-gray-300"><em>1.</em> The adaptive experiment<em>, where the oracle O</em>(MSK<em>, ·</em>) = FE<em>.</em>Keygen(MSK<em>, ·</em>)<em>: the functional encryption scheme FE is said to be</em> indistinguishable-secure for one message against adaptive adversaries (1-AD-IND-secure, for short) if for every polynomial function  <span class="math">\ell = \ell(\kappa)</span>  and every admissible p.p.t. admissible adversary  <span class="math">A = (A_1, A_2)</span> , the advantage of A defined as below is negligible in the security parameter  <span class="math">\kappa</span> :</p>
      <div class="math-block">\mathsf&#123;Adv&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;(\kappa) := \big|\Pr[\mathsf&#123;Exp&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;^&#123;(0)&#125;(1^\kappa) = 1] - \Pr[\mathsf&#123;Exp&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;^&#123;(1)&#125;(1^\kappa) = 1]\big|</div>
      <p class="text-gray-300">where the probability is over the random coins of the algorithms of the scheme  <span class="math">\mathcal&#123;FE&#125;</span>  and that of A.</p>
      <p class="text-gray-300">2. The non-adaptive experiment, where the oracle  <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;MSK&#125;,\cdot)</span>  is the "empty oracle" that returns nothing: the functional encryption scheme  <span class="math">\mathcal&#123;FE&#125;</span>  is said to be indistinguishable-secure for one message against non-adaptive adversaries (1-NA-IND-secure, for short) if for every admissible p.p.t. adversary  <span class="math">A = (A_1, A_2)</span> , the advantage of A defined as above is negligible in the security parameter  <span class="math">\kappa</span> .</p>
      <p class="text-gray-300">We do not distinguish between one and many message security since this definition composes [GVW12].</p>
      <h3 id="span-id-page-17-0-span-b-many-message-simulation-based-definition-of-security" class="text-xl font-semibold mt-8 mb-3"><span id="page-17-0"></span>B Many-Message Simulation-based Definition of Security</h3>
      <p class="text-gray-300"><strong>Definition B.1</strong> (many-NA-SIM- and many-AD-SIM- Security). Let  <span class="math">\mathcal&#123;FE&#125;</span>  be a functional encryption scheme for a family of circuit  <span class="math">\mathcal&#123;C&#125;</span> . Let  <span class="math">U_x(\cdot)</span>  denote the universal oracle that on input C returns  <span class="math">U_x(C) = C(x)</span> . Consider a p.p.t. adversary  <span class="math">A = (A_1, A_2)</span>  and a stateful p.p.t. simulator Sim. Consider the following two experiments:</p>
      <p class="text-gray-300">``` \underline&#123;\operatorname&#123;Exp&#125;^&#123;\operatorname&#123;real&#125;&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;(1^&#123;\kappa&#125;)&#125; : \underline&#123;\operatorname&#123;Exp&#125;^&#123;\operatorname&#123;ideal&#125;&#125;_&#123;\mathcal&#123;FE&#125;,\operatorname&#123;Sim&#125;&#125;(1^&#123;\kappa&#125;)&#125; : \\ 1: (\operatorname&#123;MPK&#125;, \operatorname&#123;MSK&#125;) \leftarrow \operatorname&#123;FE.Setup&#125;(1^&#123;\kappa&#125;) \\ 2: (\&#123;x_i\&#125;_&#123;i \in [\ell]&#125;, st) \leftarrow A_1^&#123;\operatorname&#123;FE.Keygen&#125;(\operatorname&#123;MSK&#125;, \cdot)&#125;(\operatorname&#123;MPK&#125;) \\ 3: \operatorname&#123;CT&#125;_i \leftarrow \operatorname&#123;FE.Enc&#125;(\operatorname&#123;MPK&#125;, x_i) \ \ for \ \ all \ \ i \in [\ell] \\ 4: \ \alpha \leftarrow A_2^&#123;\mathcal&#123;O&#125;(\operatorname&#123;MSK&#125;, \cdot)&#125;(\operatorname&#123;MPK&#125;, \&#123;\operatorname&#123;CT&#125;_i\&#125;_&#123;i \in [\ell]&#125;, st) \\ 5: \ \ \operatorname&#123;Output&#125;(\&#123;x_i\&#125;_&#123;i \in [\ell]&#125;, \alpha) \\ 1: \ \operatorname&#123;MPK&#125; \leftarrow \operatorname&#123;Sim&#125;(1^&#123;\kappa&#125;) \\ 2: (\&#123;x_i\&#125;_&#123;i \in [\ell]&#125;, st) \leftarrow A_1^&#123;\operatorname&#123;Sim&#125;(\cdot)&#125;(\operatorname&#123;MPK&#125;) \\ 3: \&#123;\operatorname&#123;CT&#125;_i\&#125;_&#123;i \in [\ell]&#125; \leftarrow \operatorname&#123;Sim&#125;^&#123;\&#123;U_&#123;x_i&#125;(\cdot)\&#125;_&#123;i \in [\ell]&#125;&#125;(\&#123;1^&#123;|x_i|&#125;\&#125;_&#123;i \in [\ell]&#125;) \\ 4: \ \alpha \leftarrow A_2^&#123;\mathcal&#123;O&#125;'(\cdot)&#125;(\operatorname&#123;MPK&#125;, \&#123;\operatorname&#123;CT&#125;_i\&#125;_&#123;i \in [\ell]&#125;, st) \\ 5: \ \ \operatorname&#123;Output&#125;(\&#123;x_i\&#125;_&#123;i \in [\ell]&#125;, \alpha) \\ 5: \ \ \operatorname&#123;Output&#125;(\&#123;x_i\&#125;_&#123;i \in [\ell]&#125;, \alpha) ```</p>
      <p class="text-gray-300">We distinguish between two cases of the above experiment:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>1. The adaptive experiment, where:</li>
        <li>the oracle  <span class="math">\mathcal&#123;O&#125;(\mathsf&#123;MSK&#125;,\cdot) = \mathsf&#123;FE&#125;.\mathsf&#123;Keygen&#125;(\mathsf&#123;MSK&#125;,\cdot)</span> , and</li>
        <li>the oracle  <span class="math">\mathcal&#123;O&#125;'(\cdot)</span>  is the simulator, namely  <span class="math">\operatorname&#123;Sim&#125;^&#123;\&#123;U_&#123;x_i&#125;(\cdot)\&#125;_&#123;i\in[\ell]&#125;&#125;(\cdot)</span> .</li>
      </ul>
      <p class="text-gray-300">We call a stateful simulator algorithm Sim admissible if, on each input C, Sim makes just a single query to its oracle  <span class="math">U_x(\cdot)</span>  on C itself.</p>
      <p class="text-gray-300">The functional encryption scheme  <span class="math">\mathcal&#123;FE&#125;</span>  is then said to be simulation-secure for many messages against adaptive adversaries (many-AD-SIM-secure, for short) if there is an admissible stateful</p>
      <p class="text-gray-300"><em>p.p.t. simulator</em> Sim <em>such that for every polynomial function ℓ</em> = <em>ℓ</em>(<em>κ</em>)<em>, every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the following two distributions are computationally indistinguishable:</em></p>
      <div class="math-block">\left\&#123; \mathsf&#123;Exp&#125;^&#123;\mathsf&#123;real&#125;&#125;_&#123;\mathcal&#123;FE&#125;,A&#125;(1^&#123;\kappa&#125;) \right\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125; \overset&#123;c&#125;&#123;\approx&#125; \left\&#123; \mathsf&#123;Exp&#125;^&#123;\mathsf&#123;ideal&#125;&#125;_&#123;\mathcal&#123;FE&#125;,\mathrm&#123;Sim&#125;&#125;(1^&#123;\kappa&#125;) \right\&#125;_&#123;\kappa \in \mathbb&#123;N&#125;&#125;</div>
      <p class="text-gray-300"><em>2.</em> The non-adaptive experiment<em>, where the oracles O</em>(MSK<em>, ·</em>) <em>and O′</em> (<em>·</em>) <em>are both the "empty oracles" that return nothing.</em></p>
      <p class="text-gray-300"><em>The functional encryption scheme FE is then said to be simulation-secure for many messages against non-adaptive adversaries (many-</em>NA<em>-</em>SIM<em>-secure, for short) if there is an</em> admissible <em>stateful p.p.t. simulator</em> Sim <em>such that for every polynomial function ℓ</em> = <em>ℓ</em>(<em>κ</em>)<em>, every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the two distributions above are computationally indistinguishable.</em></p>
      <p class="text-gray-300">We define many-AD-USIM and many-NA-USIM identically to the above definition, except with computationally unbounded simulator.</p>
      <h2 id="span-id-page-18-0-span-c-indistinguishability-and-unbounded-simulation" class="text-2xl font-bold mt-10 mb-4"><span id="page-18-0"></span>C Indistinguishability and Unbounded Simulation</h2>
      <p class="text-gray-300">In this section, we put forth the notion of <em>unbounded-simulation secure</em> functional encryption. We argue that this is a very natural notion of security, with counterparts in the worlds of multiparty computation and zero knowledge [[Pas03](#page-15-8), [PS04,](#page-16-6) [BS05\]](#page-14-9). Unbounded simulation security further elucidates the power and limitations of indistinguishability-based definitions, and captures the spirit of some known separations (see below).</p>
      <p class="text-gray-300">The definition of unbounded-simulation security (in both the adaptive and non-adaptive settings) is the same as Definition [2.2,](#page-7-0) except that the simulator is not restricted to run in polynomial time.</p>
      <h4 id="c-1-relationship-between-sim-usim-and-ind" class="text-lg font-semibold mt-6 mb-2">C.1 Relationship between SIM, USIM and IND</h4>
      <p class="text-gray-300"><strong>Theorem C.1.</strong> <em>Let FE be a functional encryption scheme for a family of circuits C. Then, if</em> FE <em>is</em> AD<em>-</em>SIM <em>(resp.</em> NA<em>-</em>SIM<em>) secure then it is also</em> AD<em>-</em>USIM <em>(resp.</em> NA<em>-</em>USIM<em>) secure. In addition, if</em> FE <em>is</em> AD<em>-</em>USIM<em>(resp.</em> NA<em>-</em>USIM<em>) secure then it is</em> AD<em>-</em>IND <em>(resp.</em> NA<em>-</em>IND<em>) secure.</em></p>
      <p class="text-gray-300"><em>Proof.</em> AD-SIM(NA-SIM) <em>⇒</em> AD-USIM(NA-USIM): This claim is trivial since the unbounded simulator can just run the poly-time simulator, in both the adaptive and non-adaptive cases.</p>
      <p class="text-gray-300">AD-USIM(NA-USIM) <em>⇒</em> AD-IND(NA-IND): We prove this claim by showing the contrapositive. Let <em>A</em> = (<em>A</em>1<em>, A</em>2) be the adversary that breaks AD-IND(resp. NA-IND) security of the <em>FE</em> scheme. We construct an adversary <em>B</em> = (<em>B</em>1<em>, B</em>2) from <em>A</em>. In our construction, if <em>A</em> is a AD-IND (resp. NA-IND) adversary, then <em>B</em> is a AD-USIM (resp. NA-USIM) adversary.</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*• B* FE*.*Keygen(MSK*,·*) 1 (MPK): Run *A* FE*.*Keygen(MSK*,·*) 1 (MPK). Answer *A*1's key queries using FE*.*Keygen oracle. Finally, *A*<sup>1</sup> outputs two messages *x*0*, x*<sup>1</sup> and a state *sta*. Now, choose a random bit *b* and output (*x, st*) = (*xb,* [*sta, x*0*, x*1]).</li>
        <li>*• B O*(MSK*,·*) 2 (MPK*,* CT*, st*): Invoke *A O*(MSK*,·*) 2 (MPK*,* CT*, sta*) and output whatever bit *b ′* it outputs. In the adaptive case, if *A*<sup>2</sup> makes any oracle queries, answer them using own oracle.</li>
      </ul>
      <p class="text-gray-300">The output of the real experiment is (<em>xb, st</em> = [<em>sta, x</em>0<em>, x</em>1]<em>, α</em> = <em>b ′ , C</em>1<em>, . . . , Cq</em>). Hence, with probability significantly greater than a half <em>b</em> = <em>b ′</em> and the distinguisher can verify this. Now we claim that there is no unbounded simulator Sim<em><sup>u</sup></em> for the adversary (<em>B</em>1<em>, B</em>2) in the adaptive or non-adaptive case. In particular, we argue that the simulator Sim<em><sup>u</sup></em> cannot guess bit <em>b ′</em> with probability better than a half. We observe:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*•* The IND adversary *A* = (*A*1*, A*2) is admissible, hence, for all queries *&#123;C ′ i &#125;i∈*[*<sup>q</sup> ′* that *A* makes to *B*, and hence *B* makes to Sim*u*, we have that *C ′ i* (*x*0) = *C ′ i* (*x*1). The view of Sim*<sup>u</sup>* is statistically independent of the challenge bit *b*.</li>
        <li>*•* Since the queries *C*1*, . . . , C<sup>q</sup>* are part of the output of the experiment, Sim*<sup>u</sup>* is restricted to make admissible queries only to the function oracle, otherwise a distinguisher can easily distinguish between the real and ideal worlds. Thus, it must be the case that *Ci*(*x*0) = *Ci*(*x*1)*, ∀i ∈* [*q*]. Hence, the view of Sim*<sup>u</sup>* is also statistically independent of the challenge bit *b*.</li>
      </ul>
      <p class="text-gray-300">Putting these together, we deduce that the view of the simulator is statistically independent of the challenge bit <em>b</em>, thus the probability it guesses <em>b</em> correctly is at most 1<em>/</em>2. Therefore, the simulator Sim<em><sup>u</sup></em> cannot produce the output indistinguishable from the real experiment.</p>
      <h3 id="span-id-page-19-0-span-c-2-impossibility-of-ad-usim-ibe" class="text-xl font-semibold mt-8 mb-3"><span id="page-19-0"></span>C.2 Impossibility of AD-USIM IBE</h3>
      <p class="text-gray-300">We observe that the impossibility of realizing the IBE functionality under many-AD-SIM as shown in [[BSW11,](#page-14-2) Section 5.1] (which is in turn similar to the impossibility result for non-committing encryption given in [[Nie02\]](#page-15-15)) extends to many-AD-USIM. For self containment, we provide a recap of the argument.</p>
      <p class="text-gray-300">Let <em>κ</em> denote the security parameter and <em>ℓ</em> be an upper bound on the secret key length produced by FE<em>.</em>Keygen for security parameter <em>κ</em>. Assume that both the identity and the payload message are bits. Then, the real world adversary behaves as follows (refer to Definition [2.2](#page-7-0)) (1) <em>A</em><sup>1</sup> makes no secret key queries and outputs <strong>x</strong> = <em>&#123;</em>(0<em>, x</em>0<em>,</em> 0)<em>, . . . ,</em>(0<em>, xℓ</em>+<em>κ</em>)<em>&#125;</em> where each <em>x<sup>i</sup> , i ∈</em> [<em>ℓ</em> + <em>κ</em>] is a uniformly random bit, and all payload messages correspond to identity 0. (2) The adaptive adversary <em>A</em><sup>2</sup> requests for the SK0.</p>
      <p class="text-gray-300">Note that the admissible simulator Sim can only query the function oracle <em>Ux<sup>i</sup></em> (<em>·</em>) after <em>A</em><sup>2</sup> requests the secret key SK0, and thus cannot learn the payload bits until such point. However, Sim has to simulate the tuple of <em>ℓ</em> + <em>κ</em> ciphertexts before it sees the actual payload bits. Thus, the simulator has to produce a fixed string of CTs which, upon decryption with an <em>ℓ</em> bit secret key, need to produce an <em>arbitrary ℓ</em> + <em>κ</em> bits – which is impossible. This argument holds even if the simulator is computationally unbounded, hence we conclude that many-AD-USIM is impossible, even for IBE.</p>
      <h4 id="c-3-illustrative-examples-and-discussion" class="text-lg font-semibold mt-6 mb-2">C.3 Illustrative Examples and Discussion</h4>
      <p class="text-gray-300">In this section we discuss some examples to separate the various notions of security.</p>
      <p class="text-gray-300">AD<strong>-</strong>SIM <strong>and</strong> AD<strong>-</strong>USIM : We observe the following example from [\[BSW11](#page-14-2), Section 4.2] separating AD-SIM and AD-IND also separates AD-SIM and AD-USIM. <sup>8</sup> Let <em>π</em> be a one-way permutation and consider the circuit family <em>C</em> consisting of a single circuit <em>C</em> defined as follows:</p>
      <div class="math-block">C(x) = \pi(x)</div>
      <sup>8</sup>We need to modify the construction to account for the fact that we do not admit the "empty" key.
      <p class="text-gray-300">Note that this circuit satisfies our "litmus test" in [1.2](#page-4-0) for checking if IND security is inadequate <em>π</em>(<em>x</em>) hides <em>x</em> from a computationally bounded adversary, but reveals <em>x</em> to an unbounded adversary. Now, consider the FE<em>.</em>Enc algorithm that outputs a public-key encryption of <em>x</em> on input <em>x</em>; FE<em>.</em>Keygen algorithm that outputs the secret key for the public-key encryption on input <em>C</em>; FE<em>.</em>Dec recovers <em>x</em> and outputs <em>π</em>(<em>x</em>). It was shown in [[BSW11\]](#page-14-2) that this scheme AD-IND-secure but not AD-SIM-secure. We observe that this scheme is also AD-USIM-secure, provided the underlying encryption scheme is "non-committing" (c.f. [\[GVW12](#page-15-5), Section 4.1]). The simulator proceeds as follows:</p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 my-2">
        <li>*•* If the adversary makes a secret key query before seeing the ciphertext, then the simulator learns *π*(*x*) by querying the oracle on *C*, and then computes *x* via "brute force" and encrypts it.</li>
        <li>*•* Otherwise, the simulator generates a "non-committing" simulated ciphertext. If the adversary makes a secret key query after seeing the ciphertext, then the simulator learns *π*(*x*) by querying the oracle on *C*, computes *x* via "brute force", and generates a consistent secret key.</li>
      </ul>
      <p class="text-gray-300">AD<strong>-</strong>IND <strong>and</strong> AD<strong>-</strong>USIM : We do not have a natural example of a scheme which is AD-INDsecure but not AD-USIM-secure, which we leave as an open problem. We point out that the naive approach of replacing the one-way permutation in the preceding example with a collision resistant hash function does not seem to work; if the encryptor picks the hash function, then the adversary could potentially pick a "bad" hash function for which it knows a pair of collisions.</p>
      <p class="text-gray-300"><strong>Summary.</strong> We summarize some of the properties of USIM security: (1) It clarifies the inadequacy of indistinguishability-based security definitions as pointed out in [[BSW11,](#page-14-2) Section 4.2]; specifically, the statement therein that "game-based formulation essentially ignores any computational hiding properties of the circuits, and therefore offers no security guarantees that could be meaningfully combined with such computational considerations", is really a statement about USIM security. (2) It potentially admits realizations for a large class of circuits; it allows us to circumvent our 1-NA-SIM lower bound, but is nonetheless ultimately limited by many-AD-SIM lower bound for IBE. (3) Unbounded simulation is a natural notion, with analogues in zero knowledge and secure computation [[Pas03](#page-15-8), [PS04](#page-16-6), [BS05](#page-14-9)], and comparisons with these can aid our understanding of functional encryption. (4) For certain circuit families, USIM may be "good enough"; understanding when this happens could further clarify existing constructions.</p>
    </section>
  </article>
</BaseLayout>
