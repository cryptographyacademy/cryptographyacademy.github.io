---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/468';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Functional Encryption: New Perspectives and Lower Bounds';
const AUTHORS_HTML = 'Shweta Agrawal, Sergey Gorbunov, Vinod Vaikuntanathan, Hoeteck Wee';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Functional encryption is an emerging paradigm for public-key encryption that enables fine-grained control of access to encrypted data. In this work, we present new perspectives on security definitions for functional encryption, as well as new lower bounds on what can be achieved. Our main contributions are as follows:

* We show a lower bound for functional encryption that satisfies a weak (non-adaptive) simulation-based security notion, via pseudo-random functions. This is the first lower bound that exploits unbounded collusions in an essential way.

* We put forth and discuss a simulation-based notion of security for functional encryption, with an unbounded simulator (called USIM). We show that this notion interpolates indistinguishability and simulation-based security notions, and has strong correlations to results and barriers in the zero-knowledge and multi-party computation literature.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Functional Encryption &middot; Simulation-based Definitions &middot; Pseudorandom Functions</p>
    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Preliminaries</h2>

    <p class="text-gray-300"><strong>Notations.</strong> Let  <span class="math">\\mathcal{D}</span>  denote a distribution over some finite set S. Then,  <span class="math">x \\leftarrow \\mathcal{D}</span>  is used to denote the fact that x is chosen from the distribution  <span class="math">\\mathcal{D}</span> . When we say  <span class="math">x \\leftarrow S</span> , we simply mean that x is chosen from the uniform distribution over S. Unless explicitly mentioned, all logarithms are to base 2. For  <span class="math">n \\in \\mathbb{N}</span> , let [n] denote the set of numbers  <span class="math">1, \\ldots, n</span> . Let  <span class="math">\\kappa</span>  denote the security parameter.</p>

    <p class="text-gray-300"><strong>Definition 3.1</strong> (wPRF). Let wPRF = {wPRF}_{\\kappa}_{\\kappa \\in \\mathbb{N}} denote a family of efficiently computable functions where wPRF <span class="math">_{\\kappa}</span> :  <span class="math">\\{0,1\\}^{n(\\kappa)} \\times \\{0,1\\}^{m(\\kappa)} \\to \\{0,1\\}^{k(\\kappa)}</span> , the first argument of which is called the seed to the wPRF and the second argument is the input.</p>

    <p class="text-gray-300">For every probabilistic polynomial time oracle distinguisher Dist, consider the following two experiments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Real<sub>Dist</sub>(1<sup>\\kappa</sup>): Choose  <span class="math">x \\stackrel{\\</span>}{\\leftarrow} {0,1}^{n(\\kappa)}$  and run Dist with access to a probabilistic oracle  <span class="math">\\mathcal{O}_{real}(x)</span>  which, when invoked, chooses a uniformly random  <span class="math">d \\leftarrow \\{0,1\\}^{m(\\kappa)}</span>  and returns the pair  <span class="math">(d, \\mathsf{wPRF}_{\\kappa}(x,d))</span> . This experiment outputs whatever Dist outputs.</li>
      <li>Rand<sub>Dist</sub>(1<sup>\\kappa</sup>): Choose a uniformly random function  <span class="math">R: \\{0,1\\}^{m(\\kappa)} \\to \\{0,1\\}^{k(\\kappa)}</span>  and run Dist with access to a probabilistic oracle  <span class="math">\\mathcal{O}_{rand}(R)</span>  which, when invoked, chooses a uniformly random  <span class="math">d \\leftarrow \\{0,1\\}^{m(\\kappa)}</span>  and returns the pair (d,R(d)). This experiment outputs whatever Dist outputs.</li>
    </ul>

    <p class="text-gray-300">We say wPRF is a weak pseudo-random function if for all p.p.t. distinguishers Dist,</p>

    <p class="text-gray-300"><span class="math">$\\big|\\Pr[\\mathsf{Real}_{\\mathrm{Dist}}(1^\\kappa) = 1] - \\Pr[\\mathsf{Rand}_{\\mathrm{Dist}}(1^\\kappa) = 1]\\big| = \\mathrm{negl}(\\kappa)</span>$</p>

    <p class="text-gray-300">where the probabilities are over the choice of x and R, as well as the coin-tosses of Dist and the oracles  <span class="math">\\mathcal{O}_{real}</span>  and  <span class="math">\\mathcal{O}_{rand}</span> .</p>

    <p class="text-gray-300">In our impossibility result, we will use a weak pseudo-random function with seed length  <span class="math">n(\\kappa) = \\kappa</span>  and output length  <span class="math">k(\\kappa) = 1</span> .</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>4 Impossibility Results for Functional Encryption</strong></h2>

    <p class="text-gray-300">In this section, we present our main lower bound for 1-NA-SIM-secure functional encryption. We begin with a notion of &quot;incompressible&quot; circuits. Then, we show that (1) weak pseudo-random functions are &quot;incompressible&quot;, and (2) 1-NA-SIM-secure functional encryption only exists for &quot;compressible&quot; circuits. Putting the two together yields our lower bound.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8"><strong>4.1 Incompressible Circuits</strong></h3>

    <p class="text-gray-300">We first define a family of compressible circuits. Informally, we say that a family of circuits <em>{G&kappa;}</em> is (<em>&#8467;, t</em>)-compressible if for a list of uniformly random circuit descriptions <em>G</em>1<em>, . . . , G<sup>&#8467;</sup> &isin; G<sup>&kappa;</sup></em> and a uniformly chosen input <em>x</em>, there is some efficiently computable description of <em>G</em>1(<em>x</em>)<em>, . . . , G&#8467;</em>(<em>x</em>) of size <em>t</em>. Note that if there is no efficiency requirement, then any family is (<em>&#8467;, |s|</em>)-compressible.</p>

    <p class="text-gray-300"><strong>Definition 4.1</strong> (Incompressible Circuits)<strong>.</strong> <em>Let &#8467;</em> = <em>&#8467;</em>(<em>&kappa;</em>) <em>and t</em> = <em>t</em>(<em>&kappa;</em>) <em>be functions of the security parameter &kappa;. A family of circuits G</em> = <em>{G&kappa;}&kappa;&isin;</em><sup>N</sup> <em>is</em> (<em>&#8467;, t</em>)-compressible <em>if there exist a family of (deterministic) compressor circuits {<em><strong>C</strong></em>&kappa;}&kappa;&isin;</em><sup>N</sup> <em>and a family of decompressor circuits {<em><strong>D</strong></em>&kappa;}&kappa;&isin;</em><sup>N</sup> <em>such that:</em></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull; (polynomial size) the circuits</em> **C<em><strong><sup>&kappa;</sup> and* **D</strong></em><sup>&kappa;</sup> have size* poly(<em>&kappa;, &#8467;</em>)<em>.</em></li>
      <li><em>&bull; (mild compression) for sufficiently large &kappa;,</em> **C***&kappa;<em>(</em>G<em>1</em>, . . . , G<sup>&#8467;</sup> , y<em>1</em>, . . . , y&#8467;<em>)  = *t, where y<sup>i</sup></em> = <em>Gi</em>(<em>x</em>)<em>.</em></li>
      <li><em>&bull; (correctness) there is a polynomial p</em> = <em>p</em>(<em>&kappa;</em>) <em>such that</em></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\Pr[x \\stackrel{\\</span>}{\\leftarrow} {0,1}^{\\kappa}, G_1, \\dots, G_{\\ell} \\stackrel{$}{\\leftarrow} \\mathcal{G}_{\\kappa}, y_i = G_i(x) :$$</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{D}_{\\kappa}(G_1, \\dots, G_{\\ell}, \\mathbf{C}_{\\kappa}(G_1, \\dots, G_{\\ell}, y_1, \\dots, y_{\\ell})) = (y_1, \\dots, y_{\\ell})] \\ge 1/p(\\kappa)</span>$</p>

    <p class="text-gray-300"><em>where the probability is taken over the choice of x as well as the circuits G</em>1<em>, . . . , G<sup>&#8467;</sup> .</em></p>

    <p class="text-gray-300"><em>The family G is</em> (<em>&#8467;, t</em>)-incompressible <em>if it is not</em> (<em>&#8467;, t</em>)<em>-compressible.</em></p>

    <p class="text-gray-300">We now give examples of (in)compressible circuits. First, consider the notion of preimage samplable family of circuits introduced by O'Neill [<a href="#page-15-0">O'N10</a>] which requires that given <em>G</em>1(<em>x</em>)<em>, . . . , G&#8467;</em>(<em>x</em>), there is a polynomial-time algorithm that returns an arbitrary <em>x &prime;</em> such that <em>Gi</em>(<em>x &prime;</em> ) = <em>Gi</em>(<em>x</em>) for all <em>i</em>. In our language, this says that the family <em>G</em> is (<em>&#8467;, |x &prime; |</em>)-compressible; the compression algorithm simply outputs <em>x &prime;</em> .</p>

    <p class="text-gray-300">Next, consider an arbitrary public-index circuit family parametrized by predicates <em>P</em> and given by:</p>

    <p class="text-gray-300"><span class="math">$G_P(\\mathsf{ind}, \\mu) = \\left\\{ \\begin{array}{ll} (\\mathsf{ind}, \\mu) &amp; \\mathrm{if}\\ P(\\mathsf{ind}) = 1 \\\\ (\\mathsf{ind}, \\bot) &amp; \\mathrm{otherwise} \\end{array} \\right.</span>$</p>

    <p class="text-gray-300">It is easy to see that this circuit family is (<em>&#8467;, |</em>(ind<em>, &micro;</em>)<em>|</em>)-compressible. On input</p>

    <p class="text-gray-300"><span class="math">$G_{P_1}(\\mathsf{ind},\\mu),\\ldots,G_{P_\\ell}(\\mathsf{ind},\\mu)</span>$</p>

    <p class="text-gray-300">If <em>Pi</em>(ind) = 1 for some <em>i</em>, then the compression algorithm outputs (ind<em>, &micro;</em>). If <em>Pi</em>(ind) = 0 for all <em>i</em>, then the algorithm outputs (ind<em>, &perp;</em>).</p>

    <p class="text-gray-300">On the other hand, as we show below (see Lemma <a href="#page-10-0">4.1)</a>, any family of (weak) pseudorandom functions is incompressible in a strong sense. More precisely, consider a family of circuits  <span class="math">\\mathcal{G} = \\{G_{d_i}(\\cdot) = \\mathsf{wPRF}(\\cdot, d_i)\\}</span>  where  <span class="math">d_i</span>  serves as the input to the pseudo-random function. Informally, the incompressibility is due to the fact that a sequence  <span class="math">(G_{d_1}(x), \\ldots, G_{d_\\ell}(x)) = (\\mathsf{wPRF}(x, d_1), \\ldots, \\mathsf{wPRF}(x, d_\\ell))</span>  is indistinguishable from a sequence of uniformly random bits, which are clearly incompressible.</p>

    <p class="text-gray-300"><strong>Lemma 4.1</strong> (weak PRFs are  <span class="math">(\\ell, \\ell - \\kappa)</span> -incompressible). Let wPRF = {wPRF <span class="math">_{\\kappa}</span>  :  <span class="math">\\{0,1\\}^{\\kappa} \\times \\{0,1\\}^{m(\\kappa)} \\to \\{0,1\\}\\}_{\\kappa \\in \\mathbb{N}}</span>  be a family of weak pseudo-random functions, where  <span class="math">m(\\kappa) = \\omega(\\log \\kappa)</span> . Define  <span class="math">G_d(x) = \\text{wPRF}(x,d)</span> . Consider a family  <span class="math">\\mathcal{G} = \\{\\mathcal{G}_{\\kappa}\\}_{\\kappa \\in \\mathbb{N}}</span>  defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{G}_{\\kappa} = \\left\\{ G_d(\\cdot) : |d| = m(\\kappa) \\right\\}</span>$</p>

    <p class="text-gray-300">Then,  <span class="math">\\mathcal{G}</span>  is  <span class="math">(\\ell, \\ell - \\kappa)</span> -incompressible.</p>

    <p class="text-gray-300"><em>Proof.</em> Assume, for the sake of contradiction, that  <span class="math">\\mathcal{G}</span>  is  <span class="math">(\\ell, \\ell - \\kappa)</span> -compressible. Namely, there are families of compressor and decompressor circuits  <span class="math">(\\mathbf{C}, \\mathbf{D})</span>  that satisfy Definition 4.1. We show how to construct a distinguisher  <span class="math">\\mathrm{Dist}^{\\mathcal{O}}</span>  that distinguishes between the case where  <span class="math">\\mathcal{O} = \\mathsf{wPRF}(x, \\cdot)</span>  is a pseudo-random oracle that outputs pairs  <span class="math">(d_i, y_i = \\mathsf{wPRF}_{\\kappa}(x, d_i))</span>  where  <span class="math">d_i</span>  are uniformly random, and the case where  <span class="math">\\mathcal{O}</span>  outputs strings  <span class="math">(d_i, y_i = R(d_i))</span>  where  <span class="math">d_i</span>  and R are uniformly random strings and function, respectively. Dist  <span class="math">\\mathcal{O}</span>  proceeds as follows.</p>

    <p class="text-gray-300">&bull; Choose a sufficiently large  <span class="math">\\kappa</span>  such that</p>

    <p class="text-gray-300"><span class="math">$|\\mathbf{C}_{\\kappa}(G_1,\\ldots,G_{\\ell},y_1,\\ldots,y_{\\ell})| = \\ell - \\kappa</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Query the oracle  <span class="math">\\mathcal{O}</span>  to obtain pairs of strings of the form  <span class="math">(d_i \\stackrel{\\</span>}{\\leftarrow} {0,1}^{m(\\kappa)}, y_i)$ . Define the circuit  <span class="math">G_{d_i}(\\cdot) := \\mathsf{wPRF}(\\cdot, d_i)</span> .</li>
      <li>Run the compressor  <span class="math">\\mathbf{C}_{\\kappa}</span>  to get a string</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\gamma \\leftarrow \\mathbf{C}_{\\kappa}(G_{d_1}, \\dots, G_{d_\\ell}, y_1, \\dots, y_\\ell)</span>$</p>

    <p class="text-gray-300">&bull; Outputs 1 if and only if</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{D}_{\\kappa}(G_{d_1},\\ldots,G_{d_{\\ell}},\\gamma)=(y_1,\\ldots,y_{\\ell})</span>$</p>

    <p class="text-gray-300">We now show that the distinguisher succeeds with non-negligible advantage  <span class="math">1/p(\\kappa) - 2^{-\\kappa}</span>  in breaking the weak pseudo-random function family wPRF.</p>

    <p class="text-gray-300">If  <span class="math">\\mathcal{O}</span>  is the pseudo-random oracle, then the samples  <span class="math">\\mathrm{Dist}^{\\mathcal{O}}</span>  gets are of the form  <span class="math">(d_i, y_i \\leftarrow \\mathsf{wPRF}(x, d_i))</span> . Hence, by correctness of  <span class="math">\\mathbf{C}</span>  and  <span class="math">\\mathbf{D}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{D}_{\\kappa}(G_{d_1},\\ldots,G_{d_{\\ell}},\\mathbf{C}_{\\kappa}(G_{d_1},\\ldots,G_{d_{\\ell}},y_1,\\ldots,y_{\\ell}))=(y_1,\\ldots,y_{\\ell})</span>$</p>

    <p class="text-gray-300">with probability at least  <span class="math">1/p(\\kappa)</span> . Thus, the distinguisher in this case outputs 1 with probability at least  <span class="math">1/p(\\kappa)</span>  as well.</p>

    <p class="text-gray-300">On the other hand, if  <span class="math">\\mathcal{O}</span>  outputs pairs of strings of the form  <span class="math">(d_i, y_i \\leftarrow R(d_i))</span>  for a randomly chosen function mapping R, we now show that the distinguisher above outputs 1 with probability at most  <span class="math">2^{-\\kappa}</span> . In the analysis below, we assume that  <span class="math">d_1, \\ldots, d_\\ell</span>  are distinct, for which we need to pay a price of an additive  <span class="math">\\ell^2 \\cdot 2^{-m(\\kappa)} = \\text{negl}(\\kappa)</span>  term in the distinguishing error.</p>

    <p class="text-gray-300">Pr[Dist<sup>O</sup> outputs 1]
<span class="math">$\\leq \\Pr_{\\substack{d_1, \\dots, d_\\ell \\overset{\\</span>}{\\leftarrow} {0,1}^{m(\\kappa)} \\ y_1, \\dots, y_\\ell \\overset{$}{\\leftarrow} {0,1}}} \\left[ \\exists \\gamma : |\\gamma| = \\ell - \\kappa \\text{ and } \\mathbf{D}<em>{\\kappa}(G</em>{d_1}, \\dots, G_{d_\\ell}, \\gamma) = (y_1, \\dots, y_\\ell) \\right]$$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{\\substack{\\gamma \\in \\{0,1\\}^{\\ell-\\kappa} \\\\ y_1, \\dots, y_\\ell \\overset{\\</span>}{\\leftarrow} {0,1}}} \\Pr_{\\substack{{0,1}^{m(\\kappa)} \\ y_1, \\dots, y_\\ell \\overset{$}{\\leftarrow} {0,1}}} \\left[ \\mathbf{D}<em>{\\kappa}(G</em>{d_1}, \\dots, G_{d_\\ell}, \\gamma) = (y_1, \\dots, y_\\ell) \\right] \\text{ (via a union bound)}$$</p>

    <p class="text-gray-300"><span class="math">$= \\sum_{\\substack{\\gamma \\in \\{0,1\\}^{\\ell-\\kappa} \\\\ \\gamma \\in \\{0,1\\}^{\\ell-\\kappa}}} 2^{-\\ell} \\text{ (since } y_1, \\dots, y_\\ell \\text{ are random and independent of } d_1, \\dots, d_\\ell, \\gamma)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq 2^{\\ell-\\kappa} \\cdot 2^{-\\ell} = 2^{-\\kappa}</span>$</p>

    <p class="text-gray-300">This yields the required contradiction to the security of wPRF.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8"><strong>4.2 The Impossibility Result</strong></h3>

    <p class="text-gray-300">We are now ready to state and prove our main theorem.</p>

    <p class="text-gray-300"><strong>Theorem 4.2.</strong> <em>There exists a family of circuits G for which there are no</em> 1<em>-</em>NA<em>-</em>SIM<em>-secure functional encryption schemes.</em></p>

    <p class="text-gray-300"><em>Proof.</em> We consider two cases.</p>

    <p class="text-gray-300"><strong>Case 1</strong>: Assume there exists a circuit family of weak pseudo-random functions</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{wPRF} = \\{\\mathsf{wPRF}_\\kappa : \\{0,1\\}^\\kappa \\times \\{0,1\\}^{m(\\kappa)} \\to \\{0,1\\}\\}_{\\kappa \\in \\mathbb{N}}</span>$</p>

    <p class="text-gray-300">where <em>m</em>(<em>&kappa;</em>) = <em>&omega;</em>(log <em>&kappa;</em>). Let <em>Gd</em>(<em>x</em>) = wPRF(<em>x, d</em>) and consider a family <em>G</em> = <em>{G&kappa;}&kappa;&isin;</em><sup>N</sup> defined as</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{G}_{\\kappa} = \\left\\{ G_d(\\cdot) : |d| = m(\\kappa) \\right\\}</span>$</p>

    <p class="text-gray-300">Assume, for the sake of contradiction, there exist a 1-NA-SIM-secure function encryption scheme <em>FE</em> for <em>G</em>, and let <em>|</em>CT<em>|</em> denote the length of a ciphertext in the scheme. Let <em>&#8467;</em> = <em>&#8467;</em>(<em>&kappa;</em>) = <em>|</em>CT<em>|</em> + <em>&kappa;</em>.</p>

    <p class="text-gray-300">From Lemma <a href="#page-10-0">4.1</a>, we know that <em>G</em> is (<em>|</em>CT + <em>&kappa;, |</em>CT<em>|</em>)-incompressible. However, Lemma <a href="#page-11-1">4.3</a> below tells us that since there is a 1-NA-SIM secure scheme for <em>G</em>, the family <em>G</em> is (<em>|</em>CT<em>|</em> + <em>&kappa;, |</em>CT<em>|</em>) compressible. This gives us the desired contradiction, and therefore, there cannot exist a 1-NA-SIMsecure functional encryption scheme for <em>G</em>.</p>

    <p class="text-gray-300"><strong>Case 2</strong>: Assume there does not exist a family of weak pseudo-random functions. Also, for the sake of contradiction, assume there exists a 1-NA-SIM-secure function encryption scheme for all families of circuits <em>G</em>.</p>

    <p class="text-gray-300">In particular, this means that there is a functional encryption scheme for the empty circuit family (namely, a family <em>G</em> that does not contain any circuits at all). A 1-NA-SIM-secure scheme <em>FE</em> for <em>G</em> is also a secure public-key encryption scheme. Since public-key encryption implies one-way functions, which in turn imply pseudo-random functions [<a href="#page-15-13">GGM86</a>, <a href="#page-15-14">HILL99</a>], we obtain the desired contradiction.</p>

    <p class="text-gray-300"><strong>Lemma 4.3</strong> (1-NA-SIM <em>&rArr;</em> (<em>&#8467;, |</em>CT<em>|</em>)-compressibility)<strong>.</strong> <em>Let G</em> = <em>{G&kappa;}&kappa;&isin;</em><sup>N</sup> <em>be a family of circuits. Suppose there exists a</em> 1<em>-</em>NA<em>-</em>SIM<em>-secure functional encryption scheme for the G. Then, the family G is</em> (<em>&#8467;, |</em>CT<em>|</em>)<em>-compressible for any polynomially bounded &#8467;</em> = <em>&#8467;</em>(<em>&kappa;</em>)<em>, where |</em>CT<em>| denotes size of the encryption of input x.</em></p>

    <p class="text-gray-300">Informally, the compression algorithm works as follows: on input <em>G</em>1<em>, . . . , G<sup>&#8467;</sup></em> and <em>G</em>1(<em>x</em>)<em>, . . . , G&#8467;</em>(<em>x</em>), the output is the simulated ciphertext corresponding to an encryption of <em>x</em>. The decompression algorithm then evaluates the decryption algorithm, which is guaranteed to produce <em>G</em>1(<em>x</em>)<em>, . . . , G&#8467;</em>(<em>x</em>).</p>

    <p class="text-gray-300"><em>Proof.</em> Let (FE<em>.</em>Setup<em>,</em> FE<em>.</em>Keygen<em>,</em> FE<em>.</em>Enc<em>,</em> FE<em>.</em>Dec) denote the encryption scheme for the family <em>G</em>. Consider the adversary <em>A</em> = (<em>A</em>1<em>, A</em>2) in the 1-NA-SIM security experiment that acts as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull; A</em><sup>1</sup> chooses <em>G</em>1<em>, . . . , G<sup>&#8467;</sup></em> $<em>&larr; G</em> independently at random and requests for the corresponding secret keys SK1<em>, . . . ,</em> SK<em><sup>&#8467;</sup></em> . In addition, it chooses <em>x</em> $<em>&larr; {</em>0<em>,</em> 1<em>} <sup>m</sup></em>(<em>&kappa;</em>) and outputs <em>x</em> as the challenge message, and (<em>G</em>1<em>, . . . , G<sup>&#8467;</sup> ,</em> SK1<em>, . . . ,</em> SK<em>&#8467;</em>) as the state.</li>
      <li><em>&bull; A</em><sup>2</sup> outputs <em>&alpha;</em> composed of the challenge ciphertext and the state (<em>G</em>1<em>, . . . , G<sup>&#8467;</sup> ,</em> SK1<em>, . . . ,</em> SK<em>&#8467;</em>).</li>
    </ul>

    <p class="text-gray-300">Let Sim denote the (admissible) stateful p.p.t. simulator guaranteed by 1-NA-SIM security. We show how to use the simulator to construct a family of (deterministic) compressor and decompressor circuits **C<em><strong><sup>&rho;</sup>* and **D</strong></em>&rho;<em>, indexed by a random string *&rho;</em> corresponding to the random tape for the simulator:</p>

    <p class="text-gray-300"><em>&bull;</em> The compressor **C***&rho;<em>, on input *G</em>1<em>, . . . , G<sup>&#8467;</sup></em> and <em>y</em>1<em>, . . . , y<sup>&#8467;</sup></em> works as follows: first, compute MPK <em>&larr;</em> Sim(1<em><sup>&kappa;</sup></em> ; <em>&rho;</em>) and secret keys <em>{</em>SK<em><sup>i</sup></em> : SK<em><sup>i</sup> &larr;</em> Sim(<em>G<sup>i</sup></em> ; <em>&rho;</em>)<em>}i&isin;</em>[<em>&#8467;</em>] . Then compute and output CT as the compressed string, where queries <em>Gi</em>(<em>x</em>) are answered with <em>y<sup>i</sup></em> :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{CT} \\leftarrow \\mathsf{Sim}^{U_x(\\cdot)}(1^{|m(\\kappa)|})</span>$</p>

    <p class="text-gray-300"><em>&bull;</em> The decompressor **D***&rho;<em>, on input *G</em>1<em>, . . . , G<sup>&#8467;</sup></em> and CT first reconstructs the master public key MPK <em>&larr;</em> Sim(1<em><sup>&kappa;</sup></em> ; <em>&rho;</em>) and the set of secret keys:</p>

    <p class="text-gray-300"><span class="math">$\\{\\mathsf{SK}_i : \\mathsf{SK}_i \\leftarrow \\mathrm{Sim}(G_i; \\ \\rho)\\}_{i \\in [\\ell]}</span>$</p>

    <p class="text-gray-300">Note that **D<em><strong><sup>&rho;</sup>* has the same randomness *&rho;* hard-wired, and so the secret keys SK*<sup>i</sup>* are exactly the same as those used by **C</strong></em>&rho;*. Finally, it computes and outputs:</p>

    <p class="text-gray-300"><span class="math">$\\left\\{y_i \\leftarrow \\mathsf{FE.Dec}(\\mathsf{SK}_i, \\mathsf{CT})\\right\\}_{i \\in [\\ell]}</span>$</p>

    <p class="text-gray-300">Formally, we output (**C<em><strong>&rho;,* **D</strong></em>&rho;<em>) for a random *&rho;</em>, which is a pair of polynomial-size circuits. Clearly, we achieve (<em>&#8467;, |</em>CT<em>|</em>)-compressibility, since the size of CT is determined by the functional encryption scheme and independent of <em>&#8467;</em>. To establish correctness, it suffices to show that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\rho, x, G_1, \\dots, G_{\\ell}} [\\mathbf{D}_{\\rho}(G_1, \\dots, G_{\\ell}, \\mathbf{C}_{\\rho}(G_1, \\dots, G_{\\ell}, G_1(x), \\dots, G_{\\ell}(x))) = (G_1(x), \\dots, G_{\\ell}(x))] \\ge 1 - \\operatorname{negl}(\\kappa)</span>$</p>

    <p class="text-gray-300">Here, we will rely on the correctness of the functional encryption scheme as well as 1-NA-SIMsecurity. First, consider the distinguisher Dist that given the output (<em>x,</em> CT<em>, G</em>1<em>, . . . , G<sup>&#8467;</sup> ,</em> SK1<em>, . . . ,</em> SK<em>&#8467;</em>) of the adversary <em>A</em><sup>2</sup> proceeds as follows:</p>

    <p class="text-gray-300">Output 1 iff for all
<span class="math">$i \\in [\\ell]</span>$
, FE.Dec( <span class="math">SK_i</span> ,  <span class="math">CT</span> ) =  <span class="math">G_i(x)</span> .</p>

    <p class="text-gray-300">Observe that by correctness of the encryption scheme, Dist outputs 1 with probability 1 <em>&minus;</em> negl(<em>&kappa;</em>) given the output of the adversary <em>A</em><sup>2</sup> in the 1-NA-SIM experiment. Therefore, by 1-NA-SIM-security, Dist also outputs 1 with probability 1 <em>&minus;</em> negl(<em>&kappa;</em>) given the output of the (admissible) simulator, where the randomness is taken over the coin tosses <em>&rho;</em> of the simulator, along with the random choices of <em>x, G</em>1<em>, . . . , G<sup>&#8467;</sup></em> .</p>

    <p class="text-gray-300">This shows that the pair of circuits (**C<em><strong>&rho;,* **D</strong></em>&rho;<em>) for a uniformly random *&rho;</em> is a correct compressordecompressor pair, establishing the lemma.</p>

    <p class="text-gray-300">We point out here that our lower bound extends to the setting where the simulator is not required to be admissible, by using a family of (standard) pseudo-random functions.</p>

    <p class="text-gray-300">Finally, the argument here generalizes to showing that functional encryption secure against an a-priori bounded number <em>q</em> = <em>q</em>(<em>&kappa;</em>) of collusions is impossible if one insists on small ciphertexts (namely, ciphertexts with much fewer than <em>q</em> bits). This matches the recent result of [<a href="#page-15-5">GVW12]</a> who construct such functional encryption schemes with ciphertexts of size polynomial in <em>q</em>.</p>

    <p class="text-gray-300"><strong>Corollary 4.4.</strong> <em>There exists a family of circuits G such that for every q</em> = <em>q</em>(<em>&kappa;</em>)<em>, there are no q-collusion resistant 1-</em>NA<em>-</em>SIM<em>-secure functional encryption schemes. with ciphertexts of size o</em>(<em>q</em>)<em>.</em></p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8"><strong>4.3 Extensions: Impossibility of Weaker Simulation-based Definitions</strong></h3>

    <p class="text-gray-300">The idea behind our impossibility result is robust enough to apply to various relaxations of the simulation-based security definition. In this section, we describe a number of such extensions of our result.</p>

    <p class="text-gray-300"><strong>Impossibility for the selective and random-input definitions.</strong> In the selective model, the adversary is required to commit to the secret key queries <em>G</em>1<em>, . . . , G<sup>q</sup></em> as well as the challenge input <em>x</em> before the setup phase. In particular, this means that the adversary will not be able to pick up the circuits or the challenge input depending on the system parameters. Variants of the selective security model are frequently considered in the literature as a relaxations of regular security notions (see, e.g., [<a href="#page-14-12">BB11,</a> <a href="#page-15-1">GPSW06</a>, <a href="#page-14-5">AFV11]</a>). Another relaxation one can consider is one where the adversary is not allowed to choose the circuits or the challenge, but instead, they are chosen uniformly at random.</p>

    <p class="text-gray-300">Our lower bound easily extends to these weaker notions, simply because the adversary we consider in the proof of Lemma <a href="#page-11-1">4.3</a> chooses the circuits and the challenge uniformly at random, and independent of the system parameters.</p>

    <p class="text-gray-300"><strong>Impossibility for the non-adaptive BSW Definition (the &quot;Rewinding Definition&quot;).</strong> The main difference between the definition proposed by [<a href="#page-14-2">BSW11]</a> and our definition in Section <a href="#page-6-1">2</a> is that whereas our definition restricts the simulator to be &quot;straight-line&quot;, the BSW definition allows the simulator to &quot;rewind&quot; the adversary and interact with it in order to generate the view. For more details, we direct the reader to the discussion after Definition <a href="#page-7-0">2.2.</a></p>

    <p class="text-gray-300">The proof of Lemma <a href="#page-11-1">4.3</a> transparently extends to the BSW definition. The adversary <em>A</em> is the same as in the proof. The compressor <strong>C</strong> runs the simulator, executing the code of the designated adversary <em>A</em> to compute the response whenever the simulator queries (&quot;rewinds&quot;) <em>A</em>. Also, since the simulator is admissible, the queries it makes are exactly the ones that the compressor knows the answer to. As before, we can make the impossibility result work for even non-admissible simulators by appealing to regular (rather than weak) PRFs.</p>

    <p class="text-gray-300"><strong>Impossibility for Secret-key Functional Encryption.</strong> In the setting of secret-key functional encryption (first considered by Shi, Shen and Waters [<a href="#page-16-8">SSW09</a>] in its predicate encryption variant), the encryption algorithm relies on the master secret key to produce the ciphertext for an input <em>x</em>.</p>

    <p class="text-gray-300">All our impossibility results carry over to the setting of secret key functional encryption since in the proof of Lemma <a href="#page-11-1">4.3</a>, neither the compressor nor the decompressor needs to run the encryption algorithm and generate ciphertexts.</p>

    </section>

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>Acknowledgments</strong></h2>

    <p class="text-gray-300">We thank Shafi Goldwasser, Yael Kalai, Raluca Ada Popa and Charles Rackoff for a number of insightful conversations that helped improve the presentation of the impossibility result. We would also like to thank Adam O'Neill and Amit Sahai for helpful pointers and discussions.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>References</strong></h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[ABV+12] Shweta Agrawal, Xavier Boyen, Vinod Vaikuntanathan, Panagiotis Voulgaris, and Hoeteck Wee. Functional encryption for threshold functions (or fuzzy IBE) from lattices. In <em>PKC</em>, 2012.</p></li>
      <li><p class="text-gray-300">[AFV11] Shweta Agrawal, David Mandell Freeman, and Vinod Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In <em>Asiacrypt</em>, 2011.</p></li>
      <li><p class="text-gray-300">[BB11] Dan Boneh and Xavier Boyen. Efficient selective identity-based encryption without random oracles. <em>J. Cryptology</em>, 24(4):659&ndash;693, 2011.</p></li>
      <li><p class="text-gray-300">[BF01] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. In <em>CRYPTO</em>, pages 213&ndash;229, 2001.</p></li>
      <li><p class="text-gray-300">[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In <em>Proceedings of the twentieth annual ACM symposium on Theory of computing</em>, STOC '88, pages 1&ndash;10, New York, NY, USA, 1988. ACM.</p></li>
      <li><p class="text-gray-300">[BMQU07] Michael Backes, J&uml;orn M&uml;uler-Quade, and Dominique Unruh. On the necessity of rewinding in secure multiparty computation. In <em>Proceedings of the 4th conference on Theory of cryptography</em>, TCC'07, pages 157&ndash;173, Berlin, Heidelberg, 2007. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[BMR90] Donald Beaver, Silvio Micali, and Phillip Rogaway. The round complexity of secure protocols (extended abstract). In <em>STOC</em>, pages 503&ndash;513, 1990.</p></li>
      <li><p class="text-gray-300">[BO12] Mihir Bellare and Adam O'Neill. Semantically-secure functional encryption: Possibility results, impossibility results and the quest for a general definition. Cryptology ePrint Archive, Report 2012/515, 2012.</p></li>
      <li><p class="text-gray-300">[BS05] Boaz Barak and Amit Sahai. How to play almost any mental game over the net concurrent composition via super-polynomial simulation. In <em>FOCS</em>, pages 543&ndash;552, 2005.</p></li>
      <li><p class="text-gray-300">[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In <em>TCC</em>, pages 253&ndash;273, 2011.</p></li>
      <li><p class="text-gray-300">[BW06] Xavier Boyen and Brent Waters. Anonymous hierarchical identity-based encryption (without random oracles). In <em>CRYPTO</em>, pages 290&ndash;307, 2006.</p></li>
      <li><p class="text-gray-300">[CHK03] Ran Canetti, Shai Halevi, and Jonathan Katz. A forward-secure public-key encryption scheme. In <em>EUROCRYPT</em>, pages 255&ndash;271, 2003.</p></li>
      <li><p class="text-gray-300">[Coc01] Clifford Cocks. An identity based encryption scheme based on quadratic residues. In <em>IMA Int. Conf.</em>, pages 360&ndash;363, 2001.</p></li>
      <li><p class="text-gray-300">[DKXY02] Yevgeniy Dodis, Jonathan Katz, Shouhuai Xu, and Moti Yung. Key-insulated public key cryptosystems. In <em>In EUROCRYPT</em>, pages 65&ndash;82. Springer-Verlag, 2002.</p></li>
      <li><p class="text-gray-300">[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In <em>STOC</em>, pages 416&ndash;426, 1990.</p></li>
      <li><p class="text-gray-300">[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. <em>J. ACM</em>, 33(4):792&ndash;807, 1986.</p></li>
      <li><p class="text-gray-300">[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In <em>FOCS</em>, pages 553&ndash;562, 2005.</p></li>
      <li><p class="text-gray-300">[GLW12] Shafi Goldwasser, Allison B. Lewko, and David A. Wilson. Bounded-collusion IBE from key homomorphism. In <em>TCC</em>, pages 564&ndash;581, 2012.</p></li>
      <li><p class="text-gray-300">[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In <em>ACM Conference on Computer and Communications Security</em>, pages 89&ndash;98, 2006.</p></li>
      <li><p class="text-gray-300">[GVW12] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Functional encryption with bounded collusions from multiparty computation. In <em>CRYPTO</em>, 2012. To appear.</p></li>
      <li><p class="text-gray-300">[HILL99] Johan H&#730;astad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. <em>SIAM J. Comput.</em>, 28(4):1364&ndash; 1396, 1999.</p></li>
      <li><p class="text-gray-300">[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In <em>EUROCRYPT</em>, pages 146&ndash; 162, 2008.</p></li>
      <li><p class="text-gray-300">[Lin04] Yehuda Lindell. Lower bounds and impossibility results for concurrent self composition. <em>the Journal of Cryptology</em>, 2004.</p></li>
      <li><p class="text-gray-300">[LOS+10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In <em>EUROCRYPT</em>, pages 62&ndash;91, 2010.</p></li>
      <li><p class="text-gray-300">[MPR06] Silvio Micali, Rafael Pass, and Alon Rosen. Input-indistinguishable computation. In <em>FOCS</em>, pages 367&ndash;378, 2006.</p></li>
      <li><p class="text-gray-300">[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In <em>CRYPTO</em>, pages 111&ndash;126, 2002.</p></li>
      <li><p class="text-gray-300">[O'N10] Adam O'Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. <a href="http://eprint.iacr.org/" target="_blank" rel="noopener noreferrer">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">[Pas03] Rafael Pass. Simulation in quasi-polynomial time and its application to protocol composition. In <em>EUROCRYPT</em>, pages 160&ndash;176, 2003.</p></li>
      <li><p class="text-gray-300">[PRS02] Manoj Prabhakaran, Alon Rosen, and Amit Sahai. Concurrent zero knowledge with logarithmic round-complexity. In <em>In 43rd FOCS</em>, pages 366&ndash;375, 2002.</p></li>
      <li><p class="text-gray-300">[PRV12] Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, <em>TCC</em>, volume 7194 of <em>Lecture Notes in Computer Science</em>, pages 422&ndash; 439. Springer, 2012.</p></li>
      <li><p class="text-gray-300">[PS04] Manoj Prabhakaran and Amit Sahai. New notions of security: achieving universal composability without trusted setup. In <em>STOC</em>, pages 242&ndash;251, 2004.</p></li>
      <li><p class="text-gray-300">[Sha84] Adi Shamir. Identity-based cryptosystems and signature schemes. In <em>CRYPTO</em>, pages 47&ndash;53, 1984.</p></li>
      <li><p class="text-gray-300">[SS10] Amit Sahai and Hakan Seyalioglu. Worry-free encryption: functional encryption with public keys. In <em>ACM Conference on Computer and Communications Security</em>, pages 463&ndash;472, 2010.</p></li>
      <li><p class="text-gray-300">[SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In <em>TCC</em>, pages 457&ndash;473, 2009.</p></li>
      <li><p class="text-gray-300">[SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In <em>EUROCRYPT</em>, pages 457&ndash;473, 2005.</p></li>
      <li><p class="text-gray-300">[SW08] Amit Sahai and Brent Waters. Slides on functional encryption. Power Point Presentation, 2008. http://www.cs.utexas.edu/~ bwaters/presentations/ files/functional.ppt, 2008.</p></li>
      <li><p class="text-gray-300">[Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In <em>FOCS</em>, pages 162&ndash;167, 1986.</p></li>
    </ul>

    <p class="text-gray-300"><strong>Definition A.1</strong> (NA-IND- and AD-IND-Security)<strong>.</strong> <em>Let FE be a functional encryption scheme for a family of circuits C. For every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, consider the following two experiments:</em></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Exp(0)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Exp(1)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE,A(1&kappa;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE,A(1&kappa;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">):</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">):</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Setup(1&kappa;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Setup(1&kappa;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1: (MPK,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1: (MPK,</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MSK)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">MSK)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Keygen(MSK,&middot;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Keygen(MSK,&middot;)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2: (x0, x1, st)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2: (x0, x1, st)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MPK)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MPK)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3: CT</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">3: CT</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Enc(MPK, x0)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">FE.Enc(MPK, x1)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(MSK,&middot;)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">O(MSK,&middot;)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4: b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4: b</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">A</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MPK,</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(MPK,</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CT, st)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CT, st)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">&larr;</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5: Output</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5: Output</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Define an <em>admissible adversary A</em> = (<em>A</em>1<em>, A</em>2) as one such that for each oracle query <em>C</em> of <em>A</em>, <em>C</em>(<em>x</em>0) = <em>C</em>(<em>x</em>1). <em>We distinguish between two cases of the above experiment:</em></p>

    <p class="text-gray-300"><em>1.</em> The adaptive experiment<em>, where the oracle O</em>(MSK<em>, &middot;</em>) = FE<em>.</em>Keygen(MSK<em>, &middot;</em>)<em>: the functional encryption scheme FE is said to be</em> indistinguishable-secure for one message against adaptive adversaries (1-AD-IND-secure, for short) if for every polynomial function  <span class="math">\\ell = \\ell(\\kappa)</span>  and every admissible p.p.t. admissible adversary  <span class="math">A = (A_1, A_2)</span> , the advantage of A defined as below is negligible in the security parameter  <span class="math">\\kappa</span> :</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Adv}_{\\mathcal{FE},A}(\\kappa) := \\big|\\Pr[\\mathsf{Exp}_{\\mathcal{FE},A}^{(0)}(1^\\kappa) = 1] - \\Pr[\\mathsf{Exp}_{\\mathcal{FE},A}^{(1)}(1^\\kappa) = 1]\\big|</span>$</p>

    <p class="text-gray-300">where the probability is over the random coins of the algorithms of the scheme  <span class="math">\\mathcal{FE}</span>  and that of A.</p>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>The non-adaptive experiment, where the oracle  <span class="math">\\mathcal{O}(\\mathsf{MSK},\\cdot)</span>  is the &quot;empty oracle&quot; that returns nothing: the functional encryption scheme  <span class="math">\\mathcal{FE}</span>  is said to be indistinguishable-secure for one message against non-adaptive adversaries (1-NA-IND-secure, for short) if for every admissible p.p.t. adversary  <span class="math">A = (A_1, A_2)</span> , the advantage of A defined as above is negligible in the security parameter  <span class="math">\\kappa</span> .</li>
    </ul>

    <p class="text-gray-300">We do not distinguish between one and many message security since this definition composes [GVW12].</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Many-Message Simulation-based Definition of Security</h2>

    <p class="text-gray-300"><strong>Definition B.1</strong> (many-NA-SIM- and many-AD-SIM- Security). Let  <span class="math">\\mathcal{FE}</span>  be a functional encryption scheme for a family of circuit  <span class="math">\\mathcal{C}</span> . Let  <span class="math">U_x(\\cdot)</span>  denote the universal oracle that on input C returns  <span class="math">U_x(C) = C(x)</span> . Consider a p.p.t. adversary  <span class="math">A = (A_1, A_2)</span>  and a stateful p.p.t. simulator Sim. Consider the following two experiments:</p>

    <pre><code class="language-text">\\underline{\\operatorname{Exp}^{\\operatorname{real}}_{\\mathcal{FE},A}(1^{\\kappa})} : \\underline{\\operatorname{Exp}^{\\operatorname{ideal}}_{\\mathcal{FE},\\operatorname{Sim}}(1^{\\kappa})} : \\\\ 1: (\\operatorname{MPK}, \\operatorname{MSK}) \\leftarrow \\operatorname{FE.Setup}(1^{\\kappa}) \\\\ 2: (\\{x_i\\}_{i \\in [\\ell]}, st) \\leftarrow A_1^{\\operatorname{FE.Keygen}(\\operatorname{MSK}, \\cdot)}(\\operatorname{MPK}) \\\\ 3: \\operatorname{CT}_i \\leftarrow \\operatorname{FE.Enc}(\\operatorname{MPK}, x_i) \\ \\ for \\ \\ all \\ \\ i \\in [\\ell] \\\\ 4: \\ \\alpha \\leftarrow A_2^{\\mathcal{O}(\\operatorname{MSK}, \\cdot)}(\\operatorname{MPK}, \\{\\operatorname{CT}_i\\}_{i \\in [\\ell]}, st) \\\\ 5: \\ \\ \\operatorname{Output}(\\{x_i\\}_{i \\in [\\ell]}, \\alpha) \\\\ 1: \\ \\operatorname{MPK} \\leftarrow \\operatorname{Sim}(1^{\\kappa}) \\\\ 2: (\\{x_i\\}_{i \\in [\\ell]}, st) \\leftarrow A_1^{\\operatorname{Sim}(\\cdot)}(\\operatorname{MPK}) \\\\ 3: \\{\\operatorname{CT}_i\\}_{i \\in [\\ell]} \\leftarrow \\operatorname{Sim}^{\\{U_{x_i}(\\cdot)\\}_{i \\in [\\ell]}}(\\{1^{|x_i|}\\}_{i \\in [\\ell]}) \\\\ 4: \\ \\alpha \\leftarrow A_2^{\\mathcal{O}&#x27;(\\cdot)}(\\operatorname{MPK}, \\{\\operatorname{CT}_i\\}_{i \\in [\\ell]}, st) \\\\ 5: \\ \\ \\operatorname{Output}(\\{x_i\\}_{i \\in [\\ell]}, \\alpha) \\\\ 5: \\ \\ \\operatorname{Output}(\\{x_i\\}_{i \\in [\\ell]}, \\alpha)
</code></pre>

    <p class="text-gray-300">We distinguish between two cases of the above experiment:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The adaptive experiment, where:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the oracle  <span class="math">\\mathcal{O}(\\mathsf{MSK},\\cdot) = \\mathsf{FE}.\\mathsf{Keygen}(\\mathsf{MSK},\\cdot)</span> , and</li>
      <li>the oracle  <span class="math">\\mathcal{O}&#x27;(\\cdot)</span>  is the simulator, namely  <span class="math">\\operatorname{Sim}^{\\{U_{x_i}(\\cdot)\\}_{i\\in[\\ell]}}(\\cdot)</span> .</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">We call a stateful simulator algorithm Sim admissible if, on each input C, Sim makes just a single query to its oracle  <span class="math">U_x(\\cdot)</span>  on C itself.</p>

    <p class="text-gray-300">The functional encryption scheme  <span class="math">\\mathcal{FE}</span>  is then said to be simulation-secure for many messages against adaptive adversaries (many-AD-SIM-secure, for short) if there is an admissible stateful</p>

    <p class="text-gray-300"><em>p.p.t. simulator</em> Sim <em>such that for every polynomial function &#8467;</em> = <em>&#8467;</em>(<em>&kappa;</em>)<em>, every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the following two distributions are computationally indistinguishable:</em></p>

    <p class="text-gray-300"><span class="math">$\\left\\{ \\mathsf{Exp}^{\\mathsf{real}}_{\\mathcal{FE},A}(1^{\\kappa}) \\right\\}_{\\kappa \\in \\mathbb{N}} \\overset{c}{\\approx} \\left\\{ \\mathsf{Exp}^{\\mathsf{ideal}}_{\\mathcal{FE},\\mathrm{Sim}}(1^{\\kappa}) \\right\\}_{\\kappa \\in \\mathbb{N}}</span>$</p>

    <p class="text-gray-300"><em>2.</em> The non-adaptive experiment<em>, where the oracles O</em>(MSK<em>, &middot;</em>) <em>and O&prime;</em> (<em>&middot;</em>) <em>are both the &quot;empty oracles&quot; that return nothing.</em></p>

    <p class="text-gray-300"><em>The functional encryption scheme FE is then said to be simulation-secure for many messages against non-adaptive adversaries (many-</em>NA<em>-</em>SIM<em>-secure, for short) if there is an</em> admissible <em>stateful p.p.t. simulator</em> Sim <em>such that for every polynomial function &#8467;</em> = <em>&#8467;</em>(<em>&kappa;</em>)<em>, every p.p.t. adversary A</em> = (<em>A</em>1<em>, A</em>2)<em>, the two distributions above are computationally indistinguishable.</em></p>

    <p class="text-gray-300">We define many-AD-USIM and many-NA-USIM identically to the above definition, except with computationally unbounded simulator.</p>

    </section>

    <section id="app-c" class="mb-10">
      <h2 class="text-2xl font-bold"><strong>C Indistinguishability and Unbounded Simulation</strong></h2>

    <p class="text-gray-300">In this section, we put forth the notion of <em>unbounded-simulation secure</em> functional encryption. We argue that this is a very natural notion of security, with counterparts in the worlds of multiparty computation and zero knowledge [<a href="#page-15-8">Pas03</a>, <a href="#page-16-6">PS04,</a> <a href="#page-14-9">BS05]</a>. Unbounded simulation security further elucidates the power and limitations of indistinguishability-based definitions, and captures the spirit of some known separations (see below).</p>

    <p class="text-gray-300">The definition of unbounded-simulation security (in both the adaptive and non-adaptive settings) is the same as Definition <a href="#page-7-0">2.2,</a> except that the simulator is not restricted to run in polynomial time.</p>

      <h3 id="app-c.1" class="text-xl font-semibold mt-8"><strong>C.1 Relationship between SIM, USIM and IND</strong></h3>

    <p class="text-gray-300"><strong>Theorem C.1.</strong> <em>Let FE be a functional encryption scheme for a family of circuits C. Then, if</em> FE <em>is</em> AD<em>-</em>SIM <em>(resp.</em> NA<em>-</em>SIM<em>) secure then it is also</em> AD<em>-</em>USIM <em>(resp.</em> NA<em>-</em>USIM<em>) secure. In addition, if</em> FE <em>is</em> AD<em>-</em>USIM<em>(resp.</em> NA<em>-</em>USIM<em>) secure then it is</em> AD<em>-</em>IND <em>(resp.</em> NA<em>-</em>IND<em>) secure.</em></p>

    <p class="text-gray-300"><em>Proof.</em> AD-SIM(NA-SIM) <em>&rArr;</em> AD-USIM(NA-USIM): This claim is trivial since the unbounded simulator can just run the poly-time simulator, in both the adaptive and non-adaptive cases.</p>

    <p class="text-gray-300">AD-USIM(NA-USIM) <em>&rArr;</em> AD-IND(NA-IND): We prove this claim by showing the contrapositive. Let <em>A</em> = (<em>A</em>1<em>, A</em>2) be the adversary that breaks AD-IND(resp. NA-IND) security of the <em>FE</em> scheme. We construct an adversary <em>B</em> = (<em>B</em>1<em>, B</em>2) from <em>A</em>. In our construction, if <em>A</em> is a AD-IND (resp. NA-IND) adversary, then <em>B</em> is a AD-USIM (resp. NA-USIM) adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull; B</em> FE<em>.</em>Keygen(MSK<em>,&middot;</em>) 1 (MPK): Run <em>A</em> FE<em>.</em>Keygen(MSK<em>,&middot;</em>) 1 (MPK). Answer <em>A</em>1's key queries using FE<em>.</em>Keygen oracle. Finally, <em>A</em><sup>1</sup> outputs two messages <em>x</em>0<em>, x</em><sup>1</sup> and a state <em>sta</em>. Now, choose a random bit <em>b</em> and output (<em>x, st</em>) = (<em>xb,</em> [<em>sta, x</em>0<em>, x</em>1]).</li>
      <li><em>&bull; B O</em>(MSK<em>,&middot;</em>) 2 (MPK<em>,</em> CT<em>, st</em>): Invoke <em>A O</em>(MSK<em>,&middot;</em>) 2 (MPK<em>,</em> CT<em>, sta</em>) and output whatever bit <em>b &prime;</em> it outputs. In the adaptive case, if <em>A</em><sup>2</sup> makes any oracle queries, answer them using own oracle.</li>
    </ul>

    <p class="text-gray-300">The output of the real experiment is (<em>xb, st</em> = [<em>sta, x</em>0<em>, x</em>1]<em>, &alpha;</em> = <em>b &prime; , C</em>1<em>, . . . , Cq</em>). Hence, with probability significantly greater than a half <em>b</em> = <em>b &prime;</em> and the distinguisher can verify this. Now we claim that there is no unbounded simulator Sim<em><sup>u</sup></em> for the adversary (<em>B</em>1<em>, B</em>2) in the adaptive or non-adaptive case. In particular, we argue that the simulator Sim<em><sup>u</sup></em> cannot guess bit <em>b &prime;</em> with probability better than a half. We observe:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull;</em> The IND adversary <em>A</em> = (<em>A</em>1<em>, A</em>2) is admissible, hence, for all queries <em>{C &prime; i }i&isin;</em>[<em><sup>q</sup> &prime;</em> that <em>A</em> makes to <em>B</em>, and hence <em>B</em> makes to Sim<em>u</em>, we have that <em>C &prime; i</em> (<em>x</em>0) = <em>C &prime; i</em> (<em>x</em>1). The view of Sim<em><sup>u</sup></em> is statistically independent of the challenge bit <em>b</em>.</li>
      <li><em>&bull;</em> Since the queries <em>C</em>1<em>, . . . , C<sup>q</sup></em> are part of the output of the experiment, Sim<em><sup>u</sup></em> is restricted to make admissible queries only to the function oracle, otherwise a distinguisher can easily distinguish between the real and ideal worlds. Thus, it must be the case that <em>Ci</em>(<em>x</em>0) = <em>Ci</em>(<em>x</em>1)<em>, &forall;i &isin;</em> [<em>q</em>]. Hence, the view of Sim<em><sup>u</sup></em> is also statistically independent of the challenge bit <em>b</em>.</li>
    </ul>

    <p class="text-gray-300">Putting these together, we deduce that the view of the simulator is statistically independent of the challenge bit <em>b</em>, thus the probability it guesses <em>b</em> correctly is at most 1<em>/</em>2. Therefore, the simulator Sim<em><sup>u</sup></em> cannot produce the output indistinguishable from the real experiment.</p>

      <h3 id="app-c.2" class="text-xl font-semibold mt-8"><strong>C.2 Impossibility of</strong> AD<strong>-</strong>USIM <strong>IBE</strong></h3>

    <p class="text-gray-300">We observe that the impossibility of realizing the IBE functionality under many-AD-SIM as shown in [<a href="#page-14-2">BSW11,</a> Section 5.1] (which is in turn similar to the impossibility result for non-committing encryption given in [<a href="#page-15-15">Nie02]</a>) extends to many-AD-USIM. For self containment, we provide a recap of the argument.</p>

    <p class="text-gray-300">Let <em>&kappa;</em> denote the security parameter and <em>&#8467;</em> be an upper bound on the secret key length produced by FE<em>.</em>Keygen for security parameter <em>&kappa;</em>. Assume that both the identity and the payload message are bits. Then, the real world adversary behaves as follows (refer to Definition <a href="#page-7-0">2.2</a>) (1) <em>A</em><sup>1</sup> makes no secret key queries and outputs <strong>x</strong> = <em>{</em>(0<em>, x</em>0<em>,</em> 0)<em>, . . . ,</em>(0<em>, x&#8467;</em>+<em>&kappa;</em>)<em>}</em> where each <em>x<sup>i</sup> , i &isin;</em> [<em>&#8467;</em> + <em>&kappa;</em>] is a uniformly random bit, and all payload messages correspond to identity 0. (2) The adaptive adversary <em>A</em><sup>2</sup> requests for the SK0.</p>

    <p class="text-gray-300">Note that the admissible simulator Sim can only query the function oracle <em>Ux<sup>i</sup></em> (<em>&middot;</em>) after <em>A</em><sup>2</sup> requests the secret key SK0, and thus cannot learn the payload bits until such point. However, Sim has to simulate the tuple of <em>&#8467;</em> + <em>&kappa;</em> ciphertexts before it sees the actual payload bits. Thus, the simulator has to produce a fixed string of CTs which, upon decryption with an <em>&#8467;</em> bit secret key, need to produce an <em>arbitrary &#8467;</em> + <em>&kappa;</em> bits &ndash; which is impossible. This argument holds even if the simulator is computationally unbounded, hence we conclude that many-AD-USIM is impossible, even for IBE.</p>

      <h3 id="app-c.3" class="text-xl font-semibold mt-8"><strong>C.3 Illustrative Examples and Discussion</strong></h3>

    <p class="text-gray-300">In this section we discuss some examples to separate the various notions of security.</p>

    <p class="text-gray-300">AD<strong>-</strong>SIM <strong>and</strong> AD<strong>-</strong>USIM : We observe the following example from <a href="#page-14-2">[BSW11</a>, Section 4.2] separating AD-SIM and AD-IND also separates AD-SIM and AD-USIM. <sup>8</sup> Let <em>&pi;</em> be a one-way permutation and consider the circuit family <em>C</em> consisting of a single circuit <em>C</em> defined as follows:</p>

    <p class="text-gray-300"><span class="math">$C(x) = \\pi(x)</span>$</p>

    <p class="text-gray-300"><sup>8</sup>We need to modify the construction to account for the fact that we do not admit the &quot;empty&quot; key.</p>

    <p class="text-gray-300">Note that this circuit satisfies our &quot;litmus test&quot; in <a href="#page-4-0">1.2</a> for checking if IND security is inadequate <em>&pi;</em>(<em>x</em>) hides <em>x</em> from a computationally bounded adversary, but reveals <em>x</em> to an unbounded adversary. Now, consider the FE<em>.</em>Enc algorithm that outputs a public-key encryption of <em>x</em> on input <em>x</em>; FE<em>.</em>Keygen algorithm that outputs the secret key for the public-key encryption on input <em>C</em>; FE<em>.</em>Dec recovers <em>x</em> and outputs <em>&pi;</em>(<em>x</em>). It was shown in [<a href="#page-14-2">BSW11]</a> that this scheme AD-IND-secure but not AD-SIM-secure. We observe that this scheme is also AD-USIM-secure, provided the underlying encryption scheme is &quot;non-committing&quot; (c.f. <a href="#page-15-5">[GVW12</a>, Section 4.1]). The simulator proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>&bull;</em> If the adversary makes a secret key query before seeing the ciphertext, then the simulator learns <em>&pi;</em>(<em>x</em>) by querying the oracle on <em>C</em>, and then computes <em>x</em> via &quot;brute force&quot; and encrypts it.</li>
      <li><em>&bull;</em> Otherwise, the simulator generates a &quot;non-committing&quot; simulated ciphertext. If the adversary makes a secret key query after seeing the ciphertext, then the simulator learns <em>&pi;</em>(<em>x</em>) by querying the oracle on <em>C</em>, computes <em>x</em> via &quot;brute force&quot;, and generates a consistent secret key.</li>
    </ul>

    <p class="text-gray-300">AD<strong>-</strong>IND <strong>and</strong> AD<strong>-</strong>USIM : We do not have a natural example of a scheme which is AD-INDsecure but not AD-USIM-secure, which we leave as an open problem. We point out that the naive approach of replacing the one-way permutation in the preceding example with a collision resistant hash function does not seem to work; if the encryptor picks the hash function, then the adversary could potentially pick a &quot;bad&quot; hash function for which it knows a pair of collisions.</p>

    <p class="text-gray-300"><strong>Summary.</strong> We summarize some of the properties of USIM security: (1) It clarifies the inadequacy of indistinguishability-based security definitions as pointed out in [<a href="#page-14-2">BSW11,</a> Section 4.2]; specifically, the statement therein that &quot;game-based formulation essentially ignores any computational hiding properties of the circuits, and therefore offers no security guarantees that could be meaningfully combined with such computational considerations&quot;, is really a statement about USIM security. (2) It potentially admits realizations for a large class of circuits; it allows us to circumvent our 1-NA-SIM lower bound, but is nonetheless ultimately limited by many-AD-SIM lower bound for IBE. (3) Unbounded simulation is a natural notion, with analogues in zero knowledge and secure computation [<a href="#page-15-8">Pas03</a>, <a href="#page-16-6">PS04</a>, <a href="#page-14-9">BS05</a>], and comparisons with these can aid our understanding of functional encryption. (4) For certain circuit families, USIM may be &quot;good enough&quot;; understanding when this happens could further clarify existing constructions.</p>

    </section>
`;
---

<BaseLayout title="Functional Encryption: New Perspectives and Lower Bounds (2012/468)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/468
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="functional-encryption-new-perspectives-and-lower-bounds-2012" />
  </article>
</BaseLayout>
