---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2012/468';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Functional Encryption: New Perspectives and Lower Bounds';
const AUTHORS_HTML = 'Shweta Agrawal, Sergey Gorbunov, Vinod Vaikuntanathan, Hoeteck Wee';

const CONTENT = `    <p class="text-gray-300">Functional Encryption: New Perspectives and Lower Bounds</p>

    <p class="text-gray-300">Shweta Agrawal * Sergey Gorbunov† Vinod Vaikuntanathan‡ Hoeteck Wee§</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">Functional encryption is an emerging paradigm for public-key encryption that enables fine-grained control of access to encrypted data. In this work, we present new perspectives on security definitions for functional encryption, as well as new lower bounds on what can be achieved. Our main contributions are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We show a lower bound for functional encryption that satisfies a weak (non-adaptive) simulation-based security notion, via pseudo-random functions. This is the <em>first</em> lower bound that exploits <em>unbounded</em> collusions in an essential way.</li>

      <li>We put forth and discuss a simulation-based notion of security for functional encryption, with an unbounded simulator (called USIM). We show that this notion interpolates indistinguishability and simulation-based security notions, and has strong correlations to results and barriers in the zero-knowledge and multi-party computation literature.</li>

    </ul>

    <p class="text-gray-300">Keywords: Functional encryption, Lower Bounds, Pseudo-Random Functions, Simulation-based Definitions.</p>

    <p class="text-gray-300">*UCLA. Email: shweta@cs.ucla.edu. Research supported in part from a DARPA/ONR PROCEED award, NSF grants 1136174, 1118096, 1065276, 0916574 and 0830803, a Xerox Faculty Research Award, a Google Faculty Research Award, an equipment grant from Intel, and an Okawa Foundation Research Grant (Amit Sahai). This material is based upon work supported by the Defense Advanced Research Projects Agency through the U.S. Office of Naval Research under Contract N00014-11-1-0389. The views expressed are those of the author and do not reflect the official policy or position of the Department of Defense, the National Science Foundation, or the U.S. Government.</p>

    <p class="text-gray-300">†University of Toronto. Email: sgorbunov@cs.toronto.edu. Supported by NSERC Alexander Graham Bell Graduate Scholarship.</p>

    <p class="text-gray-300">‡University of Toronto. Email: vinodv@cs.toronto.edu. Supported by an NSERC Discovery Grant and by DARPA under Agreement number FA8750-11-2-0225. The U.S. Government is authorized to reproduce and distribute reprints for Governmental purposes notwithstanding any copyright notation thereon. The views and conclusions contained herein are those of the author and should not be interpreted as necessarily representing the official policies or endorsements, either expressed or implied, of DARPA or the U.S. Government.</p>

    <p class="text-gray-300">§George Washington University. Email: hoeteck@alum.mit.edu. Supported by NSF CAREER Award CNS-1237429.</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">Functional encryption <em>[x21, x22]</em> is a new paradigm for public-key encryption that enables fine-grained control of access to encrypted data. It extends several previous notions, most notably identity-based encryption <em>[x23, x1, x10]</em>, and provides, for instance, the ability to generate and release secret keys associated with a keyword that can decrypt only those documents that contain the keyword. More generally, functional encryption allows the owner of a “master” secret key to release restricted secret keys that reveal a specific function of encrypted data. This stands in stark contrast to traditional encryption, where access to the encrypted data is all or nothing: namely, given the secret key, one can decrypt and read the entire plaintext, but without it, nothing about the plaintext is revealed at all (other than its length).</p>

    <h5 id="sec-1" class="text-base font-semibold mt-4">Functional Encryption.</h5>

    <p class="text-gray-300">A functional encryption scheme for a circuit family <em>[x3, x15]</em> <span class="math">\\mathcal{C}</span>, associates secret keys <span class="math">\\mathsf{SK}_{C}</span> with every circuit <span class="math">C\\in\\mathcal{C}</span> and ciphertext <span class="math">\\mathsf{CT}</span> with every input message <span class="math">x</span>.</p>

    <p class="text-gray-300">In broad terms, functional encryption requires that the owner of a secret key <span class="math">\\mathsf{SK}_{C}</span> and a ciphertext <span class="math">\\mathsf{CT}</span> (corresponding to an input message <span class="math">x</span>) be able to compute <span class="math">C(x)</span>, but learn nothing else about <span class="math">x</span> itself. (Typically, and throughout this work, we assume that the circuit family <span class="math">\\mathcal{C}</span> as well as the circuit queries <span class="math">C</span> are public.)</p>

    <p class="text-gray-300">Moreover, security should hold in the presence of collusions amongst “key holders”, that is, malicious users should not be able to combine their secret keys to learn unauthorized information. More formally, a collusion of users that hold secret keys <span class="math">\\mathsf{SK}_{C_{1}},\\ldots,\\mathsf{SK}_{C_{q}}</span> and an encryption of <span class="math">x</span> should learn nothing else about <span class="math">x</span> apart from <span class="math">C_{1}(x),\\ldots,C_{q}(x)</span>, for any polynomial <span class="math">q</span>.</p>

    <p class="text-gray-300">An important subclass of functional encryption is that of public-index predicate encryption. Here, the input <span class="math">x</span> is a pair <span class="math">(\\mathsf{ind},\\mu)</span> where <span class="math">\\mathsf{ind}</span> is an index and <span class="math">\\mu</span> the payload message. Let <span class="math">P</span> be a Boolean predicate defined on indices, the circuit family <span class="math">\\mathcal{C}</span> is given by:</p>

    <p class="text-gray-300">\\[ C_{P}(\\mathsf{ind},\\mu)=\\left\\{\\begin{array}[]{ll}(\\mathsf{ind},\\mu)&\\text{ if }P(\\mathsf{ind})=1\\\\ (\\mathsf{ind},\\bot)&\\text{ otherwise}\\end{array}\\right. \\]</p>

    <p class="text-gray-300">Even though public index predicate encryption seems like a weak object, it already captures identity-based encryption, and is also very useful in constructing protocols for verifiably delegating computation as shown recently by Parno, Raykova and Vaikuntanathan <em>[x20]</em>.</p>

    <p class="text-gray-300">Predicate encryption captures and generalizes a large number of previous constructions, including identity-based encryption (IBE) <em>[x23, x1, x10, x6]</em>, fuzzy IBE <em>[x21, ABV^{+}12]</em>, attribute-based encryption (ABE) <em>[x12, LOS^{+}10]</em>, and inner product encryption <em>[x17, LOS^{+}10, x1]</em>. Specifically, IBE corresponds to <span class="math">P</span> encoding a point function. Moreover, essentially all known constructions are examples of public-index predicate encryption schemes or its variants, with a few exceptions – constructions in <em>[x1, x6, x17]</em> achieve a stronger private-index security notion in which the index <span class="math">\\mathsf{ind}</span> also remains hidden from the adversary.</p>

    <h5 id="sec-2" class="text-base font-semibold mt-4">Recent Work.</h5>

    <p class="text-gray-300">Boneh, Sahai and Waters <em>[x3]</em> and O’Neill <em>[x15]</em> were the first to put forth a general definitional framework for functional encryption. They considered two security notions for functional encryption, namely: indistinguishability (IND) based security and simulation (SIM) based security. The former stipulates that it is infeasible to distinguish encryptions of any two</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">realizable for public-index</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">realizable for all circuits</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xx-yy-IND</td>

            <td class="px-3 py-2 border-b border-gray-700">open</td>

            <td class="px-3 py-2 border-b border-gray-700">open</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xx-yy-SIM (xx = 1 OR yy = NA) many-AD-SIM</td>

            <td class="px-3 py-2 border-b border-gray-700">open no [BSW11]</td>

            <td class="px-3 py-2 border-b border-gray-700">no (Section 4) no ←</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">xx-yy-USIM (xx = 1 OR yy = NA) many-AD-USIM</td>

            <td class="px-3 py-2 border-b border-gray-700">open no [BSW11] #</td>

            <td class="px-3 py-2 border-b border-gray-700">open no ←</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Summary of results and open problems. Results from this work are marked with boldface. Results implicit in previous works are marked with  <span class="math">\\sharp</span> . Results that are trivially implied by results in a previous column are marked with  <span class="math">\\leftarrow</span> . The second and third columns indicate whether the definition is realizable for all public-index predicate encryption schemes (e.g. IBE) and for all circuits respectively. USIM refers to the notion of unbounded simulation discussed in Section 1.2.</p>

    <p class="text-gray-300">messages, without getting a secret key that decrypts the ciphertexts to distinct values; the latter stipulates the existence of an efficient simulator that given  <span class="math">C_1(x), \\ldots, C_q(x)</span> , outputs the view of the colluders that are given an encryption of  <span class="math">x</span>  as well as secret keys  <span class="math">\\mathsf{SK}_{C_1}, \\ldots, \\mathsf{SK}_{C_q}</span> .</p>

    <p class="text-gray-300">Both of these notions may be further refined in two ways: adaptive (AD) versus non-adaptive (NA) which capture whether the adversary's queries to the key derivation oracle may or may not depend on the challenge ciphertext; and one versus many, referring to whether the adversary receives a single or multiple challenge ciphertexts. Together, these give rise to eight security notions xx-yy-zzz, where xx ∈ {1, many}, yy ∈ {NA, AD}, and zzz ∈ {IND, SIM}.</p>

    <p class="text-gray-300">We note that in general, indistinguishability based security provides a weaker guarantee than simulation based security (that is, xx-yy-SIM implies xx-yy-IND and xx-yy-IND does not imply xx-yy-SIM in general); on the other hand, we have that 1-yy-IND implies many-yy-IND. Boneh, et al. [BSW11] pointed out that indistinguishability based security is vacuous and inadequate for certain circuit families, which indicate that we should opt for simulation-based security whenever possible. O'Neill [O'N10] showed that NA-IND and NA-SIM are equivalent for some subclass of circuit families that are roughly speaking, "easy to invert".</p>

    <p class="text-gray-300">All prior positive results achieve many-AD-IND security or relaxations there-of. The only known impossibility result we have for general functional encryption is that of Boneh et al. [BSW11] for realizing the IBE functionality under many-AD-SIM security. In particular, in light of known results, it is entirely conceivable that we can realize functional encryption for all poly-size circuits under either 1-AD-SIM security (thus 1-AD-IND and many-AD-IND security) or many-NA-SIM security.</p>

    <p class="text-gray-300">In this work, we narrow the gap between existing security definitions for functional encryption, as well as that between existing constructions and impossibility results. Our results are as follows.</p>

    <p class="text-gray-300">1.1 New Lower Bound: Impossibility for Simulation-based Definitions</p>

    <p class="text-gray-300">Our main result rules out general functional encryption under the one message secure, non-adaptive simulation definition (1-NA-SIM). In particular, this rules out both of the scenarios presented at the end of the preceding section (i.e. 1-AD-SIM or many-NA-SIM for all circuits) in a strong sense. This is the <em>first</em> lower bound that exploits <em>unbounded</em> collusions in an essential way. We compare the impossibility result from <em>[x1]</em> with ours in Figure 2.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Theorem 1.1 (Informal).</h6>

    <p class="text-gray-300">There exists a circuit family <span class="math">\\mathcal{C}</span> for which there is no <span class="math">1</span>-NA-SIM-secure function encryption scheme.</p>

    <p class="text-gray-300">Specifically, assuming the existence of a family of weak pseudo-random function <span class="math">\\mathsf{wPRF}(\\cdot,\\cdot)</span>, we show that there does not exist a functional encryption scheme for the family:</p>

    <p class="text-gray-300"><span class="math">C_{d}(x)=\\mathsf{wPRF}(x,d),\\text{where the input message </span>x<span class="math"> is the PRF seed}</span></p>

    <p class="text-gray-300">We show that the ciphertext size in a 1-NA-SIM-secure scheme realizing this circuit family must grow with the size of the collusion; this yields a contradiction, since the scheme must handle unbounded collusions. In fact, the result is unconditional since any non-trivial functional encryption scheme gives rise to a one-way function and thus pseudo-random functions.</p>

    <p class="text-gray-300">The key observation is as follows. Suppose the adversary requests for <span class="math">q</span> secret keys corresponding to random inputs <span class="math">C_{d_{1}},\\ldots,C_{d_{q}}</span> and then requests for an encryption of a random <span class="math">x</span>. Then, the simulated ciphertext together with the <span class="math">q</span> simulated secret keys constitute a description of the values <span class="math">\\mathsf{wPRF}(x,d_{1}),\\ldots,\\mathsf{wPRF}(x,d_{q})</span>, which is essentially a sequence of <span class="math">q</span> truly random bits via pseudo-randomness. By a standard information-theoretic argument, this means that the length of the ciphertext plus the secret keys must grow with <span class="math">q</span>. To obtain a lower bound on the ciphertext size, we carefully exploit the fact that the simulator has to generate the secret keys before it sees the output of <span class="math">\\mathsf{wPRF}(x,\\cdot)</span>. Then, the simulator has to generate a small ciphertext that “explains” all these pseudorandom values which is impossible using a compressibility argument. More generally, we show that (1) weak pseudo-random family is “incompressible”, and (2) NA-SIM-secure functional encryption only exists for “compressible” circuit families. (In particular, the circuit family for all <em>public-index</em> predicate encryption is compressible.)</p>

    <p class="text-gray-300">This idea is reminiscent of the obfuscation impossibility result of Goldwasser and Kalai <em>[x10]</em>, although the precise settings are quite different (in particular, functional encryption and program obfuscation seem incomparable, although related, objects).</p>

    <h5 id="sec-4" class="text-base font-semibold mt-4">Implications.</h5>

    <p class="text-gray-300">The basic idea described above can be extended to a lower bound for even weaker forms of the simulation-based definition, including (a non-adaptive variant of) the definition of Boneh, Sahai and Waters <em>[x1]</em>. Here, we mention yet another implication of this idea.</p>

    <p class="text-gray-300">Gorbunov, Vaikuntanathan and Wee <em>[x11]</em> recently presented a 1-AD-SIM-secure functional encryption scheme for all circuits, assuming that the adversary can only corrupt an a-priori bounded number of users (and thus, get the corresponding secret keys). One of the shortcomings of their bounded-collusion security notion as well as their construction is that the parameters of the system, and especially the size of the ciphertext depends on the collusion bound <span class="math">q</span>. A natural question is whether their ciphertexts can be made to have size independent of <span class="math">q</span> (or, at the very least, <span class="math">o(q)</span>). Indeed, in light of the results of Dodis, Katz, Xu and Yung <em>[x12]</em> and most recently,</p>

    <p class="text-gray-300">Goldwasser, Lewko and Wilson [GLW12] in the context of bounded-collusion IBE, one might expect that achieving "short" ciphertexts is actually be possible in general.</p>

    <p class="text-gray-300">Unfortunately, our techniques result in a strong negative answer to this question.</p>

    <p class="text-gray-300">Corollary 1.2. There exists a family of circuits  <span class="math">\\mathcal{C}</span>  such that for every  <span class="math">q = q(\\kappa)</span> , there are no  <span class="math">q</span> -collusion resistant 1-NA-SIM-secure functional encryption schemes with ciphertexts of size  <span class="math">o(q)</span> .</p>

    <h2 id="sec-5" class="text-2xl font-bold">1.2 New Perspectives: Unbounded Simulation</h2>

    <p class="text-gray-300">The preceding lower bound together with those of Boneh, Sahai and Waters [BSW11] show that even fairly weak simulation-based definitions of functional encryption are unachievable for a large and natural class of circuits. This state of affairs begs the question:</p>

    <p class="text-gray-300">What is a meaningful and generally realizable security notion for functional encryption?</p>

    <p class="text-gray-300">While we do not provide a definitive answer to this question in our work, we firmly believe that the quest for the right definition should incorporate insights from secure computation and zero knowledge. Indeed, several recent works [GVW12, SS10] exploited techniques and insights from secure computation [Yao86, BGW88, BMR90] to derive general feasibility results for functional encryption with bounded collusions.</p>

    <p class="text-gray-300">We put forth USIM security, where the simulator has unbounded computational power. In particular, this would allow us to circumvent our lower bound in the previous section. Similar notions have been considered for zero knowledge and secure computation [Pas03, PS04, BS05].</p>

    <p class="text-gray-300">Before presenting our results for USIM security, we first provide an intuitive interpretation of what USIM security buys us, via the real/ideal paradigm. Recall that polynomial-time simulation-based security for functional encryption guarantees that against a computational bounded adversary holding a secret key  <span class="math">\\mathsf{SK}_C</span> , an encryption of  <span class="math">x</span>  leaks no more information about  <span class="math">x</span>  than what an efficient adversary can deduce given  <span class="math">C(x)</span>  (and  <span class="math">C</span> ); allowing unbounded simulation means that an encryption of  <span class="math">x</span>  leaks no more information about  <span class="math">x</span>  than what a computationally unbounded adversary can deduce given  <span class="math">C(x)</span>  (and  <span class="math">x</span> ). Indeed, in the case of public-index predicate encryption,  <span class="math">C(x)</span>  does hide  <span class="math">x</span>  completely against a computationally unbounded adversary that only holds keys for which the predicate is false. One could even make the case that for public-index predicate encryption, USIM security is "as good as" SIM security! On the other hand, for circuits that only hide information about  <span class="math">x</span>  computationally, USIM security would be inadequate and SIM security remains the desirable notion.</p>

    <p class="text-gray-300">Next, we establish basic relations between USIM security and SIM, IND security, namely it is "sandwiched" between the two, that is, for  <span class="math">\\mathsf{yy} \\in \\{\\mathsf{NA}, \\mathsf{AD}\\}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">y y - I N D \\Leftarrow y y - U S I M \\Leftarrow y y - S I M</span></div>

    <p class="text-gray-300">This inclusion yields a simple "litmus test" for checking if IND security is inadequate for a circuit family  <span class="math">\\mathcal{C}</span> : IND security is inadequate whenever USIM security is inadequate, namely  <span class="math">C(x)</span>  reveals more information about  <span class="math">x</span>  to an unbounded adversary than an efficient adversary.</p>

    <p class="text-gray-300">Furthermore, with this notion in mind, we refine and further clarify two results in [BSW11]:</p>

    <p class="text-gray-300">4</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the counter-example separating indistinguishability and simulation-based notion (which encodes a one-way permutation into the circuit family) in fact separates efficient and unbounded simulation; there, the circuit inherently leaks more information to an unbounded adversary than an efficient adversary. That is, the result really points to the inadequacy of the unbounded simulation security (and not indistinguishability-based notion) for certain families.</li>

      <li>the lower bound for IBE under many-AD-SIM security extends to many-AD-USIM; that is, the result is fundamentally about a simulation-based security notion, and not about efficiency.</li>

    </ul>

    <p class="text-gray-300">The reader is referred to Figure 1 for a survey of our results and open problems, and to Appendix C for results on the unbounded simulator definition.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">1.3 Discussion</h3>

    <h5 id="sec-7" class="text-base font-semibold mt-4">FunctoMania.</h5>

    <p class="text-gray-300">Let’s be wishful thinkers for a minute – suppose we can have whatever we hope for in functional encryption, call this world “Functomania”. What does Functomania look like? In light of the existing (im)possibilities, there will be two incomparable “dream results”:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1-AD-SIM secure public index predicate encryption for all efficient predicates; such schemes also satisfy 1-AD-IND, 1-AD-USIM, and many-AD-IND security.</li>

      <li>1-AD-USIM secure functional encryption for all poly-size circuits; such schemes also satisfy 1-AD-IND and many-AD-IND security.</li>

    </ul>

    <p class="text-gray-300">Given the current state of affairs in functional encryption, establishing either result in the affirmative (or even under the weaker 1-AD-IND security) will be considered a major break-through.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">The IND-(U)SIM Conundrum.</h5>

    <p class="text-gray-300">From a definitional stand-point, SIM/USIM-based security notions are preferable to IND-based security notion, as they offer a stronger security guarantee that has a natural, intuitive and aesthetically pleasing interpretation via the real/ideal paradigm. On the other hand, IND-based security notion allows us to bypass the impossibility results given in <em>[x1]</em> and in this work; in addition, they guarantee message <em>composability</em> in that security with a single ciphertext implies security for multiple ciphertexts (and so does NA-SIM considered in <em>[x11]</em>). We do not offer a complete answer to this conundrum; instead, we point out that 1-AD-SIM and 1-AD-USIM appear to be an adequate compromise for predicate encryption and general functional encryption respectively. We also note that such a conundrum is not unique to functional encryption, and has indeed previously surfaced and widely studied in the context of zero knowledge <em>[x10, x22]</em> and secure multi-party computation <em>[x23, x7, x20]</em>. One notable difference is that in zero knowledge and secure computation, super-polynomial time simulation offers concurrency; this is not the case for functional encryption. (The lower bound for many-AD-USIM-secure IBE indicates that even unbounded-time simulation does not help with message composability.)</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Beyond Black-Box Simulation?</h5>

    <p class="text-gray-300">In an independent work, Bellare and O’Neill <em>[x3]</em> put forth simulation-based definitions for functional encryption with non-black-box simulators. (The definitions we study in this work are “inherently black-box” since the simulator must explicitly provide the adversary with secret keys and ciphertexts.) In addition, they extended the <em>[x1]</em> lower bound for IBE to the setting of efficient, non-black-box simulators, assuming the existence of collision-resistant hash functions. This leaves as an open problem the question of realizing (or ruling out) many-AD-USIM IBE with a non-black-box simulator.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our impossibility result (Theorem 4.2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Boneh, Sahai and Waters ([BSW11, Theorem 2])</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">adaptive vs. non-adaptive</td>

            <td class="px-3 py-2 border-b border-gray-700">non-adaptive</td>

            <td class="px-3 py-2 border-b border-gray-700">adaptive</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">one vs. many messages</td>

            <td class="px-3 py-2 border-b border-gray-700">one message</td>

            <td class="px-3 py-2 border-b border-gray-700">many messages</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">one vs. many secret-key queries</td>

            <td class="px-3 py-2 border-b border-gray-700">many queries</td>

            <td class="px-3 py-2 border-b border-gray-700">one query</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">class of circuits</td>

            <td class="px-3 py-2 border-b border-gray-700">weak PRFs</td>

            <td class="px-3 py-2 border-b border-gray-700">IBE</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: A comparison between the BSW lower bound (see also Section C.2) and ours for functional encryption. The underlines indicate the stronger result. For example, the first row says that our impossibility result rules out even a non-adaptive notion of security and is thus, stronger than the BSW result that rules out an adaptive notion.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathcal{X} = \\{\\mathcal{X}_{\\kappa}\\}_{\\kappa \\in \\mathbb{N}}</span>  and  <span class="math">\\mathcal{Y} = \\{\\mathcal{Y}_{\\kappa}\\}_{\\kappa \\in \\mathbb{N}}</span>  denote ensembles where each  <span class="math">\\mathcal{X}_{\\kappa}</span>  and  <span class="math">\\mathcal{Y}_{\\kappa}</span>  is a finite set. Let  <span class="math">\\mathcal{C} = \\{\\mathcal{C}_{\\kappa}\\}_{\\kappa \\in \\mathbb{N}}</span>  denote an ensemble where each  <span class="math">\\mathcal{C}_{\\kappa}</span>  is a finite collection of circuits, and each circuit  <span class="math">C \\in \\mathcal{C}_{\\kappa}</span>  takes as input a string  <span class="math">x \\in \\mathcal{X}_{\\kappa}</span>  and outputs  <span class="math">C(x) \\in \\mathcal{Y}_{\\kappa}</span> .</p>

    <p class="text-gray-300">A functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  for  <span class="math">\\mathcal{C}</span>  consists of four algorithms  <span class="math">\\mathcal{F}\\mathcal{E} = (\\text{FE.Setup}, \\text{FE.Keygen}, \\text{FE.Enc}, \\text{FE.Dec})</span>  defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Setup FE.Setup(1 <span class="math">\\kappa</span> ) is a p.p.t. algorithm takes as input the unary representation of the security parameter and outputs the master public and secret keys (MPK, MSK).</li>

      <li>Key Generation FE.Keygen(MSK, C) is a p.p.t. algorithm that takes as input the master secret key MSK and a circuit  <span class="math">C \\in \\mathcal{C}_{\\kappa}</span>  and outputs a corresponding secret key  <span class="math">\\mathsf{SK}_C</span> .</li>

      <li>Encryption FE.Enc(MPK,  <span class="math">x</span> ) is a p.p.t. algorithm that takes as input the master public key MPK and an input message  <span class="math">x \\in \\mathcal{X}_{\\kappa}</span>  and outputs a ciphertext CT.</li>

      <li>Decryption FE.Dec(SK <span class="math">_C</span> , CT) is a deterministic algorithm that takes as input the secret key  <span class="math">\\mathsf{SK}_C</span>  and a ciphertext CT and outputs  <span class="math">C(x)</span> .</li>

    </ul>

    <p class="text-gray-300">Definition 2.1 (Correctness). A functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is correct if for all  <span class="math">C\\in \\mathcal{C}_{\\kappa}</span>  and all  <span class="math">x\\in \\mathcal{X}_{\\kappa}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {M P K}, \\mathsf {M S K}) \\leftarrow \\mathsf {F E . S e t u p} (1 ^ {\\kappa}); \\\\ \\mathsf {F E . D e c} (\\mathsf {F E . K e y g e n} (\\mathsf {M S K}, C), \\mathsf {F E . E n c} (\\mathsf {M P K}, x)) \\neq C (x) \\end{array} \\right] = \\mathsf {n e g l} (\\kappa)</span></div>

    <p class="text-gray-300">where the probability is taken over the coins of FE.Setup, FE.Keygen, and FE.Enc.</p>

    <p class="text-gray-300">In this section, we present a simulation-based definition of functional encryption, similar in spirit to the way one defines security for secure computation via the ideal/real paradigm. We define the security game for a single message since our lower bounds apply to this weaker setting. However, this definition can be easily extended to many messages setting (see Appendix B).</p>

    <p class="text-gray-300">Definition 2.2 (1-NA-SIM- and 1-AD-SIM- Security). Let  <span class="math">\\mathcal{F}\\mathcal{E}</span>  be a functional encryption scheme for a circuit family  <span class="math">\\mathcal{C}</span> . Consider a p.p.t. adversary  <span class="math">A = (A_{1}, A_{2})</span>  and a stateful p.p.t. simulator Sim. <span class="math">^7</span>  Let  <span class="math">U_{x}(\\cdot)</span>  denote a universal oracle, such that  <span class="math">U_{x}(C) = C(x)</span> . Consider the following two experiments:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp real F.E, A(1κ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp ideal F.E, Sim(1κ):</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: (MPK, MSK) ← FE.Setup(1κ)</td>

            <td class="px-3 py-2 border-b border-gray-700">1: MPK ← Sim(1κ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: (x, st) ← A1FE.Keygen(MSK,·)(MPK)</td>

            <td class="px-3 py-2 border-b border-gray-700">2: (x, st) ← A1Sim(·)(MPK)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: CT ← FE.Enc(MPK, x)</td>

            <td class="px-3 py-2 border-b border-gray-700">3: CT ← SimUx(·)(1κ, 1</td>

            <td class="px-3 py-2 border-b border-gray-700">x</td>

            <td class="px-3 py-2 border-b border-gray-700">)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: α ← A2O(MSK,·)(MPK, CT, st)</td>

            <td class="px-3 py-2 border-b border-gray-700">4: α ← A2O'(·)(MPK, CT, st)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: Output (x, α)</td>

            <td class="px-3 py-2 border-b border-gray-700">5: Output (x, α)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We distinguish between two cases of the above experiment:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adaptive experiment, where:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the oracle  <span class="math">\\mathcal{O}(\\mathrm{MSK},\\cdot) = \\mathrm{FE.Keygen}(\\mathrm{MSK},\\cdot)</span>  and</li>

      <li>the oracle  <span class="math">\\mathcal{O}&#x27;(\\cdot)</span>  is the simulator, namely  <span class="math">\\operatorname{Sim}^{U_x(\\cdot)}(\\cdot)</span></li>

    </ul>

    <p class="text-gray-300">We call a stateful simulator algorithm Sim admissible if, on each input  <span class="math">C</span> , Sim makes just a single query to its oracle  <span class="math">U_{x}(\\cdot)</span>  on  <span class="math">C</span>  itself.</p>

    <p class="text-gray-300">The functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is then said to be simulation-secure for one message against adaptive adversaries (1-AD-SIM-secure, for short) if there is an admissible stateful p.p.t. simulator Sim such that for every p.p.t. adversary  <span class="math">A = (A_{1},A_{2})</span> , the following two distributions are computationally indistinguishable:</p>

    <div class="my-4 text-center"><span class="math-block">\\left\\{\\operatorname {E x p} _ {\\mathcal {F E}, A} ^ {\\text {r e a l}} \\left(1 ^ {\\kappa}\\right) \\right\\} _ {\\kappa \\in \\mathbb {N}} \\stackrel {{c}} {{\\approx}} \\left\\{\\operatorname {E x p} _ {\\mathcal {F E}, \\operatorname {S i m}} ^ {\\text {i d e a l}} \\left(1 ^ {\\kappa}\\right) \\right\\} _ {\\kappa \\in \\mathbb {N}}</span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The non-adaptive experiment, where the oracles  <span class="math">\\mathcal{O}(\\mathrm{MSK},\\cdot)</span>  and  <span class="math">\\mathcal{O}&#x27;(\\cdot)</span>  are both the "empty oracles" that return nothing.</li>

    </ol>

    <p class="text-gray-300">The functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is then said to be simulation-secure for one message against non-adaptive adversaries (1-NA-SIM-secure, for short) if there is an admissible stateful p.p.t. simulator Sim such that for every p.p.t. adversary  <span class="math">A = (A_{1},A_{2})</span> , the two distributions above are computationally indistinguishable.</p>

    <p class="text-gray-300">Remarks on the Definition. Our definition is stronger than that in [BSW11] but weaker than that in [GVW12]; our lower bound in Section 4 holds for all three definitions. Amongst the three, the one in [GVW12] is the only for which we know a composition theorem where security for one message implies security for many messages, in the non-adaptive setting. Note that composition in the non-adaptive setting is the "best" we can hope for; composition in the adaptive setting is essentially impossible by many-AD-SIM lower bound for IBE [BSW11]. In more detail:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In <em>[x1]</em>, the simulator is given oracle access to <span class="math">A_{2}</span>, which it can call on any ciphertext. Therefore, it can “rewind” the adversary <span class="math">A_{2}</span> and adaptively reconstruct the view, which is problematic for composition <em>[x21, x17, x3]</em>. We call this a “rewinding” definition. In our “straight-line” definition, the simulator must commit to a ciphertext once and for all, which makes it stronger.</li>

      <li>Unlike our definition, the <em>[x12]</em> definition does not allow the simulator to fake or “program” the setup parameters and the secret keys. The difficulty in proving a composition theorem for our definition lies in that the simulator may use “trapdoor” information from faking the setup parameters and secret keys while simulating the ciphertext.</li>

    </ul>

    <p class="text-gray-300">We note that in the equivalence of NA-IND and NA-SIM under pre-image sampleability in <em>[x20, Section 4]</em>, the NA-SIM-simulator actually satisfies the stronger definition in <em>[x12]</em>.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">The Indistinguishability-based Definition of Security.</h5>

    <p class="text-gray-300">We define the non-adaptive NA-IND and the adaptive AD-IND notions of security in Appendix A.</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 Preliminaries</h2>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Notations.</h5>

    <p class="text-gray-300">Let <span class="math">\\mathcal{D}</span> denote a distribution over some finite set <span class="math">S</span>. Then, <span class="math">x\\leftarrow\\mathcal{D}</span> is used to denote the fact that <span class="math">x</span> is chosen from the distribution <span class="math">\\mathcal{D}</span>. When we say <span class="math">x\\leftarrow S</span>, we simply mean that <span class="math">x</span> is chosen from the uniform distribution over <span class="math">S</span>. Unless explicitly mentioned, all logarithms are to base <span class="math">2</span>. For <span class="math">n\\in\\mathbb{N}</span>, let <span class="math">[n]</span> denote the set of numbers <span class="math">1,\\ldots,n</span>. Let <span class="math">\\kappa</span> denote the security parameter.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Definition 3.1 (wPRF).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{wPRF}=\\{\\mathsf{wPRF}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> denote a family of efficiently computable functions where <span class="math">\\mathsf{wPRF}_{\\kappa}:\\{0,1\\}^{n(\\kappa)}\\times\\{0,1\\}^{m(\\kappa)}\\rightarrow\\{0,1\\}^{k(\\kappa)}</span>, the first argument of which is called the seed to the wPRF and the second argument is the input.</p>

    <p class="text-gray-300">For every probabilistic polynomial time oracle distinguisher <span class="math">\\mathrm{Dist}</span>, consider the following two experiments:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Real}_{\\mathrm{Dist}}(1^{\\kappa})</span>: Choose <span class="math">x\\stackrel{{\\scriptstyle\\</span>}}{\\leftarrow}\\{0,1\\}^{n(\\kappa)}<span class="math"> and run </span>\\mathrm{Dist}<span class="math"> with access to a probabilistic oracle </span>\\mathcal{O}_{real}(x)<span class="math"> which, when invoked, chooses a uniformly random </span>d\\leftarrow\\{0,1\\}^{m(\\kappa)}<span class="math"> and returns the pair </span>(d,\\mathsf{wPRF}_{\\kappa}(x,d))<span class="math">. This experiment outputs whatever </span>\\mathrm{Dist}$ outputs.</li>

      <li><span class="math">\\mathsf{Rand}_{\\mathrm{Dist}}(1^{\\kappa})</span>: Choose a uniformly random function <span class="math">R:\\{0,1\\}^{m(\\kappa)}\\rightarrow\\{0,1\\}^{k(\\kappa)}</span> and run <span class="math">\\mathrm{Dist}</span> with access to a probabilistic oracle <span class="math">\\mathcal{O}_{rand}(R)</span> which, when invoked, chooses a uniformly random <span class="math">d\\leftarrow\\{0,1\\}^{m(\\kappa)}</span> and returns the pair <span class="math">(d,R(d))</span>. This experiment outputs whatever <span class="math">\\mathrm{Dist}</span> outputs.</li>

    </ul>

    <p class="text-gray-300">We say <span class="math">\\mathsf{wPRF}</span> is a weak pseudo-random function if for all p.p.t. distinguishers <span class="math">\\mathrm{Dist}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr[\\mathsf{Real}_{\\mathrm{Dist}}(1^{\\kappa})=1]-\\Pr[\\mathsf{Rand}_{\\mathrm{Dist}}(1^{\\kappa})=1]\\big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=\\mathrm{negl}(\\kappa)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the probabilities are over the choice of <span class="math">x</span> and <span class="math">R</span>, as well as the coin-tosses of <span class="math">\\mathrm{Dist}</span> and the oracles <span class="math">\\mathcal{O}_{real}</span> and <span class="math">\\mathcal{O}_{rand}</span>.</p>

    <p class="text-gray-300">In our impossibility result, we will use a weak pseudo-random function with seed length <span class="math">n(\\kappa)=\\kappa</span> and output length <span class="math">k(\\kappa)=1</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">4 Impossibility Results for Functional Encryption</p>

    <p class="text-gray-300">In this section, we present our main lower bound for 1-NA-SIM-secure functional encryption. We begin with a notion of “incompressible” circuits. Then, we show that (1) weak pseudo-random functions are “incompressible”, and (2) 1-NA-SIM-secure functional encryption only exists for “compressible” circuits. Putting the two together yields our lower bound.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">4.1 Incompressible Circuits</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We first define a family of compressible circuits. Informally, we say that a family of circuits <span class="math">\\{\\mathcal{G}_{\\kappa}\\}</span> is <span class="math">(\\ell,t)</span>-compressible if for a list of uniformly random circuit descriptions <span class="math">G_{1},\\ldots,G_{\\ell}\\in\\mathcal{G}_{\\kappa}</span> and a uniformly chosen input <span class="math">x</span>, there is some efficiently computable description of <span class="math">G_{1}(x),\\ldots,G_{\\ell}(x)</span> of size <span class="math">t</span>. Note that if there is no efficiency requirement, then any family is $(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-compressible.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 4.1 (Incompressible Circuits).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell=\\ell(\\kappa)</span> and <span class="math">t=t(\\kappa)</span> be functions of the security parameter <span class="math">\\kappa</span>. A family of circuits <span class="math">\\mathcal{G}=\\{\\mathcal{G}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> is <span class="math">(\\ell,t)</span>-compressible if there exist a family of (deterministic) compressor circuits <span class="math">\\{\\mathbf{C}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> and a family of decompressor circuits <span class="math">\\{\\mathbf{D}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(polynomial size) the circuits <span class="math">\\mathbf{C}_{\\kappa}</span> and <span class="math">\\mathbf{D}_{\\kappa}</span> have size <span class="math">\\mathsf{poly}(\\kappa,\\ell)</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (mild compression) for sufficiently large <span class="math">\\kappa</span>, $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}_{\\kappa}(G_{1},\\ldots,G_{\\ell},y_{1},\\ldots,y_{\\ell})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=t<span class="math">, where </span>y_{i}=G_{i}(x)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(correctness) there is a polynomial <span class="math">p=p(\\kappa)</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[x\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\{0,1\\}^{\\kappa},</span> <span class="math">G_{1},\\ldots,G_{\\ell}\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\mathcal{G}_{\\kappa},y_{i}=G_{i}(x):</span> <span class="math">\\mathbf{D}_{\\kappa}(G_{1},\\ldots,G_{\\ell},\\mathbf{C}_{\\kappa}(G_{1},\\ldots,G_{\\ell},y_{1},\\ldots,y_{\\ell}))=(y_{1},\\ldots,y_{\\ell})]\\geq 1/p(\\kappa)</span></p>

    <p class="text-gray-300">where the probability is taken over the choice of <span class="math">x</span> as well as the circuits <span class="math">G_{1},\\ldots,G_{\\ell}</span>.</p>

    <p class="text-gray-300">The family <span class="math">\\mathcal{G}</span> is <span class="math">(\\ell,t)</span>-incompressible if it is not <span class="math">(\\ell,t)</span>-compressible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We now give examples of (in)compressible circuits. First, consider the notion of pre-image samplable family of circuits introduced by O’Neill <em>[x13]</em> which requires that given <span class="math">G_{1}(x),\\ldots,G_{\\ell}(x)</span>, there is a polynomial-time algorithm that returns an arbitrary <span class="math">x^{\\prime}</span> such that <span class="math">G_{i}(x^{\\prime})=G_{i}(x)</span> for all <span class="math">i</span>. In our language, this says that the family <span class="math">\\mathcal{G}</span> is $(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-compressible; the compression algorithm simply outputs </span>x^{\\prime}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, consider an arbitrary public-index circuit family parametrized by predicates <span class="math">P</span> and given by:</p>

    <p class="text-gray-300">\\[ G_{P}(\\mathsf{ind},\\mu)=\\left\\{\\begin{array}[]{ll}(\\mathsf{ind},\\mu)&\\text{ if }P(\\mathsf{ind})=1\\\\ (\\mathsf{ind},\\bot)&\\text{ otherwise}\\end{array}\\right. \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is easy to see that this circuit family is $(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\mathsf{ind},\\mu)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-compressible. On input</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">G_{P_{1}}(\\mathsf{ind},\\mu),\\ldots,G_{P_{\\ell}}(\\mathsf{ind},\\mu)</span></p>

    <p class="text-gray-300">If <span class="math">P_{i}(\\mathsf{ind})=1</span> for some <span class="math">i</span>, then the compression algorithm outputs <span class="math">(\\mathsf{ind},\\mu)</span>. If <span class="math">P_{i}(\\mathsf{ind})=0</span> for all <span class="math">i</span>, then the algorithm outputs <span class="math">(\\mathsf{ind},\\bot)</span>.</p>

    <p class="text-gray-300">On the other hand, as we show below (see Lemma 4.1), any family of (weak) pseudo-random functions is incompressible in a strong sense. More precisely, consider a family of</p>

    <p class="text-gray-300"><span class="math">G_{d_{i}}(\\cdot):=\\mathsf{wPRF}(\\cdot,d_{i})</span> where <span class="math">d_{i}</span> serves as the input to the pseudo-random function. Informally, the incompressibility is due to the fact that a sequence <span class="math">(G_{d_{1}}(x),\\ldots,G_{d_{\\ell}}(x))=(\\mathsf{wPRF}(x,d_{1}),\\ldots,\\mathsf{wPRF}(x,d_{\\ell}))</span> is indistinguishable from a sequence of uniformly random bits, which are clearly incompressible.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Lemma 4.1 (weak PRFs are <span class="math">(\\ell,\\ell-\\kappa)</span>-incompressible).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{wPRF}=\\{\\mathsf{wPRF}_{\\kappa}:\\{0,1\\}^{\\kappa}\\times\\{0,1\\}^{m(\\kappa)}\\rightarrow\\{0,1\\}\\}_{\\kappa\\in\\mathbb{N}}</span> be a family of weak pseudo-random functions, where <span class="math">m(\\kappa)=\\omega(\\log\\kappa)</span>. Define <span class="math">G_{d}(x)=\\mathsf{wPRF}(x,d)</span>. Consider a family <span class="math">\\mathcal{G}=\\{\\mathcal{G}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{G}_{\\kappa}=\\left\\{G_{d}(\\cdot):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m(\\kappa)\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Then, <span class="math">\\mathcal{G}</span> is <span class="math">(\\ell,\\ell-\\kappa)</span>-incompressible.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume, for the sake of contradiction, that <span class="math">\\mathcal{G}</span> is <span class="math">(\\ell,\\ell-\\kappa)</span>-compressible. Namely, there are families of compressor and decompressor circuits <span class="math">(\\mathbf{C},\\mathbf{D})</span> that satisfy Definition 4.1. We show how to construct a distinguisher <span class="math">\\mathrm{Dist}^{\\mathcal{O}}</span> that distinguishes between the case where <span class="math">\\mathcal{O}=\\mathsf{wPRF}(x,\\cdot)</span> is a pseudo-random oracle that outputs pairs <span class="math">(d_{i},y_{i}=\\mathsf{wPRF}_{\\kappa}(x,d_{i}))</span> where <span class="math">d_{i}</span> are uniformly random, and the case where <span class="math">\\mathcal{O}</span> outputs strings <span class="math">(d_{i},y_{i}=R(d_{i}))</span> where <span class="math">d_{i}</span> and <span class="math">R</span> are uniformly random strings and function, respectively. <span class="math">\\mathrm{Dist}^{\\mathcal{O}}</span> proceeds as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Choose a sufficiently large <span class="math">\\kappa</span> such that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{C}_{\\kappa}(G_{1},\\ldots,G_{\\ell},y_{1},\\ldots,y_{\\ell})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell-\\kappa$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query the oracle <span class="math">\\mathcal{O}</span> to obtain pairs of strings of the form <span class="math">(d_{i}\\stackrel{{\\scriptstyle\\sharp}}{{\\leftarrow}}\\{0,1\\}^{m(\\kappa)},y_{i})</span>. Define the circuit <span class="math">G_{d_{i}}(\\cdot):=\\mathsf{wPRF}(\\cdot,d_{i})</span>.</li>

      <li>Run the compressor <span class="math">\\mathbf{C}_{\\kappa}</span> to get a string</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\gamma\\leftarrow\\mathbf{C}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},y_{1},\\ldots,y_{\\ell})</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Outputs <span class="math">1</span> if and only if</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{D}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},\\gamma)=(y_{1},\\ldots,y_{\\ell})</span></p>

    <p class="text-gray-300">We now show that the distinguisher succeeds with non-negligible advantage <span class="math">1/p(\\kappa)-2^{-\\kappa}</span> in breaking the weak pseudo-random function family <span class="math">\\mathsf{wPRF}</span>.</p>

    <p class="text-gray-300">If <span class="math">\\mathcal{O}</span> is the pseudo-random oracle, then the samples <span class="math">\\mathrm{Dist}^{\\mathcal{O}}</span> gets are of the form <span class="math">(d_{i},y_{i}\\leftarrow\\mathsf{wPRF}(x,d_{i}))</span>. Hence, by correctness of <span class="math">\\mathbf{C}</span> and <span class="math">\\mathbf{D}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{D}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},\\mathbf{C}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},y_{1},\\ldots,y_{\\ell}))=(y_{1},\\ldots,y_{\\ell})</span></p>

    <p class="text-gray-300">with probability at least <span class="math">1/p(\\kappa)</span>. Thus, the distinguisher in this case outputs <span class="math">1</span> with probability at least <span class="math">1/p(\\kappa)</span> as well.</p>

    <p class="text-gray-300">On the other hand, if <span class="math">\\mathcal{O}</span> outputs pairs of strings of the form <span class="math">(d_{i},y_{i}\\leftarrow R(d_{i}))</span> for a randomly chosen function mapping <span class="math">R</span>, we now show that the distinguisher above outputs <span class="math">1</span> with probability at most <span class="math">2^{-\\kappa}</span>. In the analysis below, we assume that <span class="math">d_{1},\\ldots,d_{\\ell}</span> are distinct, for which we need to pay a price of an additive <span class="math">\\ell^{2}\\cdot 2^{-m(\\kappa)}=\\mathrm{negl}(\\kappa)</span> term in the distinguishing error.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\text{Dist}^{\\mathcal{O}}</span> outputs 1]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\leq</span> $\\Pr_{d_{1},\\ldots,d_{\\ell}\\overset{\\mathbb{S}}{\\leftarrow}\\{0,1\\}^{m(\\kappa)}}\\big{[}\\exists\\gamma:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\gamma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\ell-\\kappa\\text{ and }\\mathbf{D}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},\\gamma)=(y_{1},\\ldots,y_{\\ell})\\big{]}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad</span> <span class="math">\\leq</span> <span class="math">\\sum_{\\gamma\\in\\{0,1\\}^{\\ell-\\kappa}}\\Pr_{d_{1},\\ldots,d_{\\ell}\\overset{\\mathbb{S}}{\\leftarrow}\\{0,1\\}^{m(\\kappa)}}\\big{[}\\mathbf{D}_{\\kappa}(G_{d_{1}},\\ldots,G_{d_{\\ell}},\\gamma)=(y_{1},\\ldots,y_{\\ell})\\big{]}\\quad\\text{(via a union bound)}</span> <span class="math">=\\sum_{\\gamma\\in\\{0,1\\}^{\\ell-\\kappa}}2^{-\\ell}\\quad\\text{(since }y_{1},\\ldots,y_{\\ell}\\text{ are random and independent of }d_{1},\\ldots,d_{\\ell},\\gamma)</span> <span class="math">\\leq</span> <span class="math">2^{\\ell-\\kappa}\\cdot 2^{-\\ell}=2^{-\\kappa}</span></p>

    <p class="text-gray-300">This yields the required contradiction to the security of wPRF. ∎</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.2 The Impossibility Result</h3>

    <p class="text-gray-300">We are now ready to state and prove our main theorem.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 4.2.</h6>

    <p class="text-gray-300">There exists a family of circuits <span class="math">\\mathcal{G}</span> for which there are no <span class="math">1</span>-NA-SIM-secure functional encryption schemes.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We consider two cases.</p>

    <p class="text-gray-300">Case 1: Assume there exists a circuit family of weak pseudo-random functions</p>

    <p class="text-gray-300"><span class="math">\\mathsf{wPRF}=\\{\\mathsf{wPRF}_{\\kappa}:\\{0,1\\}^{\\kappa}\\times\\{0,1\\}^{m(\\kappa)}\\to\\{0,1\\}\\}_{\\kappa\\in\\mathbb{N}}</span></p>

    <p class="text-gray-300">where <span class="math">m(\\kappa)=\\omega(\\log\\kappa)</span>. Let <span class="math">G_{d}(x)=\\mathsf{wPRF}(x,d)</span> and consider a family <span class="math">\\mathcal{G}=\\{\\mathcal{G}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> defined as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathcal{G}_{\\kappa}=\\big{\\{}G_{d}(\\cdot):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=m(\\kappa)\\big{\\}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assume, for the sake of contradiction, there exist a <span class="math">1</span>-NA-SIM-secure function encryption scheme <span class="math">\\mathcal{F}\\mathcal{E}</span> for <span class="math">\\mathcal{G}</span>, and let $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denote the length of a ciphertext in the scheme. Let </span>\\ell=\\ell(\\kappa)=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\kappa$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From Lemma 4.1, we know that <span class="math">\\mathcal{G}</span> is $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}+\\kappa,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-incompressible. However, Lemma 4.3 below tells us that since there is a </span>1<span class="math">-NA-SIM secure scheme for </span>\\mathcal{G}<span class="math">, the family </span>\\mathcal{G}<span class="math"> is </span>(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+\\kappa,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-compressible. This gives us the desired contradiction, and therefore, there cannot exist a </span>1<span class="math">-NA-SIM-secure functional encryption scheme for </span>\\mathcal{G}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Case 2: Assume there does not exist a family of weak pseudo-random functions. Also, for the sake of contradiction, assume there exists a <span class="math">1</span>-NA-SIM-secure function encryption scheme for all families of circuits <span class="math">\\mathcal{G}</span>.</p>

    <p class="text-gray-300">In particular, this means that there is a functional encryption scheme for the empty circuit family (namely, a family <span class="math">\\mathcal{G}</span> that does not contain any circuits at all). A <span class="math">1</span>-NA-SIM-secure scheme <span class="math">\\mathcal{F}\\mathcal{E}</span> for <span class="math">\\mathcal{G}</span> is also a secure public-key encryption scheme. Since public-key encryption implies one-way functions, which in turn imply pseudo-random functions <em>[x10, x13]</em>, we obtain the desired contradiction. ∎</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">###### Lemma 4.3 (<span class="math">1</span>-NA-SIM $\\Rightarrow(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$-compressibility).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{G}=\\{\\mathcal{G}_{\\kappa}\\}_{\\kappa\\in\\mathbb{N}}</span> be a family of circuits. Suppose there exists a <span class="math">1</span>-NA-SIM-secure functional encryption scheme for the <span class="math">\\mathcal{G}</span>. Then, the family <span class="math">\\mathcal{G}</span> is $(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-compressible for any polynomially bounded </span>\\ell=\\ell(\\kappa)<span class="math">, where </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> denotes size of the encryption of input </span>x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">formally, the compression algorithm works as follows: on input <span class="math">G_{1},\\ldots,G_{\\ell}</span> and <span class="math">G_{1}(x),\\ldots,G_{\\ell}(x)</span>, the output is the simulated ciphertext corresponding to an encryption of <span class="math">x</span>. The decompression algorithm then evaluates the decryption algorithm, which is guaranteed to produce <span class="math">G_{1}(x),\\ldots,G_{\\ell}(x)</span>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">(\\mathsf{FE.Setup},\\mathsf{FE.Keygen},\\mathsf{FE.Enc},\\mathsf{FE.Dec})</span> denote the encryption scheme for the family <span class="math">\\mathcal{G}</span>. Consider the adversary <span class="math">A=(A_{1},A_{2})</span> in the 1-NA-SIM security experiment that acts as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">A_{1}</span> chooses <span class="math">G_{1},\\ldots,G_{\\ell}\\stackrel{{\\scriptstyle\\</span>}}{{\\leftarrow}}\\mathcal{G}<span class="math"> independently at random and requests for the corresponding secret keys </span>\\mathsf{SK}_{1},\\ldots,\\mathsf{SK}_{\\ell}<span class="math">. In addition, it chooses </span>x\\stackrel{{\\scriptstyle\\<span class="math">}}{{\\leftarrow}}\\{0,1\\}^{m(\\kappa)}</span> and outputs <span class="math">x</span> as the challenge message, and <span class="math">(G_{1},\\ldots,G_{\\ell},\\mathsf{SK}_{1},\\ldots,\\mathsf{SK}_{\\ell})</span> as the state.</li>

      <li><span class="math">A_{2}</span> outputs <span class="math">\\alpha</span> composed of the challenge ciphertext and the state <span class="math">(G_{1},\\ldots,G_{\\ell},\\mathsf{SK}_{1},\\ldots,\\mathsf{SK}_{\\ell})</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathrm{Sim}</span> denote the (admissible) stateful p.p.t. simulator guaranteed by 1-NA-SIM security. We show how to use the simulator to construct a family of (deterministic) compressor and decompressor circuits <span class="math">\\mathbf{C}_{\\rho}</span> and <span class="math">\\mathbf{D}_{\\rho}</span>, indexed by a random string <span class="math">\\rho</span> corresponding to the random tape for the simulator:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The compressor <span class="math">\\mathbf{C}_{\\rho}</span>, on input <span class="math">G_{1},\\ldots,G_{\\ell}</span> and <span class="math">y_{1},\\ldots,y_{\\ell}</span> works as follows: first, compute <span class="math">\\mathsf{MPK}\\leftarrow\\mathrm{Sim}(1^{\\kappa};\\ \\rho)</span> and secret keys <span class="math">\\{\\mathsf{SK}_{i}:\\mathsf{SK}_{i}\\leftarrow\\mathrm{Sim}(G_{i};\\ \\rho)\\}_{i\\in[\\ell]}</span>. Then compute and output <span class="math">\\mathsf{CT}</span> as the compressed string, where queries <span class="math">G_{i}(x)</span> are answered with <span class="math">y_{i}</span>:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{CT}\\leftarrow\\mathrm{Sim}^{U_{x}(\\cdot)}(1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m(\\kappa)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The decompressor <span class="math">\\mathbf{D}_{\\rho}</span>, on input <span class="math">G_{1},\\ldots,G_{\\ell}</span> and <span class="math">\\mathsf{CT}</span> first reconstructs the master public key <span class="math">\\mathsf{MPK}\\leftarrow\\mathrm{Sim}(1^{\\kappa};\\ \\rho)</span> and the set of secret keys:</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\{\\mathsf{SK}_{i}:\\mathsf{SK}_{i}\\leftarrow\\mathrm{Sim}(G_{i};\\ \\rho)\\}_{i\\in[\\ell]}</span></p>

    <p class="text-gray-300">Note that <span class="math">\\mathbf{D}_{\\rho}</span> has the same randomness <span class="math">\\rho</span> hard-wired, and so the secret keys <span class="math">\\mathsf{SK}_{i}</span> are exactly the same as those used by <span class="math">\\mathbf{C}_{\\rho}</span>. Finally, it computes and outputs:</p>

    <p class="text-gray-300"><span class="math">\\big{\\{}y_{i}\\leftarrow\\mathsf{FE.Dec}(\\mathsf{SK}_{i},\\mathsf{CT})\\big{\\}}_{i\\in[\\ell]}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Formally, we output <span class="math">(\\mathbf{C}_{\\rho},\\mathbf{D}_{\\rho})</span> for a random <span class="math">\\rho</span>, which is a pair of polynomial-size circuits. Clearly, we achieve $(\\ell,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{CT}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-compressibility, since the size of </span>\\mathsf{CT}<span class="math"> is determined by the functional encryption scheme and independent of </span>\\ell$. To establish correctness, it suffices to show that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr_{\\rho,x,G_{1},\\ldots,G_{\\ell}}[\\mathbf{D}_{\\rho}(G_{1},\\ldots,G_{\\ell},\\mathbf{C}_{\\rho}(G_{1},\\ldots,G_{\\ell},G_{1}(x),\\ldots,G_{\\ell}(x)))=(G_{1}(x),\\ldots,G_{\\ell}(x))]\\geq 1-\\mathrm{negl}(\\kappa)</span></p>

    <p class="text-gray-300">Here, we will rely on the correctness of the functional encryption scheme as well as 1-NA-SIM-security. First, consider the distinguisher <span class="math">\\mathrm{Dist}</span> that given the output <span class="math">(x,\\mathsf{CT},G_{1},\\ldots,G_{\\ell},\\mathsf{SK}_{1},\\ldots,\\mathsf{SK}_{\\ell})</span> of the adversary <span class="math">A_{2}</span> proceeds as follows:</p>

    <p class="text-gray-300"><span class="math">\\text{Output 1 iff for all }i\\in[\\ell],\\mathsf{FE.Dec}(\\mathsf{SK}_{i},\\mathsf{CT})=G_{i}(x).</span></p>

    <p class="text-gray-300">Observe that by correctness of the encryption scheme, <span class="math">\\mathrm{Dist}</span> outputs 1 with probability <span class="math">1-\\mathrm{negl}(\\kappa)</span> given the output of the adversary <span class="math">A_{2}</span> in the 1-NA-SIM experiment. Therefore, by 1-NA-SIM-security, <span class="math">\\mathrm{Dist}</span> also outputs 1 with probability <span class="math">1-\\mathrm{negl}(\\kappa)</span> given the output of the (admissible) simulator, where the randomness is taken over the coin tosses <span class="math">\\rho</span> of the simulator, along with the random choices of <span class="math">x,G_{1},\\ldots,G_{\\ell}</span>.</p>

    <p class="text-gray-300">This shows that the pair of circuits <span class="math">(\\mathbf{C}_{\\rho},\\mathbf{D}_{\\rho})</span> for a uniformly random <span class="math">\\rho</span> is a correct compressor-decompressor pair, establishing the lemma. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">We point out here that our lower bound extends to the setting where the simulator is not required to be admissible, by using a family of (standard) pseudo-random functions.</p>

    <p class="text-gray-300">Finally, the argument here generalizes to showing that functional encryption secure against an a-priori bounded number <span class="math">q=q(\\kappa)</span> of collusions is impossible if one insists on small ciphertexts (namely, ciphertexts with much fewer than <span class="math">q</span> bits). This matches the recent result of <em>[x10]</em> who construct such functional encryption schemes with ciphertexts of size polynomial in <span class="math">q</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Corollary 4.4.</h6>

    <p class="text-gray-300">There exists a family of circuits <span class="math">\\mathcal{G}</span> such that for every <span class="math">q=q(\\kappa)</span>, there are no <span class="math">q</span>-collusion resistant 1-NA-SIM-secure functional encryption schemes. with ciphertexts of size <span class="math">o(q)</span>.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">4.3 Extensions: Impossibility of Weaker Simulation-based Definitions</h3>

    <p class="text-gray-300">The idea behind our impossibility result is robust enough to apply to various relaxations of the simulation-based security definition. In this section, we describe a number of such extensions of our result.</p>

    <h5 id="sec-26" class="text-base font-semibold mt-4">Impossibility for the selective and random-input definitions.</h5>

    <p class="text-gray-300">In the selective model, the adversary is required to commit to the secret key queries <span class="math">G_{1},\\ldots,G_{q}</span> as well as the challenge input <span class="math">x</span> before the setup phase. In particular, this means that the adversary will not be able to pick up the circuits or the challenge input depending on the system parameters. Variants of the selective security model are frequently considered in the literature as a relaxations of regular security notions (see, e.g., <em>[x1, x11, x2]</em>). Another relaxation one can consider is one where the adversary is not allowed to choose the circuits or the challenge, but instead, they are chosen uniformly at random.</p>

    <p class="text-gray-300">Our lower bound easily extends to these weaker notions, simply because the adversary we consider in the proof of Lemma 4.3 chooses the circuits and the challenge uniformly at random, and independent of the system parameters.</p>

    <h5 id="sec-27" class="text-base font-semibold mt-4">Impossibility for the non-adaptive BSW Definition (the “Rewinding Definition”).</h5>

    <p class="text-gray-300">The main difference between the definition proposed by <em>[x1]</em> and our definition in Section 2 is that whereas our definition restricts the simulator to be “straight-line”, the BSW definition allows the simulator to “rewind” the adversary and interact with it in order to generate the view. For more details, we direct the reader to the discussion after Definition 2.2.</p>

    <p class="text-gray-300">The proof of Lemma 4.3 transparently extends to the BSW definition. The adversary <span class="math">A</span> is the same as in the proof. The compressor <span class="math">\\mathbf{C}</span> runs the simulator, executing the code of the designated adversary <span class="math">A</span> to compute the response whenever the simulator queries (“rewinds”) <span class="math">A</span>. Also, since the simulator is admissible, the queries it makes are exactly the ones that the compressor knows the answer to. As before, we can make the impossibility result work for even non-admissible simulators by appealing to regular (rather than weak) PRFs.</p>

    <h5 id="sec-28" class="text-base font-semibold mt-4">Impossibility for Secret-key Functional Encryption.</h5>

    <p class="text-gray-300">In the setting of secret-key functional encryption (first considered by Shi, Shen and Waters <em>[x23]</em> in its predicate encryption variant), the encryption algorithm relies on the master secret key to produce the ciphertext for an input <span class="math">x</span>.</p>

    <p class="text-gray-300">All our impossibility results carry over to the setting of secret key functional encryption since in the proof of Lemma 4.3, neither the compressor nor the decompressor needs to run the encryption algorithm and generate ciphertexts.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Shafi Goldwasser, Yael Kalai, Raluca Ada Popa and Charles Rackoff for a number of insightful conversations that helped improve the presentation of the impossibility result. We would also like to thank Adam O’Neill and Amit Sahai for helpful pointers and discussions.</p>

    <h2 id="sec-29" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[ABV^{+}12] Shweta Agrawal, Xavier Boyen, Vinod Vaikuntanathan, Panagiotis Voulgaris, and Hoeteck Wee. Functional encryption for threshold functions (or fuzzy IBE) from lattices. In PKC, 2012.</li>

      <li>[AFV11] Shweta Agrawal, David Mandell Freeman, and Vinod Vaikuntanathan. Functional encryption for inner product predicates from learning with errors. In Asiacrypt, 2011.</li>

      <li>[BB11] Dan Boneh and Xavier Boyen. Efficient selective identity-based encryption without random oracles. J. Cryptology, 24(4):659–693, 2011.</li>

      <li>[BF01] Dan Boneh and Matthew K. Franklin. Identity-based encryption from the weil pairing. In CRYPTO, pages 213–229, 2001.</li>

      <li>[BGW88] Michael Ben-Or, Shafi Goldwasser, and Avi Wigderson. Completeness theorems for non-cryptographic fault-tolerant distributed computation. In Proceedings of the twentieth annual ACM symposium on Theory of computing, STOC ’88, pages 1–10, New York, NY, USA, 1988. ACM.</li>

      <li>[BMQU07] Michael Backes, Jörn Müler-Quade, and Dominique Unruh. On the necessity of rewinding in secure multiparty computation. In Proceedings of the 4th conference on Theory of cryptography, TCC’07, pages 157–173, Berlin, Heidelberg, 2007. Springer-Verlag.</li>

      <li>[BMR90] Donald Beaver, Silvio Micali, and Phillip Rogaway. The round complexity of secure protocols (extended abstract). In STOC, pages 503–513, 1990.</li>

      <li>[BO12] Mihir Bellare and Adam O’Neill. Semantically-secure functional encryption: Possibility results, impossibility results and the quest for a general definition. Cryptology ePrint Archive, Report 2012/515, 2012.</li>

      <li>[BS05] Boaz Barak and Amit Sahai. How to play almost any mental game over the net - concurrent composition via super-polynomial simulation. In FOCS, pages 543–552, 2005.</li>

      <li>[BSW11] Dan Boneh, Amit Sahai, and Brent Waters. Functional encryption: Definitions and challenges. In TCC, pages 253–273, 2011.</li>

      <li>[BW06] Xavier Boyen and Brent Waters. Anonymous hierarchical identity-based encryption (without random oracles). In CRYPTO, pages 290–307, 2006.</li>

      <li>[CHK03] Ran Canetti, Shai Halevi, and Jonathan Katz. A forward-secure public-key encryption scheme. In EUROCRYPT, pages 255–271, 2003.</li>

      <li>[Coc01] Clifford Cocks. An identity based encryption scheme based on quadratic residues. In IMA Int. Conf., pages 360–363, 2001.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[DKXY02] Yevgeniy Dodis, Jonathan Katz, Shouhuai Xu, and Moti Yung. Key-insulated public key cryptosystems. In In EUROCRYPT, pages 65–82. Springer-Verlag, 2002.</li>

      <li>[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In STOC, pages 416–426, 1990.</li>

      <li>[GGM86] Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. J. ACM, 33(4):792–807, 1986.</li>

      <li>[GK05] Shafi Goldwasser and Yael Tauman Kalai. On the impossibility of obfuscation with auxiliary input. In FOCS, pages 553–562, 2005.</li>

      <li>[GLW12] Shafi Goldwasser, Allison B. Lewko, and David A. Wilson. Bounded-collusion IBE from key homomorphism. In TCC, pages 564–581, 2012.</li>

      <li>[GPSW06] Vipul Goyal, Omkant Pandey, Amit Sahai, and Brent Waters. Attribute-based encryption for fine-grained access control of encrypted data. In ACM Conference on Computer and Communications Security, pages 89–98, 2006.</li>

      <li>[GVW12] Sergey Gorbunov, Vinod Vaikuntanathan, and Hoeteck Wee. Functional encryption with bounded collusions from multiparty computation. In CRYPTO, 2012. To appear.</li>

      <li>[HILL99] Johan Håstad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom generator from any one-way function. SIAM J. Comput., 28(4):1364–1396, 1999.</li>

      <li>[KSW08] Jonathan Katz, Amit Sahai, and Brent Waters. Predicate encryption supporting disjunctions, polynomial equations, and inner products. In EUROCRYPT, pages 146–162, 2008.</li>

      <li>[Lin04] Yehuda Lindell. Lower bounds and impossibility results for concurrent self composition. the Journal of Cryptology, 2004.</li>

      <li>[LOS^{+}10] Allison B. Lewko, Tatsuaki Okamoto, Amit Sahai, Katsuyuki Takashima, and Brent Waters. Fully secure functional encryption: Attribute-based encryption and (hierarchical) inner product encryption. In EUROCRYPT, pages 62–91, 2010.</li>

      <li>[MPR06] Silvio Micali, Rafael Pass, and Alon Rosen. Input-indistinguishable computation. In FOCS, pages 367–378, 2006.</li>

      <li>[Nie02] Jesper Buus Nielsen. Separating random oracle proofs from complexity theoretic proofs: The non-committing encryption case. In CRYPTO, pages 111–126, 2002.</li>

      <li>[O’N10] Adam O’Neill. Definitional issues in functional encryption. Cryptology ePrint Archive, Report 2010/556, 2010. http://eprint.iacr.org/.</li>

      <li>[Pas03] Rafael Pass. Simulation in quasi-polynomial time and its application to protocol composition. In EUROCRYPT, pages 160–176, 2003.</li>

      <li>[PRS02] Manoj Prabhakaran, Alon Rosen, and Amit Sahai. Concurrent zero knowledge with logarithmic round-complexity. In In 43rd FOCS, pages 366–375, 2002.</li>

    </ul>

    <p class="text-gray-300">[PRV12] Bryan Parno, Mariana Raykova, and Vinod Vaikuntanathan. How to delegate and verify in public: Verifiable computation from attribute-based encryption. In Ronald Cramer, editor, TCC, volume 7194 of Lecture Notes in Computer Science, pages 422-439. Springer, 2012. [PS04] Manoj Prabhakaran and Amit Sahai. New notions of security: achieving universal composability without trusted setup. In STOC, pages 242-251, 2004. [Sha84] Adi Shamir. Identity-based cryptosystems and signature schemes. In CRYPTO, pages 47-53, 1984. [SS10] Amit Sahai and Hakan Seyalioglu. Worry-free encryption: functional encryption with public keys. In ACM Conference on Computer and Communications Security, pages 463-472, 2010. [SSW09] Emily Shen, Elaine Shi, and Brent Waters. Predicate privacy in encryption systems. In TCC, pages 457-473, 2009. [SW05] Amit Sahai and Brent Waters. Fuzzy identity-based encryption. In EUROCRYPT, pages 457-473, 2005. [SW08] Amit Sahai and Brent Waters. Slides on functional encryption. Power Point Presentation, 2008. http://www.cs.utexas.edu/~bwaters/presentations/files/functional.ppt, 2008. [Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In FOCS, pages 162-167, 1986.</p>

    <p class="text-gray-300">Definition A.1 (NA-IND- and AD-IND-Security). Let  <span class="math">\\mathcal{F}\\mathcal{E}</span>  be a functional encryption scheme for a family of circuits  <span class="math">\\mathcal{C}</span> . For every p.p.t. adversary  <span class="math">A = (A_{1}, A_{2})</span> , consider the following two experiments:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp(0)F.E,A(1κ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp(1)F.E,A(1κ):</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: (MPK, MSK) ← FE.Setup(1κ)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1: (MPK, MSK) ← FE.Setup(1κ)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: (x0, x1, st) ← A1FE.Keygen(MSK,·)(MPK)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2: (x0, x1, st) ← A1FE.Keygen(MSK,·)(MPK)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: CT ← FE.Enc(MPK, x0)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3: CT ← FE.Enc(MPK, x1)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: b ← A2O(MSK,·)(MPK, CT, st)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4: b ← A2O(MSK,·)(MPK, CT, st)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: Output b</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5: Output b</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Define an admissible adversary  <span class="math">A = (A_{1}, A_{2})</span>  as one such that for each oracle query  <span class="math">C</span>  of  <span class="math">A</span> ,  <span class="math">C(x_{0}) = C(x_{1})</span> . We distinguish between two cases of the above experiment:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adaptive experiment, where the oracle  <span class="math">\\mathcal{O}(\\mathsf{MSK},\\cdot) = \\mathsf{FE},\\mathsf{Keygen}(\\mathsf{MSK},\\cdot)</span> : the functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is said to be indistinguishable-secure for one message against adaptive</li>

    </ol>

    <p class="text-gray-300">adversaries (1-AD-IND-secure, for short) if for every polynomial function  <span class="math">\\ell = \\ell(\\kappa)</span>  and every admissible p.p.t. admissible adversary  <span class="math">A = (A_1, A_2)</span> , the advantage of  <span class="math">A</span>  defined as below is negligible in the security parameter  <span class="math">\\kappa</span> :</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {A d v} _ {\\mathcal {F E}, A} (\\kappa) := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr [ \\operatorname {E x p} _ {\\mathcal {F E}, A} ^ {(0)} (1 ^ {\\kappa}) = 1 ] - \\Pr [ \\operatorname {E x p} _ {\\mathcal {F E}, A} ^ {(1)} (1 ^ {\\kappa}) = 1 ] \\right</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the probability is over the random coins of the algorithms of the scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  and that of  <span class="math">A</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The non-adaptive experiment, where the oracle  <span class="math">\\mathcal{O}(\\mathsf{MSK},\\cdot)</span>  is the "empty oracle" that returns nothing: the functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is said to be indistinguishable-secure for one message against non-adaptive adversaries (1-NA-IND-secure, for short) if for every admissible p.p.t. adversary  <span class="math">A = (A_{1},A_{2})</span> , the advantage of  <span class="math">A</span>  defined as above is negligible in the security parameter  <span class="math">\\kappa</span> .</li>

    </ol>

    <p class="text-gray-300">We do not distinguish between one and many message security since this definition composes [GVW12].</p>

    <h2 id="sec-31" class="text-2xl font-bold">B Many-Message Simulation-based Definition of Security</h2>

    <p class="text-gray-300">Definition B.1 (many-NA-SIM- and many-AD-SIM- Security). Let  <span class="math">\\mathcal{F}\\mathcal{E}</span>  be a functional encryption scheme for a family of circuit  <span class="math">\\mathcal{C}</span> . Let  <span class="math">U_{x}(\\cdot)</span>  denote the universal oracle that on input  <span class="math">C</span>  returns  <span class="math">U_{x}(C) = C(x)</span> . Consider a p.p.t. adversary  <span class="math">A = (A_{1}, A_{2})</span>  and a stateful p.p.t. simulator Sim. Consider the following two experiments:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp real <span class="math">\\mathcal{F}\\mathcal{E},A</span> <span class="math">(1^{\\kappa})</span>:</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Exp ideal <span class="math">\\mathcal{F}\\mathcal{E},\\mathrm{Sim}(1^{\\kappa})</span>:</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">1: (MPK, MSK) ← FE.Setup(1^{κ})</td>

            <td class="px-3 py-2 border-b border-gray-700">1: MPK ← Sim(1^{κ})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2: ( <span class="math">\\{x_i\\}_{i\\in[\\ell]},st \\}) ← A_1^{\\mathrm{FE.Keygen(MSK},\\cdot)}(\\mathrm{MPK})</span></td>

            <td class="px-3 py-2 border-b border-gray-700">2: ( <span class="math">\\{x_i\\}_{i\\in[\\ell]},st \\}) ← A_1^{\\mathrm{Sim}(\\cdot)}(\\mathrm{MPK})</span></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3: CT_{i} ← FE.Enc(MPK, x_{i}) for all i ∈ [ℓ]</td>

            <td class="px-3 py-2 border-b border-gray-700">3: {CT_{i}}_{i\\in[\\ell]} ← Sim{U_{x_{i}(·)}_{i\\in[\\ell]}(\\{1^{</td>

            <td class="px-3 py-2 border-b border-gray-700">x_i</td>

            <td class="px-3 py-2 border-b border-gray-700">}\\}_{i\\in[\\ell]})}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">4: α ← A_2^{\\mathcal{O}(\\mathrm{MSK},\\cdot)}(\\mathrm{MPK},\\{\\mathrm{CT}_i\\}_{i\\in[\\ell]},st)$</td>

            <td class="px-3 py-2 border-b border-gray-700">4: α ← A_2^{\\mathcal{O}'(\\cdot)}(\\mathrm{MPK},\\{\\mathrm{CT}_i\\}_{i\\in[\\ell]},st)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">5: Output ( <span class="math">\\{x_i\\}_{i\\in[\\ell]}, \\alpha</span>)</td>

            <td class="px-3 py-2 border-b border-gray-700">5: Output ( <span class="math">\\{x_i\\}_{i\\in[\\ell]}, \\alpha</span>)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We distinguish between two cases of the above experiment:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The adaptive experiment, where:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the oracle  <span class="math">\\mathcal{O}(\\mathrm{MSK},\\cdot) = \\mathrm{FE.Keygen}(\\mathrm{MSK},\\cdot)</span> , and</li>

      <li>the oracle  <span class="math">\\mathcal{O}&#x27;(\\cdot)</span>  is the simulator, namely  <span class="math">\\operatorname{Sim}^{\\{U_{x_i}(\\cdot)\\}_{i\\in [\\ell]}}(\\cdot)</span> .</li>

    </ul>

    <p class="text-gray-300">We call a stateful simulator algorithm Sim admissible if, on each input  <span class="math">C</span> , Sim makes just a single query to its oracle  <span class="math">U_{x}(\\cdot)</span>  on  <span class="math">C</span>  itself.</p>

    <p class="text-gray-300">The functional encryption scheme  <span class="math">\\mathcal{F}\\mathcal{E}</span>  is then said to be simulation-secure for many messages against adaptive adversaries (many-AD-SIM-secure, for short) if there is an admissible stateful</p>

    <p class="text-gray-300">p.p.t. simulator Sim such that for every polynomial function <span class="math">\\ell=\\ell(\\kappa)</span>, every p.p.t. adversary <span class="math">A=(A_{1},A_{2})</span>, the following two distributions are computationally indistinguishable:</p>

    <p class="text-gray-300"><span class="math">\\left\\{\\mathsf{Exp}^{\\mathsf{real}}_{\\mathcal{F}\\mathcal{E},A}(1^{\\kappa})\\right\\}_{\\kappa\\in\\mathbb{N}}\\stackrel{{\\scriptstyle c}}{{\\approx}}\\left\\{\\mathsf{Exp}^{\\mathsf{ideal}}_{\\mathcal{F}\\mathcal{E},\\mathrm{Sim}}(1^{\\kappa})\\right\\}_{\\kappa\\in\\mathbb{N}}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The non-adaptive experiment, where the oracles <span class="math">\\mathcal{O}(\\mathsf{MSK},\\cdot)</span> and <span class="math">\\mathcal{O}^{\\prime}(\\cdot)</span> are both the “empty oracles” that return nothing.</li>

    </ol>

    <p class="text-gray-300">The functional encryption scheme <span class="math">\\mathcal{F}\\mathcal{E}</span> is then said to be simulation-secure for many messages against non-adaptive adversaries (many-<span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{SIM}</span>-secure, for short) if there is an admissible stateful p.p.t. simulator <span class="math">\\mathrm{Sim}</span> such that for every polynomial function <span class="math">\\ell=\\ell(\\kappa)</span>, every p.p.t. adversary <span class="math">A=(A_{1},A_{2})</span>, the two distributions above are computationally indistinguishable.</p>

    <p class="text-gray-300">We define many-<span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}</span> and many-<span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM}</span> identically to the above definition, except with computationally unbounded simulator.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Appendix C Indistinguishability and Unbounded Simulation</h2>

    <p class="text-gray-300">In this section, we put forth the notion of unbounded-simulation secure functional encryption. We argue that this is a very natural notion of security, with counterparts in the worlds of multiparty computation and zero knowledge <em>[x20, x21, x3]</em>. Unbounded simulation security further elucidates the power and limitations of indistinguishability-based definitions, and captures the spirit of some known separations (see below).</p>

    <p class="text-gray-300">The definition of unbounded-simulation security (in both the adaptive and non-adaptive settings) is the same as Definition 2.2, except that the simulator is not restricted to run in polynomial time.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">C.1 Relationship between SIM, USIM and IND</h3>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem C.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{F}\\mathcal{E}</span> be a functional encryption scheme for a family of circuits <span class="math">\\mathcal{C}</span>. Then, if <span class="math">\\mathrm{FE}</span> is <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{SIM}</span> (resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{SIM}</span>) secure then it is also <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}</span> (resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM}</span>) secure. In addition, if <span class="math">\\mathrm{FE}</span> is <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}</span>(resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM}</span>) secure then it is <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{IND}</span> (resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{IND}</span>) secure.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{SIM}(\\mathsf{NA}</span>-<span class="math">\\mathsf{SIM})\\Rightarrow\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}(\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM})</span>: This claim is trivial since the unbounded simulator can just run the poly-time simulator, in both the adaptive and non-adaptive cases.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}(\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM})\\Rightarrow\\mathsf{AD}</span>-<span class="math">\\mathsf{IND}(\\mathsf{NA}</span>-<span class="math">\\mathsf{IND})</span>: We prove this claim by showing the contrapositive. Let <span class="math">A=(A_{1},A_{2})</span> be the adversary that breaks <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{IND}</span>(resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{IND}</span>) security of the <span class="math">\\mathcal{F}\\mathcal{E}</span> scheme. We construct an adversary <span class="math">B=(B_{1},B_{2})</span> from <span class="math">A</span>. In our construction, if <span class="math">A</span> is a <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{IND}</span> (resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{IND}</span>) adversary, then <span class="math">B</span> is a <span class="math">\\mathsf{AD}</span>-<span class="math">\\mathsf{USIM}</span> (resp. <span class="math">\\mathsf{NA}</span>-<span class="math">\\mathsf{USIM}</span>) adversary.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">B_{1}^{\\mathsf{FE}.{\\mathsf{Keygen}}(\\mathsf{MSK},\\cdot)}(\\mathsf{MPK})</span>: Run <span class="math">A_{1}^{\\mathsf{FE}.{\\mathsf{Keygen}}(\\mathsf{MSK},\\cdot)}(\\mathsf{MPK})</span>. Answer <span class="math">A_{1}</span>’s key queries using <span class="math">\\mathsf{FE}.{\\mathsf{Keygen}}</span> oracle. Finally, <span class="math">A_{1}</span> outputs two messages <span class="math">x_{0},x_{1}</span> and a state <span class="math">st_{a}</span>. Now, choose a random bit <span class="math">b</span> and output <span class="math">(x,st)=(x_{b},[st_{a},x_{0},x_{1}])</span>.</li>

      <li><span class="math">B_{2}^{\\mathcal{O}(\\mathsf{MSK},\\cdot)}(\\mathsf{MPK},\\mathsf{CT},st)</span>: Invoke <span class="math">A_{2}^{\\mathcal{O}(\\mathsf{MSK},\\cdot)}(\\mathsf{MPK},\\mathsf{CT},st_{a})</span> and output whatever bit <span class="math">b^{\\prime}</span> it outputs. In the adaptive case, if <span class="math">A_{2}</span> makes any oracle queries, answer them using own oracle.</li>

    </ul>

    <p class="text-gray-300">The output of the real experiment is <span class="math">(x_{b},st=[st_{a},x_{0},x_{1}],\\alpha=b^{\\prime},C_{1},\\ldots,C_{q})</span>. Hence, with probability significantly greater than a half <span class="math">b=b^{\\prime}</span> and the distinguisher can verify this. Now we claim that there is no unbounded simulator <span class="math">\\mathrm{Sim}_{u}</span> for the adversary <span class="math">(B_{1},B_{2})</span> in the adaptive or non-adaptive case. In particular, we argue that the simulator <span class="math">\\mathrm{Sim}_{u}</span> cannot guess bit <span class="math">b^{\\prime}</span> with probability better than a half. We observe:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The IND adversary <span class="math">A=(A_{1},A_{2})</span> is admissible, hence, for all queries <span class="math">\\{C^{\\prime}_{i}\\}_{i\\in[q^{\\prime}]}</span> that <span class="math">A</span> makes to <span class="math">B</span>, and hence <span class="math">B</span> makes to <span class="math">\\mathrm{Sim}_{u}</span>, we have that <span class="math">C^{\\prime}_{i}(x_{0})=C^{\\prime}_{i}(x_{1})</span>. The view of <span class="math">\\mathrm{Sim}_{u}</span> is statistically independent of the challenge bit <span class="math">b</span>.</li>

      <li>Since the queries <span class="math">C_{1},\\ldots,C_{q}</span> are part of the output of the experiment, <span class="math">\\mathrm{Sim}_{u}</span> is restricted to make admissible queries only to the function oracle, otherwise a distinguisher can easily distinguish between the real and ideal worlds. Thus, it must be the case that <span class="math">C_{i}(x_{0})=C_{i}(x_{1}),\\;\\forall i\\in[q]</span>. Hence, the view of <span class="math">\\mathrm{Sim}_{u}</span> is also statistically independent of the challenge bit <span class="math">b</span>.</li>

    </ul>

    <p class="text-gray-300">Putting these together, we deduce that the view of the simulator is statistically independent of the challenge bit <span class="math">b</span>, thus the probability it guesses <span class="math">b</span> correctly is at most <span class="math">1/2</span>. Therefore, the simulator <span class="math">\\mathrm{Sim}_{u}</span> cannot produce the output indistinguishable from the real experiment.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">C.2 Impossibility of AD-USIM IBE</h3>

    <p class="text-gray-300">We observe that the impossibility of realizing the IBE functionality under many-AD-SIM as shown in <em>[x10, Section 5.1]</em> (which is in turn similar to the impossibility result for non-committing encryption given in <em>[x30]</em>) extends to many-AD-USIM. For self containment, we provide a recap of the argument.</p>

    <p class="text-gray-300">Let <span class="math">\\kappa</span> denote the security parameter and <span class="math">\\ell</span> be an upper bound on the secret key length produced by FE.Keygen for security parameter <span class="math">\\kappa</span>. Assume that both the identity and the payload message are bits. Then, the real world adversary behaves as follows (refer to Definition 2.2) (1) <span class="math">A_{1}</span> makes no secret key queries and outputs <span class="math">\\mathbf{x}=\\{(0,x_{0},0),\\ldots,(0,x_{\\ell+\\kappa})\\}</span> where each <span class="math">x_{i},\\;i\\in[\\ell+\\kappa]</span> is a uniformly random bit, and all payload messages correspond to identity <span class="math">0</span>. (2) The adaptive adversary <span class="math">A_{2}</span> requests for the <span class="math">\\mathsf{SK}_{0}</span>.</p>

    <p class="text-gray-300">Note that the admissible simulator <span class="math">\\mathrm{Sim}</span> can only query the function oracle <span class="math">U_{x_{i}}(\\cdot)</span> after <span class="math">A_{2}</span> requests the secret key <span class="math">\\mathsf{SK}_{0}</span>, and thus cannot learn the payload bits until such point. However, <span class="math">\\mathrm{Sim}</span> has to simulate the tuple of <span class="math">\\ell+\\kappa</span> ciphertexts before it sees the actual payload bits. Thus, the simulator has to produce a fixed string of CTs which, upon decryption with an <span class="math">\\ell</span> bit secret key, need to produce an arbitrary <span class="math">\\ell+\\kappa</span> bits – which is impossible. This argument holds even if the simulator is computationally unbounded, hence we conclude that many-AD-USIM is impossible, even for IBE.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">C.3 Illustrative Examples and Discussion</h3>

    <p class="text-gray-300">In this section we discuss some examples to separate the various notions of security.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">AD-SIM and AD-USIM</h4>

    <p class="text-gray-300">: We observe the following example from <em>[x10, Section 4.2]</em> separating AD-SIM and AD-IND also separates AD-SIM and AD-USIM. Let <span class="math">\\pi</span> be a one-way permutation and consider the circuit family <span class="math">\\mathcal{C}</span> consisting of a single circuit <span class="math">C</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">C(x)=\\pi(x)</span></p>

    <p class="text-gray-300">Note that this circuit satisfies our “litmus test” in 1.2 for checking if IND security is inadequate — <span class="math">\\pi(x)</span> hides <span class="math">x</span> from a computationally bounded adversary, but reveals <span class="math">x</span> to an unbounded adversary.</p>

    <p class="text-gray-300">Now, consider the FE.Enc algorithm that outputs a public-key encryption of <span class="math">x</span> on input <span class="math">x</span>; FE.Keygen algorithm that outputs the secret key for the public-key encryption on input <span class="math">C</span>; FE.Dec recovers <span class="math">x</span> and outputs <span class="math">\\pi(x)</span>. It was shown in <em>[x1]</em> that this scheme AD-IND-secure but not AD-SIM-secure. We observe that this scheme is also AD-USIM-secure, provided the underlying encryption scheme is “non-committing” (c.f. <em>[x11, Section 4.1]</em>). The simulator proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the adversary makes a secret key query before seeing the ciphertext, then the simulator learns <span class="math">\\pi(x)</span> by querying the oracle on <span class="math">C</span>, and then computes <span class="math">x</span> via “brute force” and encrypts it.</li>

      <li>Otherwise, the simulator generates a “non-committing” simulated ciphertext. If the adversary makes a secret key query after seeing the ciphertext, then the simulator learns <span class="math">\\pi(x)</span> by querying the oracle on <span class="math">C</span>, computes <span class="math">x</span> via “brute force”, and generates a consistent secret key.</li>

    </ul>

    <h5 id="sec-39" class="text-base font-semibold mt-4">AD-IND and AD-USIM</h5>

    <p class="text-gray-300">: We do not have a natural example of a scheme which is AD-IND-secure but not AD-USIM-secure, which we leave as an open problem. We point out that the naive approach of replacing the one-way permutation in the preceding example with a collision resistant hash function does not seem to work; if the encryptor picks the hash function, then the adversary could potentially pick a “bad” hash function for which it knows a pair of collisions.</p>

    <h5 id="sec-40" class="text-base font-semibold mt-4">Summary.</h5>

    <p class="text-gray-300">We summarize some of the properties of USIM security: (1) It clarifies the inadequacy of indistinguishability-based security definitions as pointed out in <em>[x1, Section 4.2]</em>; specifically, the statement therein that “game-based formulation essentially ignores any computational hiding properties of the circuits, and therefore offers no security guarantees that could be meaningfully combined with such computational considerations”, is really a statement about USIM security. (2) It potentially admits realizations for a large class of circuits; it allows us to circumvent our 1-NA-SIM lower bound, but is nonetheless ultimately limited by many-AD-SIM lower bound for IBE. (3) Unbounded simulation is a natural notion, with analogues in zero knowledge and secure computation <em>[x22, x23, x2]</em>, and comparisons with these can aid our understanding of functional encryption. (4) For certain circuit families, USIM may be “good enough”; understanding when this happens could further clarify existing constructions.</p>`;
---

<BaseLayout title="Functional Encryption: New Perspectives and Lower Bounds (2012/468)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2012 &middot; eprint 2012/468
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
