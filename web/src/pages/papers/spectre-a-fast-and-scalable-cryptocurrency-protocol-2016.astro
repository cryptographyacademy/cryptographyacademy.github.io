---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/1159';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'SPECTRE: A Fast and Scalable Cryptocurrency Protocol';
const AUTHORS_HTML = 'Yonatan Sompolinsky, Yoad Lewenberg, Aviv Zohar';

const CONTENT = `    <p class="text-gray-300">SPECTRE: Serialization of Proof-of-work Events: Confirming Transactions via Recursive Elections Yonatan Sompolinsky, Yoad Lewenberg, and Aviv Zohar School of Engineering and Computer Science, The Hebrew University of Jerusalem, Israel {yoni_sompo,yoadlew,avivz}@cs.huji.ac.il</p>

    <h6 id="sec-1" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Bitcoin utilizes the Nakamoto Consensus to achieve agreement on a consistent set of transactions, in the permissionless setting, where anyone can participate in the protocol anonymously. Since its rise, many other permissionless consensus protocols have been proposed. We present SPECTRE, a new protocol for the consensus core of cryptocurrencies that remains secure even under high throughput and fast confirmation times. At any throughput, SPECTRE is resilient to attackers with up to 50% of the computational power (reaching the limit defined by network congestion and bandwidth constraints). SPECTRE can operate at arbitrarily high block creation rates, which implies that its transactions confirm in mere seconds (limited mostly by the round-trip-time in the network).</p>

    <p class="text-gray-300">SPECTRE’s underlying model falls into the category of partial synchronous networks: its security depends on the existence of some bound on the delivery time of messages between honest participants, but the protocol itself does not contain any parameter that depends on this bound. Hence, while other protocols that do encode such parameters must operate with extreme safety margins, SPECTRE converges according to the actual network delay.</p>

    <p class="text-gray-300">Key to SPECTRE’s achievements is the fact that it satisfies weaker properties than classic consensus requires. In the conventional paradigm, the order between any two transactions must be decided and agreed upon by all non-corrupt nodes. In contrast, SPECTRE only satisfies this with respect to transactions performed by honest users. We observe that in the context of money, two conflicting payments that are published concurrently could only have been created by a dishonest user, hence we can afford to delay the acceptance of such transactions without harming the usability of the system. Our framework formalizes this weaker set of requirements for a cryptocurrency’s distributed ledger. We then provide a formal proof that SPECTRE satisfies these requirements.</p>

    <h2 id="sec-2" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Bitcoin is a novel cryptocurrency system, and an accompanying protocol, invented and deployed by Satoshi Nakamoto <em>[13]</em>. Transactions made in the currency are organized in a public ledger, the blockchain. Each block in the chain is a batch of transactions that were published by users of the currency. The blockchain contains consistent transactions only, as new blocks that extend it are required to maintain consistency.</p>

    <p class="text-gray-300">Unfortunately, Nakamoto Consensus has severe scalability limitations <em>[5, 18, 14]</em>: adjusting the protocol to support a high transaction throughput – by creating larger or more frequent blocks – requires stronger assumptions on the underlying network, hence smaller safety margins.</p>

    <p class="text-gray-300">In this paper we propose a new protocol, SPECTRE, that achieves high scalability. Transactions in SPECTRE can be confirmed within seconds, and the throughput can be improved by orders-of-magnitude over Bitcoin; it is limited by the network infrastructure and capacity only. The protocol thus alleviates the security-scalablility trade-off imposed by Nakamoto Consensus.</p>

    <p class="text-gray-300">In SPECTRE, every block is counted and integrated into the ledger. Technically, SPECTRE generalizes Nakamoto’s blockchain into a direct acyclic graph – a block DAG. By maintaining a full DAG of blocks, SPECTRE can allow miners to create blocks concurrently and much more frequently. This design is intended to avoid the need for nodes to reconcile their different world views regarding the identity of a selected chain at the time of block creation.</p>

    <p class="text-gray-300">Reasoning about the consensus properties of SPECTRE requires a new formal framework. Indeed, previous work that formalized the robustness of Nakamoto Consensus <em>[7, 15]</em> focused on robustness of blocks in the ledger. Extending this to the robustness of transactions in SPECTRE is not immediate, because all blocks are incorporated into the DAG, but individual transactions embedded in the DAG may still be rejected due to conflicts.</p>

    <p class="text-gray-300">Thus, this paper contains two contributions: (1) an inherently scalable protocol, SPECTRE; and (2) a formal framework for cryptocurrency payment protocols that do not necessarily use a chain of blocks to represent their ledger (in this respect we differ from previously proposed frameworks). We apply it on SPECTRE, and provide rigorous analysis of SPECTRE’s robustness properties.</p>

    <p class="text-gray-300">The main technique behind SPECTRE is a voting algorithm regarding the order between each pair of blocks in the DAG. The voters are blocks (not miners); the vote of each block is interpreted algorithmically (and not provided interactively) according to its location within the DAG. We show that the majority’s aggregate vote becomes irreversible very fast, and we use this majority vote to extract a consistent set of transactions. Essentially, Bitcoin’s longest chain rule can be seen as a voting mechanism as well – each block adding one vote to every chain that contains it – the highest-scoring chain being also the longest one. However, Bitcoin’s selection of a “single winner chain” makes it inherently unscalable, as we demonstrate below.</p>

    <p class="text-gray-300">We note that there have been several recent works revolving around new protocols for public blockchain systems. These include Bitcoin-NG <em>[6]</em>, Byzcoin <em>[9]</em>, a work by Decker et. al. <em>[4]</em>, Hybrid Consensus <em>[16]</em>, Solidus <em>[1]</em>, and recently Algorand <em>[11]</em>. We discuss these and other related works in Section 6.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2. Formal Statement of the Problem</h2>

    <p class="text-gray-300">In this section we describe a generic framework for reasoning about the security and scalability properties of cryptocurrency protocols. Generally, in our framework, a cryptocurrency protocol specifies two sets of instructions – <em>the mining protocol</em>, regarding the creation of blocks and formation of the block ledger, and <em>the TxO protocol</em>, interpreting the ledger and extracting from it a consistent subset of valid transactions. Since transactions in the protocol are accepted with increasing probability as time goes on, users additionally run <em>the Robust TxO protocol</em>, to quantify the <em>robustness</em> of an accepted transaction – a bound on the probability that it will ever be reversed, when a malicious attacker attempts to do so (Bitcoin transactions for example, can be reversed if the attacker manages to produce a longer alternative chain on which they are not present – this event occurs with decreasing probability as time passes). Next, we present our framework in the abstract sense, so as to keep it as general as possible. In Section 4, we present a protocol that meets the requirements and uses a block DAG to do so. We defer the specifics of the solution and the mining protocol, till then. We will use our framework to make clear the sense in which SPECTRE avoids the security-scalability trade-off that Bitcoin suffers from.</p>

    <p class="text-gray-300">Transactions. A transaction is typically denoted <span class="math">tx.\\;inputs\\,(tx)</span> is the set of transactions that must be accepted before <span class="math">tx</span> can be accepted; these are the transactions that have provided the money that is being spent in <span class="math">tx</span>. Two different transactions <span class="math">tx_{1}</span> and <span class="math">tx_{2}</span> conflict if they share a common input, i.e., they double spend the same money; we then write <span class="math">tx_{2}\\in conflict\\,(tx_{1})</span> (this is a symmetric relation).</p>

    <p class="text-gray-300">Mining protocol. We denote by <span class="math">\\mathcal{N}</span> the set of nodes, aka miners. Miners maintain and extend the ledger, by adding transactions to it and propagating messages, according to <em>the mining protocol</em>. The propagation time of a message of size <span class="math">B</span> KB to all nodes in the system is assumed to be under <span class="math">D=D(B)</span> seconds. For now, we regard the mining protocol as an abstract set of rules that miners must follow. We denote by <span class="math">honest</span> the set of nodes that always follow the protocol’s instructions, and by <span class="math">malicious</span> the complementary of this set.</p>

    <p class="text-gray-300">In the family of protocols we focus on, miners possess computational power and perform proof-of-work (PoW). We denote by <span class="math">\\alpha</span> the attacker’s relative computational power. Formally, it is the probability that the creator of the next PoW in the system belongs <span class="math">malicious</span>; this is well defined, as PoW creation is modeled as a memoryless process <em>[13, 18, 17]</em>.</p>

    <p class="text-gray-300">Formation of ledger. The result of the mining protocol is an (abstract) public data structure <span class="math">G</span> containing transactions (to be instantiated later, in our solution proposal, as a block DAG), aka the ledger. Nodes replicate the ledger locally. As they might hold slightly different views of the ledger (e.g., since blocks take time to propagate to all nodes), we denote by <span class="math">G^{v}_{t}</span> the state of the ledger as observed by node <span class="math">v</span> at time <span class="math">t</span>; we write <span class="math">G_{t}</span> when the local context is unimportant.</p>

    <p class="text-gray-300">TxO protocol. Given a public ledger <span class="math">G</span>, <em>the TxO protocol</em> extracts a consistent subset of transactions from <span class="math">G</span>, denoted <span class="math">TxO(G)</span>. Every transaction in this set must have its inputs in it as well, and cannot conflict with another transaction in the set.</p>

    <p class="text-gray-300">Robust TxO protocol. Users of the system must get assurances regarding their payments. Basically, we want to guarantee that transactions will be accepted by all users, and that they</p>

    <p class="text-gray-300">will remain so forever. Given <span class="math">G_{t}</span>, <em>the RobustTxO protocol</em> specifies a subset of <span class="math">TxO(G_{t})</span>, denoted <span class="math">RobustTxO(G_{t})</span>, which represents the set of accepted transactions that are guaranteed to remain so forever, up to an error probability of <span class="math">\\epsilon</span>. <span class="math">RobustTxO</span> takes as input <span class="math">G_{t}^{v}</span> (the local replicate of <span class="math">v</span>), and the values of <span class="math">D</span>,<span class="math">\\lambda</span>,<span class="math">\\alpha</span>, and <span class="math">\\epsilon</span>. A <span class="math">tx</span> in (<span class="math">Robust</span>) <span class="math">TxO</span> is said to be <em>(robustly) accepted</em>.</p>

    <p class="text-gray-300">Desired properties. Thus, the following properties are essential for a cryptocurrency protocol:</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Property 1 (Consistency).</h6>

    <p class="text-gray-300">The accepted set is consistent: For any ledger <span class="math">G</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">tx\\in TxO(G)</span> and <span class="math">tx_{2}\\in inputs\\left(tx\\right)</span> then <span class="math">tx_{2}\\in TxO(G)</span>.</li>

      <li>if <span class="math">tx\\in TxO(G)</span> and <span class="math">tx_{2}\\in conflict\\left(tx\\right)</span> then <span class="math">tx_{2}\\notin TxO(G)</span>.</li>

    </ol>

    <h6 id="sec-5" class="text-base font-medium mt-4">Property 2 (Safety).</h6>

    <p class="text-gray-300">If a transaction is robustly accepted by some node, then w.h.p. it will be robustly accepted forever by all nodes, and the expected waiting time for this event is constant. Formally, <span class="math">\\forall\\epsilon&gt;0</span>, <span class="math">\\forall v\\in\\mathcal{N}</span>, if <span class="math">tx\\in RobustTxO(G_{t}^{\\textbf{v}},D,\\lambda,\\alpha,\\epsilon)</span>, then w.p. of at least <span class="math">1-\\epsilon</span>, there exists a time <span class="math">\\tau\\geq t</span> such that <span class="math">\\forall u\\in\\mathcal{N},\\forall s\\geq\\tau:tx\\in RobustTxO(G_{s}^{\\textbf{u}},D,\\lambda,\\alpha,\\epsilon)</span>. If this event occurs, the expected value of <span class="math">\\tau-t</span> is constant.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Property 3 (Weak Liveness).</h6>

    <p class="text-gray-300">If a transaction is published in the ledger, it is robustly accepted by any node after a short while, provided that its inputs are robustly accepted and that no conflicting transactions are published. Formally, let <span class="math">v\\in\\mathcal{N}</span>, <span class="math">tx\\in G_{t}^{v}</span>, and <span class="math">\\epsilon&gt;0</span>. Define by <span class="math">\\psi\\left(t,D,\\lambda,\\alpha,\\epsilon\\right):=\\min\\left\\{s\\geq t:tx\\in RobustTxO(G_{s}^{v},D,\\lambda,\\alpha,\\epsilon)\\right\\}</span> the waiting time for its robust acceptance by <span class="math">v</span>. Then, <span class="math">\\mathbb{E}\\left[\\psi-t\\mid inputs\\left(tx\\right)\\subseteq TxO(G_{\\psi}^{\\textbf{v}})\\wedge conflict\\left(tx\\right)\\cap G_{\\psi}^{v}=\\emptyset\\right]</span> is constant.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 1.</h6>

    <p class="text-gray-300">The <em>security threshold</em> of a cryptocurrency protocol is defined by the maximal <span class="math">\\alpha</span> (attacker’s relative computational power) for which Properties 1-3 hold.</p>

    <p class="text-gray-300">The expected values of <span class="math">\\tau-t</span> and <span class="math">\\psi-t</span>, as written in Properties 2 and 3, define the expected waiting time for confirmation of transactions in the given protocol.</p>

    <p class="text-gray-300">The “weakness” of the Liveness property corresponds to the fact that we do not guarantee (though it is still hard for an attacker to prevent) a resolution in case conflicting transactions were published soon one after the other. Contrast this to traditional consensus protocols, where all conflicts are required to be decided in finite time, a property usually referred to as Liveness. Observe, however, that an honest user of the system will never publish conflicting transactions, and will transfer money only after he robustly accepted the original funds (the inputs) himself; payments of honest users are thus guaranteed to meet the conditions formalized in Weak Liveness, and to be robustly accepted. On the other hand, an attacker trying to defraud must keep his attack secret before publishing the conflict, until the victim robustly accepts; but then the victim is guaranteed that w.h.p. his transaction will not be reversed. Therefore, these two properties together ensure that payments of honest users will be robustly accepted in constant expected time, and that they remain robustly accepted forever, w.h.p.</p>

    <p class="text-gray-300">In this work we set out to design a protocol that can support a large throughput, and achieve fast confirmation times, while maintaining a high security threshold.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 SPECTRE vs Bitcoin – Overview</h2>

    <p class="text-gray-300">SPECTRE adopts many of Bitcoin’s solution features. In particular, miners create <em>blocks</em>, which are batches of transactions. A valid block must contain a solution to the PoW puzzle (Bitcoin for example, uses PoW that is based on partial SHA256 collisions). The block creation rate, denoted <span class="math">\\lambda</span>, is kept constant by the protocol by occasional readjustments of the PoW difficulty; we elaborate on this mechanism in SPECTRE in Appendix D. The size of a block is limited by some <span class="math">B</span> KB.</p>

    <p class="text-gray-300">Bitcoin’s throughput can be increased by increasing either the block size limit (which in turn increases <span class="math">D</span>) or\\and the block creation rate <span class="math">\\lambda</span>. Alas, it is well established that the security threshold of Nakamoto Consensus deteriorates as <span class="math">D\\cdot\\lambda</span> increases:</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">[Bitcoin is not scalable] The security threshold of the Bitcoin protocol goes to zero as <span class="math">D\\cdot\\lambda</span> increases.</p>

    <p class="text-gray-300">The proof of this theorem appears in various forms in previous works, see <em>[18, 15, 7]</em>. To maintain a high security threshold, Bitcoin suppresses its throughput by keeping <span class="math">\\lambda</span> low – 1/600 blocks per second. This large safety margin is needed because <span class="math">\\lambda</span> (and <span class="math">B</span>) are decided once and for all at the inception of the protocol. Consequently, even when the network is healthy and <span class="math">D</span> is low, Bitcoin suffers from a low throughput – 3 to 7 transactions per second, and slow confirmation times – tens of minutes. In contrast, SPECTRE’s throughput can be increased without deteriorating the security threshold:</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">[SPECTRE is scalable] For any <span class="math">D\\cdot\\lambda</span>, SPECTRE’s security threshold is 50%.</p>

    <p class="text-gray-300">Therefore, in the context of the Distributed Algorithms literature, SPECTRE falls into the partial synchronous setup, as it remains secure for any value of <span class="math">D</span>. Theorem 3 is proven rigorously in Appendix E.</p>

    <p class="text-gray-300">Of course, <span class="math">\\lambda</span> cannot be increased indefinitely or otherwise the network will be flooded with messages (blocks) and become congested. Theorem 3 “lives” in the theoretical framework (specified in Section 2), which does not model the limits on nodes’ bandwidth and network capacity. Practically, these barriers allow for a throughput of thousands of transactions per second, by setting <span class="math">\\lambda=10</span> and <span class="math">b=100</span>, for instance. For further discussion refer to Appendices B and D.</p>

    <p class="text-gray-300">Asymptotically, SPECTRE’s confirmation times are in <span class="math">\\mathcal{O}\\left(\\frac{\\ln(1/\\epsilon)}{\\lambda(1-2\\alpha)}+\\frac{D}{1-2\\alpha}\\right)</span>. In practice, this allows for confirmation times of mere seconds, under normal network conditions. When running <span class="math">RobustTxO</span>, each node in SPECTRE uses its own upper bound on the recent <span class="math">D</span> in the network. This bound affects only its own operation—underestimating <span class="math">D</span> will result in premature acceptance of transactions, and overestimating it by far will delay acceptance unnecessarily (by a time linear in the difference). Importantly, in case of network hiccups and long network delays, the node can switch in his local client to a more conservative bound on <span class="math">D</span> without coordinating this with other nodes.</p>

    <h2 id="sec-11" class="text-2xl font-bold">4 The SPECTRE Protocol</h2>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">A The generation of the block DAG</h3>

    <p class="text-gray-300">As in Bitcoin, participating nodes (called miners) create blocks of transactions by solving PoW puzzles. A block specifies its direct predecessors by referencing their ID in its header (a block’s ID is obtained by applying a collision resistant hash to its header); we will describe in the next subsection how these predecessors are chosen. This results in a structure of a direct acyclic graph (DAG) of blocks (as blocks can only reference blocks created before them), denoted typically <span class="math">G=(C,E)</span>. Here, <span class="math">C</span> represents blocks and <span class="math">E</span> represents the hash references. We will frequently write <span class="math">z\\in G</span> instead of <span class="math">z\\in C</span>.</p>

    <p class="text-gray-300"><span class="math">past\\left(z,G\\right)\\subset C</span> denotes the subset of blocks reachable from <span class="math">z</span>, and similarly <span class="math">future\\left(z,G\\right)\\subset C</span> denotes the subset of blocks from which <span class="math">z</span> is reachable; these are blocks that were provably created before and after <span class="math">z</span>, correspondingly. Note that an edge in the DAG points back in time, from the new block to previously created blocks which it extends. A node does not consider a block as valid until it receives its entire past set. We denote by <span class="math">cone\\left(z,G\\right)</span> the set of blocks that the DAG directly orders with respect to <span class="math">z</span>: <span class="math">cone\\left(z,G\\right):=past\\left(z,G\\right)\\cup\\{z\\}\\cup future\\left(z,G\\right)</span>, and by <span class="math">anticone\\left(z\\right)</span> the complementary of <span class="math">cone\\left(z,G\\right)</span>. The set <span class="math">past\\left(b,G\\right)</span> is fixed once and for all at the creation of <span class="math">b</span> (in sharp contrast to <span class="math">future\\left(z,G\\right)</span> and <span class="math">anticone\\left(z,G\\right)</span> that may grow as blocks are added later to the DAG), hence we can simply write <span class="math">past\\left(b\\right)</span> without noting the context.</p>

    <p class="text-gray-300">The unique block <span class="math">genesis</span> is the block created at the inception of the system, and every valid block must have it in its past set. In addition, we relate to a hypothetical block, <span class="math">virtual\\left(G\\right)</span>. This block satisfies <span class="math">past\\left(virtual\\left(G\\right)\\right)=G</span>. While its role is merely methodological, <span class="math">virtual\\left(G\\right)</span> can also be thought of as representing the next block that a node whose current observed DAG is <span class="math">G</span> attempts to create.</p>

    <p class="text-gray-300"><span class="math">G^{v}_{t}</span> denotes the block DAG observed by node <span class="math">v\\in\\mathcal{N}</span> at time <span class="math">t</span>. This DAG represents the history of all (valid) block-messages received by the node, instantiating the abstract data structure assumed in Section 2.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">B The mining protocol</h3>

    <p class="text-gray-300">SPECTRE’s instructions to miners are extremely simple:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>When creating or receiving a block, transmit the block to all peers.</li>

      <li>When creating a block, embed in its header a list containing the hash of all leaf-blocks (blocks with in-degree 0) in the locally-observed DAG.</li>

    </ol>

    <p class="text-gray-300">Note that these instructions allow miners to operate concurrently irrespective of potential conflicts in the contents of their blocks.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">C The <span class="math">TxO</span> protocol</h3>

    <p class="text-gray-300">Overview. As the block DAG may contain conflicting transactions, we must provide a method for nodes to interpret the DAG and extract from it the set of accepted transactions. Doing so in</p>

    <p class="text-gray-300">a way that will be agreed upon by all nodes (eventually) is the main challenge of SPECTRE. We now describe how this is done.</p>

    <p class="text-gray-300">The topology of a block DAG <span class="math">G</span> induces a natural precedence-relation over blocks: if <span class="math">x</span> is reachable from <span class="math">y</span> (i.e., <span class="math">x\\in past\\left(y\\right)</span>) then <span class="math">x</span> precedes <span class="math">y</span>, as it was provably created before it. SPECTRE extends this relation into a complete relation over <span class="math">G</span>’s blocks, denoted <span class="math">\\prec</span>. This order is immediately translatable into an order over transactions in <span class="math">G</span>: <span class="math">tx_{1}</span> precedes <span class="math">tx_{2}</span> if the block containing the former precedes that containing the latter. This relation, in turn, induces a natural subset of accepted transactions: <span class="math">tx</span> is accepted if it precedes all of its conflicting transactions in <span class="math">G</span>. The relation <span class="math">\\prec</span> is generated by a pairwise vote procedure that occurs independently for every pair of blocks. The operation of this layer will be explained in the next subsections.</p>

    <p class="text-gray-300">Although we may at times refer to <span class="math">\\prec</span> as though it orders blocks, we stress that <span class="math">\\prec</span> <em>is not necessarily a transitive relation</em>. It is possible to have a series of blocks that precede each other cyclically. The lack of a total linear ordering over blocks is in fact the way SPECTRE utilizes the weaker consensus requirements of our framework, as a linear order is equivalent to solving the consensus problem <em>[3]</em>.</p>

    <p class="text-gray-300">Pairwise ordering of blocks. The basic layer of SPECTRE involves deciding on a pairwise order over the block DAG. Fix two blocks <span class="math">x,y\\in G</span>. In order to decide if <span class="math">x\\prec y</span> or <span class="math">y\\prec x</span>, we interpret the structure of the DAG as representing an abstract vote. Every block <span class="math">z\\in G</span> is considered a voter with respect to the pair <span class="math">(x,y)</span>, and <em>its vote is inferred from the structure of the DAG</em>. We represent a vote by a number in <span class="math">\\{-1,0,+1\\}</span>, and we denote <span class="math">z</span>’s voting-profile on all pairs by <span class="math">vote\\left(z,G\\right)</span>. <span class="math">vote_{x,y}\\left(z,G\\right)=-1</span> represents <span class="math">x</span> preceding <span class="math">y</span> (<span class="math">x\\prec y</span>), <span class="math">vote_{x,y}\\left(z,G\\right)=+1</span> represents <span class="math">y</span> preceding <span class="math">x</span>, and <span class="math">vote_{x,y}\\left(z,G\\right)=0</span> represents a tie. Importantly, <span class="math">vote\\left(z,G\\right)</span> is an asymmetric relation: <span class="math">vote_{y,x}\\left(z,G\\right)=-vote_{x,y}\\left(z,G\\right)</span>.</p>

    <p class="text-gray-300">To simplify presentation, we associate a vote with <span class="math">virtual\\left(G\\right)</span> as well. Recall that the virtual block of <span class="math">G</span> is a hypothetical block which satisfies <span class="math">past\\left(virtual\\left(G\\right)\\right)=G</span>. The vote of <span class="math">virtual\\left(G\\right)</span> represents essentially the aggregated vote of the entire block DAG. The basic rules of <span class="math">z</span>’s vote, for any <span class="math">z\\in G\\cup\\{virtual\\left(G\\right)\\}</span>, are as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">z\\in G</span> is in <span class="math">future\\left(x\\right)</span> but not in <span class="math">future\\left(y\\right)</span> then it will vote in favour of <span class="math">x</span> (i.e., for <span class="math">x\\prec y</span>).</li>

      <li>if <span class="math">z\\in G</span> is in <span class="math">future\\left(x\\right)\\cap future\\left(y\\right)</span> then <span class="math">z</span>’s vote will be determined recursively according to the DAG that is reduced to its past, i.e., it has the same vote as <span class="math">virtual\\left(past\\left(z\\right)\\right)</span>. If the result of this vote is a tie, <span class="math">z</span> breaks it arbitrarily.</li>

      <li>if <span class="math">z\\in G</span> is not in the future of either blocks then it will vote the same way as the vote of the majority of blocks in its own future.</li>

      <li>if <span class="math">z</span> is the virtual block of <span class="math">G</span> then it will vote the same way as the vote of the majority of blocks in <span class="math">G</span>.</li>

      <li>finally, (for the case where <span class="math">z</span> equals <span class="math">x</span> or <span class="math">y</span>), <span class="math">z</span> votes for itself to succeed any block in <span class="math">past\\left(z\\right)</span> and to precede any block outside <span class="math">past\\left(z\\right)</span>.</li>

    </ol>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: An example of the voting procedure on a simple DAG. Block  <span class="math">x</span>  and blocks 6-8 vote  <span class="math">x \\prec y</span>  as they only see  <span class="math">x</span>  in their past, and not  <span class="math">y</span> . Similarly, block  <span class="math">y</span>  and blocks 9-11 vote  <span class="math">y \\prec x</span> . Block 12 votes according to a recursive call on the DAG that does not contain blocks 10,11,12. Any block from 1-5 votes  <span class="math">x \\prec y</span> , because it sees more  <span class="math">x \\prec y</span>  voters in its future than  <span class="math">y \\prec x</span>  voters.</p>

    <p class="text-gray-300">Intuitively, the first rule dictates that a block that was honestly published gain votes over blocks that are secretly withheld, as honest nodes keep adding new blocks to its future set. The second and fourth rules together guarantee majority amplification, as new blocks add votes that comply with and enhance previous decisions. The third rule is the most subtle; basically, it allows blocks in  <span class="math">\\text{past}(x)</span>  (in addition to those in  <span class="math">\\text{future}(x)</span> ) to vote in its favour against  <span class="math">y</span> , in case  <span class="math">y</span>  was withheld for a long time. This is needed to counter a pre-mining attack scheme, which will be described in future sections. Notice that all votes respect the DAG's topology: If  <span class="math">x</span>  is reachable from  <span class="math">y</span>  then all blocks vote unanimously  <span class="math">x \\prec y</span> .</p>

    <p class="text-gray-300">Figure 1 illustrates the voting procedure with regards to a single pair of blocks  <span class="math">(x,y)</span> . Additional examples along with intuition regarding this key algorithm are provided in Appendix A.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The voting procedure is implemented in Algorithm 1 below. In the algorithm,  <span class="math">\\widehat{sgn}(n) = -1</span>  for  <span class="math">n &amp;lt; 0</span> ,  <span class="math">\\widehat{sgn}(n) = +1</span>  for  <span class="math">n &amp;gt; 0</span> , and  <span class="math">\\widehat{sgn}(0) = 0</span> . To see that the recursion calls from line 4 halt, observe that they take as inputs DAGs strictly smaller than  <span class="math">G</span>  (because  <span class="math">past(z) \\subsetneq G</span> ), and hence eventually all arrive at the base case  <span class="math">G = \\emptyset</span>  and return. The algorithm is written in its naive form, for the sake of readability, with a run time of  $\\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^3)<span class="math"> . We have written a more sophisticated implementation of this procedure, which runs in expected time of  </span>\\mathcal{O}(d \\cdot \\lambda)$ . We will make the code available online in the full version.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The pairwise ordering of SPECTRE has the following highly valuable property:</p>

    <p class="text-gray-300">Property 4. Once a block is published, the set of blocks that precede it in the pairwise ordering closes fast—w.h.p. it consists only of blocks published before or right after its publication.</p>

    <p class="text-gray-300">The implications of this guarantee to the security of transactions is immediate, at least at the intuitive level: A user whose transaction is embedded in some published block  <span class="math">x</span>  can guarantee its safety by waiting some time after  <span class="math">x</span> 's publication before accepting it; he is then guaranteed that any block published later on – and that might contain a conflicting transaction – will be preceded by  <span class="math">x</span>  hence will not threaten the acceptance of his transaction. In Section 5 we will explain how this guarantee is achieved.</p>

    <p class="text-gray-300">Algorithm 1 <span class="math">CalcVotes</span> 0: <span class="math">G</span> – a block DAG 0: <span class="math">vote\\left(virtual\\left(G\\right)\\right)</span> – a pairwise ordering of blocks in <span class="math">G</span> 1: if <span class="math">G=\\emptyset</span> then 2: return an empty ordering 3: for all <span class="math">z\\in G</span> do 4: <span class="math">vote\\left(z,past\\left(z\\right)\\right)\\leftarrow CalcVotes\\left(past\\left(z\\right)\\right)</span> and break ties arbitrarily 5: for all <span class="math">z\\in G</span> in some topological order (from leaves to root) do 6: for all <span class="math">x,y\\in G</span> (<span class="math">x\\neq y</span>) do 7: if <span class="math">\\left(x\\in\\overline{past}\\left(z\\right)\\wedge y\\notin past\\left(z\\right)\\right)\\vee\\left(x\\in past\\left(z\\right),y=z\\right)</span> then 8: <span class="math">vote_{x,y}\\left(z,G\\right)\\leftarrow-1</span> 9: else if <span class="math">\\left(y\\in\\overline{past}\\left(z\\right)\\wedge x\\notin past\\left(z\\right)\\right)\\vee\\left(y\\in past\\left(z\\right),x=z\\right)</span> then 10: <span class="math">vote_{x,y}\\left(z,G\\right)\\leftarrow+1</span> 11: else if <span class="math">x,y\\in past\\left(z\\right)</span> then 12: <span class="math">vote_{x,y}\\left(z,G\\right)\\leftarrow vote_{x,y}\\left(z,past\\left(z\\right)\\right)</span> 13: else if <span class="math">x,y\\notin past\\left(z\\right)</span> then 14: <span class="math">vote_{x,y}\\left(z,G\\right)\\leftarrow\\overline{sgn}\\left(\\sum_{z^{\\prime}\\in future\\left(z,G\\right)}vote_{x,y}\\left(z^{\\prime},G\\right)\\right)</span> 15: <span class="math">vote\\left(virtual\\left(G\\right),G\\right)\\leftarrow\\overline{sgn}\\left(\\sum_{z\\in G}vote\\left(z,G\\right)\\right)</span> 16: return <span class="math">vote\\left(virtual\\left(G\\right),G\\right)</span></p>

    <p class="text-gray-300">Accepting transactions. Equipped with the pairwise relation over blocks, we now turn to construct the set of accepted transactions. To maintain consistency, we mark a transaction as accepted iff all three conditions below hold true:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>all of its inputs have been accepted.</li>

      <li>all conflicting transactions from its anticone set (i.e., that are not related to it topologically) are contained in blocks that are preceded by the block containing the transaction.</li>

      <li>all conflicting transactions from its past set (i.e., that precede it in the DAG, topologically) have been rejected.</li>

    </ol>

    <p class="text-gray-300">Algorithm 2 implements these rules, and outputs a set of accepted transactions. It operates recursively, and should be initially called with <span class="math">TxO(G,G)</span> (we later denote this simply by <span class="math">TxO(G)</span>). In the algorithm, the notation <span class="math">Z_{G}(tx)</span> stands for all blocks in <span class="math">G</span> that contain <span class="math">tx</span>. Some complexity arises due to possible multiple copies of the same transaction in the DAG; we denote by <span class="math">[tx]</span> the equivalence class containing all of <span class="math">tx</span>’s copies.</p>

    <p class="text-gray-300">The third part of the SPECTRE protocol, namely, the <span class="math">RobustTxO</span> procedure, is rather involved. We defer its description to Appendix C.</p>

    <h2 id="sec-15" class="text-2xl font-bold">5 High-level Overview of the Proof</h2>

    <p class="text-gray-300">We now provide some intuition as to why SPECTRE’s procedures indeed guarantee that transactions can be accepted safely, and that all transactions of honest users are quickly accepted. We aim at proving Property 4. As mentioned above, this property is easy to translate to the desired</p>

    <p class="text-gray-300">|  Algorithm 2 TxO  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: G - a block DAG, subG - a subDAG of G which is the past of a (possibly virtual) block  |   |</p>

    <p class="text-gray-300">|  Output: Tx - a hyper-set of valid transactions in G  |   |</p>

    <p class="text-gray-300">|  1: vote (virtual (G)) ← CalcVotes(G)  |   |</p>

    <p class="text-gray-300">|  2: Tx ← ∅  |   |</p>

    <p class="text-gray-300">|  3: for all z1 ∈ subG do  |   |</p>

    <p class="text-gray-300">|  4: for all tx ∈ z1 do  |   |</p>

    <p class="text-gray-300">|  5: for all tx2 ∈ G ∩ conflict (tx) do  |   |</p>

    <p class="text-gray-300">|  6: for all z2 ∈ ZG(tx2) ∩ anticone (z1, G) do  |   |</p>

    <p class="text-gray-300">|  7: if votez1,z2 (virtual (G)) ≥ 0 then  |   |</p>

    <p class="text-gray-300">|  8: break (to line 4 and pick next tx)  |   |</p>

    <p class="text-gray-300">|  9: if [tx2] ∩ TxO(G, past (z1)) ≠ ∅ then  |   |</p>

    <p class="text-gray-300">|  10: break (to line 4 and pick next tx)  |   |</p>

    <p class="text-gray-300">|  11: for all [tx3] ∈ inputs (tx) do  |   |</p>

    <p class="text-gray-300">|  12: if [tx3] ∩ TxO(G, past (z1)) = ∅ then  |   |</p>

    <p class="text-gray-300">|  13: break (to line 4 and pick next tx)  |   |</p>

    <p class="text-gray-300">|  14: add tx to Tx  |   |</p>

    <p class="text-gray-300">|  15: return Tx  |   |</p>

    <p class="text-gray-300">security properties of transactions (as we do formally in Appendix E). Concretely, we wish to prove the following statement (in the proposition,  <span class="math">G_r^{pub} \\coloneqq \\cup_{u \\in honest} G_r^u</span> ):</p>

    <p class="text-gray-300">Proposition. Assume block  <span class="math">x</span>  was published at time  <span class="math">t_{pub}</span>  ( <span class="math">x \\in G_{t_{pub}}^{pub}</span> ), and  <span class="math">y</span>  not published before time  <span class="math">t_{acc}</span>  ( <span class="math">y \\notin G_{t_{acc}}^{pub}</span> ). Let  <span class="math">T = t_{acc} - t_{pub}</span> . Then the probability that  <span class="math">x</span>  will not always precede  <span class="math">y</span>  ( <span class="math">\\operatorname{Pr}(\\exists u \\in honest, \\exists s \\geq t_{acc} : \\text{vote}_{x,y}(\\text{virtual}(G_s^u)) \\geq 0)</span> ) decreases exponentially in  <span class="math">T</span> .</p>

    <p class="text-gray-300">Proof overview. Assume that the event in which  <span class="math">y</span>  comes to precede  <span class="math">x</span>  in some future DAG occurs. Let  <span class="math">s</span>  be the earliest moment in time that such an event occurred at some node. Notice that  <span class="math">y</span>  cannot be in the past of  <span class="math">x</span>  or in its future (otherwise their order is determined by the topology and cannot be reversed). We thus assume henceforth  <span class="math">y \\in \\text{anticone}(x)</span> .</p>

    <p class="text-gray-300">The block race after  <span class="math">x</span>  is published. We first consider the votes of blocks created after the publication of block  <span class="math">x</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>(Almost) all honest blocks created between  <span class="math">t_{pub}</span>  and  <span class="math">t_{acc}</span>  vote forever in favour of  <span class="math">x \\prec y</span> , as they have  <span class="math">x</span>  in their past but not  <span class="math">y</span> . Denote by  <span class="math">n_1</span>  the number of such blocks.</li>

      <li>All honest blocks created between  <span class="math">t_{acc}</span>  and  <span class="math">s</span>  vote in favour of  <span class="math">x \\prec y</span> , as well, by the choice of  <span class="math">s</span> . Denote by  <span class="math">n_2</span>  the number of such blocks.</li>

      <li>Denote by  <span class="math">m_1</span>  and  <span class="math">m_2</span>  the number of blocks created by the attacker in the time intervals corresponding to  <span class="math">n_1</span>  and  <span class="math">n_2</span> . Honest nodes possess a fraction  <span class="math">1 - \\alpha &amp;gt; \\alpha</span>  of the computational</li>

    </ul>

    <p class="text-gray-300">power. Consequently, for any positive constant <span class="math">C</span>, the probability that the relation <span class="math">m_{1}+m_{2}+C-(n_{1}+n_{2})\\geq 0</span> will ever be satisfied decreases exponentially with <span class="math">n_{1}</span>. This is typically analyzed as the probability that a biased random walk on the integers, beginning at <span class="math">C</span>, returns to the origin (see <em>[13, 17, 18]</em>).</p>

    <p class="text-gray-300">The term <span class="math">m_{1}+m_{2}-(n_{1}+n_{2})</span> represents the aggregate vote between <span class="math">x</span> and <span class="math">y</span>, considering only blocks created after <span class="math">x</span>’s publication. We now show that blocks that the attacker prepared in advance before <span class="math">x</span>’s publication, in a preparatory “pre-mining” stage, do not give him more than some constant advantage (which will be counted into <span class="math">C</span> above).</p>

    <p class="text-gray-300">The pre-mining stage. Honest blocks that were created before <span class="math">x</span> was published are typically in its past (apart from a small set of blocks) and hence have their vote decided by the majority of votes in their future (as per Alg. 1). Their vote is thus possibly subject to change as the DAG grows, and as the attacker publishes blocks.</p>

    <p class="text-gray-300">For every block <span class="math">z</span> in the past of <span class="math">x</span> we must therefore consider the number of blocks above it that vote in favour of <span class="math">x</span> and those that vote against it. Denote by <span class="math">X_{z}</span> the gap between the number of attacker blocks and honest blocks in the future of <span class="math">z</span>, up to time <span class="math">t_{pub}</span>. In Lemma 24 we show that the worst case gap <span class="math">X_{z}</span> (over all blocks <span class="math">z\\in past\\left(x\\right)</span>) can be modeled as a reflecting random walk over the nonnegative integers, with bias towards the origin. Consequently, the best gap that the attacker can secretly gain over a block in <span class="math">past\\left(x\\right)</span> has an exponentially decaying tail, and, in particular, is bounded by a constant w.h.p.</p>

    <p class="text-gray-300">All in all, as <span class="math">t_{acc}-t_{pub}</span> grows, the number <span class="math">n_{1}</span> of votes, or “confirmations”, that <span class="math">x</span> receives increases linearly, and the probability that the attacker will be able to reveal enough blocks so that some <span class="math">z\\in past\\left(x\\right)</span> will have more <span class="math">y\\prec x</span> votes in its future than <span class="math">x\\prec y</span> votes, decreases exponentially in <span class="math">n_{1}</span>. Since this holds for all <span class="math">z\\in past\\left(x\\right)</span> uniformly, it implies in particular that the <span class="math">genesis</span> block has more <span class="math">x\\prec y</span> votes in its future than <span class="math">y\\prec x</span> votes (unless an exponentially unlikely event occurred). The vote of the virtual block is determined by that of the <span class="math">genesis</span> block (this is easy to see, and is proven in Lemma 13), completing the argument. ∎</p>

    <p class="text-gray-300">The proposition above is the gist of Lemmas 14 and 15. In the above sketch, we abstracted out many additional subtleties and details. For instance, honest blocks that were created <span class="math">D</span> seconds around <span class="math">t_{pub}</span>, <span class="math">t_{acc}</span>, or <span class="math">s</span> may not have contributed votes in favour of <span class="math">x</span>. In our formal analysis (Appendix E) we count these as attacker blocks, accounting for the worst case, and add them to the aforementioned constant <span class="math">C</span>. We additionally show how the user can measure <span class="math">n_{1}</span> correctly, even if the attacker publishes his blocks in an attempt to delay acceptance.</p>

    <h2 id="sec-16" class="text-2xl font-bold">6. Related work</h2>

    <p class="text-gray-300">Previous research has produced several suggestions for protocols that attempt to address the security-scalability challenge, but all protocols still provide a total order over blocks:</p>

    <p class="text-gray-300">GHOST is an alternative chain selection rule that gradually chooses a tree of blocks until converging on a single chain <em>[18]</em>. It can be shown that the Liveness property of GHOST can be attacked, as was demonstrated by <em>[8]</em>. The use of block DAGs was proposed in the Inclusive work <em>[10]</em>, in which throughput was increased by integrating off-chain blocks into the ledger.</p>

    <p class="text-gray-300">Due to the reliance on a chain, Inclusive mitigates but does not avoid the security-scalability trade-off. The Inclusive paper further includes a game theoretic analysis of the incentives of nodes to embed different transactions in their blocks (without the ability to coordinate).</p>

    <p class="text-gray-300">Bitcoin-NG <em>[6]</em> provides a clever chain structure that is composed of two types of blocks: key blocks that require PoW but contain no transactions, and mini-blocks that do not require PoW but do contain transactions. Bitcoin-NG manages to obtain a significant scalability increase, but its key blocks are still generated slowly, hence, confirmation times remain high. Another line of work bootstraps PoW to instantiate a committee that is later used to run classical BFT protocols. Examples from this line of research include Byzcoin <em>[9]</em>, a work by Decker et. al. <em>[4]</em>, Hybrid Consensus <em>[16]</em>, and recently Solidus <em>[1]</em>. Protocols built in this manner are highly scalable, building upon work in consensus protocols, but lack some of the properties achieved by Bitcoin. They typically require large committees and require committee members to remain online for long periods of time, making them susceptible to network isolation and DoS attacks. <em>[9, 4, 1]</em> additionally fail without recovering if the committee is ever composed of a high fraction of malicious entities (Bitcoin, on the other hand, is self-stabilizing). Moreover, they require forward secrecy. If the cryptographic keys of a sufficient fraction of the committee at any point in the past is compromised, the attacker can create an alternative equally acceptable version of events.</p>

    <p class="text-gray-300">The Algorand protocol <em>[11]</em> is a proof-of-stake based algorithm that uses the ownership of currency itself to achieve a scalable consensus protocol. It utilizes additional techniques (based on VRFs) to hide the committee members that take place in the consensus protocol. In contrast, miners in SPECTRE are not directly involved in any explicit consensus protocol and moreover can operate with little regard of other nodes’ synchronization status. Honey Badger <em>[12]</em> is an atomic broadcast protocol that is oblivious to network parameters and does not require tuning under different network conditions (similarly to SPECTRE). It is set in the classical permissioned setting where identities of the participants are known.</p>

    <h2 id="sec-17" class="text-2xl font-bold">7 Conclusion</h2>

    <p class="text-gray-300">In this work we presented SPECTRE, a new cryptocurrency protocol that is inherently scalable. Unlike Bitcoin and its many variants, SPECTRE is secure against attackers with less than 50% of the computational power, even when its throughput is increased and the propagation delay becomes non-negligible. Our results demonstrate that SPECTRE can achieve incredibly low confirmation times, especially compared to Nakamoto Consensus. Further work to improve and tighten the acceptance policy we derived can lower confirmation times further. Key to SPECTRE’s achievements is its willingness to delay the decision regarding visibly double-spent transactions. It thus solves a weaker problem than traditional consensus protocols. This fact also makes it less suitable for systems like Ethereum, where a total order over transactions is required</p>

    <p class="text-gray-300">The core algorithm of SPECTRE – the pairwise voting procedure (Alg. 1) – is nontrivial. We encourage the reader to refer to Appendix A for intuition and illustrations about its operation.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Ittai Abraham, Dahlia Malkhi, Kartik Nayak, Ling Ren, and Alexander Spiegelman. Solidus: An incentive-compatible cryptocurrency based on permissionless byzantine consensus. arXiv preprint arXiv:1612.02916, 2016.</li>

      <li>[2] Kenneth J Arrow, Amartya Sen, and Kotaro Suzumura. Handbook of Social Choice & Welfare, volume 2. Elsevier, 2010.</li>

      <li>[3] Miguel Correia, Nuno Ferreira Neves, and Paulo Veríssimo. From consensus to atomic broadcast: Time-free byzantine-resistant protocols without signatures. The Computer Journal, 49(1):82–96, 2006.</li>

      <li>[4] Christian Decker, Jochen Seidel, and Roger Wattenhofer. Bitcoin meets strong consistency. In Proceedings of the 17th International Conference on Distributed Computing and Networking, page 13. ACM, 2016.</li>

      <li>[5] Christian Decker and Roger Wattenhofer. Information propagation in the bitcoin network. In 13th IEEE International Conference on Peer-to-Peer Computing (P2P), Trento, Italy, September 2013.</li>

      <li>[6] Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert Van Renesse. Bitcoin-ng: A scalable blockchain protocol. In 13th USENIX Symposium on Networked Systems Design and Implementation (NSDI 16), pages 45–59, 2016.</li>

      <li>[7] Juan Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Annual International Conference on the Theory and Applications of Cryptographic Techniques, pages 281–310. Springer, 2015.</li>

      <li>[8] Aggelos Kiayias and Giorgos Panagiotakos. On trees, chains and fast transactions in the blockchain. Cryptology ePrint Archive, Report 2016/545, 2016.</li>

      <li>[9] Eleftherios Kokoris-Kogias, Philipp Jovanovic, Nicolas Gailly, Ismail Khoffi, Linus Gasser, and Bryan Ford. Enhancing bitcoin security and performance with strong consistency via collective signing. In 25th USENIX Security Symposium, USENIX Security 16, Austin, TX, USA, August 10-12, 2016., pages 279–296, 2016.</li>

      <li>[10] Yoad Lewenberg, Yonatan Sompolinsky, and Aviv Zohar. Inclusive block chain protocols. In International Conference on Financial Cryptography and Data Security, pages 528–547. Springer, 2015.</li>

      <li>[11] Silvio Micali. Algorand: the efficient and democratic ledger. arXiv preprint arXiv:1607.01341, 2016.</li>

      <li>[12] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of bft protocols. In Proceedings of the 2016 ACM SIGSAC Conference on Computer and Communications Security, pages 31–42. ACM, 2016.</li>

      <li>[13] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system, 2008.</li>

      <li>[14] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. IACR Cryptology ePrint Archive, 2016:454, 2016.</li>

      <li>[15] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. IACR Cryptology ePrint Archive, 2016:454, 2016.</li>

      <li>[16] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permissionless model. Cryptology ePrint Archive, Report 2016/917, 2016.</li>

      <li>[17] Meni Rosenfeld. Analysis of hashrate-based double spending. arXiv preprint arXiv:1402.2009, 2014.</li>

      <li>[18] Yonatan Sompolinsky and Aviv Zohar. Secure high-rate transaction processing in bitcoin. In International Conference on Financial Cryptography and Data Security, pages 507–527. Springer, 2015.</li>

    </ul>

    <h2 id="sec-18" class="text-2xl font-bold">Appendix A Intuition and Examples</h2>

    <p class="text-gray-300">In this section we provide some basic explanations and intuitions regarding the operation of SPECTRE. We focus primarily on explaining the ideas underlying Alg. 1 that is at the core of the protocol. We later go on to present examples for simple attacks that shed some light on how resilience is achieved.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Intuition 1 (Vote in favour of visible blocks).</h6>

    <p class="text-gray-300">If a block <span class="math">x</span> is known by honest participants, their blocks will include it in their past. Given that blocks vote in favour of blocks in their past</p>

    <p class="text-gray-300">(over other unknown blocks), and given that honest nodes publish their blocks quickly, hidden attacker blocks lose votes.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Intuition 2 (Majority amplification).</h6>

    <p class="text-gray-300">Given blocks <span class="math">x,y</span> that contain potential conflicts, blocks that are generated by honest participants after their publication reference both of them in the DAG. According to Alg. 1, these new blocks adopt the vote of the sub-DAG in their past with regards to <span class="math">x</span> and <span class="math">y</span>. Thus, if block <span class="math">x</span> precedes block <span class="math">y</span>, additional votes that support this decision are added, and the attacker will find it more difficult to reverse the vote.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Intuition 3 (Referencing recent blocks is beneficial).</h6>

    <p class="text-gray-300">Blocks from the past vote according to their future. Thus if an attacker creates a block that does not reference recent blocks, it is at a disadvantage compared to other blocks that do (it loses votes from recent blocks it did not reference and did not “convince”).</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Intuition 4 (Votes from the past counter pre-mining attacks).</h6>

    <p class="text-gray-300">Consider an attacker that creates a block <span class="math">y</span>, withholds it, and constructs many blocks on top of it over an extended period of time. After a long while, a conflicting transaction is released to the network, and eventually ends up in some block <span class="math">x</span>. Block <span class="math">y</span> has many blocks (built by the attacker) that reference it. Thus, if only votes from the future are counted, block <span class="math">y</span> would prevail even if <span class="math">x</span> is allowed to accumulate some votes. In SPECTRE, blocks that were created by honest nodes while <span class="math">y</span> was withheld, look to their future for their votes. These will usually vote in favour of <span class="math">x</span> and will usually outnumber the attacker blocks that were created when <span class="math">y</span> was withheld (an example of pre-mining appears in Fig. 3).</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: SPECTRE coincides with the longest-chain rule when it is applied to "simple" chains of blocks. In the depicted DAG, the chain ending at block 8 is longer and would be selected in the longest chain protocol. In SPECTRE each one of the blocks 5,6,7,8 precedes each of the blocks in 9,10,11. Consider for instance blocks 6 and 10 and the pairwise vote that involves them. Blocks 6-8 vote strongly  <span class="math">6 \\prec 10</span> , as they see block 6 in their past but not block 10. Block 5 is a weak voter, as it sees neither 6 nor 10 in its past, hence it votes as the majority of its future (thus voting  <span class="math">6 \\prec 10</span>  as well). For similar reasons, blocks 9-11 all vote  <span class="math">10 \\prec 6</span> . Block 4, at the fork of the two chains, is a weak voter as well, as it sees neither 6 nor 10 in its past; it therefore votes according to the majority of future blocks. As block 4 sees four votes in favour of  <span class="math">6 \\prec 10</span> , and three votes in favour of  <span class="math">10 \\prec 6</span> , it will vote in favour of  <span class="math">6 \\prec 10</span> . Blocks 1-3 similarly vote according to their future, and see an increasing number of votes for  <span class="math">6 \\prec 10</span> , adding their own vote to the result. Thus, the end result is that 6 precedes 10.</p>

    <p class="text-gray-300">We now demonstrate how SPECTRE coincides with Bitcoin's longest-chain rule, in the case of a "simple" fork between two chains. Consider the DAG illustrated in Fig. 2. In Bitcoin, the longer chain would be selected. Similarly, in the pairwise ordering of SPECTRE, each of the blocks in the longest chain 5,6,7,8 would precede each of the blocks in the shorter one 9,10,11. To see why this is true refer to the caption of the figure.</p>

    <p class="text-gray-300">We now turn to examine two different attack scenarios, which we name double-spending, and censorship. Recall the requirement from our miner protocol: each miner is required to  <span class="math">(i)</span>  reference recent blocks, and to  <span class="math">(ii)</span>  publish his blocks immediately. Each attack is basically a violation of one of these requirements. In the double-spending attack, the attacker delays the publication of a set of blocks (that includes a conflicting transaction), and in the censorship attack he publishes blocks but "ignores" a certain block and transactions inside it, hoping to convince nodes that it did not secure enough votes, and thus cannot be accepted.</p>

    <p class="text-gray-300">Fig. 3 depicts an (unsuccessful) double-spending attack. The attack is composed of three main phases:</p>

    <p class="text-gray-300">Phase I: Pre-mining. In phase I, the attacker begins building blocks and withholding them from the network. The first block that is constructed (named block  <span class="math">y</span> ) contains a transaction that will later conflict with the transaction sent to the honest nodes. Blocks built by the attacker ideally</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: An example of the voting procedure on a DAG in which a double-spending attack is (unsuccessfully) attempted. Block  <span class="math">x</span>  and blocks 6-8 vote strongly  <span class="math">x \\prec y</span>  as they only see  <span class="math">x</span>  in their past, and not  <span class="math">y</span> . Similarly, block  <span class="math">y</span>  and blocks 13-19 vote strongly  <span class="math">y \\prec x</span> . In the DAG which is the past of block 11, each of the blocks 1-5 sees more  <span class="math">x \\prec y</span>  voters in its future than  <span class="math">y \\prec x</span>  voters, hence each of them votes  <span class="math">x \\prec y</span> . Block 11 votes (as the virtual block of its past votes), according to the majority in its past, thus it too votes  <span class="math">x \\prec y</span> . A similar argument goes for the vote of 11 and 12. Finally, aggregating the vote of all blocks in the DAG,  <span class="math">x</span>  got more votes hence  <span class="math">x \\prec y</span> .</p>

    <p class="text-gray-300">form a chain, and due to the voting rules in SPECTRE, will all vote  <span class="math">y \\prec x</span>  (blocks  <span class="math">y, 13, 14</span> ). Blocks built by the honest node are unaware of  <span class="math">y</span>  (and also of  <span class="math">x</span>  that is yet to be created), and will eventually vote according to the majority of future votes. During this phase, attacker blocks reference honest blocks that are built (in hopes of later convincing them to vote  <span class="math">y \\prec x</span> ). After some time, the attacker transmits the transaction to the network, and proceeds to phase II.</p>

    <p class="text-gray-300">Notice that at the exact time that phase I ends, the attacker has more blocks above block 4 than honest nodes have, so it starts at an advantage: it will more easily sway the vote of block 4 towards  <span class="math">y \\prec x</span>  (this advantage later disappears as honest nodes typically build blocks faster than the attacker).</p>

    <p class="text-gray-300">Phase II: Waiting for acceptance. The attacker now continues to build blocks in secret. If he publishes his blocks, then his conflicting transaction will be visible to all, and the double-spend will be detected. Instead, he waits for block  <span class="math">x</span>  to receive sufficient weight (in the form of blocks built on top of it) so that the recipient of the transaction in  <span class="math">x</span>  accepts it, and provides the attacker with some service or product. During this phase, attacker blocks that are created (blocks 15-17) vote  <span class="math">y \\prec x</span> , as the attacker is careful to have them reference only his secret chain, and never indirectly reference block  <span class="math">x</span> . Honest blocks created during this phase will typically vote  <span class="math">x \\prec y</span></p>

    <p class="text-gray-300">since <span class="math">y</span> is hidden from them. Some small number of blocks (created before <span class="math">x</span> propagated to the whole network – block 5 in this example) do not reference <span class="math">x</span>, and so will vote according to the result of future votes.</p>

    <p class="text-gray-300">Phase III: Race to overtake. Once <span class="math">x</span> was <span class="math">\\epsilon</span>-accepted by the victim, the attacker wishes to publish his secret blocks in hopes of causing his conflicting transaction in <span class="math">y</span> to precede <span class="math">x</span>. In this case, the transaction in <span class="math">x</span> will be considered rejected, and the payment will be canceled (leaving the attacker with an item he did not pay for). He publishes his secret chain (which from this point on is referenced by honest nodes), and continues to build upon it. Blocks that he builds, again do not reference <span class="math">x</span>, and so they vote <span class="math">y\\prec x</span>, supporting his goal. New honest nodes are for the first time exposed to the conflicting transaction <span class="math">y</span>, and thus vote according to the result in the sub-DAG in their past.</p>

    <p class="text-gray-300">Why the attack fails. First, notice that the attacker in the above example creates fewer blocks in each phase than the honest nodes. This will usually be the case if attackers have less computational power than all honest nodes. “Poisson bursts” in block creation by the attacker are possible, and this will allow him to overtake the network, but these are less likely if the attack lasts for a long period of time. The defender can control the length of phase II by waiting a long while before accepting the transaction, which decreases the probability of such bursts. If phase II is long enough, <span class="math">x</span> will have more votes in this period than <span class="math">y</span>. Weak blocks in the past of <span class="math">x</span> will then vote in favour of <span class="math">x</span>, according to this majority. Such blocks that look at their future begin a cascade: each block further in the past adds a vote that agrees with the majority of future blocks and thus strengthens the decision. The greater the majority obtained in Phase II, the less likely it is that the attacker will be able to catch up from behind in Phase III. The attack therefore depends heavily on successfully swaying the votes of blocks that were created just before <span class="math">x</span> (e.g., block 4).</p>

    <p class="text-gray-300">It is important to note that an attacker that creates more blocks in expectation than the honest network will succeed in carrying out this attack. The blocks voting <span class="math">y\\prec x</span> would outnumber those who vote to the contrary. Hence the 50% threshold in Theorem 3.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">V-C Example of a censorship attack</h3>

    <p class="text-gray-300">Fig. 4 depicts an (unsuccessful) censorship attack. The attack is composed of a single main phase during which an attacker creates his own blocks, publishes them instantly, but also ignores (and does not reference) recent blocks created by the honest network. The figure depicts (in stage I on the left side) the current state of the blockchain (where all blocks are published at this point). An honest participant that then observes the network and wishes to tell if a transaction in block <span class="math">x</span> is secure, can see a large number of blocks that do not reference <span class="math">x</span>. These blocks are not guaranteed to vote in favour of <span class="math">x</span>. An attacker may later insert a conflicting transaction <span class="math">y</span> and add blocks atop it (this projected attack is depicted on the right-hand side of the figure). These may potentially sway previously created attacker blocks to vote against <span class="math">x</span>.</p>

    <p class="text-gray-300">The main risk from the censorship attack is that merchants, upon seeing the attacker’s blocks, will consider transactions in block <span class="math">x</span> not sufficiently secure. This could potentially delay the</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4: An example of the voting procedure on DAG in which an unsuccessful censorship attack is depicted. The left side depicts the current state of the block DAG. The right-hand side depicts its likely future development. Blocks 12-16 do not add strong votes to  <span class="math">x</span> . Can they be convinced to vote for block  <span class="math">y</span>  when it appears? Will they further sway other blocks in their past? The vote of each block in this projected future are depicted: Blocks 2-9 vote strongly for  <span class="math">x</span>  as they see it in their past (but not  <span class="math">y</span> ). Blocks 17-18 similarly vote strongly for  <span class="math">y</span> . Block 16 is indeed convinced to vote for  <span class="math">y</span>  as more blocks in its future vote for  <span class="math">y</span>  than for  <span class="math">x</span> . Blocks 1, 12-15 vote for  <span class="math">x</span> . They each see more votes in favour of  <span class="math">x</span>  than votes in favour of  <span class="math">y</span>  in their future. Blocks 10-11 see more  <span class="math">x \\prec y</span>  voters in their past when they make a recursive call.</p>

    <p class="text-gray-300">acceptance of transactions forever. Our analysis of SPECTRE shows that even in this case the merchants accept transactions quickly (and securely).</p>

    <p class="text-gray-300">We implemented the SPECTRE protocol in Python along with an event-driven simulator of network dynamics. For each experiment we generated an Erdős-Rényi random network topology with 20 nodes. Each node forms 5 outgoing links, in expectation. The delay on each link was uniformly distributed and later scaled linearly so that the diameter of the graph is  <span class="math">D</span>  (for the given  <span class="math">D</span> ). Every point represents the average outcome over at least 500 experiments.</p>

    <p class="text-gray-300">The main benefit of SPECTRE is fast transaction confirmation. The asymptotic waiting times derived from our formal analysis are in  <span class="math">\\mathcal{O}\\left(\\frac{\\ln(1 / \\epsilon)}{\\lambda(1 - 2\\alpha)} +\\frac{D}{1 - 2\\alpha}\\right)</span> . In order to measure the actual waiting times, we utilized the online acceptance policy derived by Alg. 7. Accordingly, we stress that the merchant needs to wait additional  <span class="math">D</span>  seconds in order to verify that no double-spend has been released in the past  <span class="math">D</span>  seconds, as explained at the end of Appendix C.</p>

    <p class="text-gray-300">How does the delay diameter affect acceptance times? Given that block creation rate is high, most of the waiting time for acceptance is dominated by the block propagation delay. Fig. 5 depicts the transaction acceptance times of SPECTRE, for various values of the delay diameter  <span class="math">D</span> , and for different security thresholds  <span class="math">\\epsilon</span> . Note that, unlike the Nakamoto Consensus,  <span class="math">D</span>  affects the acceptance time of transactions but not their security.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5: The average time for a transaction to enter  <span class="math">RobustTxO</span> , assuming there's no visible double-spend, for  <span class="math">\\lambda = 10</span>  blocks per second and  <span class="math">\\alpha = 0.25</span> .</p>

    <p class="text-gray-300">How does the block creation rate affect acceptance times? Fig. 6 depicts the acceptance times for various values of the block creation rate  <span class="math">\\lambda</span> , under a constant delay  <span class="math">d = 5</span>  seconds. The graph reaffirms the role of  <span class="math">\\lambda</span>  in our asymptotic bound: accelerating the block creation process allows for faster acceptance times. For comparison, Bitcoin's block creation rate of  <span class="math">1/600</span>  implies waiting times that are orders of magnitudes higher (not plotted).</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6: The average time for a transaction to enter  <span class="math">RobustTxO</span> , assuming there's no visible double-spend, for  <span class="math">d = 5</span>  seconds and  <span class="math">\\alpha = 0.25</span> .</p>

    <p class="text-gray-300">Can an attacker delay acceptance? We now turn to demonstrate the effect of censorship attacks in which some dishonest nodes publish blocks that do not reference other miners' blocks. Recall that the Weak Liveness property of SPECTRE (Proposition 3) guarantees fast acceptance of transactions that are not visibly double-spent, even in the presence of a censorship attack. However, such an attack still causes some delay in transaction acceptance, but this delay is minor for small attackers. In Fig. 7 we quantify this effect, by comparing the acceptance times in "peace days" to those under an active censorship attack. The parameters here are  <span class="math">d = 5</span>  seconds,  <span class="math">\\lambda = 10</span>  blocks per second, and  <span class="math">\\epsilon = 0.01</span> . The results display a modest effect of the attack, and they show that in order to delay transaction acceptance by more than 5 to 10 seconds an attacker must possess a significant share of the computational power in the network.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7: The average time for a transaction to enter  <span class="math">RobustTxO</span> , assuming there's no visible double-spend, for  <span class="math">d = 5</span>  seconds,  <span class="math">\\lambda = 10</span>  blocks per second, and  <span class="math">\\epsilon = 0.01</span> , in the presence and in the absence of a censorship attack.</p>

    <p class="text-gray-300">How does  <span class="math">\\epsilon</span>  decrease for various sizes of the attacker? Once an honest node  <span class="math">\\epsilon</span> -accepts a transaction, there's still a small risk  <span class="math">(\\epsilon)</span>  that it would eventually be rejected. We show that the probability of this event vanishes quickly, even for an extremely capable attacker (e.g., with  <span class="math">\\alpha = 0.4</span>  of the hashrate). This is illustrated in Fig. 8, assuming  <span class="math">d = 5</span>  seconds and  <span class="math">\\lambda = 10</span>  blocks per second (notice that the y-axis is in log scale).</p>

    <p class="text-gray-300">How tight is our security analysis? The analysis on which Alg. 3 relies makes several worst-case assumptions in order to bound the probability of a successful attack, e.g., that the attacker can broadcast blocks to and receive blocks from all nodes without any delay (see Appendix E, mainly Lemmas 14 and 20). Accordingly, the analysis is not tight, and in reality attacks are in fact less likely to succeed. In Fig. 9, we depict the comparison between the analytical bound and two different empirical simulations. In these simulations we explicitly generate blocks for the attacker and simulate the optimal double-spending attack. We repeat the experiment 10,000 times for each point in the graph, and measure the empirical success rate. The simulations assume two types of attackers: a worst-case attacker that is able to transmit and receive blocks with no delays, and a more realistic attacker that is connected to other nodes with typical delays. We compared the fraction of successful attacks under these setups to the analytical risk calculated by SPECTRE's policy (Alg. 7).</p>

    <p class="text-gray-300">The results show that the risk considered by SPECTRE's RiskTxAccept indeed upper bounds the actual risk, and that transactions are even safer than we guarantee formally.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 8: The probability of a successful double-spending attack, as a function of the waiting time before acceptance, under  <span class="math">d = 5</span>  seconds and  <span class="math">\\lambda = 10</span>  blocks per second, for  <span class="math">\\alpha = 0.1</span> , 0.25, and 0.4. The probability here is the result of the calculation performed by Alg.3.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 9: The analytical vs. empirical probabilities of a successful double-spending attack, as a function of the waiting time before acceptance, under  <span class="math">d = 5</span>  seconds,  <span class="math">\\lambda = 10</span> , and  <span class="math">\\alpha = 0.25</span> .</p>

    <p class="text-gray-300">In Sec. 4 we described the way SPECTRE pairwise orders blocks, and how this order is used to construct the subset of accepted transactions. In this section we describe the procedures of</p>

    <p class="text-gray-300">the second layer of SPECTRE, which allows users to measure the robustness of this order, and to translate this into the robustness of accepted transactions.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">VI-A Robustness of the block pairwise ordering</h3>

    <p class="text-gray-300">Assume that in the order of the current observable DAG the block <span class="math">x</span> precedes <span class="math">y</span>. We need a method to measure how likely is it that this relation will persist forever. Algorithm 3 outputs an upper bound on the probability that an attacker will be able to reverse the relation <span class="math">x\\prec y</span>. When the argument <span class="math">y</span> is unspecified, the interpretation of the algorithm’s output is <span class="math">x</span>’s robustness against an unseen block (withheld by an attacker or yet to be created). In the algorithm, <span class="math">gap\\left(b,G\\right)</span> denotes the size of the set <span class="math">\\left\\{z\\in anticone\\left(b,G\\right):vote_{z,b}\\left(virtual\\left(G\\right)\\right)\\geq 0\\right\\}</span>. The notation <span class="math">\\left\\langle G,z,K\\right\\rangle</span> will be explained in the paragraphs that follow.</p>

    <p class="text-gray-300">In the algorithms below, we omit for the sake of brevity the following parameters which the user must set by himself: <span class="math">\\alpha</span> – maximal size of attacker, <span class="math">d</span> – upper bound on <span class="math">D</span> (the recent delay diameter in the network), <span class="math">\\lambda</span> – the block creation rate</p>

    <p class="text-gray-300">Algorithm 3 <span class="math">Risk</span> (offline) 0: <span class="math">G=G_{time\\_now}^{v}</span> – some node <span class="math">v</span>’s current block DAG, <span class="math">x</span> – a block in <span class="math">G</span>, <span class="math">y</span> (optional) – a block in <span class="math">anticone\\left(x,G\\right)</span> 0: <span class="math">risk</span> – an upper bound on the probability that <span class="math">x</span> will not recede <span class="math">y</span> in some point in the future (<span class="math">\\Pr\\left(\\exists u\\in honest,\\exists s\\geq time\\_now:vote_{x,y}\\left(virtual\\left(G_{s}^{u}\\right)\\right)\\geq 0\\right)</span>) 1: if <span class="math">time\\_now&lt;publication(x)+2\\cdot d</span> then 2: return 1</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: $K\\leftarrow\\lceil\\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\rceil$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4: if <span class="math">NULL=y</span> then</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: $g\\leftarrow\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{future}\\left(x,G\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6: <span class="math">M\\leftarrow 0</span> 7: else 8: <span class="math">g\\leftarrow\\sum_{z^{\\prime}\\in\\overline{future}\\left(x,G\\right)}vote_{y,x}\\left(z^{\\prime},G\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: $M\\leftarrow\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{z\\in future\\left(x,G\\right):vote_{x,y}\\left(z,G\\right)=+1\\wedge gap\\left(z,\\left\\langle G,z,K\\right\\rangle\\right)=0\\right\\}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">11: <span class="math">j\\leftarrow gap\\left(x,G\\right)+K</span> 12: <span class="math">l\\leftarrow K</span> 13: <span class="math">risk\\leftarrow f_{pre\\_mine}(l)+f_{pre\\_pub}(K)+f_{post\\_pub}\\left(M\\right)+f_{post\\_mine}\\left(n_{x},g,j,l,M\\right)</span> 14: return <span class="math">risk</span></p>

    <p class="text-gray-300">In line 13 the algorithm uses several functions whose precise definitions we defer to later sections. An explicit formula for <span class="math">f_{pre\\_pub}</span> is given in (54), for <span class="math">f_{post\\_pub}</span> is given in (50) and (52), and for <span class="math">f_{post\\_mine}</span> is given in (5). Preceding Lemma 24, we provide a method to calculate <span class="math">f_{pre\\_mine}</span> numerically.</p>

    <p class="text-gray-300">intuitively, the function <span class="math">f_{pre\\_mine}</span> upper bounds the probability that the attacker has gained an advantage larger than <span class="math">l</span> during the pre-mining phase (i.e., up until the creation of <span class="math">x</span>). The function <span class="math">f_{post\\_mine}</span> upper bounds the probability that the attacker will ever be able to create enough blocks so as to reverse the relation <span class="math">x\\prec y</span>. In essence, <span class="math">f_{post\\_mine}</span> is an adaptation of a formula from <em>[17]</em>. According to our version of the formula, if during the interval <span class="math">[time(x),t_{acc}]</span> (where <span class="math">t_{acc}</span> represents the current time) honest nodes created <span class="math">n</span> blocks, then <span class="math">\\binom{n-1+m}{m}\\cdot\\alpha^{m}\\cdot(1-\\alpha)^{n}</span> is the probability that the attacker has created during this interval <span class="math">m</span> blocks. If <span class="math">g</span> aggregates all the votes of blocks in <span class="math">future\\left(x,G\\right)</span>, then the probability that the attacker will be able to reverse the majority’s vote is roughly <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{\\max\\{g-m,0\\}}</span>. The combined expressions produce an upper bound on the success-probability of an attack.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The main challenge here is to correctly measure <span class="math">n</span>. This is a difficult task, as Algorithm 3 uses only structural information (with the exception of making sure that <span class="math">x</span> has been published for at least <span class="math">2\\cdot d</span> seconds) and does not rely on measurements of blocks’ timings. Naïvely one would use $n\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> to upper bound blocks created after </span>publication(x)$. However, there are two main difficulties:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The block <span class="math">x</span> might have been created by a dishonest node and withheld by it. In this case, there might have passed a long time between its creation and its publication, which implies that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> alone may be well below </span>n<span class="math">. To avoid underestimating </span>n<span class="math">, we upper bound the number of honest blocks in </span>anticone\\left(x,G\\right)<span class="math">, by the variable </span>j<span class="math">, and add it to our count (the addition is done inside </span>f_{post\\_mine}\\left(n_{x},g,j,l,M\\right)$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The function <span class="math">f_{pre\\_pub}</span> upper bounds the probability that we have underestimated <span class="math">j</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By publishing his attack blocks, the attacker can increase the size of <span class="math">future\\left(x,G\\right)</span> and cause us to overestimate <span class="math">n</span>. This would result in an upper bound on the success-probability of an attack that is not tight enough, which would allow an attacker with a large value of <span class="math">\\alpha</span> to delay acceptance indefinitely. <span class="math">Risk</span> overcomes this problem, by recognizing attacker blocks and excluding them from the count of <span class="math">n</span>. This is done as follows.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">G</span> be a block DAG, <span class="math">b</span> a block in <span class="math">G</span>, and <span class="math">K</span> a whole number. The DAG <span class="math">\\langle G,b,K\\rangle</span> is obtained by creating a new chain <span class="math">z_{1},...,z_{K}</span> of <span class="math">K</span> hypothetical blocks, connecting an edge from <span class="math">z_{1}</span> to <span class="math">b</span> and replacing every edge <span class="math">(z,b)\\in G</span> with <span class="math">(z,z_{K})\\in G</span>. Essentially, this adds to the DAG <span class="math">K</span> artificial voters which vote strongly <span class="math">x\\prec y</span>, against any <span class="math">y\\notin past\\left(x,G\\right)</span>. In line 9, the algorithm checks whether <span class="math">gap\\left(z,\\langle G,z,K\\rangle\\right)=0</span>, i.e., whether there exists a block in <span class="math">anticone\\left(z\\right)</span> that precedes <span class="math">z</span> in the modified DAG <span class="math">\\langle G,z,K\\rangle</span>. In the case of a negative answer, <span class="math">z</span> is counted into <span class="math">n</span> (in line 10).</p>

    <p class="text-gray-300">The following property explains why this procedure is useful: If we add <span class="math">K</span> voters in favour of an honest block, for some small <span class="math">K</span>, then no other block will precede it in the pairwise ordering (apart from its past set). This is restated formally and proven in Lemma 29.</p>

    <p class="text-gray-300">6The calculations we use are quite more involved, as will be detailed later on. The reason why we aggregate in <span class="math">g</span> votes from <span class="math">future\\left(x,G\\right)</span> alone - rather than votes from the entire DAG - was discussed in Sec. 5. Essentially, observe that counting all votes - including votes of blocks in <span class="math">past\\left(x\\right)</span> - is not meaningful, as such voters might reverse their vote as future events unfold. Rather, it is useful to measure how robustly voters in <span class="math">past\\left(x\\right)</span> support <span class="math">x\\prec y</span>, which is captured by our calculations.</p>

    <p class="text-gray-300">The function <span class="math">f_{post\\_pub}</span> upper bounds the probability that we have underestimated the number of honest blocks in <span class="math">future\\left(x,G\\right)</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">VI-B Robustness of transaction acceptance</h3>

    <p class="text-gray-300">The next step is to translate robustness of blocks (calculated by <span class="math">Risk</span>) to robustness of transactions. This transition is implemented similarly to the transition from the (non-robust) ordering of blocks (Alg. 1) to the (non-robust) accepted set of transactions (Alg. 2).</p>

    <p class="text-gray-300">The <span class="math">RiskTxAccept</span> procedure (Alg. 4) takes as input <span class="math">G</span> and <span class="math">tx</span> (and an additional argument) and returns an upper bound on the probability that some honest node will not <span class="math">\\epsilon</span>-accept <span class="math">tx</span>. The main task of <span class="math">RiskTxAccept</span> is to properly account and aggregate the error bounds that <span class="math">Risk</span> induces. As can be easily recognized, <span class="math">RiskTxAccept</span> and <span class="math">RiskTxReject</span> (Alg. 5) are mirror images of each other. While <span class="math">RiskTxAccept</span> upper bounds the probability that a given transaction will ever be removed from the accepted transaction subset, <span class="math">RiskTxReject</span> upper bounds the probability that a given transaction will ever be included in this subset. This is particularly vital for the case where two conflicting transactions are related topologically, i.e., <span class="math">tx_{2}\\in y</span> and <span class="math">tx_{1}\\in x\\in future\\left(y\\right)</span>, but <span class="math">tx_{2}</span> is not in the accepted set (due to some previous conflict). In this case, although the block containing <span class="math">tx_{2}</span> precedes that containing <span class="math">tx_{1}</span>, we accept <span class="math">tx_{1}</span>. It can be further <span class="math">\\epsilon</span>-accepted if the rejection-status of <span class="math">tx_{2}</span> is robust, as calculated by <span class="math">RiskTxReject</span>.</p>

    <p class="text-gray-300">Algorithm 4 <span class="math">RiskTxAccept</span> 0: <span class="math">G=G_{time\\_now}^{v}</span> – a block DAG, 0: <span class="math">risk</span> – an upper bound on the probability that some honest node in some future point in time will accept no transaction in <span class="math">[tx]\\cap subG</span> (<span class="math">\\Pr\\left(\\exists u\\in honest,\\exists s\\geq time\\_now,[tx]\\cap subG\\cap RobustTxOG_{s}^{u}=\\emptyset\\right)</span>) 1: <span class="math">minrisk\\leftarrow 1</span> 2: for all <span class="math">z_{1}\\in Z_{G}([tx])\\cap subG</span> do 3: <span class="math">risk\\leftarrow Risk\\left(G,z_{1},\\emptyset\\right)</span> 4: for all <span class="math">tx_{2}\\in G\\cap conflict\\left(tx\\right)</span> do 5: for all <span class="math">z_{2}\\in Z_{G}(tx_{2})\\cap anticone\\left(z_{1},G\\right)</span> do 6: <span class="math">risk\\leftarrow risk+Risk\\left(G,z_{1},z_{2}\\right)</span> 7: <span class="math">risk\\leftarrow risk+RiskTxReject\\left(G,[tx_{2}],past\\left(z_{1}\\right)\\right)</span> 8: for all <span class="math">[tx_{3}]\\in inputs\\left(tx\\right)\\cap past\\left(z_{1}\\right)</span> do 9: <span class="math">risk\\leftarrow risk+RiskTxAccept\\left(G,[tx_{3}],past\\left(z_{1}\\right)\\right)</span> 10: <span class="math">minrisk\\leftarrow\\min\\left\\{minrisk,risk\\right\\}</span> 11: <span class="math">risk\\leftarrow minrisk</span> 12: return <span class="math">risk</span></p>

    <p class="text-gray-300">Building on these procedures, we now present the <span class="math">RobustTxO</span> procedure of SPECTRE. The user should provide as input the entire DAG that he currently observes <span class="math">G</span>, and the maximal error probability he is willing to tolerate <span class="math">\\epsilon</span>. As mentioned above, the user should also set the <span class="math">\\alpha,d,\\lambda</span> parameters; these will be used in the auxiliary proceudres of <span class="math">RobustTxO</span> described above.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">VI-</h3>

    <p class="text-gray-300">Algorithm 5 <span class="math">RiskTxReject</span> 0: <span class="math">G</span> – a block DAG, <span class="math">subG</span> – a subDAG of <span class="math">G</span> which is the past of a (possibly virtual) block, <span class="math">tx</span> – a copy of the transaction to defend 0: <span class="math">risk</span> – an upper bound on the probability that some honest node in some future point in time will accept a transaction in <span class="math">[tx]\\cap subG</span>. 1: <span class="math">risk\\leftarrow 0</span> 2: for all <span class="math">z_{1}\\in Z_{G}([tx])\\cap subG</span> do 3: <span class="math">minrisk\\leftarrow 1</span> 4: for all <span class="math">tx_{2}\\in G\\cap conflict\\left(tx\\right)</span> do 5: for all <span class="math">z_{2}\\in Z_{G}(tx_{2})\\cap anticone\\left(z,G\\right)</span> do 6: <span class="math">minrisk\\leftarrow\\min\\left\\{minrisk,Risk\\left(G,z_{2},z_{1}\\right)\\right\\}</span> 7: <span class="math">minrisk\\leftarrow\\min\\left\\{minrisk,RiskTxAccept\\left(G,[tx_{2}],past\\left(z_{1}\\right)\\right)\\right\\}</span> 8: for all <span class="math">[tx_{3}]\\in inputs\\left(tx\\right)</span> do 9: <span class="math">minrisk\\leftarrow\\min\\left\\{minrisk,RiskTxReject\\left(G,[tx_{3}],past\\left(z_{1}\\right)\\right)\\right\\}</span> 10: <span class="math">risk\\leftarrow risk+minrisk</span> 11: return <span class="math">risk</span></p>

    <p class="text-gray-300">Algorithm 6 <span class="math">RobustTxO</span> 0: <span class="math">G=G^{v}_{time\\_now}</span> – a block DAG representing the current DAG observed by the node running the algorithm, <span class="math">\\epsilon</span> – the maximum risk the user is willing to tolerate, <span class="math">\\alpha</span> – maximal size of attacker, <span class="math">d</span> – upper bound on network’s delay diameter, <span class="math">\\lambda</span> – the block creation rate 0: a set of transactions that are guaranteed to remain accepted, as defined by Property 2 1: <span class="math">RobustTx\\leftarrow\\emptyset</span> 2: for all <span class="math">z\\in G</span> do 3: for all <span class="math">tx\\in z</span> do 4: if <span class="math">RiskTxAccept\\left(G,[tx]\\cap G\\right)&lt;\\epsilon</span> then 5: add <span class="math">tx</span> to <span class="math">RobustTx</span></p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">V-C Online policy</h3>

    <p class="text-gray-300">We now present an alternative implementation of <span class="math">Risk</span>, which requires that the user be online at the time when his block gains confirmations. This assumption is highly reasonable for many practical scenarios, e.g., a cashier serving a continuous line of customers. The main benefit of the online version is that it relies on a tighter analysis, and therefore accepts transactions slightly faster. We now confine ourselves to the case where there is no visible double-spend (i.e., <span class="math">y=NULL</span>).</p>

    <p class="text-gray-300">The fact that the user is online can be utilized in two ways: First, any block that the user receives after <span class="math">received^{v}(b)+2\\cdot d</span> and does not belong to <span class="math">future\\left(x\\right)</span> can be marked by him as an attacker block. Second, the user can estimate the number of hidden attacker blocks by</p>

    <p class="text-gray-300">measuring the time that passed since the creation of <span class="math">x</span>.</p>

    <p class="text-gray-300">Below we describe the online version of <span class="math">Risk</span>. The algorithm takes as input node <span class="math">v</span>’s DAG and the block <span class="math">x</span> to defend, and returns an upper bound on the probability that some block <span class="math">y\\in G_{\\infty}^{pub}\\setminus G_{t}^{pub}</span> will ever precede it.</p>

    <p class="text-gray-300">Algorithm 7 <span class="math">Risk</span> (online) 0: <span class="math">G_{t}^{v}</span> – the block DAG that <span class="math">v</span> obesrves at time <span class="math">t</span>, <span class="math">x</span> – a block in <span class="math">G_{t}^{v}</span> 0: <span class="math">risk</span> – an upper bound on the probability of block <span class="math">x</span> not preceding <span class="math">y</span> at any point in the future, for some <span class="math">y\\in G_{\\infty}^{pub}\\setminus G_{t}^{pub}</span> 1: if <span class="math">time\\_now&lt;publication(x)+d</span> then 2: return 1 3: <span class="math">T\\leftarrow time\\_now-received^{v}(x)</span> 4: <span class="math">G_{x}\\leftarrow G_{received^{v}(x)+2\\cdot d}^{v}\\cup future\\left(x,G_{x}\\right)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5: $g\\leftarrow\\min_{x^{\\prime}\\in\\underline{anticon}e(x,G_{x})}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x^{\\prime},G_{x}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6: <span class="math">risk\\leftarrow risk\\_hidden(T,g)</span> 7: if <span class="math">risk&lt;\\epsilon</span> then 8: return <span class="math">ACCEPT</span> 9: else 10: return <span class="math">WAIT</span></p>

    <p class="text-gray-300">The definition of <span class="math">risk\\_hidden</span> appears in (45)-(46). In practice, as node <span class="math">v</span> may have a partial view of <span class="math">G_{\\infty}^{pub}\\setminus G_{t}^{pub}</span>, in order to use Alg. 7 the user must wait additional <span class="math">d</span> seconds and verify that <span class="math">conflict\\left(tx\\right)\\cap G_{t+d}^{v}=\\emptyset</span>, i.e., that the attacker did not publish a double-spend in the interval <span class="math">[t-d,t]</span>. The correctness of the online policy modification is proven in Corollary 27.</p>

    <h2 id="sec-32" class="text-2xl font-bold">Appendix D Implementation Details</h2>

    <p class="text-gray-300">Minting. In SPECTRE, any block whose target meets the required value <span class="math">TARGET</span> – as will be defined below – receives the same minting reward. If its target is higher than <span class="math">TARGET</span> (i.e., it is solved with an easier difficulty) by a factor of <span class="math">(1+\\delta)</span> at most, then its reward is reduced by the same factor. The parameter <span class="math">\\delta</span> represents the protocol’s tolerance to blocks mined with an outdated difficulty. Thus, if for instance <span class="math">\\delta</span> is chosen to equal 2, then blocks with a target value of <span class="math">2\\cdot TARGET</span> or <span class="math">3\\cdot TARGET</span> are valid, and their minting rewards are reduced by a factor of 2 or 3, respectively; blocks with a target higher than <span class="math">3\\cdot TARGET</span> are invalid and discarded. We now explain how <span class="math">TARGET</span> is defined and readjusted.</p>

    <p class="text-gray-300">Retargeting. Similarly to Bitcoin and other PoW-based systems, the difficulty of block creation, represented by <span class="math">TARGET</span> (Subsection 4.1), must be occasionally adapted. Varying network conditions, and changes in the amount of computational resources invested in the system, require we limit the number of blocks created per second, to avoid network congestion. In Bitcoin this is done as follows: Every <span class="math">2016</span> blocks, the next block – which we call the <em>reference block</em> – is mined according to an adjusted difficulty. The new difficulty is obtained by taking the time</p>

    <p class="text-gray-300">that elapsed since the previous reference block (using the timestamps written inside each block) and plugging it into the retargeting formula. The output of this formula is the new value of <span class="math">TARGET</span> that the new reference block should be mined with.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We adapt this scheme to SPECTRE: Let <span class="math">x_{n-1}</span> be the previous reference block. Every new block <span class="math">x_{n}</span> that has the property that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">past\\left(x_{n}\\right)\\cap\\overline{future}\\left(x_{n-1}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2016<span class="math">, is a candidate to become the new reference block. In case additional candidates exist, we choose the one with the minimal </span>dist\\_gap<span class="math">, with some arbitrary tie-breaking, where </span>dist\\_gap(b,G):=\\min_{K\\in\\mathbb{N}}gap\\left(b,\\langle G,b,K\\rangle\\right)=0<span class="math">. The variable </span>dist\\_gap(b,G)<span class="math"> represents the minimal </span>K<span class="math"> such that adding </span>K<span class="math"> votes in favour of </span>b<span class="math"> makes its </span>gap<span class="math"> equal zero. This guarantees that among a set of candidates to become </span>x_{n}<span class="math"> (satisfying the above property) one and only block would be chosen as the reference block succeeding </span>x_{n-1}<span class="math">. In particular, as explained in Appendix A, an attacker block that was withheld for a while will have a large </span>dist\\_gap<span class="math"> and will not be eligible as a reference block. Furthermore, an attacker block that was mined before </span>x_{n-1}<span class="math"> will not affect the next retargeting, as it cannot belong to </span>future\\left(x_{n-1}\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The new difficulty, with which the new reference block should be mined, is given again through the formula that uses the time that elapsed between <span class="math">x_{n-1}</span> and <span class="math">x_{n}</span> to update <span class="math">TARGET</span>. The formula should aim for a predefined <span class="math">\\lambda</span> for which nodes are believed to have sufficient bandwidth, e.g., 1 MB per second. This difficulty dictates the difficulty for every block in <span class="math">antipast\\left(x_{n}\\right)\\setminus\\overline{anticone}\\left(x_{n+1}\\right)</span>, where <span class="math">x_{n+1}</span> is the next reference block. Every block in this set should be mined according to the same difficulty as <span class="math">x_{n}</span>.</p>

    <p class="text-gray-300">If block <span class="math">b\\in antipast\\left(x_{n}\\right)\\setminus\\overline{anticone}\\left(x_{n+1}\\right)</span> was solved with an easier difficulty than that dictated by the reference block <span class="math">x_{n}</span>, then <span class="math">b</span> is still considered valid, provided that its outdated target is at most <span class="math">(1+\\delta)</span> of the target of <span class="math">x_{n}</span> (i.e., a difficulty easier by at most <span class="math">(1+\\delta)</span>). The parameter <span class="math">\\delta</span> is the protocol’s tolerance threshold. The minting reward of <span class="math">b</span> is reduced by the corresponding factor, as explained above. Blocks whose target exceeds the required one by a factor higher of <span class="math">(1+\\delta)</span> are ignored and discarded.</p>

    <p class="text-gray-300">Block headers. In order to incorporate all blocks into the DAG, every block embeds in its header pointers to the hash of previous blocks. No redundancies are permitted, hence only leaf-blocks of <span class="math">past\\left(b\\right)</span> should be pointed at by the header of <span class="math">b</span>. The implication of this is that a block’s header is of size <span class="math">\\approx 50+d\\cdot\\lambda\\cdot 32</span> Byte. Therefore, there is a limit to the extent at which block size could be reduced and block creation rates increased – at extremely high rates, the overhead of the block header becomes significant relative to the number of included transactions. We note, additionally, that in case the current observable DAG has too many leaves (whether by a rare burst in block creations or by an attacker releasing many outdated blocks), the next block creator can cap the number of leaf-blocks it points at. Blocks left out by this block will later integrate into the DAG, as future blocks will have available space in their headers and will be able to point at these blocks and include them.</p>

    <p class="text-gray-300">Efficient implementation. Our current implementation of SPECTRE uses naïve calculations which are usually inefficient, specifically, cascading the votes all the way to the <span class="math">genesis</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">block. Several efficient implementations are possible. Designing such an efficient implementation requires attention to CPU attacks, in which the attacker exposes peculiar structures of outdated blocks in order to cause other nodes to perform extensive computation. It can be shown that these attacks are highly costly to the attacker. We have an implementation of SPECTRE’s procedures that works in <span class="math">\\mathcal{O}(d\\cdot\\lambda)</span> in expectation, compared to the naïve implementation with $\\mathcal{O}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{3})$. We leave its full specification, and a proof of the cost of CPU attacks on it, to future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Transaction fees. The body of a transaction specifies the amount transferred from the payer to the payee. The transaction-fee specifies the payment from the payer to the miner whose block contains the transaction. We regard these two parts as separate transactions, in the following sense. Assume that <span class="math">tx\\in x</span>, and denote by <span class="math">fee(tx,x)</span> the transaction representing the fee-payment of <span class="math">tx</span> to the creator of block <span class="math">x</span>. Assume now that two copies of <span class="math">tx</span> appear in two different blocks <span class="math">x,y</span>. Then the body is considered simply as a copy of the same transaction (recall the notation <span class="math">[tx]</span> from Sec. 2), whereas the transactions <span class="math">fee(tx,x)</span> and <span class="math">fee(tx,y)</span> are considered a conflict, i.e., a double-spend. Accordingly, as in the ordinary scheme of SPECTRE, the fee is granted to (the creator of) block <span class="math">x</span> iff <span class="math">tx\\in TxO(G)</span> and <span class="math">x</span> defeats all other blocks that contain <span class="math">tx</span> as well.</p>

    <p class="text-gray-300">This rule can potentially harm miners, in the special case when the relation between <span class="math">x</span> and <span class="math">y</span> does not become robust (SPECTRE does not guarantee robustness if these blocks were published in time proximity and an active attack is taking place). We address this problem by introducing <em>settlement transactions</em>. A settlement transaction is a voluntary transaction which both the creators of <span class="math">x</span> and <span class="math">y</span> sign after they observe that their blocks conflict. We denote it <span class="math">settlement(x,y)</span>. The interpretation of <span class="math">settlement(x,y)</span> is that the fees from all of (or part of, if the parties involved so choose) the transactions in <span class="math">x\\cap y</span> should be divided evenly between blocks <span class="math">x</span> and <span class="math">y</span>. <span class="math">settlement(x,y)</span> essentially overrides <span class="math">fee(tx,x)</span> and <span class="math">fee(tx,y)</span>. When <span class="math">settlement(x,y)</span> appears in some block <span class="math">z</span> in the DAG <span class="math">G</span>, it is considered accepted (i.e., a member of <span class="math">TxO(G)</span>) iff <span class="math">x,y\\in past\\left(z\\right)</span> and <span class="math">z</span> precedes every block that contains a transaction <em>spending</em> <span class="math">fee(tx,x)</span> or <span class="math">fee(tx,y)</span>. Therefore, once one party has spent its fee before it belonged to it robustly, it won’t be able to settle later (w.h.p.). Miners are therefore advised to wait for their transaction-fee rewards to become robust, or to initiate a settlement, before spending these rewards.</p>

    <p class="text-gray-300">Note that this scheme can be used to settle conflicts between blocks of multiple parties simultaneously. Furthermore, the settlement scheme need not be confined to conflicts regarding fees, and can be applied to any double-spend.</p>

    <h2 id="sec-33" class="text-2xl font-bold">Appendix E The Complete Proof of Theorem 3</h2>

    <h6 id="sec-34" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">For any <span class="math">D\\cdot\\lambda</span>, SPECTRE’s security threshold is 50%.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">E-A Additional notation</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>While <span class="math">honest</span> was defined as the set of honest nodes (Section 2), we here abuse notation and use it also to denote the of blocks created by honest nodes. The context will make our use of <span class="math">honest</span> unambiguous.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">G_{t}^{oracle}:=\\cup_{v\\in\\mathcal{N}}G_{t}^{v}</span>; this is the DAG as observed by a hypothetical oracle node. Similarly, <span class="math">G_{t}^{pub}:=\\cup_{v\\in honest}G_{t}^{v}</span>; this is the DAG as observed by a hypothetical node that has 0 delay from and to honest nodes.</li>

      <li><span class="math">node(b)\\in\\mathcal{N}</span> – the node that created block <span class="math">b</span>, <span class="math">time(b)</span> – the time of its creation, <span class="math">publication(b)</span> – the time at which <span class="math">node(b)</span> begun the transmission of <span class="math">b</span> to some other honest node, <span class="math">received^{v}(b)</span> – the time at which node <span class="math">v</span> received <span class="math">b</span>.</li>

      <li><span class="math">\\overline{future}\\left(x\\right):=future\\left(x\\right)\\cup\\left\\{x\\right\\}</span>, and similarly for <span class="math">\\overline{past}\\left(x\\right)</span> and <span class="math">\\overline{anticone}\\left(x\\right)</span>. In addition, <span class="math">antipast\\left(x\\right)=future\\left(x\\right)\\cup anticone\\left(x\\right)</span>, and similarly for <span class="math">antifuture\\left(x\\right)</span></li>

      <li><span class="math">\\widehat{\\mathcal{E}}_{s}^{u}(x,y):=</span> the event where <span class="math">vote_{y,x}\\left(virtual\\left(G_{s}^{u}\\right)\\right)=+1</span>.</li>

      <li><span class="math">\\mathcal{E}_{s}^{u}(x,y,\\epsilon):=</span> the event where <span class="math">Risk\\left(G_{s}^{u},x,y\\right)&lt;\\epsilon</span>.</li>

      <li><span class="math">\\widehat{\\mathcal{A}}_{s}^{u}(tx):=</span> the event where <span class="math">tx\\in TxO(G_{s}^{u})</span>.</li>

      <li><span class="math">\\mathcal{A}_{t}^{u}(tx,\\epsilon):=</span> the event where <span class="math">TxO\\in RobustTxO(G_{t}^{u},\\epsilon)</span>.</li>

      <li><span class="math">\\mathcal{E}_{t\\rightarrow\\infty}^{all}(x,y,\\epsilon):=</span> the event <span class="math">\\cap_{u\\in honest}\\cap_{s\\in\\left(t,\\infty\\right)}\\mathcal{E}_{s}^{u}(x,y,\\epsilon)</span>, and similarly for <span class="math">\\widehat{\\mathcal{E}}_{t\\rightarrow\\infty}^{all}(x,y)</span>, <span class="math">\\mathcal{A}_{t\\rightarrow\\infty}^{all}(tx,\\epsilon)</span>, and <span class="math">\\widehat{\\mathcal{A}}_{t\\rightarrow\\infty}^{all}(tx)</span>.</li>

      <li><span class="math">past_{h}\\left(z,G\\right):=past\\left(z,G\\right)\\cap honest</span>, and similarly for the future and anticone sets.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $V_{x\\prec y}(G):=\\left\\{z\\in G</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">z\\text{ is a strong voter w.r.t. }\\left(x,y\\right)\\text{ and }vote_{x,y}\\left(z\\right)=-1\\right\\}<span class="math"> (</span>V_{x\\prec y}(G)<span class="math"> depends on </span>x,y$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}_{oiss}(\\delta,j):=e^{-\\delta}\\cdot\\frac{\\delta^{j}}{j!}</span>.</li>

      <li>If <span class="math">\\mathcal{E}</span> is a set or an event, its complement set or event is denoted <span class="math">\\mathcal{E}^{\\complement}</span>.</li>

      <li>If <span class="math">x</span> is a real number, <span class="math">x^{+}</span> is defined by <span class="math">\\max\\left\\{0,x\\right\\}</span>.</li>

    </ul>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">VI-B Formal claims</h3>

    <p class="text-gray-300">We now take apart Theorem 3 and write a separate proposition for each of the security properties Safety, Progress, and Weak Liveness, and for Consistency. In order to prove Theorem 3, we need to prove the following propositions:</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Proposition 4 (Consistency).</h6>

    <p class="text-gray-300">The accepted set is consistent: For any history <span class="math">G</span>,</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">tx\\in TxO(G)</span> and <span class="math">tx_{2}\\in inputs\\left(tx\\right)</span> then <span class="math">tx_{2}\\in TxO(G)</span>.</li>

      <li>if <span class="math">tx\\in TxO(G)</span> and <span class="math">tx_{2}\\in conflict\\left(tx\\right)</span> then <span class="math">tx_{2}\\notin TxO(G)</span>.</li>

    </ol>

    <h6 id="sec-38" class="text-base font-medium mt-4">Proposition 5 (Safety).</h6>

    <p class="text-gray-300">For any <span class="math">v\\in honest</span> and time <span class="math">t</span>, if <span class="math">tx\\in RobustTxO\\left(\\epsilon,G_{t}^{v},d^{v},\\alpha\\right)</span> then, with probability of at least <span class="math">1-\\epsilon</span>, there exists a <span class="math">\\tau\\geq t</span> such that <span class="math">\\forall u\\in honest,\\forall s\\geq\\tau:RiskTxAccept\\left(tx,G_{s}^{u},d^{u},\\alpha\\right)&lt;\\epsilon</span>, and the expectation of <span class="math">\\tau-t</span> is finite.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Proposition 6 (Weak Liveness).</h6>

    <p class="text-gray-300">Let <span class="math">t</span> be the current time, and assume that <span class="math">tx\\in G_{t}^{pub}</span>. Let <span class="math">\\psi\\geq t</span> be the earliest time after <span class="math">t</span> at which an honest node <span class="math">\\epsilon</span>-accepts <span class="math">tx</span>. Then, conditioned on the event where <span class="math">conflict\\left(tx\\right)\\cap G_{\\psi}^{pub}=\\emptyset</span> and on the event where for all <span class="math">tx_{2}\\in inputs\\left(tx\\right)</span>, <span class="math">tx_{2}</span> remains <span class="math">\\epsilon</span>-accepted forever (by some honest node), the expectation of <span class="math">\\psi-t</span> is finite.</p>

    <p class="text-gray-300">We add and prove another proposition, which states that after robustly accepting a transcation for a certain <span class="math">\\epsilon</span>, it becomes (w.p. of at least <span class="math">1-\\epsilon</span>) robustly accepted for all <span class="math">\\epsilon^{\\prime}&lt;\\epsilon</span> as well:</p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proposition 7 (Progress).</h6>

    <p class="text-gray-300">For any <span class="math">v\\in honest</span> and time <span class="math">t</span>, if <span class="math">tx\\in RobustTxO\\left(\\epsilon,G^{v}_{t},d^{v},\\alpha\\right)</span> then, with probability of <span class="math">1-\\epsilon</span> at least, for any <span class="math">\\epsilon^{\\prime}</span> there exists a <span class="math">\\phi</span> such that <span class="math">\\forall s\\geq\\phi:RiskTxAccept\\left(tx,G^{v}_{s},d^{v},\\alpha\\right)&lt;\\epsilon</span>, and the expectation of <span class="math">\\phi-t</span> is finite.</p>

    <p class="text-gray-300">To each of the last three propositions we write a matching one which regards robustness of blocks (rather than that of transactions).</p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Proposition 8 (Safety (blocks)).</h6>

    <p class="text-gray-300">For any <span class="math">v\\in honest</span>, if <span class="math">Risk\\left(x,y,G^{v}_{t}\\right)&lt;\\epsilon</span> then, with probability of <span class="math">1-\\epsilon</span> at least, there exists a <span class="math">\\tau</span> such that <span class="math">\\forall u\\in honest,\\forall s\\geq\\tau:Risk\\left(x,y,G^{u}_{s}\\right)&lt;\\epsilon</span>, and <span class="math">\\mathbb{E}[\\tau-t]&lt;\\infty</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Proposition 9 (Progress (blocks)).</h6>

    <p class="text-gray-300">For any <span class="math">v\\in honest</span>, if <span class="math">Risk\\left(x,y,G^{v}_{t}\\right)&lt;\\epsilon</span> then, with probability of <span class="math">1-\\epsilon</span> at least, for any <span class="math">\\epsilon^{\\prime}&lt;\\epsilon</span> there exists a <span class="math">\\phi</span> such that <span class="math">\\forall s\\geq\\phi:Risk\\left(x,y,G^{u}_{s}\\right)&lt;\\epsilon</span>, and <span class="math">\\mathbb{E}[\\phi-t]&lt;\\infty</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Proposition 10 (Weak Liveness (blocks)).</h6>

    <p class="text-gray-300">Let <span class="math">t</span> be the current time, and assume that <span class="math">x\\in G^{pub}_{t}</span>. Let <span class="math">\\psi</span> be the first time <span class="math">s</span> at which for some honest node <span class="math">v</span>: <span class="math">Risk\\left(x,y,G^{v}_{s}\\right)&lt;\\epsilon</span>. Then, conditioned on the event where <span class="math">y\\notin G^{pub}_{\\psi}</span>, the expectation of <span class="math">\\psi-t</span> is finite.</p>

    <p class="text-gray-300">We prove the correctness of these propositions in separate subsections below; Consistency will be proven in a later subsection. But first, we begin with three simple lemmas.</p>

    <h3 id="sec-44" class="text-xl font-semibold mt-8">IV-C Basic properties</h3>

    <p class="text-gray-300">The two following lemmas are immediate from lines 7-14 of Algorithm 1.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Lemma 11.</h6>

    <p class="text-gray-300">Topological relations are unanimously agreed: If <span class="math">G=(C,E)</span> is a block DAG, and <span class="math">(y,x)\\in E</span>, then <span class="math">\\forall z\\in G:vote_{x,y}\\left(z,G\\right)=-1</span>.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Lemma 12.</h6>

    <p class="text-gray-300">A block’s vote regarding block(s) in its past depends only on its past, hence remains fixed forever: Let <span class="math">G_{1}</span> and <span class="math">G_{2}</span> be two block DAGs, and assume <span class="math">x,y,z\\in G_{1}\\cap G_{2}</span>. If <span class="math">\\{x,y\\}\\cap\\overline{past}\\left(z\\right)\\neq\\emptyset</span> then <span class="math">vote_{x,y}\\left(z,G_{1}\\right)=vote_{x,y}\\left(z,G_{2}\\right)</span>.</p>

    <p class="text-gray-300">Accordingly, we say that <span class="math">z</span> is a strong voter w.r.t the pair <span class="math">(x,y)</span> if <span class="math">z\\in\\overline{future}\\left(x\\right)\\cup\\overline{future}\\left(y\\right)</span>, and otherwise it is a weak voter.</p>

    <p class="text-gray-300">The following Lemma shows that the vote of the <span class="math">genesis</span> coincides with the vote of the virtual block. Intuitively, the <span class="math">genesis</span> votes according to the majority vote in the DAG excluding itself, and amplifies this majority, which in turn dictates the virtual block’s vote.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 13.</h6>

    <p class="text-gray-300"><span class="math">genesis</span>’s vote is the final vote: <span class="math">vote\\left(virtual\\left(G\\right)\\right)=vote\\left(genesis,G\\right)</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suffice it show that if <span class="math">vote_{x,y}\\left(genesis,G\\right)\\geq 0</span> then <span class="math">vote_{x,y}\\left(virtual\\left(G\\right)\\right)\\geq 0</span>. If <span class="math">(x,y)</span> are related topologically then by Lemma 11 all votes agree unanimously on their ordering, and</p>

    <p class="text-gray-300">in particular <span class="math">vote_{x,y}\\left(virtual\\left(G\\right)\\right)=vote_{x,y}\\left(genesis,G\\right)\\geq 0</span>. Otherwise, it cannot be the case that <span class="math">x</span> or <span class="math">y</span> are the <span class="math">genesis</span> block, hence the <span class="math">genesis</span> is a weak voter, and by line 14 we obtain</p>

    <p class="text-gray-300"><span class="math">vote_{x,y}\\left(virtual\\left(G\\right)\\right)=\\overline{sgn}\\left(\\sum_{z\\in G}vote_{x,y}\\left(z,G\\right)\\right)=</span> (1) <span class="math">\\overline{sgn}\\left(vote_{x,y}\\left(genesis,G\\right)+\\sum_{z\\in future(genesis,G)}vote_{x,y}\\left(z,G\\right)\\right)\\geq</span> (2) <span class="math">\\overline{sgn}\\left(\\sum_{z\\in future(genesis,G)}vote_{x,y}\\left(z,G\\right)\\right)=vote_{x,y}\\left(genesis,G\\right)\\geq 0,</span> (3)</p>

    <p class="text-gray-300">hence <span class="math">vote_{x,y}\\left(virtual\\left(G\\right)\\right)\\geq 0</span>. ∎</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">V-D Overview of the proof of Safety (blocks)</h3>

    <p class="text-gray-300">Proposition 8 claims essentially that all nodes will forever agree on the (robustness of) the order <span class="math">x\\prec y</span>, provided that it was sufficiently robust in the DAG observed by some honest node. This is the main and most involved part of the proof. The rest of the propositions follow from it, and their proofs are rather self explanatory. Since its proof is involved and occasionally technical, we begin with an overview of its structure.</p>

    <p class="text-gray-300">In order to simplify the analysis, we need to make some worst case assumptions regarding the behaviour of the attacker. Lemma 20 proves that these are indeed worst case assumptions, namely, that they indeed represent the optimal attack. The vote of each block under our modification is denoted <span class="math">p\\_vote\\left(\\right)</span>, a notion which we describe formally in Subsection E.6.</p>

    <p class="text-gray-300">In the next central lemma we show that, provided that the aggregate vote in <span class="math">future\\left(x\\right)</span> is sufficiently biased in favour of <span class="math">x\\prec y</span>, the <span class="math">genesis</span> block – hence the virtual block (by Lemma 13) – will vote <span class="math">x\\prec y</span>. This proves that, roughly speaking, <em>the vote of recent weak voters cascades through the DAG and convinces older weak blocks, forming thus the <span class="math">genesis</span>’s vote</em>. The way we prove this is by choosing a specific weak voter <span class="math">z_{late}</span>(in case <span class="math">x</span> is an honest block, <span class="math">z_{late}=x</span>), and making sure that its vote is sufficiently robust so as to guarantee that (i) it will not be reversed, and (ii) it will cascade all the way to the <span class="math">genesis</span>. Consequently, a successful attack (namely, a reversal of <span class="math">x\\prec y</span> in the DAG observed by some honest node) requires that the attacker add more blocks to <span class="math">future\\left(z_{late}\\right)</span> than the honest network adds (up to some additive term), in some time interval.</p>

    <p class="text-gray-300">The following lemma formalizes these observations. It uses some parameters (<span class="math">h</span>, <span class="math">j</span>, etc.) that only an oracle can have full knowledge of. We will later show how in reality a node can infer the robustness of block relations without having access to these parameters.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Lemma 14.</h6>

    <p class="text-gray-300">Let <span class="math">t\\geq publication(x)+2\\cdot d</span>. Let <span class="math">z_{late}</span> be the latest block in <span class="math">\\overline{past_{h}}\\left(x\\right)</span>. Denote:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $h:=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(z_{late},G_{t}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">32</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $m := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\setminus \\text{future}_a\\left(x, G_t^v\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $l := \\max_{z \\in G_t^{\\text{oracle}} \\cap \\text{honest}} \\left\\{ \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a\\left(z, G_{time(z_{\\text{late}})}^u\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">- \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_h\\left(z, G_{time(z_{\\text{late}})}^u\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right\\}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g := \\sum_{z \\in \\overline{\\text{future}}(x, G_t^v)} \\text{vote}_{y,x}(z, G_t^v)</span></li>

    </ul>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)^{\\mathbb{C}} &amp;\\subseteq \\left\\{ \\exists s \\geq t, \\exists u \\in \\text{honest s.t.} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">Given the result of the previous lemma, we can upper bound the probability that the order of <span class="math">x \\prec y</span> will be reversed. This result resembles the conventional analysis of Bitcoin's security: The greater number of blocks currently pointing at <span class="math">x</span> (and in SPECTRE: voting for <span class="math">x \\prec y</span>), the less likely it is that the attacker will be able to win the block-count race and reverse the decision.</p>

    <p class="text-gray-300"><strong>Lemma 15.</strong> Given the parameters of Lemma 14,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Pr \\left( \\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)^{\\mathbb{C}} \\right) &amp;amp;\\leq \\sum_{h&#x27; = 0}^{\\infty} \\mathcal{P}_{\\text{miss}}(d \\cdot \\alpha \\cdot \\lambda, h&#x27;) \\cdot \\\\ \\left( \\frac{\\alpha}{1 - \\alpha} \\right)^{(g - 2 \\cdot h - j - k_1 - l - m - h&#x27;)^+}. \\end{aligned}</span></div>

    <p class="text-gray-300">An ordinary node does not typically know for sure the values of the parameters assumed in Lemma 14. The next corollary shows that the result of that lemma (and the one that follows) applies when replacing these parameters with proper bounds thereof. We will later discuss how a node can obtain such bounds.</p>

    <p class="text-gray-300"><strong>Corollary 16.</strong> If</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $j \\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h\\left(x, G_t^{\\text{oracle}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">n_x \\geq \\text{future}_h\\left(x, G_t^{\\text{oracle}}\\right)</span></li>

      <li><span class="math">g \\leq \\sum_{z \\in \\overline{\\text{future}}(x, G_t^v)} \\text{vote}_{y,x}(z, G_t^v)</span>.</li>

    </ul>

    <p class="text-gray-300">Then</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\right)\\leq</span> (4) <span class="math">\\sum_{k=0}^{\\infty}\\mathcal{P}_{oiss}((2-\\alpha)\\cdot d\\cdot\\lambda,k)\\cdot\\sum_{h=0}^{\\infty}\\mathcal{P}_{oiss}(d\\cdot(1-\\alpha)\\cdot\\lambda,h)\\cdot</span> <span class="math">\\sum_{m=0}^{\\infty}\\binom{n_{x}+j+h+m-1}{m}\\cdot(1-\\alpha)^{n_{x}+j+h}\\cdot\\alpha^{m}\\cdot</span> <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-m)^{+}}</span></p>

    <p class="text-gray-300">We adjust the above results to the case where some blocks in <span class="math">future\\left(x,G\\right)</span> are known to belong to the attacker. Here we assume that this knowledge is granted to us by a hypothetical oracle. Later on, we will see how attacker blocks are recognized by Algorithm 3, w.h.p.</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Corollary 17.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If in addition to the assumptions of Corollary 16 we assume that $M\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(x,G_{t}^{v}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr\\left(\\widehat{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)^{\\complement}\\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(x,G_{t}^{v}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq M\\right)\\leq$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\sum_{k=0}^{\\infty}\\mathcal{P}_{oiss}((2-\\alpha)\\cdot d\\cdot\\lambda,k)\\cdot\\sum_{h=0}^{\\infty}\\mathcal{P}_{oiss}(d\\cdot(1-\\alpha)\\cdot\\lambda,h)\\cdot</span> (5) <span class="math">\\left(\\sum_{m^{\\prime}=M}^{\\infty}\\binom{n_{x}+j+h+m^{\\prime}-1}{m^{\\prime}}\\cdot(1-\\alpha)^{n_{x}+j+h}\\cdot\\alpha^{m^{\\prime}}\\right)^{-1}\\cdot</span> <span class="math">\\sum_{m=M}^{\\infty}\\binom{n_{x}+j+h+m-1}{m}\\cdot(1-\\alpha)^{n_{x}+j+h}\\cdot\\alpha^{m}\\cdot</span> <span class="math">\\left(\\frac{\\alpha}{1-\\alpha}\\right)^{(g-2\\cdot h-k-j-l-(m-M))^{+}}.</span></p>

    <p class="text-gray-300">We denote the RHS of this inequality by <span class="math">f_{post\\_mine}\\left(n_{x},g,j,l,M\\right)</span>.</p>

    <p class="text-gray-300">So far, our analysis assumed that we are given some proper bounds over the parameters from Lemma 14. Lemmas 24, 29, and 31 show how to appropriately bound these parameters. For each of these parameters, a separate error function is defined, which upper bounds the probability that it does not serve as a correct bound. These error functions deteriorate exponentially fast, by Lemmas 25, 30, and 32. Algorithm 3 aggregates these error functions into the total risk that it outputs.</p>

    <p class="text-gray-300">The parameters are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">l</span> – the pre-mining lead that the attacker obtained before the publication of <span class="math">x</span>, with error function <span class="math">f_{pre\\_mine}(l(G_{t}^{v}))</span>, calculated numerically in Subsection E.6.1</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">n_{x}</span> – the number of honest blocks in <span class="math">future\\left(x,G_{t}^{v}\\right)</span>, with error function $f_{post\\_pub}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G_{t}^{v}\\right)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)$, defined in Corollary 29 (Inequality (52)), and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">j</span> – the number of honest blocks created after <span class="math">time(x)</span>, with error function <span class="math">f_{pre\\_pub}\\left(n_{j}(G_{t}^{v})\\right)</span>, defined in Lemma 31 (Inequality (54)).</li>

    </ul>

    <p class="text-gray-300">While we have previously shown that <span class="math">n_{x}</span> properly counts all honest blocks, we now show that it does successfully exclude almost all attack blocks. Without such a guarantee, weaker attackers would have been able to publish their blocks and delay acceptance indefinitely.</p>

    <h6 id="sec-52" class="text-base font-medium mt-4">Lemma 18.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conditioned on the event <span class="math">\\widetilde{\\mathcal{E}}_{t\\to\\infty}^{all}(x,y)</span>, there exists a time <span class="math">\\tau\\in[t,\\infty)</span> such that <span class="math">\\forall s\\geq\\tau</span>: $M(oracle^{u},s)\\geq\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(x,G_{s}^{oracle^{u}}\\right)\\cap G_{[t,s]}^{oracle}\\setminus V_{x\\prec y}(G_{s}^{oracle^{u}})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-m^{<em>}<span class="math">, for some </span>m^{</em>}<span class="math"> that remains fixed after </span>\\tau<span class="math"> (and with </span>\\mathbb{E}[m^{*}]<span class="math"> determined by the events up to time </span>t$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above analysis (particularly Lemma 14) has upper bounded the probability that the attacker would be able to reverse the relation <span class="math">x\\prec y</span>. We now show that, conditioned on the order remaining <span class="math">x\\prec y</span>, the error function <span class="math">f_{post\\_mine}</span> (which upper bounds the probability of this order ever reversing) vanishes as well, which in turn implies that their order would be considered robust by all honest nodes.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Lemma 19.</h6>

    <p class="text-gray-300">There exists a <span class="math">\\psi\\in[t,\\infty)</span> such that <span class="math">\\Pr\\left(\\mathcal{E}_{t\\to\\infty}^{all}(x,y,\\epsilon)^{\\complement}\\mid\\mathcal{E}_{t}^{v}(x,y,\\epsilon)\\right)&lt;\\epsilon</span>. Moreover, <span class="math">\\mathbb{E}\\left[\\psi-t\\right]&lt;\\epsilon</span>.</p>

    <p class="text-gray-300">We have thus shown that if the output of Algorithm 3, as run by some honest node, was smaller than <span class="math">\\epsilon</span> then with probability of at least <span class="math">1-\\epsilon</span>, any honest node running Algorithm 3 (after some time) will get a result smaller than <span class="math">\\epsilon</span>. This completes the proof of Safety w.r.t. blocks.</p>

    <h3 id="sec-54" class="text-xl font-semibold mt-8">V-E Proof of Consistency</h3>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Part I:</em> We first prove that for any DAG <span class="math">G</span>, and for any <span class="math">tx_{1},tx_{2}\\in T</span>: if <span class="math">tx_{2}\\in inputs\\left(tx_{1}\\right)</span> and <span class="math">[tx_{1}]\\cap TxO(G)\\neq\\emptyset</span> then <span class="math">[tx_{2}]\\cap TxO(G)\\neq\\emptyset</span>.</p>

    <p class="text-gray-300">Assume <span class="math">tx_{2}\\in inputs\\left(tx_{1}\\right)</span> and <span class="math">[tx_{1}]\\cap TxO(G,G)\\neq\\emptyset</span> and let <span class="math">tx_{1}\\in[tx_{1}]\\cap TxO(G,G)</span>. Consider the iteration of the second loop (line 4) over <span class="math">tx=tx_{1}</span>. As <span class="math">tx\\in TxO(G,G)</span> it must be the case that during this iteration the algorithm has reached line 14. This means that for any <span class="math">[tx_{3}]\\in inputs\\left(tx_{1}\\right)</span> it hasn’t visited line 13; in particular for <span class="math">[tx_{3}]=[tx_{2}]</span>, the condition <span class="math">[tx_{2}]\\cap TxO\\left(G,past\\left(z_{1}\\right)\\right)=\\emptyset</span> has failed, i.e., <span class="math">[tx_{2}]\\cap TxO\\left(G,past\\left(z_{1}\\right)\\right)\\neq\\emptyset</span>. To see that <span class="math">TxO\\left(G,past\\left(z_{1}\\right)\\right)\\subseteq TxO\\left(G,G\\right)</span> observe that (i) during the run of the algorithm no transaction is ever removed from <span class="math">TX</span>, and that (ii) for any <span class="math">z_{1}\\in G\\cap subG</span>, the operations (in lines 4-14) of <span class="math">TxO\\left(G,subG\\right)</span> and <span class="math">TxO\\left(G,G\\right)</span> are identical; thus any addition of a transaction in line 14 in <span class="math">TxO\\left(G,subG\\right)</span> occurs in <span class="math">TxO\\left(G,G\\right)</span> as well. In particular, <span class="math">[tx_{2}]\\cap TxO\\left(G,G\\right)\\neq\\emptyset</span>.</p>

    <p class="text-gray-300"><em>Part II:</em> We now prove that for any DAG <span class="math">G</span>, and for any <span class="math">tx_{1},tx_{2}\\in T</span>: if <span class="math">tx_{2}\\in conflict\\left(tx_{1}\\right)</span> and <span class="math">[tx_{1}]\\cap TxO(G,G)\\neq\\emptyset</span> then <span class="math">[tx_{2}]\\cap TxO(G)=\\emptyset</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">tx_{2}\\in conflict\\left(tx_{1}\\right)</span> and <span class="math">[tx_{1}]\\cap TxO(G,G)\\neq\\emptyset</span> and let <span class="math">tx_{1}</span> be an element in the latter intersection. Assume by way of negation that there exists a <span class="math">tx_{2}\\in[tx_{2}]\\cap TxO(G,G)</span>. Then during the iteration of the first loop (line 3) over some instantiation <span class="math">z_{1}^{1}</span> of <span class="math">z_{1}</span> such that</p>

    <p class="text-gray-300"><span class="math">tx_{1}\\in z_{1}^{1}</span>, and of the second loop (line 4) over <span class="math">tx_{1}</span>, the algorithm has reached line 14. In particular, it did not reach line 10, hence <span class="math">z_{1}^{2}\\notin past\\left(z_{1}^{1}\\right)</span>. For the symmetrical argument, <span class="math">z_{1}^{1}\\notin past\\left(z_{1}^{2}\\right)</span>, which implies that <span class="math">z_{1}^{2}\\in anticone\\left(z_{1}^{1},G\\right)</span> (and <span class="math">z_{1}^{2}\\in anticone\\left(z_{1}^{1},G\\right)</span>). Now, either <span class="math">vote_{z_{1}^{1},z_{1}^{2}}\\left(virtual\\left(G\\right)\\right)\\geq 0</span> or <span class="math">vote_{z_{1}^{2},z_{1}^{1}}\\left(virtual\\left(G\\right)\\right)\\geq 0</span>. Either way, line 8 was reached by either the run on <span class="math">tx_{1}</span> or the run on <span class="math">tx_{2}</span>, which contradicts the assumption that both runs reached line 14. ∎</p>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">IV-F Proof of Safety (blocks)</h3>

    <p class="text-gray-300">In order to simplify the analysis, we need to make some worst case assumptions regarding the behaviour of the attacker, namely, that it publishes all of its blocks immediately after time <span class="math">t</span> (which represents the time at which some honest node accepted the transaction), and that before <span class="math">time(x)</span> its blocks point at all available blocks. These assumptions essentially modify the DAG (in case the attacker does not carry out the optimal attack scheme). We need to prove that these modifications indeed represent the worst case. To this end we use the notion of a <em>pseudo-vote</em>. A pseudo-vote begins by first explicitly defining and <em>fixing</em> the pseudo-vote of some blocks, which we call the <em>initial pseudo-voters</em>. Then we define the pseudo-vote of the rest of the blocks as in Algorithm 1. In more detail, we replace in Algorithm 1 the <span class="math">vote\\left(\\right)</span> notation by the <span class="math">p\\_vote\\left(\\right)</span> notation, and whenever the algorithm references <span class="math">p\\_vote\\left(c\\right)</span> of an initial pseudo-voter <span class="math">c</span>, we refer to its fixed predetermined value. Thus, the pseudo-vote of an initial pseudo-voter might change the pseudo-vote of other blocks.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Lemma 20.</h6>

    <p class="text-gray-300">Let <span class="math">x,y\\in G=(C,E)</span> such that <span class="math">G_{t}^{v}\\subseteq G</span>. Let <span class="math">G^{\\prime}=(C,E^{\\prime})</span> be the DAG resulting from adding the following edges to <span class="math">E</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall z_{1}\\in G\\cap before(time(x))\\cap malicious</span>, <span class="math">\\forall z_{2}\\in G\\cap before(time(z_{1}))\\setminus\\{z_{1}\\}</span>: add <span class="math">(z_{1},z_{2})</span> to <span class="math">E</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. <span class="math">\\forall z_{1}\\in G\\cap malicious\\setminus G_{t}^{v}</span>, $\\forall z_{2}\\in G_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">publication(z_{1}),\\infty}^{oracle}\\cap honest<span class="math">: add </span>(z_{2},z_{1})<span class="math"> to </span>E$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">p\\_vote\\left(\\right)</span> be defined by specifying the following initial pseudo-voters (and their votes):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\forall z\\in\\left(G\\cap malicious\\setminus G_{t}^{v}\\right)\\cup G\\cap before(time(x))\\cap malicious</span>: <span class="math">p\\_vote_{x,y}\\left(z,G\\right)=+1</span>.</li>

    </ol>

    <p class="text-gray-300">Then <span class="math">vote_{x,y}\\left(virtual\\left(G\\right),G\\right)\\leq</span> <span class="math">p\\_vote_{x,y}\\left(virtual\\left(G^{\\prime}\\right),G^{\\prime}\\right)</span>.</p>

    <p class="text-gray-300">Importantly, we assume here that blocks in <span class="math">G\\cap malicious</span> break ties in favour of <span class="math">y\\prec x</span>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><em>Part I:</em> Assume by way of negation that <span class="math">vote_{x,y}\\left(virtual\\left(G\\right),G\\right)=+1</span> yet nonetheless <span class="math">p\\_vote_{x,y}\\left(virtual\\left(G\\right),G^{\\prime}\\right)=-1</span> (observe that this is the only case in which the claim can fail, by definition, as a virtual vote cannot take the value of 0).</p>

    <p class="text-gray-300">Let <span class="math">b</span> be a block in <span class="math">\\overline{future}\\left(x,G\\right)\\cup\\left\\{virtual\\left(G\\right)\\right\\}</span> such that <span class="math">p\\_vote_{x,y}\\left(b,G^{\\prime}\\right)=-1</span>. <span class="math">b</span> cannot belong to <span class="math">G\\setminus G_{t}^{v}</span> or to <span class="math">G\\cap before(time(x))\\cap malicious</span>, because blocks in these sets have a pseudo-vote of <span class="math">+1</span>. Let <span class="math">z</span> be a block in <span class="math">past\\left(b,G\\right)</span>. Since <span class="math">b\\notin\\left(G\\setminus G_{t}^{v}\\right)\\cup\\left(G\\cap before(time(x))\\cap malicious\\right)</span>, there exists in <span class="math">G^{\\prime}</span> a path from <span class="math">b</span> to <span class="math">z</span> that passes through</p>

    <p class="text-gray-300">36</p>

    <p class="text-gray-300">an edge <span class="math">(z_{2}, z_{1})</span> satisfying the conditions of the second modification to <span class="math">G</span>, and through an edge <span class="math">(z_{1}&#x27;, z_{2}&#x27;)</span> satisfying those of the first modification. In particular, <span class="math">time(z_{2}) \\geq publication(z_{1}) \\geq t - d</span>, and <span class="math">time(x) \\geq time(z_{2}&#x27;) \\geq time(z_{1}&#x27;)</span>. As <span class="math">b</span> and <span class="math">z</span> are the end-vertices of this path, <span class="math">time(b) \\geq time(z_{2}) \\geq t - d \\geq publication(x) + d \\geq time(x) + d \\geq time(z_{1}&#x27;) + d \\geq time(z) + d</span>. Since <span class="math">z_{2}</span> is honest, <span class="math">z \\in past(z_{2}, G)</span>, hence <span class="math">z \\in past(b, G)</span>. Combined with <span class="math">E \\subset E&#x27;</span> we obtain: <span class="math">past(b, G&#x27;) = past(b, G)</span>.</p>

    <p class="text-gray-300"><strong>Part II:</strong> Let <span class="math">b</span> be the earliest block in <span class="math">\\overline{future}(x, G) \\cup \\{virtual(G)\\}</span> for which <span class="math">vote_{x,y}(b, G) = +1</span> but <span class="math">p\\_vote_{x,y}(b, G&#x27;) = -1</span>, and let <span class="math">z</span> be the latest block in <span class="math">antifuture(x, G&#x27;)</span> for which <span class="math">vote_{x,y}(z, past(b, G)) &amp;gt; p\\_vote_{x,y}(z, past(b, G&#x27;))</span>. If such a <span class="math">z</span> exists then, similarly to the previous part, we know that <span class="math">past(z, G&#x27;) = past(z, G)</span>; this proves that <span class="math">z</span> is a weak voter both in <span class="math">G</span> and in <span class="math">G&#x27;</span>, hence that its pseudo-vote is the sign of the sum of pseudo-votes in its future.^[11]</p>

    <p class="text-gray-300">To see that such a <span class="math">z</span> indeed exists, observe that the genesis satisfies these conditions: By Lemma 13 <span class="math">vote_{x,y}(b,G) = vote_{x,y}(virtual(past(b,G))) = +1</span> implies <span class="math">vote_{x,y}(genesis,past(b,G)) \\geq 0</span>, and in a similar way <span class="math">p\\_vote_{x,y}(b,G&#x27;) = p\\_vote_{x,y}(virtual(past(b,G&#x27;)) = -1</span> implies that <span class="math">p\\_vote_{x,y}(genesis,past(b,G&#x27;)) = -1</span>.^[12]</p>

    <p class="text-gray-300"><strong>Part III:</strong> By the choice of <span class="math">z</span>, if <span class="math">z&#x27; \\in future(z, past(b, G&#x27;))</span> is weak with respect to <span class="math">(x, y)</span> then <span class="math">vote_{x,y}(z&#x27;, past(b, G)) \\leq p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;))</span>. Moreover, by the choice of <span class="math">b</span>, if <span class="math">z&#x27; \\in past(b, G&#x27;)</span> is strong w.r.t. <span class="math">(x, y)</span> and <span class="math">vote_{x,y}(z&#x27;, past(b, G)) = +1</span> then <span class="math">p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;)) = +1</span>. All in all, we have that for all <span class="math">z&#x27; \\in future(z, past(b, G&#x27;))</span>, <span class="math">vote_{x,y}(z&#x27;, past(b, G)) \\leq p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;))</span>. Therefore:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, past(b,G))} \\operatorname{vote}_{x,y}(z&#x27;, past(b,G)) \\leq \\tag{6}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, past(b,G))} p\\_vote_{x,y}(z&#x27;, past(b,G&#x27;)) \\leq \\tag{7}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, past(b,G))} p\\_vote_{x,y}(z&#x27;, past(b,G&#x27;)) +</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, past(b,G&#x27;) \\setminus past(b,G))} p\\_vote_{x,y}(z&#x27;, past(b,G&#x27;)) = \\tag{8}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, past(b,G&#x27;))} p\\_vote_{x,y}(z&#x27;, past(b,G&#x27;)) . \\tag{9}</span></div>

    <p class="text-gray-300">The last equality follows from <span class="math">future(z, past(b,G)) \\subseteq future(z, past(b,G&#x27;))</span>, which holds because <span class="math">E \\subseteq E&#x27;</span>. The inequality in (7) holds because if some <span class="math">z&#x27;</span> has been added (by transforming</p>

    <p class="text-gray-300">^[11] It cannot be the case that <span class="math">y \\in past(z, G&#x27;)</span>, because we know that <span class="math">z</span> is not an initial pseudo-voter (as its pseudo-vote is <span class="math">-1</span>), and therefore the pseudo-vote procedure would have assigned its pseudo-vote to be <span class="math">+1</span>, because <span class="math">y</span> is in its past but <span class="math">x</span> is not in it past, in the same way the ordinary procedure does.</p>

    <p class="text-gray-300">^[12] The equality <span class="math">p\\_vote_{x,y}(b,G&#x27;) = p\\_vote_{x,y}(virtual(past(b,G&#x27;)))</span> holds because <span class="math">b</span> is either a strong voter w.r.t. <span class="math">(x,y)</span> or the virtual voter.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300"><span class="math">G</span> into <span class="math">G^{\\prime}</span>) to the future of some honest block, then <span class="math">z^{\\prime}</span> must belong to the attacker, hence <span class="math">p\\_vote_{x,y}(z&#x27;, past(b, G&#x27;)) = +1 &amp;gt; 0</span>.</p>

    <p class="text-gray-300"><strong>Part IV</strong>: Consequently, since <span class="math">z</span> is a weak voter with respect to <span class="math">(x,y)</span>, (6)-(9) imply that <span class="math">vote_{x,y}(z, past(b,G)) \\leq p\\_vote_{x,y}(z, past(b,G&#x27;))</span>, which contradicts the choice of <span class="math">z</span>.</p>

    <p class="text-gray-300"><strong>Lemma 14.</strong> Let <span class="math">t \\geq \\text{publication}(x) + 2 \\cdot d</span>. Let <span class="math">z_{\\text{late}}</span> be the latest block in <span class="math">\\overline{\\text{past}}_h(x)</span>. Denote:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $h := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h(z_{\\text{late}}, G_t^{\\text{oracle}}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $m := \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a(z_{\\text{late}}, G_t^{\\text{oracle}}) \\setminus \\text{future}_a(x, G_t^v) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $k_1 := \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t-d,t]}^{oracle} \\cap \\text{honest} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">$</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $l := \\max_{z \\in G_t^{\\text{oracle}} \\cap \\text{honest}} \\left\\{ \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a(z, G_{time(z_{\\text{late}})}^u) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">- \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_h(z, G_{time(z_{\\text{late}})}^u) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right\\}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g := \\sum_{z \\in \\overline{\\text{future}}(x, G_t^v)} \\text{vote}_{y,x}(z, G_t^v)</span></li>

    </ul>

    <p class="text-gray-300">Then,</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widehat{\\mathcal{E}}_{t \\rightarrow \\infty}^{all}(x, y)^{\\complement} &amp;\\subseteq \\left\\{ \\exists s \\geq t, \\exists u \\in \\text{honest s.t.} \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} \\tag{10} $$</p>

    <p class="text-gray-300"><strong>Proof.</strong></p>

    <p class="text-gray-300"><strong>Part I</strong>: In the proof below we make the following assumption: Any attacker-block <span class="math">z</span> created before <span class="math">time(x)</span> always votes in favour of <span class="math">y \\prec x</span> (even if it is supposed to vote otherwise according to Algorithm 1). We further assume that any such <span class="math">z</span> satisfies <span class="math">\\overline{past}(z) = G_{time(z)}^{oracle}</span>, i.e., it points at all blocks available at the time of its creation. Finally, we assume that the attacker releases all of his blocks to all nodes in <span class="math">honest \\setminus \\{v\\}</span> precisely at time <span class="math">t</span> and onward. The previous lemma implies that these are indeed worst case assumptions: Take <span class="math">G</span> to be any <span class="math">G_s^u</span>. Then, what the lemma shows is that as long as <span class="math">p\\_vote_{x,y}(virtual(G_s^u)) = -1</span>, also <span class="math">vote_{x,y}(virtual(G_s^u)) = -1</span> (under the worst case assumption that ties are always broken in favour of <span class="math">y</span>). The analysis below applies, formally, to <span class="math">p\\_vote()</span> as formalized in the previous lemma (specifically in (3)). Nevertheless, now that the argument has been formally made, we omit this notation henceforth.</p>

    <p class="text-gray-300"><strong>Part II</strong>: Let us look at the following chain of implications:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} vote_{x,y}(virtual(G_s^u)) &amp;amp;\\geq 0 \\Rightarrow vote_{x,y}(genesis, G_s^u) \\geq 0 \\Rightarrow \\\\ \\sum_{z&#x27; \\in \\text{future}(genesis, G_s^u)} vote_{x,y}(z&#x27;, G_s^u) &amp;amp;\\geq 0 \\end{aligned} \\tag{11}</span></div>

    <p class="text-gray-300">In fact, we use the lemma with a slight modification: The second modification does not apply to all such <span class="math">(z_2, z_1)</span> satisfying the specified conditions, rather to a subset thereof, since blocks created by node <span class="math">v</span> between <span class="math">t</span> and <span class="math">t + d</span> need not point at all attacker blocks in <span class="math">G \\setminus G_s^v</span>. It is easy to see, however, that the proof of the lemma remains intact (and it remains so when applying the second modification to any subset of <span class="math">(G \\cap \\text{malicious} \\setminus G_t^v) \\times (G_{[publication(z_1), \\infty)}^{oracle} \\cap \\text{honest})</span>).</p>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">The first implication follows from Lemma 13. The second one follows from the definition of genesis's vote.¹⁴ Thus,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\widehat{\\mathcal{E}}_{t \\rightarrow \\infty}^{all}(x, y)^{\\mathbb{C}} = \\cup_{u \\in honest, s \\in [t, \\infty)} \\widehat{\\mathcal{E}}_{s}^{u}(x, y)^{\\mathbb{C}} = \\\\ \\{\\exists u \\in honest, \\exists s \\geq t: vote_{x, y} (virtual(G_{s}^{u})) \\geq 0\\} \\end{array}</span></div>

    <p class="text-gray-300">However, if there exists such an <span class="math">s</span> as the latter event requires, then we can look at the first such <span class="math">s</span>. With respect to it, between <span class="math">t</span> and <span class="math">s</span> all honest votes were in favour of <span class="math">x \\prec y</span>; this is because for any honest block <span class="math">z&#x27;</span> with <span class="math">time(z&#x27;) \\in [t, s)</span>, <span class="math">past(z&#x27;) = G_{time(z&#x27;)}^{node(z&#x27;)}</span>, hence <span class="math">vote(z&#x27;) = vote(Virtual(G_{time(z&#x27;)}^{node(z&#x27;)}))</span>, and by the choice of <span class="math">s</span> as the earliest time for which an honest node's DAG's virtual block votes in favour of <span class="math">y \\preceq x</span>, we know that <span class="math">vote_{x,y}(z&#x27;, G_s^u) = -1</span>.</p>

    <p class="text-gray-300"><strong>Part III:</strong> Below, the notation <span class="math">G_{[t_1,t_2]}^u</span> stands for <span class="math">G_{s}^{u}\\cap \\text{before}(t_{2})\\setminus \\text{before}(t_{1})</span>.</p>

    <p class="text-gray-300">We claim that for all <span class="math">z \\in \\overline{past_h}(x)</span>:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vote_{x, y}(z, G_{s}^{u}) \\leq \\widehat{sgn}\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t, s]}^{u} \\cap malicious \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t, s]}^{u} \\cap honest \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. + 2 \\cdot h + l + k_{1} + j + m - g \\right). \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove the claim by a complete induction on $D(z) \\coloneqq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(z, \\overline{past_h}(x)\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Assume we have proved the claim for any </span>z<span class="math"> with </span>D(z) &lt; D<span class="math">. We now prove it for </span>z<span class="math"> with </span>D(z) = D<span class="math">. If </span>z = x<span class="math"> then </span>vote_{x,y}(z, G_s^u) = -1<span class="math"> hence the above inequality is satisfied trivially. Otherwise, </span>z<span class="math"> is a weak voter, and </span>vote_{x,y}(z, G_s^u)<span class="math"> is given by the sign of the sum of votes in its future. We decompose these voters into three subsets: members of </span>future\\left(z, G_{time(z_{late})}^u\\right)<span class="math">, members of </span>future\\left(z, G_{[time(z_{late}), t]}^u\\right)<span class="math">, and members of </span>future\\left(z, G_{[t, s]}^u\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1) Members of <span class="math">future\\left(z, G_{time(z_{late})}^u\\right)</span>: By the induction hypothesis we know that all blocks in <span class="math">future_h\\left(z, \\overline{past_h}(z_{late})\\right)</span> vote in favour of <span class="math">x \\prec y</span>, and additionally we have <span class="math">future_h\\left(z, G_{time(z_{late})}^u\\right) \\setminus \\overline{past}(z_{late}) \\subseteq anticone_h\\left(z_{late}, G_{time(z_{late})}^u\\right)</span>. Thus, $\\sum_{z' \\in future_h\\left(z, G_{time(z_{late})}^u\\right)} vote_{x,y}\\left(z', G_s^u\\right) \\leq 2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h\\left(z_{late}, G_{time(z_{late})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z, G_{time(z_{late})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. We obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_{z' \\in future\\left(z, G_{time(z_{late})}^u\\right)} vote_{x, y}\\left(z', G_{s}^{u}\\right) \\leq \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h\\left(z_{late}, G_{time(z_{late})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">¹⁴ Here we implicitly assume that <span class="math">x</span> and <span class="math">y</span> are not related topologically, which rules out the option that <span class="math">x = \\text{genesis}</span> or <span class="math">y = \\text{genesis}</span>, hence <span class="math">\\text{genesis}</span> is weak w.r.t. <span class="math">(x, y)</span>. If they are related topologically, the result is trivial, for all votes are then forever unanimous in the same direction (Lemma 11).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Members of future  <span class="math">\\left(z,G_{[time(z_{late}),t]}^{u}\\right)</span> :</li>

    </ol>

    <p class="text-gray-300">a) Honest blocks: By Part I we have that  <span class="math">future_{a}\\left(z,G_{[time(z_{late}),t]}^{u}\\right)\\setminus</span> <span class="math">future_{a}\\left(z_{late},G_{[time(z_{late}),t]}^{u}\\right) = \\emptyset .</span>  This implies that  <span class="math">anticone_{h}\\left(z_{late},G_{[time(z_{late}),time(z_{late})+d]}^{u}\\right)\\supseteq future\\left(z,G_{[time(z_{late}),t]}^{u}\\right)\\setminus</span>  future  <span class="math">(z_{late},G_{t}^{u})</span>  . We obtain:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sum_ {z ^ {\\prime} \\in f u t u r e _ {h} \\left(\\boldsymbol {z}, G _ {[ t i m e (z _ {l a t e}), t ]} ^ {u}\\right)} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) \\leq \\\\ \\sum_ {z ^ {\\prime} \\in f u t u r e _ {h} (\\mathbf {z} _ {l a t e}, G _ {t} ^ {u})} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) + \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {a n t i c o n e} _ {h} \\left(z _ {\\text {l a t e}}, G _ {[ \\text {t i m e} (z _ {\\text {l a t e}), \\text {t i m e} (z _ {\\text {l a t e}}) + d ]}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\\\ \\sum_ {z ^ {\\prime} \\in f u t u r e _ {h} (z _ {l a t e}, G _ {t} ^ {v})} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) + \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {a n t i c o n e} _ {h} \\left(z _ {\\text {l a t e}}, G _ {[ \\text {t i m e} (z _ {\\text {l a t e}), \\text {t i m e} (z _ {\\text {l a t e}}) + d ]}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t - d, t ]} ^ {o r a c l e} \\cap h o n e s t \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\\\ \\sum_ {z ^ {\\prime} \\in f u t u r e _ {h} (\\boldsymbol {x}, G _ {t} ^ {v})} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) + \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {a n t i c o n e} _ {h} \\left(z _ {\\text {l a t e}}, G _ {[ \\text {t i m e} (z _ {\\text {l a t e}), \\text {t i m e} (z _ {\\text {l a t e}}) + d ]}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t - d, t ]} ^ {o r a c l e} \\cap h o n e s t \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {h} \\left(z _ {l a t e}, G _ {t} ^ {v}\\right) \\backslash f u t u r e _ {h} \\left(x, G _ {t} ^ {v}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">b) Attacker blocks: We utilize our worst case assumptions described in Part I to obtain:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\sum_ {z ^ {\\prime} \\in f u t u r e _ {a} \\left(\\boldsymbol {z}, G _ {[ t i m e (z _ {l a t e}), t ]} ^ {u}\\right)} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) = \\\\ \\sum_ {z ^ {\\prime} \\in f u t u r e _ {a} \\left(\\boldsymbol {z} _ {l a t e}, G _ {[ t i m e (z _ {l a t e}), t ]} ^ {u}\\right)} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) \\leq \\\\ \\sum_ {z ^ {\\prime} \\in f u t u r e _ {a} (\\boldsymbol {x}, G _ {t} ^ {v})} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) + \\\\ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {a} \\left(z _ {l a t e}, G _ {t} ^ {u}\\right) \\backslash f u t u r e _ {a} \\left(x, G _ {t} ^ {v}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">. \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">c) All blocks: We combine the honest and attacker blocks in <span class="math">future\\left(z, G_{[time(z_{late}),t]}^{u}\\right)</span> to obtain:</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_{z^{\\prime} \\in future\\left(z, G_{[time(z_{late}),t]}^{u}\\right)} \\operatorname{vote}_{x,y}\\left(z^{\\prime}, G_{s}^{u}\\right) \\leq \\\\ \\sum_{z^{\\prime} \\in future_{h}\\left(x, G_{t}^{v}\\right)} \\operatorname{vote}_{x,y}\\left(z^{\\prime}, G_{s}^{u}\\right) + \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticoner_{h}\\left(z_{late}, G_{[time(z_{late}),time(z_{late})+d]}^{u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>\\sum_{z^{\\prime} \\in future_{a}\\left(\\boldsymbol{x}, G_{t}^{v}\\right)} \\operatorname{vote}_{x,y}\\left(z^{\\prime}, G_{s}^{u}\\right) + \\\\</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(z_{late}, G_{t}^{u}\\right) \\setminus future_{a}\\left(x, G_{t}^{v}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\tag{12}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">g + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticoner_{h}\\left(z_{late}, G_{[time(z_{late}),time(z_{late})+d]}^{u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\tag{13}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t-d,t]}^{oracle} \\cap honest \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{h}\\left(z_{late}, G_{t}^{v}\\right) \\setminus future_{h}\\left(x, G_{t}^{v}\\right) \\right</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(z_{late}, G_{t}^{u}\\right) \\setminus future_{a}\\left(x, G_{t}^{v}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Members of <span class="math">future\\left(z, G_{[t,s]}^{u}\\right)</span>: Finally, by the choice of <span class="math">s</span>, all honest blocks created between <span class="math">t</span> and <span class="math">s</span> vote in favour of <span class="math">x \\prec y</span>, hence</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_{z^{\\prime} \\in future\\left(z, G_{[t,s]}^{u}\\right)} \\operatorname{vote}_{x,y}\\left(z^{\\prime}, G_{s}^{u}\\right) \\leq \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{h}\\left(z, G_{[t,s]}^{u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_{a}\\left(z, G_{[t,s]}^{u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where we used again the fact that <span class="math">t \\geq publication(x) + d \\geq publication(z) + d</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Combining all the above results we obtain:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, G_s^u)} \\text{vote}_{x,y} \\left(z&#x27;, G_s^u\\right) \\leq \\tag{14}</span></div>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h \\left(z_{\\text{late}}, G_{\\text{time}(z_{\\text{late}})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- g + \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{anticone}_h \\left(z_{\\text{late}}, G_{\\text{time}(z_{\\text{late}}), \\text{time}(z_{\\text{late}}) + d]}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t-d,t]}^{oracle} \\cap \\text{honest} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_h \\left(z_{\\text{late}}, G_t^v\\right) \\setminus \\text{future}_h \\left(x, G_t^v\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a \\left(z_{\\text{late}}, G_t^u\\right) \\setminus \\text{future}_a \\left(x, G_t^v\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\tag{16} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{honest} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{malicious} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq \\tag{17}</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">$$ \\begin{aligned}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2 \\cdot h + l + k_1 - g + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{honest} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a \\left(z_{\\text{late}}, G_t^u\\right) \\setminus \\text{future}_a \\left(x, G_t^v\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&amp; \\leq \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 \\cdot h + l + k_1 - g + \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{malicious} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">- \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{honest} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&amp; \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">+ \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_h \\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\setminus \\text{future}_h \\left(x, G_t^v\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\tag{19} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\text{future}_a \\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\setminus \\text{future}_a \\left(x, G_t^v\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">= \\tag{20} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">2 \\cdot h + l + k_1 - g + j + m + \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{malicious} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&amp; \\tag{21} \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G_{[t,s]}^u \\cap \\text{honest} \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">z</span> is a weak voter, we conclude that $\\text{vote}_{x,y}(z, G_s^u) \\leq \\widehat{\\text{sgn}}\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2 \\cdot h + l + k_1 + g + j + m\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part IV:</strong> In particular, for <span class="math">z = \\text{genesis}</span>, the event <span class="math">\\text{vote}_{x,y}(\\text{genesis}, G_s^u) \\geq 0</span> is contained in the event where $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ g - 2 \\cdot h - l - k_1 - j - m<span class="math">. By (11), for all </span>u \\in \\text{honest}<span class="math"> and </span>s \\geq t<span class="math"> this event contains also </span>\\widehat{\\mathcal{E}}_u^s(x,y)^\\complement<span class="math">, hence it contains also their union </span>\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)^\\complement$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">42</p>

    <p class="text-gray-300">Lemma 15. Given the parameters of Lemma 14,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {\\text {a l l}} (x, y) ^ {\\complement}\\right) \\leq \\sum_ {h ^ {\\prime} = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} \\left(d \\cdot \\alpha \\cdot \\lambda , h ^ {\\prime}\\right). \\tag {22}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - 2 \\cdot h - j - k _ {1} - l - m - h ^ {\\prime}) ^ {+}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Since all nodes <span class="math">u \\in \\text{honest}</span> receive honest blocks with a delay of <span class="math">d</span> seconds at most, we have that $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_{[t,s]}^oracle\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z_{\\text{late}}, G_{[t,\\max\\{s-d,t\\}]}^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We further upper bound </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(x, G_{[s',s]}^oracle\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> by </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(x, G_{[s-d,s]}^oracle\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and observe that the latter follows a Poisson distribution with parameter </span>\\alpha \\cdot d \\cdot \\lambda<span class="math">; we denote this variable by </span>h'<span class="math">. For any given value of </span>h'<span class="math">, the variable </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(x, G_{s'}^{oracle} \\setminus G_t^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(x, G_{s'}^{oracle} \\setminus G_t^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ h'<span class="math"> can be modeled as a random walk </span>X_i<span class="math"> (where the </span>i<span class="math">th step is the creation-time of the </span>i<span class="math">th block after time </span>t<span class="math">), with </span>X_0 = h'<span class="math">, and with a drift of </span>\\alpha<span class="math"> towards positive infinity. The probability that </span>X_i<span class="math"> would ever reach the interval </span>[-h - j - k_1 - h' - l - m + g, +\\infty)<span class="math"> is </span>\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{g - 2 \\cdot h - j - k_1 - l - m - h'}<span class="math">, if </span>g &gt; h + j + k_1 + l + m + h'$, and 1 otherwise (see [18], [17]).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Corollary 16. If</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $j \\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h\\left(x, G_t^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">l \\geq \\max_{z \\in G_t^{oracle} \\cap \\text{honest}} \\left\\{ A_{time(x)}^z - H_{time(x)}^z \\right\\}</span></li>

      <li><span class="math">n_x \\geq \\text{future}_h(x, G_t^{oracle})</span></li>

      <li><span class="math">g \\leq \\sum_{z \\in \\overline{\\text{future}}(x, G_t^v)} \\text{vote}_{y,x}(z, G_t^v)</span>.</li>

    </ul>

    <p class="text-gray-300">Then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {\\text {a l l}} (x, y)\\right) \\leq \\tag {23}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {k = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} ((2 - \\alpha) \\cdot d \\cdot \\lambda , k) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (d \\cdot (1 - \\alpha) \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + j + h + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x} + j + h} \\cdot \\alpha^ {m}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - 2 \\cdot h - k - j - l - m) ^ {+}}</span></div>

    <p class="text-gray-300">Proof. We build on the results of previous lemmas. The proof of Lemma 14, which is deterministic, remains intact when the corresponding parameters serve as bounds; see (14)-(21).</p>

    <p class="text-gray-300">43</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The variables <span class="math">k_{1}</span>, $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(z_{late},G_{time(z_{late}),time(z_{late})+d_{t}^{0}}^{u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>h'<span class="math"> are the sum of independent Poisson processes; the parameter of the first two is </span>d \\cdot (1 - \\alpha) \\cdot \\lambda<span class="math">, and the parameter of </span>h'<span class="math"> is </span>d \\cdot \\alpha \\cdot \\lambda<span class="math">. Thus, their sum is a new Poisson variable </span>k<span class="math"> with parameter </span>(2 \\cdot (1 - \\alpha) + \\alpha) \\cdot d \\cdot \\lambda = (2 - \\alpha) \\cdot d \\cdot \\lambda<span class="math">. The variable </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(z_{late},G_{time(z_{late})}^{u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is an additional Poisson variable with parameter </span>d \\cdot (1 - \\alpha) \\cdot \\lambda<span class="math">. We denote it by </span>h$ (thereby overriding its original meaning in Lemma 14).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 14 uses the variable $m = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{late}, G_t^{oracle}\\right) \\setminus \\text{future}_a(x, G_t^v) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> which is upper bounded by </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{late}, G_t^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Provided that the honest network has created precisely </span>n<span class="math"> blocks since the creation of </span>z_{late}<span class="math">, the number of blocks created by the attacker at the same time follows a negative binomial distribution (see [17]), i.e., it takes the value </span>m<span class="math"> with probability </span>\\binom{n+m-1}{n} \\cdot (1-\\alpha)^n \\cdot \\alpha^m<span class="math">. In the worst case, all of these blocks belong to </span>\\text{future}\\left(z_{late}, G_t^{oracle}\\right)<span class="math">. Here, again, it is sufficient to upper bound </span>n<span class="math">, since increasing the parameter </span>n<span class="math"> results in a distribution over </span>m<span class="math"> that stochastically dominates (in first order) the original one. The number of honest blocks created after </span>\\text{time}(z_{late})<span class="math"> (up to time </span>t<span class="math">) is upper bounded by </span>\\text{antipast}_h\\left(z_{late}, G_t^{oracle}\\right)<span class="math">, since blocks in </span>\\text{past}_h(z_{late})<span class="math">. We thus have: </span>n \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticon}_h(z_{late}, G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(z_{late}, G_t^v) \\setminus \\text{future}_h(x, G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(x, G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq h + j + n_x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally, as <span class="math">l</span> and <span class="math">j</span> are upper bounds and <span class="math">g</span> is a lower bound to the corresponding variables from Lemma 14, one could simply turn all equalities in its proof (and in the proof of Lemma 15) into “<span class="math">\\leq</span>” inequalities and the proof remains intact.</p>

    <p class="text-gray-300">Below we revisit previous results, regarding the case where <span class="math">x</span> is known to be an honest block, and to the case where one needs to defend a group of blocks rather than an individual block.</p>

    <p class="text-gray-300"><strong>Lemma 21.</strong> Assume that <span class="math">node(x) \\in \\text{honest}</span> and that <span class="math">publication(y) \\geq publication(x) + d</span>. Let <span class="math">z_{late}</span> be the latest block in <span class="math">\\overline{anticone_h}(x, G_t^v)</span> and let <span class="math">z_{early}</span> be the earliest block in <span class="math">\\overline{anticone_h}(x, G_t^v)</span>. Furthermore, assume:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $l := \\max_{z \\in G_t^{oracle} \\cap \\text{honest}} \\left\\{ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z, G_{time(z_{early})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z, G_{time(z_{early})}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">g \\leq \\max_{x&#x27; \\in \\overline{anticone_h}(x, G_t^v)} \\left\\{ z \\in \\overline{future}(x&#x27;, G_t^v) : \\text{vote}_{y,x}(z, G_t^v) = -1 \\right\\} - \\min_{x&#x27; \\in \\overline{anticone_h}(x, G_t^v)} \\left\\{ z \\in \\overline{future}(x&#x27;, G_t^v) : \\text{vote}_{y,x}(z, G_t^v) = +1 \\right\\}</span>.</li>

    </ul>

    <p class="text-gray-300">Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) ^ {\\complement}\\right) \\leq \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (d \\cdot \\lambda , h) \\cdot \\tag {24}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m}. \\tag {25}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - h - l - m) ^ {+}}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let $k_1 \\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t - d, t]}^{oracle} \\cap honest \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and let </span>m := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(z_{early}, G_t^{oracle}) \\setminus future_a(z_{late}, G_t^v) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We adjust the analysis from the proof of Lemma 14. We claim that for all </span>z \\in \\overline{anticone_h}(x, G_t^v)$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v o t e _ {x, y} \\left(z, G _ {s} ^ {u}\\right) \\leq \\overline {{s g n}} \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, s ]} ^ {u} \\cap m a l i c i o u s \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, s ]} ^ {u} \\cap h o n e s t \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. l + k _ {1} + m - g\\right). \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We prove the claim by a complete induction on $D(z) \\coloneqq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(z, \\overline{\\text{anticone}_h}(x)\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Assume we have proved the claim for any </span>z<span class="math"> with </span>D(z) &lt; D<span class="math">. We now prove it for </span>z<span class="math"> with </span>D(z) = D<span class="math">. If </span>z = x<span class="math"> then </span>\\text{vote}_{x,y}(z, G_s^u) = -1<span class="math"> hence the above inequality is satisfied trivially. Otherwise, </span>z<span class="math"> is a weak voter, as </span>y \\notin \\overline{past}(z)<span class="math"> by the assumption on publication(y), therefore </span>\\text{vote}_{x,y}(z, G_s^u)<span class="math"> is given by the sign of the sum of votes in its future. We decompose these voters into three subsets: members of future </span>(z, G_{time(z_{late})}^u)<span class="math">, members of future </span>(z, G_{[time(z_{late}), t]}^u)<span class="math">, and members of future </span>(z, G_{[t, s]}^u)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Members of future <span class="math">\\left(z, G_{time(z_{late})}^{u}\\right)</span>: By the induction hypothesis we know that all blocks in future_h <span class="math">\\left(z, \\overline{anticone_h}(z_{late})\\right)</span> vote in favour of <span class="math">x \\prec y</span>, hence We obtain:</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_ {z ^ {\\prime} \\in f u t u r e \\left(z, G _ {t i m e (z l a t e)} ^ {u}\\right)} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) \\leq \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {h} \\left(z, G _ {t i m e (z _ {l a t e})} ^ {u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {a} \\left(z, G _ {t i m e (z _ {l a t e})} ^ {u}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Members of <span class="math">future\\left(z,G_{[time(z_{late}),t]}^{u}\\right)</span>: Every <span class="math">z^{\\prime}</span> in this set belongs to <span class="math">future(x^{\\prime})</span> for some <span class="math">x^{\\prime}\\in \\overline{anticone_{h}} (x,G_{t}^{v})</span>, therefore, by the definition of <span class="math">g</span>:</li>

    </ol>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_ {z ^ {\\prime} \\in f u t u r e \\left(z, G _ {[ t i m e (z l a t e), t ]} ^ {u}\\right)} v o t e _ {x, y} \\left(z ^ {\\prime}, G _ {s} ^ {u}\\right) \\leq \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- g + \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {a} \\left(z _ {e a r l y}, G _ {t} ^ {o r a c l e}\\right) \\backslash f u t u r e _ {a} \\left(z _ {l a t e}, G _ {t} ^ {v}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- g + \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">f u t u r e _ {a} \\left(z _ {e a r l y}, G _ {t} ^ {o r a c l e}\\right) \\backslash f u t u r e _ {a} \\left(z _ {l a t e}, G _ {t} ^ {v}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">G _ {[ t - d, t ]} ^ {o r a c l e} \\cap h o n e s t \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">= \\\\</td>

          </tr>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>g + m + k _ {1}.</li>

    </ul>

    <p class="text-gray-300">\\end{array} $$</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Members of <span class="math">future\\left(z,G_{[t,s]}^{u}\\right)</span>: By the choice of <span class="math">s</span>, all honest blocks created between <span class="math">t</span> and</li>

    </ol>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300"><span class="math">s</span> vote in favour of <span class="math">x \\prec y</span>, hence</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\sum_{z' \\in \\text{future}\\left(z, G_{[t,s]}^u\\right)} \\text{vote}_{x,y}\\left(z', G_s^u\\right) \\leq \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\quad - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z, G_{[t,s]}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z, G_{[t,s]}^u\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <p class="text-gray-300">where we used the fact that <span class="math">t \\geq \\text{publication}(x) + d \\geq \\text{publication}(z) + d</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All in all,</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\sum_{z&#x27; \\in \\text{future}(z, G_s^u)} \\text{vote}_{x,y}\\left(z&#x27;, G_s^u\\right) \\leq \\tag{27}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l + k_1 + m - g - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{honest} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^u \\cap \\text{malicious} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\tag{28}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">l + k_1 + m - g - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z_{\\text{late}}, G_{[t,\\max\\{s-d,t\\}]}^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_{[t,s]}^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\tag{29}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Therefore, the event where for some <span class="math">s</span> and some <span class="math">u</span>, <span class="math">\\text{vote}_{x,y}(\\text{virtual}(G_s^u)) \\geq 0</span> is contained in the event where (29) is non-negative. As in the proof of Lemma 15, the probability of the latter event is upper bounded by <span class="math">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(l + k_1 + h&#x27; + m - g)^+}</span>, where <span class="math">h&#x27;</span> equals $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(x, G_{[s',s]}^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We then combine </span>k_1<span class="math"> and </span>h'<span class="math"> into one Poisson variable </span>h<span class="math"> with parameter </span>\\alpha \\cdot d \\cdot \\lambda + (1 - \\alpha) \\cdot d \\cdot \\lambda = d \\cdot \\lambda$, to obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left(\\widehat{\\mathcal{E}}_{t \\rightarrow \\infty}^{all}(x, y)^{\\complement}\\right) \\leq \\sum_{h=0}^{\\infty} \\mathcal{P}_{\\text{oiss}}(d \\cdot \\lambda, h) \\cdot \\tag{30}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\tag{31}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}.</span></div>

    <p class="text-gray-300">Corollary 22. If in addition to Lemma 21's assumptions we know that publication <span class="math">(y) \\geq t</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr\\left(\\widehat{\\mathcal{E}}_{t \\rightarrow \\infty}^{all}(x, y)^{\\complement}\\right) \\leq \\sum_{h=0}^{\\infty} \\mathcal{P}_{\\text{oiss}}(d \\cdot \\alpha \\cdot \\lambda, h) \\cdot \\tag{32}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{m=0}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\tag{33}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - h - l - m)^+}.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Given that <span class="math">y</span> wasn't published until time <span class="math">t</span>, we know that all honest blocks in <span class="math">future\\left(x, G_{[t - d,t]}^{oracle}\\right)</span> vote in favour of <span class="math">x</span>, hence the reduction of $k_{1} = \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t - d,t]}^{oracle} \\cap honest\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> in (26) is superfluous, and we thus only need to reduce </span>h'<span class="math">, the Poisson variable with parameter </span>d \\cdot \\alpha \\cdot \\lambda$ from Lemma 15.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Corollary 23. Let <span class="math">X \\subseteq G_t^v \\cap \\text{honest}</span> and <span class="math">Y \\subseteq G_t^{\\text{oracle}} \\setminus G_t^v</span>. Assume further that elements in <span class="math">X</span> do not relate topologically to one another (i.e., <span class="math">\\forall x_1, x_2 \\in X, x_1 \\in \\text{anticone}(x_2, G_t^v)</span>). Let <span class="math">z_{\\text{late}}</span> be the latest block in <span class="math">X</span>, let <span class="math">z_{\\text{early}}</span> be the earliest block in <span class="math">X</span>.</p>

    <p class="text-gray-300">Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) ^ {\\mathbb {C}}\\right) \\leq \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} ((3 - 2 \\cdot \\alpha) \\cdot d \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m} \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(n _ {x} - h - l - m) ^ {+}}.</span></div>

    <p class="text-gray-300">Proof. We adjust the result of Lemma 21. The main modification is that now <span class="math">g</span> must relate to all pairs <span class="math">(x, y)</span>. Define: <span class="math">g := \\max_{x_1, x_2 \\in X} \\{z \\in \\overline{future}(x_1, G_t^v) : \\text{vote}_{y,x_2}(z, G_t^v) = -1\\} - \\min_{x_1, x_2 \\in X} \\{z \\in \\overline{future}(x_1, G_t^v) : \\text{vote}_{y,x_2}(z, G_t^v) = +1\\}</span>. Observe that in the interval <span class="math">[time(z_{early}) + 2 \\cdot d, t]</span> all honest blocks belong to <span class="math">\\cap_{x \\in X} \\overline{future}(x, G_t^v)</span>. In particular, if we denote <span class="math">h&#x27; := n_x - g</span> we have that <span class="math">h&#x27;</span> is upper bounded by a Poisson variable with parameter <span class="math">2 \\cdot d \\cdot \\lambda</span>. We then apply the analysis done in the proof of Lemma 21, with <span class="math">s</span> being the first time at which for some <span class="math">(x, y) \\in X \\times Y</span>, <span class="math">\\text{vote}_{x,y}(\\text{virtual}(G_s^u)) \\geq 0</span>. Combining the result of that lemma with the probability distribution over <span class="math">h&#x27;</span> we conclude that the probability of the event <span class="math">\\cup_{(x,y) \\in X \\times Y} \\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)</span> is at most</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) ^ {\\mathbb {C}}\\right) \\leq \\sum_ {h ^ {\\prime} = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (2 \\cdot d \\cdot (1 - \\alpha) \\cdot \\lambda , h ^ {\\prime}) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (d \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m} \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(n _ {x} - h ^ {\\prime} - h - l - m) ^ {+}} =</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} ((3 - 2 \\cdot \\alpha) \\cdot d \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m} \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(n _ {x} - h - l - m) ^ {+}}.</span></div>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">47</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 17. If in addition to the assumptions of Corollary 16 we assume that $M \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(x, G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, then</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) \\mid</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f u t u r e _ {a} (x, G _ {t} ^ {v})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq M\\right) \\leq \\tag {34}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {k = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} ((2 - \\alpha) \\cdot d \\cdot \\lambda , k) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} (d \\cdot (1 - \\alpha) \\cdot \\lambda , h) \\cdot \\tag {35}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_ {m ^ {\\prime} = M} ^ {\\infty} \\binom {n _ {x} + j + h + m ^ {\\prime} - 1} {m ^ {\\prime}} \\cdot (1 - \\alpha) ^ {n _ {x} + j + h} \\cdot \\alpha^ {m ^ {\\prime}}\\right) ^ {- 1}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = M} ^ {\\infty} \\binom {n _ {x} + j + h + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x} + j + h} \\cdot \\alpha^ {m}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - 2 \\cdot h - k - j - l - (m - M)) ^ {+}}</span></div>

    <p class="text-gray-300">We denote the RHS of this inequality by <span class="math">f_{post\\_mine}(n_x, g, j, l, M)</span>. We note that from Lemmas 25, 32, and 30 it follows that, in order to compute <span class="math">f_{post\\_mine}</span>, one can truncate these sums and suffer an exponentially low error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Under the assumption on <span class="math">M</span> we have $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\setminus \\text{future}_a\\left(x, G_t^v\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(x, G_t^v\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{\\text{late}}, G_t^{\\text{oracle}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We then adjust the result of Corollary 16 and adjust (4) to account for the above updated definition of <span class="math">m</span>. Thus, in the exponent, we substitute <span class="math">m - M</span> for <span class="math">m</span> and write: <span class="math">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - 2\\cdot h - j - k - l - (m - M))^+}</span>. Next, the updated probability distribution over <span class="math">m - M</span> can be obtained by conditioning the negative binomial distribution (described in the proof of Corollary 16) on its being larger than or equal to <span class="math">M</span>; indeed, the <span class="math">M</span> blocks of <span class="math">future_{a}(x,G_{t}^{v})</span> were created after <span class="math">z_{late}</span> (and before time <span class="math">t</span>), and <span class="math">future_{a}(x,G_{t}^{v}) \\subseteq future_{a}(z_{late},G_{t}^{oracle})</span>. Consequently, the probability distribution over <span class="math">m - M</span> is given by</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(m - M\\right) = \\left(\\sum_ {m ^ {\\prime} = M} ^ {\\infty} \\binom {n _ {x} + j + h + m ^ {\\prime} - 1} {m ^ {\\prime}} \\cdot (1 - \\alpha) ^ {n _ {x} + j + h} \\cdot \\alpha^ {m ^ {\\prime}}\\right) ^ {- 1}.</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left( \\begin{array}{c} n _ {x} + j + h + m - 1 \\\\ m \\end{array} \\right) \\cdot (1 - \\alpha) ^ {n _ {x} + j + h} \\cdot \\alpha^ {m},</span></div>

    <p class="text-gray-300">and we arrive at the desired term. The rest of the arguments in the proof of Corollary 16 remain unaffected.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Numerical method to calculate <span class="math">f_{pre\\_mine}</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Put <span class="math">\\delta \\coloneqq \\alpha \\cdot \\lambda \\cdot d</span>. Pick some <span class="math">N \\gg 1</span>, and define a matrix <span class="math">T \\in \\mathbb{R}_{N \\times N}</span> as follows. For all <span class="math">1 \\leq l &amp;lt; N - 1</span>, <span class="math">T_{l - 1,l} = 1 - \\alpha</span>, <span class="math">T_{l + 1,l} = \\alpha</span>, and for <span class="math">l = N - 1</span>: <span class="math">T_{l - 1,l} = 1 - \\alpha</span>, <span class="math">T_{l,l} = \\alpha</span>.</li>

    </ul>

    <p class="text-gray-300">15 By Lemma 25, to achieve an error of at most <span class="math">\\widehat{\\epsilon}</span> it suffices to choose <span class="math">N</span> such that <span class="math">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{N - 1} &amp;lt; \\widehat{\\epsilon} / 2</span> and <span class="math">e^{-d \\cdot \\alpha \\cdot \\lambda} \\cdot \\frac{(d \\cdot \\alpha \\cdot \\lambda)^N}{N!} &amp;lt; \\widehat{\\epsilon} / 2</span>. In particular, <span class="math">N</span> is logarithmic in <span class="math">\\widehat{\\epsilon}</span>.</p>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">The first column of the matrix is defined by: <span class="math">T_{0,0} := (1 - \\alpha) \\cdot e^{-\\delta}</span>, <span class="math">T_{1,0} = e^{-\\delta} \\cdot \\alpha + e^{-\\delta} \\cdot \\delta</span>, for <span class="math">1 &amp;lt; l &amp;lt; N - 1</span>: <span class="math">T_{l,0} = e^{-\\delta} \\cdot \\frac{\\delta^l}{l!}</span>, and for <span class="math">l = N - 1</span>: <span class="math">T_{l,0} = 1 - \\sum_{l=0}^{N-2} e^{-\\delta} \\cdot \\frac{\\delta^l}{l!}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find the eigenvector of <span class="math">T</span> corresponding to the eigenvalue 1, and denote it <span class="math">\\pi</span>. Define <span class="math">\\Pi(l) := \\sum_{l&#x27;=0}^{l} \\pi(l&#x27;)</span>, and, finally, define <span class="math">f_{pre\\_mine}(l) := 1 - \\Pi((l - 1)^+)</span>.</li>

    </ul>

    <p class="text-gray-300">The matrix <span class="math">T</span> is the transition probability matrix of a special reflecting random walk <span class="math">(X_{k})</span> over the nonnegative integers: <span class="math">T_{i,j} := \\operatorname{Pr}(X_{k+1} = i \\mid X_{k} = j)</span>. At every position (apart from the edges 0 and <span class="math">N-1</span>) the walk takes a step towards negative infinity w.p.<span class="math">(1 - \\alpha)</span> and towards positive infinity w.p.<span class="math">\\alpha</span>. Whenever it reaches the origin, it jumps to its next position in <span class="math">\\{0,1,\\dots,N-1\\}</span> according to a (modified) Poisson distribution. It is easy to see that this random walk induces an ergodic Markov chain, hence it has a unique stationary distribution, which we denoted <span class="math">\\pi</span>; <span class="math">\\Pi</span> is the cumulative probability function of <span class="math">\\pi</span>.</p>

    <p class="text-gray-300"><strong>Lemma 24.</strong> For all <span class="math">\\hat{r} \\geq r</span> and for all for all <span class="math">l \\in \\mathbb{N}</span>:</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\max_{z \\in G_r^{oracle} \\cap honest} \\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a (z, G_r^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\left. f_{pre\\_mine}(l). \\right. \\tag{36} \\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> <strong>Part I:</strong> We prove the result assuming the maximum is taken over all <span class="math">z \\in G_r^{oracle} \\cap honest</span>; taking then the maximum over all <span class="math">z \\in G_r^{oracle} \\cap honest</span> does not change the result, because the variable $\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a (z, G_r^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h (z, G_r^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math"> is nonnegative (as will be shown below), and its value for </span>z \\in G_r^{oracle} \\setminus G_r^{oracle}i$ is zero.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We show that the variable $\\max_{z \\in G_r^{oracle} \\cap honest} \\left\\{ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a (z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h (z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math"> can be modeled as a reflecting random walk (with some special behaviour when the walk visits the origin, due to the honest network&#x27;s inner delay </span>d$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Intuitively, observe that whenever a new honest block <span class="math">b</span> is created, <span class="math">future_h\\left(z,G_{time(b)}^{oracle}\\right)</span> increases by 1 for all <span class="math">z</span>'s in its past. For <span class="math">b</span> itself, the value of this variable is 0. Thus, the value of <span class="math">\\max_{z\\in G_r^{oracle}\\cap honest}\\left\\{future_a(z,G_s^{oracle}) - future_h(z,G_s^{oracle})\\right\\}</span> is lower bounded by 0. On the other hand, whenever a new attack block is created, the value of <span class="math">future_a(z,G_s^{oracle})</span> increases by 1 for all honest blocks available to it at the time (following the worst case assumptions specified in Lemma 14, Part I). Therefore, the attacker's maximal advance over the honest network can be modeled as a reflecting random walk. Note that, since the creation of an honest block <span class="math">b</span> increases <span class="math">future_h(z,G_s^{oracle})</span> only for blocks in <span class="math">past_h(b)</span>, which might be a proper subset of <span class="math">before(time(b))</span> (when <span class="math">d &amp;gt; 0</span>), there are certain situations where honest blocks do not "work against" attack blocks to decrease the value of $\\max \\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(z,G_s^{oracle})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(z,G_s^{oracle})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}$. We take this into account by skewing the behaviour of the walk whenever the origin is visited (and proving that in all other states the honest network's inner delay has no effect).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the following analysis, we assume the worst case scenario, namely, that if <span class="math">z_{1}</span> and <span class="math">z_{2}</span> are honest blocks such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">time(z_{1}) - time(z_{2})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; d<span class="math"> then </span>z_{1} \\in \\text{anticone}(z_{2})$. That this is a worst case follows simply from the fact that omitting some edges between honest blocks</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">49</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">can only decrease <span class="math">future_h(z,G_s^{oracle})</span> hence increase the value of $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(z,G_s^{oracle})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(z,G_s^{oracle})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the attacker is creating blocks in secret, it needs to decide upon a strategy regarding which blocks should its new block point at, for every new block it creates. Consider the following strategy: The attacker's new block <span class="math">b</span>, created at <span class="math">time(b)</span>, points at <span class="math">G_{time(b)}^{oracle}</span> (except itself, of course). While we have already argued why this is a worst case assumption (Lemma 14, Part I), it is here easy to see that this strategy maximizes $\\max_{z\\in G_s^{oracle}\\cap honest}\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(z,G_s^{oracle})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(z,G_s^{oracle})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part II:</strong> Denote by <span class="math">t_i</span> the creation time of the <span class="math">i</span>th block in <span class="math">G_r^{oracle}</span>. Denote by <span class="math">z_s</span> the variable $\\arg \\max_{z \\in G_r^{oracle} \\cap honest} \\left\\{ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a(z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math">. Define further </span>A_s^z := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a(z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>H_s^z := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(z, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Abbreviate </span>A_s := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a(z_s, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and </span>H_s := \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(z_s, G_s^{oracle}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define a subseries <span class="math">(s_k) \\subseteq (t_i)</span> recursively: <span class="math">s_0 = 0</span>, and for all <span class="math">k &amp;gt; 0</span>: <span class="math">s_{k+1} = \\min_i \\{ t_i : t_i \\geq time(z_{s_k}) + d \\}</span>. We claim that <span class="math">(A_{s_k} - H_{s_k})</span> has the same probability distribution as <span class="math">X_k</span>. Assume this claim holds true, and let <span class="math">s_k</span> be the earliest <span class="math">s_k</span> with <span class="math">s_k \\geq r</span>. Then <span class="math">(A_r - H_r) \\leq 1 + (A_{s_k} - H_{s_k})</span>.¹⁶ Consequently,</p>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\max_{z \\in G_r^u \\cap honest} \\left\\{ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a(z, G_r^u) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\right. \\right. \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\Pr \\left(A_r - H_r &gt; l\\right) \\leq \\Pr \\left(A_{s_k} - H_{s_k} &gt; l - 1\\right) = \\\\ \\Pr \\left(X_k &gt; l - 1\\right) = 1 - \\Pi \\left((l - 1)^+\\right). \\end{array} $$</p>

    <p class="text-gray-300"><strong>Part III:</strong> To complete the proof we prove our claim, by induction on <span class="math">k</span>. For <span class="math">k = 0</span>, <span class="math">s_0 = 0</span>. At time 0, following the creation of the genesis block, the value of <span class="math">(A_0 - H_0)</span> is 0, as <span class="math">future(genesis) \\cap G_0^{oracle} = \\emptyset</span>, and likewise <span class="math">X_0 = 0</span>. Assume we have proved this for <span class="math">k</span>, and we now prove it for <span class="math">k + 1</span>. Assume first that <span class="math">(A_{s_k} - H_{s_k}) &amp;gt; 0</span>. Assume by way of negation that <span class="math">s_k &amp;lt; time(z_{s_k}) + d</span>. Then, by the construction of <span class="math">(s_k)</span>, <span class="math">s_k = time(z_{s_k})</span>. This implies that the honest network created <span class="math">z_{s_k}</span> in time <span class="math">s_k</span>. Thus <span class="math">(A_{s_k} - H_{s_k}) = 0</span>, because <span class="math">z_{s_k}</span> was created at time <span class="math">s_k</span>. As <span class="math">z_{s_k}</span> is supposed to be in <span class="math">\\arg \\max_{z \\in G_r^{oracle} \\cap honest} \\{A_{s_k} - H_{s_k}\\}</span>, this contradicts our assumption that <span class="math">A_{s_k} - H_{s_k} &amp;gt; 0</span>. Thus, <span class="math">(A_{s_k}^z - H_{s_k}^z) &amp;gt; 0</span> implies <span class="math">s_k \\geq time(z_{s_k}) + d</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consequently, if <span class="math">(A_{s_k} - H_{s_k}) &amp;gt; 0</span>, we are guaranteed that the entire honest network has learnt about the block <span class="math">z_{s_k}</span>. Thence, the honest network adds blocks to <span class="math">future(z_{s_k})</span> at a rate of <span class="math">(1 - \\alpha \\cdot \\lambda)</span>, while the attacker adds them at a rate of <span class="math">\\alpha</span>. Every block of the honest network then contributes 1 to $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(z,G_s^{oracle})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, whereas an attacker block contributes 1 to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a(z,G_s^{oracle})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, </span>(A_{s_k} - H_{s_k})<span class="math"> increases by 1 by the addition of an attacker&#x27;s block, that is, w.p. </span>\\alpha<span class="math">, and decreases by 1 w.p. </span>(1 - \\alpha)<span class="math">. Indeed, conditioned on </span>X_k &gt; 0<span class="math">, </span>X_{k+1}<span class="math">&#x27;s distribution behaves the same: </span>\\operatorname{Pr}(X_{k+1} = X_k + 1 \\mid X_k &gt; 0) = 1 - \\operatorname{Pr}(X_{k+1} = X_k - 1 \\mid X_k &gt; 0) = \\alpha$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">¹⁶ Indeed, if <span class="math">r = s_k</span> then this holds trivially. Otherwise, in the interval <span class="math">(r, s_k)</span> the honest network could have contributed at most one block to <span class="math">future(z_{s_{k-1}})</span>, because <span class="math">(X_i)</span> can decrease by at most 1 at every step, according to its transition matrix, thus in the interval <span class="math">(r, s_k) \\subseteq (s_{k-1}, s_k)</span> the honest network created at most 1 block.</p>

    <p class="text-gray-300">Assume now that <span class="math">(A_{s_k} - H_{s_k}) = 0</span>. It cannot be the case that the block that was created in time <span class="math">s_k</span> belongs to the attacker, since that would imply that the attacker has an advantage of at least 1 over the last block that was created by the honest network (up to time <span class="math">s_k</span>). Therefore, it belongs to the honest network. By the definition of <span class="math">z_{s_k}</span>, it is precisely the block that was created in time <span class="math">s_k</span>. Consequently, in the interval <span class="math">(s_k, s_k + d)</span>, the honest network does not add blocks to <span class="math">future(z_{s_k})</span> (recall we are assuming that the worst case scenario is realized, i.e., a propagation time of <span class="math">d</span> seconds per honest block). During this interval, the attacker creates blocks at following a Poisson process with parameter <span class="math">\\alpha \\cdot \\lambda</span>. Thus, <span class="math">\\left(A_{s_k + d}^{z_{s_k}} - H_{s_k + d}^{z_{s_k}}\\right) = i</span> w.p. <span class="math">\\mathcal{P}_{oiss}(\\alpha \\cdot \\lambda \\cdot d, i)</span>. Upon which, the next block in the system, created after <span class="math">s_k + d</span>, is the attacker's w.p. <span class="math">\\alpha</span>, in case which the total gap increases by <span class="math">j + 1</span>, i.e., <span class="math">\\left(A_{s_{k + 1}}^{z_{s_{k + 1}}} - H_{s_{k + 1}}^{z_{s_{k + 1}}}\\right) = \\left(A_{s_k + d}^{z_{s_k}} - H_{s_k + d}^{z_{s_k}}\\right) + 1</span>; alternatively, the next block after <span class="math">s_k + d</span> is the honest network's, w.p. <span class="math">(1 - \\alpha)</span>, in case which <span class="math">\\left(A_{s_{k + 1}}^{z_{s_{k + 1}}} - H_{s_{k + 1}}^{z_{s_{k + 1}}}\\right) = \\max \\left\\{\\left(A_{s_k + d}^{z_{s_k}} - H_{s_k + d}^{z_{s_k}}\\right) - 1, 0\\right\\}</span>. By comparing this to <span class="math">\\operatorname{Pr}(X_{k + 1} \\mid X_k = 0)</span>, we see that also in this case the variable <span class="math">X_{k + 1}</span> behaves the same as <span class="math">\\left(A_{s_{k + 1}}^{z_{s_{k + 1}}} - H_{s_{k + 1}}^{z_{s_{k + 1}}}\\right)</span>.</p>

    <p class="text-gray-300"><strong>Lemma 25.</strong> <span class="math">f_{pre\\_mine}(l) \\leq C_l \\cdot e^{-B_l \\cdot future_a(x, G_l^c)}</span> for some positive constants <span class="math">B_l, C_l</span>.</p>

    <p class="text-gray-300">To get the intuition of this result, notice that when <span class="math">d = 0</span> the stationary distribution of the reflecting random walk is known to be proportionate to <span class="math">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^l</span>, and if <span class="math">d &amp;gt; 0</span>, this relation still holds for <span class="math">l \\gg d \\cdot \\lambda</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> For <span class="math">n &amp;gt; 1</span>, the stationary distribution <span class="math">\\pi</span> satisfies the relation <span class="math">\\pi(n) = (1 - \\alpha) \\cdot \\pi(n + 1) + \\alpha \\cdot \\pi(n - 1) + e^{-\\delta} \\cdot \\frac{\\delta^n}{n!} \\cdot \\pi(0)</span>. Let us write <span class="math">\\pi(n) = C_n \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^n</span> for <span class="math">n \\geq 0</span>. We have:</p>

    <div class="my-4 text-center"><span class="math-block">C_n \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^n = (1 - \\alpha) \\cdot C_{n + 1} \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{n + 1} + \\tag{37}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\alpha \\cdot C_{n - 1} \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{n - 1} + e^{-\\delta} \\cdot \\frac{\\delta^n}{n!} \\cdot \\pi(0) \\Longrightarrow \\tag{38}</span></div>

    <div class="my-4 text-center"><span class="math-block">C_n = C_{n + 1} \\cdot \\alpha + C_{n - 1} \\cdot (1 - \\alpha)^{-1} + e^{-\\delta} \\cdot \\frac{\\left(\\delta \\cdot \\frac{(1 - \\alpha)}{\\alpha}\\right)^n}{n!} \\cdot \\pi(0). \\tag{39}</span></div>

    <p class="text-gray-300">For large enough <span class="math">n</span>'s, the last summand in the above expression is negligible. Thus, when we write <span class="math">\\forall n: C_n \\approx C</span>, the above relation will be satisfied for large <span class="math">n</span>'s (up to the negligible error of the last summand). Thus, for some constant <span class="math">C</span>, <span class="math">\\pi(n) \\leq C \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^n</span>, hence <span class="math">1 - \\Pi((n - 1)^+) = \\sum_{k=n}^{\\infty} \\pi(k) \\leq B_l \\cdot e^{-C_l \\cdot n}</span>, for some large enough <span class="math">n</span>, and some constants <span class="math">B_l, C_l &amp;gt; 0</span>.</p>

    <p class="text-gray-300">The following Corollary is immediate from Lemma 24.</p>

    <p class="text-gray-300">Corollary 26. In Lemma 21, if <span class="math">l</span> is not known, then</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {\\text {a l l}} (x, y) ^ {\\complement}\\right) \\leq \\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} (d \\cdot \\lambda , h) \\cdot \\tag {40}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m}. \\tag {41}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - h - l - m) ^ {+}}.</span></div>

    <p class="text-gray-300">Similarly, in Corollary 22,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {\\text {a l l}} (x, y) ^ {\\complement}\\right) \\leq \\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} (d \\cdot \\alpha \\lambda , h) \\cdot \\tag {42}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m}. \\tag {43}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - h - l - m) ^ {+}}. \\tag {44}</span></div>

    <p class="text-gray-300">Finally, in Corollary 23,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) ^ {\\complement}\\right) \\leq \\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} ((3 - 2 \\cdot \\alpha) \\cdot d \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m} \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(n _ {x} - h - l - m) ^ {+}}.</span></div>

    <p class="text-gray-300">Using this corollary we can prove the bound that is used by the online policy described in Algorithm 7. Denote:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {r i s k} _ {-} \\operatorname {h i d d e n} (T, g) := \\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {m = 0} ^ {\\infty} \\mathcal {P} _ {\\text {o i s s}} ((T + 2 \\cdot d) \\cdot \\alpha \\cdot \\lambda) \\cdot \\tag {45}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - l - m) ^ {+}} \\tag {46}</span></div>

    <p class="text-gray-300">Corollary 27. If Algorithm 7 returns a value less than <span class="math">\\epsilon</span> then <span class="math">\\operatorname*{Pr}\\left(\\cup_{y\\in G_{\\infty}^{\\mathrm{risk}}\\backslash G_t^{y\\sim k}}\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)^{\\complement}\\right) &amp;lt; \\epsilon.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. First, observe that the variable <span class="math">g</span> used in Corollary 22 could be replaced (here and in that corollary) with $\\min_{x' \\in \\overline{anticone}_h(x, G_t^v)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x', G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, because all blocks in </span>future(x, G_t^v)<span class="math"> vote in favour of </span>x<span class="math">, by the assumption on </span>y<span class="math">. The value assigned to </span>g<span class="math">, in line 5 of Algorithm 7, is upper bounded by </span>\\min_{x' \\in \\overline{anticone}(x, G_x)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x', G_x)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, because </span>G_x<span class="math"> includes all honest blocks in </span>G_t^v<span class="math">. Next, </span>T<span class="math"> is assigned the value time_now - received</span>^v(x) = t - received$^v(x), in line 3. Observe</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">that <span class="math">m</span> is distributed according to <span class="math">\\mathcal{P}_{oiss}(m, (t - time(x)) \\cdot \\alpha \\cdot \\lambda)</span>. As <span class="math">time(x) \\geq received^v(x) + d</span>, we can upper bound this by a Poisson variable with parameter <span class="math">(T + d) \\cdot \\alpha \\cdot \\lambda</span>. We then adjust the result of the second term in Corollary 26; we combine the distributions over <span class="math">h</span> and <span class="math">m</span> (where <span class="math">h</span> is taken from (42), to conclude that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\cup_ {y \\in G _ {\\infty} ^ {p u b} \\backslash G _ {i} ^ {p u b}} \\widehat {\\mathcal {E}} _ {t \\rightarrow \\infty} ^ {a l l} (x, y) ^ {\\complement}\\right) \\leq \\tag {47}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {m = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} ((T + 2 \\cdot d) \\cdot \\alpha \\cdot \\lambda) \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(g - l - m) ^ {+}} = \\tag {48}</span></div>

    <div class="my-4 text-center"><span class="math-block">r i s k \\_ h i d d e n (T, g). \\tag {49}</span></div>

    <p class="text-gray-300">Note that we do not need to apply here a union bound over the different <span class="math">y</span>'s in <span class="math">G_{\\infty}^{pub} \\setminus G_t^{pub}</span>, because our analysis assumes that in the worst case all of the attacker blocks vote strongly in favour of <span class="math">y \\prec x</span>, for all <span class="math">y</span> in this set, and, additionally, all honest blocks in <span class="math">G_t^v</span> will always vote strongly in favour of <span class="math">x \\prec y</span>, for all <span class="math">y</span>'s in this set (as they do not see <span class="math">y</span> in their past). Thus, under our worst case analysis, the event where for some <span class="math">y</span> in <span class="math">G_{\\infty}^{pub} \\setminus G_t^{pub}</span> the attacker manages to reverse the relation <span class="math">x \\prec y</span> is equivalent to the event where it manages to do so for a given <span class="math">y</span>. In conclusion, if Algorithm 7 returned a value less than <span class="math">\\epsilon</span>, we know that <span class="math">\\operatorname*{Pr}\\left(\\cup_{y \\in G_{\\infty}^{pub} \\setminus G_t^{pub}} \\widetilde{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)^{\\complement}\\right) &amp;lt; \\epsilon</span>.</p>

    <p class="text-gray-300">Denote by <span class="math">dist\\_gap(b, G)</span> the minimal <span class="math">k</span> for which <span class="math">gap(b, \\langle G, b, K \\rangle) = 0</span>.</p>

    <p class="text-gray-300"><strong>Lemma 28.</strong> Let <span class="math">b</span> be an honest block. Then,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left(\\cup_ {u \\in h o n e s t, s \\in [ t i m e (b), \\infty)} d i s t \\_ g a p \\left(b, G _ {s} ^ {u}\\right) &amp;gt; K\\right) \\leq \\tag {50}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (d \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {m = 0} ^ {\\infty} \\binom {n _ {x} + m - 1} {m} \\cdot (1 - \\alpha) ^ {n _ {x}} \\cdot \\alpha^ {m}. \\tag {51}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(K - h - l - m) ^ {+}}.</span></div>

    <p class="text-gray-300">We denote the RHS of (50) by <span class="math">f_{distgap}(K)</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By its definition, the event where <span class="math">dist\\_gap(b, G_s^u) &amp;gt; K</span> is equivalent to the event where some block in <span class="math">anticone\\left(b, G_{time(b)}^{node(b)}\\right) \\cup \\left(G_s^u \\setminus G_{time(b)}^{node(b)}\\right)</span> precedes <span class="math">b</span> (or achieves a tie with it) according to <span class="math">vote(virtual(\\langle G_s^u, b, K \\rangle))</span>. In <span class="math">\\langle G_s^u, b, K \\rangle</span>, <span class="math">b</span> has additional <span class="math">K</span> blocks <span class="math">b_1, \\ldots, b_K</span> that vote in favour of it against any other <span class="math">y \\notin \\overline{past}(b)</span>; indeed, for any <span class="math">y \\notin \\overline{past}(b)</span>, <span class="math">y \\notin \\overline{past}(b_i)</span>. Consequently, at <span class="math">G_{time(b)}^{node(b)}</span>, <span class="math">K</span> blocks in <span class="math">future(b)</span> vote in its favour against any block in its anticone. We can thus apply the first part of Corollary 26 with <span class="math">n_x = K</span>, <span class="math">X = \\{b\\}</span>, and <span class="math">Y =</span></p>

    <p class="text-gray-300">¹⁷ Our previous analysis measured <span class="math">m</span> using <span class="math">n_x</span>, as it was structure-based and had no access to <span class="math">T</span>.</p>

    <p class="text-gray-300">53</p>

    <p class="text-gray-300"><span class="math">G_{\\infty}^{oracle} \\setminus \\overline{past}(b)</span> to conclude that (50) is an upper bound on the probability that a block in <span class="math">anticone\\left(b, G_{time(b)}^{node(b)}\\right)</span> will ever precede <span class="math">b</span> (or obtain a tie with it) in the pairwise order of <span class="math">\\langle G_s^u, b, k \\rangle</span> for any <span class="math">s \\geq time(b)</span> in the future.</p>

    <p class="text-gray-300">Lemma 29. For all <span class="math">n_x \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h (x, G_t^v) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; n_x\\right) \\leq \\tag{52}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future} (x, G_t^v) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f_{distgap} \\left(\\sqrt {\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future} (x , G_t^v) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right). \\tag{53}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The RHS of the last inequality is denoted $f_{post\\_pub}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. If <span class="math">y = NULL</span> there is nothing to prove, since then <span class="math">n_x = future(x,G_t^v) \\geq future_h(x,G_t^v)</span>. Assume <span class="math">y \\neq NULL</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Denote $K \\coloneqq \\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. </span>n_x<span class="math"> is obtained in Algorithm 3 by subtracting </span>M<span class="math">, the number of blocks with </span>dist\\_gap &gt; K<span class="math">, from </span>future(x,G_t^v)<span class="math">. Let </span>b<span class="math"> be an honest block in </span>future(x,G)<span class="math">. By Lemma 28, the probability that </span>dist\\_gap(b,G_t^v)<span class="math"> will be larger than </span>K<span class="math"> is at most </span>f_{distgap}(K)<span class="math">. By the union bound, the probability that for some </span>b<span class="math"> in </span>future_h(x,G_t^v)<span class="math">, </span>dist\\_gap(b,G_t^v) &gt; K<span class="math">, is at most </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f_{distgap}(K) \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot f_{distgap}(K) = f_{post\\_pub}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The RHS of Inequality (50) implies:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Lemma 30. $f_{post\\_pub}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\leq C_c \\cdot e^{-B_c \\cdot future_u(x,G_t^v)}<span class="math"> for some positive constants </span>B_c, C_c$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 31. For <span class="math">n_j \\in \\mathbb{N}</span> put <span class="math">j := gap(x, G) + n_j</span>.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h (x, G_t^{\\text{oracle}}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; j \\right\\}\\right) \\leq \\tag{54}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">f_{pre\\_mine} (\\sqrt{n_j}) + \\sum_{h&#x27; = 0}^{\\infty} \\mathcal{P}_{oiss} ((1 - \\alpha) \\cdot \\lambda \\cdot d, h&#x27;) \\cdot \\tag{55}</span></div>

    <div class="my-4 text-center"><span class="math-block">f_{post\\_mine} \\left(n_j, n_j - h&#x27; + 1, \\sqrt{n_j}\\right) \\tag{56}</span></div>

    <p class="text-gray-300">We denote the RHS of this inequality by <span class="math">f_{pre\\_pub}(n_j)</span>. To understand the intuition behind this result, we recall that w.h.p. a block defeats only blocks that were published close to its publication or after it.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Part I: Let <span class="math">t_x := \\text{publication}(x)</span>. Define <span class="math">L_n := \\{z \\in \\text{anticone}_h(x, G_t^v) : \\text{future}_h(z, \\text{anticone}_h(x, G_{t_x}^v)) \\geq n\\}</span>. (Note the use of <span class="math">t_x</span> in this definition). Denote by <span class="math">A_n</span> the event <span class="math">\\{\\exists z \\in L_n : z \\in X_{win}(x, G_t^v)\\}</span>. Finally, let <span class="math">z_e</span> be the earliest block in <span class="math">L_{n&#x27;}^{\\complement} \\cap \\text{anticone}_h(x, G_t^{\\text{oracle}})</span> and put $n' := n_j -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticone}_h(z_e, G_t^{\\text{oracle}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1<span class="math"> for </span>n_j :=$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Denote by </span>X_{win}(x,G)<span class="math"> the set of blocks that </span>x<span class="math"> precedes (or obtains a tie with) in the pairwise order of </span>G<span class="math">&#x27;s virtual vote, and by </span>X_{lose}(x,G)$ the rest of blocks. Then:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; gap(x, G) + n_{j} \\right\\} = \\\\</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left. \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">X_{lose} \\left(x, G_{t}^{pub}\\right) \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; gap(x, G) + n_{j} \\right\\} = \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">X_{win} \\left(x, G_{t}^{pub}\\right) \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ gap(x, G_{t}^{v}) &gt; gap(x, G) + n_{j} \\right\\} = \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">X_{win} \\left(x, G_{t}^{pub}\\right) \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; n_{j} \\right\\} = \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">X_{win} \\left(x, G_{t}^{pub}\\right) \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; n_{j} \\right\\} \\cap A_{n'} \\right) \\cup \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left(\\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">X_{win} \\left(x, G_{t}^{pub}\\right) \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; n_{j} \\right\\} \\cap A_{n'}^{\\complement}\\right) \\subseteq \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A_{n'} \\cup \\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{n'}^{\\complement} \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; n_{j} \\right\\} = \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A_{n'} \\cup \\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{n'}^{\\complement} \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\cap \\overline{anticone_{h}} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">+ \\right. \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">\\left. \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{n'}^{\\complement} \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\cap future_{h} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; n_{j} \\right\\} = \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A_{n'} \\cup \\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{n'}^{\\complement} \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\cap future_{h} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; \\right. \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n_{j} - \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">L_{n'}^{\\complement} \\cap anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\cap \\overline{anticone_{h}} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\right\\} \\subseteq \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">A_{n'} \\cup \\left\\{\\left</td>

            <td class="px-3 py-2 border-b border-gray-700">anticone_{h} \\left(x, G_{t}^{oracle}\\right) \\cap future_{h} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">&gt; \\right. \\\\</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n_{j} - \\left</td>

            <td class="px-3 py-2 border-b border-gray-700">\\overline{anticone_{h}} \\left(z_{e}, G_{t}^{oracle}\\right) \\right</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Bigg\\}.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As <span class="math">z_{e} \\in L_{n&#x27;}</span>, and by the definition of <span class="math">n&#x27;</span>, it cannot be the case that <span class="math">anticone_{h}\\left(x, G_{t}^{oracle}\\right) \\cap future_{h}\\left(z_{e}, G_{t}^{oracle}\\right)</span> contains more than $n_{j} - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{anticone_{h}}\\left(z_{e}, G_{t}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> blocks. Thus, the event </span>\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(x, G_{t}^{oracle}\\right) \\cap future_{h}\\left(z_{e}, G_{t}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; n_{j} - \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{anticone_{h}}\\left(z_{e}, G_{t}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}<span class="math"> occurs w.p. 0, and we obtain: </span>\\operatorname{Pr}\\left(\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(x, G_{t}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; gap(x, G) + n_{j}\\right\\}\\right) \\leq \\operatorname{Pr}\\left(A_{n'}\\right)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Observe that all blocks in <span class="math">future\\left(z,anticone_{h}\\left(x,G_{t_{x}}^{v}\\right)\\right)</span> vote strongly in favour of <span class="math">z</span> against <span class="math">x</span>, for any <span class="math">z\\in L_{n&#x27;}</span>, and that by definition there are at least <span class="math">n&#x27;</span> such votes at time <span class="math">t_x</span>. Consequently, we can apply the result of Corollary 23 with respect to the following parameters: <span class="math">v = pub</span>, <span class="math">t = t_x</span>, <span class="math">X =</span> the leaf-blocks of <span class="math">L_{n&#x27;}</span>, <span class="math">Y = \\{x\\}</span>, <span class="math">g := n&#x27;</span>, <span class="math">n_x := n_j</span>, and $l' = \\max_{z\\in G_{t_x}^{oracle}\\cap honest}\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a\\left(z,G_{t_x}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h\\left(z,G_{t_x}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}$, to obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left(A_{n&#x27;}\\right) = \\Pr \\left(\\exists z \\in L_{n&#x27;}: z \\in X_{win} \\left(x, G_{t}^{v}\\right)\\right) \\leq \\\\ \\Pr \\left(\\exists s &amp;gt; t_{x}, \\exists z \\in L_{n&#x27;}: z \\in X_{win} \\left(x, G_{s}^{v}\\right)\\right) \\leq \\\\ f_{post\\_mine} \\left(n_{j}, n^{\\prime}, l^{\\prime}\\right). \\end{array}</span></div>

    <p class="text-gray-300">55</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As the value of <span class="math">l&#x27;</span> is unknown to us, we use Lemma 24 to conclude that with probability <span class="math">\\geq 1 - f_{pre\\_mine}(l)</span> its value is at most <span class="math">l</span>. Fix <span class="math">l = \\sqrt{n_j}</span>. Similarly, the value of <span class="math">n&#x27;</span> is unknown to us. However, blocks in <span class="math">\\overline{anticone_h}\\left(z_e,G_t^{oracle}\\right)</span> are created in the time interval <span class="math">[time(z_e),time(z_e) + d]</span> (by its choice), hence $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline{anticone_h}\\left(z_e,G_t^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is a Poisson variable with parameter </span>(1 - \\alpha)\\cdot \\lambda \\cdot d$. We thus conclude that:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr \\left(\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticonone}_h \\left(x, G_t^{oracle}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\operatorname {gap} (x, G) + n_j \\right\\}\\right) \\leq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">f_{pre\\_mine}\\left(\\sqrt{n_j}\\right) + \\sum_{h&#x27; = 0}^{\\infty} \\mathcal{P}_{oiss}((1 - \\alpha) \\cdot \\lambda \\cdot d, h&#x27;) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">f_{post\\_mine}\\left(n_j, n_j - h&#x27; + 1, \\sqrt{n_j}\\right) =</span></div>

    <div class="my-4 text-center"><span class="math-block">f_{pre\\_pub}(n_j).</span></div>

    <p class="text-gray-300">It is easy to verify that <span class="math">f_{post\\_mine}\\left(n_j, n_j - h&#x27; + 1, \\sqrt{n_j}\\right)</span> decreases exponentially (we do this in fact in subsequent lemmas). Therefore:</p>

    <p class="text-gray-300"><strong>Lemma 32.</strong> <span class="math">f_{pre\\_pub}(n_j) \\leq C_j \\cdot e^{-B_j \\cdot n_j}</span> for some positive constants <span class="math">B_j, C_j</span>.</p>

    <p class="text-gray-300">In the lemma below, <span class="math">\\text{oracle}^u</span> is a (hypothetical) node such that <span class="math">G_s^{oraclej} := G_s^u \\cup (G_s^{oracle} \\cap \\text{malicious})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 18.</strong> Conditioned on the event <span class="math">\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)</span>, there exists a time <span class="math">\\tau \\in [t,\\infty)</span> such that $\\forall s\\geq \\tau \\colon M(\\text{oracle}^u,s)\\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a\\left(x,G_s^{oracle^u}\\right)\\cap G_{[t,s]}^{oracle}\\setminus V_{x\\prec y}(G_s^{oracle^u})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^<em><span class="math">, for some </span>m^</em><span class="math"> that remains fixed after </span>\\tau<span class="math"> (and with </span>\\mathbb{E}[m^*]<span class="math"> determined by the events up to time </span>t$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Part I: If <span class="math">y \\notin G_s^{oracle^u}</span> then <span class="math">M(\\text{oracle}^u, s) = 0</span> (line 6), <span class="math">V_{x \\prec y}(G_s^{oracle^u}) = future\\left(x, G_s^{oracle^u}\\right)</span>, and the required inequality follows trivially. Assume <span class="math">y \\in G_s^{oracle^u}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">G</span> be any block DAG that equals the past-set of some (possibly virtual) block. Observe that conditioned on <span class="math">\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)</span>, for some constant <span class="math">C_t</span> determined at time <span class="math">t</span>, if $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}\\cap \\text{malicious}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^{oracle^u}\\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; -C_t<span class="math"> then </span>\\text{vote}_{x,y}(\\text{virtual}(G)) = -1<span class="math">. This follows from the proof of Lemma 14: We take the LHS of (17), replace </span>g<span class="math"> by </span>\\sum_{z'\\in \\text{future}(x,G_t)}\\text{vote}_{x,y}(z',G)<span class="math">, and observe that the value of the remaining term </span>2\\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticonone}_h\\left(z_{late},G_{time(z_{late})}^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z,G_{time(z_{late})}^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z,G_{time(z_{late})}^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{anticonone}_h\\left(z_{late},G_{time(z_{late}),time(z_{late}) + d]}^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t - d,t]}^{oracle}\\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h\\left(z_{late},G_t^v\\right)\\setminus \\text{future}_h(x,G_t^v)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a\\left(z_{late},G_t^{oracle^u}\\right)\\setminus \\text{future}_a(x,G_t^v)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is determined by time </span>t<span class="math">, hence we can denote it </span>C_t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">z \\in \\text{future}(x, G_{t,s}^{oracle})</span>. By the conditioning on <span class="math">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)</span>, <span class="math">z \\in \\text{malicious}</span>. Fix the DAG <span class="math">G^z := \\text{past}(z)</span>. The above argument holds in particular for <span class="math">G^z</span>: If $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^z \\cap \\text{malicious}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,s]}^z \\cap \\text{honest}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; -C_t<span class="math"> then </span>\\text{vote}_{x,y}(z) = \\text{vote}_{x,y}(\\text{virtual}(\\text{past}(z))) = -1<span class="math"> (since </span>z$ is a</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">¹⁸ We write here <span class="math">G_{[t,s]}^z</span> for <span class="math">G^z \\cap \\text{before}(s) \\setminus \\text{before}(t)</span>.</p>

    <p class="text-gray-300">56</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">strong voter we do not need to specify the context of its vote). Consequently, if <span class="math"> z \\in G_{t,s}^{oracle} \\setminus V_{x \\prec y}(G_s^{oracle}) </span> then $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,time(z)]}^z \\cap malicious</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,time(z)]}^z \\cap honest</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq -C_t $.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We arrive at the following important implication: If <span class="math"> z \\in future\\left(x, G_s^{oracle} \\setminus V_{x \\prec y}\\right) \\setminus G_s^{oracle} </span> then:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} \\left(z, G _ {s} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} \\left(z, G _ {\\text {time} (z)} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\tag {57}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} \\left(z, G _ {\\text {time} (z)} ^ {\\text {pub}}\\right) \\backslash G _ {t} ^ {\\text {oracle}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\tag {58}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {\\text {time} (z)} ^ {\\text {pub}} \\backslash G _ {t} ^ {\\text {oracle}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\overline {{\\text {past}}} (z) \\backslash G _ {t} ^ {\\text {oracle}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq \\tag {59}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {\\text {time} (z)} ^ {\\text {pub}} \\cap \\text {honest} \\backslash G _ {t} ^ {\\text {oracle}} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- G _ {[ t, \\text {time} (z) ]} ^ {z} \\cap \\text {honest} \\geq \\tag {60}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, \\text {time} (z) ]} ^ {\\text {pub}} \\cap \\text {honest} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- G _ {[ t, \\text {time} (z) ]} ^ {z} \\cap \\text {malicious} - C _ {t}. \\tag {61}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part II:</strong> Let <span class="math"> z_{1},z_{2},\\ldots </span> the order of creation of blocks in <span class="math"> future_{a}\\left(x,G_{s}^{oracle}\\setminus G_{t}^{oracle}\\right)\\setminus V_{x\\prec y}\\left(G_{s}^{oracle}\\right) </span>. Fix <span class="math"> z_{m} </span>, and let <span class="math"> b_{m} </span> be the earliest block in <span class="math"> anticone_{h}\\left(z_{m},future\\left(x,G_{s}^{oracle}\\right)\\right) </span>. With probability <span class="math"> \\mathcal{P}_{oiss}(d\\cdot (1 - \\alpha)\\cdot \\lambda ,h^{\\prime}) </span>, $ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">anticone_{h}\\left(b_{m},G_{\\infty}^{pub}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= h^{\\prime} <span class="math">. By the choice of </span> b_{m} $ together with (57) we obtain:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text {future} _ {h} \\left(b _ {m}, G _ {\\text {time} (z _ {m})} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} _ {h} \\left(z _ {m}, G _ {\\text {time} (z _ {m})} ^ {\\text {pub}}\\right) \\backslash \\operatorname {anticone} _ {h} \\left(b _ {m}, G _ {\\text {time} (z _ {m})} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} _ {h} \\left(z _ {m}, G _ {\\text {time} (z _ {m})} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname {anticone} _ {h} \\left(b _ {m}, G _ {\\text {time} (z _ {m})} ^ {\\text {pub}}\\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, \\text {time} (z _ {m}) ]} ^ {\\text {pub}} \\cap \\text {honest} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, \\text {time} (z _ {m}) ]} ^ {z _ {m}} \\cap \\text {malicious} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- C _ {t} - h ^ {\\prime} =</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t, \\text {time} (z _ {m}) ]} ^ {\\text {pub}} \\cap \\text {honest} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m - C _ {t} - h ^ {\\prime}, \\tag {62}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where we used the fact that <span class="math"> past(b_m) \\cap anticone_h(z_m) = \\emptyset </span>, by the choice of <span class="math"> b_m </span>, and that <span class="math"> anticone_h\\left(z_m,G_{time(z_m)}^{pub}\\right) = antipast_h\\left(z_m,G_{time(z_m)}^{pub}\\right) </span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part III:</strong> Given <span class="math"> m </span>, $ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,time(z_m)]}^{pub} \\cap honest \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is distributed according to a negative binomial distribution: </span> \\Pr \\left( \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[t,time(z_m)]}^{pub} \\cap honest \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= n \\right) = \\binom{n + m - 1}{n} \\cdot (1 - \\alpha)^n \\cdot \\alpha^m <span class="math">. We claim that the probability that the honest block </span> b_m <span class="math"> will ever be preceded by </span> z_m <span class="math"> in the order of </span> virtual\\left(\\langle G_s^{oracle}, z_m, K \\rangle\\right) $ is at most</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {l = 0} ^ {\\infty} \\pi (l) \\cdot \\sum_ {k = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (5 \\cdot d \\cdot (1 - \\alpha) \\cdot \\lambda , k) \\cdot \\sum_ {h = 0} ^ {\\infty} \\mathcal {P} _ {o i s s} (d \\cdot (1 - \\alpha) \\cdot \\lambda , h) \\cdot</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {n = 0} ^ {\\infty} \\binom {n + m - 1} {m} \\cdot (1 - \\alpha) ^ {n} \\cdot \\alpha^ {m} \\cdot \\left(\\frac {\\alpha}{1 - \\alpha}\\right) ^ {(n - m - K - 2 \\cdot h - C _ {t} - k - l) ^ {+}}. \\tag {63}</span></div>

    <p class="text-gray-300">Note that <span class="math"> G^z </span> contains only blocks created up to <span class="math"> time(z) </span>.</p>

    <p class="text-gray-300">57</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This follows from a similar analysis to that made in the proof of Lemma 14 and of Corollary 23. Indeed, at <span class="math">t_{ime}(z_m)</span> there were at least <span class="math">n - m - h&#x27; - C_t</span> blocks in <span class="math">future(b_m) \\setminus \\overline{future}(z_m)</span>, by the above lower bound on $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h \\left( b_m, G_{time(z_m)}^{pub} \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">; and while </span>\\text{future}_a \\left( b_m, G_{time(z_m)}^{pub} \\right) = \\emptyset<span class="math">, as </span>b_m \\notin \\text{past}(z_m)<span class="math">, there are additional </span>K<span class="math"> hypothetical blocks that vote </span>y \\prec x<span class="math">, by the construction of </span>\\langle G_s^{\\text{oracle}^u}, z_m, K \\rangle<span class="math">. Instead of reducing </span>h'<span class="math"> in the exponent (as in the bound given in Corollary 23), we added </span>2 \\cdot d \\cdot (1 - \\alpha) \\cdot \\lambda<span class="math"> to the variable </span>k<span class="math">, as the sum of Poisson variables is a Poisson variable. Finally, we use the result of Lemma 24 to ensure that </span>\\pi(l)<span class="math"> upper bounds the distribution over </span>l$.[20]</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As <span class="math">\\text{dist\\_gap}(G_s^{\\text{oracle}^u}, z_m) \\leq K</span> requires <span class="math">z_m</span> to precede <span class="math">b_m</span> in the order of <span class="math">\\text{virtual}\\left(\\langle G_s^{\\text{oracle}^u}, z_m, K \\rangle\\right)</span>, (63) serves as an upper bound also to the probability that <span class="math">\\text{dist\\_gap}(G_s^{\\text{oracle}^u}, z_m) \\leq K</span>.</p>

    <p class="text-gray-300"><strong>Part IV:</strong> Using Lemma 25 it is easy to verify the existence of constants <span class="math">a, b</span>, and <span class="math">W</span> such that <span class="math">\\operatorname{Pr}(k + l + 2 \\cdot h &amp;gt; W) \\leq e^{-a \\cdot W + b}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Put $K(\\text{oracle}^u, s) = \\sqrt{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}(x, G_s^{\\text{oracle}^u})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. The block </span>z_m<span class="math"> is counted into </span>M(\\text{oracle}^u, s)<span class="math"> in line 9 of Algorithm 3 whenever </span>\\text{dist\\_gap}(G_s^{\\text{oracle}^u}, z_m) &gt; K(\\text{oracle}^u, s)<span class="math">. From (63) we conclude that the probability that </span>z_m<span class="math"> does not increment by 1 the value of </span>M(\\text{oracle}^u, s)$ is upper bounded by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr \\left(\\text{dist\\_gap}(G_s^{\\text{oracle}^u}, z_m) \\leq K(\\text{oracle}^u, s)\\right) \\leq \\quad (64) \\\\ \\sum_{n=0}^{\\infty} \\binom{n+m-1}{m} \\cdot (1 - \\alpha)^n \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n - m - K(\\text{oracle}^u, s) - W - C_t)^+} &amp;lt; \\\\ \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{-W - C_t - K(\\text{oracle}^u, s)} \\cdot \\sum_{n=0}^{\\infty} \\binom{n+m-1}{n} \\cdot (1 - \\alpha)^n \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n - m)^+} = \\quad (65) \\\\ \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{-W - C_t - K(\\text{oracle}^u, s)} \\cdot \\left(\\Pr_{n \\sim Z(m, 1 - \\alpha)} (n &amp;gt; m) + \\Pr_{n \\sim Z(m, \\alpha)} (n \\leq m)\\right), \\quad (66) \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">Z(n,p)</span> denotes a negative binomial random variable.</p>

    <p class="text-gray-300">We now aim at showing that the last term is upper bounded by some <span class="math">e^{-D \\cdot m}</span>. The proof is very similar to that given in Lemma 19 below.</p>

    <p class="text-gray-300"><strong>Part V:</strong> For large enough <span class="math">m</span>'s, a variable distributed according to <span class="math">Z(1 - \\alpha, m)</span> converges to a normal variable with mean <span class="math">m \\cdot \\frac{\\alpha}{1 - \\alpha}</span> and variance <span class="math">m \\cdot \\frac{\\alpha}{(1 - \\alpha)^2}</span>. The second multiplicand in (66)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">^{20}</span> <span class="math">l</span> here represents $\\max_{z \\in G_{time(b_m)}^{oracle} \\cap honest} \\left\\{ \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a \\left( z, G_{time(b_m)}^{oracle^u} \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h \\left( z, G_{time(b_m)}^{oracle^u} \\right) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{21}</span> We rely here on the assumption specified in the proof of Lemma 14 according to which, in the worst case, after time <span class="math">t</span> the attacker publishes all his blocks to all nodes immediately after their creation.</p>

    <p class="text-gray-300">58</p>

    <p class="text-gray-300">thus converges, as <span class="math">m</span> grows, to</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\leq \\frac{m - \\frac{1 - \\alpha}{\\alpha} \\cdot m}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot m}}\\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{m - \\frac{\\alpha}{1 - \\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot m}}\\right) = \\tag{67}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{\\frac{1 - \\alpha}{\\alpha} \\cdot m - m}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot m}}\\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{m - \\frac{\\alpha}{1 - \\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot m}}\\right). \\tag{68}</span></div>

    <p class="text-gray-300">The following inequality is due to Komatu (1955). Let <span class="math">x \\geq 0</span> and let <span class="math">z \\sim \\mathcal{N}(0,1)</span>. Then: <span class="math">\\operatorname*{Pr}(z &amp;gt; x) \\leq \\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x^2 / 2}}{x + \\sqrt{2 + x^2}}</span>. Put <span class="math">x_1 := \\frac{\\frac{1 - 2 \\cdot \\alpha}{1 - \\alpha} \\cdot m}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot m}}</span> and <span class="math">x_2 := \\frac{\\frac{1 - 2 \\cdot \\alpha}{1 - \\alpha} \\cdot m}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot m}}</span>. We obtain an upper bound on (68):</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x_1^2 / 2}}{x_1 + \\sqrt{2 + x_1^2}} + \\frac{1}{\\sqrt{2 \\cdot \\pi}} \\cdot \\frac{2 \\cdot e^{-x_2^2 / 2}}{x_2 + \\sqrt{2 + x_2^2}} \\leq \\tag{69}</span></div>

    <div class="my-4 text-center"><span class="math-block">C_1 \\cdot e^{-x_1^2 / 2} + C_2 \\cdot e^{-x_2^2 / 2} = C_1 \\cdot e^{-D_1 \\cdot m} + C_2 \\cdot e^{-D_2 \\cdot m} \\leq C_3 \\cdot e^{-D_3 \\cdot m} \\tag{70}</span></div>

    <p class="text-gray-300">for some positive constants <span class="math">C_i, D_i</span> that depend on <span class="math">\\alpha</span> (a property which applies to the constants below as well).</p>

    <p class="text-gray-300">When this term is multiplied by <span class="math">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{-W - C_t - K(\\text{oracle}^u, s)}</span> we obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{-W - C_t - K(\\text{oracle}^u, s)} \\cdot C_3 \\cdot e^{-D_3 \\cdot m} \\leq \\tag{71}</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_4 \\cdot e^{-D_3 \\cdot m + D_4 \\cdot K(\\text{oracle}^u, s)} = C_4 \\cdot e^{-D_3 \\cdot m + D_4 \\cdot \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}(x, G_{\\tau}^{\\text{oracle}^u}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}. \\tag{72}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">There exists therefore an <span class="math">M_1</span> such that if $m &gt; \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}(x, G_s^{\\text{oracle}^u}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; M_1<span class="math"> then the last expression is upper bounded by </span>C_5 \\cdot e^{-D_5 \\cdot m}<span class="math"> for some </span>C_5, D_5$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part VI:</strong> After some <span class="math">\\psi</span> (with expected value <span class="math">M_1 / \\lambda</span>), the condition $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}(x, G_s^{\\text{oracle}^u}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq M_1<span class="math"> is satisfied. Put </span>s_m := \\text{time}(z_m)<span class="math"> and assume </span>s_m \\geq \\psi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As $\\sum_{m = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x,G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}}^{\\infty} C_5 \\cdot e^{-D_5 \\cdot m} &lt; \\infty<span class="math">, Fatou’s lemma implies that there exists (a.s.) an </span>m^{*} &gt; \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x,G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> such that for all </span>m \\geq m^{<em>}<span class="math">, </span>\\text{dist\\_gap}(z_m) &gt; K(\\text{oracle}^u, s_m)<span class="math">. The expected waiting time for </span>z_{m^{</em>}}<span class="math"> is finite.²² Define </span>\\tau = \\max \\left\\{\\psi ,\\text{time}(z_{m^{*}})\\right\\}$. Then, for any</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">²² We have $\\operatorname<em>{Pr}(m^{</em>}\\geq r)\\leq \\sum_{m = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x,G_s^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}^r C_5\\cdot e^{-D_5\\cdot m}$. Therefore,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{E} \\left[ m^{*} \\right] \\leq \\sum_{r = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x, G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}^\\infty \\sum_{m = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x, G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}} ^r - 1} C_5 \\cdot e^{-D_5 \\cdot m} =</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sum_{m = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x,G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}}^{\\infty} \\sum_{r = m + 1}^{\\infty} C_5 \\cdot e^{-D_5 \\cdot m} = \\sum_{m = \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x,G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1}}}^{\\infty} C_6 \\cdot e^{-D_6 \\cdot m} \\leq</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C_7 \\cdot e^{-D_7 \\cdot \\sqrt{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}\\left(x, G_{s_m}^{\\text{oracle}^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">59</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s \\geq \\tau: M(oracle^u, s) \\geq \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a \\left(x, G_s^{oracle^u}\\right) \\cap G_{[t, s]}^{oracle} \\setminus V_{x \\prec y}(G_s^{oracle^u}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^*.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Lemma 19. There exists a <span class="math">\\psi \\in [t,\\infty)</span> such that <span class="math">\\operatorname{Pr}\\left(\\mathcal{E}_{t\\to \\infty}^{all}(x,y,\\epsilon)^{\\mathbb{C}}\\mid \\mathcal{E}_t^v (x,y,\\epsilon)\\right) &amp;lt; \\epsilon</span>. Moreover, <span class="math">\\mathbb{E}[\\psi - t] &amp;lt; \\epsilon</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Part I: We show that if all honest blocks vote in favour of <span class="math">x</span> then all error functions converge to zero. Indeed, the event <span class="math">\\mathcal{E}_t^v (x,y,\\epsilon)</span> implies that $f_{pre\\_mine}(l(G_t^v)) + f_{pre\\_pub}(n_j(G_t^v)) + f_{post\\_pub}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) + f_{post\\_mine}(n_x(G_t^v),g(G_t^v),l(G_t^v)) &lt; \\epsilon<span class="math">. By the union bound, and by Lemmas 24, 29, and 31 respectively, the following relations hold with probability </span>\\geq 1 - \\epsilon$:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\max_{z\\in G_t^{oracle}\\cap honest}\\left\\{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_a\\left(z,G_{time(x)}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h\\left(z,G_{time(x)}^{oracle}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right\\} \\leq l(G_t^v)$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- $</td>

            <td class="px-3 py-2 border-b border-gray-700">anticone_h(x,G_t^{oracle})</td>

            <td class="px-3 py-2 border-b border-gray-700">\\leq gap(x,G) + n_j =: j$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Conditioned on these relations, by Corollary 17 the event <span class="math">\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)</span> occurs w.p. <span class="math">\\geq 1 - f_{post\\_mine}(n_x(G_t^v),g(G_t^v),l(G_t^v))</span>. All in all, conditioned on <span class="math">\\mathcal{E}_t^v (x,y,\\epsilon)</span>, the event <span class="math">\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)</span> occurs w.p. <span class="math">\\geq 1 - \\epsilon</span>.</p>

    <p class="text-gray-300">Part II: We proceed to show that, conditioned on <span class="math">\\widehat{\\mathcal{E}}_{t\\to \\infty}^{all}(x,y)</span> and on the above relations, the value of <span class="math">Risk(G_s^u,x,y)</span> goes (almost surely) to 0 as time develops, for all <span class="math">u\\in honest</span>.24</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">That $f_{pre\\_mine}(l(G_s^u)) + f_{pre\\_pub}(n_j(G_s^u)) + f_{post\\_pub}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future(x,G_s^u)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> goes to 0 as </span>s<span class="math"> grows follows immediately from Lemmas 25, 32, and 30. Let </span>\\epsilon_0 &gt; 0<span class="math">. We now prove that after some </span>\\tau<span class="math"> of finite expectation, </span>f_{post\\_mine}(n_x(G_s^u),g(G_s^u),l(G_s^u)) &lt; \\epsilon_0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M(oracle^u, s) + g(oracle^u, s) - n_x(oracle^u, s) \\geq -2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[time(x), t]}^{oracle} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^* \\tag{73}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">m^*</span> is the variable described in Lemma 18. Assume first that <span class="math">malicious \\cap G_s^{oracle} \\subseteq G_s^{oracle^u}</span>. Let us decompose <span class="math">future(x, G_s^{oracle^u})</span> as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Blocks in <span class="math">G_{[time(x), t]}^{oracle}</span>. Clearly, the number of blocks in this set does not grow with <span class="math">s</span>. Their contribution is lower bounded by $-2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[time(x), t]}^{oracle} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Blocks in <span class="math">V_{x \\prec y}(G_s^{oracle^u}) \\setminus G_t^{oracle}</span>: Every <span class="math">z</span> in this set adds <span class="math">(+1)</span> to <span class="math">g(oracle^u, s)</span>. As <span class="math">z</span> cannot decrement the value of <span class="math">M(oracle^u, s) - n_x(oracle^u, s)</span> by more than 1, the contribution of this set is at least 0.</li>

    </ul>

    <p class="text-gray-300">The expected waiting time for <span class="math">z_{m^*}</span> is the last term divided by <span class="math">\\alpha \\cdot \\lambda</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23Note that <span class="math">\\mathbb{E}[m^*]</span> is determined by the events up to time <span class="math">t</span>: take the expected value of the expression in the previous proof, where the distribution over the values of $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G_{s_m}^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> (and of the </span>s_m<span class="math">&#x27;s themselves) is conditioned on </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G_t^{oracle^u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ (for the oracle which maximizes the expected value).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">24In fact, we need to show that <span class="math">\\max \\{Risk(G_s^u,x,y)\\}</span> goes to 0. However, since our analysis below takes the worst case regarding <span class="math">u</span>, namely, that messages from it and to it arrive at a delay of precisely <span class="math">d</span>, these events are equivalent in the worst case, and thus we will relate to <span class="math">u</span> as a fixed honest node.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">25In fact, by the conditioning on the relation $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future_h(x,G_t^v)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n_x<span class="math">, we know that all honest blocks belong to this category, hence we can arrive at a tighter bound: </span>M(oracle^u,s) + g(oracle^u,s) - n_x(oracle^u,s) \\geq -\\left[G_{[time(x),t]}^{oracle} \\cap malicious\\right] - m^*$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">60</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Blocks in <span class="math">G_{s}^{oracle^{u}} \\setminus (V_{x \\prec y}(G_{s}^{oracle^{u}}) \\cup G_{t}^{oracle})</span>: Lemma 18 guarantees that, conditioned on the event <span class="math">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x,y)</span>, at least $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_a(x,G_{s}^{oracle^{u}}) \\cap G_{[t,s]}^{oracle} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^<em><span class="math"> of the blocks that are published after some </span>\\tau<span class="math"> and that do not belong to </span>V_{x \\prec y}(G_{s}^{oracle^{u}})<span class="math"> – hence that add </span>(-1)<span class="math"> to </span>g(\\text{oracle}^u,s)^{26}<span class="math"> – add </span>(+1)<span class="math"> to the value of </span>M(\\text{oracle}^u,s)<span class="math">. In other words, at most </span>m^</em><span class="math"> blocks from the set </span>\\text{future}_a(x,G_{s}^{oracle^{u}}) \\cap G_{[t,s]}^{oracle} \\setminus V_{x \\prec y}(G_{s}^{oracle^{u}})<span class="math"> add </span>(-1)<span class="math"> to </span>g(\\text{oracle}^u,s)<span class="math"> and are not canceled out by a </span>(+1)<span class="math"> increment to the value of </span>M(\\text{oracle}^u,s)<span class="math">. The contribution of this set is therefore lower bounded by </span>-m^*$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Part III</strong>: We now claim that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M \\left(G _ {s} ^ {u}\\right) + g \\left(G _ {s} ^ {u}\\right) - n _ {x} \\left(G _ {s} ^ {u}\\right) \\geq - 2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G _ {[ t i m e (x), t ]} ^ {o r a c l e} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m ^ {*} \\tag {74}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Indeed, let <span class="math">C(z)</span> be the contribution of <span class="math">z</span> to (73) and let <span class="math">c(z)</span> be its contribution to (74). First, <span class="math">C(z) \\geq -2</span>, hence the contribution of all <span class="math">z \\in G_{[time(x),t]}^{oracle}</span> is at least $-2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[time(x),t]}^{oracle}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, as previously.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Assume that <span class="math">z \\in G_{s}^{oracle^{u}} \\setminus G_{t}^{oracle}</span> and that it votes <span class="math">x \\prec y</span>. Then <span class="math">z</span> is not counted into <span class="math">M(\\text{oracle}^{u}, s)</span>, hence its contribution to <span class="math">M(\\text{oracle}^{u}, s) + g(\\text{oracle}^{u}, s) - n_{x}(\\text{oracle}^{u}, s)</span> is <span class="math">0 + 1 - 1 = 0</span>, i.e., <span class="math">c(z) = 0</span>. And for the same argument <span class="math">C(z) = 0</span>.</p>

    <p class="text-gray-300">Assume that <span class="math">z \\in G_{s}^{oracle^{u}} \\setminus G_{t}^{oracle}</span> and that it votes <span class="math">y \\prec x</span>. Then <span class="math">z \\in malicious</span> (by the conditioning on <span class="math">\\widehat{\\mathcal{E}}_{t \\to \\infty}^{all}(x, y)</span>). In the analysis of Lemma 18 we assumed the following worst case: that for any three blocks <span class="math">v, z, w \\in G_{s}^{oracle^{u}}</span>, such that <span class="math">v, z \\in malicious</span> and <span class="math">w \\in honest</span>, <span class="math">v</span> votes strongly for <span class="math">z \\prec w</span>. Under this worst case assumption regarding the votes of attacker blocks, <span class="math">\\text{dist\\_gap}(z, G_{s}^{oracle^{u}}) \\leq \\text{dist\\_gap}(z, G_{s}^{u})</span>, as <span class="math">G_{s}^{oracle^{u}} \\setminus G_{s}^{u}</span> contains only attacker blocks. Thus, if <span class="math">z</span> was counted in <span class="math">M(\\text{oracle}^{u}, s)</span> then it is counted also in <span class="math">M(G_{s}^{u})</span>; in particular, <span class="math">C(z) \\geq c(z)</span>.</p>

    <p class="text-gray-300">Consequently, using the analysis from Lemma 18,</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} - m ^ {*} \\leq \\sum_ {z \\in G _ {s} ^ {\\text {o r a c l e} u} \\backslash G _ {t} ^ {\\text {o r a c l e}}} c (z) \\leq \\\\ \\sum_ {z \\in G _ {s} ^ {o r a c l e u} \\backslash (G _ {t} ^ {o r a c l e} \\cup V _ {x \\prec y} (G _ {s} ^ {o r a c l e u}))} c (z) = \\\\ \\sum_ {z \\in G _ {s} ^ {u} \\backslash (G _ {t} ^ {o r a c l e} \\cup V _ {x \\prec y} (G _ {s} ^ {o r a c l e u}))} c (z) + \\sum_ {z \\in G _ {s} ^ {o r a c l e u} \\backslash (G _ {s} ^ {u} \\cup V _ {x \\prec y} (G _ {s} ^ {o r a c l e u}))} c (z) \\leq \\\\ \\sum_ {z \\in G _ {s} ^ {u} \\backslash (G _ {t} ^ {o r a c l e} \\cup V _ {x \\prec y} (G _ {s} ^ {o r a c l e u}))} c (z) \\leq \\sum_ {z \\in G _ {s} ^ {u} \\backslash (G _ {t} ^ {o r a c l e} \\cup V _ {x \\prec y} (G _ {s} ^ {o r a c l e u}))} C (z). \\\\ \\end{array}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">All in all, $M(G_s^u) + g(G_s^u) - n_x(G_s^u) \\geq -2 \\cdot \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[time(x),t]}^{oracle}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^*$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Part IV</strong>: In the remainder of the proof we occasionally abbreviate <span class="math">n_x(G_s^u)</span> and write simply <span class="math">n_x</span>, and similarly for the rest of the variables, for convenience. Lemmas 25 and 32 imply further</p>

    <p class="text-gray-300">26 They cannot add 0 since only strong voters are counted into these variables.</p>

    <p class="text-gray-300">27 Indeed, therein we only counted honest voters in favour of honest blocks. This could be formalized using pseudo-votes, as in Lemma 20.</p>

    <p class="text-gray-300">that there exist constants <span class="math">a</span>, <span class="math">b</span>, and <span class="math">W</span> such that <span class="math">\\operatorname{Pr}(k + l + 2 \\cdot h + j &amp;gt; W) \\leq e^{-a \\cdot W + b}</span> (as in the proof of the previous lemma, but not necessarily with the same constants). Take <span class="math">W</span> such that <span class="math">e^{-a \\cdot W + b} &amp;lt; \\epsilon_0 / 4</span>. Thus, with probability <span class="math">\\geq 1 - \\epsilon_0 / 4</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f_{\\text{post\\_mine}} \\left(n_x \\left(G_s^u\\right), g \\left(G_s^u\\right), l \\left(G_s^u\\right)\\right) = \\\\ \\sum_{k=0}^{\\infty} \\mathcal{P}_{\\text{oiss}} \\left(3 \\cdot d \\cdot (1 - \\alpha) \\cdot \\lambda, k\\right) \\cdot \\sum_{h=0}^{\\infty} \\mathcal{P}_{\\text{oiss}} \\left(d \\cdot (1 - \\alpha) \\cdot \\lambda, h\\right) \\cdot \\tag{75} \\\\ \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x + j + h + m&#x27; - 1}{m&#x27;} \\cdot (1 - \\alpha)^{n_x + j + h} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\cdot \\tag{76} \\\\ \\sum_{m=M}^{\\infty} \\binom{n_x + j + h + m - 1}{m} \\cdot (1 - \\alpha)^{n_x + j + h} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(g - 2 \\cdot h - k - j - l - (m - M))^+} \\tag{77} \\end{array}</span></div>

    <p class="text-gray-300">For large enough <span class="math">n_x</span>'s, this term is at most <span class="math">\\epsilon_0 / 4</span> away from</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{g + M - n_x - W} \\cdot \\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x + m&#x27; - 1}{m&#x27;} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\tag{78}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{m=M}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n_x - m)^+} \\tag{79}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Part V</strong>: As for the first multiplicand of (78), by Part II of this proof, after some <span class="math">\\tau</span> of finite expectation: $M(G_s^u) + g(G_s^u) - n_x(G_s^u) \\geq -\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G_{[time(x),t]}^{oracle}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- m^* =: D_2<span class="math"> (a constant determined by time </span>\\tau<span class="math">). Assume </span>s \\geq \\tau<span class="math">. We conclude that the term </span>\\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{g + M - n_x - W}<span class="math"> is upper bounded by </span>e^{D_3 \\cdot D_4}<span class="math"> (with </span>D_3 = \\ln \\left(\\frac{1 - \\alpha}{\\alpha}\\right)$). Thus, in order to show that (78) vanishes suffice it to show that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\sum_{m&#x27;=M}^{\\infty} \\binom{n_x + m&#x27; - 1}{m&#x27;} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^{m&#x27;}\\right)^{-1} \\tag{80}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\sum_{m=M}^{\\infty} \\binom{n_x + m - 1}{m} \\cdot (1 - \\alpha)^{n_x} \\cdot \\alpha^m \\cdot \\left(\\frac{\\alpha}{1 - \\alpha}\\right)^{(n_x - m)^+} \\tag{81}</span></div>

    <p class="text-gray-300">vanishes.</p>

    <p class="text-gray-300">The last term equals</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\Pr_{m \\sim Z(1 - \\alpha, n_x)} (m \\geq M)\\right)^{-1} \\cdot \\left(\\Pr_{m \\sim Z(\\alpha, n_x)} (m \\leq n_x) + \\Pr_{m \\sim Z(1 - \\alpha, n_x)} (m \\geq n_x)\\right). \\tag{82}</span></div>

    <p class="text-gray-300">For large enough <span class="math">n_x</span>'s, a variable distributed according to <span class="math">Z(1 - \\alpha, n_x)</span> converges to a normal variable with mean <span class="math">n_x \\cdot \\frac{\\alpha}{1 - \\alpha}</span> and variance <span class="math">n \\cdot \\frac{\\alpha}{(1 - \\alpha)^2}</span>. The last term is therefore at most <span class="math">\\epsilon_0 / 4</span> away from</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)\\right)^{-1}. \\tag{83}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\leq \\frac{n_x - \\frac{1 - \\alpha}{\\alpha} \\cdot n_x}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot n_x}}\\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)\\right) = \\tag{84}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)\\right)^{-1}. \\tag{85}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{\\frac{1 - \\alpha}{\\alpha} \\cdot n_x - n_x}{\\sqrt{\\frac{1 - \\alpha}{\\alpha^2} \\cdot n_x}}\\right) + \\Pr_{z \\sim \\mathcal{N}(0,1)} \\left(z \\geq \\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)\\right). \\tag{86}</span></div>

    <p class="text-gray-300">We use the following inequalities due to Komatu (1955), for <span class="math">x \\geq 0</span>, and a standard normal variable <span class="math">z \\sim \\mathcal{N}(0,1)</span>: <span class="math">\\frac{1}{\\sqrt{2} \\cdot \\pi} \\cdot \\frac{2 \\cdot e^{-z^2 / 2}}{x + \\sqrt{4 + x^2}} \\leq \\Pr(z &amp;gt; x) \\leq \\frac{1}{\\sqrt{2} \\cdot \\pi} \\cdot \\frac{2 \\cdot e^{-z^2 / 2}}{x + \\sqrt{2 + x^2}}</span>.</p>

    <p class="text-gray-300">Put <span class="math">x_1 := \\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}</span>, and <span class="math">x_3 := \\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}</span>.</p>

    <p class="text-gray-300">We obtain an upper bound on (86):</p>

    <div class="my-4 text-center"><span class="math-block">\\sqrt{\\pi / 2} \\cdot \\left(x_1 + \\sqrt{4 + x_1^2}\\right) \\cdot e^{x_1^2 / 2} \\cdot \\left(\\frac{1}{\\sqrt{\\pi / 2}} \\cdot \\frac{e^{-x_2^2 / 2}}{x_2} + \\frac{1}{\\sqrt{\\pi / 2}} \\cdot \\frac{e^{-x_3^2 / 2}}{x_3}\\right) = \\tag{87}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(x_1 + \\sqrt{4 + x_1^2}\\right) \\cdot e^{x_1^2 / 2} \\cdot \\left(\\frac{e^{-x_3^2 / 2}}{x_2} + \\frac{e^{-x_3^2 / 2}}{x_3}\\right) \\tag{88}</span></div>

    <p class="text-gray-300">We further observe that, for large <span class="math">n_x</span>'s: <span class="math">x_2 \\geq C_2 \\cdot \\sqrt{n_x}</span> and <span class="math">x_3 \\geq C_3 \\cdot \\sqrt{n_x}</span>, for some positive constants <span class="math">C_i</span> (this applies to all constants below as well). Therefore, <span class="math">\\frac{\\left(x_1 + \\sqrt{4 + x_1^2}\\right)}{\\min\\{x_2, x_3\\}} \\leq C_1 / \\max\\{C_2, C_3\\} =: D_1</span>. The above term is therefore upper bounded, up to a multiplicative factor of <span class="math">D_1</span>, by</p>

    <div class="my-4 text-center"><span class="math-block">e^{x_1^2 / 2 - x_2^2 / 2} + e^{x_1^2 / 2 - x_3^2 / 2} =</span></div>

    <div class="my-4 text-center"><span class="math-block">e^{0.5 \\cdot \\left(\\left(\\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)^2 - \\left(\\frac{\\frac{1 - \\alpha}{1 - \\alpha} \\cdot n_x - n_x}{\\sqrt{\\frac{1 - \\alpha}{1 - \\alpha} \\cdot n_x}}\\right)^2\\right)} + e^{0.5 \\cdot \\left(\\left(\\frac{M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{\\alpha}{(1 - \\alpha)^2} \\cdot n_x}}\\right)^2 - \\left(\\frac{n_x - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x}{\\sqrt{\\frac{1 - \\alpha}{1 - \\alpha} \\cdot n_x}}\\right)^2\\right)} \\leq</span></div>

    <div class="my-4 text-center"><span class="math-block">e^{0.5 \\cdot \\left(\\frac{(1 - \\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x\\right)^2 - \\frac{(1 - 2 \\cdot \\alpha)^2}{1 - \\alpha} \\cdot n_x\\right)} + e^{0.5 \\cdot \\left(\\frac{(1 - \\alpha)^2}{\\alpha \\cdot n_x} \\cdot \\left(M - \\frac{\\alpha}{1 - \\alpha} \\cdot n_x\\right)^2 - \\frac{(1 - 2 \\cdot \\alpha)^2}{\\alpha} \\cdot n\\right)}. \\tag{89}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Conditioned on the relation $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{future}_h(x, G_t^{\\text{oracle}}) \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq n_x<span class="math">, </span>M \\leq \\text{future}_a(x, G_s^u)<span class="math">, hence its expected value is at most </span>\\frac{\\alpha}{1 - \\alpha} \\cdot n_x<span class="math">. For any </span>\\delta &gt; 0<span class="math">, by the Strong Law of Large Numbers, after some </span>\\tau<span class="math"> (of finite expectation), </span>\\forall s \\geq \\tau : M \\leq (1 + \\delta) \\cdot \\mathbb{E}[M] \\leq (1 + \\delta) \\cdot \\frac{\\alpha}{1 - \\alpha} \\cdot n_x$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Consequently, (89) is upper bounded by</p>

    <p class="text-gray-300"><span class="math">e^{0.5\\cdot\\frac{(1-\\alpha)^{2}}{\\alpha\\cdot n_{x}}\\cdot\\left(M-\\frac{\\alpha}{1-\\alpha}\\cdot n_{x}\\right)^{2}-0.5\\cdot\\frac{(1-2\\cdot\\alpha)^{2}}{1-\\alpha}\\cdot n_{x}}+e^{0.5\\cdot\\frac{(1-\\alpha)^{2}}{\\alpha\\cdot n_{x}}\\cdot\\left(M-\\frac{\\alpha}{1-\\alpha}\\cdot n_{x}\\right)^{2}-0.5\\cdot\\frac{(1-2\\cdot\\alpha)^{2}}{\\alpha}\\cdot n_{x}}\\leq</span> (90) <span class="math">e^{0.5\\cdot\\frac{(1-\\alpha)^{2}}{\\alpha\\cdot n_{x}}\\cdot\\left(\\delta\\cdot\\frac{\\alpha}{1-\\alpha}\\cdot n_{x}\\right)^{2}-0.5\\cdot\\frac{(1-2\\cdot\\alpha)^{2}}{1-\\alpha}\\cdot n_{x}}+e^{0.5\\cdot\\frac{(1-\\alpha)^{2}}{\\alpha\\cdot n_{x}}\\cdot\\left(\\delta\\cdot\\frac{\\alpha}{1-\\alpha}\\cdot n_{x}\\right)^{2}-0.5\\cdot\\frac{(1-2\\cdot\\alpha)^{2}}{\\alpha}\\cdot n_{x}}\\leq</span> (91) <span class="math">e^{R_{1}/n_{x}-R_{2}\\cdot n_{x}}+e^{R^{3}/n_{x}-R_{4}\\cdot n_{x}}\\leq e^{-R_{5}\\cdot n_{x}},</span> (92)</p>

    <p class="text-gray-300">for some positive constants <span class="math">R_{i}</span>, where the last inequality holds for large enough <span class="math">n_{x}</span>’s, and the preceding inequality holds for small enough <span class="math">\\delta</span>’s (<span class="math">\\delta&lt;1/n_{x}</span>).</p>

    <p class="text-gray-300">Taking <span class="math">n_{x}</span> to be greater than <span class="math">n_{x}&gt;\\ln\\left(4\\cdot D_{1}/\\epsilon_{0}\\right)/R_{5}</span> we conclude that for some large enough <span class="math">n_{x}</span>:</p>

    <p class="text-gray-300"><span class="math">f_{post\\_mine}\\left(n_{x}\\left(G_{s}^{u}\\right),g\\left(G_{s}^{u}\\right),l\\left(G_{s}^{u}\\right)\\right)&lt;4\\cdot\\epsilon_{0}/4=\\epsilon_{0}.</span> (93)</p>

    <p class="text-gray-300">(Note that the expected waiting time for the first <span class="math">\\tau</span> such that <span class="math">\\forall j\\in honest:n_{x}(u,\\psi)</span> is at least some <span class="math">n_{0}</span> is at most <span class="math">n_{0}\\cdot\\left((1-\\alpha)\\cdot\\lambda\\right)^{-1}+d</span>: it is <span class="math">1/((1-\\alpha)\\cdot\\lambda)</span> for the creation of every honest block, and <span class="math">d</span> for the last one to arrive at all nodes.) ∎</p>

    <p class="text-gray-300">The same technique used in the proof of Lemma 19 is used below to prove the Progress property (Proposition 9); indeed, in the proof we see that the term that aggregates all the error functions vanishes as time develops, w.h.p., in the perspective of all honest nodes. In particular, for <span class="math">v</span> (the node that originally <span class="math">\\epsilon</span>-accepted the transaction), it becomes smaller than <span class="math">\\epsilon^{\\prime}</span> w.h.p. A yet similar usage of this argument is used below to prove Weak Liveness (Proposition 10); indeed, in the latter we only need to regard the case where <span class="math">y=NULL</span>. In this case, all published blocks are strong voters in favour of <span class="math">x</span>, and so we can guarantee the convergence of the error functions without going through Lemma 14 and the analysis that follows.</p>

    <h3 id="sec-59" class="text-xl font-semibold mt-8">V-G Proof of Weak Liveness (blocks)</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We’ve seen that the error functions <span class="math">f_{pre\\_mine}(l\\left(G_{s}^{u}\\right))</span>, <span class="math">f_{pre\\_pub}\\left(n_{j}\\left(G_{s}^{u}\\right)\\right)</span>, and $f_{post\\_pub}\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G_{s}^{u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)<span class="math"> go to zero as </span>s<span class="math"> grows. For any </span>s<\\psi<span class="math">, </span>y\\notin G_{s}^{pub}<span class="math">, hence by line 5 of Algorithm 3, </span>g\\left(G_{s}^{v}\\right)=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=n_{x}\\left(G_{s}^{u}\\right)<span class="math">, and </span>M\\left(G_{s}^{v}\\right)=0<span class="math">. In particular, the relation (73) is satisfied trivially, and the analysis in the proof of Lemma 19 applies, proving that the term </span>f_{post\\_mine}<span class="math"> vanishes as time grows. In particular, since these functions decrease exponentially, it becomes smaller than </span>\\epsilon<span class="math"> after a number of honest blocks in the order of </span>\\mathcal{O}(\\ln(1/\\epsilon))<span class="math"> are created, and the expected waiting time for this is obtained by dividing this number by </span>(1-\\alpha)\\cdot\\lambda<span class="math"> (and adding </span>d$ for all honest blocks to receive these blocks).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">V-H Proof of Progress (blocks)</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This follows immediately from the proof of Lemma 19, in which it was shown that, conditioned on the event <span class="math">\\widehat{\\mathcal{E}}_{\\neg\\infty}^{all}t(x,y)</span>, $f_{pre\\_mine}(l\\left(G_{s}^{v}\\right))+f_{pre\\_pub}\\left(n_{j}\\left(G_{s}^{u}\\right)\\right)+f_{post\\_pub}\\left(\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">future\\left(x,G_{t}^{u}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)+f_{post\\_mine}\\left(n_{x}\\left(G_{s}^{u}\\right),g\\left(G_{s}^{u}\\right),l\\left(G_{s}^{u}\\right)\\right)<span class="math"> vanishes as </span>s<span class="math"> grows indefinitely. In Lemma 14 it was shown that, up to a probability of </span>\\epsilon<span class="math">, the event </span>\\mathcal{E}_{t}^{v}(x,y,\\epsilon)<span class="math"> is contained in </span>\\widehat{\\mathcal{E}}_{\\neg\\infty}^{all}t(x,y)<span class="math"> (i.e., when the former is intersected with an event of probability </span>\\geq 1-\\epsilon$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">64</p>

    <p class="text-gray-300"><strong>Part I:</strong> Denote by <span class="math">risk_{acc}(G_s^u, tx, subG)</span> (<span class="math">risk_{rej}</span>) the output of Algorithm 4 (respectively, Algorithm 5) when given the inputs <span class="math">G_s^u</span> (for some honest <span class="math">u</span>), <span class="math">tx</span>, and <span class="math">subG</span> (such that <span class="math">subG</span> is the past of some (possibly virtual) block). For any <span class="math">z \\in [tx] \\cap subG</span>, denote by <span class="math">risk_{acc}^z(G_s^u, tx, subG)</span> the value of the <span class="math">risk</span> variable as the loop in line 2 of <span class="math">RiskTxAccept</span> terminates its run over <span class="math">z</span>. Denote similarly <span class="math">minrisk_{rej}^z(G_s^u, tx, subG)</span> w.r.t. the variable <span class="math">minrisk</span> in <span class="math">RiskTxReject</span>.</p>

    <p class="text-gray-300">We claim that, with probability <span class="math">&amp;gt; 1 - risk_{acc}(G_t^v, tx, subG)</span>, there exists a <span class="math">\\tau_{acc}</span> of finite expectation such that for all <span class="math">s \\geq \\tau_{acc}</span>, for all <span class="math">u \\in honest</span>, and for all <span class="math">subG&#x27; \\supseteq subG</span>:</p>

    <div class="my-4 text-center"><span class="math-block">risk_{acc}(G_t^v, tx, subG) \\geq risk_{acc}(G_s^u, tx, subG&#x27;) \\tag{94}</span></div>

    <p class="text-gray-300">Similarly, we claim that, with probability <span class="math">&amp;gt; 1 - risk_{rej}(G_t^v, tx, subG)</span>, there exists a <span class="math">\\tau_{rej}</span> of finite expectation such that for all <span class="math">s \\geq \\tau_{rej}</span>, for all <span class="math">u \\in honest</span>:</p>

    <div class="my-4 text-center"><span class="math-block">risk_{rej}(G_t^v, tx, subG) \\geq risk_{rej}(G_s^u, tx, subG). \\tag{95}</span></div>

    <p class="text-gray-300">Assume we have proved this for all <span class="math">subG</span> of size <span class="math">&amp;lt; k</span>. We now prove this for <span class="math">subG_k</span> of size <span class="math">k</span>.</p>

    <p class="text-gray-300">By the definition of <span class="math">risk_{acc}</span>, there exists a <span class="math">z_{tx} \\in subG_k \\cap [tx]</span> such that <span class="math">risk_{acc}(G_t^v, tx, subG&#x27;) = risk_{acc}^{z_{tx}}(G_t^v, tx, subG&#x27;)</span>.</p>

    <p class="text-gray-300"><strong>Part II:</strong> Denote by <span class="math">Z_2</span> the set of instantiations of the third-loop-variable <span class="math">z_2</span>, inside the iteration of the first-loop with <span class="math">z_1 = z_{tx}</span>. By Propositions 8 and 9, <span class="math">\\forall z_2 \\in Z_2</span>, with probability <span class="math">\\geq 1 - Risk(G_t^v, (vote(z&#x27;))_{z&#x27; \\in C}, z_1, z_2)</span>, for any <span class="math">\\epsilon&#x27;</span>, after some <span class="math">\\tau</span> (of finite expectation), <span class="math">\\forall z_2&#x27; \\in (G_s^u \\setminus G_t^v) \\cup \\{z_2\\}: Risk(G_s^u, (vote(z))_{z \\in C}, z_{tx}, z_2&#x27;) \\leq \\epsilon&#x27;</span>. Moreover, in the proof of Proposition 19 it was shown that the minimal <span class="math">\\epsilon&#x27;</span> for which this property holds at time <span class="math">s</span> decreases exponentially with <span class="math">n</span> (which grows linearly with <span class="math">s</span>). Thus, for all <span class="math">s</span> greater than some <span class="math">\\tau</span>, <span class="math">\\sum_{z_2&#x27; \\in (G_s^u \\setminus G_t^v) \\cup Z_2}: Risk(G_s^u, (vote(z))_{z \\in C}, z_{tx}, z_2&#x27;) \\leq \\sum_{z_2&#x27; \\in Z_2} Risk(G_t^v, (vote(z))_{z \\in C}, z_{tx}, z_2&#x27;)</span>.</p>

    <p class="text-gray-300"><strong>Part III:</strong> Similarly, by Proposition 8, with probability of at least <span class="math">Risk(G_t^v, (vote(z))_{z \\in C}, z_{tx}, \\emptyset)</span>, after some <span class="math">\\tau</span> (of finite expectation), <span class="math">Risk(G_s^u, (vote(z))_{z \\in C}, z_{tx}, \\emptyset) \\leq Risk(G_t^v, (vote(z))_{z \\in C}, z_{tx}, \\emptyset)</span>.</p>

    <p class="text-gray-300"><strong>Part IV:</strong> Let <span class="math">\\epsilon_i(G_s^u, tx, subG)</span> be the series of values returned by the call to <span class="math">RiskTxAccept</span> in line 7 of <span class="math">RiskTxAccept</span> (when given the inputs <span class="math">(G_s^u, tx, subG)</span>) and to <span class="math">RiskTxReject</span> in line 9 of <span class="math">RiskTxAccept</span> (with these inputs). By the induction hypothesis, with probability <span class="math">\\geq 1 - \\epsilon_i</span>, after some time <span class="math">\\tau</span>, <span class="math">\\epsilon_i(G_s^u, tx, past(z_{tx})) \\leq \\epsilon_i(G_t^v, tx, past(z_{tx}))</span>.</p>

    <p class="text-gray-300"><strong>Part V:</strong> The above arguments show that, with probability <span class="math">\\geq 1 - risk_{acc}^{z_{tx}}(G_t^v, tx, subG)</span>, the sum of increments to the value of <span class="math">risk_{acc}^{z_{tx}}(G_s^u, tx, subG&#x27;)</span> is upper bounded by the</p>

    <p class="text-gray-300">28Technically, the indexes <span class="math">i</span> on both hand-sides of this inequality should be described more carefully. To save cumbersome notation, we rely on the understanding of the reader. Informally, every instantiation of the loop-variables inside <span class="math">RiskTxAccept</span> (when given the inputs <span class="math">(G_t^v, tx, subG)</span>) is also realized by future calls of <span class="math">RiskTxAccept</span> (when given the inputs <span class="math">(G_s^u, tx, subG&#x27;)</span>). We thus compare the results of the increments in the former to those in the latter. This is also true vice versa (for <span class="math">z_1 = z_{tx}</span>): Inside the first-loop's iteration over <span class="math">z_1 = z_{tx}</span>, the exact same calls to <span class="math">RiskTxAccept</span> and <span class="math">RiskTxReject</span> are made, because <span class="math">past(z_{tx})</span> does not evolve with time.</p>

    <p class="text-gray-300">the sum of increments to the value of <span class="math">risk_{acc}^{z_{tx}}(G_{t}^{v},tx,subG)</span>, for all <span class="math">s\\geq\\tau</span>, where <span class="math">\\tau</span> is of finite expectation. As <span class="math">risk_{acc}(G_{s}^{u},tx,subG^{\\prime})\\leq risk_{acc}^{z_{tx}}(G_{s}^{u},tx,subG^{\\prime})</span>, and as <span class="math">risk_{acc}(G_{t}^{v},tx,subG)=risk_{acc}^{z_{tx}}(G_{t}^{v},tx,subG)</span>, this proves that, with probability <span class="math">\\geq 1-risk_{acc}^{z_{tx}}(G_{t}^{v},tx,subG)</span> the inequality <span class="math">risk_{acc}(G_{s}^{u},tx,subG^{\\prime})\\leq risk_{acc}(G_{t}^{v},tx,subG)</span> holds.</p>

    <p class="text-gray-300"><em>Part VI:</em> Similar arguments prove the induction step w.r.t. <span class="math">RiskTxReject</span>. The difference in the proof is that, since <span class="math">risk_{rej}^{z_{1}}</span> is not a sum, rather a minimum, hence we can ignore the fact that <span class="math">anticone\\left(z_{1},G_{s}^{u}\\right)</span> may grow in time and add loop-iterations that might further reduce the value of <span class="math">risk_{rej}^{z_{1}}</span>. Note further that the induction claim, w.r.t. <span class="math">RiskTxReject</span>, is restricted to the case <span class="math">subG^{\\prime}=subG</span>. Hence, the fact that the set <span class="math">Z_{G}([tx])</span> possibly grows with time is of no consequence, since the first loop-variable is chosen from <span class="math">Z_{G}([tx])\\cap subG</span>. We thus conclude that, with probability <span class="math">\\geq 1-risk_{rej}(G_{s}^{u},tx,subG_{k})</span>, there exists a <span class="math">\\tau</span> of finite expectation such that for all <span class="math">s\\geq\\tau</span> and all <span class="math">u\\in honest</span>: <span class="math">risk_{rej}(G_{s}^{u},tx,subG_{k})\\leq risk_{rej}(G_{t}^{v},tx,subG_{k})</span>.</p>

    <p class="text-gray-300">This completes the proof of the induction claim.</p>

    <p class="text-gray-300"><em>Part VII:</em> Algorithm 6 returns a set that contains <span class="math">tx</span> if and only if <span class="math">RiskTxAccept</span> returned a value smaller than <span class="math">\\epsilon</span>. The above claim implies that, if <span class="math">risk_{acc}(G_{t}^{v},tx,G_{t}^{v})&lt;\\epsilon</span>, with probability <span class="math">\\geq 1-\\epsilon</span>, for all <span class="math">s\\geq\\tau</span>, for some <span class="math">\\tau</span> of finite expectation, for all <span class="math">u\\in honest</span>: <span class="math">risk_{acc}(G_{s}^{u},tx,G_{s}^{u})&lt;\\epsilon</span>. In other words, conditioned on <span class="math">\\mathcal{A}_{t}^{v}(tx,\\epsilon)</span>, the event <span class="math">\\cap_{u\\in honest,s\\in(\\tau(t),\\infty)}\\mathcal{A}_{s}^{u}(tx,\\epsilon)</span> occurs with probability <span class="math">\\geq 1-\\epsilon</span>.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">IV-J Proof of Liveness</h3>

    <p class="text-gray-300">Fix some <span class="math">z_{1}\\in Z_{G}([tx])</span> for <span class="math">G=G_{t}^{v}</span>. The condition that until <span class="math">\\psi(t)</span>: <span class="math">conflict\\left(tx\\right)\\cap G_{s}^{pub}=\\emptyset</span>, implies that lines 6 and 7 of <span class="math">RiskTxAccept</span> do not contribute to the value of <span class="math">risk_{acc}(G_{s}^{u},tx,subG)</span>. The assumption <span class="math">\\sum_{[tx_{i}]\\in inputs(tx)}RiskTxAccept\\left(G_{t}^{v},\\left(vote\\left(z\\right)\\right)_{z\\in C},[tx_{i}],G_{t}^{v}\\right)&lt;\\epsilon/2</span> implies that, with probability <span class="math">\\geq 1-\\epsilon/2</span>, the overall contribution of the fourth loop to the value of <span class="math">risk_{acc}^{z_{1}}(G_{s}^{u},[tx],G_{s}^{u})</span> is at most <span class="math">\\epsilon/2</span> (after some <span class="math">\\tau</span>). Finally, by Proposition 10, the contribution of line 3 to <span class="math">risk_{acc}^{z_{1}}</span> is less than <span class="math">\\epsilon/2</span>, after some <span class="math">\\tau</span> of finite expectation. We conclude that after some <span class="math">\\tau</span> of finite expectation, the value of <span class="math">risk_{acc}^{z_{1}}(G_{s}^{u},[tx],G_{s}^{u})</span> is smaller than <span class="math">\\epsilon/2+\\epsilon/2=\\epsilon</span>, for all <span class="math">s\\geq\\tau</span> and <span class="math">u\\geq s</span>, hence <span class="math">risk_{acc}(G_{s}^{u},[tx],G_{s}^{u})&lt;\\epsilon</span>, which implies the event <span class="math">\\cap_{u\\in honest,s\\in(\\tau(t),\\infty)}\\mathcal{A}_{s}^{u}(tx,\\epsilon)</span>.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">IV-K Proof of Progress</h3>

    <p class="text-gray-300">The proof of this proposition is similar in structure to that of Proposition 2. Therein we have already argued that the contributions to the value of <span class="math">risk_{acc}^{z_{tx}}</span> (and similarly for <span class="math">risk_{rej}^{z_{tx}}</span>) of lines 3 and of 6 go to zero; and the increments of lines 7 and 9 go to zero by the induction hypothesis. Thus, <span class="math">risk_{acc}(G_{s}^{v},tx,G_{s}^{v})</span> goes to 0 as time develops, with probability <span class="math">\\geq 1-risk_{acc}(G_{t}^{v},tx,G_{t}^{v})</span>. As <span class="math">\\epsilon&gt;risk_{acc}(G_{t}^{v},tx,G_{t}^{v})</span>, we conclude that, with probability <span class="math">\\geq 1-\\epsilon</span>, for all <span class="math">G_{s}^{u}</span> with <span class="math">s\\geq\\tau</span> and <span class="math">u\\in honest</span>, Algorithm 6 returns a set that contains <span class="math">tx</span>.</p>`;
---

<BaseLayout title="SPECTRE: A Fast and Scalable Cryptocurrency Protocol (2016/1159)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/1159
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
