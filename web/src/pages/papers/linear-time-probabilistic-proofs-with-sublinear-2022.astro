---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1056';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Linear-Time Probabilistic Proofs with Sublinear Verification for Algebraic Automata Over Every Field';
const AUTHORS_HTML = 'Jonathan Bootle, Alessandro Chiesa, Ziyi Guan, Siqi Liu';

const CONTENT = `    <p class="text-gray-300">Jonathan Bootle jbt@zurich.ibm.com IBM Research – Zurich Alessandro Chiesa alessandro.chiesa@epfl.ch EPFL Ziyi Guan ziyi.guan@epfl.ch EPFL Siqi Liu sliu18@berkeley.edu UC Berkeley</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Interactive oracle proofs (IOPs) are a generalization of probabilistically checkable proofs that can be used to construct succinct arguments. Improvements in the efficiency of IOPs lead to improvements in the efficiency of succinct arguments. Key efficiency goals include achieving provers that run in linear time and verifiers that run in sublinear time, where the time complexity is with respect to the arithmetic complexity of proved computations over a finite field <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">We consider the problem of constructing IOPs for any given finite field <span class="math">\\mathbb{F}</span> with a linear-time prover and polylogarithmic query complexity. Several previous works have achieved these efficiency requirements with <span class="math">O(1)</span> soundness error for NP-complete languages. However, constrained by the soundness error of the sumcheck protocol underlying these constructions, the IOPs achieve linear prover time only for instances in fields of size <span class="math">\\Omega(\\log n)</span>. Recent work <em>(Ron-Zewi and Rothblum, STOC 2022)</em> overcomes this problem, but with linear verification time.</p>

    <p class="text-gray-300">We construct IOPs for the algebraic automata problem over any finite field <span class="math">\\mathbb{F}</span> with a linear-time prover, polylogarithmic query complexity, and sublinear verification complexity. We additionally prove a similar result to Ron-Zewi and Rothblum for the NP-complete language R1CS using different techniques. The IOPs imply succinct arguments for (nondeterministic) arithmetic computations over any finite field with linear-time proving (given black-box access to a linear-time collision-resistant hash function).</p>

    <p class="text-gray-300">Inspired by recent constructions of reverse-multiplication-friendly embeddings, our IOP constructions embed problem instances over small fields into larger fields and adapt previous IOP constructions to the new instances. The IOP provers are modelled as random access machines and use precomputation techniques to achieve linear prover time. In this way, we avoid having to replace the sumcheck protocol.</p>

    <p class="text-gray-300">Keywords: interactive oracle proofs; succinct arguments; linear-time prover; sublinear verification</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our results 2 1.2 Related works 4</p>

    <p class="text-gray-300">2 Techniques 7 2.1 Starting point: the tensor-query to point-query paradigm 7 2.2 Overview of techniques 7 2.3 Systematic reverse-multiplication-friendly embeddings 8 2.4 A tensor IOP for R1CS over small fields 10 2.5 Eliminating overhead through precomputation 12 2.6 Algebraic automata 13 2.7 Completing the point-query IOP construction 15</p>

    <p class="text-gray-300">3 Preliminaries 17</p>

    <p class="text-gray-300">4 Systematic reverse-multiplication-friendly embeddings 19 4.1 Systematic RMFE from polynomial interpolation 19 4.2 Systematic RMFE from algebraic geometry 20 4.3 Asymptotic results 21</p>

    <p class="text-gray-300">5 Biased generators 22 5.1 A subspace biased generator from an <span class="math">\\epsilon</span>-biased generator 22 5.2 A biased generator computable in linear time 23</p>

    <p class="text-gray-300">6 Tensor IOP for R1CS over every field 25 6.1 Multi-lincheck 25 6.2 Modular multi-lincheck protocol 27 6.3 A tensor IOP for R1CS 29</p>

    <p class="text-gray-300">7 Algebraic automata 32 7.1 R1CS automata 32 7.2 Achieving sublinear verification for R1CS automata 34 7.3 Cyclic-shift test 37 7.4 Biased generator consistency test 38 7.5 Tensor-sum consistency test 41</p>

    <p class="text-gray-300">8 From point queries to tensor queries 42 8.1 Proximity test 43 8.2 Consistency checks on tensor codes 45 8.3 The proximity generator that we use 47</p>

    <p class="text-gray-300">9 Random access machines and precomputation 49</p>

    <p class="text-gray-300">10 Proof of main theorems 51 10.1 Step 1: robustification 51 10.2 Step 2: composition 52 10.3 Step 3: tensor queries to point queries 53 10.4 Step 4: Precomputing expensive operations 54</p>

    <p class="text-gray-300">Acknowledgments 56</p>

    <p class="text-gray-300">References 56</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">A succinct argument is a protocol where a prover aims to convince a verifier that a statement is correct, by communicating a short and efficiently verifiable proof, rather than a witness to the correctness of the statement. Succinct arguments have found numerous applications, such as verifiable computation schemes and electronic voting systems. Motivated by these applications, researchers strive to improve the efficiency of succinct arguments. The main efficiency measures are communication complexity, and prover and verifier running time. Amazingly, prior work on succinct arguments <em>[x11, x14, x15, x16]</em> culminates in constructions whose communication complexity and verifier time are independent of the statement to be proved. However, the prover complexity of these constructions remains a major bottleneck in practice, motivating research into linear-time prover algorithms.</p>

    <p class="text-gray-300">All known constructions of succinct arguments with linear-time provers are interactive protocols where the prover and the verifier interact over multiple rounds. Building on <em>[x12, x21]</em>, <em>[x27]</em> constructed succinct arguments for layered arithmetic circuit evaluation with linear prover time, later extended to all circuits in <em>[x30]</em>. The drawback is that these protocols’ verify the correctness of polynomial-time computations, rather than NP statements. Later constructions target <span class="math">\\mathsf{NP}</span> languages, and use the Interactive Oracle Proof (IOP) model, first introduced in <em>[x5]</em> and <em>[x32]</em>. In the IOP model, the prover sends oracles to the verifier, who queries the oracles at various points instead of reading them in their entirety. Various IOP constructions such as <em>[x1, x4]</em> encode computations using polynomial encodings which require quasilinear time to compute, and whose multiplicative properties facilitate protocol design. However, linear-time constructions must employ linear-time encodings, for which no constructions with multiplicative properties are known.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The first construction of a linear-time IOP for general arithmetic circuits in <em>[x6]</em> had square-root communication complexity in the circuit size, and was subsequently improved to sublinear <em>[x7]</em> and finally polylogarithmic <em>[x8]</em>, with comparable verification times, using techniques from <em>[x31, x4]</em>. However, as in <em>[x31]</em>, <em>[x6, x7]</em> rely on the the <em>[x20]</em> sumcheck procotol. Due to implicit use of polynomial encodings, the soundness error of the sumcheck protocol is $O(\\frac{\\log n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">, which limits <em>[x6, x7]</em> to circuits defined over fields of size </span>\\Omega(\\log n)<span class="math">. Recently, <em>[x31]</em> solved this problem with a new multi-sumcheck protocol using linear-time encodings, which leads to an IOP for circuit satisfiability with linear verification time and soundness error </span>O(1)$ over any finite field. Thus, the development of IOPs with linear-time provers so far is entirely based on eliminating polynomial arithmetic in favour of linear-time encodings, at first, in order to avoid computational overheads, and later, to achieve non-trivial soundness guarantees over constant-size fields.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">On the other hand, <em>[x10]</em> successfully constructs sound IOPs for <span class="math">\\mathsf{NP}</span> statements defined over <span class="math">\\mathbb{F}_{2}</span> by reducing them to <span class="math">\\mathsf{NP}</span> statements over polynomial-size fields using specialised encodings called reverse multiplication-friendly embeddings (RMFEs) <em>[x13]</em>. They then apply IOP protocols over large fields. Due to looseness in the reductions and overheads associated with the RMFEs, <em>[x10]</em> gives a superlinear-time prover algorithm. However, their approach is attractive, as it allows reuse of existing protocols and implementations. We revisit the embedding strategy of <em>[x10]</em> to see whether it can be used to construct linear-time prover algorithms.</p>

    <p class="text-gray-300">In this work, we construct IOPs with linear-time prover for the language of <span class="math">\\mathrm{R1CS}</span> automata, and the NP-complete language <span class="math">\\mathrm{R1CS}</span> defined over <span class="math">\\mathbb{F}_{2}</span>, by combining techniques from <em>[x10]</em> and previous works on linear-time IOPs, along with some new techniques that reduce the prover’s computational overhead. Perhaps surprisingly, our work shows that linear-time proofs over constant-size fields can leverage multiplicative encodings of super-constant size, avoiding the computational overhead associated with encoding the entire</p>

    <p class="text-gray-300">witness by using precomputation techniques. Furthermore, our IOP for R1CS automata achieves sublinear verification. Previously, this was only known for R1CS for over large fields, and used preprocessing techniques <em>[x1, x2]</em>. Note that preprocessing is essential for sublinear verification time for R1CS, because merely reading the instance requires linear time for the verifier.</p>

    <p class="text-gray-300">Though our result for R1CS is similar to that of <em>[x18]</em>, we use different computational models and techniques. Our provers and verifiers are random-access machines while theirs are circuits. More comparisons between the two approaches are given in Section 1.2.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Our results</h3>

    <p class="text-gray-300">We construct linear-time IOPs for computations over <em>every</em> field (including the boolean field). The first IOP supports <em>rank-1 constraint satisfiability</em> (R1CS), a standard generalization of arithmetic circuit-SAT, where the “circuit description” is encoded in coefficient matrices. This NP-complete problem is widely used in the IOP literature since it efficiently expresses arithmetic circuits and is convenient for protocol design.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 1.1.</h6>

    <p class="text-gray-300">The R1CS problem over a finite field <span class="math">\\mathbb{F}</span> is as follows: given matrices <span class="math">A,B,C\\in\\mathbb{F}^{N\\times N}</span> with at most <span class="math">M=\\Omega(N)</span> non-zero entries, and an instance vector <span class="math">x</span> over <span class="math">\\mathbb{F}</span>, does there exist a witness <span class="math">w</span> over <span class="math">\\mathbb{F}</span> such that <span class="math">z\\coloneqq(x,w)\\in\\mathbb{F}^{N}</span> and <span class="math">Az\\circ Bz=Cz</span>? Here “<span class="math">\\circ</span>” denotes the entry-wise product.</p>

    <p class="text-gray-300">Merely checking the validity of a witness by directly checking the R1CS condition costs <span class="math">O(M)</span> operations over <span class="math">\\mathbb{F}</span>, so “linear time” for R1CS means computations that cost no more than <span class="math">O(M)</span> operations over <span class="math">\\mathbb{F}</span> (or the equivalent in bit operations).</p>

    <p class="text-gray-300">The first main result of this paper is an IOP for R1CS, over any given field, that achieves linear-time proving (thus also linear-size proofs) and polylogarithmic query complexity. The notion of linear time is achieved over a random-access machine. A comparison with prior linear-time IOPs is given in Figure 1.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1.2 (main).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span>, there is a public-coin IOP (with point queries), for R1CS instances whose matrices have <span class="math">M=\\Omega(N)</span> nonzero entries, that has the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log N)</span>;</li>

      <li>answer alphabet is <span class="math">\\mathbb{F}</span>;</li>

      <li>proof length is <span class="math">O(N)</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- query complexity is $O(\\log(N)^{2}/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover is a RAM with word length <span class="math">\\Theta(\\log N)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(M+N)</span> time and <span class="math">O(N)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">\\Theta(\\log N)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(M+N)</span> time and <span class="math">O(N)</span> space.</li>

    </ul>

    <p class="text-gray-300">The theorem directly implies the existence of linear-time succinct arguments for R1CS over any field, via a known implication that involves combining IOPs and linear-time collision resistant hash functions (used as a black box) <em>[x1]</em>. Such hash functions are known to exist, e.g., under certain assumptions about finding short codewords in linear codes <em>[x1]</em>; moreover, these candidate hash functions are not known to be insecure against quantum adversaries, making the succinct argument plausibly post-quantum secure.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Corollary 1.3 (succinct argument).</h6>

    <p class="text-gray-300">Using any linear-time collision-resistant hash function with security parameter <span class="math">\\lambda</span> as a black box, there is an interactive argument for R1CS over any finite field <span class="math">\\mathbb{F}</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log N)</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- communication complexity is $\\poly(\\lambda,\\log(N)^{2}/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover is a RAM with word length <span class="math">\\Theta(\\log N)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(\\lambda\\log(M+N)+M+N)</span> time and <span class="math">O(N)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">\\Theta(\\log N)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(\\lambda\\log(M+N)+M+N)</span> time and <span class="math">O(N)</span> space.</li>

    </ul>

    <p class="text-gray-300">The second IOP supports the algebraic automata language, which verifies the transition function for an automata using R1CS coefficient matrices. This problem is previously discussed in <em>[x1]</em>, where they construct an IOP with linear proof length and polylogarithmic verification time with respect to the computation time of the corresponding automata.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 1.4.</h6>

    <p class="text-gray-300">The algebraic automata problem over a finite field <span class="math">\\mathbb{F}</span> is as follows: given matrices <span class="math">A,B,C\\in\\mathbb{F}^{w\\times 2w}</span>, a vector <span class="math">x\\in\\mathbb{F}^{w}</span>, and a computation time <span class="math">T</span>, does there exist an execution trace <span class="math">z\\colon[T+1]\\to\\mathbb{F}^{w}</span> such that <span class="math">z(1)=x</span> and <span class="math">A(z(t),z(t+1))\\circ B(z(t),z(t+1))=C(z(t),z(t+1))</span> for every <span class="math">t\\in[T]</span>?</p>

    <p class="text-gray-300">Our second result is an IOP for the algebraic automata problem that achieves linear-time proving and sublinear verification over any field. In comparison, <em>[x1]</em> can only be extended to constant-size fields with an additional logarithmic factor in the proof length. In the context of this problem, since the automata encoded by the matrices are executed <span class="math">T</span> times, we define “linear time” for algebraic automata to be computations that cost no more than <span class="math">O(T)</span> operations in <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-9" class="text-base font-medium mt-4">Theorem 1.5 (main).</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span>, and for every positive constant <span class="math">\\epsilon&gt;0</span>, there is a public-coin IOP (with point queries), for the algebraic automata problem with instances with <span class="math">w=O(1)</span>, that has the following efficiency:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log T)</span>;</li>

      <li>answer alphabet is <span class="math">\\mathbb{F}</span>;</li>

      <li>proof length is <span class="math">O(T)</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- query complexity is $O(\\log(T)^{2}/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover is a RAM with word length <span class="math">\\Theta(\\log T)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(T)</span> time and <span class="math">O(T)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">\\Theta(\\log T)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(T^{\\epsilon})</span> time and <span class="math">O(T^{\\epsilon})</span> space.</li>

    </ul>

    <p class="text-gray-300">Figure 2 compares their IOP with the one we have in Theorem 1.5. As with R1CS, Theorem 1.5 directly implies a succinct argument for R1CS automata.</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Corollary 1.6 (succinct argument).</h6>

    <p class="text-gray-300">For any constant <span class="math">\\epsilon&gt;0</span>, using any linear-time collision-resistant hash function with security parameter <span class="math">\\lambda</span> as a black box, there is an interactive argument for the algebraic automata problem over any finite field <span class="math">\\mathbb{F}</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log T)</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- communication complexity is $\\poly(\\lambda,\\log(T)^{2}/\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover is a RAM with word length <span class="math">\\Theta(\\log T)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(\\lambda\\log(T)+T)</span> time and <span class="math">O(T)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">\\Theta(\\log T)</span> and <span class="math">O(1)</span> registers that runs in <span class="math">O(\\lambda\\log(T)+T^{\\epsilon})</span> time and <span class="math">O(T^{\\epsilon})</span> space.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">execution model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">circuit encoding cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCGGHJ17]</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(√N)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCG20]</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nε) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nε)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCL22]</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[XZS22]</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2N) F-ops†</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(N)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[RR22]</td>

            <td class="px-3 py-2 border-b border-gray-700">circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">not applicable</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops‡</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(N)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 1.2</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">not applicable</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2N)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 1: Comparison of known IOPs with a linear-time prover. The parameters are for an  <span class="math">N</span> -gate arithmetic circuit defined over a field  <span class="math">\\mathbb{F}</span> ; and  <span class="math">\\epsilon</span>  is any positive constant. The sublinear verification in all cases is achieved in the holographic setting (the verifier has oracle access to an encoding of the circuit). For the IOPs modelled using RAM, prover and verifier costs are measured in terms of the equivalent number of operations over  <span class="math">\\mathbb{F}</span> , by dividing the total number of basic RAM operations by the number required to perform a field operation. ( <span class="math">\\dagger</span> : we compare against a preprocessing version of [XZS22] incorporating techniques from [Set20].) ( <span class="math">\\ddagger</span> : see Remark 1.8.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">IOP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">execution model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prover cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">verifier cost</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">query complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">field size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCGGRS19]</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T log T) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">polylog(T) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Ω(T)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[HR22]</td>

            <td class="px-3 py-2 border-b border-gray-700">circuit</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Tε) F-ops</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Tε)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Theorem 1.5</td>

            <td class="px-3 py-2 border-b border-gray-700">RAM</td>

            <td class="px-3 py-2 border-b border-gray-700">O(T) F-ops*</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Tε) F-ops*</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log2T)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Comparison of known IOPs for R1CS automata. The parameters are for an automata with computation time  <span class="math">T</span>  defined over a field  <span class="math">\\mathbb{F}</span> ; and  <span class="math">\\epsilon</span>  is any positive constant. For the IOPs modelled using RAM, prover and verifier costs are measured in terms of the equivalent number of operations over  <span class="math">\\mathbb{F}</span> , by dividing the total number of basic RAM operations by the number required to perform a field operation. ( <span class="math">\\dagger</span> : see Remark 1.8.)</p>

    <p class="text-gray-300">Prior work on linear-time IOPs. Our main results focus on constructing efficient interactive oracle proofs with linear-time provers for R1CS. Several prior works have considered the same goal. First, [BCGGHJ17] obtained an IOP with linear-time prover and square-root verification time for arithmetic circuit satisfiability. Later, [BCG20] and [BCL22] improved this result by achieving sublinear, and then polylogarithmic verification time for R1CS. These works, [BCGGHJ17; BCG20; BCL22], all require nonconstant-size fields. Recently, [RR22] proved a similar result to Theorem 1.2, and constructed an IOP with a linear-time prover for boolean circuit satisfiability, via different techniques. Figure 1 summarizes the properties of the IOPs obtained from these works.</p>

    <p class="text-gray-300">We now carefully discuss how our result differs from the one proved by Ron-Zewi and Rothblum in [RR22]. Note that the comparison below is only between Theorem 1.2 and Theorem 1.7, since their work does not mention sublinear verification and targets only general but not staircase R1CS instances.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1.7 ([RR22, Theorem 3.1]). There is an IOP for proving the satisfiability of a boolean circuit  <span class="math">C</span>  where: soundness error is  <span class="math">O(1)</span> ; round complexity is  $O(\\log</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> ; proof length is  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  over the binary alphabet; query complexity is polylog  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ; and the prover and verifier can be implemented via boolean circuits of size  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  (that can be efficiently computed from  </span>C$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Both Theorem 1.2 and Theorem 1.7 extend the line of works on linear-time IOPs by contributing new tools that enable a constant soundness error over boolean fields. The IOP in [RR22] works for the satisfiability of boolean circuits; however, it could be extended to work with R1CS, the language our IOPs are constructed</p>

    <p class="text-gray-300">for. Meanwhile, we note that the execution models of the IOPs differ. The IOP prover in <em>[x21]</em> is a boolean circuit that can be efficiently obtained from the boolean circuit whose satisfiability is being proved. Our IOP prover is an algorithm for a random-access machine. The <em>[x21]</em> result would also imply a linear-time RAM prover if the linear-size prover circuit can be efficiently generated by a linear-time RAM program. We do not know whether our result implies a corresponding result with circuit prover.</p>

    <p class="text-gray-300">More interestingly, the two results differ significantly in the underlying techniques.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Multi-sumcheck. The IOP in <em>[x21]</em> relies on a multi-sumcheck protocol based on code-switching <em>[x20]</em>, in combination with an arithmetization inspired by <em>[x1]</em>. The multi-sumcheck protocol foregoes the use of multiplication codes (the product of codewords is a codeword from a related code) of super-constant length, relying instead on linear-time encodable codes and repeated use of code-switching to avoid the computational overhead caused by multiplications of long codewords.</li>

      <li>Embedding and precomputation. Our IOP combines ideas from the tensor-to-point-query approach <em>[x1]</em>, which itself is an optimization of the code-switching technique in <em>[x20]</em>, and the embedding techniques in <em>[x7]</em>. This leads to a construction over a field extension that is not too large, and we rely on precomputation to avoid costly multiplications in the extension field. Our IOP construction does use a generalization of the biased generator for boolean fields constructed in <em>[x21]</em>.</li>

    </ul>

    <h6 id="sec-12" class="text-base font-medium mt-4">Remark 1.8.</h6>

    <p class="text-gray-300">The verifier of the IOP in <em>[x21]</em> and the verifier of our IOP for R1CS both run in linear time. This is optimal because the verifier must read the circuit/R1CS description. In both cases it remains an open question whether sublinear verification can additionally be achieved for general R1CS instances. Meanwhile, our IOP for algebraic automata achieve sublinear verification (without holography). We remark that <em>[x21]</em> additionally discuss a model where the verifier performs a <em>private</em> linear-time computation in an offline phase followed by a sublinear-time computation in the online phase. This is a type of preprocessing that many probabilistic proofs satisfy (including our IOP) but we do not discuss this model since it is of limited use.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Concurrent work on linear-time IOPs.</h4>

    <p class="text-gray-300">Recently, <em>[x29]</em> developed new algorithms to improve the efficiency of the linear-time encodings used in linear-time IOPs, modified the proof composition techniques used in <em>[x3]</em>, and produced an efficient implementation of the resulting arguments. Note that while <em>[x29]</em> presents a protocol with linear verification time, it is straightforward to extend this to the results in Figure 1 using techniques from <em>[x26]</em>, leading to the same dependence on large fields as in <em>[x1, x2, x3]</em>.</p>

    <p class="text-gray-300">Our work and <em>[x21]</em> achieve constant soundness error, but can achieve <span class="math">2^{-\\lambda}</span> soundness error with <span class="math">O(\\lambda)\\cdot N</span> prover time via repetition. Recently, <em>[x12]</em> improved the trade-off between the prover overhead and soundness error for special classes of R1CS instances including algebraic automata (referred to as succinct R1CS). They construct an IOP with <span class="math">\\mathsf{polylog}(\\lambda)\\cdot N</span> prover time, <span class="math">2^{-\\lambda}</span> soundness error, and sublinear verification time for R1CS instances whose matrices have a tensor structure. Setting <span class="math">\\lambda=O(1)</span> leads to the results in Figure 2. Their general strategy is to improve the protocol in <em>[x21]</em> by transforming input vectors for several subprotocols into tensor products. They then reduce soundness error by partitioning the tensors into <span class="math">\\Theta(\\lambda)</span> parts and applying the subprotocols to each part independently. Whether there are IOPs for general R1CS instances achieving the same trade-off between prover time and soundness error is an open question.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Prior work on cryptographic proofs with linear-time provers.</h4>

    <p class="text-gray-300">As previously discussed, constructions of linear-time IOPs can be compiled into linear-time succinct arguments using suitable collision resistant hash functions. One can also use more complex cryptographic compilers which involve further composition with succinct arguments. Prior works <em>[x15, x13]</em> apply this strategy to the arguments from <em>[x1]</em>. Among other optimizations, they contribute improved constructions of linear-time encodable codes, which</p>

    <p class="text-gray-300">improve the concrete efficiency of linear-time IOPs and lead to efficient implementations. These works give arguments over large fields.</p>

    <p class="text-gray-300">Another line of work focuses on achieving practical linear-size proofs with linear-time prover algorithms. For example, <em>[x21, x11, x22]</em> provide proof systems for verifying arithmetic circuits over fields of any size, based on vector oblivious linear evaluation protocols. In particular, <em>[x1]</em> also employ embedding techniques. These protocols have a linear-time verifier. Another strategy for achieving linear time prover and verifier complexity in earlier works comes from the MPC-in-the-head paradigm <em>[x12]</em>. Other works such as <em>[x6, x7]</em> provide linear-time provers for statements about RAM executions.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Techniques</p>

    <p class="text-gray-300">We describe the main ideas behind our result.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.1 Starting point: the tensor-query to point-query paradigm</h3>

    <p class="text-gray-300">Our construction follows the same approach as <em>[x1]</em>, first constructing a tensor IOP for <span class="math">\\mathrm{R1CS}</span> with linear time and then compiling it to a standard IOP. This approach is an optimization of both the code-switching technique in <em>[x21]</em>, and the compiler for linear queries on vectors to point queries in <em>[x1]</em>, tailored to this type of construction.</p>

    <p class="text-gray-300">Tensor IOP for <span class="math">\\mathbf{R1CS}</span>. In a tensor IOP, the verifier makes tensor queries to oracle messages sent by the prover. A tensor IOP is parametrized by a field <span class="math">\\mathbb{F}_{p}</span>, where <span class="math">p</span> is an arbitrary prime power, and positive integers <span class="math">k</span> and <span class="math">t</span>. Given a proof message <span class="math">\\Pi\\in\\mathbb{F}_{p}^{k^{t}}</span>, the verifier can make tensor queries of the form <span class="math">q=(q_{1},\\ldots,q_{t})\\in(\\mathbb{F}_{p}^{k})^{t}</span> and receive answer <span class="math">\\langle q_{1}\\otimes\\cdots\\otimes q_{t},\\Pi\\rangle</span>. Recall that for standard IOPs, the verifier uses point queries which allow them to query single locations of proof messages. For <span class="math">\\mathrm{R1CS}</span>, the problem decides whether for given coefficient matrices <span class="math">A,B,C\\in\\mathbb{F}_{p}^{N\\times N}</span> and an instance vector <span class="math">x\\in\\mathbb{F}_{p}^{*}</span>, there exists a witness vector <span class="math">w</span> such that <span class="math">z=(x,w)\\in\\mathbb{F}_{p}^{N}</span> satisfies <span class="math">Az\\circ Bz=Cz</span>. Following the standard approach for designing IOPs for <span class="math">\\mathrm{R1CS}</span>, it suffices for the prover <span class="math">\\mathbf{P}</span> to send <span class="math">z</span> and <span class="math">z_{A},z_{B},z_{C}\\in\\mathbb{F}_{p}^{N}</span> and convince the verifier <span class="math">\\mathbf{V}</span> that <span class="math">z_{A}=Az,z_{B}=Bz,z_{C}=Cz</span>, and <span class="math">z_{A}\\circ z_{B}=z_{C}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Twisted scalar product. All four conditions can be reduced to a relation called the twisted scalar product relation introduced by <em>[x1]</em>, which checks whether <span class="math">\\vec{a},\\vec{b},\\vec{y}\\in\\mathbb{F}_{p}^{n}</span> and <span class="math">\\tau\\in\\mathbb{F}_{p}</span> satisfy <span class="math">\\langle\\vec{a}\\circ\\vec{y},\\vec{b}\\rangle=\\tau</span>. The tensor IOP constructed by <em>[x1]</em> for this relation achieves a soundness error of $\\log N/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">z_{U}=Uz</span>: To check this type of condition, the verifier sends a random challenge <span class="math">r</span> with tensor structure, reducing the conditions to <span class="math">\\langle r,z_{U}\\rangle=\\langle r^{\\intercal}U,z\\rangle</span>, where the left-hand side can be obtained through a tensor query to <span class="math">z_{U}</span>. Then set <span class="math">\\vec{a}=r^{\\intercal}U,\\vec{y}=1^{n},\\vec{b}=z</span> and <span class="math">\\tau=\\langle r,z_{U}\\rangle</span> and invoke the tensor IOP protocol to check that the right-hand side is equal to the left.</li>

      <li><span class="math">z_{A}\\circ z_{B}=z_{C}</span>: This condition is checked by picking a random vector as the twist <span class="math">\\vec{y}</span> and setting <span class="math">\\vec{a}=z_{A},\\vec{b}=z_{B}</span>, and <span class="math">\\tau=\\langle z_{C},\\vec{y}\\rangle</span>.</li>

    </ul>

    <p class="text-gray-300">Tensor IOP to point IOP compiler. After obtaining a tensor IOP for R1CS, <em>[x1]</em> provides a way to efficiently convert the tensor IOP into a standard point IOP by simulating tensor queries via a number of point queries. More specifically, <em>[x1]</em> designs a compiler that takes in a tensor IOP and any linear code whose encoding function is represented by a circuit as inputs, and outputs a point IOP that decides the same language as the tensor IOP up to an overhead in soundness error.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Bottlenecks from <em>[x1]</em>. We cannot directly apply the linear-time IOP of <em>[x1]</em> to constant-size fields. This is because their final construction gives a tensor IOP with soundness error $\\log N/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> due to the soundness error of the twisted scalar product protocol, which compiles to a standard IOP with soundness error </span>N/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$. Therefore, the size of the underlying field has to be large in order for the soundness error to be small. Therefore, to adapt this approach for small fields, we will use an embedding from a small field to a larger field, inspired by <em>[x6]</em>, and then design our IOPs in this larger field.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.2 Overview of techniques</h3>

    <p class="text-gray-300">Recently, <em>[x7]</em> introduced embeddings called reverse-multiplication friendly embeddings (RMFEs) which were later used by <em>[x6]</em> to construct a Reed-Solomon-encoded IOP for <span class="math">R_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}_{2}</span>. RMFEs</p>

    <p class="text-gray-300">are embeddings that transform a vector over a small field to an element in a large field while preserving multiplicative relations. More precisely, the encoding function <span class="math">\\phi\\colon\\mathbb{F}_{2}^{a}\\to\\mathbb{F}_{2^{b}}</span> and decoding function <span class="math">\\psi\\colon\\mathbb{F}_{2^{b}}\\to\\mathbb{F}_{2}^{a}</span> are such that <span class="math">\\vec{x}\\circ\\vec{y}=\\psi(\\phi(\\vec{x})\\phi(\\vec{y}))</span> for all <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}_{2}^{a}</span>. The key idea behind the IOP construction is to embed the <span class="math">R_{\\mathrm{R1CS}}</span> instance matrices and witness vectors into a large field <span class="math">\\mathbb{F}_{2^{b}}</span> via the encoding function. Note that the embedding function <span class="math">\\phi</span> preserves multiplicative relations between embedded vectors, which makes it possible for the IOP to check the relation <span class="math">Az\\circ Bz=Cz</span>.</p>

    <p class="text-gray-300">Further, after the reduction, in addition to equations proving <span class="math">R_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}_{2^{b}}</span>, the prover needs to convince the verifier of some new relations. For instance, the prover needs to show that some given vector <span class="math">\\widetilde{x}</span> is indeed a valid encoding in <span class="math">\\mathrm{Im}(\\phi)</span>. To this end, <em>[x1]</em> introduces a subprotocol called a modular lincheck protocol for all such relations.</p>

    <p class="text-gray-300">Unfortunately the IOP construction in <em>[x1]</em> uses Reed–Solomon codes, which immediately make the prover’s running time superlinear. Additionally, two places in the modular lincheck protocol also incur superlinear operations already.</p>

    <p class="text-gray-300">We get around using Reed–Solomon codes by applying the paradigm of <em>[x3]</em>. We first construct a tensor IOP and then use a tensor-to-point query compiler to obtain an IOP for <span class="math">R_{\\mathrm{R1CS}}</span> over small fields.</p>

    <p class="text-gray-300">The other two problems are caused by an inefficient use of randomized hashing in the modular lincheck protocol, and we solve them by first using a RMFE that has a <em>systematic</em> property and second by replacing the hash function with one that achieves smaller soundness error. The precise definition of a systematic RMFE is given in Section 2.3. More details on the construction of our modular lincheck protocol can be found in Section 2.4.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.3 Systematic reverse-multiplication-friendly embeddings</h3>

    <p class="text-gray-300">In order to tackle the task for finite fields <span class="math">\\mathbb{F}_{p}</span>, we use reverse-multiplication-friendly embeddings (RMFE) introduced by <em>[x1]</em>. As mentioned before, we seek injective mappings from small fields to large fields, to enable techniques similar to those developed in <em>[x3]</em> and <em>[x2]</em> and construct an IOP protocol. More specifically, we use an efficient embedding that allows us to encode <span class="math">a</span> elements in <span class="math">\\mathbb{F}_{p}</span> into one element in <span class="math">\\mathbb{F}_{p^{b}}</span>, where <span class="math">b=O(a)</span>. Then we construct IOPs with tensor queries for <span class="math">\\mathrm{R1CS}</span> over <span class="math">\\mathbb{F}_{p}</span>, which make black-box use of tensor IOPs for the encoded <span class="math">\\mathrm{R1CS}</span> over <span class="math">\\mathbb{F}_{p^{b}}</span>. One thing to be careful about is that operations in the large field are more expensive than those in the original small field. Thus, in order to keep our IOP efficient, we need to precompute the expensive operations, as we will describe in more detail in Section 2.5.</p>

    <p class="text-gray-300">Now we discuss what characteristics we want our RMFEs to possess. First, they should be efficiently encodable to ensure the efficiency of the IOP where they will be used. Moreover, we want them to be systematic. In particular, given a basis of the large field <span class="math">\\mathbb{F}_{p^{b}}</span>, we think of the element as a vector of length <span class="math">b</span>, where each entry in the vector is the coefficient of the <span class="math">i</span>-th basis vector. We say that an RMFE is systematic if the coefficient vector of the encoded element is the original element padded with zeros. This property ensures that the tensor IOP has a linear-time prover. Lastly, we want the embeddings to preserve the component-wise additions and products of the original vectors in the small field <span class="math">\\mathbb{F}_{p}^{a}</span> so that relations such as <span class="math">\\langle x,y\\rangle</span> are preserved. Keeping these properties in mind, we now present the formal definition of <span class="math">(a,b)_{p}</span>-RMFE given in <em>[x1]</em> and also our definition of systematic <span class="math">(a,b)_{p}</span>-RMFE.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2.1 (<em>[x1, Definition 1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime power and <span class="math">\\mathbb{F}_{p}</span> a field with <span class="math">p</span> elements. Let <span class="math">a,b\\geq 1</span> be integers. A pair <span class="math">(\\phi,\\psi)</span> is called a <span class="math">(a,b)_{p}</span>-reverse-multiplication-friendly embedding (RMFE) if <span class="math">\\phi\\colon\\mathbb{F}_{p}^{a}\\to\\mathbb{F}_{p^{b}}</span> and <span class="math">\\psi\\colon\\mathbb{F}_{p^{b}}\\to\\mathbb{F}_{p}^{a}</span> are both <span class="math">\\mathbb{F}_{p}</span>-linear maps such that for all <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}_{p}^{a}</span>,</p>

    <p class="text-gray-300"><span class="math">\\vec{x}\\circ\\vec{y}=\\psi(\\phi(\\vec{x})\\cdot\\phi(\\vec{y}))\\;\\;.</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Note that this definition ensures that RMFEs preserve component-wise additions and products, as described in the previous paragraph. Therefore, in our later discussion, we on efficient encoding and the systematic property.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 2.2.</h6>

    <p class="text-gray-300">An <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span> is systematic if there exists a basis <span class="math">\\{e_{j}\\}_{j\\in[b]}</span> of the <span class="math">\\mathbb{F}_{p}</span>-linear space <span class="math">\\mathbb{F}_{p^{b}}</span> such that for every element <span class="math">\\vec{x}=(x_{1},\\ldots,x_{a})\\in\\mathbb{F}_{p}^{a}</span> it holds that <span class="math">\\phi(\\vec{x})=(x_{1},\\ldots,x_{a},0,\\ldots,0)</span>, where the <span class="math">i</span>-th entry of <span class="math">\\phi(\\vec{x})</span> is the coefficient with respect to the <span class="math">i</span>-th basis vector <span class="math">e_{i}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that this definition implies that systematic RMFE encodes a vector <span class="math">\\vec{x}</span> over <span class="math">\\mathbb{F}_{p}</span> into an element in <span class="math">\\mathbb{F}_{p^{b}}</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\vec{x}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{0}<span class="math"> non-zero coefficients in basis </span>\\mathsf{E}$. Therefore, the cost of writing down the encoded vector is linear in terms of the input vector, which we can afford.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Warmup: systematic RMFE based on polynomial interpolation. We outline a simple RMFE construction based on polynomial interpolation from <em>[x10]</em>, and explain how to make it systematic.</p>

    <p class="text-gray-300">Fix <span class="math">k</span> distinct elements <span class="math">(\\alpha_{1},\\ldots,\\alpha_{k})</span> in <span class="math">\\mathbb{F}_{p}</span> and <span class="math">\\zeta\\in\\mathbb{F}_{p^{2k-1}}</span> such that <span class="math">\\mathbb{F}_{p^{2k-1}}=\\mathbb{F}_{p}(\\zeta)</span>. The encoding map <span class="math">\\phi_{\\mathrm{int}}</span> works a follows: on input <span class="math">(x_{1},\\ldots,x_{a})\\in\\mathbb{F}_{p}^{a}</span>, compute the polynomial <span class="math">f</span> over <span class="math">\\mathbb{F}_{p}[X]_{&lt;k}</span> such that <span class="math">f(\\alpha_{i})=x_{i}</span> for all <span class="math">1\\leq i\\leq k</span>, and output <span class="math">f(\\zeta)</span>. The decoding map <span class="math">\\psi_{\\mathrm{int}}</span> takes an element <span class="math">\\beta</span> in <span class="math">\\mathbb{F}_{p^{2k-1}}</span> and determines the unique polynomial <span class="math">f</span> in <span class="math">\\mathbb{F}_{p}[X]_{&lt;2k-1}</span> such that <span class="math">\\beta=f(\\zeta)</span> and outputs <span class="math">(f(\\alpha_{1}),\\ldots,f(\\alpha_{k}))</span>. Intuitively, this forms an RMFE because the image of <span class="math">\\phi_{\\mathrm{int}}</span> is the set of elements <span class="math">\\beta=f(\\zeta)\\in\\mathbb{F}_{p^{2k-1}}</span> where <span class="math">\\deg f\\leq a-1</span>, which implies that the product of <span class="math">f(\\zeta),g(\\zeta)\\in\\mathrm{Im}\\phi_{\\mathrm{int}}</span> is represented as <span class="math">(f\\cdot g)(\\zeta)</span> since <span class="math">\\deg f\\cdot g&lt;2k-1</span>. Therefore, applying <span class="math">\\psi_{\\mathrm{int}}</span> will evaluate <span class="math">f\\cdot g</span> at <span class="math">\\alpha_{i}</span> as desired. Both maps are efficiently computable because polynomial interpolation is efficient.</p>

    <p class="text-gray-300">Is it systematic? This RMFE is, in general, not systematic. For example, consider the canonical basis <span class="math">\\{1,\\zeta,\\ldots,\\zeta^{k-1},\\ldots,\\zeta^{(2k-1)-1}\\}</span> for <span class="math">\\mathbb{F}_{p^{2k-1}}</span>. Assume for the sake of contradiction that this basis satisfies the systematic property. Then following Definition 2.2, it must be that <span class="math">\\phi^{\\prime}(\\alpha)=(\\alpha_{1},\\ldots,\\alpha_{a},0,\\ldots,0)=\\sum_{i=1}^{a}\\alpha_{i}\\zeta^{i-1}</span> for <span class="math">\\alpha=(\\alpha_{1},\\ldots,\\alpha_{a})</span>. However, according to the construction, we know that <span class="math">\\phi(\\alpha)=\\sum_{i=1}^{k}\\alpha_{i}L_{i}(\\zeta)</span> where <span class="math">L_{i}(\\zeta)=\\Pi_{1\\leq j\\leq k\\atop j\\neq i}\\frac{\\zeta-\\alpha_{j}}{\\alpha_{i}-\\alpha_{j}}</span> is the <span class="math">i</span>-th Lagrange polynomial. One can find some <span class="math">\\alpha\\in\\mathbb{F}_{p}^{a}</span> such that <span class="math">\\phi^{\\prime}(\\alpha)\\neq\\phi(\\alpha)</span>, which shows that this basis does not give us the systematic property.</p>

    <p class="text-gray-300">Making it systematic. Suppose that we change the canonical basis such that the first <span class="math">k</span> elements are replaced by the Lagrange basis. Then each element in the image of the encoding can be represented as a linear combination of the first <span class="math">k</span> elements in the basis, and the coefficient vector in the linear combination is exactly the input vector. With this change, the RMFE based on polynomial interpolation achieves the systematic property.</p>

    <p class="text-gray-300">Why the above RMFE does not suffice. The RMFE based on polynomial interpolation requires the base field <span class="math">\\mathbb{F}_{p}</span> to have size at least <span class="math">k</span> (which can be improved to size at least <span class="math">k-1</span> as in Section 4.1) as there have to be enough distinct elements for the interpolation. However, in this paper we will need to use embeddings for super-constant <span class="math">k</span> and constant-sized base fields <span class="math">\\mathbb{F}_{p}</span>. Therefore we cannot use this RMFE based on polynomial interpolation.</p>

    <p class="text-gray-300">A systematic RMFE based on AG codes. In this paper we use an RMFE based on algebraic geometry (AG) codes from <em>[x10]</em>, which we show can be made systematic. Informally, instead of using elements of a finite field, the RMFE based on AG codes uses rational places in algebraic function fields. The embedding outputs the evaluation of the polynomial uniquely determined by the input at a place with high degree, which is similar to the case in the previous construction where it takes the value of the Lagrange-interpolated polynomial at <span class="math">\\alpha</span>. In the more detailed explanation of this construction in Definition 4.6, we use tools from algebraic geometry, such as divisors, Riemann–Roch spaces, Ihara’s constant, etc. to justify the properties we need. We postpone the full construction and detailed proof to Section 4.</p>

    <p class="text-gray-300">2.4 A tensor IOP for R1CS over small fields</p>

    <p class="text-gray-300">We use RMFEs to construct a tensor-query IOP for R1CS over any field. Below we summarize the result and construction, leaving technical details for Section 6.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 2.3 (informal).</h6>

    <p class="text-gray-300">A <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP is an IOP in which the prover sends <span class="math">\\Pi_{i}\\in\\mathbb{F}^{\\ell_{i}\\cdot k^{t}}</span> for some positive integer <span class="math">\\ell_{i}</span> and the verifier queries <span class="math">\\langle v_{0}\\otimes v_{1}\\otimes\\cdots\\otimes v_{t},\\Pi_{i}\\rangle</span> for <span class="math">v_{0}\\in\\mathbb{F}^{\\ell_{i}}</span> and <span class="math">v_{1},\\ldots,v_{t}\\in\\mathbb{F}^{k}</span>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Theorem 2.4 (informal).</h6>

    <p class="text-gray-300">Let <span class="math">\\phi\\colon\\mathbb{F}_{p}^{a}\\to\\mathbb{F}_{p^{b}}</span> be an RMFE, where <span class="math">b=O(a)</span> and the finite field <span class="math">\\mathbb{F}_{p^{b}}</span> has size <span class="math">p^{b}\\in\\Omega(\\log N)</span>. There exists a <span class="math">(\\mathbb{F}_{p^{b}},k,t)</span>-tensor IOP for <span class="math">\\mathrm{R1CS}</span> instances of size <span class="math">N</span> with <span class="math">M</span> non-zero entries over <span class="math">\\mathbb{F}_{p}</span> with the parameters below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log(N/a))</span>;</li>

      <li>proof length is <span class="math">O(N/a)</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span>;</li>

      <li>query complexity is <span class="math">O(1)</span>;</li>

      <li>the prover sends <span class="math">O(\\log(N/a))</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span> as non-oracle messages;</li>

      <li>the prover uses <span class="math">O(M+N)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tN/a)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier uses <span class="math">O(M+N)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tk)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(\\log(N/a))</span> over <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">O(\\log(N/a))</span> over <span class="math">\\mathbb{F}_{p}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prior constructions of tensor-query IOPs work only for large enough fields <em>[x1, x2, x3]</em>. Briefly, the use of the sumcheck protocol introduces a soundness error of $\\Omega(\\frac{\\log N}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">; moreover, holographic techniques to achieve sublinear verification introduce an even larger soundness error of </span>\\Omega(\\frac{N}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Straightforwardly expressing an <span class="math">\\mathrm{R1CS}</span> problem over <span class="math">\\mathbb{F}_{p}</span> as an R1CS problem over a large enough extension field leads to instances of more than linear size, and therefore does not suffice for our goal of linear-time IOPs. We show that, nevertheless, a more refined <em>embedding approach</em> does suffice.</p>

    <p class="text-gray-300">Starting point: embedding <span class="math">\\mathrm{R1CS}</span> from <em>[x4]</em>. Cascudo and Giunta <em>[x4]</em> rely on RMFEs to construct a linear-size IOP based on the Reed–Solomon code for <span class="math">R_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}_{p}</span> for <span class="math">p=2</span>. Their IOP is not linear-time due to the use of the Reed–Solomon code. Yet their approach directly inspires our linear-time tensor IOP construction, and so we summarize their approach here as a starting point, generalised from <span class="math">p=2</span> to any <span class="math">p</span>.</p>

    <p class="text-gray-300">The idea in <em>[x4]</em> is to use an RMFE embedding <span class="math">\\phi</span> to embed the coefficient matrices <span class="math">A,B,C</span> and the witness vector <span class="math">z</span> into a field <span class="math">\\mathbb{F}_{p^{b}}</span> where <span class="math">p^{b}=\\Omega(\\log(N))</span>, and then show that <span class="math">\\phi(A)\\phi(z)\\circ\\phi(B)\\phi(z)=\\phi(C)\\phi(z)</span>, where <span class="math">\\phi</span> is applied to matrices row-wise (so that the dimensions of the matrix multiplications match). We call this new problem over the large field <em>modular <span class="math">\\mathrm{R1CS}</span></em>. Then one can construct an IOP for modular <span class="math">R_{\\mathrm{R1CS}}</span> over the large field <span class="math">\\mathbb{F}_{p^{b}}</span>. To make this reduction work, the prover additionally needs to prove relations of the form <span class="math">\\widetilde{x}\\in\\mathrm{Im}(\\phi)</span> for <span class="math">\\widetilde{x}</span> that is claimed to be an embedded vector. Since <span class="math">\\phi</span> is a linear function, <em>[x4]</em> introduces a subprotocol called modular lincheck to prove statements of the form <span class="math">\\widetilde{A}\\widetilde{x}\\in V^{\\lambda}</span> where <span class="math">V</span> is a <span class="math">\\mathbb{F}_{p}</span>-linear subspace of <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">\\lambda</span> is the dimension of the resulting vector being checked. We will now explain this subprotocol in more detail.</p>

    <p class="text-gray-300">The modular lincheck in <em>[x4]</em>. Consider a matrix <span class="math">A\\in\\mathbb{F}_{p}^{N\\times N}</span> with <span class="math">M</span> non-zero entries, a vector <span class="math">x\\in\\mathbb{F}_{p}^{N}</span>, a <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span>, and a <span class="math">\\mathbb{F}_{p}</span>-linear subspace <span class="math">V\\subseteq\\mathbb{F}_{p^{b}}</span>. Let <span class="math">\\widetilde{A}\\in\\mathbb{F}_{p^{b}}^{N\\times N/a}</span> and <span class="math">\\widetilde{x}\\in\\mathbb{F}_{p^{b}}^{N/a}</span> be the alleged embeddings of <span class="math">A</span> and <span class="math">x</span>. The modular lincheck protocol checks whether <span class="math">\\widetilde{A}\\widetilde{x}\\in V^{N}</span>.</p>

    <p class="text-gray-300">The usual approach to testing a linear relation of the form <span class="math">Ax=b</span> is <em>linear hashing</em>: the IOP verifier samples a random matrix <span class="math">R</span> and then asks the prover to show that <span class="math">R(Ax-b)=0</span>. In the context of a modular lincheck, the IOP verifier samples a random matrix <span class="math">R\\in\\mathbb{F}_{p^{b}}^{\\lambda\\times N}</span>. It first checks that <span class="math">R\\widetilde{A}\\widetilde{x}=y</span> for some <span class="math">y\\in\\mathbb{F}_{p^{b}}^{\\lambda}</span> using a lincheck protocol adapted from the one in <em>[x1]</em> with input matrix <span class="math">R\\widetilde{A}</span> and</p>

    <p class="text-gray-300">vector <span class="math">\\widetilde{x}</span> and designated matrix-vector product <span class="math">y</span>. We define <span class="math">\\epsilon_{\\text{\\tiny LC}}</span> to be the soundness error of this check. Then the verifier checks that <span class="math">y\\in V^{\\lambda}</span>. Since <span class="math">V</span> is a <span class="math">\\mathbb{F}_{p}</span>-linear space, <span class="math">R</span> needs to be sampled from <span class="math">\\mathbb{F}_{p}^{\\lambda\\times N}</span> to ensure that <span class="math">R\\widetilde{A}\\widetilde{x}\\in V^{\\lambda}</span> whenever <span class="math">\\widetilde{A}\\widetilde{x}\\in V^{N}</span>.</p>

    <p class="text-gray-300">The linear hashing matrix <span class="math">R\\in\\mathbb{F}_{p}^{\\lambda\\times N}</span> in <em>[x10]</em> is sampled as follows. Sample an element <span class="math">\\alpha\\in\\mathbb{F}_{p^{\\lambda}}</span> uniformly at random. The field <span class="math">\\mathbb{F}_{p^{\\lambda}}\\cong\\mathbb{F}_{p}[X]/(P)</span> for some irreducible polynomial <span class="math">P</span> over <span class="math">\\mathbb{F}_{p}</span>, and every element <span class="math">f\\in\\mathbb{F}_{p}[X]/(P)</span> has a matrix representation <span class="math">M_{f}\\in\\mathbb{F}_{p}^{\\lambda\\times\\lambda}</span> such that for any <span class="math">g=\\sum_{i=0}^{\\lambda-]}a_{i}X^{i}\\in\\mathbb{F}_{p}[X]/(P)</span> with associated coefficient vector <span class="math">\\vec{g}</span>, <span class="math">M_{f}\\cdot\\vec{g}</span> is the coefficient vector for <span class="math">f\\cdot g\\in\\mathbb{F}_{p}[X]/(P)</span>. The matrix <span class="math">R</span> is then defined by horizontally concatenating the matrices <span class="math">M_{\\alpha},M_{\\alpha^{2}},\\ldots,M_{\\alpha^{N}}</span>.</p>

    <p class="text-gray-300">This choice of <span class="math">R</span> guarantees that this check has soundness error bounded by <span class="math">\\frac{N/\\lambda}{p^{\\lambda}}</span>. Here <span class="math">N/\\lambda</span> is the highest degree of <span class="math">\\alpha</span> that is used to generate <span class="math">R</span> and <span class="math">p^{\\lambda}</span> is the order of the field that <span class="math">\\alpha</span> is sampled from. Thus, the overall modular lincheck protocol has soundness error <span class="math">\\frac{N/\\lambda}{p^{\\lambda}}+\\epsilon_{\\text{\\tiny LC}}</span>.</p>

    <p class="text-gray-300">Finally we note that the modular lincheck protocol in <em>[x10]</em> is a Reed–Solomon encoded IOPP. Namely the verifier’s oracle is encoded by a Reed–Solomon code, and the oracle is accessed via point queries. This protocol can be converted to a tensor IOP by observing that a point query to a Reed–Solomon encoding of <span class="math">\\Pi</span> can be simulated by a tensor query to <span class="math">\\Pi</span>. Thus we can extract a tensor IOP to test the same relation.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">Our construction.</h4>

    <p class="text-gray-300">It is tempting to directly combine the modular lincheck protocol from <em>[x10]</em> and the linear-time tensor IOP from <em>[x3]</em> to get a linear-time tensor IOP for <span class="math">R_{\\text{\\tiny R1CS}}</span> over <span class="math">\\mathbb{F}_{p}</span>. This, however, does not work. We describe the main problems that arise and how we solve them.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Problem 1: computing <span class="math">\\phi(A)</span> and <span class="math">R\\phi(A)</span> takes superlinear time.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For certain instance matrices <span class="math">A</span>, a naive <span class="math">(a,b)_{p}</span>-RMFE <span class="math">\\phi</span> would make the prover’s time superlinear. Consider a matrix <span class="math">A\\in\\mathbb{F}_{p}^{N\\times N}</span> with <span class="math">M</span> non-zero entries, and recall that <span class="math">\\phi</span> is applied to <span class="math">A</span> row-wise. If any two non-zero elements in the same row of <span class="math">A</span> are <span class="math">a</span>-entries apart from each other, then <span class="math">\\phi(A)\\in\\mathbb{F}_{p^{b}}^{N\\times N/a}</span> also has <span class="math">M</span> non-zero elements in <span class="math">\\mathbb{F}_{p^{b}}</span>. The embedding takes a matrix <span class="math">A</span> with <span class="math">M</span> elements in <span class="math">\\mathbb{F}_{p}</span> to a matrix <span class="math">\\phi(A)</span> with <span class="math">M</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span>. If we naively write down <span class="math">\\phi(A)</span> as elements in <span class="math">\\mathbb{F}_{p^{b}}</span>, this step alone would take <span class="math">O(M)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations which could cost at least <span class="math">bM</span> <span class="math">\\mathbb{F}_{p}</span>-operations. Since $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^{b}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Omega(\\log N)<span class="math">, this step incurs superlinear cost in </span>M$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, passing <span class="math">\\phi(A)</span> to the tensor IOP for the modular <span class="math">R_{\\text{\\tiny R1CS}}</span> over <span class="math">\\mathbb{F}_{p^{b}}</span> would result in the prover having arithmetic complexity <span class="math">\\Theta(M)</span> over <span class="math">\\mathbb{F}_{p^{b}}</span>: in the modular lincheck protocol the prover computes the product <span class="math">R\\phi(A)</span> (for <span class="math">R\\in\\mathbb{F}_{p}^{\\lambda\\times N}</span> and <span class="math">\\phi(A)\\in\\mathbb{F}_{p^{b}}^{N\\times N/a}</span>) which takes <span class="math">\\lambda M</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span>. This step is also superlinear in <span class="math">M</span> over <span class="math">\\mathbb{F}_{p}</span> when $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^{b}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\Omega(\\log N)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Solution: systematic RMFEs.</h4>

    <p class="text-gray-300">We rely on a systematic RMFE with basis <span class="math">\\mathsf{E}</span> (discussed in Section 2.3) in order to write down <span class="math">\\phi(A)</span> and compute <span class="math">R\\phi(A)</span> in linear time. First we represent every element in <span class="math">\\mathbb{F}_{p^{b}}</span> in the basis <span class="math">\\mathsf{E}</span>. Recall that <span class="math">\\mathsf{E}</span> is a basis for the <span class="math">\\mathbb{F}_{p}</span>-linear space <span class="math">\\mathbb{F}_{p^{b}}</span>. For any field element <span class="math">f\\in\\mathbb{F}_{p^{b}}</span> we use <span class="math">\\mathsf{E}(f)\\in\\mathbb{F}_{p}^{b}</span> to denote <span class="math">f</span>’s coefficient vector under <span class="math">\\mathsf{E}</span>, and for any matrix <span class="math">H</span> in <span class="math">\\mathbb{F}_{p^{b}}^{x\\times y}</span> we use <span class="math">\\mathsf{E}(H)\\in\\mathbb{F}_{p}^{x\\times by}</span> to denote the representation of <span class="math">H</span> such that each entry is encoded by the corresponding coefficient vector under <span class="math">\\mathsf{E}</span>.</p>

    <p class="text-gray-300">Since the RMFE <span class="math">\\phi</span> is systematic with respect to <span class="math">\\mathsf{E}</span>, for any matrix <span class="math">A</span> with <span class="math">M</span> non-zero entries, <span class="math">\\mathsf{E}(\\phi(A))</span> also has <span class="math">M</span> non-zero entries. Thus writing down <span class="math">\\mathsf{E}(\\phi(A))</span> takes <span class="math">O(M)</span> <span class="math">\\mathbb{F}_{p}</span>-operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Additionally, since <span class="math">\\mathbb{F}_{p^{b}}</span> is <span class="math">\\mathbb{F}_{p}</span>-linear, for every <span class="math">f\\in\\mathbb{F}_{p^{b}}</span> and <span class="math">e\\in\\mathbb{F}_{p}</span>, <span class="math">\\mathsf{E}(ef)=e\\mathsf{E}(f)</span> where the multiplication of <span class="math">e</span> by <span class="math">\\mathsf{E}(f)</span> is performed over <span class="math">\\mathbb{F}_{p}</span>. Then computing <span class="math">\\mathsf{E}(R\\phi(A))=R\\mathsf{E}(\\phi(A))</span> requires only <span class="math">\\lambda M</span> operations over <span class="math">\\mathbb{F}_{p}</span>. For addition of two elements over the large field, as discussed in Section 2.3, given a vector <span class="math">v\\in\\mathbb{F}_{p}^{a}</span>, the given systematic RMFE would encode it into an element in <span class="math">\\mathbb{F}_{p^{b}}</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{0}<span class="math"> non-zero coefficients in basis </span>\\mathsf{E}$. Therefore, we only need to do a linear number of additions of the coefficients to add two elements over the large field. Each addition requires a linear number of operations, which is not problematic.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-25" class="text-base font-medium mt-4">Problem 2: super constant <span class="math">\\lambda</span>.</h6>

    <p class="text-gray-300">Now that computing <span class="math">R\\phi(A)</span> takes <span class="math">O(\\lambda M)</span> <span class="math">\\mathbb{F}_{p}</span>-operations, <span class="math">\\lambda</span> must be a constant for the prover and the verifier to run in time linear in <span class="math">M</span>. However, in the Boolean case, as analysed in the modular lincheck protocol above, <span class="math">\\lambda</span> needs to be at least <span class="math">\\log N</span> for the soundness error <span class="math">\\frac{N}{\\lambda p^{\\lambda}}</span> to be non-trivial.</p>

    <p class="text-gray-300">Solution: subspace biased generators. We use an alternative random hashing matrix. We conceptualize the linear hashing step, and come up with a useful definition of a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generator <span class="math">G_{\\mathsf{sub}}</span>, which generates random hashing matrices <span class="math">R</span> such that for any <span class="math">\\mathbb{F}_{p}</span>-linear subspace <span class="math">V\\subseteq\\mathbb{F}_{p^{b}}</span> and <span class="math">z\\not\\in V^{N}</span>, we have <span class="math">\\Pr_{R\\leftarrow G_{\\mathsf{sub}}(\\mathbb{F}_{p^{\\lambda}}^{s})}[Rz\\in V^{\\lambda}]\\leq\\epsilon_{\\mathsf{sub}}</span>. This definition fully captures the required property of the linear hashing matrix. We also provide a generic construction of a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generator for any constant integers <span class="math">p</span> and <span class="math">\\lambda</span>, and any constant soundness error <span class="math">\\epsilon_{\\mathsf{sub}}&gt;\\frac{1}{p^{\\lambda}}</span> that additionally has arithmetic complexity <span class="math">O_{\\lambda,p,\\epsilon_{\\mathsf{sub}}}(N)</span>. So replacing the random <span class="math">R</span> in <em>[x10]</em> with the output of such a generator <span class="math">G_{\\mathsf{sub}}</span> ensures that <span class="math">\\lambda</span> is a constant and that the soundness error is non-trivial.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">2.5 Eliminating overhead through precomputation</h3>

    <p class="text-gray-300">In fact, the techniques described above generalise from binary fields to any finite field <span class="math">\\mathbb{F}_{p}</span>. Given a systematic <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span> with basis <span class="math">\\mathsf{E}</span>, where <span class="math">b=\\eta\\cdot a</span> for some constant <span class="math">\\eta</span>, we can construct an IOP with prover arithmetic complexity <span class="math">O(M)</span> operations over <span class="math">\\mathbb{F}_{p}</span> and <span class="math">O(N/b)</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span>. To offset the soundness error mentioned in Section 2.1, we have <span class="math">b\\in\\Omega(\\log\\log N)</span>.</p>

    <p class="text-gray-300">Our main theorem requires prover arithmetic complexity <span class="math">O(M)</span> operations over <span class="math">\\mathbb{F}_{p}</span>. Consider the cost of <span class="math">O(N/b)</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span> measured over <span class="math">\\mathbb{F}_{p}</span>. Clearly, <em>addition</em> operations over <span class="math">\\mathbb{F}_{p^{b}}</span> costs <span class="math">O(b)</span> operations over <span class="math">\\mathbb{F}_{p}</span>, regardless of the <span class="math">\\mathbb{F}_{p}</span>-basis used to represent elements of <span class="math">\\mathbb{F}_{p^{b}}</span>. Therefore, <span class="math">O(N/b)</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span> translates to <span class="math">O(M)</span> operations over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">However, since <span class="math">b</span> is super-constant, each <em>multiplication</em> operation over <span class="math">\\mathbb{F}_{p^{b}}</span> costs a superlinear (in <span class="math">b</span>) number of basic operations over <span class="math">\\mathbb{F}_{p}</span>. For example, in the standard basis, it costs <span class="math">O(b^{2})</span> operations in <span class="math">\\mathbb{F}_{p}</span> to multiply <span class="math">x_{1}</span> and <span class="math">x_{2}\\in\\mathbb{F}_{p^{b}}</span> using a schoolbook multiplication algorithm. Since the IOP described above uses <span class="math">O(N/b)</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span>, this translates to <span class="math">O(bN)</span> prover operations over <span class="math">\\mathbb{F}_{p}</span>, which could be as much as <span class="math">N\\log\\log N</span>! Even the best known multiplication algorithm by <em>[x20]</em> requires <span class="math">O(b\\log b)</span> operations, which would lead to <span class="math">N\\log^{3}N</span> prover operations. In fact, <em>[x1]</em> gives evidence that multiplication in <span class="math">O(b\\log b)</span> operations is optimal under a central conjecture in network coding theory; any improvement over this bound would be a breakthrough result. Therefore, we cannot hope for our tensor IOP to achieve linear prover complexity simply by using better algorithms over <span class="math">\\mathbb{F}_{p^{b}}</span>.</p>

    <p class="text-gray-300">Precomputing multiplication tables. We address this problem by observing that we can afford to precompute <em>every possible operation</em> over <span class="math">\\mathbb{F}_{p^{b}}</span> in <span class="math">O(N)</span> operations over <span class="math">\\mathbb{F}_{p}</span>, if <span class="math">b</span> is <em>sufficiently small</em>. Then, instead of performing each of the <span class="math">O(N/b)</span> operations over <span class="math">\\mathbb{F}_{p^{b}}</span> from scratch, one can simply retrieve the result of each operation over <span class="math">\\mathbb{F}_{p^{b}}</span> from a precomputed look-up table. We formalize this approach by modeling algorithms as random-access machines, and providing straightforward statements about precomputation.</p>

    <p class="text-gray-300">The multiplication table for <span class="math">\\mathbb{F}_{p^{b}}</span> is a matrix of size <span class="math">p^{b}\\times p^{b}</span>. Computing each entry of the matrix costs <span class="math">O(b^{2})</span> operations over <span class="math">\\mathbb{F}_{p}</span> via the naive multiplication algorithm, leading to a total precomputation cost of <span class="math">O(b^{2}p^{2b})</span> operations over <span class="math">\\mathbb{F}_{p}</span>. Afterwards, the result of any multiplication over <span class="math">\\mathbb{F}_{p^{b}}</span> can be loaded from the lookup table stored in memory in <span class="math">O(1)</span> operations.</p>

    <p class="text-gray-300">For <span class="math">b=\\frac{1}{2}\\log N-o(\\log N)</span>, we have <span class="math">O(b^{2}p^{2b})=O(N)</span>, giving a linear time complexity. Note that this places a strict upper limit of <span class="math">\\mathbb{F}_{p^{b}}&lt;\\sqrt{N}</span> on the size of the extension fields used in our tensor IOP.</p>

    <p class="text-gray-300">The technical details for precomputation for RAM are in Section 9.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">2.6 Algebraic automata</h3>

    <p class="text-gray-300">The previous sections strive to optimize the running time of the prover, but verification time is also an important efficiency parameter that we want to improve. Although we do not know how to improve verification time for general R1CS instances, we explain how to achieve sublinear verification for algebraic automata.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">From algebraic automata to R1CS.</h4>

    <p class="text-gray-300">Since an algebraic automata instance is defined in a similar way to an R1CS instance, we are able to reduce an algebraic automata instance to a special R1CS instance. Let <span class="math">M</span> be a matrix in <span class="math">\\{A,B,C\\}\\subset\\mathbb{F}^{w\\times 2w}</span> and <span class="math">z:[T+1]\\to\\mathbb{F}^{w}</span>. Definition 1.4 computes <span class="math">M(z(t),z(t+1))</span> for every computation time step <span class="math">t</span>. If we view <span class="math">z</span> as a vector in <span class="math">\\mathbb{F}^{w(T+1)}</span>, right-multiplying <span class="math">z</span> by a large matrix <span class="math">S_{M}</span> in which the diagonal entries are <span class="math">T</span> repeated blocks of <span class="math">M</span> gives a tall vector with all desired <span class="math">M(z(t),z(t+1))</span>. More formally, <span class="math">S_{M}=[M,\\ldots,M]</span> is a diagonal matrix of dimension <span class="math">wT\\times w(T+1)</span>. Therefore, we could rewrite the algebraic automata constraints as <span class="math">S_{A}z\\circ S_{B}z=S_{C}z</span>, which is an R1CS instance where the matrices have special structure.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Holographic tensor IOP for algebraic automata.</h4>

    <p class="text-gray-300">We previously described a tensor IOP for general R1CS instances. The tensor IOP has a linear-time verifier due to the subprotocol checking <span class="math">\\phi(A)\\vec{x}=\\vec{x}_{A}</span>. The general approach to checking equations of this form is to check that for some random vector <span class="math">r</span>, <span class="math">r^{\\intercal}\\phi(A)\\vec{x}=r^{\\intercal}\\vec{x}_{A}</span>. While the right hand side can be verified efficiently by using relatively standard techniques, computing the left hand side naively could take time linear in the number of non-zero entries in <span class="math">\\phi(A)</span>. One general strategy taken by <em>[x1]</em> is to rewrite the quadratic form as</p>

    <p class="text-gray-300"><span class="math">r^{\\intercal}\\phi(A)\\vec{x}=\\sum_{i}r(\\mathrm{row}_{A}(i))\\mathrm{val}_{A}(i)\\vec{x}(\\mathrm{col}_{A}(i)),</span></p>

    <p class="text-gray-300">where <span class="math">\\mathrm{val}_{A}</span> is a vector of all the nonzero entries in <span class="math">\\phi(A)</span>, <span class="math">\\mathrm{row}_{A}</span> is the vector of their row indices, and <span class="math">\\mathrm{col}</span> is the vector of their column indices. Given the vectors <span class="math">r(\\mathrm{row}_{A}(<em>))</span>, <span class="math">\\mathrm{val}_{A}</span>, and <span class="math">\\vec{x}(\\mathrm{col}_{A}(</em>))</span> the verifier can efficiently check the value of the right hand side via standard procedures. The hard part is to check that <span class="math">r(\\mathrm{row}_{A}(<em>))</span> and <span class="math">\\vec{x}(\\mathrm{col}_{A}(</em>))</span> are correctly generated given <span class="math">r</span> and <span class="math">\\vec{x}</span>. Previous works <em>[x1, x2]</em> have used look-up protocols to check this relation. However those protocols crucially rely on <span class="math">\\Omega(n)</span> size fields. We cannot afford to embed into such large fields due to the overhead in the precomputation phase. So instead, we look at the special case of staircase matrices <span class="math">\\phi(A)</span> for which <span class="math">r(\\mathrm{row}_{A}(<em>))</span> and <span class="math">\\vec{x}(\\mathrm{col}_{A}(</em>))</span> are well-structured. Essentially, when <span class="math">\\phi(A)</span> is a staircase matrix, it can be decomposed into two almost-diagonal matrices <span class="math">\\phi(A)_{0}+\\phi(A)_{1}</span>. Their corresponding row index vectors satisfy <span class="math">r(\\mathrm{row}_{0}(<em>))=r(\\mathrm{row}_{1}(</em>))=r([1,\\ldots,n])=r</span>, and their column index vectors satisfy <span class="math">\\vec{x}(\\mathrm{col}_{0}(<em>))=\\vec{x}=\\mathrm{shift}(\\vec{x}(\\mathrm{col}_{1}(</em>)))</span>. Specifically, <span class="math">\\mathrm{col}_{0}(<em>)=[1,2\\ldots,n-1]</span> and <span class="math">\\mathrm{col}_{0}(</em>)=[2,3\\ldots,n]</span>. So we design a cyclic shift protocol to check this shift relation for instances over small fields.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Shift protocol over small fields.</h4>

    <p class="text-gray-300">We require a tensor IOP protocol for the following relation.</p>

    <h6 id="sec-31" class="text-base font-medium mt-4">Definition 2.5.</h6>

    <p class="text-gray-300">The shift relation <span class="math">R_{\\circlearrowleft}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})=(\\perp,(\\mathbb{F},s,N),(a,b))</span></p>

    <p class="text-gray-300">where <span class="math">N=k^{t}</span>, <span class="math">b\\in\\mathbb{F}^{N}</span> is the cyclic shift of <span class="math">a\\in\\mathbb{F}^{N}</span>, which we denote <span class="math">b=\\mathrm{shift}(a)</span>, if for all <span class="math">i\\in[N-s]</span>, it holds that <span class="math">a_{i}=b_{i+s}</span>, and for <span class="math">i\\geq N-s</span>, <span class="math">a_{i}=0</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">We explain how the new protocol works, using the shift protocol in <em>[x1]</em> as a starting point. The shift protocol in <em>[x1]</em> (for <span class="math">s=1</span>) considers the polynomials <span class="math">A(X):=\\sum_{i=1}^{N}a_{i}X^{i-1}</span> and <span class="math">B(X):=\\sum_{i=1}^{N}b_{i}X^{i-1}</span>, and uses the fact that <span class="math">X\\cdot A(X)</span> is approximately equal to <span class="math">B(X)</span>, up to some small corrections involving a constant number of coefficients of <span class="math">A(X)</span> and <span class="math">B(X)</span>. This follows from the fact that if <span class="math">a=\\mathrm{shift}(b)</span>, then <span class="math">a_{i}=b_{i+1}</span> for <span class="math">i\\leq N-1</span>, and so the <span class="math">i</span>-th coefficient of <span class="math">XA(X)-B(X)</span> is equal to zero.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This leads to a test for <span class="math">R_{\\odot}</span>, checking that a polynomial identity of degree <span class="math">N</span> is satisfied at a random point <span class="math">\\gamma\\in\\mathbb{F}</span>. By the Schwartz–Zippel lemma, if <span class="math">b\\neq\\mathrm{shift}(a)</span>, then the probability that <span class="math">A(\\gamma)-\\gamma\\cdot B(\\gamma)=(1-\\gamma^{N})\\cdot b_{N}</span> is at most $N/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This polynomial identity test relies on the structure of monomials <span class="math">X^{i}</span> and the ability to scale two related polynomials so that their coefficients match. However, we cannot use it in our setting since the polynomial identity used has degree <span class="math">N</span>, which may be larger than the number of elements in the finite field <span class="math">\\mathbb{F}</span>, leading to a trivial bound on the soundness error of the protocol. Therefore, we design a more complex solution.</p>

    <p class="text-gray-300">Suppose that <span class="math">N=k^{t}</span>. In the tensor IOP setting, we can evaluate the polynomials <span class="math">A(X)</span> and <span class="math">B(X)</span> at any point <span class="math">\\gamma\\in\\mathbb{F}</span> using a tensor query:</p>

    <p class="text-gray-300"><span class="math">(1,\\gamma,\\gamma^{2},\\ldots,\\gamma^{k-1})\\otimes(1,\\gamma^{k},\\gamma^{2k,\\ldots,\\gamma^{k(k-1)}})\\otimes\\cdots\\otimes(1,\\gamma^{k^{t-1}},\\gamma^{2k^{t-1}},\\ldots,\\gamma^{k^{t-1}(k-1)})\\enspace.</span></p>

    <p class="text-gray-300">However, as discussed, this leads to a polynomial identity of degree <span class="math">N=k^{t}</span>. A natural way to reduce the polynomial dimension of this tensor query is to consider the following alternative query for random points <span class="math">\\gamma_{1},\\ldots,\\gamma_{t}\\in\\mathbb{F}</span> :</p>

    <p class="text-gray-300"><span class="math">(1,\\gamma_{1},\\gamma_{1}^{2},\\ldots,\\gamma_{1}^{k-1})\\otimes(1,\\gamma_{2},\\gamma_{2}^{2},\\ldots,\\gamma_{2}^{k-1})\\otimes\\cdots\\otimes(1,\\gamma_{t},\\gamma_{t}^{2},\\ldots,\\gamma_{t}^{k-1})\\enspace.</span> (1)</p>

    <p class="text-gray-300">This query provides evaluations of the polynomial <span class="math">A(X_{1},\\ldots,X_{t}):=\\sum_{i_{1},\\ldots,i_{t}\\in\\{0,\\ldots,k-1\\}}a_{i_{t},\\ldots,i_{1}}X_{1}^{i_{1}}\\ldots X_{t}^{i_{t}}</span>, and similarly for <span class="math">B(X)</span>, where we have reindexed the <span class="math">N=k^{t}</span> entries of <span class="math">a</span> using a <span class="math">k</span>-ary representation. However, it is no longer possible to scale <span class="math">A(X_{1},\\ldots,X_{t})</span> by a single monomial as in the univariate case in order to get a polynomial approximately equal to <span class="math">B(X_{1},\\ldots,X_{t})</span>.</p>

    <p class="text-gray-300">In fact, the appropriate scaling factor now differs according to the <span class="math">k</span>-ary representation of <span class="math">i</span>. Let <span class="math">s&lt;k</span>, and consider the number of carries when adding <span class="math">s</span> to <span class="math">(i_{t},\\ldots,i_{1})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">0\\leq i_{1}\\leq k-1-s</span>, then there are no carries when adding <span class="math">s</span> to the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})</span>. This means that <span class="math">a_{i_{t},\\ldots,i_{1}}</span> is equal to <span class="math">b_{i_{t},\\ldots,i_{1}+s}</span>. Since <span class="math">a_{i_{t},\\ldots,i_{1}}</span> and <span class="math">b_{i_{t},\\ldots,i_{1}+s}</span> appear as coefficients of monomial <span class="math">X_{1}^{i_{1}}\\ldots X_{t}^{i_{t}}</span> when <span class="math">a</span> and <span class="math">b</span> are queried using the tensor query from Equation (1), these coefficients can be related using the scaling factor <span class="math">X_{1}^{s}</span>.</li>

      <li>If <span class="math">k-s\\leq i_{1}\\leq k-1</span>, and <span class="math">0\\leq i_{2}\\leq k-2</span>, then there is one carry when adding <span class="math">s</span> to the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})</span>. This means that <span class="math">a_{i_{t},\\ldots,i_{1}}</span> is equal to <span class="math">b_{i_{t},\\ldots,i_{2}+1,i_{1}+s-k}</span>. Since <span class="math">a_{i_{t},\\ldots,i_{1}}</span> and <span class="math">b_{i_{t},\\ldots,i_{2}+1,i_{1}+s-k}</span> appear as coefficients of monomial <span class="math">X_{1}^{i_{1}}\\ldots X_{t}^{i_{t}}</span> when <span class="math">a</span> and <span class="math">b</span> are queried using the tensor query from Equation (1), these coefficients can be related using the scaling factor <span class="math">X_{1}^{s-k}X_{2}</span>.</li>

    </ul>

    <p class="text-gray-300">Using similar reasoning to the above, it is possible to determine a suitable scaling factor for each possible number of carries from <span class="math">1</span> up to <span class="math">t</span>. By setting certain coefficients of the tensor query in Equation (1) to zero, it is possible to make queries which only involve the entries of <span class="math">a</span> and <span class="math">b</span> involved in the <span class="math">r</span>-carry case. The verifier must make a tensor query to <span class="math">a</span> and <span class="math">b</span> in each case, and multiply by scaling factors. This leads to a total of <span class="math">O(t)</span> queries. Furthermore, the maximum degree of polynomials used in the protocol is now <span class="math">O(tk)</span>, meaning that by setting <span class="math">t</span> large enough, we can use the shift protocol over small fields.</p>

    <p class="text-gray-300">Checking the output of the biased generator. To achieve sublinear verification, we also need to find a way to check the output of the biased generator efficiently. More specifically, in the protocol for general</p>

    <p class="text-gray-300">R1CS described in Section 2.4, we described the use of linear-time-computable subspace biased generators. However, to achieve sublinear verification, the verifier cannot afford to naively check whether the output of the subspace biased generator is consistent with the randomness chosen by the verifier. On the other hand, it is possible to efficiently check that a vector has a tensor structure using protocols similar to the tensor-consistency test in <em>[x1]</em>, which has sublinear verification. Therefore, we will design our subspace biased generator with tensor structure in mind.</p>

    <p class="text-gray-300">Our subspace biased generator is constructed from <span class="math">\\epsilon</span>-biased generators. Given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}_{p^{\\lambda}}^{s}\\to\\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span>, let <span class="math">G^{\\prime}(r_{1},\\ldots,r_{t})\\coloneqq G(r_{1})\\otimes\\cdots\\otimes G(r_{t})</span> for <span class="math">r_{1},\\ldots,r_{t}\\in\\mathbb{F}_{p^{\\lambda}}^{s}</span>. Note that <span class="math">G^{\\prime}</span> is a <span class="math">t\\epsilon</span>-biased generator. We then define the corresponding subspace biased generator to be the matrix representation of <span class="math">G^{\\prime}</span>. Let <span class="math">r=(r_{1},\\ldots,r_{t})\\in\\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}</span>. Note that <span class="math">G^{\\prime}(r)</span> can be viewed as a matrix in <span class="math">\\mathbb{F}_{p}^{\\lambda\\times\\lambda}</span> for all <span class="math">i</span>, and we define <span class="math">G_{\\mathsf{sub}}(r)_{i}</span> to be this matrix. Viewed as a vector of field-extension elements, the biased generator output has a tensor structure, which would be easy to check using the tensor-consistency test in <em>[x1]</em>. However, we require the matrix representation of <span class="math">G^{\\prime}</span> instead as parts of our protocol for algebraic automata use calculations involving individual elements of the base field. The proof that this construction gives a subspace biased generator with the desired property is explained more carefully in Section 5.1. Further, in our real protocol, we use a slightly more complicated biased-generator construction, for reasons explained in Section 7.</p>

    <p class="text-gray-300">Now we can think of the output of our subspace biased generator <span class="math">G_{\\mathsf{sub}}\\colon\\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\to\\mathbb{F}_{p}^{\\lambda\\times\\lambda b^{\\prime t}}</span> as <span class="math">b^{\\prime t}</span> matrices in <span class="math">\\mathbb{F}_{p}^{\\lambda\\times\\lambda}</span>. Define <span class="math">y^{(m_{0},m_{t})}\\in\\mathbb{F}_{p}^{b^{\\prime t}}</span> to be such that its <span class="math">k</span>-th entry is the <span class="math">(m_{0},m_{t})</span>-th entry of the <span class="math">k</span>-th matrix of <span class="math">G_{\\mathsf{sub}}(r)</span>. We can write <span class="math">y^{(m_{0},m_{t})}</span> for all <span class="math">m_{0},m_{t}\\in[\\lambda]</span> as a sum of tensor products because of the tensor structure of <span class="math">G^{\\prime}</span> and the properties of matrix multiplication. A detailed calculation is presented in Section 7.4. Then, we successfully reduce the task of checking that the output of a subspace biased generator was computed correctly, to checking that the output is a sum of tensor products, which can be done by modifying an established protocol, the tensor-consistency test, in <em>[x1]</em> and meet our constraints on verifier efficiency.</p>

    <p class="text-gray-300">Bottleneck for improving on sublinear verification. With this approach, the bottleneck for verifier efficiency is checking that the output of the biased generator was computed correctly. As explained above, in this subprotocol the verifier uses <span class="math">O(t\\cdot\\mathsf{o}_{G})</span> operations where <span class="math">\\mathsf{o}_{G}</span> is the time complexity of computing the <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}_{p^{\\lambda}}^{s}\\to\\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span>. By Corollary 5.10, we can construct such a biased generator for any <span class="math">\\epsilon&gt;\\frac{1}{p^{\\lambda}}</span> and time complexity <span class="math">\\mathsf{o}_{G}=\\Theta(b^{\\prime})\\;\\mathbb{F}_{p^{\\lambda}}</span>-operations. Since we need to pick <span class="math">\\lambda\\in O(1)</span> in order to achieve linear prover time for the IOP protocol, <span class="math">\\epsilon\\in\\Omega(1)</span>. Therefore in order to obtain a nontrivial tensor-structured <span class="math">t\\epsilon</span>-biased generator <span class="math">G^{\\prime}</span>, we need to pick the tensor rank <span class="math">t&lt;\\frac{1}{\\epsilon}&lt;p^{\\lambda}</span>. For such choices of <span class="math">t</span>, the verifier time for checking the output of <span class="math">G^{\\prime}</span> becomes <span class="math">\\Theta(t\\cdot\\mathsf{o}_{G})=\\Theta(t\\cdot(wT)^{1/t})\\;\\mathbb{F}_{p^{\\lambda}}</span>-operations which translates to <span class="math">\\Theta_{p,\\lambda}((wT)^{1/t})</span> operations over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This approach cannot achieve polylogarithmic verification time because we do not know how to construct <span class="math">\\epsilon</span>-biased generators over fields <span class="math">\\mathbb{F}</span> with $\\epsilon<\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. This fact holds true even for the trivial biased generator that simply outputs the random seed. To summarize, there is a tradeoff between soundness and verification time but since we are working over the small field </span>\\mathbb{F}_{p^{\\lambda}}$, the best verification time that we can achieve is sublinear.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">2.7 Completing the point-query IOP construction</h3>

    <p class="text-gray-300">We explain how to combine the ingredients described in previous sections to obtain the IOP in Theorem 1.2. The IOP described in Theorem 1.5 uses similar techniques.</p>

    <p class="text-gray-300">From tensor queries to point queries. We transform the tensor-query IOP from Section 2.4 into a point-</p>

    <p class="text-gray-300">query IOP by following the strategy of <em>[x1]</em>, which uses point queries to check the correctness of claimed answers to tensor queries. The IOPP in <em>[x1]</em> encodes each proof message <span class="math">\\Pi</span> in the tensor-query IOP using a suitable tensor code to obtain an encoded proof message <span class="math">\\hat{\\Pi}</span> for the point-query IOP; then the IOPP relies on a <em>proximity test</em> to ensure that each <span class="math">\\hat{\\Pi}</span> is close to a valid tensor encoding.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proximity test in <em>[x1]</em> relies on the fact that taking random linear combinations of noisy codewords preserves their distance from the code up to some small error probability. Later, the proximity test of <em>[x2]</em> replaced purely random linear combinations with certain structured combinations that use a much smaller seed. Unfortunately, in either case, the error-probabilities associated with taking linear combinations contribute $O(N/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> to the soundness error of the proximity test. This is unacceptable because as explained in Section 2.5, we can only apply precomputation techniques in fields of size </span>o(\\sqrt{N})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To solve this problem, we generalize the <em>[x1, x2]</em> proximity tests by replacing the linear combinations with more general <em>proximity generators</em>, which are randomness generators whose outputs obey the same distance preservation property. We then instantiate the proximity generator with a different construction (given in Section 8.3) than those used in <em>[x1, x2]</em>, which has better error probability.</p>

    <p class="text-gray-300">However, when applied to the tensor IOP from Section 2.4, the new consistency test IOPP has query complexity <span class="math">O(N^{1/t})</span> which is insufficient for Theorem 1.2.</p>

    <p class="text-gray-300">Interactive proof composition. We follow <em>[x2]</em>, by using interactive proof composition to reduce the query complexity of the IOPP to <span class="math">\\mathsf{polylog}(N)</span> over <span class="math">\\mathbb{F}_{p}</span>. This involves robustifying the IOPP via a linear code, and then applying the proof composition transformation in <em>[x3]</em> with the robustified consistency check as the outer IOP and the PCPP from <em>[x14]</em> as the inner IOP. This yields an IOPP with query complexity <span class="math">\\mathsf{polylog}(N)</span>.</p>

    <p class="text-gray-300">When applied to the tensor IOP of Section 2.4, which is defined over <span class="math">\\mathbb{F}_{p^{b}}</span>, the resulting point-query IOP for R1CS over <span class="math">\\mathbb{F}_{p}</span> is an IOP over <span class="math">\\mathbb{F}_{p^{b}}</span>, with query complexity <span class="math">\\mathsf{polylog}(N)</span>, and prover and verifier arithmetic complexity <span class="math">O(M)</span> operations in <span class="math">\\mathbb{F}_{p}</span> and <span class="math">O(N/a)</span> multiplications in <span class="math">\\mathbb{F}_{p^{b}}</span>. This is still insufficient for Theorem 1.2 because the overhead of performing arithmetic operations over <span class="math">\\mathbb{F}_{p^{b}}</span> leads to superlinear prover costs over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Precomputing the multiplication table. We solve this problem using the precomputation techniques of Section 2.5, precomputing the multiplication table of <span class="math">\\mathbb{F}_{p^{b}}</span>. Each of the <span class="math">O(N/a)</span> multiplications over <span class="math">\\mathbb{F}_{p^{b}}</span> can be replaced by looking up the product in the multiplication table. This means reading a single element of <span class="math">\\mathbb{F}_{p^{b}}</span>, which can be written as <span class="math">O(a)</span> elements of <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">Thus, the <span class="math">O(N/a)</span> multiplications in <span class="math">\\mathbb{F}_{p^{b}}</span> are replaced by <span class="math">O(N)</span> operations over <span class="math">\\mathbb{F}_{p}</span>, plus the <span class="math">O(b^{2}p^{2b})</span> operations required to precompute the multiplication table. Setting <span class="math">b=\\frac{1}{2}\\log N-o(\\log N)</span> so that <span class="math">O(b^{2}p^{2b})=O(N)</span>, the <span class="math">O(N)</span> operations over <span class="math">\\mathbb{F}_{p}</span> dominate, giving an IOP with both prover and verifier arithmetic complexity <span class="math">O(M+N)</span> over <span class="math">\\mathbb{F}_{p}</span>.</p>

    <p class="text-gray-300">This gives a point-query IOP for <span class="math">R_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}_{p}</span> with linear-time prover and verifier. The construction of the consistency test IOPP is given in Section 8. A formal explanation of precomputation techniques is given in Section 9, and Section 10 gives a rigorous analysis of the final IOP and its parameters.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">An indexed relation <span class="math">R</span> is a set of triples <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> where <span class="math">\\mathfrak{i}</span> is the index, <span class="math">\\mathtt{x}</span> the instance, and <span class="math">\\mathtt{w}</span> the witness. The corresponding indexed language <span class="math">L(R)</span> is the set of pairs <span class="math">(\\mathfrak{i},\\mathtt{x})</span> for which there exists a witness <span class="math">\\mathtt{w}</span> such that <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Definition 3.2.</h6>

    <p class="text-gray-300">A IOP with query class <span class="math">\\mathcal{Q}</span> (some set of functions) is a tuple <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span>, where <span class="math">\\mathbf{I}</span> is the <em>indexer</em>, <span class="math">\\mathbf{P}</span> the <em>prover</em>, and <span class="math">\\mathbf{V}</span> the <em>verifier</em>. The indexer is a deterministic polynomial-time algorithm, while the prover and verifier are probabilistic polynomial-time interactive algorithms.</p>

    <p class="text-gray-300">In an offline phase, the indexer <span class="math">\\mathbf{I}</span> is given an index <span class="math">\\mathfrak{i}</span> and outputs an encoding <span class="math">\\Pi_{0}</span> of <span class="math">\\mathfrak{i}</span>.</p>

    <p class="text-gray-300">In an online phase, the prover <span class="math">\\mathbf{P}</span> receives as input an index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> and the verifier <span class="math">\\mathbf{V}</span> receives as input the instance <span class="math">\\mathtt{x}</span>; in addition, the verifier <span class="math">\\mathbf{V}</span> has query access to <span class="math">\\Pi_{0}</span> (in a precise sense specified below), which we denote as <span class="math">\\mathbf{V}^{\\Pi_{0}}(\\mathtt{x})</span>. The online phase consists of multiple rounds, and in each round the prover <span class="math">\\mathbf{P}</span> sends a proof message <span class="math">\\Pi_{i}</span> and the verifier <span class="math">\\mathbf{V}</span> replies with a challenge message <span class="math">\\rho_{i}</span>.</p>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> may compute its proof message <span class="math">\\Pi_{i}</span> based on its input <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> and all the verifier challenges received thus far (none if <span class="math">i=1</span> or <span class="math">\\rho_{1},\\ldots,\\rho_{i-1}</span> if <span class="math">i&gt;1</span>). In contrast, the verifier <span class="math">\\mathbf{V}</span> may compute its challenge message <span class="math">\\rho_{i}</span> based on its input <span class="math">\\mathtt{x}</span> and on answers obtained by querying <span class="math">(\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> via queries in <span class="math">\\mathcal{Q}</span>. In more detail, the answer of a query <span class="math">q\\in\\mathcal{Q}</span> to <span class="math">(\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> is <span class="math">v:=q(\\mathtt{x},\\Pi_{0},\\Pi_{1},\\ldots,\\Pi_{i})</span> (this answer could also be a special error value in case the proof messages are not according to an expected format).</p>

    <p class="text-gray-300">After the interaction and all queries are concluded, the verifier <span class="math">\\mathbf{V}</span> accepts or rejects.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Remark 3.3 (non-oracle messages).</h6>

    <p class="text-gray-300">We allow the prover in an IOP to also send, at any point in the interaction, arbitrary messages that the verifier will simply read in full (without making any queries) as in a usual interactive proof. We refer to such messages as <em>non-oracle messages</em>, to differentiate them from the <em>oracle messages</em> to which the verifier has query access. These non-oracle messages can typically be viewed as degenerate cases of oracle messages, and we use them in protocol descriptions for convenience of exposition.</p>

    <p class="text-gray-300">A holographic interactive oracle proof <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> for an indexed relation <span class="math">R</span> has completeness <span class="math">1</span> and soundness error <span class="math">\\epsilon</span> if the following holds.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[leftmargin=*]</li>

      <li>Completeness. For every index-instance-witness tuple <span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})\\in R</span>, the probability that <span class="math">\\mathbf{P}(\\mathfrak{i},\\mathtt{x},\\mathtt{w})</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})</span> to accept is <span class="math">1</span>.</li>

      <li>Soundness. For every index-instance tuple <span class="math">(\\mathfrak{i},\\mathtt{x})\\notin L(R)</span> and malicious prover <span class="math">\\widetilde{\\mathbf{P}}</span>, the probability that <span class="math">\\widetilde{\\mathbf{P}}</span> convinces <span class="math">\\mathbf{V}^{\\mathbf{I}(\\mathfrak{i})}(\\mathtt{x})</span> to accept is at most <span class="math">\\epsilon</span>.</li>

    </ul>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Public coins.</h5>

    <p class="text-gray-300">A holographic IOP is <em>public-coin</em> if each verifier message to the prover is a random string. This means that the verifier’s randomness is its challenge messages <span class="math">\\rho_{1},\\ldots,\\rho_{\\text{rc}}</span>. All verifier queries can be postponed, without loss of generality, to a query phase that occurs after the interactive phase with the prover.</p>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Non-adaptive queries.</h5>

    <p class="text-gray-300">A holographic IOP is <em>non-adaptive</em> if all verifier queries depend solely on the input instance <span class="math">\\mathtt{x}</span> and the verifier’s randomness, as opposed to some queries depending on answers to prior queries. For non-adaptive IOPs, the verifier <span class="math">\\mathbf{V}</span> can be written as a pair of algorithms <span class="math">(\\mathbf{V}_{\\mathrm{q}},\\mathbf{V}_{\\mathrm{d}})</span> where: (a) <span class="math">\\mathbf{V}_{\\mathrm{q}}</span> is probabilistic, takes as input the instance <span class="math">\\mathtt{x}</span>, interacts with the prover <span class="math">\\mathbf{P}</span>, and outputs a decision state <span class="math">\\sigma</span> and a query set <span class="math">I</span> (for the index oracle and proof oracles); and (b) <span class="math">\\mathbf{V}_{\\mathrm{d}}</span> is deterministic, takes as input the decision state <span class="math">\\sigma</span> and query answers <span class="math">\\mathbf{v}\\in\\Sigma^{I}</span>, and outputs a decision bit. For this case, we define the relation <span class="math">R(\\mathbf{V})</span> to be all pairs <span class="math">(\\sigma,\\mathbf{v})</span> such that there exist <span class="math">\\mathtt{x}</span> and <span class="math">I</span> with <span class="math">(\\sigma,I)</span> in the support of <span class="math">\\mathbf{V}_{\\mathrm{q}}(\\mathtt{x})</span> and <span class="math">\\mathbf{V}_{\\mathrm{d}}(\\sigma,\\mathbf{v})=1</span>.</p>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Complexity measures.</h5>

    <p class="text-gray-300">We consider several complexity measures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">\\mathsf{rc}</span> is the number of back-and-forth message exchanges between the prover and verifier;</li>

      <li>answer alphabet <span class="math">\\Sigma</span> is the alphabet over which oracle messages are defined;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- proof length <span class="math">l = li + lp + lc</span> where $li :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the number of alphabet symbols output by the indexer, </span>lp :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\cdots +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pi_{rc}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the total number of alphabet symbols sent in oracle messages by the prover, and </span>lc$ is the total number of alphabet symbols sent in non-oracle messages by the prover;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>randomness <span class="math">r</span> is the number of random bits used by the verifier;</li>

      <li>query complexity <span class="math">q</span> is the total number of queries made by the verifier (to any oracle);</li>

      <li>running time <span class="math">ti</span> is the running time of <span class="math">I</span>, <span class="math">tp</span> is the running time of <span class="math">P</span>, and <span class="math">tv</span> is the running time of <span class="math">V</span>. In the non-adaptive case, <span class="math">tq</span> and <span class="math">td</span> are the running times of the query and decision components of <span class="math">V</span> respectively.</li>

    </ul>

    <p class="text-gray-300">We define the two query classes that we use in this paper, point queries and tensor queries.</p>

    <p class="text-gray-300"><strong>Definition 3.4.</strong> A holographic IOP with point queries is an IOP with the query class <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> defined as follows: <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> is all functions of the form <span class="math">q(\\mathbf{x}, \\Pi_0, \\Pi_1, \\ldots, \\Pi_i) = \\Pi_j[k]</span> for some <span class="math">j \\in \\{0, 1, \\ldots, i\\}</span> and location <span class="math">k</span>. (If the location <span class="math">k</span> does not exist, the answer is an error.) Namely, each query in the class <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> returns the symbol at a location of the encoded index (<span class="math">j = 0</span>) or of a specified prover message (<span class="math">j &amp;gt; 0</span>).</p>

    <p class="text-gray-300"><strong>Definition 3.5.</strong> Given a finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k, t</span>, a holographic IOP with <span class="math">(\\mathbb{F}, k, t)</span>-tensor queries is an IOP with the query class <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k, t)</span> defined as follows: <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k, t)</span> contains all functions of the form <span class="math">q(\\mathbf{x}, \\Pi_0, \\Pi_1, \\ldots, \\Pi_i) = \\langle q_0 \\otimes q_1 \\otimes \\cdots \\otimes q_t, \\Pi_j \\rangle</span> for some <span class="math">j \\in \\{0, 1, \\ldots, i\\}</span> and vectors <span class="math">q_0 \\in \\mathbb{F}^*</span> and <span class="math">q_1, \\ldots, q_t \\in \\mathbb{F}^k</span>. (If the lengths of the linear combination <span class="math">q_0 \\otimes q_1 \\otimes \\cdots \\otimes q_t</span> and proof string <span class="math">\\Pi_j</span> do not match, the answer is an error.) Namely, each query in the class <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}</span> returns the scalar product of a certain tensor vector and the encoded index (<span class="math">j = 0</span>) or of a specified prover message (<span class="math">j &amp;gt; 0</span>).</p>

    <p class="text-gray-300"><strong>Remark 3.6.</strong> In the context of tensor IOPs, we often view a proof message <span class="math">\\Pi \\in \\mathbb{F}^{\\ell \\cdot k^t}</span> as consisting of <span class="math">\\ell</span> "sub-messages" <span class="math">\\pi_1, \\ldots, \\pi_\\ell</span> each in <span class="math">\\mathbb{F}^{k^t}</span>. In this case, when describing a protocol, we may make a tensor query <span class="math">q_1 \\otimes \\cdots \\otimes q_t</span> to one of the sub-messages <span class="math">\\pi</span>, with the understanding that one can specify an indicator vector <span class="math">q_0 \\in \\mathbb{F}^\\ell</span> so that <span class="math">\\langle q_0 \\otimes q_1 \\otimes \\cdots \\otimes q_t, \\Pi \\rangle = \\langle q_1 \\otimes \\cdots \\otimes q_t, \\pi \\rangle</span>.</p>

    <p class="text-gray-300">18</p>

    <p class="text-gray-300">4 Systematic reverse-multiplication-friendly embeddings</p>

    <p class="text-gray-300">We recall the definition of an RMFE (from <em>[x10, Definition 1]</em>) and introduce the systematic property that we use in this work. Then in Section 4.1 and in Section 4.2 we prove that two RMFE constructions from <em>[x10]</em> are systematic. The first construction is based on polynomial interpolation and the second construction is based on algebraic-geometry codes. The first construction is a warmup, and the second construction is the one that we use in our IOP, via the asymptotic corollaries that we state in Section 4.3.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Definition 4.1.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime power and <span class="math">\\mathbb{F}_{p}</span> the field with <span class="math">p</span> elements. Let <span class="math">a,b\\geq 1</span> be integers. A pair <span class="math">(\\phi,\\psi)</span> is a <span class="math">(a,b)_{p}</span>-reverse-multiplication-friendly embedding (RMFE) if <span class="math">\\phi\\colon\\mathbb{F}_{p}^{a}\\to\\mathbb{F}_{p^{b}}</span> and <span class="math">\\psi\\colon\\mathbb{F}_{p^{b}}\\to\\mathbb{F}_{p}^{a}</span> are <span class="math">\\mathbb{F}_{p}</span>-linear maps such that, for every <span class="math">\\vec{x},\\vec{y}\\in\\mathbb{F}_{p}^{a}</span>,</p>

    <p class="text-gray-300"><span class="math">\\vec{x}\\circ\\vec{y}=\\psi\\Big{(}\\phi(\\vec{x})\\cdot\\phi(\\vec{y})\\Big{)}\\enspace.</span></p>

    <h6 id="sec-40" class="text-base font-medium mt-4">Definition 4.2.</h6>

    <p class="text-gray-300">An <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span> is systematic if there exists an <span class="math">\\mathbb{F}_{p}</span>-basis <span class="math">\\{e_{j}\\}_{j\\in[b]}</span> of <span class="math">\\mathbb{F}_{p^{b}}</span> such that for all <span class="math">x=(x_{1},\\ldots,x_{a})\\in\\mathbb{F}_{p^{a}}^{a}</span> we have <span class="math">\\phi(x)=(x_{1},\\ldots,x_{a},0,\\ldots,0)</span>, where the <span class="math">i</span>-th entry of <span class="math">\\phi(x)</span> is the coefficient with respect to the <span class="math">i</span>-th basis vector <span class="math">e_{i}</span>.</p>

    <h3 id="sec-41" class="text-xl font-semibold mt-8">4.1 Systematic RMFE from polynomial interpolation</h3>

    <p class="text-gray-300">We show that the <span class="math">(k,2k-1)_{p}</span>-RMFE construction in <em>[x10]</em> based on polynomial interpolation is systematic. We do not use this construction in our main theorem (as the RMFE requires <span class="math">p</span> to be large); however, this construction serves as a warm-up for the construction in the next section.</p>

    <p class="text-gray-300">In the definition below we use this notation: for every positive integer <span class="math">t</span>, the formal symbol <span class="math">\\infty_{t}</span> acts as an evaluation point in that, for every <span class="math">f\\in\\mathbb{F}_{p}[X]_{&lt;t}</span>, we define <span class="math">f(\\infty_{t})</span> to be the coefficient of <span class="math">X^{t-1}</span> in <span class="math">f</span>.</p>

    <h6 id="sec-42" class="text-base font-medium mt-4">Definition 4.3 (<em>[x10, Lemma 4]</em>).</h6>

    <p class="text-gray-300">Fix a choice of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>positive integer <span class="math">k</span> and arbitrary prime power <span class="math">p</span> such that <span class="math">1\\leq k\\leq p+1</span>;</li>

      <li>an element <span class="math">\\zeta\\in\\mathbb{F}_{p^{2k-1}}</span> such that <span class="math">\\mathbb{F}_{p^{2k-1}}=\\mathbb{F}_{p}[\\zeta]</span>;</li>

      <li>pairwise distinct elements <span class="math">\\{\\alpha_{1},\\ldots,\\alpha_{k}\\}</span> in <span class="math">\\mathbb{F}_{p}\\cup\\{\\infty_{k+1}\\}</span>.</li>

    </ul>

    <p class="text-gray-300">The maps are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encoding map: <span class="math">\\phi_{\\mathrm{int}}\\colon\\mathbb{F}_{p}^{k}\\to\\mathbb{F}_{p^{2k-1}}</span> maps <span class="math">(x_{1},\\ldots,x_{k})\\mapsto f(\\zeta)</span> where <span class="math">f</span> is the unique polynomial in <span class="math">\\mathbb{F}_{p}[X]_{&lt;k}</span> such that <span class="math">f(\\alpha_{i})=x_{i}</span> for every <span class="math">i\\in[k]</span>.</li>

      <li>Decoding map: <span class="math">\\psi_{\\mathrm{int}}\\colon\\mathbb{F}_{p^{2k-1}}\\to\\mathbb{F}_{p}^{k}</span> maps <span class="math">\\beta\\mapsto(f(\\alpha_{1}^{\\prime}),\\ldots,f(\\alpha_{k}^{\\prime}))</span> where <span class="math">f</span> is the unique polynomial in <span class="math">\\mathbb{F}_{p}[X]_{&lt;2k-1}</span> such that <span class="math">\\beta=f(\\zeta)</span>. Here <span class="math">\\alpha_{i}^{\\prime}:=\\alpha_{i}</span> if <span class="math">\\alpha_{i}\\in\\mathbb{F}_{p}</span> and <span class="math">\\alpha_{i}^{\\prime}:=\\infty_{2k-1}</span> if <span class="math">\\alpha_{i}=\\infty_{k+1}</span>.</li>

    </ul>

    <h6 id="sec-43" class="text-base font-medium mt-4">Lemma 4.4 (<em>[x10, Lemma 4]</em>).</h6>

    <p class="text-gray-300"><span class="math">(\\phi_{\\mathrm{int}},\\psi_{\\mathrm{int}})</span> in Definition 4.3 is a <span class="math">(k,2k-1)_{p}</span>-RMFE.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Theorem 4.5.</h6>

    <p class="text-gray-300"><span class="math">(\\phi_{\\mathrm{int}},\\psi_{\\mathrm{int}})</span> in Definition 4.3 is systematic.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The interpolated polynomial for an input <span class="math">\\vec{x}=(x_{1},\\ldots,x_{k})\\in\\mathbb{F}_{p}^{k}</span> is <span class="math">f(X)=\\sum_{i=1}^{k}x_{i}L_{i}(X)</span> where <span class="math">L_{i}(X)=\\prod_{j\\in[k]\\setminus\\{i\\}}\\frac{X-x_{j}}{x_{i}-x_{j}}</span> is the <span class="math">i</span>-th Lagrange polynomial. By Definition 4.3, we know that <span class="math">\\phi_{\\mathrm{int}}(\\vec{x})=f(\\zeta)=\\sum_{i=1}^{k}x_{i}L_{i}(\\zeta)</span> where <span class="math">\\zeta\\in\\mathbb{F}_{p^{2k-1}}</span> is such that <span class="math">\\mathbb{F}_{p^{2k-1}}=\\mathbb{F}_{p}[\\zeta]</span>.</p>

    <p class="text-gray-300">It is well-known that Lagrange polynomials are a basis; specifically, <span class="math">\\{L_{1}(X),\\ldots,L_{k}(X)\\}</span> is a basis for <span class="math">\\mathbb{F}_{p}[X]_{&lt;k}</span>. We prove this claim for completeness. Consider any decomposition of the zero polynomial</p>

    <p class="text-gray-300"><span class="math">0=a_{1}L_{1}(X)+\\dots+a_{k}L_{k}(X)</span> under this Lagrange basis. By evaluating the zero polynomial at every <span class="math">x_{i}</span> for <span class="math">i\\in[k]</span>, we get that <span class="math">a_{1}=\\dots=a_{k}=0</span>. Since the zero polynomial has a unique decomposition in this basis, we conclude that <span class="math">\\{L_{1}(X),\\dots,L_{k}(X)\\}</span> are linearly independent. Thus, it forms a basis for <span class="math">\\mathbb{F}_{p}[X]_{&lt;k}</span>.</p>

    <p class="text-gray-300">We conclude by noting that <span class="math">\\{L_{1}(\\zeta),\\dots,L_{k}(\\zeta),\\zeta^{k},\\dots,\\zeta^{(2k-1)-1}\\}</span> is a basis for <span class="math">\\mathbb{F}_{p^{2k-1}}=\\mathbb{F}_{p}[\\zeta]</span> and the basis makes <span class="math">(\\phi_{\\mathrm{int}},\\psi_{\\mathrm{int}})</span> systematic since <span class="math">\\phi_{\\mathrm{int}}(\\vec{x})=\\sum_{i=1}^{k}x_{i}L_{i}(\\zeta)</span>. ∎</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">4.2 Systematic RMFE from algebraic geometry</h3>

    <p class="text-gray-300">We show that the <span class="math">(k,m)_{p}</span>-RMFE construction in <em>[x1]</em> based on algebraic-geometry codes is systematic. Below, we assume familiarity with certain algebraic-geometry concepts: a function field <span class="math">F/\\mathbb{F}_{p}</span>; the genus <span class="math">g</span> of function fields; places <span class="math">P</span> associated with the function fields; the number of rational places <span class="math">N_{1}(F)</span> of a function field <span class="math">F</span>; Ihara’s constant <span class="math">A(p)</span> of <span class="math">\\mathbb{F}_{p}</span>; a divisor <span class="math">G</span>; and the Riemann–Roch space <span class="math">\\mathcal{L}(G)</span> associated with <span class="math">G</span>. We refer the reader to the book by Stichtenoth <em>[x27]</em> for explanations of these notions.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Definition 4.6 (<em>[x1, Lemma 6]</em>).</h6>

    <p class="text-gray-300">Fix a choice of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a function field <span class="math">F/\\mathbb{F}_{p}</span> of genus <span class="math">g</span>;</li>

      <li><span class="math">k</span> distinct rational places <span class="math">P_{1},\\dots,P_{k}</span> in <span class="math">F/\\mathbb{F}_{p}</span>;</li>

      <li>a divisor <span class="math">G</span> of <span class="math">F</span> such that <span class="math">\\mathrm{supp}(G)\\cap\\{P_{1},\\dots,P_{k}\\}=\\emptyset</span> and <span class="math">\\dim_{\\mathbb{F}_{p}}\\mathcal{L}(G)-\\dim_{\\mathbb{F}_{p}}\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})=k</span>;</li>

      <li>a place <span class="math">R</span> of degree <span class="math">m&gt;2\\deg G</span>.</li>

    </ul>

    <p class="text-gray-300">Define:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi\\colon\\mathcal{L}(G)\\to\\mathbb{F}_{p}^{k}</span> maps <span class="math">f\\mapsto(f(P_{1}),\\dots,f(P_{k}))</span> (<span class="math">\\pi</span> is surjective since <span class="math">\\ker\\pi=\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>);</li>

      <li><span class="math">W\\subseteq\\mathcal{L}(G)</span> with <span class="math">\\dim_{\\mathbb{F}_{p}}W=k</span> such that <span class="math">\\pi</span> induces an isomorphism between <span class="math">W</span> and <span class="math">\\mathbb{F}_{p}^{k}</span>;</li>

      <li><span class="math">\\tau\\colon\\mathcal{L}(2G)\\to\\mathbb{F}_{p^{m}}</span> maps <span class="math">f\\mapsto f(R)\\in\\mathbb{F}_{p^{m}}</span> (<span class="math">\\tau</span> is <span class="math">\\mathbb{F}_{p}</span>-linear and injective since <span class="math">m=\\deg R&gt;\\deg 2G</span>).</li>

    </ul>

    <p class="text-gray-300">The maps are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Encoding map: <span class="math">\\phi_{\\mathrm{ag}}\\colon\\pi(W)=\\mathbb{F}_{p}^{k}\\to\\mathbb{F}_{p^{m}}</span> maps <span class="math">(x_{1},\\dots,x_{k})\\mapsto f(R)</span> where <span class="math">f</span> is the unique polynomial in <span class="math">W</span> such that <span class="math">f(P_{i})=x_{i}</span> for every <span class="math">i\\in[k]</span>.</li>

      <li>Decoding map: <span class="math">\\psi_{\\mathrm{ag}}</span> to be the linear extension of <span class="math">\\psi_{\\mathrm{ag}}^{\\prime}</span> from <span class="math">\\mathrm{Im}(\\tau)</span> to <span class="math">\\mathbb{F}_{p^{m}}</span> where <span class="math">\\psi_{\\mathrm{ag}}^{\\prime}\\colon\\mathrm{Im}(\\tau)\\to\\mathbb{F}_{p}^{k}</span> maps <span class="math">f(R)\\mapsto(f(P_{1}),\\dots,f(P_{k}))</span> where <span class="math">f\\in\\mathcal{L}(2G)</span> is uniquely determined by <span class="math">f(R)</span>.</li>

    </ul>

    <h6 id="sec-48" class="text-base font-medium mt-4">Lemma 4.7 (<em>[x1, Lemma 6]</em>).</h6>

    <p class="text-gray-300"><span class="math">(\\phi_{\\mathrm{ag}},\\psi_{\\mathrm{ag}})</span> in Definition 4.6 is a <span class="math">(k,m)_{p}</span>-RMFE.</p>

    <h6 id="sec-49" class="text-base font-medium mt-4">Theorem 4.8.</h6>

    <p class="text-gray-300"><span class="math">(\\phi_{\\mathrm{ag}},\\psi_{\\mathrm{ag}})</span> in Definition 4.6 is systematic.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first assume that we have a basis <span class="math">\\{e_{j}\\}_{j\\in[m]}</span> for <span class="math">\\mathbb{F}_{p^{m}}</span> such that the subset <span class="math">\\{e_{j}\\}_{j\\in[k]}</span> of <span class="math">\\{e_{j}\\}_{j\\in[m]}</span> (reordered if necessary) forms a basis for <span class="math">\\mathrm{Im}(\\phi_{\\mathrm{ag}})</span> and prove that this basis makes the RMFE systematic. Let <span class="math">\\{e_{i}^{\\prime}\\}_{i\\in[k]}</span> be the standard basis of <span class="math">\\mathbb{F}_{p}^{k}</span> (the <span class="math">i</span>-th entry of <span class="math">e_{i}^{\\prime}</span> is 1 and all other entries are <span class="math">0</span>). The map <span class="math">\\pi</span> induces an isomorphism between <span class="math">W</span> and <span class="math">\\mathbb{F}_{p}^{k}</span>, which means that each <span class="math">e_{i}^{\\prime}\\in\\mathbb{F}_{p}^{k}</span> uniquely determines some <span class="math">f_{i}\\in W\\subseteq\\mathcal{L}(G)</span>. Let <span class="math">y_{i}:=f_{i}(R)\\in\\mathbb{F}_{p^{m}}</span>. We know that <span class="math">y_{i}=\\sum_{j=1}^{k}a_{ij}e_{j}</span> because <span class="math">y_{i}\\in\\mathrm{Im}(\\phi_{\\mathrm{ag}})</span>. Note that <span class="math">\\{y_{i}\\}_{i\\in[k]}</span> is linearly independent since <span class="math">\\phi_{\\mathrm{ag}}</span> is an injective linear map, and if we replace <span class="math">\\{e_{j}\\}_{j\\in[k]}</span> with <span class="math">\\{y_{i}\\}_{i\\in[k]}</span>, the resulting set <span class="math">\\{y_{1},\\dots,y_{k},e_{k+1},\\dots,e_{m}\\}</span> forms a basis that makes <span class="math">(\\phi_{\\mathrm{ag}},\\psi_{\\mathrm{ag}})</span> systematic since <span class="math">\\{y_{i}\\}_{i\\in[k]}</span> are the image of basis vectors of the domain of <span class="math">\\phi_{\\mathrm{ag}}</span>.</p>

    <p class="text-gray-300">We are left to construct a basis for <span class="math">\\mathbb{F}_{p^{m}}</span> whose first <span class="math">k</span> elements form a basis for <span class="math">\\mathrm{Im}(\\phi_{\\mathrm{ag}})</span>. Let <span class="math">\\mathcal{B}</span> be a basis for the Riemann–Roch space <span class="math">\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>. Since <span class="math">\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span> has finite dimension, <span class="math">\\mathcal{B}</span></p>

    <p class="text-gray-300">is a finite set. Since we have <span class="math">\\ker\\pi=\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>, with the fact that <span class="math">\\phi_{\\mathrm{ag}}</span> maps vectors in <span class="math">\\mathbb{F}_{p}^{k}</span> to the evaluation of the high degree place <span class="math">R</span> of a unique polynomial in <span class="math">W\\subseteq\\mathcal{L}(G)</span>, we can conclude that <span class="math">\\operatorname{Im}(\\phi_{\\mathrm{ag}})\\cong\\mathcal{L}(G)/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>. Therefore, if we found a basis for <span class="math">\\mathcal{L}(G)/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>, it would naturally give a basis for <span class="math">\\operatorname{Im}(\\phi_{\\mathrm{ag}})</span>. To do that, we start with finding a basis for <span class="math">\\mathcal{L}(G-\\sum_{i=2}^{k}P_{i})/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>, then we proceed inductively to obtain a basis for <span class="math">\\mathcal{L}(G)/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>. Let <span class="math">k(P_{1})</span> be the residue field of <span class="math">P_{1}</span>. Consider the linear map <span class="math">\\chi\\colon\\mathcal{L}(G-\\sum_{i=2}^{k}P_{i})/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})\\to k(P_{1})</span> defined as <span class="math">\\chi(f)=f\\bmod P_{1}</span>. Since <span class="math">\\mathcal{L}(G-\\sum_{i=2}^{k}P_{i})/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span> is of dimension <span class="math">1</span>, any <span class="math">f</span> not in <span class="math">\\ker(\\chi)</span> would be a basis for <span class="math">\\mathcal{L}(G-\\sum_{i=2}^{k}P_{i})/\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})</span>. ∎</p>

    <h6 id="sec-51" class="text-base font-medium mt-4">Remark 4.9.</h6>

    <p class="text-gray-300">Theorem 4.5 is a special case of Theorem 4.8. We started with the canonical basis <span class="math">\\{1,\\zeta,\\dots,\\zeta^{(2k-1)-1}\\}</span> of <span class="math">\\mathbb{F}_{p^{2k-1}}</span> and replace the first <span class="math">k</span> elements by the evaluations of degree <span class="math">k</span> Lagrange polynomials at <span class="math">\\zeta</span>, which is a basis for <span class="math">\\mathbb{F}_{p}^{k}</span> and <span class="math">\\operatorname{Im}(\\phi_{\\mathrm{int}})\\subseteq\\mathbb{F}_{p}^{k}</span>.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">4.3 Asymptotic results</h3>

    <p class="text-gray-300">We need a family of systematic <span class="math">(a,b)_{p}</span>-RMFE such that <span class="math">b\\in O(a)</span>. Below we explain how such a family exists for every finite field <span class="math">\\mathbb{F}_{p}</span>.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Proposition 4.10 (<em>[x18, Theorem 5.2.10(c)]</em>).</h6>

    <p class="text-gray-300">For every function field <span class="math">F/\\mathbb{F}_{p}</span> and <span class="math">b\\in\\mathbb{N}</span> with <span class="math">2g+1\\leq p^{(b-1)/2}(\\sqrt{p}-1)</span>, there exists a place in <span class="math">F</span> of degree <span class="math">b</span>. In particular, this holds for every <span class="math">m\\geq 4g+3</span>, regardless of <span class="math">p</span>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Remark 4.11.</h6>

    <p class="text-gray-300">For <span class="math">a\\geq 2</span>, any <span class="math">b\\geq 2a+4g-1</span> satisfies the inequality in Proposition 4.10. Therefore, as long as <span class="math">F/\\mathbb{F}_{p}</span> has at least <span class="math">a</span> distinct rational places, we can construct <span class="math">(a,b)_{p}</span>-RMFE for any <span class="math">b\\geq 2a+4g-1</span> according to Definition 4.6.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 4.12 (<em>[x1, Theorem 5]</em>).</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, there exists a family of <span class="math">(a,b)_{p}</span>-RMFE (via the construction in Definition 4.6) where <span class="math">\\lim_{a\\to\\infty}\\frac{b}{a}=2+\\frac{4}{A(p)}</span> (here <span class="math">A(p)</span> is Ihara’s constant).</p>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider a family <span class="math">\\{F_{l}\\}_{l}</span> of function fields over <span class="math">\\mathbb{F}_{p}</span> of growing genus <span class="math">g_{l}\\to\\infty</span> such that <span class="math">N_{1}(F_{l})/g_{l}\\to A(p)</span>. Let <span class="math">a=N_{1}(F_{l})</span> and <span class="math">b=2a+4g_{l}-1</span>. Note that <span class="math">N_{1}(F_{l})</span> is the number of distinct rational places of <span class="math">F_{l}</span>, let <span class="math">\\{P_{1},\\dots,P_{k}\\}</span> be these places. We take <span class="math">G</span> to be a degree-<span class="math">(a+2g_{l}-1)</span> divisor such that <span class="math">\\operatorname{supp}(G)\\cap\\{P_{1},\\dots,P_{k}\\}=\\emptyset</span>. Since <span class="math">\\deg G\\geq 2g_{l}-1</span> and <span class="math">\\deg G-\\sum_{i=1}^{k}P_{i}\\geq 2g_{l}-1</span>, the Riemann Theorem guarantees that <span class="math">\\dim_{\\mathbb{F}_{p}}\\mathcal{L}(G)-\\dim_{\\mathbb{F}_{p}}\\mathcal{L}(G-\\sum_{i=1}^{k}P_{i})=k</span>. Then by Lemma 4.7, the construction in Definition 4.6 yields a <span class="math">(a,b)_{p}</span>-RMFE. ∎</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Remark 4.13.</h6>

    <p class="text-gray-300">For <span class="math">p=2</span>, <em>[x11]</em> proves the lower bound <span class="math">A(2)\\geq 0.31</span>. So by Theorem 4.12 there exists a family of <span class="math">(a,b)_{2}</span>-RMFE with <span class="math">\\lim_{a\\to\\infty}\\frac{b}{a}\\leq 2+\\frac{4}{0.31}\\approx 14.903</span>. The lower bound is constructive: <em>[x11]</em> gives a construction for an infinite sequence of function fields <span class="math">\\{F_{l}\\}_{l}</span> over <span class="math">\\mathbb{F}_{2}</span> such that <span class="math">N_{1}(F_{l})/g_{l}\\to 0.31</span>.</p>

    <p class="text-gray-300"><em>[x1, Corollary 2]</em> also gives an explicit family of <span class="math">(a,b)_{2}</span>-RMFE with <span class="math">\\lim_{a\\to\\infty}\\frac{b}{a}\\to c\\approx 4.92</span>. Instead of finding a bound on <span class="math">A(2)</span> and then applying Theorem 4.12, they build a family of <span class="math">(a,b)_{32}</span>-RMFE where <span class="math">\\lim_{a\\to\\infty}\\frac{b}{a}=\\frac{62}{21}</span>, and then show that the concatenation of a <span class="math">(3,5)_{2}</span>-RMFE and the family of <span class="math">(a,b)_{32}</span>-RMFE is a family of <span class="math">(3a,5b)_{2}</span>-RMFE where <span class="math">\\lim_{a\\to\\infty}\\frac{5b}{3a}\\approx 4.92</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">5 Biased generators</p>

    <p class="text-gray-300">We define two biased generators that are later used in our constructions.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{n}</span> be a function. We say that <span class="math">G</span> is an <span class="math">\\epsilon</span>-biased generator if</p>

    <p class="text-gray-300"><span class="math">\\max_{w\\in\\mathbb{F}^{n}\\setminus\\{0\\}}\\Pr_{x\\in\\mathbb{F}^{s}}[\\langle w,G(x)\\rangle=0]\\leq\\epsilon\\enspace.</span></p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Lemma 5.2 (<em>[x1, Lemma 4.5]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{n}</span> be an <span class="math">\\epsilon</span>-biased generator and let <span class="math">G^{\\prime}\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{n}</span> be an <span class="math">\\epsilon^{\\prime}</span>-biased generator. Then, the function <span class="math">G\\otimes G^{\\prime}\\colon(x,x^{\\prime})\\mapsto G(x)\\otimes G^{\\prime}(x^{\\prime})</span> is an <span class="math">(\\epsilon+\\epsilon^{\\prime})</span>-biased generator.</p>

    <h6 id="sec-60" class="text-base font-medium mt-4">Definition 5.3.</h6>

    <p class="text-gray-300">Let <span class="math">G_{\\mathsf{sub}}\\colon\\mathbb{F}^{s}_{p^{\\lambda}}\\to\\mathbb{F}_{p}^{\\lambda\\times\\lambda b^{\\prime}}</span> be a function. We say that <span class="math">G_{\\mathsf{sub}}</span> is a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generator if for any <span class="math">\\mathbb{F}_{p}</span>-linear subspace <span class="math">H\\subseteq\\mathbb{F}_{p^{\\lambda}}</span>,</p>

    <p class="text-gray-300"><span class="math">\\max_{v\\in\\mathbb{F}^{\\lambda b^{\\prime}}\\setminus H^{\\lambda b^{\\prime}}}\\Pr_{r\\leftarrow\\mathbb{F}_{p^{\\lambda}}^{s}}\\left[G_{\\mathsf{sub}}(r)v=\\vec{0}\\mod H^{\\lambda b^{\\prime}}\\right]\\leq\\epsilon_{\\mathsf{sub}}\\enspace.</span></p>

    <p class="text-gray-300">We note that <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generators can be constructed from <span class="math">\\epsilon</span>-biased generators. A proof is given in Section 5.1.</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">5.1 A subspace biased generator from an <span class="math">\\epsilon</span>-biased generator</h3>

    <p class="text-gray-300">In this section we provide a construction for the <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon</span>-biased generator for <span class="math">\\mathbb{F}</span> which is used in the modular lincheck protocol. The construction is done by doing transformation to an <span class="math">\\epsilon</span>-biased generator over <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>.</p>

    <p class="text-gray-300">Before introducing the construction we make two observations about fields of the form <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Observation 5.4.</h6>

    <p class="text-gray-300">For an degree-<span class="math">\\lambda</span> irreducible polynomial <span class="math">P</span> in <span class="math">\\mathbb{F}_{p}[X]</span>, <span class="math">\\mathbb{F}_{p^{\\lambda}}\\cong\\mathbb{F}_{p}[X]/(P)</span>. Every element <span class="math">f\\in\\mathbb{F}_{p}[X]/(P)</span> has a matrix representation <span class="math">M_{f}\\in\\mathbb{F}_{p}^{\\lambda\\times\\lambda}</span> such that for any <span class="math">g=\\sum_{i=0}^{\\lambda-1}a_{i}X^{i}\\in\\mathbb{F}_{p}[X]/(P)</span> with associated coefficient vector <span class="math">\\vec{g}</span>, <span class="math">M_{f}\\cdot\\vec{g}</span> is the coeffcient vector for <span class="math">f\\cdot g\\in\\mathbb{F}_{p}[X]/(P)</span>.</p>

    <h6 id="sec-63" class="text-base font-medium mt-4">Construction 5.5.</h6>

    <p class="text-gray-300">Given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}^{s}_{p^{\\lambda}}\\to\\mathbb{F}^{b^{\\prime}}_{p^{\\lambda}}</span> as input. Fix <span class="math">r\\in\\mathbb{F}^{s}_{p^{\\lambda}}</span>. Use <span class="math">G(r)_{i}\\in\\mathbb{F}_{p^{\\lambda}}</span> to denote the <span class="math">i</span>-th element of <span class="math">G(r)</span>, and <span class="math">G_{\\mathsf{sub}}(r)_{i}\\in\\mathbb{F}_{p}^{\\lambda\\times\\lambda}</span> to denote the <span class="math">i</span>-th <span class="math">\\lambda\\times\\lambda</span> block of <span class="math">G_{\\mathsf{sub}}(r)</span>. Then <span class="math">G_{\\mathsf{sub}}(r)_{i}</span> is defined to be <span class="math">M_{G(r)_{i}}</span>, the matrix representation of <span class="math">G(r)_{i}</span> from Observation 5.4.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 5.6.</h6>

    <p class="text-gray-300">Given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}^{s}_{p^{\\lambda}}\\to\\mathbb{F}^{b^{\\prime}}_{p^{\\lambda}}</span>, the construction in Construction 5.5 gives a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon</span>-biased generator <span class="math">G_{\\mathsf{sub}}</span> for <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By definition of an <span class="math">\\epsilon</span>-biased generator, we know that for any <span class="math">z\\in\\mathbb{F}_{p}^{b^{\\prime}}\\setminus\\{\\vec{0}\\}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r\\leftarrow\\mathbb{F}_{p^{\\lambda}}^{s}}[\\langle G(r),z\\rangle=0]\\leq\\epsilon\\enspace.</span> (2)</p>

    <p class="text-gray-300">We now show that <span class="math">G_{\\mathsf{sub}}</span> in Construction 5.5 is indeed a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon</span>-biased generator for <span class="math">\\mathbb{F}</span>. Let <span class="math">\\theta\\colon\\mathbb{F}_{p}^{\\lambda}\\to\\mathbb{F}_{p^{\\lambda}}</span> be the isomorphism that maps a vector <span class="math">b\\in\\mathbb{F}_{p}^{\\lambda}</span> to <span class="math">\\sum_{j=0}^{\\lambda-1}b_{j}X^{j}\\in\\mathbb{F}_{p^{\\lambda}}</span>. Then we note that for any <span class="math">x\\in\\mathbb{F}_{p^{\\lambda}}</span> and <span class="math">i=1,\\ldots,\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">G(r)_{i}\\cdot\\theta(b)=\\theta\\left(M_{G(r)_{i}}\\cdot b\\right)=\\theta\\left(G_{\\mathsf{sub}}(r)_{i}\\cdot b\\right)</span></p>

    <p class="text-gray-300">For any <span class="math">H\\subseteq\\mathbb{F}</span> a <span class="math">\\mathbb{F}_{p}</span>-linear subspace of <span class="math">\\mathbb{F}</span>, let <span class="math">j=\\dim H</span>. We can find a base <span class="math">e_{1},\\ldots,e_{k}</span> of <span class="math">\\mathbb{F}</span> such that <span class="math">e_{1},\\ldots,e_{j}</span> is a basis for <span class="math">H</span>. Consider any <span class="math">v\\in\\mathbb{F}^{\\lambda b^{\\prime}}\\setminus H^{\\lambda b^{\\prime}}</span>. Then represent <span class="math">v</span> using this basis as</p>

    <p class="text-gray-300"><span class="math">v=\\sum_{i=1}^{k}e_{i}c_{i}</span></p>

    <p class="text-gray-300">where <span class="math">c_{i}\\in\\mathbb{F}_{p}^{\\lambda b^{\\prime}}</span>.</p>

    <p class="text-gray-300">We have that</p>

    <p class="text-gray-300"><span class="math">G_{\\mathsf{sub}}(r)v</span> <span class="math">=\\sum_{i=1}^{k}e_{i}G_{\\mathsf{sub}}(r)c_{i}</span> <span class="math">=\\sum_{i=1}^{k}e_{i}\\theta^{-1}(\\langle G(r),\\theta(c_{i})\\rangle)</span></p>

    <p class="text-gray-300">Suppose <span class="math">G_{\\mathsf{sub}}(r)v=\\vec{0}\\mod H^{\\lambda}</span>. Then for all <span class="math">i&gt;j</span> we have <span class="math">\\theta^{-1}(\\langle G(r),\\theta(c_{i})\\rangle)=\\vec{0}</span>. Additionally, since <span class="math">v\\not\\in H^{\\lambda b^{\\prime}}</span>, there exists some <span class="math">i^{<em>}&gt;j</span> such that <span class="math">c_{i^{</em>}}\\neq\\vec{0}</span>. Therefore</p>

    <p class="text-gray-300"><span class="math">\\Pr_{r\\leftarrow\\mathbb{F}_{p^{\\lambda}}^{<em>}}\\Big{[}G_{\\mathsf{sub}}(r)v=\\vec{0}\\mod H^{\\lambda}\\Big{]}</span> <span class="math">\\leq\\Pr_{r\\leftarrow\\mathbb{F}_{p^{\\lambda}}^{</em>}}\\Big{[}\\theta^{-1}(\\langle G(r),\\theta(c_{i^{<em>}})\\rangle)=\\vec{0}\\Big{]}</span> <span class="math">=\\Pr_{r\\leftarrow\\mathbb{F}_{p^{\\lambda}}^{</em>}}[\\langle G(r),\\theta(c_{i^{*}})\\rangle=0]\\leq\\epsilon</span></p>

    <p class="text-gray-300">The last inequality holds by definition of <span class="math">G</span>. Thereby we complete the proof. ∎</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Remark 5.7.</h6>

    <p class="text-gray-300">Note that for our construction to work, a weaker <span class="math">\\epsilon</span>-biased generator <span class="math">G</span> suffices. We only requires that Equation (2) holds for all <span class="math">z\\in\\mathbb{F}_{p}^{b^{\\prime}}\\setminus\\{\\vec{0}\\}</span> instead of for all <span class="math">z\\in\\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}\\setminus\\{\\vec{0}\\}</span>.</p>

    <p class="text-gray-300">We also note that computing <span class="math">G_{\\mathsf{sub}}(r)</span> takes <span class="math">O(\\mathsf{o}_{G})\\ \\mathbb{F}_{p^{\\lambda}}</span> operations, where <span class="math">\\mathsf{o}_{G}</span> denotes the number of operations needed to compute <span class="math">G(r)</span>.</p>

    <h3 id="sec-67" class="text-xl font-semibold mt-8">5.2 A biased generator computable in linear time</h3>

    <p class="text-gray-300">We describe a biased generator that is computable in linear time, over any given field <span class="math">\\mathbb{F}</span>. The construction is a generalization of the biased generator in <em>[x21]</em> for the boolean field <span class="math">\\mathbb{F}_{2}</span>. First we describe a construction based on any linear error correcting code over <span class="math">\\mathbb{F}</span>, and then we deduce the desired result via the existence of linear codes of constant rate and relative distance that are efficiently encodable.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Lemma 5.8.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{C}\\subseteq\\mathbb{F}^{n}</span> be a linear code with rate <span class="math">r</span> and relative distance <span class="math">\\delta</span>. If <span class="math">\\mathcal{C}</span>’s generator matrix can be computed in time <span class="math">O(n^{c})</span>, then for any integer <span class="math">t</span> there exists a $(\\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(1-\\delta^{c})^{t}+\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">-biased generator </span>G\\colon\\mathbb{F}^{t}\\times[n]^{tc}\\to\\mathbb{F}^{(rn)^{c}}<span class="math"> that is computable with </span>O(tcn^{c})<span class="math"> </span>\\mathbb{F}$-operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">M\\in\\mathbb{F}^{n\\times rn}</span> be the generating matrix of the code <span class="math">\\mathcal{C}</span>, and <span class="math">M_{i}</span> be its <span class="math">i</span>-th row. Then consider the function <span class="math">S(i)=M_{i}</span>. We observe that first <span class="math">S</span> can be computed in time <span class="math">O(n^{c})</span>, and second <span class="math">S\\colon[n]\\to\\mathbb{F}^{rn}</span> is a <span class="math">(1-\\delta)</span>-biased generator. This is because for every <span class="math">\\vec{y}\\in\\mathbb{F}^{rn}\\setminus\\{\\vec{0}\\}</span> it holds that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{i\\leftarrow[n]}[\\langle S(i),\\vec{y}\\rangle=0]=\\Pr_{i\\leftarrow[n]}[\\langle M_{i},\\vec{y}\\rangle=0]=1-\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M\\vec{y}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{0}\\leq 1-\\delta\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We prove that the tensor function <span class="math">S^{\\otimes i} \\colon i[n] \\to \\mathbb{F}^{(rn)^i}</span> is a <span class="math">(1 - \\delta^i)</span>-biased generator over <span class="math">\\mathbb{F}</span>, b induction on <span class="math">i</span>.</p>

    <p class="text-gray-300"><strong>Base case.</strong> For <span class="math">i = 1</span>, the result comes trivially.</p>

    <p class="text-gray-300"><strong>Inductive step.</strong> Suppose this fact holds for <span class="math">i - 1</span>. Consider any <span class="math">Y \\in \\mathbb{F}^{(rn)^{i-1} \\times rn}</span> that is not all zero. Use <span class="math">\\vec{Y}</span> to denote the vectorization of <span class="math">Y</span>, which stacks the columns of <span class="math">Y</span> to make it a column vector. Then we have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\operatorname{Pr}_{(x, x&#x27;) \\leftarrow [n]^{i-1} \\times [n]} [\\langle S^{\\otimes i}(x) \\otimes S(x&#x27;), \\vec{Y} \\rangle = 0] \\\\ &amp;amp; = \\operatorname{Pr}_{(x, x&#x27;) \\leftarrow [n]^{i-1} \\times [n]} [S^{\\otimes i}(x)^T Y S(x&#x27;) = 0] \\\\ &amp;amp; = \\operatorname{Pr}_{x&#x27; \\leftarrow [n]} [Y S(x&#x27;) = \\vec{0}] + \\operatorname{Pr}_{x&#x27; \\leftarrow [n]} [Y S(x&#x27;) \\neq \\vec{0}] \\cdot \\operatorname{Pr}_{x \\leftarrow [n]^{i-1}} [\\langle S^{\\otimes i}(x), Y S(x&#x27;) \\rangle = 0 \\mid Y S(x&#x27;) \\neq \\vec{0}] \\\\ &amp;amp; \\leq (1 - \\delta) + \\delta \\cdot (1 - \\delta^{i-1}) \\\\ &amp;amp; = 1 - \\delta^i. \\end{aligned}</span></div>

    <p class="text-gray-300">Therefore the function <span class="math">S^{\\otimes c}[n]^c \\to \\mathbb{F}^{(rn)^c}</span> is a <span class="math">(1 - \\delta^c)</span>-biased generator.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use <span class="math">S^{\\otimes c}</span> to construct the <span class="math">\\epsilon</span>-biased generator <span class="math">G \\colon \\mathbb{F}^t \\times [n]^{tc} \\to \\mathbb{F}^{(rn)^c}</span> with $\\epsilon = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} (1 - \\delta^c)^t + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. For any </span>z \\in \\mathbb{F}^t<span class="math"> and </span>x = (x_i)_{i \\in [t]}<span class="math"> where </span>x_i \\in [k]^c<span class="math">, we define </span>G(z, x) \\coloneqq \\sum_{i=1}^{t} z_i S^{\\otimes c}(x_i)<span class="math">. For every </span>\\vec{y} \\in \\mathbb{F}^{(rn)^c} \\setminus \\{\\vec{0}\\}$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{aligned} &amp; \\operatorname{Pr}_{z \\leftarrow \\mathbb{F}^t, x \\leftarrow [n]^{tc}} [\\langle G(z, x), \\vec{y} \\rangle = 0] \\\\ &amp; = \\operatorname{Pr}_{z \\leftarrow \\mathbb{F}^t, x \\leftarrow [n]^{tc}} \\left[ \\sum_{i=1}^{t} z_i \\langle S^{\\otimes c}(x_i), \\vec{y} \\rangle = 0 \\right] \\\\ &amp; = \\operatorname{Pr}_{x \\leftarrow [n]^{tc}} \\left[ \\forall i, \\langle S^{\\otimes c}(x_i), \\vec{y} \\rangle = 0 \\right] + \\operatorname{Pr}_{x \\leftarrow [n]^{tc}} \\left[ \\exists i, \\langle S^{\\otimes c}(x_i), \\vec{y} \\rangle \\neq 0 \\right] \\cdot \\max_{\\vec{y}' \\in \\mathbb{F}^t \\setminus \\{\\vec{0}\\}} \\operatorname{Pr}_{z \\sim \\mathbb{F}^t} \\left[ \\langle z, \\vec{y}' \\rangle = 0 \\right] \\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&amp; \\leq (1 - \\delta^c)^t + (1 - (1 - \\delta^c)^t) \\cdot \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\frac{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} (1 - \\delta^c)^t + \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{aligned} $$</p>

    <p class="text-gray-300">To compute <span class="math">G</span>, we call <span class="math">S</span> tc times, compute <span class="math">t</span> order <span class="math">c</span> tensor products, and calculate the linear combination of <span class="math">t</span> vectors in <span class="math">\\mathbb{F}^{(rn)^c}</span>. This in total takes <span class="math">O(tcn^c + t(rn)^c) = O(tcn^c)</span> operations in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300"><strong>Lemma 5.9</strong> ([DI14, Lemma 3.1.4]). There exist constants <span class="math">d_1 &amp;gt; 1</span> and <span class="math">d_2 &amp;gt; 0</span> such that for every finite field <span class="math">\\mathbb{F}</span> there exists a family of linear codes with code length <span class="math">\\lfloor d_1 k \\rfloor</span>, dimension <span class="math">k</span>, and minimum distance <span class="math">\\lceil d_2 k \\rceil</span> over <span class="math">\\mathbb{F}</span> which can be encoded by a uniform family of linear-size arithmetic circuits consisting of addition and fan-out gates only.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Corollary 5.10.</strong> For every finite field <span class="math">\\mathbb{F}</span>, and constant $\\epsilon &gt; \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">, there exists a family of </span>\\epsilon<span class="math">-biased generators </span>G \\colon \\mathbb{F}^{\\log_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}(n)} \\to \\mathbb{F}^{O(n)}<span class="math"> that can be computed with </span>O(n)<span class="math"> </span>\\mathbb{F}$-operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Invoke Lemma 5.8 with the codes in Lemma 5.9.</p>

    <p class="text-gray-300">6 Tensor IOP for R1CS over every field</p>

    <p class="text-gray-300">We construct a tensor-query IOP for R1CS over fields <span class="math">\\mathbb{F}_{p}</span> for any prime power <span class="math">p</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Definition 6.1 (R1CS).</h6>

    <p class="text-gray-300">The indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> is the set of all triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=\\left((\\mathbb{F}_{p},n_{\\mathrm{row}},n_{\\mathrm{col}},A,B,C),(n_{\\mathrm{in}},x),w\\right)</span></p>

    <p class="text-gray-300">where <span class="math">\\mathbb{F}_{p}</span> is a finite field, <span class="math">A,B,C</span> are matrices in <span class="math">\\mathbb{F}_{p}^{n_{\\mathrm{row}}\\times n_{\\mathrm{col}}}</span> each with at most <span class="math">M</span> non-zero entries, <span class="math">x\\in\\mathbb{F}_{p}^{n_{\\mathrm{in}}}</span>, <span class="math">w\\in\\mathbb{F}_{p}^{n_{\\mathrm{col}}-n_{\\mathrm{in}}}</span>, and <span class="math">z\\coloneqq(x,w)\\in\\mathbb{F}_{p}^{n_{\\mathrm{col}}}</span> is a vector such that <span class="math">Az\\circ Bz=Cz</span>. (Here “<span class="math">\\circ</span>” is the entry-wise product.)</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Theorem 6.2.</h6>

    <p class="text-gray-300">For all prime powers <span class="math">p</span>, and every finite field <span class="math">\\mathbb{F}_{p^{b}}</span> such that <span class="math">p^{b}\\in\\Omega(\\log n_{\\mathrm{col}})</span>, given a systematic <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span> such that <span class="math">a\\in\\Theta(b)</span>, there is a <span class="math">(\\mathbb{F}_{p^{b}},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with <span class="math">n_{\\mathrm{row}}=n_{\\mathrm{col}}=a\\cdot k^{t}</span>, <span class="math">n_{\\mathrm{in}}=a\\cdot\\ell_{\\mathrm{in}}\\cdot k^{t_{\\mathrm{in}}}</span> and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log(n_{\\mathrm{row}}/a))</span>;</li>

      <li>proof length is <span class="math">O(n_{\\mathrm{row}}/a)</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span>;</li>

      <li>query complexity is <span class="math">O(1)</span>;</li>

      <li>the prover sends <span class="math">O(\\log(n_{\\mathrm{row}}/a))</span> non-oracle messages over <span class="math">\\mathbb{F}_{p^{b}}</span>;</li>

      <li>the prover uses <span class="math">O(M+n_{\\mathrm{row}})</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tn_{\\mathrm{row}}/a)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier uses <span class="math">O(M+n_{\\mathrm{row}})</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tk)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(\\log(n_{\\mathrm{row}}/a))</span> over <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">O(\\log(n_{\\mathrm{row}}/a))</span> over <span class="math">\\mathbb{F}_{p}</span>.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">M</span> denotes the number of non-zero entries in the instance matrices <span class="math">A</span>, <span class="math">B</span>, <span class="math">C</span>.</p>

    <p class="text-gray-300">Our construction involves first embedding the instance matrices into a large field <span class="math">\\mathbb{F}_{p^{b}}</span> using a systematic RMFE, and then reducing the <span class="math">\\mathrm{R1CS}</span> relation over <span class="math">\\mathbb{F}_{p}</span> to a different relation over <span class="math">\\mathbb{F}_{p^{b}}</span>. This relation requires the embedded instance matrices to satisfy a set of modular-linear equalities. So we need to construct a protocol for the modular-linear relation. In its constructor, we make use of a tensor-query protocol for the multi-lincheck relation. This section is organized as follows. We first introduce the protocol for the multi-lincheck relation. Then based on that, we construct the modular-linear relation protocol. Building on top of that, we provide a tensor IOP for <span class="math">R_{\\mathrm{R1CS}}</span> that achieves linear time.</p>

    <h3 id="sec-72" class="text-xl font-semibold mt-8">6.1 Multi-lincheck</h3>

    <p class="text-gray-300">We describe a tensor-query IOP for the multi-lincheck relation, which tests the sum of several matrix products. We first define the twisted scalar product relation, which is used as a subroutine in the multi-lincheck protocol.</p>

    <h6 id="sec-73" class="text-base font-medium mt-4">Definition 6.3.</h6>

    <p class="text-gray-300">The twisted scalar product relation <span class="math">R_{\\mathrm{TSP}}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=(\\bot,(\\mathbb{F},n,\\vec{y},\\tau),(\\vec{a},\\vec{b}))</span></p>

    <p class="text-gray-300">where <span class="math">\\vec{a},\\vec{b},\\vec{y}\\in\\mathbb{F}^{n}</span>, <span class="math">\\tau\\in\\mathbb{F}</span>, and <span class="math">\\langle\\vec{a}\\circ\\vec{y},\\vec{b}\\rangle=\\tau</span>.</p>

    <h6 id="sec-74" class="text-base font-medium mt-4">Lemma 6.4 (<em>[x1, Theorem 5.13]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor exact IOPP for the indexed relation <span class="math">R_{\\mathrm{TSP}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">n=\\ell\\cdot k^{t}</span> and <span class="math">\\vec{y}=\\vec{y}_{0}\\otimes\\vec{y}_{1}\\otimes\\cdots\\otimes\\vec{y}_{t}</span> for <span class="math">\\vec{y}_{0}\\in\\mathbb{F}^{\\ell}</span>, <span class="math">\\vec{y}_{1},\\ldots,\\vec{y}_{t}\\in\\mathbb{F}^{k}</span>, and has the following parameters: soundness error is $O(\\log n/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">; round complexity is </span>O(\\log n)<span class="math">; query complexity is </span>O(1)<span class="math">; the prover sends </span>O(\\log n)<span class="math"> non-oracle messages in </span>\\mathbb{F}<span class="math"> and the proof length is </span>O(n)<span class="math"> elements in </span>\\mathbb{F}<span class="math">; the prover uses </span>O(n)<span class="math"> field operations; the verifier uses </span>O(\\ell+tk)<span class="math"> field operations; and the verifier has randomness complexity </span>O(\\log n)<span class="math"> elements in </span>\\mathbb{F}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-75" class="text-base font-medium mt-4">Definition 6.5.</h6>

    <p class="text-gray-300">The multi-lincheck relation <span class="math">R_{\\mathrm{mlin}}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})=(((U_{i})_{i\\in[h]},\\vec{b}),(\\mathbb{F},n_{\\mathrm{row}},n_{\\mathrm{col}},h,(M_{i})_{i\\in[h]}),(\\vec{x}_{i})_{i\\in[h]})</span></p>

    <p class="text-gray-300">where <span class="math">U_{i}\\in\\mathbb{F}^{n_{\\mathrm{row}}\\times n_{\\mathrm{col}}}</span> has <span class="math">M_{i}</span> non-zero entries, <span class="math">\\vec{x}_{i}\\in\\mathbb{F}^{n_{\\mathrm{col}}}</span>, <span class="math">\\vec{b}\\in\\mathbb{F}^{n_{\\mathrm{row}}}</span>, and <span class="math">\\sum_{i=1}^{h}U_{i}\\vec{x}_{i}=\\vec{b}</span>.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Theorem 6.6.</h6>

    <p class="text-gray-300">For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k,t</span>, there is a <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{mlin}}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">n_{\\mathrm{col}}=\\ell\\cdot k^{t}</span> and arbitrary <span class="math">n_{\\mathrm{row}}</span> and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>perfect completeness;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O(\\log n_{\\mathrm{col}}/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(\\log n_{\\mathrm{col}})</span>;</li>

      <li>proof length is <span class="math">O(hn_{\\mathrm{col}})</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity is <span class="math">O(h)</span>;</li>

      <li>the prover sends <span class="math">O(h(n_{\\mathrm{row}}+\\log n_{\\mathrm{col}}))</span> non-oracle messages;</li>

      <li>the prover uses <span class="math">O(hn_{\\mathrm{col}}+hn_{\\mathrm{row}}+\\sum_{i=1}^{h}M_{i})</span> field operations;</li>

      <li>the verifier uses <span class="math">O(\\sum_{i=1}^{h}M_{i}+h\\cdot(\\ell+kt))</span> field operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(h\\log n_{\\mathrm{col}})</span> elements in <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <h6 id="sec-77" class="text-base font-medium mt-4">Construction 6.7 (tensor IOP for <span class="math">R_{\\mathrm{mlin}}</span>).</h6>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> takes as input the index <span class="math">\\mathbbm{i}=((U_{i})_{i\\in[h]},\\vec{b})</span>, instance <span class="math">\\mathbbm{x}=(\\mathbb{F},n_{\\mathrm{row}},n_{\\mathrm{col}},h,(M_{i})_{i\\in[h]})</span>, and witness <span class="math">\\mathbbm{w}=(\\vec{x}_{i})_{i\\in[h]}</span>, while the verifier <span class="math">\\mathbf{V}</span> takes as input <span class="math">\\mathbbm{i}</span> and <span class="math">\\mathbbm{x}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> computes <span class="math">\\vec{b}_{i}=U_{i}\\vec{x}_{i}\\in\\mathbb{F}^{n_{\\mathrm{row}}}</span>. The prover <span class="math">\\mathbf{P}</span> sends the oracle messages <span class="math">\\mathbbm{w}</span> and non-oracle messages <span class="math">(\\vec{b}_{i})_{i\\in[h]}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> sends uniformly random challenge vector <span class="math">\\vec{r}\\in\\mathbb{F}^{n_{\\mathrm{row}}}</span>.</li>

      <li>The prover <span class="math">\\mathbf{P}</span> computes <span class="math">\\tau_{i}=\\langle\\vec{r},\\vec{b}_{i}\\rangle\\in\\mathbb{F}</span> and <span class="math">\\vec{a}_{i}=\\vec{r}^{\\intercal}U_{i}\\in\\mathbb{F}^{n_{\\mathrm{col}}}</span>. The prover <span class="math">\\mathbf{P}</span> sends the non-oracle messages <span class="math">(\\tau_{i})_{i\\in[h]}\\in\\mathbb{F}^{h}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> computes <span class="math">\\vec{a}_{i}=\\vec{r}^{\\intercal}U_{i}\\in\\mathbb{F}^{n_{\\mathrm{col}}}</span>.</li>

      <li>The prover <span class="math">\\mathbf{P}</span> and the verifier <span class="math">\\mathbf{V}</span> engage in <span class="math">h</span> TSP protocols, each of which with <span class="math">\\mathbbm{i}=\\perp</span>, <span class="math">\\mathbbm{x}=(\\mathbb{F},n_{\\mathrm{col}},\\vec{1},\\tau_{i})</span>, and <span class="math">\\mathbbm{w}=(\\vec{a}_{i},\\vec{x}_{i})</span> to check that <span class="math">\\langle\\vec{a}_{i}\\circ\\vec{1},\\vec{x}_{i}\\rangle=\\tau_{i}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> computes <span class="math">\\langle\\vec{r},\\vec{b}_{i}\\rangle</span> and checks that <span class="math">\\tau_{i}=\\langle\\vec{r},\\vec{b}_{i}\\rangle</span>. The verifier computes <span class="math">\\langle\\vec{r},\\vec{b}\\rangle</span> and checks that <span class="math">\\sum_{i=1}^{h}\\tau_{i}=\\langle\\vec{r},\\vec{b}\\rangle</span>.</li>

    </ul>

    <h6 id="sec-78" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We analyze the error and efficiency parameters of the above construction.</p>

    <p class="text-gray-300">Completeness. Suppose <span class="math">\\sum_{i=1}^{h}U_{i}\\vec{x}_{i}=\\vec{b}</span>. The honest prover sends the correct values of <span class="math">(\\vec{b}_{i})_{i\\in[h]}</span> and <span class="math">(\\tau_{i})_{i\\in[h]}</span>. Then by the completeness of the TSP protocol, each check of <span class="math">\\langle\\vec{a}_{i},\\vec{x}_{i}\\rangle=\\tau_{i}</span> passes, and by definition, the check for <span class="math">\\sum_{i=1}^{h}\\tau_{i}=\\langle\\vec{r},\\vec{b}\\rangle</span> also passes. Therefore, the construction is perfectly complete.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. The soundness error is $O(\\log n_{\\mathrm{col}}/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">: Suppose </span>\\sum_{i=1}^{h}U_{i}\\vec{x}_{i}\\neq\\vec{b}$. If the verifier accepts, then there are two possible cases:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The honestly computed <span class="math">(\\tau_{i})_{i\\in[h]}</span> satisfies that <span class="math">\\sum_{i=1}^{h}\\tau_{i}=\\langle\\vec{r},\\vec{b}\\rangle</span>: Consider <span class="math">\\sum_{i=1}^{h}\\tau_{i}=\\langle\\vec{r},\\vec{b}\\rangle</span> as a polynomial with respect to the <span class="math">n_{\\mathrm{row}}</span> coordinate of <span class="math">\\vec{r}</span>, each uniformly randomly sampled from <span class="math">\\mathbb{F}</span>, by Schwartz–Zippel Lemma, we have that $\\Pr[\\sum_{i=1}^{h}\\tau_{i}=\\langle\\vec{r},\\vec{b}\\rangle]\\leq 1/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\log n_{\\mathrm{col}}/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- At least one value <span class="math">\\tau_{i^{*}}</span> is not honestly computed: the probability that the verifier accepts is at most the soundness error of the TSP protocol, which is $\\log n_{\\mathrm{col}}/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Efficiency parameters.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(\\log n_{\\mathrm{col}})</span>: The round complexity of the protocol is dominated by the round complexity of the TSP protocol, which is <span class="math">O(\\log n_{\\mathrm{col}})</span>.</li>

      <li>proof length is <span class="math">O(hn_{\\mathrm{col}})</span> elements in <span class="math">\\mathbb{F}</span>: The proof length is the sum of length of <span class="math">\\vec{x}_{i}</span>’s and the proof length for the TSP protocols. We know that the proof length for one TSP protocol is <span class="math">O(n_{\\mathrm{col}})</span> elements in <span class="math">\\mathbb{F}</span>, the total proof length is <span class="math">O(hn_{\\mathrm{col}})</span>.</li>

      <li>query complexity is <span class="math">O(h)</span>: The query complexity is dominated by the TSP protocols, which is <span class="math">O(h)</span> in total.</li>

      <li>the prover sends <span class="math">O(h(n_{\\mathrm{row}}+\\log n_{\\mathrm{col}}))</span> non-oracle messages: The non-oracle messages sent by the prover are <span class="math">\\tau_{i}</span>’s and <span class="math">\\vec{b}_{i}</span>’s, and the non-oracle messages in the TSP protocols, which in total is <span class="math">O(hn_{\\mathrm{row}})+O(h\\log n_{\\mathrm{col}})</span>.</li>

      <li>the prover uses <span class="math">O(hn_{\\mathrm{col}}+hn_{\\mathrm{row}}+\\sum_{i=1}^{h}M_{i})</span> field operations: The prover uses <span class="math">O(M_{i})</span> operations in <span class="math">\\mathbb{F}</span> to compute each <span class="math">\\vec{b}_{i}</span>’s. Then the prover uses <span class="math">O(hn_{\\mathrm{row}}+\\sum_{i=1}^{h}M_{i})</span> to compute <span class="math">\\tau_{i}</span>’s and <span class="math">\\vec{a}_{i}</span>’s. Then it also uses <span class="math">O(h\\cdot n_{\\mathrm{col}})</span> to finish the SP protocols. The total number of field operations is thus <span class="math">O(hn_{\\mathrm{col}}+hn_{\\mathrm{row}}+\\sum_{i=1}^{h}M_{i})</span>.</li>

      <li>the verifier uses <span class="math">O(\\sum_{i=1}^{h}M_{i}+h\\cdot(\\ell+kt))</span> field operations: The verifier uses <span class="math">O(\\sum_{i=1}^{h}M_{i})</span> field operations to compute <span class="math">\\vec{a}_{i}</span>’s. The total cost needs to account for the cost of the TSP protocols as well.</li>

      <li>the verifier has randomness complexity <span class="math">O(h\\log n_{\\mathrm{col}})</span> elements in <span class="math">\\mathbb{F}</span>: The randomness complexity is dominated by the randomness complexity of the TSP protocol.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-79" class="text-xl font-semibold mt-8">6.2 Modular multi-lincheck protocol</h3>

    <h6 id="sec-80" class="text-base font-medium mt-4">Definition 6.8.</h6>

    <p class="text-gray-300">The modular multi-lincheck relation <span class="math">R_{\\mathrm{Mlin_{h}}}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathtt{x},\\mathtt{w})=((H,(U_{i})_{i\\in[h]}),(\\mathbb{F},\\mathsf{E},n_{\\mathrm{row}},n_{\\mathrm{col}},h),(\\vec{x}_{i})_{i\\in[h]})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">H\\subseteq\\mathbb{F}</span> is a <span class="math">\\mathbb{F}_{p}</span>-linear subspace of <span class="math">\\mathbb{F}</span>, <span class="math">U_{i}\\in\\mathbb{F}^{n_{\\mathrm{row}}\\times n_{\\mathrm{col}}}</span>, <span class="math">\\mathsf{E}</span> is a basis for the <span class="math">\\mathbb{F}_{p}</span> linear space <span class="math">\\mathbb{F}</span>, and <span class="math">\\vec{x}_{i}\\in\\mathbb{F}^{n_{\\mathrm{col}}}</span> such that <span class="math">\\sum_{i=1}^{h}U_{i}\\vec{x}_{i}=\\vec{0}\\mod H^{n_{\\mathrm{row}}}</span>. Additionally, <span class="math">U_{i}</span> and <span class="math">\\vec{x}_{i}</span> are given in the basis <span class="math">\\mathsf{E}</span>, so they can be written as $U_{i}=\\sum_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}A_{ij}e_{j}<span class="math"> and </span>\\vec{x}_{i}=\\sum_{j\\in[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{E}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}u_{ij}e_{j}<span class="math"> where </span>A_{ij}\\in\\mathbb{F}_{p}^{n_{\\mathrm{row}}\\times n_{\\mathrm{col}}}<span class="math"> and </span>u_{ij}\\in\\mathbb{F}_{p}^{n_{\\mathrm{col}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We construct a tensor IOP for the relation <span class="math">R_{\\mathrm{Mlin_{h}}}</span> using a tensor IOP for <span class="math">R_{\\mathrm{mlin}}</span> and a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generator for <span class="math">\\mathbb{F}</span>. Let <span class="math">\\epsilon_{\\mathrm{LC}}</span> denote the soundness error of the multi-lincheck protocol, <span class="math">\\mathsf{r}_{\\mathrm{LC}}</span> its round complexity, <span class="math">\\mathsf{l}_{\\mathrm{LC}}</span> its proof length, <span class="math">\\mathsf{qc}_{\\mathrm{LC}}</span> its query complexity, <span class="math">\\mathsf{c}_{\\mathrm{LC}}</span> its communication complexity, <span class="math">\\mathsf{tp}_{\\mathrm{LC}}</span> its prover arithmetic complexity, <span class="math">\\mathsf{tv}_{\\mathrm{LC}}</span> its verifier arithmetic complexity, and <span class="math">\\mathsf{rd}_{\\mathrm{LC}}</span> its randomness complexity. We also use <span class="math">\\mathsf{o}_{G_{\\mathsf{sub}}}</span> to denote the arithmetic complexity of computing <span class="math">G_{\\mathsf{sub}}</span>.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 6.9.</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, and every finite field <span class="math">\\mathbb{F}_{p^{b}}</span>, every <span class="math">\\mathbb{F}_{p}</span>-linear subspace <span class="math">H\\subseteq\\mathbb{F}_{p^{b}}</span>, and positive integers <span class="math">k,t</span>, given a <span class="math">(p,\\lambda)</span>-subspace <span class="math">\\epsilon_{\\mathsf{sub}}</span>-biased generator <span class="math">G_{\\mathsf{sub}}:\\mathbb{F}_{p^{\\lambda}}^{s}\\to\\mathbb{F}_{p}^{\\lambda\\times n_{\\mathrm{row}}}</span>, there is a <span class="math">(\\mathbb{F}_{p^{b}},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{Mlin_{h}}}</span> that supports instances over <span class="math">\\mathbb{F}_{p^{b}}</span> with <span class="math">n_{\\mathrm{col}}=\\ell\\cdot k^{t}</span>, and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">\\max(\\epsilon_{\\mathsf{sub}}, \\epsilon_{\\mathsf{LC}})</span>;</li>

      <li>round complexity is <span class="math">O(\\mathsf{r}_{\\mathrm{LC}})</span>;</li>

      <li>proof length is <span class="math">O(h \\cdot n_{\\mathrm{col}} + \\mathsf{l}_{\\mathrm{LC}})</span> elements in <span class="math">\\mathbb{F}_{p^b}</span>;</li>

      <li>query complexity is <span class="math">O(\\mathsf{qc}_{\\mathrm{LC}})</span>;</li>

      <li>the prover sends <span class="math">O(\\lambda + \\mathsf{c}_{\\mathrm{LC}})</span> non-oracle messages;</li>

      <li>the prover uses <span class="math">O(\\lambda \\cdot M_{\\mathsf{E}} + \\mathsf{o}_{G_{\\mathrm{sub}}}) \\mathbb{F}_p</span> operations and <span class="math">O(h \\cdot \\lambda n_{\\mathrm{col}} + \\mathsf{tp}_{\\mathrm{LC}}) \\mathbb{F}_{p^b}</span> operations;</li>

      <li>the verifier uses <span class="math">O(\\lambda \\cdot (M_{\\mathsf{E}} + b^{3}) + \\mathsf{o}_{G_{\\mathrm{sub}}}) \\mathbb{F}_{p}</span> operations and <span class="math">O(\\mathsf{tv}_{\\mathrm{LC}}) \\mathbb{F}_{p^b}</span> operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(s)</span> over <span class="math">\\mathbb{F}_{p^{\\lambda}}</span> and <span class="math">O(\\mathrm{rd}_{\\mathrm{LC}})</span> elements in <span class="math">\\mathbb{F}_{p^b}</span>.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">M_{\\mathsf{E}}</span> denotes the number of non-zero entries in <span class="math">U_{i}s&#x27;</span> coefficient matrices.</p>

    <p class="text-gray-300"><strong>Construction 6.10 (tensor IOP for <span class="math">R_{\\mathrm{Mlin_h}}</span>).</strong> We construct an interactive oracle proof <span class="math">\\mathsf{IOP} = (\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span> with tensor queries for the indexed relation <span class="math">R_{\\mathrm{Mlin_h}}</span>.</p>

    <p class="text-gray-300">The prover <span class="math">\\mathbf{P}</span> takes as input the index <span class="math">\\mathbb{i} = (H, (U_i)_{i \\in [h]})</span>, instance <span class="math">\\mathbb{x} = (\\mathbb{F}, \\mathsf{E}, n_{\\mathrm{row}}, n_{\\mathrm{col}}, h)</span>, and witness <span class="math">\\mathbb{w} = (\\vec{x}_i)_{i \\in [h]}</span>, while the verifier takes as input <span class="math">\\mathbb{i}</span> and <span class="math">\\mathbb{x}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> sends the oracle message <span class="math">\\mathbb{w}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> sends uniformly random seeds <span class="math">r \\in \\mathbb{F}_{p^{\\lambda}}^{s}</span>.</li>

      <li>The prover computes the matrix <span class="math">R = G_{\\mathrm{sub}}(r) \\in \\mathbb{F}_p^{\\lambda \\times n_{\\mathrm{row}}}</span> and the vector <span class="math">\\vec{b} = \\sum_{i=1}^{h} R U_i \\vec{x}_i \\in \\mathbb{F}^\\lambda</span>, and sends the non-oracle message <span class="math">\\vec{b}</span>.</li>

      <li>The verifier first checks that <span class="math">\\vec{b} = \\vec{0} \\mod H^{\\lambda}</span>, and rejects if the check fails.</li>

      <li>The prover and the verifier <span class="math">\\mathbf{V}</span> compute the matrices <span class="math">B_i = R U_i \\in \\mathbb{F}^{\\lambda \\times n_{\\mathrm{col}}}</span> and <span class="math">M_i</span> the number of non-zero elements in <span class="math">B_i</span>. Then they engage in a multi-lincheck protocol, with <span class="math">\\mathbb{i} = \\left((B_i)_{i \\in [h]}, \\vec{b}\\right)</span>, <span class="math">\\mathbb{x} = (\\mathbb{F}, \\lambda, n_{\\mathrm{col}}, h, (M_i)_{i \\in [h]})</span>, and <span class="math">\\mathbb{w} = (\\vec{x}_i)_{i \\in [h]}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Proof. Completeness.</strong> Suppose the triple is in the relation and the prover is honest. Then <span class="math">\\sum_{i=1}^{h} U_i \\vec{x}_i = \\vec{0} \\mod H^{n_{\\mathrm{row}}}</span>, and the prover sends the correct value <span class="math">\\vec{b}</span>. By definition <span class="math">\\vec{b} = \\vec{0} \\mod H</span>, and <span class="math">\\sum_{i=1}^{h} R U_i \\vec{x}_i = \\vec{b}</span>. So the construction is perfectly complete.</p>

    <p class="text-gray-300"><strong>Soundness error.</strong> Suppose <span class="math">\\sum_{i=1}^{h} M_i \\vec{x}_i \\neq \\vec{0} \\mod H^{n_{\\mathrm{row}}}</span>. Fix a malicious prover who sends the value <span class="math">\\vec{b&#x27;}</span>. Then one of the following three cases happens.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples <span class="math">r</span> such that <span class="math">\\sum_{i=1}^{h} G_{\\mathrm{sub}}(r) U_i \\vec{x}_i = \\vec{0} \\mod H^{n_{\\mathrm{row}}}</span>. This case happens with probability at most <span class="math">\\epsilon_{\\mathrm{sub}}</span> by Definition 5.3.</li>

      <li><span class="math">\\vec{b&#x27;} \\neq \\vec{0} \\mod H^{\\lambda}</span>. In this case the verifier always rejects and so the soundness error is 0.</li>

      <li><span class="math">\\vec{b&#x27;} \\neq \\sum_{i=1}^{h} G_{\\mathrm{sub}}(r) U_i \\vec{x}_i</span>. In this case, the multi-lincheck protocol guarantees a soundness error of <span class="math">\\epsilon_{\\mathrm{LC}}</span>.</li>

    </ul>

    <p class="text-gray-300">Thus the soundness error is the maximum of the three.</p>

    <p class="text-gray-300"><strong>Prover arithmetic complexity.</strong> First, the prover computes <span class="math">(B_i)_{i \\in [h]}</span> by multiplying the matrices <span class="math">U_i = \\sum_{j \\in [h]} A_{ij} e_j</span> with the matrix <span class="math">R \\in \\mathbb{F}_p^{\\lambda \\times n_{\\mathrm{row}}}</span>. So in total this procedure takes <span class="math">O(\\lambda \\cdot M_{\\mathsf{E}}) \\mathbb{F}_p</span>-operations. On top of this step, the prover also computes <span class="math">\\vec{b}</span>, which is done by multiplying <span class="math">B_i</span>s with <span class="math">\\vec{x}_i</span>s. Thus this step takes <span class="math">O(h \\cdot \\lambda n_{\\mathrm{col}}) \\mathbb{F}</span> operations. The other prover operations such as computing <span class="math">G_{\\mathrm{sub}}(r)</span>, and engaging in the multi-lincheck protocol take <span class="math">\\mathsf{o}_{G_{\\mathrm{sub}}} \\mathbb{F}_p</span>-operations and <span class="math">\\mathsf{tp}_{\\mathrm{LC}}</span>-<span class="math">\\mathbb{F}</span> operations.</p>

    <p class="text-gray-300">28</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier arithmetic complexity. Checking that  <span class="math">\\vec{b} = \\vec{0} \\mod H^{\\lambda}</span>  takes  $O(\\lambda \\cdot \\log_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2 \\cdot (\\log_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - \\dim(H)))<span class="math"> </span>\\mathbb{F}_p<span class="math"> -operations. As shown above, computing  </span>R<span class="math">  and  </span>B_i<span class="math"> s takes  </span>O(\\lambda \\cdot M_{\\mathsf{E}} + \\mathsf{o}_{G_{\\mathrm{sub}}})<span class="math"> </span>\\mathbb{F}_p<span class="math"> -operations, and engaging in the multi-lincheck protocol take  </span>\\mathsf{tv}_{\\mathrm{LC}}<span class="math"> </span>\\mathbb{F}$ -operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Other parameters. The other parameters follow directly from the construction.</p>

    <p class="text-gray-300">In this part, we construct a tensor IOP for R1CS from the modular multi-lincheck protocol and the twisted scalar-product protocol. Write  <span class="math">\\epsilon_{\\mathrm{Mlin_h}}</span>  for the soundness error of the modular multi-lincheck protocol,  <span class="math">\\mathsf{r}_{\\mathrm{Mlin_h}}</span>  for its round complexity,  <span class="math">\\mathsf{l}_{\\mathrm{Mlin_h}}</span>  for its proof length,  <span class="math">\\mathsf{c}_{\\mathrm{Mlin_h}}</span>  for its communication complexity,  <span class="math">\\mathsf{tp}_{\\mathrm{Mlin_h}}</span>  for its prover operations,  <span class="math">\\mathsf{tv}_{\\mathrm{Mlin_h}}</span>  for its verifier operations, and  <span class="math">\\mathsf{rd}_{\\mathrm{Mlin_h}}</span>  for its randomness complexity. Use  <span class="math">\\epsilon_{\\mathrm{TSP}}, \\mathsf{r}_{\\mathrm{TSP}}, \\mathsf{l}_{\\mathrm{TSP}}, \\mathsf{c}_{\\mathrm{TSP}}, \\mathsf{tp}_{\\mathrm{TSP}}, \\mathsf{tv}_{\\mathrm{TSP}}, \\mathsf{rd}_{\\mathrm{TSP}}</span>  to denote the corresponding parameters of the twisted scalar-product protocol. Define  <span class="math">\\mathsf{o}_G</span>  to be the arithmetic complexity of computing  <span class="math">\\epsilon</span> -biased generator  <span class="math">G</span>  over  <span class="math">\\mathbb{F}_{p^b}</span> .</p>

    <p class="text-gray-300">Theorem 6.11. For any prime power  <span class="math">p</span> , integer  <span class="math">a \\in \\Omega(\\log_p(\\log n_{\\mathrm{col}}))</span> , and positive integers  <span class="math">k, t</span> , given a systematic  <span class="math">(a, b)_p</span> -RMFE  <span class="math">(\\phi, \\psi)</span>  with basis  <span class="math">\\mathsf{E}</span>  that embeds vectors in  <span class="math">\\mathbb{F}_p^a</span>  to elements in  <span class="math">\\mathbb{F}_{p^b}</span>  (where  <span class="math">b = O(a)</span> ), and an  <span class="math">\\epsilon</span> -biased generator  <span class="math">G \\colon S^s \\to \\mathbb{F}^k</span> , there is a  <span class="math">(\\mathbb{F}_{p^b}, k, t)</span> -tensor IOP, with non-adaptive queries, for the indexed relation  <span class="math">R_{\\mathrm{R1CS}}</span>  that supports instances over  <span class="math">\\mathbb{F}_p</span>  with  <span class="math">n_{\\mathrm{row}} = n_{\\mathrm{col}} = a \\cdot k^t</span> ,  <span class="math">n_{\\mathrm{in}} = a \\cdot \\ell_{\\mathrm{in}} \\cdot k^{t_{\\mathrm{in}}}</span> , and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is  <span class="math">\\max(t\\epsilon, \\epsilon_{\\mathrm{Mlin_h}}, \\epsilon_{\\mathrm{TSP}})</span> ;</li>

      <li>round complexity is  <span class="math">O(\\max(\\mathsf{r}_{\\mathrm{Mlin_h}}, \\mathsf{r}_{\\mathrm{TSP}}))</span> ;</li>

      <li>proof length is  <span class="math">O(n_{\\mathrm{row}} / a + \\mathsf{l}_{\\mathrm{Mlin_h}} + \\mathsf{l}_{\\mathrm{TSP}})</span>  elements in  <span class="math">\\mathbb{F}_{p^b}</span> ;</li>

      <li>query complexity is  <span class="math">O(\\mathsf{qc}_{\\mathrm{Mlin_h}} + \\mathsf{qc}_{\\mathrm{TSP}})</span> ;</li>

      <li>the prover sends  <span class="math">O(\\mathsf{c}_{\\mathrm{Mlin_h}} + \\mathsf{c}_{\\mathrm{TSP}})</span>  non-oracle messages over  <span class="math">\\mathbb{F}_{p^b}</span> ;</li>

      <li>the prover uses  <span class="math">O(M + n_{\\mathrm{row}})</span> <span class="math">\\mathbb{F}_p</span> -operations and  <span class="math">O(t \\cdot (\\mathsf{o}_G + n_{\\mathrm{row}} / a))</span> <span class="math">\\mathbb{F}_{p^b}</span> -operations in addition to the  <span class="math">O(\\mathsf{tp}_{\\mathrm{Mlin_h}} + \\mathsf{tp}_{\\mathrm{TSP}})</span>  operations from the sub-protocols;</li>

      <li>the verifier uses  <span class="math">O(M + n_{\\mathrm{row}})</span> <span class="math">\\mathbb{F}_p</span> -operations and  <span class="math">O(t \\cdot \\mathsf{o}_G)</span> <span class="math">\\mathbb{F}_{p^b}</span> -operations in addition to the  <span class="math">O(\\mathsf{tv}_{\\mathrm{Mlin_h}} + \\mathsf{tv}_{\\mathrm{TSP}})</span>  operations from the sub-protocols;</li>

      <li>the verifier has randomness complexity  <span class="math">O(ts)</span>  over  <span class="math">S</span>  in addition to the  <span class="math">O(\\mathsf{rd}_{\\mathrm{Mlin_h}} + \\mathsf{rd}_{\\mathrm{TSP}})</span>  randomness for the sub-protocols.</li>

    </ul>

    <p class="text-gray-300">Here  <span class="math">M</span>  denotes the number of non-zero entries in the instance matrices  <span class="math">A, B, C</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The strategy here is to embed a R1CS instance over  <span class="math">\\mathbb{F}_p</span>  into a larger field  <span class="math">\\mathbb{F}_{p^b}</span>  of cardinality  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= p^{O(a)}<span class="math"> . Then the R1CS relation for matrices over  </span>\\mathbb{F}_p<span class="math">  is translated into a relation over  </span>\\mathbb{F}_{p^b}$  as stated in the following lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Lemma 6.12 ([CG21, Theorem 1]). Let  <span class="math">(\\dot{\\mathbf{s}},\\mathbf{x}) = \\big((\\mathbb{F}_p,n_{\\mathrm{row}},n_{\\mathrm{col}},A,B,C),(n_{\\mathrm{in}},x)\\big)</span>  be a R1CS index-instance pair, and let  <span class="math">(\\phi ,\\psi)</span>  be a systematic  <span class="math">(a,b)_p</span>  -RMFE. Then there exists  <span class="math">\\mathbf{w}\\in \\mathbb{F}_p^{n_{\\mathrm{col}} - n_{\\mathrm{in}}}</span>  such that  <span class="math">(\\dot{\\mathbf{s}},\\mathbf{x},\\mathbf{w})\\in R_{\\mathrm{R1CS}}</span>  if and only if there exists  <span class="math">\\widetilde{z}\\in \\mathbb{F}_{p^b}^{n_{\\mathrm{col}} / a}</span>  and  <span class="math">\\widetilde{z_A},\\widetilde{z_B},\\widetilde{z_C},\\widetilde{b}\\in \\mathbb{F}_{p^b}^{n_{\\mathrm{row}} / a}</span>  satisfying</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {z _ {A}} \\circ \\widetilde {z _ {B}} = \\widetilde {b} \\tag {3}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {z} = \\vec {0} \\mod (\\operatorname {I m} \\phi) ^ {n _ {\\mathrm {c o l}} / a} \\tag {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {z _ {U}} = \\vec {0} \\mod (\\operatorname {I m} \\phi) ^ {n _ {\\mathrm {r o w}} / a} \\quad \\forall U = A, B, C \\tag {5}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {U} \\widetilde {z} - \\widetilde {I _ {n _ {\\mathrm {r o w}}}} \\widetilde {z _ {U}} = \\vec {0} \\mod \\left(\\ker \\sum_ {j = 1} ^ {a} \\star \\psi\\right) ^ {n _ {\\mathrm {r o w}}} \\quad \\forall U = A, B, C \\tag {6}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {b} - u \\widetilde {z _ {C}} = \\vec {0} \\mod (\\ker \\psi) ^ {n _ {\\mathrm {r o w}} / a} \\tag {7}</span></div>

    <p class="text-gray-300">where <span class="math">z = (x,\\mathbb{W}),\\widetilde{z_U} = \\Phi (Uz),\\widetilde{z} = \\Phi (z),\\widetilde{U} = \\Phi (U)</span> and <span class="math">u = \\phi (\\mathbf{1}^a)</span>. We use the notation <span class="math">\\Phi (U)</span> to denote the matrix obtained by applying <span class="math">\\phi</span> row-wise to the matrix <span class="math">U</span>, and the notation <span class="math">\\sum_{j = 1}^{a}\\star \\psi</span> to denote the operation of applying <span class="math">\\psi</span> to an element in <span class="math">\\mathbb{F}_{p^b}</span> and then sum up the entries of the resulting vector in <span class="math">\\mathbb{F}_p^a</span>.</p>

    <p class="text-gray-300">Now we construct an interactive oracle proof <span class="math">\\mathsf{IOP} = (\\mathbf{P},\\mathbf{V})</span> with tensor queries for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> by checking whether the above relation holds over the larger field <span class="math">\\mathbb{F}_{p^b}</span>.</p>

    <p class="text-gray-300"><strong>Construction 6.13 (tensor IOP for R1CS).</strong> The prover <span class="math">\\mathbf{P}</span> takes as input <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x},\\mathbf{w}) = \\big((\\mathbb{F}_p,n_{\\mathrm{row}},n_{\\mathrm{col}},A,B,C),(n_{\\mathrm{in}},x),w\\big)</span>, while the verifier <span class="math">\\mathbf{V}</span> takes as input <span class="math">(\\dot{\\mathbf{i}},\\mathbf{x})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> constructs the full assignment <span class="math">z \\coloneqq (x, w) \\in \\mathbb{F}_p^{n_{\\mathrm{col}}}</span> and computes the vectors</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {z} := \\Phi (z) \\in \\mathbb {F} _ {p ^ {b}} ^ {n _ {\\mathrm {c o l}} / a}, \\qquad \\widetilde {z _ {A}} := \\Phi (A z), \\qquad \\widetilde {z _ {B}} := \\Phi (B z), \\qquad \\widetilde {z _ {C}} := \\Phi (C z), \\qquad \\widetilde {b} := \\widetilde {z _ {A}} \\circ \\widetilde {z _ {B}} \\in \\mathbb {F} _ {p ^ {b}} ^ {n _ {\\mathrm {r o w}} / a}</span></div>

    <p class="text-gray-300">The prover sends the oracle message <span class="math">\\Pi_1\\coloneqq (\\widetilde{z},\\widetilde{z_A},\\widetilde{z_B},\\widetilde{z_C},\\widetilde{b})</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier <span class="math">\\mathbf{V}</span> sends uniformly random seeds <span class="math">\\rho_{1},\\ldots ,\\rho_{t}\\in S^{s}</span>.</li>

      <li>The prover <span class="math">\\mathbf{P}</span> computes the query vector <span class="math">r \\coloneqq G(\\rho_1) \\otimes \\dots \\otimes G(\\rho_t)</span>, and the field element <span class="math">\\nu_b \\coloneqq \\langle r, \\widetilde{b} \\rangle</span>. The prover <span class="math">\\mathbf{P}</span> sends the non-oracle message <span class="math">\\nu_b \\in \\mathbb{F}_{p^b}</span>.</li>

      <li>The verifier <span class="math">\\mathbf{V}</span> performs consistency checks. First, <span class="math">\\mathbf{V}</span> queries <span class="math">\\widetilde{b}</span> in <span class="math">\\Pi_1</span> at <span class="math">r = G(\\rho_1) \\otimes \\dots \\otimes G(\\rho_t)</span> in order to obtain the answer <span class="math">\\langle r, \\widetilde{b} \\rangle</span>. Then, <span class="math">\\mathbf{V}</span> checks that <span class="math">\\nu_b = \\langle r, \\widetilde{b} \\rangle</span>, which shows that <span class="math">\\nu_b</span> is the correct answer to the query on <span class="math">\\widetilde{b}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, <span class="math">\\mathbf{V}</span> checks that the (claimed) embedded satisfying assignment <span class="math">\\widetilde{z}</span> is consistent with the partial assignment <span class="math">x</span> as follows: sample uniformly random seeds <span class="math">\\sigma_{1},\\ldots ,\\sigma_{t_{\\mathrm{in}} + 1}\\in S^{s}</span>; compute vectors <span class="math">s_i = G(\\sigma_i)</span> for <span class="math">i\\in [t_{\\mathrm{in}}]</span>, and compute <span class="math">s_{t_{\\mathrm{in}} + 1}</span> by computing <span class="math">G(\\sigma_{t_{\\mathrm{in}} + 1})</span> and changing all but the first <span class="math">\\ell_{\\mathrm{in}}</span> entries to zero. Set <span class="math">s_{t_{\\mathrm{in}} + 1}^{\\prime}</span> to be the first <span class="math">\\ell_{\\mathrm{in}}</span> entries. Then set each of the vectors <span class="math">s_{t_{\\mathrm{in}} + 2},\\dots,s_t\\in \\mathbb{F}_{p^b}^k</span> to equal <span class="math">(1,0,\\dots,0)\\in \\mathbb{F}_{p^b}^k</span>; query <span class="math">\\widetilde{z}</span> in <span class="math">\\Pi_1</span> at the tensor <span class="math">s\\coloneqq s_1\\otimes \\dots \\otimes s_t</span> in order to obtain the answer <span class="math">\\langle s,\\widetilde{z}\\rangle</span>; and check that <span class="math">\\langle s,\\widetilde{z}\\rangle = \\langle s_1\\otimes \\dots \\otimes s_{t_{\\mathrm{in}}}\\otimes s_{t_{\\mathrm{in}} + 1}^{\\prime},\\widetilde{x}\\rangle</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover <span class="math">\\mathbf{P}</span> and verifier <span class="math">\\mathbf{V}</span> engage in several sub-protocols to check equations (1)-(5) of Lemma 6.12.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A twisted scalar-product protocol with instance <span class="math">\\mathbf{x} = (\\mathbb{F}_{p^b}, n_{\\mathrm{row}} / a, r, \\nu_b)</span> and witness <span class="math">\\mathbf{w} = (\\widetilde{z_A}, \\widetilde{z_B})</span> to show that <span class="math">\\langle \\widetilde{z_A} \\circ r, \\widetilde{z_B} \\rangle = \\nu_b</span>.</li>

      <li>For every <span class="math">U \\in \\{A, B, C\\}</span>, a modular multi-lincheck protocol with <span class="math">\\dot{\\mathbf{i}} = (\\operatorname{Im} \\phi, I_{n_{\\mathrm{row}} / a})</span>, <span class="math">\\mathbf{x} = (\\mathbb{F}_{p^b}, \\mathsf{E}, n_{\\mathrm{row}} / a, n_{\\mathrm{row}} / a, 1)</span>, and <span class="math">\\mathbf{w} = \\widetilde{z_U}</span> to show that <span class="math">\\widetilde{z_U} = \\vec{0} \\mod (\\operatorname{Im} \\phi)^{n_{\\mathrm{row}} / a}</span>.</li>

      <li>For every <span class="math">U \\in \\{A, B, C\\}</span>, a modular multi-lincheck protocol with <span class="math">\\dot{\\mathbf{i}} = (\\ker \\sum_{j=1}^{n_{\\mathrm{col}}/a} \\star \\phi, (\\widetilde{U}, -\\widetilde{I_{n_{\\mathrm{row}}}}))</span>, <span class="math">\\mathbf{x} = (\\mathbb{F}_{p^b}, \\mathsf{E}, n_{\\mathrm{row}}, n_{\\mathrm{col}}/a, 2)</span>, and <span class="math">\\mathbf{w} = (\\widetilde{z}, \\widetilde{z_U})</span> to show that <span class="math">\\widetilde{U} \\widetilde{z} - \\widetilde{I_{n_{\\mathrm{row}}}} \\widetilde{z_U} = \\vec{0} \\mod (\\ker \\sum_{j=1}^{n_{\\mathrm{col}}/a} \\star \\phi)^{n_{\\mathrm{row}}}</span>.</li>

      <li>A modular multi-lincheck protocol with <span class="math">\\dot{\\mathbf{i}} = (\\ker \\psi, (I_{n_{\\mathrm{row}}/a}, I_{n_{\\mathrm{row}}/a}))</span>, <span class="math">\\mathbf{x} = (\\mathbb{F}_{p^b}, \\mathsf{E}, n_{\\mathrm{row}}/a, n_{\\mathrm{row}}/a, 2)</span>, and <span class="math">\\mathbf{w} = (\\widetilde{b}, -u\\widetilde{z_C})</span> to show that <span class="math">\\widetilde{b} - u\\widetilde{z_C} = \\vec{0} \\mod (\\ker \\psi)^{n_{\\mathrm{row}}/a}</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Proof. Completeness.</strong> Let <span class="math">z \\coloneqq (x, \\mathbb{W})</span> be a solution to the R1CS instance. The honest prover sends the oracles <span class="math">\\widetilde{z} \\coloneqq \\Phi(z)</span>, <span class="math">\\widetilde{z_U} \\coloneqq \\Phi(Uz)</span> and <span class="math">\\widetilde{b} \\coloneqq \\widetilde{z_A} \\circ \\widetilde{z_B}</span>, and the non-oracle message <span class="math">\\nu_b \\coloneqq \\langle r, \\widetilde{b} \\rangle</span>. It implies that we have <span class="math">\\nu_b = \\langle \\widetilde{z_A} \\circ r, \\widetilde{z_B} \\rangle</span>, and that all the modular equations in Lemma 6.12 are satisfied. This means that</p>

    <p class="text-gray-300">30</p>

    <p class="text-gray-300">the twisted scalar-product protocol and the modular multi-lincheck protocols succeed. Finally by construction, <span class="math">\\widetilde{z}</span> is consistent with the partial assignment <span class="math">x</span>. So it always holds that <span class="math">\\langle s,\\widetilde{z}\\rangle=\\langle s_{1}\\otimes\\cdots\\otimes s_{t_{\\mathrm{in}}}\\otimes s^{\\prime}_{t_{\\mathrm{in}}+1},\\widetilde{x}\\rangle</span>.</p>

    <p class="text-gray-300">Soundness error. Let <span class="math">\\mathbf{x}=(\\mathbb{F}_{p},n_{\\mathrm{row}},n_{\\mathrm{col}},A,B,C,x)</span>. Fix a malicious prover who sends oracle messages <span class="math">\\Pi_{1}\\coloneqq(\\widetilde{z},\\widetilde{z_{A}},\\widetilde{z_{B}},\\widetilde{z_{C}},\\widetilde{b})</span>. Then one of the following cases must hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widetilde{z}</span> is not consistent with the embedded partial assignment <span class="math">\\widetilde{x}</span>. In this case the verifier samples <span class="math">s</span> such that <span class="math">\\langle s,\\widetilde{z}\\rangle=\\langle s_{1}\\otimes\\cdots\\otimes s_{t_{\\mathrm{in}}}\\otimes s^{\\prime}_{t_{\\mathrm{in}}+1},\\widetilde{x}\\rangle</span> with probability at most <span class="math">(t_{\\mathrm{in}}+1)\\epsilon</span> by the property of the <span class="math">\\epsilon</span>-biased generator.</li>

      <li><span class="math">\\widetilde{b}\\neq\\widetilde{z_{A}}\\circ\\widetilde{z_{B}}</span>. In this case the verifier samples <span class="math">r</span> such that <span class="math">\\langle r,\\widetilde{b}\\rangle=\\langle\\widetilde{z_{A}}\\circ r,\\widetilde{z_{B}}\\rangle</span> with probability at most <span class="math">t\\epsilon</span> by the property of the <span class="math">\\epsilon</span>-biased generator. If this equality does not hold, then the twisted scalar-product protocol gives the soundness error guarantee of <span class="math">\\epsilon_{\\mathrm{SP}}</span>. Therefore the soundness error in this case is <span class="math">\\max(t\\epsilon,\\epsilon_{\\mathrm{SP}})</span>.</li>

      <li>At least one equation among Equations (2)-(5) in Lemma 6.12 does not hold. Then the modular lincheck protocols give the soundness error guarantee of <span class="math">\\epsilon_{\\mathrm{Mlin_{h}}}</span>.</li>

    </ul>

    <p class="text-gray-300">Therefore altogether the protocol has soundness error <span class="math">\\max(t\\epsilon,\\epsilon_{\\mathrm{SP}},\\epsilon_{\\mathrm{Mlin_{h}}})</span>.</p>

    <p class="text-gray-300">Prover arithmetic complexity. In step 1, the prover computes <span class="math">Uz</span> for <span class="math">U=A,B,C</span>, encodes the resulting vectors, and finally computes the entry-wise product <span class="math">\\widetilde{b}</span>. The first part takes <span class="math">O(M)</span> operations in <span class="math">\\mathbb{F}_{p}</span>, the second part takes <span class="math">O(3n_{\\mathrm{row}}+n_{\\mathrm{col}})</span> operations in <span class="math">\\mathbb{F}_{p}</span>, and the last part takes <span class="math">O(n_{\\mathrm{row}}/a)</span> operations in <span class="math">\\mathbb{F}_{p^{b}}</span>. In step 3, the prover computes the query vector <span class="math">r</span> and the field element <span class="math">\\nu_{b}</span>. In total this step takes <span class="math">O(t(\\mathsf{o}_{G}+n_{\\mathrm{row}}/a))</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations. In step 5, the prover encodes the matrices <span class="math">A,B,C</span> and <span class="math">I_{n_{\\mathrm{row}}}</span> and represents them in the basis <span class="math">\\mathsf{E}</span> before running the subprotocols. Since the encoding <span class="math">\\phi</span> is systematic, the encoding time is linear in the number of non-zero elements in the matrices. So this part takes <span class="math">O(M+n_{\\mathrm{row}})</span> operations in <span class="math">\\mathbb{F}_{p}</span> in addition to the operations in the subprotocols.</p>

    <p class="text-gray-300">Verifier arithmetic complexity. In step 4, the verifier computes query vectors <span class="math">(G(\\rho_{i}))_{i\\in[t]}</span> and <span class="math">(s_{i})_{i\\in[t]}</span>, which takes <span class="math">O(t\\cdot\\mathsf{o}_{G})</span> operations in <span class="math">\\mathbb{F}_{p^{b}}</span>. In step 5, the verifier encodes the matrices <span class="math">A,B,C</span> and <span class="math">I_{n_{\\mathrm{row}}}</span> before running the subprotocols, which takes <span class="math">O(M+n_{\\mathrm{row}})</span> operations in <span class="math">\\mathbb{F}_{p}</span> in addition to the operations in the subprotocols.</p>

    <p class="text-gray-300">Other parameters. The other parameters follow directly from the construction. <span class="math">\\square</span></p>

    <p class="text-gray-300">7 Algebraic automata</p>

    <p class="text-gray-300">In this section, we focus on constructing a tensor IOP for R1CS automata, a relation that is similar to but more structured than the R1CS relation. We slightly modify the notion of R1CS automata introduced in <em>[x1]</em> and explain how we adapt our tensor IOP for R1CS to construct an IOP for R1CS automata achieving sublinear verifier while preserving the linear-time prover. The construction relies on a cyclic-shift test that enables a multi-lincheck protocol with sublinear verification, which is the bottleneck for the verification time in the IOP for R1CS.</p>

    <h6 id="sec-83" class="text-base font-medium mt-4">Definition 7.1.</h6>

    <p class="text-gray-300">The R1CS automata relation <span class="math">R_{\\mathrm{R1CSA}}</span> is the set of triples</p>

    <p class="text-gray-300"><span class="math">(\\mathbbm{i},\\mathbbm{x},\\mathbbm{w})=(x,(\\mathbb{F}_{p},A,B,C),(w,T),z)\\enspace.</span></p>

    <p class="text-gray-300">Here, <span class="math">\\mathbb{F}_{p}</span> is a finite field, <span class="math">T\\in\\mathbb{N}</span> is the computation time of the automata, and <span class="math">w</span> is the computation width, <span class="math">A,B,C\\in\\mathbb{F}_{p}^{w\\times 2w}</span> define the time constraints, <span class="math">x\\in\\mathbb{F}_{p}^{w}</span> defines boundary conditions, and the execution trace <span class="math">z\\colon[T+1]\\to\\mathbb{F}_{p}^{w}</span> is a function that specifies the content of the <span class="math">w</span> registers at each time step. The trace satisfies <span class="math">z(1)=x</span>, and for all <span class="math">t\\in[T]</span>, <span class="math">A(z(t),z(t+1))\\circ B(z(t),z(t+1))=C(z(t),z(t+1))</span>. (Here “<span class="math">\\circ</span>” is the entry-wise product and “<span class="math">(\\cdot,\\cdot)</span>” is the vector concatenation.)</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Theorem 7.2.</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, and every finite field <span class="math">\\mathbb{F}_{p^{b}}</span> such that <span class="math">p^{b}\\in\\Omega(\\log n_{\\mathrm{col}})</span>, given a systematic <span class="math">(a,b)_{p}</span>-RMFE <span class="math">(\\phi,\\psi)</span> such that <span class="math">a\\in\\Theta(b)</span>, there is a <span class="math">(\\mathbb{F}_{p^{b}},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed automata relation <span class="math">R_{\\mathrm{R1CSA}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with computation width <span class="math">w</span>, computation time <span class="math">T</span>, <span class="math">(T+1)w=a\\cdot k^{t}</span> and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log(wT/a))</span>;</li>

      <li>proof length is <span class="math">O(wT/a)</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">O(wT/a)</span> elements in <span class="math">\\mathbb{F}_{p}</span>;</li>

      <li>query complexity is <span class="math">O(t)</span>;</li>

      <li>the prover sends <span class="math">O(\\log(wT/a))</span> non-oracle messages over <span class="math">\\mathbb{F}_{p^{b}}</span>;</li>

      <li>the prover uses <span class="math">O(w^{2}T)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(twT/a))</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier uses <span class="math">O(b^{3})</span> <span class="math">\\mathbb{F}_{p}</span>-operations, <span class="math">O(t(wT)^{1/t})</span> <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>-operations, and <span class="math">O(tk)</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(\\log(wT/a))</span> over <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">O(\\log(wT/a))</span> over <span class="math">\\mathbb{F}_{p}</span>.</li>

    </ul>

    <h3 id="sec-85" class="text-xl font-semibold mt-8">7.1 R1CS automata</h3>

    <p class="text-gray-300">As described in Section 2.6, in order to adapt the techniques we use when designing IOPs for R1CS, we express the automata relation in terms of the R1CS relation. To do that, we rewrite the register-wise Hadamard product constraints as a single matrix-vector-multiplication Hadamard product constraint by exploiting the special structure of staircase matrices as described below.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 7.3.</h6>

    <p class="text-gray-300">The rectangular identity matrix <span class="math">I_{T\\times(T+1)}\\in\\mathbb{F}^{T\\times(T+1)}</span> is defined as</p>

    <p class="text-gray-300">\\[ \\overset{\\rightharpoonup}{I}_{T}=\\left(\\begin{array}[]{cccccc}1&0&&&\\\\ &1&0&&\\\\ &&\\ddots&\\ddots&\\\\ &&&1&0\\end{array}\\right). \\]</p>

    <p class="text-gray-300">Definition 7.4. The shifted identity matrix  <span class="math">\\vec{I}_{T\\times (T + 1)}\\in \\mathbb{F}^{T\\times (T + 1)}</span>  is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\vec {I} _ {T} = \\left( \\begin{array}{c c c c c} 0 &amp;amp; 1 &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; 0 &amp;amp; 1 &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; 0 &amp;amp; 1 \\end{array} \\right).</span></div>

    <p class="text-gray-300">Definition 7.5. The staircase matrix of two matrices  <span class="math">M, M&#x27; \\in \\mathbb{F}^{w \\times w}</span>  is the matrix in  <span class="math">\\mathbb{F}^{wT \\times w(T + 1)}</span>  defined as</p>

    <div class="my-4 text-center"><span class="math-block">S (M, M ^ {\\prime}) = I _ {T \\times (T + 1)} \\otimes M + \\vec {I} _ {T \\times (T + 1)} \\otimes M ^ {\\prime} = \\left( \\begin{array}{c c c c c} M &amp;amp; M ^ {\\prime} &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; M &amp;amp; M ^ {\\prime} &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; M &amp;amp; M ^ {\\prime} &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; M \\end{array} \\right)</span></div>

    <p class="text-gray-300">where  <span class="math">I_{T \\times (T + 1)}</span>  is the rectangular identity matrix and  <span class="math">\\vec{I}_{T \\times (T + 1)}</span>  is the shifted identity matrix.</p>

    <p class="text-gray-300">Lemma 7.6 (Reduction from  <span class="math">R_{\\mathrm{R1CSA}}</span>  to staircase matrices). For any  <span class="math">(\\mathfrak{i}, \\mathbf{x}, \\mathbf{w}) = ((\\mathbb{F}_p, A, B, C), (w, T), z)</span> , consider  <span class="math">S_A = S(A_1, A_2)</span> ,  <span class="math">S_B = S(B_1, B_2)</span> ,  <span class="math">S_C = S(C_1, C_2) \\in \\mathbb{F}_p^{wT \\times w(T + 1)}</span>  where  <span class="math">M_1</span>  is the first  <span class="math">w</span>  columns of  <span class="math">M</span>  and  <span class="math">M_2</span>  is the remaining  <span class="math">w</span>  columns for all  <span class="math">M \\in \\{A, B, C\\}</span> . Viewing  <span class="math">z</span>  as a vector in  <span class="math">\\mathbb{F}_p^{w(T + 1)}</span> ,  <span class="math">(\\mathfrak{i}, \\mathbf{x}, \\mathbf{w}) \\in R_{\\mathrm{R1CSA}}</span>  iff  <span class="math">S_Az \\circ S_Bz = S_Cz</span> .</p>

    <p class="text-gray-300">Proof. Note that we have</p>

    <div class="my-4 text-center"><span class="math-block">S _ {A} z = S \\left(A _ {1}, A _ {2}\\right) \\cdot z = \\left(A (z (1), z (2)), A (z (2), z (3)), \\dots , A (z (T), z (T + 1)), \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {B} z = S \\left(B _ {1}, B _ {2}\\right) \\cdot z = \\left(B (z (1), z (2)), B (z (2), z (3)), \\dots , B (z (T), z (T + 1)), \\right.</span></div>

    <div class="my-4 text-center"><span class="math-block">S _ {C} z = S \\left(C _ {1}, C _ {2}\\right) \\cdot z = \\left(C (z (1), z (2)), C (z (2), z (3)), \\dots , C (z (T), z (T + 1)\\right).</span></div>

    <p class="text-gray-300">The lemma follows.</p>

    <p class="text-gray-300">As in Section 6, we need to embed the instance matrices  <span class="math">S_A, S_B, S_C \\in \\mathbb{F}_p^{wT \\times w(T + 1)}</span>  as defined in Lemma 7.6 with a systematic  <span class="math">(a,b)_p</span> -RMFE  <span class="math">(\\phi, \\psi)</span>  to  <span class="math">\\widetilde{S_A}, \\widetilde{S_B}, \\widetilde{S_C} \\in \\mathbb{F}_{p^b}^{wT / a \\times w(T + 1)}</span>  such that  <span class="math">w</span>  divides  <span class="math">a</span> .</p>

    <p class="text-gray-300">Definition 7.7. For any staircase matrix  <span class="math">S(M, M&#x27;) \\in \\mathbb{F}_p^{wT \\times w(T + 1)}</span>  and any systematic  <span class="math">(a, b)_p</span> -RMFE such that  <span class="math">w</span>  divides  <span class="math">a</span> , we define the embedded staircase matrix to be</p>

    <div class="my-4 text-center"><span class="math-block">S (\\widetilde {M , M ^ {\\prime}}) = \\left( \\begin{array}{c c c c c} m _ {0} &amp;amp; m _ {1} &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; m _ {0} &amp;amp; m _ {1} &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; m _ {0} &amp;amp; m _ {1} &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; m _ {0} &amp;amp; m _ {1} \\end{array} \\right) \\in \\mathbb {F} _ {p ^ {b}} ^ {w T \\times (w T / a + 1)}</span></div>

    <p class="text-gray-300">where  <span class="math">m_0, m_1 \\in \\mathbb{F}_{p^b}^a</span>  are the  <span class="math">\\phi</span> -embeddings of the following two square matrices</p>

    <div class="my-4 text-center"><span class="math-block">M _ {0} = \\left( \\begin{array}{c c c c c} M &amp;amp; M ^ {\\prime} &amp;amp; &amp;amp; &amp;amp; \\\\ &amp;amp; M &amp;amp; M ^ {\\prime} &amp;amp; &amp;amp; \\\\ &amp;amp; &amp;amp; M &amp;amp; M ^ {\\prime} &amp;amp; \\\\ &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots \\\\ &amp;amp; &amp;amp; &amp;amp; &amp;amp; M \\end{array} \\right) \\in \\mathbb {F} _ {p} ^ {a \\times a},   M _ {1} = \\left( \\begin{array}{c c c c} 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ \\vdots &amp;amp; \\vdots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ 0 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ M ^ {\\prime} &amp;amp; 0 &amp;amp; &amp;amp; 0 \\end{array} \\right) \\in \\mathbb {F} _ {p} ^ {a \\times a}</span></div>

    <p class="text-gray-300"><span class="math">\\widetilde{M,M^{\\prime}})=I_{Tw/a\\times(Tw/a+1)}\\otimes m_{0}+\\overset{\\rightharpoonup}{I}_{Tw/a}\\otimes m_{1}.</span></p>

    <p class="text-gray-300">So for any instance matrices <span class="math">U\\in\\{A,B,C\\}</span>, the embedded staircase matrix <span class="math">\\widetilde{S_{U}}</span> has a simple decomposition into to two tensors.</p>

    <h3 id="sec-87" class="text-xl font-semibold mt-8">7.2 Achieving sublinear verification for R1CS automata</h3>

    <p class="text-gray-300">Next we extend the tensor IOP for R1CS in Section 2.4 to achieve sublinear verification for the R1CS automata relation <span class="math">R_{\\mathrm{R1CSA}}</span>.</p>

    <p class="text-gray-300">In the current construction Construction 6.13, the verifier needs to perform matrix-matrix calculations in the modular multi-lincheck protocols. To reduce the arithmetic complexity of the verifier, we make the modular multi-lincheck protocol in Construction 6.10 to have sublinear verifier by making the prover prove the correctness of the calculations to the verifier via a tensor-product protocol.</p>

    <p class="text-gray-300">In the rest of the section we describe the construction of a modular lincheck protocol with sublinear verification, in which we use several sub-protocols, including the cyclic shift protocol and the biased generator consistency that are mentioned in Section 2.6 and will be discussed thoroughly in later sections.</p>

    <p class="text-gray-300">We write <span class="math">\\epsilon_{\\mathrm{CS}},\\epsilon_{\\mathrm{TSP}},\\epsilon_{\\mathrm{BGC}}</span> for the soundness error of the cyclic shift protocol, the twisted scalar-product protocol, and the biased generator consistency test, <span class="math">\\mathsf{r}_{\\mathrm{CS}},\\mathsf{r}_{\\mathrm{TSP}},\\mathsf{r}_{\\mathrm{BGC}}</span> for their round complexity, <span class="math">\\mathsf{l}_{\\mathrm{CS}},\\mathsf{l}_{\\mathrm{TSP}},\\mathsf{l}_{\\mathrm{BGC}}</span> for their proof length, <span class="math">\\mathsf{qc}_{\\mathrm{CS}},\\mathsf{qc}_{\\mathrm{TSP}},\\mathsf{qc}_{\\mathrm{BGC}}</span> for their query complexity, <span class="math">\\mathsf{c}_{\\mathrm{CS}},\\mathsf{c}_{\\mathrm{TSP}}</span> for communication complexity, <span class="math">\\mathsf{tp}_{\\mathrm{CS}},\\mathsf{tp}_{\\mathrm{TSP}},\\mathsf{tp}_{\\mathrm{BGC}}</span> for prover arithmetic complexity, <span class="math">\\mathsf{tv}_{\\mathrm{CS}},\\mathsf{tv}_{\\mathrm{TSP}},\\mathsf{tv}_{\\mathrm{BGC}}</span> for verifier arithmetic complexity, and <span class="math">\\mathsf{rd}_{\\mathrm{CS}},\\mathsf{rd}_{\\mathrm{TSP}},\\mathsf{rd}_{\\mathrm{BGC}}</span> for randomness complexity. We also use <span class="math">\\mathsf{o}_{G_{\\mathsf{sub}}}</span> to denote the arithmetic complexity of computing <span class="math">G_{\\mathsf{sub}}</span>.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Lemma 7.8 (Special case of Theorem 6.9).</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, and every finite field <span class="math">\\mathbb{F}_{p^{b}}</span>, every <span class="math">\\mathbb{F}_{p}</span>-linear subspace <span class="math">H\\subseteq\\mathbb{F}_{p^{b}}</span>, and positive integers <span class="math">k,t</span>, given a <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}_{p^{\\lambda}}^{s}\\to\\mathbb{F}_{p^{\\lambda}}^{(\\omega T/\\lambda t)^{1/t}}</span>, there is a <span class="math">(\\mathbb{F}_{p^{b}},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{Mlin_{b}}}</span> that supports staircase instances over <span class="math">\\mathbb{F}_{p^{b}}</span> with block size <span class="math">w</span>, <span class="math">n_{\\mathrm{row}}=wT</span>, and <span class="math">n_{\\mathrm{col}}=\\ell\\cdot k^{t}</span>, and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">\\max(t\\epsilon,\\lambda\\log\\frac{n_{\\mathrm{row}}}{a}/p^{b},\\epsilon_{\\mathrm{CS}},\\epsilon_{\\mathrm{BGC}})</span>;</li>

      <li>round complexity is <span class="math">O(\\lambda\\mathsf{r}_{\\mathrm{TSP}}+\\mathsf{r}_{\\mathrm{CS}}+\\mathsf{r}_{\\mathrm{BGC}})</span>;</li>

      <li>proof length is <span class="math">O(h\\cdot n_{\\mathrm{col}}+h\\cdot\\mathsf{l}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{l}_{\\mathrm{TSP}})</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span> and <span class="math">O(\\mathsf{l}_{\\mathrm{BGC}})</span> elements in <span class="math">\\mathbb{F}_{p}</span>;</li>

      <li>query complexity is <span class="math">O(h\\cdot\\mathsf{qc}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{qc}_{\\mathrm{TSP}}+\\mathsf{qc}_{\\mathrm{BGC}})</span>;</li>

      <li>the prover sends <span class="math">O(h\\cdot\\lambda+h\\cdot\\mathsf{c}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{c}_{\\mathrm{TSP}})</span> non-oracle messages;</li>

      <li>the prover uses <span class="math">O(\\lambda\\cdot M_{\\mathsf{E}}+\\mathsf{o}_{G_{\\mathsf{sub}}})</span> <span class="math">\\mathbb{F}_{p}</span>-operations, <span class="math">O(h\\cdot\\lambda n_{\\mathrm{col}}+h\\cdot\\mathsf{tp}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{tp}_{\\mathrm{TSP}})</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations, and <span class="math">O(\\mathsf{tp}_{\\mathrm{BGC}})</span> <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>-operations;</li>

      <li>the verifier uses <span class="math">O(\\lambda\\cdot b^{3})</span> <span class="math">\\mathbb{F}_{p}</span>-operations, <span class="math">O(h\\cdot\\mathsf{tv}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{tv}_{\\mathrm{TSP}})</span> <span class="math">\\mathbb{F}_{p^{b}}</span>-operations and <span class="math">O(\\mathsf{tv}_{\\mathrm{BGC}})</span> <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>-operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(ts)</span> over <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>, <span class="math">O(h\\cdot\\mathsf{rd}_{\\mathrm{CS}}+h\\cdot\\lambda^{2}\\cdot\\mathsf{rd}_{\\mathrm{TSP}})</span> elements in <span class="math">\\mathbb{F}_{p^{b}}</span>, and <span class="math">O(\\mathsf{rd}_{\\mathrm{BGC}})</span> elements in <span class="math">\\mathbb{F}_{p}</span>.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">M_{\\mathsf{E}}</span> denotes the number of non-zero entries in <span class="math">U_{i}</span>’s coefficient matrices (notations as defined in Definition 6.8).</p>

    <p class="text-gray-300">The construction mostly follows the steps in Construction 6.10. The only changes are the following. For a randomly generated vector <span class="math">\\vec{r}</span> the verifier needs to check that <span class="math">\\vec{r}^{\\intercal}S_{U}\\vec{x}=\\tau</span> where <span class="math">S_{U}\\in\\{\\widetilde{S_{A}},\\widetilde{S_{B}},\\widetilde{S_{C}},\\widetilde{I_{n_{\\mathrm{row}}}},\\widetilde{I_{n_{\\mathrm{row}}/a}}\\}</span> are embedded staircase matrice. We note that for any embedded staircase matrix <span class="math">S(\\widetilde{M,M^{\\prime}})</span> the left hand of the equation can be written as</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {r} ^ {\\intercal} S (\\widetilde {M, M ^ {\\prime}}) \\vec {x} = \\langle \\vec {r} \\circ (\\vec {1} _ {T w / a} \\otimes m _ {0}) \\circ (\\vec {x} _ {0} \\otimes \\vec {1} _ {a}) + \\vec {r} \\circ (\\vec {1} _ {T w / a} \\otimes m _ {1}) \\circ (\\vec {x} _ {1} \\otimes \\vec {1} _ {a}), \\vec {1} _ {T w} \\rangle \\tag {8}</span></div>

    <p class="text-gray-300">where  <span class="math">\\vec{x}_0 = \\vec{x}[1:Tw / a]</span>  and  <span class="math">\\vec{x}_1 = \\vec{x}[2:Tw / a + 1]</span> .</p>

    <p class="text-gray-300">Now we present the construction.</p>

    <p class="text-gray-300"><strong>Construction 7.9 (tensor IOP for  <span class="math">R_{\\mathrm{Mlin_h}}</span>  with sublinear verification).</strong> We construct an interactive oracle proof  <span class="math">\\mathsf{IOP} = (\\mathbf{I}, \\mathbf{P}, \\mathbf{V})</span>  with tensor queries for the indexed relation  <span class="math">R_{\\mathrm{Mlin_h}}</span>  that achieves sublinear verification.</p>

    <p class="text-gray-300">Given the index  <span class="math">\\mathbb{i} = (H, (U_i)_{i \\in [h]})</span> , the indexer  <span class="math">\\mathbf{I}</span>  computes and outputs as oracle message  <span class="math">\\Pi_0 = (U_{i,0}, U_{i,1})_{i \\in [h]}</span> , where  <span class="math">U_i = S(\\widetilde{M_i, M_i&#x27;})</span>  are the embedded staircase matrices in Definition 7.7,  <span class="math">U_{i,0} = \\vec{1}_{Tw/a} \\otimes m_0</span> , and  <span class="math">U_{i,1} = \\vec{1}_{Tw/a} \\otimes m_1</span> .</p>

    <p class="text-gray-300">The prover  <span class="math">\\mathbf{P}</span>  takes as input the index  <span class="math">\\mathbb{i}</span> , instance  <span class="math">\\mathbb{x} = (\\mathbb{F},\\mathsf{E},n_{\\mathrm{row}},n_{\\mathrm{col}},h)</span> , and witness  <span class="math">\\mathbb{W} = (\\vec{x}_i)_{i\\in [h]}</span>  while the verifier takes as input  <span class="math">\\Pi_0</span>  and  <span class="math">\\mathbb{x}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span>  computes and sends the oracle message  <span class="math">(\\vec{x}_{i,0},\\vec{x}_{i,1})_{i\\in [h]}</span>  where  <span class="math">\\vec{x}_{i,0},\\vec{x}_{i,1}</span>  are as defined in Equation (8).</li>

      <li>The verifier  <span class="math">\\mathbf{V}</span>  sends uniformly random seeds  <span class="math">r\\in \\mathbb{F}_{p^{\\lambda}}^{st}</span> .</li>

      <li>The prover uses the biased generator  <span class="math">G_{\\mathrm{sub}}</span>  defined in Construction 7.16 to generate the matrix  <span class="math">R = G_{\\mathrm{sub}}(r) \\in \\mathbb{F}_p^{\\lambda \\times n_{\\mathrm{row}}}</span>  and then computes the vector  <span class="math">\\vec{b} = \\sum_{i=1}^{h} RU_i \\vec{x}_i \\in \\mathbb{F}_{p^b}^\\lambda</span>  and sends the non-oracle message  <span class="math">\\vec{b}</span> .</li>

      <li>The verifier first checks that  <span class="math">\\vec{b} = \\vec{0} \\mod H^{\\lambda}</span> , and rejects if the check fails.</li>

      <li>The prover computes  <span class="math">\\vec{b}_i = RU_i\\vec{x}_i</span>  for all  <span class="math">i\\in [h]</span> , and sends  <span class="math">(\\vec{b}_i)_{i\\in [h]}</span>  as non-oracle message and  <span class="math">(R_j)_{j\\in [\\lambda]}</span>  as oracles to the verifier.</li>

      <li>The verifier checks that  <span class="math">\\vec{b} = \\sum_{i=1}^{h} \\vec{b}_i</span> .</li>

      <li>For every  <span class="math">i \\in [h]</span> , the prover and the verifier engage in a cyclic shift protocol to check that  <span class="math">\\vec{x}_{i,1}</span>  is the 1-entry cyclic shift of  <span class="math">\\vec{x}_{i,0}</span>  over  <span class="math">\\mathbb{F}_{p^b}</span> . This relation and its protocol are explained in more detail in Section 7.3.</li>

      <li>For every  <span class="math">i \\in [h]</span>  and  <span class="math">j \\in [\\lambda]</span> , the prover and the verifier engage in  <span class="math">2\\lambda</span>  TSP protocols to check that  <span class="math">\\langle R_j \\circ (\\vec{x}_{i,0} \\otimes \\vec{1}_a), U_{i,0} \\rangle + \\langle R_j \\circ (\\vec{x}_{i,1} \\otimes \\vec{1}_a), U_{i,1} \\rangle = (\\vec{b}_i)_j</span>  (see Remark 7.10).</li>

      <li>The prover and the verifier enagage in the protocol from Construction 7.19 to check that  <span class="math">R = G_{\\mathrm{sub}}(r)</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Remark 7.10.</strong> By construction of  <span class="math">G_{\\mathrm{sub}}</span> , the  <span class="math">j</span> -th row of  <span class="math">R</span>  has the following tensor structure (see Section 7.4 for more on the structure of  <span class="math">R</span> )</p>

    <div class="my-4 text-center"><span class="math-block">R _ {j} = \\sum_ {\\ell_ {t - 1}, \\ell_ {t} \\in [ \\lambda ]} u ^ {(j, \\ell_ {t - 1})} \\otimes e ^ {(\\ell_ {t - 1}, \\ell_ {t})},</span></div>

    <p class="text-gray-300">where  <span class="math">u^{(j,\\ell_{t - 1})}\\in \\mathbb{F}_p^{Tw / a}</span>  and  <span class="math">e^{(\\ell_{t - 1},\\ell_t)}\\in \\mathbb{F}_p^a</span>  . Plugging this decomposition of  <span class="math">R_{j}</span>  into the expression, we obtain that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\langle R _ {j} \\circ (\\vec {x} _ {i, 0} \\otimes \\vec {1} _ {a}), U _ {i, 0} \\rangle + \\langle R _ {j} \\circ (\\vec {x} _ {i, 1} \\otimes \\vec {1} _ {a}), U _ {i, 1} \\rangle \\\\ = \\sum_ {\\ell_ {t - 1} \\in [ \\lambda ]} \\langle u ^ {(j, \\ell_ {t - 1})} \\circ \\vec {x} _ {i, 0}, \\vec {1} _ {T w / a} \\rangle \\cdot \\sum_ {\\ell_ {t} \\in [ \\lambda ]} \\langle e ^ {(\\ell_ {t - 1}, \\ell_ {t})} \\circ \\vec {1} _ {a}, m _ {0} \\rangle + \\sum_ {\\ell_ {t - 1} \\in [ \\lambda ]} \\langle u ^ {(j, \\ell_ {t - 1})} \\circ \\vec {x} _ {i, 1}, \\vec {1} _ {T w / a} \\rangle \\cdot \\sum_ {\\ell_ {t} \\in [ \\lambda ]} \\langle e ^ {(\\ell_ {t - 1}, \\ell_ {t})} \\circ \\vec {1} _ {a}, m _ {1} \\rangle \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The verifier can compute the terms <span class="math">\\sum_{\\ell_t\\in [\\lambda]}\\langle e^{(\\ell_{t - 1},\\ell_t)}\\circ \\vec{1}_a,m_c\\rangle</span>, <span class="math">c\\in \\{0,1\\}</span> <span class="math">\\ell_{t - 1}\\in [\\lambda ]</span>, with <span class="math">O(\\lambda^2\\cdot a)</span> operations in <span class="math">\\mathbb{F}_{p^b}</span>. To check the values for the terms <span class="math">\\langle u^{(j,\\ell_{t - 1})}\\circ \\vec{x}_{i,c},\\vec{1}_{Tw / a}\\rangle = \\langle u^{(j,\\ell_{t - 1})}\\circ \\vec{1}_{Tw / a},\\vec{x}_{i,c}\\rangle</span>, <span class="math">c\\in \\{0,1\\}</span>, the verifier engages in <span class="math">2\\lambda</span> TSP protocols checking. By Lemma 6.4, this step takes the prover <span class="math">O(Tw / a)</span> operations in <span class="math">\\mathbb{F}_{p^b}</span> and the verifier <span class="math">O\\left(t\\stackrel {\\iota -\\downarrow}{\\sqrt[4]{Tw / a}}\\right)</span> operations in <span class="math">\\mathbb{F}_{p^b}</span>.</p>

    <p class="text-gray-300">Proof. Completeness. Completeness is straightforward from the construction.</p>

    <p class="text-gray-300">Soundness error. Suppose <span class="math">\\sum_{i=1}^{h} U_i \\vec{x}_i \\neq \\vec{0} \\mod H^{n_{\\mathrm{row}}}</span>. Fix a malicious prover who sends the messages <span class="math">\\vec{b}&#x27;</span>, <span class="math">(\\vec{x}_{i,0}&#x27;, \\vec{x}_{i,1}&#x27;)_{i \\in [h]}, (\\vec{b}_i&#x27;)_{i \\in [h]}</span>, and <span class="math">(R_j)_{j \\in [\\lambda]}</span>. Then one of the following six cases happens.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier samples <span class="math">r</span> such that <span class="math">\\sum_{i=1}^{h} G_{\\mathrm{sub}}(r) U_i \\vec{x}_i = \\vec{0} \\mod H^{n_{\\mathrm{row}}}</span>. This case happens with probability at most <span class="math">\\epsilon_{\\mathrm{sub}}</span> by Definition 5.3.</li>

      <li><span class="math">\\vec{b}^{\\prime} \\neq \\vec{0} \\mod H^{\\lambda}</span>. In this case the verifier always rejects and so the soundness error is 0.</li>

      <li><span class="math">\\vec{b}^{\\prime} \\neq \\sum_{i=1}^{h} \\vec{b}_{i}^{\\prime}</span>. In this case the verifier always rejects and so the soundness error is 0.</li>

      <li>For some <span class="math">i \\in [h]</span>, <span class="math">\\vec{x}_{i,1}</span> is not the 1-entry cyclic shift of <span class="math">\\vec{x}_{i,0}</span>. In this the cyclic shift protocol guarantees a soundness error of at most <span class="math">\\epsilon_{\\mathrm{CS}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\langle R_j \\circ (\\vec{x}_{i,0} \\otimes \\vec{1}_a), U_{i,0} \\rangle + \\langle R_j \\circ (\\vec{x}_{i,1} \\otimes \\vec{1}_a), U_{i,1} \\rangle \\neq \\vec{b}_{i,j}&#x27;</span> for certain <span class="math">i</span> and <span class="math">j</span>. In this case, the TSP protocol guarantees a soundness error of $\\epsilon_{\\mathrm{TSP}} = \\frac{2\\lambda \\cdot \\log \\frac{n_{\\mathrm{row}}}{a}}{\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^b}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R \\neq G_{\\mathrm{sub}}(r)</span>. In this case the soundness error is at most <span class="math">\\epsilon_{\\mathrm{BGC}}</span>.</li>

    </ul>

    <p class="text-gray-300">Thus the soundness error is the maximum of the six.</p>

    <p class="text-gray-300">Prover arithmetic complexity. First, the prover computes <span class="math">(\\vec{b}_i)_{i\\in [h]}</span> by multiplying the matrices <span class="math">U_{i} = \\sum_{j\\in [b]}A_{ij}e_{j}</span> with the matrix <span class="math">R\\in \\mathbb{F}_p^{\\lambda \\times n_{\\mathrm{row}}}</span> and the vector <span class="math">\\vec{x}_i</span>. So in total this procedure takes <span class="math">O(\\lambda \\cdot M_{\\mathsf{E}})</span> <span class="math">\\mathbb{F}_p</span>-operations and <span class="math">O(h\\cdot \\lambda n_{\\mathrm{col}})</span> <span class="math">\\mathbb{F}</span>-operations. Moreover, the prover computes <span class="math">G_{\\mathrm{sub}}(r)</span>, engages in the cyclic shift protocols, the twisted scalar product protocols, and the test for subspace biased generator, which take <span class="math">O(\\mathsf{o}_{G_{\\mathrm{sub}}})</span> <span class="math">\\mathbb{F}_p</span>-operations, <span class="math">O(h\\cdot \\mathsf{tp}_{\\mathrm{CS}} + h\\cdot \\lambda^2\\cdot \\mathsf{tp}_{\\mathrm{TSP}})</span> <span class="math">\\mathbb{F}_{p^b}</span>-operations, and <span class="math">O(\\mathsf{tp}_{\\mathrm{BGC}})</span> <span class="math">\\mathbb{F}_{p^{\\lambda}}</span>-operations.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier arithmetic complexity. Checking that <span class="math">\\vec{b} = \\vec{0} \\mod H^{\\lambda}</span> takes $O(\\lambda \\cdot \\log_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)^2 \\cdot (\\log_p(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{p^b}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) - \\dim(H)))<span class="math"> </span>\\mathbb{F}_p<span class="math">-operations. Engaging in the TSP protocols and cyclic shift protocols take </span>h \\cdot \\lambda^2 \\cdot \\mathrm{tv}_{\\mathrm{TSP}} + h \\cdot \\mathrm{tv}_{\\mathrm{CS}}<span class="math"> </span>\\mathbb{F}_{p^b}<span class="math">-operations. The check for the output of the subspace biased generator takes </span>O(\\mathrm{tv}_{\\mathrm{BGC}})<span class="math"> </span>\\mathbb{F}_{p^{\\lambda}}$-operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Other parameters. The other parameters follow directly from the construction.</p>

    <p class="text-gray-300">So now, we can construct a tensor IOP for the R1CS automata relation <span class="math">R_{\\mathrm{R1CSA}}</span> from the modular multi-lincheck protocol given in Lemma 7.8 as in Section 6.3. Write <span class="math">\\epsilon_{\\mathrm{MLA}}</span> for the soundness error of the modular multi-lincheck protocol, <span class="math">\\mathsf{r}_{\\mathrm{MLA}}</span> for its round complexity, <span class="math">\\mathsf{l}_{\\mathrm{MLA}}</span> for its proof length, <span class="math">\\mathsf{c}_{\\mathrm{MLA}}</span> for its communication complexity, <span class="math">\\mathsf{tp}_{\\mathrm{MLA}}</span> for its prover operations, <span class="math">\\mathsf{tv}_{\\mathrm{MLA}}</span> for its verifier operations, and <span class="math">\\mathsf{rd}_{\\mathrm{MLA}}</span> for its randomness complexity. Use <span class="math">\\epsilon_{\\mathrm{TSP}}, \\mathsf{r}_{\\mathrm{TSP}}, \\mathsf{l}_{\\mathrm{TSP}}, \\mathsf{c}_{\\mathrm{TSP}}, \\mathsf{tp}_{\\mathrm{TSP}}, \\mathsf{tv}_{\\mathrm{TSP}}, \\mathsf{rd}_{\\mathrm{TSP}}</span> to denote the corresponding parameters of the twisted scalar-product protocol. Define <span class="math">\\mathsf{o}_G</span> to be the arithmetic complexity of computing <span class="math">\\epsilon</span>-biased generator <span class="math">G</span> over <span class="math">\\mathbb{F}_{p^b}</span>.</p>

    <p class="text-gray-300">Theorem 7.11. For every prime power <span class="math">p</span>, integer <span class="math">a \\in \\Omega(\\log_p n_{\\mathrm{col}})</span>, and positive integers <span class="math">k, t</span>, given a systematic <span class="math">(a, b)_p</span>-RMFE <span class="math">(\\phi, \\psi)</span> with basis <span class="math">\\mathsf{E}</span> that embeds vectors in <span class="math">\\mathbb{F}_p^a</span> to elements in <span class="math">\\mathbb{F}_{p^b}</span> (where <span class="math">b = O(a)</span>),</p>

    <p class="text-gray-300">and an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon S^{s}\\to \\mathbb{F}_{p^{b}}^{k}</span>, there is a <span class="math">(\\mathbb{F}_{p^b},k,t)</span>-tensor IOP, with non-adaptive queries, for the indexed automata relation <span class="math">R_{\\mathrm{R1CSA}}</span> that supports instances over <span class="math">\\mathbb{F}_p</span> with <span class="math">n_{\\mathrm{row}} = Tw</span>, <span class="math">n_{\\mathrm{col}} = (T + 1)w = a\\cdot k^t</span>, <span class="math">n_{\\mathrm{in}} = a\\cdot \\ell_{\\mathrm{in}}\\cdot k^{t_{\\mathrm{in}}}</span>, and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">\\max(t\\epsilon, \\epsilon_{\\mathrm{MLA}}, O(\\epsilon_{\\mathrm{TSP}}))</span>;</li>

      <li>round complexity is <span class="math">O(\\max(\\mathsf{r}_{\\mathrm{MLA}}, \\mathsf{r}_{\\mathrm{TSP}}))</span>;</li>

      <li>proof length is <span class="math">O(n_{\\mathrm{row}} / a + \\mathsf{l}_{\\mathrm{MLA}} + \\mathsf{l}_{\\mathrm{TSP}})</span> elements in <span class="math">\\mathbb{F}_{p^b}</span>;</li>

      <li>query complexity is <span class="math">O(\\mathsf{qc}_{\\mathrm{MLA}} + \\mathsf{qc}_{\\mathrm{TSP}})</span>;</li>

      <li>the prover sends <span class="math">O(\\mathsf{c}_{\\mathrm{MLA}} + \\mathsf{c}_{\\mathrm{TSP}})</span> non-oracle messages over <span class="math">\\mathbb{F}_{p^b}</span>;</li>

      <li>the prover uses <span class="math">O(M + n_{\\mathrm{row}})\\mathbb{F}_p</span> operations and <span class="math">O(t\\cdot (\\mathsf{o}_G + n_{\\mathrm{row}} / a))\\mathbb{F}_{p^b}</span> operations in addition to the <span class="math">O(\\mathsf{tp}_{\\mathrm{MLA}} + \\mathsf{tp}_{\\mathrm{TSP}})</span> operations from the sub-protocols;</li>

      <li>the verifier uses <span class="math">O(b^{3})\\mathbb{F}_{p}</span> operations and <span class="math">O(t\\cdot \\mathsf{o}_G)\\mathbb{F}_{p^b}</span> operations in addition to the <span class="math">O(\\mathsf{tv}_{\\mathrm{MLA}} + \\mathsf{tv}_{\\mathrm{TSP}})</span> operations from the sub-protocols;</li>

      <li>the verifier has randomness complexity <span class="math">O(ts)</span> over <span class="math">S</span> in addition to the <span class="math">O(\\mathsf{rd}_{\\mathrm{MLA}} + \\mathsf{rd}_{\\mathrm{TSP}})</span> randomness for the sub-protocols.</li>

    </ul>

    <p class="text-gray-300">Here <span class="math">M</span> denotes the number of non-zero entries in the instance matrices <span class="math">A, B, C</span> as in Section 6.3, and due to the special structure of staircase matrices, we know <span class="math">M = w^{2}T</span>.</p>

    <h2 id="sec-89" class="text-2xl font-bold">7.3 Cyclic-shift test</h2>

    <p class="text-gray-300">We construct a tensor IOP for the shift relation.</p>

    <p class="text-gray-300"><strong>Definition 7.12.</strong> The shift relation <span class="math">R_{\\odot}</span> is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf {i}, \\mathbf {x}, \\mathbf {w}) = (\\perp , (\\mathbb {F}, s, N), (a, b))</span></div>

    <p class="text-gray-300">where <span class="math">N = k^t</span>, <span class="math">b \\in \\mathbb{F}^N</span> is the cyclic shift of <span class="math">a \\in \\mathbb{F}^N</span>, which we denote <span class="math">b = \\mathrm{shift}(a)</span>, if for all <span class="math">i \\in [N - s]</span>, it holds that <span class="math">a_i = b_{i + s}</span>, and for <span class="math">i \\geq N - s</span>, <span class="math">a_i = 0</span>.</p>

    <p class="text-gray-300"><strong>Theorem 7.13.</strong> For every finite field <span class="math">\\mathbb{F}</span> and positive integers <span class="math">k, t, s</span> with <span class="math">s &amp;lt; k</span>, there is a <span class="math">(\\mathbb{F}, k, t)</span>-tensor IOP for the indexed relation <span class="math">R_{\\odot}</span> that supports instances over <span class="math">\\mathbb{F}</span> with <span class="math">N = k^t</span> and has the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O(tk /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(1)</span>;</li>

      <li>proof length is <span class="math">O(N)</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity is <span class="math">O(t)</span>;</li>

      <li>the verifier uses <span class="math">O(tk)</span> field operations;</li>

      <li>the verifier has randomness complexity <span class="math">O(t)</span>.</li>

    </ul>

    <p class="text-gray-300">We define vector notation which allows us to describe the protocol more succinctly.</p>

    <p class="text-gray-300"><strong>Definition 7.14.</strong> For <span class="math">\\gamma_1, \\ldots, \\gamma_t \\in \\mathbb{F}</span>, and <span class="math">v, w \\in \\{0, 1, \\ldots, k-1\\}</span> with <span class="math">v \\leq w</span>, let <span class="math">\\Gamma_j := (1, \\gamma_j, \\ldots, \\gamma_j^{k-1}) \\in \\mathbb{F}^k</span>, and let <span class="math">\\Gamma_j^{(v,w)} := (0, \\ldots, 0, \\gamma_j^v, \\gamma_j^{v+1}, \\ldots, \\gamma_j^w, 0, \\ldots, 0) \\in \\mathbb{F}^k</span>.</p>

    <p class="text-gray-300"><strong>Construction 7.15 (tensor IOP for cyclic shift test).</strong> We construct an interactive oracle proof <span class="math">\\mathsf{IOP} = (\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> with tensor queries for the indexed relation <span class="math">R_{\\odot}</span>. The indexer algorithm <span class="math">\\mathbf{I}</span> is trivial. The prover <span class="math">\\mathbf{P}</span> takes as input the instance <span class="math">\\mathbf{x} = (n_{\\mathrm{in}},x)</span>, and witness <span class="math">\\mathbf{w} = w</span>, while the verifier <span class="math">\\mathbf{V}</span> takes as input the instance <span class="math">\\mathbf{x}</span>.</p>

    <p class="text-gray-300">The verifier makes <span class="math">2t + 1</span> tensor queries to check the following expressions:</p>

    <div class="my-4 text-center"><span class="math-block">\\gamma_ {1} ^ {s} \\langle \\Gamma_ {1} ^ {(0, k - 1 - s)} \\otimes \\bigotimes_ {j = 2} ^ {t} \\Gamma_ {j}, a \\rangle = \\langle \\Gamma_ {1} ^ {(s, k - 1)} \\otimes \\bigotimes_ {j = 2} ^ {t} \\Gamma_ {j}, b \\rangle</span></div>

    <p class="text-gray-300"><span class="math">\\gamma_{2}\\gamma_{1}^{s-k}\\langle\\Gamma_{1}^{(k-s,k-1)}\\otimes\\Gamma_{2}^{(0,k-2)}\\otimes\\bigotimes_{j=3}^{t}\\Gamma_{j},a\\rangle=\\langle\\Gamma_{1}^{(0,s-1)}\\otimes\\Gamma_{2}^{(1,k-1)}\\otimes\\bigotimes_{j=3}^{t}\\Gamma_{j},b\\rangle</span> <span class="math">\\vdots</span> <span class="math">\\gamma_{r}\\gamma_{r-1}^{1-k}\\cdots\\gamma_{2}^{1-k}\\gamma_{1}^{s-k}\\langle\\Gamma_{1}^{(k-s,k-1)}\\otimes\\bigotimes_{j=2}^{r-1}\\Gamma_{j}^{(k-1,k-1)}\\otimes\\Gamma_{r}^{(0,k-2)}\\otimes\\bigotimes_{j=r+1}^{t}\\Gamma_{j},a\\rangle</span> <span class="math">=\\langle\\Gamma_{1}^{(0,s-1)}\\otimes\\bigotimes_{j=2}^{r-1}\\Gamma_{j}^{(0,0)}\\otimes\\Gamma_{r}^{(1,k-1)}\\otimes\\bigotimes_{j=r+1}^{t}\\Gamma_{j},b\\rangle</span> <span class="math">\\vdots</span> <span class="math">\\gamma_{t}\\gamma_{t-1}^{1-k}\\cdots\\gamma_{2}^{1-k}\\gamma_{1}^{s-k}\\langle\\Gamma_{1}^{(k-s,k-1)}\\otimes\\bigotimes_{j=2}^{t-1}\\Gamma_{j}^{(k-1,k-1)}\\otimes\\Gamma_{r}^{(0,k-2)},a\\rangle=\\langle\\Gamma_{1}^{(0,s-1)}\\otimes\\bigotimes_{j=2}^{t-1}\\Gamma_{j}^{(0,0)}\\otimes\\Gamma_{t}^{(1,k-1)},b\\rangle</span> <span class="math">\\langle\\Gamma_{1}^{(k-s,k-1)}\\otimes\\bigotimes_{j=2}^{t}\\Gamma_{j}^{(k-1,k-1)},b\\rangle=0</span></p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We analyze the error and efficiency parameters of the above construction.</p>

    <p class="text-gray-300">Completeness. Perfect completeness: Index the entries of <span class="math">a,b\\in\\mathbb{F}^{N}</span> using the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})\\in\\{0,1,\\ldots,k-1\\}^{t}</span> (recall that <span class="math">N=k^{t}</span>). Consider how the <span class="math">k</span>-ary representation of <span class="math">i</span> changes when adding <span class="math">s</span> to get <span class="math">i+s</span>. Since <span class="math">s&lt;k</span>, the only possible options are as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">0\\leq i_{1}\\leq k-1-s</span>, then there are no carries when adding <span class="math">s</span> to the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})</span>. This means that <span class="math">a_{i_{t},\\ldots,i_{1}}</span> is equal to <span class="math">b_{i_{t},\\ldots,i_{1}+s}</span>.</li>

      <li>If <span class="math">k-s\\leq i_{1}\\leq k-1</span>, and <span class="math">0\\leq i_{2}\\leq k-2</span>, then there is one carry when adding <span class="math">s</span> to the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})</span>. This means that <span class="math">a_{i_{t},\\ldots,i_{1}}</span> is equal to <span class="math">b_{i_{t},\\ldots,i_{2}+1,i_{1}+s-k}</span>.</li>

      <li>If <span class="math">k-s\\leq i_{1}\\leq k-1</span>, and <span class="math">0\\leq i_{2}\\leq k-2</span>, then there are two carries when adding <span class="math">s</span> to the <span class="math">k</span>-ary representation <span class="math">(i_{t},\\ldots,i_{1})</span>. This means that <span class="math">a_{i_{t},\\ldots,i_{1}}</span> is equal to <span class="math">b_{i_{t},\\ldots,i_{3}+1,0,i_{1}+s-k}</span>.</li>

    </ul>

    <p class="text-gray-300">In the tensor queries in Construction 7.15, the <span class="math">(i_{t},\\ldots,i_{1})</span>-th entries of <span class="math">a</span> and <span class="math">b</span> either do not appear, or are multiplied by the monomial <span class="math">\\gamma_{t}^{i_{t}}\\cdots\\gamma_{1}^{i_{1}}</span>. Therefore, the number of carries gives the monomial which the <span class="math">(i_{t},\\ldots,i_{1})</span>-th term in <span class="math">a</span> must be scaled by to give the corresponding term in <span class="math">b</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness. Soundness error $O(tk/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">: Suppose that </span>a\\neq\\mathrm{shift}(b)<span class="math">. This means that either </span>a_{i}\\neq b<span class="math"> for some </span>i\\in[N-s]<span class="math">, or </span>a_{i}\\neq 0<span class="math"> for some </span>i\\geq N-s<span class="math">. In the latter case, the final verification equation consists of a non-zero polynomial of degree at most </span>kt<span class="math"> evaluated at random points </span>\\gamma_{1},\\ldots,\\gamma_{t}\\in\\mathbb{F}<span class="math">. The stated soundness error then follows from the Schwartz–Zippel lemma. In the former case, the number of carries in the </span>k<span class="math">-ary representation of </span>i<span class="math"> when adding </span>s<span class="math"> to </span>i$ determines which of the verification equations consists of a non-zero polynomial, and the stated soundness error follows in a similar fashion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Efficiency parameters. All the efficiency parameters follow directly from the construction.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-91" class="text-xl font-semibold mt-8">7.4 Biased generator consistency test</h3>

    <p class="text-gray-300">We explain how to check the correctness of the output for the subspace biased generator efficiently, with the assumption that we have a tensor-sum consistency test as described in Section 7.5.</p>

    <p class="text-gray-300">Construction 7.16. Given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon \\mathbb{F}_{p^{\\lambda}}^{s}\\to \\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span>, let <span class="math">G^{\\prime}(r_1,\\ldots ,r_t.r_{t + 1}):= G(r_1)\\otimes \\dots \\otimes G(r_t)\\otimes r_{t + 1}</span> for <span class="math">r_1,\\ldots ,r_t\\in \\mathbb{F}_{p^{\\lambda}}^s</span> and <span class="math">r_{t + 1}\\in \\mathbb{F}_{p^{\\lambda}}^{a / \\lambda}</span>. Then, use Construction 5.5 to construct <span class="math">G_{\\mathrm{sub}}\\colon \\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\to \\mathbb{F}_{p}^{\\lambda \\times b^{\\prime t}a}</span> from <span class="math">G^{\\prime}</span>.</p>

    <p class="text-gray-300">By Lemma 5.2, <span class="math">G&#x27;</span> is a <span class="math">(t\\epsilon + 1/p^{\\lambda})</span>-biased generator. Therefore, by Construction 5.5, <span class="math">G_{\\mathrm{sub}} \\colon \\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t} \\to \\mathbb{F}_{p}^{\\lambda \\times \\lambda b^{\\prime t}}</span> is a <span class="math">(p, \\lambda)</span>-subspace <span class="math">(t\\epsilon + 1/p^{\\lambda})</span>-biased generator.</p>

    <p class="text-gray-300">Lemma 7.17. Given an <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon \\mathbb{F}_{p^{\\lambda}}^{s}\\to \\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span>, let <span class="math">G^{\\prime}\\colon \\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\times \\mathbb{F}_{p^{\\lambda}}^{a / \\lambda}\\to \\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}t}a / \\lambda</span> and <span class="math">G_{\\mathrm{sub}}\\colon \\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\times \\mathbb{F}_{p^{\\lambda}}^{a / \\lambda}\\to \\mathbb{F}_{p}^{b^{\\prime}t}a</span> be the outputs from Construction 7.16. The matrix representation of the output of <span class="math">G_{\\mathrm{sub}}</span> can be written as sums of tensor products.</p>

    <p class="text-gray-300">Proof. For all <span class="math">r_1, \\ldots, r_t \\in \\mathbb{F}_{p^\\lambda}^s</span> and <span class="math">r_{t+1} \\in \\mathbb{F}_{p^\\lambda}^{a/\\lambda}</span>, we have <span class="math">G&#x27;(r_1, \\ldots, r_t \\cdot r_{t+1}) = G(r_1) \\otimes \\cdots \\otimes G(r_t) \\otimes r_{t+1}</span>. Indexing the entries of each <span class="math">G(r_j)</span> over <span class="math">[b&#x27;]</span>, <span class="math">r_{t+1}</span> over <span class="math">[a/\\lambda]</span>, and <span class="math">G&#x27;(r_1, \\ldots, r_t)</span> over <span class="math">[b&#x27;]^t</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">G ^ {\\prime} (r) _ {i _ {1}, \\dots , i _ {t}, i _ {t + 1}} = G (r _ {1}) _ {i _ {1}} \\cdot \\dots \\cdot G (r _ {t}) _ {i _ {t}} \\cdot \\left(r _ {t + 1}\\right) _ {i _ {t + 1}}. \\tag {9}</span></div>

    <p class="text-gray-300">Let <span class="math">M^{(i,j)} \\in \\mathbb{F}_p^{\\lambda \\times \\lambda}</span> be the matrix representation of the <span class="math">j</span>-th entry of <span class="math">G(r_i) \\in \\mathbb{F}_{p^\\lambda}^{b&#x27;}</span> or <span class="math">r_{t+1} \\in \\mathbb{F}_{p^\\lambda}^{a/\\lambda}</span>, as defined by Observation 5.4. Similarly, let <span class="math">Y^{(i_1,\\dots,i_{t+1})} \\in \\mathbb{F}_p^{\\lambda \\times \\lambda}</span> be the matrix representation of the <span class="math">(i_1,\\ldots,i_{t+1})</span>-th entry of <span class="math">G&#x27;(r) \\in \\mathbb{F}_{p^\\lambda}^{b&#x27;&#x27;a/\\lambda}</span>.</p>

    <p class="text-gray-300">Rewrite Equation (9) using the <span class="math">Y^{(i_1,\\dots,i_{t + 1})}</span> and matrix multiplications of the <span class="math">M^{(i,j)}</span>. For all <span class="math">i_1,\\ldots ,i_t\\in [b&#x27;]</span>, <span class="math">i_{t + 1}\\in [a / \\lambda ]</span>,</p>

    <div class="my-4 text-center"><span class="math-block">Y ^ {(i _ {1}, \\dots , i _ {t})} = \\prod_ {k = 1} ^ {t + 1} M ^ {(k, i _ {k})}.</span></div>

    <p class="text-gray-300">Writing out the matrix multiplication explicitly in terms of the entries of the <span class="math">M^{(k,i_k)}</span>, the <span class="math">(m_0,m_{t + 1})</span>-th entry of <span class="math">Y^{(i_1,\\dots ,i_{t + 1})}</span> is equal to</p>

    <div class="my-4 text-center"><span class="math-block">Y _ {m _ {0}, m _ {t + 1}} ^ {(i _ {1}, \\dots , i _ {t + 1})} = \\left(\\prod_ {k = 1} ^ {t + 1} M ^ {(k, i _ {k})}\\right) _ {m _ {0}, m _ {t + 1}} = \\sum_ {m _ {1}, \\dots , m _ {t} \\in [ \\lambda ]} \\prod_ {k = 1} ^ {t} M _ {m _ {k - 1}, m _ {k}} ^ {(k, i _ {k})}, \\tag {10}</span></div>

    <p class="text-gray-300">where the subscripts are row and column indices, respectively.</p>

    <p class="text-gray-300">Now we explain how we to write the output of <span class="math">G_{\\mathrm{sub}}</span> as a sum of tensor products. Define vectors <span class="math">y^{(m_0,m_{t + 1})}\\in \\mathbb{F}_p^{b^{\\prime}t}a</span> whose <span class="math">(i_1,\\ldots ,i_{t + 1})</span>-th entries are defined to be <span class="math">y^{(m_0,m_{t + 1})}_{i_1,\\dots ,i_{t + 1}}\\coloneqq Y^{(i_1,\\dots ,i_{t + 1})}_{m_0,m_{t + 1}}</span>. Define vectors <span class="math">v^{(k,m_{k - 1},m_k)}\\in \\mathbb{F}_p^{b&#x27;}</span> for <span class="math">k\\in [t]</span> and <span class="math">v^{(t + 1,m_t,m_{t + 1})}\\in \\mathbb{F}_p^{a / \\lambda}</span> whose <span class="math">i_k</span>-th entries are defined to be <span class="math">v^{(k,m_{k - 1},m_k)} := M^{(k,i_k)}_{m_{k - 1},m_k}</span>. Equation (10) can be rewritten as</p>

    <div class="my-4 text-center"><span class="math-block">y ^ {\\left(m _ {0}, m _ {t + 1}\\right)} = \\sum_ {m _ {1}, \\dots , m _ {t} \\in [ \\lambda ]} \\bigotimes_ {k = 1} ^ {t + 1} v ^ {\\left(k, m _ {k - 1}, m _ {k}\\right)}. \\tag {11}</span></div>

    <p class="text-gray-300">Equation (11) follows from Equation (10) by considering the <span class="math">(i_1,\\ldots ,i_{t + 1})</span>-th components of the equation.</p>

    <p class="text-gray-300">Since the output of <span class="math">G_{\\mathrm{sub}}</span> is <span class="math">Y</span> can be described using the vectors <span class="math">y^{(m_0,m_{t + 1})}\\in \\mathbb{F}_p^{b^{\\prime}t}a</span> for <span class="math">m_0,m_{t + 1}\\in [\\lambda ]</span> (using the <span class="math">Y^{(i_1,\\dots ,i_{t + 1})}</span> as an intermediate step), we have succeeded in writing the output of <span class="math">G_{\\mathrm{sub}}</span> as sums of tensor products.</p>

    <p class="text-gray-300">39</p>

    <p class="text-gray-300">Now we are ready to construct a tensor IOP for checking the output of subspace-biased generator using a tensor IOP for tensor-sum consistency in Section 7.5. Write <span class="math">\\epsilon_{\\texttt{TS}}</span> for the soundness error of the tensor-sum consistency protocol, <span class="math">\\mathsf{r}_{\\texttt{TS}}</span> for its round complexity, <span class="math">\\mathsf{l}_{\\texttt{TS}}</span> for its proof length, <span class="math">\\mathsf{qc}_{\\texttt{TS}}</span> for its query complexity, <span class="math">\\mathsf{c}_{\\texttt{TS}}</span> for its communication complexity, <span class="math">\\mathsf{tp}_{\\texttt{TS}}</span> for its prover arithmetic complexity, <span class="math">\\mathsf{tv}_{\\texttt{TS}}</span> for its verifier arithmetic complexity, and <span class="math">\\mathsf{rd}_{\\texttt{TS}}</span> for its randomness complexity. We also use <span class="math">\\mathsf{o}_{G_{\\texttt{sub}}}</span> to denote the arithmetic complexity of computing <span class="math">G_{\\texttt{sub}}</span> and <span class="math">\\mathsf{o}_{G}</span> to denote the arithmetic complexity of computing <span class="math">G</span>.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Theorem 7.18.</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, and <span class="math">\\epsilon</span>-biased generator <span class="math">G\\colon\\mathbb{F}_{p^{\\lambda}}^{s}\\to\\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span>, there is a <span class="math">(\\mathbb{F}_{p},b^{\\prime},t)</span>-tensor IOP, with non-adaptive queries, for the output of a <span class="math">(p,\\lambda)</span>-subspace biased generator <span class="math">G_{\\texttt{sub}}\\colon\\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\to\\mathbb{F}_{p}^{\\lambda\\times b^{\\prime t}a}</span> constructed using Construction 7.16 from <span class="math">G</span>, and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">\\epsilon_{\\texttt{TS}}</span>;</li>

      <li>round complexity is <span class="math">\\mathsf{r}_{\\texttt{TS}}</span>;</li>

      <li>proof length is <span class="math">O(\\lambda^{2}b^{\\prime t}a)</span> elements in <span class="math">\\mathbb{F}_{p}</span> and <span class="math">\\mathsf{l}_{\\texttt{TS}}</span> from subprotocols;</li>

      <li>query complexity is <span class="math">O(\\lambda^{2}\\mathsf{qc}_{\\texttt{TS}})</span>;</li>

      <li>the prover uses <span class="math">\\mathsf{o}_{G_{\\texttt{sub}}}\\,\\mathbb{F}_{p^{\\lambda}}</span>-operations in addition to <span class="math">\\mathsf{tp}_{\\texttt{TS}}</span> operations from the sub-protocols;</li>

      <li>the verifier uses <span class="math">(t\\cdot\\mathsf{o}_{G}+a/\\lambda)\\,\\mathbb{F}_{p^{\\lambda}}</span>-operations in addition to the <span class="math">\\mathsf{tv}_{\\texttt{TS}}</span> operations from the sub-protocols;</li>

      <li>the verifier has randomness complexity <span class="math">\\mathsf{rd}_{\\texttt{TS}}</span> from the sub-protocols.</li>

    </ul>

    <h6 id="sec-93" class="text-base font-medium mt-4">Construction 7.19 (tensor IOP for subspace biased generator).</h6>

    <p class="text-gray-300">We construct an interactive oracle proof <span class="math">\\mathsf{IOP}=(\\mathbf{I},\\mathbf{P},\\mathbf{V})</span> with tensor queries for checking the output of <span class="math">G_{\\texttt{sub}}</span> in Theorem 7.18. The indexer algorithm <span class="math">\\mathbf{I}</span> is trivial.</p>

    <p class="text-gray-300">The prover takes as input matrix <span class="math">R=G_{\\texttt{sub}}(r)\\in\\mathbb{F}_{p}^{\\lambda\\times b^{\\prime t}a}</span>,and seed <span class="math">r=(r_{1},\\ldots,r_{t},r_{t+1})\\in\\left(\\mathbb{F}_{p^{\\lambda}}^{s}\\right)^{t}\\times\\mathbb{F}_{p^{\\lambda}}^{a/\\lambda}</span>. The verifier takes as input <span class="math">r_{1},\\ldots,r_{t}\\in\\mathbb{F}_{p^{\\lambda}}^{s}</span> and <span class="math">r_{t+1}\\in\\mathbb{F}_{p^{\\lambda}}^{a/\\lambda}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}</span> sends oracle messages <span class="math">y^{(m_{0},m_{t+1})}\\in\\mathbb{F}_{p}^{b^{\\prime t}a}</span> defined as in Lemma 7.17;</li>

      <li><span class="math">\\mathbf{V}</span> computes <span class="math">v^{(k,m,m^{\\prime})}</span> for all <span class="math">k\\in[t+1],m,m^{\\prime}\\in[\\lambda]</span> such that <span class="math">v^{(k,m,m^{\\prime})}_{i_{k}}:=M^{(k,i_{k})}_{m,m^{\\prime}}</span>, where <span class="math">M^{(k,i_{k})}</span> is the matrix representation of the <span class="math">i_{k}</span>-th entry of <span class="math">G(r_{i_{k}})\\in\\mathbb{F}_{p^{\\lambda}}^{b^{\\prime}}</span> for <span class="math">k\\in[t]</span>, and the matrix representation of <span class="math">(r_{t+1})_{i_{t+1}}</span> when <span class="math">k=t+1</span>;</li>

      <li><span class="math">\\mathbf{P}</span> and <span class="math">\\mathbf{V}</span> engage in <span class="math">\\lambda^{2}</span> tensor-sum consistency tests (defined in Section 7.5) to check if <span class="math">y^{(m_{0},m_{t+1})}=\\sum_{m_{1},\\ldots,m_{t}}\\bigotimes_{k=1}^{t+1}v^{(k,m_{k-1},m_{k})}</span>.</li>

    </ul>

    <h6 id="sec-94" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We analyze the error and efficiency parameters of the above construction.</p>

    <p class="text-gray-300">Completeness. If the output of <span class="math">G_{\\texttt{sub}}</span> is correctly computed, then all the tensor-sum consistency tests will pass according to Lemma 7.17.</p>

    <p class="text-gray-300">Soundness. The soundness error is <span class="math">\\epsilon_{\\texttt{TS}}</span>: Suppose the output of <span class="math">G_{\\texttt{sub}}</span> is not correctly computed. Then at least one of the tensor-sum consistency passes incorrectly. The probability that this happens is <span class="math">\\epsilon_{\\texttt{TS}}</span>.</p>

    <p class="text-gray-300">Efficiency parameters. The round complexity, query complexity, and verifier’s randomness complexity are inherited from the tensor-sum consistency tests directly. The proof length is the length of the <span class="math">\\lambda^{2}</span> oracle messages in <span class="math">\\mathbb{F}_{p}^{b^{\\prime t}}</span> and the proof length from the sub-protocols. The prover’s and verifier’s arithmetic complexities include the operations from the sub-protocols, and the operations to compute <span class="math">G_{\\texttt{sub}}</span> and <span class="math">G</span>, respectively.</p>

    <p class="text-gray-300">7.5 Tensor-sum consistency test</p>

    <p class="text-gray-300">In Construction 7.9, <span class="math">\\mathbf{V}</span> knows <span class="math">r_{1,i},\\ldots,r_{t,i}\\in\\mathbb{F}^{k}</span> for <span class="math">i\\in[\\ell]</span> and must check that <span class="math">\\mathbf{P}</span> has sent <span class="math">r\\in\\mathbb{F}^{k^{t}}</span> that equals <span class="math">\\sum_{i=1}^{\\ell}r_{1,i}\\otimes\\cdots\\otimes r_{t,i}</span>. The test easily generalises to the case where the components <span class="math">r_{1,i},\\ldots,r_{t,i}</span> have different lengths.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">r_{i}:=r_{1,i}\\otimes\\cdots\\otimes r_{t,i}</span>. Using the same strategy as <em>[x1, Claim 6.9]</em>, note that for every tensor <span class="math">s=s_{1}\\otimes\\cdots\\otimes s_{t}\\in\\mathbb{F}^{k^{t}}</span>, we have <span class="math">\\langle r_{i},s\\rangle=\\langle r_{1,i},s_{1}\\rangle\\cdots\\langle r_{t,i},s_{t}\\rangle</span>, and if <span class="math">r_{i}\\neq r_{1,i}\\otimes\\cdots\\otimes r_{t,i}</span>, then by the Schwartz–Zippel lemma, <span class="math">\\langle r_{i},s\\rangle\\neq\\langle r_{1,i},s_{1}\\rangle\\cdots\\langle r_{t,i},s_{t}\\rangle</span> except with probability at most $t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over the random choice of </span>s<span class="math">. The same strategy can be applied to the sum of the </span>r_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To check that <span class="math">\\sum_{i=1}^{\\ell}r_{1,i}\\otimes\\cdots\\otimes r_{t,i}</span>, the verifier samples random <span class="math">s_{1},\\ldots,s_{t}\\in\\mathbb{F}^{k}</span>, and queries <span class="math">r</span> at the tensor <span class="math">s=s_{1}\\otimes\\cdots\\otimes s_{t}\\in\\mathbb{F}^{k^{t}}</span>. The verifier computes <span class="math">\\sum_{i=1}^{k}\\langle r_{1,i},s_{1}\\rangle\\cdots\\langle r_{t,i},s_{t}\\rangle</span> in <span class="math">O(\\ell tk)</span> arithmetic operations, and checks that the two values are equal. This gives rise to the following claim.</p>

    <h6 id="sec-95" class="text-base font-medium mt-4">Claim 7.20.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In a <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP, where <span class="math">\\mathbf{V}</span> has oracle access to <span class="math">v\\in\\mathbb{F}^{k^{t}}</span> and explicit input <span class="math">v_{1,i},\\ldots,v_{t,i}\\in\\mathbb{F}^{k}</span>, <span class="math">\\mathbf{V}</span> can check that <span class="math">v=\\sum_{i=1}^{\\ell}v_{1,i}\\otimes\\cdots\\otimes v_{t,i}</span> with soundness error $t/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, using a single tensor query to </span>v<span class="math"> and </span>O(\\ell tk)$ arithmetic operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8 From point queries to tensor queries</p>

    <p class="text-gray-300">We give a generalization of the compiler of <em>[x1]</em>, which transforms a tensor-query IOP into a corresponding point-query IOP. That compiler relies on a proximity test for tensor codes which “folds” vectors via random linear combinations, using the fact that if any of the vectors is far from the code then the random linear combination is likely to be far from the code. Our generalization enables folding via any linear combination that satisfies the following distance preservation property.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Definition 8.1 (<em>[x1]</em>).</h6>

    <p class="text-gray-300">We say that <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{\\ell}</span> is a <span class="math">(\\delta_{0},\\epsilon)</span>-proximity generator if for all <span class="math">n</span>, all codes <span class="math">\\mathcal{C}\\subseteq\\mathbb{F}^{n}</span>, all <span class="math">U\\in\\mathbb{F}^{\\ell\\times n}</span> with (blockwise) relative distance <span class="math">\\delta_{U}=\\delta(U,\\mathcal{C}^{\\ell})</span>, and all <span class="math">\\Delta\\in[0,1]</span> such that <span class="math">\\Delta&lt;\\delta_{0}(\\mathcal{C},U)</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\Pr_{w\\leftarrow\\mathbb{F}^{s}}[\\delta(G(w)^{\\intercal}U,\\mathcal{C})\\leq\\Delta]\\leq\\epsilon(\\Delta)\\enspace.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The proximity generators used in prior work do not suffice for us. In <em>[x1]</em>, <span class="math">s=1</span> but <span class="math">\\epsilon=O(\\ell\\cdot n)</span>, which prevents the compiler from being used over fields with <span class="math">o(n)</span> elements; and in <em>[x1]</em>, $\\epsilon=O(1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> but </span>s=O(\\ell)<span class="math">, which is too inefficient for our purposes, as the verifier must send the entire seed for the proximity generator to the prover, and this incurs </span>O(k)$ communication costs in the consistency test. However, if we plug the proximity generator obtained in <em>[x1]</em> (see Section 8.3) into our generalized compiler, then we obtain a compiler that with suitable efficiency over not-too-large fields.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-97" class="text-base font-medium mt-4">Definition 8.2.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">R_{\\text{\\tiny{cons}}}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\mathfrak{i},\\mathbb{x},\\mathbb{w})=\\Big{(}\\bot,(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s}),c\\Big{)}</span></p>

    <p class="text-gray-300">such that <span class="math">c=\\mathrm{Enc}_{\\mathcal{C}^{\\otimes t}}(f)\\in\\mathbb{F}^{\\ell\\cdot n^{t}}</span> for some <span class="math">f\\in\\mathbb{F}^{\\ell\\cdot k^{t}}</span>, for each <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">q^{(s)}=(q_{0}^{(s)},\\ldots,q_{t}^{(s)})\\in\\mathbb{F}^{\\ell}\\times\\left(\\mathbb{F}^{k}\\right)^{t}</span>, and for all <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">\\langle\\otimes_{i}q_{i}^{(s)},f\\rangle=v^{(s)}</span>.</p>

    <h6 id="sec-98" class="text-base font-medium mt-4">Remark 8.3.</h6>

    <p class="text-gray-300">For notational simplicity, when proving Lemma 8.4 which follows, we assume that the function <span class="math">\\delta_{0}</span> associated with proximity generators <span class="math">G</span> and <span class="math">G^{\\prime}</span> simply divides the relative distance <span class="math">\\delta_{U}</span> of an interleaved codeword <span class="math">U</span> by a constant factor <span class="math">\\kappa</span>. The analysis still applies to more general functions <span class="math">\\delta_{0}</span>, resulting in iterated <span class="math">\\delta_{0}</span> functions in expressions for the soundness error.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Lemma 8.4.</h6>

    <p class="text-gray-300">Consider the following ingredients.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A linear code <span class="math">\\mathcal{C}</span> over <span class="math">\\mathbb{F}</span> with rate <span class="math">\\rho=\\frac{k}{n}</span>, relative distance <span class="math">\\delta=\\frac{d}{n}</span>, and encoding arithmetic complexity <span class="math">\\Psi(k)\\cdot k</span>.</li>

      <li>A function <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{(\\mathfrak{q}+1)k}</span> such that for each <span class="math">r\\in[t-1]</span>, <span class="math">\\mathcal{C}^{\\otimes r}</span> has a <span class="math">(\\delta_{0},\\epsilon)</span> proximity gap with <span class="math">\\delta_{0}(\\mathcal{C}^{\\otimes r},U)=\\delta(U,\\mathcal{C}^{\\otimes r})/\\kappa</span>, and <span class="math">G</span> can be evaluated in <span class="math">\\mathsf{o}_{G}</span> operations over <span class="math">\\mathbb{F}</span>.</li>

      <li>A function <span class="math">G^{\\prime}\\colon\\mathbb{F}^{s^{\\prime}}\\to\\mathbb{F}^{\\ell}</span> with a <span class="math">(\\delta_{0},\\epsilon)</span> proximity gap with threshold <span class="math">\\delta_{0}(\\mathcal{C}^{\\otimes t},U)=\\delta(U,\\mathcal{C}^{\\otimes t})/\\kappa</span>, and <span class="math">G^{\\prime}</span> can be evaluated in <span class="math">\\mathsf{o}_{G^{\\prime}}</span> operations over <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">There exists an non-adaptive interactive oracle proof of proximity <span class="math">\\mathsf{IOPP}=(\\mathbf{P},(\\mathbf{V}_{\\mathrm{q}},\\mathbf{V}_{\\mathrm{d}}))</span> with point queries for the relation <span class="math">R_{\\text{\\tiny{cons}}}(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s})</span> with the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}^{\\ell}</span> for the witness, and <span class="math">\\mathbb{F}^{k}</span> for the proof;</li>

      <li>soundness error <span class="math">O\\left(\\sum_{r=1}^{t}\\epsilon(\\min\\{\\delta^{t-r}/4,\\Delta_{\\otimes}\\})\\right)+\\left(1-\\kappa^{-2}\\min\\{\\delta^{t}/4,\\Delta_{\\otimes}\\}\\right)^{\\lambda}+\\left(1-\\left(\\delta^{t}-2\\min\\{\\delta^{t}/4,\\Delta_{\\otimes}\\}\\right)\\right)^{\\lambda}</span>;</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(t)</span>;</li>

      <li>proof length <span class="math">O(\\mathfrak{q} \\cdot n^{t-1})</span>;</li>

      <li>query complexity <span class="math">O(\\lambda)</span> to the witness and <span class="math">O(\\lambda \\cdot t \\cdot \\mathfrak{q})</span> to the proof;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- prover time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathfrak{q} \\cdot t\\ell k^t) + (t - 1) \\cdot \\mathsf{o}_G + \\mathsf{o}_G'$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>verifier randomness complexity <span class="math">O(t \\cdot \\mathfrak{q})</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li><span class="math">\\mathbf{V}_{\\mathrm{d}}</span>'s decision state <span class="math">\\sigma = (\\Xi, r)</span> where <span class="math">r</span> is the verifier randomness;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathbf{V}_{\\mathrm{d}}</span> time $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mathfrak{q} \\cdot (\\ell + kt)) + (t - 1) \\cdot \\mathsf{o}_G + \\mathsf{o}_G'$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-100" class="text-2xl font-bold">8.1 Proximity test</h2>

    <p class="text-gray-300"><strong>Definition 8.5.</strong> The indexed relation <span class="math">R_{\\otimes}</span> is the set of tuples</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbb {i}, \\Xi , \\mathbb {w}) = \\left(\\bot , (\\mathbb {F}, \\mathcal {C}, \\ell , \\mathfrak {q}, t), (c _ {0} ^ {(0)}, \\{c _ {1} ^ {(s)} \\} _ {s}, \\dots , \\{c _ {t - 1} ^ {(s)} \\} _ {s})\\right)</span></div>

    <p class="text-gray-300">such that <span class="math">c_0^{(0)} \\in (\\mathcal{C}^{\\otimes t})^\\ell</span> and, for all <span class="math">r \\in [t - 1]</span> and <span class="math">s \\in [\\mathfrak{q}]</span>, we have <span class="math">c_r^{(s)} \\in (\\mathcal{C}^{\\otimes t - r})^k</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Definition 8.6.</strong> Let <span class="math">\\mathbb{W} = (c_0^{(0)},\\{c_1^{(s)}\\}_s,\\ldots ,\\{c_{t - 1}^{(s)}\\}_s)</span> be such that <span class="math">c_0^{(0)}\\in \\mathbb{F}^{\\ell \\cdot n^t}</span> and, for all <span class="math">r\\in [t - 1]</span> and <span class="math">s\\in [\\mathfrak{q}]</span>, we have <span class="math">c_r^{(s)}\\in \\mathbb{F}^{k\\cdot n^{t - r}}</span>. Given <span class="math">(\\mathbb{i},\\Xi) = (\\bot ,(\\mathbb{F},\\mathcal{C},\\ell ,\\mathfrak{q},t))</span>, the <span class="math">\\Delta_{\\otimes}</span>-distance of <span class="math">\\mathbb{W}</span> to $R_{\\mathrm{com}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{(\\mathbb{i},\\Xi)}$ is</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">$$ \\begin{array}{l}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_ {\\otimes} \\left(\\mathbb {w}, R _ {\\mathrm {c o m}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {(\\mathbb {i}, \\Xi)}\\right) := \\max  \\{\\Delta_ {0}, \\Delta_ {1}, \\ldots , \\Delta_ {t - 1} \\} \\quad \\text {where} \\quad \\left\\{</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\begin{array}{l} \\Delta_ {0} := \\Delta (c _ {0} ^ {(0)}, \\mathcal {C} ^ {\\otimes t}) \\\\ \\forall r \\in [ t - 1 ], \\Delta_ {r} := \\Delta (\\{c _ {r} ^ {(s)} \\} _ {s}, \\mathcal {C} ^ {\\otimes t - r}) \\\\ \\end{array} \\right. \\end{array} $$</p>

    <p class="text-gray-300"><strong>Definition 8.7.</strong> The folding of a function <span class="math">c\\colon [a]\\times [b_1]\\times \\dots \\times [b_h]\\to \\mathbb{F}</span> by a linear combination <span class="math">\\alpha \\colon [a]\\to \\mathbb{F}</span> is the function <span class="math">\\operatorname {Fold}(c;\\alpha)\\colon [b_1]\\times \\dots \\times [b_h]\\to \\mathbb{F}</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} (c; \\alpha) := \\sum_ {i \\in [ a ]} \\alpha (i) c (i, \\cdot , \\dots , \\cdot). \\tag {12}</span></div>

    <p class="text-gray-300">Moreover, the folding of a set of functions <span class="math">\\{c_s\\}_s</span> by a set of corresponding linear combinations <span class="math">\\{\\zeta_s\\}_s</span> is the function <span class="math">\\operatorname{Fold}(\\{c_s\\}_s; \\{\\zeta_s\\}_s) \\colon [b_1] \\times \\dots \\times [b_h] \\to \\mathbb{F}</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} \\left(\\left\\{c _ {s} \\right\\} _ {s}; \\left\\{\\zeta_ {s} \\right\\} _ {s}\\right) := \\sum_ {s} \\operatorname {F o l d} \\left(c _ {s}; \\zeta_ {s}\\right).</span></div>

    <p class="text-gray-300">More generally, for <span class="math">r \\in \\{0, 1, \\ldots, h\\}</span>, we write <span class="math">\\operatorname{Fold}_r</span> to indicate a folding operation that is applied to the <span class="math">r</span>-th coordinate in the sum in Equation (12), as opposed to the 0-th coordinate.</p>

    <p class="text-gray-300"><strong>Remark 8.8.</strong> For efficiency reasons, we assume that the honest prover <span class="math">\\mathbf{P}&#x27;</span> also receives the decodings <span class="math">(f_0^{(0)},\\{f_1^{(s)}\\}_s,\\ldots ,\\{f_{t - 1}^{(s)}\\}_s)</span> of the witness elements <span class="math">(c_0^{(0)},\\{c_1^{(s)}\\}_s,\\ldots ,\\{c_{t - 1}^{(s)}\\}_s)</span> in the construction below.</p>

    <p class="text-gray-300"><strong>Construction 8.9.</strong> We describe the construction of <span class="math">\\mathsf{IOPP} = (\\mathbf{P}&#x27;,\\mathbf{V}&#x27;)</span>. The prover <span class="math">\\mathbf{P}&#x27;</span> takes as input an index <span class="math">\\mathbb{i} = \\bot</span>, instance <span class="math">\\Xi = (\\mathbb{F},\\mathcal{C},\\ell ,\\mathfrak{q},t)</span>, witness codewords <span class="math">\\mathbb{W} = (c_0^{(0)},\\{c_1^{(s)}\\}_s,\\ldots ,\\{c_{t - 1}^{(s)}\\}_s)</span> and underlying messages <span class="math">(f_0^{(0)},\\{f_1^{(s)}\\}_s,\\ldots ,\\{f_{t - 1}^{(s)}\\}_s)</span>, while the verifier <span class="math">\\mathbf{V}&#x27;</span> takes as input the index <span class="math">\\mathbb{i}</span> and the instance <span class="math">\\Xi</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Interactive phase. For each round <span class="math">r \\in [t]</span>:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{V}&#x27;</span> sends random challenge message <span class="math">w \\in \\mathbb{F}^s</span>. (For <span class="math">r = 1</span>, <span class="math">\\mathbf{V}&#x27;</span> sends <span class="math">w \\in \\mathbb{F}^{s&#x27;}</span>.)</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{P}^{\\prime}</span> sends the proof message <span class="math">c_{r}^{(0)}\\in\\mathbb{F}^{k\\cdot n^{t-r}}</span> computed as</li>

    </ul>

    <p class="text-gray-300"><span class="math">f_{r}^{(0)}\\coloneqq\\mathrm{Fold}_{r-1}(\\{f_{r-1}^{(s)}\\}_{s};G(w))\\quad\\text{and}\\quad c_{r}^{(0)}\\coloneqq\\mathrm{Enc}_{r+1,\\ldots,t}(f_{r}^{(0)})\\enspace.</span></p>

    <p class="text-gray-300">(For <span class="math">r=1</span>, <span class="math">\\mathbf{P}^{\\prime}</span> uses <span class="math">\\mathrm{Fold}_{r-1}(\\{f_{r-1}^{(s)}\\}_{s};G^{\\prime}(w))</span> instead.)</p>

    <p class="text-gray-300">Note that when <span class="math">r=t</span> the expression <span class="math">\\mathrm{Enc}_{r+1,\\ldots,t}</span> is degenerate and no encoding takes place.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Query phase. The verifier <span class="math">\\mathbf{V}^{\\prime}</span> samples <span class="math">\\lambda</span> tuples of the form <span class="math">(j_{1},\\ldots,j_{t})\\leftarrow[n]^{t}</span> and proceeds as follows for each tuple. For each <span class="math">s\\in\\{0,1,\\ldots,\\mathfrak{q}\\}</span>, <span class="math">\\mathbf{V}^{\\prime}</span> queries the function <span class="math">c_{r}^{(s)}\\colon[k]\\times[n]^{t-r}\\to\\mathbb{F}</span> at <span class="math">(i_{r},j_{r+1},\\ldots,j_{t})</span> for each <span class="math">i_{r}\\in[k]</span> and checks, for each <span class="math">r\\in[t]</span>, the following equation (replacing <span class="math">G</span> with <span class="math">G^{\\prime}</span> when <span class="math">r=1</span>):</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathrm{Fold}_{r-1}(\\{c_{r-1}^{(s)}\\}_{s};G(w))(j_{r},\\ldots,j_{t})=\\mathrm{Enc}(c_{r}^{(0)})(j_{r},\\ldots,j_{t})\\enspace.</span> (13)</p>

    <h6 id="sec-101" class="text-base font-medium mt-4">Lemma 8.10.</h6>

    <p class="text-gray-300">The proximity test is sound with soundness error</p>

    <p class="text-gray-300"><span class="math">O\\left(\\sum_{r=1}^{t}\\epsilon(\\min\\{\\delta^{t-r}/4,\\Delta_{\\otimes}\\})\\right)+\\left(1-\\kappa^{-2}\\min\\{\\delta^{t-1}/4,\\Delta_{\\otimes}\\}\\right)^{\\lambda}\\enspace.</span></p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">If <span class="math">(\\mathbb{i},\\mathbb{z})\\notin L(R_{\\otimes})</span>, then the witness <span class="math">\\mathbb{w}</span> and the oracle messages sent by a malicious prover <span class="math">\\mathbf{P}^{\\prime}</span> define functions <span class="math">c_{r}^{(s)}</span> for <span class="math">r\\in[t]</span> and <span class="math">s\\in[\\mathfrak{q}]</span>. If <span class="math">\\mathbf{P}^{\\prime}</span> were honest, each oracle message <span class="math">c_{r}^{(s)}</span> would lie in <span class="math">(\\mathcal{C}^{\\otimes t-r})^{k}</span> and <span class="math">c_{0}^{(0)}</span> would lie in <span class="math">(\\mathcal{C}^{\\otimes t})^{\\ell}</span>.</p>

    <p class="text-gray-300">As in <em>[x1]</em>, the soundness analysis can be separated into two cases, each accounting for one of the terms in the soundness error. For each <span class="math">r\\in\\{0,1,\\ldots,t\\}</span>, we define <span class="math">\\Delta_{r}^{\\dagger}:=\\min\\{\\delta^{t-r}/4,\\Delta_{\\otimes}\\}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: One of the proximity generators fails (described as distortion in <em>[x1]</em>). This means that for some <span class="math">r\\in[t]</span>, we have <span class="math">\\Delta(\\mathrm{Fold}(\\{c_{r}^{(s)}\\}_{s};G(w)),\\mathcal{C}^{\\otimes t-r})&lt;\\Delta_{r}^{\\dagger}/\\kappa</span>.</li>

    </ul>

    <p class="text-gray-300">Since <span class="math">G</span> is a proximity generator, this occurs with probability at most <span class="math">\\epsilon(\\min\\{\\Delta_{r},\\Delta_{r}^{\\dagger}\\})</span>. This replaces the use of a specific proximity generator from <em>[x2]</em>.</p>

    <p class="text-gray-300">Applying a union bound, the probability that any proximity generator fails is bounded above by</p>

    <p class="text-gray-300"><span class="math">O\\left(\\sum_{r=1}^{t}\\epsilon(\\min\\{\\Delta_{r},\\Delta_{r}^{\\dagger}\\})\\right)\\enspace.</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: None of the proximity generators fail. At least one of the proof messages is far from being a codeword, or the proof messages are close to being codewords but the decoded messages from different rounds of the interactive phase are not consistent. Formally, for all <span class="math">r\\in\\{0,1,\\ldots,t-1\\}</span>, we have <span class="math">\\Delta(\\mathrm{Fold}(\\{c_{r}^{(s)}\\}_{s};G(w)),\\mathcal{C}^{\\otimes t-r})\\geq\\Delta_{r}^{\\dagger}/\\kappa</span> but there exists <span class="math">r\\in\\{0,1,\\ldots,t-1\\}</span> such that one of the following conditions is satisfied:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Delta_{r}\\geq\\Delta_{r}^{\\dagger}</span>;</li>

      <li><span class="math">\\Delta_{r}&lt;\\Delta_{r}^{\\dagger}</span> and <span class="math">\\mathrm{Fold}_{r}(\\{\\overline{c}_{r}^{(s)}\\}_{s};G(w))\\neq\\mathrm{Enc}_{r+1}(\\overline{c}_{r+1}^{(0)})</span>.</li>

    </ul>

    <p class="text-gray-300">Here, <span class="math">\\overline{c}_{r}^{(s)}</span> is the closest codeword to <span class="math">c_{r}^{(s)}</span>. This closest codeword exists and is unique if the second condition is satisfied, since <span class="math">\\Delta_{r}&lt;\\Delta_{r}^{\\dagger}</span></p>

    <p class="text-gray-300">In this case, the analysis from [BCG20, Section 10.3.4] holds, with <span class="math">\\Delta_{r^<em>}^{\\dagger}</span> replaced by <span class="math">\\Delta_{r^</em>}^{\\dagger} / \\kappa</span> in [BCG20, Claim 10.11]. This gives a lower bound of <span class="math">\\Delta_{r^*}^{\\dagger} / \\kappa</span> on the probability that verifier queries lie in "failure" and "error" sets. The analysis from [BCG20, Section 10.3.5] then adapts to shows that the verifier will reject at least a <span class="math">1 / \\kappa</span> fraction of all queries in the failure or error sets, leading to a probability of <span class="math">\\min_r\\{\\Delta_r^\\dagger\\} = \\min \\{\\delta^t /4,\\Delta_\\infty \\}</span> that the verifier will reject when <span class="math">\\lambda = 1</span>. This leads to the stated soundness error.</p>

    <p class="text-gray-300">□</p>

    <h2 id="sec-103" class="text-2xl font-bold">8.2 Consistency checks on tensor codes</h2>

    <p class="text-gray-300"><strong>Construction 8.11.</strong> We describe the construction of <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span>. The indexer <span class="math">\\hat{\\mathbf{I}}</span>, given an index <span class="math">\\mathbb{I}</span>, runs <span class="math">\\mathbf{I}</span> on <span class="math">\\mathbb{I}</span> to produce <span class="math">\\Pi_0\\in \\mathbb{F}^{\\ell_0\\cdot k^t}</span> indexed by <span class="math">(i_0,i_1,\\ldots ,i_t)\\in [\\ell_0]\\times [k]^t</span>; then computes and outputs <span class="math">\\hat{\\Pi}_0\\coloneqq \\mathrm{Enc}_{1,\\dots,t}(\\Pi_0)\\in \\mathbb{F}^{\\ell_0\\cdot n^t}</span>.</p>

    <p class="text-gray-300">The prover <span class="math">\\hat{\\mathbf{P}}</span> receives as input an instance <span class="math">\\mathbf{x}</span> and witness <span class="math">\\mathbf{w}</span>, while the verifier <span class="math">\\hat{\\mathbf{V}}</span> receives as input the instance <span class="math">\\mathbf{x}</span>. The construction has two phases, a simulation phase and a consistency phase. We describe each in turn.</p>

    <p class="text-gray-300"><strong>Simulation phase.</strong> For each <span class="math">i \\in [\\mathsf{rc}]</span>, <span class="math">\\hat{\\mathbf{P}}</span> and <span class="math">\\hat{\\mathbf{V}}</span> simulate the <span class="math">i</span>-th round of the interaction between <span class="math">\\mathbf{P}(\\mathbf{x}, \\mathbf{w})</span> and <span class="math">\\mathbf{V}(\\mathbf{x})</span>, as well as any tensor queries by <span class="math">\\mathbf{V}</span> to the received proof strings.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Prover messages.</strong> <span class="math">\\hat{\\mathbf{P}}</span> receives from <span class="math">\\mathbf{P}</span> a proof message <span class="math">\\Pi_i \\in \\mathbb{F}^{\\ell_i \\cdot k^t}</span> indexed by <span class="math">(i_0, i_1, \\ldots, i_t) \\in [\\ell_i] \\times [k]^t</span>, computes a new proof message <span class="math">\\hat{\\Pi}_i \\coloneqq \\mathrm{Enc}_{t,\\dots,t}(\\Pi_i) \\in \\mathbb{F}^{\\ell_i \\cdot n^t}</span>, and sends <span class="math">\\hat{\\Pi}_i</span> to <span class="math">\\hat{\\mathbf{V}}</span>. Also, <span class="math">\\hat{\\mathbf{P}}</span> forwards any non-oracle messages from <span class="math">\\mathbf{P}</span> to <span class="math">\\mathbf{V}</span> via <span class="math">\\hat{\\mathbf{V}}</span>.</li>

      <li><strong>Verifier messages.</strong> <span class="math">\\hat{\\mathbf{V}}</span> receives challenge message <span class="math">\\rho_{i}</span> from <span class="math">\\mathbf{V}</span> and forwards it to <span class="math">\\hat{\\mathbf{P}}</span>, who forwards it to <span class="math">\\mathbf{P}</span>.</li>

      <li><strong>Tensor queries.</strong> If <span class="math">\\hat{\\mathbf{V}}</span> receives any tensor query (or queries) <span class="math">q \\in \\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F}, k, t)</span> on <span class="math">(\\Pi_0, \\Pi_1, \\ldots, \\Pi_i)</span> from <span class="math">\\mathbf{V}</span>, it sends the query <span class="math">q</span> to <span class="math">\\hat{\\mathbf{P}}</span>, who responds by computing <span class="math">q(\\mathbf{x}, \\Pi_0, \\Pi_1, \\ldots, \\Pi_i)</span> themselves and sending it to <span class="math">\\hat{\\mathbf{V}}</span> as a non-oracle message. Then <span class="math">\\hat{\\mathbf{V}}</span> forwards this (alleged) query answer to <span class="math">\\mathbf{V}</span>.</li>

    </ol>

    <p class="text-gray-300">This completes the simulation of the tensor IOP. If at this point the tensor IOP verifier <span class="math">\\mathbf{V}</span> rejects, then the IOP verifier <span class="math">\\hat{\\mathbf{V}}</span> rejects too. (There is no need to check if the IOP prover <span class="math">\\hat{\\mathbf{P}}</span> answered tensor queries honestly.)</p>

    <p class="text-gray-300"><strong>Consistency phase.</strong> In this phase the IOP verifier <span class="math">\\hat{\\mathbf{V}}</span> checks that the IOP prover <span class="math">\\hat{\\mathbf{P}}</span> honestly answered the tensor queries of the tensor IOP verifier <span class="math">\\mathbf{V}</span> in the simulation phase. Suppose that the tensor queries of <span class="math">\\mathbf{V}</span> are given by <span class="math">q^{(s)} = (q_0^{(s)}, q_1^{(s)}, \\ldots, q_t^{(s)})</span> for each <span class="math">s \\in [\\mathfrak{q}]</span>. They are known to <span class="math">\\hat{\\mathbf{P}}</span> and <span class="math">\\hat{\\mathbf{V}}</span>. They interact as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Send codewords.</strong> The prover <span class="math">\\hat{\\mathbf{P}}</span> sends proof messages <span class="math">\\{c_r^{(1)},\\ldots ,c_r^{(\\mathfrak{q})}\\in \\mathbb{F}^{k\\cdot n^{t - r}}\\}_{r\\in [t]}</span> that are computed as described below.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, define the functions</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {0} ^ {(0)} := \\operatorname {S t a c k} \\left(\\Pi_ {0}, \\dots , \\Pi_ {\\mathbf {r c}}\\right) \\in \\mathbb {F} ^ {\\ell \\cdot k ^ {t}} \\quad \\text {and} \\quad c _ {0} ^ {(0)} \\left(i _ {0}, j _ {1}, \\dots , j _ {t}\\right) := \\operatorname {S t a c k} \\left(\\hat {\\Pi} _ {0}, \\dots , \\hat {\\Pi} _ {\\mathbf {r c}}\\right) \\in \\mathbb {F} ^ {\\ell \\cdot n ^ {t}}.</span></div>

    <p class="text-gray-300">Note that <span class="math">c_0^{(0)} = \\mathrm{Enc}_{1,\\dots,t}(f_0^{(0)})</span>. Moreover, <span class="math">\\hat{\\mathbf{P}}</span> already knows the value of <span class="math">f_0^{(0)}</span> and of <span class="math">c_0^{(0)}</span> at every point, and <span class="math">\\hat{\\mathbf{V}}</span> has point-query access to every value of <span class="math">c_0^{(0)}</span> from the index or the messages sent during the simulation phase.</p>

    <p class="text-gray-300">45</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Next, for each <span class="math">r \\in [t]</span> and <span class="math">s \\in [\\mathfrak{q}]</span>, <span class="math">\\hat{\\mathbf{P}}</span> computes the following message and its encoding:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">f _ {r} ^ {(s)} := \\operatorname {F o l d} _ {r - 1} \\left(f _ {r - 1} ^ {(s)}; q _ {r - 1} ^ {(s)}\\right) \\in \\mathbb {F} ^ {k \\cdot k ^ {t - r}} \\quad \\text {and} \\quad c _ {r} ^ {(s)} := \\operatorname {E n c} _ {r + 1, \\dots , t} \\left(f _ {r} ^ {(s)}\\right) \\in \\mathbb {F} ^ {k \\cdot n ^ {t - r}}.</span></div>

    <p class="text-gray-300">For <span class="math">r = 1</span>, <span class="math">\\mathrm{Fold}_{r-1}(f_{r-1}^{(0)}; q_{r-1}^{(s)})</span> is used. When <span class="math">r = t</span>, the expression <span class="math">\\mathrm{Enc}_{r+1,\\dots,t}</span> is degenerate and no encoding takes place, and so <span class="math">c_t^{(1)}, \\ldots, c_t^{(\\mathfrak{q})}</span> are vectors in <span class="math">\\mathbb{F}^k</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proximity test. The prover <span class="math">\\hat{\\mathbf{P}}</span> and verifier <span class="math">\\hat{\\mathbf{V}}</span> engage in the IOP of proximity <span class="math">\\mathsf{IOPP} = (\\mathbf{P}&#x27;,\\mathbf{V}&#x27;)</span> for <span class="math">R_{\\otimes}(\\mathbb{F},\\mathcal{C},\\ell ,\\mathfrak{q},t)</span> with index <span class="math">\\dot{\\mathfrak{s}} = \\bot</span>, instance <span class="math">\\mathbb{x} = (\\mathbb{F},\\mathcal{C},\\ell ,\\mathfrak{q},t)</span>, and witness <span class="math">\\mathbb{W} = (c_0^{(0)},\\{c_1^{(s)}\\}_s,\\ldots ,\\{c_{t - 1}^{(s)}\\}_s)</span> to show that <span class="math">c_0^{(0)}\\in (\\mathcal{C}^{\\otimes t})^\\ell</span> (or at least close) and that <span class="math">c_r^{(s)}\\in (\\mathcal{C}^{\\otimes t - r})^k</span> (or at least close) for all <span class="math">r\\in [t]</span> and <span class="math">s\\in [\\mathfrak{q}]</span>. (If <span class="math">\\mathbf{V}&#x27;</span> rejects in this sub-protocol, then <span class="math">\\hat{\\mathbf{V}}</span> rejects.)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency checks. The verifier <span class="math">\\hat{\\mathbf{V}}</span> samples <span class="math">\\lambda</span> tuples of the form <span class="math">(j_{1},\\ldots ,j_{t})\\gets [n]^{t}</span> and, for each tuple <span class="math">(j_{1},\\ldots ,j_{t})</span>, proceeds as follows. For each <span class="math">r\\in [t]</span>, each <span class="math">s\\in [\\mathfrak{q}]</span>, and each <span class="math">i_r\\in [k]</span>, the verifier <span class="math">\\hat{\\mathbf{V}}</span> queries the function <span class="math">c_{r}^{(s)}: [k] \\times [n]^{t - r} \\to \\mathbb{F}</span> at <span class="math">(i_r,j_{r + 1},\\dots ,j_t)</span>. Then, for each <span class="math">r\\in [t]</span> and <span class="math">s\\in [\\mathfrak{q}]</span>, <span class="math">\\hat{\\mathbf{V}}</span> checks the following equation:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} _ {r - 1} \\left(c _ {r - 1} ^ {(s)}; q _ {r - 1} ^ {(s)}\\right) \\left(j _ {r}, \\dots , j _ {t}\\right) = \\operatorname {E n c} _ {r} \\left(c _ {r} ^ {(s)}\\right) \\left(j _ {r}, \\dots , j _ {t}\\right).</span></div>

    <p class="text-gray-300">Finally, for each <span class="math">s[\\mathfrak{q}]</span>, <span class="math">\\hat{\\mathbf{V}}</span> computes <span class="math">\\mathrm{Fold}_t(c_t^{(s)};q_t^{(s)})</span>, and checks that it is equal to the answer to the <span class="math">s</span>-th tensor query <span class="math">q^{(s)} = (q_0^{(s)},q_1^{(s)},\\ldots ,q_t^{(s)})</span> that was reported by <span class="math">\\hat{\\mathbf{P}}</span> in the simulation phase.</p>

    <p class="text-gray-300">Lemma 8.12 (soundness). <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}})</span> has soundness error</p>

    <div class="my-4 text-center"><span class="math-block">\\epsilon^ {\\prime} \\left(\\Delta_ {\\otimes}\\right) + \\left(1 - \\left(\\delta^ {t} - 2 \\min  \\{\\delta^ {t} / 4, \\Delta_ {\\otimes} \\}\\right)\\right) ^ {\\lambda}.</span></div>

    <p class="text-gray-300">Proof sketch. If <span class="math">(\\dot{\\mathfrak{s}},\\mathfrak{x})\\notin L(R)</span> then the witness <span class="math">\\mathbb{W}</span> and oracle messages sent by a malicious prover <span class="math">\\hat{\\mathbf{P}}</span> define a word <span class="math">c_0^{(0)}\\in \\mathbb{F}^{\\ell \\cdot n^t}</span> which, in an honest proof, would be <span class="math">\\ell</span> interleaved <span class="math">\\mathcal{C}^{\\otimes t}</span>-codewords, and word <span class="math">c_r^{(s)}\\in \\mathbb{F}^{k\\cdot n^{t - r}}</span> for each <span class="math">r\\in [t]</span> and <span class="math">s\\in [\\mathfrak{q}]</span>, where, in an honest proof, <span class="math">c_{r}^{(s)}</span> would be <span class="math">k</span> interleaved <span class="math">\\mathcal{C}^{\\otimes t - r}</span>-codewords.</p>

    <p class="text-gray-300">We separate the soundness proof into different cases.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: At least one of the proof messages is far from being a codeword. Formally, there exists <span class="math">r \\in \\{0,1,\\ldots,t-1\\}</span> such that <span class="math">\\Delta_r \\geq \\delta^{t-r}/4</span>. By soundness of the proximity test, it follows that <span class="math">(\\mathbf{P}&#x27;,\\mathbf{V}&#x27;)</span>, and hence <span class="math">\\hat{\\mathbf{V}}</span>, will accept with probability at most <span class="math">\\epsilon&#x27;(\\Delta_{\\otimes})</span>.</li>

      <li>Case 2: The proof messages are close to being codewords but the decodings of words <span class="math">c_r^{(s)}</span> from the consistency phase are not consistent across values of <span class="math">r</span>. Formally, for all <span class="math">r \\in \\{0,1,\\ldots,t-1\\}</span> we have <span class="math">\\Delta_r &amp;lt; \\delta_0(\\mathcal{C}^{\\otimes t-r})</span>, but there exists <span class="math">r \\in \\{0,1,\\ldots,t-1\\}</span> and <span class="math">s \\in [\\mathfrak{q}]</span> such that <span class="math">\\mathrm{Fold}_r(\\overline{c}_r^{(s)};q_r^{(s)}) \\neq \\mathrm{Enc}_{r+1}(\\overline{c}_{r+1}^{(s)})</span>.</li>

    </ul>

    <p class="text-gray-300">In this case, the analysis in Case 2 of [BCG20, Lemma 9.6] shows that <span class="math">\\mathrm{Fold}_r(\\overline{c}_r^{(s)};q_r^{(s)})\\neq \\mathrm{Enc}_{r + 1}(\\overline{c}_{r + 1}^{(s)})</span> are at least <span class="math">\\delta^{t - r} - 2\\min \\{\\delta^t /4,\\Delta_\\otimes \\}</span> apart in relative distance, so that the verifier will reject with probability at least this value. This follows from replacing <span class="math">\\delta^{t - r} / 4</span> by <span class="math">\\min \\{\\delta^t /4,\\Delta_\\otimes \\}</span> in the inequalities.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 3: Every message is close to being a codeword, and the decodings of words <span class="math">c_r^{(s)}</span> are all consistent over different values of <span class="math">r</span>. Formally, for all <span class="math">r \\in \\{0, 1, \\ldots, t - 1\\}</span>, we have <span class="math">\\Delta_r &amp;lt; \\delta_0(\\mathcal{C}^{\\otimes t - r})</span> so in particular, for</li>

    </ul>

    <p class="text-gray-300">all <span class="math">r\\in\\{0,1,\\ldots,t-1\\}</span> and <span class="math">s\\in[\\mathfrak{q}]</span>, the closest codewords <span class="math">\\overline{c}_{r}^{(s)}</span> are well-defined. Then, the consistency checks are satisfied by the corrected words <span class="math">\\overline{c}_{r}^{(s)}</span> i.e. for all <span class="math">r\\in\\{0,1,\\ldots,t-1\\}</span> and <span class="math">s\\in[\\mathfrak{q}]</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Fold}_{r}(\\overline{c}_{r}^{(s)};q_{r}^{(s)})=\\mathrm{Enc}_{r+1}(\\overline{c}_{r+1}^{(s)})\\enspace.</span></p>

    <p class="text-gray-300">Decoding the codewords <span class="math">\\overline{c}_{r}^{(s)}</span> for each <span class="math">r\\in\\{0,1,\\ldots,t-1\\}</span> and <span class="math">s\\in[\\mathfrak{q}]</span>, gives functions <span class="math">f_{r+1}^{(s)}</span> consisting of <span class="math">k</span> vectors in <span class="math">\\mathbb{F}^{k^{t-r}}</span> (or <span class="math">\\ell</span> vectors for <span class="math">r=0</span>) satisfying <span class="math">f_{r+1}^{(s)}=\\mathrm{Fold}_{r}(f_{r}^{(s)};q_{r}^{(s)})</span>. This implies that <span class="math">\\mathrm{Fold}_{t}(c_{t}^{(s)};q_{t}^{(s)})</span> is equal to <span class="math">\\langle\\otimes_{i}q_{i}^{(s)},f\\rangle=v^{(s)}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h5 id="sec-104" class="text-base font-semibold mt-4">Efficiency parameters.</h5>

    <p class="text-gray-300">The round complexity of the consistency test is the same as in <em>[x1]</em>, with <span class="math">O(\\mathsf{rc})</span> rounds for the simulation phase and <span class="math">O(t)</span> rounds for the consistency phase, including the proximity test.</p>

    <p class="text-gray-300">The proof messages and queries are identical to those in the consistency test of <em>[x1]</em> but are now measured in terms of two different alphabet sizes. In the consistency test, the prover sends a message array of size <span class="math">\\ell\\cdot k^{t}</span>, parsed over the alphabet <span class="math">\\mathbb{F}^{\\ell}</span>, and <span class="math">O(\\mathfrak{q})</span> messages for each of the array sizes <span class="math">k^{t}</span>, <span class="math">k^{t-1},\\ldots,k</span>, parsed over the alphabet <span class="math">\\mathbb{F}^{k}</span>. Each message array is queried at <span class="math">O(\\lambda)</span> alphabet symbols.</p>

    <p class="text-gray-300">Indexer time is the same as in <em>[x1]</em>. The prover and verifier time are the same except that the random linear combinations used in <em>[x1]</em> are now replaced by the output of proximity generators, which incur extra running time <span class="math">(t-1)\\cdot\\mathsf{o}_{G}+\\mathsf{o}_{G}^{\\prime}</span>.</p>

    <p class="text-gray-300">Contributions to the verifier randomness complexity in <em>[x1]</em> were dominated by various random linear combinations of lengths <span class="math">\\ell k</span> and <span class="math">(\\mathfrak{q}+1)k</span>. In this construction, this contribution is replaced by the seed length of the proximity generators used. The remaining randomness complexity is inherited from the tensor IOP.</p>

    <h3 id="sec-105" class="text-xl font-semibold mt-8">8.3 The proximity generator that we use</h3>

    <p class="text-gray-300">We rely on <em>[x1]</em> to show that a multilinear generator is a proximity generator.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Definition 8.13.</h6>

    <p class="text-gray-300">We say that a function <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{(s/k)^{k}}</span> is a degree-<span class="math">k</span> multilinear generator if for any input <span class="math">\\{x_{j,h}\\}_{j\\in[k],h\\in[s/k]}</span> the function outputs the string <span class="math">\\{y_{h_{1},\\ldots,h_{k}}\\}_{h_{1},\\ldots,h_{k}\\in[s/k]^{k}}</span> where <span class="math">y_{h_{1},\\ldots,h_{k}}=\\prod_{j\\in[k]}x_{j,h_{j}}</span>.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Lemma 8.14 (<em>[x1]</em>).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A degree-<span class="math">k</span> multilinear generator <span class="math">G\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{(s/k)^{k}}</span> is a <span class="math">(\\delta_{0},\\epsilon)</span>-proximity generator where <span class="math">\\delta_{0}(\\mathcal{C},U)=\\delta(U,\\mathcal{C}^{(s/k)^{k}})/2^{k}</span> and $\\epsilon=\\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-108" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove the statement by induction on the degree <span class="math">k</span>.</p>

    <p class="text-gray-300"><em>Base case.</em> When <span class="math">k=1</span>, the generator <span class="math">G</span> simply outputs the uniformly random distribution over <span class="math">\\mathbb{F}^{s}</span>. Then by <em>[x21, Lemma 1.6]</em>, for any <span class="math">\\Delta\\leq\\delta(U,\\mathcal{C}^{(s/k)^{k}})/2</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{w\\leftarrow\\mathbb{F}^{s}}\\left[\\delta(w^{\\intercal}U,\\mathcal{C})\\leq\\Delta\\right]\\leq\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}\\enspace.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Inductive step.</em> Suppose the statement holds for multilinear generators of degree <span class="math">k-1</span>. Then we observe that the degree-<span class="math">k</span> generator <span class="math">G_{k}\\colon\\mathbb{F}^{s}\\to\\mathbb{F}^{(s/k)^{k}}</span> can be constructed from the degree-<span class="math">(k-1)</span> generator <span class="math">G_{k-1}\\colon\\mathbb{F}^{s(1-1/k)}\\to\\mathbb{F}^{(s/k)^{k-1}}</span> as follows. Let <span class="math">x\\in\\mathbb{F}^{s/k}</span> and <span class="math">w\\in\\mathbb{F}^{s(1-1/k)}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$G_{k}(x,w)=x_{1}\\cdot G_{k-1}(w)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{2}\\cdot G_{k-1}(w)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{s/k}\\cdot G_{k-1}(w)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For any matrix <span class="math">U \\in \\mathbb{F}^{(s/k)^k \\times n}</span>, let <span class="math">\\{U_h\\}_{h \\in [s/k]}</span> be the <span class="math">(h-1) \\cdot (s/k)^{k-1} + 1</span>-th to <span class="math">h \\cdot (s/k)^{k-1}</span>-th rows of <span class="math">U</span>, and let <span class="math">u_h</span> be the random variable <span class="math">G_{k-1}(w)^\\top U_h</span> where <span class="math">w \\gets \\mathbb{F}^{s(1-1/k)}</span>. Finally use <span class="math">U_{(k)} \\in \\mathbb{F}^{(s/k) \\times n}</span> to denote the matrix whose <span class="math">h</span>-th row is <span class="math">u_h</span>. Then for any <span class="math">\\Delta \\leq \\delta(U, \\mathcal{C}^{(s/k)^k}) / 2^k</span>, define the event <span class="math">E_k</span> that <span class="math">\\delta(U_{(k)}, \\mathcal{C}^{s/k}) \\geq \\delta(U, \\mathcal{C}^{(s/k)^k}) / 2^{k-1}</span>. We then obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\Pr_{(x, w) \\leftarrow \\mathbb{F}^s} \\left[ \\delta \\left(G_k(x, w)^\\top U, \\mathcal{C}\\right) \\leq \\Delta \\right] \\\\ = \\Pr_{(x, w) \\leftarrow \\mathbb{F}^s} \\left[ \\delta \\left(x^\\top U_{(k)}, \\mathcal{C}\\right) \\leq \\Delta \\right] \\\\ \\leq \\Pr_{w \\leftarrow \\mathbb{F}^s} \\left[ E_k \\right] \\cdot \\Pr_{(x, w) \\leftarrow \\mathbb{F}^s} \\left[ \\delta \\left(x^\\top U_k, \\mathcal{C}\\right) \\leq \\delta \\left(U_{(k)}, \\mathcal{C}^{(s/k)^k}\\right) / 2 \\mid E_k \\right] + \\Pr_{w \\leftarrow \\mathbb{F}^s} \\left[ \\overline{E_k} \\right]. \\end{aligned}</span></div>

    <p class="text-gray-300">Let <span class="math">i^<em></span> be the row in <span class="math">U</span> with the maximum distance to <span class="math">\\mathcal{C}</span>, and <span class="math">U_{h^</em>}</span> be the submatrix that contains row <span class="math">i^*</span>. Then</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{w \\leftarrow \\mathbb{F}^s} \\left[ E_k \\right] \\geq \\Pr_{w \\leftarrow \\mathbb{F}^s} \\left[ \\delta \\left(G_{k-1}(w)^\\top U_{h^*}, \\mathcal{C}\\right) \\geq \\delta (U, \\mathcal{C}^\\ell) / 2^{k-1} \\right] \\geq 1 - \\frac{k-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">The last inequality holds by observing that <span class="math">\\delta(U, \\mathcal{C}^\\ell) = \\delta(U_{h^*}, \\mathcal{C}^{(s/k)^{k-1}})</span> and then applying the inductive hypothesis. Then plugging this bound back to the inequality we obtain that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{(x, w) \\leftarrow \\mathbb{F}^s} \\left[ \\delta \\left(G_k(x, w)^\\top U, \\mathcal{C}\\right) \\leq \\Delta \\right] \\leq \\left(1 - \\frac{k-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}\\right) \\cdot \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} + \\frac{k-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1} \\leq \\frac{k}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Thus we complete the proof.</p>

    <p class="text-gray-300">As a corollary we obtain proximity generators with exponential stretch by setting <span class="math">k = s/2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 8.15. For any positive integer <span class="math">c</span> and any <span class="math">m</span>, there exists a <span class="math">(\\delta_0, \\epsilon)</span>-proximity generator <span class="math">G \\colon \\mathbb{F}^{cm^{1/c}} \\to \\mathbb{F}^m</span>, where <span class="math">\\delta_0(\\mathcal{C}, U) = \\delta(U, \\mathcal{C}^\\ell)/2^c</span> and $\\epsilon = \\frac{c}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- 1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">48</p>

    <p class="text-gray-300">9 Random access machines and precomputation</p>

    <p class="text-gray-300">The definition of a random access machine below captures the usual notion of “word RAM”, and is similar to definitions in <em>[x1, x2]</em>.</p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Definition 9.1.</h6>

    <p class="text-gray-300">A random access machine <span class="math">M=(P,R,w,I)</span> consists of:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">R</span> working registers, each storing a word in <span class="math">\\{0,1\\}^{w}</span> (and initially set to <span class="math">0^{w}</span>);</li>

      <li><span class="math">2^{w}</span> memory registers, each storing a word in <span class="math">\\{0,1\\}^{w}</span> (and initially set to <span class="math">0^{w}</span>);</li>

      <li>a program <span class="math">P</span> applying instructions in <span class="math">I</span> to the working registers;</li>

      <li>a read-only input tape containing a list of words in <span class="math">\\{0,1\\}^{w}</span>; and</li>

      <li>a write-only output tape, containing a list of words in <span class="math">\\{0,1\\}^{w}</span>, with every word initially set to <span class="math">0^{w}</span>.</li>

    </ul>

    <p class="text-gray-300">Instructions in <span class="math">I</span> are functions taking a fixed number of working registers as input and writing the output to a single working register. In addition:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>memory instructions in <span class="math">I</span> allow writing from a working register to a memory register, and vice versa;</li>

      <li>read instructions allow reading a word from the input tape to a working register (and move that tape’s head forward);</li>

      <li>write instructions allow writing a word from a working register to the output tape (and move that tape’s head forward); and</li>

      <li>a special Halt instruction halts the execution of the machine.</li>

    </ul>

    <h6 id="sec-110" class="text-base font-medium mt-4">Definition 9.2.</h6>

    <p class="text-gray-300">The time <span class="math">T</span> of a random access machine is the number of instructions executed by the machine before halting. The space <span class="math">S</span> is the maximum number of non-zero memory registers throughout the execution. The output consists of the contents of the output tape after the machine halts.</p>

    <p class="text-gray-300">We assume that the instruction set <span class="math">I</span> consists of standard RISC instructions (jumps, shifts, bitwise boolean operators, certain integer arithmetic, and so on), all of which take <span class="math">O(1)</span> registers as input.</p>

    <p class="text-gray-300">The lemma below provides a generic way to precompute a specific operation, by computing its evaluation table once and subsequently looking up the desired entries in the table as needed.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Lemma 9.3.</h6>

    <p class="text-gray-300">Let <span class="math">(P_{O},R,w,I)</span> be a machine that evaluates a function <span class="math">O\\colon\\{0,1\\}^{k\\times w_{O}}\\to\\{0,1\\}^{w_{O}}</span> in time <span class="math">T_{O}</span> and space <span class="math">S_{O}</span>. Let <span class="math">M=(P,R,w,I\\cup\\{O\\})</span> be a RAM with word length <span class="math">w\\geq kw_{O}</span> that runs in time <span class="math">T</span> and space <span class="math">S</span>. There exists a machine <span class="math">M^{\\prime}=(P^{\\prime},R,w,I)</span> that produces the same output as <span class="math">M</span> and runs in time <span class="math">T^{\\prime}:=T+2^{kw_{O}}\\cdot T_{O}</span> and space <span class="math">S^{\\prime}:=S+2^{kw_{O}}+S_{O}</span>.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">The program <span class="math">P^{\\prime}</span> uses the program <span class="math">P_{O}</span> to evaluate <span class="math">O</span> at every possible input (of which there are <span class="math">2^{kw_{O}}</span>) and stores the results in memory in a look-up table. This can be done in time <span class="math">2^{kw_{O}}\\cdot T_{O}</span> and space <span class="math">2^{kw_{O}}+S_{O}</span>. The program <span class="math">P^{\\prime}</span> then runs the program <span class="math">P</span> but replaces “<span class="math">O</span>” instructions with memory instructions that read the relevant entries in the stored look-up table. ∎</p>

    <h5 id="sec-113" class="text-base font-semibold mt-4">Precomputation of field operations.</h5>

    <p class="text-gray-300">We define an instruction that realizes field operations, and then apply precomputation to realize operations over an extension field in terms of operations over the base field.</p>

    <p class="text-gray-300">The instruction <span class="math">O_{\\mathbb{F}}</span> defined below can be used to add or multiply elements of the finite field <span class="math">\\mathbb{F}</span>. Note that <span class="math">O_{\\mathbb{F}}</span> can be implemented using standard RISC instructions.</p>

    <h6 id="sec-114" class="text-base font-medium mt-4">Definition 9.4.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be a prime power, <span class="math">b\\in\\mathbb{N}</span>, and <span class="math">\\mathbb{F}</span> a finite field with <span class="math">p^{b}</span> elements. The field operation <span class="math">O_{\\mathbb{F}}</span> is an instruction, compatible with a RAM with word length <span class="math">w\\geq b\\log p</span>, that works as follows.</p>

    <p class="text-gray-300">######</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first, second, and third registers are each parsed as <span class="math">\\lfloor \\frac{w}{b\\log p} \\rfloor</span> “slots”, with each slot containing an element of <span class="math">\\mathbb{F}</span> stored as <span class="math">b</span> elements of <span class="math">\\mathbb{F}_p</span> in some fixed basis.</li>

      <li>The fourth register is parsed as a single bit denoting either addition or multiplication.</li>

      <li>The fifth, sixth, and seventh register are each parsed as three bit-strings of length <span class="math">\\log \\left\\lfloor \\frac{w}{b\\log p} \\right\\rfloor</span>, each addressing a single slot of the first, second, and third registers.</li>

    </ul>

    <p class="text-gray-300">The instruction <span class="math">O_{\\mathbb{F}}</span>: parses the addressed slots of the first and second registers as elements of <span class="math">\\mathbb{F}</span>; adds or multiplies them over <span class="math">\\mathbb{F}</span> according to the bit in the fourth register; and writes the result to the addressed slot in the third register.</p>

    <p class="text-gray-300">We use precomputation (Lemma 9.3) to replace applications of <span class="math">O_{\\mathbb{F}_{p^b}}</span> with applications of <span class="math">O_{\\mathbb{F}_p}</span>.</p>

    <p class="text-gray-300">Lemma 9.5. Let <span class="math">M = (P, R, w, I \\cup \\{O_{\\mathbb{F}_{p^b}}\\})</span> be a RAM with word length <span class="math">w \\geq 2b \\log p</span> that runs in time <span class="math">T</span> and space <span class="math">S</span>. There is a RAM <span class="math">M&#x27; = (P&#x27;, R, w, I \\cup \\{O_{\\mathbb{F}_p}\\})</span> that runs in time <span class="math">T + O(b^2 \\cdot p^{2b})</span> and space <span class="math">S + O(p^{2b})</span>.</p>

    <p class="text-gray-300">Proof. We discuss how to realize additions and then multiplications.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Addition. An addition over <span class="math">\\mathbb{F}_{p^b}</span> is straightforwardly realized via <span class="math">b</span> additions over <span class="math">\\mathbb{F}_p</span> (no precomputed lookup table is needed), since elements of <span class="math">\\mathbb{F}_{p^b}</span> are stored in a basis representation over <span class="math">\\mathbb{F}_p</span> for <span class="math">O_{\\mathbb{F}_p}</span>.</li>

      <li>Multiplication. We apply Lemma 9.3. The multiplication lookup table for <span class="math">\\mathbb{F}_{p^b}</span> has size <span class="math">p^{2b}</span>. The cost of changing the basis representation of an element of <span class="math">\\mathbb{F}_{p^b}</span> into the standard basis over <span class="math">\\mathbb{F}_p</span> is <span class="math">O(b^2)</span> operations in <span class="math">\\mathbb{F}_p</span> (using a stored change-of-basis matrix in <span class="math">\\mathbb{F}_p^{b\\times b}</span>). Then, the cost of multiplying two elements of <span class="math">\\mathbb{F}_{p^b}</span> in the standard basis over <span class="math">\\mathbb{F}_p</span> is <span class="math">O(b^2)</span> operations using a schoolbook multiplication algorithm. Finally, converting the resulting <span class="math">\\mathbb{F}_{p^b}</span> element back into the desired basis over <span class="math">\\mathbb{F}_p</span> costs <span class="math">O(b^2)</span> multiplications, again using a stored change-of-basis matrix.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">50</p>

    <p class="text-gray-300">10 Proof of main theorems</p>

    <p class="text-gray-300">In this section, we explain how to construct linear-time point-query IOPs for R1CS and for automata computations over any finite field.</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Theorem 10.1 (main).</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, there is a public-coin IOP (with point queries) for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with <span class="math">N\\times N</span> matrices, each containing <span class="math">M=\\Omega(N)</span> non-zero entries, that has the following efficiency parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log N)</span>;</li>

      <li>answer alphabet is <span class="math">\\mathbb{F}_{p}</span>;</li>

      <li>proof length is <span class="math">O(M+N)</span>;</li>

      <li>query complexity is <span class="math">O(\\log^{2}N/\\log p)</span>;</li>

      <li>the prover is a RAM with word length <span class="math">w=\\Theta(\\log N)</span>, <span class="math">R=O(1)</span> registers that runs in <span class="math">O(M+N)</span> time and <span class="math">O(N)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">w=\\Theta(\\log N)</span>, <span class="math">R=O(1)</span> registers that runs in <span class="math">O(M+N)</span> time and <span class="math">O(N)</span> space.</li>

    </ul>

    <h6 id="sec-116" class="text-base font-medium mt-4">Theorem 10.2 (main).</h6>

    <p class="text-gray-300">For every prime power <span class="math">p</span>, and constant <span class="math">t\\in\\mathbb{N}</span>, there is a public-coin IOP (with point queries) for the indexed automata relation <span class="math">R_{\\mathrm{R1CSA}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with computation width <span class="math">w</span> and computation time <span class="math">T</span>, that has the following efficiency parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>soundness error is <span class="math">O(1)</span>;</li>

      <li>round complexity is <span class="math">O(\\log(wT))</span>;</li>

      <li>answer alphabet is <span class="math">\\mathbb{F}_{p}</span>;</li>

      <li>proof length is <span class="math">O(wT)</span>;</li>

      <li>query complexity is <span class="math">O(\\log^{2}(wT)/\\log p)</span>;</li>

      <li>the prover is a RAM with word length <span class="math">w=\\Theta(\\log wT)</span>, <span class="math">R=O(1)</span> registers that runs in <span class="math">O(w^{2}T)</span> time and <span class="math">O(w^{2}T)</span> space;</li>

      <li>the verifier is a RAM with word length <span class="math">w=\\Theta(\\log N)</span>, <span class="math">R=O(1)</span> registers that runs in <span class="math">O((wT)^{1/t})</span> time and <span class="math">O((wT)^{1/t})</span> space.</li>

    </ul>

    <p class="text-gray-300">We obtain these IOPs over <span class="math">\\mathbb{F}_{p}</span> in four steps. Initially, we construct all protocols over an extension field <span class="math">\\mathbb{F}_{p^{b}}</span> of <span class="math">\\mathbb{F}_{p}</span>. In Section 10.1, we construct a robust IOPP for checking consistency between encoded proof messages and answers to tensor queries. In Section 10.2 we use proof composition to improve the query complexity of the IOPP. In Section 10.3, we use the IOPP to compile the tensor-query IOPs for <span class="math">R_{\\mathrm{R1CS}}</span> (Theorem 6.2) and <span class="math">R_{\\mathrm{R1CSA}}</span> (Theorem 7.2) into point-query IOPs over <span class="math">\\mathbb{F}_{p^{b}}</span>. In Section 10.4, we use the preprocessing techniques of Section 9 to convert them into point-query IOPs over <span class="math">\\mathbb{F}_{p}</span>. The first three steps in the proof are direct adaptations of results in <em>[x1]</em>, so we provide proof sketches (and more details can be found in <em>[x1]</em>).</p>

    <h3 id="sec-117" class="text-xl font-semibold mt-8">10.1 Step 1: robustification</h3>

    <h6 id="sec-118" class="text-base font-medium mt-4">Corollary 10.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{C}\\colon\\mathbb{F}^{k}\\to\\mathbb{F}^{O(k)}</span> be a linear code with constant rate, constant relative distance, and linear-time encoding, membership-deciding, and (error-free) decoding. For every <span class="math">c\\in\\mathbb{N}</span> the relation <span class="math">R_{\\mathrm{cons}}</span> has a non-adaptive point-query IOPP <span class="math">(\\mathbf{P}_{\\mathrm{r}},(\\mathbf{V}_{\\mathrm{q}_{\\mathrm{r}}},\\mathbf{V}_{\\mathrm{d}_{\\mathrm{r}}}))</span> with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(t/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)<span class="math"> with robustness </span>\\Theta(1/(\\ell+t))$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">round complexity <span class="math">O(t)</span>;</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet <span class="math">\\mathbb{F}</span>;</li>

      <li>proof length <span class="math">O(\\mathfrak{q}\\cdot\\ell k^{t})</span>;</li>

      <li>query complexity <span class="math">O(\\mathfrak{q}k\\cdot(\\ell+t))</span>;</li>

      <li>prover time <span class="math">O(\\mathfrak{q}\\cdot t\\ell k^{t})</span>;</li>

      <li>verifier time <span class="math">O(\\mathfrak{q}k\\cdot(\\ell+t))</span>;</li>

      <li>verifier randomness complexity <span class="math">O(\\mathfrak{q}k^{1/c}(\\ell^{1/c}+t))</span>;</li>

      <li><span class="math">\\mathbf{V}_{\\mathrm{dr}}</span> time <span class="math">O(\\mathfrak{q}k\\cdot(\\ell+t))</span>.</li>

    </ul>

    <p class="text-gray-300">The notion of robustness is explained in <em>[x1, Definition 3.7]</em>.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">The proof of Corollary 10.3 uses Lemma 8.4 to construct an IOPP for the new relation <span class="math">R^{\\prime}_{\\mathrm{cons}}</span>, before converting this into a robust IOPP for <span class="math">R_{\\mathrm{cons}}</span>.</p>

    <h6 id="sec-120" class="text-base font-medium mt-4">Definition 10.4.</h6>

    <p class="text-gray-300">The indexed relation <span class="math">R^{\\prime}_{\\mathrm{cons}}</span> is the set of tuples</p>

    <p class="text-gray-300"><span class="math">(\\dot{\\mathfrak{s}},\\mathbf{x},\\mathbf{w})=\\Big{(}\\bot,(\\mathbb{F},\\mathcal{C},\\ell,\\mathfrak{q},t,\\{q^{(s)}\\}_{s},\\{v_{s}\\}_{s}),c\\Big{)}</span></p>

    <p class="text-gray-300">such that <span class="math">c=\\mathrm{Enc}_{\\mathcal{C}^{\\otimes(t-1)}}(f)\\in\\mathbb{F}^{\\ell k\\cdot n^{t-1}}</span> for some <span class="math">f\\in\\mathbb{F}^{\\ell\\cdot k^{t}}</span>, for each <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">q^{(s)}=(q^{(s)}_{0},\\ldots,q^{(s)}_{t})\\in\\mathbb{F}^{\\ell}\\times\\left(\\mathbb{F}^{k}\\right)^{t}</span>, and for all <span class="math">s\\in[\\mathfrak{q}]</span>, <span class="math">\\langle q^{(s)},f\\rangle=v^{(s)}</span>.</p>

    <p class="text-gray-300">First, instantiate the IOPP for <span class="math">R_{\\mathrm{cons}}</span> in Lemma 8.4 using the proximity generator from Corollary 8.15, but parsing the message <span class="math">f^{(0)}_{0}</span> as a <span class="math">t</span>-dimensional array of size <span class="math">\\ell k\\cdot k^{t-1}</span> rather than a <span class="math">(t+1)</span>-dimensional array of size <span class="math">\\ell\\cdot k^{t}</span>. The first components <span class="math">q^{(s)}_{0}\\in\\mathbb{F}^{\\ell}</span> and <span class="math">q^{(s)}_{1}\\in\\mathbb{F}^{k}</span> of each tensor query are grouped together as a single component <span class="math">q^{(s)}_{0}\\otimes q^{(s)}_{1}\\in\\mathbb{F}^{\\ell k}</span>, and the first “folding” step applies <span class="math">q^{(s)}_{0}\\otimes q^{(s)}_{1}</span> to <span class="math">f^{(0)}_{0}</span>. In Lemma 8.4, set the constant <span class="math">\\kappa=2^{c}</span>. Use the proximity generators from Corollary 8.15 with seed lengths <span class="math">ck^{1/c}</span> and <span class="math">c(\\ell k)^{1/c}</span>. This gives an IOPP for <span class="math">R^{\\prime}_{\\mathrm{cons}}</span> with the stated soundness error and verifier randomness complexity.</p>

    <p class="text-gray-300">Robustify this IOPP (using the transformation in <em>[x1, Lemma A.1]</em>) by encoding each witness symbol and each proof symbol using the error-correcting code <span class="math">\\mathcal{C}</span>. In Lemma 8.4, the witness has alphabet <span class="math">\\mathbb{F}^{\\ell k}</span>, and will be encoded in <span class="math">\\ell</span> parts by applying <span class="math">\\mathcal{C}</span> to blocks of length <span class="math">k</span>. This converts a witness for the relation <span class="math">R^{\\prime}_{\\mathrm{cons}}</span> into a witness for the relation <span class="math">R_{\\mathrm{cons}}</span>. Thus the new witness can be viewed as <span class="math">\\ell</span> codewords in <span class="math">\\mathcal{C}^{\\otimes t}</span>, or equivalently <span class="math">O(\\ell k)</span> codewords in <span class="math">\\mathcal{C}^{\\otimes(t-1)}</span>. Proof elements have alphabet <span class="math">\\mathbb{F}^{k}</span> and will be encoded using <span class="math">\\mathcal{C}</span>.</p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-121" class="text-xl font-semibold mt-8">10.2 Step 2: composition</h3>

    <h6 id="sec-122" class="text-base font-medium mt-4">Lemma 10.5 (<em>[x28, x35]</em>).</h6>

    <p class="text-gray-300">Fix functions <span class="math">T(n)=\\Omega(n)</span>, <span class="math">\\delta(n)&gt;0</span>, and <span class="math">\\epsilon(n)&gt;0</span>. Every relation <span class="math">R</span> in <span class="math">\\mathsf{NTIME}(T)</span> has a PCPP for <span class="math">R</span> with: answer alphabet <span class="math">\\{0,1\\}</span>; proof length <span class="math">T(n)\\cdot\\mathsf{polylog}(T(n))</span>; query complexity <span class="math">O(\\log(1/\\epsilon(n))\\cdot\\log(1/\\delta(n))/\\delta(n))</span>; soundness error <span class="math">\\epsilon(n)</span> with proximity parameter <span class="math">\\delta(n)</span>; prover time <span class="math">\\mathsf{poly}(T(n))</span>; verifier time <span class="math">\\mathsf{poly}(n,\\log T(n))</span>.</p>

    <h6 id="sec-123" class="text-base font-medium mt-4">Lemma 10.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\epsilon\\in(0,1)</span> be any constant. For instances of <span class="math">R_{\\mathrm{cons}}</span> in which each query <span class="math">q^{(s)}</span> is described using a seed of length at most <span class="math">O(t\\cdot k)</span>, there is a point-query IOPP <span class="math">(\\mathbf{P},\\mathbf{V})</span> for <span class="math">R_{\\mathrm{cons}}</span> with:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $O(t/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)+\\epsilon<span class="math"> with proximity parameter </span>\\Theta(1/t)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">O(t)</span>;</li>

      <li>answer alphabet <span class="math">\\mathbb{F}</span>;</li>

      <li>proof length <span class="math">O(\\mathfrak{q}\\cdot\\ell k^{t})</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>query complexity <span class="math">O_{\\epsilon}(t \\log t)</span>;</li>

      <li>prover time <span class="math">\\poly(\\mathfrak{q}k \\cdot (\\ell + t))</span> operations in <span class="math">\\mathbb{F}</span>;</li>

      <li>verifier time <span class="math">\\poly(\\mathfrak{q}k \\cdot (\\ell + t))</span> operations in <span class="math">\\mathbb{F}</span>.</li>

    </ul>

    <p class="text-gray-300">Proof sketch. Apply proof composition (using the transformation in [BCL22, Lemma B.1]) to the robust outer IOP provided by Corollary 10.3 with a properly chosen parameter <span class="math">c</span> and the inner IOP of proximity provided by Lemma 10.5.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The inner relation <span class="math">R(\\mathbf{V}_{\\mathrm{dr}})</span> has instance <span class="math">(\\Xi, r) := (\\mathbb{F}, \\mathcal{C}, \\ell, \\mathfrak{q}, t, \\{q^{(s)}\\}_s, \\{v_s\\}_s, r)</span>, where <span class="math">r</span> has size <span class="math">O(\\mathfrak{q} \\cdot k^{1/c} (\\ell^{1/c} + t))</span>, and by assumption, the query set has a description of size <span class="math">O(\\mathfrak{q} \\cdot t \\log k)</span>. This means that the instance size is <span class="math">O(\\mathfrak{q} \\cdot t \\log k)</span>. The witness size of <span class="math">R(\\mathbf{V}_{\\mathrm{dr}})</span> is equal to the query complexity of the robust outer IOP and has size <span class="math">O(\\mathfrak{q}k \\cdot (\\ell + t))</span>. The outer verifier's decision time is $T(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) = O(\\mathfrak{q}k \\cdot (\\ell + t))<span class="math">. Choosing a </span>c$ large enough and substituting these values into Lemma 10.5 gives the proof length, prover time and verifier time written in the theorem.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The round complexity <span class="math">O(t)</span> is inherited from the robust outer IOPP, while the query complexity <span class="math">O_{\\epsilon}(t \\log t)</span> is obtained from the applying Lemma 10.5 with the proximity parameter <span class="math">\\delta = \\Theta(1/t)</span>.</p>

    <h2 id="sec-124" class="text-2xl font-bold">10.3 Step 3: tensor queries to point queries</h2>

    <p class="text-gray-300">We restate [BCL22, Lemma 8.2], removing details related to zero-knowledge and error-correcting codes.</p>

    <p class="text-gray-300"><strong>Lemma 10.7</strong> ([BCL22, Lemma 8.2, restated]). There exists an explicit polynomial-time transformation <span class="math">T</span> that satisfies the following. The inputs to the transformation are as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A <span class="math">t</span>-linear tensor code <span class="math">\\mathcal{C}^{\\otimes t}</span> over <span class="math">\\mathbb{F}</span> with encoding function <span class="math">\\mathrm{Enc}_{\\mathcal{C}^{\\otimes t}}</span>, with rate <span class="math">\\rho = \\frac{k^t}{n^t}</span>, relative distance <span class="math">\\delta = \\frac{d^t}{n^t}</span>, encoding arithmetic complexity <span class="math">\\Psi(k) \\cdot k^t</span>.</li>

      <li>An interactive oracle proof <span class="math">\\mathsf{IOP} = (\\mathbf{P},\\mathbf{V})</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{tensor}}(\\mathbb{F},k,t)</span> for an indexed relation <span class="math">R</span> with: soundness error <span class="math">\\epsilon</span>; round complexity <span class="math">\\mathsf{rc}</span>; proof length <span class="math">\\mathsf{l} = \\mathsf{li} + \\mathsf{lp} = \\ell k^t</span>; query complexity <span class="math">\\mathfrak{q}</span>; arithmetic complexity <span class="math">\\mathsf{ti}</span> for the indexer; arithmetic complexity <span class="math">\\mathsf{tp}</span> for the prover; arithmetic complexity <span class="math">\\mathsf{tv}</span> for the verifier.</li>

      <li>An interactive oracle proof of proximity <span class="math">\\mathsf{IOPP} = (\\mathbf{P}&#x27;,\\mathbf{V}&#x27;)</span> with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> for the indexed relation <span class="math">R_{\\mathrm{com}}(\\mathbb{F},\\mathcal{C},\\ell ,\\mathfrak{q},t)</span> with soundness error <span class="math">\\epsilon&#x27;</span>; round complexity <span class="math">\\mathsf{rc}&#x27;</span>; proof length <span class="math">\\mathsf{l}&#x27;</span>; input query complexity <span class="math">\\mathfrak{q}_{\\pi}&#x27;</span>, the number of verifier queries to the input oracle; proof query complexity <span class="math">\\mathfrak{q}_{\\pi}&#x27;</span>, the number of verifier queries to the IOPP proof oracles; arithmetic complexity <span class="math">\\mathsf{tp}&#x27;</span> for the prover; arithmetic complexity <span class="math">\\mathsf{tv}&#x27;</span> for the verifier.</li>

    </ul>

    <p class="text-gray-300">The output of the transformation <span class="math">(\\hat{\\mathbf{I}},\\hat{\\mathbf{P}},\\hat{\\mathbf{V}}):= T(\\mathcal{C},\\mathsf{IOP},\\mathsf{IOPP})</span> is an interactive oracle proof with queries in <span class="math">\\mathcal{Q}_{\\mathrm{point}}</span> for the indexed relation <span class="math">R</span> with the following parameters:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error $\\max(\\epsilon, (1 - 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)\\epsilon'(1/4) + 1/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity <span class="math">\\mathsf{rc} + \\mathsf{rc}&#x27; + 1</span>;</li>

      <li>proof length <span class="math">O\\left(\\frac{n^t}{k^t} \\cdot \\mathsf{l}\\right) + \\mathsf{l}&#x27;</span>;</li>

      <li>query complexity <span class="math">2\\mathfrak{q}_{\\pi}&#x27; + \\mathfrak{q}_{\\pi}&#x27;</span>, where <span class="math">2\\mathfrak{q}_{\\pi}&#x27;</span> queries are to the IOP proof oracles, and <span class="math">\\mathfrak{q}_{\\pi}&#x27;</span> queries are to the IOPP proof oracles;</li>

      <li>indexer time <span class="math">\\mathsf{ti} + \\mathsf{ti}&#x27;</span>;</li>

      <li>prover time <span class="math">\\mathsf{tp} + \\mathsf{tp}&#x27;</span>; and</li>

      <li>verifier time <span class="math">\\mathsf{tv} + \\mathsf{tv}&#x27;</span>.</li>

    </ul>

    <p class="text-gray-300">53</p>

    <h6 id="sec-125" class="text-base font-medium mt-4">Lemma 10.8.</h6>

    <p class="text-gray-300">There is a constant <span class="math">\\eta</span> such that, for every prime power <span class="math">p</span>, and every <span class="math">a\\in\\Omega(\\log\\log N)</span>, there is a point-query IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{R1CS}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with <span class="math">N=a\\cdot k^{t}</span> and <span class="math">M=a\\cdot\\ell\\cdot k^{t}</span> and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet is <span class="math">\\mathbb{F}:=\\mathbb{F}_{p^{\\eta a}}</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O(t/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)+\\epsilon$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(t+\\log(N/a))</span>;</li>

      <li>proof length is <span class="math">O(N/a)</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity <span class="math">O_{\\epsilon}(t\\log t)</span>;</li>

      <li>the prover sends <span class="math">O(\\log(N/a))</span> non-oracle messages over <span class="math">\\mathbb{F}</span>;</li>

      <li>the prover uses <span class="math">O(M+N)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tN/a)+\\mathsf{poly}(\\mathsf{q}k\\cdot(\\ell+t))</span> <span class="math">\\mathbb{F}</span>-operations</li>

      <li>the verifier uses <span class="math">O(M+N)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tk)+\\mathsf{poly}(\\mathsf{q}k\\cdot(\\ell+t))</span> <span class="math">\\mathbb{F}</span>-operations.</li>

    </ul>

    <h6 id="sec-126" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">Set <span class="math">N=a\\cdot k^{t}</span> and <span class="math">M=a\\cdot\\ell\\cdot k^{t}</span> for some <span class="math">k,t\\in\\mathbb{N}</span>. Theorem 6.2 gives a <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP for <span class="math">R_{\\mathrm{R1CS}}</span> over <span class="math">\\mathbb{F}_{p}</span>, which has query complexity <span class="math">\\mathsf{q}=O(1)</span>, and for which each query can be described by a short seed of size <span class="math">O(tk)</span>. Applying Lemma 10.7 with Theorem 6.2 as the input tensor IOP, Lemma 10.6 as the input proximity test, using Spielman codes over <span class="math">\\mathbb{F}</span> (for which <span class="math">\\delta,\\Psi</span> and <span class="math">\\rho</span> are all constant) yields the desired complexity parameters. ∎</p>

    <h6 id="sec-127" class="text-base font-medium mt-4">Lemma 10.9.</h6>

    <p class="text-gray-300">There is a constant <span class="math">\\eta</span> such that, for every prime power <span class="math">p</span>, and every <span class="math">a\\in\\Omega(\\log\\log wT)</span>, there is a point-query IOP, with non-adaptive queries, for the indexed relation <span class="math">R_{\\mathrm{R1CSA}}</span> that supports instances over <span class="math">\\mathbb{F}_{p}</span> with <span class="math">w(T+1)=a\\cdot k^{t}</span> and has the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>answer alphabet is <span class="math">\\mathbb{F}:=\\mathbb{F}_{p^{\\eta a}}</span>;</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- soundness error is $O(t/\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)+O(1)+\\epsilon$;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>round complexity is <span class="math">O(t+\\log(wT/a))</span>;</li>

      <li>proof length is <span class="math">O(wT/a)</span> elements in <span class="math">\\mathbb{F}</span>;</li>

      <li>query complexity <span class="math">O_{\\epsilon}(t\\log t)</span>;</li>

      <li>the prover sends <span class="math">O(\\log(wT/a))</span> non-oracle messages over <span class="math">\\mathbb{F}</span>;</li>

      <li>the prover uses <span class="math">O(w^{2}T)</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(twT/a)+\\mathsf{poly}(\\mathsf{q}k\\cdot(\\ell+t))</span> <span class="math">\\mathbb{F}</span>-operations</li>

      <li>the verifier uses <span class="math">O(a^{3})+O(t(wT)^{1/t})+\\mathsf{poly}(\\mathsf{q}k\\cdot(\\ell+t))</span> <span class="math">\\mathbb{F}_{p}</span>-operations and <span class="math">O(tk)</span> <span class="math">\\mathbb{F}</span>-operations.</li>

    </ul>

    <h6 id="sec-128" class="text-base font-medium mt-4">Proof sketch.</h6>

    <p class="text-gray-300">Set <span class="math">w(T+1)=a\\cdot k^{t}</span> for some <span class="math">k,t\\in\\mathbb{N}</span>. Theorem 7.2 gives a <span class="math">(\\mathbb{F},k,t)</span>-tensor IOP for <span class="math">R_{\\mathrm{R1CSA}}</span> over <span class="math">\\mathbb{F}_{p}</span>, which has query complexity <span class="math">\\mathsf{q}=O(1)</span>, and for which each query can be described by a short seed of size <span class="math">O(tk)</span>. Applying Lemma 10.7 with Theorem 7.2 as the input tensor IOP, Lemma 10.6 as the input proximity test, using Spielman codes over <span class="math">\\mathbb{F}</span> (for which <span class="math">\\delta,\\Psi</span> and <span class="math">\\rho</span> are all constant) yields the desired complexity parameters. Since <span class="math">\\lambda=O(1)</span>, all <span class="math">\\mathbb{F}_{p^{\\lambda}}</span> operations in Theorem 7.2 are counted as <span class="math">O(1)</span> <span class="math">\\mathbb{F}_{p}</span> operations. ∎</p>

    <h3 id="sec-129" class="text-xl font-semibold mt-8">10.4 Step 4: Precomputing expensive operations</h3>

    <p class="text-gray-300">We complete the proofs of Theorem 10.1 and Theorem 10.2 by applying Lemma 9.5 to Lemma 10.8 and Lemma 10.9 in order to precompute expensive operations over <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Precomputing for Theorem 10.1. We justify each parameter of Theorem 10.1 in turn. Set the output parameter for the RMFE to be <span class="math">a:=\\frac{1}{2\\eta}\\log_{p}N-\\frac{1}{\\eta}\\log_{p}\\log_{p}N</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The answer alphabet <span class="math">\\mathbb{F}</span> from Lemma 10.8 becomes <span class="math">\\mathbb{F}_{p}</span>, simply by parsing each element of <span class="math">\\mathbb{F}=\\mathbb{F}_{p^{\\eta a}}</span> as a vector of <span class="math">\\eta a</span> elements of <span class="math">\\mathbb{F}_{p}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The soundness error becomes <span class="math">O(t/p^{\\eta a}) + O(1) + \\epsilon</span>. Since <span class="math">a \\in \\Omega(\\log \\log N)</span>, and <span class="math">\\epsilon</span> can be an arbitrarily small constant in <span class="math">(0, 1)</span>, the soundness error is <span class="math">O(1)</span>.</li>

      <li>The round complexity is <span class="math">O(t + \\log (N / a))</span> which is <span class="math">O(\\log N)</span>.</li>

      <li>The proof length becomes <span class="math">O(N)</span> elements in <span class="math">\\mathbb{F}_p</span>, by parsing each element of <span class="math">\\mathbb{F} = \\mathbb{F}_{p^{\\eta a}}</span> as a vector of <span class="math">\\eta a</span> elements of <span class="math">\\mathbb{F}_p</span> as before.</li>

      <li>The query complexity becomes <span class="math">O_{\\epsilon}(t\\eta a \\log t)</span> elements of <span class="math">\\mathbb{F}_p</span>.</li>

      <li>The prover sends <span class="math">O(\\eta a \\log (N / a))</span> non-oracle messages over <span class="math">\\mathbb{F}_p</span>.</li>

      <li>Consider the prover as a RAM with word length <span class="math">w = \\Theta (\\log N)</span>, which is sufficient to model calculations over <span class="math">\\mathbb{F}_p</span> and <span class="math">\\mathbb{F}_{p^{\\eta a}}</span>. The prover uses <span class="math">O(M + N)</span> <span class="math">\\mathbb{F}_p</span>-operations from <span class="math">\\mathbb{F}_p</span> operations in Lemma 10.8, and <span class="math">O(tN) + a\\cdot \\mathrm{poly}(\\mathfrak{q}k\\cdot (\\ell +t))</span> <span class="math">\\mathbb{F}_p</span>-operations from looking up the results of <span class="math">\\mathbb{F}</span> operations in Lemma 10.8. In addition, the prover incurs an extra cost of <span class="math">O(a^{2}p^{2\\eta a})</span> operations in <span class="math">\\mathbb{F}_p</span> for precomputing the multiplication table of <span class="math">\\mathbb{F}</span>. By choice of <span class="math">\\eta</span>, this requires <span class="math">O(N)</span> operations and <span class="math">O(N)</span> memory.</li>

      <li>Consider the verifier as a RAM with word length <span class="math">w = \\Theta (\\log N)</span>, which is sufficient to model calculations over <span class="math">\\mathbb{F}_p</span> and <span class="math">\\mathbb{F}_{p^{\\eta a}}</span>. The verifier uses <span class="math">O(M + N)</span> <span class="math">\\mathbb{F}_p</span>-operations from <span class="math">\\mathbb{F}_p</span> operations in Lemma 10.8, and <span class="math">O(tka) + \\eta a\\cdot \\mathrm{poly}(\\mathfrak{q}k\\cdot (\\ell +t))</span> <span class="math">\\mathbb{F}_p</span>-operations from looking up the results of <span class="math">\\mathbb{F}</span> operations in Lemma 10.8. In addition, the verifier incurs an extra cost of <span class="math">O(a^{2}p^{2\\eta a})</span> operations in <span class="math">\\mathbb{F}_p</span> for precomputing the multiplication table of <span class="math">\\mathbb{F}</span>. As before, this requires <span class="math">O(N)</span> operations and <span class="math">O(N)</span> memory.</li>

    </ul>

    <p class="text-gray-300"><strong>Precomputation for Theorem 10.2.</strong> Setting <span class="math">a \\coloneqq \\frac{1}{2\\eta} \\log_p wT - \\frac{1}{\\eta} \\log_p \\log_p wT</span> as in Theorem 10.1, the answer alphabet, soundness error, round complexity, proof length, query complexity, number of non-oracle messages and prover complexity in Theorem 10.2 follow similarly to Theorem 10.1.</p>

    <p class="text-gray-300">We justify the verifier complexity. Consider the verifier as a RAM with word length <span class="math">w = \\Theta (\\log N)</span>, which is sufficient to model calculations over <span class="math">\\mathbb{F}_p</span> and <span class="math">\\mathbb{F}_{p^{\\eta a}}</span>. The verifier uses <span class="math">O(a^{3}) + O(t(wT)^{1 / t}) + \\mathrm{poly}(\\mathfrak{q}k\\cdot (\\ell +t))</span> <span class="math">\\mathbb{F}_p</span>-operations and <span class="math">O(tk)</span> <span class="math">\\mathbb{F}</span>-operations in Lemma 10.9. Since the verifier for Lemma 10.9 uses only a sublinear number of operations, there is no need for the verifier to precompute the multiplication table of <span class="math">\\mathbb{F}</span>. As such, the verifier simply uses <span class="math">O(a^{3}) + O(t(wT)^{1 / t}) + O(tk)\\cdot \\mathrm{polylog}(tk) + \\mathrm{poly}(\\mathfrak{q}k\\cdot (\\ell +t))</span> time and memory, where the <span class="math">O(tk)\\cdot \\mathrm{polylog}(tk)</span> cost comes from using multiplication algorithms such as the Schonhage-Strassen algorithm to compute <span class="math">O(tk)</span> <span class="math">\\mathbb{F}</span>-operations using operations in <span class="math">\\mathbb{F}_p</span>. Taking Lemma 10.9 with a larger value of <span class="math">t</span> than given in Theorem 10.2, we can subsume this polylogarithmic factor inside the <span class="math">O(t(wT)^{1 / t})</span> term, which yields the result.</p>

    <p class="text-gray-300">55</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Noga Ron-Zewi and Ron Rothblum for their detailed comments which helped us to improve the paper. This research was supported in part by: the Berkeley Haas Blockchain Initiative and a donation from the Ethereum Foundation.</p>

    <h2 id="sec-130" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AFKL19] Peyman Afshani, Casper Benjamin Freksen, Lior Kamma, and Kasper Green Larsen. “Lower Bounds for Multiplication via Network Coding”. In: (2019). URL: http://arxiv.org/abs/1902.10935.</li>

      <li>[AHIKV17] Benny Applebaum, Naama Haramaty, Yuval Ishai, Eyal Kushilevitz, and Vinod Vaikuntanathan. “Low-Complexity Cryptographic Hash Functions”. In: Proceedings of the 8th Innovations in Theoretical Computer Science Conference. ITCS ’17. 2017, 7:1–7:31.</li>

      <li>[AHIV17] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. “Ligero: Lightweight Sublinear Arguments Without a Trusted Setup”. In: Proceedings of the 24th ACM Conference on Computer and Communications Security. CCS ’17. 2017, pp. 2087–2104.</li>

      <li>[AV77] Dana Angluin and Leslie G. Valiant. “Fast probabilistic algorithms for hamiltonian circuits and matchings”. In: Proceedings on 9th Annual ACM Symposium on Theory of Computing. STOC ’77. 1977, pp. 30–41.</li>

      <li>[BBHR18] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. “Fast Reed–Solomon Interactive Oracle Proofs of Proximity”. In: Proceedings of the 45th International Colloquium on Automata, Languages and Programming. ICALP ’18. 2018, 14:1–14:17.</li>

      <li>[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. “Linear-Time Arguments with Sublinear Verification from Tensor Codes”. In: Proceedings of the 18th Theory of Cryptography Conference. TCC ’20. 2020, pp. 19–46.</li>

      <li>[BCGGHJ17] Jonathan Bootle, Andrea Cerulli, Essam Ghadafi, Jens Groth, Mohammad Hajiabadi, and Sune K. Jakobsen. “Linear-Time Zero-Knowledge Proofs for Arithmetic Circuit Satisfiability”. In: Proceedings of the 23rd International Conference on the Theory and Applications of Cryptology and Information Security. ASIACRYPT ’17. 2017, pp. 336–365.</li>

      <li>[BCGGRS19] Eli Ben-Sasson, Alessandro Chiesa, Lior Goldberg, Tom Gur, Michael Riabzev, and Nicholas Spooner. “Linear-Size Constant-Query IOPs for Delegating Computation”. In: Proceedings of the 17th Theory of Cryptography Conference. TCC ’19. 2019, pp. 494–521.</li>

      <li>[BCGRS17] Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas Spooner. “Interactive Oracle Proofs with Constant Rate and Query Complexity”. In: Proceedings of the 44th International Colloquium on Automata, Languages and Programming. ICALP ’17. 2017, 40:1–40:15.</li>

      <li>[BCHO22] Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orrù. “Gemini: Elastic SNARKs for Diverse Environments”. In: Proceedings of the 41st Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’22. 2022, pp. 427–457.</li>

      <li>[BCL22] Jonathan Bootle, Alessandro Chiesa, and Siqi Liu. “Zero-Knowledge Succinct Arguments with a Linear-Time Prover”. In: Proceedings of the 42nd Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’22. 2022.</li>

      <li>[BCRSVW19] Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. “Aurora: Transparent Succinct Arguments for R1CS”. In: Proceedings of the 38th Annual International Conference on the Theory and Applications of Cryptographic Techniques. EUROCRYPT ’19. 2019, pp. 103–128.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. “Interactive Oracle Proofs”. In: Proceedings of the 14th Theory of Cryptography Conference. TCC ’16-B. 2016, pp. 31–60.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BMRS21] Carsten Baum, Alex J Malozemoff, Marc B Rosen, and Peter Scholl. “Mac’n’Cheese: Zero-Knowledge Proofs for Boolean and Arithmetic Circuits with Nested Disjunctions”. In: Proceedings of the 41st Annual International Cryptology Conference. CRYPTO ’21. 2021, pp. 92–122.</li>

      <li>[CCXY18] Ignacio Cascudo, Ronald Cramer, Chaoping Xing, and Chen Yuan. “Amortized Complexity of Information-Theoretically Secure MPC Revisited”. In: Proceedings of the 38th Annual International Cryptology Conference. CRYPTO ’18. 2018, pp. 395–426.</li>

      <li>[CG21] Ignacio Cascudo and Emanuele Giunta. On Interactive Oracle Proofs for Boolean R1CS Statements. IACR Cryptology ePrint Archive, Report 2021/694. 2021.</li>

      <li>[CKLM22] Alessandro Chiesa, Seri Khoury, Siqi Liu, and Sidhanth Mohanty. Proximity generators for testing linear codes. 2022.</li>

      <li>[CR72] Stephen A. Cook and Robert A. Reckhow. “Time-bounded random access machines”. In: Proceedings of the 4th Annual ACM Symposium on Theory of Computing. STOC ’72. 1972, pp. 73–80.</li>

      <li>[DI14] Erez Druk and Yuval Ishai. “Linear-time encodable codes meeting the Gilbert–Varshamov bound and their cryptographic applications”. In: Proceedings of the 5th Innovations in Theoretical Computer Science Conference. ITCS ’14. 2014, pp. 169–182.</li>

      <li>[DM11] Iwan Duursma and Kit-Ho Mak. “On lower bounds for the Ihara constants A(2) and A(3)”. In: arXiv preprint arXiv:1102.4127 (2011).</li>

      <li>[FKLOWW21] Nicholas Franzese, Jonathan Katz, Steve Lu, Rafail Ostrovsky, Xiao Wang, and Chenkai Weng. “Constant-Overhead Zero-Knowledge for RAM Programs”. In: Proceedings of the 28th ACM Conference on Computer and Communications Security. CCS ’21. 2021, pp. 178–191.</li>

      <li>[GGPR13] Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. “Quadratic Span Programs and Succinct NIZKs without PCPs”. In: Proceedings of the 32nd Annual International Conference on Theory and Application of Cryptographic Techniques. EUROCRYPT ’13. 2013, pp. 626–645.</li>

      <li>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. “Delegating Computation: Interactive Proofs for Muggles”. In: Journal of the ACM 62.4 (2015), 27:1–27:64.</li>

      <li>[GLSTW21] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad Wahby. Brakedown: Linear-time and post-quantum SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/1043. 2021.</li>

      <li>[Gro10] Jens Groth. “Short Non-interactive Zero-Knowledge Proofs”. In: Proceedings of the 16th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’10. 2010, pp. 341–358.</li>

      <li>[Gro16] Jens Groth. “On the Size of Pairing-Based Non-interactive Arguments”. In: Proceedings of the 35th Annual International Conference on Theory and Applications of Cryptographic Techniques. EUROCRYPT ’16. 2016, pp. 305–326.</li>

      <li>[HH21] David Harvey and Joris van der Hoeven. “Integer multiplication in time <span class="math">O(n\\log n)</span>”. In: Annals of Mathematics 193 (2021), pp. 563–617.</li>

      <li>[HK20] David Heath and Vladimir Kolesnikov. “A 2.1 KHz Zero-Knowledge Processor with BubbleRAM”. In: Proceedings of the 27th ACM SIGSAC Conference on Computer and Communications Security. CCS ’20. 2020, pp. 2055–2074.</li>

      <li>[HR22] Justin Holmgren and Ron Rothblum. “Faster Sounder Succinct Arguments and IOPs”. In: Proceedings of the 42nd Annual International Cryptology Conference. CRYPTO ’22. 2022.</li>

      <li>[IKOS07] Yuval Ishai, Eyal Kushilevitz, Rafail Ostrovsky, and Amit Sahai. “Zero-knowledge from secure multiparty computation”. In: Proceedings of the 39th Annual Symposium on Theory of Computing. STOC’07. 2007, pp. 21–30.</li>

    </ul>

    <p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. “Algebraic Methods for Interactive Proof Systems”. In: Journal of the ACM 39.4 (1992), pp. 859–868.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LSTW21] Jonathan Lee, Srinath Setty, Justin Thaler, and Riad Wahby. Linear-time zero-knowledge SNARKs for R1CS. Cryptology ePrint Archive, Report 2021/030. 2021.</li>

      <li>[Lip13] Helger Lipmaa. “Succinct Non-interactive Zero Knowledge Arguments from Span Programs and Linear Error-Correcting Codes”. In: Proceedings of the 19th International Conference on the Theory and Application of Cryptology and Information Security. ASIACRYPT ’13. 2013, pp. 41–60.</li>

      <li>[Mie09] Thilo Mie. “Short PCPPs verifiable in polylogarithmic time with O(1) queries”. In: Annals of Mathematics and Artificial Intelligence 56 (3 2009), pp. 313–338.</li>

      <li>[RR20] Noga Ron-Zewi and Ron Rothblum. “Local Proofs Approaching the Witness Length”. In: Proceedings of the 61st Annual IEEE Symposium on Foundations of Computer Science. FOCS ’20. 2020, pp. 846–857.</li>

      <li>[RR22] Noga Ron-Zewi and Ron D. Rothblum. “Proving as Fast as Computing: Succinct Arguments with Constant Prover Overhead”. In: Proceedings of the 54th Annual ACM Symposium on Theory of Computing. STOC ’22. 2022.</li>

      <li>[RRR16] Omer Reingold, Ron Rothblum, and Guy Rothblum. “Constant-Round Interactive Proofs for Delegating Computation”. In: Proceedings of the 48th ACM Symposium on the Theory of Computing. STOC ’16. 2016, pp. 49–62.</li>

      <li>[RVW13] Guy N. Rothblum, Salil Vadhan, and Avi Wigderson. “Interactive Proofs of Proximity: Delegating Computation in Sublinear Time”. In: Proceedings of the 45th Annual ACM Symposium on Theory of Computing. STOC ’13. 2013, pp. 793–802.</li>

      <li>[Set20] Srinath Setty. “Spartan: Efficient and general-purpose zkSNARKs without trusted setup”. In: Proceedings of the 40th Annual International Cryptology Conference. CRYPTO ’20. Referencing Cryptology ePrint Archive, Report 2019/550, revision from 2020.02.28. 2020, pp. 704–737.</li>

      <li>[Sti08] Henning Stichtenoth. Algebraic function fields and codes. 2nd. Springer Publishing Company, 2008.</li>

      <li>[Tha13] Justin Thaler. “Time-Optimal Interactive Proofs for Circuit Evaluation”. In: Proceedings of the 33rd Annual International Cryptology Conference. CRYPTO ’13. 2013, pp. 71–89.</li>

      <li>[WYKW20] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. Wolverine: Fast, Scalable, and Communication-Efficient Zero-Knowledge Proofs for Boolean and Arithmetic Circuits. IACR Cryptology ePrint Archive, Report 2020/925. 2020.</li>

      <li>[XZS22] Tiancheng Xie, Yupeng Zhang, and Dawn Song. “Orion: Zero Knowledge Proof with Linear Prover Time”. In: Proceedings of the 42nd Annual International Cryptology Conference. CRYPTO ’22. 2022.</li>

      <li>[XZZPS19] Tiancheng Xie, Jiaheng Zhang, Yupeng Zhang, Charalampos Papamanthou, and Dawn Song. “Libra: Succinct Zero-Knowledge Proofs with Optimal Prover Computation”. In: Proceedings of the 39th Annual International Cryptology Conference. CRYPTO ’19. 2019, pp. 733–764.</li>

      <li>[YSWW21] Kang Yang, Pratik Sarkar, Chenkai Weng, and Xiao Wang. “QuickSilver: Efficient and Affordable Zero-Knowledge Proofs for Circuits and Polynomials over Any Field”. In: Proceedings of the 28th ACM Conference on Computer and Communications Security. CCS ’21. 2021, pp. 2986–3001.</li>

      <li>[ZWZZ20] Jiaheng Zhang, Weijie Wang, Yinuo Zhang, and Yupeng Zhang. Doubly Efficient Interactive Proofs for General Arithmetic Circuits with Linear Prover Time. Cryptology ePrint Archive, Report 2020/1247. 2020.</li>

    </ul>`;
---

<BaseLayout title="Linear-Time Probabilistic Proofs with Sublinear Verification... (2022/1056)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; eprint 2022/1056
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
