---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1972';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'RoK, Paper, SISsors – Toolkit for Lattice-based Succinct Arguments';
const AUTHORS_HTML = 'Michael Klooß, Russell W. F. Lai, Ngoc Khanh Nguyen, Michał Osadnik';

const CONTENT = `    <p class="text-gray-300">RoK, Paper, SISsors – Toolkit for Lattice-based Succinct Arguments (Full Version)</p>

    <p class="text-gray-300">Michael Kloofi<span class="math">^{1*}</span>, Russell W. F. Lai<span class="math">^{2}</span>, Ngoc Khanh Nguyen<span class="math">^{3}</span>, and Michał Osadnik<span class="math">^{2}</span></p>

    <p class="text-gray-300"><span class="math">^{1}</span> ETH Zurich, Zurich, Switzerland <span class="math">^{2}</span> Aalto University, Espoo, Finland <span class="math">^{3}</span> King’s College London, London, UK</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Abstract. Lattice-based succinct arguments allow to prove bounded-norm satisfiability of relations, such as <span class="math">f(\\mathbf{s}) = \\mathbf{t} \\mod q</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta<span class="math">, over specific cyclotomic rings </span>\\mathcal{O}_{\\mathcal{K}}<span class="math">, with proof size polylogarithmic in the witness size. However, state-of-the-art protocols require either 1) a super-polynomial size modulus </span>q<span class="math"> due to a soundness gap in the security argument, or 2) a verifier which runs in time linear in the witness size. Furthermore, construction techniques often rely on specific choices of </span>\\mathcal{K}$ which are not mutually compatible. In this work, we exhibit a diverse toolkit for constructing efficient lattice-based succinct arguments:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(i) We identify new subtractive sets for general cyclotomic fields <span class="math">\\mathcal{K}</span> and their maximal real subfields <span class="math">\\mathcal{K}^+</span>, which are useful as challenge sets, e.g. in arguments for exact norm bounds. (ii) We construct modular, verifier-succinct reductions of knowledge for the bounded-norm satisfiability of structured-linear/inner-product relations, without any soundness gap, under the vanishing SIS assumption, over any <span class="math">\\mathcal{K}</span> which admits polynomial-size subtractive sets. (iii) We propose a framework to use twisted trace maps, i.e. maps of the form <span class="math">\\tau(z) = \\frac{1}{N} \\cdot \\mathrm{Trace}_{\\mathcal{K}/\\mathbb{Q}}(\\alpha \\cdot z)</span>, to embed <span class="math">\\mathbb{Z}</span>-inner-products as <span class="math">\\mathcal{R}</span>-inner-products for some structured subrings <span class="math">\\mathcal{R} \\subseteq \\mathcal{O}_{\\mathcal{K}}</span> whenever the conductor has a square-free odd part. (iv) We present a simple extension of our reductions of knowledge for proving the consistency between the coefficient embedding and the Chinese Remainder Transform (CRT) encoding of <span class="math">\\mathbf{s}</span> over any cyclotomic field <span class="math">\\mathcal{K}</span> with a smooth conductor, based on a succinct decomposition of the CRT map into automorphisms, and a new, simple succinct argument for proving automorphism relations.</p>

    <p class="text-gray-300">Combining all techniques, we obtain, for example, verifier-succinct arguments for proving that <span class="math">\\mathbf{s}</span> satisfying <span class="math">f(\\mathbf{s}) = \\mathbf{t} \\bmod q</span> has binary coefficients, without soundness gap and with polynomial-size modulus <span class="math">q</span>.</p>

    <p class="text-gray-300">1 Introduction</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A fundamental and recurring task in constructing lattice-based succinct arguments is to prove knowledge of a committed vector <span class="math">\\mathbf{s} \\in \\mathcal{R}^m</span> over a ring <span class="math">\\mathcal{R}</span> which satisfies norm-bound constraints, such as $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta$. For instance, such protocols could be extended directly into a succinct argument for structured languages [CLM23], combined with quadratic functional commitments to yield succinct arguments for NP [ACL+22, CLM23]⁴, or transformed into polynomial commitment schemes [FMN23, AFLN24, CMNW24] which allow compiling polynomial interactive oracle proofs [BCS16] into succinct arguments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As evidenced in prior works [Lyu12, LNP22, BS23], the currently most efficient lattice-based (non-)succinct arguments operate over rings of integers <span class="math">\\mathcal{R} := \\mathbb{Z}[\\zeta]</span> of cyclotomic number fields <span class="math">\\mathcal{K} := \\mathbb{Q}(\\zeta)</span>, where <span class="math">\\zeta</span> is a primitive <span class="math">\\mathfrak{f}</span>-th root of unity for <span class="math">\\mathfrak{f} = \\mathsf{poly}(\\lambda)</span>. Indeed, the ability to construct exponential-sized low-norm challenge sets over <span class="math">\\mathcal{R}</span> allows the aforementioned protocols to achieve negligible soundness in one-shot while maintaining relatively small lattice parameters. However, this comes at a cost of the following two complications.</p>

    <p class="text-gray-300">*Work done at Aalto University. The author’s affiliation changed before publication. ⁴[ACL+22, CLM23] relied on the knowledge-kRISIS assumption for the knowledge soundness of well-formedness of commitments. However, the assumption has subsequently been cryptanalysed [WW23, DFS24], rendering the security proofs vacuous.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Correctness Gap. The first one can be described as the <em>correctness gap</em>. Namely, most of the recursion-based protocols start with the initial witness <span class="math">\\mathbf{s}_{0}:=\\mathbf{s}</span>, and in the <span class="math">i</span>-th iteration, an honest prover somehow folds the “current” witness <span class="math">\\mathbf{s}_{i-1}</span> into a new one <span class="math">\\mathbf{s}_{i}</span>; thus shrinking the dimension of the witness, but simultaneously, increasing its norm. At the end, say after <span class="math">\\mu</span> iterations, the prover outputs the final witness <span class="math">\\mathbf{s}_{\\mu}</span> of small (potentially constant) dimension. Suppose there exists some <span class="math">\\gamma</span> such that for all <span class="math">i=1,\\ldots,\\mu</span> we have $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\gamma\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Then, in order to maintain correctness, one must inherently choose </span>q>\\gamma^{\\mu}\\cdot\\beta\\geq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{\\mu}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We call this phenomenon the correctness gap, since if our only task were to commit to </span>\\mathbf{s}<span class="math"> using a standard lattice-based commitment scheme, setting </span>q=O(\\beta)$ would suffice.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Soundness Gap. A more concerning issue is the <em>soundness gap</em>. A vast majority of prior works based on cyclotomic rings encounter the problem that the extracted witness <span class="math">\\bar{\\mathbf{s}}</span> is not necessarily short, but it is of the fractional form <span class="math">\\bar{\\mathbf{s}}:=\\bar{\\mathbf{z}}/\\bar{c}\\bmod q</span>, where <span class="math">q</span> is the proof system modulus and both <span class="math">\\bar{\\mathbf{z}}\\in\\mathcal{R}^{m}</span> and <span class="math">\\bar{c}\\in\\mathcal{R}</span> are somewhat short (but $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bar{\\mathbf{z}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is larger than </span>\\beta<span class="math">). Even though this <em>relaxed</em> soundness suffices to construct basic primitives, such as signature schemes <em>[x14, DKL^{+}18]</em>, verifiable encryption <em>[x16]</em>, or few-time verifiable random functions <em>[EKS^{+}21]</em>, it is not enough when the required functionality naturally involves proving exact norm bounds (e.g. in set membership and range proofs). But especially in the context of succinct arguments built in a recursive manner, dealing with the slack and other norm-growth related issues have shown to have enormous impact on setting up the parameters <em>[x2, x3, x1, x2]</em>, such as picking super-polynomial modulus </span>q$, which makes the aforementioned schemes seem barely practical.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prior works. Since the soundness gap seemed to be the main efficiency bottleneck of lattice-based succinct arguments, several works naturally tried to address this issue first. To begin with, Albrecht and Lai <em>[x1]</em> designed a lattice-based argument of polylogarithmic size, where the extracted witness <span class="math">\\bar{\\mathbf{s}}</span> is somewhat short. The key ingredient of <em>[x1]</em> was the notion of <em>subtractive sets</em>. Namely, a set <span class="math">S\\subseteq\\mathcal{R}</span> is called subtractive if for any two distinct elements <span class="math">c,c^{\\prime}\\in S</span>, <span class="math">c-c^{\\prime}</span> is invertible over the ring <span class="math">\\mathcal{R}</span>. Since the invertibility is independent of the proof system modulus <span class="math">q</span>, the latter can be picked freely so that the inverse <span class="math">(c-c^{\\prime})^{-1}</span> is short relative to <span class="math">q</span>. Further, it was shown how to construct such subtractive sets of cardinality <span class="math">p</span> in cyclotomic rings of prime power conductors <span class="math">\\mathfrak{f}:=p^{k}</span>. Thus, using subtractive sets as a challenge space for the verifier, one can argue that the extracted witness <span class="math">\\bar{\\mathbf{s}}:=\\bar{\\mathbf{z}}/\\bar{c}</span> has low norm, because <span class="math">1/\\bar{c}</span> itself is short. However, this approach comes at a cost of non-negligible soundness error (due to the size of subtractive sets), and therefore some sort of soundness amplification is necessary. Furthermore, the protocol itself still does not manage to prove the exact norm bound, i.e. $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">. In fact, in the context of recursive succinct arguments, the norm of the extracted witness can only be upper bounded by </span>\\gamma^{\\mu}\\cdot\\theta^{O(\\mu)}\\cdot\\beta<span class="math"> for some </span>\\theta\\approx\\mathfrak{f}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the setting of power-of-two cyclotomic rings, the strategy above falls apart completely since there exists no subtractive set of size larger than two <em>[x17, x1]</em>. Hence, a different methodology has recently been developed. Notably, Beullens and Seiler <em>[x4]</em> proposed a succinct argument, LaBRADOR, for proving $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}\\leq\\beta^{2}$ (among other relations), inspired by the following two-fold approach from <em>[x19]</em>:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Approximate shortness proof</em>. Prove that <span class="math">\\mathbf{s}</span> is somewhat short.</li>

      <li><span class="math">\\mathbb{Z}_{q}</span>-<em>Inner product proof</em>. Prove that <span class="math">(\\langle\\psi(\\mathbf{s}),\\psi(\\mathbf{s})\\rangle\\pmod{q})\\leq\\beta^{2}</span>, where <span class="math">\\psi(\\mathbf{s})</span> is the coefficient vector of <span class="math">\\mathbf{s}</span>.</li>

    </ol>

    <p class="text-gray-300">Combining (i) and (ii), one can argue that for a large enough modulus <span class="math">q</span> no modulo wrap-around occurs, and therefore <span class="math">\\langle\\psi(\\mathbf{s}),\\psi(\\mathbf{s})\\rangle\\leq\\beta^{2}</span> holds over <span class="math">\\mathbb{Z}</span>.</p>

    <p class="text-gray-300">In order to prove (i) without relying on subtractive sets, LaBRADOR uses the Johnson-Lindenstrauss random projection technique <em>[x1, x18, x11]</em>. The idea is that the verifier will first generate an integer matrix <span class="math">\\mathbf{B}</span> with short (binary or ternary) values as a challenge, and the prover then outputs <span class="math">\\psi(\\mathbf{v}):=\\mathbf{B}\\psi(\\mathbf{s})\\pmod{q}</span>. Afterwards, the verifier checks whether <span class="math">\\psi(\\mathbf{v})</span> is of low norm (which is true in the honest executions, since both <span class="math">\\mathbf{B}</span> and <span class="math">\\psi(\\mathbf{s})</span> are). Finally, the prover needs to prove wellformedness of <span class="math">\\psi(\\mathbf{v})</span>, i.e. the linear equation <span class="math">\\mathbf{B}\\psi(\\mathbf{s})=\\psi(\\mathbf{v})</span> over <span class="math">\\mathbb{Z}_{q}</span>. The crucial soundness argument is that if the extracted <span class="math">\\mathbf{s}</span> was not short, then with high probability (dictated by the number of rows of <span class="math">\\mathbf{B}</span>), <span class="math">\\psi(\\mathbf{v})=\\mathbf{B}\\psi(\\mathbf{s})</span> would not have low norm, which leads to a contradiction. Unfortunately, the random projection strategy inherently requires the verifier to generate the matrix <span class="math">\\mathbf{B}</span>, which itself has length <span class="math">O(m)</span>. As a consequence, the verifier</p>

    <p class="text-gray-300">runtime becomes essentially linear in the witness size, which may not be satisfying in certain real-world use cases.</p>

    <p class="text-gray-300">We highlight that both (i) and (ii) require some kind of inner product proof over <span class="math">\\mathbb{Z}_{q}</span>; either between two committed vectors, or between one public and one committed vector. Since the underlying protocol natively operates over cyclotomic rings <span class="math">\\mathcal{R}=\\mathbb{Z}[\\zeta]</span>, it is essential to transform <span class="math">\\mathbb{Z}</span>-relations into equivalent ones over the ring <span class="math">\\mathcal{R}</span>. To this end, it was shown in <em>[x13]</em> that for any two elements <span class="math">a,b\\in\\mathcal{R}</span> of a power-of-two cyclotomic ring, the constant term of <span class="math">a\\cdot\\bar{b}\\in\\mathcal{R}</span> is exactly equal to the inner product <span class="math">\\langle\\psi(\\mathbf{a}),\\psi(\\mathbf{b})\\rangle\\in\\mathbb{Z}</span>, where <span class="math">\\psi(\\mathbf{a}),\\psi(\\mathbf{b})</span> are the coefficient vectors of <span class="math">a,b</span> respectively and <span class="math">\\bar{\\cdot}</span> here denotes the complex conjugation. This observation allows us to translate proving inner products and linear relations over integers into proving statements about constant terms over the ring <span class="math">\\mathcal{R}</span>. Finally, LaBRADOR makes use of the fact that inner product relations over <span class="math">\\mathcal{R}</span> are “folding-friendly” and can be efficiently proven in a recursive manner.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Interestingly, LaBRADOR also managed to circumvent the correctness gap by taking inspiration from the “decompose-then-hash” paradigm used in lattice-based Merkle trees <em>[x16]</em>. Intuitively, using the notation above for describing recursive-based protocols, instead of folding the intermediate witness <span class="math">\\mathbf{s}_{i-1}</span> directly into a new one <span class="math">\\mathbf{s}_{i}</span>, an honest prover would first decompose <span class="math">\\mathbf{s}_{i-1}</span> (w.r.t. some decomposition base <span class="math">b</span>) into multiple vectors <span class="math">(\\mathbf{s}_{i-1,j})_{j\\in[\\ell]}</span> of much smaller norm and then fold all of them together into a new witness <span class="math">\\mathbf{s}_{i}</span>. By carefully picking various parameters, such as <span class="math">b</span>, one can ensure that, in an honest execution, if $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{i-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">, then we must have </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta$. This technique was also adopted in a recent folding scheme called LatticeFold <em>[x2]</em>.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Bridging the gap.</h4>

    <p class="text-gray-300">At a high level, the aforementioned approaches to prove shortness seem somewhat orthogonal. For <span class="math">\\mathfrak{f}=p^{k}</span>, where <span class="math">p=\\mathsf{poly}(\\lambda)</span> is a large enough prime, one can rely on subtractive sets to efficiently prove approximate shortness (i) with succinct verification <em>[x6]</em>. However, it is unknown how to translate proving <span class="math">\\mathbb{Z}_{q}</span>-relations, as in (ii), into equivalent relations over odd prime-power cyclotomic rings. On the other hand, for <span class="math">\\mathfrak{f}=2^{k}</span>, one can apply the Johnson-Lindenstrauss projection strategy to prove both (i) and (ii), but at the cost of slow verification time.</p>

    <p class="text-gray-300">Hence, it is an important research question whether there exist cyclotomic (or other) rings <span class="math">\\mathcal{R}</span>, which contain subtractive sets of fairly large size, and at the same time, expose efficient packing and batching techniques for turning relations over <span class="math">\\mathbb{Z}</span> (or more generally, other base rings) to relations over <span class="math">\\mathcal{R}</span>. An affirmative answer, together with existing optimisations, would then yield a practical lattice-based succinct argument for proving exact norm bounds with fast verification.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">In this work, we present a versatile toolkit for constructing lattice-based succinct arguments that eliminate correctness and soundness gaps while maintaining succinct verification. Our contributions are outlined as follows:</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Succinct Arguments for Bounded-Norm Satisfiability.</h4>

    <p class="text-gray-300">We design a lattice-based succinct argument system for bounded-norm satisfiability of structured linear and inner-product relations. Our system retains features of previous protocols, such as transparent setup, quasi-linear-time prover, polylogarithmic-time verifier, and negligible soundness in one-shot, while simultaneously eliminating any correctness and soundness gaps. Consequently, our argument system achieves asymptotically the most attractive proof sizes, which are smaller by at least a factor of <span class="math">\\Omega(\\log^{2}\\lambda)</span> than the prior state-of-the-art constructions (see Figure 1 for more details). Furthermore, our protocol’s modular design allows for straightforward analysis and customisation, making it adaptable to various applications.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Subtractive Sets.</h4>

    <p class="text-gray-300">Our protocol uses subtractive sets as challenge sets. While subtractive sets for prime-power cyclotomic rings are well-known, the non-prime-power case seems less studied. Motivated by the need of non-prime-power rings (e.g. for the twisted trace technique, see below) in some applications, we identify a subtractive set for cyclotomic rings <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> of non-prime-power conductor <span class="math">\\mathfrak{f}</span> with a cardinality of <span class="math">\\mathfrak{f}/\\mathfrak{f}_{\\max}</span>, where <span class="math">\\mathfrak{f}_{\\max}</span> is the largest prime-power divisor of <span class="math">\\mathfrak{f}</span>. Additionally, we identify subtractive sets</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assumptions</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">transparent setup</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">proof size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CLM23]</td>

            <td class="px-3 py-2 border-b border-gray-700">vSIS</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log5m·λ2/ log2λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[BCS23]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log6m·λ2/ logλ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[FMN23]</td>

            <td class="px-3 py-2 border-b border-gray-700">PowerBASIS</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log5m·λ2/ log2λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[AFLN24]</td>

            <td class="px-3 py-2 border-b border-gray-700">M-SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log5m·λ2/ log2λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CMNW24]</td>

            <td class="px-3 py-2 border-b border-gray-700">SIS</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log3m·λ2)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">This work</td>

            <td class="px-3 py-2 border-b border-gray-700">vSIS</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log3m·λ2/ log2λ)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. Asymptotic efficiency of our commitment opening proof (in bits) and comparison with prior works which support succinct poly  <span class="math">(\\log m, \\lambda)</span>  verification time. Here,  <span class="math">\\lambda</span>  is the security parameter and  <span class="math">m</span>  is the length of the committed vector. For each construction, the proof size corresponds to the soundness error poly  <span class="math">(\\lambda, \\log m) \\cdot 2^{-\\lambda}</span> . The SIS-related parameters were chosen with respect to the methodology from [MR09] for running BKZ on block size  <span class="math">b = O(\\lambda)</span> . For [BCS23, CLM23, FMN23], which only achieve inverse-polynomial soundness in one-shot, we applied a standard soundness amplification by parallel-repeating the protocol by a factor of  <span class="math">O(\\lambda / \\log \\lambda)</span> . We note that for [AFLN24], [CMNW24], and this work, super-polynomial knowledge extraction runtime  <span class="math">O(m^{\\log \\lambda})</span>  is obtained.</p>

    <p class="text-gray-300">over the real subrings  <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}} + \\zeta_{\\mathfrak{f}}^{-1}]</span> , with a cardinality of  <span class="math">(p + 1) / 2</span>  for prime-power conductors  <span class="math">\\mathfrak{f} = p^k</span>  and  <span class="math">\\lfloor \\mathfrak{f} / (2\\mathfrak{f}_{\\max})\\rfloor</span>  for non-prime-power  <span class="math">\\mathfrak{f}</span> .</p>

    <p class="text-gray-300">Embedded  <span class="math">\\mathbb{Z}</span> -Inner-Products via Twisted Trace. While our protocol supports proving inner products over rings such as  <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> , higher-layer applications may require proving inner products over  <span class="math">\\mathbb{Z}</span> , e.g. for proving that a committed  <span class="math">\\mathbb{Z}</span> -vector is binary. Unfortunately, efficient methods for embedding  <span class="math">\\mathbb{Z}</span> -inner products to  <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> -inner products were only known for  <span class="math">\\mathfrak{f} = 2^d</span>  being a power of 2, which is problematic because subtractive sets over  <span class="math">\\mathbb{Z}[\\zeta_{2^d}]</span>  are of cardinality at most 2. We extend the existing embedding method to any ring of the form  <span class="math">\\mathbb{Z}[\\zeta_{2^d}] \\otimes \\mathbb{Z}[\\zeta_{p_0} + \\zeta_{p_0}^{-1}] \\otimes \\ldots \\otimes \\mathbb{Z}[\\zeta_{p_{k-1}} + \\zeta_{p_{k-1}}^{-1}]</span> , where  <span class="math">p_0, \\ldots, p_{k-1}</span>  are distinct odd primes. This is achieved by replacing the "constant term map" with a "twisted trace map" of the form  <span class="math">\\tau(z) = \\frac{1}{N} \\operatorname{Trace}(\\alpha \\cdot z)</span> .</p>

    <p class="text-gray-300">Succinct Consistency Proof for CRT. Another typical way of embedding  <span class="math">\\mathbb{Z}</span> -relations into  <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> -relations is via the Chinese Remainder Transform (CRT). However, this requires proving that the witness vector is committed in both the coefficient embedding and its CRT coefficients consistently, and known consistency proofs are not succinct. Using the fact that the CRT over cyclotomic fields with smooth conductors can be succinctly represented through a few automorphism evaluations, we derive a succinct argument for the consistency between the commitment of the coefficient embedding and that of the CRT coefficients. At the core of our succinct consistency proof is a new succinct argument that verifies whether two committed vectors are related by an entry-wise automorphism.</p>

    <p class="text-gray-300">Throughout this work, we will assume that  <span class="math">\\mathcal{K} = \\mathbb{Q}(\\zeta)</span>  is a cyclotomic field with conductor  <span class="math">\\mathfrak{f}</span>  and degree  <span class="math">\\varphi = \\varphi (\\mathfrak{f}) = \\mathsf{poly}(\\lambda)</span> , and  <span class="math">\\mathcal{O}_{\\mathcal{K}} = \\mathbb{Z}[\\zeta ]</span>  is its ring of integers. For some of our results, we will further require  <span class="math">\\mathcal{K}^{+} = \\mathbb{Q}(\\zeta +\\zeta^{-1})</span> , the maximal real subfield of  <span class="math">\\mathcal{K}</span> , and its ring of integers  <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}} = \\mathbb{Z}[\\zeta +\\zeta^{-1}]</span> . Depending on the context of a specific section, we will use  <span class="math">\\mathcal{R}\\subset \\mathcal{O}_{\\mathcal{K}}</span>  to denote a ring of interest to that section. Unless specified, we measure the norm of elements and vectors by their  <span class="math">\\ell_2</span> -norm over the canonical embedding over  <span class="math">\\mathcal{K}</span> . Our results can be divided into three parts, which we overview in Section 2.1, 2.2, and 2.3 respectively.</p>

    <p class="text-gray-300">In Section 4, we expose subtractive sets over  <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>  with non-prime-power conductor  <span class="math">\\mathfrak{f}</span> , and over  <span class="math">\\mathcal{O}_{\\mathcal{K}^+}</span>  with both prime-power and non-prime-power conductors, with favourable properties, i.e. they have  <span class="math">\\mathrm{poly}(\\lambda)</span></p>

    <p class="text-gray-300">cardinality and small expansion factors. These subtractive sets can be used in any lattice-based arguments, and in particular those developed in this work.</p>

    <p class="text-gray-300">A set <span class="math">S\\subset\\mathcal{R}</span> is said to be subtractive over <span class="math">\\mathcal{R}</span> if for any two distinct elements <span class="math">c,c^{\\prime}\\in S</span>, it holds that <span class="math">c-c^{\\prime}\\in\\mathcal{R}^{\\times}</span>, i.e. <span class="math">c-c^{\\prime}</span> is a unit. This concept is prevalently linked with the examination of Euclidean number fields <em>[x14]</em> and has also found relevance in lattice-based cryptography, specifically in argument systems and secret sharing <em>[x1]</em>. An explicit creation of an upper-bound-matching cardinality <span class="math">p</span> is evident in a cyclotomic ring <span class="math">\\mathcal{R}=\\mathcal{O}_{\\mathcal{K}}</span> with a prime-power conductor <span class="math">\\mathfrak{f}=p^{k}</span>. On the other hand, we are not aware of explicit studies of subtractive sets regarding other cyclotomic rings and their subrings.</p>

    <p class="text-gray-300">For applications in lattice-based cryptography, the most relevant measures of the quality of a subtractive set <span class="math">S</span> are its</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. cardinality $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, which inversely affects the knowledge error of argument systems using </span>S$ as a challenge set,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>“expansion factor” <span class="math">\\gamma=\\gamma_{S}</span>, i.e. how much the norm of an element grows when multiplied with an element in <span class="math">S</span>, which affects the “correctness gap” of lattice-based argument systems,</li>

      <li>“inverse-expansion factor” <span class="math">\\theta=\\theta_{S}</span>, i.e. how much the norm of an element grow when multiplied with <span class="math">(c-c^{\\prime})^{-1}</span> for distinct <span class="math">c,c^{\\prime}\\in S</span>, which affects the “soundness gap” of lattice-based argument systems.</li>

    </ol>

    <p class="text-gray-300">For <span class="math">\\mathcal{R}=\\mathcal{O}_{\\mathcal{K}}</span> with prime-power conductor <span class="math">\\mathfrak{f}=p^{k}</span>, it is known <em>[x14, x1]</em> that there exists a subtractive set <span class="math">S</span> of cardinality <span class="math">p</span> and expansion factors <span class="math">\\gamma,\\theta\\approx p</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our main result in this part is the exposition of the subtractive set <span class="math">S\\coloneqq\\left\\{\\zeta^{i}\\right\\}_{i\\in[\\mathfrak{f}/\\mathfrak{f}_{\\max}]}</span> of cardinality $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\mathfrak{f}/\\mathfrak{f}_{\\max}<span class="math"> for any conductor </span>\\mathfrak{f}<span class="math"> with at least two distinct prime factors, where </span>\\mathfrak{f}_{\\max}<span class="math"> is the largest prime-power factor of </span>\\mathfrak{f}<span class="math">. Notably, the expansion factor (conserning the canonical 2-norm) is </span>\\gamma=1<span class="math">, i.e. the norm of an element does not grow when multiplied with an element from </span>S<span class="math">, while the inverse-expansion factor </span>\\theta\\approx\\mathfrak{f}$ is similar to the existing result for prime-power rings.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For completeness, we also expose related subtractive sets over <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span> for both prime-power and non-prime-power conductors.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Tight Succinct Argument for Bounded Norm Satisfiability</h3>

    <p class="text-gray-300">In Section 5, we work with <span class="math">\\mathcal{R}=\\mathcal{O}_{\\mathcal{K}}</span> or <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span>. We present a new lattice-based succinct argument for proving the bounded norm satisfiability of structured linear and/or inner-product relations, denoted by <span class="math">\\Xi^{\\text{lin}}</span> and <span class="math">\\Xi^{\\text{sp}}</span> respectively. More concretely, the argument system allows to prove knowledge of a short vector <span class="math">\\mathbf{w}\\in\\mathcal{R}^{m}</span>, with <span class="math">m=d^{n}</span>, satisfying</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a linear relation <span class="math">\\mathbf{F}\\mathbf{w}=\\mathbf{y}\\bmod q</span>, where <span class="math">\\mathbf{F}=\\mathbf{F}_{\\mu-1}\\bullet\\ldots\\bullet\\mathbf{F}_{0}\\in\\mathcal{R}_{q}^{n\\times m}</span> can be expressed as a row-wise tensor product of <span class="math">\\mu</span> matrices <span class="math">\\mathbf{F}_{i}\\in\\mathcal{R}_{q}^{n\\times d}</span>, and</li>

      <li>(optionally) an inner-product relation <span class="math">\\langle\\mathbf{w},\\alpha(\\mathbf{w})\\rangle\\bmod q</span>, where <span class="math">\\alpha</span> is either the identity function or the complex conjugate (specified publicly).</li>

    </ul>

    <p class="text-gray-300">Our argument system consists of <span class="math">O(\\mu)=O(\\log_{d}m)</span> rounds and is public-coin, and can thus be made non-interactive via the Fiat-Shamir transform. The prover time is quasi-linear in the size of the statement, and both the proof size and the verifier time are polylogarithmic in the statement size. It can be instantiated with a transparent setup. For example, the rows of <span class="math">\\mathbf{F}</span> could contain a random commitment key of the vSIS commitment scheme <em>[x6]</em> and evaluations of monomials at different evaluation points. This turns the vSIS commitment scheme into a polynomial commitment scheme, which can then be used to compile a PIOP into a SNARK.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">Correctness and Soundness Gaps.</h4>

    <p class="text-gray-300">A distinguishing feature of our argument system is that it is free of the so-called “correctness gap” and “soundness gap”.</p>

    <p class="text-gray-300">The correctness gap refers to the phenomenon that although the prover’s witness <span class="math">\\mathbf{w}</span> is of norm at most <span class="math">\\beta</span>, the norm check performed by the verifier in the protocol is against a bound <span class="math">\\beta^{\\prime}\\gg\\beta</span>. Typically, e.g. in lattice-based Bulletproofs, we have <span class="math">\\beta^{\\prime}\\approx(1+\\gamma)^{\\mu}\\beta</span>. Using the subtractive set suggested in <em>[x1]</em> and picking <span class="math">\\mu\\approx\\log\\lambda</span>, the gap <span class="math">\\beta^{\\prime}/\\beta\\approx(1+\\gamma)^{\\mu}</span> is super-polynomial in <span class="math">\\lambda</span>. Note that if the subtractive set suggested in Section 4 with <span class="math">\\gamma=1</span> is used, then the correctness gap is immediately reduced to <span class="math">\\mathsf{poly}(\\lambda)</span> but still greater than 1 (i.e. no gap).</p>

    <p class="text-gray-300">a) Lattice-based Bulletproofs.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <p class="text-gray-300">b) This work.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. Overview of the evolution of a prover witness  <span class="math">\\mathbf{w}_0</span>  to an extracted witness  <span class="math">\\mathbf{w}_0^*</span>  in lattice-based Bulletproofs and in this work.</p>

    <p class="text-gray-300">The more challenging issue is that of the soundness gap, which refers to the limitation that, in addition to the correctness gap  <span class="math">\\beta&#x27; / \\beta</span> , the witness produced by a knowledge extractor is of even larger norm  <span class="math">\\beta^{<em>} \\gg \\beta&#x27;</span> . Using the example of lattice-based Bulletproofs again, we have  <span class="math">\\beta^{</em>} \\approx (2\\theta)^{3\\mu}\\beta&#x27; \\approx (1 + \\gamma)^{\\mu}(2\\theta)^{3\\mu}\\beta</span> . Since no currently known subtractive set (including those suggested in Section 4) achieves  <span class="math">\\theta = O(1)</span> , the soundness gap problem cannot be solved by simply using a different subtractive set, at least until more favourable sets are found.</p>

    <p class="text-gray-300">Figure 2 overviews the evolution of a prover witness  <span class="math">\\mathbf{w}_0</span>  to an extracted witness  <span class="math">\\mathbf{w}_0^*</span>  in lattice-based Bulletproofs and in this work.</p>

    <p class="text-gray-300">Lattice-based Bulletproofs. In Fig. 2 part a) for Bulletproofs, each arrow in the top row represents one Bulletproofs folding step, where  <span class="math">\\mathbf{w}_i</span>  denotes the intermediate witness after the  <span class="math">i</span> -th folding step. The norm of the  <span class="math">i</span> -th round prover witness  <span class="math">\\mathbf{w}_i</span>  grows by a multiplicative factor of (around)  <span class="math">\\gamma</span>  compared to the previous round prover witness  <span class="math">\\mathbf{w}_{i-1}</span> . The last round witness  <span class="math">\\mathbf{w}_{\\mu}</span>  is then of norm around  <span class="math">\\beta \\gamma^{\\mu}</span> , i.e. with correctness gap  <span class="math">\\gamma^{\\mu}</span> . The vertical arrow is trivial since the last-round prover witness is sent in plain, i.e.  <span class="math">\\mathbf{w}_{\\mu}^{<em>} = \\mathbf{w}_{\\mu}</span> . Each arrow in the bottom row represents a "traditional witness extraction step", i.e. moving one layer up in the tree-special soundness witness extraction, where  <span class="math">\\mathbf{w}_i^{</em>}</span>  denotes the extracted witness at depth  <span class="math">i</span> . The norm of the  <span class="math">i</span> -th round extracted witness  <span class="math">\\mathbf{w}_i^{<em>}</span>  grows by (roughly) a multiplicative factor of  <span class="math">\\theta^3</span>  compared to the previous round extracted witness  <span class="math">\\mathbf{w}_{i-1}^{</em>}</span> . The final extracted witness  <span class="math">\\mathbf{w}_0^{*}</span>  is then of norm around  <span class="math">\\beta \\gamma^{\\mu} \\theta^{3\\mu}</span> , i.e. the soundness gap is  <span class="math">\\gamma^{\\mu} \\theta^{3\\mu}</span> .</p>

    <p class="text-gray-300">Split-and-Fold and Norm-Check. We propose a modular approach to building a protocol which has no correctness and soundness gaps. The basis are atomic reductions of knowledge for handling different tasks. Before explaining our protocols, we need to look ahead and introduce our principal relation  <span class="math">\\Xi^{\\mathrm{fin}}</span> .</p>

    <p class="text-gray-300">Bird-eye view of principal relation. Recall that our the principal relation  <span class="math">\\Xi^{\\mathrm{fin}}</span>  consists of statements  <span class="math">(\\mathbf{H},\\mathbf{F},\\mathbf{Y})</span>  and witnesses  <span class="math">\\mathbf{W}</span> , all matrices over  <span class="math">\\mathcal{R}</span> , which satisfy the relation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{H}\\mathbf{F}\\mathbf{W} = \\mathbf{Y}</span>  (mod  <span class="math">q</span>  ) and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For simplicity, we first ignore the matrix  <span class="math">\\mathbf{H}</span>  and treat it as the identity matrix. As noted above, the matrix  <span class="math">\\mathbf{F}</span>  has a tensor structure,  <span class="math">\\mathbf{F} = \\mathbf{F}_{\\mu -1}\\bullet \\ldots \\bullet \\mathbf{F}_0\\in \\mathcal{R}_q^{n\\times m}</span>  where  <span class="math">\\mathbf{F}_i\\in \\mathcal{R}_q^{n\\times d}</span> . The dimension  <span class="math">m\\times r</span>  of the witness  <span class="math">\\mathbf{W}\\in \\mathcal{R}_q^{m\\times r}</span>  and its norm bound  <span class="math">\\beta</span>  are the pivotal measures our atomic protocols operate on. Note that the claim  <span class="math">\\mathbf{FW} = \\mathbf{Y}</span>  is equivalent to  <span class="math">r</span>  claims  <span class="math">\\mathbf{Fw}_i = \\mathbf{y}_i</span> , for  <span class="math">i\\in [r]</span> , where  <span class="math">\\mathbf{W} = (\\mathbf{w}_0,\\dots ,\\mathbf{w}_{r - 1})</span> .</p>

    <p class="text-gray-300">The atomic protocols.</p>

    <p class="text-gray-300">Next, we give a high-level overview of our atomic protocols. These are all reductions of knowledge, which reduce a claim <span class="math">(\\mathbf{H},\\mathbf{F},\\mathbf{Y})</span> to another claim <span class="math">(\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}})</span> and witness <span class="math">\\mathbf{W}</span> to <span class="math">\\widetilde{\\mathbf{W}}</span>. Each protocol affects different parameters of the statement or witness.</p>

    <h5 id="sec-9" class="text-base font-semibold mt-4">Split.</h5>

    <p class="text-gray-300">The purpose of the split protocol <span class="math">\\Pi^{\\mathsf{split}}</span> is to reduce the witness height <span class="math">m</span> to <span class="math">m/d</span> in exchange for growing the width <span class="math">r</span> to <span class="math">rd</span>. In other words, we reduce the dimension of the columns <span class="math">\\mathbf{w}_{i}</span> by increasing the number of instances/columns. To achieve this, we use the row-wise tensor structure of <span class="math">\\mathbf{F}</span> to factor it into <span class="math">\\mathbf{F}=\\mathbf{R}\\bullet\\widetilde{\\mathbf{F}}</span>, where <span class="math">\\bullet</span> denotes row-wise tensoring. Decomposing <span class="math">\\mathbf{W}</span> into <span class="math">\\sum_{i\\in[d]}\\mathbf{e}_{i}\\otimes\\mathbf{W}_{i}</span>, i.e. viewing <span class="math">\\mathbf{W}</span> as a <em>vertical</em> stack of matrices <span class="math">\\mathbf{W}_{i}</span> compatible with the tensor decomposition, we let <span class="math">\\widetilde{\\mathbf{Y}}_{j}=\\widetilde{\\mathbf{F}}\\mathbf{W}_{j}</span>, and <span class="math">\\widetilde{\\mathbf{Y}}=(\\widetilde{\\mathbf{Y}}_{0},\\ldots,\\widetilde{\\mathbf{Y}}_{d-1})</span> and the prover sends these cross terms. The reduced statement is then <span class="math">(\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}})</span> with witness <span class="math">\\widetilde{\\mathbf{W}}=(\\mathbf{W}_{0},\\ldots,\\mathbf{W}_{d-1})</span> the <em>horizontal</em> concatenation of the matrices.</p>

    <p class="text-gray-300">Note that <span class="math">\\Pi^{\\mathsf{split}}</span> reshapes the dimensions of <span class="math">\\mathbf{W}</span> as required. Moreover, the witness norm is left unchanged. Lastly, we note that handling the case where <span class="math">\\mathbf{H}</span> (and thus <span class="math">\\widetilde{\\mathbf{H}}</span>) is not the identity matrix slightly is more involved and explained in detail in Section 5.3.</p>

    <h5 id="sec-10" class="text-base font-semibold mt-4">Fold.</h5>

    <p class="text-gray-300">The fold protocol <span class="math">\\Pi^{\\mathsf{fold}}</span> reduces the witness width <span class="math">r</span> to <span class="math">r^{\\prime}</span> (by random linear combining the columns). The protocol simply multiplies <span class="math">\\mathbf{W}</span> and <span class="math">\\mathbf{Y}</span> with a random short challenge matrix <span class="math">\\mathbf{C}\\in\\mathcal{R}_{q}^{r^{\\prime}\\times r}</span> from the left to get <span class="math">\\widetilde{\\mathbf{W}}=\\mathbf{W}\\cdot\\mathbf{C}</span> and <span class="math">\\widetilde{\\mathbf{Y}}=\\mathbf{Y}\\cdot\\mathbf{C}</span> and the new instance is <span class="math">(\\mathbf{H},\\mathbf{F},\\widetilde{\\mathbf{Y}})</span>. Observe that the norm of the witness grows. Also note that the soundness of this step depends on the dimension <span class="math">r^{\\prime}</span>: The larger <span class="math">r^{\\prime}</span> the shorter <span class="math">\\mathbf{C}</span> can be. Hence, we can pick binary <span class="math">\\mathbf{C}</span> (resp. roots of unity) to reduce norm growth at the expense of a wider <span class="math">\\widetilde{\\mathbf{W}}</span>.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4"><span class="math">b</span>-ary Decomposition.</h5>

    <p class="text-gray-300">The <span class="math">b</span>-ary decomposition protocol <span class="math">\\Pi^{b\\text{-decomp}}</span> reduces the witness norm <span class="math">\\beta</span> by <span class="math">b</span>-ary decomposing the matrix <span class="math">\\mathbf{W}</span> as <span class="math">\\sum_{i=0}^{\\ell-1}b^{i}\\mathbf{V}_{i}</span>, at the expense of increased width <span class="math">\\widetilde{r}</span> in the resulting <span class="math">\\widetilde{\\mathbf{W}}</span>. The prover needs to communicate <span class="math">\\mathbf{Y}_{i}=\\mathbf{H}\\mathbf{F}\\mathbf{V}_{i}</span>. The new witness is <span class="math">\\widetilde{\\mathbf{W}}=(\\mathbf{V}_{0},\\ldots,\\mathbf{V}_{\\ell-1})</span> and the resulting <span class="math">\\widetilde{\\mathbf{Y}}</span> is <span class="math">(\\mathbf{Y}_{0},\\ldots,\\mathbf{Y}_{\\ell-1})</span>. This protocol is used to counteract the norm growth in <span class="math">\\Pi^{\\mathsf{fold}}</span> and eliminate the correctness gap.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Norm-Check and Inner Product.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The norm-check protocol <span class="math">\\Pi^{\\mathsf{norm}}</span> ensures that the norm bound $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{W}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\beta<span class="math"> holds, at the expense of slightly extending the witness by adding columns and constraints (i.e. increasing the width </span>r<span class="math"> and height </span>n^{\\mathsf{out}}<span class="math"> of </span>\\mathbf{Y}<span class="math">). All above protocols (</span>\\Pi^{\\mathsf{split}},\\Pi^{\\mathsf{fold}},\\Pi^{b\\text{-decomp}}<span class="math">) negatively affect the norm of the <em>extracted</em> witness. The norm check counteracts this, and ensures that the norm of the extracted witness is at most </span>\\beta$. This eliminates the soundness gap.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The norm-check is implemented through the <em>inner product</em> protocol <span class="math">\\Pi^{\\mathsf{ip}}</span>, which proves that <span class="math">t=\\left\\langle\\mathbf{w},\\overline{\\mathbf{w}}\\right\\rangle</span>, where <span class="math">\\overline{\\mathbf{w}}</span> denotes the complex conjugate. Given the inner product <span class="math">t</span>, the canonical <span class="math">\\ell_{2}</span>-norm $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{w}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> of </span>\\mathbf{w}<span class="math"> satisfies </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{w}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}=\\mathsf{Trace}(t)<span class="math">, and thus, the norm-check can be implemented on top of the inner product by checking </span>\\mathsf{Trace}(t)\\leq\\beta^{2}<span class="math">. (This check is expanded to a matrix </span>\\mathbf{W}<span class="math"> column-wise; we leave details to Section 5.6.) To implement </span>\\Pi^{\\mathsf{ip}}<span class="math">, the prover encodes </span>\\mathbf{w}<span class="math"> as the coefficients of a polynomial </span>g(X)<span class="math">, and commits to the coefficients of the Laurent polynomial </span>L(X)=g(X)\\cdot\\tilde{g}(X^{-1})<span class="math">, whose constant term is </span>\\left\\langle\\mathbf{w},\\overline{\\mathbf{w}}\\right\\rangle<span class="math">. This reduces the problem to checking that </span>L<span class="math"> is computed correctly and has constant term </span>t<span class="math">, both of which can be expressed as relations captured by </span>\\Xi^{\\mathsf{fin}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Two issues remain: First, the norm of the coefficients of <span class="math">L(X)</span> is around <span class="math">\\beta^{2}</span> instead of <span class="math">\\beta</span>. To tackle this, we shrink the coefficients of <span class="math">L(X)</span> by immediately <span class="math">b</span>-ary decomposing (for suitable <span class="math">b</span>); we note that for technical reasons, we do not apply <span class="math">\\Pi^{b\\text{-decomp}}</span> modularly here. We add this decomposition to <span class="math">\\mathbf{W}</span>, as well as additional rows to <span class="math">\\mathbf{F}</span> for the new evaluation constraints of <span class="math">L(X)</span>. Second, checking that <span class="math">L</span> is computed correctly and has constant term <span class="math">t</span> by introducing more constraints translates to higher communication costs when handled naively, namely, when <span class="math">\\mathbf{H}</span> is always the identity. To tackle this, the parties run the batch protocol <span class="math">\\Pi^{\\mathsf{batch}}</span> to compress the newly added constraints with the existing ones. We explain this now.</p>

    <h5 id="sec-13" class="text-base font-semibold mt-4">Batch.</h5>

    <p class="text-gray-300">As noted above, during the <span class="math">\\Pi^{\\mathsf{norm}}</span> protocol (and also the complete version of <span class="math">\\Pi^{\\mathsf{split}}</span>), new constraints (i.e. rows) are added to <span class="math">\\mathbf{F}</span> and <span class="math">\\mathbf{Y}</span>, which increases the size of <span class="math">\\mathbf{Y}</span> and thus the size of the cross terms communicated in our atomic protocols. To counteract this, our principal relation includes the matrix <span class="math">\\mathbf{H}</span>, which is will be of the form</p>

    <p class="text-gray-300">\\[ \\mathbf{H}=\\begin{pmatrix}\\mathbf{I}_{\\overline{n}}&\\mathbf{0}_{\\overline{n}\\times\\underline{n}}\\\\ \\mathbf{H}_{0}&\\mathbf{H}_{\\underline{n}^{\\mathsf{out}}\\times\\underline{n}}\\end{pmatrix} \\]</p>

    <p class="text-gray-300">and which captures batch verification of the rows of <span class="math">\\mathbf{F}</span>: The identity block <span class="math">\\mathbf{I}_k</span> ensures the vSIS instance in <span class="math">\\mathbf{F}</span> is never compressed during batch verification (as this leads to technical problems), while the bottom rows <span class="math">\\underline{\\mathbf{H}} = (\\underline{\\mathbf{H}}_0, \\underline{\\mathbf{H}}_1)</span>, where <span class="math">\\underline{\\mathbf{H}}_0 = \\mathbf{0}_{\\underline{n^{\\mathrm{out}}} \\times \\underline{n}}</span>, capture the current state of batch verification of the remaining rows of <span class="math">\\mathbf{F}</span>.</p>

    <p class="text-gray-300">The batch protocol <span class="math">\\Pi^{\\mathrm{batch}}</span> reduces the height of <span class="math">\\mathbf{Y}</span> by randomly linearly combining its bottom rows by left-multiplying with <span class="math">\\mathbf{C} = \\begin{pmatrix} \\mathbf{I}_{\\Xi} &amp;amp; \\mathbf{0}_{\\overline{\\mathbf{N}} \\times \\underline{\\mathbf{N}}} \\\\ \\underline{\\mathbf{c}}_0^{\\dagger} &amp;amp; \\underline{\\mathbf{c}}_1^{\\dagger} \\end{pmatrix}</span> for a challenge vector <span class="math">\\mathbf{c} = (\\underline{\\mathbf{c}}_0, \\underline{\\mathbf{c}}_1)</span>. This yields <span class="math">\\widetilde{\\mathbf{H}} = \\mathbf{C} \\cdot \\mathbf{H}</span> and <span class="math">\\widetilde{\\mathbf{Y}} = \\mathbf{C} \\cdot \\mathbf{Y}</span> for the new instance, with <span class="math">\\mathbf{F}</span> and <span class="math">\\mathbf{W}</span> left unchanged. The protocol needs no prover communication, and has (almost) no effect on correctness and soundness gaps. Hence, it is applied whenever the height of <span class="math">\\mathbf{Y}</span> is not minimal.</p>

    <p class="text-gray-300">Composing the atomic protocols. In Section 6 we propose ways of composing the protocols with respect to asymptotic and concrete efficiency. The goal is to compose these atomic protocols to obtain succinct arguments for <span class="math">\\Xi^{\\mathrm{fin}}</span> without correctness and soundness gaps. We discuss the composition strategies, keeping track of parameter changes and communication costs to ensure that the security budget and norms remain within limits. Finally, an asymptotic complexity analysis shows how our proposed composition yields communication-efficient protocols while ensuring the hardness of the underlying cryptographic assumptions.</p>

    <p class="text-gray-300">One suggested composition, which yields an easy-to-analyse (asymptotically) composition, is:</p>

    <div class="my-4 text-center"><span class="math-block">(\\Pi^ {\\text {n o r m}} \\to \\Pi^ {\\text {b a t c h}} \\to \\Pi^ {b - d e c o m p} \\to \\Pi^ {\\text {s p l i t}} \\to \\Pi^ {\\text {f o l d}}) _ {i \\in [ \\mu ]} \\to \\Pi^ {\\text {f i n i s h}},</span></div>

    <p class="text-gray-300">where <span class="math">\\Pi^{\\mathrm{finish}}</span> introduces the trivial step of sending the witness in plain.</p>

    <h2 id="sec-14" class="text-2xl font-bold">2.3 Embedding <span class="math">\\mathbb{Z}</span>-Inner Products</h2>

    <p class="text-gray-300">Lattice-based succinct arguments such as those constructed in Section 5 typically support proving relations over a ring <span class="math">\\mathcal{R}</span> natively. However, in many applications, we would like to prove algebraic statements given over <span class="math">\\mathbb{Z}</span>, which motivates the question of how to reduce a statement over <span class="math">\\mathbb{Z}</span> to statements over <span class="math">\\mathcal{R}</span>, so that a proof of the latter implies a proof of the former. Specifically, we consider the task of proving that some (committed) vectors <span class="math">\\mathbf{x},\\mathbf{y}\\in \\mathbb{Z}^{m\\delta}</span> satisfies <span class="math">\\langle \\mathbf{x},\\mathbf{y}\\rangle = z</span> for some given <span class="math">z\\in \\mathbb{Z}</span>. This task is of particular interest since, for some applications (e.g. constructing verifiable delay function [LM23]) it is necessary for the prover to prove that the witness is not only short but in fact binary. More generally, the application might require the prover to show a proof for <span class="math">\\mathbf{x}\\in [a,b]^{m\\delta}</span> for some <span class="math">a,b\\in \\mathbb{Z}</span>, which is not immediately implied by a bounded-norm guarantee.</p>

    <p class="text-gray-300">To prove binariness, the basic idea is, for a witness <span class="math">\\mathbf{w} \\in \\mathbb{Z}^{m\\delta}</span>, to use the equivalence <span class="math">\\mathbf{w} \\in \\{0,1\\}^{m\\delta} \\iff \\langle \\mathbf{1}^{m\\delta} - \\mathbf{w}, \\mathbf{w} \\rangle_{\\mathbb{Z}} = 0</span> to reduce checking the binariness of <span class="math">\\mathbf{w}</span> to checking that some transformed witness vector over <span class="math">\\mathcal{R}</span> is short and satisfies some linear and inner-product relations, where <span class="math">\\mathcal{R} \\subset \\mathcal{O}_{\\mathcal{K}}</span> is of dimension <span class="math">\\delta \\mid \\varphi</span> when viewed as <span class="math">\\mathbb{Z}</span>-modules.</p>

    <p class="text-gray-300">Existing Embedding Methods. We are aware of three ways to embed <span class="math">\\mathbb{Z}</span>-inner products into <span class="math">\\mathcal{R}</span>-inner products in the literature, each with a significant drawback:</p>

    <p class="text-gray-300">(i) Naive embedding: Interpret each <span class="math">\\mathbb{Z}</span> element as an <span class="math">\\mathcal{R}</span> element via the inclusion <span class="math">\\mathbb{Z} \\subset \\mathcal{R}</span>, and interpret the <span class="math">\\mathbb{Z}</span>-inner product as an <span class="math">\\mathcal{R}</span>-inner product. This incurs a multiplicative overhead of <span class="math">\\delta</span> in terms of statement and witness sizes, which translate into overheads in prover and verifier computation, proof size, etc.</p>

    <p class="text-gray-300">(ii) Coefficient embedding: Divide the witness into blocks containing <span class="math">\\delta</span> <span class="math">\\mathbb{Z}</span>-elements, and encode each block as an <span class="math">\\mathcal{R}</span> element via the (inverse-)coefficient embedding <span class="math">\\psi^{-1}:\\mathbb{Z}^{m\\delta}\\to \\mathcal{R}^m</span>. For certain <span class="math">\\mathcal{R}</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\mathbf {x}, \\mathbf {y} \\rangle_ {\\mathbb {Z}} = \\operatorname {c t} \\left(\\left\\langle \\psi^ {- 1} (\\mathbf {x}), \\overline {{\\psi^ {- 1} (\\mathbf {y})}} \\right\\rangle_ {\\mathcal {R}}\\right)</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{ct}(\\cdot)</span> denotes the constant term of the coefficient embedding.</p>

    <p class="text-gray-300">This embedding has a convenient property that it is (somewhat) norm-preserving, i.e. <span class="math">\\mathbf{x}</span> is short if and only if <span class="math">\\psi^{-1}(\\mathbf{x})</span> is also short (in both coefficient and canonical embedding). However, this approach only works for <span class="math">\\mathbb{Z}[\\zeta_{2^{\\delta}}]</span>. This is problematic since the largest subtractive set over <span class="math">\\mathbb{Z}[\\zeta_{2^{\\delta}}]</span> is <span class="math">\\{0,1\\}</span>.</p>

    <p class="text-gray-300">8</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CRT embedding: Let the witness vectors be such that <span class="math">\\mathbf{x},\\mathbf{y}\\in\\mathbb{Z}_{p}^{m\\delta}</span> for some (typically small) prime <span class="math">p</span> which splits completely in <span class="math">\\mathcal{R}</span>. Divide the witness into blocks of <span class="math">\\delta</span> <span class="math">\\mathbb{Z}</span> elements, and encode each block as an <span class="math">\\mathcal{R}</span> element via the (inverse-)CRT embedding <span class="math">\\mathsf{CRT}_{p}^{-1}:\\mathbb{Z}_{p}^{m\\delta}\\to\\mathcal{R}_{p}^{m}</span>. It holds that</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=\\left\\langle\\mathbf{1}^{\\delta},\\mathsf{CRT}_{p}\\left(\\langle\\mathsf{CRT}_{p}^{-1}(\\mathbf{x}),\\mathsf{CRT}_{p}^{-1}(\\mathbf{y})\\rangle_{\\mathcal{R}}\\right)\\right\\rangle_{\\mathbb{Z}}\\text{ mod }p.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This approach is powerful in that it not only supports proving about <span class="math">\\mathbb{Z}_{p}</span>-inner products, but in fact about <span class="math">\\mathbb{Z}_{p}</span>-Hadamard products <span class="math">\\mathbf{x}\\odot\\mathbf{y}\\text{ mod }p</span>, which is more fine-grained. However, to turn a claim about <span class="math">\\mathbb{Z}_{p}</span>-inner products into a claim about <span class="math">\\mathbb{Z}</span>-inner products (without reduction modulo <span class="math">p</span>), we would additionally need to prove that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\langle\\mathbf{x},\\mathbf{y}\\rangle\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<p/2<span class="math">, so that the reduction modulo </span>p<span class="math"> has no effect. Since </span>\\mathsf{CRT}_{p}<span class="math"> does not respect the geometry of </span>\\mathbb{Z}<span class="math"> and </span>\\mathcal{R}<span class="math">, this approach usually requires the prover to commit to the witness vectors in both the </span>\\psi^{-1}(\\cdot)<span class="math"> and </span>\\mathsf{CRT}_{p}^{-1}(\\cdot)$ encodings, prove that the former is short, and prove that the two commitments are consistent. An issue here is that existing proofs of consistency between the two encodings (e.g. <em>[x10, x26]</em>) do not have a succinct verifier, i.e. they run in time linear in the witness size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In the following, we highlight how the aforementioned issues regarding the coefficient and CRT embeddings can be solved over certain (wide) range of rings.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Twisted Trace Maps.</h4>

    <p class="text-gray-300">In Section 7, we generalise the coefficient embedding technique over power-of-2 rings to a wide range of other rings. Recall from the above that, over <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> with a power-of-2 conductor, it holds that <span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=\\mathsf{ct}(\\langle\\psi^{-1}(\\mathbf{x}),\\overline{\\psi^{-1}(\\mathbf{y})}\\rangle_{\\mathcal{R}})</span>. In fact, the constant term function can be expressed as <span class="math">\\mathsf{ct}(\\cdot)=\\frac{1}{\\varphi}\\cdot\\mathsf{Trace}_{\\mathcal{K}/\\mathbb{Q}}(\\cdot)</span> where <span class="math">\\mathsf{Trace}_{\\mathcal{K}/\\mathbb{Q}}</span> denotes the field trace, and the power basis <span class="math">\\{\\,1,\\zeta,\\ldots,\\zeta^{\\varphi-1}\\,\\}</span> satisfies i.e. the power basis is orthogonal with respect to the field trace.</p>

    <p class="text-gray-300">The above point of view motivates the search for ideal lattices with <span class="math">\\mathbb{Z}</span>-bases orthogonal with respect to the field trace. This leads us to the literature of lattice constellations. In particular, we extract the following embedding method from <em>[x3]</em>: Over <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span> with prime conductor <span class="math">\\mathfrak{f}</span>, there exists an (efficiently computable) basis <span class="math">\\mathbf{b}^{+}\\in\\mathcal{O}_{\\mathcal{K}^{+}}^{\\varphi/2}</span> and a twist element <span class="math">\\alpha\\in\\mathcal{O}_{\\mathcal{K}^{+}}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=\\frac{1}{2\\mathfrak{f}}\\mathsf{Trace}_{\\mathcal{K}/\\mathbb{Q}}(\\alpha\\cdot\\langle\\psi^{-1}_{\\mathbf{b}^{+}}(\\mathbf{x}),\\overline{\\psi^{-1}_{\\mathbf{b}^{+}}(\\mathbf{y})}\\rangle_{\\mathcal{R}})</span></p>

    <p class="text-gray-300">where <span class="math">\\psi_{\\mathbf{b}^{+}}:\\mathcal{O}_{\\mathcal{K}^{+}}\\to\\mathbb{Z}^{\\varphi/2}</span> denotes the coefficient embedding with respect to the basis <span class="math">\\mathbf{b}^{+}</span>. Furthermore, adapting a result from the same work <em>[x3]</em> regarding tensor products of rings, we extract similar embedding methods based on twisted trace maps for rings <span class="math">\\mathcal{R}</span> of the form <span class="math">\\mathcal{R}=\\mathcal{O}_{\\mathcal{K}_{p\\delta}}\\otimes\\mathcal{O}_{\\mathcal{K}_{p_{0}}^{+}}\\otimes\\ldots\\otimes\\mathcal{O}_{\\mathcal{K}_{p_{k-1}}^{+}}</span>, where the subscripts of <span class="math">\\mathcal{K}</span> denote the conductors the respective factor rings and <span class="math">p_{0},\\ldots,p_{k-1}</span> are distinct odd primes. This captures power-of-2 rings as a special case. Notably, since such <span class="math">\\mathcal{R}</span> generally have non-prime-power conductors, they are compatible with the subtractive set for non-prime-power rings exposed in Section 4.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Succinct Proof for Consistency of CRT.</h4>

    <p class="text-gray-300">As highlighted earlier, the missing piece, required to harness the power of the CRT embedding for Hadamard and inner products, is a verifier-succinct argument for proving the consistency between the coefficient embedding and the CRT embedding. More precisely, we need a succinct argument for proving that two ring vectors <span class="math">\\mathbf{w},\\mathbf{w}^{\\prime}\\in\\mathcal{R}^{m}</span> satisfy</p>

    <p class="text-gray-300"><span class="math">\\psi(\\mathbf{w})=\\mathsf{CRT}_{p}(\\mathbf{w}^{\\prime})\\text{ mod }p.</span> (1)</p>

    <p class="text-gray-300">In Section 8, we present a protocol for performing this task over <span class="math">\\mathcal{R}=\\mathcal{O}_{\\mathcal{K}}</span> where the conductor <span class="math">\\mathfrak{f}</span> is <span class="math">w</span>-smooth, i.e. all its prime factors are at most some small integer <span class="math">w</span>, with proof size and verifier time scaling linearly in <span class="math">w\\log_{w}\\mathfrak{f}</span>. In other words, if <span class="math">w=O(1)</span>, then the complexity is logarithmic in <span class="math">\\mathfrak{f}</span>.</p>

    <p class="text-gray-300">Underlying our protocol is the observation that, if the conductor <span class="math">\\mathfrak{f}</span> is <span class="math">w</span>-smooth, then the map <span class="math">\\mathsf{CRT}_{p}^{-1}\\circ\\psi</span> can be expressed as the composition of <span class="math">t\\leq O(\\log\\mathfrak{f})</span> maps, each being a linear combination of <span class="math">h\\leq O(\\log\\mathfrak{f})</span> automorphisms from <span class="math">\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})</span> with coefficients lying in <span class="math">\\mathcal{R}</span>. This means that, to succinctly prove that <span class="math">\\mathbf{w}^{\\prime}=\\mathsf{CRT}_{p}^{-1}(\\psi(\\mathbf{w}))\\text{ mod }p</span>, it suffices to design a succinct argument for proving automorphism relations.</p>

    <p class="text-gray-300">Motivated by the above, we present a succinct reduction of knowledge from checking <span class="math">\\alpha(\\mathbf{w})=\\mathbf{w}^{\\prime}</span> to checking that <span class="math">(\\mathbf{w},\\mathbf{w}^{\\prime})</span> satisfies some linear relations. We obtain a succinct argument for proving Eq. (1).</p>

    <p class="text-gray-300">3 Preliminaries</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{N} = \\{1,2,\\ldots \\}</span> denotes natural numbers and <span class="math">\\lambda \\in \\mathbb{N}</span> be the security parameter. For <span class="math">n\\in \\mathbb{N}</span>, we write <span class="math">[n]\\coloneqq \\{0,\\dots ,n - 1\\}</span> counting from 0. For multidimensional ranges, we use the shorthand <span class="math">(i,j,k)\\in [n,m,\\ell ]</span> for <span class="math">i\\in [n]</span>, <span class="math">j\\in [m]</span>, and <span class="math">k\\in [\\ell ]</span>.</p>

    <p class="text-gray-300">Throughout this work, we let <span class="math">\\mathcal{K} = \\mathbb{Q}(\\zeta)</span> be a cyclotomic field with conductor <span class="math">\\mathfrak{f}</span> of degree <span class="math">\\varphi = \\varphi (\\mathfrak{f})</span>, where <span class="math">\\zeta</span> is a root of unity of order <span class="math">\\mathfrak{f}</span> and <span class="math">\\varphi</span> is Euler's totient function, and <span class="math">\\mathcal{O}_{\\mathcal{K}} = \\mathbb{Z}[\\zeta ]</span> be its ring of integers. We will also consider the maximal real subfield <span class="math">\\mathcal{K}^{+} = \\mathbb{Q}(\\zeta +\\zeta^{-1})</span> of <span class="math">\\mathcal{K}</span> and its ring of integers <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}} = \\mathbb{Z}[\\zeta +\\zeta^{-1}]</span>. In contexts where we refer to multiple cyclotomic fields with different conductors <span class="math">(\\mathfrak{f}_i)_{i\\in [k]}</span>, we write <span class="math">\\mathcal{K}_{\\mathfrak{f}_i}</span> for <span class="math">i\\in [k]</span> to emphasise the conductors. We will usually use <span class="math">\\mathcal{R}\\subseteq \\mathcal{O}_{\\mathcal{K}}</span> to denote a subring which has dimension <span class="math">\\delta</span> when viewed as a <span class="math">\\mathbb{Z}</span>-module.</p>

    <p class="text-gray-300">For a modulus <span class="math">q \\in \\mathbb{N}</span>, we write <span class="math">\\mathcal{R}_q \\coloneqq \\mathcal{R} / q\\mathcal{R}</span>. We denote by <span class="math">\\mathcal{R}^\\times</span> and <span class="math">\\mathcal{R}_q^\\times</span> the sets of units in <span class="math">\\mathcal{R}</span> and <span class="math">\\mathcal{R}_q</span> respectively. We endow <span class="math">\\mathcal{R}</span> with two geometries via the coefficient embedding <span class="math">\\psi_{\\mathbf{b}}: \\mathcal{R} \\to \\mathbb{Z}^{\\delta}</span> (for a given basis <span class="math">\\mathbf{b}</span>) and the canonical embedding <span class="math">\\sigma: \\mathcal{K} \\to \\mathbb{C}^{\\varphi}</span> (of <span class="math">\\mathcal{K}</span>). Specifically, for a given <span class="math">\\mathbb{Z}</span>-basis <span class="math">\\mathbf{b} = (b_i)_{i \\in [\\delta]}</span> of <span class="math">\\mathcal{R}</span> and an element <span class="math">x = \\sum_{i \\in [\\delta]} x_i b_i \\in \\mathcal{R}</span>, we write</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {\\mathbf {b}} (x) := \\left(x _ {i}\\right) _ {i \\in [ \\delta ]}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma (x) := \\left(\\sigma_ {j} (x)\\right) _ {j \\in [ \\varphi ]}</span></div>

    <p class="text-gray-300">where <span class="math">\\sigma_{j}\\in \\mathsf{Gal}(\\mathcal{K} / \\mathbb{Q})</span>. Note that we define <span class="math">\\sigma (x)</span> by treating <span class="math">x\\in \\mathcal{K}</span> in order to avoid discussing the canonical embedding of subfields of <span class="math">\\mathcal{K}</span>. If <span class="math">\\mathcal{R} = \\mathcal{O}_{\\mathcal{K}}</span> and is the standard powerful basis, we may omit <span class="math">\\mathbf{b}</span> from the subscript of <span class="math">\\psi_{\\mathbf{b}}</span>. We define powerful basis as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {b} = (1, \\zeta , \\dots , \\zeta^ {\\varphi - 1})</span></div>

    <p class="text-gray-300">for prime-power conductor <span class="math">\\mathfrak{f}</span>. The basis generalises to the composite conductor <span class="math">\\mathfrak{f} = \\prod_{i\\in [k]}\\mathfrak{f}_i^{e_i}</span> for prime <span class="math">\\mathfrak{f}_i</span> via tensor product,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {b} = \\bigotimes_ {i \\in [ k ]} \\left(1, \\zeta_ {\\mathrm {f} _ {i}}, \\dots , \\zeta_ {\\mathrm {f} _ {i}} ^ {\\varphi (\\mathrm {f} _ {i}) - 1}\\right).</span></div>

    <p class="text-gray-300">We extend the notation of <span class="math">\\psi_{\\mathbf{b}}</span> and <span class="math">\\sigma</span> naturally to vectors, i.e. if <span class="math">\\mathbf{x} = (x_i)_{i\\in [m]}\\in \\mathcal{R}^m</span>, then</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_ {\\mathbf {b}} (\\mathbf {x}) := \\left(\\psi_ {\\mathbf {b}} \\left(x _ {i}\\right)\\right) _ {i \\in [ \\delta ]}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma (\\mathbf {x}) := \\left(\\sigma_ {j} \\left(x _ {i}\\right)\\right) _ {j \\in [ \\varphi ]}</span></div>

    <p class="text-gray-300">are defined as concatenations.</p>

    <p class="text-gray-300">For any <span class="math">p \\in \\mathbb{N}</span>, we consider the balanced representation of <span class="math">\\mathbb{Z}_p</span>, i.e. elements are represented by <span class="math">[-p/2, p/2) \\cap \\mathbb{Z}</span>. When considering the quotient ring <span class="math">\\mathcal{R}_p \\coloneqq \\mathcal{R}/p\\mathcal{R}</span> where <span class="math">\\mathcal{R}</span> has <span class="math">\\mathbb{Z}</span>-basis <span class="math">\\mathbf{b}</span>, we assume that an element <span class="math">x \\in \\mathcal{R}_p</span> is represented by <span class="math">\\psi_{\\mathbf{b}}(x) \\in ([-p/2, p/2) \\cap \\mathbb{Z})^\\varphi</span>. As such, for any <span class="math">x \\in \\mathcal{R}</span>, we abuse the notation <span class="math">x \\in \\mathcal{R}_p</span> to mean that <span class="math">\\psi(x) \\in ([-p/2, p/2) \\cap \\mathbb{Z})^\\varphi</span>. The above extends naturally to vectors over <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">To distinguish between <span class="math">\\mathbb{Z}</span>-inner products and <span class="math">\\mathcal{R}</span>-inner products, we write <span class="math">\\langle \\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}} = \\sum_{i\\in [m]}x_iy_i</span> or <span class="math">\\langle \\mathbf{x},\\mathbf{y}\\rangle_{\\mathcal{R}} = \\sum_{i\\in [m]}x_iy_i</span> depending on whether <span class="math">\\mathbf{x},\\mathbf{y}\\in \\mathbb{Z}^m</span> or <span class="math">\\mathbf{x},\\mathbf{y}\\in \\mathcal{R}^m</span>. Note that <span class="math">\\langle \\mathbf{x},\\mathbf{y}\\rangle_{\\mathcal{R}}</span> is defined without complex conjugation.</p>

    <p class="text-gray-300">For any Galois extension <span class="math">\\mathcal{M} / \\mathcal{L}</span>, the field trace can be computed as <span class="math">\\operatorname{Trace}_{\\mathcal{M} / \\mathcal{L}}: \\mathcal{K} \\to \\mathcal{L}</span>, <span class="math">\\operatorname{Trace}_{\\mathcal{M} / \\mathcal{L}}(x) := \\sum_{\\sigma_j \\in \\operatorname{Gal}(\\mathcal{K} / \\mathcal{L})} \\sigma_j(x)</span>. When <span class="math">\\mathcal{L} = \\mathbb{Q}</span>, we drop the subscript and write <span class="math">\\operatorname{Trace} = \\operatorname{Trace}_{\\mathcal{M} / \\mathbb{Q}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The coefficient <span class="math">\\ell_p</span>-norm and canonical <span class="math">\\ell_p</span>-norm of a vector <span class="math">\\mathbf{x} \\in \\mathcal{R}^m</span> is denoted by $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\mathbf{x}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_p<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{x}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_p<span class="math"> respectively. We will mostly use </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math">. For matrices, the norm is defined as </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{M} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vec}(\\mathbf{M}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> for all norms, where </span>\\mathrm{vec}(\\cdot)<span class="math"> denotes vectorisation, i.e. rearranging the elements of the matrix into a vector. In the context of 2-norms, such norm is called &quot;Frobenius norm&quot;. The ring expansion factor of </span>\\mathcal{R}<span class="math"> w.r.t. the coefficient </span>\\ell_{\\infty}<span class="math">-norm is defined as </span>\\gamma_{\\mathcal{R}} := \\max_{a,b \\in \\mathcal{R}} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(a \\cdot b) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} / (\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(a) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(b) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty})<span class="math">. Assuming balanced representation, for any </span>x \\in \\mathcal{R}_p<span class="math">, we have </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq p/2<span class="math">. Note that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{x}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2 = \\mathrm{Trace}(\\mathbf{x}^2 \\overline{\\mathbf{x}})<span class="math">, where </span>\\overline{\\cdot}$ denotes the complex conjugate.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For horizontal and vertical concatenation of matrices, we write respectively:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\mathbf {M} _ {i}\\right) _ {i \\in [ \\ell ]}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\overbrace {\\mathbf {M} _ {i}} _ {i \\in [ \\ell ]} \\quad \\left(\\text {or} \\sum_ {i \\in [ \\ell ]} \\mathbf {e} _ {i} \\otimes \\mathbf {M} _ {i}\\right).</span></div>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">We state an equivalent formulation of the vanishing short integer solution (vSIS) assumption [CLM23], which has a simpler description and better aligns with the notation adopted in this work. For more discussion on vSIS, we refer to Appendix A.2.</p>

    <p class="text-gray-300"><strong>Definition 1 (vSIS Assumption (adapted from [CLM23])).</strong> Let <span class="math">\\mathsf{params} = (\\mathcal{R}, q, \\beta, \\chi)</span> be parametrised by <span class="math">\\lambda</span>, where <span class="math">\\mathcal{R}</span> is a ring, <span class="math">q \\in \\mathbb{N}</span> a modulus, <span class="math">\\beta &amp;gt; 0</span> a norm bound, and <span class="math">\\chi</span> a distribution over <span class="math">\\mathcal{R}_q^{n \\times \\otimes_{i \\in [\\mu]} d_i}</span> for some dimensions <span class="math">n, d_0, \\ldots, d_{\\mu-1}, \\mu \\in \\mathbb{N}</span>. The <span class="math">\\mathsf{vSIS}_{\\mathsf{params}}</span> assumption states that, for any PPT adversary <span class="math">\\mathcal{A}</span>, the advantage function satisfies</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Adv}_{\\mathsf{params},\\mathcal{A}}^{\\mathsf{vSIS}}(\\lambda) := \\Pr \\left[ \\begin{array}{l l} \\mathbf{F}\\mathbf{w} = \\mathbf{0} \\bmod q &amp; \\mathbf{F} \\leftarrow \\updownarrow \\chi \\\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{w}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\beta &amp; \\mathbf{w} \\leftarrow \\mathcal{A}(\\mathbf{F}) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For simplicity, in this work, we will consider the setting where the block sizes <span class="math">d_0,\\ldots ,d_{\\mu -1}</span> are identically set to some <span class="math">d\\in \\mathbb{N}</span>, so that <span class="math">\\mathbf{F}</span> can be factored into <span class="math">\\mathbf{F} = \\mathbf{F}_{\\mu -1}\\bullet \\dots \\bullet \\mathbf{F}_0</span> with <span class="math">\\mathbf{F}_i\\in \\mathcal{R}_q^{n\\times d}</span>, where <span class="math">\\bullet</span> denotes the row-wise tensor product.</p>

    <p class="text-gray-300">In this paper we consider ternary relations <span class="math">\\Xi \\subseteq \\{0,1\\}^{<em>} \\times \\{0,1\\}^{</em>} \\times \\{0,1\\}^{<em>}</span>, where a tuple <span class="math">(\\mathsf{pp}, \\mathsf{stmt}, \\mathsf{wit}) \\in \\Xi</span> consists of public parameters <span class="math">\\mathsf{pp}</span>, statement <span class="math">\\mathsf{stmt}</span> and witness <span class="math">\\mathsf{wit}</span>. For presentation, we omit including <span class="math">\\mathsf{pp}</span> when it is known from the context. We consider a modified and simplified definition of a reduction of knowledge [KP23] for the following reasons: All of our protocols are </em>public coin<em> and </em>(coordinate-wise)<em> </em>special sound<em> [FMN23] or similar. Thus, public reducibility is automatic and we have (super-constant) sequential composition results due to known (tree) black-box extractors, whereas composition in [KP23] is limited a constant number of protocols. Lastly, we define a </em>relaxed* knowledge soundness notion which is not present in [KP23]. For lack of space, we provide a condensed overview of reductions of knowledge. See Appendix A.3 for details.</p>

    <p class="text-gray-300"><strong>Definition 2 (Reduction of Knowledge (modified)).</strong> Let <span class="math">\\Xi_0, \\Xi_1</span> be ternary relations. A reduction of knowledge (RoK) <span class="math">\\Pi</span> from <span class="math">\\Xi_0</span> to <span class="math">\\Xi_1</span>, short <span class="math">\\Pi \\colon \\Xi_0 \\to \\Xi_1</span>, is defined by two PPT algorithms <span class="math">\\Pi = (\\mathcal{P}, \\mathcal{V})</span>, the prover <span class="math">\\mathcal{P}</span>, and the verifier <span class="math">\\mathcal{V}</span>, with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{pp}, \\mathsf{stmt}_1, \\mathsf{wit}_1) \\to (\\mathsf{stmt}_2, \\mathsf{wit}_2)</span>: Interactively reduce the input statement <span class="math">(\\mathsf{pp}, \\mathsf{stmt}, \\mathsf{wit}) \\in \\Xi_0</span> to a new statement <span class="math">(\\underline{\\mathsf{pp}}, \\overline{\\mathsf{stmt}}, \\overline{\\mathsf{wit}}) \\in \\Xi_1</span> or <span class="math">\\perp</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pp}, \\mathsf{stmt}) \\to \\mathsf{stmt}</span>: Interactively reduce the task of checking the input statement <span class="math">(\\mathsf{pp}, \\mathsf{stmt})</span> w.r.t <span class="math">\\Xi_0</span> to checking a new statement <span class="math">(\\mathsf{pp}, \\overline{\\mathsf{stmt}})</span> w.r.t. <span class="math">\\Xi_1</span>.</li>

    </ul>

    <p class="text-gray-300">A RoK <span class="math">\\Pi</span> is <em>correct</em>, if for any honest protocol run (with correct inputs), the prover outputs a witness for the reduced statement (which the verifier outputs). A RoK <span class="math">\\Pi</span> is <em>relaxed knowledge sound</em> from <span class="math">\\Xi_0^{\\mathsf{KS}}</span> to <span class="math">\\Xi_1^{\\mathsf{KS}}</span> with knowledge error <span class="math">\\kappa(\\mathsf{pp}, \\mathsf{stmt})</span> if there is a <em>black-box</em> expected polynomial-time extractor <span class="math">\\mathcal{E}</span>, which succeeds with probability <span class="math">\\epsilon - \\kappa(\\mathsf{pp}, \\mathsf{stmt})</span> if the malicious prover outputs a valid witness for the reduced statement with probability <span class="math">\\epsilon</span> (on verifier's input <span class="math">(\\mathsf{pp}, \\mathsf{stmt})</span>).</p>

    <p class="text-gray-300"><strong>Lemma 1 (Relations between norms (derived from [LPR13] and [DPSZ12, DPSZ12])).</strong> Let <span class="math">x \\in \\mathcal{K} = \\mathbb{Q}(\\zeta_{\\mathfrak{f}})</span> and <span class="math">\\varphi = \\varphi(\\mathfrak{f})</span>. Let <span class="math">\\bar{\\mathfrak{f}}</span> be <span class="math">\\mathfrak{f}</span> if <span class="math">\\mathfrak{f}</span> is odd and <span class="math">\\mathfrak{f}/2</span> if it is even; let <span class="math">\\mathsf{rad}(\\mathfrak{f})</span> be the radical (i.e. the product of all primes dividing <span class="math">\\mathfrak{f}</span>). Let <span class="math">\\sigma \\colon \\mathcal{K} \\to \\mathbb{R}^{\\varphi}</span> be the canonical embedding and let <span class="math">\\psi \\colon \\mathcal{K} \\to \\mathbb{R}^{\\varphi}</span> be the coefficient embedding w.r.t. the powerful basis. Then we have</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(i) $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\sqrt{\\frac{\\mathsf{rad}(\\mathfrak{f})}{\\mathfrak{f}}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2$</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(iii) $\\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\sigma (x)\\</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\infty}\\leq \\varphi \\cdot \\</td>

            <td class="px-3 py-2 border-b border-gray-700">\\psi (x)\\</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\infty}$</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">(iv)</span> $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq \\mathfrak{c}_{\\mathbf{rad}(\\mathfrak{f})}\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> where </span>\\mathfrak{c}_j<span class="math"> is a constant such that </span>\\mathfrak{c}_{\\mathbf{rad}(\\mathfrak{f})}\\leq (4 / \\pi)^{\\ell}<span class="math">, where </span>\\ell<span class="math"> is the number of different odd prime factors in </span>\\mathbf{rad}(\\mathfrak{f})<span class="math">. Moreover, </span>\\mathfrak{c}_{f_1\\cdot f_2} = \\mathfrak{c}_{f_1}\\cdot \\mathfrak{c}_{f_2}<span class="math"> for coprime </span>f_{1}<span class="math"> and </span>f_{2}<span class="math"> and </span>\\mathfrak{c}_{2^e} = 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that the constants <span class="math">\\mathfrak{c}_{\\mathfrak{f}}</span> are quite small in practice: For all <span class="math">\\mathfrak{f} \\leq 255254</span> we have <span class="math">\\mathfrak{c}_{\\mathfrak{f}} \\leq (4 / \\pi)^5 \\leq 3.35</span>. Because <span class="math">\\ell</span> is the number of odd prime factors in <span class="math">\\mathfrak{f}</span>, we find that, up to <span class="math">\\mathfrak{f} \\leq 1154 = 3 \\cdot 5 \\cdot 7 \\cdot 11 - 1</span> we have <span class="math">\\mathfrak{c}_{\\mathfrak{f}} \\leq (4 / \\pi)^3 \\leq 2.065</span>; and up to <span class="math">\\mathfrak{f} \\leq 15014 = 3 \\cdot 5 \\cdot 7 \\cdot 11 \\cdot 13 - 1</span> we have <span class="math">\\mathfrak{c}_{\\mathfrak{f}} \\leq (4 / \\pi)^4 \\leq 2.63</span>; and so on.</p>

    <p class="text-gray-300">Proof. The relations follow essentially from bounds in [LPR13] and [DPSZ12]. The crucial piece is the powerful basis <span class="math">\\mathbf{b}</span> and the canonica embedding matrix CRT, which is defined as</p>

    <div class="my-4 text-center"><span class="math-block">\\sigma (\\mathbf {b}) := \\left(\\sigma_ {1} (\\mathbf {b}), \\dots , \\sigma_ {\\varphi} (\\mathbf {b})\\right)</span></div>

    <p class="text-gray-300">i.e. the columns are different canonical embeddings. In this basis, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\forall x \\in \\mathcal {K}: \\quad \\sigma (x) = \\sigma (\\mathbf {b}) \\cdot \\psi (x)</span></div>

    <p class="text-gray-300">Moreover, by [LPR13, Lemma 4.3], we have for the singular values of <span class="math">\\sigma(\\mathbf{b})</span></p>

    <div class="my-4 text-center"><span class="math-block">s _ {m i n} (\\sigma (\\mathbf {b})) = \\sqrt {\\mathfrak {f} / \\operatorname {r a d} (\\mathfrak {f})} \\quad \\text {and} \\quad s _ {m a x} (\\sigma (\\mathbf {b})) = \\sqrt {\\mathfrak {f}}</span></div>

    <p class="text-gray-300">where <span class="math">\\tilde{\\mathfrak{f}} = \\mathfrak{f}</span> if odd, else <span class="math">\\mathfrak{f} / 2</span>. With this, we can prove the claims.</p>

    <p class="text-gray-300">The first point follows from</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} ^ {2} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) \\psi (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} ^ {2} \\geq s _ {m i n} (\\sigma (\\mathbf {b})) ^ {2} \\cdot \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} ^ {2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where taking the square root yields the claim.<span class="math">^{12}</span></p>

    <p class="text-gray-300">The second point is immediate from</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) \\psi_ {2} (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\leq s _ {\\max } (\\sigma (\\mathbf {b})) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">by bounds for the operator norm of <span class="math">\\sigma (\\mathbf{b})</span>.</p>

    <p class="text-gray-300">The third point follows from</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) \\psi (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {o p}, \\infty} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The operator norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{b})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op},\\infty}<span class="math"> w.r.t. </span>\\infty<span class="math">-norm is row-wise 1-norm of </span>\\sigma (\\mathbf{b})<span class="math">, which is yields exactly </span>\\varphi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The last point is a consequence of [DPSZ12, Lemma 4 and 5], which applied to</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) ^ {- 1} \\sigma (\\mathbf {b}) \\psi (x) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {b}) ^ {- 1} \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\mathrm {o p}, \\infty} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">shows that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{b})^{-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathrm{op},\\infty}\\leq \\mathfrak{c}_{\\mathfrak{f}}<span class="math"> for a family of constants which satisfies </span>\\mathfrak{c}_{p^e} = \\mathfrak{c}_p<span class="math"> for prime powers </span>p\\neq 2<span class="math"> (and </span>\\mathfrak{c}_{2^e} = 1<span class="math">), and </span>\\mathfrak{c}_{mn}\\leq \\mathfrak{c}_m\\mathfrak{c}_n<span class="math"> for coprime </span>m,n$, and</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak {c} _ {p} = \\frac {1}{p} \\sum_ {p = 1} ^ {r} 2 \\sin (r \\pi / p) = \\frac {- 2 \\cdot \\sin (\\pi / p)}{p \\cdot (1 - \\cos (\\pi / p))} \\leq 4 / \\pi</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">From this we deduce that given <span class="math">\\ell</span> odd prime factors in <span class="math">\\mathfrak{f}</span>, we have <span class="math">\\mathfrak{c}_{\\mathfrak{f}} \\leq (4 / \\pi)^{\\ell}</span>. (The claim <span class="math">\\mathfrak{c}_{mn} \\leq \\mathfrak{c}_m \\mathfrak{c}_n</span> for coprime <span class="math">m, n</span> is not shown explicitly in [DPSZ12], but is a direct consequence of the tensor decomposition of CRT and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A} \\otimes \\mathbf{B} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{B} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> for any complex matrices </span>\\mathbf{A}, \\mathbf{B}<span class="math">.) </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The following corollary is immediate from Lemma 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Corollary 1. Let <span class="math">x \\in \\mathcal{K}</span>. It holds that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{\\mathfrak{f} \\varphi} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(x) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\mathbf{x}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{x}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{12}</span>We note that the inequality follows by expressing terms as inner products, using SVD decomposition to cancel <span class="math">U</span> in <span class="math">U\\Sigma V^{<em>}</span>, and then obvious inequality for a diagonal <span class="math">D \\geq 0</span> and <span class="math">\\langle Dz, Dz \\rangle</span> with <span class="math">z = V^{</em>}\\psi(x)</span>, and finally using that <span class="math">V^{*}</span> is unitary, so can be removed in the norm.</p>

    <p class="text-gray-300">4 Subtractive Sets</p>

    <p class="text-gray-300">A subtractive set <span class="math">S</span> over a ring <span class="math">\\mathcal{R}</span> is such that <span class="math">c-c^{\\prime}</span> is a unit for any distinct <span class="math">c,c^{\\prime}\\in S</span>. While the notion is connected to the study of Euclidean number fields <em>[x16]</em>, it also found applications in lattice-based cryptography in the contexts of argument systems and secret sharing <em>[x1]</em>. For a cyclotomic ring <span class="math">\\mathcal{R}</span> with prime-power conductor <span class="math">\\mathfrak{f}=p^{k}</span>, an explicit construction of upper-bound-matching cardinality <span class="math">p</span> is known. For other cyclotomic rings and their subrings, however, not much seem to be explicitly studied. In this section, we construct subtractive sets over non-prime-power cyclotomic rings, as well as <em>real</em> cyclotomic rings.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 3 (Subtractive Set).</h6>

    <p class="text-gray-300">We say that a set <span class="math">S\\subseteq\\mathcal{R}</span> is subtractive over <span class="math">\\mathcal{R}</span> if <span class="math">c-c^{\\prime}\\in\\mathcal{R}^{\\times}</span> for any distinct <span class="math">c,c^{\\prime}\\in S</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">While <em>[x1]</em> measured the quality of a subtractive set over cyclotomic rings in terms of the <span class="math">\\ell_{\\infty}</span>-norm over the coefficient embedding, in this work, we will instead work with the <span class="math">\\ell_{\\infty}</span>-norm over the canonical embedding for compatibility with Section 5 via the inequality $\\forall\\ c,x\\in\\mathcal{R},\\ \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(c\\cdot x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(c\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math">. We measure the quality of a subtractive set by its cardinality, expansion factor </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}<span class="math">, and inverse-expansion factor </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}$, with the latter two defined below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 4 ((Inverse-)Expansion Factor of Subtractive Set).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">S\\subseteq\\mathcal{R}</span> be subtractive over <span class="math">\\mathcal{R}</span>. The expansion and inverse-expansion factors of <span class="math">S</span> are $\\gamma_{S}\\coloneqq\\max_{c\\in S,t\\in\\mathcal{R},t\\neq 0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t\\cdot c\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>\\theta_{S}\\coloneqq\\max_{c,c^{\\prime}\\in S,c\\neq c^{\\prime},t\\in\\mathcal{R},,t\\neq 0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t\\frac{1}{c-c^{\\prime}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">/\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ respectively.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To distiguish between canonical 2-norm and coefficient <span class="math">\\infty</span>-norm, we use $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}<span class="math">, </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}<span class="math">, </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}<span class="math">. Recall that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(cy\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(c\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(y\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> for </span>x,y\\in\\mathcal{R}<span class="math">, and thus </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(c\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math"> is (a bound on) the expansion factor of </span>x$ w.r.t. canonical (2-)norm. The following lemma often is handy for analysing inverse-expansion factors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-21" class="text-base font-medium mt-4">Lemma 2.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">K=\\mathbb{Q}(\\zeta)</span> with <span class="math">\\zeta</span> a primitive <span class="math">\\mathfrak{f}</span>-th root of unity such that <span class="math">\\mathfrak{f}\\geq 4</span>. It holds that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\frac{1}{1-\\zeta}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{\\mathfrak{f}}{4\\sqrt{2}}<span class="math">. Furthermore, if </span>\\zeta<span class="math"> is a (not necessarily primitive) </span>k<span class="math">-th root of unity, i.e. </span>\\zeta^{k}=1<span class="math"> and </span>k\\in\\mathbb{N}<span class="math"> is minimal, then </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\frac{1}{1-\\zeta^{i}}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{k}{4\\sqrt{2}}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the definition of $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\cdot\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, we need to upper bound </span>\\max_{\\sigma_{j}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma_{j}\\left(\\frac{1}{1-\\zeta}\\right)\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max_{\\sigma_{j}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{1-\\sigma_{j}(\\zeta)}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, where </span>\\sigma_{j}<span class="math"> ranges from </span>\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})<span class="math">. Since </span>\\sigma_{j}(\\zeta)<span class="math"> ranges over all primitive </span>\\mathfrak{f}<span class="math">-th root of unity, this is the same as </span>\\max_{j\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{1-\\zeta^{j}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\max_{j\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}}\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{1-e^{j\\cdot 2\\pi i/\\mathfrak{f}}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Thus, it suffices to lower-bound </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1-e^{j\\cdot 2\\pi i/\\mathfrak{f}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> over </span>j\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}<span class="math">. Geometrically, </span>e^{j\\cdot 2\\pi i/\\mathfrak{f}}<span class="math"> are points on the unit circle in the complex plane with angles incremented by </span>2\\pi j/\\mathfrak{f}<span class="math">. Thus, the value is approximately </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1-e^{j\\cdot 2\\pi 1/\\mathfrak{f}}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2\\pi j/\\mathfrak{f}<span class="math"> for small </span>2\\pi j/\\mathfrak{f}<span class="math">. For an explicit bound, observe that for </span>\\alpha\\leq\\frac{1}{4}<span class="math"> we have </span>\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1-e^{\\alpha 2\\pi i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=2\\cdot\\sin(\\frac{2\\pi\\alpha}{2})\\geq\\alpha\\cdot 4\\sqrt{2}<span class="math">. Setting </span>\\alpha=\\frac{1}{4}<span class="math"> proves the claim. Observe that the above argument only depends on the multiplicative order of </span>\\zeta<span class="math">, thus, the claim </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\frac{1}{1-\\zeta}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\frac{k}{2}<span class="math"> follows for any (not necessarily primitive) </span>k<span class="math">-th root of unity </span>\\zeta$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">###### Corollary 2 (Field expansion factor $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\mathcal{K}}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathcal{K}=\\mathbb{Q}(\\zeta)</span> with <span class="math">\\zeta</span> a primitive <span class="math">\\mathfrak{f}</span>-th root of unity, Let <span class="math">S\\subseteq K</span> be the powerful basis w.r.t. <span class="math">\\zeta</span> of <span class="math">K</span>. Then for all <span class="math">x,y\\in\\mathcal{K}</span>, we have $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\mathcal{K}}\\leq\\mathfrak{c}_{\\mathsf{rad}(\\mathfrak{f})}\\varphi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$ because</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(xy\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\mathfrak{c}_{\\mathsf{rad}(\\mathfrak{f})}\\varphi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(y\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-23" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The claim follows immediately from Lemma 1, because</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(xy\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\mathfrak{c}_{\\mathsf{rad}(\\mathfrak{f})}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(xy\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\mathfrak{c}_{\\mathsf{rad}(\\mathfrak{f})}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(y\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\mathfrak{c}_{\\mathsf{rad}(\\mathfrak{f})}\\varphi\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(y\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">holds for <span class="math">x,y\\in\\mathcal{K}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">We recall the subtractive set for prime-power cyclotomics [Len76, AL21] with conductor <span class="math">\\mathfrak{f} = p^k</span> and analyse its (inverse-)expansion factor in canonical <span class="math">\\ell_2</span>-norm. Although we are interested mostly in <span class="math">p \\gg 2</span>, the result also holds for <span class="math">p = 2</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 1. Let <span class="math">\\mathfrak{f} = p^k &amp;gt; 4</span> for some prime <span class="math">p</span>. The set <span class="math">S := \\{\\mu_0, \\ldots, \\mu_{p-1}\\} \\subseteq_p \\mathcal{O}_{\\mathcal{K}}</span> is subtractive, where <span class="math">\\mu_i = (\\zeta^i - 1) / (\\zeta - 1)</span>. Further, $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2, S} \\leq p<span class="math">, </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2, S} \\leq \\frac{1}{2\\sqrt{2}}<span class="math">, and </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty, S} \\leq \\varphi<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty, S} \\leq \\varphi<span class="math">, where </span>\\varphi = \\varphi(\\mathfrak{f})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof. Let <span class="math">i &amp;lt; j \\in [p]</span>. Observe that <span class="math">\\mu_j - \\mu_i = \\zeta^i + \\zeta^{i+1} + \\ldots + \\zeta^{j-1} = \\zeta^i \\cdot \\frac{\\zeta^{j-i-1}}{\\zeta-1}</span> which is clearly a unit in <span class="math">\\mathcal{R}</span>, hence <span class="math">S</span> is subtractive.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the canonical 2-norm expansion factor, note that <span class="math">\\mu_{i}</span> is a sum of <span class="math">i</span> roots of unity and <span class="math">i &amp;lt; p</span>. Therefore $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2,S} = \\max_{i\\in [p]}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mu_i)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty &lt; p$. For the inverse-expansion factor, observe that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left(\\frac {1}{\\mu_ {j} - \\mu_ {i}}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} = \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left(\\zeta^ {- i} \\cdot \\frac {\\zeta - 1}{\\zeta^ {j - i} - 1}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\zeta - 1) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\cdot \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left(\\frac {1}{\\zeta^ {j - i} - 1}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq 2 \\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left(\\frac {1}{\\zeta^ {j - i} - 1}\\right) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\frac {\\mathfrak {f}}{2 \\sqrt {2}},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where the last inequality follows from Lemma 2 and the rest are elementary.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the coefficient <span class="math">\\infty</span>-norm expansion factor, we recall results of [AL21] that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (1 / \\mu_i - \\mu_j)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 1<span class="math">. Therefore, </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}\\leq \\varphi<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}\\leq \\varphi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">□</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A drawback of the subtractive set recalled above is its rather large expansion factor $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2,S}\\leq p<span class="math">. In some applications, e.g. Section 5, we would like </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2,S}$ to be constant. Below, we expose a subtractive set over non-prime-power cyclotomic rings with very small expansion factor.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Theorem 2. Let <span class="math">\\mathfrak{f}</span> factor into <span class="math">k\\geq 2</span> coprime prime-power factors <span class="math">(\\hat{\\mathfrak{f}}_i)_{i\\in [k]}</span>, i.e. <span class="math">\\mathfrak{f} = \\prod_{i\\in [k]}\\hat{\\mathfrak{f}}_i</span>. Write <span class="math">\\hat{\\mathfrak{f}}_{\\mathrm{max}}\\coloneqq \\max_{i\\in [k]}\\hat{\\mathfrak{f}}_i</span>. The set <span class="math">S\\coloneqq \\left\\{1,\\zeta ,\\zeta^2,\\ldots ,\\zeta^{\\mathfrak{f} / \\hat{\\mathfrak{f}}_{\\mathrm{max}} - 1}\\right\\} \\subseteq_{\\mathfrak{f} / \\mathfrak{f}_{\\mathrm{max}}}\\mathcal{O}_{\\mathcal{K}}</span>, is subtractive. Furthermore, $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2,S} = 1<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2,S}\\leq \\frac{1}{4\\sqrt{2}}<span class="math">, and </span>\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}\\leq \\epsilon_{\\mathrm{rad}(f)}\\varphi<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},S}\\leq \\epsilon_{\\mathrm{rad}(f)}\\varphi$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To prove Theorem 2, we begin with the following lemma which we believe should be well-established together with a suppostive proposition. Since we could not find an explicit reference to the lemma, we provide a proof.</p>

    <p class="text-gray-300">Lemma 3. Let <span class="math">\\mathcal{R} = \\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> with a conductor <span class="math">\\mathfrak{f}</span> having <span class="math">k \\geq 2</span> coprime prime-power factors <span class="math">^{13}</span> <span class="math">(\\hat{\\mathfrak{f}}_i)_{i \\in [k]}</span>, i.e. <span class="math">\\mathfrak{f} = \\prod_{i \\in [k]} \\hat{\\mathfrak{f}}_i</span>. Write <span class="math">\\hat{\\mathfrak{f}}_{\\max} := \\max_{i \\in [k]} \\hat{\\mathfrak{f}}_i</span>. For <span class="math">j \\in \\left\\{1, 2, \\ldots, \\frac{\\mathfrak{f}}{\\mathfrak{f}_{\\max}} - 1\\right\\}</span>, it holds that <span class="math">1 - \\zeta^j \\in \\mathcal{R}^\\times</span>.</p>

    <p class="text-gray-300">Proof. Write <span class="math">\\zeta = \\zeta_{\\mathfrak{f}}</span>. First, consider the case when <span class="math">\\zeta^j</span> is a primitive <span class="math">\\mathfrak{f}</span>-th root of unity. Then, by Proposition 1, <span class="math">1 - \\zeta^j</span> is a unit in <span class="math">\\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span>. If <span class="math">\\zeta^j</span> is not a primitive <span class="math">\\mathfrak{f}</span>-th root of unity, then it is a primetime <span class="math">\\mathfrak{h}</span>-th root of unity for some <span class="math">\\mathfrak{h} \\mid \\mathfrak{f}</span> and <span class="math">\\zeta^j \\in \\mathbb{Z}[\\zeta_{\\mathfrak{h}}]</span>. Observe that <span class="math">\\frac{\\mathfrak{f}}{\\mathfrak{h}} \\mid j</span>. Assume that <span class="math">\\mathfrak{h}</span> is a prime-power, i.e. <span class="math">\\mathfrak{h} = \\hat{\\mathfrak{f}}_i^n</span> for some <span class="math">i \\in [k]</span> and <span class="math">n \\geq 2</span>. Hence, as <span class="math">j \\in \\left\\{1, 2, \\ldots, \\frac{\\mathfrak{f}}{\\mathfrak{f}_{\\max}} - 1\\right\\}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\mathfrak {f}}{\\hat {\\mathfrak {f}} _ {i} ^ {n}} \\leq j &amp;lt;   \\frac {\\mathfrak {f}}{\\hat {\\mathfrak {f}} _ {\\max}},</span></div>

    <p class="text-gray-300">which implies <span class="math">\\mathfrak{f}_{\\max} &amp;lt; \\hat{\\mathfrak{f}}_i^n</span>, a contradiction. Therefore, <span class="math">\\mathfrak{h}</span> is not a prime power, i.e. it has more than one distinct prime factors. By Proposition 1, <span class="math">1 - \\zeta^j</span> is invertible in <span class="math">\\mathcal{R}_{\\mathfrak{h}}</span>, thus in <span class="math">\\mathcal{R}_{\\mathfrak{f}}</span>.</p>

    <p class="text-gray-300">Next, we recall an elementary result.</p>

    <p class="text-gray-300">Proposition 1 ([Was97, Proposition 2.8]). Suppose <span class="math">\\mathfrak{f}</span> has at least two distinct prime factors. Then, <span class="math">1 - \\zeta</span> is a unit in <span class="math">\\mathcal{R} = \\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span> for any <span class="math">\\mathfrak{f}</span>-th primitive root of unity <span class="math">\\zeta</span>.</p>

    <p class="text-gray-300">Finally, we state our proof of Theorem 2.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Proof (Proof of Theorem 2).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For <span class="math">i,j\\in[\\mathfrak{f}/\\mathfrak{f}_{\\mathsf{max}}]</span>, where <span class="math">i&lt;j</span>, <span class="math">\\zeta^{i}-\\zeta^{j}=\\zeta^{i}\\cdot(1-\\zeta^{j-i})</span> is invertible due to Lemma 3. The expansion factor satisfying $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}=1$ is immediate. For the inverse-expansion factor, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}=\\max_{i\\neq j}\\big{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\frac{1}{\\zeta^{i}-\\zeta_{j}}\\big{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{\\infty}=\\max_{i\\neq j}\\big{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\frac{1}{1-\\zeta_{i-j}}\\big{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}_{\\infty}\\leq\\frac{\\mathfrak{f}}{4\\sqrt{2}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the inequality is due to Lemma 2.</p>

    <p class="text-gray-300">For coefficient <span class="math">\\infty</span>-norm, we observe that both bounds follow from Corollary 2. ∎</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.3 Real Cyclotomics</h3>

    <p class="text-gray-300">We identify subtractive sets for real cyclotomic rings, i.e. the rings of integers of maximal real subfields of cyclotomic fields. The results over these rings mirror those for cyclotomic fields presented in Theorems 1 and 2.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}^{+}=\\mathbb{Z}[\\zeta_{\\mathfrak{f}}+\\zeta_{\\mathfrak{f}}^{-1}]</span> with <span class="math">\\mathfrak{f}=p^{k}</span>, <span class="math">\\mathfrak{f}&gt;4</span>, <span class="math">p</span> prime. The set</p>

    <p class="text-gray-300"><span class="math">S\\coloneqq\\{\\,\\mu_{1}^{+},\\ldots,\\mu_{(p+1)/2}^{+}\\,\\}\\subseteq_{(p+1)/2}\\mathcal{R}^{+}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is subtractive, where <span class="math">\\mu_{i}^{+}=\\mu_{i}+\\bar{\\mu}_{i}</span> and <span class="math">\\mu_{i}=(\\zeta^{i}-1)/(\\zeta-1)</span> for <span class="math">i\\in[(p+1)/2]</span>, where <span class="math">\\bar{\\cdot}</span> denotes the complex conjugate. Furthermore, $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq p<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq\\frac{\\mathfrak{f}^{2}}{8}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-29" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that, for <span class="math">i&gt;j</span>,</p>

    <p class="text-gray-300"><span class="math">\\mu_{i}-\\mu_{j}=\\big{(}1+\\zeta^{-j-i+1}\\big{)}\\cdot\\frac{\\zeta^{i}-\\zeta^{j}}{\\zeta-1}.</span></p>

    <p class="text-gray-300">The first factor is invertible if <span class="math">j+i-1\\nmid\\mathfrak{f}</span>, which holds for distinct <span class="math">i,j\\in[(p+1)/2]</span>. The second factor is invertible due to Theorem 1. Hence, <span class="math">S</span> is subtractive.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Since any <span class="math">c\\in S</span> is a sum of at most <span class="math">p</span> roots of unity, we have $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq p<span class="math">. For </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}$, we observe that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{1}{\\mu_{i}-\\mu_{j}}=\\frac{\\zeta-1}{(1+\\zeta^{-j-i+1})\\cdot(\\zeta^{i}-\\zeta^{j})}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Write $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\cdot\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}$. By Lemma 2,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{\\zeta-1}{(1+\\zeta^{-j-i+1})\\cdot(\\zeta^{i}-\\zeta^{j})}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\zeta^{i}\\cdot(\\zeta-1)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{1-\\zeta^{j-i}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{1+\\zeta^{-j-i+1}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\frac{\\mathfrak{f}^{2}}{8}.\\qed$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where we use that <span class="math">-\\zeta^{-j-i+1}</span> is at most a root of unity of order <span class="math">2\\mathfrak{f}</span>.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Theorem 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}^{+}=\\mathbb{Z}[\\zeta_{\\mathfrak{f}}+\\zeta_{\\mathfrak{f}}^{-1}]</span> with a non-prime-power conductor <span class="math">\\mathfrak{f}</span> having <span class="math">k\\geq 2</span> coprime prime-power factors <span class="math">(\\tilde{\\mathfrak{f}}_{i})_{i\\in[k]}</span>, i.e. <span class="math">\\mathfrak{f}=\\prod_{i\\in[k]}\\tilde{\\mathfrak{f}}_{i}</span>. Write <span class="math">\\tilde{\\mathfrak{f}}_{\\max}\\coloneqq\\max_{i\\in[k]}\\tilde{\\mathfrak{f}}_{i}</span>. The set</p>

    <p class="text-gray-300"><span class="math">S\\coloneqq\\big{\\{}\\zeta^{i}+\\zeta^{-i}\\big{\\}}\\mathop{\\left[\\left\\lfloor\\frac{\\mathfrak{f}/\\mathfrak{f}_{\\mathsf{max}}}{2}\\right.\\right]}\\subseteq\\mathop{\\left\\lfloor\\frac{\\mathfrak{f}/\\mathfrak{f}_{\\mathsf{max}}}{2}\\right.\\right]}\\mathcal{R}^{+},</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is subtractive. Furthermore, $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq 2<span class="math"> and </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq\\frac{\\mathfrak{f}^{2}}{32}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-31" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider <span class="math">c_{i}=\\zeta^{i}+\\zeta^{-i}\\in S</span> and <span class="math">c_{j}=\\zeta^{j}+\\zeta^{-j}\\in S</span> with <span class="math">i&gt;j</span>. Note that <span class="math">c_{i}-c_{j}=(\\zeta^{i}+\\zeta^{-i})-(\\zeta^{j}+\\zeta^{-j})=\\zeta^{-i}\\cdot(\\zeta^{i+j}-1)\\cdot(\\zeta^{i-j}-1)</span>. As, <span class="math">i+j,i-j\\in[\\mathfrak{f}/\\tilde{\\mathfrak{f}}_{\\max}]</span>, <span class="math">c_{i}-c_{j}</span> is invertible in <span class="math">\\mathcal{R}</span> by Theorem 2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The expansion factor satisfying $\\gamma_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}\\leq 2<span class="math"> is immediate. Write </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\cdot\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">. For </span>\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2},S}$, we observe that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{c_{i}-c_{j}}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{\\zeta^{i+j}-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\frac{1}{\\zeta^{i-j}-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\left(\\frac{\\mathfrak{f}}{4\\sqrt{2}}\\right)^{2}=\\frac{\\mathfrak{f}^{2}}{32},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where the inequality follows from Theorem 2. ∎</p>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In this section, we assume that  <span class="math">\\mathcal{R}</span>  is either  <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>  or  <span class="math">\\mathcal{O}_{\\mathcal{K}^+}</span>  which admit large enough subtractive sets, e.g. those constructed in Section 4. Let  <span class="math">\\mathcal{C}_{\\mathcal{R}} \\subset \\mathcal{R}</span>  denote a fixed subtractive set with expansion factor  <span class="math">\\gamma</span>  and inverse-expansion factor  <span class="math">\\theta</span> . Throughout, we use both canonical 2-norm and coefficient  <span class="math">\\infty</span> -norm, and simply write  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , when this is not relevant. Both norms might be useful in various application-specific context. In theorems, we track both norms (if needed) and use visual distinctions. The norm of the matrix is defined via vectorisation, i.e. for  </span>\\mathbf{A} \\in \\mathcal{R}^{m \\times n}<span class="math"> ,  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{vec}(\\mathbf{A}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . We use the shorthand notation  </span>\\mathcal{R}_q^{n \\times d^{\\otimes \\mu}} := ((\\mathcal{R}_q^{1 \\times d})^{\\otimes \\mu})^n<span class="math">  for a matrix whose rows are elementary tensors. We also write  </span>\\overline{\\mathbf{Z}}<span class="math">  (resp.  </span>\\underline{\\mathbf{Z}}<span class="math"> ) to indicate the top (resp. bottom) half of a block matrix; the block dimension will be clear from the context. Lastly, we let  </span>\\mathcal{C}_{\\mathcal{R}_q} \\subseteq \\mathcal{R}_q^\\times<span class="math">  be obtained by taking a subfield of  </span>\\mathcal{R}_q<span class="math">  and removing 0. Note that  </span>\\mathcal{C}_{\\mathcal{R}}<span class="math">  and  </span>\\mathcal{C}_{\\mathcal{R}_q}<span class="math">  have the invertible differences property with respect to  </span>\\mathcal{R}<span class="math">  and  </span>\\mathcal{R}_q<span class="math">  respectively, i.e.  </span>\\forall x \\neq y \\in \\mathcal{C}_{\\mathcal{R}}<span class="math">  (resp.  </span>\\mathcal{C}_{\\mathcal{R}_q}<span class="math"> ):  </span>x - y \\in \\mathcal{R}^\\times<span class="math">  (resp.  </span>\\mathcal{R}_q^\\times$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The goal of this section is to construct atomic RoK protocols</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi^ {b - d e c o m p}, \\Pi^ {s p l i t}, \\Pi^ {f o l d}, \\Pi^ {b a t c h}, \\Pi^ {n o r m} \\text {a n d} \\Pi^ {i p}</span></div>

    <p class="text-gray-300">for proving that a short vector  <span class="math">\\mathbf{w}</span>  satisfies:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{R}_q</span> -linear elementary tensor relations, i.e.  <span class="math">(\\mathbf{g}_{\\mu -1}\\otimes \\ldots \\otimes \\mathbf{g}_0)\\cdot \\mathbf{w} = y\\bmod q</span></li>

      <li>a self-inner-product relation, i.e.  <span class="math">t = \\langle \\mathbf{w}, \\alpha(\\mathbf{w}) \\rangle_{\\mathcal{R}} = \\sum_{i=0}^{m-1} w_i \\cdot \\alpha(w)_i \\in \\mathcal{R}_q</span> ; where  <span class="math">\\alpha \\in \\{\\mathrm{id}, \\overline{\\mathrm{id}}\\}</span>  is either the identity map or the complex conjugate; and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- a norm bound  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">More specifically, each atomic protocol is a reduction of knowledge which maps between families of relations of the above form with different parameters. In Table 1 on page 27, we provide an overview of parameters for correctness and relaxed knowledge soundness.</p>

    <p class="text-gray-300">The section will be structured as follows. In Section 5.1, we establish some notational convention for this section and formally define the principal relation  <span class="math">\\Xi^{\\mathrm{lin}}</span>  for which (self-)reductions of knowledge will be constructed. In Sections 5.2 to 5.5, we present the self-reductions of knowledge  <span class="math">\\Pi^{b\\text{-decomp}}</span> ,  <span class="math">\\Pi^{\\mathrm{split}}</span> ,  <span class="math">\\Pi^{\\mathrm{fold}}</span>  and  <span class="math">\\Pi^{\\mathrm{batch}}</span>  for  <span class="math">\\Xi^{\\mathrm{lin}}</span> . Finally, in Section 5.6, we define two extended relations  <span class="math">\\Xi^{\\mathrm{norm}}</span>  and  <span class="math">\\Xi^{\\mathrm{ip}}</span>  and two reductions of knowledge,  <span class="math">\\Pi^{\\mathrm{norm}}</span>  and  <span class="math">\\Pi^{\\mathrm{ip}}</span>  respectively, which reduce the extended relations to the principal  <span class="math">\\Xi^{\\mathrm{lin}}</span>  relation.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5.1 The (principal) relation  <span class="math">\\Xi^{\\mathrm{lin}}</span></h2>

    <p class="text-gray-300">We begin by defining the relation  <span class="math">\\Xi^{\\mathrm{lin}}</span>  and outline how protocols reduce instances in this relation to other instances. This relation serves as the principal building block for further protocols.</p>

    <p class="text-gray-300"><strong>Basic (single-block) relation.</strong> We define our central relation(s) over the ring  <span class="math">\\mathcal{R}</span> , modulo  <span class="math">q</span> , for witness dimension  <span class="math">m = d^{\\mu}</span> . In fact, there are two central relations:  <span class="math">\\Xi^{\\mathrm{lin}}</span>  for correctness; and  <span class="math">\\Xi^{\\mathrm{lin} \\vee \\mathrm{sis}}</span>  for relaxed knowledge soundness. We define both at once, so that  <span class="math">\\Xi^{\\mathrm{lin} \\vee \\mathrm{sis}} \\supseteq \\Xi^{\\mathrm{lin}}</span>  contains all highlighted parts additionally. Let</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{\\mathcal{R},q,m,n^{\\mathrm{not}},r,\\mu ,\\beta ,\\beta^{\\mathrm{dis}}}^{\\mathrm{lin}\\vee \\mathrm{sis}}\\coloneqq \\left\\{ \\begin{array}{l}((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W}\\text{or}\\mathbf{w}):\\\\ \\mathbf{H}\\in \\mathcal{R}_{q}^{n^{\\mathrm{not}}\\times n};\\mathbf{F}\\in \\mathcal{R}_{q}^{n\\times d^{\\otimes \\mu}}\\subseteq \\mathcal{R}_{q}^{n\\times m};\\mathbf{Y}\\in \\mathcal{R}_{q}^{n^{\\mathrm{not}}\\times r};\\mathbf{W}\\in \\mathcal{R}^{m\\times r};\\mathbf{w}\\in \\mathcal{R}^{m}\\\\ \\left\\{ \\begin{array}{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\\\ \\mathbf{H}\\mathbf{F}\\mathbf{W} = \\mathbf{Y}\\bmod q \\end{array} \\right\\} \\quad \\text{or}\\quad \\left\\{ \\begin{array}{l}\\mathbf{w}\\neq \\mathbf{0}\\wedge \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta^{\\mathrm{sis}}\\\\ \\overline{\\mathbf{H}}\\mathbf{F}\\mathbf{w} = \\mathbf{0}_{\\overline{n}}\\bmod q \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} \\right\\} $$</p>

    <p class="text-gray-300">where we always assume that  <span class="math">\\mathbf{H}</span>  has the block structure</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {H} = \\left( \\begin{array}{l} \\overline {{\\mathbf {H}}} \\\\ \\underline {{\\mathbf {H}}} \\end{array} \\right) \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {n o t}} \\times n} \\quad \\text {w h e r e} \\quad \\overline {{\\mathbf {H}}} = \\left(\\mathbf {I} _ {\\overline {{n}}} \\mathbf {0}\\right) \\in \\mathcal {R} _ {q} ^ {\\overline {{n}} \\times n} \\quad \\text {a n d} \\quad \\underline {{\\mathbf {H}}} \\in \\mathcal {R} _ {q} ^ {\\underline {{n}} \\times n} \\tag {2}</span></div>

    <p class="text-gray-300">Similarly, we write  <span class="math">\\overline{\\mathbf{Y}}\\in \\mathcal{R}_q^{\\overline{n}}</span>  and  <span class="math">\\underline{\\mathbf{Y}}\\in \\mathcal{R}_q^{\\underline{n}}</span>  for the  <span class="math">\\overline{n}</span>  top (resp.  <span class="math">\\underline{n}</span>  bottom) rows of  <span class="math">\\mathbf{Y}</span> .</p>

    <p class="text-gray-300">16</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Remark 1 (Notational conventions).</h6>

    <p class="text-gray-300">We often omit irrelevant parameters in <span class="math">\\Xi^{\\text{lin}}</span> and similar relations. Especially all fixed parameters in our protocols, which are <span class="math">\\mathcal{R}</span>, <span class="math">q</span>, <span class="math">\\overline{n}</span>, <span class="math">\\beta^{\\text{sis}}</span>. For example, for parameterised relation like <span class="math">\\Xi_{\\mathcal{R},q,x,y}</span>, we write <span class="math">\\Xi_{x=f(\\xi)}</span> for <span class="math">\\Xi_{\\mathcal{R},q,f(\\xi),z}</span> or even just <span class="math">\\Xi_{f(\\xi)}</span> if <span class="math">x=f(\\xi)</span> is clear from the context. Also, we fix <span class="math">d</span> and always set <span class="math">m=d^{\\mu}</span>. As such, we often omit <span class="math">d</span> and <span class="math">\\mu</span>.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Remark 2 (Matrix witness).</h6>

    <p class="text-gray-300">For generality and efficiency, we present a relation which deals with a <em>matrix</em> <span class="math">\\mathbf{W}</span> instead of a vector <span class="math">\\mathbf{w}</span> for the witness, and likewise a matrix <span class="math">\\mathbf{Y}</span> instead of a vector <span class="math">\\mathbf{y}</span>. However, it is convenient to think of the columns of <span class="math">\\mathbf{W}</span> as a tuple of witnesses <span class="math">(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{r})</span> and claims <span class="math">\\mathbf{H}\\mathbf{F}\\mathbf{w}_{i}=\\mathbf{y}_{i}</span>. Indeed, the linear constraint in <span class="math">\\Xi^{\\text{lin}}</span> is equivalent to <span class="math">r</span> linear constraints (column-wise). However, for efficiency reasons we consider the norm constraint over <span class="math">\\mathbf{W}</span> (instead of column-wise norm constraints).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Clearly, relation <span class="math">\\Xi^{\\text{lin}}</span> asserts that the witness <span class="math">\\mathbf{W}</span> has norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math">. For the linear relation, let us first assume that </span>\\mathbf{H}=\\mathbf{I}_{n}<span class="math"> is an identity matrix. In this case, the relation asserts that </span>\\mathbf{F}\\mathbf{W}=\\mathbf{Y}<span class="math"> holds over </span>\\mathcal{R}_{q}<span class="math">. The matrix </span>\\mathbf{F}<span class="math"> is structured, namely each row </span>\\mathbf{f}<span class="math"> is an elementary tensor in </span>\\mathcal{R}_{q}^{1\\times d^{\\otimes\\mu}}<span class="math">, i.e. </span>\\mathbf{f}=\\mathbf{g}_{\\mu-1}\\otimes\\ldots\\otimes\\mathbf{g}_{0}<span class="math"> for </span>\\mathbf{g}_{i}=(g_{i,0},\\ldots,g_{i,d-1})\\in\\mathcal{R}_{q}^{1\\times d}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\Xi^{\\text{lin}\\vee\\text{sis}}</span>, we relax these assertions by introducing the highlighted OR-part, which captures a break of some underlying cryptographic assumption, e.g. a break of the vSIS assumption <em>[x10]</em> (Appendix A.2). For this, <span class="math">\\overline{\\mathbf{F}}=\\overline{\\mathbf{H}}\\mathbf{F}</span> will be the commitment key in a protocol. If the assumption is broken, then <span class="math">\\Xi^{\\text{lin}}</span> may not be satisfied, hence the relaxed soundness relation <span class="math">\\Xi^{\\text{lin}\\vee\\text{sis}}</span> is necessary.</p>

    <p class="text-gray-300">Now, we further explain <span class="math">\\mathbf{H}</span>. The primary use of <span class="math">\\mathbf{H}</span> is to capture <em>random linear combination</em> of rows of <span class="math">\\mathbf{F}</span>. The block structure asserts that the top <span class="math">\\overline{n}</span> rows of <span class="math">\\mathbf{F}</span> are simply copied — <span class="math">\\overline{\\mathbf{F}}=\\overline{\\mathbf{H}}\\mathbf{F}</span> will correspond to the commitment key. Naively, our protocols would have communication costs linear in the number of rows of <span class="math">\\mathbf{F}</span>, but by using <span class="math">\\mathbf{H}</span>, we can compress this from <span class="math">n</span> down to <span class="math">n^{\\text{out}}=\\overline{n}+\\underline{n}</span>. In prior works, one would simply (re)define <span class="math">\\mathbf{F}</span> as <span class="math">\\mathbf{H}\\mathbf{F}</span>. However, to keep <em>(verifier-)succinctness</em>, we cannot do this: A (random) linear combination of elementary tensors is in general not an elementary tensor. However, our protocol crucially relies on the rows of <span class="math">\\mathbf{F}</span> being elementary tensors in order to apply FRI-style (verifier-succinct) folding of the statement. Therefore, we remember the (random) linear combinations of rows in <span class="math">\\mathbf{H}</span>, instead of carrying out the multiplication. Importantly, the <em>communication</em> of the protocol can indeed by compressed by applying <span class="math">\\mathbf{H}</span>. (Note there that the dimensions of <span class="math">\\mathbf{H}</span> and <span class="math">\\mathbf{Y}</span> are in general much smaller than that of <span class="math">\\mathbf{W}</span>.)</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Reductions between <span class="math">\\Xi^{\\text{lin}}</span>.</h4>

    <p class="text-gray-300">Our protocols reduce instances of <span class="math">\\Xi^{\\text{lin}}_{m,\\beta}</span> with different parameters, and we chain them to obtain our final split-and-fold protocol with intermediate norm checks. Primary protocols and parameters of interest are:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi^{\\text{b-decomp}}</span>: Reduce an instance with norm bound <span class="math">\\beta</span> to an instance with more columns (<span class="math">r^{\\prime}&gt;r</span>) but smaller norm bound.</li>

      <li><span class="math">\\Pi^{\\text{split}}</span>: Reduce an instance with witness of shape <span class="math">m\\times r</span> to shape <span class="math">\\frac{m}{d}\\times(r\\cdot d)</span>.</li>

      <li><span class="math">\\Pi^{\\text{fold}}</span>: Reduce an instance with witness of shape <span class="math">m\\times r</span> and norm <span class="math">\\beta</span> to an instance of shape <span class="math">m\\times r^{\\prime}</span> and norm <span class="math">\\beta^{\\prime}=\\gamma\\beta</span>. to shape <span class="math">m^{\\prime}\\times r^{\\prime}</span> with <span class="math">m^{\\prime}=m/d</span> and <span class="math">r^{\\prime}=r\\cdot d</span>. Usually, <span class="math">r^{\\prime}\\in\\mathcal{O}(1)</span> or <span class="math">r^{\\prime}\\in\\mathcal{O}(\\lambda)</span> is fixed and independent of <span class="math">r</span>.</li>

      <li><span class="math">\\Pi^{\\text{batch}}</span>: Reduce one instance to another instance by randomly combining the last <span class="math">\\underline{n}</span> rows of <span class="math">\\mathbf{H}</span> and <span class="math">\\mathbf{Y}</span> into a single one, so that <span class="math">n^{\\text{out}}=\\overline{n}+1</span>.</li>

    </ol>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Handling vSIS breaks.</h4>

    <p class="text-gray-300">Knowledge reductions can simply pass a <span class="math">\\Xi^{\\text{lin}\\vee\\text{sis}}</span>-witness on as their extracted witness. Thus, we sometimes omit that discussion entirely.</p>

    <h3 id="sec-38" class="text-xl font-semibold mt-8">5.2 <span class="math">\\boldsymbol{\\Pi}^{\\text{b-decomp}}</span>: <span class="math">\\boldsymbol{b}</span>-ary Decomposition Knowledge Reduction</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">b\\geq 1</span> be an integer. The protocol <span class="math">\\Pi^{\\text{b-decomp}}</span> (Fig. 3) is very simple: It takes a claim <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})\\in\\Xi^{\\text{lin}}_{m,\\beta}</span> and does a balanced <span class="math">b</span>-ary decomposition of the witness <span class="math">\\mathbf{W}</span> with $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta<span class="math"> into </span>\\mathbf{W}=\\sum_{i=0}^{\\ell-1}b^{i}\\mathbf{V}_{i}<span class="math">, where </span>\\mathbf{V}_{i}\\in\\mathcal{R}_{b}^{i}<span class="math"> (hence </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{V}_{i}\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq b/2<span class="math">) and </span>\\ell=\\lceil\\log_{b}(2\\beta+1)\\rceil<span class="math">. Then, appropriate claims </span>\\mathbf{Z}_{i}=\\mathbf{H}\\mathbf{F}\\mathbf{V}_{i}<span class="math"> for the decomposed witness are computed, and the verifier makes sure the new claims imply the original one. Thus, the original statement is reduced to </span>((\\mathbf{H},\\mathbf{F},\\mathbf{Z}_{i}),\\mathbf{V}_{i})_{i\\in[\\ell]}<span class="math">, which is further combined to </span>((\\mathbf{H},\\mathbf{F},\\widetilde{\\mathbf{Z}}),\\widetilde{\\mathbf{V}})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-39" class="text-base font-medium mt-4">Remark 3.</h6>

    <p class="text-gray-300">In protocol <span class="math">\\Pi^{\\text{b-decomp}}</span>, we could apply the optimisation of not sending <span class="math">\\mathbf{Z}_{0}</span>, and instead let the verifier compute the unique accepting <span class="math">\\mathbf{Z}_{0}</span>, i.e. such that <span class="math">\\mathbf{Y}=\\sum_{i\\in[\\ell]}b^{i}\\mathbf{Z}_{i}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3. Protocol  <span class="math">\\Pi^{b\\text{-decomp}}</span> , a reduction of  <span class="math">\\Xi_{\\text{par-in}}^{\\text{lin}}</span>  to  <span class="math">\\Xi_{\\text{par-out}}^{\\text{lin}}</span>  with par-in, par-out specified in Lemma 4. As a proof (but not reduction) of knowledge,  <span class="math">\\Pi^{b\\text{-decomp}}</span>  sends the marked parts.</p>

    <p class="text-gray-300">Lemma 4 (Decomposition). Let  <span class="math">m, d, r, \\in \\mathbb{N}</span>  where  <span class="math">0 \\leq \\beta \\leq \\beta^{\\mathrm{sis}} \\leq q</span> . Protocol  <span class="math">\\Pi^{b\\text{-decomp}}</span>  is a perfectly correct self-reduction of knowledge for  <span class="math">\\Xi^{\\mathrm{lin}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(r, \\beta\\right) \\mapsto \\left(r \\cdot \\ell , \\boxed {\\frac {1}{2} \\sqrt {\\ell r m} \\sqrt {\\mathring {\\dagger} \\varphi b}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}} \\left(\\operatorname {r e s p .}, \\boxed {\\frac {b}{2}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}}\\right)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">It is a perfectly relaxed knowledge sound self-reduction for  <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(r, \\beta_ {0} ^ {\\prime}, \\beta^ {\\mathrm {s i s}}\\right) \\leftrightarrow \\left(r \\cdot \\ell , \\beta_ {1} ^ {\\prime}, \\beta^ {\\mathrm {s i s}}\\right).</span></div>

    <p class="text-gray-300">where  <span class="math">\\beta_0^{\\prime} = \\frac{b^{\\ell} - 1}{b - 1}\\cdot \\beta_1^{\\prime}</span>  and  <span class="math">\\ell = \\lceil \\log_b(2\\beta +1)\\rceil</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Perfect correctness of  <span class="math">\\Pi^{b\\text{-decomp}}</span>  from  <span class="math">\\Xi_{m,r,\\beta}^{\\mathrm{lin}}</span>  to  <span class="math">\\Xi_{m,r\\cdot \\ell ,b}^{\\mathrm{lin}}</span>  is easy to see: By construction, each  <span class="math">\\mathbf{V}_i</span>  has  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf{V}_i)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq b / 2<span class="math"> , and by Corollary 1 it follows that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{V}_i)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\frac{1}{2}\\sqrt{rm}\\sqrt{\\mathring{\\dagger}\\varphi b}<span class="math"> , and therefore  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{V}_0,\\ldots ,\\mathbf{V}_{\\ell -1})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\frac{1}{2}\\sqrt{\\ell rm}\\sqrt{\\mathring{\\dagger}\\varphi b}<span class="math">  as claimed. The linear equations  </span>\\mathbf{HFV}_i = \\mathbf{Z}_i$  hold by definition.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For relaxed knowledge soundness, observe that again by linearity, the original linear equation holds for  <span class="math">\\mathbf{W} = \\sum_{i=0}^{\\ell-1} b^{i} \\mathbf{V}_{i}</span> . For the norm, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {W} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\sum_ {i = 0} ^ {\\ell - 1} b ^ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {V} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\frac {b ^ {\\ell} - 1}{b - 1} \\cdot \\beta_ {1} ^ {\\prime}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">by the geometric series. Now, we derive the second, simplified bound (which has more slack). For that, observe that  <span class="math">\\frac{b^{\\ell} - 1}{b - 1} \\leq \\frac{b^{\\ell}}{b - 1} = \\frac{b}{b - 1} b^{\\ell - 1} \\leq 2b^{\\ell - 1}</span> . Moreover, for  <span class="math">x = 2\\beta + 1</span> , observe that  <span class="math">b \\leq \\lceil (2\\beta + 1)^{1/\\ell} \\rceil \\leq x^{1/\\ell} + 1</span> , and therefore  <span class="math">b^{\\ell - 1} \\leq (x^{1/\\ell} + 1)^{\\ell - 1} = x^{1 - 1/\\ell}(1 + x^{-1/\\ell})^{\\ell - 1}</span>  and  <span class="math">(1 + x^{-1/\\ell})^{\\ell - 1} = \\exp((\\ell - 1)\\ln(1 + x^{-1/\\ell})) \\leq \\exp((\\ell - 1)x^{-1/\\ell})</span> .</p>

    <p class="text-gray-300">Finally the OR-branch in  <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span>  is handled by letting the  <span class="math">\\mathbf{w}</span>  with  <span class="math">\\overline{\\mathbf{H}}\\mathbf{F}\\mathbf{w} = \\mathbf{0}</span>  be the extracted witness. If  <span class="math">\\beta_0^\\prime \\leq \\beta^{\\mathrm{sis}}</span> , this is a witness for  <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span> .</p>

    <p class="text-gray-300">Remark 4 (Choice of  <span class="math">b</span> ). To balance between correctness, soundness, and efficiency, it is convenient to choose  <span class="math">\\ell</span>  instead of  <span class="math">b</span> , and then consider  <span class="math">b = \\lceil (2\\beta + 1)^{1/\\ell} \\rceil</span> . In other words, it might be possible that for various values  <span class="math">b</span> , the corresponding values  <span class="math">\\ell</span>  will be equivalent. For the efficiency perspective, there is no point in selecting other  <span class="math">b</span>  except the smallest one for specified  <span class="math">\\ell</span> .</p>

    <p class="text-gray-300">Remark 5. Protocol  <span class="math">\\Pi^{\\mathrm{split}}</span>  can be optimised. Intead of sending  <span class="math">(\\mathbf{Z}_k)_{k\\in [\\ell ]}</span>  and verifying  <span class="math">\\mathbf{Y}\\stackrel {?}{=}\\sum_{i\\in [\\ell ]}b^{i}\\mathbf{Z}_{i}</span> , is it enough to send  <span class="math">(\\mathbf{Z}_k)_{k\\in [\\ell -1]}</span>  and recompute the remaining part.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P((H,F,Y),W)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">V((H,F,Y))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  parse F = R • F // Row-wise tensor decomposition of F into R ∈ Rn×d and F ∈ Rn×(m/d) |   |</p>

    <p class="text-gray-300">|  parse Di = [x → Re_i • x] ∈ Rn×m // Diagonal matrix representing Hadamard product with Re_i |   |</p>

    <p class="text-gray-300">|  parse W = ∑i∈[d] e_i ⊗ W_i // Decomposition into W_i ∈ Rm/d×r |   |</p>

    <p class="text-gray-300">|  for j ∈ [d] // Top row intermediate evaluations for H = (I_R 0) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Y_j := HFW_j</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\overline{(\\mathbf{Y}_j)_{j\\in[d]}}\\) \\(\\mathbf{Y}_j\\)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  for (i,j) ∈ [d] × [d] // Bottom row cross terms |   |</p>

    <p class="text-gray-300">|  Y_i,j := H · Di · F W_j // Intermediate evaluations |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\overline{(\\mathbf{Y}_{i,j})_{(i,j)\\in[d]\\times[d]}}\\) \\(\\mathbf{Y}_j\\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\mathbf{Y}_j\\)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  c = (c^i)_{i∈[d]} := (1, c, ..., c^{d-1})^T |   |</p>

    <p class="text-gray-300">|  H = H · ∑i∈[d] c^i D_i |   |</p>

    <p class="text-gray-300">|  \\(\\widetilde{\\mathbf{Y}} = \\left(\\sum_{i\\in[d]}c^i\\mathbf{Y}_{i,j}\\right)_{j\\in[d]}\\) |   |</p>

    <p class="text-gray-300">|  \\(\\widetilde{\\mathbf{H}} = \\mathbf{H} \\cdot \\sum_{i\\in[d]}c^i\\mathbf{D}_i; \\quad \\widetilde{\\mathbf{H}} = \\left( \\begin{array}{c} \\mathbf{H} \\\\ \\mathbf{H} \\end{array} \\right)\\) |   |</p>

    <p class="text-gray-300">|  \\(\\widetilde{\\mathbf{Y}}_j = \\sum_{i\\in[d]}c^i\\mathbf{Y}_{i,j}; \\quad \\widetilde{\\mathbf{Y}}_j = \\left( \\begin{array}{c} \\mathbf{Y}_j \\\\ \\widetilde{\\mathbf{Y}}_j \\end{array} \\right)\\) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\widetilde{\\mathbf{W}} = (\\mathbf{W}_j)_{j\\in[d]}\\)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\(\\widetilde{\\mathbf{W}}\\)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 4. Protocol  <span class="math">\\Pi^{\\mathrm{split}}</span> , a reduction from  <span class="math">\\Xi_{\\mathrm{par - in}}^{\\mathrm{lin}}</span>  to  <span class="math">\\Xi_{\\mathrm{par - out}}^{\\mathrm{lin}}</span>  with par-in, par-out specified in Lemma 5.  <span class="math">\\Pi^{\\mathrm{split}}</span>  sends the marked parts only as a proof (but not reduction) of knowledge.</p>

    <p class="text-gray-300">In Fig. 4 we describe protocol  <span class="math">\\Pi^{\\mathrm{split}}</span>  which takes a claim from  <span class="math">\\Xi_{m,r,\\beta}^{\\mathrm{lin}}</span>  and splits it into claim in  <span class="math">\\Xi_{m/d,r\\cdot d,\\beta}^{\\mathrm{lin}}</span> . We explain the idea and correctness of the protocol below.</p>

    <p class="text-gray-300">To split the witness, interpret  <span class="math">\\mathcal{R}^{m\\cdot r}</span>  as  <span class="math">\\mathcal{R}^{d^{\\otimes \\nu}\\times r}</span> , and split  <span class="math">\\mathbf{W}\\in \\mathcal{R}^{m\\times r}\\cong \\mathcal{R}^{d^{\\otimes \\nu}\\times r}</span>  into  <span class="math">\\mathbf{W} = \\sum_{i = 0}^{\\mu -1}\\mathbf{e}_i\\otimes</span> <span class="math">\\mathbf{W}_i</span>  where  <span class="math">\\mathbf{W}_i\\in \\mathcal{R}^{m / d\\times r}\\cong \\mathcal{R}^{d^{\\otimes (\\mu -1)}\\times r}</span>  and  <span class="math">\\mathbf{e}_i\\in \\{0,1\\} ^d</span>  is the  <span class="math">i</span> -th standard unit vector. Splitting  <span class="math">\\mathbf{W}</span>  like this is compatible with the row-wise tensor structure of  <span class="math">\\mathbf{F}</span> . Let us take a closer look at this.</p>

    <p class="text-gray-300">For simplicity, first consider a single row  <span class="math">\\mathbf{f} \\in \\mathcal{R}_q^{1 \\times d^{\\otimes \\nu}}</span>  of  <span class="math">\\mathbf{F}</span> . By the elementary tensor structure of the row-vector  <span class="math">\\mathbf{f}</span> , we can write it as  <span class="math">\\mathbf{f} = \\mathbf{r} \\otimes \\widetilde{\\mathbf{f}} = (r_0 \\cdot \\widetilde{\\mathbf{f}}, \\ldots, r_{d-1} \\cdot \\widetilde{\\mathbf{f}}) = (\\mathbf{f}_0, \\ldots, \\mathbf{f}_{d-1})</span>  where  <span class="math">\\widetilde{\\mathbf{f}} \\in \\mathcal{R}_q^{1 \\times d^{\\otimes (\\mu-1)}}</span> ,  <span class="math">\\mathbf{r} = (r_0, \\ldots, r_{d-1}) \\in \\mathcal{R}_q^{1 \\times d}</span> , and  <span class="math">\\mathbf{f}_i = r_i \\cdot \\widetilde{\\mathbf{f}}_i</span> . Therefore,  <span class="math">\\mathbf{f} \\cdot \\mathbf{W} = \\sum_{i \\in [d]} \\mathbf{f}_i \\mathbf{W}_i = \\sum_{i \\in [d]} (\\widetilde{\\mathbf{f}} \\cdot \\mathbf{W}_i) \\cdot (\\mathbf{r} \\cdot \\mathbf{e}_i^{\\mathrm{T}}) = \\sum_{i \\in [d]} r_i \\widetilde{\\mathbf{f}} \\cdot \\mathbf{W}_i</span> .</p>

    <p class="text-gray-300">Now, consider any matrix  <span class="math">\\mathbf{F}</span>  with row-wise tensor structure and  <span class="math">n</span>  rows, as in  <span class="math">\\Xi^{\\mathrm{lin}}</span> . That is,  <span class="math">\\mathbf{F} \\in \\mathcal{R}_q^{n \\times d^{\\otimes \\nu}}</span> . Observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {F} = \\left( \\begin{array}{c} \\mathbf {F} _ {0, \\bullet} \\\\ \\vdots \\\\ \\mathbf {F} _ {n - 1, \\bullet} \\end{array} \\right) = \\left( \\begin{array}{c c} \\mathbf {F} _ {0, 0} &amp;amp; \\dots \\mathbf {F} _ {0, d - 1} \\\\ \\vdots &amp;amp; \\vdots \\\\ \\mathbf {F} _ {n - 1, 0} &amp;amp; \\dots \\mathbf {F} _ {0, d - 1} \\end{array} \\right) = \\left( \\begin{array}{c} \\mathbf {r} _ {0} \\otimes \\widetilde {\\mathbf {f}} _ {0} \\\\ \\vdots \\\\ \\mathbf {r} _ {n - 1} \\otimes \\widetilde {\\mathbf {f}} _ {n - 1} \\end{array} \\right) \\tag {3}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{F}_{i,\\bullet}</span> denotes the <span class="math">i</span>-th row of <span class="math">\\mathbf{F}</span>, and <span class="math">\\mathbf{F}_{i,j} \\in \\mathcal{R}_q^{1 \\times d^{\\otimes \\mu}}</span> the block of rows (the analogue of <span class="math">(\\mathbf{f}_0, \\ldots, \\mathbf{f}_{d-1})</span> of the single-row case), and <span class="math">\\widetilde{\\mathbf{f}}_i \\in \\mathcal{R}_q^{1 \\times d^{\\otimes (\\mu-1)}}</span> and <span class="math">\\mathbf{r}_i \\in \\mathcal{R}_q^{1 \\times d}</span> are the analogues of <span class="math">\\mathbf{r}</span> and <span class="math">\\widetilde{\\mathbf{f}}</span> of the single-row case respectively. To ease notation, we define <span class="math">\\mathbf{R} = (\\mathbf{r}_i^\\intercal)_{i \\in [n]} \\in \\mathcal{R}_q^{n \\times d}</span> and <span class="math">\\widetilde{\\mathbf{F}} = (\\widetilde{\\mathbf{f}}_i)_{i \\in [n]} \\in \\mathcal{R}_q^{n \\times d^{\\otimes (\\mu-1)}}</span>, and we write <span class="math">\\mathbf{F} = \\mathbf{R} \\bullet \\widetilde{\\mathbf{F}}</span> for the row-wise tensor product<span class="math">^{15}</span> of <span class="math">\\mathbf{R}</span> and <span class="math">\\widetilde{\\mathbf{F}}</span> as seen in Eq. (3). In this notation,</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {F} \\cdot \\mathbf {W} = (\\mathbf {R} \\bullet \\widetilde {\\mathbf {F}}) \\cdot \\left(\\sum_ {i = 0} ^ {\\mu - 1} \\mathbf {e} _ {i} \\otimes \\mathbf {W} _ {i}\\right) = \\sum_ {i} \\underbrace {(\\mathbf {R e} _ {i})} _ {\\in \\mathcal {R} _ {q} ^ {n}} \\bullet (\\widetilde {\\mathbf {F}} \\mathbf {W} _ {i}) _ {= \\mathbf {Y} _ {i} \\in \\mathcal {R} _ {q} ^ {n \\times r}} \\tag {4}</span></div>

    <p class="text-gray-300">Note that for the vector <span class="math">\\mathbf{r}_i = \\mathbf{R}\\mathbf{e}_i</span>, row-wise tensoring <span class="math">\\mathbf{r}_i\\bullet \\mathbf{W}_i</span> is just componentwise multiplication with <span class="math">r_{i,j}</span> in the <span class="math">j</span>-th row of <span class="math">\\mathbf{W}_i</span>. Thus, with <span class="math">\\mathbf{D}_i\\coloneqq \\mathrm{diag}(\\mathbf{r}_i)</span>, we can rewrite (4) as</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {F} \\cdot \\mathbf {W} = \\sum_ {i} \\mathbf {D} _ {i} \\cdot \\widetilde {\\mathbf {F}} \\mathbf {W} _ {i} \\tag {5}</span></div>

    <p class="text-gray-300">With the above, we have derived a splitting protocol for the special case where <span class="math">\\mathbf{H} = \\mathbf{I}_n</span> is the identity matrix: Simply send <span class="math">\\mathbf{Y}_i = \\mathbf{D}_i\\cdot \\widetilde{\\mathbf{F}}\\mathbf{W}_i</span> and set <span class="math">\\widetilde{\\mathbf{Y}} = (\\mathbf{Y}_0,\\dots ,\\mathbf{Y}_{d - 1})</span> for new statement <span class="math">(\\mathbf{H},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}})</span> and witness <span class="math">\\widetilde{\\mathbf{W}} = (\\mathbf{W}_i)_{i\\in [d]}</span>.</p>

    <p class="text-gray-300">When <span class="math">\\mathbf{H}</span> is not necessarily the identity, we must also handle the bottom part <span class="math">\\underline{\\mathbf{H}}</span> of <span class="math">\\mathbf{H}</span>. To do so, our protocol (cf. Fig. 4) additionally sends cross terms, namely <span class="math">\\mathbf{D}_i\\cdot \\widetilde{\\mathbf{F}}\\mathbf{W}_j</span> for <span class="math">i,j\\in [d]</span>, which are then randomly recombined.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Lemma 5 (Split).</strong> Let <span class="math">m, d, r, \\mu \\in \\mathbb{N}</span> where $d</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m<span class="math"> and </span>0 \\leq \\beta \\leq \\beta^{\\mathrm{sis}} \\leq q<span class="math">. Protocol </span>\\Pi^{\\mathrm{split}}<span class="math"> is a perfectly correct self-reduction of knowledge for </span>\\Xi^{\\mathrm{lin}}$ with parameters</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(m, r, \\mu , \\beta\\right) \\mapsto \\left(m / d, r \\cdot d, \\mu - 1, \\beta\\right).</span></div>

    <p class="text-gray-300">It is a perfectly relaxed knowledge sound self-reduction for <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span> with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, r, \\mu , \\beta , \\beta^ {\\mathrm {s i s}}\\right) \\leftrightarrow \\left(m / d, r \\cdot d, \\mu - 1, \\beta , \\beta^ {\\mathrm {s i s}}\\right)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">with <span class="math">d</span>-special sound extraction and knowledge error $\\kappa = (d - 1) / \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> if </span>2\\beta \\leq \\beta^{\\mathrm{sis}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Perfect correctness of <span class="math">\\Pi^{\\mathrm{split}}</span> is straightforward for the top rows: Since <span class="math">\\overline{\\mathbf{H}} = (\\mathbf{I}_{\\overline{n}}\\mathbf{0})</span>, we have <span class="math">\\overline{\\mathbf{F}} = \\overline{\\mathbf{H}}\\mathbf{F}</span> are just the <span class="math">\\overline{n}</span> top rows of <span class="math">\\mathbf{F}</span>, and similar for <span class="math">\\widetilde{\\mathbf{F}}</span>, and thus by our discussion before and some renaming (using <span class="math">\\overline{\\mathbf{F}}</span> instead of <span class="math">\\mathbf{F}</span> makes <span class="math">\\overline{\\mathbf{H}}</span> the identity) we know that the top part is perfectly correct. For the bottom rows, correctness follows essentially from Eqs. (4) and (5) which asserts that</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {H}} \\widetilde {\\mathbf {F}} \\mathbf {W} _ {j} = \\sum_ {i, j \\in [ d ]} c _ {i} \\underline {{\\mathbf {H}}} \\cdot \\mathbf {D} _ {i} \\cdot \\widetilde {\\mathbf {F}} \\mathbf {W} _ {j} = \\sum_ {i, j \\in [ d ]} c _ {i} \\underline {{\\mathbf {Y}}} _ {i, j} = \\widetilde {\\mathbf {Y}} _ {j}.</span></div>

    <p class="text-gray-300">For relaxed knowledge soundness, we argue through <span class="math">d</span>-special soundness. So we have <span class="math">d</span> related accepting transcripts for challenge vectors <span class="math">\\mathbf{c}^{(k)}</span> with witness <span class="math">\\widetilde{\\mathbf{W}}^{(k)} = (\\widetilde{\\mathbf{W}}_i^{(k)})_{i\\in [d]}</span> which satisfies <span class="math">((\\widetilde{\\mathbf{H}}^{(k)},\\widetilde{\\mathbf{F}}^{(k)},\\widetilde{\\mathbf{Y}}^{(k)}),\\widetilde{\\mathbf{W}}^{(k)})\\in \\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span>.</p>

    <p class="text-gray-300"><strong>Step 1 (top rows):</strong> Let us first consider the top rows (and any single transcript): Here, it is straightforward to see that</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {W} ^ {(k)} = \\underbrace {\\widetilde {\\mathbf {W}} _ {i} ^ {(k)}} _ {i \\in [ d ]} \\quad \\text {s a t i s f i e s} \\quad \\overline {{\\mathbf {H}}} \\mathbf {F} \\mathbf {W} ^ {(k)} = \\overline {{\\mathbf {H}}} \\sum_ {i} \\mathbf {D} _ {i} \\widetilde {\\mathbf {F}} \\mathbf {W} _ {i} ^ {(k)} = \\sum_ {i} \\overline {{\\mathbf {Y}}} _ {i} = \\overline {{\\mathbf {Y}}}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for all <span class="math">k \\in [d]</span> by construction (and using <span class="math">\\overline{\\mathbf{H}} = (\\mathbf{I}_{\\overline{n}}\\mathbf{0})</span>). Thus, we trivially and unconditionally find a witness for the top rows. Clearly, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\beta$ as the witness is simply rearranged.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, by looking at the top rows, we see that: Either, there is a unique <span class="math">\\mathbf{W}_j</span> over all transcripts, i.e. <span class="math">\\mathbf{W}_j^{(k)} = \\mathbf{W}_j^{(k&#x27;)}</span> for all <span class="math">k, k&#x27; \\in [d]</span>. Or, there is a non-zero difference <span class="math">\\mathbf{V}_j = \\mathbf{W}_j^{(k)} - \\mathbf{W}_j^{(k&#x27;)}</span> of norm at</p>

    <p class="text-gray-300">15This row-wise tensor product is known under several names, e.g. row-wise Kronecker product, “face-splitting product”, “transposed Khatri-Rao product” (and more general forms, as block Kronecker product and Khatri-Rao product).</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 5. Protocol  <span class="math">\\Pi^{\\mathrm{fold}}</span>  folds instance of  <span class="math">\\Xi_{\\mathrm{par - in}}^{\\mathrm{fin}}</span>  into  <span class="math">\\Xi_{\\mathrm{par - out}}^{\\mathrm{fin}}</span>  with par-in, par-out specified in Lemma 6.  <span class="math">\\Pi^{\\mathrm{fold}}</span>  sends the marked parts only as a proof (but not reduction) of knowledge.</p>

    <p class="text-gray-300">most  <span class="math">2\\beta</span> . Consider a non-zero column  <span class="math">\\mathbf{v}_j</span> , such that  <span class="math">\\overline{\\mathbf{HF}}\\mathbf{v}_j = \\mathbf{0}</span> , and thus  <span class="math">\\overline{\\mathbf{HF}}\\mathbf{v}_j = \\mathbf{0}</span>  is a witness for the OR-branch in  <span class="math">\\Xi^{\\mathrm{fin}\\vee \\mathrm{sis}}</span>  (of norm at most  <span class="math">2\\beta</span> ). Hence, from now on, we assume all transcripts contain the same  <span class="math">\\mathbf{W}_j = \\mathbf{W}_j^{(k)}</span>  for all  <span class="math">k\\in [d]</span> .</p>

    <p class="text-gray-300">Step 2 (bottom rows): Now, we consider the bottom row, with an arbitrary  <span class="math">\\underline{\\mathbf{H}}</span> . Towards showing  <span class="math">d</span> -special soundness, define for  <span class="math">i \\in [0, \\mu - 1]</span>  and  <span class="math">j \\in [0, d - 1]</span>  the shorthand</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {Z} _ {i, j} = \\mathbf {D} _ {i} \\widetilde {\\mathbf {F}} \\mathbf {W} _ {j}.</span></div>

    <p class="text-gray-300">As the first step, we show that  <span class="math">\\underline{\\mathbf{H}}\\mathbf{Z}_{i,j} = \\underline{\\mathbf{Y}}_{i,j}</span>  for all  <span class="math">i,j</span> . Towards this, we rewrite the verifier's checks as</p>

    <div class="my-4 text-center"><span class="math-block">\\underline {{\\mathbf {H}}} \\cdot \\mathbf {Z} _ {j} \\cdot \\mathbf {c} ^ {(k)} = \\sum_ {i} \\underline {{\\mathbf {H}}} \\cdot (\\mathbf {Z} _ {i, j}) _ {i} c _ {i} ^ {(k)} = \\sum_ {i} (\\underline {{\\mathbf {Y}}} _ {i, j}) _ {i} c _ {i} ^ {(k)} = \\underline {{\\mathbf {Y}}} _ {j} \\cdot \\mathbf {c} ^ {(k)}</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{Z}_j = (\\mathbf{Z}_{0,j},\\dots,\\mathbf{Z}_{d - 1,j})</span>  and likewise for  <span class="math">\\underline{\\mathbf{Y}}_j</span> . From  <span class="math">d</span>  distinct challenges, we assemble a (Vandermonde) matrix  <span class="math">\\mathbf{C} = (\\mathbf{c}^{(0)},\\dots,\\mathbf{c}^{(d - 1)})</span> . Since  <span class="math">\\mathcal{C}_{\\mathcal{R}_q}</span>  has the invertibility of differences property,  <span class="math">\\mathbf{C}</span>  is invertible over  <span class="math">\\mathcal{R}_q</span> , and therefore</p>

    <div class="my-4 text-center"><span class="math-block">\\underline {{\\mathbf {H}}} \\cdot \\mathbf {Z} _ {j} \\cdot \\mathbf {C} = \\underline {{\\mathbf {Y}}} _ {j} \\cdot \\mathbf {C} \\quad \\Longrightarrow \\quad \\underline {{\\mathbf {H}}} \\cdot \\mathbf {Z} _ {j} = \\underline {{\\mathbf {Y}}} _ {j}.</span></div>

    <p class="text-gray-300">Thus  <span class="math">\\underline{\\mathbf{H}}\\mathbf{Z}_{i,j} = \\underline{\\mathbf{Y}}_{i,j}</span>  for all  <span class="math">i,j</span>  as claimed. Then we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\underline {{\\mathbf {Y}}} = \\sum_ {i} \\underline {{\\mathbf {Y}}} _ {i, i} = \\underline {{\\mathbf {H}}} \\sum_ {i} \\mathbf {Z} _ {i, i} = \\underline {{\\mathbf {H}}} \\sum_ {i} \\mathbf {D} _ {i} \\widetilde {\\mathbf {F}} \\mathbf {W} _ {i} = \\underline {{\\mathbf {H}}} \\mathbf {F} \\mathbf {W}</span></div>

    <p class="text-gray-300">and therefore,  <span class="math">\\mathbf{W}</span>  (as assembled in Step 1) is a witness for the bottom rows as well.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Step 3 (OR-branch): Finally consider the OR-branch in  <span class="math">\\Xi^{\\mathrm{fin}\\vee \\mathrm{sis}}</span> . If  <span class="math">\\overline{\\mathbf{HF}}\\mathbf{v}_j = \\mathbf{0}</span> , we simply let  <span class="math">\\mathbf{v}_j</span>  be the extracted witness note that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}_j\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\leq \\beta^{\\mathrm{sis}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 6. Protocol  <span class="math">\\Pi^{\\mathrm{split}}</span>  can be optimised. For example, suppose that  <span class="math">\\mathbf{r}_0 = \\mathbf{R}\\mathbf{e}_0</span>  has no zero component. Then instead of sending  <span class="math">\\overline{\\mathbf{Y}}_0</span> , we can compute it as  <span class="math">\\mathbf{D}_0^{-1}\\sum_{i\\in [d]\\setminus \\{0\\}}\\mathbf{D}_i\\overline{\\mathbf{Y}}_i</span>  because no other choice satisfies the verifier's check. Similarly, we can omit  <span class="math">\\underline{\\mathbf{Y}}_{0,0}</span> . For arbitrary  <span class="math">\\mathbf{R}</span> , in each row there is some  <span class="math">i</span>  such that  <span class="math">\\mathbf{R}\\mathbf{e}_i</span>  is not zero (else  <span class="math">\\mathbf{F}</span>  has a zero row, which is useless), so a more complex variant of this optimization always applies, saving  <span class="math">d\\mathcal{R}_q</span> -elements of communication. Moreover, whenever  <span class="math">\\underline{\\mathbf{H}}</span>  has structured rows (e.g. contains (permuted) identity submatrices, etc.), application specific optimisations may apply.</p>

    <p class="text-gray-300">In Fig. 5, we present the protocol  <span class="math">\\Pi^{\\mathrm{fold}}</span> , which is a simple batching technique which reduces the number  <span class="math">r</span>  of columns in  <span class="math">\\mathbf{W}</span> . It takes an instance of  <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})</span>  of  <span class="math">\\Xi_{m,r_{\\mathrm{in}}}^{\\mathrm{fin}}</span> , and produces a random linear combination  <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\widetilde{\\mathbf{W}})</span>  in  <span class="math">\\Xi_{m,r_{\\mathrm{out}}}^{\\mathrm{fin}}</span>  as output, with increased norm bounds.</p>

    <p class="text-gray-300">Lemma 6 (Fold). Let  <span class="math">m, r_{\\mathrm{in}}, r_{\\mathrm{out}}, \\in \\mathbb{N}</span>  and  <span class="math">0 \\leq \\beta&#x27; \\leq \\beta^{\\mathrm{sis}} \\leq q</span> . Protocol  <span class="math">\\Pi^{\\mathrm{fold}}</span>  is a perfectly correct self-reduction of knowledge for  <span class="math">\\Xi^{\\mathrm{fin}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(r _ {\\mathrm {i n}}, \\beta\\right) \\mapsto \\left(r _ {\\mathrm {o u t}}, \\boxed {\\sqrt {r _ {\\mathrm {o u t}}} r _ {\\mathrm {i n}} \\gamma \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\beta} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}} \\left(\\mathsf {r e s p .}, \\boxed {r _ {\\mathrm {i n}} \\gamma \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\beta} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}}\\right)\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">It is a relaxed knowledge sound self-reduction for <span class="math">\\Xi^{\\mathrm{lin}\\vee\\mathrm{sis}}</span> with parameters</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left(r_{\\mathrm{in}}, \\left[ \\underline{2 \\sqrt{r_{\\mathrm{in}}} \\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2} \\beta'}\\right]_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2} \\left(\\text{resp.}, \\left[ \\underline{2 \\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty} \\beta'}\\right]_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty}\\right), \\beta^{\\mathrm{sis}}\\right) \\leftrightarrow \\left(r_{\\mathrm{out}}, \\beta', \\beta^{\\mathrm{sis}}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">with <span class="math">r_{\\mathrm{in}}</span>-CWSS extraction.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. For perfect correctness, it is clear that <span class="math">\\widetilde{\\mathbf{W}}</span> satisfies <span class="math">\\mathbf{HF}\\widetilde{\\mathbf{W}} = \\widetilde{\\mathbf{Y}}</span> by construction. Moreover, for <span class="math">\\mathbf{W} = (\\mathbf{w}_i)_{i\\in [r_{\\mathrm{in}}]}</span> and <span class="math">\\widetilde{\\mathbf{W}} = (\\widetilde{\\mathbf{w}}_i)_{i\\in [r_{\\mathrm{out}}]}</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\widetilde{\\mathbf{W}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{out}}} \\max_{i\\in [r_{\\mathrm{out}}]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\widetilde{\\mathbf{w}}_i)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{out}}} \\sum_{j\\in [r_{\\mathrm{out}}]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(c_{j,i}\\mathbf{w}_j)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{out}}} \\sum_{j\\in [r_{\\mathrm{in}}]} \\gamma_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{w}_j)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{out}}} \\gamma_2 r_{\\mathrm{in}} \\beta<span class="math">, and with a similar reasoning </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\widetilde{\\mathbf{W}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq \\gamma_\\infty r_{\\mathrm{in}} \\beta$, thus the norm is also within bounds and correctness follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For relaxed knowledge soundness, through <span class="math">r_{\\mathrm{in}}</span>-CWSS we are given <span class="math">r_{\\mathrm{in}} + 1</span> accepting transcripts <span class="math">\\widetilde{\\mathbf{W}}_0, \\ldots, \\widetilde{\\mathbf{W}}_{r_{\\mathrm{in}}}</span>, for challenges <span class="math">\\mathbf{C}^{(i)} = \\sum_{k \\in [r_{\\mathrm{in}}]} \\mathbf{c}_k \\otimes \\mathbf{c}_k^{\\mathsf{T}(i)}</span> where <span class="math">\\mathbf{C}^{(i)}</span> and <span class="math">\\mathbf{C}^{(r_{\\mathrm{in}})}</span> differ exactly in row <span class="math">i \\in \\{0, \\ldots, r_{\\mathrm{in}} - 1\\}</span>. We can now subtract the accepting equations to obtain</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{HF} (\\widetilde{\\mathbf{W}}_i - \\widetilde{\\mathbf{W}}_{r_{\\mathrm{in}}}) = \\mathbf{Y} (\\mathbf{C}^{(i)} - \\mathbf{C}^{(r_{\\mathrm{in}})}) = \\mathbf{y}_i \\big(\\mathbf{c}_i^{(i)} - \\mathbf{c}_i^{(r_{\\mathrm{in}})}\\big)^\\top.</span></div>

    <p class="text-gray-300">Let <span class="math">j \\in [r_{\\mathrm{out}}]</span> be selected such that <span class="math">c_{i,j}^{(i)} \\neq c_{i,j}^{(r_{\\mathrm{in}})}</span>. Let <span class="math">(\\widetilde{\\mathbf{W}}_i - \\widetilde{\\mathbf{W}}_{r_{\\mathrm{in}}}) = \\widehat{\\mathbf{W}}_i = (\\widehat{\\mathbf{w}}_{i,j})_{j \\in [r_{\\mathrm{out}}]}</span> Thus, setting</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{w}_i := \\frac{1}{c_{i,j}^{(i)} - c_{i,j}^{(r_{\\mathrm{in}})}} \\widehat{\\mathbf{w}}_{i,j}</span></div>

    <p class="text-gray-300">is a column of witness in <span class="math">\\mathcal{R}_q^m</span>, where we use the subtractive set property of <span class="math">\\mathcal{C}_{\\mathcal{R}}</span> to ensure division in <span class="math">\\mathcal{R}</span>. The recovered witness satisfies <span class="math">\\mathbf{HFW} = \\mathbf{Y}</span> by construction. Moreover, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{in}}} \\cdot \\max_{i \\in [r_{\\mathrm{in}}]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{w}_i) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 = \\sqrt{r_{\\mathrm{in}}} \\cdot \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\frac{1}{c_i^{(i)} - c_i^{(r_{\\mathrm{in}})}} \\widehat{\\mathbf{w}}_{i,j}\\right) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{r_{\\mathrm{in}}} \\cdot \\theta_2 \\cdot 2 \\cdot \\beta_1'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">and by the same reasoning</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_\\infty \\leq \\max_{i \\in [r_{\\mathrm{in}}]} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\mathbf{w}_i) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\theta_\\infty \\cdot 2 \\cdot \\beta_1'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">by definition of the inverse-expansion factor for <span class="math">\\mathcal{C}_{\\mathcal{R}}</span>. For the knowledge error, we use <span class="math">r_{\\mathrm{in}}</span>-CWSS: The challenge space per coordinate is <span class="math">\\mathcal{C}_{\\mathcal{R}}^{r_{\\mathrm{out}}}</span>, and we need to extract <span class="math">r_{\\mathrm{in}}</span> coordinates, hence $\\kappa \\leq \\frac{r_{\\mathrm{in}}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{r_{\\mathrm{out}}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, the OR-branch in <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span> is handled by letting <span class="math">\\mathbf{w}</span> equal to a non-zero columns of <span class="math">\\widehat{\\mathbf{w}}</span>; obviously, <span class="math">\\overline{\\mathbf{HFw}} = \\mathbf{0}</span> holds and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta' \\leq \\beta^{\\mathrm{sis}}$. This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-42" class="text-2xl font-bold">5.5 <span class="math">\\Pi^{\\mathrm{batch}}</span>: Batch-Rows Knowledge Reduction</h2>

    <p class="text-gray-300">The protocol <span class="math">\\Pi^{\\mathrm{batch}}</span> (Fig. 6) is a protocol to batch the claims along multiple rows into fewer rows of claims. This is done by a random linear combination of the rows in question. This protocol maps an instance <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})</span> of <span class="math">\\Xi_{m,\\beta}^{\\mathrm{lin}}</span> to an instance <span class="math">((\\widetilde{\\mathbf{H}},\\mathbf{F},\\widetilde{\\mathbf{Y}}),\\mathbf{W})</span>, where the height of <span class="math">\\widetilde{\\mathbf{Y}}</span> is smaller. We describe it in more detail: Let <span class="math">n^{\\mathrm{out}} = \\overline{n} + \\underline{n}</span>. Then <span class="math">\\Pi^{\\mathrm{batch}}</span> keeps the top <span class="math">\\overline{n}</span> rows <span class="math">\\overline{\\mathbf{y}}</span> of <span class="math">\\mathbf{Y}</span> (resp. <span class="math">\\overline{\\mathbf{H}}</span> of <span class="math">\\mathbf{H}</span>, and thus of <span class="math">\\mathbf{HF}</span>) unchanged. But the bottom <span class="math">\\underline{n}</span> rows are linearly combined into a single row. For this, <span class="math">\\mathbf{H}</span> and <span class="math">\\mathbf{Y}</span> are split into top and bottom half, and the bottom half is multiplied by a vector <span class="math">\\mathbf{c}</span> consisting of powers of <span class="math">c \\leftrightarrow \\mathcal{C}_{\\mathcal{R}_q}</span>. Both parties then update the statement suitably.</p>

    <p class="text-gray-300"><strong>Lemma 7 (Batch).</strong> Let <span class="math">n^{\\mathrm{out}}, \\overline{n} \\in \\mathbb{N}</span> and <span class="math">0 \\leq \\beta \\leq \\beta^{\\mathrm{sis}} \\leq q</span>. Protocol <span class="math">\\Pi^{\\mathrm{batch}}</span> is a perfectly correct self-reduction of knowledge for <span class="math">\\Xi^{\\mathrm{lin}}</span> with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(n^{\\mathrm{out}}, \\beta\\right) \\mapsto \\left(\\overline{n} + 1, \\beta\\right).</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It is a relaxed knowledge sound self-reduction for <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span> with knowledge error $\\kappa = \\frac{n^{\\mathrm{out}} - \\overline{n} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{r\\cdot \\underline{n}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> if </span>2\\beta' \\leq \\beta^{\\mathrm{sis}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(n^{\\mathrm{out}}, \\beta&#x27;, \\beta^{\\mathrm{sis}}\\right) \\leftrightarrow \\left(\\overline{n} + 1, \\beta&#x27;, \\beta^{\\mathrm{sis}}\\right).</span></div>

    <p class="text-gray-300">Extraction requires two uniformly distributed transcripts (Footnote 11).</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 6. Protocol  <span class="math">\\varPi^{\\mathrm{batch}}</span>  reduces an instance of  <span class="math">\\Xi_{\\mathrm{par - in}}^{\\mathrm{lin}}</span>  to  <span class="math">\\Xi_{\\mathrm{par - out}}^{\\mathrm{lin}}</span>  with par-in, par-out specified in Lemma 4, with fewer rows by batching to the last  <span class="math">\\underline{n}</span>  of  <span class="math">\\mathbf{H}</span> .  <span class="math">\\varPi^{\\mathrm{batch}}</span>  sends the marked parts only as a proof (but not reduction) of knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The correctness of this protocol is straightforward by linearity. For (knowledge) soundness, we rely on the Schwartz-Zippel lemma over  <span class="math">\\mathcal{C}_{\\mathcal{R}_q}</span> , which we recall is almost a subfield  <span class="math">\\mathbb{F}</span>  of  <span class="math">\\mathcal{R}_q</span>  except that 0 is missing. The lemma states that, for any degree- <span class="math">d</span>  non-zero polynomial over  <span class="math">\\mathbb{F}</span> , the probability that the polynomial evaluates to zero at a uniformly random point chosen from  <span class="math">\\mathcal{C}_{\\mathcal{R}_q}</span>  is at most  $d /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . To translate this upper bound into a knowledge error, observe the following: If  </span>\\mathcal{A}<span class="math">  succeeds for 2 challenges, then the first transcript fixes some  </span>\\mathbf{W}_1<span class="math">  which satisfies  </span>((\\widetilde{\\mathbf{H}}_1,\\mathbf{F},\\widetilde{\\mathbf{Y}}_1),\\mathbf{W}_1)\\in \\Xi^{\\mathrm{lin}}<span class="math"> . Suppose  </span>((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W}_1)\\notin \\Xi^{\\mathrm{lin}}<span class="math"> , i.e.  </span>\\mathbf{W}_1<span class="math">  is not a witness for the original statement. Then we observe that at most a fraction of  </span>\\kappa = \\frac{n^{\\mathrm{out}} - \\overline{n} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  challenges can be accepting for  </span>\\mathbf{W}_1<span class="math">  (by Schwartz-Zippel and union bound). In other words, if  </span>\\mathcal{A}<span class="math">  succeeds with probability  </span>\\epsilon<span class="math"> , then with probability at least  </span>\\epsilon - \\kappa<span class="math">  the 2-transcript extractor successfully outputs two transcripts where the responses  </span>\\mathbf{W}_1<span class="math">  and  </span>\\mathbf{W}_2<span class="math">  differ. </span>^{16}<span class="math">  Now,  </span>\\mathbf{V} = \\mathbf{W}_1 - \\mathbf{W}_2<span class="math">  is a non-zero preimage with a non-zero column  </span>\\mathbf{v}<span class="math"> , s.t.  </span>\\widetilde{\\mathbf{H}}\\mathbf{F}\\mathbf{v} = \\mathbf{0}<span class="math">  of norm at most  </span>2\\beta' \\leq \\beta^{\\mathrm{sis}}<span class="math"> , i.e. the OR-branch of  </span>\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 7. The knowledge-error can improved by issuing  <span class="math">t &amp;gt; 1</span>  challenges which yields  $\\kappa = \\frac{n^{\\mathrm{out}} - \\overline{n} - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\left(\\frac{r \\cdot n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right)^t<span class="math"> . The protocol remains the same with the exception that instead of a vector  </span>\\mathbf{c}<span class="math"> , the protocol uses a matrix  </span>\\mathbf{C} \\in \\mathcal{R}_q^{n \\times t}<span class="math"> , where  </span>i<span class="math"> -th row is a series of consecutive powers of challenge  </span>\\xi_i<span class="math">  for  </span>i \\in [t]<span class="math"> . The protocol is a perfectly correct self-reduction of knowledge for  </span>\\Xi^{\\mathrm{lin}}$  with parameters</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\left(n ^ {\\text {o u t}}, \\beta\\right) \\mapsto \\left(\\bar {n} + t, \\beta\\right).</span></div>

    <p class="text-gray-300">It is a relaxed knowledge sound self-reduction for  <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}</span>  with knowledge error  <span class="math">\\kappa</span>  if  <span class="math">2\\beta^{\\prime}\\leq \\beta^{\\mathrm{sis}}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(n ^ {\\text {o u t}}, \\beta^ {\\prime}, \\beta^ {\\text {s i s}}\\right) \\leftrightarrow \\left(\\bar {n} + t, \\beta^ {\\prime}, \\beta^ {\\text {s i s}}\\right).</span></div>

    <p class="text-gray-300">Similarly, the extraction requires two uniformly distributed transcripts.</p>

    <p class="text-gray-300">To restrain the norm growth of the extracted witness, we introduce norm checks. We present the norm check protocol  <span class="math">\\varPi^{\\mathrm{norm}}</span> , which handles reducing the norm relation  <span class="math">\\Xi^{\\mathrm{norm}}</span> , to multiple  <span class="math">\\Xi^{\\mathrm{lin}}</span>  relations. The relations  <span class="math">\\Xi^{\\mathrm{norm}}</span>  and  <span class="math">\\Xi^{\\mathrm{ip}}</span> , as well as their variants  <span class="math">\\Xi^{\\mathrm{norm}\\vee \\mathrm{sis}}</span>  and  <span class="math">\\Xi^{\\mathrm{ip}\\vee \\mathrm{sis}}</span> , are defined as follows.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_ {\\mathcal {R}, q, m, n ^ {\\mathrm {o u t}}, r, \\mu , \\beta , \\beta^ {\\mathrm {s i n}}} ^ {\\mathrm {n o r m} \\vee \\mathrm {s i s}} := \\left\\{ \\begin{array}{l} ((\\mathbf {H}, \\mathbf {F}, \\mathbf {Y}, \\mathbf {c}, \\nu), \\mathbf {W} \\text {o r} \\mathbf {w}): \\\\ \\quad \\mathbf {H} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {o u t}} \\times n}; \\mathbf {F} \\in \\mathcal {R} _ {q} ^ {n \\times d ^ {\\otimes \\mu}} \\subseteq \\mathcal {R} _ {q} ^ {n \\times m}; \\mathbf {Y} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {o u t}} \\times r}; \\mathbf {c} \\in \\mathcal {R} _ {q} ^ {r} \\text {s . t .} \\overline {{\\mathbf {c}}} = \\mathbf {c}; \\\\ \\quad 0 \\leq \\nu \\leq \\beta ; \\mathbf {W} = (\\mathbf {w} _ {i}) _ {i = 0} ^ {r} \\in \\mathcal {R} ^ {m \\times r}; \\mathbf {w} \\in \\mathcal {R} ^ {m} \\\\ \\left\\{ \\begin{array}{l} \\sum_ {i = 0} ^ {r} c _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {w} _ {i} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\nu \\\\ \\mathbf {H F W} = \\mathbf {Y} \\bmod q \\end{array} \\right\\} \\quad \\text {o r} \\quad \\left\\{ \\begin{array}{l} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta^ {\\mathrm {s i s}} \\\\ \\widetilde {\\mathbf {H}} \\mathbf {F} \\mathbf {w} = 0 _ {\\overline {{n}}} \\bmod q \\end{array} \\right\\}, \\end{array} \\right.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Xi_{\\mathcal{R},q,m,n^{\\mathrm{net}},r,\\mu,\\beta,\\beta^{\\mathrm{in}},\\alpha}^{\\mathrm{ip}\\vee \\mathrm{vis}} := \\left\\{ \\begin{array}{l}((\\mathbf{H}, \\mathbf{F}, \\mathbf{Y}, \\mathbf{c}, t), \\mathbf{W} \\text{ or } \\mathbf{w}): \\\\ \\qquad \\qquad \\mathbf{H} \\in \\mathcal{R}_{q}^{n^{\\mathrm{net}}\\times n}; \\mathbf{F} \\in \\mathcal{R}_{q}^{n\\times d^{\\oplus \\nu}} \\subseteq \\mathcal{R}_{q}^{n\\times m}; \\mathbf{Y} \\in \\mathcal{R}_{q}^{n^{\\mathrm{net}}\\times r}; \\mathbf{c} \\in \\mathcal{R}_{q}^{r} \\text{ s.t. } \\alpha(\\mathbf{c}) = \\mathbf{c} \\\\ \\qquad \\qquad t \\in \\mathcal{R}; \\mathbf{W} = (\\mathbf{w}_{i})_{i=0}^{r} \\in \\mathcal{R}^{m\\times r}; \\mathbf{w} \\in \\mathcal{R}^{m} \\\\ \\qquad \\qquad \\left\\{ \\begin{array}{c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\\\ \\mathbf{H F W} = \\mathbf{Y} \\bmod q \\\\ \\sum_{i=0}^{r} c_{i}\\langle \\mathbf{w}_{i}, \\alpha(\\mathbf{w}_{i}) \\rangle_{\\mathcal{R}} = t \\bmod q \\end{array} \\right\\} \\text{ or } \\left\\{ \\begin{array}{c} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta^{\\mathrm{vis}} \\\\ \\overline{\\mathbf{H F w}} = 0_{\\mathbb{H}} \\bmod q \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\end{array} \\right\\}. $$</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Note that, compared to <span class="math">\\Xi^{\\mathrm{fin}}</span>, the norm relation <span class="math">\\Xi^{\\mathrm{norm}}</span> differs in that a witness norm bound <span class="math">\\nu \\leq \\beta</span> is given as part of the statement, and a stricter weighted norm relation $\\sum_{i=0}^{r} c_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}_i \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\nu<span class="math"> is checked. Similarly, </span>\\Xi^{\\mathrm{ip}}<span class="math"> differs from </span>\\Xi^{\\mathrm{fin}}<span class="math"> in that the statement additionally includes an inner product value </span>t<span class="math">, and the witness additionally satisfies a weighted inner product relation. Furthermore, we note that </span>\\Xi^{\\mathrm{ip}}<span class="math"> is parametrised by </span>\\alpha \\in \\{\\mathrm{id}, \\overline{\\mathrm{id}}\\}<span class="math"> which is either the identity or complex conjugate, controlling which type of inner product is being considered. We require that the weights are invariant under </span>\\alpha<span class="math">, i.e. </span>\\alpha(\\mathbf{c}) = \\mathbf{c}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The protocols <span class="math">\\Pi^{\\mathrm{norm}}</span> and <span class="math">\\Pi^{\\mathrm{ip}}</span>. The protocols <span class="math">\\Pi^{\\mathrm{norm}}</span>, <span class="math">\\Pi^{\\mathrm{ip}}</span> for <span class="math">\\alpha = \\mathrm{id}</span> and <span class="math">\\Pi^{\\mathrm{ip}}</span> for <span class="math">\\alpha = \\overline{\\mathrm{id}}</span> are very similar. In the following description we focus on <span class="math">\\Pi^{\\mathrm{ip}}</span> for <span class="math">\\alpha = \\overline{\\mathrm{id}}</span>. Removing all conjugates yields the protocol <span class="math">\\Pi^{\\mathrm{ip}}</span> for <span class="math">\\alpha = \\mathrm{id}</span>. The protocol <span class="math">\\Pi^{\\mathrm{norm}}</span> can be obtained by letting the verifier compute the trace of the alleged inner product.</p>

    <p class="text-gray-300">Our approach is based on polynomial identities. For <span class="math">\\mathbf{w} \\in \\mathcal{R}^m</span>, define the polynomials</p>

    <div class="my-4 text-center"><span class="math-block">g _ {\\mathbf {w}} (X) = \\sum_ {j \\in [ m ]} w _ {j} X ^ {j} \\quad \\text {resp.} \\quad \\bar {g} _ {\\mathbf {w}} (X) = \\sum_ {j \\in [ m ]} \\bar {w} _ {j} X ^ {j} \\tag {6}</span></div>

    <p class="text-gray-300">and observe that <span class="math">\\bar{g}_{\\mathbf{w}} = g_{\\bar{\\mathbf{w}}}</span> and that the Laurent polynomial</p>

    <div class="my-4 text-center"><span class="math-block">L (X) = \\sum_ {i \\in \\pm [ m ]} v _ {i} X ^ {i} := g _ {\\mathbf {w}} (X) \\cdot \\bar {g} _ {\\mathbf {w}} \\left(X ^ {- 1}\\right) \\tag {7}</span></div>

    <p class="text-gray-300">has constant coefficient <span class="math">\\langle \\mathbf{w},\\bar{\\mathbf{w}}\\rangle_{\\mathcal{R}}</span>. Also, observe that</p>

    <div class="my-4 text-center"><span class="math-block">v _ {k} = \\sum_ {i - j = k} v _ {i} \\bar {v} _ {j} = \\overline {{\\mathrm {i d}}} \\left(\\sum_ {i - j = k} \\bar {v} _ {i} v _ {j}\\right) = \\overline {{\\mathrm {i d}}} \\left(\\sum_ {j - i = k} \\bar {v} _ {j} v _ {i}\\right) = \\bar {v} _ {- k}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">v_{k} \\coloneqq 0</span> if $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq m<span class="math">. We exploit this symmetry to commit to </span>L(X)<span class="math"> by committing only to </span>(v_{0}, \\ldots, v_{m-1})$. Setting</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">h (X) = \\sum_ {i \\in [ m ]} v _ {i} X ^ {i} \\quad \\text {resp.} \\quad \\bar {h} (X) = \\sum_ {i \\in [ m ]} \\bar {v} _ {i} X ^ {i}</span></div>

    <p class="text-gray-300">we see that</p>

    <div class="my-4 text-center"><span class="math-block">L (X) = h (X) + \\bar {h} (X ^ {- 1}) - v _ {0}.</span></div>

    <p class="text-gray-300">We use this equality to prove the polynomial identity in Eq. (7) between <span class="math">\\mathbf{v}</span> and <span class="math">\\mathbf{W}</span> by evaluating <span class="math">g, \\bar{g}, h, \\bar{h}</span> at a random point <span class="math">\\xi \\gets \\mathcal{C}_{\\mathcal{R}_q}</span> (and checking if <span class="math">v_0 = t</span>).</p>

    <p class="text-gray-300">To generalize the above to the weighted inner product <span class="math">v_{0} = \\sum_{j\\in [r]}c_{j}\\langle \\mathbf{w}_{j},\\overline{\\mathbf{w}}_{j}\\rangle_{\\mathcal{R}}</span> for a matrix witness <span class="math">\\mathbf{W} = (\\mathbf{w}_1,\\dots ,\\mathbf{w}_r)\\in \\mathcal{R}^{m\\times r}</span> with weights <span class="math">\\mathbf{c}</span> that satisfy <span class="math">\\mathbf{c} = \\overline{\\mathbf{c}}</span>, we apply the above approach component-wise, and then compute the weighted sum. Consequently, we set</p>

    <div class="my-4 text-center"><span class="math-block">L (X) = \\sum_ {i \\in \\pm [ m ]} v _ {i} X ^ {i} := \\sum_ {j \\in [ r e p ]} c _ {j} L _ {j} (X)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text {where} \\quad L _ {j} (X) = \\sum_ {i \\in \\pm [ m ]} v _ {j, i} X ^ {i} = g _ {\\mathbf {w} _ {j}} (X) \\cdot \\bar {g} _ {\\mathbf {w} _ {j}} \\left(X ^ {- 1}\\right) \\tag {8}</span></div>

    <p class="text-gray-300">and observe that the constant coefficient <span class="math">v_{0}</span> of <span class="math">L(X)</span> is now <span class="math">\\sum_{j\\in [r]}c_{j}\\langle \\mathbf{w}_{j},\\hat{\\mathbf{w}}_{j}\\rangle_{\\mathcal{R}}</span>. Since we require <span class="math">\\mathbf{c} = \\alpha (\\mathbf{c})</span> from the weights <span class="math">\\mathbf{c}</span>, we still have <span class="math">v_{k} = \\bar{v}_{-k}</span>. Thus, we can again define</p>

    <div class="my-4 text-center"><span class="math-block">h (X) = \\sum_ {i \\in [ m ]} v _ {i} X ^ {i} \\quad \\text {resp.} \\quad \\bar {h} (X) = \\sum_ {i \\in [ m ]} \\bar {v} _ {i} X ^ {i} \\tag {9}</span></div>

    <p class="text-gray-300">and obtain again the equality</p>

    <p class="text-gray-300"><span class="math">L(X)=h(X)+\\bar{h}(X^{-1})-v_{0}.</span> (10)</p>

    <p class="text-gray-300">where <span class="math">v_{0}=\\sum_{j\\in[r]}c_{j}\\langle\\mathbf{w}_{j},\\bar{\\mathbf{w}}_{j}\\rangle_{\\mathcal{R}}</span>. Thus, we extended the check from a vector <span class="math">\\mathbf{w}</span> to a matrix <span class="math">\\mathbf{W}=(\\mathbf{w}_{1},\\ldots,\\mathbf{w}_{r})</span>, by considering <span class="math">g_{\\mathbf{w}_{j}},\\bar{g}_{\\mathbf{w}_{j}}</span> and <span class="math">L_{j}</span> first component-wise, and then summing up those components with weights <span class="math">c</span> to obtain <span class="math">L</span> (and the symmetry decomposition <span class="math">h</span> of <span class="math">L</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If the above check based on polynomial identities is used naively, a problem occurs: The terms <span class="math">v_{i}</span> have the norm of the individual coefficients bounded by <span class="math">\\beta^{2}</span>, so $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{v}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ may be beyond the threshold for which the commitment is binding.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A natural approach is to run <span class="math">\\Pi^{b\\text{-decomp}}</span> to counteract this problem. However, doing so modularly comes at the cost of a suboptimal relaxed knowledge guarantee. We can tighten our analysis if we treat the composition with <span class="math">\\Pi^{b\\text{-decomp}}</span> as <em>within</em> the protocol <span class="math">\\Pi^{\\text{ip}}</span>, i.e. we immediately send the decomposed (and binding) commitments. The reason is a technical artefact of relaxed knowledge soundness and reductions of knowledge: Relaxed soundness in <span class="math">\\Pi^{b\\text{-decomp}}</span> incurs a large factor of norm growth when extracting the witness. However, in <span class="math">\\Pi^{\\text{ip}}</span>, the auxiliary commitment to <span class="math">\\mathbf{v}</span> is <em>not</em> part of the witness (yet), and we need not extract it. Thus, we argue directly for the decomposition of <span class="math">\\mathbf{v}</span> into smaller <span class="math">\\mathbf{V}=(\\mathbf{v}_{i})_{i}</span> of norm <span class="math">\\approx\\beta</span>. This avoids treating <span class="math">\\mathbf{v}</span> as a witness in <span class="math">\\Pi^{b\\text{-decomp}}</span>, which significantly improves the parameters. This optimised protocol is presented in Fig. 7</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Lemma 8 (Norm and Inner Product).</h6>

    <p class="text-gray-300">Let <span class="math">m,r,\\ell,b_{\\text{ip}}\\in\\mathbb{N}</span> and <span class="math">0\\leq\\beta\\leq\\beta^{\\text{sis}}\\leq q</span>, <span class="math">0\\leq 2\\beta^{\\prime}\\leq\\beta^{\\text{sis}}</span>. Protocol <span class="math">\\Pi^{\\text{ip}}</span> is a perfectly correct reduction of knowledge from <span class="math">\\Xi^{\\text{ip}}</span> to <span class="math">\\Xi^{\\text{fin}}</span></p>

    <p class="text-gray-300"><span class="math">\\left(m,n^{\\text{out}},r,\\beta\\right)\\mapsto\\left(m,n^{\\text{out}^{\\prime}},r+\\ell,\\beta_{\\text{out}}\\right)</span></p>

    <p class="text-gray-300">where <span class="math">\\beta_{\\text{out}}=\\sqrt{\\beta^{2}+\\beta_{\\mathbf{V}}^{2}}</span> (resp. <span class="math">\\beta_{\\text{out}}=\\max\\{\\beta,\\beta_{\\mathbf{V}}\\}</span>), and knowledge sound reduction of knowledge from <span class="math">\\Xi^{\\text{ip}}</span> to <span class="math">\\Xi^{\\text{fin}}</span> with parameters</p>

    <p class="text-gray-300"><span class="math">\\left(m,n^{\\text{out}},r,\\beta^{\\prime},\\beta^{\\text{sis}}\\right)\\leftrightarrow\\left(m,n^{\\text{out}^{\\prime}},r+\\ell,\\beta_{\\text{out}}^{\\prime},\\beta^{\\text{sis}}\\right),</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">n^{\\text{out}^{\\prime}}=n^{\\text{out}}+3</span>, <span class="math">b_{\\text{ip}}</span> and <span class="math">\\ell\\geq\\log_{b_{\\text{ip}}}(2\\beta_{\\mathbf{V}}^{2}+1)</span> is such that <span class="math">b_{\\text{ip}}\\leq 2\\beta_{\\mathbf{V}}/(\\sqrt{\\ell m}\\sqrt{\\dagger\\varphi}\\,)</span> (resp. <span class="math">b_{\\text{ip}}=2\\beta_{\\mathbf{V}}+1</span> and <span class="math">\\ell\\geq\\log_{b_{\\text{ip}}}(2\\beta_{\\mathbf{V}}+1)</span>). Extraction requires two uniformly distributed transcripts (Footnote 11) and has knowledge error $\\kappa\\leq\\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_{q}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For <span class="math">\\Pi^{\\text{norm}}</span>, the analogous statements hold and additionally <span class="math">\\Pi^{\\text{norm}}</span> is a knowledge sound reduction of knowledge from <span class="math">\\Xi^{\\text{norm}}</span> to <span class="math">\\Xi^{\\text{fin}}</span> with parameters</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left(m,n^{\\text{out}},r,\\boxed{\\nu}_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\,\\left(\\text{resp.},\\boxed{\\sqrt{\\dagger\\varphi}\\,\\sqrt{mr}\\,\\nu}_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}}\\right),\\beta^{\\text{sis}}\\right)\\leftrightarrow\\left(m,n^{\\text{out}^{\\prime}},r+\\ell,\\beta^{\\prime},\\beta^{\\text{sis}}\\right).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-45" class="text-base font-medium mt-4">Proof.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\widetilde{\\mathbf{W}}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math">, observe that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\widetilde{\\mathbf{W}}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left((\\mathbf{V},\\mathbf{W}))\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{V}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}+\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{W}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}<span class="math">, where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{W}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}^{2}\\leq\\beta^{2}<span class="math"> by assumption on </span>\\mathbf{W}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{V}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{2}\\leq\\beta_{\\mathbf{V}}^{2}<span class="math"> by definition of </span>b_{\\text{ip}}<span class="math"> and the bounds for </span>\\Pi^{b\\text{-decomp}}<span class="math"> from Lemma 4. (We set </span>b_{\\text{ip}}<span class="math"> such that </span>\\frac{1}{2}\\sqrt{\\ell m}\\,\\sqrt{\\dagger\\varphi}\\,b_{\\text{ip}}\\leq\\beta_{\\mathbf{V}}$ holds by definition.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For the norm $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\widetilde{\\mathbf{W}}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}<span class="math">, observe that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\widetilde{\\mathbf{W}}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left((\\mathbf{V},\\mathbf{W})\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\max\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\mathbf{V}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty},\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\mathbf{W}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\}<span class="math">, where </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\mathbf{W}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math"> by assumption on </span>\\mathbf{W}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\mathbf{V}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{\\mathbf{V}}<span class="math"> by definition of </span>b_{\\text{ip}}=2\\beta_{\\mathbf{V}}+1<span class="math"> and the bounds for </span>\\Pi^{b\\text{-decomp}}$ from Lemma 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For correctness, observe that <span class="math">\\mathbf{EW}</span> contains the evaluations <span class="math">z_{+1,j}=\\sum_{i}w_{i,j}\\xi^{i}=g_{\\mathbf{w}_{j}}(\\xi)</span> and <span class="math">z_{-1,j}=\\sum_{i}w_{i,j}\\xi^{-i}=\\overline{g_{\\mathbf{w}_{j}}(\\xi^{-1})}</span>, and the component <span class="math">w_{0,j}</span> which we ignore. We can thus compute</p>

    <p class="text-gray-300"><span class="math">\\sum_{j\\in[r]}c_{j}g_{\\mathbf{w}_{j}}(\\xi)\\cdot\\vec{g_{\\mathbf{w}_{j}}}(\\xi^{-1})=\\mathbf{c}^{\\mathsf{T}}(\\mathbf{z}_{+1}\\odot\\overline{\\mathbf{z}}_{-1}).</span></p>

    <p class="text-gray-300">Similarly, <span class="math">\\mathbf{EV}(1,b,\\ldots,b^{t-1})=\\mathbf{Ev}</span> contains <span class="math">z^{\\prime}_{+1}=\\sum_{i}v_{i}\\xi^{i}</span> and <span class="math">z^{\\prime}_{-1}=\\sum_{i}v_{i}\\overline{\\xi}^{-i}</span> and <span class="math">v_{0}</span>. By the symmetry property <span class="math">L(\\xi)=\\sum_{i\\in[m]}v_{i}\\xi^{i}-v_{0}=</span> we recover <span class="math">L(\\xi)=z^{\\prime}_{+1}+\\overline{z}^{\\prime}_{-1}-t^{\\prime}</span>. Thus, correctness holds by the polynomial identities explained above, specifically Eqs. (8) to (10). As we already showed that the norm bounds are respected for the output, we have shown that the reduction of knowledge is perfectly complete.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 7. Protocol  <span class="math">\\boxed{\\Pi^{\\mathrm{ip}}}</span>  or  <span class="math">\\boxed{\\Pi^{\\mathrm{norm}}}</span>  a reduction of  <span class="math">\\boxed{\\Xi_{\\mathrm{par - in}}^{\\mathrm{ip}}}</span>  or  <span class="math">\\boxed{\\Xi_{\\mathrm{par - in}}^{\\mathrm{norm}}}</span>  to  <span class="math">\\Xi_{\\mathrm{par - out}}^{\\mathrm{lin}}</span>  with par-in, par-out specified in Lemma 8, with optimisation to directly include  <span class="math">\\Pi^{\\mathrm{h - decomp}}</span> , presented for  <span class="math">\\alpha = \\overline{\\mathrm{id}}</span> . To obtain  <span class="math">\\alpha = \\mathrm{id}</span>  all conjugates are removed.  <span class="math">\\Pi^{\\mathrm{ip}}</span>  sends the marked parts only as a proof (but not reduction) of knowledge.</p>

    <p class="text-gray-300">Now, we show relaxed knowledge soundness. First, observe that, as argued above, given fixed  <span class="math">\\mathbf{v}</span>  which defines  <span class="math">h(X) = \\sum_{i=0}^{m-1} v_i X^i</span> , then the probability that</p>

    <div class="my-4 text-center"><span class="math-block">L (X) \\neq h (X) + \\bar {h} \\left(X ^ {- 1}\\right) - v _ {0} \\quad \\text {b u t} \\quad L (\\xi) \\neq h (\\xi) + \\bar {h} \\left(\\xi^ {- 1}\\right) - v _ {0} \\tag {11}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">holds, is bounded by  $\\frac{2m - 1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} = \\kappa<span class="math"> , where  </span>\\xi \\gets \\mathbb{S}\\mathcal{C}_{\\mathcal{R}_q}<span class="math"> . (By the lemma of Schwartz-Zippel, analogous to Lemma 7.) However, this is a soundness argument for fixed polynomials, but the vector  </span>\\mathbf{v} = \\mathbf{V} \\cdot (1, \\ldots, b_{\\mathrm{ip}}^{\\ell - 1})<span class="math">  is only determined in the last step. Now, we argue analogous to Lemma 7 to turn soundness into knowledge soundness: Let  </span>\\mathbf{V}^{(0)}<span class="math">  with  </span>\\widehat{\\mathbf{HF}}\\mathbf{V}^{(0)} = \\widehat{\\mathbf{Y}}^{\\prime(0)}<span class="math">  denote the (first) preimage (from the two accepting transcripts). Let  </span>\\widehat{\\mathbf{y}}^{(0)} = \\widehat{\\mathbf{Y}}^{\\prime(0)} \\cdot (1, \\ldots, b_{\\mathrm{ip}}^{\\ell - 1})<span class="math">  denote the non-decomposed linear claim for  </span>\\mathbf{V}<span class="math"> . Observe that, unless the polynomial identity holds, only fraction  </span>\\kappa<span class="math">  of challenges can satisfy (11) for any fixed  </span>\\mathbf{V}^{(0)}<span class="math"> . Thus, if the adversary succeeds with probability  </span>\\epsilon<span class="math"> , then with probability  </span>\\epsilon - \\kappa<span class="math"> , the 2-transcript extractor gives two transcripts where either one  </span>\\mathbf{V}^b<span class="math">  satisfies the polynomial identity (and we&#x27;re done), or  </span>\\mathbf{V}^{(0)} \\neq \\mathbf{V}^{(1)}<span class="math"> . Let  </span>\\mathbf{U} = \\mathbf{V}^{(0)} - \\mathbf{V}^{(1)}<span class="math"> . Then we have  </span>\\mathbf{HFU} = 0<span class="math"> , as  </span>\\mathbf{HFV}^{(j)} = \\mathbf{Y}_j'<span class="math">  holds for both  </span>j = 0, 1<span class="math"> . This yields a witness for the OR-branch of  </span>\\Xi^{\\mathrm{ip} \\vee \\mathrm{sis}}<span class="math">  with norm at most  </span>2\\beta' \\leq \\beta^{\\mathrm{sis}}<span class="math"> . (Note here that the vector  </span>\\mathbf{v}<span class="math">  (which we decompose as  </span>\\mathbf{V}<span class="math"> ) is not part of the initial witness, so its norm is of no concern during extraction and we avoid the large growth of  </span>\\beta_0'$  for decomposition in Lemma 4.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To handle the norm protocol, we just note that  $\\sum_{i}x_{i}\\bar{x}_{i} = \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{x})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math"> , and that  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf{x})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq \\sqrt{\\mathfrak{f}\\varphi}\\sqrt{mr}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{x})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}<span class="math">  for  </span>\\mathbf{x}\\in \\mathcal{R}^{mr}<span class="math">  by Lemma 1 and the standard inequality between  </span>\\infty$ -norm and 2-norm.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">m←m'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">rin←rout</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β0←β1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">β1'←β0'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">κ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">#tr</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Condition</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πb-decomp</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">lrin</td>

            <td class="px-3 py-2 border-b border-gray-700">(0,√lrinm√fφb/2)</td>

            <td class="px-3 py-2 border-b border-gray-700">b2-1/2-1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">l = [logb(2β0+1)]</td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πsplit</td>

            <td class="px-3 py-2 border-b border-gray-700">1/d</td>

            <td class="px-3 py-2 border-b border-gray-700">drin</td>

            <td class="px-3 py-2 border-b border-gray-700">β0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">5</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πfold</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">rout</td>

            <td class="px-3 py-2 border-b border-gray-700">(√routrinγ,0)</td>

            <td class="px-3 py-2 border-b border-gray-700">2√rinθ</td>

            <td class="px-3 py-2 border-b border-gray-700">rln/</td>

            <td class="px-3 py-2 border-b border-gray-700">CRq</td>

            <td class="px-3 py-2 border-b border-gray-700">/∞</td>

            <td class="px-3 py-2 border-b border-gray-700">rin+1</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πbatch</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">rin</td>

            <td class="px-3 py-2 border-b border-gray-700">β0</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">rln/</td>

            <td class="px-3 py-2 border-b border-gray-700">CRq</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2β1' ≤ βsis</td>

            <td class="px-3 py-2 border-b border-gray-700">7</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πip</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">l+rin</td>

            <td class="px-3 py-2 border-b border-gray-700">√β02+βv2'</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">2m/</td>

            <td class="px-3 py-2 border-b border-gray-700">CRq</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2β0' ≤ βsis</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Πnorm</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">l+rin</td>

            <td class="px-3 py-2 border-b border-gray-700">√β02+βv2'</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">ν/β1'</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">2β0' ≤ βsis</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Parameters of protocols expressed in the canonical 2-norm. Expressed as  <span class="math">\\beta_{1} = f(\\beta_{0})</span>  for correctness when starting from  <span class="math">\\beta_{0}</span> , and as  <span class="math">\\beta_0^{\\prime} = g(\\beta_1^{\\prime})</span>  and  <span class="math">\\beta_0^\\prime \\leq \\beta^{\\mathrm{sis}}</span>  for relaxed soundness when guaranteed  <span class="math">\\beta_1^\\prime</span> , knowledge error  <span class="math">\\kappa</span> , number #tr of transcripts to extract, and other variables or important constraints. Full details in are in the respective theorems.</p>

    <p class="text-gray-300">In this section, we discuss how to compose the atomic protocols constructed in Section 5 to obtain asymptotically and concrete efficient succinct arguments for the principal relation  <span class="math">\\Xi^{\\mathrm{lin}}</span>  which does not have any correctness and soundness gaps. We begin in Section 6.1 by overviewing the functionality of each atomic protocol  <span class="math">\\Pi^{b\\text{-decomp}}</span> ,  <span class="math">\\Pi^{\\mathrm{split}}</span> ,  <span class="math">\\Pi^{\\mathrm{fold}}</span> ,  <span class="math">\\Pi^{\\mathrm{batch}}</span>  and  <span class="math">\\Pi^{\\mathrm{norm}}</span>  and discussing considerations when composing them.[18] We also introduce a dummy protocol  <span class="math">\\Pi^{\\mathrm{fmish}}</span>  which implements the trivial step of sending the witness in plain. We then provide an example composition Section 6.2 which, although not necessarily optimal in terms of concrete efficiency, serves as a baseline for compositions which we consider reasonable.</p>

    <p class="text-gray-300">We discuss how to compose the atomic protocols  <span class="math">\\Pi^{b\\text{-decomp}}</span> ,  <span class="math">\\Pi^{\\mathrm{split}}</span> ,  <span class="math">\\Pi^{\\mathrm{fold}}</span> ,  <span class="math">\\Pi^{\\mathrm{batch}}</span>  and  <span class="math">\\Pi^{\\mathrm{norm}}</span>  to obtain succinct arguments for  <span class="math">\\Xi^{\\mathrm{lin}}</span>  (or more precisely  <span class="math">\\Xi^{\\mathrm{lin} \\vee \\mathrm{sis}}</span> , see below).</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-48" class="text-base font-semibold mt-4">Bird-eye view of principal relation.</h5>

    <p class="text-gray-300">Recall that in <span class="math">\\mathcal{Z}^{\\text{lin}}</span> a statement <span class="math">(\\mathbf{H},\\mathbf{F},\\mathbf{Y})</span> and a witness <span class="math">\\mathbf{W}</span> satisfy the relation</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathbf{H}\\mathbf{F}\\mathbf{W}=\\mathbf{Y}\\bmod q</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\mathbf{H}\\in\\mathcal{R}_{q}^{n^{\\text{not}}\\times n}</span> consists of a top part <span class="math">\\overline{\\mathbf{H}}=(\\mathbf{I}_{\\overline{n}}\\;\\mathbf{0})\\in\\mathcal{R}_{q}^{\\overline{n}\\times n}</span> and a bottom part <span class="math">\\underline{\\mathbf{H}}\\in\\mathcal{R}_{q}^{n\\times n},\\mathbf{F}\\in\\mathcal{R}_{q}^{n\\times d^{\\otimes\\mu}}\\subseteq\\mathcal{R}_{q}^{n\\times m}</span>, <span class="math">\\mathbf{Y}\\in\\mathcal{R}_{q}^{n^{\\text{not}}\\times r}</span> and <span class="math">\\mathbf{W}\\in\\mathcal{R}^{m\\times r}</span>. Splitting <span class="math">\\mathbf{F}</span> and <span class="math">\\mathbf{Y}</span> into a top part <span class="math">(\\overline{\\mathbf{F}},\\overline{\\mathbf{Y}})\\in\\mathcal{R}_{q}^{\\overline{n}\\times d^{\\otimes\\mu}}\\times\\mathcal{R}_{q}^{\\overline{n}\\times r}</span> and a bottom part <span class="math">(\\underline{\\mathbf{F}},\\underline{\\mathbf{Y}})\\in\\mathcal{R}_{q}^{n\\times d^{\\otimes\\mu}}\\times\\mathcal{R}_{q}^{n\\times r}</span>, we can equivalently write the above relation as</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\begin{CD}\\pi\\overbrace{\\mathbf{F}}^{m=d^{\\otimes\\mu}}\\mathbf{W}=\\overbrace{\\mathbf{Y}}^{r}\\bmod q,\\quad\\pi\\overbrace{\\underline{\\mathbf{H}}^{m=d^{\\otimes\\mu}}\\mathbf{F}}^{r}\\mathbf{W}=\\overbrace{\\mathbf{Y}}^{r}\\bmod q,\\quad\\text{and}\\quad_{m=d^{\\otimes\\mu}}\\{\\overbrace{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{W}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}^{r}\\leq\\beta.\\end{CD}$ (12)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To catch the exception of a malicious prover succeeding in violating soundness through solving vSIS, the OR-branch of <span class="math">\\mathcal{Z}^{\\text{lin}\\vee\\text{sis}}</span> allows an alternative witness <span class="math">\\mathbf{w}\\in\\mathcal{R}^{m}</span> satisfying</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\begin{CD}\\pi\\overbrace{\\mathbf{F}}^{m=d^{\\otimes\\mu}}\\mathbf{w}=\\mathbf{0}\\bmod q\\quad\\text{and}\\quad_{m=d^{\\otimes\\mu}}\\{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{w}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\beta^{\\text{sis}}.\\end{CD}$ (13)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since all atomic protocols <span class="math">\\Pi^{\\text{b-decomp}},\\Pi^{\\text{split}},\\Pi^{\\text{fold}},\\Pi^{\\text{batch}}</span> and <span class="math">\\Pi^{\\text{norm}}</span> (and also <span class="math">\\Pi^{\\text{ip}}</span>) preserve the norm bound <span class="math">\\beta^{\\text{sis}}</span> for the OR-branch, when choosing parameters it suffices to ensure the hardness of finding <span class="math">\\mathbf{w}</span> satisfying Eq. (13). We therefore omit the discussion about the OR-branch and the parameter <span class="math">\\beta^{\\text{sis}}</span> below.</p>

    <h5 id="sec-49" class="text-base font-semibold mt-4">Keeping track of composition costs.</h5>

    <p class="text-gray-300">The basic idea of obtaining a succinct argument protocol for <span class="math">\\mathcal{Z}^{\\text{lin}}</span> is to compose the self-reductions of knowledge <span class="math">\\Pi^{\\text{split}},\\Pi^{\\text{fold}}</span> and <span class="math">\\Pi^{\\text{batch}}</span> to reduce the witness dimensions <span class="math">m\\times r</span> so that the resulting witness is small enough in description size to be sent in plain. We denote this last step as <span class="math">\\Pi^{\\text{finish}}</span>. As highlighted in Sections 1 and 2 this would result in an argument with both correctness and soundness gaps. To recall, the correctness gap refers to the growth of the norm bound <span class="math">\\beta</span> of the running witness, while the soundness gap refers to the norm of a witness extracted by the knowledge extractor. We denote the latter by <span class="math">\\beta^{\\text{ext}}</span>.</p>

    <p class="text-gray-300">To eliminate the correctness gap, the idea is to throw the self-reduction of knowledge <span class="math">\\Pi^{\\text{b-decomp}}</span> into the mix, so that the norm bound <span class="math">\\beta</span> of the running witness is controlled throughout the composition. It remains to remove the soundness gap. For this, we let the prover send out explicit norm claims <span class="math">\\nu</span> for the running witness from time to time, which expands the running <span class="math">\\mathcal{Z}^{\\text{lin}}</span> relation into a <span class="math">\\mathcal{Z}^{\\text{norm}}</span> relation, and run <span class="math">\\Pi^{\\text{norm}}</span> to reduce this <span class="math">\\mathcal{Z}^{\\text{norm}}</span> relation back to a <span class="math">\\mathcal{Z}^{\\text{lin}}</span> relation. We will assume that the prover is rational and always sets <span class="math">\\nu\\coloneqq\\beta</span>, i.e. making the tightest claim possible about the norm of the running witness. The effect of this procedure is, therefore, to insert a “checkpoint” into the composition, so that the witness extracted at this step of the composition is “reset” to <span class="math">\\beta^{\\text{ext}}=\\beta</span> (assuming that the norm of the running witness does not exceed the allowed boundary in subsequent protocols).</p>

    <p class="text-gray-300">When composing the above atomic RoKs, we have to keep track of the following for each atomic RoK:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The changes to the parameters <span class="math">\\underline{n},n,m,r,\\beta</span> so that the hypothetical norm bound <span class="math">\\beta^{\\text{ext}}</span> of the extracted witness (and hence the norm bound <span class="math">\\beta</span> of the running witness) do not exceed the allowed budget <span class="math">\\beta^{\\text{sis}}</span>, i.e. to ensure <span class="math">(\\beta\\leq)\\beta^{\\text{ext}}&lt;\\beta^{\\text{sis}}/2</span>.</li>

      <li>The soundness cost, i.e. how much soundness error does a RoK add to the overall composition, so that the cumulative soundness cost does not exceed the allowed budget, say <span class="math">2^{-80}</span>.</li>

      <li>The communication cost.</li>

    </ul>

    <p class="text-gray-300">We note that, somewhat confusingly, the hypothetical norm bound <span class="math">\\beta^{\\text{ext}}</span> of the extracted witness is not a function of the parameters of preceding protocols in the chain of composition, but rather a function of the parameters of subsequent protocols. In other words, as we insert more protocols into the composition, the <span class="math">\\beta^{\\text{ext}}</span> values of all previous protocols may change.</p>

    <p class="text-gray-300">The overall communication cost of the composition, which is a natural target for optimisation, is the sum of the communication costs of all instances of atomic protocols involved plus the size of the final witness. We note, however, that each atomic protocol also has different prover and verifier time costs which are harder to keep track. In the following, we focus only on minimising the communication cost for simplicity.</p>

    <p class="text-gray-300">Composition strategy for minimising communication. We next discuss a natural (but not necessarily optimal) strategy for minimising the overall communication cost. To aid reasoning, we first give intuitive descriptions of the functionality of each atomic RoK. We will omit mention of soundness costs since parameters can be easily set to make them negligible.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi^{b\\text{-decomp}}</span> : Shrink  <span class="math">\\beta</span>  but grow  <span class="math">r</span>  and  <span class="math">\\beta^{\\mathrm{ext}}</span> . Cost  <span class="math">(\\ell - 1)n^{\\mathrm{out}}r</span>  of  <span class="math">\\mathcal{R}_q</span>  communication.</li>

      <li><span class="math">\\Pi^{\\mathrm{split}}</span> : Shrink  <span class="math">m</span>  but grow  <span class="math">r</span> . Cost  <span class="math">r((d^{2} - 1) \\cdot (n^{\\mathrm{out}} - \\overline{n}) + (d - 1) \\cdot \\overline{n})</span>  of  <span class="math">\\mathcal{R}_q</span>  communication.</li>

      <li><span class="math">\\Pi^{\\mathrm{fold}}</span> : Reset  <span class="math">r</span>  to some fixed (e.g. the initial) value but grow  <span class="math">\\beta</span>  and  <span class="math">\\beta^{\\mathrm{ext}}</span> . Cost 0 communication.</li>

      <li><span class="math">\\Pi^{\\mathrm{batch}}</span> : Shrink  <span class="math">\\underline{n}</span>  to 1. Cost 0 communication.</li>

      <li><span class="math">\\Pi^{\\mathrm{norm}}</span> : Reset  <span class="math">\\beta^{\\mathrm{ext}}</span>  to  <span class="math">\\beta</span>  but grow  <span class="math">\\underline{n}</span> ,  <span class="math">r</span>  and  <span class="math">\\beta</span>  (for the next round). Cost  <span class="math">\\ell n^{\\mathrm{out}} + 3 \\cdot (r + \\ell)</span>  of  <span class="math">\\mathcal{R}_q</span>  communication.</li>

      <li><span class="math">\\Pi^{\\mathrm{finish}}</span> : Finish the composition. Cost  <span class="math">mr\\varphi \\log \\beta</span>  communication.</li>

    </ul>

    <p class="text-gray-300">We make several observations. Each protocol except  <span class="math">\\Pi^{\\mathrm{batch}}</span>  and  <span class="math">\\Pi^{\\mathrm{finish}}</span>  shrinks one of the parameters at the cost of growing others. The  <span class="math">\\Pi^{\\mathrm{batch}}</span>  protocol is essentially free (ignoring soundness cost), shrinking  <span class="math">\\underline{n}</span>  while costing no parameter growth nor communication, and can therefore always be run immediately after  <span class="math">\\Pi^{\\mathrm{norm}}</span>  to suppress the growth of  <span class="math">\\underline{n}</span>  there. The  <span class="math">\\Pi^{\\mathrm{split}}</span>  protocol trades  <span class="math">m</span>  for  <span class="math">r</span>  and thus does not reduce the witness size, i.e. the communication cost of  <span class="math">\\Pi^{\\mathrm{finish}}</span> .</p>

    <p class="text-gray-300">With the above observations, a natural composition strategy is to split the protocol into 2 phases - looping and finishing. We first define the 2 phases and then provide an explanation.</p>

    <p class="text-gray-300">(i) Looping phase: Repeat the sequence</p>

    <div class="my-4 text-center"><span class="math-block">(\\Pi^ {b - \\text {d e c o m p}} \\rightarrow) \\Pi^ {\\text {n o r m}} \\rightarrow \\Pi^ {\\text {b a t c h}} \\rightarrow \\Pi^ {\\text {s p l i t}} \\rightarrow \\Pi^ {\\text {f o l d}},</span></div>

    <p class="text-gray-300">where the optional step is specified in parenthesis. After each loop, check what would be the overall communication cost if  <span class="math">\\Pi^{\\mathrm{finish}}</span>  is run now. Exit the loop if the overall communication cost does not decrease if another loop is executed.</p>

    <p class="text-gray-300">(ii) Finishing phase: Execute  <span class="math">\\Pi^{\\mathrm{finish}}</span> .</p>

    <p class="text-gray-300">In the beginning of the looping phase, we start with  <span class="math">\\Pi^{\\mathrm{norm}}</span>  (as the  <span class="math">\\Pi^{b\\text{-decomp}}</span>  is unnecessary) to create a checkpoint for  <span class="math">\\beta^{\\mathrm{ext}} = \\beta</span> , so that the final extracted witness is guaranteed to be of norm at most  <span class="math">\\beta</span> , i.e. without soundness gap, given that the witness norm does not blow up in subsequent protocols. As observed above,  <span class="math">\\Pi^{\\mathrm{norm}}</span>  should be followed by  <span class="math">\\Pi^{\\mathrm{batch}}</span>  to negate the growth of  <span class="math">\\underline{n}</span> . We run  <span class="math">\\Pi^{\\mathrm{split}}</span>  to trade  <span class="math">m</span>  for  <span class="math">r</span> , followed by  <span class="math">\\Pi^{\\mathrm{fold}}</span>  to shrink  <span class="math">r</span>  to the initial value at the cost of growing  <span class="math">\\beta</span>  and  <span class="math">\\beta^{\\mathrm{ext}}</span> . At this point, the norm of the running witness is possibly quite large. Therefore, we potentially insert a  <span class="math">\\Pi^{b\\text{-decomp}}</span>  step at the beginning of the next loop to control the norm  <span class="math">\\beta</span>  of the running witness <span class="math">^{20}</span> .</p>

    <p class="text-gray-300">At the end of each loop, if the hypothetical exiting cost does not decrease in further loops, i.e. the overall communication cost if  <span class="math">\\Pi^{\\mathrm{finish}}</span>  is run now is not higher than running it later, there is no reason to continue looping. We therefore execute  <span class="math">\\Pi^{\\mathrm{finish}}</span>  to finish the protocol.</p>

    <h2 id="sec-50" class="text-2xl font-bold">6.2 Asymptotic Complexity</h2>

    <p class="text-gray-300">For the asymptotic parameters, we assume a slightly different composition than suggested in Section 6.1. The looping phase is now defined with the following sequence:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pi^ {\\text {n o r m}} \\rightarrow \\Pi^ {\\text {b a t c h}} \\rightarrow \\Pi^ {b - \\text {d e c o m p}} \\rightarrow \\Pi^ {\\text {s p l i t}} \\rightarrow \\Pi^ {\\text {f o l d}},</span></div>

    <p class="text-gray-300">repeated  <span class="math">\\mu</span>  times. For simplicity,  <span class="math">\\Pi^{b\\text{-decomp}}</span>  is included in each round. Such ordering, although not optimal, is easier to analyse as we can assume that the final and the initial norm are identical. However, it yields slightly worse concrete proof sizes (cf. Section 9). Conveniently, all the bounds are tracked according to the canonical 2-norm. The parameters are chosen as shown in Table 2 and argued below.</p>

    <p class="text-gray-300">29</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">description</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">instantiation</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">λ</td>

            <td class="px-3 py-2 border-b border-gray-700">security parameter</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">height of the witness matrix W</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">q</td>

            <td class="px-3 py-2 border-b border-gray-700">argument system modulus</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ,m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βsis</td>

            <td class="px-3 py-2 border-b border-gray-700">norm of the (presumably hard) vSIS instance</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ,m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f</td>

            <td class="px-3 py-2 border-b border-gray-700">conductor of the ring</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ log m/ log λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">φ</td>

            <td class="px-3 py-2 border-b border-gray-700">ring dimension</td>

            <td class="px-3 py-2 border-b border-gray-700">φ(f)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r4</td>

            <td class="px-3 py-2 border-b border-gray-700">soundness amplification factor</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ/ log λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">width of the witness matrix W</td>

            <td class="px-3 py-2 border-b border-gray-700">r4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">height of the matrix F</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">μ</td>

            <td class="px-3 py-2 border-b border-gray-700">total number of invocations of the protocol</td>

            <td class="px-3 py-2 border-b border-gray-700">logdm</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">number of top rows of H</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">number of bottom rows of H</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">nout</td>

            <td class="px-3 py-2 border-b border-gray-700">number of rows of H</td>

            <td class="px-3 py-2 border-b border-gray-700">n + n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">e</td>

            <td class="px-3 py-2 border-b border-gray-700">number of irreducible factors</td>

            <td class="px-3 py-2 border-b border-gray-700">ω(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β0</td>

            <td class="px-3 py-2 border-b border-gray-700">initial norm bound</td>

            <td class="px-3 py-2 border-b border-gray-700">poly(λ,m)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r0</td>

            <td class="px-3 py-2 border-b border-gray-700">initial width of the witness W</td>

            <td class="px-3 py-2 border-b border-gray-700">O(λ/ log λ)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bn</td>

            <td class="px-3 py-2 border-b border-gray-700">decomposition base for the coeffs. of the Laurent poly.</td>

            <td class="px-3 py-2 border-b border-gray-700">β1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ln</td>

            <td class="px-3 py-2 border-b border-gray-700">length of the decomposition basis w.r.t.</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">bd</td>

            <td class="px-3 py-2 border-b border-gray-700">decomposition base</td>

            <td class="px-3 py-2 border-b border-gray-700">O((m^2/2(λ/ log λ)^5/2)^{1/θ(1)})</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">ld</td>

            <td class="px-3 py-2 border-b border-gray-700">length of the decomposition basis w.r.t. bd</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">d</td>

            <td class="px-3 py-2 border-b border-gray-700">folding factor</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Parameter instantiation for the protocol.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hardness of SIS. To measure the hardness of vSIS, we heuristically assume that it is as hard as the plain SIS problem for the dimension  <span class="math">\\varphi = \\varphi(\\mathfrak{f})</span> . To measure the hardness of SIS, we first translate the canonical norm  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math">  into the Euclidean norm  </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi(\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2<span class="math"> , and then follow the heuristic methodology from [MR09]. Let  </span>b = O(\\lambda)<span class="math">  be the block size of the BKZ algorithm to find a short vector in the corresponding  </span>q$ -ary lattice for SIS (cf. [BDGL16]). Define the root Hermite factor as</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\delta_ {\\mathrm {r h f}} = \\left(\\frac {b (\\pi b) ^ {1 / b}}{2 \\pi e}\\right) ^ {1 / (2 (b - 1))}.</span></div>

    <p class="text-gray-300">Then, SIS with matrix dimensions  <span class="math">\\varphi \\times \\varphi m</span>  and Euclidean norm  <span class="math">\\beta^{\\mathrm{sis}}</span>  is hard when</p>

    <div class="my-4 text-center"><span class="math-block">\\beta^ {\\mathrm {s i s}} &amp;lt;   \\min  \\left(2 ^ {2 \\sqrt {\\varphi \\log q \\log \\delta_ {\\mathrm {r h f}}}}, q\\right).</span></div>

    <p class="text-gray-300">By rearranging, we get that</p>

    <div class="my-4 text-center"><span class="math-block">\\varphi \\log q &amp;gt; \\frac {\\log^ {2} \\beta^ {\\mathrm {s i s}}}{4 \\log \\delta_ {\\mathrm {r h f}}}.</span></div>

    <p class="text-gray-300">Note that</p>

    <div class="my-4 text-center"><span class="math-block">\\log \\delta_ {\\mathrm {r h f}} = \\frac {1}{2 (b - 1)} \\log \\left(\\frac {b (\\pi b) ^ {1 / b}}{2 \\pi e}\\right) = \\Theta \\left(\\frac {\\log b}{b}\\right) = \\Theta \\left(\\frac {\\log \\lambda}{\\lambda}\\right).</span></div>

    <p class="text-gray-300">This means that the size of a single  <span class="math">\\mathcal{R}_q</span>  element is asymptotically</p>

    <div class="my-4 text-center"><span class="math-block">\\Omega \\left(\\frac {\\lambda \\cdot (\\log m + \\log \\lambda) ^ {2}}{\\log \\lambda}\\right) = \\Omega \\left(\\frac {\\lambda \\cdot \\log^ {2} m}{\\log \\lambda}\\right).</span></div>

    <p class="text-gray-300">We will assume this size of an  <span class="math">\\mathcal{R}_q</span>  in the analysis below.</p>

    <p class="text-gray-300">Round Communication Complexity. To aid discussion, we introduce auxiliary variables for keeping track of how the parameters of the  <span class="math">\\Xi^{\\mathrm{lin}}</span>  relation change throughout a single loop of the protocol.</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m _ {0}, n _ {0}, r _ {0}, \\beta_ {0}\\right) \\xrightarrow {\\Pi^ {\\mathrm {n o r m}}} \\left(m _ {0}, n _ {1}, r _ {1}, \\beta_ {1}\\right) \\xrightarrow {\\Pi^ {\\mathrm {b a t c h}}} \\left(m _ {0}, n _ {0}, r _ {1}, \\beta_ {1}\\right)</span></div>

    <p class="text-gray-300"><span class="math">\\xrightarrow{\\Pi^{b\\text{-}decomp}}(m_{0},n_{0},r_{2},\\beta_{2})\\xrightarrow{\\Pi^{\\mathsf{spls}}}(m_{1},n_{0},r_{3},\\beta_{2})\\xrightarrow{\\Pi^{\\mathsf{fold}}}(m_{1},n_{0},r_{4},\\beta_{3}).</span></p>

    <p class="text-gray-300">We will use the parameters for analysing the communication complexity. For simple recursion, we assume that parameters are chosen so that <span class="math">\\beta_{0}=\\beta_{3}</span>.</p>

    <p class="text-gray-300">For <span class="math">\\Pi^{\\mathsf{norm}}</span>, we set <span class="math">\\beta_{1}=O(\\sqrt{mr_{1}\\hat{\\mathfrak{f}}\\varphi}\\,\\beta_{0})</span>. To argue that the norm grows by that factor, we observe that the coefficient <span class="math">\\infty</span>-norm of <span class="math">\\mathbf{v}</span> (cf. Lemma 8) is at most <span class="math">\\beta_{1}^{2}</span> (cf. Corollary 1), and therefore the matrix of such norm can be decomposed into matrix of coefficient <span class="math">\\infty</span>-norm <span class="math">\\beta_{0}</span> with a constant decomposition basis length. Translation back to the canonical 2-norm incurrs the additional <span class="math">\\sqrt{mr_{1}\\varphi\\mathfrak{f}}</span> factor (cf. Corollary 1). Furthermore, <span class="math">\\beta_{2}=\\sqrt{mr_{2}\\hat{\\mathfrak{f}}\\varphi}\\,b_{\\mathsf{d}}</span> and <span class="math">\\beta_{3}=\\beta_{2}\\sqrt{r_{4}}\\,r_{3}\\gamma</span>, where <span class="math">\\gamma</span> is the expansion factor of the subtractive set (assumed constant).</p>

    <p class="text-gray-300">To argue about the feasibility of the setting, we need to establish that there exists <span class="math">b_{\\mathsf{d}}</span> such that <span class="math">\\ell_{\\mathsf{d}}=O(1)</span> and <span class="math">\\beta_{3}=\\beta_{0}</span>. We observe that <span class="math">\\beta_{3}=O(r_{3}\\sqrt{r_{4}}\\sqrt{mr_{1}\\hat{\\mathfrak{f}}\\varphi}\\,\\sqrt{mr_{2}\\hat{\\mathfrak{f}}\\varphi}\\,b_{\\mathsf{d}})</span>. After substituting <span class="math">\\beta_{3}=\\beta_{0}</span>, <span class="math">\\beta_{0}=b_{\\mathsf{d}}^{\\Theta(1)}</span> and <span class="math">(r_{i})_{i\\in[5]}</span> params with asymptotic expressions, we establish the condition for <span class="math">b_{\\mathsf{d}}</span> as</p>

    <p class="text-gray-300"><span class="math">b_{\\mathsf{d}}=O\\left(\\left(m\\tilde{\\mathfrak{f}}^{2}(\\lambda/\\log\\lambda)^{5/2}\\right)^{1/\\Theta(1)}\\right).</span></p>

    <p class="text-gray-300">We analyse the necessary size of the proof system modulus <span class="math">q</span>. For <span class="math">\\mathsf{vSIS}</span> hardness, we need <span class="math">q&gt;\\beta^{\\mathsf{sis}}</span>, where the bound on <span class="math">\\beta^{\\mathsf{sis}}</span> is computed as follows. By setting <span class="math">\\beta_{3}^{\\prime}=\\beta_{3}(=\\beta_{0})</span>, we get</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\beta^{\\mathsf{sis}}\\geq 2\\left(2\\beta_{0}\\sqrt{r_{3}}\\,\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\right)^{\\ell_{\\mathsf{d}}}=\\mathsf{poly}(m,\\lambda).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">as <span class="math">\\ell_{\\mathsf{d}}=O(1)</span>, resulting in a polynomial-sized modulus <span class="math">q</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To discuss this in further detail, we assume a witness of norm <span class="math">\\beta_{0}</span> and analyse RoKs in the “extraction direction”. The extractor for <span class="math">\\Pi^{\\mathsf{fold}}</span> extracts a witness of norm $2\\beta_{0}\\sqrt{r_{3}}\\,\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}<span class="math">. The extractor for </span>\\Pi^{\\mathsf{split}}<span class="math"> does not alter the norm. For </span>\\Pi^{b\\text{-}decomp}<span class="math">, the recomposed witness norm becomes </span>\\left(2\\beta_{0}\\sqrt{r_{3}}\\,\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\right)^{\\ell_{\\mathsf{d}}}<span class="math">. In </span>\\Pi^{\\mathsf{batch}}<span class="math">, the extractor retrieves the unaltered witness or produces a </span>\\mathsf{vSIS}<span class="math"> break with norm </span>2\\left(2\\beta_{0}\\sqrt{r_{3}}\\,\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\right)^{\\ell_{\\mathsf{d}}}<span class="math">. Similarly, for </span>\\Pi^{\\mathsf{norm}}<span class="math">, the extractor extracts a witness of norm </span>\\beta_{0}<span class="math"> or results in a </span>\\mathsf{vSIS}<span class="math"> break with norm </span>2\\left(2\\beta_{0}\\sqrt{r_{3}}\\,\\theta_{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma(\\cdot)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}}\\right)^{\\ell_{\\mathsf{d}}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Evenatually, we are ready to estimate the proof size. Considering the non-interactive setting, we will only count the prover messages. We track the communication cost for atomic RoKs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi^{\\mathsf{norm}}</span> involves sending <span class="math">\\ell_{\\mathsf{n}}=O(1)</span> <span class="math">\\mathcal{R}_{q}</span> elements,</li>

      <li><span class="math">\\Pi^{\\mathsf{batch}}</span> incurs no communication cost,</li>

      <li><span class="math">\\Pi^{b\\text{-}decomp}</span> involves sending <span class="math">\\ell_{\\mathsf{n}}=O(r_{2})=O(r)=O(\\lambda/\\log\\lambda)</span> <span class="math">\\mathcal{R}_{q}</span> elements,</li>

      <li><span class="math">\\Pi^{\\mathsf{split}}</span> involves sending <span class="math">\\ell_{\\mathsf{n}}=O(r_{2})=O(r)=O(\\lambda/\\log\\lambda)</span> <span class="math">\\mathcal{R}_{q}</span> elements,</li>

      <li><span class="math">\\Pi^{\\mathsf{fold}}</span> incurs no communication cost.</li>

    </ul>

    <p class="text-gray-300">We conclude that the total communication cost for a single round is <span class="math">O(\\lambda/\\log\\lambda)</span> <span class="math">\\mathcal{R}_{q}</span> elements, expressed in bits as</p>

    <p class="text-gray-300"><span class="math">O\\left(\\frac{\\lambda^{2}}{\\log^{2}\\lambda}\\cdot\\log^{2}m\\right).</span></p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">Total Communication Complexity.</h5>

    <p class="text-gray-300">After <span class="math">\\mu=O(\\log m)</span> rounds, the height of the witness is <span class="math">O(1)</span> and the width becomes <span class="math">O(r_{0})</span>, consisting of <span class="math">\\mathcal{R}_{q}</span> elements. The size (in bits) of such a witness is</p>

    <p class="text-gray-300"><span class="math">O\\left(\\frac{\\lambda}{\\log\\lambda}\\cdot\\frac{\\lambda\\cdot\\log^{2}m}{\\log\\lambda}\\right)=O\\left(\\frac{\\lambda^{2}}{\\log^{2}\\lambda}\\cdot\\log^{2}m\\right).</span></p>

    <p class="text-gray-300">The total communication cost across all rounds and the final witness sent is</p>

    <p class="text-gray-300"><span class="math">O\\left(\\frac{\\lambda^{2}}{\\log^{2}\\lambda}\\cdot\\log^{3}m\\right).</span></p>

    <p class="text-gray-300">We propose an abstract framework based on "twisted trace maps" that reduces  <span class="math">\\mathbb{Z}</span> -inner products to  <span class="math">\\mathcal{R}</span> -inner products over various choices of  <span class="math">\\mathcal{R}</span> . In a nutshell, for a fixed choice of  <span class="math">\\mathcal{R}</span> , we would like to construct a twisted trace map  <span class="math">\\tau: \\mathcal{R} \\to \\mathbb{Z}</span>  of the form shown below, where  <span class="math">N \\in \\mathbb{N}</span>  is some normalisation factor and  <span class="math">\\alpha \\in \\mathcal{R}</span>  is called a "twist" element, such that the following diagram commutes:</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a></p>

    <p class="text-gray-300">Definition 5 (Inner-Product Embedding). Let  <span class="math">\\mathcal{R} \\subset \\mathcal{O}_{\\mathcal{K}}</span>  be a subring identified by a  <span class="math">\\mathbb{Z}</span> -basis  <span class="math">\\mathbf{b} \\in \\mathcal{R}^{\\delta}</span>  of  <span class="math">\\delta</span>  elements. We say that a tuple  <span class="math">\\tau</span>  is an inner-product embedding over  <span class="math">\\mathcal{R}</span>  if  <span class="math">\\tau: \\mathcal{R} \\to \\mathbb{Z}^{\\delta}</span>  is a  <span class="math">\\mathbb{Z}</span> -linear map and, for any  <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\mathbb{Z}^{\\delta}</span> , it holds that  <span class="math">\\langle \\mathbf{x}, \\mathbf{y} \\rangle_{\\mathbb{Z}} = \\tau \\left( \\psi_{\\mathbf{b}}^{-1}(\\mathbf{x}) \\cdot_{\\mathcal{R}} \\overline{\\psi_{\\mathbf{b}}^{-1}(\\mathbf{y})} \\right)</span> .</p>

    <p class="text-gray-300">As a simple concrete example, we recall a well-known folklore technique for computing the inner product over the coefficient embeddings of power-of-two cyclotomics.</p>

    <p class="text-gray-300">Theorem 5. Let  <span class="math">\\mathcal{R} = \\mathbb{Z}[\\zeta_{\\mathfrak{f}}]</span>  with a conductor  <span class="math">\\mathfrak{f} = 2^k</span>  for some  <span class="math">k \\in \\mathbb{N}</span> ,  <span class="math">\\delta = \\varphi = \\varphi(\\mathfrak{f}) = \\mathfrak{f}/2</span> ,  <span class="math">\\tau(\\cdot) = \\mathsf{ct}(\\cdot) = (\\psi(\\cdot))_0</span> , where  <span class="math">\\psi</span>  denotes the coefficient embedding and  <span class="math">\\mathsf{ct}(\\cdot)</span>  is the constant term of the coefficient embedding. Then  <span class="math">\\tau</span>  is an inner-product embedding over  <span class="math">\\mathcal{R}</span> .</p>

    <p class="text-gray-300">Proof. Write  <span class="math">\\zeta = \\zeta_{\\mathfrak{f}}</span> . Observe that  <span class="math">\\mathsf{ct}(\\zeta^i) = (i \\stackrel{?}{=} 0)</span>  for all  <span class="math">i \\in \\pm [\\varphi]</span> . Consider the vectors  <span class="math">\\mathbf{x} = (x_0, \\ldots, x_{\\varphi - 1}), \\mathbf{y} = (y_0, \\ldots, y_{\\varphi - 1}) \\in \\mathbb{Z}^\\varphi</span> . The elements  <span class="math">x \\coloneqq \\psi^{-1}(\\mathbf{x})</span>  and  <span class="math">\\bar{y} \\coloneqq \\overline{\\psi^{-1}(\\mathbf{y})}</span>  can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">x = \\psi^ {- 1} (\\mathbf {x}) = \\sum_ {i \\in [ \\varphi ]} x _ {i} \\zeta^ {i} \\quad \\text {and} \\quad \\bar {y} = \\overline {{\\psi^ {- 1} (\\mathbf {y})}} = \\sum_ {i \\in [ \\varphi ]} y _ {i} \\zeta^ {- i}</span></div>

    <p class="text-gray-300">respectively. Note that their product  <span class="math">z \\coloneqq x \\cdot \\bar{y}</span>  satisfies</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} z = x \\cdot \\bar {y} = \\left(\\sum_ {i \\in [ \\varphi ]} x _ {i} \\zeta^ {i}\\right) \\left(\\sum_ {j \\in [ \\varphi ]} y _ {j} \\zeta^ {- j}\\right) = \\sum_ {i, j \\in [ \\varphi ]} x _ {i} y _ {j} \\zeta^ {i - j} \\\\ = \\underbrace {\\sum_ {i \\in [ \\varphi ]} x _ {i} y _ {i}} _ {\\alpha (s)} + \\sum_ {i, j \\in [ \\varphi ]: i \\neq j} a _ {i} b _ {j} \\zeta^ {i - j}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Therefore,  <span class="math">\\tau (\\psi^{-1}(\\mathbf{x}),\\overline{\\psi^{-1}(\\mathbf{y})}) = \\langle \\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}</span>  , as desired.</p>

    <p class="text-gray-300">Remark 8. The constant term map  <span class="math">\\mathsf{ct}(x)</span>  from Theorem 5 can be expressed in terms of the Trace function as  <span class="math">\\tau(x) = \\frac{1}{\\varphi} \\mathsf{Trace}(x)</span> , where  <span class="math">\\varphi = \\mathfrak{f}/2</span>  since  <span class="math">\\mathfrak{f}</span>  is a power of 2, and might be viewed as a twisted trace map  <span class="math">\\tau(x) = \\frac{1}{\\varphi} \\mathsf{Trace}(\\alpha \\cdot x)</span>  with  <span class="math">\\alpha = 1</span> .</p>

    <p class="text-gray-300">As pointed out in Section 4, power-of-two cyclotomic rings do not admit large subtractive sets, and are therefore ill-suited for certain applications, e.g. instantiating the succinct arguments presented in Section 5. This motivates the search for inner-product embeddings  <span class="math">\\tau</span>  over other rings.</p>

    <p class="text-gray-300">7.2 Prime Real Cyclotomics via Twisted Trace</p>

    <p class="text-gray-300">A natural class of rings to search for inner-product embeddings are cyclotomic rings with large prime conductors, since they admit large subtractive sets (cf. Section 4). Although we did not manage to design inner-product embeddings in those rings, we did so for its maximal real subring, adapting a result from lattice code theory <em>[x1, Proposition 1]</em>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{K}=\\mathbb{Q}(\\zeta_{\\mathfrak{f}})</span> where <span class="math">\\mathfrak{f}</span> is prime and <span class="math">\\mathcal{R}=\\mathbb{Z}[\\zeta_{\\mathfrak{f}}+\\zeta_{\\mathfrak{f}}^{-1}]</span> be identified by the <span class="math">\\mathbb{Z}</span>-basis <span class="math">\\mathbf{b}^{+}=\\left\\{\\sum_{i=[j+1]}(\\zeta^{\\varphi/2-i}+\\zeta^{-(\\varphi/2-i)})\\right\\}_{j\\in[\\varphi/2]}</span>. For <span class="math">z\\in\\mathcal{R}</span>, let <span class="math">\\tau(z)=\\frac{1}{2\\mathfrak{f}}\\mathsf{Trace}(\\alpha z)</span> be a twisted trace map for the twist element <span class="math">\\alpha=t\\cdot\\bar{t}</span> where <span class="math">t=\\zeta^{-\\varphi/2}-\\zeta^{\\varphi/2}</span>. Then <span class="math">\\tau</span> is an inner product embedding over <span class="math">\\mathcal{R}</span>.</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Since <span class="math">\\mathfrak{f}</span> is prime, we have <span class="math">\\varphi=\\mathfrak{f}-1</span> and <span class="math">\\delta=\\varphi/2=(\\mathfrak{f}-1)/2</span>. In the following, write <span class="math">\\mathsf{Trace}=\\mathsf{Trace}</span>. Recall that <span class="math">\\mathsf{Trace}(1)=\\sum_{j\\in[\\varphi]}1=\\varphi=\\mathfrak{f}-1</span>. Furthermore, for <span class="math">i\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span>, we have <span class="math">\\mathsf{Trace}(\\zeta^{i})=\\sum_{j\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}}\\zeta^{ij}=\\sum_{j\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}}\\zeta^{j}=-1</span>.</p>

    <p class="text-gray-300">As a starting point, we consider the following sequence.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{b}^{-}=(b_{i}^{-})_{i\\in[\\varphi/2]}=(\\zeta^{i+1}-\\zeta^{-(i+1)})_{i\\in[\\varphi/2]}.</span></p>

    <p class="text-gray-300">Note that the sequence <span class="math">\\mathbf{b}^{-}</span> is trace-orthogonal. Namely, the following function acts as Kronecker delta.</p>

    <p class="text-gray-300">\\[ \\frac{1}{2\\mathfrak{f}}\\cdot\\mathsf{Trace}(\\overline{b_{i}^{-}}\\cdot b_{j}^{-})=\\begin{cases}1&i=j\\\\ 0&i\\neq j.\\end{cases} \\]</p>

    <p class="text-gray-300">To see this, let <span class="math">i^{\\prime}=i+1</span> and <span class="math">j^{\\prime}=j+1</span> and consider the trace of the expression below.</p>

    <p class="text-gray-300"><span class="math">\\overline{b_{i}^{-}}\\cdot b_{j}^{-}</span> <span class="math">=\\overline{(\\zeta^{i^{\\prime}}-\\zeta^{-i^{\\prime}})}\\cdot(\\zeta^{j^{\\prime}}-\\zeta^{-j^{\\prime}})</span> <span class="math">=(\\zeta^{-i^{\\prime}}-\\zeta^{i^{\\prime}})\\cdot(\\zeta^{j^{\\prime}}-\\zeta^{-j^{\\prime}})=(\\zeta^{-i^{\\prime}+j^{\\prime}}-\\zeta^{i^{\\prime}+j^{\\prime}}-\\zeta^{-i^{\\prime}-j^{\\prime}}+\\zeta^{i^{\\prime}-j^{\\prime}}),</span> <span class="math">\\mathsf{Trace}(b_{i}^{-}\\cdot\\overline{b_{j}^{-}})</span> <span class="math">=\\mathsf{Trace}(\\zeta^{-i^{\\prime}+j^{\\prime}}-\\zeta^{i^{\\prime}+j^{\\prime}}-\\zeta^{-i^{\\prime}-j^{\\prime}}+\\zeta^{i^{\\prime}-j^{\\prime}})</span> <span class="math">=\\mathsf{Trace}(\\zeta^{-(i^{\\prime}-j^{\\prime})})-\\mathsf{Trace}(\\zeta^{i^{\\prime}+j^{\\prime}})-\\mathsf{Trace}(\\zeta^{-(i^{\\prime}+j^{\\prime})})+\\mathsf{Trace}(\\zeta^{i^{\\prime}-j^{\\prime}}).</span></p>

    <p class="text-gray-300">Since <span class="math">i,j\\in[\\varphi/2]</span>, we have <span class="math">2\\leq i^{\\prime}+j^{\\prime}\\leq\\varphi</span>, meaning that <span class="math">i^{\\prime}+j^{\\prime}\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span> and <span class="math">-(i^{\\prime}+j^{\\prime})\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span>. Furthermore, if <span class="math">i\\neq j</span>, then <span class="math">i^{\\prime}-j^{\\prime}\\in\\pm[\\varphi/2]\\setminus\\{0\\}</span>, hence <span class="math">i^{\\prime}-j^{\\prime}\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span> and <span class="math">-(i^{\\prime}-j^{\\prime})\\in\\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span>. Therefore, we conclude that</p>

    <p class="text-gray-300"><span class="math">(i=j)</span> <span class="math">\\implies\\mathsf{Trace}(b_{i}^{-}\\cdot\\overline{b_{j}^{-}})=2\\mathfrak{f},</span> <span class="math">(i\\neq j)</span> <span class="math">\\implies\\mathsf{Trace}(b_{i}^{-}\\cdot\\overline{b_{j}^{-}})=0.</span></p>

    <p class="text-gray-300">Although <span class="math">\\mathbf{b}^{-}</span> is trace-orthogonal, it does not constitute a basis of any ring. It does, however, match in cardinality the degree of the maximal real subring <span class="math">\\mathcal{R}</span>, to which our attention now turns. Consider the “suffix-sum” basis for the maximal real subring as in the theorem statement:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{b}^{+}=(b_{j}^{+})_{j\\in[\\varphi/2]}=\\left\\{\\sum_{i\\in[j+1]}(\\zeta^{\\varphi/2-i}+\\zeta^{-(\\varphi/2-i)})\\right\\}_{j\\in[\\varphi/2]}</span></p>

    <p class="text-gray-300">From the identity <span class="math">-\\varphi/2=\\mathfrak{f}-\\varphi/2=\\varphi+1-\\varphi/2=\\varphi/2+1</span> mod <span class="math">\\mathfrak{f}</span>, for each <span class="math">j\\in[\\varphi/2]</span>, we observe that</p>

    <p class="text-gray-300"><span class="math">b_{j}^{-}=b_{j}^{+}\\cdot\\underbrace{(\\zeta^{-\\varphi/2}-\\zeta^{\\varphi/2})}_{i}</span></p>

    <p class="text-gray-300">since</p>

    <p class="text-gray-300"><span class="math">b_{j}^{+}\\cdot(\\zeta^{-\\varphi/2}-\\zeta^{\\varphi/2})=\\sum_{i\\in[j+1]}(\\zeta^{\\varphi/2-i}+\\zeta^{-(\\varphi/2-i)})\\cdot(\\zeta^{-\\varphi/2}-\\zeta^{\\varphi/2})</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = \\sum_{i \\in [j + 1]} \\left(\\zeta^{-i} - \\zeta^{i} + \\zeta^{-(\\varphi - i)} - \\zeta^{\\varphi - i}\\right) \\\\ = \\sum_{i \\in [j + 1]} \\left(\\zeta^{-i} - \\zeta^{-(i + 1)} + \\zeta^{i + 1} - \\zeta^{i}\\right) \\\\ = \\sum_{i \\in [j + 1]} \\left(\\zeta^{-i} - \\zeta^{-(i + 1)}\\right) + \\sum_{i \\in [j + 1]} \\left(\\zeta^{i + 1} - \\zeta^{i}\\right) \\\\ = \\zeta^{j + 1} - \\zeta^{-j + 1} = b_{j}^{-}. \\end{array}</span></div>

    <p class="text-gray-300">Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\frac{1}{2\\mathfrak{f}} \\cdot \\mathsf{Trace}(t \\cdot b_{i}^{+} \\cdot \\overline{t \\cdot b_{j}^{+}}) = \\frac{1}{2\\mathfrak{f}} \\cdot \\mathsf{Trace}(\\alpha \\cdot b_{i}^{-} \\cdot \\overline{b_{j}^{-}}) = \\begin{cases} 1 &amp;amp; i = j \\\\ 0 &amp;amp; i \\neq j. \\end{cases}</span></div>

    <p class="text-gray-300">Now, suppose <span class="math">x = \\psi_{\\mathbf{b}^{+}}^{-1}(\\mathbf{x})</span> and <span class="math">\\bar{y} = \\overline{\\psi_{\\mathbf{b}^{+}}^{-1}(\\mathbf{y})}</span> for some <span class="math">\\mathbf{x}, \\mathbf{y} \\in \\mathbb{Z}^{\\delta}</span>. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau (x \\cdot \\bar{y}) = \\frac{1}{2\\mathfrak{f}} \\mathsf{Trace}(\\alpha x \\cdot \\bar{y}) = \\sum_{i, j \\in [\\varphi / 2]} x_{i} y_{j} \\frac{1}{2\\mathfrak{f}} \\mathsf{Trace}(t \\cdot b_{i}^{+} \\cdot \\bar{t} \\cdot \\overline{b_{i}^{+}}) = \\sum_{i \\in [\\varphi / 2]} x_{i} y_{i} \\\\ = \\langle \\mathbf{x}, \\mathbf{y} \\rangle. \\end{array}</span></div>

    <p class="text-gray-300">The above theorem constructs inner-product embeddings for <span class="math">\\mathcal{R} = \\mathbb{Z}[\\zeta_{\\mathrm{f}} + \\zeta_{\\mathrm{f}}^{-1}]</span> where <span class="math">\\mathfrak{f}</span> is prime. This restricts the choice of <span class="math">\\mathcal{R}</span> quite severely, especially considering that the subtractive set constructed in Section 4 for <span class="math">\\mathbb{Z}[\\zeta_{\\mathrm{f}}]</span> or <span class="math">\\mathbb{Z}[\\zeta_{\\mathrm{f}} + \\zeta_{\\mathrm{f}}^{-1}]</span> for prime <span class="math">\\mathfrak{f}</span> has a large expansion factor bound <span class="math">\\gamma_{S} \\leq \\mathfrak{f}</span>.</p>

    <h2 id="sec-56" class="text-2xl font-bold">7.3 Tensor of Prime Real Cyclotomics</h2>

    <p class="text-gray-300">To allow more fine-grained parameter selection, we extend the result in Sections 7.1 and 7.2 by constructing larger rings using the tensor product, inspired by [BFOV04, Proposition 6]. Concretely, we construct subtractive sets for rings</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{R} = \\mathcal{O}_{\\mathcal{K}_{2^{\\delta}}} \\otimes \\mathcal{O}_{\\mathcal{K}_{\\bar{p}_{0}}^{+}} \\otimes \\dots \\otimes \\mathcal{O}_{\\mathcal{K}_{\\bar{p}_{k-1}}^{+}} \\tag{14}</span></div>

    <p class="text-gray-300">for distinct odd primes <span class="math">p_0, \\ldots, p_{k-1}</span>. Note that <span class="math">\\mathcal{R}</span> has conductor <span class="math">\\mathfrak{f} = 2^d \\cdot \\prod_{i \\in [k]} p_i</span> and degree <span class="math">\\delta = 2^d \\cdot \\prod_{i \\in [k]} (p_i - 1)</span>. It is contained in the ring <span class="math">\\mathcal{O}_{\\mathcal{K}_{\\mathfrak{f}}}</span> which admits a subtractive set <span class="math">S</span> of size <span class="math">\\mathfrak{f} / \\mathfrak{f}_{\\max}</span> with expansion factor <span class="math">\\gamma_S = 1</span> (cf. Section 4).</p>

    <p class="text-gray-300"><strong>Theorem 7.</strong> Let <span class="math">\\mathcal{R} = \\mathcal{O}_{\\mathcal{K}_{\\mathfrak{g}}}\\otimes \\mathcal{O}_{\\mathcal{K}_{\\bar{t}_0}^+}\\otimes \\ldots \\otimes \\mathcal{O}_{\\mathcal{K}_{\\bar{t}_{k - 1}}^+}</span>, <span class="math">\\mathfrak{g} = 2^{d}</span> for some <span class="math">d\\in \\mathbb{N}</span>, and <span class="math">\\mathfrak{f}_0,\\dots ,\\mathfrak{f}_{k - 1}</span> distinct odd primes. Let <span class="math">\\mathbf{b} = \\mathbf{b}_{\\mathfrak{g}}\\otimes \\left(\\bigotimes_{i\\in [k]}\\mathbf{b}_{\\mathfrak{f}_i}^+\\right)</span>, where <span class="math">\\mathbf{b}_{\\mathfrak{g}}</span> is the power basis for <span class="math">\\mathcal{R}_{\\mathfrak{g}}</span> and <span class="math">\\mathbf{b}_{\\mathfrak{f}_i}^+</span> is a basis for <span class="math">\\mathcal{R}_{\\mathfrak{f}_i}^+</span> defined as in Theorem 6. Then, <span class="math">\\tau (\\cdot) = \\frac{1}{t}\\cdot \\mathrm{Trace}(\\alpha \\cdot (\\cdot))</span> is inner-product embedding for <span class="math">\\alpha = \\prod_{i\\in [k]}\\alpha_{\\mathfrak{f}_i}</span>, where <span class="math">t = 2^{k}\\varphi (\\mathfrak{g})\\prod_{i\\in [k]}\\mathfrak{f}_{i}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Write <span class="math">\\mathcal{R}_{\\mathfrak{g}}</span> for <span class="math">\\mathcal{O}_{\\mathcal{K}_{\\mathfrak{g}}}</span> and <span class="math">\\mathcal{R}_i</span> for <span class="math">\\mathcal{O}_{\\mathcal{K}_{\\bar{p}_i}^+}</span> for <span class="math">i\\in [k]</span>. Define <span class="math">t_{\\mathfrak{f}_i} = 2\\mathfrak{f}_i</span> and <span class="math">t_{\\mathfrak{g}} = \\varphi (\\mathfrak{g})</span>. We prove by induction on tensoring consecutive rings <span class="math">\\mathcal{R}_{\\mathfrak{g}}</span> and <span class="math">\\mathcal{R}_{\\mathfrak{f}_i}\\forall i\\in [k]</span>, indexed as <span class="math">\\mathcal{R}_i = \\mathcal{O}_{\\mathcal{K}_i}</span> for <span class="math">i\\in [h]</span>, where <span class="math">h = k + 1</span> or <span class="math">h = k</span> (if no power-of-two components). We use <span class="math">\\mathfrak{h}_i</span> for <span class="math">i\\in [h]</span> to iterate over coprime factors of the conductor.</p>

    <p class="text-gray-300">By Remark 8 and Theorem 6 <span class="math">\\mathcal{R}_i</span> has an inner-product embedding <span class="math">\\tau_{i}</span>, i.e.</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_{i}((b_{i})_{m}\\cdot (\\bar{b}_{i})_{n}) = \\frac{1}{t_{i}}\\mathsf{Trace}_{\\kappa_{i} / \\zeta_{i}}(\\alpha_{i}\\cdot (b_{i})_{m}\\cdot (\\bar{b}_{i})_{n}) = \\begin{cases} 1 &amp;amp; \\text{if } m = n, \\\\ 0 &amp;amp; \\text{if } m \\neq n \\end{cases} \\quad \\forall i\\in [h].</span></div>

    <p class="text-gray-300">We devise a proof by induction.</p>

    <p class="text-gray-300">First, we define the base case <span class="math">(\\overline{\\mathfrak{h}}_0,\\overline{t}_0,\\overline{\\alpha}_0,\\overline{\\mathcal{R}}_0,\\overline{\\alpha}_0,\\overline{\\mathbf{b}}_0) = (\\mathfrak{h}_0,t_0,\\alpha_0,\\mathcal{R}_0,\\alpha_0,\\mathbf{b}_0)</span>.</p>

    <p class="text-gray-300">Then, for <span class="math">i \\in [h - 1]</span>, define the following inductive steps:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathfrak{h}_{i + 1} := \\mathfrak{h}_{i + 1} \\cdot \\widetilde{\\mathfrak{h}}_{i} \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\quad \\overline{t}_{i + 1} := t_{i} \\cdot \\widetilde{t}_{i + 1}</span></div>

    <p class="text-gray-300"><span class="math">\\widetilde{\\alpha}_{i+1}</span> <span class="math">\\coloneqq\\alpha_{i}\\cdot\\widetilde{\\alpha}_{i+1}</span> <span class="math">\\widetilde{\\mathcal{R}}_{i+1}</span> <span class="math">\\coloneqq\\mathcal{R}_{i+1}\\otimes\\widetilde{\\mathcal{R}}_{i}</span> <span class="math">\\widetilde{\\alpha}_{i+1}</span> <span class="math">\\coloneqq\\alpha_{i+1}\\cdot\\widetilde{\\alpha}_{i}</span> <span class="math">\\widetilde{\\mathbf{b}}_{i+1}</span> <span class="math">\\coloneqq\\mathbf{b}_{i+1}\\otimes\\widetilde{\\mathbf{b}}_{i}</span></p>

    <p class="text-gray-300">We want to show that, if <span class="math">\\widetilde{\\mathcal{R}}_{i}</span> has an inner-product embedding, then <span class="math">\\widetilde{\\mathcal{R}}_{i+1}</span> also has an inner-product embedding.</p>

    <p class="text-gray-300">We write</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathbf{b}}_{i}=\\left\\{\\widetilde{b}_{i,0},\\ldots,\\widetilde{b}_{i,\\widetilde{\\varphi}_{i}-1}\\right\\},</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\mathbf{b}_{i+1}=\\left\\{b_{i+1,0},\\ldots,b_{i+1,\\varphi_{i+1}-1}\\right\\}.</span></p>

    <p class="text-gray-300">Elements of a new basis <span class="math">\\widetilde{\\mathbf{b}}_{i+1}</span> are uniquely defined as a product of two elements from bases <span class="math">\\widetilde{\\mathbf{b}}_{i}</span> and <span class="math">\\mathbf{b}_{i+1}</span>. Consider elements <span class="math">b_{i+1,m}\\cdot\\widetilde{b}_{i,r}</span> and <span class="math">b_{i+1,n}\\cdot\\widetilde{b}_{i,s}</span> of a new basis <span class="math">\\widetilde{\\mathbf{b}}_{i+1}</span> Due to the coprimality of <span class="math">\\widetilde{\\mathfrak{h}}_{i}</span> and <span class="math">\\mathfrak{h}_{i+1}</span>, the tower structure of traces is interchangeable, thus</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\tau}_{i+1}\\left(b_{i+1,m}\\widetilde{b}_{i,r}\\cdot\\overline{b_{i+1,n}\\cdot\\widetilde{b}_{i,s}}\\right)</span> <span class="math">=\\frac{1}{\\widetilde{t}_{i+1}}\\mathsf{Trace}_{\\widetilde{\\kappa}_{\\ldots,\\beta}}\\left(\\widetilde{\\alpha}_{i+1}\\cdot b_{i+1,m}\\widetilde{b}_{i,r}\\cdot\\overline{b_{i+1,n}\\cdot\\widetilde{b}_{i,s}}\\right)</span> <span class="math">=\\frac{1}{\\widetilde{t}_{i}}\\mathsf{Trace}_{\\widetilde{\\kappa}_{\\ldots,\\beta}}\\left(\\widetilde{\\alpha}_{i}\\cdot\\widetilde{b}_{i,r}\\cdot\\widetilde{\\widetilde{b}}_{i,s}\\right)\\cdot\\frac{1}{t_{i+1}}\\mathsf{Trace}_{\\kappa_{\\ldots,\\beta}}\\left(\\alpha_{i+1}\\cdot b_{i+1,m}\\cdot\\breve{b}_{i+1,n}\\right)</span> \\[ =\\widetilde{\\tau}_{i}\\left(\\widetilde{b}_{i,r}\\cdot\\widetilde{\\widetilde{b}}_{i,s}\\right)\\cdot\\tau_{i+1}\\left(b_{i+1,m}\\cdot\\breve{b}_{i+1,n}\\right)=\\begin{cases}1&\\text{if}\\quad(m,r)=(n,s)\\\\ 0&\\text{if}\\quad(m,r)\\neq(n,s)\\end{cases} \\]</p>

    <p class="text-gray-300">Finally,</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathfrak{h},t,\\alpha,\\mathcal{R},\\alpha,\\mathbf{b}\\right)=\\left(\\widetilde{\\mathfrak{h}}_{h-1},\\widetilde{t}_{h-1},\\widetilde{\\alpha}_{h-1},\\widetilde{\\mathcal{R}}_{h-1},\\widetilde{\\alpha}_{h-1},\\widetilde{\\mathbf{b}}_{h-1}\\right),</span></p>

    <p class="text-gray-300">which concludes the proof. ∎</p>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">7.4 Reducing Binariness to Bounded Norm</h3>

    <p class="text-gray-300">We show how to reduce the <span class="math">\\mathbb{Z}</span>-relation <span class="math">\\mathbf{x}\\in\\{0,1\\}^{m\\delta}</span> to an <span class="math">\\mathcal{R}</span>-relation natively supported by the succinct arguments presented in Section 5, via the inner-product embedding framework. First, we recall the following elementary fact from <em>[x14]</em>.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Proposition 2.</h6>

    <p class="text-gray-300">A vector <span class="math">\\mathbf{x}\\in\\mathbb{Z}^{m\\delta}</span> is binary if and and only if <span class="math">\\langle\\mathbf{x},1^{m}-\\mathbf{x}\\rangle_{\\mathbb{Z}}=0</span>.</p>

    <h6 id="sec-59" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">To argue about the “ <span class="math">\\Longrightarrow</span> ” direction this is enough to observe that, for each <span class="math">j\\in[m\\delta]</span>, we have <span class="math">x_{j}=0</span> or <span class="math">1-x_{j}=0</span>. And therefore the sum satisfies <span class="math">\\sum_{j\\in[m\\delta]}x_{j}(1-x_{j})=0</span>. The “ <span class="math">\\Longleftarrow</span> ” direction relies on the observation that, for each <span class="math">j\\in[m\\delta]</span>, <span class="math">x_{j}(1-x_{j})\\geq 0</span> as <span class="math">x_{j}\\in\\mathbb{Z}</span>. Also, if <span class="math">x_{j}\\not\\in\\{0,1\\}</span>, then <span class="math">x_{j}(1-x_{j})&gt;0</span>. Hence, if for some <span class="math">j\\in[m\\delta]</span>, <span class="math">x_{j}\\not\\in\\{0,1\\}</span>, then <span class="math">\\sum_{j\\in[m\\delta]}x_{j}(1-x_{j})&gt;0</span>, which is a contradiction. ∎</p>

    <p class="text-gray-300">Next, we observe the following equivalence: <span class="math">\\langle\\mathbf{x},\\mathbf{1}^{m\\delta}-\\mathbf{x}\\rangle_{\\mathbb{Z}}=0\\iff\\langle\\mathbf{x},\\mathbf{1}^{m\\delta}\\rangle_{\\mathbb{Z}}-\\langle\\mathbf{x},\\mathbf{x}\\rangle_{\\mathbb{Z}}=0\\iff\\langle\\mathbf{x},\\mathbf{1}^{m\\delta}\\rangle_{\\mathbb{Z}}=\\langle\\mathbf{x},\\mathbf{x}\\rangle_{\\mathbb{Z}}</span>. This suggests the following reduction:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The prover sends two claimed values <span class="math">s,t\\in\\mathcal{R}</span> supposedly satisfying <span class="math">\\tau(t)=\\tau(s)</span></li>

      <li>The prover then sends a succinct proof for <span class="math">\\langle\\psi^{-1}(\\mathbf{x}),\\overline{\\psi^{-1}(\\mathbf{1}^{\\delta m})}\\rangle_{\\mathcal{R}}=s</span> and <span class="math">\\langle\\psi^{-1}(\\mathbf{x}),\\overline{\\psi^{-1}(\\mathbf{x})}\\rangle_{\\mathcal{R}}=t</span>.</li>

    </ol>

    <p class="text-gray-300">From the identity <span class="math">\\forall\\ \\mathbf{a},\\mathbf{b}\\in\\mathbb{Z}^{m\\delta}</span>, <span class="math">\\tau(\\langle\\psi^{-1}(\\mathbf{a}),\\overline{\\psi^{-1}(\\mathbf{b})}\\rangle_{\\mathcal{R}})=\\langle\\mathbf{a},\\mathbf{b}\\rangle_{\\mathbb{Z}}</span>, the verifier would be convinced that <span class="math">\\mathbf{x}</span> is indeed binary.</p>

    <p class="text-gray-300">However, there is a subtle issue that, on one hand, the rings <span class="math">\\mathcal{R}</span> considered in this section are of the form displayed in Eq. (14), which are not necessarily equal to <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> or <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span> for any cyclotomic field <span class="math">\\mathcal{K}</span>. On the other hand, the succinct arguments constructed in Section 5 are over rings which admit large subtractive sets, for which we only know constructions in <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> and <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span>. We therefore need to lift the <span class="math">\\mathcal{R}</span>-relations that we want to prove to some <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>-relations (or <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span>-relations, but we focus on the former) with <span class="math">\\mathcal{R}\\subseteq\\mathcal{O}_{\\mathcal{K}}</span>, while ensuring that the prover cannot cheat by using a witness over <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>. To do this, we</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> Fig. 8. Protocol  <span class="math">\\boxed{\\Pi_{\\tau}^{\\mathrm{lin - bin}}}</span>  or  <span class="math">\\boxed{\\Pi_{\\tau}^{\\mathrm{ip - bin}}}</span> , a reduction from  <span class="math">\\boxed{\\Xi_{\\mathrm{par - in}}^{\\mathrm{lin}}\\cap \\Xi_{m,r}^{\\mathrm{bin}}}</span>  or  <span class="math">\\boxed{\\Xi_{\\mathrm{par - in}}^{\\mathrm{ip}}\\cap \\Xi_{m,r}^{\\mathrm{bin}}}</span>  to  <span class="math">\\Xi_{\\mathrm{par - out}}^{\\mathrm{ip}}</span>  with par-in, par-out specified in Theorem 8. The marked parts are only sent / checked when the protocol is used as a proof of knowledge. As a reduction of knowledge, they are omitted.</p>

    <p class="text-gray-300">need the lemma which allows viewing  <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>  as an  <span class="math">\\mathcal{R}</span> -module in such a way that the geometry of  <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>  is respected. We refer to Lemma 9 for a precise lemma with the proof.</p>

    <p class="text-gray-300">We next formally define the binariness relation which ignores the statement and simply checks that the witness is a binary vector.</p>

    <div class="my-4 text-center"><span class="math-block">\\Xi_ {m, r} ^ {\\mathrm {b i n}} := \\left\\{\\left(\\mathsf {s t m t}, \\mathbf {W}\\right): \\mathsf {s t m t} \\in \\{0, 1 \\} ^ {*}; \\mathbf {W} \\in \\mathcal {R} ^ {m \\times r}; \\psi (\\mathbf {W}) \\in \\{0, 1 \\} ^ {m r \\delta} \\right\\}.</span></div>

    <p class="text-gray-300">In Fig. 8, we present two similar reductions of knowledge  <span class="math">\\Pi^{\\mathrm{lin - bin}}</span>  and  <span class="math">\\Pi^{\\mathrm{ip - bin}}</span>  from  <span class="math">\\Xi^{\\mathrm{lin}}\\cap \\Xi^{\\mathrm{bin}}</span>  or  <span class="math">\\Xi^{\\mathrm{ip}}\\cap \\Xi^{\\mathrm{bin}}</span>  to  <span class="math">\\Xi^{\\mathrm{ip}}</span> , respectively. Note that, when reducing  <span class="math">\\Xi^{\\mathrm{ip}}\\cap \\Xi^{\\mathrm{bin}}</span>  to  <span class="math">\\Xi^{\\mathrm{ip}}</span> , the inner product  <span class="math">t = \\langle \\psi^{-1}(\\mathbf{x}),\\overline{\\psi^{-1}(\\mathbf{x})}\\rangle_{\\mathcal{R}}</span>  is already included as part of the statement, and thus the prover does not need to send it. The formal result is stated in Theorem 8, whose proof relies on Lemma 9 stated immediately after.</p>

    <p class="text-gray-300">Theorem 8. Let  <span class="math">m, r, \\ell, b_{\\mathrm{ip}} \\in \\mathbb{N}</span>  and  <span class="math">0 \\leq \\beta \\leq \\beta^{\\mathrm{sis}} \\leq q</span> ,  <span class="math">0 \\leq 2\\beta&#x27; \\leq \\beta^{\\mathrm{sis}}</span> . Let  <span class="math">\\tau</span>  be an inner-product embedding over  <span class="math">\\mathcal{R}</span> . The protocol  <span class="math">\\Pi_{\\tau}^{\\mathrm{lin - bin}}</span>  (resp.  <span class="math">\\Pi_{\\tau}^{\\mathrm{ip - bin}}</span> ) is a perfectly correct reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{ip}} \\cap \\Xi^{\\mathrm{bin}}</span>  to  <span class="math">\\Xi^{\\mathrm{lin}}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\text {o u t}}, r, \\beta\\right) \\mapsto \\left(m, n ^ {\\text {o u t} ^ {\\prime}}, r + \\ell , \\beta_ {\\text {o u t}}\\right)</span></div>

    <p class="text-gray-300">and knowledge sound reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{ip}}\\cap \\Xi^{\\mathrm{bin}\\vee \\mathrm{sis}}</span>  to  <span class="math">\\Xi^{\\mathrm{lin}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\text {o u t}}, r, \\beta^ {\\prime}, \\beta^ {\\text {s i s}}\\right) \\leftrightarrow \\left(m, n ^ {\\text {o u t} ^ {\\prime}}, r + \\ell , \\beta_ {\\text {o u t}} ^ {\\prime}, \\beta^ {\\text {s i s}}\\right),</span></div>

    <p class="text-gray-300">where  <span class="math">n^{\\mathrm{out}&#x27;} = n^{\\mathrm{out}} + 3</span>  for  <span class="math">\\beta = 1</span>  if</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boxed {\\sqrt {m} \\cdot 2 ^ {k} \\cdot \\varphi \\sqrt {\\mathfrak {f} \\varphi} \\cdot \\beta \\leq \\beta^ {\\mathrm {s i s}}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}} \\left(\\text {r e s p .}, \\boxed {2 ^ {k} \\varphi \\beta \\leq \\beta^ {\\mathrm {s i s}}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}}\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where  <span class="math">k</span>  is defined as in Lemma 9.</p>

    <p class="text-gray-300">Proof. For perfect completeness, consider  <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})\\in \\Xi_{m,n^{\\mathrm{out}},\\mu ,\\beta}^{\\mathrm{lin}}\\cap \\Xi_{m,r}^{\\mathrm{bin}}</span>  over  <span class="math">\\mathcal{R}</span> . We have  <span class="math">\\psi (\\mathbf{W})\\in \\{0,1\\}^{rm\\delta}</span> . Clearly,  <span class="math">\\beta = 1</span> , regardless if canonical 2-norm or coefficient  <span class="math">\\infty</span> -norm is concerned. By Proposition 2 and the discussion immediately after, it holds that  <span class="math">\\langle \\psi (\\mathbf{w}_i),\\mathbf{1}^{m\\delta}\\rangle_{\\mathbb{Z}} = \\langle \\psi (\\mathbf{w}_i),\\psi (\\mathbf{w}_i)\\rangle_{\\mathbb{Z}}</span> . Since  <span class="math">\\tau</span>  is an inner-product embedding over  <span class="math">\\mathcal{R}</span> , it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\tau \\left(\\sum_ {i \\in [ r ]} s _ {i}\\right) = \\tau \\left(\\sum_ {i \\in [ r ]} \\langle \\mathbf {w} _ {i}, \\overline {{\\psi^ {- 1} (\\mathbf {1} ^ {\\delta m})}} \\rangle_ {\\mathcal {R}}\\right) = \\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\mathbf {1} ^ {m \\delta} \\rangle_ {\\mathbb {Z}}, \\text {a n d}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau (t) = \\tau \\left(\\sum_ {i \\in [ r ]} \\langle \\mathbf {w} _ {i}, \\overline {{\\mathbf {w} _ {i}}} \\rangle_ {\\mathcal {R}}\\right) = \\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\psi (\\mathbf {w} _ {i}) \\rangle_ {\\mathbb {Z}},</span></div>

    <p class="text-gray-300">and thus <span class="math">\\tau\\left(\\sum_{i\\in [r]}\\{s_i\\}\\right) = \\tau (t)</span>. Furthermore, since <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})\\in \\Xi_{m,n^{\\mathrm{out}},\\mu ,\\beta}^{\\mathrm{lin}}</span>, we have <span class="math">\\mathbf{s}^{\\intercal}\\coloneqq \\overline{\\psi^{-1}(\\mathbf{1}^{\\delta m})}\\cdot \\mathbf{W}</span> and <span class="math">t\\coloneqq \\sum_{i\\in [r]}\\langle \\mathbf{w}_i,\\overline{\\mathbf{w}}_i\\rangle_{\\mathcal{R}}</span>. Therefore, <span class="math">((\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}},t),\\mathbf{W})\\in \\Xi_{m,n^{\\mathrm{out}} + 1,\\mu ,\\beta ,\\mathrm{i}\\overline{\\mathbf{d}}}^{\\mathrm{ip}}</span> over <span class="math">\\mathcal{R}</span>. Since <span class="math">\\mathcal{R}\\subseteq \\mathcal{O}_{\\kappa}</span>, the claim follows.</p>

    <p class="text-gray-300">For perfect relaxed knowledge soundness, suppose that <span class="math">((\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}},t),\\mathbf{W})\\in \\Xi_{m,n^{\\mathrm{out}} + 1,\\mu ,\\beta ,\\mathrm{i}\\overline{\\mathbf{d}}}^{\\mathrm{ip}}</span> over <span class="math">\\mathcal{O}_{\\kappa}</span>. If <span class="math">\\mathbf{W}\\in \\mathcal{R}^{m\\times r}</span>, then we have <span class="math">\\mathbf{s}^{\\intercal}\\coloneqq \\overline{\\psi^{-1}(\\mathbf{1}^{\\delta m})}\\cdot \\mathbf{W}</span> and <span class="math">t\\coloneqq \\sum_{i\\in [r]}\\langle \\mathbf{w}_i,\\overline{\\mathbf{w}}_i\\rangle_{\\mathcal{R}}</span>. Since <span class="math">\\tau \\left(\\sum_{i\\in [r]}s_i\\right) = \\tau (t)</span>, reversing the above argument gives <span class="math">\\psi (\\mathbf{w})\\in \\{0,1\\}^{m\\delta r}</span>. Thus <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{w})\\in \\Xi_{m,n^{\\mathrm{out}},\\mu ,\\beta}^{\\mathrm{lin}}\\cap \\Xi_{m,r}^{\\mathrm{bin}}</span> over <span class="math">\\mathcal{R}</span> as desired.</p>

    <p class="text-gray-300">If <span class="math">\\mathbf{W} \\in \\mathcal{O}_{\\mathcal{K}}^{m} \\setminus \\mathcal{R}^{m}</span>, then we can express any column <span class="math">\\mathbf{w}</span> as a linear combination of <span class="math">\\mathcal{R}</span>-vectors. Let <span class="math">\\hat{\\mathbf{w}}</span> be the coefficient of any basis element other than 1. Note that <span class="math">\\widetilde{\\mathbf{H}}\\mathbf{F}\\hat{\\mathbf{w}} = \\mathbf{0}^{n&#x27;}</span> mod <span class="math">q</span>. Moreover, by Lemma 9, we have</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\hat {\\mathbf {w}}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\leq \\sqrt {m} \\cdot 2 ^ {k} \\cdot \\varphi \\sqrt {\\mathfrak {f} \\varphi} \\cdot \\beta \\leq \\beta^ {\\mathrm {s i s}}} \\left(\\text {resp .}, \\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\hat {\\mathbf {w}}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq 2 ^ {k} \\varphi \\beta \\leq \\beta^ {\\mathrm {s i s}}}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">i.e. a vSIS break.</p>

    <p class="text-gray-300">The argument for <span class="math">\\varPi_{\\sigma}^{\\mathrm{ip - bin}}</span> is almost verbatim, except that <span class="math">t</span> is given as part of the statement rather than being sent by the prover.</p>

    <p class="text-gray-300">Lemma 9. If <span class="math">\\mathfrak{f}</span> be an odd prime, then <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> can be seen as an <span class="math">\\mathcal{O}_{\\mathcal{K}^{+}}</span>-module with the basis <span class="math">\\{1,\\zeta\\}</span>. More generally, let <span class="math">\\mathcal{R} = \\mathcal{O}_{\\mathcal{K}_{\\mathfrak{q}}}\\otimes \\mathcal{O}_{\\mathcal{K}_{\\mathfrak{f}_0}^+}\\otimes \\ldots \\otimes \\mathcal{O}_{\\mathcal{K}_{\\mathfrak{f}_{k - 1}}^+}</span> where <span class="math">\\mathfrak{g} = 2^{d}</span> for some <span class="math">d\\in \\mathbb{N}</span> and <span class="math">\\mathfrak{f}_0,\\dots ,\\mathfrak{f}_{k - 1}</span> are distinct odd primes. Let <span class="math">\\mathfrak{f}\\coloneqq \\mathfrak{g}\\prod_{i\\in [k]}\\mathfrak{f}_i</span>. Then <span class="math">\\mathcal{O}_{\\mathcal{K}_{\\mathfrak{f}}}</span> is an <span class="math">\\mathcal{R}</span>-module with the basis <span class="math">\\bigotimes_{i\\in [k]}(1,\\zeta_{\\mathfrak{f}_i})</span>.</p>

    <p class="text-gray-300">Furthermore, let <span class="math">\\mathbf{x} \\in \\mathcal{O}_{\\mathcal{K}_{\\mathfrak{f}}}^{m}</span> be expressed as a <span class="math">\\mathcal{R}^m</span>-combination of <span class="math">\\bigotimes_{i \\in [k]} (1, \\zeta_{\\mathfrak{f}_i})</span>. If</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf {x}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\leq \\beta} \\left(\\text {resp .}, \\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf {x}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq \\beta}\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">then each <span class="math">\\mathcal{R}</span>-coefficient <span class="math">\\hat{\\mathbf{x}}</span> of <span class="math">\\mathbf{x}</span> satisfies</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\hat {\\mathbf {x}}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2} \\leq 2 ^ {k} \\cdot \\varphi \\sqrt {\\mathfrak {f} \\varphi} \\cdot \\beta} \\left(\\text {resp .}, \\boxed {\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\hat {\\mathbf {x}}) \\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty} \\leq 2 ^ {k} \\varphi \\beta}\\right).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Proof. First part. We first consider the simple case where <span class="math">\\mathfrak{f}</span> is an odd prime. Consider the <span class="math">\\mathbb{Z}</span>-basis <span class="math">\\mathbf{b}^{+} = \\{b_{0}^{+},\\ldots ,b_{\\varphi /2 - 1}^{+}\\} = \\{1,\\zeta +\\zeta^{-1},\\ldots ,\\zeta^{\\varphi /2 - 1} + \\zeta^{1 - \\varphi /2}\\}</span> of <span class="math">\\mathcal{O}_{\\mathcal{K}^+}</span>. We show that <span class="math">(1,\\zeta)\\otimes \\mathbf{b}^{+}</span> is a <span class="math">\\mathbb{Z}</span>-basis of <span class="math">\\mathcal{O}_{\\mathcal{K}}</span>, implying that <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> is an <span class="math">\\mathcal{O}_{\\mathcal{K}^+}</span>-module with the basis <span class="math">\\{1,\\zeta\\}</span>. Consider the "balanced power basis"</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {b} = \\left\\{b _ {- \\varphi / 2 + 1}, \\dots , b _ {- 1}, b _ {0}, \\dots , b _ {\\varphi / 2} \\right\\} \\\\ = \\{\\zeta^ {- \\varphi / 2 + 1}, \\dots , \\zeta^ {- 1}, 1, \\dots , \\zeta^ {\\varphi / 2} \\}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We prove by induction that <span class="math">b_{-i}</span> and <span class="math">b_{i+1}</span> and can be expressed as a <span class="math">\\{-1,0,1\\}</span>-combination of elements from <span class="math">(1,\\zeta)\\otimes \\mathbf{b}^{+}</span> for all <span class="math">i\\in [\\varphi /2]</span>.</p>

    <p class="text-gray-300">For <span class="math">i = 0</span>, we observe that <span class="math">b_{0} = b_{0}^{+}</span> and <span class="math">b_{1} = b_{0}^{+} \\cdot \\zeta</span>. Now, suppose the induction hypothesis holds for <span class="math">i \\leq k</span> for some <span class="math">\\ell \\in [\\varphi /2]</span>, i.e. <span class="math">b_{-i}</span> and <span class="math">b_{i + 1}</span> are constructed for all <span class="math">i \\in [k]</span>. Our goal is to obtain <span class="math">b_{-k}</span> and <span class="math">b_{k + 1}</span>. Observe that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} b _ {k} ^ {+} = b _ {k} + b _ {- k}, \\\\ b _ {k} ^ {+} \\cdot \\zeta = (b _ {k} + b _ {- k}) \\cdot \\zeta = b _ {k + 1} + b _ {- k + 1}, \\\\ b _ {- k} = b _ {k} ^ {+} - b _ {k}, \\\\ b _ {k + 1} = b _ {k} ^ {+} \\cdot \\zeta - b _ {- k + 1}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The claim then follows from the induction hypothesis. The above directly generalises for the tensor rings by arguing about each factor ring independently.</p>

    <p class="text-gray-300">"Furthermore" part. For simplicity, we first consider the case where <span class="math">\\mathfrak{f}</span> is prime. From the previous part of the proof, we know that there exists a <span class="math">\\mathbb{Z}</span>-basis <span class="math">\\mathbf{b}</span> of <span class="math">\\mathcal{O}_{\\mathcal{K}}</span> which can be expressed as a <span class="math">\\{-1,0,1\\}</span>-combination of elements in <span class="math">(1,\\zeta)\\otimes \\mathbf{b}^{+}</span>. We can write</p>

    <div class="my-4 text-center"><span class="math-block">b _ {i} = \\sum_ {j \\in [ \\varphi / 2 ]} s _ {i, j} b _ {j} ^ {+} + \\sum_ {j \\in [ \\varphi / 2 ]} t _ {i, j} b _ {j} ^ {+} \\cdot \\zeta ,</span></div>

    <p class="text-gray-300">where <span class="math">s_{i,j},t_{i,j}\\in\\{-1,0,1\\}</span>.</p>

    <p class="text-gray-300">Consider <span class="math">\\mathbf{x}=(x_{0},\\ldots x_{m-1})</span> for any <span class="math">\\mathbf{x}\\in\\mathcal{O}_{\\mathcal{K}_{l}}^{m}</span>. Then, we write</p>

    <p class="text-gray-300"><span class="math">x_{i}=\\sum_{j\\in[\\varphi]}\\tilde{x}_{i,j}b_{j}=\\sum_{j\\in[\\varphi],\\ell\\in[\\varphi/2]}\\tilde{x}_{i,j}\\left(s_{j,\\ell}+t_{j,\\ell}\\zeta\\right)b_{\\ell}^{+},</span></p>

    <p class="text-gray-300">where <span class="math">\\tilde{x}_{i,j}\\in\\mathbb{Z}^{m}</span>.</p>

    <p class="text-gray-300">Let <span class="math">\\hat{x}_{\\ell,i}=\\sum_{j\\in[\\varphi]}\\tilde{x}_{i,j}(s_{j,\\ell}+t_{j,\\ell}\\zeta)</span> and <span class="math">\\hat{\\mathbf{x}}_{\\ell}=(x_{\\ell,0},\\ldots x_{\\ell,m-1})</span>. Then,</p>

    <p class="text-gray-300"><span class="math">x_{i}=\\sum_{j=\\ell\\in[\\varphi/2]}\\hat{x}_{\\ell,i}b_{j}^{+}.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For canonical 2-norm, consider $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(x_{i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}=\\beta_{i}<span class="math">, by applying Corollary 1, we derive that </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(x_{i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{i}<span class="math">. We observe that as </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,j}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{i}<span class="math">, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{\\ell,i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2\\varphi\\beta_{i}<span class="math"> and </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\hat{x}_{\\ell,i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq 2\\varphi\\sqrt{\\hat{\\mathfrak{f}}\\varphi}\\,\\beta_{i}$ due to the norm conversion.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Eventaully, consider the norm of <span class="math">\\hat{\\mathbf{x}}_{\\ell}</span>, i.e.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\hat{\\mathbf{x}}_{\\ell}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq\\sqrt{\\sum_{i\\in[m]}\\left(\\beta_{i}2\\varphi\\sqrt{\\hat{\\mathfrak{f}}\\varphi}\\right)^{2}^{i}}=2\\varphi\\sqrt{\\hat{\\mathfrak{f}}\\varphi}\\,\\sqrt{\\sum_{i\\in[m]}\\beta_{i}^{2}^{i}}=2\\varphi\\sqrt{\\hat{\\mathfrak{f}}\\varphi}\\,\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma\\left(\\mathbf{x}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{2}\\leq 2\\varphi\\sqrt{\\hat{\\mathfrak{f}}\\varphi}\\,\\beta.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For coefficient <span class="math">\\infty</span>-norm, observe that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(x_{i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math">. Further, </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,j}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math"> so </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{\\ell,i}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2\\varphi\\beta<span class="math"> and </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{\\mathbf{x}}_{j}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 2\\varphi\\beta$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To argue about the composite case, we consider bases <span class="math">\\mathbf{b}=\\mathbf{b}^{(1)}\\otimes\\mathbf{b}^{(2)}</span>, where <span class="math">\\mathbf{b}^{(1)}</span> and <span class="math">\\mathbf{b}^{(2)}</span> are bases of the cyclotomic rings with prime conductors. Let <span class="math">b_{i,j}=b_{i}\\cdot b_{j}</span> and <span class="math">b_{i,j}^{+}=b_{i}^{+}\\cdot b_{j}^{+}</span>. Let <span class="math">\\varphi=\\varphi^{(1)}\\cdot\\varphi^{(2)}</span> and <span class="math">\\zeta=\\zeta^{(1)}\\cdot\\zeta^{(2)}</span> defined analogously. Then, we write:</p>

    <p class="text-gray-300"><span class="math">x_{i}</span> <span class="math">=\\sum_{j^{(1)}\\in[\\varphi^{(1)}],j^{(2)}\\in[\\varphi^{(2)}]}\\tilde{x}_{i,j^{(1)},j^{(2)}}b_{\\ell^{(1)}}^{(1)}b_{\\ell^{(2)}}^{(2)}</span> <span class="math">=\\sum_{\\stackrel{{\\scriptstyle j^{(1)}\\in[\\varphi^{(1)}]}}{{j^{(2)}\\in[\\varphi^{(2)}]}}}\\tilde{x}_{i,j^{(1)},j^{(2)}}b_{\\ell^{(1)}}^{(1)}b_{\\ell^{(2)}}^{(2)}</span> <span class="math">\\stackrel{{\\scriptstyle\\ell^{(2)}\\in[\\varphi^{(2)}/2]}}{{\\ell^{(2)\\in[\\varphi^{(2)}/2]}}}\\tilde{x}_{i,j^{(1)},j^{(2)}}(s_{j^{(1)},\\ell^{(1)}}^{(1)}+t_{j^{(1)},\\ell^{(1)}}^{(1)}\\cdot\\zeta^{(1)})(s_{j^{(2)},\\ell^{(2)}}^{(2)}+t_{j^{(2)},\\ell^{(2)}}^{(2)}\\cdot\\zeta^{(2)})\\cdot b_{\\ell^{(1)},\\ell^{(2)}}^{+}</span> <span class="math">=\\sum_{\\stackrel{{\\scriptstyle j^{(1)}\\in[\\varphi^{(1)}]}}{{j^{(2)}\\in[\\varphi^{(2)}]}}}\\tilde{\\ell^{(1)}\\in[\\varphi^{(1)}/2]}</span> <span class="math">\\stackrel{{\\scriptstyle\\ell^{(2)}\\in[\\varphi^{(2)}/2]}}{{\\ell^{(2)\\in[\\varphi^{(2)}/2]}}}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\hat{x}_{i,\\ell^{(1)},\\ell^{(2)}}=\\sum_{j^{(1)}\\in[\\varphi^{(1)}],j^{(2)}\\in[\\varphi^{(2)}]}\\tilde{x}_{i,j^{(1)},j^{(2)}}(s_{j^{(1)},\\ell^{(1)}}^{(1)}+t_{j^{(1)},\\ell^{(1)}}^{(1)}\\cdot\\zeta^{(1)})(s_{j^{(2)},\\ell^{(2)}}^{(2)}+t_{j^{(2)},\\ell^{(2)}}^{(2)}\\cdot\\zeta^{(2)})</span>. Then, For canonical 2-norm, we observe that as $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,j^{(1)},j^{(2)}}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta_{i}<span class="math">, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,\\ell^{(1)},\\ell^{(2)}}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 4\\varphi\\beta_{i}<span class="math">. For coefficient </span>\\infty<span class="math">-norm, we observe that as </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,j^{(1)},j^{(2)}}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math">, then </span>\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\hat{x}_{i,\\ell^{(1)},\\ell^{(2)}}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 4\\varphi\\beta$. Continue the reasoning as in the base case. Clearly, the argument extends for terson rings of more than two prime rings. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-60" class="text-2xl font-bold">8 Packed <span class="math">\\mathbb{Z}</span>-Inner Products via CRT Embedding</h2>

    <p class="text-gray-300">The idea of embedding <span class="math">\\mathbb{Z}</span>-relations into <span class="math">\\mathcal{R}</span>-relations via the CRT embedding is well-established (e.g. <em>[x10, x13]</em>). However, an obstacle to applying this to lattice-based succinct arguments is the lack of a succinct-verifier argument for proving the consistency of two vectors related via the coefficient and the CRT embeddings.</p>

    <p class="text-gray-300">In this section, we first recall the method of embedding <span class="math">\\mathbb{Z}</span>-relations into <span class="math">\\mathcal{R}</span>-relations via the CRT embedding. Then, by exploiting the fine-grained tower structure of cyclotomic rings with smooth conductors, we provide a verifier-succinct argument for proving the consistency between the coefficient and the CRT embeddings. Throughout this section, we assume that <span class="math">\\mathcal{R}=\\mathbb{Z}[\\zeta_{\\mathfrak{l}}]</span> is a cyclotomic ring of degree <span class="math">\\varphi</span>, and <span class="math">p\\in\\mathbb{N}</span> is a rational prime which splits completely over <span class="math">\\mathcal{R}</span>.</p>

    <p class="text-gray-300">###</p>

    <h3 id="sec-61" class="text-xl font-semibold mt-8">8.1 Embedding <span class="math">\\mathbb{Z}_{p}</span>-inner products into <span class="math">\\mathcal{R}_{p}</span>-inner products</h3>

    <p class="text-gray-300">To begin, let us write <span class="math">\\mathsf{CRT}_{p}:\\mathcal{R}\\to\\mathbb{Z}^{\\varphi}</span>, for the invertible <span class="math">\\mathbb{Z}</span>-linear transform which maps a ring element <span class="math">x\\in\\mathcal{R}</span> to its Chinese remainder representation modulo each prime ideal dividing <span class="math">p</span>. Note that we are viewing <span class="math">\\mathsf{CRT}_{p}</span> as a <span class="math">\\mathbb{Z}</span>-linear map rather than a <span class="math">\\mathbb{Z}_{p}</span>-linear map, and we will write <span class="math">\\text{mod }p</span> explicitly when reducing modulo <span class="math">p</span>. We extend the notation naturally to vectors, i.e. for <span class="math">\\mathbf{x}=(x_{i})_{i\\in[m]}\\in\\mathcal{R}^{m}</span> we define <span class="math">\\mathsf{CRT}_{p}(\\mathbf{x})=(\\mathsf{CRT}_{p}(x_{i}))_{i\\in[m]}</span>.</p>

    <p class="text-gray-300">It is well-known that addition and multiplication in the CRT domain is component-wise. Using this property, there exists a natural method of embedding <span class="math">\\mathbb{Z}_{p}</span>-inner products into <span class="math">\\mathcal{R}_{p}</span>-inner-products, as summarised in Proposition 3. The proof is trivial and thus omitted.</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Proposition 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}=\\mathbb{Z}[\\zeta_{\\mathsf{f}}]</span> be a cyclotomic ring of degree <span class="math">\\varphi</span> and <span class="math">p\\in\\mathbb{N}</span> be a rational prime which fully splits over <span class="math">\\mathcal{R}</span>. Let <span class="math">\\tau_{p}:\\mathcal{R}\\to\\mathbb{Z}</span> be defined as <span class="math">\\tau_{p}(z)\\coloneqq\\langle\\mathbf{1}^{\\varphi},\\mathsf{CRT}_{p}(z)\\rangle</span>. For any <span class="math">\\mathbf{x}=(\\mathbf{x}_{i})_{i\\in[m]},(\\mathbf{y}_{i})_{i\\in[m]}\\in\\mathbb{Z}^{m\\varphi}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\tau_{p}(\\langle\\mathsf{CRT}_{p}^{-1}(\\mathbf{x}),\\mathsf{CRT}_{p}^{-1}(\\mathbf{y})\\rangle_{\\mathcal{R}})=\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}\\text{ mod }p.</span></p>

    <p class="text-gray-300">Using Proposition 3, a prover is already able to succinctly prove that certain <span class="math">\\mathbb{Z}_{p}</span>-inner product relations hold using the succinct arguments provided in Section 5, provided that the application allows the witness vectors to be committed in their <span class="math">\\mathsf{CRT}_{p}^{-1}(\\cdot)</span> form. A bit more concretely, consider a toy example where the prover wishes to prove that <span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=z\\text{ mod }p</span> for some public value <span class="math">z\\in\\mathbb{Z}_{p}</span>, where <span class="math">p</span> is sufficiently shorter than the modulus <span class="math">q</span> used in the argument system. It performs the following procedures:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">\\widehat{z}\\coloneqq\\langle\\mathsf{CRT}_{p}^{-1}(\\mathbf{x}),\\mathsf{CRT}_{p}^{-1}(\\mathbf{y})\\rangle_{\\mathcal{R}}\\text{ mod }p</span> and send it to the verifier.</li>

      <li>Let <span class="math">\\widehat{\\mathbf{x}}\\coloneqq\\mathsf{CRT}_{p}^{-1}(\\mathbf{x})</span> and <span class="math">\\mathsf{CRT}_{p}^{-1}(\\mathbf{y})\\coloneqq\\mathsf{CRT}_{p}^{-1}(\\mathbf{y})\\text{ mod }p</span>.</li>

      <li>Find <span class="math">\\mathbf{r}\\in\\mathcal{R}^{m}</span> such that <span class="math">\\widehat{z}=\\langle\\widehat{\\mathbf{x}},\\widehat{\\mathbf{y}}\\rangle_{\\mathcal{R}}+p\\cdot\\mathbf{r}</span>.</li>

      <li>Commit to <span class="math">(\\widehat{\\mathbf{x}},\\widehat{\\mathbf{y}},\\mathbf{r})</span>.</li>

      <li>Provide a proof that <span class="math">(\\widehat{\\mathbf{x}},\\widehat{\\mathbf{y}},\\mathbf{r})</span> satisfies <span class="math">\\widehat{z}=\\langle\\widehat{\\mathbf{x}},\\widehat{\\mathbf{y}}\\rangle_{\\mathcal{R}}+p\\cdot\\mathbf{r}</span>.</li>

    </ul>

    <p class="text-gray-300">In turn, the verifier checks that <span class="math">\\tau_{p}(\\widehat{z})=z\\text{ mod }p</span> and the proof for <span class="math">\\widehat{z}=\\langle\\widehat{\\mathbf{x}},\\widehat{\\mathbf{y}}\\rangle_{\\mathcal{R}}+p\\cdot\\mathbf{r}</span> is valid. If both checks go through, then by the soundness of the argument system the verifier would be convinced that <span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=z\\text{ mod }p</span> (for some <span class="math">\\mathbf{x},\\mathbf{y}</span> which satisfy <span class="math">(\\mathbf{x},\\mathbf{y})=(\\mathsf{CRT}_{p}(\\widehat{\\mathbf{x}}),\\mathsf{CRT}_{p}(\\widehat{\\mathbf{y}}))\\text{ mod }p</span>).</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">8.2 Lifting to <span class="math">\\mathbb{Z}</span> and <span class="math">\\mathcal{R}</span></h3>

    <p class="text-gray-300">In case the prover wishes to prove that <span class="math">\\langle\\mathbf{x},\\mathbf{y}\\rangle_{\\mathbb{Z}}=z</span> without reduction modulo <span class="math">p</span>, and/or the application postulates that the witness vectors are committed in <span class="math">\\psi^{-1}</span> form, then the prover needs to additionally perform the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Write <span class="math">\\widetilde{\\mathbf{x}}\\coloneqq\\psi^{-1}(\\mathbf{x})</span> and <span class="math">\\widetilde{\\mathbf{y}}\\coloneqq\\psi^{-1}(\\mathbf{y})</span>.</li>

      <li>Find <span class="math">\\mathbf{r},\\widetilde{\\mathbf{s}}\\in\\mathcal{R}^{m}</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathbf{x}}</span> <span class="math">=\\psi^{-1}(\\mathsf{CRT}_{p}(\\widehat{\\mathbf{x}}))+p\\cdot\\mathbf{r},</span> (15) <span class="math">\\widetilde{\\mathbf{y}}</span> <span class="math">=\\psi^{-1}(\\mathsf{CRT}_{p}(\\widehat{\\mathbf{y}}))+p\\cdot\\widetilde{\\mathbf{s}}.</span> (16)</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Further commit to <span class="math">(\\widetilde{\\mathbf{x}},\\widetilde{\\mathbf{y}},\\mathbf{r},\\widetilde{\\mathbf{s}})</span>.</li>

      <li>Provide a proof that <span class="math">\\left\\lVert\\sigma\\left(\\widetilde{\\mathbf{x}}\\right)\\right\\rVert_{2}</span> and <span class="math">\\left\\lVert\\sigma\\left(\\widetilde{\\mathbf{y}}\\right)\\right\\rVert_{2}</span> are short.</li>

      <li>Provide a proof that Eqs. (15) and (16) hold.</li>

    </ul>

    <p class="text-gray-300">From Eqs. (15) and (16), the verifier would be convinced that</p>

    <p class="text-gray-300"><span class="math">\\psi(\\widetilde{\\mathbf{x}})=\\mathsf{CRT}_{p}(\\widetilde{\\mathbf{x}})\\text{ mod }p</span> and <span class="math">\\psi(\\widetilde{\\mathbf{y}})=\\mathsf{CRT}_{p}(\\widetilde{\\mathbf{y}})\\text{ mod }p.</span></p>

    <p class="text-gray-300">Combined with the previous guarantee that <span class="math">\\langle\\mathsf{CRT}_{p}(\\widehat{\\mathbf{x}}),\\mathsf{CRT}_{p}(\\widehat{\\mathbf{y}})\\rangle_{\\mathbb{Z}}=z\\text{ mod }p</span>, the verifier would be convinced that</p>

    <p class="text-gray-300"><span class="math">\\langle\\psi(\\widetilde{\\mathbf{x}}),\\psi(\\widetilde{\\mathbf{y}})\\rangle_{\\mathbb{Z}}=z\\text{ mod }p.</span></p>

    <p class="text-gray-300">With the proof of <span class="math">\\left\\lVert\\sigma\\left(\\widetilde{\\mathbf{x}}\\right)\\right\\rVert_{2}</span> and <span class="math">\\left\\lVert\\sigma\\left(\\widetilde{\\mathbf{y}}\\right)\\right\\rVert_{2}</span> being short, it must be the case that <span class="math">\\left\\lVert\\psi(\\widetilde{\\mathbf{x}})\\right\\rVert_{\\infty}</span> and <span class="math">\\left\\lVert\\psi(\\widetilde{\\mathbf{y}})\\right\\rVert_{\\infty}</span> are also short. Provided that these norms are small enough relative to <span class="math">p</span>, the reduction modulo <span class="math">p</span> has no effect, and thus we arrive at</p>

    <p class="text-gray-300"><span class="math">\\langle\\psi(\\widetilde{\\mathbf{x}}),\\psi(\\widetilde{\\mathbf{y}})\\rangle_{\\mathbb{Z}}=z.</span></p>

    <p class="text-gray-300">Next, we discuss how to succinctly instantiate the above protocol, in particular the arguments for Eqs. (15) and (16), using tools developed in Section 5.</p>

    <p class="text-gray-300">8.3 Computing CRT via Automorphisms</p>

    <p class="text-gray-300">In the above, we established that the method of embedding <span class="math">\\mathbb{Z}</span>-inner products via CRT requires proving consistency between the <span class="math">\\mathsf{CRT}_{p}^{-1}(\\cdot)</span> and <span class="math">\\psi^{-1}(\\cdot)</span> encodings of the witness vectors. Specifically, we would like to design a succinct argument for arguing that</p>

    <p class="text-gray-300"><span class="math">\\widetilde{\\mathbf{x}}=\\psi^{-1}(\\mathsf{CRT}_{p}(\\widetilde{\\mathbf{x}}))\\bmod p</span></p>

    <p class="text-gray-300">where <span class="math">\\widetilde{\\mathbf{x}},\\widetilde{\\mathbf{x}}\\in\\mathcal{R}^{m}</span> are committed vectors. We note that existing protocols for proving such correspondence treat <span class="math">\\psi^{-1}\\circ\\mathsf{CRT}_{p}</span> as a generic <span class="math">\\mathbb{Z}</span>-linear map and prove the correspondence as an unstructured system of linear equations over <span class="math">\\mathbb{Z}</span>. Instead, we would like to exploit the tensor structure of the <span class="math">\\psi^{-1}\\circ\\mathsf{CRT}_{p}</span> map for carefully chosen rings <span class="math">\\mathcal{R}</span>, and the fact that any <span class="math">\\mathbb{Z}</span>-linear map can be expressed as a linear combination of automorphisms in <span class="math">\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})</span> with <span class="math">\\mathcal{R}</span> coefficients.</p>

    <p class="text-gray-300">Motivated by the above, the goal of this subsection is to prove Theorem 9, which states that, for <span class="math">\\mathcal{R}</span> with a smooth conductor, the <span class="math">\\psi^{-1}\\circ\\mathsf{CRT}_{p}</span> map can be expressed as the composition of a few succinct linear combinations of automorphisms in <span class="math">\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})</span> with <span class="math">\\mathcal{R}</span> coefficients. To prove this theorem, we will make use of two elementary lemmas. In Lemma 13, we prove an elementary fact that, if <span class="math">L/K</span> is a Galois extension, then any <span class="math">K</span>-linear map <span class="math">f:L\\to L</span> can be expressed as an <span class="math">L</span>-linear combination of <span class="math">\\mathsf{Gal}(L/K)</span>. Then, in Lemma 14, we prove an analogous lemma for <span class="math">\\mathcal{O}_{K}/p\\mathcal{O}_{K}</span>-linear map <span class="math">f:\\mathcal{O}_{L}/p\\mathcal{O}_{L}\\to\\mathcal{O}_{L}/p\\mathcal{O}_{L}</span>, if <span class="math">L</span> is cyclotomic and has conductor less than <span class="math">p</span>, where <span class="math">p</span> is a rational prime. Using these two results, we arrive at the following theorem.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Theorem 9.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{R}</span> be a cyclotomic ring with a <span class="math">w</span>-smooth conductor <span class="math">\\mathfrak{f}</span>. Then, the transformation <span class="math">\\psi^{-1}\\circ\\mathsf{CRT}_{p}:\\mathcal{R}\\to\\mathcal{R}</span> can be expressed as the succinct composition of <span class="math">\\mathcal{R}</span>-linear combinations of at most <span class="math">w</span> automorphisms over <span class="math">\\mathcal{R}</span>. Formally, there exists <span class="math">t\\in O(\\log\\mathfrak{f})</span>, <span class="math">h_{i}\\leq w</span>, <span class="math">s_{i,j}\\in\\mathcal{R}</span>, and <span class="math">\\alpha_{i,j}\\in\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})</span> for all <span class="math">i\\in[t]</span> and <span class="math">j\\in[h_{i}]</span>, such that</p>

    <p class="text-gray-300"><span class="math">(\\psi^{-1}\\circ\\mathsf{CRT}_{p})(\\cdot)=\\bigcirc_{i\\in[t]}\\sum_{j\\in[h_{i}]}s_{i,j}\\alpha_{i,j}(\\cdot)\\bmod p,</span></p>

    <p class="text-gray-300">where <span class="math">\\bigcirc</span> denotes function composition.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{K}</span> denote the <span class="math">\\mathfrak{f}</span>-th cyclotomic field. Since <span class="math">\\mathfrak{f}</span> is <span class="math">w</span>-smooth, <span class="math">\\mathcal{K}/\\mathbb{Q}</span> can be decomposed into a tower of <span class="math">t\\leq O(\\log\\mathfrak{f})</span> Galois extensions where each step of the extension is of degree at most <span class="math">h_{i}\\leq w</span>. Let <span class="math">L/K</span> denote the <span class="math">i</span>-th step of the tower of extensions. Correspondingly, the map <span class="math">(\\psi^{-1}\\circ\\mathsf{CRT}_{p}\\bmod p)</span> can be decomposed as a composition</p>

    <p class="text-gray-300"><span class="math">\\psi^{-1}\\circ\\mathsf{CRT}_{p}=\\bigcirc_{i\\in[t]}\\widehat{f}_{i}</span></p>

    <p class="text-gray-300">where <span class="math">\\widehat{f}_{i}</span> is obtained by lifting an <span class="math">\\mathcal{O}_{K}/p\\mathcal{O}_{K}</span>-linear map <span class="math">f_{i}:\\mathcal{O}_{L}/p\\mathcal{O}_{L}\\to\\mathcal{O}_{L}/p\\mathcal{O}_{L}</span> to <span class="math">\\mathcal{O}_{\\mathcal{K}}/p\\mathcal{O}_{\\mathcal{K}}</span>. By Lemma 14, <span class="math">f_{i}</span> can be expressed as an <span class="math">\\mathcal{O}_{L}/p\\mathcal{O}_{L}</span>-linear combination of <span class="math">\\mathsf{Gal}(L/K)</span> which contains at most <span class="math">h_{i}\\leq w</span> elements. Correspondingly, <span class="math">\\widehat{f}_{i}</span> can be expressed as an <span class="math">\\mathcal{O}_{\\mathcal{K}}/p\\mathcal{O}_{\\mathcal{K}}</span>-linear combination of <span class="math">\\mathsf{Gal}(\\mathcal{K}/\\mathbb{Q})</span> which contains at most <span class="math">h_{i}\\leq w</span> elements. The theorem thus follows. ∎</p>

    <h3 id="sec-66" class="text-xl font-semibold mt-8">8.4 <span class="math">\\bm{\\Pi}^{\\mathsf{sip}}</span>: Extended Inner-product relation</h3>

    <p class="text-gray-300">The <span class="math">\\Xi^{\\mathsf{ip}}</span> relation defined in Section 5.6 asserts a single constraint on the self-inner-product of the entire witness. In preparation for our CRT-based embedding for <span class="math">\\mathbb{Z}</span>-inner-products to be presented in Section 8, we need a slightly extended relation which captures multiple inner-product relations between different blocks of the witness vector, which is now interpreted as a block vector. Formally, we define the “extended inner-product” relation <span class="math">\\Xi^{\\mathsf{sip}}</span> below.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{r l} &amp; {\\Xi_ {\\mathcal {R}, q, m, n ^ {\\mathrm {s u t}}, r, \\mu , \\atop \\beta , n ^ {\\mathrm {b l k}}, n ^ {\\mathrm {i p}}, \\alpha , \\beta^ {\\mathrm {s i k}}} ^ {\\mathbf {e i p} \\vee \\mathrm {s i s}} := \\left\\{\\begin{array}{l}((\\iota_ {\\mathrm {i p}}, \\iota_ {\\mathrm {i p - i n}}, \\mathbf {H}, \\mathbf {F}, \\mathbf {Y}, \\mathbf {c}, \\mathbf {t}), \\mathbf {W} \\text {o r} \\mathbf {w}):\\\\\\mathbf {H} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {s u t}} \\times n}; \\mathbf {F} \\in \\mathcal {R} _ {q} ^ {n \\times d ^ {\\otimes \\mu}} \\subseteq \\mathcal {R} _ {q} ^ {n \\times m}; \\mathbf {Y} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {s u t}} \\times r}, \\mathbf {c} \\in \\mathcal {R} _ {q} ^ {r}, \\mathbf {t} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {i p}}}\\\\\\iota_ {\\mathrm {i p}} \\in \\{1, - 1 \\} \\rightarrow [ n ^ {\\mathrm {i p}} ]; \\iota_ {\\mathrm {i p - i n}} \\in [ n ^ {\\mathrm {b l k}} ] \\rightarrow [ n ^ {\\mathrm {i p}} ]\\\\\\mathbf {W} = (\\mathbf {w} _ {i}) _ {i \\in [ r ]}; \\mathbf {w} _ {i} ^ {\\intercal} = (\\mathbf {w} _ {i, k} ^ {\\intercal}) _ {k \\in [ n ^ {\\mathrm {b l k}} ]}\\\\\\left\\{\\begin{array}{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {W} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta\\\\\\mathbf {H F W} = \\mathbf {Y} \\bmod q\\\\\\alpha (\\mathbf {c}) = \\mathbf {c}\\\\\\sum_ {i \\in [ r ]} c _ {i} \\langle \\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}, \\alpha_ {\\iota_ {\\mathrm {i p}} (k)} (\\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}) \\rangle_ {\\mathcal {R}} = t _ {k} \\bmod q\\\\\\forall [ k ] \\in [ n ^ {\\mathrm {i p}} ]\\end{array}\\right\\}\\end{array}\\right. \\quad \\text {o r} \\quad \\left\\{\\begin{array}{c}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta^ {\\mathrm {s i s}}\\\\\\overline {{\\mathbf {H F w}}} = 0 _ {\\overline {{\\alpha}}} \\bmod q\\end{array}\\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">Note that  <span class="math">\\Xi^{\\mathrm{eip}}</span>  implicitly has two additional parameters: number of blocks  <span class="math">n^{\\mathrm{blk}}</span>  and number of inner-product relations  <span class="math">n^{\\mathrm{ip}}</span> . Compared to  <span class="math">\\Xi^{\\mathrm{ip}}</span> , a statement in  <span class="math">\\Xi^{\\mathrm{eip}}</span>  contains additionally two index maps  <span class="math">\\iota_{\\mathrm{ip}}:[n^{\\mathrm{ip}}]\\to \\{1, - 1\\}</span>  and  <span class="math">\\iota_{\\mathrm{ip - in}}:[n^{\\mathrm{ip}}]\\to [n^{\\mathrm{blk}}]</span> , and the inner product image  <span class="math">t</span>  is replaced by a vector  <span class="math">\\mathbf{t}\\in \\mathcal{R}_q^{n^{\\mathrm{ip}}}</span> . Furthermore, the single inner-product relation in  <span class="math">\\Xi^{\\mathrm{ip}}</span>  is replaced with weighted inner-product</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i \\in [ r ]} c _ {i} \\langle \\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}, \\alpha_ {\\iota_ {\\mathrm {i p}} (k)} (\\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}) \\rangle_ {\\mathcal {R}} = t _ {k} \\bmod q \\forall k \\in [ n ^ {\\mathrm {i p}} ].</span></div>

    <p class="text-gray-300">Since  <span class="math">\\Pi^{\\mathrm{ip}}</span>  is already quite notation heavy, and the generalisations to  <span class="math">\\Pi^{\\mathrm{eip}}</span>  is straightforward, we omit a formal description but instead highlight the differences between  <span class="math">\\Pi^{\\mathrm{eip}}</span>  and  <span class="math">\\Pi^{\\mathrm{ip}}</span>  below.</p>

    <p class="text-gray-300">The main protocol The main protocol  <span class="math">\\Pi^{\\mathrm{eip}}</span>  differs from  <span class="math">\\Pi^{\\mathrm{ip}}</span>  in the following:</p>

    <p class="text-gray-300">(i) The protocol runs in parallel for  <span class="math">j \\in [n^{\\mathrm{ip}}]</span> :</p>

    <p class="text-gray-300">(i) The witness  <span class="math">\\mathbf{W}</span>  used for obtaining  <span class="math">\\mathbf{V}</span>  (now, denoted as  <span class="math">\\widetilde{\\mathbf{V}}_j</span> ) is replaced by  <span class="math">\\mathbf{W}_{\\iota_{\\mathrm{ip - in}}(j)}</span> . Let</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\mathbf {V}} _ {j} := \\mathbf {e} _ {\\iota_ {\\mathrm {i p - i n}} (j)} \\otimes \\widetilde {\\mathbf {V}} _ {j}.</span></div>

    <p class="text-gray-300">(ii) Similarly, matrix  <span class="math">\\mathbf{E}</span>  is replaced by</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {\\mathbf {E}} _ {j} := \\mathbf {e} _ {\\iota_ {\\mathrm {i p - i n}} (j)} \\otimes \\left( \\begin{array}{c c c c} 1 &amp;amp; \\xi &amp;amp; \\ldots &amp;amp; \\xi^ {m / n ^ {\\mathrm {b l k}} - 1} \\\\ 1 &amp;amp; \\bar {\\xi} ^ {- 1} &amp;amp; \\ldots &amp;amp; \\bar {\\xi} ^ {- (m / n ^ {\\mathrm {b l k}} - 1)} \\\\ 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\end{array} \\right).</span></div>

    <p class="text-gray-300">(ii) The new claims both parties compute are:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {H}} := \\left( \\begin{array}{c c} \\mathbf {H} &amp;amp; \\mathbf {0} \\\\ \\mathbf {0} &amp;amp; \\mathbf {I} _ {n ^ {\\mathrm {s u t}} \\cdot 3} \\end{array} \\right), \\quad \\widetilde {\\mathbf {F}} := \\left( \\begin{array}{c} \\mathbf {F} \\\\ \\sum_ {j \\in [ n ^ {\\mathrm {i p}} ]} \\mathbf {e} _ {j} \\otimes \\widehat {\\mathbf {E}} _ {j} \\end{array} \\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {Y}} := \\left( \\begin{array}{c} \\mathbf {Y} \\\\ \\sum_ {j \\in [ n ^ {\\mathrm {i p}} ]} \\mathbf {e} _ {j} \\otimes \\mathbf {Y} _ {\\widehat {\\mathbf {E}} _ {j}} \\end{array} \\right), \\quad \\widetilde {\\mathbf {Y}} _ {i} ^ {\\prime} := \\left( \\begin{array}{c} \\mathbf {Y} _ {i} ^ {\\prime} \\\\ \\sum_ {j \\in [ n ^ {\\mathrm {i p}} ]} \\mathbf {e} _ {j} \\otimes \\mathbf {Y} _ {\\widehat {\\mathbf {E}} _ {j}, i} ^ {\\prime} \\end{array} \\right),</span></div>

    <p class="text-gray-300">where  <span class="math">\\mathbf{Y}_{\\widehat{\\mathbf{E}}_j} \\coloneqq \\widehat{\\mathbf{E}}_j \\mathbf{W}</span>  and  <span class="math">\\mathbf{Y}_{\\widehat{\\mathbf{E}}_j,i}&#x27; \\coloneqq \\widehat{\\mathbf{E}}_j \\widehat{\\mathbf{V}}_{j,i}</span> .</p>

    <p class="text-gray-300">(iii) Further, the verifications are replaced by</p>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\mathbf {V}}} = \\sum_ {[ i, j ] \\in [ \\ell , n ^ {\\mathrm {i p}} ]} \\mathbf {e} _ {i} ^ {\\intercal} \\otimes \\widehat {\\mathbf {V}} _ {j, i}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\mathbf {W}}} = (\\overline {{\\mathbf {V}}}, \\mathbf {W})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\overline {{\\mathbf {Y}}} = \\sum_ {[ i ] \\in [ \\ell ]} \\mathbf {e} _ {i} ^ {\\intercal} \\otimes \\widetilde {\\mathbf {Y}} _ {i} ^ {\\prime} + \\mathbf {e} _ {\\ell} ^ {\\intercal} \\otimes \\widetilde {\\mathbf {Y}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\widetilde {\\mathbf {H}}, \\widetilde {\\mathbf {F}}, \\overline {{\\mathbf {Y}}}\\right), \\overline {{\\mathbf {W}}}\\right) _ {j \\in [ n ^ {\\mathrm {i p}} ]} \\stackrel {?} {\\in} \\Xi_ {m, n ^ {\\mathrm {s u t}} + 3 \\cdot n ^ {\\mathrm {i p}}, r \\cdot n ^ {\\mathrm {i p}} \\cdot (\\ell + 1), \\beta_ {0}}</span></div>

    <p class="text-gray-300">for the same parameters as in Fig. 7.</p>

    <p class="text-gray-300">We do not provide explicit proof of Lemma 10 below as it completely analogous to Lemma 8.</p>

    <p class="text-gray-300">Lemma 10 (Extended Norm and Inner Product). Let  <span class="math">m, r, \\ell, b_{\\mathrm{ip}} \\in \\mathbb{N}</span>  and  <span class="math">0 \\leq \\beta \\leq \\beta^{\\mathrm{six}} \\leq q</span> ,  <span class="math">0 \\leq 2\\beta&#x27; \\leq \\beta^{\\mathrm{six}}</span> . Protocol  <span class="math">\\Pi^{\\mathrm{ip}}</span>  is a perfectly correct reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{ip}}</span>  to  <span class="math">\\Xi^{\\mathrm{fin}}</span></p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\text {o u t}}, r, n ^ {\\text {i p}}, \\beta ,\\right) \\mapsto \\left(m, n ^ {\\text {o u t} ^ {\\prime}}, r + n ^ {\\text {i p}} \\cdot \\ell , \\beta_ {\\text {o u t}}\\right)</span></div>

    <p class="text-gray-300">where  <span class="math">\\beta_{\\mathrm{out}} = \\sqrt{\\beta^2 + \\beta_{\\overline{\\mathbf{V}}}^2}</span>  (resp.  <span class="math">\\beta_{\\mathrm{out}} = \\max \\{\\beta, \\beta_{\\overline{\\mathbf{V}}}\\}</span> ), and knowledge sound reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{ip}}</span>  to  <span class="math">\\Xi^{\\mathrm{fin}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\text {o u t}}, r, \\beta^ {\\prime}, \\beta^ {\\text {s i x}}\\right) \\leftrightarrow \\left(m, n ^ {\\text {o u t} ^ {\\prime}}, r + n ^ {\\text {i p}} \\cdot \\ell , \\beta_ {\\text {o u t}} ^ {\\prime}, \\beta^ {\\text {s i x}}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">n^{\\mathrm{out}&#x27;} = n^{\\mathrm{out}} + 3n^{\\mathrm{ip}}</span> ,  <span class="math">b_{\\mathrm{ip}}</span>  and  <span class="math">\\ell \\geq \\log_{b_{\\mathrm{ip}}} (2\\beta_{\\overline{\\mathbf{V}}}^2 + 1)</span>  is such that  <span class="math">b_{\\mathrm{ip}} \\leq 2\\beta_{\\overline{\\mathbf{V}}} / (\\sqrt{\\ell m} \\sqrt{\\dagger \\varphi})</span>  (resp.  <span class="math">b_{\\mathrm{ip}} = 2\\beta_{\\overline{\\mathbf{V}}} + 1</span>  and  <span class="math">\\ell \\geq \\log_{b_{\\mathrm{ip}}} (2\\beta_{\\overline{\\mathbf{V}}} + 1)</span> ). Extraction requires two uniformly distributed transcripts (Footnote 11) and has knowledge error  $\\kappa \\leq \\frac{2m}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . For  </span>\\Pi^{\\mathrm{norm}}$ , the analogous statements hold.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-67" class="text-2xl font-bold">8.5  <span class="math">\\Pi^{\\mathrm{aut}}</span> : Automorphism Check</h2>

    <p class="text-gray-300">For our CRT-based protocol, we need to efficiently check automorphism relations between different blocks of the witness. Formally, we define the automorphism check relation below.</p>

    <p class="text-gray-300">$$ \\begin{array}{l} \\Xi^ {\\mathrm {a u t}; \\mathrm {c a i g}} _ {\\mathcal {R}, q, m, n ^ {\\mathrm {o u t}}, r, \\mu ,} \\quad \\left\\{ \\begin{array}{l} ((\\iota_ {\\mathrm {i p}}, \\iota_ {\\mathrm {i p - i n}}, \\iota_ {\\mathrm {a u t}}, \\iota_ {\\mathrm {a u t - i n}}, \\iota_ {\\mathrm {a u t - o u t}}, \\mathbf {H}, \\mathbf {F}, \\mathbf {Y}, \\mathbf {c}, \\mathbf {t}), \\mathbf {W} \\text {o r} \\mathbf {w}): \\\\ \\mathbf {H} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {o u t}} \\times n}; \\mathbf {F} \\in \\mathcal {R} _ {q} ^ {n \\times d ^ {\\otimes \\mu}} \\subseteq \\mathcal {R} _ {q} ^ {n \\times m}; \\mathbf {Y} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {o u t}} \\times r}, \\mathbf {c} \\in \\mathcal {R} _ {q} ^ {r}, \\mathbf {t} \\in \\mathcal {R} _ {q} ^ {n ^ {\\mathrm {i p}}} \\\\ \\iota_ {\\mathrm {i p}} \\in \\{1, - 1 \\} \\to [ n ^ {\\mathrm {i p}} ]; \\iota_ {\\mathrm {i p - i n}} \\in [ n ^ {\\mathrm {b l k}} ] \\to [ n ^ {\\mathrm {i p}} ] \\\\ \\iota_ {\\mathrm {a u t}} \\in [ \\varphi ] \\to [ n ^ {\\mathrm {a u t}} ]; \\iota_ {\\mathrm {a u t - i n}}, \\iota_ {\\mathrm {a u t - o u t}} \\in [ n ^ {\\mathrm {b l k}} ] \\to [ n ^ {\\mathrm {a u t}} ] \\\\ \\mathbf {W} = (\\mathbf {w} _ {i}) _ {i \\in [ r ]}; \\mathbf {w} _ {i} = \\underbrace {\\overline {{\\mathbf {w} _ {i , k}}}} _ {k \\in [ n ^ {\\mathrm {b l k}} ]}; \\widetilde {\\mathbf {W}} _ {k} = \\underbrace {\\overline {{\\mathbf {W} _ {k}}}} _ {k \\in [ n ^ {\\mathrm {b l k}} ]} \\\\ \\left\\{ \\begin{array}{c}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {W} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathbf {H F W} = \\mathbf {Y} \\bmod q \\\\ \\alpha (\\mathbf {c}) = \\mathbf {c} \\\\ \\sum_ {i \\in [ r ]} c _ {i} \\langle \\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}, \\alpha_ {\\iota_ {\\mathrm {i p}} (k)} (\\mathbf {w} _ {i, \\iota_ {\\mathrm {i p - i n}} (k)}) \\rangle_ {\\mathcal {R}} = t _ {k} \\bmod q \\forall [ k ] \\in [ n ^ {\\mathrm {i p}} ] \\\\ \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\widetilde {\\mathbf {W}} _ {i, \\iota_ {\\mathrm {a u t - i n}} (k)}) = \\widetilde {\\mathbf {W}} _ {i, \\iota_ {\\mathrm {a u t - o u t}} (k)} \\bmod q \\quad \\forall k \\in [ n ^ {\\mathrm {a u t}} ] \\\\ \\text {o r} \\quad \\left\\{ \\begin{array}{c}</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf {w} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\beta^ {\\mathrm {s i g}} \\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\overline {{\\mathbf {H F w}}} = \\theta_ {\\overline {{\\mathbf {H}}}} \\bmod q \\end{array} \\right. \\end{array} \\right. \\end{array} \\right. $$</p>

    <p class="text-gray-300">Note that  <span class="math">\\Xi^{\\mathrm{aut}}</span>  implicitly has an additional parameter - the number of automorphism relations  <span class="math">n^{\\mathrm{aut}}</span> . An instance of  <span class="math">\\Xi^{\\mathrm{aut}}</span>  is almost identical to an instance of  <span class="math">\\Xi^{\\mathrm{sip}}</span> , except that it additionally asserts that the automorphism relations  <span class="math">\\alpha_{\\iota_{\\mathrm{aut}}(k)}(\\mathbf{w}_{\\iota_{\\mathrm{aut - in}}(k)}) = \\mathbf{w}_{\\iota_{\\mathrm{aut - out}}(k)} \\bmod q</span>  hold for all  <span class="math">k \\in [n^{\\mathrm{aut}}]</span>  for the index maps  <span class="math">\\iota_{\\mathrm{aut}}, \\iota_{\\mathrm{aut - in}}, \\iota_{\\mathrm{aut - out}}</span>  given as part of the statement. Thus, to see that  <span class="math">\\Xi^{\\mathrm{aut}}</span>  reduces to  <span class="math">\\Xi^{\\mathrm{sip}}</span> , we only need to check that the automorphism relations can be reduced to linear relations. We outline the logic of this reduction below and give a formal description in Fig. 9.</p>

    <p class="text-gray-300">Instead of checking that all automorphism relations hold, which would not be succinct, the verifier sends a random  <span class="math">\\xi \\gets \\mathbb{C}_{\\mathcal{R}_q} \\subseteq \\mathcal{R}_q</span> . The prover then sends</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} _ {k} := (1, \\xi , \\dots , \\xi^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\text {a u t - i n}} (k)} \\bmod q</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {z} _ {k} ^ {\\prime} := (1, \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi), \\dots , \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi) ^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - o u t}} (k)} \\bmod q</span></div>

    <p class="text-gray-300">for  <span class="math">k\\in [n^{\\mathrm{aut}}]</span></p>

    <p class="text-gray-300">In turn, the verifier checks that  <span class="math">\\alpha_{\\iota_{\\mathrm{aut}}(k)}(\\mathbf{z}_k) = \\mathbf{z}_k&#x27;</span>  for  <span class="math">k \\in [n^{\\mathrm{aut}}]</span> . Completeness can be seen by observing</p>

    <div class="my-4 text-center"><span class="math-block">\\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\mathbf {z} _ {k}) = \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} ((1, \\xi , \\dots , \\xi^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - i n}} (k)})</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} = (1, \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi), \\dots , \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi) ^ {m - 1}) \\cdot \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - i n}} (k)}) \\\\ = (1, \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi), \\dots , \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi) ^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - a u t}} (k)} = \\mathbf {z} _ {k} ^ {\\prime}. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This reduces the automorphism check to verifying the linear relations</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf {z} _ {k} := (1, \\xi , \\dots , \\xi^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - i n}} (k)} \\bmod q \\forall k \\in [ n ^ {\\mathrm {a u t}} ], \\\\ \\mathbf {z} _ {k} ^ {\\prime} := (1, \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi), \\dots , \\alpha_ {\\iota_ {\\mathrm {a u t}} (k)} (\\xi) ^ {m - 1}) \\cdot \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - a u t}} (k)} \\bmod q \\forall k \\in [ n ^ {\\mathrm {a u t}} ] \\\\ \\end{array}</span></div>

    <p class="text-gray-300">which is supported by  <span class="math">\\Xi^{\\mathrm{eip}}</span> . Note that the reduction increases the number of rows significantly, and  <span class="math">\\Pi^{\\mathrm{batch}}</span>  could be run to batch them before further reductions.</p>

    <p class="text-gray-300">The security of  <span class="math">\\Pi^{\\mathrm{aut}}</span>  is summarised below. Nevertheless, the proof is omitted due to its similarity with the previous proofs in this section.</p>

    <p class="text-gray-300">Lemma 11 (Security of  <span class="math">\\Pi^{\\mathrm{aut}}</span> ). Let  <span class="math">n^{\\mathrm{out}}, n^{\\mathrm{ip&#x27;}}, \\in \\mathbb{N}</span>  and  <span class="math">0 \\leq \\beta \\leq \\beta^{\\mathrm{ais}} \\leq q</span> . The protocol  <span class="math">\\Pi^{\\mathrm{aut}}</span>  is a perfectly correct reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{aut}}</span>  to  <span class="math">\\Xi^{\\mathrm{eip}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(n ^ {\\mathrm {i p}}, n ^ {\\mathrm {o u t}}\\right) \\mapsto \\left(n ^ {\\mathrm {i p} ^ {\\prime}}\\right)</span></div>

    <p class="text-gray-300">and knowledge sound reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{aut}}</span>  to  <span class="math">\\Xi^{\\mathrm{eip}}</span> , with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(n ^ {\\mathrm {i p}}, n ^ {\\mathrm {o u t}}, \\beta^ {\\mathrm {a i s}}\\right) \\leftrightarrow \\left(n ^ {\\mathrm {i p} ^ {\\prime}}, \\beta^ {\\mathrm {a i s}}\\right),</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  <span class="math">n^{\\mathrm{ip}&#x27;} = n^{\\mathrm{out}} + n^{\\mathrm{ip}}</span> . The knowledge error is  $n^{\\mathrm{aut}} / \\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathcal{R}_q}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-68" class="text-2xl font-bold">8.6 Reducing CRT-based Binariness Check to Automorphism Check</h2>

    <p class="text-gray-300">Equipped with Theorem 9 and Lemma 11, in Fig. 10, we construct a reduction of knowledge  <span class="math">\\Pi_{\\mathrm{crit},p}^{\\mathrm{lin - bin}}</span>  using a CRT-based binariness check. For the ease of notation, the reduction of knowledge  <span class="math">\\Pi_{\\mathrm{crit},p}^{\\mathrm{lin - bin}}</span>  in Fig. 10 makes use of the following subroutine CRTmake(H,F,Y,W) which maps a  <span class="math">\\Xi^{\\mathrm{lin}}\\cap \\Xi^{\\mathrm{bin}}</span>  instance to a  <span class="math">\\Xi^{\\mathrm{aut}}</span>  instance:</p>

    <h2 id="sec-69" class="text-2xl font-bold">CRTmake(H,F,Y,W)</h2>

    <p class="text-gray-300">(i) Compute  <span class="math">\\widetilde{\\mathbf{W}}_0\\coloneqq \\mathsf{CRT}_p^{-1}(\\psi (\\mathbf{W}))</span>  and let  <span class="math">\\mathbf{R}_0\\coloneqq \\mathbf{0}^{m\\times r}</span> (ii) Compute  <span class="math">\\widetilde{\\mathbf{y}}^{\\dagger} := \\left(\\mathsf{CRT}^{-1}(\\mathbf{1}^{\\varphi m})\\right)^{\\top} \\cdot \\left(\\mathsf{CRT}_{p}^{-1}(\\psi (\\mathbf{W}))\\right)</span> ,  <span class="math">t_0 := \\sum_{i \\in [r]} \\langle \\mathsf{CRT}_p^{-1}(\\psi (\\mathbf{w}_i)), \\mathsf{CRT}_p^{-1}(\\psi (\\mathbf{w}_i)) \\rangle_{\\mathcal{R}}</span> , and  <span class="math">t_1 := \\sum_{i \\in [r]} \\langle \\mathbf{w}_i, \\overline{\\mathbf{w}_i} \\rangle_{\\mathcal{R}}</span> .</p>

    <p class="text-gray-300">(iii) For each  <span class="math">i\\in [t]</span></p>

    <p class="text-gray-300">(i) Compute the  <span class="math">i</span> -th step of the CRT decomposition as described in Theorem 9, i.e.  <span class="math">\\mathbf{W}_{i,j} \\coloneqq \\alpha_{i,j}(\\widetilde{\\mathbf{W}}_i)</span>  for all  <span class="math">j \\in [h_i]</span> . (ii) Compute the  <span class="math">p</span> -ary representative  <span class="math">\\widetilde{\\mathbf{W}}_{i + 1}\\coloneqq \\sum_{j\\in [h_i]}s_{i,j}\\mathbf{W}_{i,j}</span>  mod  <span class="math">p</span> (iii) Find the quotient  <span class="math">\\mathbf{R}_{i + 1}\\in \\mathcal{R}^m</span>  satisfying  <span class="math">\\widetilde{\\mathbf{W}}_{i + 1} - \\sum_{j\\in [h_i]}s_{i,j}\\cdot \\mathbf{W}_{i,j} + p\\cdot \\mathbf{R}_{i + 1} = \\mathbf{0}^{m\\times r}</span>  (mod  <span class="math">q</span> ).</p>

    <p class="text-gray-300">(iv) Concatenate all intermediate witnesses as</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde {\\mathbf {W}} := \\overbrace {\\underbrace {\\mathbf {W} _ {i , j} ^ {\\dagger}} _ {(i , j) \\in [ t , h _ {i} ]}} ^ {\\mathbf {W} _ {i, j} ^ {\\dagger}} \\in \\mathcal {R} ^ {\\tilde {m} \\cdot r}</span></div>

    <p class="text-gray-300">where  <span class="math">\\tilde{m} := m \\cdot n^{\\mathrm{blk}}</span>  and  <span class="math">n^{\\mathrm{blk}} := w \\log \\mathfrak{f} + 2t + 2</span> .</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 9. Protocol  <span class="math">\\Pi^{\\mathrm{aut}}</span> , a reduction of knowledge from  <span class="math">\\Xi_{m,\\mu,\\beta,n^{\\mathrm{aut}},n,n^{\\mathrm{bb}},n^{\\mathrm{ip}},n^{\\mathrm{aut}}}^{\\mathrm{aut}}</span>  to  <span class="math">\\Xi_{m,\\mu,\\beta,n^{\\mathrm{aut}}+2\\cdot n^{\\mathrm{aut}},n+2\\cdot,n^{\\mathrm{bb}},n^{\\mathrm{ip}}}^{\\mathrm{sup}}</span> .  <span class="math">\\Pi^{\\mathrm{aut}}</span>  sends the marked parts only as a proof (but not reduction) of knowledge.</p>

    <p class="text-gray-300">(v) Parse the witness as a block vector  <span class="math">\\widetilde{\\mathbf{W}} = \\overbrace{\\widetilde{\\mathbf{W}}_k}^{\\widetilde{\\mathbf{W}}_k}</span>  where  <span class="math">\\widetilde{\\mathbf{W}}_k\\in \\mathcal{R}^{m\\cdot r}</span> . (vi) Concatenate all linear map images as</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">(vii) Concatenate all inner product images as  <span class="math">\\widetilde{\\mathbf{t}}^{\\mathrm{T}}\\coloneqq (\\widetilde{t}_0,\\widetilde{t}_1)\\in \\mathcal{R}^2</span> (viii) Define a matrix  <span class="math">\\widetilde{\\mathbf{F}}\\in \\mathcal{R}_q^{\\widetilde{n}\\times \\widetilde{m}}</span>  such that  <span class="math">\\widetilde{\\mathbf{F}}\\widetilde{\\mathbf{W}} = \\widetilde{\\mathbf{Y}}\\bmod q</span>  represented the following system of equations:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{F}\\widetilde{\\mathbf{W}}_t = \\mathbf{Y}</span>  (mod  <span class="math">q</span>  1</p>

    <p class="text-gray-300"><span class="math">\\left(\\mathsf{CRT}^{-1}(\\mathbf{1}^{\\varphi m})\\right)^{\\mathsf{T}}\\cdot \\widehat{\\mathbf{W}}_0 = \\widehat{\\mathbf{y}}^{\\mathsf{T}}</span>  (mod  <span class="math">q</span>  1</p>

    <p class="text-gray-300"><span class="math">\\widehat{\\mathbf{W}}_{i + 1} - \\sum_{j\\in [h_i]}s_{i,j}\\cdot \\mathbf{W}_{i,j} + p\\cdot \\mathbf{R}_{i + 1} = \\mathbf{0}^{m\\times r}\\pmod {q}\\forall i\\in [t].</span></p>

    <p class="text-gray-300">(ix) Write  <span class="math">\\{\\sigma_k\\}_{k\\in \\mathbb{Z}_1^\\times} = \\mathsf{Gal}(\\mathcal{K} / \\mathbb{Q})</span></p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 10. Protocol  <span class="math">I_{\\mathrm{ort},p}^{\\mathrm{lin - bin}}</span> , a reduction from  <span class="math">\\Xi^{\\mathrm{lin}} \\cap \\Xi^{\\mathrm{bin}}</span>  to  <span class="math">\\Xi^{\\mathrm{aut}}</span> , where  <span class="math">\\beta, \\beta&#x27;</span> , and  <span class="math">p</span>  are set as in Lemma 12. See the text for the definition of the subroutine CRTmake. The marked parts are only sent / checked when  <span class="math">I_{\\mathrm{ort},p}^{\\mathrm{lin - bin}}</span>  is used as a proof of knowledge. As a reduction of knowledge, they are omitted.</p>

    <p class="text-gray-300">(x) Let  <span class="math">\\widetilde{\\mathbf{W}} = \\left(\\widehat{\\widetilde{\\mathbf{w}}_{k,i}}_{k\\in [n^{\\mathrm{bk}}]}\\right)_{i\\in [r]}</span> . Let  <span class="math">n^{\\mathrm{ip}}\\coloneqq 2</span>  and define the index maps  <span class="math">\\iota_{\\mathrm{ip}}:[n^{\\mathrm{ip}}]\\to \\{1, - 1\\}</span>  and  <span class="math">\\iota_{\\mathrm{ip - in}}:[n^{\\mathrm{ip}}]\\to [n^{\\mathrm{blk}}]</span>  for inner products such that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ n ^ {\\mathrm {i p}} ], t _ {k} = \\sum_ {i \\in [ r ]} \\langle \\widetilde {\\mathbf {w}} _ {\\iota_ {\\mathrm {i p - i n}} (k), i}, \\sigma_ {\\iota_ {\\mathrm {i p}} (k)} (\\widetilde {\\mathbf {w}} _ {\\iota_ {\\mathrm {i p - i n}} (k), i}) \\rangle \\iff \\widetilde {t} _ {0} = \\sum_ {i \\in [ r ]} \\langle \\widehat {\\mathbf {w}} _ {0, i}, \\widehat {\\mathbf {w}} _ {0, i} \\rangle_ {\\mathcal {R}} \\wedge \\widetilde {t} _ {1} = \\sum_ {i \\in [ r ]} \\langle \\widehat {\\mathbf {w}} _ {t, i}, \\overline {{\\widehat {\\mathbf {w}}} _ {t , i}} \\rangle_ {\\mathcal {R}}</span></div>

    <p class="text-gray-300">(xi) Let  <span class="math">\\widehat{\\mathbf{W}} = \\widehat{\\widetilde{\\mathbf{W}}_k}_{k\\in [n^{\\mathrm{bk}}]}</span> . Let  <span class="math">n^{\\mathrm{aut}}\\coloneqq w\\log \\mathfrak{f}</span>  and define the index maps  <span class="math">\\iota_{\\mathrm{aut}}:[n^{\\mathrm{aut}}]\\to \\mathbb{Z}_{\\mathfrak{f}}^{\\times}</span>  and  <span class="math">\\iota_{\\mathrm{aut - in}}:[n^{\\mathrm{aut}}]\\to [n^{\\mathrm{blk}}]</span> , and  <span class="math">\\iota_{\\mathrm{aut - out}}:[n^{\\mathrm{aut}}]\\to [n^{\\mathrm{blk}}]</span>  for automorphisms so that</p>

    <div class="my-4 text-center"><span class="math-block">\\forall k \\in [ \\mathfrak {f} ], \\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - o u t}} (k)} = \\sigma_ {\\iota_ {\\mathrm {a u t}} (k)} (\\widetilde {\\mathbf {W}} _ {\\iota_ {\\mathrm {a u t - i n}} (k)}) \\iff \\forall i \\in [ t ], j \\in [ h _ {i} ], \\mathbf {W} _ {i, j} := \\alpha_ {i, j} (\\widetilde {\\mathbf {W}} _ {i}).</span></div>

    <p class="text-gray-300">(xii) Set  <span class="math">\\widetilde{\\mathbf{H}}\\coloneqq \\left( \\begin{array}{ll}\\mathbf{H} &amp;amp; \\mathbf{0}\\\\ \\mathbf{0} &amp;amp; \\mathbf{I}_{tm + 1} \\end{array} \\right).</span></p>

    <p class="text-gray-300">(xiii) Output  <span class="math">(\\iota_{\\mathrm{ip}},\\iota_{\\mathrm{ip - in}},\\iota_{\\mathrm{aut}},\\iota_{\\mathrm{aut - in}},\\iota_{\\mathrm{aut - out}},\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}},\\widetilde{\\mathbf{t}},\\widetilde{\\mathbf{W}})</span></p>

    <p class="text-gray-300">Lemma 12. Let  <span class="math">m, n^{\\mathrm{out}}, r, \\in \\mathbb{N}, 0 \\leq \\beta \\leq \\beta^{\\mathrm{sis}} \\leq q</span> . The protocol  <span class="math">\\Pi_{\\mathrm{ert},p}^{\\mathrm{lin - bin}}</span>  is a perfectly correct reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{lin}} \\cap \\Xi^{\\mathrm{bin}}</span>  to  <span class="math">\\Xi^{\\mathrm{aut}}</span>  with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\mathrm {o u t}}, \\beta\\right) \\mapsto \\left( \\begin{array}{c c} m ^ {\\prime} &amp;amp; n ^ {\\mathrm {o u t} ^ {\\prime}}, \\quad \\beta^ {\\prime}, \\\\ n ^ {\\mathrm {i p}} = 2, &amp;amp; n ^ {\\mathrm {a u t}} = w \\log \\mathfrak {f}, \\quad n ^ {\\mathrm {b l k}} = w (1 + t) + 2 t + 2 \\end{array} \\right).</span></div>

    <p class="text-gray-300">and knowledge sound reduction of knowledge from  <span class="math">\\Xi^{\\mathrm{lin}\\vee \\mathrm{sis}}\\cap \\Xi^{\\mathrm{bin}\\vee \\mathrm{sis}}</span>  to  <span class="math">\\Xi^{\\mathrm{aut}\\vee \\mathrm{sis}}</span> , with parameters</p>

    <div class="my-4 text-center"><span class="math-block">\\left(m, n ^ {\\text {o u t}}, \\beta , \\beta^ {\\text {s i s}}\\right) \\leftrightarrow \\left(m ^ {\\prime} n ^ {\\text {o u t} ^ {\\prime}}, \\beta^ {\\prime}, \\beta^ {\\text {s i s}}\\right).</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta = \\boxed {\\sqrt {\\hat {\\mathfrak {f}} \\varphi} \\cdot \\sqrt {m r}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}} \\left(\\operatorname {r e s p} _ {\\cdot}, \\boxed {1} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">m ^ {\\prime} = m \\cdot (w \\log \\mathfrak {f} + 2 t + 2),</span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta^ {\\prime} = \\boxed {\\frac {p}{4} \\cdot w \\cdot \\gamma_ {\\mathcal {R}} \\cdot \\sqrt {\\hat {\\mathfrak {f}} \\varphi} \\cdot \\sqrt {m r \\cdot n ^ {\\mathrm {b l k}}}} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {2}} \\left(\\operatorname {r e s p} _ {\\cdot}, \\boxed {\\frac {p}{4} \\left(2 \\cdot \\sqrt {\\hat {\\mathfrak {f}} \\varphi} + w \\cdot \\gamma_ {\\mathcal {R}}\\right)} _ {\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\cdot) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_ {\\infty}}\\right),</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block">n ^ {\\text {o u t} ^ {\\prime}} = n ^ {\\text {o u t}} + t m + 1,</span></div>

    <div class="my-4 text-center"><span class="math-block">p / 2 &amp;gt; \\beta^ {2} \\cdot m \\cdot r \\cdot \\varphi .</span></div>

    <p class="text-gray-300">Proof. Completeness. For perfect completeness, we consider the statement  <span class="math">((\\mathbf{H},\\mathbf{F},\\mathbf{Y}),\\mathbf{W})\\in \\Xi_{m,\\beta}^{\\mathrm{lin}}\\cap \\Xi_{m,r}^{\\mathrm{bin}}</span>  Let  <span class="math">\\mathbf{W} = (\\mathbf{w}_i)_{i\\in [r]}</span>  . Clearly, we have  <span class="math">\\psi (\\mathbf{w}_i)\\in \\{0,1\\} ^{m\\varphi}</span>  . Therefore,</p>

    <div class="my-4 text-center"><span class="math-block">\\langle \\psi (\\mathbf {w} _ {i}), \\mathbf {1} ^ {m \\varphi} \\rangle_ {\\mathbb {Z}} = \\langle \\psi (\\mathbf {w} _ {i}), \\psi (\\mathbf {w} _ {i}) \\rangle_ {\\mathbb {Z}} \\forall i \\in [ r ]</span></div>

    <p class="text-gray-300">by Proposition 2 (and the discussion immediately after). Since  <span class="math">\\mathsf{CRT}_p</span>  is a  <span class="math">\\tau_p</span> -embedding over  <span class="math">\\mathcal{R}</span>  and  <span class="math">\\widehat{\\mathbf{w}}_t = \\mathbf{w}</span>  due to the construction it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {p} \\left(\\sum_ {i \\in [ r ]} \\hat {y} _ {i}\\right) = \\left(\\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\mathbf {1} ^ {m \\varphi} \\rangle_ {\\mathbb {Z}}\\right) \\bmod p, \\text {a n d}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {p} (t _ {0}) = \\left(\\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\psi (\\mathbf {w} _ {i}) \\rangle_ {\\mathbb {Z}}\\right) \\bmod p,</span></div>

    <p class="text-gray-300">As a consequence,  <span class="math">\\tau_p(t_0) = \\tau_p\\left(\\sum_{i\\in [r]}\\hat{y}_i\\right)</span>  and the first check of the verifier passes.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Further, as $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf{W})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq 1<span class="math">, and by Corollary 1 </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{W})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\sqrt{\\mathfrak{f}\\varphi}\\sqrt{mr} = \\beta<span class="math">. We observe that </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{W})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2^2 = \\mathsf{Trace}(d)$ and hence the second verifier's check passes.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Next, we show that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\iota_ {\\mathrm {i p}}, \\iota_ {\\mathrm {i p - i n}}, \\iota_ {\\mathrm {a u t}}, \\iota_ {\\mathrm {a u t - i n}}, \\iota_ {\\mathrm {a u t - o u t}}, \\widetilde {\\mathbf {H}}, \\widetilde {\\mathbf {F}}, \\widetilde {\\mathbf {y}}, \\widetilde {\\mathbf {t}}\\right), \\widetilde {\\mathbf {w}}\\right) \\in \\Xi_ {m, \\mu , \\beta^ {\\prime}, n ^ {\\mathrm {a u t}}, n, n ^ {\\mathrm {b l k}}, n ^ {\\mathrm {i n}}, n ^ {\\mathrm {a u t}}} ^ {\\mathrm {a u t}}.</span></div>

    <p class="text-gray-300">The linear part of the relation <span class="math">\\Xi^{\\mathrm{aut}}</span> above holds due to Item (viii) of the CRTmake subroutine. Similarly, the correctness of all steps of the CRT transformation implies that all automorphism relations hold. For the inner-product type of relation, they are correct due to the honest computation of <span class="math">t_0</span> and <span class="math">t_1</span>.</p>

    <p class="text-gray-300">Finally, it remains to argue about the correctness of the bound <span class="math">\\beta&#x27;</span> for the new witness. Observe that the witness <span class="math">\\widehat{\\mathbf{W}}</span> is a concatenation of three types of blocks. Particularly:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the steps of the CRT transformation, <span class="math">\\widehat{\\mathbf{W}}_i</span>,</li>

      <li>the remainders, <span class="math">\\mathbf{R}_i</span>,</li>

      <li>and <span class="math">\\mathbf{W}_{i,j}</span> used for automorphisms-based relations.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For canonical 2-norm, due to reduction modulo <span class="math">p</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\left((\\widehat{\\mathbf{W}}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq p / 2<span class="math"> . After translating the norm, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left((\\widehat{\\mathbf{W}}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq p / 2\\cdot \\sqrt{\\mathfrak{f}\\varphi}\\cdot \\sqrt{mr\\cdot(1 + t)}<span class="math"> with the canonical 2-norm of an individual element bounded by </span>p / 2\\cdot \\sqrt{\\mathfrak{f}\\varphi}<span class="math"> . Thereby, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left((\\mathbf{W}_{i,j})_{(i,j)\\in [t,h_j]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq p / 2\\cdot \\sqrt{\\mathfrak{f}\\varphi}\\cdot \\sqrt{mr\\cdot(1 + t)\\cdot w}<span class="math"> as the automorphisms do not impact the canonical norm of a ring element. However, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\left((\\mathbf{R}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq (\\frac{p}{2}\\cdot \\frac{p}{2}\\cdot w\\cdot \\gamma_{\\mathcal{R}}) / p = \\frac{p}{4}\\cdot w\\cdot \\gamma_{\\mathcal{R}} = \\widehat{p}<span class="math"> . After translating norms, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma \\left((\\mathbf{R}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\widehat{p}\\cdot \\sqrt{\\mathfrak{f}\\varphi}\\cdot \\sqrt{mr\\cdot(1 + t)}<span class="math"> . To sum up, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\widehat{\\mathbf{W}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2\\leq \\frac{p}{4}\\cdot w\\cdot \\gamma_{\\mathcal{R}}\\cdot \\sqrt{\\mathfrak{f}\\varphi}\\cdot \\sqrt{mr\\cdot n^{\\mathrm{blk}}}$ , which concludes the proof of the perfect correctness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For coefficient <span class="math">\\infty</span>-norm, due to reduction modulo <span class="math">p</span>, $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\left((\\widehat{\\mathbf{W}}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq p / 2<span class="math"> . After translating the norm the canonical 2-norm of an individual element bounded by </span>p / 2\\cdot \\sqrt{\\mathfrak{f}\\varphi}<span class="math"> . Thereby, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\left((\\mathbf{W}_{i,j})_{(i,j)\\in [t,h_j]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq p / 2\\cdot \\sqrt{\\mathfrak{f}\\varphi}<span class="math"> as the automorphisms do not impact the canonical norm of a ring element. However, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi \\left((\\mathbf{R}_i)_{i\\in [t + 1]}\\right)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq (\\frac{p}{2}\\cdot \\frac{p}{2}\\cdot w\\cdot \\gamma_{\\mathcal{R}}) / p = \\frac{p}{4}\\cdot w\\cdot \\gamma_{\\mathcal{R}}<span class="math"> . To sum up, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\widetilde{\\mathbf{W}})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq \\frac{p}{2}\\cdot \\sqrt{\\mathfrak{f}\\varphi} +\\frac{p}{4}\\cdot w\\cdot \\gamma_{\\mathcal{R}}\\leq \\frac{p}{4}\\left(2\\cdot \\sqrt{\\mathfrak{f}\\varphi} +w\\cdot \\gamma_{\\mathcal{R}}\\right)$ , which concludes the proof of the perfect correctness.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Soundness. For perfect knowledge soundness, suppose that</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\left(\\iota_ {\\mathrm {i p}}, \\iota_ {\\mathrm {i p - i n}}, \\iota_ {\\mathrm {a u t}}, \\iota_ {\\mathrm {a u t - i n}}, \\iota_ {\\mathrm {a u t - o u t}}, \\widetilde {\\mathbf {H}}, \\widetilde {\\mathbf {F}}, \\widetilde {\\mathbf {Y}}, \\widetilde {\\mathbf {t}}\\right), \\widetilde {\\mathbf {W}}\\right) \\in \\Xi_ {m, \\mu , \\beta^ {\\prime}, n ^ {\\mathrm {a u t}}, n, n ^ {\\mathrm {b l k}}, n ^ {\\mathrm {i n}}, n ^ {\\mathrm {a u t}}} ^ {\\mathrm {a u t}},</span></div>

    <p class="text-gray-300">meaning that <span class="math">\\left(\\iota_{\\mathrm{ip}},\\iota_{\\mathrm{ip - in}},\\iota_{\\mathrm{aut}},\\iota_{\\mathrm{aut - in}},\\iota_{\\mathrm{aut - out}},\\widetilde{\\mathbf{H}},\\widetilde{\\mathbf{F}},\\widetilde{\\mathbf{Y}},\\widetilde{\\mathbf{t}}\\right)</span> takes the form as constructed in CRTmake. We have</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {p} \\left(\\sum_ {i \\in [ r ]} \\hat {y} _ {i}\\right) = \\left(\\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\mathbf {1} ^ {m \\varphi} \\rangle_ {\\mathbb {Z}}\\right) \\bmod p, \\text { and}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {p} (t _ {0}) = \\left(\\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\psi (\\mathbf {w} _ {i}) \\rangle_ {\\mathbb {Z}}\\right) \\bmod p,</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{W} = (\\mathbf{w}_i)_{i\\in [r]}</span>. Since <span class="math">\\tau_p\\left(\\sum_{i\\in [r]}\\hat{y}_i\\right) = \\tau_p(t_0)</span>, we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {i \\in [ r ]} \\langle \\psi (\\mathbf {w} _ {i}), \\psi (\\mathbf {w} _ {i}) - \\mathbf {1} ^ {m \\varphi} \\rangle_ {\\mathbb {Z}} = 0 \\bmod p.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Furthermore, <span class="math">\\mathsf{Trace}(t_1) \\leq \\beta^2</span> implies that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\beta<span class="math"> , thus by Corollary 1 </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq \\beta<span class="math"> . Therefore, as </span>\\beta^2 \\cdot m \\cdot r \\cdot \\varphi &lt; p/2<span class="math"> , the inner product above holds without modulo </span>p<span class="math"> and thus </span>\\psi (\\mathbf{W}) \\in \\{0,1\\}^{m\\varphi r}<span class="math"> . Hence, </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\sigma (\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_2 \\leq \\sqrt{\\mathfrak{f}\\varphi} \\sqrt{mr}<span class="math"> and </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi (\\mathbf{W}) \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\leq 1$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">47</p>

    <p class="text-gray-300">Remark 9.</p>

    <p class="text-gray-300">Lemma 12 trivially generalises to yield a reduction of knowledge from <span class="math">\\mathcal{Z}^{\\mathsf{ip}}\\cap\\mathcal{Z}^{\\mathsf{bin}}</span> to <span class="math">\\mathcal{Z}^{\\mathsf{aut}}</span>, analogous to Theorem 8. We omit the details for succinctness.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Remark 10.</h6>

    <p class="text-gray-300">Note that the reduction of knowledge <span class="math">\\Pi^{\\mathsf{lin}\\text{-}\\mathsf{bin}}_{\\mathsf{crt},p}</span> increases the number of linear relations from <span class="math">n</span> to <span class="math">n+tm+1</span>, where we recall that <span class="math">m</span> is the dimension for each block of the witness. Nevertheless, we observe that the matrices <span class="math">\\widetilde{\\mathbf{H}}</span> and <span class="math">\\widetilde{\\mathbf{F}}</span> in the statement are sparse and highly structured. Therefore, when applying the chain of reductions in Section 5, the verifier time can still be polylogarithmic in <span class="math">m</span> as long as succinct representations of <span class="math">\\widetilde{\\mathbf{H}}</span> and <span class="math">\\widetilde{\\mathbf{F}}</span> are used when running <span class="math">\\Pi^{\\mathsf{batch}}</span> for batching.</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Remark 11.</h6>

    <p class="text-gray-300">The CRT-based embedding method discussed in this section requires the prime <span class="math">p</span> to split completely, i.e. <span class="math">p=1\\bmod{\\mathfrak{f}}</span>, which immediately implies that <span class="math">\\mathfrak{f}</span> must be even. When <span class="math">\\mathfrak{f}=2^{k}</span>, we observe that choices of <span class="math">p</span> are limited, and they tend to be significantly larger than <span class="math">\\mathfrak{f}</span> – the smallest values of <span class="math">p</span> for <span class="math">\\mathfrak{f}\\in(256,512,1024)</span> are <span class="math">p\\in(267,7681,12289)</span>. For general <span class="math">\\mathfrak{f}</span>, choices appear to be more flexible – the smallest values of <span class="math">p</span> for <span class="math">\\mathfrak{f}\\in(598,1102,2926)</span> are <span class="math">p\\in(599,1103,2927)</span>.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Remark 12.</h6>

    <p class="text-gray-300">We discuss a possible optimisation which allows to pick smaller primes <span class="math">p</span>. Recall that, for knowledge soundness, we required <span class="math">p/2&gt;\\beta^{2}\\cdot m\\cdot r\\cdot\\varphi</span>, which makes <span class="math">p</span> linear in the length of the witness length. Towards picking smaller primes <span class="math">p</span>, we suggest using multiple primes <span class="math">p_{1},p_{2},\\ldots</span> such that all of which fully split over <span class="math">\\mathcal{R}</span>. To be concrete, consider the case with two primes, i.e. <span class="math">p_{1}</span> and <span class="math">p_{2}</span>. After repeating the protocol twice for <span class="math">p_{1}</span> and <span class="math">p_{2}</span> respectively (or even better, running a merged version of the protocol), the verifier should be convinced that:</p>

    <p class="text-gray-300">\\[ \\left.\\begin{array}[]{l}\\left\\langle\\mathbf{x},\\mathbf{y}\\right\\rangle=c\\bmod p_{1}\\\\ \\left\\langle\\mathbf{x},\\mathbf{y}\\right\\rangle=c\\bmod p_{2}\\\\ (p_{1},p_{2})=1\\end{array}\\right\\}\\implies\\left\\langle\\mathbf{x},\\mathbf{y}\\right\\rangle=c\\bmod p_{1}\\cdot p_{2}. \\]</p>

    <p class="text-gray-300">Obviously, this generalises to having a set <span class="math">P</span> of arbitrarily many primes. Consequently, for knowledge soundness, we would only require <span class="math">\\prod_{p\\in P}p/2&gt;\\beta^{2}\\cdot m\\cdot r\\cdot\\varphi</span>. If the conductor <span class="math">\\mathfrak{f}</span> is smooth, it is possible to find many highly favourable primes (cf. Remark 11).</p>

    <h2 id="sec-73" class="text-2xl font-bold">9 Parameters Selection</h2>

    <p class="text-gray-300">We propose concrete instantiations of our protocols for various values of <span class="math">m</span> and initial norm. For comparison with prior works, e.g. <em>[x1, x2]</em>, we aim for 128-bit security and knowledge error <span class="math">\\kappa=2^{-80}</span>. This corresponds to the root Hermite factor <span class="math">\\delta_{\\mathsf{rbf}}\\approx 1.0044</span> (cf. Section 6.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We instantiate protocol as described in Section 6 combining atomic RoKs. We focus on the following simple goal: commit to a short vector <span class="math">\\psi(\\mathbf{W})\\in\\mathbb{Z}_{q}^{h}</span>, such that $\\left\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\psi\\left(\\mathbf{W}\\right)\\right\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\leq\\beta<span class="math"> and prove knowledge of the commitment opening. To this end, we will pack </span>h=m\\cdot\\varphi\\cdot r<span class="math"> integers into a matrix </span>\\mathbf{W}\\in\\mathcal{R}_{q}^{m\\times r}<span class="math"> of </span>m\\cdot r<span class="math"> ring elements employing standard coefficient embedding. Then, we will use the vSIS commitment scheme on </span>\\mathbf{W}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The relation of our interest is a proof of vSIS commitment opening <em>[x3]</em>, i.e. the polynomial evaluation equation <span class="math">\\mathbf{w}(v)=y\\pmod{q}</span> for public ring elements <span class="math">v,y\\in\\mathcal{R}_{q}</span>, where <span class="math">\\mathbf{w}</span> represents a column of <span class="math">\\mathbf{W}</span>. When adapting this relation to the language of <span class="math">\\mathcal{Z}^{\\mathsf{ip}}</span>, we would initially set <span class="math">(\\overline{n},n^{\\mathsf{out}})=(\\overline{n}_{0},\\overline{n}_{0})</span>, where <span class="math">\\overline{n}_{0}</span> is defined so that (module-)vSIS is hard (we adapt reasoning from Section 6 ). Throughout the batching protocols, we set <span class="math">\\underline{n}=1</span>.</p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Concrete parameters.</h4>

    <p class="text-gray-300">In Table 3 we suggest concrete parameters with the estimated proof size. The results are obtained via a dedicated script simulating protocol execution and measuring the communication cost.</p>

    <p class="text-gray-300">The script also includes the details of the composition and fine-grained parameters selection. From the high-level perspective, the most optimal composition for each selection is described as</p>

    <p class="text-gray-300"><span class="math">\\left((\\Pi^{\\mathsf{f}\\text{-}\\mathsf{decomp}}\\rightarrow)\\Pi^{\\mathsf{norm}}\\rightarrow\\Pi^{\\mathsf{batch}}\\rightarrow\\Pi^{\\mathsf{split}}\\rightarrow\\Pi^{\\mathsf{fold}}\\right)_{i\\in[\\mu]}\\rightarrow\\Pi^{\\mathsf{finish}},</span></p>

    <p class="text-gray-300">where <span class="math">\\Pi^{\\mathsf{f}\\text{-}\\mathsf{decomp}}</span> is performed in (roughly) <span class="math">2/3</span> of rounds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">witness length in Z-elements</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈230</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈230</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">≈232</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">log q</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

            <td class="px-3 py-2 border-b border-gray-700">64</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">β</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1023</td>

            <td class="px-3 py-2 border-b border-gray-700">1023</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">βds</td>

            <td class="px-3 py-2 border-b border-gray-700">35.6</td>

            <td class="px-3 py-2 border-b border-gray-700">38.8</td>

            <td class="px-3 py-2 border-b border-gray-700">39.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">f</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">m</td>

            <td class="px-3 py-2 border-b border-gray-700">≈221.4</td>

            <td class="px-3 py-2 border-b border-gray-700">≈221.4</td>

            <td class="px-3 py-2 border-b border-gray-700">≈223.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">r</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">μ</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">9</td>

            <td class="px-3 py-2 border-b border-gray-700">11</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">rounds with Πb-decomp</td>

            <td class="px-3 py-2 border-b border-gray-700">{2,3,4,5,7}</td>

            <td class="px-3 py-2 border-b border-gray-700">{1,2,4,5,7,8}</td>

            <td class="px-3 py-2 border-b border-gray-700">{1,2,4,5,7,9,11}</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">n0</td>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">witness size</td>

            <td class="px-3 py-2 border-b border-gray-700">128 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">1280 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">5120 MB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">proof size</td>

            <td class="px-3 py-2 border-b border-gray-700">5.3 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">5.7 MB</td>

            <td class="px-3 py-2 border-b border-gray-700">7.1 MB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3. Concrete parameters, together with proof sizes, for security level  <span class="math">\\lambda  = {128}</span>  and  <span class="math">\\kappa  = 2{}^{-{80}}</span>  .</p>

    <p class="text-gray-300">Proof Composition. To further shrink communication, one could use standard proof composition, where instead of the verifier checking the verification conditions, the prover provides proof of knowledge of the input for which the verification holds. To this end, we can directly apply the LaBRADOR proof system [BS23]. Note that this approach is different from running [BS23] for the original relation because now the statement/witness size for LaBRADOR is only of size  <span class="math">\\mathsf{poly}(\\lambda ,\\log m)</span> , and thus we do maintain succinct verification. Hence, we estimate the final communication size to be  <span class="math">\\approx 100\\mathrm{KB}</span>  based on performance described in [BS23].</p>

    <p class="text-gray-300">Fiat-Shamir Transformation. As noted in [AFK22], transforming interactive proofs, which admit parallel repetition, to the non-interactive setting via Fiat-Shamir transformation can incur a significant loss in the order of  <span class="math">Q^{\\mu}</span> , where  <span class="math">Q</span>  is the number of random oracle queries made by an adversary. Following [CMNW24], we designed our protocols with the "bundling approach" for parallel repetition, i.e., we don't treat the parallel repetitions (the columns of  <span class="math">\\mathbf{Y}</span>  and  <span class="math">\\mathbf{W}</span> ) separately, but mix them together. In particular,  <span class="math">\\Pi^{\\mathrm{fold}}</span>  randomly combines the parallel threads and is  <span class="math">(r_{\\mathrm{in}} + 1)</span> -special sound (Table 1), where  <span class="math">r_{\\mathrm{in}} \\in \\mathcal{O}(d\\lambda) = \\mathcal{O}(\\lambda)</span>  if  <span class="math">d = \\mathcal{O}(1)</span> . The other protocols either require a single transcript or require two (suitable) transcripts, which behave like 2-special soundness. Hence, we can heuristically assume that the tree-special soundness extractors from [AFK22] are applicable to our protocols. Overall every round is  <span class="math">\\mathcal{O}(\\lambda)</span> -special sound, and thus extracting from  <span class="math">\\mu \\leq \\log(m) \\in \\mathcal{O}(\\log(\\lambda))</span>  rounds requires a tree of  <span class="math">\\mathcal{O}(\\lambda)^{\\mathcal{O}(\\log(\\lambda))}</span>  transcripts. Hence, heuristically, there is an extractor for the Fiat-Shamir-compiled protocol whose running time is in the order of  <span class="math">Q \\cdot \\mathcal{O}(\\lambda)^{\\mathcal{O}(\\log(\\lambda))}</span> , where  <span class="math">Q</span>  denotes the number of random oracle queries.</p>

    <p class="text-gray-300">The work of R.L. and M.O. was supported by the Research Council of Finland project No. 358951. This work was supported by the Helsinki Institute for Information Technology (HIIT) and conducted while M.K. was affiliated with Aalto University. N.K.N. was supported by the Protocol Labs RFP-013: Cryptonet network grant.</p>

    <p class="text-gray-300"><span class="math">\\mathrm{ACL}^{+}22</span>  Martin R. Albrecht, Valerio Cini, Russell W. F. Lai, Giulio Malavolta, and Sri Aravinda Krishnan Thyagarajan. Lattice-based SNARKs: Publicly verifiable, preprocessing, and recursively composable - (extended abstract). In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part II, volume 13508 of LNCS, pages 102-132. Springer, Cham, August 2022. 1, 52 AFK22. Thomas Attema, Serge Fehr, and Michael Kloos. Fiat-shamir transformation of multi-round interactive proofs. In Eike Kiltz and Vinod Vaikuntanathan, editors, TCC 2022, Part I, volume 13747 of LNCS, pages 113-142. Springer, Cham, November 2022. 49 AFLN24. Martin R. Albrecht, Giacomo Fenzi, Oleksandra Lapiha, and Ngoc Khanh Nguyen. SLAP: Succinct lattice-based polynomial commitments from standard assumptions. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part VII, volume 14657 of LNCS, pages 90-119. Springer, Cham, May 2024. 1, 2, 4, 48</p>

    <p class="text-gray-300">AL21. Martin R. Albrecht and Russell W. F. Lai. Subtractive sets over cyclotomic rings - limits of Schnorr-like arguments over lattices. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part II, volume 12826 of LNCS, pages 519–548, Virtual Event, August 2021. Springer, Cham. 2, 5, 12, 13, 14</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BC24] Dan Boneh and Binyi Chen. Latticefold: A lattice-based folding scheme and its applications to succinct proof systems. Cryptology ePrint Archive, Paper 2024/257, 2024. https://eprint.iacr.org/2024/257.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. Interactive oracle proofs. In Martin Hirt and Adam D. Smith, editors, TCC 2016-B, Part II, volume 9986 of LNCS, pages 31–60. Springer, Berlin, Heidelberg, October / November 2016.</li>

      <li>[BCS23] Jonathan Bootle, Alessandro Chiesa, and Katerina Sotiraki. Lattice-based succinct arguments for NP with polylogarithmic-time verification. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 227–251. Springer, Cham, August 2023.</li>

      <li>[BDGL16] Anja Becker, Léo Ducas, Nicolas Gama, and Thijs Laarhoven. New directions in nearest neighbor searching with applications to lattice sieving. In Robert Krauthgamer, editor, 27th SODA, pages 10–24. ACM-SIAM, January 2016.</li>

      <li>[BFOV04] E. Bayer-Fluckiger, F. Oggier, and E. Viterbo. New algebraic constructions of rotated z/sup n/-lattice constellations for the rayleigh fading channel. IEEE Transactions on Information Theory, 50(4):702–714, 2004.</li>

      <li>[BL17] Carsten Baum and Vadim Lyubashevsky. Simple amortized proofs of shortness for linear relations over polynomial rings. Cryptology ePrint Archive, Report 2017/759, 2017.</li>

      <li>[BLNS20] Jonathan Bootle, Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. A non-PCP approach to succinct quantum-safe zero-knowledge. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part II, volume 12171 of LNCS, pages 441–469. Springer, Cham, August 2020.</li>

      <li>[BS23] Ward Beullens and Gregor Seiler. LaBRADOR: Compact proofs for R1CS from module-SIS. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part V, volume 14085 of LNCS, pages 518–548. Springer, Cham, August 2023.</li>

      <li>[CLM23] Valerio Cini, Russell W. F. Lai, and Giulio Malavolta. Lattice-based succinct arguments from vanishing polynomials - (extended abstract). In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 72–105. Springer, Cham, August 2023.</li>

      <li>[CMNW24] Valerio Cini, Giulio Malavolta, Ngoc Khanh Nguyen, and Hoeteck Wee. Polynomial commitments from lattices: Post-quantum security, fast verification and transparent setup. In Leonid Reyzin and Douglas Stebila, editors, CRYPTO 2024, Part X, volume 14929 of LNCS, pages 207–242. Springer, Cham, August 2024.</li>

      <li>[DFS24] Thomas Debris-Alazard, Pouria Fallahpour, and Damien Stehlé. Quantum oblivious LWE sampling and insecurity of standard model lattice-based SNARKs. In Bojan Mohar, Igor Shinkar, and Ryan O’Donnell, editors, 56th ACM STOC, pages 423–434. ACM Press, June 2024.</li>

      <li>[DKL^{+}18] Léo Ducas, Eike Kiltz, Tancrède Lepoint, Vadim Lyubashevsky, Peter Schwabe, Gregor Seiler, and Damien Stehlé. Crystals-dilithium: A lattice-based digital signature scheme. IACR Transactions on Cryptographic Hardware and Embedded Systems, 2018(1):238–268, Feb. 2018.</li>

      <li>[DPSZ12] Ivan Damgård, Valerio Pastro, Nigel P. Smart, and Sarah Zakarias. Multiparty computation from somewhat homomorphic encryption. In Reihaneh Safavi-Naini and Ran Canetti, editors, CRYPTO 2012, volume 7417 of LNCS, pages 643–662. Springer, Berlin, Heidelberg, August 2012.</li>

      <li>[EKS^{+}21] Muhammed F. Esgin, Veronika Kuchta, Amin Sakzad, Ron Steinfeld, Zhenfei Zhang, Shifeng Sun, and Shumo Chu. Practical post-quantum few-time verifiable random function with applications to algorand. In Nikita Borisov and Claudia Díaz, editors, FC 2021, Part II, volume 12675 of LNCS, pages 560–578. Springer, Berlin, Heidelberg, March 2021.</li>

      <li>[FMN23] Giacomo Fenzi, Hossein Moghaddas, and Ngoc Khanh Nguyen. Lattice-based polynomial commitments: Towards asymptotic and concrete efficiency. Cryptology ePrint Archive, Paper 2023/846, 2023. https://eprint.iacr.org/2023/846.</li>

      <li>[GHL22] Craig Gentry, Shai Halevi, and Vadim Lyubashevsky. Practical non-interactive publicly verifiable secret sharing with thousands of parties. In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part I, volume 13275 of LNCS, pages 458–487. Springer, Cham, May / June 2022.</li>

      <li>[HKR19] Max Hoffmann, Michael Klooß, and Andy Rupp. Efficient zero-knowledge arguments in the discrete log setting, revisited. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2093–2110. ACM Press, November 2019.</li>

      <li>[KP23] Abhiram Kothapalli and Bryan Parno. Algebraic reductions of knowledge. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part IV, volume 14084 of LNCS, pages 669–701. Springer, Cham, August 2023.</li>

      <li>[Len76] H. W. Lenstra. Euclidean number fields of large degree. Inventiones mathematicae, 38(3):237–254, 1976.</li>

    </ul>

    <p class="text-gray-300">LM23. Russell W. F. Lai and Giulio Malavolta. Lattice-based timed cryptography. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part V, volume 14085 of LNCS, pages 782–804. Springer, Cham, August 2023.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LN17] Vadim Lyubashevsky and Gregory Neven. One-shot verifiable encryption from lattices. In Jean-Sébastien Coron and Jesper Buus Nielsen, editors, EUROCRYPT 2017, Part I, volume 10210 of LNCS, pages 293–323. Springer, Cham, April / May 2017.</li>

      <li>[LNP22] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Maxime Plançon. Lattice-based zero-knowledge proofs and applications: Shorter, simpler, and more general. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part II, volume 13508 of LNCS, pages 71–101. Springer, Cham, August 2022.</li>

      <li>[LNS20] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. Practical lattice-based zero-knowledge proofs for integer relations. In Jay Ligatti, Xinming Ou, Jonathan Katz, and Giovanni Vigna, editors, ACM CCS 2020, pages 1051–1070. ACM Press, November 2020.</li>

      <li>[LNS21] Vadim Lyubashevsky, Ngoc Khanh Nguyen, and Gregor Seiler. Shorter lattice-based zero-knowledge proofs via one-time commitments. In Juan Garay, editor, PKC 2021, Part I, volume 12710 of LNCS, pages 215–241. Springer, Cham, May 2021.</li>

      <li>[LPR13] Vadim Lyubashevsky, Chris Peikert, and Oded Regev. A toolkit for ring-LWE cryptography. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 35–54. Springer, Berlin, Heidelberg, May 2013.</li>

      <li>[Lyu12] Vadim Lyubashevsky. Lattice signatures without trapdoors. In David Pointcheval and Thomas Johansson, editors, EUROCRYPT 2012, volume 7237 of LNCS, pages 738–755. Springer, Berlin, Heidelberg, April 2012.</li>

      <li>[MR09] Daniele Micciancio and Oded Regev. Lattice-based Cryptography, pages 147–191. Springer Berlin Heidelberg, Berlin, Heidelberg, 2009.</li>

      <li>[PSTY13] Charalampos Papamanthou, Elaine Shi, Roberto Tamassia, and Ke Yi. Streaming authenticated data structures. In Thomas Johansson and Phong Q. Nguyen, editors, EUROCRYPT 2013, volume 7881 of LNCS, pages 353–370. Springer, Berlin, Heidelberg, May 2013.</li>

      <li>[Was97] Lawrence C. Washington. Introduction to cyclotomic fields, volume 83. Springer, 1997.</li>

      <li>[WW23] Hoeteck Wee and David J. Wu. Lattice-based functional commitments: Fast verification and cryptanalysis. In Jian Guo and Ron Steinfeld, editors, ASIACRYPT 2023, Part V, volume 14442 of LNCS, pages 201–235. Springer, Singapore, December 2023.</li>

    </ul>

    <h2 id="sec-77" class="text-2xl font-bold">Appendix A Extended Preliminaries</h2>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">A.1 Algebraic Number Theory</h3>

    <h6 id="sec-79" class="text-base font-medium mt-4">Lemma 13.</h6>

    <p class="text-gray-300">If <span class="math">L/K</span> is a Galois extension, then any <span class="math">K</span>-linear map <span class="math">f:L\\to L</span> can be expressed as an <span class="math">L</span>-linear combination of <span class="math">\\mathsf{Gal}(L/K)</span>.</p>

    <h6 id="sec-80" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">L/K</span> be of degree <span class="math">\\varphi</span>. Let <span class="math">\\mathbf{e}=(e_{i})_{i\\in[\\varphi]}</span> be a <span class="math">\\mathcal{O}_{K}</span>-basis of <span class="math">\\mathcal{O}_{L}</span>, and <span class="math">\\mathbf{e}^{\\vee}=(e^{\\vee}_{i})_{i\\in[\\varphi]}</span> be a <span class="math">\\mathcal{O}_{K}</span>-basis of <span class="math">\\mathcal{O}_{L}^{\\vee}</span>. We show that there exists a vector <span class="math">\\mathbf{a}=(a_{\\tau})_{\\tau\\in\\mathsf{Gal}(L/K)}\\in(\\mathcal{O}_{L}^{\\vee})^{\\varphi}</span> such that, for any <span class="math">x\\in L</span>, we can write</p>

    <p class="text-gray-300"><span class="math">f(x)=\\sum_{\\tau\\in\\mathsf{Gal}(L/K)}a_{\\tau}\\cdot\\tau(x).</span></p>

    <p class="text-gray-300">To construct <span class="math">\\mathbf{a}</span>, we first construct another vector <span class="math">\\mathbf{b}=(b_{i})_{i\\in\\varphi}\\in L^{\\varphi}</span> by setting <span class="math">b_{i}\\coloneqq f(e_{i})</span> for all <span class="math">i\\in[\\varphi]</span>. We then define <span class="math">a_{\\tau}\\coloneqq\\mathbf{b}^{\\intercal}\\cdot\\tau(\\mathbf{e}^{\\vee})</span> for all <span class="math">\\tau\\in\\mathsf{Gal}(L/K)</span>, where the automorphism <span class="math">\\tau</span> is applied component-wise. For any <span class="math">x=\\sum_{i\\in[\\varphi]}x_{i}e_{i}\\in L</span> where <span class="math">x_{i}\\in K</span>, we observe that</p>

    <p class="text-gray-300"><span class="math">\\sum_{\\tau\\in\\mathsf{Gal}(L/K)}a_{\\tau}\\cdot\\tau(x)</span> <span class="math">=\\sum_{\\tau\\in\\mathsf{Gal}(L/K)}\\mathbf{b}^{\\intercal}\\tau(\\mathbf{e}^{\\vee})\\cdot\\tau(x)</span> <span class="math">=\\sum_{\\tau\\in\\mathsf{Gal}(L/K)}\\sum_{j\\in[\\varphi]}b_{j}\\tau(e^{\\vee}_{j})\\cdot\\tau(\\sum_{i\\in[\\varphi]}x_{i}e_{i})</span> <span class="math">=\\sum_{\\tau\\in\\mathsf{Gal}(L/K)}\\sum_{i,j\\in[\\varphi]}b_{j}\\tau(e^{\\vee}_{j}e_{i})x_{i}</span> <span class="math">=\\sum_{i,j\\in[\\varphi]}b_{j}\\mathsf{Trace}_{L/K}(e^{\\vee}_{j}e_{i})x_{i}</span> <span class="math">=\\sum_{i\\in[\\varphi]}b_{i}x_{i}=\\sum_{i\\in[\\varphi]}f(e_{i})x_{i}=f(x).\\qed</span></p>

    <p class="text-gray-300">######</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Lemma 14.</h6>

    <p class="text-gray-300">Let <span class="math">L</span> be a cyclotomic field, <span class="math">L/K</span> a Galois extension, <span class="math">\\mathfrak{f}_{L}</span> be the conductor of <span class="math">L</span>, and <span class="math">p</span> be a rational prime with <span class="math">\\mathfrak{f}_{L}&lt;p</span>. It holds that any <span class="math">\\mathcal{O}_{K}/p\\mathcal{O}_{K}</span>-linear map <span class="math">f:\\mathcal{O}_{L}/p\\mathcal{O}_{L}\\to\\mathcal{O}_{L}/p\\mathcal{O}_{L}</span> can be expressed as an <span class="math">\\mathcal{O}_{L}/p\\mathcal{O}_{L}</span>-linear combination of <span class="math">\\mathsf{Gal}(L/K)</span>.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In the proof of Lemma 13, we can see that any <span class="math">\\mathcal{O}_{K}</span>-linear map <span class="math">f:\\mathcal{O}_{L}\\to\\mathcal{O}_{L}</span> can be expressed as an <span class="math">\\mathcal{O}_{L}^{\\vee}</span>-linear combination of <span class="math">\\mathsf{Gal}(L/K)</span>. Since <span class="math">L</span> is cyclotomic, it is known (see e.g. <em>[x10]</em>) that</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}_{L}\\subseteq\\mathcal{O}_{L}^{\\vee}\\subseteq\\mathfrak{f}_{L}^{-1}\\mathcal{O}_{L}.</span></p>

    <p class="text-gray-300">Taking quotients, we have</p>

    <p class="text-gray-300"><span class="math">\\frac{\\mathcal{O}_{L}}{p\\mathcal{O}_{L}}\\subseteq\\frac{\\mathcal{O}_{L}^{\\vee}}{p\\mathcal{O}_{L}}\\subseteq\\frac{\\mathfrak{f}_{L}^{-1}\\mathcal{O}_{L}}{p\\mathcal{O}_{L}}.</span></p>

    <p class="text-gray-300">However, since <span class="math">\\mathfrak{f}_{L}&lt;p</span> and <span class="math">p</span> is prime, we have</p>

    <p class="text-gray-300"><span class="math">\\frac{\\mathcal{O}_{L}}{p\\mathcal{O}_{L}}\\subseteq\\frac{\\mathcal{O}_{L}^{\\vee}}{p\\mathcal{O}_{L}}\\subseteq\\frac{\\mathfrak{f}_{L}^{-1}\\mathcal{O}_{L}}{p\\mathcal{O}_{L}}=\\frac{\\mathcal{O}_{L}}{p\\mathcal{O}_{L}},</span></p>

    <p class="text-gray-300">forcing <span class="math">\\frac{\\mathcal{O}_{L}^{\\vee}}{p\\mathcal{O}_{L}}=\\frac{\\mathcal{O}_{L}}{p\\mathcal{O}_{L}}</span>. The claim thus follows. ∎</p>

    <h3 id="sec-83" class="text-xl font-semibold mt-8">A.2 Vanishing Short Integer Solution Assumption</h3>

    <p class="text-gray-300">To prove the soundness of some of the argument systems proposed in this work, we rely on the vanishing short integer solution (vSIS) assumption, proposed in <em>[x4]</em> as a structured variant of the standard SIS assumption, and can be seen as a variant of the kRISIS assumption <em>[ACL^{+}22]</em> without hints. To recall, the vSIS assumption is in fact a family of assumptions parametrised by a ring <span class="math">\\mathcal{R}</span>, a modulus <span class="math">q</span>, a number of points <span class="math">n</span>, a number of variables <span class="math">\\mu</span>, a norm bound <span class="math">\\beta</span> (for an implicit norm function), and a family <span class="math">\\mathcal{G}</span> of <span class="math">\\mu</span>-variate (possibly Laurent) polynomials over <span class="math">\\mathcal{R}</span>. It states that, given <span class="math">n</span> randomly sampled evaluation points <span class="math">\\mathbf{x}_{i}\\leftarrow\\ast(\\mathcal{R}_{q}^{\\times})^{\\mu}</span> for <span class="math">i\\in[n]</span>, it is infeasible to find a polynomial <span class="math">g\\in\\mathcal{G}</span> satisfying <span class="math">g(\\mathbf{x}_{i})=0\\bmod q</span> for all <span class="math">i\\in[n]</span> and whose coefficient vector has norm at most <span class="math">\\beta</span>.</p>

    <p class="text-gray-300">Currently, the best known approach to solve a vSIS problem is to solve it as an unstructured SIS problem, except for extreme cases, e.g. when <span class="math">g</span> is allowed to have a degree close to <span class="math">q</span>. We refer to <em>[x4]</em> for more discussion about the conjectured hardness of vSIS.</p>

    <p class="text-gray-300">Referring to the formulation of the vSIS assumption given in Definition 1, setting <span class="math">\\chi</span> to be the uniform distribution over <span class="math">\\mathcal{R}_{q}^{n\\times m}</span> recovers the standard SIS assumption. More interestingly, by instantiating the distribution <span class="math">\\chi</span> differently, we can recover various variants of the vSIS assumption stated in the style of <em>[x4]</em>. For example, setting <span class="math">\\chi</span> to the uniform distribution of vectors of the form <span class="math">\\bigotimes_{i\\in[\\mu]}(1,x_{i})</span> for <span class="math">x_{i}\\in\\mathcal{R}_{q}^{\\times}</span>, we recover the single-point multilinear variant. Another example is to set <span class="math">\\chi</span> to the uniform distribution of vectors of the form <span class="math">\\bigotimes_{i\\in[\\mu]}(1,x^{2^{i}})</span>, which corresponds to the single-point univariate variant.</p>

    <h3 id="sec-84" class="text-xl font-semibold mt-8">A.3 Reduction of Knowledge</h3>

    <p class="text-gray-300">In this paper we consider ternary relations <span class="math">\\Xi\\subseteq\\{0,1\\}^{<em>}\\times\\{0,1\\}^{</em>}\\times\\{0,1\\}^{<em>}</span>, where a tuple <span class="math">(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})\\in\\Xi</span> consists of public parameters <span class="math">\\mathsf{pp}</span>, statement <span class="math">\\mathsf{stmt}</span> and witness <span class="math">\\mathsf{wit}</span>. For presentation, we omit including <span class="math">\\mathsf{pp}</span> when it is known from the context. We consider a modified and simplified definition of a reduction of knowledge </em>[x11]<em> for the following reasons: All of our protocols are </em>public coin<em> and </em>(coordinate-wise) special sound<em> </em>[x6]<em> or similar. Thus, public reducibility is automatic and we have (super-constant) sequential composition results due to known (tree) black-box extractors, whereas composition in </em>[x11]<em> is limited a constant number of protocols. Lastly, we define a </em>relaxed<em> knowledge soundness notion which is not present in </em>[x11]*.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Remark 13.</h6>

    <p class="text-gray-300">To turn soundness errors of probabilistic tests (such as Schwartz–Zippel) into knowledge errors, we merely need two uniformly random accepting transcripts. These are produced by (CW)SS extractors for example. We call such extractors 2-transcript extractors. We note that the protocols themselves are <em>not</em> (CW)SS, as not <em>any</em> pair of transcripts (with distinct challenges) suffices for extraction.</p>

    <p class="text-gray-300">However, given two transcripts (where the challenges are uniformly distributed conditioned on accepting), we can nonetheless bound the knowledge error. This occurs when extracting a reduction of knowledge whose soundness relies on a Schwartz–Zippel-type argument. All common extractors for (CW)SS satisfy the required distribution of transcripts, hence we can use these extractors as 2-transcript extractors. Importantly, we can “pretend” to deal with (CW)SS in terms of extracting two transcripts. Thus, the tree-special soundness is still applicable and the running time is bounded in the tree size (for state of the art extractors). Our definition of knowledge error is simply additive for sequential compositions of extractors. Hence we can compose as many extractors as we need, and the resulting extractor is efficient if the extracted tree of transcripts is remains polynomial in size.</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 6 (Reduction of Knowledge (modified)).</h6>

    <p class="text-gray-300">Let <span class="math">\\Xi_{0}</span>, <span class="math">\\Xi_{1}</span> be ternary relations. A reduction of knowledge <span class="math">\\Pi</span> from <span class="math">\\Xi_{0}</span> to <span class="math">\\Xi_{1}</span>, short <span class="math">\\Pi\\colon\\Xi_{0}\\to\\Xi_{1}</span>, is defined by two PPT algorithms <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span>, the prover <span class="math">\\mathcal{P}</span> , and the verifier <span class="math">\\mathcal{V}</span>, with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}(\\mathsf{pp},\\mathsf{stmt}_{1},\\mathsf{wit}_{1})\\to(\\mathsf{stmt}_{2},\\mathsf{wit}_{2})</span>: Interactively reduce the input statement <span class="math">(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})\\in\\Xi_{0}</span> to a new statement <span class="math">(\\mathsf{pp},\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\in\\Xi_{1}</span> or <span class="math">\\bot</span>.</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pp},\\mathsf{stmt})\\to\\widetilde{\\mathsf{stmt}}</span>: Interactively reduce the task of checking the input statement <span class="math">(\\mathsf{pp},\\mathsf{stmt})</span> w.r.t <span class="math">\\Xi_{0}</span> to checking a new statement <span class="math">(\\mathsf{pp},\\widetilde{\\mathsf{stmt}})</span> w.r.t. <span class="math">\\Xi_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> denote the interaction between <span class="math">\\mathcal{P}</span> and <span class="math">\\mathcal{V}</span>, as a function that takes as input <span class="math">(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})</span> and runs the prover <span class="math">\\mathcal{P}</span> (resp. verifier <span class="math">\\mathcal{V}</span>) on input <span class="math">(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})</span> (resp. <span class="math">(\\mathsf{pp},\\mathsf{stmt})</span>). At the end of the interaction, <span class="math">\\langle\\mathcal{P},\\mathcal{V}\\rangle</span> outputs the verifier’s statement <span class="math">\\widetilde{\\mathsf{stmt}}</span> and prover’s witness <span class="math">\\widetilde{\\mathsf{wit}}</span>. We define following properties.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Definition 7 (Correctness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> be a reduction of knowledge from <span class="math">\\Xi_{0}</span> to <span class="math">\\Xi_{1}</span>. We say <span class="math">\\Pi</span> has correctness error <span class="math">\\gamma(\\,\\cdot\\,)</span>, if for all <span class="math">(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})\\in\\Xi_{0}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Pr}[(\\mathsf{pp},\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\in\\Xi_{1}\\mid(\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\leftarrow\\langle\\mathcal{P},\\mathcal{V}\\rangle(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})]\\geq 1-\\gamma(\\mathsf{pp},\\mathsf{stmt}).</span></p>

    <p class="text-gray-300">If <span class="math">\\gamma\\equiv 0</span>, we call <span class="math">\\Pi</span> perfectly correct.</p>

    <p class="text-gray-300">Our definitions of knowledge soundness and error are tailored to knowledge extractors for (coordinate-wise) special soundness (cf. Appendix A.4). Unlike <em>[x10]</em>, we require black-box extraction and ignore efficiency of the adversary.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Definition 8 ((Black-Box) Knowledge Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> be a reduction of knowledge. We say that <span class="math">\\Pi</span> is relaxed knowledge sound from <span class="math">\\Xi_{0}^{\\mathsf{KS}}</span> to <span class="math">\\Xi_{1}^{\\mathsf{KS}}</span> with knowledge error <span class="math">\\kappa(\\mathsf{pp},\\mathsf{stmt})</span> if there exists a black-box expected polynomial-time extractor <span class="math">\\mathcal{E}</span> such that: For all <span class="math">\\mathsf{pp},\\mathsf{stmt}</span>, and every (unbounded) malicious prover <span class="math">\\mathcal{P}^{*}</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Pr}[(\\mathsf{pp},\\mathsf{stmt},\\mathsf{wit})\\in\\Xi_{1}^{\\mathsf{KS}}\\mid\\mathsf{wit}\\leftarrow\\mathcal{E}^{\\mathcal{P}^{<em>}}(\\mathsf{pp},\\mathsf{stmt})]</span> <span class="math">\\geq</span> <span class="math">\\mathsf{Pr}[(\\mathsf{pp},\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\in\\Xi_{0}^{\\mathsf{KS}}\\mid(\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\leftarrow\\langle\\mathcal{P}^{</em>},\\mathcal{V}\\rangle(\\mathsf{pp},\\mathsf{stmt})]-\\kappa(\\mathsf{pp},\\mathsf{stmt}).</span></p>

    <p class="text-gray-300">If <span class="math">\\Pi</span> is both correct and relaxed knowledge sound from <span class="math">\\Xi_{0}^{\\mathsf{KS}}</span> to <span class="math">\\Xi_{1}^{\\mathsf{KS}}</span>, then we say that <span class="math">\\Pi</span> is knowledge sound from <span class="math">\\Xi_{0}^{\\mathsf{KS}}</span> to <span class="math">\\Xi_{1}^{\\mathsf{KS}}</span>.</p>

    <p class="text-gray-300">We assert no composition theorem. Instead we appeal to the fact that all of our protocols are (coordinate-wise) special sound, so we eventually require are tree-CWSS extractor. These are known to exist, even for the Fiat–Shamir transformed protocol, see e.g. <em>[x9]</em>. Formally, we must translate reductions of knowledge to proofs of knowledge to apply special soundness. But this is a triviality:</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Definition 9.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(\\mathcal{P},\\mathcal{V})</span> be a reduction of knowledge from <span class="math">\\Xi_{0}</span> to <span class="math">\\Xi_{1}</span>. We define the induced proof of knowledge <span class="math">\\widehat{\\Pi}=(\\widehat{\\mathcal{P}},\\widehat{\\mathcal{V}})</span> of <span class="math">\\Pi</span>, where the prover <span class="math">\\widehat{\\mathcal{P}}</span> sends an additional (final) protocol message <span class="math">\\widetilde{\\mathsf{wit}}</span>, and the verifier outputs the bit <span class="math">(\\mathsf{pp},\\widetilde{\\mathsf{stmt}},\\widetilde{\\mathsf{wit}})\\in\\Xi_{1}</span>.</p>

    <p class="text-gray-300">By considering the induced proof of knowledge for <span class="math">\\Pi\\colon\\Xi_{0}\\to\\Xi_{1}</span>, our for <span class="math">\\Pi_{\\mathsf{KS}}\\colon\\Xi_{0}^{\\mathsf{KS}}\\to\\Xi_{1}^{\\mathsf{KS}}</span> in case of relaxed knowledge soundness, we see that the notion of correctness and (relaxed) knowledge soundness is equivalent to the respective notion for reduction of knowledge, with the same knowledge error. Hence, we can indeed apply all our tools for (coordinate-wise special sound) proofs of knowledge.</p>

    <p class="text-gray-300">A.4 Coordinate-Wise Special Soundness</p>

    <p class="text-gray-300">We recall the notion of coordinate-wise special soundness (CWSS) from <em>[x10]</em> in a simple form. Let <span class="math">S</span> be a finite set and <span class="math">\\ell\\geq 1</span>. For <span class="math">i\\in[\\ell]</span> define the following relation <span class="math">\\equiv_{i}</span> for two vectors <span class="math">\\mathbf{x},\\mathbf{y}\\in S^{\\ell}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{x}\\equiv_{i}\\mathbf{y}\\iff x_{i}\\neq y_{i}\\quad\\text{and}\\quad x_{j}=y_{j}\\quad\\forall j\\in[\\ell]\\backslash\\{i\\}.</span></p>

    <p class="text-gray-300">This means that <span class="math">\\mathbf{x}</span> and <span class="math">\\mathbf{y}</span> differ in exactly the <span class="math">i</span>-th coordinate. Next, we consider the following set:</p>

    <p class="text-gray-300"><span class="math">\\Gamma(S,\\ell):=\\left\\{(\\mathbf{x}_{0},\\ldots,\\mathbf{x}_{\\ell})\\subseteq(S^{\\ell})^{\\ell+1}\\ :\\ \\forall i\\in[\\ell],\\mathbf{x}_{0}\\equiv_{i}\\mathbf{x}_{i}.\\right\\}</span></p>

    <p class="text-gray-300">In other words, <span class="math">(\\mathbf{x}_{0},\\ldots,\\mathbf{x}_{\\ell})\\in\\Gamma(S,\\ell)</span> if for every coordinate <span class="math">i\\in[\\ell]</span>, there exists exactly one vector <span class="math">\\mathbf{x}_{i}</span> that differs from <span class="math">\\mathbf{x}_{0}</span> in exactly (and only) the <span class="math">i</span>-th coordinate. One can think of <span class="math">\\mathbf{x}_{0}</span> as the “central” vector.</p>

    <p class="text-gray-300">Intuitively, coordinate-wise special soundness for three-round interactive proofs says that given <span class="math">\\ell+1</span> valid transcripts with challenges <span class="math">\\mathbf{x}_{0},\\ldots,\\mathbf{x}_{\\ell}</span> which satisfy <span class="math">(\\mathbf{x}_{0},\\ldots,\\mathbf{x}_{\\ell})\\in\\Gamma(S,\\ell)</span>, one can efficiently extract the witness. In this paper, we will call such protocols <span class="math">\\ell</span>-CWSS. To argue knowledge soundness from coordinate-wise special soundness in the context of reduction of knowledge, we will use the following lemma from <em>[x10]</em>.</p>

    <h6 id="sec-90" class="text-base font-medium mt-4">Lemma 15 (CWSS).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell\\in\\mathbb{N}</span>, and <span class="math">S</span> be a finite set of cardinality <span class="math">N</span>. Let <span class="math">\\mathcal{C}:=S^{\\ell}</span> and take a verification function <span class="math">\\mathcal{V}:\\mathcal{C}\\times\\{0,1\\}^{*}\\rightarrow\\{0,1\\}</span>. Then there exists an extractor algorithm <span class="math">\\mathcal{E}</span>, which given oracle access to a probabilistic algorithm <span class="math">\\mathcal{A}</span> such that</p>

    <p class="text-gray-300"><span class="math">\\varepsilon:=\\mathsf{Pr}\\left[\\mathcal{V}(\\mathbf{x},\\mathcal{A}(\\mathbf{x}))=1\\right],</span></p>

    <p class="text-gray-300">where the probability is over the choice of <span class="math">\\mathbf{x}\\leftarrow\\mathcal{C}</span> and random coins of <span class="math">\\mathcal{A}</span>, it makes an expected number of at most <span class="math">\\ell+1</span> queries to <span class="math">\\mathcal{A}</span> and with probability at least</p>

    <p class="text-gray-300"><span class="math">\\varepsilon-\\ell/N</span></p>

    <p class="text-gray-300">outputs <span class="math">\\ell+1</span> pairs <span class="math">(\\mathbf{x}_{i},y_{i})_{0\\leq i\\leq\\ell}</span> such that <span class="math">V(\\mathbf{x}_{i},y_{i})=1</span> for all <span class="math">0\\leq i\\leq\\ell</span> and <span class="math">\\{\\mathbf{x}_{0},\\ldots,\\mathbf{x}_{\\ell}\\}\\in\\Gamma(S,\\ell)</span>.</p>

    <h2 id="sec-91" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="RoK, Paper, SISsors – Toolkit for Lattice-based Succinct Arg... (2024/1972)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1972
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
