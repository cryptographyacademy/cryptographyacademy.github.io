---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1283';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'A Univariate Attack against the Limited-Data Instance of Ciminion';
const AUTHORS_HTML = 'Augustin Bariant';

const CONTENT = `    <p class="text-gray-300">Augustin Bariant</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">With the increasing interest for advanced protocols for Multi-Party Computation, Fully-Homomorphic Encryption or Zero-Knowledge proofs, a need for cryptographic algorithms with new constraints has emerged. These algorithms, called Arithmetization-Oriented ciphers, seek to minimize the number of field multiplications in large finite fields <span class="math">\\mathbb{F}_{2^{n}}</span> or <span class="math">\\mathbb{F}_{p}</span>. Among them, Ciminion is an encryption algorithm proposed by Dobraunig et al. at Eurocrypt 2021.</p>

    <p class="text-gray-300">In this paper, we focus on the limited-data instance of Ciminion; the parameters of this instance were chosen to provide <span class="math">s</span>-bit security against an attacker that has access to at most <span class="math">2^{s/2}</span> data. We present a new univariate modeling of Ciminion and show that the designers choice to reduce the number of rounds under this data constraint leads to full-round attacks for security levels <span class="math">s\\geq 93</span>. We also propose some slight modifications of Ciminion that would overcome this vulnerability.</p>

    <h6 id="sec-3" class="text-base font-medium mt-4">Keywords:</h6>

    <p class="text-gray-300">Cryptanalysis Algebraic attack Univariate polynomial solving Ciminion Arithmetization-oriented</p>

    <h2 id="sec-4" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Recent advanced protocols for applications such as Multi-Party Computation (MPC), Fully-Homomorphic Encryption (FHE) or Zero-Knowledge (ZK) proofs have become the object of attention in modern cryptography. Some ZK proof systems and MPC protocols operate on large finite fields <span class="math">\\mathbb{F}_{q}</span> with <span class="math">q</span> prime or power of 2 <em>[10, 15, 16, 7]</em>. In such protocols, the cost is tightly linked to the number of field multiplications required by the ZK proof or the MPC function to evaluate. Moreover, these protocols rely on different symmetric cryptography primitives: ZK proof protocols often involve cryptographic hash functions, and MPC protocols make use of symmetric-key encryptions to improve the data storage and transfer, as discussed in <em>[22]</em>. A first approach is to convert standard bit-oriented cryptography primitives to sequences of finite field operations over the native field <span class="math">\\mathbb{F}_{q}</span> of the protocol under consideration, with a preferably low number of multiplications. In this context, multiple works were conducted to reduce the implementation cost of AES <em>[14, 22]</em>.</p>

    <p class="text-gray-300">In 2015, LowMC was the first cryptographic design aiming at minimizing the number of boolean multiplications <em>[3]</em>. The next year, the family of block</p>

    <p class="text-gray-300">riples of the CIPA and the CIPA-2021 CIPA-2021 CIPA-2021. The CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021.</p>

    <h2 id="sec-5" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <h2 id="sec-6" class="text-2xl font-bold">1.1 CIPA-2021</h2>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">1.1.1 CIPA-2021</h3>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.1.2 CIPA-2021</h3>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <h2 id="sec-9" class="text-2xl font-bold">2 CIPA</h2>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.1 CIPA</h3>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <h2 id="sec-11" class="text-2xl font-bold">3 CIPA</h2>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 CIPA</h3>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <h2 id="sec-13" class="text-2xl font-bold">4 CIPA</h2>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">4.1 CIPA</h3>

    <p class="text-gray-300">CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021 CIPA-2021</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1. The Ciminion stream cipher over  <span class="math">\\mathbb{F}_p</span>  (replace  <span class="math">+</span>  by  <span class="math">\\oplus</span>  over  <span class="math">\\mathbb{F}_{2^n}</span> ).</p>

    <p class="text-gray-300">modified version of the Farfalle construction [8]: it takes as input two master keys  <span class="math">MK_{1}, MK_{2} \\in \\mathbb{F}_{q}</span> , a nonce  <span class="math">\\aleph \\in \\mathbb{F}_{q}</span> , and outputs some keystream elements in  <span class="math">S_{1}, S_{2}, \\ldots</span> , each in  <span class="math">\\mathbb{F}_{q}</span>  and of arbitrary length. These keystream elements are then added to plaintext elements to yield the ciphertext. As a precomputation, the master keys  <span class="math">MK_{1}, MK_{2}</span>  are expanded into subkeys  <span class="math">K_{1}, K_{2}, \\ldots, K_{2l}</span> , which are stored and re-used directly with different nonces. Since this key expansion is performed only once, the designers used a strong and costly key expansion based on the Sponge construction [9]. The specification of Ciminion is highlighted in Figure 1.</p>

    <p class="text-gray-300">The state of Ciminion is composed of three elements of  <span class="math">\\mathbb{F}_q</span> . Two permutations are employed:  <span class="math">p_C</span>  and  <span class="math">p_E</span> , both iterating the round function  <span class="math">f_i</span> . At round  <span class="math">i</span> ,  <span class="math">f_i</span>  uses the round constants  <span class="math">RC1_i, RC2_i, RC3_i, RC4_i</span>  in  <span class="math">\\mathbb{F}_q</span> , where  <span class="math">RC4_i</span>  is assumed to be different from 0 or 1.  <span class="math">p_C = f_N \\circ \\dots \\circ f_1</span>  is composed of  <span class="math">N</span>  rounds, and  <span class="math">p_E = f_{R+N} \\circ \\dots \\circ f_{N+1}</span>  is composed of  <span class="math">R</span>  rounds <span class="math">^1</span> . The round function and the rol function are based on Toffoli gates and are of degree 2. Because both these</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2. rolling function rol.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig.3. Ciminion round function  <span class="math">f_{i}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Instance</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Standard</td>

            <td class="px-3 py-2 border-b border-gray-700">s+6</td>

            <td class="px-3 py-2 border-b border-gray-700">[ s+37/12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Limited-data</td>

            <td class="px-3 py-2 border-b border-gray-700">[ 2(s+6)/3]</td>

            <td class="px-3 py-2 border-b border-gray-700">[ s+37/12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conservative</td>

            <td class="px-3 py-2 border-b border-gray-700">s+6</td>

            <td class="px-3 py-2 border-b border-gray-700">[ 3/2·s+37/12]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Number of rounds  <span class="math">N</span>  of  <span class="math">p_C</span>  and  <span class="math">R</span>  of  <span class="math">p_E</span>  for the instances proposed by the designers of Ciminion, for a security level of  <span class="math">64 \\leq s \\leq \\log(q)</span> . The limited-data instance restricts the attacker to at most  <span class="math">2^{s/2}</span>  data.</p>

    <p class="text-gray-300">functions use Toffoli gates rather than low degree Sboxes, the inverse of these functions are also of degree 2. They are depicted in Figure 2 and Figure 3.</p>

    <p class="text-gray-300">Ciminion truncates one output element of each permutation  <span class="math">p_E</span> , to prevent the recovery of intermediate states. Since the knowledge of a truncated element allows to recover the intermediate states and thus the round keys  <span class="math">K_1</span>  and  <span class="math">K_2</span> , the security of Ciminion cannot exceed  <span class="math">\\log(q)</span>  by design. The designers claim a security level of  <span class="math">64 \\leq s \\leq \\log(q)</span>  for three instances presented in Table 1, where the numbers of rounds  <span class="math">N</span>  and  <span class="math">R</span>  depend on the security level  <span class="math">s</span> . In particular, the limited-data instance limits the attacker to at most  <span class="math">2^{s/2}</span>  oracle queries and has fewer rounds than the standard and conservative instances.</p>

    <p class="text-gray-300">As it is the case in other Arithmetization-Oriented ciphers, statistical attacks perform poorly because of the strong cryptographic properties (e.g. linear, differential ...) of the multiplication in large fields. The number of rounds of the Ciminion instances was therefore chosen to provide security against algebraic attacks, by ensuring that the best known algebraic attack exceeds  <span class="math">2^{s}</span>  in time complexity.</p>

    <p class="text-gray-300">On the security of the limited-data instance of Ciminion. In the security analysis of Ciminion in the limited-data instance [18, Appendix F], the designers derive the number of rounds from Gröbner basis and interpolation attacks. The Gröbner basis attack on Ciminion only requires a few keystream elements², and involves only the 'right' part of the cipher, with the permutation  <span class="math">p_E</span> . For this reason, the designers apply the same analysis as in the standard instance, and choose the same number of rounds for  <span class="math">p_E</span>  as in the standard instance. On the</p>

    <p class="text-gray-300">other hand, in the interpolation attack, the attacker queries <span class="math">d</span> keystream elements <span class="math">S_{1}^{i}</span> under different nonces <span class="math">\\aleph^{i}</span>, for <span class="math">i\\in\\{1,\\ldots d\\}</span>. If <span class="math">S_{1}</span> can be expressed with a key-dependant polynomial of the nonce <span class="math">Q_{K}(\\aleph)</span> of degree at most <span class="math">d-1</span>, the attacker can perform a Lagrange interpolation from <span class="math">d</span> pairs <span class="math">(\\aleph^{i},Q_{K}(\\aleph^{i}))</span> to recover the coefficients of the polynomial <span class="math">Q_{K}</span> and thus entirely know the mapping from the nonce to the first keystream element <span class="math">S_{1}</span>. The drawback of this attack is the large number of data needed by the attacker to mount the attack. Because of this very reason, the designers of Ciminion suggested that if the attacker is limited to <span class="math">2^{s/2}</span> data, the number of rounds can be reduced as long as the degree of the polynomial <span class="math">Q_{K}(\\aleph)</span> exceeds <span class="math">2^{s/2}</span> <em>[18, Appendix F]</em>, for a security level <span class="math">s</span>. In the setting chosen by the designers, the polynomial <span class="math">Q_{K}(\\aleph)</span> (representing <span class="math">S_{1}</span>) is of degree <span class="math">2^{\\lceil\\frac{2(s+6)}{4}\\rceil+\\lceil\\frac{s+37}{12}\\rceil-1}\\approx 2^{\\frac{3s}{4}+7}</span>; it is less than <span class="math">2^{s}</span> for large security levels <span class="math">s</span>.</p>

    <h2 id="sec-15" class="text-2xl font-bold">3 Our attack using univariate polynomial solving</h2>

    <p class="text-gray-300">Generally, a polynomial solving algebraic attack on an AO cipher can be decomposed into two main steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Modeling: The attacker models the cipher with a system of polynomial equations in <span class="math">\\mathbb{F}_{q}</span>, such that a solution of the polynomial system contains secret data (e.g. the encryption key or an internal state).</li>

      <li>System solving: The attacker solves the polynomial system using state-of-the-art techniques, such as root finding algorithms for univariate polynomials or Gröbner basis algorithms for multivariate systems.</li>

    </ul>

    <p class="text-gray-300">Both steps should be carefully analyzed when mounting an algebraic attack. On the one hand, the modeling step is highly cipher dependant, and heavily impacts the complexity of the attack. Some ciphers might possess different modelings with different solving time complexities, such as Anemoi <em>[11]</em>, or Griffin <em>[19]</em>. Efficient modelings are found through cryptanalysis. On the other hand, the system solving step often relies on existing generic algorithms and the complexity of such algorithms is hard to improve upon.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.1 Univariate polynomial solving attacks</h3>

    <p class="text-gray-300">In univariate polynomial systems, the system that we want to solve is a unique polynomial equation of degree <span class="math">d</span> in <span class="math">\\mathbb{F}_{q}</span>:</p>

    <p class="text-gray-300"><span class="math">P(X)=0.</span></p>

    <p class="text-gray-300">Advanced algorithms for polynomial operations. First, let us recall the complexity of the main operations on polynomials over an arbitrary field <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">Let <span class="math">P,Q</span> be two polynomials of degree <span class="math">d</span> over a field <span class="math">\\mathbb{F}</span>. Naïvely, the element-wise multiplication <span class="math">P\\times Q</span> costs <span class="math">d^{2}</span> multiplications over <span class="math">\\mathbb{F}</span>. However, faster polynomial multiplication algorithms exist, using Fast Fourier Transform (FFT) <em>[25]</em>.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Proposition 1 (<em>[12]</em>).</h6>

    <p class="text-gray-300">Two polynomials of degree at most <span class="math">d</span> over a field <span class="math">\\mathbb{F}</span> can be multiplied with <span class="math">\\mathcal{O}(d\\log(d))</span> multiplications and <span class="math">\\mathcal{O}(d\\log(d)\\log(\\log(d)))</span> additions in <span class="math">\\mathbb{F}</span>.</p>

    <p class="text-gray-300">The fast polynomial multiplications can even be sped up to <span class="math">\\mathcal{O}(d\\log(d))</span> operations if a primitive root of unity is known in <span class="math">\\mathbb{F}</span>, as discussed in <em>[12]</em>. Many other polynomial operations achieve quasi-linear complexities with the same techniques. They are all based on fast polynomial multiplication, which is why a factor <span class="math">\\log(\\log(d))</span> appears in the complexity, in the case where no primitive root of unity is known in <span class="math">\\mathbb{F}</span>.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Proposition 2 (<em>[26]</em>).</h6>

    <p class="text-gray-300">The Euclidian division of two polynomials of degree at most <span class="math">d</span> over a field <span class="math">\\mathbb{F}</span> can be performed in <span class="math">\\mathcal{O}(d\\log(d)\\log(\\log(d)))</span> operations.</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Proposition 3 (<em>[24, Corollary 2]</em>).</h6>

    <p class="text-gray-300">The Greatest Common Divisor (GCD) of two polynomials of degree at most <span class="math">d</span> over a field <span class="math">\\mathbb{F}</span> can be computed in <span class="math">\\mathcal{O}(d\\log(d)^{2}\\log(\\log(d)))</span> operations.</p>

    <p class="text-gray-300">In particular, all the algorithms mentioned above hold in finite fields <span class="math">\\mathbb{F}_{q}</span>. The following propositions only hold for finite fields <span class="math">\\mathbb{F}_{q}</span>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Proposition 4 (<em>[13,23]</em>).</h6>

    <p class="text-gray-300">A polynomial <span class="math">P</span> of degree <span class="math">d</span> over <span class="math">\\mathbb{F}_{q}</span> can be factored in <span class="math">\\mathcal{O}(d^{1.815}\\log(q))</span> operations.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proposition 5.</h6>

    <p class="text-gray-300">Let <span class="math">P</span> be a polynomial of degree <span class="math">d</span> in <span class="math">\\mathbb{F}_{q}</span>. Let us suppose that <span class="math">P</span> has a few roots in <span class="math">\\mathbb{F}_{q}</span>. The roots of <span class="math">P</span> in <span class="math">\\mathbb{F}_{q}</span> can be recovered in</p>

    <p class="text-gray-300"><span class="math">\\mathcal{O}(d\\log(d)(\\log(d)+\\log(q))\\log(\\log(d)))</span></p>

    <p class="text-gray-300">operations.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof comes from the following well-known algorithm, described in <em>[6]</em>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute <span class="math">Q=X^{q}-X\\bmod P</span>. The computation is performed with a double-and-add algortihm to compute <span class="math">X^{k}\\bmod P</span>. At each step, we multiply two polynomials of degree <span class="math">d</span> with <span class="math">\\mathcal{O}(d\\log(d)\\log(\\log(d)))</span> field operations (Proposition 1), and compute the remainder of a polynomial of degree <span class="math">2d</span> by <span class="math">P</span> (of degree <span class="math">d</span>) in <span class="math">\\mathcal{O}(d\\log(d)\\log(\\log(d)))</span> field operations (Proposition 2). There are <span class="math">\\log(q)</span> steps, therefore this costs <span class="math">\\mathcal{O}(d\\log(q)\\log(d)\\log(\\log(d)))</span> field operations.</li>

      <li>Compute <span class="math">R=\\gcd(P,Q)</span>. <span class="math">R</span> has the same roots as <span class="math">P</span> in the field <span class="math">\\mathbb{F}_{q}</span> since <span class="math">R=\\gcd(P,X^{q}-X)</span>, but its degree is much lower (it is exactly the number of roots in <span class="math">\\mathbb{F}_{q}</span>). This requires <span class="math">\\mathcal{O}(d\\log(d)^{2}\\log(\\log(d)))</span> field operations (Proposition 3).</li>

      <li>Factor <span class="math">R</span>. This costs <span class="math">\\deg(R)^{1.815}\\log(q)</span> operations (Proposition 4). Since the degree of <span class="math">R</span> is exactly the number of roots of <span class="math">P</span> in <span class="math">\\mathbb{F}_{q}</span>, as long as <span class="math">P</span> has less than <span class="math">\\left(\\frac{d\\log(d)^{2}}{\\log(q)}\\right)^{\\frac{1}{1.815}}</span> roots in <span class="math">\\mathbb{F}_{q}</span>, this step has a negligible complexity.</li>

    </ol>

    <p class="text-gray-300">Proposition 5 gives a bound on the solving complexity of the univariate system composed of the equation <span class="math">P(X)=0</span> in <span class="math">\\mathbb{F}_{q}</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4. Our modeling of Ciminion.</p>

    <p class="text-gray-300">This attack breaks the security claims of the designers in the limited-data instance for large security levels, in which the attacker cannot query more than  <span class="math">2^{s/2}</span>  data. It is an equivalent key-recovery attack in the sense that it allows to recover an arbitrary number of subkeys  <span class="math">K_1, K_2 \\ldots</span>  but does not allow to recover the master key  <span class="math">MK_1, MK_2</span> , since the subkey generation is performed with a non-invertible sponge construction. The recovery of the subkeys is enough for an attacker to compute keystream blocks under different nonces, and thus breaks the security of the cipher.</p>

    <p class="text-gray-300">Attack principle. In the big picture, our univariate modeling is represented on Figure 4. This attack is a known-plaintext attack using two keystream blocks  <span class="math">S_{1}</span>  and  <span class="math">S_{2}</span>  under a nonce  <span class="math">\\aleph</span> . The variable  <span class="math">X</span>  represents the truncated output of the first branch  <span class="math">p_{E}</span> . Our attack is based on the observation that the nonce  <span class="math">\\aleph</span>  can be represented as a polynomial  <span class="math">Q_{S_1,S_2}(X)</span>  of relatively small degree, whose coefficients only depend on the known keystream values  <span class="math">S_{1}</span>  and  <span class="math">S_{2}</span> . Using the queried keystream values  <span class="math">S_{1}</span>  and  <span class="math">S_{2}</span> , the attacker may compute and solve the polynomial equation  <span class="math">Q_{S_1,S_2}(X) - \\aleph = 0</span>  in  <span class="math">\\mathbb{F}_q</span>  to recover a few possible candidates for  <span class="math">X</span> .</p>

    <p class="text-gray-300">Generation of the polynomial  <span class="math">Q_{S_1, S_2}(X)</span> . The two first keystream blocks  <span class="math">S_1</span>  and  <span class="math">S_2</span>  are considered known to the attacker. First, let us note that  <span class="math">p_E \\circ p_C = f_{N + R} \\circ \\dots \\circ f_1</span>  is composed  <span class="math">N + R</span>  round function iterations. We start from three polynomials representing the output of  <span class="math">p_E \\circ p_C</span> :</p>

    <div class="my-4 text-center"><span class="math-block">T _ {S _ {1}, S _ {2}} ^ {N + R} (X) = S _ {1}, \\qquad U _ {S _ {1}, S _ {2}} ^ {N + R} (X) = S _ {2}, \\qquad V _ {S _ {1}, S _ {2}} ^ {N + R} (X) = X.</span></div>

    <p class="text-gray-300">Then, for  <span class="math">i = N + R,\\ldots 1</span> , we compute the polynomials  <span class="math">T_{S_1,S_2}^{i - 1}(X),U_{S_1,S_2}^{i - 1}(X)</span>  and  <span class="math">V_{S_1,S_2}^{i - 1}(X)</span>  from  <span class="math">T_{S_1,S_2}^i (X),U_{S_1,S_2}^i (X)</span> , and  <span class="math">V_{S_1,S_2}^i (X)</span>  using the algebraic representation of the round function  <span class="math">f_{i}</span> , as highlighted in Figure 5:</p>

    <div class="my-4 text-center"><span class="math-block">T _ {S _ {1}, S _ {2}} ^ {i - 1} (X) = U _ {S _ {1}, S _ {2}} ^ {i} (X) - R C 1 _ {i} - R C 4 _ {i} \\left(V _ {S _ {1}, S _ {2}} ^ {i} (X) - R C 2 _ {i}\\right),</span></div>

    <div class="my-4 text-center"><span class="math-block">U _ {S _ {1}, S _ {2}} ^ {i - 1} (X) = V _ {S _ {1}, S _ {2}} ^ {i} (X) - R C 2 _ {i} - T _ {S _ {1}, S _ {2}} ^ {i} (X) + R C 3 _ {i},</span></div>

    <div class="my-4 text-center"><span class="math-block">V _ {S _ {1}, S _ {2}} ^ {i - 1} (X) = T _ {S _ {1}, S _ {2}} ^ {i} (X) - R C 3 _ {i} - T _ {S _ {1}, S _ {2}} ^ {i - 1} (X) \\times U _ {S _ {1}, S _ {2}} ^ {i - 1} (X).</span></div>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 5. Modeling of the round function  <span class="math">f_{i}</span> .</p>

    <p class="text-gray-300">By induction on  <span class="math">i = N + R - 1, \\ldots, 0</span> , we can easily deduce the degrees of the polynomials:</p>

    <div class="my-4 text-center"><span class="math-block">\\forall i \\in \\{0, \\ldots N + R - 1 \\}, \\qquad \\left\\{ \\begin{array}{l l} \\deg \\left(T _ {S _ {1}, S _ {2}} ^ {i} (X)\\right) &amp;amp; = 2 ^ {N + R - i - 1}, \\\\ \\deg \\left(U _ {S _ {1}, S _ {2}} ^ {i} (X)\\right) &amp;amp; = 2 ^ {N + R - i - 1}, \\\\ \\deg \\left(V _ {S _ {1}, S _ {2}} ^ {i} (X)\\right) &amp;amp; = 2 ^ {N + R - i}. \\end{array} \\right.</span></div>

    <p class="text-gray-300">This implies that the polynomial  <span class="math">Q_{S_1, S_2}(X) = T_{S_1, S_2}^0(X)</span>  is of degree  <span class="math">2^{N + R - 1}</span> . At round  <span class="math">i</span> , the complexity of computing the polynomials is dominated by the multiplication  <span class="math">T_{S_1, S_2}^{i - 1}(X) \\times U_{S_1, S_2}^{i - 1}(X)</span> , of two polynomials of degree  <span class="math">2^{N + R - i}</span> , which costs</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(2 ^ {N + R - i} (N + R - i) (\\log (N + R - i))\\right)</span></div>

    <p class="text-gray-300">field operations (Proposition 1). In total, generating  <span class="math">Q_{S_1,S_2}(X)</span>  costs:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(\\sum_ {i = 1} ^ {N + R} 2 ^ {N + R - i} (N + R - i) \\log (N + R - i)\\right) = \\mathcal {O} (2 ^ {N + R} (N + R) \\log (N + R)).</span></div>

    <p class="text-gray-300">This is negligible compared to the complexity of the rest of the attack.</p>

    <p class="text-gray-300">Solving the univariate equation. The equation  <span class="math">Q_{S_1, S_2}(X) - \\aleph = 0</span>  is of degree  <span class="math">2^{N + R - 1}</span>  and we expect it to have a few roots in  <span class="math">\\mathbb{F}_q</span> , therefore we can use Proposition 5 to bound the complexity of computing its roots in  <span class="math">\\mathbb{F}_q</span>  to:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {O} \\left(2 ^ {N + R - 1} (N + R - 1) (N + R - 1 + \\log (q)) \\log (N + R)\\right).</span></div>

    <p class="text-gray-300">Recovery of the subkeys. For each candidate for the truncated output  <span class="math">X</span> , the attacker can deduce candidates for  <span class="math">K_{1}</span>  and  <span class="math">K_{2}</span>  by inverting  <span class="math">p_{E} \\circ p_{C}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">(\\aleph , K _ {1}, K _ {2}) = p _ {C} ^ {- 1} \\circ p _ {E} ^ {- 1} (S _ {1}, S _ {2}, X).</span></div>

    <p class="text-gray-300">The right candidate for  <span class="math">(K_{1}, K_{2})</span>  may be confirmed with an extra query under a different nonce. After the recovery of  <span class="math">K_{1}</span>  and  <span class="math">K_{2}</span> , the attacker can query further keystream elements  <span class="math">S_{i}</span>  for  <span class="math">i \\geq 3</span> , under the same nonce  <span class="math">\\aleph</span> . The inner state before the first branch  <span class="math">p_{E}</span>  is known, as depicted in green and dotted in Figure 6. We denote  <span class="math">Y</span>  the truncated output of the second branch  <span class="math">p_{E}</span> . We can compute the polynomial  <span class="math">\\tilde{Q}_{S_{3}, S_{4}}(Y)</span>  representing the first inner state element, which is known</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 6. Recovery of keystream elements  <span class="math">K_{3}</span>  and  <span class="math">K_{4}</span> . The green dotted wires denote the known internal state elements from the recovery of  <span class="math">K_{1}</span>  and  <span class="math">K_{2}</span> .</p>

    <p class="text-gray-300">from the recovery of  <span class="math">K_{1}</span>  and  <span class="math">K_{2}</span> ; We denote its value  <span class="math">\\alpha</span> . The truncated output of the second  <span class="math">p_{E}</span>  is a root of  <span class="math">\\tilde{Q}_{S_3,S_4}(Y) - \\alpha</span> , which is a polynomial of degree  <span class="math">2^{R} + 2^{R - 1} \\approx 2^{R + 0.6}</span> . The recovery of  <span class="math">Y</span>  is of negligible complexity compared to the rest of the attack. This allows to recover the inner state before the second branch  <span class="math">p_{E}</span>  and therefore to recover  <span class="math">K_{3}</span>  and  <span class="math">K_{4}</span> .</p>

    <p class="text-gray-300">Ultimately,  <span class="math">(K_{2i + 1}, K_{2i + 2})</span>  for  <span class="math">i \\geq 2</span>  can be recovered in a similar manner if the keystream is long enough.</p>

    <p class="text-gray-300">Complexity of our attack. For a security level of  <span class="math">s</span> , the designers chose the following parameters in the limited-data variant:</p>

    <div class="my-4 text-center"><span class="math-block">N = \\lceil \\frac {2 (s + 6)}{3} \\rceil ,</span></div>

    <div class="my-4 text-center"><span class="math-block">R = \\lceil \\frac {s + 3 7}{1 2} \\rceil ,</span></div>

    <p class="text-gray-300">which gives, asymptotically,  <span class="math">N + R \\approx \\frac{3s}{4} + 7</span> . The complexity of our attack is dominated by the univariate polynomial solving. It has a time complexity of</p>

    <div class="my-4 text-center"><span class="math-block">T = 2 ^ {N + R - 1} (N + R - 1) (N + R - 1 + \\log (q)) \\log (N + R)</span></div>

    <p class="text-gray-300">equivalent Ciminion encryptions3.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 7. Complexity of our attack for different security levels  <span class="math">s</span>  with  <span class="math">s = \\log (q)</span> .</p>

    <p class="text-gray-300">For large security levels  <span class="math">s</span> , our attack runs faster than  <span class="math">2^s</span>  operations: the complexity is quasi-linear in  <span class="math">2^{\\frac{N}{4}}</span> , and we can verify that  <span class="math">T \\leq 2^s</span>  for  <span class="math">s = \\log(q) \\geq 93</span> . The complexity of our attack for different security levels is plotted on Figure 7. In particular,  <span class="math">T = 2^{217.4}</span>  for  <span class="math">s = \\log(q) = 256</span> , and  <span class="math">T = 2^{120.3}</span>  for  <span class="math">s = \\log(q) = 128</span> .</p>

    <p class="text-gray-300">Aiminion. Aiminion is an aggressive evolution of Ciminion presented in appendix of the Ciminion paper [18]. Since it uses a key addition right before outputting the keystream, it is impossible to express the nonce only with the keystreams  <span class="math">S_{1}</span> ,  <span class="math">S_{2}</span>  and the truncated element  <span class="math">X</span> . Instead, the unknown subkeys  <span class="math">K_{3}</span>  and  <span class="math">K_{4}</span>  would be involved in the formula. We did not manage to overcome this difficulty to mount an attack.</p>

    <p class="text-gray-300">Comparison with other attacks. Our attack exploits the links between the nonce and the keystream elements, therefore it only holds if both  <span class="math">p_C</span>  and  <span class="math">p_E</span>  are weak permutations. The Gröbner basis attack of [6] instead derives relations between multiple keystream elements (under two different nonces) to recover the truncated outputs. Their attack only exploits the weakness of  <span class="math">p_E</span> . For that reason, their attack succeeds in the standard and limited-data instances which have the same number of rounds  <span class="math">R</span>  for  <span class="math">p_E</span> , while ours only succeeds in the limited-data</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attack type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Generic N, R</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Full-instance attacks</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Data</td>

            <td class="px-3 py-2 border-b border-gray-700">Time</td>

            <td class="px-3 py-2 border-b border-gray-700">Standard</td>

            <td class="px-3 py-2 border-b border-gray-700">Limited-data</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Gröbner basis (SKR)</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">O(24Rω)</td>

            <td class="px-3 py-2 border-b border-gray-700">s ≥ 587</td>

            <td class="px-3 py-2 border-b border-gray-700">s ≥ 587</td>

            <td class="px-3 py-2 border-b border-gray-700">[6]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Integral (dist.)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2N+R)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2N+R)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">[27]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Univariate (SKR)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">O(2N+R)</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">s ≥ 93</td>

            <td class="px-3 py-2 border-b border-gray-700">Section 3</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2. Comparison of existing attacks against generic Ciminion parameters and full Ciminion instances with  <span class="math">s</span> -bit security.  <span class="math">N</span>  and  <span class="math">R</span>  are respectively the number of rounds of  <span class="math">p_C</span>  and  <span class="math">p_E</span> .  <span class="math">2.41 \\leq \\omega \\leq 3</span>  is the linear algebra exponent. SKR denotes subkey recovery.</p>

    <p class="text-gray-300">instance, which has a lower number of round  <span class="math">N</span>  for  <span class="math">p_C</span> . The attack of [27] use the low degree of the forward function  <span class="math">p_E \\circ p_C</span>  to derive an integral attack. However, the integral attack requires a large amount of data, which is the reason why they do not threaten the limited-data instance of Ciminion. These attacks are compared in Table 2.</p>

    <p class="text-gray-300">Protection against our attack. The univariate solving attack presented in Section 3 relies on the backward computation of  <span class="math">p_C</span>  from the single guess of the first truncated output value. To provide protection against this attack in the limited-data instance, a cheap modification is to perform a feedforward after  <span class="math">p_C</span> , by XORing at least one key elements  <span class="math">K_0</span> ,  <span class="math">K_1</span>  or both to one or several outputs of  <span class="math">p_C</span> . A variant of this feedforward would be to add new key elements to the output of  <span class="math">p_C</span> , although this costs extra key scheduling. This way, it is no longer possible to compute  <span class="math">p_C</span>  backward with the sole knowledge of the first truncated output value.</p>

    <p class="text-gray-300">Another possible protection is to increase the number of rounds of  <span class="math">p_C</span> , in which case we recommend to use the parameters of the standard Ciminion instance.</p>

    <p class="text-gray-300">On the security of conservative and the standard instances. The security of the standard and conservative instances is not threatened by this attack, since the number of rounds is sufficient to guarantee that the degree of the involved univariate polynomial exceeds  <span class="math">2^s</span> .</p>

    <p class="text-gray-300">Acknowledgement This work was supported by the French DGA. We would like to thank Gaetan Leurent for the insightful discussions regarding this result.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Albrecht, M.R., Cid, C., Grassi, L., Khovratovich, D., Lüftenegger, R., Rechberger, C., Schofnegger, M.: Algebraic cryptanalysis of STARK-friendly designs: Applica</li>

    </ol>

    <p class="text-gray-300">tion to MARVELlous and MiMC. In: Galbraith, S.D., Moriai, S. (eds.) Advances in Cryptology – ASIACRYPT 2019, Part III. Lecture Notes in Computer Science, vol. 11923, pp. 371–397. Springer, Heidelberg, Germany, Kobe, Japan (Dec 8–12, 2019). https://doi.org/10.1007/978-3-030-34618-8_13</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] Albrecht, M.R., Grassi, L., Rechberger, C., Roy, A., Tiessen, T.: MiMC: Efficient encryption and cryptographic hashing with minimal multiplicative complexity. In: Cheon, J.H., Takagi, T. (eds.) Advances in Cryptology – ASIACRYPT 2016, Part I. Lecture Notes in Computer Science, vol. 10031, pp. 191–219. Springer, Heidelberg, Germany, Hanoi, Vietnam (Dec 4–8, 2016). https://doi.org/10.1007/978-3-662-53887-6_7</li>

      <li>[3] Albrecht, M.R., Rechberger, C., Schneider, T., Tiessen, T., Zohner, M.: Ciphers for MPC and FHE. In: Oswald, E., Fischlin, M. (eds.) Advances in Cryptology – EUROCRYPT 2015, Part I. Lecture Notes in Computer Science, vol. 9056, pp. 430–454. Springer, Heidelberg, Germany, Sofia, Bulgaria (Apr 26–30, 2015). https://doi.org/10.1007/978-3-662-46800-5_17</li>

      <li>[4] Aly, A., Ashur, T., Ben-Sasson, E., Dhooghe, S., Szepieniec, A.: Design of symmetric-key primitives for advanced cryptographic protocols. IACR Transactions on Symmetric Cryptology 2020(3), 1–45 (2020). https://doi.org/10.13154/tosc.v2020.i3.1-45</li>

      <li>[5] Ashur, T., Dhooghe, S.: MARVELlous: a STARK-friendly family of cryptographic primitives. Cryptology ePrint Archive, Report 2018/1098 (2018), https://eprint.iacr.org/2018/1098</li>

      <li>[6] Bariant, A., Bouvier, C., Leurent, G., Perrin, L.: Algebraic attacks against some arithmetization-oriented primitives. IACR Transactions on Symmetric Cryptology 2022(3), 73–101 (2022). https://doi.org/10.46586/tosc.v2022.i3.73-101</li>

      <li>[7] Ben-Sasson, E., Bentov, I., Horesh, Y., Riabzev, M.: Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Report 2018/046 (2018), https://eprint.iacr.org/2018/046</li>

      <li>[8] Bertoni, G., Daemen, J., Hoffert, S., Peeters, M., Assche, G.V., Keer, R.V.: Farfalle: parallel permutation-based cryptography. IACR Transactions on Symmetric Cryptology 2017(4), 1–38 (2017). https://doi.org/10.13154/tosc.v2017.i4.1-38</li>

      <li>[9] Bertoni, G., Daemen, J., Peeters, M., Van Assche, G.: Sponge functions. In: ECRYPT hash workshop. vol. 2007 (2007)</li>

      <li>[10] Bitansky, N., Canetti, R., Chiesa, A., Tromer, E.: From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In: Goldwasser, S. (ed.) ITCS 2012: 3rd Innovations in Theoretical Computer Science. pp. 326–349. Association for Computing Machinery, Cambridge, MA, USA (Jan 8–10, 2012). https://doi.org/10.1145/2090236.2090263</li>

      <li>[11] Bouvier, C., Briaud, P., Chaidos, P., Perrin, L., Salen, R., Velichkov, V., Willems, D.: New design techniques for efficient arithmetization-oriented hash functions: ttAnemoi permutations and ttJive compression mode. In: Advances in Cryptology – CRYPTO 2023, Part III. pp. 507–539. Lecture Notes in Computer Science, Springer, Heidelberg, Germany, Santa Barbara, CA, USA (Aug 2023). https://doi.org/10.1007/978-3-031-38548-3_17</li>

      <li>[12] Cantor, D.G., Kaltofen, E.L.: On fast multiplication of polynomials over arbitrary algebras. Acta Informatica 28(7), 693–701 (1991). https://doi.org/10.1007/BF01178683, https://doi.org/10.1007/BF01178683</li>

      <li>[13] Cantor, D.G., Zassenhaus, H.: A new algorithm for factoring polynomials over finite fields. Mathematics of Computation 36(154), 587–592 (1981)</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Damgård, I., Lauritsen, R., Toft, T.: An empirical study and some improvements of the MiniMac protocol for secure computation. In: Abdalla, M., Prisco, R.D. (eds.) SCN 14: 9th International Conference on Security in Communication Networks. Lecture Notes in Computer Science, vol. 8642, pp. 398–415. Springer, Heidelberg, Germany, Amalfi, Italy (Sep 3–5, 2014). https://doi.org/10.1007/978-3-319-10879-7_23</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>15. Damgård, I., Pastro, V., Smart, N.P., Zakarias, S.: Multiparty computation from somewhat homomorphic encryption. In: Safavi-Naini, R., Canetti, R. (eds.) Advances in Cryptology – CRYPTO 2012. Lecture Notes in Computer Science, vol. 7417, pp. 643–662. Springer, Heidelberg, Germany, Santa Barbara, CA, USA (Aug 19–23, 2012). https://doi.org/10.1007/978-3-642-32009-5_38</li>

      <li>16. Damgård, I., Zakarias, S.: Constant-overhead secure computation of Boolean circuits using preprocessing. In: Sahai, A. (ed.) TCC 2013: 10th Theory of Cryptography Conference. Lecture Notes in Computer Science, vol. 7785, pp. 621–641. Springer, Heidelberg, Germany, Tokyo, Japan (Mar 3–6, 2013). https://doi.org/10.1007/978-3-642-36594-2_35</li>

      <li>17. Dobraunig, C., Grassi, L., Guinet, A., Kuijsters, D.: Ciminion: Symmetric encryption based on Toffoli-gates over large finite fields. In: Canteaut, A., Standaert, F.X. (eds.) Advances in Cryptology – EUROCRYPT 2021, Part II. Lecture Notes in Computer Science, vol. 12697, pp. 3–34. Springer, Heidelberg, Germany, Zagreb, Croatia (Oct 17–21, 2021). https://doi.org/10.1007/978-3-030-77886-6_1</li>

      <li>18. Dobraunig, C., Grassi, L., Guinet, A., Kuijsters, D.: Ciminion: Symmetric encryption based on toffoli-gates over large finite fields. Cryptology ePrint Archive, Report 2021/267 (2021), https://eprint.iacr.org/2021/267</li>

      <li>19. Grassi, L., Hao, Y., Rechberger, C., Schofnegger, M., Walch, R., Wang, Q.: Horst meets fluid-SPN: Griffin for zero-knowledge applications. In: Advances in Cryptology – CRYPTO 2023, Part III. pp. 573–606. Lecture Notes in Computer Science, Springer, Heidelberg, Germany, Santa Barbara, CA, USA (Aug 2023). https://doi.org/10.1007/978-3-031-38548-3_19</li>

      <li>20. Grassi, L., Khovratovich, D., Rechberger, C., Roy, A., Schofnegger, M.: Poseidon: A new hash function for zero-knowledge proof systems. In: Bailey, M., Greenstadt, R. (eds.) USENIX Security 2021: 30th USENIX Security Symposium. pp. 519–535. USENIX Association (Aug 11–13, 2021)</li>

      <li>21. Grassi, L., Øygarden, M., Schofnegger, M., Walch, R.: From farfalle to megafono via ciminion: The PRF hydra for MPC applications. In: Hazay, C., Stam, M. (eds.) Advances in Cryptology – EUROCRYPT 2023, Part IV. Lecture Notes in Computer Science, vol. 14007, pp. 255–286. Springer, Heidelberg, Germany, Lyon, France (Apr 23–27, 2023). https://doi.org/10.1007/978-3-031-30634-1_9</li>

      <li>22. Grassi, L., Rechberger, C., Rotaru, D., Scholl, P., Smart, N.P.: MPC-friendly symmetric key primitives. In: Weippl, E.R., Katzenbeisser, S., Kruegel, C., Myers, A.C., Halevi, S. (eds.) ACM CCS 2016: 23rd Conference on Computer and Communications Security. pp. 430–443. ACM Press, Vienna, Austria (Oct 24–28, 2016). https://doi.org/10.1145/2976749.2978332</li>

      <li>23. Kaltofen, E.L., Shoup, V.: Subquadratic-time factoring of polynomials over finite fields. Math. Comput. 67(223), 1179–1197 (1998). https://doi.org/10.1090/S0025-5718-98-00944-2, https://doi.org/10.1090/S0025-5718-98-00944-2</li>

      <li>24. Moenck, R.T.: Fast computation of gcds. In: Aho, A.V., Borodin, A., Constable, R.L., Floyd, R.W., Harrison, M.A., Karp, R.M., Strong, H.R. (eds.) Proceedings of the 5th Annual ACM Symposium on Theory of Computing, April 30 - May 2,</li>

    </ul>

    <p class="text-gray-300">1973, Austin, Texas, USA. pp. 142–151. ACM (1973). https://doi.org/10.1145/800125.804045, https://doi.org/10.1145/800125.804045</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[25] Nussbaumer, H.J., Nussbaumer, H.J.: The fast Fourier transform. Springer (1982)</li>

      <li>[26] Strassen, V.: Die berechnungskomplexität der symbolischen differentiation von interpolationspolynomen. Theor. Comput. Sci. 1(1), 21–25 (1975). https://doi.org/10.1016/0304-3975(75)90010-9, https://doi.org/10.1016/0304-3975(75)90010-9</li>

      <li>[27] Zhang, L., Liu, M., Li, S., Lin, D.: Cryptanalysis of ciminion. In: Deng, Y., Yung, M. (eds.) Information Security and Cryptology. pp. 234–251. Springer Nature Switzerland, Cham (2023)</li>

    </ul>`;
---

<BaseLayout title="A Univariate Attack against the Limited-Data Instance of Cim... (2023/1283)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1283
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
