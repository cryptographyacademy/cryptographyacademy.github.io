---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2024/1058';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Natively Compatible Super-Efficient Lookup Arguments and How to Apply Them';
const AUTHORS_HTML = 'Matteo Campanelli, Dario Fiore, Rosario Gennaro';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli [ ] Dario Fiore [ ] and Rosario Gennaro [ ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Lookup arguments allow an untrusted prover to commit to a vector <span class="math">\\mathbf{f}\\in\\mathbb{F}^{n}</span> and show that its entries reside in a predetermined table <span class="math">\\mathbf{t}\\in\\mathbb{F}^{N}</span>. One of their key applications is to augment general-purpose SNARKs making them more efficient on subcomputations that are hard to arithmetize. In order for this “augmentation” to work out, a SNARK and a lookup argument should have some basic level of compatibility with respect to the commitment on <span class="math">\\mathbf{f}</span>. However, not all existing efficient lookup arguments are fully compatible with other efficient general-purpose SNARKs. This incompatibility can for example occur whenever SNARKs use multilinear extensions under the hood (e.g. Spartan) but the lookup argument is univariate in flavor (e.g. Caulk or cq).</p>

    <p class="text-gray-300">In this paper we discuss how to widen the spectrum of “super-efficient” lookup arguments (where the proving time is independent of the size of the lookup table): we present a new construction inspired by cq and based on multilinear polynomial encodings (MLE). Our construction is the first lookup argument for any table that is also natively compatible with MLE-based SNARKs at comparable costs with other state-of-the-art lookup arguments, particularly when the large table is unstructured. This case arises in various applications, such as using lookups to prove that the program in a virtual machine is fetching the right instruction and when proving the correct computation of floating point arithmetic (e.g., in verifiable machine learning).</p>

    <p class="text-gray-300">We also introduce a second more general construction: a compiler that, given any super-efficient lookup argument compatible with univariate SNARKs, converts it into a lookup argument compatible with MLE-based SNARKs with a very small overhead. Finally, we discuss SNARKs that we can compose with our constructions, as well as approaches for this composition to work effectively.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Lookup arguments are an important building block in modern SNARK constructions. They can be used as a tool to strengthen the efficiency of general-purpose proof systems <em>[x1]</em>, but also as a tool of their own to construct one from scratch <em>[x1, x2, x14]</em>.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">Quick background on lookup arguments</h4>

    <p class="text-gray-300">Given a table <span class="math">T\\in\\mathbb{F}^{N}</span> and a vector <span class="math">f\\in\\mathbb{F}^{n}</span>, we would like to check through a proof whether all the items in <span class="math">f</span> appear in <span class="math">T</span>. The verifier, in addition to the proof, takes as input succinct commitments <span class="math">c_{T}</span> and <span class="math">c_{f}</span> respectively to <span class="math">T</span> and <span class="math">f</span>. Verification should run in time significantly lower than <span class="math">N</span> or <span class="math">n</span>. Typically, these commitments exploit a polynomial encoding of <span class="math">T</span> and <span class="math">f</span> and are based on polynomial commitments such as <em>[x10, x13]</em>. Very recently there has been a flourishing of lookup constructions in literature <em>[CFF^{+}24, ZBK^{+}22a, ZBK^{+}22b, x7, x12, x1, x2, ZGK^{+}22, x1, x3]</em>.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">Integrating SNARKs and lookup arguments</h4>

    <p class="text-gray-300">Lookup arguments are useful because they allow one to efficiently prove specific computations. For example they allow more efficient operations that are non-native to field arithmetic such as XOR of bit strings or range checks. Range checks are useful to enforce that a variable <span class="math">w</span> is (say) actually a byte and this can be enforced as a lookup by enforcing that <span class="math">w</span> is in the table <span class="math">T_{&lt;256}:=0,1,\\ldots,255</span>. This is in contrast to having to show 256 bit constraints of the type <span class="math">(w_{i}-0)(w_{i}-1)=0</span>, where <span class="math">w=\\sum_{i}w_{i}2^{i}</span>. For the case of XOR, a lookup consists in checking that a triple <span class="math">(a,b,c)</span> is in the table of all possible XOR values <span class="math">(x,y,x\\oplus y)</span> (for bytes this table is of size <span class="math">2^{16}=(2^{8})^{2}</span>).</p>

    <p class="text-gray-300">Lookup arguments are thus used as aids to SNARKs for general-purpose computations. The latter outsources part of the work to the lookup arguments as in the examples above. In the context of a larger proof we then show knowledge of a witness <span class="math">w</span> such that some property <span class="math">P(w)</span> holds (proved with a general-purpose SNARKs) and in addition some subset at indices <span class="math">I</span> of <span class="math">w</span> satisfy a lookup relation (proved with a lookup argument) which we compactly denote with <span class="math">w_{I}\\prec T</span>.</p>

    <p class="text-gray-300">In order for lookup arguments to be able to work together with SNARKs, they need to be able to refer to the <em>same witness</em> as the one for which the general property <span class="math">P</span> is being shown. This is typically done through commitments—a succinct collision-resistant digest—and by three (idealized) facts: <em>(i)</em> The larger SNARK will commit to the witness <span class="math">w</span> through a commitment scheme producing <span class="math">c_{w}</span>; <em>(ii)</em> The lookup argument is able to express statements of the type <span class="math">c_{f}</span> commits to an <span class="math">f</span> that is contained in the table <span class="math">T</span>; <em>(iii)</em> Another argument proves that the content of <span class="math">c_{f}</span> actually refers to the parts of interest—the ones at indices <span class="math">I</span>—in the witness committed in <span class="math">c_{w}</span>.</p>

    <p class="text-gray-300">For the lookup approach to be cost effective when integrated with SNARKs, it is crucial that steps <em>(ii)</em> and <em>(iii)</em> are both as cheap as possible. We refer to this as the <em>challenge of native compatibility</em>, to which we will get back later in this introduction.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Super-efficient lookup arguments</h4>

    <p class="text-gray-300">An efficiency measure that is often desirable in lookup arguments is what we call <em>super efficiency</em>. We say a lookup argument is super-efficient if its proving time is independent of the size of the table. In particular, after a one-time preprocessing of the table, the prover can run only in time dependent on the size of the vector being looked up. This prop</p>

    <p class="text-gray-300">erty makes a difference whenever the table size dominates the size of the witness proven by the general SNARK, and thus of the looked up vector. Use cases where this occurs are for example the lookup table sizes used for SHA256 or tables for wide range checks.</p>

    <p class="text-gray-300">Due to the importance of this property, several lookup arguments in the state of the art are super-efficient [STW24, CFF+24, ZBK+22a, ZBK+22b, PK22, GK22, ZGK+22, EFG22]. With the only exception of [STW24], all these lookup arguments rely on the KZG polynomial commitment. This means that the <span class="math">c_{f}</span> of steps (ii)–(iii) is a KZG commitment to a univariate polynomial that interpolates the vector <span class="math">f</span>. KZG-based lookup arguments have two main advantages: (a) they exploit special properties of univariate polynomials and pairing-based verification to achieve super efficiency, and (b) they can be efficiently integrated with KZG-based SNARKs (e.g., [CHM+20, GWC19]) that are among the most popular and efficient ones.</p>

    <p class="text-gray-300">If one wishes to integrate a super efficient lookup argument with SNARKs based on multivariate polynomial commitments (e.g., [Set20, CBBZ23, CGG+23]) the only choice left is the work in [STW24]. The latter though achieves super efficiency only for tables that present a specific, regular structure.</p>

    <p class="text-gray-300">Therefore, the state of the art presents the following open question:</p>

    <p class="text-gray-300">Can we construct a super-efficient lookup argument for arbitrary tables that is natively compatible with SNARKs based on multivariate polynomials?</p>

    <p class="text-gray-300">Addressing this question is the main focus of this work.</p>

    <p class="text-gray-300">The challenge of compatibility In the question above we emphasize the requirement that the solution should be “natively compatible”. This is due to the wish of implementing the step (iii) above in the cheapest possible way. Otherwise, a straw-man solution could be to pick one of the existing super efficient lookup arguments where <span class="math">c_{f}</span> is a KZG commitment, and then use the multilinear-based SNARK to additionally prove the link of step (iii) w.r.t. <span class="math">f</span> in the KZG commitment <span class="math">c_{f}</span> (e.g., by encoding the commitment computation as a circuit).</p>

    <p class="text-gray-300">One obvious example of the problem of native compatibility in literature appears in the HyperPLONK paper [CBBZ23]. Here the authors, in order to achieve compatibility of lookups with multivariate polynomial commitments, need to redesign the Plookup lookup argument [GW20] (a lookup argument based on univariate encodings) for the multivariate setting. Through the solutions in this work, we can enable super-efficient lookups to be used in MLE-based SNARKS such as HyperPlonk and without the efficiency penalty due to the very general transformation above.</p>

    <p class="text-gray-300">4The table for SHA256 is of size approximately 2 and requires approximately the order of the few thousands lookups per input block [hbc]. The number of lookups stays low in applications where not many hashes are performed. This is not uncommon: see for example proofs of hashing-to-primes in the setting of proving set membership[BBF19, BCF+21].</p>

    <p class="text-gray-300">4</p>

    <h2 id="sec-7" class="text-2xl font-bold">1.1 Our Contributions</h2>

    <p class="text-gray-300">We contribute two constructions: the first one is a “direct” construction, while the second is a general compiler which effectively yields a family of constructions.</p>

    <p class="text-gray-300"><strong>Our first construction, <span class="math">\\mu</span>-seek</strong>: we propose a direct construction of super-efficient lookup arguments that are natively compatible with multilinear encodings. This construction is inspired by cq and we call it <span class="math">\\mu</span>-seek<span class="math">^{5}</span>. The construction is <em>modular</em> and can be instantiated with an appropriate multilinear polynomial commitment scheme (see Section 1.3.1 for a discussion).</p>

    <p class="text-gray-300">The starting point of <span class="math">\\mu</span>-seek is the technique of <em>cached quotients</em> in cq [EFG22]. The latter is an approach to efficiently compute at proving time a set of “committed quotients”<span class="math">^{6}</span>. One lens through which to describe our approach is this: by looking at cq as a “<em>Polynomial IOP</em>”<span class="math">^{7}</span>, it is possible to isolate the polynomial <span class="math">f</span> encoding the vector being looked up: this is the vector whose polynomial encoding will be provided through a commitment for multilinear polynomials. This change is not enough by itself. In fact, some of the checks on this polynomial in cq work through a polynomial equation that leverages the representation of <span class="math">f</span> as a univariate polynomial commitment. We then need to change how some of these checks are performed representing them as appropriate sumcheck equations and porting other polynomial commitments to the multilinear world.</p>

    <p class="text-gray-300">The resulting construction can be seen as a modular version of cq instantiable with a generic commitment scheme for multilinear polynomials with minimal requirements. The proving time is mostly dominated by one execution of the multivariate sumcheck protocol [GKR08] and computing two evaluation proofs of the multilinear polynomial commitment scheme. In Fig. 1 we describe a concrete breakdown of the performance of <span class="math">\\mu</span>-seek when instantiated with the polynomial commitment obtained by applying the Gemini compiler [BCHO22] on top of KZG [KZG10].</p>

    <p class="text-gray-300"><strong>Our generic compiler</strong>: our second contribution consists of a compiler which on input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>a super-efficient lookup argument over <em>univariate</em> polynomial commitments;</li>

      <li>a multivariate polynomial commitment;</li>

    </ul>

    <p class="text-gray-300">produces a super-efficient lookup argument over <em>multivariate</em> polynomial commitments. From a technical standpoint the compiler mostly consists of a sub-</p>

    <p class="text-gray-300">argument “linking” the two representations (respectively univariate and multivariate) of the looked up vector through a multivariate sumcheck. We refer the reader to Section 4 for a technical overview.</p>

    <p class="text-gray-300">Like <span class="math">\\mu</span>-seek, our compiler-based lookup argument is modular: it can be instantiated with an arbitrary multilinear polynomial commitment scheme and with an arbitrary lookup argument—the only compatibility requirement, for efficiency reasons, is that both work over the same finite field. From the efficiency standpoint, our compiler has a profile similar to that of <span class="math">\\mu</span>-seek: both require one sumcheck and a few proofs of evaluations for committed polynomials. Nonetheless, our compiler is slightly less efficient. Its (relatively) worse performance profile comes from its generality: it requires additional checks on top of a <em>black-box</em> lookup argument, whereas <span class="math">\\mu</span>-seek is designed to integrate cq’s framework within a multilinear framework as seamlessly as possible.</p>

    <h5 id="sec-8" class="text-base font-semibold mt-4">Applications to general-purpose SNARKs:</h5>

    <p class="text-gray-300">One of the applications of lookup arguments is to support general-purpose SNARKs into efficiently proving arbitrary computations that are hard to represent as a purely arithmetic set of constraints. As an additional contribution, we show how to integrate our flavor of lookup arguments with SNARKs for R1CS (Rank-One Constraint Systems), a popular form of <em>intermediate representations</em> for circuits. For this purpose, we introduce a simple intermediate abstraction—projective lookup arguments—and we show how to instantiate it in two different ways, through existing work and through simple adaptations of our techniques in specific settings.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">1.2 Related Work</h3>

    <p class="text-gray-300">Lookup arguments were introduced by Bootle, Cerulli, Groth, Jakobsen and Maller <em>[BCG^{+}18]</em>. The work of Gabizon and Williamson <em>[x11]</em>, called Plookup, sparked an interest in the development of lookup arguments for SNARKs based on the Kate et al. (commonly known as KZG) polynomial commitment scheme <em>[x20]</em>. In this research line, Caulk <em>[ZBK^{+}22a]</em> by Zapico et al. was the first to achieve a protocol where the prover complexity depends only logarithmically on the size of the bigger table, after preprocessing. A rapid sequence of works improved the prover’s efficiency of lookup arguments for KZG commitments: Caulk+ by Posen and Kattis <em>[x22]</em>, flookup by Gabizon and Khovratovich <em>[x12]</em>, Baloo <em>[ZGK^{+}22]</em> by Zapico et al., and cq by Eagen, Fiore, Gabizon <em>[x10]</em>. cq is among the most efficient and extremely succinct lookup arguments for arbitrary tables. Relying on the technique of logarithmic derivates of Haböck <em>[x15]</em> (which also appear in <em>[CHJ^{+}20, x13]</em>), it achieves proofs of constant size and a prover complexity proportional only to the size of the smaller vector. Recently Campanelli et al. <em>[CFF^{+}24]</em> proposed cq+, a version of cq with even smaller proofs and zero-knowledge capabilities (among other extensions). All these schemes require preprocessing and support the lookup of vectors committed using the KZG polynomial commitment, and thus are efficiently applicable to SNARKs based on KZG.</p>

    <p class="text-gray-300">Another important class of SNARKs rely on techniques based on the sum-check protocol [LFKN90] and multilinear polynomial commitments, e.g., [PST13]. To benefit of lookup capabilities, these schemes would need a lookup argument where the small vector is committed using a multilinear polynomial commitment. We mention a few works that address this problem. Hyperplonk [CBBZ23] gives a protocol for lookups inspired to Plookup [GW20]. Habock [Hab22] introduces the logarithmic derivatives technique and uses it to construct a lookup argument that, while asymptotically similar to that of Hyperplonk, is concretely more efficient, especially for multi-column lookups. In a subsequent work, Papini and Habock [PH23] shows a variant of Habock's protocol [Hab22] using the GKR protocol and then extends it work with vectors committed using a univariate polynomial commitment scheme. All these works, however, have prover complexity linear in the size of the table, and thus fail to achieve the super-efficiency property which is the goal of this work. Recently, Setty, Thaler and Wahby [STW24] introduced a new lookup argument, called Lasso, that achieves prover complexity sub-linear in the size of the table, albeit this holds only for a class of tables that they call "structured". In a nutshell, structured tables are tables that can be succinctly described when encoded with a multilinear polynomial. Lasso is extremely efficient, and in particular more efficient than cq, for this class of tables. On the other hand, when it comes to handling arbitrary tables outside the structured class, Lasso still fails to achieve super efficiency and is therefore asymptotically slower than our solutions.</p>

    <p class="text-gray-300">The concurrent work in [GNS24] has proposed dual polynomial commitment schemes which allows to link the opening in a univariate polynomial commitment with that in a multivariate one. Their techniques are radically different from the ones we apply in our compiler. We leave as an interesting future work direction to explore how to combine their approach with ours.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table-specific Preprocessing</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prover work group, field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verifier work</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MLE-compatible?</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plookup [GW20]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">5G1,9F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N),O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Halo2 [BGH19]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">6G1,5F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N),O(N log N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk [ZBK+22a]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">14G1,1G2,4F</td>

            <td class="px-3 py-2 border-b border-gray-700">15m,O(m3+m log(N))</td>

            <td class="px-3 py-2 border-b border-gray-700">4P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Caulk+ [PK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">7G1,1G2,2F</td>

            <td class="px-3 py-2 border-b border-gray-700">8m,O(m2)</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">flookup [GK22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log3N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">7G1,1G2,4F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m),O(m log3m)</td>

            <td class="px-3 py-2 border-b border-gray-700">3P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baloo [ZGK+22]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">12G1,1G2,4F</td>

            <td class="px-3 py-2 border-b border-gray-700">14m,O(m log3m)</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">cq+ [CFF+24]</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">7G1,1F</td>

            <td class="px-3 py-2 border-b border-gray-700">8m,O(m log m)</td>

            <td class="px-3 py-2 border-b border-gray-700">5P</td>

            <td class="px-3 py-2 border-b border-gray-700">X</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lasso w/ KZG + Gemini (unstructured table) [STW24]</td>

            <td class="px-3 py-2 border-b border-gray-700">-</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log m)G1O(log m)F</td>

            <td class="px-3 py-2 border-b border-gray-700">(c+1)m+cN†,O(m+N)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P O(log m)F</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">this work μ-seek w/ KZG + Gemini</td>

            <td class="px-3 py-2 border-b border-gray-700">O(N log N) exps</td>

            <td class="px-3 py-2 border-b border-gray-700">2(log m+3)G16(log m+1)F</td>

            <td class="px-3 py-2 border-b border-gray-700">O(m),O(m)</td>

            <td class="px-3 py-2 border-b border-gray-700">2P O(log m)G1</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Fig. 1. Comparison among different lookup arguments. Our proof sizes include optimizations through batching techniques. A comparison with Lasso for structured tables is in Section 1.3.3.</p>

    <p class="text-gray-300">7</p>

    <h2 id="sec-10" class="text-2xl font-bold">1.3 Discussion</h2>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">1.3.1 On the generality of our constructions</h3>

    <p class="text-gray-300">Our two constructions offer some flexibility on the choice of the multivariate polynomial commitment scheme through which to commit the vector to be looked up. For <span class="math">\\mu</span>-seek the only constraint this multivariate polynomial commitment mPC needs to satisfy has to do with the field <span class="math">\\mathbb{F}</span> of the underlying univariate polynomial commitment uPC in the construction (KZG). In particular, mPC will have to support the same field <span class="math">\\mathbb{F}</span>. A similar constraint holds for our general compiler: mPC needs to be over the same field as the underlying univariate polynomial commitment in the lookup argument in input.</p>

    <p class="text-gray-300">There are several instantiation candidates that satisfy these conditions. Possible candidates include: the multivariate version of KZG, i.e., the PST commitment scheme [PST13]; the commitment scheme obtained by applying the Gemini compiler to KZG [BCHO22]; the Testudo polynomial commitment [CGG⁺23]; any field-agnostic multivariate polynomial commitment scheme like Orion [XZS22] or Brakedown [GLS⁺23].</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">1.3.2 SNARKs compatible with our constructions</h3>

    <p class="text-gray-300">The promise of natively compatible lookup arguments is to easily augment general purpose SNARKs with lookups through easy “plug-and-play” composition. Our work proposes constructions that are compatible with SNARKs where the proof includes a multivariate polynomial commitment to the witness, i.e., the proof can be parsed as a <span class="math">(\\mathsf{cm},\\pi_{\\mathrm{rst}})</span> where cm is a commitment to the witness through a multivariate polynomial commitment mPC.</p>

    <p class="text-gray-300">We cite two such examples of constructions with this property. One is HyperPLONK [CBBZ23], a multivariate version of PLONK. Here we can apply the <span class="math">\\mu</span>-seek construction instantiated with whichever mPC we use as underlying polynomial commitment scheme for HyperPLONK (e.g., KZG+Gemini). Another example is Testudo [CGG⁺23], a hybrid of Groth16 [Gro16], Spartan [Set20] and Inner Product Arguments [BMM⁺21] with short CRSs and optimized for data-parallel computations. Here we can apply <span class="math">\\mu</span>-seek instantiated with the Testudo polynomial commitment scheme as mPC.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.3.3 Detailed comparison with Lasso</h3>

    <p class="text-gray-300">For the general case of “unstructured” tables, we have pointed out that Lasso has a cost profile that grows linearly with the table size <span class="math">N</span> in terms of field operations, and sublinearly in terms of group operations (<span class="math">O(cN^{1/c})</span> for an arbitrary constant <span class="math">c</span>). These group operations, it should be noted, are mostly exponentiations with small exponents. In the case of “structured” tables Lasso will avoid this linear cost, but will still</p>

    <p class="text-gray-300">8This approach has been explicitly studied and successfully applied in several works [CHA22, CFF⁺21, ABC⁺22, CHAK23, FT22, CFQ19, AGM18, BCF⁺21, CFH⁺22, CEO22, CHAK24, RMH⁺24].</p>

    <p class="text-gray-300">9Loosely defined as tables that have a succinct representation allowing the verifier to evaluate the multilinear extension of <span class="math">T</span> on its own.</p>

    <p class="text-gray-300">pay <span class="math">O(cN^{1/c})</span> group operations (again, with the caveat above about the size of the exponents). On the other hand, our construction <span class="math">\\mu</span>-seek, thanks to preprocessing, has proving time which is <em>independent</em> of <span class="math">N</span>. Because our protocol is heavier in group operations than Lasso, it is hard to estimate where this asymptotic advantage translates in a real advantage in practical applications, especially in the case of unstructured tables where Lasso is already sublinear.</p>

    <p class="text-gray-300">We remark, however, that there are several interesting applications that could benefits from efficient lookups over unstructured tables. One is floating point arithmetic, which is particularly relevant in the case of verifiable machine learning (a table of size <span class="math">2^{32}</span> for 16-bit floating point arithmetic). Another is using lookups to implement fetching the next instruction in a zkVM program: in this case the table is the sequence of instructions and could be arbitrary.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Outline of this paper</h4>

    <p class="text-gray-300">In Section 2 we present preliminaries on some of the abstractions we will adopt (the language of commit-and-prove SNARKs and polynomial commitments formalized under that language) as well as background on some of our basic techniques, including multivariate sumchecks. In Section 3 we present our main construction, <span class="math">\\mu</span>-seek. Our generic compiler is presented in Section 4. In Section 5 we describe methods to augment SNARKs for R1CS with some of the lookup arguments presented in this paper.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.1 Notation</h3>

    <p class="text-gray-300">We denote the security parameter by <span class="math">\\lambda</span> and a negligible function by <span class="math">\\textsf{negl}(\\lambda)</span>. If <span class="math">m\\in\\mathbb{N}</span> we denote by <span class="math">[m]</span> the set <span class="math">\\{1,2,\\ldots,m\\}</span>. If <span class="math">\\mathbf{X}=(X_{1},\\ldots,X_{\\mu})</span> is a vector of <span class="math">\\mu</span> formal variables and <span class="math">I\\subseteq[\\mu]</span> then we denote by <span class="math">\\mathbf{X}^{I}</span> the monomial <span class="math">\\prod_{i\\in I}X_{i}</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.2 Commit-and-Prove SNARKs <em>[x10]</em></h3>

    <p class="text-gray-300">A commitment scheme is a tuple of algorithm <span class="math">\\mathsf{CS}=(\\mathsf{KGen},\\mathsf{Com})</span> where the first algorithm samples a commitment key ck and the second algorithm, upon input of the commitment key, a message <span class="math">p</span> and opening material <span class="math">o</span>, outputs a commitment c. The basic notions of security for the commitment scheme are (perfect) <em>hiding</em> and (computational) <em>binding</em>. The former property states that no (unbounded) adversary can distinguish commitments of two different messages when the opening materials are sampled at random from their domain, the latter property states that no (polynomial time) adversary, upon input of the commitment key, can find two different messages and two opening materials that commit to the same commitment. We will not require hiding in this work.</p>

    <p class="text-gray-300">Following Groth et al.<em>[GKM^{+}18]</em>, we define a relation <span class="math">\\mathcal{R}</span> verifying triple <span class="math">(\\mathsf{pp};x;w)</span>. We say that <span class="math">w</span> is a witness to the instance <span class="math">x</span> being in the relation defined by the parameters <span class="math">\\mathsf{pp}</span> when <span class="math">(\\mathsf{pp};x;w)\\in\\mathcal{R}</span> (equivalently, we sometimes write <span class="math">\\mathcal{R}(\\mathsf{pp};x;w)=1</span>). For example, the parameters <span class="math">\\mathsf{pp}</span> could be the description of a bilinear group, or additionally contain a commitment key for a commitment scheme or a common reference string (for lookup arguments we will include in <span class="math">\\mathsf{pp}</span> the lookup table at hand). Whenever it is clear of the context, we will write <span class="math">\\mathcal{R}(x;w)</span> as a shortcut for <span class="math">\\mathcal{R}(\\mathsf{pp};x;w)</span>.</p>

    <p class="text-gray-300">Briefly speaking, Commit-and-Prove SNARKs (CP-SNARKs) are zkSNARKs whose relations verify predicates over commitments <em>[x10]</em>. Given a commitment scheme <span class="math">\\mathsf{CS}</span>, we consider relations <span class="math">\\mathcal{R}</span> whose instances are of the form <span class="math">x=((\\mathsf{c}_{j})_{j\\in[\\ell]},\\hat{x})</span>, where we can unambiguously parse the witness as <span class="math">w=((p_{j})_{j\\in[\\ell]},(o_{j})_{j\\in[\\ell]})</span> for some <span class="math">\\ell\\in\\mathbb{N}</span>. Here, <span class="math">p_{j}</span> is in the domain of a commitment scheme <span class="math">\\mathsf{CS}</span> for all <span class="math">j</span> (with <span class="math">o_{j}</span> being the corresponding opening) and there exists a polynomial time relation <span class="math">\\hat{\\mathcal{R}}</span> such that for <span class="math">\\hat{w}=(p_{j})_{j\\in[\\ell]}</span> and a tuple <span class="math">\\mathsf{pp}</span> (which includes the commitment key <span class="math">\\mathsf{ck}</span> of <span class="math">\\mathsf{CS}</span>) we have:</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}(\\mathsf{pp};x;w)=1\\iff\\hat{\\mathcal{R}}(\\mathsf{pp};\\hat{x};\\hat{w})=1\\wedge\\forall j\\in[\\ell]:\\mathsf{c}_{j}=\\mathsf{Com}(\\mathsf{ck},p_{j},o_{j}).</span></p>

    <p class="text-gray-300">We refer to a relation <span class="math">\\hat{\\mathcal{R}}</span> as derived above as a <em>Commit-and-Prove</em> (CP) relation. Given a CP-relation <span class="math">\\hat{\\mathcal{R}}</span> and a commitment scheme <span class="math">\\mathsf{CS}</span>, we can easily derive the <em>associated</em> NP-relation <span class="math">\\mathcal{R}</span>. Instances of NP-relations may contain only commitments. Therefore, using the notation above, the instances of the associated CP-relation are empty strings <span class="math">\\varepsilon</span>, namely, <span class="math">\\hat{\\mathcal{R}}</span> is a predicate over the committed witness. To avoid cluttering the notation, in these cases, we may omit the (empty) instance and simply write <span class="math">\\hat{\\mathcal{R}}(\\mathsf{pp},\\hat{w})</span>.</p>

    <p class="text-gray-300">A CP-SNARK for <span class="math">\\hat{\\mathcal{R}}</span> over a commitment scheme <span class="math">\\mathsf{CS}</span> is a zkSNARK for the associated relation <span class="math">\\mathcal{R}</span> as described above. More in detail, we consider a tuple of algorithms <span class="math">\\mathsf{CP}=(\\mathsf{Setup},\\mathsf{Prove},\\mathsf{Verify})</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(\\mathsf{ck})\\to\\mathsf{srs}</span> is a probabilistic algorithm that takes as input a commitment key <span class="math">\\mathsf{ck}</span> for <span class="math">\\mathsf{CS}</span> and it outputs <span class="math">\\mathsf{srs}\\coloneqq(\\mathsf{ek},\\mathsf{vk},\\mathsf{pp})</span>, where <span class="math">\\mathsf{ek}</span> is the evaluation key, <span class="math">\\mathsf{vk}</span> is the verification key, and <span class="math">\\mathsf{pp}</span> are the parameters for the relation <span class="math">\\mathcal{R}</span> (which include the commitment key <span class="math">\\mathsf{ck}</span>).</li>

      <li><span class="math">\\mathsf{Prove}(\\mathsf{ek},x,w)\\to\\pi</span> takes an evaluation key <span class="math">\\mathsf{ek}</span>, a statement <span class="math">x</span>, and a witness <span class="math">w</span> such that <span class="math">\\mathcal{R}(\\mathsf{pp},x,w)</span> holds, and returns a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">\\mathsf{Verify}(\\mathsf{vk},x,\\pi)\\to b</span> takes a verification key, a statement <span class="math">x</span>, and either accepts <span class="math">(b=1)</span> or rejects <span class="math">(b=0)</span> the proof <span class="math">\\pi</span>.</li>

    </ul>

    <p class="text-gray-300">In some cases, the <span class="math">\\mathsf{Setup}</span> algorithm would simply (and deterministically) re-parse the commitment key <span class="math">\\mathsf{ck}</span> information. In these cases, we might omit <span class="math">\\mathsf{Setup}</span> and refer to the CP-SNARK as a tuple of two algorithms.</p>

    <p class="text-gray-300">We require a CP-SNARK to be correct and knowledge sound.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 1 (Correctness).</h6>

    <p class="text-gray-300">A CP-SNARK is correct if for any <span class="math">\\mathsf{pp},x,w</span> such that <span class="math">\\mathcal{R}(\\mathsf{pp},x,w)=1</span> then</p>

    <p class="text-gray-300">\\[ \\Pr\\begin{bmatrix}\\mathsf{ck}\\leftarrow\\mathsf{CS.KGen}(1^{\\lambda},d);\\mathsf{srs}\\leftarrow\\mathsf{CP.Setup}(\\mathsf{ck});\\\\ \\pi\\leftarrow\\mathsf{CP.Prove}(\\mathsf{srs},\\mathsf{pp},x,w);\\\\ \\mathsf{CP.Verify}(\\mathsf{srs},\\mathsf{pp},x,\\pi)=1\\end{bmatrix}=1 \\]</p>

    <h6 id="sec-19" class="text-base font-medium mt-4">Definition 2 (Knowledge Soundness).</h6>

    <p class="text-gray-300">A CP-SNARK is knowledge extractableif for any PPT adversary <span class="math">\\mathcal{A}</span>, there exists a polynomial-time (not necessarily uniform) extractor <span class="math">\\mathcal{E}</span> such that:</p>

    <p class="text-gray-300">\\[ \\Pr\\begin{bmatrix}\\mathsf{ck}\\leftarrow\\mathsf{CS.KGen}(1^{\\lambda},d);\\mathsf{srs}\\leftarrow\\mathsf{CP.Setup}(\\mathsf{ck});\\\\ (x,\\pi)\\leftarrow\\ \\mathcal{A}(\\mathsf{srs});w\\leftarrow\\ \\mathcal{E}(\\mathsf{srs})\\\\ \\mathsf{CP.Verify}(\\mathsf{srs},x,\\pi)=1\\wedge\\neg\\mathcal{R}(\\mathsf{pp},x,w)\\end{bmatrix}\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Indexed Relations and Universal CP-SNARKs</h4>

    <p class="text-gray-300">We extend the notion of relations to indexed relations <em>[CHM^{+}20]</em>. We define a polynomial-time indexed relation <span class="math">\\mathcal{R}</span> verifying tuple <span class="math">(\\mathsf{pp},ind,x,w)</span>. We say that <span class="math">w</span> is a witness to the instance <span class="math">x</span> being in the relation defined by the <span class="math">\\mathsf{pp}</span> and index <span class="math">ind</span> when <span class="math">(\\mathsf{pp},ind,x,w)\\in\\mathcal{R}</span> (equivalently, we sometimes write <span class="math">\\mathcal{R}(\\mathsf{pp},ind,x,w)=1</span>).</p>

    <p class="text-gray-300">Briefly, we say that a CP-SNARK is <em>universal</em> if there exists a deterministic algorithm <span class="math">\\mathsf{Derive}</span> that takes as input an <span class="math">\\mathsf{srs}</span> and an index <span class="math">ind</span>, and outputs a specialized reference string <span class="math">\\mathsf{srs}_{ind}=(\\mathsf{vk}_{ind},\\mathsf{ek}_{ind})</span> where <span class="math">\\mathsf{vk}_{ind}</span> is a succinct verification key and <span class="math">\\mathsf{ek}_{ind}</span> is a proving key for such an index. Moreover, we require that the verifier <span class="math">\\mathsf{Verify}</span> (resp. the <span class="math">\\mathsf{P}</span>) of a Universal CP-SNARK takes as additional input the specialized verification key <span class="math">\\mathsf{vk}_{ind}</span> (resp. the specialized <span class="math">\\mathsf{ek}_{ind}</span>).</p>

    <p class="text-gray-300">Consider the relation <span class="math">\\mathcal{R}^{\\prime}</span> such that <span class="math">\\mathcal{R}^{\\prime}(\\mathsf{pp},(ind,x),w)\\iff\\mathcal{R}(\\mathsf{pp},ind,x,w)</span>, the tuple of algorithms <span class="math">(\\mathsf{KGen,Prove,Verify}^{\\prime})</span> is an argument system for the relation <span class="math">\\mathcal{R}^{\\prime}</span> and <span class="math">\\mathsf{Verify}^{\\prime}</span> is the algorithm that upon input <span class="math">\\mathsf{srs}</span>, instance <span class="math">(ind,x)</span> and a proof <span class="math">\\pi</span>, first runs <span class="math">\\mathsf{Derive}</span> on <span class="math">\\mathsf{srs}</span> and index <span class="math">ind</span>, then runs <span class="math">\\mathsf{Verify}(\\mathsf{vk}_{ind},x,\\pi)</span>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">2.3 Lookup arguments</h3>

    <p class="text-gray-300">We formalize lookup arguments as CP-SNARKs for the indexed relation</p>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{lookup}}:=\\left\\{(\\mathsf{t};\\hat{\\mathsf{c}}_{\\mathsf{f}};(\\mathsf{f},o_{\\mathsf{f}})):\\mathsf{f}\\prec\\mathsf{t}\\wedge\\mathsf{c}_{\\mathsf{f}}=\\mathsf{Com}(\\mathsf{ck},\\mathsf{f},o_{\\mathsf{f}})\\right\\}</span></p>

    <p class="text-gray-300">where we write <span class="math">\\mathbf{f}\\prec\\mathbf{t}</span> to compactly denote that there exists a (multi) set <span class="math">K=\\{k_{1},\\ldots,k_{n}\\}\\subseteq[N]</span> such that for every <span class="math">j\\in[n]</span> <span class="math">\\mathbf{f}_{j}=\\mathbf{t}_{k_{j}}</span>.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">2.4 Polynomial Commitment Schemes</h3>

    <p class="text-gray-300">We define polynomial commitments using the CP-SNARKs framework. We will not require hiding properties from the commitments schemes. Below <span class="math">\\mathbb{F}</span> denotes a</p>

    <p class="text-gray-300">finite field which will be defined by the context in which we use them. We assume that parameters of the polynomials being committed (such as maximum degree or maximum number of variables) are determined by an appropriate function of the security parameters <span class="math">\\lambda</span>.</p>

    <p class="text-gray-300"><strong>Definition 3 (Univariate polynomial commitment).</strong> A univariate polynomial commitment scheme is a pair <span class="math">(\\mathsf{uPC},\\mathsf{CP}_u)</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{uPC} = (\\mathsf{KGen},\\mathsf{Com})</span> is a binding commitment scheme whose message space is <span class="math">\\mathbb{F}^{&amp;lt;d}[X]</span> where <span class="math">d</span> is a function of the security parameter <span class="math">\\lambda</span>.</li>

      <li><span class="math">\\mathsf{CP}_u</span> is a CP-SNARK over <span class="math">\\mathsf{uPC}</span> for the relation <span class="math">\\mathcal{R}_{eval}(x,y;p) := &quot;p(x) = y&quot;</span>.</li>

    </ul>

    <p class="text-gray-300"><strong>Definition 4 (Multilinear polynomial commitment).</strong> A multilinear polynomial commitment scheme is a pair <span class="math">(\\mathsf{mPC},\\mathsf{CP}_m)</span> where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{mPC} = (\\mathsf{KGen},\\mathsf{Com})</span> is a binding commitment scheme whose message space is <span class="math">\\mathbb{F}[X_1,\\ldots ,X_\\mu ]</span> of multivariate polynomials of individual degree 1 where <span class="math">\\mu</span> is a function of the security parameter <span class="math">\\lambda</span>.</li>

      <li><span class="math">\\mathsf{CP}_m</span> is a CP-SNARK over <span class="math">\\mathsf{mPC}</span> for the evaluation relation <span class="math">\\mathcal{R}_{eval}((x_i)_{i\\in [\\mu ]},y;p) := &quot;p(x_1,\\ldots ,x_\\mu) = y&quot;</span>.</li>

    </ul>

    <p class="text-gray-300">For <span class="math">\\mathsf{mPC}</span> we overload notation and use it to commit to vectors by writing <span class="math">\\mathsf{mPC}.\\mathsf{Com}(\\mathsf{ck},\\mathsf{f})</span> as a shortcut notation for <span class="math">\\mathsf{mPC}.\\mathsf{Com}(\\mathsf{ck},\\tilde{f})</span> where <span class="math">\\tilde{f}\\in \\mathbb{F}[X_1,\\ldots ,X_\\mu ]</span> is the unique multilinear extension of vector <span class="math">\\mathbf{f}\\in \\mathbb{F}^n</span>, i.e., the unique polynomial such that for all <span class="math">\\mathbf{b}\\in \\{0,1\\}^\\mu</span> we have <span class="math">\\tilde{f} (\\mathbf{b}) = \\mathbf{f}_{\\sum_j b_j2^j}</span>, with <span class="math">\\mu = \\log n</span>.</p>

    <h2 id="sec-23" class="text-2xl font-bold">2.5 (Vanilla) Sumcheck Protocol</h2>

    <p class="text-gray-300">Let <span class="math">p(X_1, \\ldots, X_\\mu)</span> be a multilinear<span class="math">^{11}</span> polynomial in <span class="math">\\mu</span> variables defined over a field <span class="math">\\mathbb{F}</span>. Consider the value <span class="math">a = \\sum_{\\mathbf{b} \\in \\{0,1\\}^\\mu} p(\\mathbf{b})</span>, i.e., the sum of the value of <span class="math">p</span> on all the vertices of the Boolean hypercube. This computation takes <span class="math">n = 2^\\mu</span> time and the sumcheck protocol [LFKN90] described in Figure 2, is a way for a Prover to convince a Verifier that <span class="math">a</span> is correct in <span class="math">O(\\mu)</span> time, plus a single query to the polynomial <span class="math">p</span> on a random point in <span class="math">\\mathbb{F}^\\mu</span>.</p>

    <h2 id="sec-24" class="text-2xl font-bold">2.6 Generalized Sumcheck Protocol</h2>

    <p class="text-gray-300">In the previous section we described a sumcheck protocol for the case where the verifier has oracle access to the polynomial in the sum. In some cases, this polynomial will not be available "directly" to the verifier. This is the case, for example, if the verifier is interested in checking the sum</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{\\mathbf{b}} (p(\\mathbf{b}) + \\gamma) \\cdot q(\\mathbf{b}) \\cdot f(\\mathbf{b}) + f&#x27;(\\mathbf{b}) \\cdot t(\\mathbf{b}) \\tag{1}</span></div>

    <p class="text-gray-300"><span class="math">^{11}</span>We only care about multilinear polynomials for the context of this work but the sumcheck protocol can be run on any multivariate polynomial (with a different efficiency profile).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2. The Sumcheck Protocol</p>

    <p class="text-gray-300">where  <span class="math">p, q, t</span>  are polynomials for which the verifier has a commitment,  <span class="math">\\gamma</span>  is a public value and  <span class="math">f, f&#x27;</span>  are public polynomials that the verifier can compute on their own.</p>

    <p class="text-gray-300">Here we define a sumcheck protocol for the generalized sumcheck relation for expressions like the above and that allows for committed polynomials. The relation is parametrized by a (multilinear) polynomial commitment  <span class="math">\\mathsf{PC}</span>  and is defined as follows:</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a></p>

    <p class="text-gray-300">Above,  <span class="math">d</span>  is a natural number, the  <span class="math">f_{k}</span> -s are public multilinear polynomials and the  <span class="math">\\mathcal{I}_k</span>  are subsets of  <span class="math">[\\ell]</span> . All these elements are used to describe the public expression <span class="math">^{12}</span>  (such as the one in Eq. (1)) on which we are performing the sumcheck.</p>

    <p class="text-gray-300">A protocol for  <span class="math">\\mathcal{R}_{\\mathrm{SC}}</span>  is described in Fig. 3. This protocol is folklore. For its security analysis we refer the reader to [CFQ19, Section 5.2].</p>

    <p class="text-gray-300">Remark 1 (On Notation for proving/verifying  <span class="math">\\mathcal{R}_{SC}</span> ). The formal description of the statements for  <span class="math">\\mathcal{R}_{\\mathrm{SC}}</span>  is quite involved when expressed through the subsets  <span class="math">\\mathcal{I}_k</span>  as above. Nonetheless the expressions proved are often simple enough and</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>P and V run the protocol in Fig. 2 with polynomial <span class="math">p(\\mathbf{X}) := \\sum_{k=1}^{d} f_k(\\mathbf{X}) \\cdot \\prod_{j \\in \\mathcal{J}_k} g_j(\\mathbf{X})</span>. On the last round, since the verifier has no direct access to <span class="math">p</span> it proceeds to compute <span class="math">p(r_1, \\ldots, r_\\mu)</span> through the following steps.</li>

      <li>P sends V the tuples <span class="math">(y_i, \\pi_i)_{i \\in [\\ell]}</span> where <span class="math">y_i = g_i(r_1, \\ldots, r_\\mu)</span> and <span class="math">\\pi_i</span> is a polynomial evaluation proof that <span class="math">y_i = g_i(r_1, \\ldots, r_\\mu)</span>.</li>

      <li>V checks each pair <span class="math">(y_i, \\pi_i)</span> with respect to commitment <span class="math">c_i</span></li>

      <li>V computes <span class="math">y^{<em>} = \\sum_{k=1}^{d} f_{k}(r_{1}, \\ldots, r_{\\mu}) \\cdot \\prod_{j \\in \\mathcal{J}_{k}} y_{j}</span> and checks that <span class="math">y^{</em>} = p_{\\mu-1}(r_{\\mu})</span> (where <span class="math">p_{\\mu-1}</span> is defined as in Fig. 2)</li>

    </ol>

    <p class="text-gray-300">Fig. 3. The Generalized Sumcheck Protocol for <span class="math">\\mathcal{R}_{\\mathrm{SC}}</span>.</p>

    <p class="text-gray-300">their formal representation should be immediate to the reader. For this reason, in our protocols, we adopt a more readable solution whenever proving/verifying <span class="math">\\mathcal{R}_{\\mathrm{SC}}</span>: we simply provide a description of the expression we are proving in the pseudocode and make explicit the public/witness inputs to be passed to the SNARK algorithms.</p>

    <p class="text-gray-300"><strong>Proof size</strong> The proof size of the protocol in Fig. 3 is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ell \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_ {\\mathrm {m P C}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\mu (\\ell + 2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ \\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is the size of one opening proof for the multilinear polynomial commitment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In this section we describe our construction <span class="math">\\mu</span>-seek of a lookup argument for multilinear polynomial commitments. Namely, given a commitment scheme mPC for multilinear polynomials, <span class="math">\\mu</span>-seek is a CP-SNARK for the following indexed relation</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\text {l o o k u p}} := \\left\\{\\left(\\mathbf {t}; \\hat {\\mathbf {c}} _ {\\mathbf {f}}; \\mathbf {f}\\right): \\mathbf {f} \\prec \\mathbf {t}, \\hat {\\mathbf {c}} _ {\\mathbf {f}} = \\mathrm {m P C}. \\operatorname {C o m} (\\mathrm {c k}, \\mathbf {f}) \\right\\} \\tag {2}</span></div>

    <p class="text-gray-300"><strong>Remark 2.</strong> In the relation above we do not explicitly include <span class="math">N</span> and <span class="math">n</span>, the table and lookup vector size in order to simplify notation. These are, however, assumed to be parameters of the relation and can be embedded in the evaluation and verification keys.</p>

    <p class="text-gray-300">The main ingredients of our construction are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment scheme <span class="math">\\mathsf{mPC}</span> for multilinear polynomials with <span class="math">\\mu = \\log n</span> variables. This is the scheme we use for committing to the vectors of which we want to test lookup relations (and thus also the vectors to be used in larger SNARK protocols). To commit to a vector <span class="math">\\mathbf{f}</span> we use its unique multilinear extension <span class="math">\\tilde{f}</span> (see below).</li>

      <li>A CP-SNARK <span class="math">\\mathsf{CP}_{SC}</span> for the generalized sumcheck relation over polynomials committed with <span class="math">\\mathsf{mPC}</span>. As mentioned in Section 2.6, <span class="math">\\mathsf{CP}_{SC}</span> can be in turn realized from a CP-SNARK <span class="math">\\mathsf{CP}_m</span> for the basic polynomial evaluation functionality.</li>

      <li>The KZG polynomial commitment for univariate polynomials of degree <span class="math">&amp;lt; N</span>. We use KZG to commit to the table <span class="math">\\mathbf{t}</span> and store this commitment in the verification key <span class="math">\\mathsf{vk}_{\\mathbf{t}}</span> for the indexed relation defined by <span class="math">\\mathbf{t}</span>. We commit to <span class="math">\\mathbf{t}</span> using Lagrange interpolation over a multiplicative subgroup <span class="math">\\mathbb{K} \\subset \\mathbb{F}</span> of order <span class="math">N</span>. We emphasize that KZG is not the main commitment scheme of <span class="math">\\mu</span>-seek; it rather acts as an auxiliary building block for our protocol.</li>

    </ul>

    <p class="text-gray-300">For these building blocks to work together we only require that mPC supports polynomials over the same finite field <span class="math">\\mathbb{F}</span> used in KZG.</p>

    <p class="text-gray-300">Notation and preliminaries For a vector <span class="math">\\mathbf{v} \\in \\mathbb{F}^n</span>, its multilinear extension, denoted <span class="math">\\tilde{v}</span>, is the unique polynomial that evaluates to <span class="math">\\mathbf{v}</span> on the boolean hypercube, i.e., for <span class="math">\\mu = \\log n</span>, <span class="math">\\tilde{v} \\in \\mathbb{F}[X_1, \\ldots, X_\\mu]</span> such that for all <span class="math">\\mathbf{b} \\in \\{0, 1\\}^\\mu \\tilde{v}(\\mathbf{b}) = \\mathbf{f}_{\\sum_j b_j 2^j}</span>.</p>

    <p class="text-gray-300">To commit a vector with mPC we use multilinear extensions; nevertheless we abuse notation and write <span class="math">\\mathsf{mPC.Com}(\\mathsf{ck},\\mathbf{v})</span> as a shortcut for <span class="math">\\mathsf{mPC.Com}(\\mathsf{ck},\\tilde{v})</span> where <span class="math">\\tilde{v}</span> is <span class="math">\\mathbf{v}</span>'s multilinear extension.</p>

    <p class="text-gray-300">Let <span class="math">\\mathbb{K} \\subset \\mathbb{F}</span> be a multiplicative subgroup of order <span class="math">N</span>, and let <span class="math">\\omega</span> be a fixed generator of <span class="math">\\mathbb{K}</span>. Then we denote by <span class="math">\\nu_{\\mathbb{K}}(X) = (X^{N} - 1)</span> the vanishing polynomial of <span class="math">\\mathbb{K}</span>, and by <span class="math">\\lambda_j^{\\mathbb{K}}(X) = \\nu_{\\mathbb{K}}(X)\\omega_N^{j-1} / (N(X - \\omega_N^{j-1}))</span> the Lagrange polynomials of <span class="math">\\mathbb{K}</span>. To commit to a vector <span class="math">\\mathbf{t} \\in \\mathbb{F}^N</span> with KZG, we use the polynomial <span class="math">\\mathsf{T}(X) = \\sum_j \\mathbf{t}_j \\cdot \\lambda_j^{\\mathbb{K}}(X)</span>.</p>

    <p class="text-gray-300">We use the univariate sumcheck lemma from Aurora [BCR⁺19] and the following lemma from [Hab22].</p>

    <p class="text-gray-300"><strong>Lemma 1 (Univariate Sumcheck, [BCR⁺19])</strong>. Let <span class="math">\\mathbb{H}</span> be multiplicative subgroup of <span class="math">\\mathbb{F}</span> of order <span class="math">n</span>. For any <span class="math">P(X)</span> of degree <span class="math">&amp;lt; n</span> we have</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i} P(\\omega_{n}^{i}) = n \\cdot P(0)</span></div>

    <p class="text-gray-300"><strong>Lemma 2 (Set inclusion, [Hab22])</strong>. Let <span class="math">\\mathbb{F}</span> be a field of characteristic <span class="math">p &amp;gt; N</span>, and suppose that <span class="math">(a_i)_{i=1}^N</span>, <span class="math">(b_i)_{i=1}^N</span> are arbitrary sequences of field elements. Then <span class="math">\\{a_i\\} \\subseteq \\{b_i\\}</span> as sets (with multiples of values removed), if and only if there exists a sequence <span class="math">(m_i)_{i=1}</span> of field elements from <span class="math">\\mathbb{F}_p \\subseteq \\mathbb{F}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_{i=1}^N \\frac{1}{X - a_i} = \\sum_{i=1}^N \\frac{m_i}{X - b_i} \\tag{3}</span></div>

    <p class="text-gray-300">in the function field <span class="math">\\mathbb{F}(X)</span>. Moreover, we have equality of the sets <span class="math">\\{a_i\\} = \\{b_i\\}</span>, if and only if <span class="math">m_i \\neq 0</span>, for every <span class="math">i = 1, \\ldots, N</span>.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">Bilinear groups</p>

    <p class="text-gray-300">Finally, our construction relies on type-3 bilinear groups that are defined by a tuple <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,P_{1},P_{2})</span> where <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> are groups of prime order <span class="math">q</span>, and we set <span class="math">\\mathbb{F}=\\mathbb{Z}_{q}</span>. <span class="math">P_{1},P_{2}</span> are generators of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span>. <span class="math">e\\colon\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span> is an efficiently-computable non-degenerate bilinear map, and there is no efficiently computable isomorphism between <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. We use the implicit notation <span class="math">[a]_{i}\\coloneqq aP_{i}</span>, for elements in <span class="math">\\mathbb{G}_{i},i\\in\\{1,2,T\\}</span> and set <span class="math">P_{T}\\coloneqq e(P_{1},P_{2})</span>.</p>

    <p class="text-gray-300">For security we rely that in these groups the Power Discrete Logarithm assumption, defined below, holds.</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 5 (Power Discrete Logarithm <em>[x12]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">d_{1}(\\lambda),d_{2}(\\lambda)\\in\\mathsf{poly}</span>. The <span class="math">(d_{1},d_{2})</span>-PDL (Power Discrete Logarithm) assumption holds in the group described by <span class="math">(q,\\mathbb{G}_{1},\\mathbb{G}_{2},\\mathbb{G}_{T},e,P_{1},P_{2})</span> if for any non-uniform PPT <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Adv}^{\\mathrm{ndl}}_{d_{1},d_{2},\\mathcal{A}}(\\lambda):=\\Pr\\Big{[}s\\leftarrow\\sharp\\mathbb{F}^{*}:\\mathcal{A}\\left(\\mathsf{pp},\\left[(s^{i})_{i=0}^{d_{1}}\\right]_{1},\\left[(s^{i})_{i=0}^{d_{2}}\\right]_{2}\\right)=s\\,\\Big{]}=\\mathsf{negl}(\\lambda)\\enspace.</span></p>

    <p class="text-gray-300">Finally, we prove the security of our construction in the algebraic group model <em>[x10]</em>. An algorithm <span class="math">\\mathcal{A}</span> is called <em>algebraic</em> if for all group elements that <span class="math">\\mathcal{A}</span> outputs, it additionally provides the representation relative to all previously received group elements. That is, if <span class="math">\\mathbf{h}\\in\\mathbb{G}_{i}^{N}</span> is the list of group elements received by <span class="math">\\mathcal{A}</span>, then for any group element <span class="math">\\mathsf{z}\\in\\mathbb{G}_{i}</span> returned in output, the adversary must also provide a vector <span class="math">\\mathbf{c}\\in\\mathbb{F}^{N}</span> such that <span class="math">\\mathsf{z}=\\langle\\mathbf{c},\\mathbf{h}\\rangle</span>.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Our protocol</h4>

    <p class="text-gray-300">The protocol is described in Figure 4. Below we provide a textual description of its main steps along with some intuitive explanations.</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Setup</h4>

    <p class="text-gray-300">We assume a universal SRS that consists of an SRS for <span class="math">\\mathsf{KZG}</span>, <span class="math">\\mathsf{srs}_{\\mathsf{KZG}}=(\\left[(s^{j})_{j=0}^{N-1}\\right]_{1},\\left[(s^{j})_{j=0}^{N}\\right]_{2})</span>, and an SRS <span class="math">\\mathsf{srs}_{\\mathsf{mPC}}</span> for the <span class="math">\\mathsf{mPC}</span> scheme.</p>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Derivation</h4>

    <p class="text-gray-300">We encode the table <span class="math">\\mathbf{t}</span> in the univariate polynomial</p>

    <p class="text-gray-300"><span class="math">\\mathsf{T}(X):=\\sum_{j=1}^{N}=\\mathbf{t}_{j}\\lambda_{j}^{\\mathbb{K}}(X)</span></p>

    <p class="text-gray-300">we store its KZG commitment <span class="math">\\left[\\mathsf{T}(s)\\right]_{2}</span> (in group <span class="math">\\mathbb{G}_{2}</span>), and then we compute the cached quotients of <span class="math">\\mathsf{T}(X)</span> (using the <span class="math">O(N\\log N)</span> algorithm of <em>[x11]</em>):</p>

    <p class="text-gray-300"><span class="math">\\left[Q_{j}(s)\\right]_{1}\\text{ where }\\;Q_{j}(X):=\\frac{(\\mathsf{T}(X)-\\mathbf{t}_{j})\\lambda_{j}^{\\mathbb{K}}(X)}{\\nu_{\\,\\mathbb{K}}(X)}\\enspace.</span></p>

    <p class="text-gray-300">Additionally we precompute the commitments <span class="math">\\left[r_{j}^{\\mathbb{K}}(s)\\right]_{1}</span> to the polynomials <span class="math">r_{j}^{\\mathbb{K}}(X)=(\\lambda_{j}^{\\mathbb{K}}(X)-\\lambda_{j}^{\\mathbb{K}}(0))/X</span>, which help computing a KZG evaluation proof on <span class="math">0</span> for sparse polynomials in Lagrange basis.</p>

    <p class="text-gray-300">Prover</p>

    <p class="text-gray-300">The first steps of the prover algorithm closely follow the cq protocol:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the prover commits to the sparse vector <span class="math">\\mathbf{m}</span> of multiplicities, such that <span class="math">\\sum_{j=1}^{N} \\frac{m_i}{\\mathbf{t}_i + X} = \\sum_{j=1}^{n} \\frac{1}{\\mathbf{f}_j + X}</span>;</li>

      <li>the verifier sends a random challenge <span class="math">\\beta</span>. Then, the prover’s goal is showing</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\sum_{j=1}^{N} \\frac{m_i}{\\mathbf{t}_j + \\beta} = \\sum_{j=1}^{n} \\frac{1}{\\mathbf{f}_i + \\beta} \\tag{4}</span></div>

    <p class="text-gray-300">This is done by committing to vectors <span class="math">\\mathbf{a}</span>, <span class="math">\\mathbf{b}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">a_j = \\frac{m_j}{\\mathbf{t}_j + \\beta} \\quad \\text{and} \\quad b_i = \\frac{1}{\\mathbf{f}_i + \\beta}. \\tag{5}</span></div>

    <p class="text-gray-300">The commitment to <span class="math">\\mathbf{a}</span> is done using KZG, i.e., by committing to the interpolation <span class="math">A(X)</span> of <span class="math">\\mathbf{a}</span> over <span class="math">\\mathbb{K}</span>, that is <span class="math">[A(s)]_1</span>. This is like in [EFG22]. The commitment to <span class="math">\\mathbf{b}</span> is done using the multilinear commitment <span class="math">\\mathsf{mPC}</span>, which differs from cq.</p>

    <p class="text-gray-300">To prove (4), we perform the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove that <span class="math">[A(s)]_1</span> is wellformed, that is <span class="math">\\forall j = 1 \\dots N</span>, <span class="math">A(\\omega^{j-1})(\\mathsf{T}(\\omega^{j-1}) + \\beta) = M(\\omega^{j-1})</span>, or equivalently <span class="math">A(X)(\\mathsf{T}(X) + \\beta) = M(X) \\mod \\nu_{\\mathbb{K}}(X)</span>. Following cq, we commit to the quotient <span class="math">Q_A(X)</span> in <span class="math">O(n)</span> time, using the cached quotient technique, i.e., compute <span class="math">[Q_A(s)]_1</span> relying on the precomputed <span class="math">[Q_j(s)]_1</span>.</li>

      <li>Compute <span class="math">z \\gets \\sum_{j=1}^{N} a_j = \\sum_{i=1}^{n} b_i</span></li>

      <li>Prove that <span class="math">z = \\sum_{j=1}^{N} A(\\omega^{j-1})</span>. By relying on the univariate sumcheck lemma and the fact that the SRS imposes <span class="math">\\deg(A) &amp;lt; N</span>, we have <span class="math">\\sum_{j=1}^{N} A(\\omega^{j-1}) = N \\cdot A(0)</span>.</li>

      <li>Prove that <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{b}}</span> is wellformed w.r.t. <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{f}}</span>. The idea is to reduce it to a sumcheck statement on the multilinear polynomials <span class="math">\\tilde{f}(\\mathbf{X})</span> and <span class="math">\\tilde{b}(\\mathbf{X})</span> that encode <span class="math">\\mathbf{f}</span> and <span class="math">\\mathbf{b}</span> respectively. Namely, we want to prove</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathbf{h} \\in \\{0, 1\\}^{\\mu}: \\tilde{b}(\\mathbf{h})(\\tilde{f}(\\mathbf{h}) + \\beta) = 1</span></div>

    <p class="text-gray-300">which we can test, using a random challenge <span class="math">\\pmb{\\rho} \\gets \\mathbb{F}^{\\mu}</span>, as the following sumcheck</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} (\\tilde{b}(\\mathbf{h})(\\tilde{f}(\\mathbf{h}) + \\beta) - 1) \\chi(\\pmb{\\rho}, \\mathbf{h})</span></div>

    <p class="text-gray-300">where <span class="math">\\chi(\\mathbf{X},\\mathbf{h}) := \\prod_{j=1}^{\\mu}((1 - X_j)(1 - h_j) + X_j h_j)</span> is the multilinear extension of the identity function that returns 1 on <span class="math">\\mathbf{X} = \\mathbf{h}</span> and 0 on a boolean <span class="math">\\mathbf{h}&#x27; \\neq \\mathbf{h}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Prove that <span class="math">z = \\sum_{i=1}^{n} b_i</span>. This is a standard sumcheck to show that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">z = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} \\tilde{b}(\\mathbf{h})</span></div>

    <p class="text-gray-300">As an optimization, we batch the last two steps above, with a random challenge <span class="math">\\tau \\gets \\mathbb{F}</span>, into a single sumcheck:</p>

    <div class="my-4 text-center"><span class="math-block">z = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} \\tilde{b}(\\mathbf{h}) + \\tau \\cdot \\chi(\\boldsymbol{\\rho}, \\mathbf{h}) \\cdot (\\tilde{b}(\\mathbf{h}) \\cdot (\\tilde{f}(\\mathbf{h}) + \\beta) - 1)</span></div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 4. Our lookup argument  <span class="math">\\mu</span> -seek.</p>

    <p class="text-gray-300">Proof size. The proof size of our protocol is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} _ {1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(\\log n + 2) + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal {C} _ {\\mathrm {m P C}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_ {\\mathrm {m P C}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  are respectively the size of the commitment and opening proof in the multilinear polynomial commitment.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Theorem 1. If mPC is an extractable commitment scheme,  <span class="math">\\mathsf{CP}_{SC}</span>  is a CP-SNARK for mPC and the generalized sumcheck relation  <span class="math">\\mathcal{R}_{SC}</span> , and the power</p>

    <p class="text-gray-300">discrete logarithm (PDL) assumption holds, then the protocol <span class="math">\\mu</span>-seek in Figure 4 is knowledge-sound in the AGM and ROM.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider an algebraic adversary <span class="math">\\mathcal{A}</span> that, after interacting with the honest verifier, returns: a commitment <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span>, a valid proof</p>

    <p class="text-gray-300"><span class="math">\\pi=([M(s),A(s),Q_{A}(s),A^{\\prime}(s)]_{1}\\,,z,\\hat{\\mathsf{c}}_{\\mathbf{b}},\\pi_{SC})</span></p>

    <p class="text-gray-300">and algebraic explanations for each group element consisting of the polynomials</p>

    <p class="text-gray-300"><span class="math">M(X),A(X),Q_{A}(X),A^{\\prime}(X)\\in\\mathbb{F}[X]\\text{ of degree }&lt;N.</span></p>

    <p class="text-gray-300">For every <span class="math">\\mathcal{A}</span> we can also define the adversary <span class="math">\\mathcal{A}_{SC}</span> that runs <span class="math">\\mathcal{A}</span> and then outputs the commitments <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}},\\hat{\\mathsf{c}}_{\\mathbf{b}}</span>, the description <span class="math">(z,\\chi(\\boldsymbol{\\rho},\\mathbf{X}),\\beta,\\tau)</span> of the generalized sumcheck statement, and the proof <span class="math">\\pi_{SC}</span> returned by <span class="math">\\mathcal{A}</span>. By the extractability of <span class="math">\\mathsf{mPC}</span> and the knowledge-soundness of <span class="math">\\mathsf{CP}_{SC}</span>, for every <span class="math">\\mathcal{A}_{SC}</span> there exists a corresponding extractor <span class="math">\\mathsf{Ext}_{SC}</span> that returns openings <span class="math">\\mathbf{f},\\mathbf{b}</span> for the commitments <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}},\\hat{\\mathsf{c}}_{\\mathbf{b}}</span>.</p>

    <p class="text-gray-300">We define the extractor <span class="math">\\mathsf{Ext}_{\\mathcal{A}}</span> as the algorithm that runs <span class="math">\\mathsf{Ext}_{SC}</span> and then outputs the opening <span class="math">\\mathbf{f}</span> for <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span>.</p>

    <p class="text-gray-300">To prove knowledge soundness for <span class="math">(\\mathcal{A},\\mathsf{Ext}_{\\mathcal{A}})</span>, notice that <span class="math">M(X),\\mathbf{f}</span> do not depend on <span class="math">\\beta,\\boldsymbol{\\rho},\\tau</span>, while <span class="math">A(X),Q_{A}(X),A^{\\prime}(X),\\mathbf{b}</span> do not depend on <span class="math">\\boldsymbol{\\rho},\\tau</span>. The independence follows by the fact that they can be extracted prior to receiving those random challenges.</p>

    <p class="text-gray-300">Consider the polynomials</p>

    <p class="text-gray-300"><span class="math">V_{1}(X)</span> <span class="math">:=A(X)(\\mathsf{T}(X)+\\beta)-M(X)-Q_{A}(X)\\nu_{\\,\\mathbb{K}}(X),</span> <span class="math">V_{2}(X)</span> <span class="math">:=A(X)-z/N-XA^{\\prime}(X)</span></p>

    <p class="text-gray-300">Since <span class="math">\\mathcal{A}</span> returns a valid proof, by the verification equation ((i)) (resp. ((ii))) we have <span class="math">V_{1}(s)=0</span> (resp. <span class="math">V_{2}(s)=0</span>). If either <span class="math">V_{1}(X)\\neq 0</span> or <span class="math">V_{2}(X)\\neq 0</span>, we can make a reduction that computes <span class="math">s</span> and breaks the PDL problem.</p>

    <p class="text-gray-300">Therefore, let us continue assuming that both <span class="math">V_{1}(X)</span> and <span class="math">V_{2}(X)</span> are zero.</p>

    <p class="text-gray-300">From <span class="math">V_{1}(X)=0</span> we get</p>

    <p class="text-gray-300"><span class="math">A(X)(\\mathsf{T}(X)+\\beta)=M(X)\\text{ mod }\\nu_{\\,\\mathbb{K}}(X)\\iff\\forall j\\in[N]:A(\\omega^{j-1})=\\frac{M(\\omega^{j-1})}{(\\mathsf{T}(\\omega^{j-1})+\\beta)}</span></p>

    <p class="text-gray-300">From <span class="math">V_{2}(X)=0</span> we get that <span class="math">A(X)-z/N</span> is divisible by <span class="math">X</span> which, in combination with the fact that <span class="math">A(X)</span> is of degree <span class="math">&lt;N</span> and the univariate sumcheck lemma, yields that <span class="math">z=N\\cdot A(0)=\\sum_{j}A(\\omega^{j-1})=\\sum_{j}\\frac{M(\\omega^{j-1})}{\\mathsf{T}(\\omega^{j-1})+\\beta}</span>.</p>

    <p class="text-gray-300">On the other hand, from the knowledge soundness of the sumcheck proof we have that <span class="math">z=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{\\mu}}\\tilde{b}(\\mathbf{h})+\\tau\\cdot\\chi(\\boldsymbol{\\rho},\\mathbf{h})\\cdot(\\tilde{b}(\\mathbf{h})\\cdot(\\tilde{f}(\\mathbf{h})+\\beta)-1)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">By the independence of <span class="math">\\tilde{f},\\tilde{b},z</span> on <span class="math">\\boldsymbol{\\rho},\\tau</span> the above sumcheck implies (except with negligible probability $(\\mu+1)/</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">z=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{\\mu}}\\tilde{b}(\\mathbf{h})\\quad\\wedge\\quad\\forall\\mathbf{h}\\in\\{0,1\\}^{\\mu}:\\tilde{b}(\\mathbf{h})=(\\tilde{f}(\\mathbf{h})+\\beta)^{-1}</span></p>

    <p class="text-gray-300">namely <span class="math">z=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{p}}\\frac{1}{(\\hat{f}(\\mathbf{h})+\\beta)}</span>.</p>

    <p class="text-gray-300">Putting things together, we have reached</p>

    <p class="text-gray-300"><span class="math">\\sum_{j\\in[N]}\\frac{M(\\omega^{j-1})}{\\mathbf{t}_{j}+\\beta}=\\sum_{i\\in[n]}\\frac{1}{\\mathbf{f}_{i}+\\beta}</span></p>

    <p class="text-gray-300">and since <span class="math">M(X),\\mathbf{f},\\mathbf{t}</span> do not depend on the random challenge <span class="math">\\beta</span>, the following equality holds</p>

    <p class="text-gray-300"><span class="math">\\sum_{j}\\frac{M(\\omega^{j-1})}{\\mathbf{t}_{j}+X}=\\sum_{i}\\frac{1}{\\mathbf{f}_{i}+X}</span></p>

    <p class="text-gray-300">which by the inclusion lemma implies <span class="math">\\mathbf{f}\\prec\\mathbf{t}</span>. ∎</p>

    <h2 id="sec-31" class="text-2xl font-bold">4 Our Generic Construction</h2>

    <p class="text-gray-300">In this section we present our generic construction of a lookup argument for multilinear polynomial commitments, based on one for univariate polynomial commitments.</p>

    <p class="text-gray-300">The building blocks of our construction are:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The commitment scheme <span class="math">\\mathsf{mPC}</span> for multilinear polynomials with <span class="math">\\mu=\\log n</span> variables and coefficients in <span class="math">\\mathbb{F}</span>. We assume that <span class="math">\\mathsf{srs}_{\\mathsf{mPC}}</span> is a universal SRS for <span class="math">\\mathsf{mPC}</span> and for all the CP-SNARKs for this commitment scheme.</li>

      <li>A CP-SNARK <span class="math">\\mathsf{CP}_{SC}</span> for the generalized sumcheck relation over polynomials committed with <span class="math">\\mathsf{mPC}</span>.</li>

      <li>A commitment scheme <span class="math">\\mathsf{uPC}</span> for univariate polynomials of degree <span class="math">&lt;n</span> and coefficients in <span class="math">\\mathbb{F}</span>. We assume that <span class="math">\\mathsf{srs}_{\\mathsf{uPC}}</span> is a universal SRS for <span class="math">\\mathsf{uPC}</span> and for all the CP-SNARKs for this commitment scheme.</li>

      <li>A CP-SNARK <span class="math">\\mathsf{CP}_{u}</span> for the evaluation of univariate polynomials committed with <span class="math">\\mathsf{uPC}</span>.</li>

      <li>A super-efficient lookup argument for <span class="math">\\mathsf{uPC}</span>, that is a CP-SNARK <span class="math">\\mathsf{CP}_{\\mathsf{lookup}}</span> for the relation</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{R}_{\\mathsf{lookup}}:=\\left\\{(\\mathbf{t};\\mathsf{c_{f}};(\\mathbf{f},o_{\\mathbf{f}})):\\mathbf{f}\\prec\\mathbf{t}\\wedge\\mathsf{c_{f}}=\\mathsf{uPC}.{\\mathsf{Com}}(\\mathsf{srs}_{\\mathsf{uPC}},\\mathbf{f})\\right\\}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{uPC}.{\\mathsf{Com}}(\\mathsf{ck},\\mathbf{f})</span> denotes committing to the Lagrange interpolation of <span class="math">\\mathbf{f}</span> over a domain <span class="math">\\mathbb{H}</span> of size <span class="math">n</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Our protocol</h4>

    <p class="text-gray-300">The construction is described in full detail in Fig. 5. Here we describe its main ideas.</p>

    <p class="text-gray-300">In this protocol, the prover holds a commitment <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span> to the vector <span class="math">\\mathbf{f}</span> in multilinear encoding (i.e., a commitment to the multilinear extension of <span class="math">\\mathbf{f}</span>). Then the main idea is that the prover: (a) generates a commitment <span class="math">\\mathsf{c}_{\\mathbf{f}}</span> to the univariate polynomial that interpolates <span class="math">\\mathbf{f}</span> over a domain <span class="math">\\mathbb{H}</span>, (b) uses the (super-efficient) lookup argument to prove the lookup relation w.r.t. <span class="math">\\mathsf{c}_{\\mathbf{f}}</span>, (c) proves that <span class="math">\\mathsf{c}_{\\mathbf{f}}</span> and <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span> commit to the same vector.</p>

    <p class="text-gray-300">To address (c), we use a random point <span class="math">\\sigma</span> to test that</p>

    <div class="my-4 text-center"><span class="math-block">f(\\sigma) = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} \\tilde{f}(\\mathbf{h}) \\cdot \\lambda_{\\sum_j h_j 2^j}^{\\mathbb{H}}(\\sigma)</span></div>

    <p class="text-gray-300">The left-hand side of the equation can be proven via a standard polynomial evaluation that <span class="math">y = f(\\sigma)</span>.</p>

    <p class="text-gray-300">For the right-hand side, we proceed as follows. First, the prover commits in <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{r}}</span> to the multilinear extension of the vector <span class="math">\\mathbf{r} = (\\lambda_1^{\\mathbb{H}}(\\sigma), \\dots, \\lambda_n^{\\mathbb{H}}(\\sigma))</span>. Second, it proves that <span class="math">y = \\sum_{i=1}^{n} \\mathbf{f}_i \\cdot \\mathbf{r}_i</span> with standard sumcheck for inner products</p>

    <div class="my-4 text-center"><span class="math-block">y = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} \\tilde{f}(\\mathbf{h}) \\tilde{r}(\\mathbf{h})</span></div>

    <p class="text-gray-300">Third, it proves that <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{r}}</span> is wellformed as follows. For every <span class="math">i \\in [n]</span> it holds <span class="math">\\mathbf{r}_i = \\lambda_i^{\\mathbb{H}}(\\sigma) = \\frac{\\omega^{i-1}(\\sigma^n - 1)}{n(\\sigma - \\omega^{i-1})}</span>, which can be reduced to the following statement</p>

    <div class="my-4 text-center"><span class="math-block">\\forall \\mathbf{h} \\in \\{0, 1\\}^{\\mu}: \\tilde{r}(\\mathbf{h}) n(\\sigma - \\tilde{\\omega}(\\mathbf{h})) = \\tilde{\\omega}(\\mathbf{h})(\\sigma^n - 1)</span></div>

    <p class="text-gray-300">w.r.t. the multilinear polynomials <span class="math">\\tilde{r}(\\mathbf{X})</span> and <span class="math">\\tilde{\\omega}(\\mathbf{X})</span>, which are the multilinear extensions of <span class="math">\\mathbf{r}</span> and <span class="math">\\boldsymbol{\\omega} = (\\omega^{i-1})_{i=1}^n</span> respectively<span class="math">^{13}</span>.</p>

    <p class="text-gray-300">By using a random challenge <span class="math">\\rho \\gets \\mathfrak{s} \\mathbb{F}^{\\mu}</span> we reduce the statement above to the following sumcheck</p>

    <div class="my-4 text-center"><span class="math-block">0 = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} (\\tilde{r}(\\mathbf{h})(\\sigma - \\tilde{\\omega}(\\mathbf{h})) - \\tilde{\\omega}(\\mathbf{h})n(\\sigma^n - 1)) \\chi(\\boldsymbol{\\rho}, \\mathbf{h})</span></div>

    <p class="text-gray-300">Finally, we optimize and batch the two sumchecks, with a random challenge <span class="math">\\tau \\gets \\mathfrak{s} \\mathbb{F}</span>, into a single sumcheck:</p>

    <div class="my-4 text-center"><span class="math-block">y = \\sum_{\\mathbf{h} \\in \\{0, 1\\}^{\\mu}} \\tilde{f}(\\mathbf{h}) \\tilde{r}(\\mathbf{h}) + \\tau \\cdot \\chi(\\boldsymbol{\\rho}, \\mathbf{h}) \\cdot (\\tilde{r}(\\mathbf{h})n(\\sigma - \\tilde{\\omega}(\\mathbf{h})) - \\tilde{\\omega}(\\mathbf{h})(\\sigma^n - 1))</span></div>

    <p class="text-gray-300"><strong>Proof size.</strong> The proof size of our generic protocol is</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\mathcal{C}_{\\mathrm{uPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 3 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, (\\log n + 2) + 1 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\mathcal{C}_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 4 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\pi_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+ 1 \\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\, \\pi_{\\mathrm{uPC-lu}}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{uPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the commitment in the univariate polynomial commitment, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{C}_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{mPC}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> are respectively the size of the commitment and opening proof in the multilinear polynomial commitment, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{\\mathrm{uPC-lu}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ is the size of the lookup argument for univariate polynomial commitments.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">^{13}</span>A commitment to <span class="math">\\boldsymbol{\\omega}</span>, which only depends on the size <span class="math">n</span> of the vector, can be created during the preprocessing phase.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 5. Our generic lookup argument for multilinear polynomials.</p>

    <p class="text-gray-300">Remark 3 (Batching optimizations in our constructions). We stress that in construction in Fig. 4 (resp. Fig. 5) one is able to avoid the full size and verification cost of the two (resp. four) multilinear evaluation proofs if the underlying polynomial commitment supports batching.</p>

    <p class="text-gray-300">Theorem 2. If  <span class="math">\\mathsf{mPC}</span>  is an extractable commitment scheme,  <span class="math">\\mathsf{CP}_{SC}</span>  is a CP-SNARK for  <span class="math">\\mathsf{mPC}</span>  and the generalized sumcheck relation  <span class="math">\\mathcal{R}_{SC}</span> ,  <span class="math">\\mathsf{CP}_u</span>  is a CP-SNARK for  <span class="math">\\mathsf{uPC}</span>  and polynomial evaluations, and  <span class="math">\\mathsf{CP}_{\\mathrm{lookup}}</span>  is a CP-SNARK for  <span class="math">\\mathsf{uPC}</span>  for  <span class="math">\\mathcal{R}_{\\mathrm{lookup}}</span> , then the protocol in Figure 5 is knowledge-sound in the ROM.</p>

    <p class="text-gray-300">Proof. Consider an adversary  <span class="math">\\mathcal{A}</span>  that, after interacting with the honest verifier, returns: a commitment  <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{f}}</span>  and a valid proof</p>

    <div class="my-4 text-center"><span class="math-block">\\pi = \\left(c _ {f}, \\pi_ {u P C - l u}, y, \\hat {c} _ {r}, \\pi_ {f}, \\pi_ {S C}\\right)</span></div>

    <p class="text-gray-300">For every  <span class="math">\\mathcal{A}</span>  we can define the adversary  <span class="math">\\mathcal{A}_{\\mathrm{mPC}}</span>  that runs  <span class="math">\\mathcal{A}</span>  until the first round and then outputs  <span class="math">\\hat{\\mathbf{c}}_{\\mathbf{f}}</span> . By the extractability of mPC, for  <span class="math">\\mathcal{A}_{\\mathrm{mPC}}</span>  there is</p>

    <p class="text-gray-300">an extractor <span class="math">\\mathsf{Ext}_{\\mathsf{mPC}}</span> that outputs a valid opening <span class="math">\\tilde{f}</span> of <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span> with overwhelming probability.</p>

    <p class="text-gray-300">We define the extractor <span class="math">\\mathsf{Ext}_{\\mathcal{A}}</span> as the algorithm that runs <span class="math">\\mathsf{Ext}_{\\mathsf{lookup}}</span> and then outputs the opening <span class="math">\\hat{f}</span> for <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}}</span>.</p>

    <p class="text-gray-300">To prove that the pair <span class="math">(\\mathcal{A},\\mathsf{Ext}_{\\mathcal{A}})</span> satisfies knowledge soundness, we also define the following additional extractors.</p>

    <p class="text-gray-300">First, for every <span class="math">\\mathcal{A}</span> we define the adversary <span class="math">\\mathcal{A}_{\\mathsf{lookup}}</span> that runs <span class="math">\\mathcal{A}</span> until the first round and then outputs <span class="math">\\mathsf{c}_{\\mathbf{f}},\\pi_{\\mathsf{uPC - lu}}</span>. By the knowledge-soundness of <span class="math">\\mathsf{CP}_{\\mathsf{lookup}}</span>, for every <span class="math">\\mathcal{A}_{\\mathsf{lookup}}</span> there is a corresponding extractor <span class="math">\\mathsf{Ext}_{\\mathsf{lookup}}</span> that returns a polynomial <span class="math">f(X)</span> that, with overwhelming probability, is a valid opening for <span class="math">\\mathsf{c}_{\\mathbf{f}}</span> and whose encoded vector <span class="math">\\mathbf{f}</span> (i.e., such that <span class="math">f(X)=\\sum_{i=1}^{n}\\mathbf{f}_{i}\\cdot\\lambda_{i}^{\\mathbb{H}}(X)</span>) satisfies <span class="math">\\mathbf{f}\\prec\\mathbf{t}</span>.</p>

    <p class="text-gray-300">Second, we define <span class="math">\\mathcal{A}_{\\mathsf{CP}_{n}}</span> that runs <span class="math">\\mathcal{A}</span> until the second round and then outputs <span class="math">\\mathsf{c}_{\\mathbf{f}}</span> and proof <span class="math">\\pi_{\\mathbf{f}}</span>. By the knowledge-soundness of <span class="math">\\mathsf{CP}_{n}</span> there is an extractor <span class="math">\\mathsf{Ext}_{\\mathsf{CP}_{n}}</span> that returns a polynomial <span class="math">f^{\\prime}(X)</span> that, with overwhelming probability, is a valid opening for <span class="math">\\mathsf{c}_{\\mathbf{f}}</span> and such that <span class="math">y=f^{\\prime}(\\sigma)</span>.</p>

    <p class="text-gray-300">Third, we define the adversary <span class="math">\\mathcal{A}_{SC}</span> that runs <span class="math">\\mathcal{A}</span> until the end and returns the commitments <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}},\\hat{\\mathsf{c}}_{\\mathbf{r}}</span>, the description <span class="math">(y,\\chi(\\boldsymbol{\\rho},\\mathbf{X}),\\sigma,\\tau)</span> of the generalized sumcheck statement, and the proof <span class="math">\\pi_{SC}</span>. By the knowledge-soundness of <span class="math">\\mathsf{CP}_{SC}</span>, for every <span class="math">\\mathcal{A}_{SC}</span> there exists a corresponding extractor <span class="math">\\mathsf{Ext}_{SC}</span> that returns <span class="math">\\hat{f}^{\\prime},\\tilde{r}</span> that are valid openings for the commitments <span class="math">\\hat{\\mathsf{c}}_{\\mathbf{f}},\\hat{\\mathsf{c}}_{\\mathbf{r}}</span> and are consistent with the generalized sumcheck statement.</p>

    <p class="text-gray-300">By the computational binding of the commitment schemes we can exclude that <span class="math">f(X)\\neq f^{\\prime}(X)</span>, <span class="math">\\tilde{f}\\neq\\tilde{f}^{\\prime}</span>.</p>

    <p class="text-gray-300">Next, we notice that <span class="math">\\tilde{f},f(X)</span> do not depend on <span class="math">\\sigma,\\boldsymbol{\\rho},\\tau</span>, while <span class="math">\\tilde{r}</span> does not depend on <span class="math">\\boldsymbol{\\rho},\\tau</span> (the same holds clearly for <span class="math">\\boldsymbol{\\omega}</span>). The independence follows by the fact that they can be extracted prior to receiving those random challenges.</p>

    <p class="text-gray-300">From the knowledge soundness of the sumcheck proof we have that</p>

    <p class="text-gray-300"><span class="math">y=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{\\mu}}\\tilde{f}(\\mathbf{h})\\tilde{r}(\\mathbf{h})+\\tau\\cdot\\chi(\\boldsymbol{\\rho},\\mathbf{h})\\cdot(\\tilde{r}(\\mathbf{h})n(\\sigma-\\tilde{\\omega}(\\mathbf{h}))-\\tilde{\\omega}(\\mathbf{h})(\\sigma^{n}-1)).</span></p>

    <p class="text-gray-300">By the independence of <span class="math">\\tilde{f},\\tilde{r},y</span> (and the rest of the statement) on <span class="math">\\boldsymbol{\\rho},\\tau</span>, the above sumcheck implies</p>

    <p class="text-gray-300"><span class="math">y=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{\\mu}}\\tilde{f}(\\mathbf{h})\\tilde{r}(\\mathbf{h})\\quad\\wedge\\quad\\forall\\mathbf{h}\\in\\{0,1\\}^{\\mu}:\\tilde{r}(\\mathbf{h})=\\frac{\\tilde{\\omega}(\\mathbf{h})(\\sigma^{n}-1)}{n(\\sigma-\\tilde{\\omega}(\\mathbf{h}))}</span></p>

    <p class="text-gray-300">namely <span class="math">y=\\sum_{\\mathbf{h}\\in\\{0,1\\}^{\\mu}}\\tilde{f}(\\mathbf{h})\\cdot\\lambda_{\\mathbb{E}_{ij}h_{j}2^{j}}^{\\mathbb{H}}(\\sigma)</span>.</p>

    <p class="text-gray-300">Putting things together, we have reached</p>

    <p class="text-gray-300"><span class="math">f(\\sigma)=\\sum_{i=1}^{n}\\hat{\\mathbf{f}}_{i}\\cdot\\lambda_{i}^{\\mathbb{H}}(\\sigma)</span></p>

    <p class="text-gray-300">where <span class="math">\\hat{\\mathbf{f}}</span> is the vector represented by the multilinear polynomial <span class="math">\\tilde{f}</span>. Since <span class="math">f(X),\\tilde{f}</span> do not depend on the random challenge <span class="math">\\sigma</span>, the following identity</p>

    <p class="text-gray-300"><span class="math">f(X)=\\sum_{i=1}^{n}\\hat{\\mathbf{f}}_{i}\\cdot\\lambda_{i}^{\\mathbb{H}}(X)\\iff\\mathbf{f}=\\hat{\\mathbf{f}}</span></p>

    <p class="text-gray-300">for</p>

    <p class="text-gray-300">holds with probability</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 - n /</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300">In this section we are interested in augmenting proof systems for rank-1 constraint systems (R1CS) with lookup capabilities.</p>

    <p class="text-gray-300">We briefly recap the definition of R1CS:</p>

    <p class="text-gray-300"><strong>Definition 6 (R1CS).</strong> An R1CS relation <span class="math">\\mathcal{R}_{R1CS}</span> is defined by three matrices <span class="math">\\mathbf{A},\\mathbf{B},\\mathbf{C} \\in \\mathbb{F}^{m \\times (\\ell + n)}</span> and accepts <span class="math">(\\mathbf{x},\\mathbf{w}) \\in \\mathbb{F}^{\\ell} \\times \\mathbb{F}^{n}</span> such that, for <span class="math">\\mathbf{z} = (\\mathbf{x},\\mathbf{w})</span>,</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{A} \\cdot \\mathbf{z}) \\circ (\\mathbf{B} \\cdot \\mathbf{z}) = (\\mathbf{C} \\cdot \\mathbf{z})</span></div>

    <p class="text-gray-300">The augmented constraint system we want to support is the following:</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> Let <span class="math">\\mathbf{A},\\mathbf{B},\\mathbf{C}</span> be matrices describing an R1CS with witness of size <span class="math">n</span>, let <span class="math">I \\subseteq [n]</span> and let <span class="math">\\mathbf{t}</span> be a lookup table. We define the relation <span class="math">\\mathcal{R}_{R1CS + \\text{lookup}}</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">(\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}_{R1CS + \\text{lookup}} \\iff (\\mathbf{x}, \\mathbf{w}) \\in \\mathcal{R}_{R1CS} \\wedge \\mathbf{w}_I \\prec \\mathbf{t}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{w}_I</span> denotes the subvector of <span class="math">\\mathbf{w}</span> restricted to the indices in <span class="math">I</span>.</p>

    <p class="text-gray-300">We can build a (CP) SNARK for <span class="math">\\mathcal{R}_{\\mathsf{R1CS + lookup}}</span> by using the following building blocks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A commitment scheme mPC for multilinear polynomials.</li>

      <li>A CP-SNARK <span class="math">\\Pi_{\\mathsf{R1CS}}</span> over commitment scheme mPC for <span class="math">\\mathcal{R}_{\\mathsf{R1CS}}</span>.</li>

      <li>A CP-SNARK <span class="math">\\Pi_{\\mathsf{prj-lkup}}</span> over commitment scheme mPC for the projective lookup relation <span class="math">\\mathcal{R}_{\\mathsf{prj-lkup}}</span> defined as follows: <span class="math">(\\bot, \\mathbf{w}) \\in \\mathcal{R}_{\\mathsf{prj-lkup}} \\iff \\mathbf{w}_I \\prec \\mathbf{t}</span> where <span class="math">^14</span> <span class="math">\\mathbf{t}</span> and <span class="math">I</span> parametrize the relation and are respectively a lookup table and a subset of <span class="math">[n]</span> where <span class="math">n</span> denotes the size of <span class="math">w</span> (this argument is what we call a projective lookup in this section).</li>

    </ul>

    <p class="text-gray-300">The proof of the following theorem follows immediately from the CP-SNARK properties of its building blocks (see [CFQ19, Section 3.2]).</p>

    <p class="text-gray-300"><strong>Theorem 3.</strong> The construction in Fig. 6 is a CP-SNARK for <span class="math">\\mathcal{R}_{R1CS + \\text{lookup}}</span> (Definition 7).</p>

    <p class="text-gray-300">Below we discuss two ways to add projective properties to existing lookup arguments.</p>

    <hr class="my-8 border-gray-700" />

    <p class="text-gray-300">¹⁴Notice that from the definition of the relation the public input of the CP-SNARK verification algorithm is a commitment to <span class="math">\\mathbf{w}</span> and not to <span class="math">\\mathbf{w}_I</span>. This specific feature makes our first construction particularly simple.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 6. Our construction for augmented R1CS relations through projective lookups. Key generation and derivation algorithm are not described in figure: they simply consist in running the key generation of  <span class="math">\\Pi_{\\mathrm{R1CS}}</span>  and  <span class="math">\\Pi_{\\mathrm{prj - lkup}}</span>  and returning the concatenation of their outputs.</p>

    <p class="text-gray-300">The first method to build a CP-SNARK for  <span class="math">\\mathcal{R}_{\\mathrm{prj - lkup}}</span>  is to create a commitment  <span class="math">\\mathbf{c_f}</span>  to the subvector  <span class="math">\\mathbf{f} = \\mathbf{w}_I</span> , run a CP-SNARK for lookup with  <span class="math">\\mathbf{c_f}</span>  (to prove that  <span class="math">\\mathbf{f} \\prec \\mathbf{t}</span> ) and then use a CP-SNARK for indexed lookups to prove that  <span class="math">\\mathbf{f} = \\mathbf{w}_I</span>  w.r.t. commitments  <span class="math">\\mathbf{c_w}</span>  an  <span class="math">\\mathbf{c_f}</span> . An indexed lookup can be realized via one for proving that  <span class="math">\\mathbf{f} = \\mathbf{M} \\cdot \\mathbf{w}</span>  for an appropriately defined projection matrix  <span class="math">\\mathbf{M}</span> , see e.g., [STW24, RZ21].</p>

    <p class="text-gray-300">In alternative to the method described above, we show how to turn a lookup argument into a projective one in the case of subsets  <span class="math">I \\subseteq [n]</span>  that have a simple representation through a wildcard pattern. In such a case, we support projective lookups without introducing more commitments, at virtually no overhead. For example the subset  <span class="math">I := \\{i : 1 \\leq i \\leq 2^{\\frac{\\mu}{2}}\\} \\subseteq [2^{\\mu}]</span>  can be represented through the wildcard pattern  <span class="math">\\underbrace{00 \\ldots 00}_{\\mu/2} \\xleftarrow{\\star \\cdots \\star \\star} \\text{since each bit replacement of the } \\star</span> -s corresponds to the binary representation of an integer  <span class="math">j</span>  such that  <span class="math">j + 1 \\in I</span> . On the other hand there is no such wildcard pattern for a subset like  <span class="math">I&#x27; := \\{\\underbrace{00 \\ldots 00}_{\\mu}, \\underbrace{11 \\ldots 11}_{\\mu}\\}</span> .</p>

    <p class="text-gray-300">We now capture these intuitions formally:</p>

    <p class="text-gray-300">Definition 8 (Wildcard pattern). Let  <span class="math">\\mu \\in \\mathbb{N}</span> . A wildcard pattern  <span class="math">\\mathbb{P}</span>  of size  <span class="math">\\mu</span>  is a vector in  <span class="math">\\{0,1,\\star\\}^{\\mu}</span>  (e.g., the string  <span class="math">00010 \\star 1 \\star</span> ). We denote by  <span class="math">\\kappa(\\mathbb{P})</span>  the</p>

    <p class="text-gray-300">number of star symbols (<span class="math">\\star</span>) in the pattern <span class="math">\\mathbb{P}</span>. Given a binary string <span class="math">\\mathbf{b}\\in\\{0,1\\}^{\\kappa(\\mathbb{P})}</span>, we denote by <span class="math">\\mathbf{b}\\sqcup\\mathbb{P}</span> the binary string obtained by replacing the <span class="math">\\star</span>-s in <span class="math">\\mathbb{P}</span> with the bits in <span class="math">\\mathbf{b}</span> in order (e.g., <span class="math">001\\sqcup 110\\star 1\\star 1\\star\\to 110\\underline{0}1\\underline{0}1\\underline{1}</span>, where the replaced positions are underlined). We will also extend this notation <span class="math">\\mathbf{u}\\sqcup\\mathbb{P}</span> in the natural way to the case where the vector <span class="math">\\mathbf{u}</span> is of arbitrary field elements (rather than bits only).</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 9 (Wildcard-expressible subset).</h6>

    <p class="text-gray-300">Let <span class="math">n\\in\\mathbb{N}</span> where <span class="math">n=2^{\\mu}</span>. Let <span class="math">I\\subseteq[n]</span>. We say that <span class="math">I</span> is wildcard-expressible if there exists a wildcard pattern <span class="math">\\mathbb{P}_{I}</span> of length <span class="math">\\mu</span> such that we can represent each element of <span class="math">I</span> as a string “matched” by <span class="math">\\mathbb{P}_{I}</span> (most-significant bit on the left), i.e., if</p>

    <p class="text-gray-300"><span class="math">\\forall i\\in I\\ \\exists\\mathbf{b}\\in\\{0,1\\}^{\\kappa(\\mathbb{P})}:i=1+\\sum_{j=1}^{\\mu}2^{\\mu-j}\\cdot z_{j},\\text{ where }\\mathbf{z}:=\\mathbf{b}\\sqcup\\mathbb{P}_{I}</span></p>

    <p class="text-gray-300">The key observation we will use to make our lookup arguments “projective” is that for a wildcard-expressible subset <span class="math">I</span> we can describe <span class="math">\\tilde{w}_{I}</span>—the MLE of the subvector <span class="math">\\mathbf{w}_{I}</span> of <span class="math">\\mathbf{w}</span> (its restrictions to indices <span class="math">i\\in I</span>)—through a partial evaluation of <span class="math">\\tilde{w}</span> on the non-wildcard characters. More formally, let <span class="math">I\\subseteq[n]</span> be a wildcard-expressible subset with associated pattern <span class="math">\\mathbb{P}_{I}</span>, let <span class="math">\\mathbf{w}\\in\\mathbb{F}^{n}</span> be a vector, <span class="math">\\mathbf{w}_{I}\\in\\mathbb{F}^{2^{\\kappa(\\mathbb{P}_{I})}}</span> the <span class="math">I</span>-subvector of <span class="math">\\mathbf{w}</span>, and let <span class="math">\\tilde{w}</span> and <span class="math">\\tilde{w}_{I}</span> be their respective MLE. Then for any <span class="math">\\mathbf{x}\\in\\mathbb{F}^{\\kappa(\\mathbb{P}_{I})}</span> it holds <span class="math">\\tilde{w}_{I}(\\mathbf{x})=\\tilde{w}(\\mathbf{x}\\sqcup\\mathbb{P}_{I})</span> (this is easy to see and we don’t prove it explicitly).</p>

    <p class="text-gray-300">Given the observation above, we can turn both our constructions for <span class="math">\\mathcal{R}_{\\mathsf{lookup}}</span> of Sections 3 and 4 into constructions for <span class="math">\\mathcal{R}_{\\mathsf{R1CS+lookup}}</span>. For <span class="math">\\mathcal{R}_{\\mathsf{R1CS+lookup}}</span>, let us assume that the prover holds a commitment <span class="math">\\mathsf{c}_{\\mathbf{w}}</span> to the vector <span class="math">\\mathbf{w}</span> and wishes to prove that <span class="math">\\mathbf{w}_{I}\\prec\\mathbf{t}</span>. Then we let the prover algorithm work in the same way by setting <span class="math">\\mathbf{f}=\\mathbf{w}_{I}</span> and by “simulating” <span class="math">\\tilde{f}(\\mathbf{x})=\\tilde{w}_{I}(\\mathbf{x})</span> as <span class="math">\\tilde{w}(\\mathbf{x}\\sqcup\\mathbb{P}_{I})</span> following the observation above. From the point of view of the verifier, the only change is that, whenever it needs to verify an evaluation of <span class="math">\\tilde{f}</span> on point <span class="math">\\mathbf{x}</span> w.r.t. the commitment <span class="math">\\mathsf{c}_{\\mathbf{w}}</span>, the verifier runs <span class="math">\\mathsf{CP}_{m}</span>’s verification on the augmented point <span class="math">\\mathbf{x}\\sqcup\\mathbb{P}_{I}</span>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Acknowledgements</h4>

    <p class="text-gray-300">Matteo Campanelli partly worked on this project while at Matter Labs. We thank Justin Thaler for fruitful discussions about the cost profile of Lasso and applications of unstructured tables. We also thank Dario Catalano and Emanuele Giunta who contributed to discussions during the early stages of this work. Thanks to Helger Lipmaa for useful comments on the presentation of our results. Finally, we thank the anonymous JoC reviewers.</p>

    <p class="text-gray-300">This work is supported by the PICOCRYPT project that has received funding from the European Research Council (ERC) under the European Union’s Horizon 2020 research and innovation programme (Grant agreement No. 101001283), partially supported by projects PRODIGY (TED2021-132464B-I00) and ESPADA (PID2022-142290OB-I00) funded by MCIN/AEI/10.13039/501100011033/ and the European Union NextGenerationEU/PRTR.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ABC^{+}22. Diego F. Aranha, Emil Madsen Bennedsen, Matteo Campanelli, Chaya Ganesh, Claudio Orlandi, and Akira Takahashi. ECLIPSE: Enhanced compiling method for pedersen-committed zkSNARK engines. In Goichiro Hanaoka, Junji Shikata, and Yohei Watanabe, editors, PKC 2022, Part I, volume 13177 of LNCS, pages 584–614. Springer, Cham, March 2022.</li>

      <li>AGM18. Shashank Agrawal, Chaya Ganesh, and Payman Mohassel. Non-interactive zero-knowledge proofs for composite statements. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 643–673. Springer, Cham, August 2018.</li>

      <li>AST24. Arasu Arun, Srinath T. V. Setty, and Justin Thaler. Jolt: SNARKs for virtual machines via lookups. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part VI, volume 14656 of LNCS, pages 3–33. Springer, Cham, May 2024.</li>

      <li>BBF19. Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching techniques for accumulators with applications to IOPs and stateless blockchains. In Alexandra Boldyreva and Daniele Micciancio, editors, CRYPTO 2019, Part I, volume 11692 of LNCS, pages 561–586. Springer, Cham, August 2019.</li>

      <li>BCF^{+}21. Daniel Benarroch, Matteo Campanelli, Dario Fiore, Kobi Gurkan, and Dimitris Kolonelos. Zero-knowledge proofs for set membership: Efficient, succinct, modular. In Nikita Borisov and Claudia Díaz, editors, FC 2021, Part I, volume 12674 of LNCS, pages 393–414. Springer, Berlin, Heidelberg, March 2021.</li>

      <li>BCG^{+}18. Jonathan Bootle, Andrea Cerulli, Jens Groth, Sune K. Jakobsen, and Mary Maller. Arya: Nearly linear-time zero-knowledge proofs for correct program execution. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part I, volume 11272 of LNCS, pages 595–626. Springer, Cham, December 2018.</li>

      <li>BCHO22. Jonathan Bootle, Alessandro Chiesa, Yuncong Hu, and Michele Orrù. Gemini: Elastic SNARKs for diverse environments. In Orr Dunkelman and Stefan Dziembowski, editors, EUROCRYPT 2022, Part II, volume 13276 of LNCS, pages 427–457. Springer, Cham, May / June 2022.</li>

      <li>BCR^{+}19. Eli Ben-Sasson, Alessandro Chiesa, Michael Riabzev, Nicholas Spooner, Madars Virza, and Nicholas P. Ward. Aurora: Transparent succinct arguments for R1CS. In Yuval Ishai and Vincent Rijmen, editors, EUROCRYPT 2019, Part I, volume 11476 of LNCS, pages 103–128. Springer, Cham, May 2019.</li>

      <li>BFS20. Benedikt Bünz, Ben Fisch, and Alan Szepieniec. Transparent SNARKs from DARK compilers. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 677–706. Springer, Cham, May 2020.</li>

      <li>BGH19. Sean Bowe, Jack Grigg, and Daira Hopwood. Halo: Recursive proof composition without a trusted setup. Cryptology ePrint Archive, Report 2019/1021, 2019.</li>

      <li>BMM^{+}21. Benedikt Bünz, Mary Maller, Pratyush Mishra, Nirvan Tyagi, and Psi Vesely. Proofs for inner pairing products and applications. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 65–97. Springer, Cham, December 2021.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">CBBZ23. Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. HyperPlonk: Plonk with linear-time prover and high-degree custom gates. In Carmit Hazay and Martijn Stam, editors, EUROCRYPT 2023, Part II, volume 14005 of LNCS, pages 499–530. Springer, Cham, April 2023.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CEO22. Matteo Campanelli, Felix Engelmann, and Claudio Orlandi. Zero-knowledge for homomorphic key-value commitments with applications to privacy-preserving ledgers. In Clemente Galdi and Stanislaw Jarecki, editors, SCN 22, volume 13409 of LNCS, pages 761–784. Springer, Cham, September 2022.</li>

      <li>CFF^{+}21. Matteo Campanelli, Antonio Faonio, Dario Fiore, Anaïs Querol, and Hadrián Rodríguez. Lunar: A toolbox for more efficient universal and updatable zkSNARKs and commit-and-prove extensions. In Mehdi Tibouchi and Huaxiong Wang, editors, ASIACRYPT 2021, Part III, volume 13092 of LNCS, pages 3–33. Springer, Cham, December 2021.</li>

      <li>CFF^{+}24. Matteo Campanelli, Antonio Faonio, Dario Fiore, Tianyu Li, and Helger Lipmaa. Lookup arguments: Improvements, extensions and applications to zero-knowledge decision trees. In Qiang Tang and Vanessa Teague, editors, PKC 2024, Part II, volume 14602 of LNCS, pages 337–369. Springer, Cham, April 2024.</li>

      <li>CFH^{+}22. Matteo Campanelli, Dario Fiore, Semin Han, Jihye Kim, Dimitris Kolonelos, and Hyunok Oh. Succinct zero-knowledge batch proofs for set accumulators. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 455–469. ACM Press, November 2022.</li>

      <li>CFQ19. Matteo Campanelli, Dario Fiore, and Anaïs Querol. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In Lorenzo Cavallaro, Johannes Kinder, XiaoFeng Wang, and Jonathan Katz, editors, ACM CCS 2019, pages 2075–2092. ACM Press, November 2019.</li>

      <li>CFR24. Matteo Campanelli, Antonio Faonio, and Luigi Russo. SNARKs for virtual machines are non-malleable. Cryptology ePrint Archive, Paper 2024/1551, 2024.</li>

      <li>CGG^{+}23. Matteo Campanelli, Nicolas Gailly, Rosario Gennaro, Philipp Jovanovic, Mara Mihali, and Justin Thaler. Testudo: Linear time prover snarks with constant size proofs and square root size universal setup. In International Conference on Cryptology and Information Security in Latin America, pages 331–351. Springer, 2023.</li>

      <li>CHA22. Matteo Campanelli and Mathias Hall-Andersen. Veksel: Simple, efficient, anonymous payments with large anonymity sets from well-studied assumptions. In Yuji Suga, Kouichi Sakurai, Xuhua Ding, and Kazue Sako, editors, ASIACCS 22, pages 652–666. ACM Press, May / June 2022.</li>

      <li>CHAK23. Matteo Campanelli, Mathias Hall-Andersen, and Simon Holmgaard Kamp. Curve trees: Practical and transparent <span class="math">\\{</span>Zero-Knowledge<span class="math">\\}</span> accumulators. In 32nd USENIX Security Symposium (USENIX Security 23), pages 4391–4408, 2023.</li>

      <li>CHAK24. Matteo Campanelli, Mathias Hall-Andersen, and Simon Holmgaard Kamp. Curve forests: Transparent zero-knowledge set membership with batching and strong security. Cryptology ePrint Archive, Paper 2024/1647, 2024.</li>

      <li>CHJ^{+}20. Heewon Chung, Kyoohyung Han, Chanyang Ju, Myungsun Kim, and Jae Hong Seo. Bulletproofs+: Shorter proofs for privacy-enhanced distributed ledger. Cryptology ePrint Archive, Report 2020/735, 2020.</li>

    </ul>

    <p class="text-gray-300">CHM^{+}20. Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Psi Vesely, and Nicholas P. Ward. Marlin: Preprocessing zkSNARKs with universal and updatable SRS. In Anne Canteaut and Yuval Ishai, editors, EUROCRYPT 2020, Part I, volume 12105 of LNCS, pages 738–768. Springer, Cham, May 2020.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>EFG22. Liam Eagen, Dario Fiore, and Ariel Gabizon. cq: Cached quotients for fast lookups. Cryptology ePrint Archive, Report 2022/1763, 2022.</li>

      <li>EKRN24. Liam Eagen, Sanket Kanjalkar, Tim Ruffing, and Jonas Nick. Bulletproofs++: Next generation confidential transactions via reciprocal set membership arguments. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part V, volume 14655 of LNCS, pages 249–279. Springer, Cham, May 2024.</li>

      <li>FK23. Dankrad Feist and Dmitry Khovratovich. Fast amortized KZG proofs. Cryptology ePrint Archive, Paper 2023/033, 2023.</li>

      <li>FKL18. Georg Fuchsbauer, Eike Kiltz, and Julian Loss. The algebraic group model and its applications. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part II, volume 10992 of LNCS, pages 33–62. Springer, Cham, August 2018.</li>

      <li>FT22. Dario Fiore and Ida Tucker. Efficient zero-knowledge proofs on signed data with applications to verifiable computation on data streams. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 1067–1080. ACM Press, November 2022.</li>

      <li>GK22. Ariel Gabizon and Dmitry Khovratovich. flookup: Fractional decomposition-based lookups in quasi-linear time independent of table size. Cryptology ePrint Archive, Report 2022/1447, 2022.</li>

      <li>GKM^{+}18. Jens Groth, Markulf Kohlweiss, Mary Maller, Sarah Meiklejohn, and Ian Miers. Updatable and universal common reference strings with applications to zk-SNARKs. In Hovav Shacham and Alexandra Boldyreva, editors, CRYPTO 2018, Part III, volume 10993 of LNCS, pages 698–728. Springer, Cham, August 2018.</li>

      <li>GKR08. Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. Delegating computation: interactive proofs for muggles. In Richard E. Ladner and Cynthia Dwork, editors, 40th ACM STOC, pages 113–122. ACM Press, May 2008.</li>

      <li>GLS^{+}23. Alexander Golovnev, Jonathan Lee, Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Brakedown: Linear-time and field-agnostic SNARKs for R1CS. In Helena Handschuh and Anna Lysyanskaya, editors, CRYPTO 2023, Part II, volume 14082 of LNCS, pages 193–226. Springer, Cham, August 2023.</li>

      <li>GNS24. Chaya Ganesh, Vineet Nair, and Ashish Sharma. Dual polynomial commitment schemes and applications to commit-and-prove SNARKs. Cryptology ePrint Archive, Paper 2024/943, 2024. https://eprint.iacr.org/2024/943.</li>

      <li>Gro16. Jens Groth. On the size of pairing-based non-interactive arguments. In Marc Fischlin and Jean-Sébastien Coron, editors, EUROCRYPT 2016, Part II, volume 9666 of LNCS, pages 305–326. Springer, Berlin, Heidelberg, May 2016.</li>

      <li>GW20. Ariel Gabizon and Zachary J. Williamson. plookup: A simplified polynomial protocol for lookup tables. Cryptology ePrint Archive, Report 2020/315, 2020.</li>

    </ul>

    <p class="text-gray-300">GWC19. Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. PLONK: Permutations over Lagrange-bases for oecumenical noninteractive arguments of knowledge. Cryptology ePrint Archive, Report 2019/953, 2019.</p>

    <p class="text-gray-300">Hab22. Ulrich Haböck. Multivariate lookups based on logarithmic derivatives. Cryptology ePrint Archive, Report 2022/1530, 2022.</p>

    <p class="text-gray-300">hbc. halo2 book contributors. The halo2 book. 16-bit table chip for sha-256. https://zcash.github.io/halo2/design/gadgets/sha256/table16.html#16-bit-table-chip-for-sha-256.</p>

    <p class="text-gray-300">KZG10. Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-size commitments to polynomials and their applications. In Masayuki Abe, editor, ASIACRYPT 2010, volume 6477 of LNCS, pages 177–194. Springer, Berlin, Heidelberg, December 2010.</p>

    <p class="text-gray-300">LFKN90. Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan. Algebraic methods for interactive proof systems. In 31st FOCS, pages 2–10. IEEE Computer Society Press, October 1990.</p>

    <p class="text-gray-300">Lip12. Helger Lipmaa. Progression-free sets and sublinear pairing-based noninteractive zero-knowledge arguments. In Ronald Cramer, editor, TCC 2012, volume 7194 of LNCS, pages 169–189. Springer, Berlin, Heidelberg, March 2012.</p>

    <p class="text-gray-300">PH23. Shahar Papini and Ulrich Haböck. Improving logarithmic derivative lookups using GKR. Cryptology ePrint Archive, Paper 2023/1284, 2023. https://eprint.iacr.org/2023/1284.</p>

    <p class="text-gray-300">PK22. Jim Posen and Assimakis A. Kattis. Caulk+: Table-independent lookup arguments. Cryptology ePrint Archive, Report 2022/957, 2022.</p>

    <p class="text-gray-300">PST13. Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of correct computation. In Amit Sahai, editor, TCC 2013, volume 7785 of LNCS, pages 222–242. Springer, Berlin, Heidelberg, March 2013.</p>

    <p class="text-gray-300">RA. Rick and Morty Wiki Authors. Mr. meeseeks. rick and morty wiki. https://rickandmorty.fandom.com/wiki/Mr._Meeseeks.</p>

    <p class="text-gray-300">RMH^{+}24. Michael Rosenberg, Tushar Mopuri, Hossein Hafezi, Ian Miers, and Pratyush Mishra. Hekaton: Horizontally-scalable zkSNARKs via proof aggregation. Cryptology ePrint Archive, Paper 2024/1208, 2024.</p>

    <p class="text-gray-300">RZ21. Carla Ràfols and Arantxa Zapico. An algebraic framework for universal and updatable SNARKs. In Tal Malkin and Chris Peikert, editors, CRYPTO 2021, Part I, volume 12825 of LNCS, pages 774–804, Virtual Event, August 2021. Springer, Cham.</p>

    <p class="text-gray-300">Set20. Srinath Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. In Daniele Micciancio and Thomas Ristenpart, editors, CRYPTO 2020, Part III, volume 12172 of LNCS, pages 704–737. Springer, Cham, August 2020.</p>

    <p class="text-gray-300">STW24. Srinath T. V. Setty, Justin Thaler, and Riad S. Wahby. Unlocking the lookup singularity with Lasso. In Marc Joye and Gregor Leander, editors, EUROCRYPT 2024, Part VI, volume 14656 of LNCS, pages 180–209. Springer, Cham, May 2024.</p>

    <p class="text-gray-300">Whi. Barry Whitehat. Lookup singularity. https://zkresear.ch/t/lookup-singularity/65/7.</p>

    <p class="text-gray-300">XZS22. Tiancheng Xie, Yupeng Zhang, and Dawn Song. Orion: Zero knowledge proof with linear prover time. In Yevgeniy Dodis and Thomas Shrimpton, editors, CRYPTO 2022, Part IV, volume 13510 of LNCS, pages 299–328. Springer, Cham, August 2022.</p>

    <p class="text-gray-300">ZBK^{+}22a. Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. In Heng Yin, Angelos Stavrou, Cas Cremers, and Elaine Shi, editors, ACM CCS 2022, pages 3121–3134. ACM Press, November 2022.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ZBK^{+}22b. Arantxa Zapico, Vitalik Buterin, Dmitry Khovratovich, Mary Maller, Anca Nitulescu, and Mark Simkin. Caulk: Lookup arguments in sublinear time. Cryptology ePrint Archive, Report 2022/621, 2022.</li>

      <li>ZGK^{+}22. Arantxa Zapico, Ariel Gabizon, Dmitry Khovratovich, Mary Maller, and Carla Ràfols. Baloo: Nearly optimal lookup arguments. Cryptology ePrint Archive, Report 2022/1565, 2022.</li>

    </ul>`;
---

<BaseLayout title="Natively Compatible Super-Efficient Lookup Arguments and How... (2024/1058)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2024 &middot; eprint 2024/1058
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
