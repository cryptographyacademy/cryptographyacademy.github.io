---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2013/641';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Indistinguishability Obfuscation vs. Auxiliary-Input Extractable Functions: One Must Fall';
const AUTHORS_HTML = 'Nir Bitansky, Ran Canetti, Omer Paneth, Alon Rosen';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">We show that if there exist indistinguishability obfuscators for all circuits then there do not exist auxiliary-input extractable one-way functions. In particular, the knowledge of exponent assumption with
respect to adversaries with auxiliary input is false in any group where computing discrete logarithms is intractable. The proof uses the &ldquo;punctured programs&rdquo; technique of [Sahai-Waters 2013].</p>
      <p class="text-gray-300"><strong>Keywords:</strong> extractable functions &middot; indistinguishability obfuscation &middot; knowledge of exponent &middot; obfuscation</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The ability to argue about what adversarial programs &quot;know&quot; in the context of a given interaction is central to modern cryptography. A central facet of such argumentation is the ability to efficiently &quot;extract&quot; knowledge from the adversarial program, or alternatively to channel it into meaningful use. Establishing this ability is often a crucial step in security analysis of cryptographic protocols and schemes.</p>

    <p class="text-gray-300">One basic flavor of such extraction takes the form of security reductions; namely, efficiently transforming an adversarial program that breaks the security of the analyzed scheme into a program that performs some computational task that is believed to be hard. Examples include transforming a distinguisher for a pseudorandom generator into an inverter of the underlying one-way function [BM84, GL89,</p>

    <p class="text-gray-300"><sup>*</sup>Supported by an IBM Ph.D. Fellowship, the Check Point Institute for Information Security, and an ISF grant 20006317. Part of this research was conducted while visiting Boston University.</p>

    <p class="text-gray-300"><sup>&dagger;</sup>Supported by the Check Point Institute for Information Security, an ISF grant 20006317, and an NSF grant 1218461.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;&Dagger;</sup>Supported by the Simons award for graduate students in theoretical computer science and NSF award 1218461. Part of this research was conducted while at Microsoft Research New England.</p>

    <p class="text-gray-300"><a href="#page-23-1">HILL99]</a>, or transforming a cheating prover in a proof system into a collision-finder in the underlying function <a href="#page-24-0">[Kil92]</a>.</p>

    <p class="text-gray-300">Adversarial knowledge also plays a central role in formulating definitions of security: Here we often require that adversarial participants in a computation &quot;know&quot; their inputs to the computation. This is used as a means for guaranteeing global meaningfulness and secure composition of protocols, for instance in the context of proofs of knowledge and ideal-process based security <a href="#page-23-2">[FS89,</a> <a href="#page-22-3">Can00,</a> <a href="#page-22-4">Can01]</a>.</p>

    <p class="text-gray-300">The ability to extract values from the adversary is also useful when <em>simulating</em> the adversary's view in a given protocol, to establish privacy of secret inputs, as in the case of zero-knowledge or multi-party computation <a href="#page-23-3">[GMR89,</a> <a href="#page-23-4">GMW87]</a>. A quintessential example here is the Feige-Lapidot-Shamir paradigm <a href="#page-23-5">[FLS99]</a>, discussed in more detail below and used extensively in the protocol design literature.</p>

    <p class="text-gray-300">How is knowledge extracted? Traditionally, the basic technique for extracting knowledge from an adversary is to run it on multiple related inputs to deduce what it &quot;knows&quot; from the resulting outputs. In the context of interactive protocols (which will be in the focus of this work), this technique is known as rewinding. The power of the technique is in that it treats the adversary as a black-box and does not need to know anything regarding its &quot;internals&quot;. However, as a number of impossibility results for black-box reductions and simulation show, this technique is also quite limited. One main limitation of rewinding-based extraction is that it requires multiple rounds of interaction with the adversary. Indeed, proving security of candidate 3-message zero-knowledge protocols, succinct non-interactive arguments (SNARGs), and other tasks are out of the technique's reach <a href="#page-23-6">[GK96,</a> <a href="#page-23-7">GW11]</a>.</p>

    <p class="text-gray-300">Starting with the work of Barak et al. <a href="#page-21-0">[Bar01]</a>, a handful of extraction techniques that go beyond the limitations of black-box extraction have been developed. These techniques use in an essential way having access to the actual adversarial program. However, these techniques too require at least several rounds of protocol interaction. Thus, like black-box rewinding techniques, do not work in the above contexts.</p>

    <p class="text-gray-300">Extractable functions. Originating in Damgard's work <a href="#page-23-8">[Dam92]</a>, and abstracted by Canetti and Dak- &#730; douk <a href="#page-22-5">[CD08,</a> <a href="#page-22-6">CD09]</a>, the notion of <em>extractable functions</em> provides an alternative extraction method that does not rely on multiple rounds of interaction with the adversary. These are function families {fk} where, in addition to standard hardness properties, such as one-wayness or collision-resistance, any program M that given k outputs v in the image of f<sup>k</sup> has an &quot;extractor&quot; Ext that given k and the code of M, outputs a preimage of v. As an expression to their power, extractable one-way functions are known to suffice for constructing 3-message zero-knowledge protocols <a href="#page-23-9">[HT98,</a> <a href="#page-22-7">BP04,</a> <a href="#page-22-6">CD09]</a>. Extractable collision-resistant hash functions are known to suffice for constructing succinct non-interactive arguments (SNARGs) <a href="#page-22-8">[BCCT12]</a>. Extractable functions also given rise to relatively efficient CCA constructions <a href="#page-23-8">[Dam92,</a> <a href="#page-22-7">BP04]</a>.</p>

    <p class="text-gray-300">The black-box impossibility of some of the above applications imply that it is impossible to obtain extractable functions where the extractor uses the adversary's program M only as a black box. Coming up with the suitable non-black-box techniques has been the main obstacle in constructing extractable function, and to date, no construction with an explicit extraction procedure is known. Instead, for all the existing candidate constructions of extractable functions (e.g., <a href="#page-23-8">[Dam92,</a> <a href="#page-22-6">CD09,</a> <a href="#page-22-8">BCCT12,</a> <a href="#page-21-1">BC12]</a>), the existence of such an extractor is merely <em>assumed.</em> Such assumptions are arguably not satisfying. For one, they do not qualify as &quot;efficiently falsifiable&quot; <a href="#page-24-1">[Nao03]</a>; namely, unlike standard assumptions where it possible to algorithmically study the best possible &quot;breakers&quot;, here we do not even have an algorithmic way to test whether a given adversary M breaks the assumption. In addition, the impossibility of extractable functions with black-box extraction only further decreases our confidence in such assumptions, as our current understanding of non-black-box techniques and their limitations is quite partial.</p>

    <p class="text-gray-300">Thus, a natural question arises:</p>

    <p class="text-gray-300"><em>Can we construct useful extractable functions from standard hardness assumptions?</em></p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Results</h3>

    <p class="text-gray-300">We provide a positive answer to this question. Specifically, we construct one-way functions that are extractable against adversaries with non-uniform advice of bounded polynomial length, but unbounded polynomial running time (from hereon, BAPT adversaries). Note that this class includes, in particular, all uniform PT adversaries. We also show how to use our constructions to obtain 3-message and 2-message zero-knowledge, against BAPT adversarial verifiers.</p>

    <p class="text-gray-300">A bit more precisely, we construct a variant of EOWF, which we call <em>generalized extractable oneway functions</em> (GEOWF). A GEOWF is associated with an equivalence relation on its range. The one-wayness requirement is strengthened: not only is it hard to find an exact preimage of v, but it is also hard to find a preimage of any equivalent v 0 . The extractability requirement is weakened commensurately: the extractor does not have to output a preimage of v, but only a preimage of some equivalent v 0 . Such a generalization was previously considered in <a href="#page-22-8">[BCCT12]</a> for a similar purpose, in the context of extractable collision-resistant hash functions (referred to as proximity ECRHs).</p>

    <p class="text-gray-300">Our extraction technique is inspired by the uniform public-coin ZK protocol of Barak <a href="#page-21-0">[Bar01]</a>.<a href="#page-2-0">1</a> The main technical tool used in our constructions are non-interactive computationally sound proofs for deterministic polytime statements, from hereon referred to as P-delegation schemes. In a recent breakthrough, Kalai, Raz, and Rothblum <a href="#page-24-2">[KRR]</a> construct a P-delegation scheme based on the assumption of a subexponentially secure private information retrieval scheme.</p>

    <p class="text-gray-300">We show:</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Theorem 1.1 (informal).</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><em>1. Assuming P-delegation, and 1-Hop homomorphic encryption with function privacy <a href="#page-23-10">[GHV10]</a>, there exist GEOWFs against BAPT adversaries.</em></li>
      <li><em>2. Assuming GEOWFs as above and ZAPs <a href="#page-23-11">[DN07]</a>, there exist a 3-message ZK argument of knowledge against BAPT verifiers.</em></li>
      <li><em>3. Assuming the GEOWFs are one-way against subexponential adversaries, there exists a 2-message ZK argument against BAPT verifiers.</em></li>
    </ul>

    <p class="text-gray-300">We note that all the assumptions above can be reduced, for example, to subexponential Decision Diffie-Hellman (or Quadratic Residuosity) and trapdoor permutations <a href="#page-21-2">[AIR01,</a> <a href="#page-24-3">NP01,</a> <a href="#page-23-11">DN07,</a> <a href="#page-24-4">OI07,</a> <a href="#page-23-10">GHV10,</a> <a href="#page-23-12">HK12,</a> <a href="#page-24-2">KRR]</a>.</p>

    <p class="text-gray-300">Limitations and previous work. 3-message zero-knowledge protocols with black-box simulation exist only for trivial languages <a href="#page-23-6">[GK96]</a>. Impossibility extends to the case of adversaries with bounded advice of size n &Omega;(1), where n is the security parameter. See Appendix <a href="#page-24-5">A</a> for more details. All previous 3-message zero-knowledge protocols were based on knowledge of exponent (or more general extractability) assumptions, where the simulator uses a non-black extractor that is only assumed to exist, but not explicitly constructed <a href="#page-23-9">[HT98,</a> <a href="#page-22-7">BP04,</a> <a href="#page-22-5">CD08]</a>.</p>

    <p class="text-gray-300">Two-message zero-knowledge arguments against adversaries with unbounded polynomial advice exist only for trivial languages (regardless of how simulation is done) <a href="#page-23-13">[GO94]</a>. In fact, impossibility extends even to adversaries with bounded advice, provided that the advice string is longer than the verifier's message. Barak et al. <a href="#page-22-9">[BLV06]</a> construct a 2-message argument that is zero-knowledge as long as the verifier's advice is shorter than the verifier message by super-logarithmic additive factor. However, security of the Barak et al. protocol is only shown assuming existence of P-delegation <a href="#page-2-1">2</a> schemes that</p>

    <p class="text-gray-300"><sup>1</sup>The term &quot;uniform ZK&quot; is used in Barak <a href="#page-21-0">[Bar01]</a>. Barak, Lindell, Vadhan <a href="#page-22-9">[BLV06]</a> use the term &quot;plain ZK&quot; instead, to stress the fact that only the verifier is uniform, while all other components (including prover and distinguisher) are non-uniform.</p>

    <p class="text-gray-300">In fact, <a href="#page-22-9">[BLV06]</a> assume non-interactive CS proofs for all of NP; however, their argument can be augmented and based on CS proofs for P</p>

    <p class="text-gray-300">are <em>publicly verifiable</em>. While this assumption is falsifiable [CLP13], its only candidate constructions are either Micali's CS proof construction in the random oracle model, or the publicly verifiable SNARGs of [BCCT13] based on knowledge of exponent type assumptions. We obtain the same result, under the assumptions stated above.</p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8">1.2 Techniques</h3>

    <p class="text-gray-300">Constructing extractable functions. We now sketch how we construct extractable one-way functions against BAPT adversaries. To convey the basic idea behind our construction, consider the following first attempt. Let PRG:  <span class="math">\\{0,1\\}^n \\to \\{0,1\\}^{3n}</span>  be a pseudorandom generator. Define  <span class="math">f: \\{0,1\\}^n \\times \\{0,1\\}^n \\to \\{0,1\\}^{3n}</span>  as so:</p>

    <p class="text-gray-300"><span class="math">$f(i;s) = \\begin{cases} \\mathsf{PRG}(s) &amp; \\text{if } i \\neq 0^n \\\\ s(1^n) &amp; \\text{if } i = 0^n \\end{cases}.</span>$</p>

    <p class="text-gray-300">That is, if  <span class="math">i \\neq 0^n</span> , apply the PRG to the seed s. Otherwise, interpret s as a machine, and output its first 3n output bits. The one-wayness of f follows from the pseudo-randomness of its output and the fact that a truly random output would have high Kolmogorov complexity. f is also extractable with respect to programs M whose description size is bounded by n: If M outputs some  <span class="math">v \\in \\{0,1\\}^{3n}</span> , the extractor Ext just outputs  <span class="math">(0^n, M)</span> .</p>

    <p class="text-gray-300">The main problem is that the time required to compute f is not bounded by any particular polynomial. One can try to fix this by padding the input with  <span class="math">1^t</span>  where t is the running time of  <span class="math">s(1^n)</span> . However, now the length of the extracted primage depends on the running time of M and is not bounded by any particular polynomial in the length of the image. Such extractable functions do not seem to be as powerful though; in particular, we do not know how to use them for constructing 2-message and 3-message ZK protocols.</p>

    <p class="text-gray-300">A similar problem is encountered in Barak's zero-knowledge protocol [Bar01], where the entire computation of a malicious verifier is used as the simulation trapdoor. As in the protocol of [BLV06], we get around this problem using a non-interactive proof system that allows for <em>quick verification</em> of (possibly long) computations. Instead of computing the output v of  <span class="math">s(1^n)</span> , f will (quickly) verify a proof for the fact that  <span class="math">s(1^n)</span>  outputs v. That is, we define  <span class="math">f&#x27;(0^n, s, v, \\pi)</span>  that outputs v only if  <span class="math">\\pi</span>  is a convincing proof that  <span class="math">s(1^n) = v</span> . Intuitively, the soundness of the proof guarantees that function is still one-way. Extraction from a BAPT adversary M is done by simply computing a proof for its computation.</p>

    <p class="text-gray-300">However, which proof system should we use? Barak [Bar01] uses interactive universal arguments [Kil92, BG08], whereas we need a non-interactive version of universal arguments that we call NIUA. More precisely, in a NIUA, the verifier generates, once and for all, an &quot;offline message&quot;  <span class="math">\\sigma</span>  together with a private verification state  <span class="math">\\tau</span>  and sends  <span class="math">\\sigma</span>  to the prover. Then, the prover can compute a non-interactive proof  <span class="math">\\pi</span>  for any adaptively chosen statement of the sort: &quot;machine M outputs v within v steps&quot;. We require that the verifier runs in time polynomial in the security parameter v, but only polylogarithmic in v, and the prover runs in time polynomial in v.</p>

    <p class="text-gray-300">EOWFs can be constructed from NIUA that are <em>publicly verifiable</em>, that is, where the verification state  <span class="math">\\tau</span>  can be published without compromising soundness. We define a function family  <span class="math">\\{f_k&#x27;\\}</span>  as above, where the key k contains the NIUA offline message  <span class="math">\\sigma</span>  and the verification state  <span class="math">\\tau</span> . The function  <span class="math">f_k&#x27;</span>  will verify an NIUA proof  <span class="math">\\pi</span>  for the fact that the program s outputs v within, say,  <span class="math">n^{\\log n}</span>  steps.</p>

    <p class="text-gray-300"><strong>Instantiating NIUAs.</strong> Alas, we do not know how to construct publicly verifiable NIUAs from standard assumptions. Still, in a recent breakthrough result, Kalai, Raz and Rothblum [KRR13, KRR] construct P-delegation scheme based on any private information retrieval scheme with sub-exponential security. Such P-delegation scheme directly yield NIUA that are <em>privately-verifiable</em>. The problem is that now,</p>

    <p class="text-gray-300">including the NIUA's private verification state  <span class="math">\\tau</span>  as part of the key k will break the soundness of the NIUA and thus also the one-wayness of  <span class="math">f&#x27;_k</span> .</p>

    <p class="text-gray-300">Our solution is to modify the function as follows: The key k will contain the offline message  <span class="math">\\sigma</span>  together with a fully homomorphic encryption  <span class="math">c_{\\tau}</span>  of the corresponding verification state  <span class="math">\\tau</span> . (In fact, a 1-HOP, non-compact homomorphic encryption suffices.) Intuitively, the function is defined as before except that verification of the proof  <span class="math">\\pi</span>  is done homomorphically, using the encrypted verification state  <span class="math">\\tau</span> . That is, we define  <span class="math">f&#x27;&#x27;_{\\sigma,c_{\\tau}}(0^n,s,v,\\pi)=(v,\\hat{c})</span> , where  <span class="math">\\hat{c}</span>  is the result of homomorphically evaluating the privately-verifiable NIUA verifier. In the case that the first field i is not  <span class="math">0^n</span> , instead of just outputting PRG(s), the output includes also an encryption  <span class="math">c_1</span>  of the value 1.</p>

    <p class="text-gray-300">Generalized EOWF. Note that the function f'' is no longer extractable in the standard sense. Given a BAPT adversary M that outputs an image  <span class="math">(v, \\hat{c})</span> , the extractor can compute a proof  <span class="math">\\pi</span>  for the computation of M and output the preimage  <span class="math">(0^n, M, v, \\pi)</span>  as before. However, f'' on this preimage will output  <span class="math">(v, \\hat{c}&#x27;)</span>  where  <span class="math">\\hat{c}&#x27;</span>  is an encryption of 1 that is most probably different than  <span class="math">\\hat{c}</span> . Nonetheless, f'' satisfies the notion of generalized extractable one-way functions (GEOWF). We define an equivalence relation  <span class="math">\\sim</span>  on the range of  <span class="math">f_k</span>  as follows:  <span class="math">(v, \\hat{c}) \\sim (v&#x27;, \\hat{c}&#x27;)</span>  iff v = v' and both  <span class="math">\\hat{c}</span>  and  <span class="math">\\hat{c}&#x27;</span>  are encryptions of 1. As required, the extractor described above outputs a preimage of  <span class="math">(v, \\hat{c}&#x27;)</span>  such that  <span class="math">(v, \\hat{c}) \\sim (v, \\hat{c}&#x27;)</span> . The one-wayness of f'' with respect to  <span class="math">\\sim</span>  follows from the one-wayness of  <span class="math">f&#x27;_k</span>  and the semantic security of the encryption: given an image  <span class="math">(v, \\hat{c})</span> , finding a primage u of  <span class="math">(v, \\hat{c}&#x27;)</span>  such that  <span class="math">(v, \\hat{c}) \\sim (v, \\hat{c}&#x27;)</span>  is hard, since if  <span class="math">\\hat{c}&#x27;</span>  is an encryption of 1, u must also be a valid preimage of v under v, whereas by sematic security the encrypted verification state  <span class="math">c_\\tau</span>  should not help in inverting v. Note that the relation v can only be tested given the secret key for the encryption. We refer to such a relation as privately testable. (The above is somewhat of an oversimplification of the actual definition of v. See the body for details.)</p>

    <p class="text-gray-300">Next, we show how to construct 2-message and 3-message zero-knowledge protocols from GEOWF with a privately testable relation.</p>

    <p class="text-gray-300">From EOWF to 3-message zero-knowledge. We start by describing a 3-message zero-knowledge protocol from strict EOWFs (namely, when the equivalence relation  <span class="math">\\sim</span>  is equality). The protocol follows the Feige-Lapidot-Shamir trapdoor paradigm [FLS99]. The basic idea is to have the verifier sample a function  <span class="math">f_k</span>  from the EOWF family, and send an image  <span class="math">v=f_k(u)</span>  of a random element u, which will serve as the trapdoor. The prover would then give a witness-indistinguishable proof of knowledge attesting that it either knows a witness w for the proven statement, or it knows a preimage u' of v. Intuitively, soundness (and actually proof of knowledge) follow from the one-wayness of  <span class="math">f_k</span>  and the proof of knowledge property of the WI system. Zero-knowledge follows from the extractability of  <span class="math">f_k</span> . Indeed, the simulator, given the code of the verifier, can run the extractor of the EOWF, obtain u, and use it to simulate the WI proof.</p>

    <p class="text-gray-300">Following through on this intuition encounters several difficulties. First, since a WI proof of knowledge requires 3 messages, the first WI prover message must be sent in the first message of the protocol. However, the WI statement is only determined when the verifier sends v in the second protocol message. Therefore, we must make sure to use a WI proof of knowledge where the first prover message does not depend on the statement. Another basic problem concerns the length of the first WI message. Recall that, in our construction of EOWFs against BAPT adversaries, the function's output is longer than the adversary's advice. Since a cheating verifier may compute v using the first WI message as an advice, we must use a WI system where the length of the first message is independent of the length of the proven statement. We design a WI proof of knowledge with the required properties based on ZAPs [DN07] and extractable commitments [PW09].</p>

    <p class="text-gray-300"><strong>2-message zero-knowledge.</strong> In the 2-message protocol, we replace the 3-message WI proof of knowledge with a 2-message WI proof (e.g. ZAP). However, in the above 3-message protocol, soundness is established by using the proof-of-knowledge property of the WI, whereas 2-message WI proofs of knowledge are not known. Instead, we prove soundness using complexity leveraging. The prover adds</p>

    <p class="text-gray-300">to its message a statistically binding commitment to junk, and proves that either &quot;x &isin; L&quot;, or &quot;fk(u) = v <em>and the commitment is to</em> u&quot;. We require that the commitment is invertible in some superpolynomial time T, whereas the one-wayness of f<sup>k</sup> still holds against adversaries that run in time poly(T). Now, an inverter of f<sup>k</sup> can run the cheating prover with a verifier message that contains its input image v, and brute-force break the commitment to obtain a preimage of v.</p>

    <p class="text-gray-300">Replacing EOWF with GEOWF. The zero-knowledge protocols from GEOWFs are similar, with the exception that now, rather than proving knowledge of a preimage of v, the prover will send an image v 0 such that v <sup>0</sup> &sim; v and prove knowledge of a preimage of v 0 . To keep the protocol ZK, the honest prover must be able to sample an image v 0 that is distributed like the image that is sent by the simulator even without knowing a corresponding preimage. In our GEOWF construction, such an equivalent image can be efficiently sampled.</p>

      <h3 id="sec-1.3" class="text-xl font-semibold mt-8">1.3 Why Extractable Functions?</h3>

    <p class="text-gray-300">As pointed out above, the extractable functions constructed here mimic Barak's zero-knowledge protocol <a href="#page-21-0">[Bar01]</a>. The similarity becomes even stronger when considering the two-message zero-knowledge protocol of Barak et. al <a href="#page-22-9">[BLV06]</a>: Our two message protocol can be directly obtained from that of <a href="#page-22-9">[BLV06]</a> by replacing the CS proofs with P-delegation, and accounting for private verifiability as sketched above. This can be done without mention of extractable functions. Still, we believe that the abstraction of extractable functions is helpful in this context. In particular, it helps separating the protocol structure from the underlying mechanism of extracting a secret value from a given adversarial program.</p>

    <p class="text-gray-300">Furthermore, we hope that this abstraction will prove useful for additional applications beyond two and three-message zero-knowledge. Applications like succinct non-interactive arguments (SNARGs) and efficient CCA encryption seem to require extractable functions with stronger properties such as injectiveness or collision-resistance <a href="#page-23-8">[Dam92,</a> <a href="#page-22-8">BCCT12]</a>. At this point, candidates for extractable functions with such properties are known based on non-standard assumptions regarding different number theoretic and algebraic structures, such as the knowledge-of-exponent assumption. In contrast, our construction is unstructured and does not satisfy the above properties. Indeed, in our function it is easy to find collisions: Consider a machine M that just evaluates the function on any arbitrary input u. By simply applying the extractor on M, we can obtain a different preimage u <sup>0</sup> mapping to an equivalent image.</p>

    <p class="text-gray-300">We hope that the proposed construction will provide a stepping stone to improved constructions of stronger extractable functions based on standard and better understood hardness assumptions. Two natural targets here are extractable collision-resistant hash functions and extractable non-interactive commitments.</p>

    <p class="text-gray-300">Organization. Section <a href="#page-5-0">2</a> defines the notion of NIUA and other main tools used in our constructions. Section <a href="#page-7-0">3</a> presents our main construction of GEOWF against BAPT adversaries. Section <a href="#page-13-0">4</a> constructs 2-message and 3-message ZK protocols against BAPT verifiers.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Tools</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Non-Interactive Universal Arguments for Deterministic Computations &amp; Delegation</h3>

    <p class="text-gray-300">We define <em>non-interactive universal arguments for deterministic computations</em> (NIUAs), which can be seen as a special case of Barak's and Goldreich's <a href="#page-22-12">[BG08]</a> UAs. We then explain the relation to the problem of delegation and the corresponding existence result of Kalai, Raz, and Rothblum <a href="#page-24-2">[KRR]</a>.</p>

    <p class="text-gray-300">In what follows, we denote by L<sup>U</sup> the universal language consisting of all tuples (M, x, t) such that M accepts y within t steps. We denote by LU(T) all pairs (M, x) such that (M, x, T) &isin; LU.</p>

    <p class="text-gray-300">Let  <span class="math">T(n) \\in (2^{\\omega(\\log n)}, 2^{\\operatorname{poly}(n)})</span>  be a computable superpolynomial function. An NIUA system for  <span class="math">\\operatorname{Dtime}(T)</span>  consists of three algorithms  <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span>  that work as follows. The (probabilistic) generator  <span class="math">\\mathcal{G}</span> , given a security parameter  <span class="math">1^n</span> , outputs a <em>reference string</em>  <span class="math">\\sigma</span>  and a corresponding <em>verification state</em>  <span class="math">\\tau</span> ; in particular,  <span class="math">\\mathcal{G}</span>  is independent of any statement to be proven later. The honest prover  <span class="math">\\mathcal{P}(M, x; \\sigma)</span>  produces a certificate  <span class="math">\\pi</span>  for the fact that  <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(T(n))</span> . The verifier  <span class="math">\\mathcal{V}(M, x; \\pi, \\tau)</span>  verifies the validity of  <span class="math">\\pi</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (NIUA). A triple of algorithms  <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span>  is a non-interactive universal argument system for for Dtime(T) if it satisfies:</p>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">&bull; Perfect Completeness:</h4>

    <p class="text-gray-300">For any  <span class="math">n \\in \\mathbb{N}</span>  and  <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(T(n))</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{(\\sigma,\\tau) \\leftarrow \\mathcal{G}(1^n)} \\left[ \\mathcal{V}\\left(M, x; \\pi, \\tau\\right) = 1 \\mid \\pi \\leftarrow \\mathcal{P}\\left(M, x; \\sigma\\right) \\right] = 1 \\ .</span>$</p>

    <h4 id="sec-misc-3" class="text-lg font-semibold mt-6">&bull; Adaptive soundness:</h4>

    <p class="text-gray-300">For any polysize prover  <span class="math">\\mathcal{P}^*</span>  and large enough  <span class="math">n \\in \\mathbb{N}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{(\\sigma,\\tau)\\leftarrow\\mathcal{G}(1^n)}} \\left[ \\ \\mathcal{V}(M,x;\\pi,\\tau) = 1 \\ \\left| \\ \\begin{array}{c} (M,x,\\pi)\\leftarrow\\mathcal{P}^*(\\sigma) \\\\ (M,x)\\in\\{0,1\\}^n\\setminus\\mathcal{L}_{\\mathcal{U}}(T(n)) \\end{array} \\right] \\leq \\operatorname{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">&bull; Fast verification and relative prover efficiency:</p>

    <p class="text-gray-300">There exists a polynomial p such that for every  <span class="math">n \\in \\mathbb{N}</span> ,  <span class="math">t \\leq T(n)</span> , and  <span class="math">(M, x) \\in \\mathcal{L}_{\\mathcal{U}}(t)</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>the generator G runs in time p(n);</li>
      <li>the verifier V runs in time p(n + |M| + |x|);</li>
      <li>the prover  <span class="math">\\mathcal{P}</span>  runs in time p(n+|M|+|x|+t).</li>
    </ul>

    <p class="text-gray-300">The system is said to be publicly verifiable if it is sound when  <span class="math">\\tau</span>  is public. In this case, we will assume WLOG that  <span class="math">\\sigma = \\tau</span> .</p>

    <p class="text-gray-300">Existence and connection to delegation of computation. There are two differences between the notion of delegation for deterministic computations (See, e.g., [KRR13]) and the NIUA notion defined above. The first is that a delegation system is associated with a given language  <span class="math">\\mathcal{L}(M)</span>  for a fixed deterministic machine M, and the corresponding efficiency parameters depend on the worst-case running time  <span class="math">T_M</span>  of M. In particular, the generator  <span class="math">\\mathcal G</span>  depends on  <span class="math">T_M</span>  as an extra parameter, and the prover's efficiency is polynomial in the worst-case running time  <span class="math">T_M</span> . The second difference is that only non-adaptive soundness is required; in particular, the generator's message  <span class="math">\\sigma</span>  may depend on the input x.</p>

    <p class="text-gray-300">Kalai, Raz, and Rothblum [KRR] show how to construct such a privately verifiable <em>delegation</em> scheme for every language in  <span class="math">Dtime(T) \\subseteq EXP</span> , assuming subexponentially secure private information retrieval schemes that are subexponentially secure, which can in turn be constructed based the subexponential Learning with Errors assumption [BV11].<sup>3</sup></p>

    <p class="text-gray-300">In order to get a (privately verifiable) NIUA for  <span class="math">\\operatorname{Dtime}(T)</span> , we could potentially use their result with respect to a universal machine and worst-case running time O(T). However, this solution would lack the required prover efficiency, as the prover will always run in time  <span class="math">\\operatorname{poly}(T)</span> , even for machines M with running time  <span class="math">t_M &lt;&lt; T</span> . This is undesired in our case, as we will be interested in T that is superpolynomial. Fortunately, a rather standard transformation does allow to get the required efficiency from</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{3}&lt;/sup&gt;</span> Private information retrieval based on Quadratic Residousity, Decision Diffie-Helmman, or more generally additively homomorphic encryption can also be used. However, this induces worst communication complexity [OI07], and leads to NIUAs for smaller, but still super-polynomial, upper bound T; this is still sufficient for our purpose.</p>

    <p class="text-gray-300">their result. Specifically, we could run the generator in their solution to generate reference string and verification state  <span class="math">(\\sigma, \\tau)</span>  for computations of size t for all  <span class="math">t \\in \\{1, 2, 2^2, \\dots, 2^{\\log T}\\}</span> , and have the prover and verifier use the right  <span class="math">(\\sigma, \\tau)</span>  according to the concrete running time  <span class="math">t_M &lt; T</span> , guaranteeing that the prover's running time is at most  <span class="math">\\operatorname{poly}(2t_M)</span>  as required.</p>

    <p class="text-gray-300">Also, in their scheme, the generator works independently of the input x, but soundness is shown only when  <span class="math">\\sigma</span>  is generated independently of x. To guarantee soundness for adaptively chosen inputs  <span class="math">x \\in \\{0,1\\}^n</span> , we may repeat the above argument 2n times. Since parallel repetition exponentially reduces the soundness error in two-message arguments, we can then take a union bound over all  <span class="math">2^n</span>  adaptive choices of x and get the required soundness. The 2n-factor hit in succinctness and verification time are still tolerable for our purposes (and still satisfy the above definition).</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 1-Hop Homomorphic Encryption</h3>

    <p class="text-gray-300">A 1-Hop homomorphic encryption scheme [GHV10] allows a pair of parties to securely evaluate a function as follows: the first party encrypts an input, the second party homomorphically evaluates a function on the ciphertext, and the first party decrypts the evaluation result. Such a scheme can be instantiated based on garbled-circuits and an appropriate 2-message oblivious transfer protocol, based on either Decision Diffie-Hellman or Quadratic Residuosity [Yao86, GHV10, NP01, AIR01, HK12].</p>

    <p class="text-gray-300"><strong>Definition 2.2.</strong> A scheme (Gen, Enc, Eval, Dec) is a semantically-secure, circuit-private, 1-Hop homomorphic encryption scheme if it satisfies the following properties:</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">&bull; Perfect correctness:</h4>

    <p class="text-gray-300">For any  <span class="math">n \\in \\mathbb{N}</span> ,  <span class="math">u \\in \\{0,1\\}^n</span>  and circuit C:</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{\\mathsf{sk} \\leftarrow \\mathsf{Gen}(1^n) \\\\ \\mathsf{c} \\leftarrow \\mathsf{Enc}_{\\mathsf{sk}}(u) \\\\ \\mathsf{Eval}}} \\left[ \\begin{array}{c} \\hat{\\mathsf{c}} \\leftarrow \\mathsf{Eval}_{\\mathsf{sk}}(\\mathsf{c},C) \\\\ \\mathsf{Dec}_{\\mathsf{sk}}(\\hat{\\mathsf{c}}) = C(u) \\end{array} \\right] = 1 \\ .</span>$</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">&bull; Semantic security:</h4>

    <p class="text-gray-300">For any polysize A, large enough  <span class="math">n \\in \\mathbb{N}</span> , and any pair of inputs  <span class="math">u_0, u_1 \\in \\{0, 1\\}^n</span></p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{\\mathsf{b} \\leftarrow \\{0,1\\}\\\\\\mathsf{sk} \\leftarrow \\mathsf{Gen}(1^n)}} \\left[ \\mathcal{A}(\\mathsf{Enc}_{\\mathsf{sk}}(u_\\mathsf{b})) = \\mathsf{b} \\right] &lt; \\frac{1}{2} + \\mathrm{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">&bull; <u>Circuit privacy</u>: A randomized evaluation should not leak information on the input circuit C. This should hold even for malformed ciphertexts. Formally, let  <span class="math">\\mathcal{E}(x) = \\operatorname{Supp}(\\operatorname{Enc}(x))</span>  be the set of all legal encryptions of x, let  <span class="math">\\mathcal{E}_n = \\bigcup_{x \\in \\{0,1\\}^n} \\mathcal{E}(x)</span>  be the set legal encryptions for strings of length n, and let  <span class="math">\\mathcal{C}_n</span>  be the set of all circuits on n input bits. There exists a (possibly unbounded) simulator  <span class="math">\\mathcal{S}</span>  such that:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\{C, \\mathsf{Eval}(c,C)\\}_{\\substack{n \\in \\mathbb{N}, C \\in \\mathcal{C}_n \\\\ x \\in \\{0,1\\}^n, c \\in \\mathcal{E}(x)}} &amp;\\approx_c \\{C, \\mathcal{S}(c,C(x),|C|)\\}_{\\substack{n \\in \\mathbb{N}, C \\in \\mathcal{C}_n \\\\ x \\in \\{0,1\\}^n, c \\in \\mathcal{E}(x)}} \\\\ \\{C, \\mathsf{Eval}(c,C)\\}_{\\substack{n \\in \\mathbb{N} \\\\ C \\in \\mathcal{C}_n, c \\notin \\mathcal{E}_n}} &amp;\\approx_c \\{C, \\mathcal{S}(c,\\bot,|C|)\\}_{\\substack{n \\in \\mathbb{N} \\\\ C \\in \\mathcal{C}_n, c \\notin \\mathcal{E}_n}} \\end{split}.</span>$</p>

    <p class="text-gray-300">In this section, we define and construct extractable one-way functions against adversaries with bounded advice.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Definitions</h3>

    <p class="text-gray-300">For brevity, we refer to extractable one-way functions against polytime adversaries with m-bounded advice as EOWFs against m-BAPT adversaries. Such functions are one-way in the usual sense, and in addition it is possible to efficiently extract a pre-image from the code of any adversary that outputs a valid image, provided that the adversary only has bounded non-uniform advice, but arbitrary polynomial running time; this, in particular, includes the class of <em>uniform polytime adversaries</em>. Concretely, we shall focus on PPT adversaries with non-uniform advice  <span class="math">z \\in \\{0,1\\}^{m(n)}</span> . We treat any randomness that the machines may use as part of their advice z; in particular, our adversaries are only allowed bounded randomness, which in most application is not a restriction, as they can use a PRG to stretch it (see Remark 3.2).</p>

    <p class="text-gray-300"><strong>Definition 3.1</strong> (EOWFs against m-BAPT adversaries). Let  <span class="math">\\ell, \\ell&#x27;</span>  be polynomially bounded length functions. An efficiently computable family of functions</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\left\\{ f_k : \\{0, 1\\}^{\\ell(n)} \\to \\{0, 1\\}^{\\ell&#x27;(n)} \\mid k \\in \\{0, 1\\}^{\\text{poly}(n)}, n \\in \\mathbb{N} \\right\\} ,</span>$</p>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler K, is an extractable one-way function against adversaries with m-bounded advice if it satisfies:</p>

    <p class="text-gray-300">&bull; One-wayness: For any polysize A, and large enough security parameter  <span class="math">n \\in \\mathbb{N}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{k \\leftarrow \\mathcal{K}(1^n) \\\\ u \\leftarrow \\{0,1\\}^{\\ell(n)}}} \\left[ \\begin{array}{c} u&#x27; \\leftarrow \\mathcal{A}(k, f_k(u)) \\\\ f_k(u&#x27;) = f_k(u) \\end{array} \\right] \\le \\operatorname{negl}(n) .</span>$</p>

    <p class="text-gray-300">&bull; Extractability: For any PPT adversary M, there exists a PPT extractor Ext such that, for any large enough security parameter  <span class="math">n \\in \\mathbb{N}</span> , and advice  <span class="math">z \\in \\{0,1\\}^{m(n)}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathcal{K}(1^n)} \\left[ \\begin{array}{c} v \\leftarrow M(k;z) \\\\ \\exists u : f_k(u) = v \\end{array} \\wedge \\begin{array}{c} u&#x27; \\leftarrow \\mathsf{Ext}(k;z) \\\\ f_k(u&#x27;) \\neq v \\end{array} \\right] \\leq \\mathrm{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">Generalized EOWFs. We next define generalized EOWFs (GEOWFs), analogous to the proximity extractable collision-resistance in [BCCT12]. Here the extractable function family  <span class="math">\\{f_k\\}</span>  is associated with an equivalence relation  <span class="math">\\sim</span>  on the range of  <span class="math">f_k</span> . The one-wayness requirement is then strengthened: not only is it hard to find an exact preimage of v, but it is also hard to find a preimage of any equivalent  <span class="math">v&#x27; \\sim v</span>  (we shall often refer to such a preimage as a &quot;relative preimage&quot;). The extractability requirement is weakened accordingly: the extractor does not have to output an exact preimage of v, but only a preimage of some equivalent  <span class="math">v&#x27; \\sim v</span> . Intuitively, one can think of a generalized EOWF where each  <span class="math">f_k</span>  maps  <span class="math">\\{0,1\\}^\\ell</span>  to  <span class="math">\\{0,1\\}^{\\ell&#x27;}</span>  as a standard EOWF that maps  <span class="math">\\{0,1\\}^\\ell</span>  to the quotient space of co-sets in  <span class="math">\\{0,1\\}^{\\ell&#x27;}</span>  modulo  <span class="math">\\sim</span> .</p>

    <p class="text-gray-300">We may further allow that the relation  <span class="math">\\sim</span>  depends on the key k, where the relation  <span class="math">\\sim</span>  can either be publicly-testable given k, or require the private coins used to sample k for efficient testing. In particular, any standard EOWF is a GEOWF with the publicly-testable equality relation.</p>

    <p class="text-gray-300"><strong>Definition 3.2</strong> (GEOWFs against m-BAPT adversaries). An efficiently computable family of functions</p>

    <p class="text-gray-300"><span class="math">$\\mathcal{F} = \\left\\{ f_k : \\{0, 1\\}^{\\ell(n)} \\to \\{0, 1\\}^{\\ell&#x27;(n)} \\mid k \\in \\{0, 1\\}^{\\text{poly}(n)}, n \\in \\mathbb{N} \\right\\} ,</span>$</p>

    <p class="text-gray-300">associated with an efficient (probabilistic) key sampler K, is an extractable one-way function, with proximity relation  <span class="math">\\sim</span>  on  <span class="math">\\{0,1\\}^{\\ell&#x27;(n)} \\times \\{0,1\\}^{\\ell&#x27;(n)}</span> , against adversaries with m-bounded advice, if it satisfies:</p>

    <p class="text-gray-300">&bull; <em>Strong one-wayness: for any polysize</em> A<em>, and large enough security parameter</em> n &isin; N<em>:</em></p>

    <p class="text-gray-300"><span class="math">$\\Pr_{\\substack{k \\leftarrow \\mathcal{K}(1^n) \\\\ u \\leftarrow \\{0,1\\}^{\\ell(n)}}} \\left[ \\begin{array}{c} u&#x27; \\leftarrow \\mathcal{A}(k, f_k(u)) \\\\ f_k(u) \\sim f_k(u&#x27;) \\end{array} \\right] \\le \\operatorname{negl}(n) .</span>$</p>

    <p class="text-gray-300">&bull; <em>Weak extractability: for any PPT adversary</em> M<em>, there exists a PPT extractor</em> Ext <em>such that, for any large enough security parameter</em> n &isin; N<em>, and advice</em> z &isin; {0, 1} m(n) <em>:</em></p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathcal{K}(1^n)} \\left[ \\begin{array}{c} v \\leftarrow M(k;z) \\\\ \\exists u : f_k(u) = v \\end{array} \\wedge \\begin{array}{c} u&#x27; \\leftarrow \\mathsf{Ext}(k;z) \\\\ f_k(u&#x27;) \\not\\sim v \\end{array} \\right] \\le \\mathrm{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">&bull; <em>Testable relation: There exists a deterministic polytime machine</em> T <em>such that, given the random coins used by</em> K <em>to sample</em> k<em>,</em> T <em>accepts</em> v, v<sup>0</sup> &isin; {0, 1} \` 0 (n) <em>if and only if</em> v &sim;<sup>k</sup> v 0 <em>. The relation is publicly-testable</em> T <em>only requires</em> k<em>, but not the private coins used to sample it.</em></p>

    <p class="text-gray-300"><em>Remark</em> 3.1 (universal extractor)<em>.</em> In the above definitions, each PPT M is required to have a designated PPT extractor ExtM. Our constructions will, in fact, guarantee the existence of one universal extractor Ext that given any (M, z, k) and a bound 1 <sup>t</sup><sup>M</sup> on the running time of M(k; z), can perform extraction. Moreover, the running time of Ext is bounded by some (universal) polynomial poly(tM) in the running time of M.</p>

    <p class="text-gray-300"><em>Remark</em> 3.2 (bounded randomness)<em>.</em> In our definitions, we assumed that any randomness used by the machines is part of their bounded advice, and in particular, is bounded itself. For many applications, this is sufficient as we can transform any adversary that uses arbitrary polynomial randomness to one that uses bounded randomness, by having it stretch its randomness with a PRG. (Alternatively, we can achieve an alternative extraction definition where the extractor is randomized and is allowed to simulate the adversary's randomness.) This approach is applicable for example for ZK against BAPT verifiers (see Section <a href="#page-13-0">4)</a>, as well as for any application where testing if the adversary breaks the scheme can be done efficiently.</p>

    <p class="text-gray-300">Additional properties of GEOWFs. We next discuss additional properties of GEOWFs that will prove useful in the design of protocols.</p>

    <p class="text-gray-300">The first property is called <em>everywhere extractability</em> and requires that extractability does not only hold with overwhelming over keys k &larr; K(1<sup>n</sup> ), but also holds for any maliciously chosen key.</p>

    <p class="text-gray-300">Definition 3.3. <em>A GEOWF (or EOWF) is said to satisfy everywhere extractability if weak extractability holds for any</em> k &isin; {0, 1} poly(n) <em>, where</em> poly(n) <em>is the length of keys output by</em> K(1<sup>n</sup> )<em>.</em></p>

    <p class="text-gray-300">We note that everywhere extractability cannot be achieved if the output of the function \` 0 is shorter than the length of the advice m that the adversary is allowed; otherwise, the adversary may simply get as advice a random image under some key, and the extractor would fail to invert for that key. Indeed, in our constructions that achieve everywhere extractability, the output of the function will be longer than the allowed advice.</p>

    <p class="text-gray-300">Also, we note that one can make an analogous property of <em>everywhere one-wayness</em>, which for some applications may be a sufficient alternative to everywhere extractability; however, we will not require (nor achieve) this property in this work.</p>

    <p class="text-gray-300">The second property, called <em>oblivious image sampling</em>, strengthens even further the extractability requirement, saying that the distribution of images v <sup>0</sup> = fk(u 0 ) induced by the extraction procedure Ext is simulatable, given only the image v output by the adversary M (and without the code of M). Accordingly, the extractor Ext will now be randomized.</p>

    <p class="text-gray-300">The requirement that  <span class="math">\\tilde{v} \\sim v</span>  is stated for the sake of clarity, and actually follows automatically from the fact that everywhere extraction guarantees  <span class="math">v&#x27; \\sim v</span> , and that  <span class="math">v&#x27; \\approx_c \\tilde{v}&#x27;</span> . We also note that oblivious image sampling automatically holds for standard EOWFs (rather than GEOWF) that are everywhere extractable. Indeed, the image sampler can just output the same image v it gets as input.</p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Constructions</h3>

    <p class="text-gray-300">We start by describing a construction of a (standard) EOWF against BAPT adversaries from any publicly verifiable NIUA system and any pseudorandom generator. We then provide an augmented construction of a GEOWF based only on privately verifiable NIUA and any 1-Hop homomorphic encryption scheme.</p>

      <h4 id="sec-3.2.1" class="text-lg font-semibold mt-6">3.2.1 EOWF from publicly verifiable NIUA.</h4>

    <p class="text-gray-300">In what follows, let  <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span>  be a publicly verifiable NIUA system for  <span class="math">\\operatorname{Dtime}(T(n))</span>  for some function  <span class="math">T(n) \\in (2^{\\omega(\\log n)}, 2^{\\operatorname{poly}(n)})</span> , and assume that for security parameter  <span class="math">n, \\mathcal{G}(1^n)</span>  outputs the public reference string (which is also the verification state)  <span class="math">\\sigma \\in \\{0,1\\}^n</span> , and that  <span class="math">\\mathcal{P}</span>  outputs certificates  <span class="math">\\pi</span>  of size n. Let PRG be a pseudo random generator stretching n bits to m(n) + 2n bits. The construction basically follows the high-level ideas presented in the introduction (with slight syntactic differences).</p>

    <p class="text-gray-300">Construction 3.1. The key generation algorithm K is just the generator G.</p>

    <p class="text-gray-300">The function is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$(i; M, y, \\pi; s) \\xrightarrow{f_{\\sigma}} \\begin{cases} y, \\mathcal{V}(M, \\sigma, y; \\pi, \\sigma) &amp; \\text{if } i = 0^n \\\\ \\mathsf{PRG}(s), 1 &amp; \\text{if } i \\neq 0^n \\end{cases},</span>$</p>

    <p class="text-gray-300">where  <span class="math">V(M, \\sigma, y; \\pi, \\sigma)</span>  is the result of verifying the certificate  <span class="math">\\pi</span>  for the statement &quot; <span class="math">M(\\sigma) = y</span>  within T(n) steps&quot;. Each of the inputs to the function is of length n, except M that is of length m, and y that is of length m + 2n, like  <span class="math">\\mathsf{PRG}(s)</span> .</p>

    <p class="text-gray-300"><strong>Theorem 3.1.</strong> The function family  <span class="math">\\mathcal{F} = \\{f_k\\}_{n \\in \\mathbb{N}}</span> , given by Construction 3.1, is a GEOWF against  <span class="math">(m - \\omega(1))</span> -BAPT adversaries.</p>

    <p class="text-gray-300"><strong>High-level idea behind the proof.</strong> To see that the function is one-way, note that a random image v is almost always the output of a PRG (i.e., comes from the  <span class="math">i \\neq 0^n</span>  branch). To invert it, the adversary must either invert the PRG, in which case it can produce a preimage of the  <span class="math">i \\neq 0^n</span>  type, or it could find a short machine M and an accepting proof that it outputs v, in which case it can produce a preimage of the  <span class="math">i = 0^n</span>  type. The first case does not occur since PRG is one-way. The second case cannot occur because of the pseudorandomness of PRG and the soundness of the NIUA; indeed, had we replace the output v of the PRG with a truly random string, it would almost surely have high Kolomogorov complexity, and a short machine M that outputs v wouldn't exist, meaning that the inverter would have to produce an accepting proof for a false statement, and violate soundness.</p>

    <p class="text-gray-300">As for extraction, given a machine  <span class="math">M_z</span>  with short advice z that outputs (v, 1), the extractor simply computes a proof  <span class="math">\\pi</span>  for this computation, and outputs the preimage  <span class="math">(0^n; M_z, v, \\pi; 1^n)</span> . If M outputs something of the form (v, 0), the extractor produces instead some non accepting statement and proof  <span class="math">(M&#x27;, \\pi&#x27;)</span> , and outputs  <span class="math">(0^n; M&#x27;, v, \\pi&#x27;; 1^n)</span> .</p>

    <p class="text-gray-300">We omit the full proof, which is subsumed by the proof of the private-verifiability case treated below.</p>

      <h4 id="sec-3.2.2" class="text-lg font-semibold mt-6">3.2.2 GEOWF from privately verifiable NIUA.</h4>

    <p class="text-gray-300">Let  <span class="math">(\\mathcal{G}, \\mathcal{P}, \\mathcal{V})</span>  be a privately verifiable NIUA system for Dtime(T(n)) for some function  <span class="math">T(n) \\in (2^{\\omega(\\log n)}, 2^{\\text{poly}(n)})</span> , and assume that for security parameter n,  <span class="math">\\mathcal{G}(1^n)</span>  outputs a public reference string  <span class="math">\\sigma</span>  and private verification state  <span class="math">\\tau</span> , each of size n, and assume that  <span class="math">\\mathcal{P}</span>  outputs certificates  <span class="math">\\pi</span>  of size n. Let PRG be a</p>

    <p class="text-gray-300">pseudo random generator stretching n bits to  <span class="math">m(n)+n^2+2n</span>  bits. Let (Gen, Enc, Dec, Eval) be a 1-Hop homomorphic encryption scheme (not necessarily compact), and assume that a cipher c encrypting n bits is of size  <span class="math">n^2</span> . Let  <span class="math">\\mathcal{C}_{\\mathcal{V}}=\\mathcal{C}_{\\mathcal{V}}(M,\\sigma,\\mathsf{c},y,\\pi,\\cdot)</span>  be a circuit that, given  <span class="math">\\tau</span>  as input, verifies that  <span class="math">\\mathcal{V}(M,(\\sigma,\\mathsf{c}),y;\\pi,\\tau)=1</span> ; namely, it verifiers the certificate  <span class="math">\\pi</span>  for the statement &quot; <span class="math">M(\\sigma,\\mathsf{c})=y</span>  within T(n) steps&quot;. Let  <span class="math">\\mathcal{C}_1</span>  be a circuit that always outputs 1 and is of the same size as  <span class="math">\\mathcal{C}_{\\mathcal{V}}</span> .</p>

    <p class="text-gray-300">Construction 3.2. The key generator  <span class="math">\\mathcal{K}</span>  samples  <span class="math">(\\sigma, \\tau) \\leftarrow \\mathcal{G}(1^n)</span> ,  <span class="math">c_{\\tau} \\leftarrow \\mathsf{Enc}(\\tau)</span> , and outputs  <span class="math">\\sigma, c_{\\tau}</span> . The function  <span class="math">f_{\\sigma, c_{\\tau}}</span>  is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$(i; M, y, \\pi; s) \\stackrel{f_{\\sigma, c_{\\tau}}}{\\longmapsto} \\begin{cases} y, \\hat{c}_{\\mathcal{V}}, i &amp; \\text{if } i = 0^n \\\\ \\mathsf{PRG}(s), \\hat{c}_1, i &amp; \\text{if } i \\neq 0^n \\end{cases},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{c}_{\\mathcal{V}} \\leftarrow \\text{Eval}(\\mathcal{C}_{\\mathcal{V}}, c_{\\tau})</span>  and  <span class="math">\\hat{c}_1 \\leftarrow \\text{Eval}(\\mathcal{C}_1, c_{\\tau})</span>  (both Eval can be deterministic). Each of the inputs to the function are of length n, except M that is of length m, and y that is of length  <span class="math">m + n^2 + 2n</span> .</p>

    <p class="text-gray-300">The proximity relation  <span class="math">\\sim</span>  is defined as follows:  <span class="math">(y, \\hat{c}, i) \\sim (y&#x27;, \\hat{c}&#x27;, i&#x27;)</span>  if either</p>

    <p class="text-gray-300"><span class="math">$y = y&#x27;</span>$
and  <span class="math">Dec(\\hat{c}) = Dec(\\hat{c}&#x27;) = 1</span> ,
or  <span class="math">i = i&#x27; = 0</span> .</p>

    <p class="text-gray-300"><strong>Theorem 3.2.</strong> The function family  <span class="math">\\mathcal{F} = \\{f_k\\}_{n \\in \\mathbb{N}}</span> , given by Construction 3.1, is a GEOWF, against  <span class="math">(m - \\omega(1))</span> -BAPT adversaries, with a privately testable equivalence relation.</p>

    <p class="text-gray-300"><strong>High-level idea behind the proof.</strong> The proof follows the same high-level ideas as in the previous construction, except that now there is a private NIUA verification state  <span class="math">\\tau</span>  that has to remain secret or soundness, and thus also one-wayness, will be compromised. By including an encryption of  <span class="math">\\tau</span>  in the key, we guarantee that soundness and one-wayness are maintained. However, now the NIUA verification has to be done homomorphically under the encryption. The reason that i is added to the output of the function is to guarantee that we can extract in cases that the adversary produces an output of v,  <span class="math">\\hat{c}</span> , where  <span class="math">\\text{Dec}(\\hat{c}) = 0</span>  (e.g. by choosing a false statement). Unlike in the previous construction, the extractor cannot tell that this is the case simply by looking at  <span class="math">\\hat{c}</span> , which is why we provide it with i.</p>

    <p class="text-gray-300">We now provide a more detailed proof sketch.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We first show strong one-wayness, and then show weak extractability. The fact that the relation is testable given the coins used to sample k (specifically the decryption key) follows readily.</p>

    <p class="text-gray-300"><strong>Strong one-wayness.</strong> Assume that given  <span class="math">f_{\\sigma,c_{\\tau}}(u)</span> , where  <span class="math">u \\leftarrow \\{0,1\\}^{\\ell(n)}</span>  and  <span class="math">(\\sigma,c_{\\tau}) \\leftarrow \\mathcal{K}(1^n)</span> , a polysize inverter  <span class="math">\\mathcal{I}</span>  finds u' such that  <span class="math">f_k(u) \\sim f_k(u&#x27;)</span>  with noticeable probability  <span class="math">\\epsilon</span> . We describe a polysize adversary  <span class="math">\\mathcal{B}</span>  that breaks the soundness of the NIUA with probability  <span class="math">\\epsilon - \\operatorname{negl}(n)</span> . Given  <span class="math">\\sigma, \\mathcal{B}</span>  first samples  <span class="math">c_0 \\leftarrow \\operatorname{Enc}(0^n)</span> , and computes  <span class="math">\\hat{c} \\leftarrow \\operatorname{Eval}(\\mathcal{C}_1, c_0)</span> . It then samples  <span class="math">r \\leftarrow U_{m+n^2+2n}</span> ,  <span class="math">i \\leftarrow U_n</span> , and runs the inverter  <span class="math">\\mathcal{I}((\\sigma, c_0), (r, \\hat{c}, i))</span>  who outputs  <span class="math">u&#x27; = (i&#x27;; M&#x27;, y&#x27;, \\pi&#x27;; s&#x27;)</span> .</p>

    <p class="text-gray-300">We claim that, with probability  <span class="math">\\epsilon - \\operatorname{negl}(n)</span> ,  <span class="math">\\pi&#x27;</span>  is a valid certificate for the fact that  <span class="math">M&#x27;(\\sigma, c_0) = r</span> ; namely,  <span class="math">\\mathcal{V}(M&#x27;, (\\sigma, c_0), y&#x27;; \\pi, \\tau) = 1</span> . Indeed, if this is the case, we are done since  <span class="math">|M&#x27;| + |\\sigma| + |c_0| \\le m + n + n^2</span> , and thus  <span class="math">M&#x27;(\\sigma, c_0) = r</span>  with probability at most  <span class="math">2^{-n}</span> . This implies that  <span class="math">\\pi&#x27;</span>  is an accepting proof for a false statement with probability  <span class="math">\\epsilon - \\operatorname{negl}(n)</span> . To prove the claim we consider two hybrid breakers.</p>

    <p class="text-gray-300"><strong>Breaker</strong>  <span class="math">\\mathcal{B}_0</span>  samples  <span class="math">r_0 \\leftarrow \\mathsf{PRG}(U_n)</span> ,  <span class="math">i \\leftarrow U_n</span>  on its own, gets an external encryption  <span class="math">\\mathsf{c}_\\tau</span>  of the random coins used by the generator  <span class="math">\\mathcal{G}</span>  of the NIUA system, computes  <span class="math">\\hat{\\mathsf{c}} \\leftarrow \\mathsf{Eval}(\\mathcal{C}_1, \\mathsf{c}_\\tau)</span> , and runs  <span class="math">\\mathcal{I}((\\sigma, \\mathsf{c}_\\tau), (r_0, \\hat{\\mathsf{c}}, i))</span> . We claim that, with probability  <span class="math">\\epsilon - \\mathsf{negl}(n)</span> ,  <span class="math">\\mathcal{B}_0</span>  obtains u' such that  <span class="math">f_{\\sigma, \\mathsf{c}_\\tau}(u&#x27;) \\sim (r_0, \\hat{\\mathsf{c}}, i)</span> . Indeed,  <span class="math">\\mathcal{I}</span> 's input is distributed identically to the original inversion experiment conditioned on  <span class="math">i \\neq 0^n</span> , which occurs with probability  <span class="math">1 - 2^{-n}</span> .</p>

    <p class="text-gray-300">Now, consider  <span class="math">\\mathcal{B}_0</span> 's output  <span class="math">u&#x27;=(i&#x27;;M&#x27;,y&#x27;,\\pi&#x27;;s&#x27;)</span> . We claim that, except with negligible probability, whenever  <span class="math">(r_0,\\hat{\\mathsf{c}},i)\\sim f_{\\sigma,\\mathsf{c}_\\tau}(u&#x27;)</span> , it must be that  <span class="math">i&#x27;=0^n</span>  (and  <span class="math">i\\neq 0^n</span> ), meaning that  <span class="math">\\mathcal{B}_0</span>  finds  <span class="math">(M&#x27;,y&#x27;,\\pi&#x27;)</span> , such that  <span class="math">\\mathsf{Dec}(\\mathsf{Eval}(\\mathcal{C}_\\mathcal{V},\\mathsf{c}_\\tau))=\\mathsf{Dec}(\\hat{\\mathsf{c}})=1</span> , and  <span class="math">y&#x27;=r_0</span> , which in turn implies that  <span class="math">\\pi&#x27;</span>  is an accepting proof for the fact that  <span class="math">M&#x27;(\\sigma,\\mathsf{c}_\\tau)=y&#x27;=r_0</span> . Indeed, if (relative) inversion occurs with noticeable probability when  <span class="math">i&#x27;\\neq 0^n</span> , we can use  <span class="math">\\mathcal{B}_0</span>  to invert PRG, contradicting its one-wayness.</p>

    <p class="text-gray-300"><strong>Breaker</strong>  <span class="math">\\mathcal{B}_1</span>  operates exactly like  <span class="math">\\mathcal{B}_0</span> , but gets an external encryption  <span class="math">c_0</span>  of  <span class="math">0^n</span> , instead of  <span class="math">\\tau</span> . By semantic security,  <span class="math">\\mathcal{B}_1</span>  would also find  <span class="math">(M&#x27;, \\pi&#x27;)</span>  such that  <span class="math">\\pi&#x27;</span>  is a valid for certificate for the statement &quot; <span class="math">M&#x27;(\\sigma, c_0) = r_0</span>  within T(n) steps&quot; with probability  <span class="math">\\epsilon - \\text{negl}(n)</span> .</p>

    <p class="text-gray-300">To conclude the proof, we observe that the only difference between  <span class="math">\\mathcal{B}_1</span>  and  <span class="math">\\mathcal{B}</span>  is that  <span class="math">\\mathcal{B}</span>  samples  <span class="math">r \\leftarrow U_{m+n^2+2n}</span> , rather than  <span class="math">r_0 \\leftarrow \\mathsf{PRG}(U_n)</span> , and so the claim follows by pseudo-randomness.</p>

    <p class="text-gray-300">Weak extractability. We now show weak extractability via a universal extractor Ext (see Remark 3.1). For an adversarial code M and advice  <span class="math">z \\in \\{0,1\\}^{m-\\omega(1)}</span>  denote by  <span class="math">M_z</span>  the machine  <span class="math">M(\\cdot;z)</span> . Given any key  <span class="math">k = (\\sigma, c_\\tau)</span>  and (M, z), where  <span class="math">M_z</span>  has description size at most m(n) and running time at most t &lt; T(n), and  <span class="math">M_z(\\sigma, c_\\tau) = (y, \\hat{c}, i) \\in \\mathsf{Image}(f_k)</span> .</p>

    <p class="text-gray-300">Our extractor Ext works according to two cases. If  <span class="math">i=0^n</span> , the extractor simply outputs some canonical  <span class="math">u&#x27;_*=(i&#x27;;M&#x27;,y&#x27;,\\pi&#x27;;s&#x27;)</span> , such that  <span class="math">i&#x27;=0^n</span> . If  <span class="math">i\\neq 0^n</span> , Ext computes a certificate  <span class="math">\\pi</span>  for the fact that &quot; <span class="math">M_z(\\sigma, \\mathbf{c}_\\tau) = y</span> &quot;, and then outputs the (relative) pre-image  <span class="math">u&#x27;=(0^n,M_z,y,\\pi,s)</span> , where s could be any arbitrary string, e.g.,  <span class="math">1^n</span> . By definition  <span class="math">f_k(u&#x27;)=(y,\\operatorname{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathbf{c}_\\tau),0^n)</span> , so to guarantee that  <span class="math">f_k(u&#x27;)\\sim(y,\\hat{\\mathbf{c}},i)</span> , it is left to see that  <span class="math">\\operatorname{Dec}(\\operatorname{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathbf{c}_\\tau))=\\operatorname{Dec}(\\hat{\\mathbf{c}})</span> . Indeed, if  <span class="math">i\\neq 0^n</span> , it is guaranteed that  <span class="math">\\operatorname{Dec}(\\hat{\\mathbf{c}})=1</span> . Furthermore, for any  <span class="math">k\\in\\operatorname{supp}(\\mathcal{K}(1^n))</span> , by the perfect completeness of the NIUA system and perfect correctness of the 1-Hop homomorphic encryption, it also holds that  <span class="math">\\operatorname{Dec}(\\operatorname{Eval}(\\mathcal{C}_{\\mathcal{V}},\\mathbf{c}_\\tau))=1</span> .</p>

    <p class="text-gray-300">Everywhere extractability and oblivious image sampling. We note that the extractor described above works for  <span class="math">k \\in \\operatorname{supp}(\\mathcal{K}(1^n))</span> , and not only for an overwhelming fraction of keys in the support. However, the extractor is not guaranteed to work for a maliciously chosen  <span class="math">k \\notin \\operatorname{supp}(\\mathcal{K}(1^n))</span> . For example, if the NIUA keys  <span class="math">\\sigma</span>  and  <span class="math">\\tau</span>  (determined by  <span class="math">c_{\\tau}</span> ) are maliciously sampled, it may be that the NIUA verification procedure would reject true statements; in particular, it could be that  <span class="math">\\operatorname{Dec}(\\operatorname{Eval}(\\mathcal{C}_{\\mathcal{V}}, c_{\\tau})) = 0</span> , and thus extraction would fail. Looking ahead, the very same problem would prevent us from obtaining oblivious image sampling for maliciously chosen keys.</p>

    <p class="text-gray-300">We now show, however, that we can slightly augment the construction so it would satisfy both everywhere extractability and oblivious image sampling. The high-level idea is to simply embed inside the function a test for the validity of the key k.</p>

    <p class="text-gray-300">Specifically, instead of including in the key only an encryption  <span class="math">c_{\\tau}</span>  of the NIUA's private verification state, we will include an encryption  <span class="math">c_r</span>  of the randomness r used by the NIUA generator  <span class="math">\\mathcal G</span>  to sample  <span class="math">(\\sigma,\\tau)</span> . Now, instead of the circuit  <span class="math">\\mathcal C_{\\mathcal V}=\\mathcal C_{\\mathcal V}(M,\\sigma,\\mathsf c,y,\\pi,\\cdot)</span>  that, given  <span class="math">\\tau</span>  as input, verifies that  <span class="math">\\mathcal V(M,(\\sigma,\\mathsf c),y;\\pi,\\tau)=1</span> , we will consider a new circuit  <span class="math">\\mathcal C_{\\mathcal V,\\mathcal G}(M,\\sigma,\\mathsf c,y,\\pi,\\cdot)</span>  that, given r derives r, and checks the above, but in addition also checks that r is consistent with  <span class="math">\\mathcal G(1^n;r)</span> . Analogously, instead of the circuit  <span class="math">\\mathcal C_1</span>  that always outputs 1, we will consider the circuit  <span class="math">\\mathcal C_{\\mathcal G}(\\sigma,\\cdot)</span>  that, given r, checks that r0 is consistent with r2 that always outputs 1, we will consider the circuit r3 that, given r4 checks that r4 is consistent with r5 that, and additional tweak meant to support oblivious image sampling is that now the homomorphic evaluation procedures will be randomized to guarantee circuit privacy.</p>

    <p class="text-gray-300">Overall the augmented function  <span class="math">f_{\\sigma,c_r}</span>  is defined as follows:</p>

    <p class="text-gray-300"><span class="math">$(i; M, y, \\pi; s; r&#x27;) \\stackrel{f_{\\sigma, c_{\\tau}}}{\\longmapsto} \\begin{cases} y, \\hat{c}_{\\mathcal{V}, \\mathcal{G}}, i &amp; \\text{if } i = 0^n \\\\ \\mathsf{PRG}(s), \\hat{c}_{\\mathcal{G}}, i &amp; \\text{if } i \\neq 0^n \\end{cases} ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\hat{c}_{\\mathcal{V}} \\leftarrow \\text{Eval}(\\mathcal{C}_{\\mathcal{V}}, c_r; r&#x27;)</span>  and  <span class="math">\\hat{c}_{\\mathcal{G}} \\leftarrow \\text{Eval}(\\mathcal{C}_{\\mathcal{G}}, c_r; r&#x27;)</span>  are now randomized to guarantee circuit privacy. The proximity relation  <span class="math">\\sim</span>  is augmented to account also for the case that  <span class="math">\\text{Dec}(\\hat{c}) = 0</span>  (due to a malicious choice of keys):</p>

    <p class="text-gray-300"><span class="math">$y = y&#x27;</span>$
and  <span class="math">Dec(\\hat{c}) = Dec(\\hat{c}&#x27;)</span> ,
or  <span class="math">i = i&#x27; = 0</span> .</p>

    <p class="text-gray-300"><strong>Claim 3.1.</strong> The augmented construction is a GEOWF that satisfies both everywhere extractability and oblivious image sampling.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> First, since for an honestly sampled k the new function is equivalent to the previous, strong one-wayness of the function holds just as before. As for extractability, the extractor is defined exactly as before only that now it also has to output randomness r' for the homomorphic evaluation, which it will just sample uniformly at random. Now, even when  <span class="math">k \\notin \\operatorname{supp}(\\mathcal{K}(1^n))</span> , extraction is still guaranteed. Indeed, the only case that changes is when  <span class="math">\\sigma</span>  is not sampled consistently with r and  <span class="math">i \\neq 0^n</span> ; here, both  <span class="math">\\hat{c}_{\\mathcal{V},\\mathcal{G}}</span>  corresponding to the extracted value, and  <span class="math">\\hat{c}_{\\mathcal{G}}</span>  corresponding to the adversary's image would decrypt to 0.</p>

    <p class="text-gray-300">We next show that oblivious key sampling holds. The image sampler  <span class="math">\\mathcal{I}</span> , given a key  <span class="math">k=(\\tau,\\mathsf{c}_r)</span>  and an image  <span class="math">v=(y,\\hat{\\mathsf{c}},i)</span> , acts according to two cases (similarly to the extractor). If  <span class="math">i=0^n</span> , it can completely imitate the extractor choosing a canonical  <span class="math">u&#x27;_*=(i&#x27;;M&#x27;,y&#x27;,\\pi&#x27;;s&#x27;;r&#x27;)</span>  with i'=n, and outputting  <span class="math">\\tilde{v}=f_k(u&#x27;_*)</span> . If  <span class="math">i\\neq 0^n</span> ,  <span class="math">\\mathcal{I}</span>  outputs  <span class="math">\\tilde{v}=(y,\\hat{\\mathsf{c}}&#x27;&#x27;,i)</span> , where  <span class="math">\\hat{\\mathsf{c}}&#x27;&#x27;\\leftarrow \\mathsf{Eval}(\\mathcal{C}_{\\mathcal{G}},\\mathsf{c}_{\\tau})</span>  (and Eval is randomized). Indeed, the image output by  <span class="math">\\mathcal{I}</span>  is the same as the one induced by the extractor, except that  <span class="math">\\hat{\\mathsf{c}}&#x27;&#x27;</span>  may differ from the evaluated cipher  <span class="math">\\hat{\\mathsf{c}}&#x27;</span>  output by the extractor. However, as explained above, we are guaranteed that in this case  <span class="math">\\mathsf{Dec}(\\hat{\\mathsf{c}}&#x27;&#x27;)=\\mathsf{Dec}(\\hat{\\mathsf{c}}&#x27;)</span> , and so by the circuit privacy of the 1-Hop scheme, the output  <span class="math">\\tilde{v}</span>  of  <span class="math">\\mathcal{I}</span>  is computationally indistinguishable from the output v' induced by the extraction procedure  <span class="math">\\mathsf{Ext}</span> . (Recall that circuit privacy here holds even if the cipher  <span class="math">\\mathsf{c}_r</span>  is sampled maliciously.)</p>

    <p class="text-gray-300">Remark 3.3 (one-wayness against superpolynomial adversaries). In Section 4.3.2, we shall require GEOWFs that are one way even against adversaries of size poly(T(n)), for some superpolynomial function T(n). Such GEOWFs can be obtained from our constructions, by using a PRG that is secure that is secure against poly(T(n)) adversaries, and an NIUA that is sound against such adversaries (such an NIUA can be obtained from [KRR], based on an appropriately strong private information retrieval scheme).</p>

    <p class="text-gray-300">In this section, we define and construct two and three message ZK arguments against verifiers with bounded advice.</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Definition</h3>

    <p class="text-gray-300">The standard definition of zero-knowledge [GMR89, Gol04] considers adversarial verifiers with non-uniform auxiliary input of arbitrary polynomial size. We consider a relaxed notion of zero-knowledge against verifiers that have bounded non-uniform advice, but arbitrary polynomial running time. This relaxed notion, in particular, includes zero-knowledge against uniform verifiers (sometimes referred to as <em>plain zero-knowledge</em> [BLV06]).</p>

    <p class="text-gray-300">Concretely, we shall focus on PPT verifiers  <span class="math">V^*</span>  having advice z of size at most m, and using an arbitrary polynomial number of random coins.</p>

    <p class="text-gray-300"><strong>Definition 4.1.</strong> An argument system (P, V) is zero-knowledge against verifiers with m-bounded advice if for every PPT verifier  <span class="math">V^*</span> , there exists a PPT simulator Sim such that:</p>

    <p class="text-gray-300"><span class="math">$\\{ \\langle P(w) \\leftrightarrows V^*(z) \\rangle(x) \\}_{\\substack{(x,w) \\in \\mathcal{R}_{\\mathcal{L}} \\\\ z \\in \\{0,1\\}^{m(|x|)}}} \\approx_c \\{ \\operatorname{Sim}(z,x) \\}_{\\substack{(x,w) \\in \\mathcal{R}_{\\mathcal{L}} \\\\ z \\in \\{0,1\\}^{m(|x|)}}} ,</span>$</p>

    <p class="text-gray-300">where computational indistinguishability is with respect to arbitrary non-uniform distinguishers.</p>

    <p class="text-gray-300">Remark 4.1 (universal simulator). In the above definition, each PPT  <span class="math">V^*</span>  is required to have a designated PPT simulator  <span class="math">\\operatorname{Sim}_V^*</span> . Our constructions will, in fact, guarantee the existence of one universal simulator  <span class="math">\\operatorname{Sim}</span>  that, in addition to (z,x), is also given the code of  <span class="math">V^*</span>  and a bound  <span class="math">1^{t_V^*}</span>  on the running time of  <span class="math">V^*(x;z)</span> , and simulates  <span class="math">V^*</span> 's view. Moreover, the running time of  <span class="math">\\operatorname{Sim}</span>  is bounded by some (universal) polynomial  <span class="math">\\operatorname{poly}(t_V^*)</span>  in the running time of  <span class="math">V^*</span> . We note that, in ZK with unbounded polynomial auxiliary input, such universality follows automatically by considering the universal machine and auxiliary input  <span class="math">(V^*, 1^{t_V^*})</span> . In our context, however, this does not hold since  <span class="math">t_{V^*}</span>  is unbounded and can be larger than the bound m on the size of the advice.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 WI Proof of Knowledge with an Instance-Independent First Message</h3>

    <p class="text-gray-300">In this section, we define and construct 3-message WI proofs of knowledge with an instance-independent first message, which will be used in our construction of a 3-message ZK argument of knowledge. In such proof systems, the prover's first message is completely independent of the statement and witness  <span class="math">(x,w) \\in \\mathcal{R}_{\\mathcal{L}}</span>  to be proven; in particular, it is of fixed polynomial length in the security parameter n, independently of |x,w|.</p>

    <p class="text-gray-300">Classical WIPOK protocols do not satisfy this requirement. For example, in the classical Hamiltonicity protocol [Blu86], the first message is independent of the witness w, but does depend on the statement x. In Lapidot and Shamir's Hamiltonicity variant [LS90], the first message is independent of (x, w) themselves, but does depend on |x, w| (see details in [OV12]). ZAPs do satisfy the independence requirement (as there is no first prover message at all), but they do not provide proof of knowledge.</p>

    <p class="text-gray-300">We show that, using ZAPs, and 3-message extractable commitments, we can obtain a WIPOK where the first (prover) message is completely independent of (x, w), even of their length, and the second (verifier) message only depends on |x|.</p>

    <p class="text-gray-300"><strong>Definition 4.2</strong> (WIPOK with instance-independent first message). Let  <span class="math">\\langle P \\leftrightarrows V \\rangle</span>  be a 3-message proof system for  <span class="math">\\mathcal L</span>  with messages  <span class="math">(\\alpha, \\beta, \\gamma)</span> ; we say it is a WIPOK with instance-independent first message, if it satisfies:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Completeness with first message independence: For any  <span class="math">x \\in \\mathcal{L} \\cap \\{0,1\\}^{\\ell}</span> ,  <span class="math">w \\in \\mathcal{R}_{\\mathcal{L}}(x)</span> ,  <span class="math">n \\in \\mathbb{N}</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[V(x,\\alpha,\\beta,\\gamma;r&#x27;) = 1 \\middle| \\begin{array}{c} \\alpha \\leftarrow P(1^n;r) \\\\ \\beta \\leftarrow V(\\ell,\\alpha;r&#x27;) \\\\ \\gamma \\leftarrow P(x,w,\\alpha,\\beta;r) \\end{array} \\right] = 1 ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">r, r&#x27; \\leftarrow \\{0, 1\\}^{\\text{poly}(n)}</span>  are the randomness used by P and V.</p>

    <p class="text-gray-300">The honest prover's first message  <span class="math">\\alpha</span>  is of length n, independently of the length of the statement and witness (x, w).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Adaptive witness-indistinguishability: for any deterministic polysize verifier  <span class="math">V^*</span>  and all large enough  <span class="math">n \\in \\mathbb{N}</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\Pr \\left[ V^*(x, \\alpha, \\beta, \\gamma) = b \\, \\middle| \\, \\begin{array}{c} \\alpha \\leftarrow P(1^n; r) \\\\ x, w_0, w_1, \\beta \\leftarrow V^*(\\alpha) \\\\ \\gamma \\leftarrow P(x, w_b, \\alpha, \\beta; r) \\end{array} \\right] \\leq \\frac{1}{2} + \\operatorname{negl}(n) ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">b \\leftarrow \\{0,1\\}</span> ,  <span class="math">r \\leftarrow \\{0,1\\}^{\\text{poly}(n)}</span>  is the randomness used by P, and  <span class="math">w_0, w_1 \\in \\mathcal{R}_{\\mathcal{L}}(x)</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Adaptive Proof of knowledge: there is a PPT extractor Ext, such that, for any polynomial  <span class="math">\\ell = \\ell(n)</span> , all large enough  <span class="math">n \\in \\mathbb{N}</span> , and any deterministic prover  <span class="math">P^*</span> :</li>
    </ol>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\text{if } \\Pr\\left[\\begin{array}{c|c} V(x,\\alpha,\\beta,\\gamma;r&#x27;) = 1 &amp; \\alpha \\leftarrow P^* \\\\ V(x,\\alpha,\\beta,\\gamma;r&#x27;) = 1 &amp; \\beta \\leftarrow V(\\ell(n),\\alpha;r&#x27;) \\\\ x,\\gamma \\leftarrow P^*(\\alpha,\\beta) &amp; \\geq \\epsilon \\end{array}\\right., \\\\ &amp; \\text{then } \\Pr\\left[\\begin{array}{c|c} w \\leftarrow \\mathsf{Ext}^{P^*}(1^{1/\\epsilon},x,\\alpha,\\beta,\\gamma) &amp; \\alpha \\leftarrow P^* \\\\ w \\notin \\mathcal{R}_{\\mathcal{L}}(x) &amp; \\alpha \\leftarrow P^* \\\\ w \\notin \\mathcal{R}_{\\mathcal{L}}(x) &amp; x,\\gamma \\leftarrow P^*(\\alpha,\\beta) \\\\ V(x,\\alpha,\\beta,\\gamma;r&#x27;) = 1 \\end{array}\\right] \\leq \\mathrm{negl}(n) \\enspace , \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">x \\in \\{0,1\\}^{\\ell(n)}</span> , and  <span class="math">r&#x27; \\leftarrow \\{0,1\\}^{\\text{poly}(n)}</span>  is the randomness used by  <span class="math">P^*</span> .</p>

    <p class="text-gray-300">Construction from ZAPs. We now show how to use ZAPs and extractable commitments to construct a WIPOK with the required properties. As mentioned above, ZAPs already have the required independence, but they do not provide POK. The high-level idea is to add the POK feature to ZAPs, while maintaining the required instance-independence. This can be done by have the prover commit to a random string r using a 3-message extractable commitment (e.g., as formalized in [PW09]), and then sending, as the third message, the padded witness  <span class="math">w \\oplus r</span>  along with a ZAP proof that it was computed correctly. While the first message is independent of x, w it does depend on the length |w|; this is naturally solved by committing to a seed s of fixed length and later deriving r using a PRG.</p>

    <p class="text-gray-300">Intuitively, extraction of the witness is now possible by extracting r (or s) from the committing prover. To ensure WI we use the idea of turning a single witness statement into a two independent-witnesses statement as done in [FS90, COSV12, BP13].</p>

    <p class="text-gray-300">In what follows, we denote by  <span class="math">(\\mathcal{C},\\mathcal{R})</span>  the committer and receiver algorithms of a perfectly-binding 3-message extractable commitment protocol, and we denote by  <span class="math">\\vec{C} = (C^{(1)}, C^{(2)}, C^{(3)})</span>  its three messages. We further required that extraction is possible given any two valid transcipts  <span class="math">\\vec{C}, \\vec{C}&#x27;</span>  that share the same first message. Such an extractable commitment can be constructed from any perfectly-binding non-interactive commitment, see e.g. [PW09].</p>

    <p class="text-gray-300"><strong>Lemma 4.1.</strong> Protocol 1 is a 3-message WIPOK with instance-independent first message.</p>

    <p class="text-gray-300">We next prove the lemma. The proof is an adaptation of a proof from [BP13].</p>

    <p class="text-gray-300"><em>Proof.</em> We start by showing that the protocol is WI. Let</p>

    <p class="text-gray-300"><span class="math">$(\\mathcal{X}, \\mathcal{W}_0, \\mathcal{W}_1) = \\{(x, w_0, w_1) : (x, w_0), (x, w_1) \\in \\mathcal{R}_{\\mathcal{L}}\\}</span>$</p>

    <p class="text-gray-300">be any infinite sequence of instances in  <span class="math">\\mathcal{L}</span>  and corresponding witness pairs. We next consider a sequence of hybrids starting with an hybrid describing an interaction with a prover that uses  <span class="math">w_0 \\in \\mathcal{W}_0</span> , and ending with an hybrid describing an interaction with a prover that uses  <span class="math">w_1 \\in \\mathcal{W}_1</span> , where both  <span class="math">w_0, w_1</span> , are witnesses for some  <span class="math">x \\in \\mathcal{X}</span> . We shall prove that no efficient verifier can distinguish between any two hybrids in the sequence. The list of hybrids is given in Table 1. We think of the hybrids as two symmetric sequences: one 0.1-6, starts from witness  <span class="math">w_0</span> , and the other 1.1-6 starts at witness  <span class="math">w_1</span> . We will show that within these sequences the hybrids are indistinguishable, and then we will show that 0.6 is indistinguishable from 1.6.</p>

    <p class="text-gray-300">Hybrid 0.1: This hybrid describes a true interaction of a malicious verifier  <span class="math">V^*</span>  with an honest prover P that uses  <span class="math">w_0</span>  as a witness for the statement  <span class="math">x \\in \\mathcal{L}</span> . In particular, the ZAP uses the witness  <span class="math">((s_0, w_0), (s_1, w_0))</span> ; formally, the witness also includes the randomness for the commitments  <span class="math">\\vec{C}_0</span>  and  <span class="math">\\vec{C}_1</span> , but for notational brevity, we shall omit it. In Table 1, the witness used in part 0 of the ZAP is referred to as  <span class="math">zapw_0</span> , and the one corresponding to 1 in  <span class="math">zapw_1</span> .</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6"><strong>Protocol 1</strong></h4>

    <p class="text-gray-300"><strong>Common Input:</strong> security parameter n, and  <span class="math">x \\in \\mathcal{L} \\cap \\{0,1\\}^{\\text{poly}(n)}</span> .</p>

    <p class="text-gray-300">Auxiliary Input to P:  <span class="math">w \\in \\mathcal{R}_{\\mathcal{L}}(x)</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P samples seeds  <span class="math">s_0, s_1 \\leftarrow \\{0,1\\}^{\\sqrt{n}}</span> , and a bit  <span class="math">b \\leftarrow \\{0,1\\}</span> , and sends the first commitment message to each of the three  <span class="math">(C_0^{(1)}, C_1^{(1)}, C^{(1)}) \\leftarrow (\\mathcal{C}(s_0), \\mathcal{C}(s_1), \\mathcal{C}(b))</span> , where  <span class="math">|(C_0^{(1)}, C_1^{(1)}, C^{(1)})| = n</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V, given the length of the statement  <span class="math">\\ell = |x|</span> , samples randomness  <span class="math">r \\leftarrow \\{0,1\\}^{\\text{poly}(n)}</span>  for a ZAP, and receiver messages  <span class="math">(C_0^{(2)}, C_1^{(2)}, C^{(2)}) \\leftarrow (\\mathcal{R}(C_0^{(1)}), \\mathcal{R}(C_1^{(1)}), \\mathcal{R}(C^{(1)}))</span> , and sends over  <span class="math">(r, C_0^{(2)}, C_1^{(2)}, C^{(2)})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P, given (x, w), now performs the following:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\begin{array}{l} \\bullet \\ \\ \\text{computes the third committer messages} \\\\ (C_0^{(3)}, C_1^{(3)}, C^{(3)}) \\leftarrow (\\mathcal{C}(s_0, C_0^{(2)}), \\mathcal{C}(s_1, C_1^{(2)}), \\mathcal{C}(b, C^{(2)})). \\end{array}</span></li>
      <li>computes  <span class="math">a_0 = w \\oplus \\mathsf{PRG}(s_0), a_1 = w \\oplus \\mathsf{PRG}(s_1).</span></li>
      <li>computes an ZAP proof  <span class="math">\\pi</span>  for the statement:</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\left\\{ \\left\\{ \\vec{C} = \\mathcal{C}(0, C^{(2)}) \\right\\} \\vee \\left\\{ \\begin{array}{l} \\vec{C}_0 = \\mathcal{C}(s_0, C_0^{(2)}) \\\\ a_0 = w \\oplus \\mathsf{PRG}(s_0) \\\\ w \\in \\mathcal{R}_{\\mathcal{L}}(x) \\end{array} \\right\\} \\right\\} \\bigwedge</span>$</p>

    <p class="text-gray-300"><span class="math">$\\left\\{ \\left\\{ \\vec{C} = \\mathcal{C}(1, C^{(2)}) \\right\\} \\vee \\left\\{ \\begin{array}{l} \\vec{C}_1 = \\mathcal{C}(s_1, C_1^{(2)}) \\\\ a_1 = w \\oplus \\mathsf{PRG}(s_1) \\\\ w \\in \\mathcal{R}_{\\mathcal{L}}(x) \\end{array} \\right\\} \\right\\}</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>sends  <span class="math">C_0^{(3)}, C_1^{(3)}, C_1^{(3)}, a_0, a_1, \\pi</span> .</li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V verifies the ZAP proof  <span class="math">\\pi</span> , the validity of the commitments transcripts, and decides whether to accept accordingly.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Figure 1: A 3-message WIPOK with instance-independent first message</p>

    <p class="text-gray-300">Hybrid 0.2: This hybrid differs from the previous one only in the witness used in the ZAP. Specifically, for the bit b given by  <span class="math">\\vec{C}</span> , the witness for the ZAP is set to be  <span class="math">(b, (s_{1-b}, w_0))</span> , instead of  <span class="math">((s_b, w_0), (s_{1-b}, w_0))</span> . (Again the witness should include the randomness for the commitment  <span class="math">\\vec{C}</span> , and  <span class="math">\\vec{C}_{1-b}</span> , but is omitted from our notation.) Since the ZAP is WI, this hybrid is computationally indistinguishable from the previous one.</p>

    <p class="text-gray-300">Hybrid 0.3: In this hybrid, the commitment  <span class="math">\\vec{C}_b</span>  is for the plaintext  <span class="math">0^{|s_b|}</span> , instead of the plaintext  <span class="math">s_b</span> . This hybrid is computationally indistinguishable from the previous one due to the computational hiding of the commitment scheme  <span class="math">\\vec{C}</span> .</p>

    <p class="text-gray-300">Hybrid 0.4: In this hybrid, instead of padding with  <span class="math">PRG(s_b)</span> , padding is done with a random independent string  <span class="math">u \\leftarrow \\{0,1\\}^{|PRG(s_b)|}</span> . Computational indistinguishability of this hybrid and the previous one, follows pseudorandomness.</p>

    <p class="text-gray-300">Hybrid 0.5: In this hybrid, the padded value  <span class="math">a_b</span>  is taken to be  <span class="math">w_1 \\oplus r_b</span> , instead of  <span class="math">w_0 \\oplus r_b</span> . Since  <span class="math">r_b</span>  is now uniform and independent of all other elements, this hybrid induces the exact same distribution as the previous hybrid.</p>

    <p class="text-gray-300">Hybrid 0.6: This hybrid now backtracks, returning to the same experiment as in hybrid 0.1 with</p>

    <p class="text-gray-300"> <span class="math">&lt;sup&gt;^{&lt;/sup&gt;a}</span> The commitment to b does not have to be extractable; however, we use the same commitment scheme to avoid extra notation.</p>

    <p class="text-gray-300"></p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">hyb</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">zapw_b</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\vec{C}_b</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_b</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">a_b \\oplus r_b</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">zapw_{1-b}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\vec{C}_{1-b}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">r_{1-b}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">a_{1-b} \\oplus r_{1-b}</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_b, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_b</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_b</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0^{ s_b }</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0^{ s_b }</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">u</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">0^{ s_b }</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">u</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_b, w_1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_b</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.6</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_b, w_0)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_b</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_0</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.2-5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_b, w_1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_b</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG_b(s_b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_1</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(s_{1-b}, w_1)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">s_{1-b}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">PRG(s_{1-b})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">w_1</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: The sequence of hybrids; the bit b corresponds to the bit commitment  <span class="math">\\vec{C}</span> ; the gray cells indicate the difference from the previous hybrid.</p>

    <p class="text-gray-300">the exception that the ZAP witness is now  <span class="math">((s_b, w_1), (s_{1-b}, w_0))</span>  instead of  <span class="math">((s_b, w_0), (s_{1-b}, w_0))</span> . This indistinguishability follows exactly as when moving from 0.1 to 0.5 (only backwards).</p>

    <p class="text-gray-300">Hybrids 1.1 to 1.6: These hybrids are symmetric to the above hybrids, only that they start from  <span class="math">w_1</span>  instead of  <span class="math">w_0</span> . This means that they end in 1.6 which uses an ZAP witness  <span class="math">((s_b, w_0), (s_{1-b}, w_1))</span> , which is the same as 0.6, only in reverse order.</p>

    <p class="text-gray-300">Hybrids 0.6 and 1.6 are computationally indistinguishable. This follows directly from the computational hiding of the commitment  <span class="math">\\vec{C}</span>  to b. Indeed, assume towards contradiction that V distinguishes the two hybrids. Concretely, denote the probability it outputs 1 on 0.6 by  <span class="math">p_0</span> , and the probability it outputs 1 on 1.6 by  <span class="math">p_1</span> , and assume WLOG that  <span class="math">p_0 - p_1 \\ge \\epsilon</span> , for some noticeable  <span class="math">\\epsilon = \\epsilon(n)</span> . We can construct a predictor that given a commitment  <span class="math">\\vec{C} = \\mathcal{C}(b)</span>  to a random bit  <span class="math">b \\leftarrow \\{0,1\\}</span> , guesses b with probability  <span class="math">\\frac{1+\\epsilon}{2}</span> . The predictor, samples a random  <span class="math">b&#x27; \\leftarrow \\{0,1\\}</span>  as a candidate guess for b, and performs the experiment corresponding to 0.6, only that it locates  <span class="math">w_0</span>  and  <span class="math">w_1</span>  according to b', rather than the unknown b. If the distinguisher outputs 1, the predictor guesses b = b' and otherwise it guesses b = 1 - b'.</p>

    <p class="text-gray-300">Conditioned on b=b', V is experiencing 0.6, and thus the guess will be correct with probability  <span class="math">p_0</span> ; conditioned on b=1-b', V is experiencing 1.6, and the guess will be right with probability  <span class="math">1-p_1</span> . So overall the guessing probability is  <span class="math">\\frac{p_0}{2}+\\frac{1-p_1}{2}\\geq \\frac{1}{2}+\\frac{\\epsilon}{2}</span> . This completes the proof that the protocol is WI.</p>

    <p class="text-gray-300">It is left to show that the protocol is an argument of knowledge. Indeed, let  <span class="math">P^*</span>  be any prover that convinces the honest verifier of accepting with noticeable probability  <span class="math">\\epsilon = \\epsilon(n)</span> , then with probability at least  <span class="math">\\epsilon/2</span>  over its first message, it holds with probability at least  <span class="math">\\epsilon/2</span>  over the rest of the protocol that  <span class="math">P^*</span>  convinces V. Let us call such a prefix good. Now for any good prefix, we can consider the perfectly binding induced commitment to the bit b, and from the soundness of the ZAP, we get a circuit that with probability at least  <span class="math">\\epsilon/2 - \\text{negl}(n)</span>  completes produces an accepting commitment transcript for the plaintext  <span class="math">s_{1-b}</span> , and gives a valid witness  <span class="math">w \\in \\mathcal{R}_{\\mathcal{L}}</span> , padded with  <span class="math">\\text{PRG}(s_{1-b})</span> . This in particular, means that we can first sample a prefix (hope it is good), and then use the extraction guarantee of the commitment to learn  <span class="math">s_{1-b}</span>  and  <span class="math">\\text{PRG}(s_{1-b})</span> , and thus also the witness w. This completes the proof of Lemma 4.1.</p>

    <p class="text-gray-300"><strong>2-message WI with instance-independent first message.</strong> We shall also make use of 2-message WI with instance-independent first message. Here, there are two verifier and prover messages. Like in the three message definition the verifier message does not depend on the instance, but is allowed to depend on its length. In such a protocol, we only require soundness. ZAPs, for instance, satisfy this requirement, but we can also do with a privately verifiable protocol rather than a ZAP. (In fact, also in the above construction of 3-message WIPOKs with instance-independent first message, the ZAPs can be replace with any 2-message WI with instance-independent first message.</p>

      <h3 id="sec-4.3" class="text-xl font-semibold mt-8">4.3 Constructions</h3>

    <p class="text-gray-300">In this section, we construct zero-knowledge protocols against verifiers with bounded advice from generalized extractable one-way functions against adversaries with bounded advice (GEOWFs against BAPT adversaries). We start by describing a construction of a 3-message argument of knowledge from any GEOWF that is everywhere extractable and has oblivious image verification, and every 3-message WIPOK with instance-independent first message. We then show a 2-message argument, assuming (noninteractive) commitments that can be inverted in super-poly time T(n), GEOWFs that are one-way against poly(T(n))-size adversaries, and any 2-message WI with instance-independent verifier message (in particular, ZAPs).</p>

      <h4 id="sec-4.3.1" class="text-lg font-semibold mt-6">4.3.1 A 3-message zero-knowledge argument of knowledge.</h4>

    <p class="text-gray-300">In what follows, let F be a family of GEOWFs, against m-BAPT adversaries, and assume that F is everywhere extractable and has an oblivious image sampler I. We shall denote by (wi1,wi2,wi3) the messages of a WIPOK with an instance-independent first message (as in Definition <a href="#page-14-0">4.2)</a>. The protocol is given in Figure <a href="#page-18-0">2.</a></p>

    <h4 id="sec-misc-7" class="text-lg font-semibold mt-6">Protocol <a href="#page-18-0">2</a></h4>

    <p class="text-gray-300">Common Input: x &isin; L &cap; {0, 1} n.</p>

    <p class="text-gray-300">Auxiliary Input to P: a witness w for x.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P sends the first message wi<sup>1</sup> &isin; {0, 1} <sup>n</sup> of the instance-dependent WIPOK.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V samples k &larr; K(1n; r), u &larr; {0, 1} \`(n) , computes v = fk(u), and sends (k, v) , as well as the second WIPOK message wi2.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P samples v&tilde; &larr; I(k, v), and sends v&tilde;, together with the third WIPOK message wi<sup>3</sup> stating that:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\{x \\in \\mathcal{L}\\} \\bigvee \\{\\exists u : \\ \\tilde{v} = f_k(u) \\}</span>$
,</p>

    <p class="text-gray-300">using the witness w &isin; RL(x).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V verifies the proof and tests that the equivalence relation holds by running T (v, v, r &tilde; ).</li>
    </ol>

    <p class="text-gray-300">Figure 2: A 3-message ZK argument of knowledge against verifiers with m-bounded advice.</p>

    <p class="text-gray-300">Theorem 4.1. <em>Protocol <a href="#page-18-0">2</a> is a zero-knowledge argument of knowledge against</em> m<em>-BAPT verifiers.</em></p>

    <p class="text-gray-300"><em>Remark</em> 4.2 (Instance-independent first-message)<em>.</em> An additional feature of the protocol is that it preserves the first message instance-independence of the WIPOK system.</p>

    <p class="text-gray-300">The high-level idea behind the proof is provided in the introduction, we now provide a more detailed proof sketch.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We first show that the protocol is an argument of knowledge.</p>

    <p class="text-gray-300">Claim 4.1. <em>Protocol <a href="#page-18-0">2</a> is an argument of knowledge against against arbitrary polysize provers.</em></p>

    <p class="text-gray-300"><em>Proof sketch.</em> Let P <sup>&lowast;</sup> be any polysize prover that convinces V of accepting with noticeable probability = (n). The witness extractor would derive from P &lowast; a new prover for P &lowast; wi that emulates P &lowast; in the WIPOK; in particular, it would honestly sample (k, v) as part of the second verifier message that P <sup>&lowast;</sup> gets. The extractor would then choose the random coins r for P &lowast; wi, sample a transcript trwi of an execution with the honest WIPOK verifier  <span class="math">V_{\\text{wi}}</span> , and apply the WIPOK extractor on the transcript tr, with oracle access to  <span class="math">P_{\\text{wi}}^*</span> . The WIPOK extractor then hopefuly obtains a witness for the WI statement</p>

    <p class="text-gray-300"><span class="math">$\\{x \\in \\mathcal{L}\\} \\bigvee \\{\\exists u : \\tilde{v} = f_k(u)\\}</span>$
,</p>

    <p class="text-gray-300">where (k,v) are those honestly sampled by  <span class="math">P_{\\mathrm{wi}}^*</span> , and  <span class="math">\\tilde{v}</span>  is output by  <span class="math">P^*</span> .</p>

    <p class="text-gray-300">We claim that, with noticeable probability  <span class="math">\\epsilon^2/2 - \\operatorname{negl}(n)</span> , we find a witness w for the first part of the statement  <span class="math">x \\in \\mathcal{L}</span> . Otherwise, we can use  <span class="math">P^*</span>  to break the (strong) one-wayness of  <span class="math">\\mathcal{F}</span> . To prove the claim, we first note that the emulated transcript tr in this experiment is distributed identically to the transcript in a real execution of  <span class="math">P^*</span>  with the honest verifier. Thus, we know that such a transcript tr is accepted by V with probability at least  <span class="math">\\epsilon</span> . Now, let us call random coins r for  <span class="math">P^*_{wi}</span>  good if they are such that with probability at least  <span class="math">\\epsilon/2</span>  over the coins of the WIPOK verifier  <span class="math">V_{wi}</span> , it accepts the proof given by  <span class="math">P^*_{wi}</span> . Since we know that overall  <span class="math">V_{wi}</span>  accepts with probability at least  <span class="math">\\epsilon</span> , then by a standard averaging argument, at least an  <span class="math">\\epsilon/2</span>  fraction of the coins r for  <span class="math">P^*_{wi}</span>  are good. Furthermore, conditioned on a transcript tr that is accepted by V, the probability that the corresponding coins r are good increases. Thus, it follows that the probability that tr is accepting and the corresponding coins r are good is at least  <span class="math">\\epsilon \\cdot \\epsilon/2</span> . Now, recall that, whenever this occurs, the extractor for the WIPOK would also output a witness for the corresponding statement (except with negligible probability).</p>

    <p class="text-gray-300">We would like to show that the extracted witness is the one for the  <span class="math">x \\in \\mathcal{L}</span>  statement. Indeed, assume that, with noticeable probability  <span class="math">\\eta</span> , it holds that tr is accepting, the extractor outputs a witness, but the witness is for the second statement. This, in particular, means that the witness extractor outputs u', and  <span class="math">v&#x27; = f_k(u&#x27;)</span> , such that  <span class="math">\\tilde{v} = f_k(u&#x27;)</span> , where  <span class="math">\\tilde{v}</span>  is the output of  <span class="math">P^*</span> . Moreover, since the transcript is accepting, we know that  <span class="math">v \\sim v&#x27;</span> .</p>

    <p class="text-gray-300">We can now construct an inverter that breaks the (strong) one-wayness of  <span class="math">\\mathcal{F}</span> . The inverter, given (k,v) would simply emulate all of the experiment above on its own, where  <span class="math">P_{\\text{wi}}</span>  would use (k,v) to emulate the second verifier message, instead of sampling it on its own. By the above, it would obtain a (relative) preimage with noticeable probability  <span class="math">\\eta</span> .</p>

    <p class="text-gray-300">This completes the proof.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">We next show that the protocol is ZK. We note that, since the ZK simulator is allowed to simulate the (apriori unbounded) randomness of the verifier  <span class="math">V^*</span> , we can restrict attention to verifiers  <span class="math">V^*</span>  that only have bounded randomness. Indeed (assuming there exist OWFs), we can always consider a new verifier  <span class="math">\\widetilde{V}^*</span>  that first stretches its bounded randomness using a PRG and then emulates  <span class="math">V^*</span> . Then to simulate the view of  <span class="math">V^*</span> , we can first apply the simulator  <span class="math">\\widetilde{\\text{Sim}}</span>  for  <span class="math">\\widetilde{V}^*</span> , and then apply the PRG on the simulated randomness to obtain a full simulated view for  <span class="math">V^*</span> . In particular, from hereon we we can simply focus on deterministic verifiers  <span class="math">V^*</span>  that get their bounded randomness as part of their bounded advice.</p>

    <p class="text-gray-300"><strong>Claim 4.2.</strong> Protocol 2 is ZK against any polytime verifier  <span class="math">V^*</span>  with advice of size at most m(n) - 2n.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We describe a universal ZK simulator Sim and show its validity (universality is in the sense of Remark 4.1). Let  <span class="math">x \\in \\mathcal{L}</span>  and let  <span class="math">V^*</span>  be the code of any malicious verifier, and let z' be any advice of length at most m-2n. Sim starts by honestly computing the first message  <span class="math">\\text{wi}_1 \\in \\{0,1\\}^n</span>  of the WIPOK with instance-independent first message. It then feeds  <span class="math">\\text{wi}_1</span>  to  <span class="math">V^*(x;z&#x27;)</span>  who returns  <span class="math">(k,v,\\text{wi}_2)</span>  that are (allegedly) a key for an extractable function, an image under the function, and the second message of the WIPOK.</p>

    <p class="text-gray-300">Sim now constructs from the code of  <span class="math">V^*</span>  a machine  <span class="math">M_{V^*}</span>  that, given k and  <span class="math">z=(z&#x27;,x,\\operatorname{wi}_1)</span>  as input, outputs some v, and whose running time is linear in the running time  <span class="math">t_{V^*}</span>  of  <span class="math">V^*</span> . Note that  <span class="math">|z| \\leq |z&#x27;| + |x| + |\\operatorname{wi}_1| \\leq m(n)</span> , and thus  <span class="math">\\operatorname{Sim}</span>  can apply the extractor  <span class="math">\\operatorname{Ext}</span>  on  <span class="math">M_{V^*}</span> , and obtain  <span class="math">u&#x27; \\in \\{0,1\\}^\\ell</span>  in time  <span class="math">\\operatorname{poly}(t_V^*)</span> .  <span class="math">\\operatorname{Sim}</span>  now computes  <span class="math">v&#x27; = f_k(u&#x27;)</span>  to  <span class="math">V^*</span> , and completes the WIPOK using the trapdoor u' as a witness.</p>

    <p class="text-gray-300">The validity of the simulator now follows by witness indistinguishability, as well as the oblivious image sampling guarantee. Specifically, we can first move to a hybrid simulator Sim<sup>0</sup> that proves the WIPOK statement using the witness w. The view generated by Sim<sup>0</sup> is indistinguishable from the one generated by Sim due to the WI property. Now, we can claim that the view generated by Sim<sup>0</sup> is indistinguishable from that generated by honest prover P. Indeed, the only difference between the two is that P sends v&tilde; &larr; I(k, v), whereas Sim<sup>0</sup> sends v <sup>0</sup> = fk(u 0 ), for the extracted input u 0 ; however, by the oblivious image sampling guarantee v&tilde; &asymp;<sup>c</sup> v 0 .</p>

    <p class="text-gray-300">This completes the proof of Theorem <a href="#page-18-1">4.1.</a></p>

      <h4 id="sec-4.3.2" class="text-lg font-semibold mt-6">4.3.2 A 2-message zero-knowledge argument.</h4>

    <p class="text-gray-300">In this section, we show that, using complexity leveraging (and superpolynomial hardness assumptions), we can augment the protocol from the previous section to a 2-message argument.</p>

    <p class="text-gray-300">In what follows, let C be a perfectly binding commitment that is hiding against polysize adversaries, and can be completely inverted in time T(n), for some computable super-polynomial function T(n) = n <sup>&omega;</sup>(1). Let F be a family of GEOWFs, against m-BAPT adversaries, and assume that F is everywhere extractable and has an oblivious image sampler I. Further assume that F is one-way against adversaries of size poly(T) (see Remark <a href="#page-13-1">3.3)</a>. Also, we shall denote by (wi1,wi2) the verifier and prover messages of a 2-message WI with an instance-independent first message (as in Definition <a href="#page-14-0">4.2)</a>.</p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Protocol <a href="#page-20-1">3</a></h4>

    <p class="text-gray-300">Common Input: x &isin; L &cap; {0, 1} n.</p>

    <p class="text-gray-300">Auxiliary Input to P: a witness w for x.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V samples k &larr; K(1n; r), u &larr; {0, 1} \`(n) , computes v = fk(u), and sends k, v , as well as the first WI message wi1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>P samples a commitment to zero C &larr; C(0\` ), and v&tilde; &larr; I(k, v), and sends C, v&tilde;, together with the second WI message wi<sup>2</sup> stating that:</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\{x \\in \\mathcal{L}\\} \\bigvee \\left\\{ \\exists u : \\begin{array}{l} v = f_k(u) \\\\ C = \\mathcal{C}(u) \\end{array} \\right\\} ,</span>$</p>

    <p class="text-gray-300">using the witness w &isin; RL(x).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>V verifies the proof and tests proximity by running T (v, v, r &tilde; ).</li>
    </ol>

    <p class="text-gray-300">Figure 3: A 2-message ZK argument against verifiers with bounded advice.</p>

    <p class="text-gray-300">Theorem 4.2. <em>Protocol <a href="#page-20-1">3</a> is a zero-knowledge argument against</em> m<em>-BAPT verifiers.</em></p>

    <p class="text-gray-300">High-level idea behind the proof. Proving ZK against verifiers with bounded advice is essentially the same as in the 3-message protocol, only that now the simulator also commits to the input that it extracts from the verifier (and by the hiding of the commitment ZK is maintained). The proof of soundness is essentially the same as showing POK in the 3-message protocol, only that now we will construct an extractor that works in time poly(T(n)), by inverting the prover's commitment with brute-force. Since one-wayness holds even against poly(T(n))-adversaries, soundness follows.</p>

    <p class="text-gray-300">A more detailed proof follows.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We first show that the protocol is a sound against polysize adversaries.</p>

    <h4 id="sec-misc-9" class="text-lg font-semibold mt-6">Claim 4.3. Protocol 3 is an argument.</h4>

    <p class="text-gray-300"><em>Proof sketch.</em> Let  <span class="math">P^*</span>  be any polysize prover, and assume towards contradiction that for infinitely many  <span class="math">x \\notin \\mathcal{L}</span> ,  <span class="math">P^*</span>  convinces V of accepting with noticeable probability  <span class="math">\\epsilon = \\epsilon(n)</span> . We show to break the strong one-wayness of  <span class="math">\\mathcal{F}</span> . The invereter, given (k, v) would sample a first WI message wi<sub>1</sub>, and feed  <span class="math">(k, v, \\text{wi}_1)</span>  to  <span class="math">P^*</span> , who outputs a commitment C, an alleged image  <span class="math">\\tilde{v}</span> , and a proof wi<sub>2</sub> for the statement</p>

    <p class="text-gray-300"><span class="math">$\\{x \\in \\mathcal{L}\\} \\bigvee \\left\\{ \\exists u : \\begin{array}{l} \\tilde{v} = f_k(u) \\\\ C = \\mathcal{C}(u) \\end{array} \\right\\} .</span>$</p>

    <p class="text-gray-300">We know that with probability  <span class="math">\\epsilon</span>  the proof is convincing, so by the soundness of the WI scheme, and since  <span class="math">x \\notin \\mathcal{L}</span> , it follows that C is a commitment to a (relative) preimage of v. The inverter can now break C in time T(n) and thus break the strong one-wayness of  <span class="math">\\mathcal{F}</span> .</p>

    <p class="text-gray-300">We next show that the protocol is ZK. As noted in the previous section, we can restrict attention to deterministic verifiers  <span class="math">V^*</span>  that get their bounded randomness as part of their bounded advice.</p>

    <p class="text-gray-300"><strong>Claim 4.4.</strong> Protocol 3 is ZK against any polytime verifier  <span class="math">V^*</span>  with advice of size at most m(n) - n.</p>

    <p class="text-gray-300"><em>Proof sketch.</em> We describe a universal ZK simulator Sim and show its validity (universality is in the sense of Remark 4.1). Let  <span class="math">x \\in \\mathcal{L}</span>  and let  <span class="math">V^*</span>  be the code of any malicious verifier, and let z' be any advice of length at most m-n. Sim starts by running  <span class="math">V^*(x;z&#x27;)</span>  who returns  <span class="math">(k,v,\\operatorname{wi}_1)</span>  that are (allegedly) a key for an extractable function, an image of the of the function, and the verifier message of the WI protocol.</p>

    <p class="text-gray-300">Sim now constructs from the code of  <span class="math">V^*</span>  a machine  <span class="math">M_{V^*}</span>  that, given k and z=(z',x) as input, outputs some v, and whose running time is linear in the running time  <span class="math">t_{V^*}</span>  of  <span class="math">V^*</span> . In particular,  <span class="math">|z| \\le |z&#x27;| + |x| \\le m(n)</span> . Sim then applies the extractor Ext on  <span class="math">M_{V^*}</span> , and obtains  <span class="math">u&#x27; \\in \\{0,1\\}^{\\ell}</span>  in time poly <span class="math">(t_V^*)</span> .</p>

    <p class="text-gray-300">Sim now computes  <span class="math">v&#x27; = f_k(u&#x27;)</span> , as well as a commitment C to u', and completes the WI using the trapdoor u' as a witness. It sends C, v', wi<sub>2</sub> to complete the simulation.</p>

    <p class="text-gray-300">The validity of the simulator now follows by witness indistinguishability, as well as the oblivious image sampling guarantee. Specifically, we can first move to a hybrid simulator  <span class="math">\\mathsf{Sim}&#x27;</span>  that proves the WIPOK statement using the witness w. The view generated by  <span class="math">\\mathsf{Sim}&#x27;</span>  is indistinguishable from the one generated by  <span class="math">\\mathsf{Sim}</span>  due to the WI property. Now, we can claim that the view generated by  <span class="math">\\mathsf{Sim}&#x27;</span>  is indistinguishable from that generated by honest prover P. Indeed, the only difference between the two is that P commits to  <span class="math">0^\\ell</span>  instead of u', and sends  <span class="math">\\tilde{v} \\leftarrow \\mathcal{I}(k,v)</span> , whereas  <span class="math">\\mathsf{Sim}&#x27;</span>  sends  <span class="math">v&#x27; = f_k(u&#x27;)</span> , for the extracted input u'. Thus, the two views are indistinguishable by the hiding of the commitment and by the oblivious image sampling guarantee that  <span class="math">\\tilde{v} \\approx_c v&#x27;</span> .</p>

    <p class="text-gray-300">This completes the proof of Theorem 4.2.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">[AIR01] William Aiello, Yuval Ishai, and Omer Reingold. Priced oblivious transfer: How to sell digital goods. In <em>EUROCRYPT</em>, pages 119&ndash;135, 2001.</p></li>
      <li><p class="text-gray-300">[Bar01] Boaz Barak. How to go beyond the black-box simulation barrier. In <em>FOCS</em>, pages 106&ndash;115, 2001.</p></li>
      <li><p class="text-gray-300">[BC12] Nir Bitansky and Alessandro Chiesa. Succinct arguments from multi-prover interactive proofs and their efficiency benefits. In <em>CRYPTO</em>, pages 255&ndash;272, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT12] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable collision resistance to succinct non-interactive arguments of knowledge, and back again. In <em>Proceedings of the 3rd Innovations in Theoretical Computer Science Conference</em>, ITCS '12, pages 326&ndash;349, 2012.</p></li>
      <li><p class="text-gray-300">[BCCT13] Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive composition and bootstrapping for snarks and proof-carrying data. In <em>STOC</em>, pages 111&ndash;120, 2013.</p></li>
      <li><p class="text-gray-300">[BCPR13] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. Indistinguishability obfuscation vs. auxiliary-input extractable functions: One must fall. <em>IACR Cryptology ePrint Archive</em>, 2013:641, 2013.</p></li>
      <li><p class="text-gray-300">[BCPR14] Nir Bitansky, Ran Canetti, Omer Paneth, and Alon Rosen. On the existence of extractable one-way functions. In <em>Proceedings of the 46th Annual ACM Symposium on Theory of Computing</em>, STOC '14, 2014.</p></li>
      <li><p class="text-gray-300">[BG08] Boaz Barak and Oded Goldreich. Universal arguments and their applications. <em>SIAM J. Comput.</em>, 38(5):1661&ndash;1694, 2008.</p></li>
      <li><p class="text-gray-300">[Blu86] Manuel Blum. How to prove a theorem so no one else can claim it. In <em>Proceedings of the International Congress of Mathematicians</em>, pages 1444&ndash;1451, 1986.</p></li>
      <li><p class="text-gray-300">[BLV06] Boaz Barak, Yehuda Lindell, and Salil P. Vadhan. Lower bounds for non-black-box zero knowledge. <em>J. Comput. Syst. Sci.</em>, 72(2):321&ndash;391, 2006.</p></li>
      <li><p class="text-gray-300">[BM84] Manuel Blum and Silvio Micali. How to generate cryptographically strong sequences of pseudo-random bits. <em>SIAM J. Comput.</em>, 13(4):850&ndash;864, 1984.</p></li>
      <li><p class="text-gray-300">[BP04] Mihir Bellare and Adriana Palacio. The knowledge-of-exponent assumptions and 3-round zero-knowledge protocols. In <em>Proceedings of the 24th Annual International Cryptology Conference</em>, pages 273&ndash;289, 2004.</p></li>
      <li><p class="text-gray-300">[BP13] Nir Bitansky and Omer Paneth. On the impossibility of approximate obfuscation and applications to resettable cryptography. In <em>STOC</em>, pages 241&ndash;250, 2013.</p></li>
      <li><p class="text-gray-300">[BV11] Zvika Brakerski and Vinod Vaikuntanathan. Efficient fully homomorphic encryption from (standard) lwe. In <em>FOCS</em>, pages 97&ndash;106, 2011.</p></li>
      <li><p class="text-gray-300">[Can00] Ran Canetti. Security and composition of multiparty cryptographic protocols. <em>Journal of Cryptology</em>, pages 143&ndash;202, 2000.</p></li>
      <li><p class="text-gray-300">[Can01] Ran Canetti. Universally composable security: A new paradigm for cryptographic protocols. In <em>Proceedings of the 42nd Annual IEEE Symposium on Foundations of Computer Science</em>, pages 136&ndash;145, 2001.</p></li>
      <li><p class="text-gray-300">[CD08] Ran Canetti and Ronny Ramzi Dakdouk. Extractable perfectly one-way functions. In <em>Proceedings of the 35th International Colloquium on Automata, Languages and Programming</em>, pages 449&ndash;460, 2008.</p></li>
      <li><p class="text-gray-300">[CD09] Ran Canetti and Ronny Ramzi Dakdouk. Towards a theory of extractable functions. In <em>TCC</em>, pages 595&ndash;613, 2009.</p></li>
      <li><p class="text-gray-300">[CLP13] Kai-Min Chung, Huijia Lin, and Rafael Pass. Constant-round concurrent zero knowledge from p-certificates. In <em>FOCS</em>, 2013.</p></li>
      <li><p class="text-gray-300">[COSV12] Chongwon Cho, Rafail Ostrovsky, Alessandra Scafuro, and Ivan Visconti. Simultaneously resettable arguments of knowledge. In <em>TCC</em>, pages 530&ndash;547, 2012.</p></li>
      <li><p class="text-gray-300">[Dam92] Ivan Damgard. Towards practical public key systems secure against chosen ciphertext at- &#730; tacks. In <em>Proceedings of CRYPTO91</em>, pages 445&ndash;456, 1992.</p></li>
      <li><p class="text-gray-300">[DN07] Cynthia Dwork and Moni Naor. Zaps and their applications. <em>SIAM J. Comput.</em>, 36(6):1513&ndash; 1543, 2007.</p></li>
      <li><p class="text-gray-300">[FLS99] Uriel Feige, Dror Lapidot, and Adi Shamir. Multiple noninteractive zero knowledge proofs under general assumptions. <em>SIAM J. Comput.</em>, 29(1):1&ndash;28, 1999.</p></li>
      <li><p class="text-gray-300">[FS89] Uriel Feige and Adi Shamir. Zero knowledge proofs of knowledge in two rounds. pages 526&ndash;544, 1989.</p></li>
      <li><p class="text-gray-300">[FS90] Uriel Feige and Adi Shamir. Witness indistinguishable and witness hiding protocols. In <em>STOC</em>, pages 416&ndash;426, 1990.</p></li>
      <li><p class="text-gray-300">[GHV10] Craig Gentry, Shai Halevi, and Vinod Vaikuntanathan. <em>i</em>-hop homomorphic encryption and rerandomizable yao circuits. In <em>CRYPTO</em>, pages 155&ndash;172, 2010.</p></li>
      <li><p class="text-gray-300">[GK96] Oded Goldreich and Hugo Krawczyk. On the composition of zero-knowledge proof systems. <em>SIAM J. Comput.</em>, 25(1):169&ndash;192, 1996.</p></li>
      <li><p class="text-gray-300">[GL89] O. Goldreich and L. A. Levin. A hard-core predicate for all one-way functions. In <em>STOC '89: Proceedings of the twenty-first annual ACM symposium on Theory of computing</em>, pages 25&ndash;32, New York, NY, USA, 1989. ACM.</p></li>
      <li><p class="text-gray-300">[GMR89] Shafi Goldwasser, Silvio Micali, and Charles Rackoff. The knowledge complexity of interactive proof systems. <em>SIAM J. Comput.</em>, 18(1):186&ndash;208, 1989.</p></li>
      <li><p class="text-gray-300">[GMW87] Oded Goldreich, Silvio Micali, and Avi Wigderson. How to play any mental game. In <em>STOC '87: Proceedings of the nineteenth annual ACM symposium on Theory of computing</em>, pages 218&ndash;229, 1987.</p></li>
      <li><p class="text-gray-300">[GO94] Oded Goldreich and Yair Oren. Definitions and properties of zero-knowledge proof systems. <em>Journal of Cryptology</em>, 7(1):1&ndash;32, December 1994.</p></li>
      <li><p class="text-gray-300">[Gol04] Oded Goldreich. <em>Foundations of Cryptography: Volume 2, Basic Applications</em>. Cambridge University Press, New York, NY, USA, 2004.</p></li>
      <li><p class="text-gray-300">[GW11] Craig Gentry and Daniel Wichs. Separating succinct non-interactive arguments from all falsifiable assumptions. In <em>Proceedings of the 43rd Annual ACM Symposium on Theory of Computing</em>, pages 99&ndash;108, 2011.</p></li>
      <li><p class="text-gray-300">[HILL99] Johan Hastad, Russell Impagliazzo, Leonid A. Levin, and Michael Luby. A pseudorandom &#730; generator from any one-way function. <em>SIAM J. Comput.</em>, 28(4):1364&ndash;1396, 1999.</p></li>
      <li><p class="text-gray-300">[HK12] Shai Halevi and Yael Tauman Kalai. Smooth projective hashing and two-message oblivious transfer. <em>J. Cryptology</em>, 25(1):158&ndash;193, 2012.</p></li>
      <li><p class="text-gray-300">[HT98] Satoshi Hada and Toshiaki Tanaka. On the existence of 3-round zero-knowledge protocols. In <em>Proceedings of the 18th Annual International Cryptology Conference</em>, pages 408&ndash;423, 1998.</p></li>
      <li><p class="text-gray-300">[Kil92] Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In <em>Proceedings of the 24th Annual ACM Symposium on Theory of Computing</em>, pages 723&ndash;732, 1992.</p></li>
      <li><p class="text-gray-300">[KRR] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for p. In <em>Announcement at STOC13</em>.</p></li>
      <li><p class="text-gray-300">[KRR13] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum. Delegation for bounded space. In <em>STOC</em>, pages 565&ndash;574, 2013.</p></li>
      <li><p class="text-gray-300">[LS90] Dror Lapidot and Adi Shamir. Publicly verifiable non-interactive zero-knowledge proofs. In <em>CRYPTO</em>, pages 353&ndash;365, 1990.</p></li>
      <li><p class="text-gray-300">[Nao03] Moni Naor. On cryptographic assumptions and challenges. In <em>Proceedings of the 23rd Annual International Cryptology Conference</em>, pages 96&ndash;109, 2003.</p></li>
      <li><p class="text-gray-300">[NP01] Moni Naor and Benny Pinkas. Efficient oblivious transfer protocols. In <em>SODA</em>, pages 448&ndash; 457, 2001.</p></li>
      <li><p class="text-gray-300">[OI07] Rafail Ostrovsky and William E. Skeith III. A survey of single-database private information retrieval: Techniques and applications. In <em>Public Key Cryptography</em>, pages 393&ndash;411, 2007.</p></li>
      <li><p class="text-gray-300">[OV12] Rafail Ostrovsky and Ivan Visconti. Simultaneous resettability from collision resistance. <em>Electronic Colloquium on Computational Complexity (ECCC)</em>, 2012.</p></li>
      <li><p class="text-gray-300">[PW09] Rafael Pass and Hoeteck Wee. Black-box constructions of two-party protocols from oneway functions. In <em>TCC</em>, pages 403&ndash;418, 2009.</p></li>
      <li><p class="text-gray-300">[Yao86] Andrew Chi-Chih Yao. How to generate and exchange secrets (extended abstract). In <em>FOCS</em>, pages 162&ndash;167, 1986.</p></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Black-Box Lower Bounds</h2>

    <p class="text-gray-300">In our construction of EOWFs (or GEOWFs) against BAPT adversaries, the extractor is non-black-box, i.e., it makes explicit use of the adversary's code. In particular, the simulation of our 2-message and 3-message ZK protocols, which invokes this extractor, makes a non-black-box use of the adversarial verifier. In this section, we show that this is inherent by extending known results for adversaries with unbounded polynomial advice to the case of BAPT adversaries. We also observe that such black-box impossibilities do not hold for totally uniform adversaries (having no advice at all, on top of their constant size description).</p>

    <p class="text-gray-300">EOWF with black-box extractors. We sketch why there do not exist EOWFs against m-BAPT adversaries where m = n &Omega;(1), for security parameter n, and where the extractor only uses the adversary as a black-box (a similar implication can be shown for the case of generalized EOWFs). Specifically, we show that given a function family F that satisfies one-wayness, there does not exist a PPT black-box extractor Ext such that for any PPT adversary M, any large enough security parameter n &isin; N, and any advice z &isin; {0, 1} m(n) :</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{k \\leftarrow \\mathcal{K}(1^n)} \\left[ \\begin{array}{c} v \\leftarrow M(k;z) \\\\ \\exists u : f_k(u) = v \\end{array} \\wedge \\begin{array}{c} u&#x27; \\leftarrow \\mathsf{Ext}^{M(\\cdot;z)}(k) \\\\ f_k(u&#x27;) \\neq v \\end{array} \\right] \\leq \\mathrm{negl}(n) \\ .</span>$</p>

    <p class="text-gray-300">To see this, consider the adversary M that interprets its auxiliary input as a seed of a pseudo-random function PRF that maps the keys of F to inputs of F. On input (k; z), M computes an input u = PRFz(k) and outputs v = fk(u). Using the guarantee of the pseudo-random function, it is not hard to see that any black-box extractor Ext can be used to break the one-wayness property of F. Indeed, given (k, y), an inverter can simulate the view of Ext in an interaction with M(&middot;; z) by answering any query k <sup>0</sup> 6= k with a random image f<sup>k</sup> <sup>0</sup>(x), and answering the query k with y.</p>

    <p class="text-gray-300">Note that the above does not hold when m = O(log(n)), since then the advice cannot contain a seed for a secure pseudo-random function. In fact, when m = O(log(n)), any family that is EOWF against m-BAPT adversaries also has a black-box extractor. The extractability property of the EOWF guarantees the existence of an extractor for every adversary M and advice z. Since there are only polynomially many different pairs (M, z), a black-box extractor can run the (possibly non-black-box) extractor for every such (M, z), and is guaranteed that one of these executions outputs a valid preimage.</p>

    <p class="text-gray-300">3-round ZK with black-box simulation. Goldreich and Krawczyk <a href="#page-23-6">[GK96]</a> show that a 3-message protocol for a language L &isin;/ BPP that is zero-knowledge against non-uniform verifiers cannot have a black-box simulator. That is, there is no simulator that only uses the verifier as a black-box. To show this, they first construct a specific family V of non-uniform verifiers, and then prove that any black-box simulator that can simulate verifiers in V can be used to decide L efficiently. This proof, however, does not directly rule out black-box simulation for BAPT verifiers. The reason is that, in the proof of <a href="#page-23-6">[GK96]</a>, the advice given to verifiers in V encodes a key for a p-wise independent hash function where p bounds the running time of the simulator. Now, to rule out any polytime simulator, we must require simulation for verifiers with advice of arbitrary polynomial length.</p>

    <p class="text-gray-300">However, assuming one-way functions exist, we can replace the p-wise independent hash function in the construction of V by a pseudo-random function with seed length that is independent of p. Then, using the same argument as <a href="#page-23-6">[GK96]</a>, we can show that black-box simulation is impossible even for m-BAPT verifiers where m = n &Omega;(1) .</p>

    <p class="text-gray-300">Similarly to the case EOWF, there is no impossibility for 3-message ZK against m-BAPT verifiers where m = O(log(n)). In fact, as explained above, in this case, the non-black-box extractor of our EOWF also implies a black-box extractor, which we can use to construct a black-box simulator in our 3-message ZK protocol.</p>

    <p class="text-gray-300">2-round ZK. Goldreich and Oren <a href="#page-23-13">[GO94]</a> show that 2-message protocols for any language L &isin;/ BPP that are zero-knowledge against non-uniform verifiers do not exist (even with non-black-box simulation). Their result crucially relies on the fact that the advice of the verifier can encode the first message of the protocol (and can in fact be extended to also rule out the case of BAPT verifiers, with advice longer that the first message). Our construction of 2-message ZK does not contradict the impossibility of <a href="#page-23-13">[GO94]</a> sice it is only ZK against m-BAPT adversaries where m is smaller then the length of the first protocol message.</p>

    </section>
`;
---

<BaseLayout title="Indistinguishability Obfuscation vs. Auxiliary-Input Extract... (2013/641)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2013 &middot; eprint 2013/641
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="3-extractable-one-way-functions-against-adversaries-with-2013" />
  </article>
</BaseLayout>
