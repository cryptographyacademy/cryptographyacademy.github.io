---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/327';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Veksel: Simple, Efficient, Anonymous Payments with Large Anonymity Sets from Well-Studied Assumptions';
const AUTHORS_HTML = 'Matteo Campanelli, Mathias Hall-Andersen';

const CONTENT = `    <p class="text-gray-300">Matteo Campanelli [ Aarhus University matteo@cs.au.dk ] and Mathias Hall-Andersen [ Aarhus University ma@cs.au.dk ]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We propose <span class="math">\\mathbb{V}</span>eksel, a simple generic paradigm for constructing efficient non-interactive coin mixes. The central component in our work is a concretely efficient proof <span class="math">\\pi_{1\\text{-many}}</span> that a homomorphic commitment <span class="math">\\mathrm{c}^{*}</span> is a rerandomization of a commitment <span class="math">\\mathrm{c}\\in\\{\\mathrm{c}_{1},\\ldots,\\mathrm{c}_{\\ell}\\}</span> without revealing <span class="math">\\mathrm{c}</span>. We formalize anonymous account-based cryptocurrency as a universal composability functionality and show how to efficiently instantiate the functionality using <span class="math">\\pi_{1\\text{-many}}</span> in a straightforward way (<span class="math">\\mathbb{V}</span>eksel). We instantiate and implement <span class="math">\\pi_{1\\text{-many}}</span> from Strong-RSA, DDH and random oracles targeting <span class="math">\\approx 112</span> bits of security. The resulting NIZK has constant size ($</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_{1\\text{-many}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=5.3<span class="math">KB) and constant proving/verification time (</span>\\approx 90<span class="math">ms), on an already accumulated set. Compared to ZCash—which offers comparable marginal verification cost and an anonymity set consisting of every existing transaction—our transaction are larger (</span>6.2<span class="math"> KB) and verification is slower. On the other hand, </span>\\mathbb{V}<span class="math">eksel relies on more well-studied assumptions, does not require an expensive trusted setup for proofs and is arguably simpler (from an implementation standpoint). Additionally we think that </span>\\pi_{1\\text{-many}}$ might be interesting in other applications, e.g. proving possession of some credential posted on-chain. The efficiency of our concrete NIZK relies on a new Ristretto-friendly elliptic curve, Jabberwock, that is of independent interest: it can be used to efficiently prove statements on “committments on commitments” in Bulletproofs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">bibliography.bib</p>

    <h2 id="sec-3" class="text-2xl font-bold">Keywords</h2>

    <p class="text-gray-300">blockchains, UC, zero-knowledge, accumulators, implementation</p>

    <h2 id="sec-4" class="text-2xl font-bold">1. Introduction</h2>

    <p class="text-gray-300">Cryptocurrencies allow for fully decentralized and publicly verifiable currency systems. An interesting problem in cryptocurrencies is that of guaranteeing some level of privacy by making impossible to an observer to learn anything about the “flow of money”. While users in the network only require known pseudonyms to be identified, we know that they are not sufficient to achieve an acceptable level of privacy <em>(29; 31)</em>.</p>

    <p class="text-gray-300">Several prior works address this problem (ZeroCash, Monero, OmniRing). The main challenge they face is to build solutions that are private but can still scale. An important requirement for scalability are the efficiency of spending and verifying transactions as well as their size. Often this boils down to the efficiency and proof size of their underlying non-interactive <em>zero-knowledge schemes</em>—or NIZKs—these works rely on (a NIZK is a cryptographic primitive allowing to prove knowledge of a secret without leaking anything about it).</p>

    <p class="text-gray-300">Some protocols (e.g., Monero and OmniRing <em>(27)</em>) inherently trade efficiency against privacy requirements. They need to keep a relatively small anonymity set (a ring of signatures, in their specific constructions) for each transaction: a set of “coins” that a spending transaction can refer to. Other solutions (e.g. Zcash <em>(24)</em>) do not have this limitation, but have other caveats. First, they rely on NIZKs where the setup needs to be performed by a trusted authority. For this type of setup, even <em>emulating</em> the trusted authority through a distributed protocol can be expensive in terms of resources and organization<em>(3)</em>. Second, their underlying NIKZ depends on cryptographic assumptions that are not well-studied yet and hard to scrutinize in general (i.e., knowledge-of-exponent-flavored assumptions <em>(20)</em>).</p>

    <p class="text-gray-300">In this work we address the question of <em>how to design cryptocurrencies whose efficiency does not degrade with privacy requirements</em>. A focus on transaction-size is particularly important since nodes need to store transaction histories whose size is often in the tens of millions. Addressing this question, we also focus on solutions that rely on “minimal” cryptographic assumptions. In particular we want to design solutions that rely on <em>transparent</em> proof systems, i.e. that do not require a trusted setup and avoid the use of non-well studied assumptions such as knowledge-of-exponent.</p>

    <p class="text-gray-300">Along the way, we study the problem of formalizing and obtaining privacy in account-based cryptocurrencies. We believe that this model is of interest because many existing cryptocurrencies (e.g. Ethereum) are account-based. Additionally, some of the approaches in literature to balance privacy and accountability are account-based <em>(16)</em>. In this setting where users maintain fixed accounts over time, however, we cannot hope to achieve the same levels of privacy of the UTXO (Unspent Transaction Output) model where each transfer can refer to freshly created pseudonyms. Though weaker, this privacy model is still interesting in some applications. To the best of our knowledge it has not been formally investigated before.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.1. Contribution</h3>

    <p class="text-gray-300">Our main contribution is a concrete construction for a cryptocurrency with privacy-preserving properties <em>that supports arbitrary-sized anonymity sets</em>. We obtain small concrete transaction sizes compared to other solutions in literature (see Figure 1) and efficient marginal costs of verification and spending (see Figure 2 and Section 5). Our construction relies on standard cryptographic assumptions and on transparent non-interactive zero-knowledge proofs (secure in the random oracle model). Our concrete efficiency relies on improvements on the state of art of zero-knowledge arguments over</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Anonymity Set</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Concrete Tx Size</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monero [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">< 24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">QuisQuis</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">13 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lelantus210</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">2.7 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lelantus214</td>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">3.9 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lelantus216</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">5.6 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Omniring210</td>

            <td class="px-3 py-2 border-b border-gray-700">210</td>

            <td class="px-3 py-2 border-b border-gray-700">1.0 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Omniring214</td>

            <td class="px-3 py-2 border-b border-gray-700">214</td>

            <td class="px-3 py-2 border-b border-gray-700">1.3 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Omniring216</td>

            <td class="px-3 py-2 border-b border-gray-700">216</td>

            <td class="px-3 py-2 border-b border-gray-700">1.4 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zcash†</td>

            <td class="px-3 py-2 border-b border-gray-700">Any</td>

            <td class="px-3 py-2 border-b border-gray-700">< 1 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zerocoin</td>

            <td class="px-3 py-2 border-b border-gray-700">Any</td>

            <td class="px-3 py-2 border-b border-gray-700">45 KB</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Veksel</td>

            <td class="px-3 py-2 border-b border-gray-700">Any</td>

            <td class="px-3 py-2 border-b border-gray-700">< 6.3 KB</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\dagger</span>  : relies on large-scale trusted setup and relatively new assumptions.</p>

    <p class="text-gray-300">accumulators that may be of independent interests (more details below). We implement our construction in Rust; its code is open source and available at [2].</p>

    <p class="text-gray-300">Along the way we make the following contributions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We formalize privacy-preserving cryptocurrencies with accounts (Section 6) through a UC functionality.</li>

      <li>We provide a highly general and modular construction for this functionality (Section 3). By a modular description, our construction can be further improved by simply replacing some of its building blocks without having to prove its security again. Its more concrete version is described (in light of following sections) in Appendix A. Our solution supports coins of arbitrary value and can be extended to the UTXO setting (see Appendix D).</li>

      <li>We describe a new concrete transparent NIZK to prove a one-out-of-many relation [23], to prove that one public commitment is rerandomized from a set of existing commitments. Our techniques rely on commit-and-prove <span class="math">^{3}</span>  zero-knowledge proof accumulators in unknown-order groups [7] and on optimized relations in Bulletproofs [11]. One challenge we need to solve is how to commit (and accumulate) to coins. Since coins are also "commitments" it is not immediate to have an efficient proof system that supports this double level of commitments. In our solutions we adopt a new SNARK-friendly elliptic curve that is compatible with Curve25519. We believe this curve (which we dub Jabberwock) and its surrounding techniques can be of independent interest. Among others, its applications can be directly used to obtain efficient anonymous credentials [12].</li>

    </ul>

    <p class="text-gray-300">Groth &amp; Kohlweiss: In [23], Groth and Kohlweiss constructed an efficient proof of size  <span class="math">O(\\log n)</span>  for relation  <span class="math">\\{r : \\exists i \\text{st Comm}(0; r) = c_i\\}</span>  where  <span class="math">c_1, \\ldots, c_n</span>  are Pedersen commitments given as input. Using this they showed how to exploit the homomorphic property</p>

    <p class="text-gray-300">Figure 1: Comparison of transaction size depending on anonymity sets. Veksel obtains the best concrete size for arbitrary anonymity sets from well-studied assumptions.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Spend (time)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (time)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tx Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Amounts</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Monero</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">QuisQuis</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Lelantus</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Omniring</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zerocash</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(log n)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Zerocoin</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Veksel</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(1)</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Asymptotic marginal cost of verification / spending time and transaction size. Above  <span class="math">n</span>  is the anonymity set size.</p>

    <p class="text-gray-300">of the commitment scheme to create concretely efficient anonymous transactions. Similar techniques has since been widely explored in Omniring [27], RingCT3.0 [32] and Lelantus [25]. These works have different concrete efficiency, but share the same asymptotic efficiency:  <span class="math">O(\\log n)</span>  transaction size and inherent  <span class="math">O(n)</span>  spending/verification time since the size of the statement proved in zero-knowledge is linear in the anonymity set. Due to the linear verification time these approaches only scale to anonymity sets of size  <span class="math">\\approx 2^{16}</span>  in practice, even with batch verification techniques.</p>

    <p class="text-gray-300">Zerocoin: Zerocoin [30] uses an RSA accumulator to "compress" the set of coins, a coin is spent by opening the unique serial number of the coin and proving its membership in the accumulator in zero-knowledge. This enables  <span class="math">O(1)</span>  spending/verification assuming the coins have been aggregated ahead of time. Unfortunately the "double discrete-log" proof in Zerocoin relies on cut-and-choose and is therefore concretely inefficient: over 45 KB for 128-bits of security. Additionally Zerocoin does not enable coins to have arbitrary denominations.</p>

    <p class="text-gray-300">Zcash: Zcash (which roughly implements Zerocash [6]) applies the same technique of "compressing the statement" using an accumulator (Merkle tree) which enables it to achieve logarithmic marginal spending/verification cost. Zcash verifies the Merkle path inside a zk-SNARK (Groth16 [22] in the current implementation), which hides the index of the coin to be spent and compresses the membership proof down to  <span class="math">O(1)</span>  with very small constants. In terms of concrete efficiency, Zcash is currently the most efficient decentralized payment system with a "full" anonymity set.</p>

    <p class="text-gray-300">QuisQuis: QuisQuis [19] seeks to mitigate the issue of an ever-growing set of "spending tags" which must be maintained by the nodes in Zerocash to avoid double spending. This is achieved by having the spender essentially do a shuffle locally: the spender picks  <span class="math">n</span>  other unspend coins along with the coin he wishes to spend, then proves that she can spend one of the  <span class="math">n + 1</span>  coins, correctly rerandomize the remaining  <span class="math">n</span>  coins and post the  <span class="math">n</span>  new rerandomized coins on the chain. Since QuisQuis relies on posting the new set of outputs to the chain, the transaction size of this approach is  <span class="math">O(n)</span> . The anonymity set also inherently consists (at best) of the set of unspent outputs (as oppose to the set of all coins created).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 3: The  <span class="math">\\pi_{1\\text{-many}} = (\\pi_{\\text{set-mem}}, \\pi_{\\text{rerand}})</span>  argument consists of two sub-proofs: a) A set membership proof, proving that  <span class="math">c = \\operatorname{Comm}^{\\circ}(\\operatorname{cn}; r_c)</span>  commits to  <span class="math">\\operatorname{cn} \\in A</span> . b) A rerandomization proof, showing that the same  <span class="math">c = \\operatorname{Comm}^{\\circ}(\\operatorname{cn}; r_c)</span>  commits to  <span class="math">\\operatorname{cn} = \\operatorname{cn}^{+} - \\operatorname{Comm}^{\\odot}(0; r)</span>  where  <span class="math">\\operatorname{cn}^{+}</span>  is a part of the statement (public).</p>

    <p class="text-gray-300">Basic Setting. At a basic level our approach to decentralized payments is similar to that of Zerocoin[30], however we aim at supporting coins of arbitrary (hidden) denominations, in this sense we diverge from the simpler setting in [23, 30] where all coins have the same denomination. For sake of providing intuition, in this section we describe the account-based model where each party has a commitment  <span class="math">(\\mathrm{bal}_i)_i</span>  stored on-chain and locally holds the private balance  <span class="math">v_{i}</span>  that is the opening of bal.</p>

    <p class="text-gray-300">To transfer a certain amount  <span class="math">v</span> , a sender party  <span class="math">S</span>  will create a coin spendable by the recipient  <span class="math">\\mathcal{R}</span> , that is a commitment to a triple consisting of: a)  <span class="math">v</span>  the value of the coin (payment amount) b) the identity of the recipient c) a random spending tag  <span class="math">t</span> . The sender then broadcasts this commitment together with an encryption through  <span class="math">\\mathrm{pk}_{\\mathcal{R}}</span>  of its opening. Naturally the sender should also be able to show they can afford the transfer; we temporarily ignore this issue and discuss how to approach it later in this section. Once they have observed that someone created a new coin, all users keep track of it in a set  <span class="math">S_{\\mathrm{coins}}</span>  of existing coins.</p>

    <p class="text-gray-300">In order to claim the transfer—to collect the coin—user  <span class="math">\\mathcal{R}</span>  will need to do two things: (i) show that it knows the opening of one among the existing coins; (ii) reveal its tag  <span class="math">t</span>  so that the coin cannot be spent again. The first step requires some care because we want the transfer to be somewhat private, i.e. with the exception of  <span class="math">S</span>  and  <span class="math">\\mathcal{R}</span> , no observer of the system should learn anything about the coin being collected. To do that we need to apply a zero-knowledge proof showing we know the opening of some coin in  <span class="math">S_{\\mathrm{coins}}</span>  such that this coin encodes tag  <span class="math">t</span> .</p>

    <p class="text-gray-300">Because we require each coin to denote a custom transferred amount, we now have an additional challenge. When parties observe that  <span class="math">\\mathcal{R}</span>  collects a coin, they should have a way to update  <span class="math">\\mathcal{R}</span> 's balance  <span class="math">\\mathrm{bal}_{\\mathcal{R}}</span>  without having  <span class="math">\\mathcal{R}</span>  reveal the value of the coin. While this could be done using the homomorphic properties of commitments by "adding" the coin to the balance, we cannot reveal the coin itself either (that would, at the least, leak the sender!). Thus we</p>

    <p class="text-gray-300">let  <span class="math">\\mathcal{R}</span>  produce a rerandomization <span class="math">^5</span> <span class="math">\\mathrm{cn}^+</span>  of the collected coin; parties can now use homomorphically add the latter to  <span class="math">\\mathrm{bal}_{\\mathcal{R}}</span> .</p>

    <p class="text-gray-300">Following the approach outlined above, collecting a coin requires  <span class="math">\\mathcal{R}</span>  to prove in zero-knowledge that the rerandomized coin  <span class="math">\\mathrm{cn}^+</span>  opens to same amount (and tagging information) as one of the coins in  <span class="math">S_{\\mathrm{coins}}^6</span> . In the remainder of this section we describe our technical solutions to efficiently produce and verify this proof.</p>

    <p class="text-gray-300">Our techniques. As a first step towards our goal, we let parties keep a compressed digest to the set  <span class="math">S_{\\mathrm{coins}}</span> , through algebraic accumulators [4, 7, 9, 12]. Thus, given a set  <span class="math">S</span> , we can produce  <span class="math">A = \\mathrm{accum}(S)</span> , a binding (but usually not hiding) compressing commitments to  <span class="math">S</span> . An important feature of accumulators is that it allows to prove membership of elements "inside"  <span class="math">A</span>  efficiently (that is, with short certificates and fast verification). In order to efficiently prove the desired relation in zero-knowledge we adopt a modular approach and we split it in two components, set membership and rerandomization. We thus apply two proof systems that are specifically efficient for each of the two relation components. To ensure that they refer to the same content, we use a commit-and-prove approach, and link them through a hiding commitment to the coin  <span class="math">cn_k</span>  we are collecting. We now describe this process in more detail.</p>

    <p class="text-gray-300">Recall that coins are commitments to pairs of amounts and additional information (tags and recipient identity). We denote by  <span class="math">\\mathrm{Comm}^{\\odot}(\\cdot;\\cdot)</span>  the commitment procedure that produces coins and by  <span class="math">\\mathrm{Comm}^{\\odot}(\\cdot;\\cdot)</span>  the commitment procedure we use to link the two proofs mentioned above. The first parameter in each is the message we are committing to (which possibly has additional structure) while the second parameter denotes the randomness. For our concrete case, the two commitment schemes can be thought of as variants of Pedersen commitments in different groups. In order to prove that a coin  <span class="math">c_k</span>  is valid without revealing it,  <span class="math">\\mathcal{R}</span>  first produces a</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Comm}^{\\circ}(\\mathrm{cn}_{k},r_{c})</span> where <span class="math">r_{c}</span> is some freshly sampled randomness. Then <span class="math">\\mathcal{R}</span> broadcasts <span class="math">c</span> together with two proofs (<span class="math">\\pi_{\\mathrm{set-mem}},\\pi_{\\mathrm{rerand}}</span>) with the following semantics:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\pi_{\\mathrm{set-mem}}</span>: “I know <span class="math">(\\mathrm{cn}_{k},r_{c})</span> such that <span class="math">\\mathrm{cn}_{k}\\in\\mathrm{Set}(A)</span> and <span class="math">c=\\mathrm{Comm}^{\\circ}(\\mathrm{cn}_{k},r_{c})</span>”.</li>

      <li><span class="math">\\pi_{\\mathrm{rerand}}</span>: “I know <span class="math">(\\mathrm{cn}_{k},r_{c},r)</span> such that <span class="math">\\mathrm{cn}^{*}=\\mathrm{cn}_{k}+\\mathrm{Comm}^{\\circ}(0;r)</span> and <span class="math">c=\\mathrm{Comm}^{\\circ}(\\mathrm{cn}_{k},r_{c})</span>”.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In addition to the above, user <span class="math">\\mathcal{R}</span> needs to prove knowledge of an actual opening of <span class="math">\\mathrm{cn}^{<em>}</span> that refers to the revealed tag, identity <span class="math">\\mathcal{R}</span> and some secret value <span class="math">v</span>. In our concrete construction we use standard sigma protocols to prove knowledge of <span class="math">(v,r)</span> such that $\\mathrm{cn}^{</em>}=f^{v}g^{\\mathrm{H(t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R})}}h^{r}<span class="math">, where </span>\\mathrm{H}<span class="math"> is a collision resistant function that maps to a valid exponent for </span>g<span class="math">. In a sense we prove only a partial opening of </span>\\mathrm{cn}^{*}<span class="math"> since </span>g^{\\mathrm{H(t)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R})}}<span class="math"> can be subtracted publicly from </span>\\mathrm{cn}^{*}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now discuss how we efficiently instantiate <span class="math">\\pi_{\\mathrm{set-mem}}</span> and <span class="math">\\pi_{\\mathrm{rerand}}</span>. We choose to efficiently instantiate <span class="math">\\pi_{\\mathrm{set-mem}}</span> with some of the components in <em>[7]</em>—which describes efficient commit-and-prove zkSNARKs over accumulated sets—and <span class="math">\\pi_{\\mathrm{rerand}}</span> with Bulletproofs, a transparent zero-knowledge schemes with short proofs that are compatible with some instantiations of <em>[7]</em>.</p>

    <p class="text-gray-300">We need some care in applying these techniques. Notice that the proof of rerandomization involves two different types of commitments in the statements (<span class="math">\\mathrm{Comm}^{\\circ}</span> and <span class="math">\\mathrm{Comm}^{\\circ}</span>). Since their output may correspond to different groups, this can make it hard to <em>efficiently</em> instantiate the rerandomize relation for Bulletproofs. To solve these efficiency challenges we restrict what coins we can use in our systems (what coins are <em>permissible</em>) and describe a new SNARK-friendly curve whose arithmetic can be efficiently described as field operations when instantiating Bulletproofs over Ristretto25519.</p>

    <p class="text-gray-300">Figure 3 illustrates a simplified version of our approach. We refer the reader to Section 4 for details.</p>

    <p class="text-gray-300">Outline. In the next section we describe preliminaries. In Section 3 we describe the bulk of our construction with a simplified model which we also introduce informally in the same section. Our formal model in UC (and respective adaptation of our construction in UC) is deferred to Section 6. Section 4 describes our instantiations (proof schemes, curves, etc.). We evaluate <span class="math">\\mathbb{V}</span>eksel in Section 5.</p>

    <h2 id="sec-8" class="text-2xl font-bold">2. Preliminaries</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1. Notation</h3>

    <p class="text-gray-300">When describing an NP relation that we prove through a zero-knowledge argument, we use a semicolon to distinguish between public input and private witness as in <span class="math">R(x;w)</span>. In the context of commitments we use a semicolon to distinguish between the committed value and the masking randomness as in <span class="math">\\mathrm{Comm}(\\mathrm{ck},u;r)</span> where <span class="math">u</span> is the committed value.</p>

    <p class="text-gray-300">We assume all cryptographic algorithms implicitly take as input their respective public parameters whenever this yields no unambiguity, For example we may write <span class="math">\\mathrm{Comm}(u;r)</span> to denote <span class="math">\\mathrm{Comm}(\\mathrm{ck},u;r)</span> whenever <span class="math">\\mathrm{ck}</span> is obvious from the context.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2. Commitments</h3>

    <p class="text-gray-300">We use the following syntax for commitments:</p>

    <h6 id="sec-11" class="text-base font-medium mt-4">Definition 2.1 (Commitments).</h6>

    <p class="text-gray-300">A commitment scheme <span class="math">\\mathrm{C}</span> is a pair of algorithms <span class="math">(\\mathrm{Setup},\\mathrm{Comm})</span> with syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{Setup}(1^{\\lambda})\\to\\mathrm{ck}</span> : generates a commitment key <span class="math">\\mathrm{ck}</span>;</li>

      <li><span class="math">\\mathrm{Comm}(\\mathrm{ck},m;r)\\to c_{m}</span> : produces commitment <span class="math">com_{m}</span> to message <span class="math">m</span> with randomness <span class="math">r</span>.</li>

    </ul>

    <p class="text-gray-300">As it is standard, we call <em>message space</em> the set of of <span class="math">m</span>-s for which <span class="math">\\mathrm{Comm}</span> is defined and commitment space its range, <span class="math">\\mathrm{Rng}(\\mathrm{Comm})</span>. We require commitments to be <em>perfectly hiding</em>—the distribution of <span class="math">\\mathrm{Comm}(\\mathrm{ck},m;r)</span> is identical to the uniform distribution over the commitment space—and <em>computationally binding</em>—no efficient adversary can produce two pairs <span class="math">(m,r),(m^{\\prime},r^{\\prime})</span> such that <span class="math">m\\neq m^{\\prime}</span> and <span class="math">\\mathrm{Comm}(\\mathrm{ck},m;r)=\\mathrm{Comm}(\\mathrm{ck},m^{\\prime};r^{\\prime})</span>. Sometimes we want to require binding only with respect to messages from a set <span class="math">\\mathcal{P}</span> of <em>permissible</em> messages, a subset of the message space. In that case we say the scheme is binding “with respect to set <span class="math">\\mathcal{P}</span>”.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.3. Accumulators</h3>

    <h6 id="sec-13" class="text-base font-medium mt-4">Definition 2.2 (Accumulator scheme).</h6>

    <p class="text-gray-300">An accumulator scheme <span class="math">\\mathrm{Acc}</span> over universe <span class="math">\\mathcal{U}_{\\lambda}(\\mathrm{Acc})</span> (where <span class="math">\\lambda</span> is a security parameter) consists of PPT algorithms <span class="math">\\mathrm{Acc}=(\\mathrm{Setup},\\mathrm{Accum},\\mathrm{PrvMem},\\mathrm{VfyMem})</span> with the following syntax:</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Setup}(1^{\\lambda})\\to(\\mathrm{pp})</span> generates public parameters <span class="math">\\mathrm{pp}</span>. <span class="math">\\mathrm{Accum}(\\mathrm{pp},S)\\to A</span> deterministically computes accumulator <span class="math">A</span> for set <span class="math">S\\subseteq\\mathcal{U}_{\\lambda}(\\mathrm{Acc})</span>. <span class="math">\\mathrm{PrvMem}(\\mathrm{pp},S,x)\\to W</span> computes witness <span class="math">W</span> that proves <span class="math">x</span> is in accumulated set <span class="math">S</span>. <span class="math">\\mathrm{VfyMem}(\\mathrm{pp},A,x,W)\\to b\\in\\{0,1\\}</span> verifies through witness whether <span class="math">x</span> is in the set accumulated in <span class="math">A</span>. We do not require parameter <span class="math">x</span> to be in <span class="math">\\mathcal{U}_{\\lambda}(\\mathrm{Acc})</span> from the syntax.</p>

    <p class="text-gray-300">An accumulator scheme should satisfy correctness—the accumulator works as expected—and soundness—no efficient adversary can choose a set <span class="math">S</span> and then find a witness that checks on <span class="math">\\mathrm{Acc.Accum}(\\mathrm{pp},S)</span> and <span class="math">x\\notin S^{7}</span>.</p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Remark 1 (Efficient Insertion).</h6>

    <p class="text-gray-300">Throughout this work we assume an additional (deterministic) algorithm <span class="math">\\mathrm{Acc.Add}</span> for a scheme <span class="math">\\mathrm{Acc}</span> such that for all <span class="math">\\lambda,x\\in\\mathcal{U}_{\\lambda}(\\mathrm{Acc}),S\\subseteq\\mathcal{U}_{\\lambda}(\\mathrm{Acc})</span> <span class="math">A^{\\prime}=\\mathrm{Acc.Add}(A,x)</span> is such that, if <span class="math">A=\\mathrm{Acc.Accum}(S)</span> then <span class="math">A^{\\prime}=\\mathrm{Acc.Accum}(S\\cup\\{x\\})</span>.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">2.4. NIZKs</h3>

    <p class="text-gray-300">Non-Interactive Zero-Knowledge schemes (or NIZKs) require a reference string which can be either uniformly sampled (a urs), or structured (a srs). In the latter case it needs to be sampled by a trusted party. In this work we use and assume <em>transparent</em> NIZKs, i.e. whose algorithms use a reference string urs sampled uniformly.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Definition 2.3.</h6>

    <p class="text-gray-300">A NIZK for a relation family <span class="math">\\mathfrak{R}=\\{\\mathfrak{R}_{\\lambda}\\}_{\\lambda\\in\\mathbb{N}}</span> is a tuple of algorithms <span class="math">\\mathrm{ZK}=(\\mathrm{Prove},\\mathrm{VerProof})</span> with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathrm{ZK.Prove}(\\mathrm{urs},R,x,w)\\to\\pi</span> takes as input a string urs, a relation description <span class="math">R</span>, a statement <span class="math">x</span> and a witness <span class="math">w</span> such that <span class="math">R(x,w)</span>; it returns a proof <span class="math">\\pi</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>ZK.VerProof(urs, <span class="math">R,x,\\pi</span>) <span class="math">\\rightarrow</span> <span class="math">b</span> <span class="math">\\in</span> <span class="math">\\{0,1\\}</span> takes as input a string urs, a relation description <span class="math">R</span>, a statement <span class="math">x</span> and a proof <span class="math">\\pi</span>; it accepts or rejects the proof.</li>

    </ul>

    <p class="text-gray-300">We require a NIZK to be complete, that is, for any <span class="math">\\lambda\\in\\mathbb{N},R\\in\\Re</span> and <span class="math">(x,w)\\in R</span> it holds with overwhelming probability that VerProof(urs, <span class="math">R,x,\\pi</span>) where urs <span class="math">\\leftarrow</span>s <span class="math">\\{0,1\\}^{\\mathrm{poly}(\\lambda)}</span> and proof <span class="math">\\pi\\leftarrow</span> Prove(urs, <span class="math">R,x,w</span>).</p>

    <p class="text-gray-300">We also require knowledge-soundness and zero-knowledge to hold. Informally, the former states we can efficiently “extract” a valid witness from a proof that passes verification; the latter states that the proof leaks nothing about the witness (this is modeled through a simulator that can output a valid proof for an input in the language without knowing the witness). We use variants of these notions with certain composability properties, e.g. requiring auxiliary inputs and relation generators. For a full formal treatment of these, we refer the reader to Sections 2.2 and 2.5 in <em>[7]</em>.</p>

    <p class="text-gray-300">Whenever the relation family is obviously defined, we talk about a “NIZK for a relation <span class="math">R</span>”.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Remark 2 (Relations and Public Inputs).</h6>

    <p class="text-gray-300">In the algorithms above we have both a relation <span class="math">R</span> and a public input <span class="math">x</span> as inputs. The reason is that in a soundness experiment, <span class="math">R</span> may be constrained to be from a certain distribution on <span class="math">\\Re</span> whereas <span class="math">x</span> can be be chosen arbitrarily by the adversary. See for example Section 2.2 in <em>[7]</em>. In our constructions we often assume prover and verifier to implicitly take as input the relation description.</p>

    <p class="text-gray-300">In the proof of security of our construction we require an additional property for one of our NIZKs, simulation-extractability. Namely, extractability should hold even with respect to an adversary that has access to simulated proofs. We refer the reader to <em>[21]</em> for formal definitions.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Trusted Accumulator-Model.</h4>

    <p class="text-gray-300">In our concrete constructions we will use NIZKs for relations parametrized by accumulators. This requires a tweak in the soundness definition: a malicious adversary should be able to select an arbitrary set, but the accumulator over that set should be computed honestly. Given an accumulator scheme Acc, we informally talk about this specific notion as “security under the Trusted Accumulator-Model for Acc”. We do not provide formal details since this model corresponds to the notion of partial-extractable soundness in Section 5.2 in <em>[7]</em>; we refer the reader to this work for further details. This weaker model fits our applications where an accumulator of existing coins is maintained by the network.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Modular NIZKs through Commit-and-Prove.</h4>

    <p class="text-gray-300">We use the framework for black-box modular composition of commit-and-prove NIZKs (or CP-NIZKs) in <em>[13]</em> and <em>[7]</em>. Informally a CP-NIZK is a NIZK that can efficiently prove properties of committed inputs through some commitment scheme <span class="math">\\mathrm{C}^{\\omega}</span>. Let <span class="math">x</span> be a public input and <span class="math">c_{\\circ}</span> a commitment. Such a scheme can for example prove knowledge of <span class="math">(u,\\omega,r)</span> such that <span class="math">c_{\\circ}=\\mathrm{Comm}^{\\circ}(u;r)</span> and that relation <span class="math">R_{\\mathrm{inner}}(x;u,\\omega)</span> holds. We can think of <span class="math">\\omega</span> as a non-committed part of the witness. Besides the proof, the verifier’s inputs are <span class="math">x</span> and <span class="math">c_{\\circ}</span>.</p>

    <p class="text-gray-300">In Section 4.2 we will make use of the following folklore composition to obtain efficient NIZKs from CP-NIZKs. Fixed a commitment scheme and given two CP-NIZKs CP, CP^{′} respectively for two “inner” relations <span class="math">R</span> and <span class="math">R^{\\prime}</span>, we can prove their conjunction (for a shared witness <span class="math">u</span>) <span class="math">R^{<em>}(x,x^{\\prime},u,\\omega,\\omega^{\\prime})=R(x,u,\\omega)\\wedge R^{\\prime}(x^{\\prime},u,\\omega^{\\prime})</span> like this: the prover commits to <span class="math">u</span> as <span class="math">c_{\\circ}\\leftarrow\\mathrm{Comm}^{\\circ}(u,r)</span>; generates proofs <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> from the respective schemes; it outputs combined proof <span class="math">\\pi^{</em>}:=(c_{\\circ},\\pi,\\pi^{\\prime})</span>. The verifier checks each proof over respective inputs <span class="math">(x,c_{\\circ})</span> and <span class="math">(x^{\\prime},c_{\\circ}^{\\prime})</span>.</p>

    <p class="text-gray-300">The following theorem (informally stated) is a direct consequence of Theorem 3.1 in <em>[13]</em>.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 2.4 (Black-Box Composition or CP-NIZKs).</h6>

    <p class="text-gray-300">The construction above is a secure NIZK for the conjunction relation <span class="math">R^{*}</span>.</p>

    <p class="text-gray-300">We can see Bulletproof <em>[11]</em> as a CP-NIZK since it works efficiently over an implicit commitment representation (see discussion in <em>[13]</em>). We use this fact in our instantiations (in Section 4).</p>

    <h2 id="sec-21" class="text-2xl font-bold">3. A Construction for Anonymous Account-based Payments</h2>

    <p class="text-gray-300">In this section we provide intuitions about our model and our main construction. Our description tries to be as general as possible and to push all features that can be seen as optimizations to our instantiations in Section 4. The bulk of our construction is in Figure 4. A more concrete and optimized version is in Appendix A.</p>

    <h3 id="sec-22" class="text-xl font-semibold mt-8">3.1. Intuition on the Model and an Auxiliary Syntax</h3>

    <p class="text-gray-300">While we present a fully formal model in section 6, here we describe our construction of an anonymous payment system through a simplified syntax which we dub a “Decentralized Unlinkable-Payments” scheme (DUP). Thus we can present our scheme without having to dive into the technicalities of universal composability right away.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">Model Intuition.</h4>

    <p class="text-gray-300">The intuition about our architecture is a as follows (more information about syntax further in this section):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>we assume a setup stage where parties are assigned initial balances and public parameters of the system. Each party holds a current ledger state which contains their knowledge about the current state of affairs depending on the history of transactions.</li>

      <li>a transfer from <span class="math">\\mathcal{S}</span> to <span class="math">\\mathcal{R}</span> occurs with party <span class="math">\\mathcal{S}</span> producing a “create” transaction. This contains a coin and a proof of its validity. At the same time party <span class="math">\\mathcal{S}</span> will also privately send auxiliary information to <span class="math">\\mathcal{R}</span> which the latter can later use to claim the coin.</li>

      <li>to claim a coin and update their balance, a receiver of a coin will produce a “collect” transaction through the auxiliary information received earlier. Notice that which coin is being collected should remain hidden by the security properties.</li>

      <li>verification and processing of a coin: after a transaction (of type create or collect) is broadcast, all parties verify their validity and update their state accordingly. Verification of create-transactions should ensure the sender can afford them;</li>

    </ul>

    <p class="text-gray-300">verification of collect-transactions should ensure receivers are collecting existing coins <em>to them</em> and that these have not been claimed before.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">Security Intuition.</h4>

    <p class="text-gray-300">Our security properties are later modeled though the functionality in section 6, but intuitively our model captures: <em>anonymity</em> (the adversary cannot link honest create/collects <em>and</em> values of transactions are hidden), <em>balance conservation</em> (no money can be created in the system), <em>security of balances</em> (the adversary cannot “steal money” from honest parties) and <em>“Faerie gold”</em>-type attacks where a corrupted party can create multiple coins accepted by honest parties of which only a subset can be spent.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Syntax.</h4>

    <p class="text-gray-300">A formal description of the syntax we assume:</p>

    <h6 id="sec-26" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A DUP scheme consists of a tuple of PPT algorithms <span class="math">\\textsc{DUP}=(\\textsc{Setup},\\textsc{CreateCoin},\\textsc{CollectCoin},\\textsc{Vfy},\\textsc{Process})</span> with the following syntax:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\textsc{Setup}(1^{\\lambda})\\to(\\text{pp},\\mathcal{L}_{0},(\\text{st}_{i})_{i\\in[m]})</span> Generates public parameters, an initial ledger <span class="math">\\mathcal{L}_{0}</span> and the initial private state of all users;</li>

      <li><span class="math">\\textsc{CreateCoin}(\\text{pp},\\text{st}_{\\mathcal{S}},\\text{pk}_{\\mathcal{R}},v)\\to(\\text{st}^{\\prime}_{\\mathcal{S}},\\text{aux}_{\\text{coin}},\\text{tx}_{\\text{create}})</span> Makes a coin c of value <span class="math">v</span> payable to user <span class="math">\\mathcal{R}</span>; it embeds the coin in a public transaction <span class="math">\\text{tx}_{\\text{create}}</span>; <span class="math">\\text{aux}_{\\text{coin}}</span> contains information sent privately to <span class="math">\\mathcal{R}</span>; it also outputs a new private state <span class="math">\\text{st}^{\\prime}_{\\mathcal{S}}</span>.</li>

      <li><span class="math">\\textsc{CollectCoin}(\\text{pp},\\text{st}_{\\mathcal{R}},\\text{aux}_{\\text{coin}},\\mathcal{L})\\to(\\text{st}^{\\prime}_{\\mathcal{R}},\\text{tx}_{\\text{clct}})</span> It takes as input a a private state <span class="math">\\text{st}_{\\mathcal{R}}</span>, a string <span class="math">\\text{aux}_{\\text{coin}}</span> and a ledger <span class="math">\\mathcal{L}</span>; it outputs a new private state <span class="math">\\text{st}^{\\prime}_{\\mathcal{R}}</span> and a “collect” transaction <span class="math">\\text{tx}_{\\text{clct}}</span>.</li>

      <li><span class="math">\\textsc{Vfy}(\\text{pp},\\text{tx},\\mathcal{L})\\to\\text{accept}/\\text{reject}</span> It verifies a transaction tx with respect to ledger <span class="math">\\mathcal{L}</span>.</li>

      <li><span class="math">\\textsc{Process}(\\text{pp},\\text{tx},\\mathcal{L})\\to\\mathcal{L}^{\\prime}</span> It processes a transaction tx with respect to ledger <span class="math">\\mathcal{L}</span> and returns a new ledger.</li>

    </ol>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">3.2. Building Blocks for Our Construction</h3>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Commitment schemes</h4>

    <p class="text-gray-300">We assume a commitment scheme <span class="math">\\textsc{C}^{\\circ}=(\\textsc{Setup}^{\\circ},\\textsc{Comm}^{\\circ})</span>. We concretely instantiate it later in Figure 6 as a Pedersen commitment over pairs. We also make the following assumptions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We assume that we can commit to pairs and they are homomorphic with respect to pairs, that is <span class="math">\\textsc{Comm}((a,b);r)+\\textsc{Comm}((c,d);r^{\\prime})=\\textsc{Comm}((a+c,b+d);r+r^{\\prime})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Given a value <span class="math">v</span>, a tag <span class="math">t</span> and an identity <span class="math">\\mathcal{R}</span> we assume that the concatenation $t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}<span class="math"> is such that </span>(v,t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R})$ is always a pair in the message space of the commitment scheme.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We assume all commitment invocations take as input the public commitment key ck although not explicitly included. We assume the same for zero-knowledge proofs over commitment in the protocol.</li>

    </ul>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Zero-Knowledge Arguments</h4>

    <p class="text-gray-300">We assume the following zero-knowledge arguments. We assume the commitment key to be part of the relation description. Although we keep it implicit, one should think of the following relations as parametrized by it.</p>

    <p class="text-gray-300">We use three zero knowledge proofs for the following tasks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Knowledge of opening:</em> at collection time, we prove knowledge of opening of a coin we are collecting. For technical reasons (see construction) we require the second component to be zero, that is this argument shows knowledge of opening to a pair <span class="math">(v,0)</span>.</li>

      <li><em>Ranges:</em> whenever we transfer an amount (“create” tx), we prove that we can afford the transfer. We also prove that the transferred amount is non-negative (so that we are not subtracting a negative value from our balance increasing it!). This involves proving that the opening of two distinct commitments—an updated balance and a coin—are both in a range <span class="math">[0,B_{\\max}]</span> where we consider <span class="math">B_{\\max}</span> a parameter of the construction. Although the commitments we assume here bind to pairs of values <span class="math">(a,b)</span> (rather than single value), we are interested only in ensuring that the first component <span class="math">a</span> is in range.</li>

      <li><em>One coin out of many:</em> whenever we claim an amount (“collect” tx), we also need to prove that the coin we are collecting actually exists. We want to do this without revealing that coin we are collecting, thus we prove that a rerandomized commitment <span class="math">\\text{c}^{*}</span> (which we revealed publicly) actually refers to “one out of many” in the set of existing coins.</li>

    </ul>

    <p class="text-gray-300">Formally we assume the following NIZKs:</p>

    <p class="text-gray-300">ZKOpen is an extractable NIZK argument for the relation</p>

    <p class="text-gray-300"><span class="math">R_{\\text{opn}}(c;v,r)=1\\iff\\text{c}=\\text{Comm}^{\\circ}((v,0);r)</span></p>

    <p class="text-gray-300">ZKDblRange is a NIZK argument for the relation</p>

    <p class="text-gray-300"><span class="math">R_{\\text{DRng}}(c,c^{\\prime};(a,b),r,(a^{\\prime},b^{\\prime}),r^{\\prime})=1\\iff</span> <span class="math">a\\in[0,B_{\\max}]\\wedge a\\in[0,B_{\\max}]</span> <span class="math">\\wedge\\text{ c}=\\text{Comm}^{\\circ}((a,b);r)</span> <span class="math">\\wedge\\text{ c}^{\\prime}=\\text{Comm}^{\\circ}((a^{\\prime},b^{\\prime});r^{\\prime})</span></p>

    <p class="text-gray-300">ZK-1-many is a simulation-extractable NIZK argument for the relation</p>

    <p class="text-gray-300"><span class="math">R_{\\text{1-many}}(c^{<em>},S;\\text{c},r^{</em>})=1\\iff\\text{c}\\in S\\wedge\\text{ c}^{<em>}=\\text{c}+\\text{Comm}^{\\circ}((0,0);r^{</em>})</span></p>

    <p class="text-gray-300">For simplicity we assume a single uniform reference string urs for all of them that can be sampled from a space large enough parametrized by security parameter <span class="math">\\lambda</span> and maximum balance <span class="math">B_{\\max}</span>.</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">3.3. Construction Description</h3>

    <p class="text-gray-300">Our construction is in fig. 4.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Ledger, states and transactions</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume a ledger to be structured as a triple <span class="math">\\mathcal{L}=(S_{\\text{null}},S_{\\text{coins}},\\{\\text{bal}\\}_{i\\in[m]})</span> containing: a set <span class="math">S_{\\text{null}}</span> of “nullified” coin tag–recipient identity $t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}<span class="math">; an set </span>S_{\\text{coins}}<span class="math"> of coins created so far; a tuple of commitments </span>\\{\\text{bal}\\}_{i\\in[m]})<span class="math"> to the balances of parties. Within the construction we implicitly parse the ledger according to this syntax. We let states contain the opening of their committed balances. Notice that, for technical reasons, </span>\\text{bal}_{i}<span class="math"> is not a commitment to a single scalar </span>B<span class="math"> representing the balance amount. Instead a private state </span>\\text{st}_{i}-<span class="math">the opening of </span>\\text{bal}_{i}-<span class="math">is a triple </span>(B,\\text{aux}_{t},r_{i})<span class="math"> such that </span>\\text{bal}_{i}=\\text{Comm}((B,\\text{aux}_{t}),r_{i})<span class="math">, that is it opens to the pair </span>(v,\\text{aux}_{t})<span class="math"> where </span>\\text{aux}_{t}$ is a “hint” to open the balance</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and depends on the transfers that user <span class="math">i</span> carried out till any given moment in time (see construction for details). Transactions can be of two types, Create or Collect; we prepend a type description to each transaction.</p>

    <h2 id="sec-32" class="text-2xl font-bold">4. Efficient Instantiations of Our Arguments</h2>

    <p class="text-gray-300">In this section we describe how to instantiate our construction from the previous section through transparent and efficient proof systems. We describe this at different levels of abstraction.</p>

    <p class="text-gray-300">First we replace a set (of coins) with a compressed representation, an accumulator. Thus we replace relation <span class="math">R_{1\\text{-many}}</span> with <span class="math">R_{1\\text{-many}}^{A}</span> that works over an accumulator <span class="math">A</span>. We then proceed how to decompose the latter efficiently through a commit-and-prove approach. In the rest of the section we describe our specific instantiations using: RSA accumulators, zero-knowledge techniques on them from <em>[7]</em>, and Bulletproofs.</p>

    <p class="text-gray-300">Our main technical challenge is how to have commitments over coins (which are themselves commitments) that support efficient proofs over them. We do this introducing a new SNARK-friendly curve (in the pairing-free group of Curve25519) and embedding its arithmetic in a Bulletproof relation in an optimized manner (see also Appendix C).</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">On notation.</h4>

    <p class="text-gray-300">We will use and describe two commitments schemes in this section, <span class="math">\\text{C}^{\\circ}</span> and <span class="math">\\text{C}^{\\circ}</span>. The scheme <span class="math">\\text{C}^{\\circ}</span> is the scheme we use in our construction for payments in the previous section; we can think of its output as coins and we denote them by a circle as in <span class="math">c_{\\circ}</span>. The elements of the accumulated set are the output of <span class="math">\\text{Comm}^{\\circ}</span>. The commitment scheme <span class="math">\\text{C}^{\\circ}</span> is the one we use for commit-and-prove NIZKs (see also construction for Theorem 2.4). We denote its output as <span class="math">\\text{Comm}^{\\circ}</span>.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">4.1. One-out-of-many Relations over Accumulators</h3>

    <p class="text-gray-300">Here we define a variant of the one-out-of-many relation <span class="math">R_{1\\text{-many}}</span> introduced in Section 3.2. Instead of taking as input a set we let the relation be parametrized by an accumulator, a binding commitment to the set. Thus we can reduce prover and verifier’s complexity to that of proving <span class="math">\\text{PrvMem}</span> and <span class="math">\\text{VfyMem}</span> which both run in constant time in our instantiation.</p>

    <p class="text-gray-300">Given an accumulator scheme <span class="math">\\text{Acc}</span> and an accumulator <span class="math">A</span>, the relation <span class="math">R_{1\\text{-many}}^{A}</span> is defined as:</p>

    <p class="text-gray-300"><span class="math">R_{1\\text{-many}}^{A}(c_{\\circ}^{<em>};c_{\\circ},r_{\\circ}^{</em>},W)=1</span> <span class="math">\\iff</span> <span class="math">\\text{Acc.VfyMem}(A,\\text{c},W)</span> <span class="math">\\land</span> <span class="math">c_{\\circ}^{<em>}=c_{\\circ}+\\text{Comm}^{\\circ}((0,0);r_{\\circ}^{</em>})</span></p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">4.2. One-out-of-many from Commit-and-Prove NIZKs</h3>

    <p class="text-gray-300">Here we use the construction in Theorem 2.4. For that we need CP-NIZKs that work over commitments to <span class="math">c_{\\circ}</span>. As usual we denote the commitment scheme for CP-NIZKs as <span class="math">\\text{C}^{\\circ}</span>.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">Permissible Set.</h4>

    <p class="text-gray-300">We assume a permissible set <span class="math">\\mathcal{P}</span> of coins <span class="math">c_{\\circ}</span>. This allows us to model security requirements in a fine-grained way, e.g. we assume computational binding of <span class="math">\\text{C}^{\\circ}</span> to hold only for coins in <span class="math">\\mathcal{P}</span> and similarly the soundness of the accumulator (we ensure this implicitly; see Figure 5). In this section we keep the permissible set abstract but we specify it completely in Section 4.3.1.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Breaking Down <span class="math">R_{\\text{setmem}}^{A}</span>.</h4>

    <p class="text-gray-300">We can decompose the above through two commit-and-prove schemes for the following two relations. The first one proves set membership, but does not guarantee that the coin is permissible (this is for technical reasons we explain in Section 4.4). The other relation guarantees that we can open (in <span class="math">\\text{C}^{\\circ}</span>) to a rerandomized permissible commitment (in <span class="math">\\text{C}^{\\circ}</span>).</p>

    <p class="text-gray-300"><span class="math">R_{\\text{setmem}}^{A}(c_{\\circ};c_{\\circ},r_{\\circ},W)=1</span> <span class="math">\\iff</span> <span class="math">(\\text{Acc.VfyMem}(A,c_{\\circ},W)\\lor c_{\\circ}\\notin\\mathcal{P})</span> <span class="math">\\land</span> <span class="math">c_{\\circ}=\\text{Comm}^{\\circ}(c_{\\circ};r_{\\circ})</span> <span class="math">R_{\\text{rrnd}\\&amp;prms}(c_{\\circ},c_{\\circ}^{<em>};c_{\\circ},r_{\\circ},r_{\\circ}^{</em>})=1</span> <span class="math">\\iff</span> <span class="math">c_{\\circ}^{<em>}=c_{\\circ}+\\text{Comm}^{\\circ}((0,0);r_{\\circ}^{</em>})</span> <span class="math">\\land</span> <span class="math">c_{\\circ}\\in\\mathcal{P}</span> <span class="math">\\land</span> <span class="math">c_{\\circ}=\\text{Comm}^{\\circ}(c_{\\circ};r_{\\circ})</span></p>

    <p class="text-gray-300">We can now obtain a proof scheme for <span class="math">R_{1\\text{-many}}^{A}</span> by composing <span class="math">\\text{ZKCP}_{\\text{setmem}}^{A}</span> and <span class="math">\\text{ZKCP}_{\\text{rrnd}\\&amp;prms}</span> and applying Theorem 2.4 in the Trusted-Accumulator Model.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Corollary 4.1.</h6>

    <p class="text-gray-300">Let <span class="math">\\text{Acc}</span> be an accumulator scheme and <span class="math">\\text{C}^{\\circ}</span> a commitment scheme that is computationally binding w.r.t. set <span class="math">\\mathcal{P}</span>. Then the composition of <span class="math">\\text{ZKCP}_{\\text{setmem}}^{A}</span> and <span class="math">\\text{ZKCP}_{\\text{rrnd}\\&amp;prms}</span> as for Theorem 2.4 is a NIZK for <span class="math">R_{1\\text{-many}}^{A}</span> in the Trusted-Accumulator Model for <span class="math">\\text{Acc}</span>.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.3. Instantiating Accumulators and Commitment Schemes</h3>

    <p class="text-gray-300">We first describe our accumulator and commitment schemes construction and then describe the concrete groups in which they operate in Section 4.3.1.</p>

    <p class="text-gray-300">We assume a group of unknown order <span class="math">\\mathbb{G}_{?}</span> for our accumulator construction. For our commitments we assume two groups <span class="math">\\mathbb{G}^{\\circ}</span> and <span class="math">\\mathbb{G}^{\\circ}</span>. The two groups are related as we assume we can represent <span class="math">\\mathbb{G}^{\\circ}</span> elements as pairs <span class="math">(\\mathbb{F}_{[\\mathbb{G}^{\\circ}]},\\mathbb{F}_{[\\mathbb{G}^{\\circ}]})</span> (see also Section 4.3.1).</p>

    <p class="text-gray-300">Our accumulator schemes supports sets of <span class="math">\\mathbb{G}^{\\circ}</span> elements with a special structure (the first component should be prime, the standard encoding for elements in accumulators in groups of unknown order). The commitment scheme <span class="math">\\text{Comm}^{\\circ}</span> has as message space pairs <span class="math">(\\mathbb{F}_{[\\mathbb{G}^{\\circ}]},\\mathbb{F}_{[\\mathbb{G}^{\\circ}]})</span> and commitment space <span class="math">\\mathbb{G}^{\\circ}</span>. The scheme <span class="math">\\mathbb{G}^{\\circ}</span> has as message space elements in <span class="math">\\mathbb{G}^{\\circ}</span>.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Constraints on Permissible Set.</h4>

    <p class="text-gray-300">The permissible set <span class="math">\\mathcal{P}</span> is a set of pairs in <span class="math">(\\mathbb{F}_{[\\mathbb{G}^{\\circ}]},\\mathbb{F}_{[\\mathbb{G}^{\\circ}]}</span>. We require that the permissible set <span class="math">\\mathcal{P}</span> is such that there are no “collisions in the second components” that</p>

    <p class="text-gray-300">|  Setup(1λ) → (pp, L0, (sti)i∈[m])  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  ck ← Setup⊕(1λ)  |   |</p>

    <p class="text-gray-300">|  urs ← UZK(1λ, Bmax)  |   |</p>

    <p class="text-gray-300">|  for i = 1..m do  |   |</p>

    <p class="text-gray-300">|  // Create balances for all parties at default v0  |   |</p>

    <p class="text-gray-300">|  ri ← F  |   |</p>

    <p class="text-gray-300">|  bali ← Comm⊕(v0; ri)  |   |</p>

    <p class="text-gray-300">|  sti := (v0, 0, ri)  |   |</p>

    <p class="text-gray-300">|  L0 := {0, 0, (bali)i∈[m]}  |   |</p>

    <p class="text-gray-300">|  return {pp := ck, L0, (sti)i∈[m]}  |   |</p>

    <p class="text-gray-300">|  CreateCoin(pp, stS, R, v) → (st'S, auxcoin, txcreate)  |   |</p>

    <p class="text-gray-300">|  Parse stS as (B, auxt, rS)  |   |</p>

    <p class="text-gray-300">|  t ← {0, 1}λ; rc ← F  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ← Comm⊕((v, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R); rc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  // Update balance subtracting coin from current balance  |   |</p>

    <p class="text-gray-300">|  bal' ← Comm⊕((B, auxt); rS) - c  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">o' := ((B - v, auxt - t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R), rS - rc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  // Prove coin amount is positive and that S can afford it  |   |</p>

    <p class="text-gray-300">|  πcreate ← ZKDblRange.Prove(urs, c, bal'; oc, o')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">st'S := (B - v, auxt - t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R, rS - rc)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Let auxcoin := (v, t, rc)  |   |</p>

    <p class="text-gray-300">|  txcreate := (Create, c, πcreate)  |   |</p>

    <p class="text-gray-300">|  return (st'S, auxcoin, S, txcreate)  |   |</p>

    <p class="text-gray-300">|  Process(pp, tx, L) → L'  |   |</p>

    <p class="text-gray-300">|  Run Vfy(pp, tx, L) and abort if it fails  |   |</p>

    <p class="text-gray-300">|  if type(tx) = Create then  |   |</p>

    <p class="text-gray-300">|  Parse tx as (Create, c, S, πcreate)  |   |</p>

    <p class="text-gray-300">|  // add coin to set  |   |</p>

    <p class="text-gray-300">|  S'coins ← Scoins ∪ {c}  |   |</p>

    <p class="text-gray-300">|  // homomorphically update balance of sender  |   |</p>

    <p class="text-gray-300">|  bal'S ← balS - c  |   |</p>

    <p class="text-gray-300">|  elseif type(tx) = Collect then  |   |</p>

    <p class="text-gray-300">|  Parse tx as (Collect, c*, t, R, πclct)  |   |</p>

    <p class="text-gray-300">|  // add tag to nullifier set  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">S'null ← Snull ∪ {t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  // homomorphically update balance of receiver  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cv ← c* - Comm⊕((0, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R); 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  bal'R ← balR + cv  |   |</p>

    <p class="text-gray-300">|  Let L' be L updated with new set and balance  |   |</p>

    <p class="text-gray-300">|  return L'  |   |</p>

    <p class="text-gray-300">|  CollectCoin(pp, stR, auxcoin, L) → (st'R, txclct)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Parse stS as (B, auxt, rR)  |   |</p>

    <p class="text-gray-300">|  Parse auxcoin as (v, t, rc)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c ← Comm⊕((v, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R); rc)// reconstruct coin</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  // Rerandomize coin  |   |</p>

    <p class="text-gray-300">|  r<em> ← F; c</em> ← c + Comm⊕((0, 0); r*)  |   |</p>

    <p class="text-gray-300">|  // Prove one out of many w.r.t. accumulator  |   |</p>

    <p class="text-gray-300">|  π1-many ← ZK-1-many.Prove(urs, c<em>, Scoins; r</em>)  |   |</p>

    <p class="text-gray-300">|  // Prove “partial” opening of c*  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cv ← c* - Comm⊕((0, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R); 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  πopn ← ZKOpen.Prove(urs, cv; v, rc + r*)  |   |</p>

    <p class="text-gray-300">|  r'R ← rR + rc + r*  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">st'R := (B + v, auxt + t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R, r'R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  txclct := (Collect, c*, t, R, πclct := (π1-many, πopn))  |   |</p>

    <p class="text-gray-300">|  return (st'R, txclct)  |   |</p>

    <p class="text-gray-300">|  Vfy(pp, tx, L) → accept/reject  |   |</p>

    <p class="text-gray-300">|  if type(tx) = Create then  |   |</p>

    <p class="text-gray-300">|  Parse tx as (Create, c, S, πcreate)  |   |</p>

    <p class="text-gray-300">|  Assert ZKDblRange.Vfy(urs, c, balS - c, , πcreate) = 1  |   |</p>

    <p class="text-gray-300">|  elseif type(tx) = Collect then  |   |</p>

    <p class="text-gray-300">|  Parse tx as (Collect, c*, t, R, πclct := (π1-many, πopn))  |   |</p>

    <p class="text-gray-300">|  Assert ZK-1-many.Vfy(urs, c*, Scoins, π1-many) = 1  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cv ← c* - Comm⊕((0, t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R); 0)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Assert ZKOpen.Vfy(urs, cv) = 1  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Assert t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R∉Snull</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Procedures describing the bulk of our construction; we use them as auxiliary syntax when we show our construction in more detail in Section 6 (where we also take care of authentication/channels) and it is fully unfolded in Appendix A. These procedures have no side-effects (except for sampling randomness) and return pure functions of their inputs.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 5: Accumulator Instantiation for Acc.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 6: Commitment Instantiations for  <span class="math">C^{\\circ}</span>  and  <span class="math">C^{\\circ}</span> .</p>

    <p class="text-gray-300">is: for all  <span class="math">(\\pi, y) \\in \\mathcal{P}</span>  there exists no  <span class="math">y&#x27; \\neq y</span>  such that  <span class="math">(\\pi, y&#x27;) \\in \\mathcal{P}</span> . This is the case for permissible sets over elliptic curves such as the one we define in Section 4.3.1.</p>

    <p class="text-gray-300"><strong>Constructions.</strong> We now proceed to describe our constructions for accumulators and commitments. We denote by  <span class="math">\\mathcal{G}</span>  a group generation function which we assume returns a group description together with a generator.</p>

    <p class="text-gray-300">In Figure 5 we describe our accumulator instantiation. This construction is secure under the Strong-RSA assumption <span class="math">^{12}</span>  and is based on the construction from Barić and Pfitzmann [4], later used in the context of efficient proofs in [7, 9, 12] among other works. In the accumulator construction we describe explicitly the structure of the messages (elements in  <span class="math">\\mathbb{G}^{\\circ}</span> ) as pairs of components and we accumulate using first component only. Notice that we describe the construction through a variant of the syntax in the preliminaries (Definition 2.2): we define only an insertion algorithm and let the setup return an accumulator  <span class="math">A_0</span>  to an empty set. We assume the Strong-RSA property holds for  <span class="math">\\mathbb{G}_?</span>  (and its group generation algorithm).</p>

    <p class="text-gray-300">The commitment schemes  <span class="math">\\mathbf{C}^{\\circ}</span>  and  <span class="math">\\mathbf{C}^{\\circ}</span>  are described in Figure 6. They are both standard Pedersen commitments, but we make the following tweaks: in  <span class="math">\\mathbf{C}^{\\circ}</span>  the messages are pairs; in  <span class="math">\\mathbf{C}^{\\circ}</span>  we describe</p>

    <p class="text-gray-300">explicitly the structure of the messages (elements in  <span class="math">\\mathbb{G}^{\\circ}</span> ) as pairs of components and we commit to the first component discarding the second. Recall that we can do this in light of the constraint on the second component from  <span class="math">\\mathcal{P}</span> . We assume that the discrete-log assumption holds for  <span class="math">\\mathbb{G}^{\\circ}</span>  and  <span class="math">\\mathbb{G}^{\\circ}</span> .</p>

    <p class="text-gray-300">We do not prove security of the schemes in Figures 5 and 6 since it is standard.</p>

    <p class="text-gray-300">THEOREM 4.2 (SECURITY OF SCHEMES IN FIGURES 5 AND 6).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the Strong-RSA assumption holds for  <span class="math">\\mathcal{G}_?</span>  then the construction in Figure 5 is a secure accumulator for sets  <span class="math">S\\subset \\mathcal{P}</span>  where all the  <span class="math">(\\pi ,y)\\in S</span>  have all distinct primes  <span class="math">\\pi</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If the DLOG assumption holds for  <span class="math">\\mathcal{G}_{\\circ}</span>  (resp.  <span class="math">\\mathcal{G}_{\\circ}</span> )  <span class="math">\\mathrm{C}^{\\circ}</span>  (resp.  <span class="math">\\mathrm{C}^{\\circ}</span> ) is a computationally binding (resp. binding w.r.t  <span class="math">\\mathcal{P}</span> ) and perfectly hiding commitment scheme with message space  $(\\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\circ}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\circ}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">  (resp.  </span>\\mathbb{G}^{\\circ}<span class="math"> ) and commitment space  </span>\\mathbb{G}^{\\circ}<span class="math">  (resp.  </span>\\mathbb{G}^{\\circ}$ ).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">REMARK 3 (ACCUMULATORS WITHOUT TRAPDOORS). We observe that our accumulator scheme construction can be instantiated in class groups [10] or constructions based on hyperelliptic curve constructions [17, 28] assuming the Low-Order Assumption holds for  <span class="math">\\mathcal{G}_?</span> . We also refer the reader to Appendix E in [7].</p>

    <p class="text-gray-300">REMARK 4 (TRAPDOORS IN RSA GROUPS AND MPC). We note that there exist practical MPC protocols to securely construct RSA moduli, e.g., [15].</p>

    <p class="text-gray-300">4.3.1 Group Instantiations and Set of Permissible Coins. We now describe concrete instantiations targeting 128-bits of security.</p>

    <p class="text-gray-300">Group  <span class="math">\\mathbb{G}^{\\square}</span>  The group  <span class="math">\\mathbb{G}^{\\square}</span>  -used in our commit-and-prove NIZKs- is Ristretto25519, the Ristretto subgroup of Curve25519 <span class="math">^{13}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Group  <span class="math">\\mathbb{G}^{\\square}</span>  and the Jabberwock Curve Group  $\\mathbb{G}^{\\square} = \\mathbb{E}(\\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math">  used to represent coins and other commitments in our constructions is derived from an elliptic curve over the scalar field  </span>\\mathbb{F}^{\\square} = \\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  of the curve  </span>\\mathbb{G}^{\\square}$  (Ristretto25519) with:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} ^ {\\square} \\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2 ^ {2 5 2} + 2 7 7 4 2 3 1 7 7 7 7 3 7 2 3 5 3 5 3 5 8 5 1 9 3 7 7 9 0 8 8 3 6 4 8 4 9 3</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">In particular, we instantiate  <span class="math">\\mathbb{G}^{\\square}</span>  as the Edwards curve [8, 18] with equation:</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {2} y ^ {2} = 1 - 6 9 8 x ^ {2} y ^ {2}</span></div>

    <p class="text-gray-300">The curve has a cofactor of 4 and a prime order group of  <span class="math">2^{250} - 28148165643402996844773726717916548891</span> .</p>

    <p class="text-gray-300">Similar techniques has previously been used in the C0C0 [26] framework and Zcash [24] (JubJub curve <span class="math">^{14}</span> ).</p>

    <p class="text-gray-300">Group  <span class="math">\\mathbb{G}_7</span>  The group  <span class="math">\\mathbb{G}_7</span>  is a 2048-bit RSA group.</p>

    <p class="text-gray-300">Permissible Set The set  <span class="math">\\mathcal{P}</span>  of commitments, parametrized by an integer  <span class="math">\\mu</span> , consists of points on  <span class="math">\\mathbb{G}^{\\square}</span> , where the  <span class="math">\\pi</span> -coordinate is a  <span class="math">\\mu</span> -bit prime and the  <span class="math">\\gamma</span> -coordinate is the "canonically chosen" square root so that the point can be described by its  <span class="math">\\pi</span> -coordinate alone.</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\begin{array}{l} \\mathcal {P} = \\left\\{\\left(\\pi , y\\right) \\in \\mathbb {G} ^ {\\square} \\subseteq \\left(\\mathbb {F} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} ^ {\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}, \\mathbb {F} _ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb {G} ^ {\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right) \\mid \\right. \\\\ \\pi \\in [ 2 ^ {\\mu - 1}, 2 ^ {\\mu}) \\wedge y \\equiv 0 \\mod 2 \\} \\\\ \\end{array}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">For our concrete instantiations we use  <span class="math">\\mu = 251</span>  bits. We note that the results in Section 4.2 hold for any definition of  <span class="math">\\mathcal{P}</span>  (with the collision constraint on the second component described earlier). Other choices of  <span class="math">\\mu</span>  are also possible if one appropriately changes other parameters in the instantiations.</p>

    <p class="text-gray-300">4.4.1  <span class="math">\\mathsf{ZKCP}_{rrnd\\&amp;amp;prms}</span> . We instantiate  <span class="math">\\mathsf{ZKCP}_{rrnd\\&amp;amp;prms}</span>  (Section 4.2) with a Bulletproof relation described in Appendix in Section C.</p>

    <p class="text-gray-300">4.4.2  <span class="math">\\mathsf{ZKCP}_{\\mathrm{setmem}}^{A}</span> . We instantiate  <span class="math">\\mathsf{ZKCP}_{\\mathrm{setmem}}^{A}</span>  (Section 4.2) through a simplified variant of the (commit-and-prove) SNARK for set membership in [7], described below.</p>

    <p class="text-gray-300">|  ZKCPA setmem.Prove(c0;c0,r,W) → π*  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Parse c0 as c0 := (π,y)  |</p>

    <p class="text-gray-300">|  // Make integer commitment to π  |</p>

    <p class="text-gray-300">|  Sample randomness r'  |</p>

    <p class="text-gray-300">|  cint← gπhγ'  |</p>

    <p class="text-gray-300">|  πmodEq← CPmodEq.Prove(cint, c0;π,r',r)  |</p>

    <p class="text-gray-300">|  πroot← CPA root.Prove(cint;π,r,W)  |</p>

    <p class="text-gray-300">|  return π* := (cint, πmodEq, πroot)  |</p>

    <p class="text-gray-300">The corresponding verifier checks both proofs using  <span class="math">c_{\\mathrm{int}}</span>  and the rest of the public input.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Above we use an integer commitment in the RSA group  <span class="math">\\mathbb{G}_7</span>  using an appropriately sampled element  <span class="math">h_7</span> . The proof system  <span class="math">\\mathrm{CP}_{\\mathrm{modEq}}</span>  roughly shows knowledge of integers  <span class="math">x, r&#x27;</span>  and of  <span class="math">\\pi, r</span>  such that  $x \\equiv \\pi \\mod</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}^\\square</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> ,  </span>c_{\\mathrm{int}} = g_7^\\pi h_7^{r'}<span class="math">  and  </span>c_\\circ = g_\\circ^\\pi h_\\circ^r<span class="math"> . The scheme  </span>\\mathrm{CP}_{\\mathrm{root}}^A<span class="math">  proves knowledge of  </span>W \\in \\mathbb{G}_7<span class="math"> , an integer  </span>x<span class="math">  that opens  </span>c_{\\mathrm{int}}<span class="math">  as above and such that  </span>W<span class="math">  is a  </span>x<span class="math"> -root for the accumulator  </span>A<span class="math">  (this is roughly Acc.VfyMem), that is  </span>W^x = A$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Above we skip some technical details from that are not relevant to understand our construction at a high-level. We however elaborate on one of them that is important in our larger context: the full scheme in [7] crucially relies on  <span class="math">\\pi</span>  being in some correct range. Without this guarantee on range, the construction above does not prove set membership w.r.t.  <span class="math">A</span>  for elements that are not permissible (that is why we have " <span class="math">\\vee c_{\\circ} \\notin \\mathcal{P}^{*}</span>  in  <span class="math">R_{\\mathrm{setmem}}^{A}</span> ). On the other hand, once we prove  <span class="math">c_{\\circ} = (\\pi, y)</span>  is permissible through  <span class="math">\\mathrm{ZKCP}_{\\mathrm{rnd\\&amp;amp;prms}}</span> , we ensure  <span class="math">\\pi</span>  is in range, and our scheme is secure as of the analysis in [7]. For further details and a proof of the following theorem, we refer to Section 4 in [7].</p>

    <p class="text-gray-300">THEOREM 4.3. The construction above is a NIZK for the relation  <span class="math">R_{\\text{setmem}}^A</span>  (Section 4.2) in the Trusted-Accumulator Model for accumulator scheme Acc in Figure 5.</p>

    <p class="text-gray-300">4.4.3 ZKOpen. We instantiate ZKOpen from Section 6 with a Schnorr proof. On public input  <span class="math">c_{\\circ}</span>  (the coin) and a commitment key  <span class="math">\\mathrm{ck}_{\\circ}</span>  for  <span class="math">\\mathbf{C}^{\\square}</span>  containing  <span class="math">f_{\\circ}</span>  and  <span class="math">h_{\\circ}</span> , the schemes proves (in zero-knowledge) knowledge of  <span class="math">(v, r)</span>  such that  <span class="math">c_{\\circ} = f_{\\circ}^{v}h_{\\circ}^{r}</span> . This protocol is very standard and we do not describe it in further details here.</p>

    <p class="text-gray-300">4.4.4 ZKDblRange. We instantiate ZKDblRange with Bulletproofs.</p>

    <p class="text-gray-300">We implemented our instantiation of ZK-1-many in Rust and experimentally evaluate its performance. Our code is open source and available at [2]. The performance of our implementation of ZK-1-many is shown in Figure 7.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5309 B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proving Time</td>

            <td class="px-3 py-2 border-b border-gray-700">460 ms</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Verification Time</td>

            <td class="px-3 py-2 border-b border-gray-700">93 ms</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 7: Concrete performance of ZK-1-many from our Rust implementation. All benchmarking is done on a single core of AMD EPYC 7601 (@ 2.2 GHz).</p>

    <p class="text-gray-300">We estimate the transaction size of  <span class="math">\\mathbb{V}</span>  eksel to be 6261 bytes (breakdown shown in Figure 8), based on: implementation of  <span class="math">\\pi_{1\\text{-many}}</span> , the formula for the size of a Bulletproof (used as  <span class="math">\\pi_{\\text{create}}</span> ) and the size of a generalized Schnorr for two generators used to 'partially open' the coin (used as  <span class="math">\\pi_{\\text{opn}}</span> ). We note that both  <span class="math">\\pi_{1\\text{-many}}</span>  and  <span class="math">\\pi_{\\text{opn}}</span>  can be used as signatures of knowledge.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">π1-many</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">5309 B</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πcreate: Bulletproof with 128 constrains.</td>

            <td class="px-3 py-2 border-b border-gray-700">736 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">πopn: Schnorr proof with 2 generators.</td>

            <td class="px-3 py-2 border-b border-gray-700">128 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">t: Spending tag</td>

            <td class="px-3 py-2 border-b border-gray-700">16 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Enc@(t</td>

            <td class="px-3 py-2 border-b border-gray-700">v</td>

            <td class="px-3 py-2 border-b border-gray-700">r): Elgamal encrypted spending info</td>

            <td class="px-3 py-2 border-b border-gray-700">72 B</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total</td>

            <td class="px-3 py-2 border-b border-gray-700">6261 B</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Here we formally describe our functionality for account-based payments with privacy requirements.</p>

    <p class="text-gray-300">Universal Composability (UC). We formalize our model in the Universal Composability framework by Canetti (see [14] for more details). Recall that, in the UC model, we specify an "ideal functionality" in order to state what a protocol is supposed to do. The functionality accepts input from the parties and computes outputs in a specific way that an adversary by definition cannot modify. We say that a protocol securely implements the functionality if running the protocol is, in a certain well-defined sense, "equivalent" to interacting with the functionality. We denote by  <span class="math">\\diamond</span>  compositions of UC functionalities and protocols e.g.  <span class="math">\\Pi_A\\diamond \\mathcal{F}_B</span>  denotes the protocol A in the B-hybrid model (a protocol for A assuming B an ideal functionality B). We denote by  <span class="math">A\\geq B</span>  that "A implements B", i.e. the exists an efficient simulator  <span class="math">\\mathrm{Sim}_A</span>  st.  <span class="math">A\\stackrel {\\mathrm{def}}{=}\\mathrm{Sim}_A\\diamond B</span>  for any enviroment; throughout this paper we only consider PPT enviroments.</p>

    <p class="text-gray-300">Formal Model. We describe our functionality in Figure 9. See section 3.1 for intuitions about its semantics. In our construction we will make use of an idealized communication  <span class="math">\\mathcal{F}_{Comm}</span>  functionality described in Figure 10.</p>

    <p class="text-gray-300">REMARK 5 (SIMPLIFICATIONS IN  <span class="math">\\mathcal{F}_{Comm}</span> ). In practice the simultaneously delivery in  <span class="math">\\mathcal{F}_{Comm}</span>  is impossible to implement, however we deliberately simplify the functionality since the omitted details in the modelling of the distributed ledger seem unlikely to affect the security of our anonymous transactions and it simplifies explication.</p>

    <p class="text-gray-300">REMARK 6 (IMPLEMENTATION OF  <span class="math">\\mathcal{F}_{Comm}</span> ). In practice the anonymous message delivery (of  <span class="math">M</span> ) in  <span class="math">\\mathcal{F}_{Comm}</span>  can be achieved by having the sender encrypt the message to the receiver using a public-key encryption scheme wherein the correct public key for a ciphertext is indistinguishable from a random public key. The same technique is used in Zerocash. Standard Elgamal encryption is one such scheme. The authenticated broadcast (of  <span class="math">B</span> ) can be achieved by using digital signatures.</p>

    <p class="text-gray-300">The use of port ids in Figure 10 to identify which player sends a message avoids the explicit use of public keys in the constructions, however in practice  <span class="math">\\mathcal{F}_{Comm}</span>  will be instantiated by identifying a peer by its public key and signing the broadcast messages.</p>

    <p class="text-gray-300">Figure 8: Breakdown of estimated transaction (Create and Collect) size in  <span class="math">\\mathbb{V}</span>  eksel.</p>

    <p class="text-gray-300">|  FAnon  |</p>

    <p class="text-gray-300">| --- |</p>

    <p class="text-gray-300">|  Initialize: On input Balance, C on infl: (1) Corrupt the players in C. (2) Set Coins ← [], Events ← []. (3) Store the initial balances Balance. (4) Assert MAX-MONEY ≥ ∑i=1n Balance[i]. Create coin: Input (Create, i, v) on Pj: (1) Assert Balance[j] ≥ v. (2) Set Balance[j] ← Balance[j] - v. (3) If i∉C send (Create, j) on leak. (4) If i ∈ C send (Create, j, i, v) on leak. (5) Receive fresh id on infl. (6) Set Events[id] ← (Create, j, i, v) Collect coin: Input (Collect, id') on Pi: (1) Assert (id', v, j, i) in Coins. (2) Remove (id', v, j, i) from Coins. (3) If j∉C send (Collect, i) on leak. (4) If j ∈ C send (Collect, id', j, i, v) on leak. (5) Receive fresh id on infl. (6) Set Events[id] ← (Collect, j, i, v) Process: Input (Process, id) on infl: (1) If Events[id] = (Create, j, i, v) (a) Output (id, v) on Pi (b) Add (id, v, j, i) to Coins (2) If Events[id] = (Collect, j, i, v) (a) Output Balance[i] ← Balance[i] + v on Pi. (3) Remove Event[id]  |</p>

    <p class="text-gray-300">Figure 9: Ideal functionality for account based anonymous transactions. The functionality enables the environment to learn when an account creates a transaction, but not the link between create/pickup unless the sender is corrupted. If an assertion is violated, the message is ignored and the state of functionality reverts to before receiving the message.</p>

    <p class="text-gray-300">|  FComm  |</p>

    <p class="text-gray-300">| --- |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Initialize: Given C on infl (1) Set msg ← [] (2) Corrupt the players in C Message: Input (Msg, B, M, d) on Pi: (1) If d ∈ C output (Msg, i, B, M, d) on leak. (2) If d∉C output (Msg, i, B,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) on leak. (3) Receive fresh id on infl. (4) Add (id, i, B, M, d) to msg Deliver: Input (Deliver, id) on infl: (1) Assert (id, i, B, M, d) ∈ msg (2) For j ∈ [1, n]: (a) If d = j output (B, M) on Pj (b) If d ≠ j output B on Pj (3) Remove (id, i, B, M, d) from msg</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 10: The above models broadcast and private messages. For simplicity it assumes that every player receives the messages simultaneously and that they have instant "finality".</p>

    <p class="text-gray-300">Formal description of our construction. Here we describe <span class="math">\\Pi_{Anon}\\diamond\\mathcal{F}_{Comm}</span> through the Interface in Figure 4. We do not formally describe the initialization stage but we assume that honest parties receive initial public parameters, ledger for a common initial balance <span class="math">v_{0}</span> and initial private states as described in Setup in Figure 4. The rest of the protocol looks as follows:</p>

    <p class="text-gray-300">Create Coin: On input (Create, <span class="math">j,v</span>) on <span class="math">\\Pi_{Anon}</span>.<span class="math">P_{i}</span> (1) Run (<span class="math">{\\rm st}_{i},\\mathrm{aux}_{\\mathrm{coin}},\\mathrm{tx}_{\\mathrm{create}}</span>) <span class="math">\\leftarrow</span> CreateCoin(<span class="math">{\\rm pp},{\\rm st}_{i},j,v</span>) (2) Broadcast <span class="math">\\mathrm{tx}_{\\mathrm{create}}</span> and send coin privately by outputting (<span class="math">{\\rm Msg},\\mathrm{tx}_{\\mathrm{create}},\\mathrm{aux}_{\\mathrm{coin}},\\mathcal{R}</span>) on <span class="math">\\mathcal{F}_{Comm}</span>.<span class="math">P_{S}</span> Receive Coin: On input (<span class="math">{\\rm Msg},j,\\mathrm{tx}_{\\mathrm{create}},\\mathrm{aux}_{\\mathrm{coin}}</span>) on <span class="math">\\mathcal{F}_{Comm}</span>.<span class="math">P_{i}</span>:</p>

    <p class="text-gray-300">(1) Assert <span class="math">\\mathrm{Vfy}({\\rm pp},{\\rm tx},\\mathcal{L})=1</span> (2) Update <span class="math">\\mathcal{L}\\leftarrow\\mathrm{Process}({\\rm pp},{\\rm tx}_{\\mathrm{create}},\\mathcal{L})</span> (3) Parse <span class="math">\\mathrm{aux}_{\\mathrm{coin}}</span> as <span class="math">(v,t,r_{c})</span> (4) If <span class="math">t\\in\\mathrm{MyTags}</span> return early, o.w. add <span class="math">t</span> to <span class="math">\\mathrm{MyTags}</span>. (5) Sample local <span class="math">id</span> randomly. (6) Store <span class="math">\\mathrm{mycoins}[id]\\leftarrow\\mathrm{aux}_{\\mathrm{coin}}</span> (7) Output <span class="math">(id,v)</span> on <span class="math">P_{i}</span> Collect Coin: On input (Collect, <span class="math">id^{\\prime}</span>) on <span class="math">\\Pi_{Anon}</span>.<span class="math">P_{i}</span>:</p>

    <p class="text-gray-300">(1) Assert <span class="math">\\exists</span> entry <span class="math">\\mathrm{mycoins}[id^{\\prime}]</span> (2) Update <span class="math">({\\rm st}_{i},{\\rm tx}_{\\mathrm{clct}})\\leftarrow\\mathrm{Collect}({\\rm st}_{i},\\mathrm{mycoins}[id^{\\prime}],\\mathcal{L})</span> (3) Remove <span class="math">\\mathrm{mycoins}[id^{\\prime}]</span> (4) Output (<span class="math">{\\rm Msg},{\\rm tx}_{\\mathrm{clct}},\\bot,\\bot</span>) on <span class="math">\\mathcal{F}_{Comm}</span>.<span class="math">P_{\\mathcal{R}}</span> Process Tx: On input (<span class="math">{\\rm Msg},S,\\mathrm{tx}</span>) on <span class="math">\\mathcal{F}_{Comm}</span>.<span class="math">P_{i}</span>:</p>

    <p class="text-gray-300">(1) Assert <span class="math">\\mathrm{Vfy}({\\rm pp},{\\rm tx},\\mathcal{L})=1</span> (2) Update <span class="math">\\mathcal{L}\\leftarrow\\mathrm{Process}({\\rm pp},{\\rm tx},\\mathcal{L})</span></p>

    <p class="text-gray-300">Completeness of the construction above follows by observation; we prove its security in the Appendix in Section B.</p>

    <p class="text-gray-300">This work was partly supported by the Carlsberg Foundation under the Semper Ardens Research Project CF18-112 (BCM) and the Concordium Blockchain Center.</p>

    <h2 id="sec-46" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Monero block size (estimated from several blocks). https://localmonero.co/blocks/tx/6a76504dc8f2e2cc05c533f8155d51710e9d3bee932192c251d4b0a992cf84a1.</li>

      <li>[2] Veksel implementation. https://github.com/matteocam/veksel.</li>

      <li>[3] Zcash parameter generation. https://z.cash/technology/paramgen/.</li>

      <li>[4] Baric, N., and Pritzmann, B. Collision-free accumulators and fail-stop signature schemes without trees. In International conference on the theory and applications of cryptographic techniques (1997), Springer, pp. 480–494.</li>

      <li>[5] Bellare, M., Boldfreva, A., Desai, A., and Pointcheval, D. Key-privacy in public-key encryption. In ASIACRYPT 2001 (Dec. 2001), C. Boyd, Ed., vol. 2248 of LNCS, Springer, Heidelberg, pp. 566–582.</li>

      <li>[6] Ben-Sasson, E., Chiesa, A., Garman, C., Green, M., Miers, I., Tromer, E., and Virea, M. Zerocash: Decentralized anonymous payments from bitcoin. In 2014 IEEE Symposium on Security and Privacy (May 2014), IEEE Computer Society Press, pp. 459–474.</li>

      <li>[7] Benarroch, D., Campanelli, M., Fiore, D., Gurkan, K., and Kolonelos, D. Zero-knowledge proofs for set membership: Efficient, succinct, modular. Cryptology ePrint Archive, Report 2019/1255, 2019. https://eprint.iacr.org/2019/1255.</li>

      <li>[8] Bernstein, D. J., and Lange, T. Faster addition and doubling on elliptic curves. In ASIACRYPT 2007 (Dec. 2007), K. Kurosawa, Ed., vol. 4833 of LNCS, Springer, Heidelberg, pp. 29–50.</li>

      <li>[9] Boneh, D., Bünz, B., and Fisch, B. Batching techniques for accumulators with applications to iops and stateless blockchains. In Annual International Cryptology Conference (2019), Springer, pp. 561–586.</li>

      <li>[10] Buchanan, J., and Handy, S. A survey on iq cryptography. In Public-Key Cryptography and Computational Number Theory (2011), pp. 1–15.</li>

      <li>[11] Bünz, B., Bootle, J., Boneh, D., Poelstra, A., Wuille, P., and Maxwell, G. Bulletproofs: Short proofs for confidential transactions and more. In 2018 IEEE Symposium on Security and Privacy (SP) (2018), IEEE, pp. 315–334.</li>

      <li>[12] Camenisch, J., and Lysyanskaya, A. Dynamic accumulators and application to efficient revocation of anonymous credentials. In Annual International Cryptology Conference (2002), Springer, pp. 61–76.</li>

      <li>[13] Campanelli, M., Fiore, D., and Qureol, A. LegoSNARK: Modular design and composition of succinct zero-knowledge proofs. In ACM CCS 2019 (Nov. 2019), L. Cavallaro, J. Kinder, X. Wang, and J. Katz, Eds., ACM Press, pp. 2075–2092.</li>

      <li>[14] Canetti, R. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS (Oct. 2001), IEEE Computer Society Press, pp. 136–145.</li>

      <li>[15] Chen, M., Hazay, C., Ishai, Y., Kashnikov, Y., Micciancio, D., Riviere, T., Abhi Shelat, Venkitasubramaniam, M., and Wang, R. Diogenes: Lightweight scalable rsa modulus generation with a dishonest majority. Cryptology ePrint Archive, Report 2020/374, 2020. https://eprint.iacr.org/2020/374.</li>

      <li>[16] Damgård, I., Ganesh, C., Khoshakhlagh, H., Orlandi, C., and Smiscalchi, L. Balancing privacy and accountability in blockchain transactions. Cryptology ePrint Archive, Report 2020/1511, 2020. https://eprint.iacr.org/2020/1511.</li>

      <li>[17] Dorson, S., Galbraith, S. D., and Smith, B. Trustless groups of unknown order with hyperelliptic curves. Cryptology ePrint Archive, Report 2020/196, 2020. https://eprint.iacr.org/2020/196.</li>

      <li>[18] Edwards, H. M. A normal form for elliptic curves. Bulletin of the American Mathematical Society 44, 03 (Apr. 2007), 393–423.</li>

      <li>[19] Faizi, P., Meiklejohn, S., Mercer, R., and Orlandi, C. Quisquis: A new design for anonymous cryptocurrencies. In ASIACRYPT 2019, Part I (Dec. 2019), S. D. Galbraith and S. Moriai, Eds., vol. 11921 of LNCS, Springer, Heidelberg, pp. 649–678.</li>

      <li>[20] Goldwasser, S., and Kalai, Y. T. Cryptographic assumptions: A position paper. In TCC 2016-A, Part I (Jan. 2016), E. Kushilevitz and T. Malkin, Eds., vol. 9562 of LNCS, Springer, Heidelberg, pp. 505–522.</li>

      <li>[21] Groth, J. Simulation-sound nizk proofs for a practical language and constant size group signatures. In International Conference on the Theory and Application of Cryptology and Information Security (2006), Springer, pp. 444–459.</li>

      <li>[22] Groth, J. On the size of pairing-based non-interactive arguments. In EUROCRYPT 2016, Part II (May 2016), M. Fischlin and J.-S. Coron, Eds., vol. 9666 of LNCS, Springer, Heidelberg, pp. 305–326.</li>

      <li>[23] Groth, J., and Kohlweiss, M. One-out-of-many proofs: Or how to leak a secret and spend a coin. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (2015), Springer, pp. 253–280.</li>

      <li>[24] Horwood, D., Bowe, S., Horney, T., and Wilcox, N. Zcash protocol specification, version 2020.1.15, 2020.</li>

      <li>[25] Jivantan, A. Lelantus: Towards confidentiality and anonymity of blockchain transactions from standard assumptions. Cryptology ePrint Archive, Report 2019/373, 2019. https://eprint.iacr.org/2019/373.</li>

      <li>[26] Koska, A., Zhao, Z., Miller, A., Qian, Y., Chan, H., Papamanthou, C., Pass, R., Shelat, A., and Shi, E. How to use SNARKs in universally composable protocols. Cryptology ePrint Archive, Report 2015/1093, 2015. http://eprint.iacr.org/2015/1093.</li>

      <li>[27] Lai, R. W. F., Ronge, V., Ruffing, T., Schneider, D., Thyagarajan, S. A. K., and Wang, J. Omniring: Scaling private payments without trusted setup. In ACM CCS 2019 (Nov. 2019), L. Cavallaro, J. Kinder, X. Wang, and J. Katz, Eds., ACM Press, pp. 31–48.</li>

      <li>[28] Lee, J. The security of groups of unknown order based on jacobians of hyperelliptic curves. Cryptology ePrint Archive, Report 2020/289, 2020. https://eprint.iacr.org/2020/289.</li>

      <li>[29] Meiklejohn, S., and Orlandi, C. Privacy-enhancing overlays in bitcoin. In International Conference on Financial Cryptography and Data Security (2015), Springer, pp. 127–141.</li>

      <li>[30] Miers, I., Garman, C., Green, M., and Rubin, A. D. Zerocoin: Anonymous distributed E-cash from Bitcoin. In 2013 IEEE Symposium on Security and Privacy (May 2013), IEEE Computer Society Press, pp. 397–411.</li>

      <li>[31] Reid, F., and Hardigan, M. An analysis of anonymity in the bitcoin system. In Security and privacy in social networks. Springer, 2013, pp. 197–223.</li>

      <li>[32] Yuen, T. H., Sun, S., Liu, J. K., Au, M. H., Esgin, M. F., Zhang, Q., and Gu, D. RingCT 3.0 for blockchain confidential transaction: Shorter size and stronger security. In FC 2020 (Feb. 2020), J. Bonneau and N. Heninger, Eds., vol. 12059 of LNCS, Springer, Heidelberg, pp. 464–483.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">A EXPLICIT ACCOUNT-BASED CONSTRUCTION</p>

    <p class="text-gray-300">For the sake of completeness, we describe a concrete and optimized version of our construction in Section 3. We assume all the instantiations described in Section 4.3. The main differences with Figure 4 are:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Set of coins: Rather than explicitly maintaining <span class="math">S_{\\mathrm{coins}}</span> each party keeps the current (group of unknown order) accumulator <span class="math">A_{\\mathrm{coins}}</span> containing all coins <span class="math">S_{\\mathrm{coins}}</span> and a membership proof of all coins that she possesses (an accumulator of all coins except hers). Hence Collect transactions can be generated in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{mycoins}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time by proving </span>R^{A_{\\mathrm{coins}}}_{1-\\mathrm{many}}<span class="math"> using Corollary 4.1. Similarly Collect transactions can be verified in </span>O(1)$ time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Identities: In Figure 4 the abstract identities of the parties <span class="math">\\mathcal{R} = (\\mathrm{pk}_{\\sigma},\\mathrm{pk}_{e})</span> takes the concrete form of public keys <span class="math">(\\mathrm{pk}_{\\sigma},\\mathrm{pk}_{e})</span> for a strongly unforgable signature scheme (e.g. Schnorr) and IND-CPA + IK-CPA [5] (key-privacy) secure public key encryption <span class="math">\\mathrm{pk}_{e}</span> (e.g. Elgmal) respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathcal{F}_{\\mathrm{Comm}}</span>: To send <span class="math">(\\mathsf{Msg}, B, M, \\mathcal{R})</span> interpret <span class="math">\\mathcal{R} = (\\mathrm{pk}_{\\sigma}^{(\\mathcal{R})}, \\mathrm{pk}_{e}^{(\\mathcal{R})})</span>, encrypt <span class="math">c \\gets \\mathsf{Enc}_1(\\mathrm{pk}_{\\sigma}^{(\\mathcal{R})}, \\mathsf{M})</span>, then produce signature $\\sigma \\gets \\operatorname{Sign}(\\mathrm{pk}_{\\sigma}^{(\\mathcal{S})}, \\mathrm{pk}_{\\sigma}^{(\\mathcal{S})} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c)<span class="math">, broadcast </span>(\\sigma, \\mathrm{pk}_{\\sigma}^{(\\mathcal{S})}, B, c)<span class="math">. Hence in the explicit construction </span>\\mathrm{aux}_{\\mathrm{coin}}<span class="math"> is encrypted with </span>\\mathrm{pk}_{e}^{(\\mathcal{R})}<span class="math"> of the receiver and the ciphertext is broadcast on a public bulletin board (&#x27;blockchain&#x27;) with a signature from the sender </span>\\mathcal{S}<span class="math">. The network checks the signatures </span>\\sigma$ on the transactions.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Compressing $t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}<span class="math">: Since </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt; \\log_2(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> in general, we use a collision resistance function </span>\\mathsf{H} : \\{0,1\\}^{*} \\to \\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> before committing to the second component through </span>\\mathrm{Comm}^{\\square}<span class="math"> i.e. compute </span>\\mathrm{Comm}^{\\square}(v, \\mathsf{H}(t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{R}); r)<span class="math">. Since these fields are revealed during &#x27;collect&#x27; this hash can be recomputed by the verifier and is never proven in zero-knowledge (does not affect the efficiency of the proof schemes). Given the last two items, a coin with value </span>v<span class="math"> and tag </span>t<span class="math"> to recipient </span>\\mathcal{R}<span class="math"> is concretely computed as </span>c \\gets f_{\\circ}^{\\mathrm{tr}} g_{\\circ}^{\\mathrm{H}(t</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{pk}_{\\mathcal{R}})} h_{\\circ}^{r}<span class="math"> where </span>r<span class="math"> is the randomness and </span>\\mathrm{pk}_{\\mathcal{R}}$ is the public key of the recipient;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Permissibility: A sender must produce a permissible coin <span class="math">c</span>, to ensure that <span class="math">c \\in \\mathcal{P}</span> she keep sampling new randomness <span class="math">r</span> until she obtains such a coin (e.g., the <span class="math">\\pi</span> component should be a prime). When validating a transaction, the network checks that <span class="math">c \\in \\mathcal{P}</span> and adds it the accumulator (see Figure 5).</p>

    <p class="text-gray-300">B SECURITY OF OUR CONSTRUCTION</p>

    <p class="text-gray-300">THEOREM B.1 (<span class="math">\\Pi_{Anon} \\diamond \\mathcal{F}_{Comm} \\geq \\mathcal{F}_{Anon}</span>). For the three different NIWI/NIZK arguments in the construction we require:</p>

    <p class="text-gray-300">ZK-1-many: Simulation sound and zero-knowledge.</p>

    <p class="text-gray-300">ZKOpen: Witness indistinguishable.</p>

    <p class="text-gray-300">ZKDblRange: Witness indistinguishable.</p>

    <p class="text-gray-300">Proof. Construct <span class="math">\\operatorname{Sim}_{Anon}</span> as follows: Get initial balances (genesis block) <span class="math">(v_{1},\\ldots ,v_{n})</span>.</p>

    <p class="text-gray-300">Initialize: Input <span class="math">Balance = (v_{1},\\ldots ,v_{n})</span> to <span class="math">\\mathcal{F}_{Anon}</span>. Initialize the empty ledger <span class="math">\\mathcal{L}\\gets \\epsilon</span>.</p>

    <p class="text-gray-300">Create coin (honest sender, honest receiver): Receiving as input (Create, <span class="math">j</span>) on <span class="math">\\mathcal{F}_{Anon}</span>. Leak where <span class="math">j \\notin C</span>. Pick <span class="math">r \\gets \\S \\mathbb{F}</span>, pick</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">t\\gets \\S \\{0,1\\}^{\\lambda}</span>, let <span class="math">v = 0</span>, let <span class="math">i = 0</span>, let $c\\gets \\mathrm{Comm}^{\\square}((v,t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i);r)<span class="math">. Run ZKDblRange on the statement (c, bal&#x27; = bal - c), where bal = </span>\\mathrm{Comm}^{\\square}(v_i;r_i)<span class="math"> or bal = </span>\\mathrm{Comm}^{\\square}(v_i;0)^{16}<span class="math"> using </span>v, v_i, i, t, r, r_i<span class="math"> as the witness, obtain </span>\\pi_{\\mathrm{create}}<span class="math">. Output (Msg, j, (Create, c, </span>\\pi_{\\mathrm{create}}<span class="math">), </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(t,v,r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">) on </span>\\mathcal{F}_{Comm}<span class="math">. Leak (pick random id for </span>\\mathcal{F}_{Anon}$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Collect coin (honest sender, honest receiver): Receiving as input (Collect, i) on <span class="math">\\mathcal{F}_{Anon}</span>. Leak where <span class="math">i \\notin C</span>. Pick <span class="math">r^{<em>} \\gets \\S \\mathbb{F}</span>, pick <span class="math">t \\gets \\S \\{0,1\\}^{\\lambda}</span>, let <span class="math">v = 0</span>, simulate the ZK-1-many proof for the commitment $c^{</em>} \\gets \\mathrm{Comm}^{\\square}((v,t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i);r)<span class="math"> using </span>\\tau<span class="math">, get </span>\\pi_{1\\text{-many}}<span class="math">. Run ZKOpen. Prove with statement </span>(i,t,c_{\\Delta} = c^{*} - \\mathrm{Comm}^{\\square}((0,t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i);0))<span class="math"> and witness </span>(r,v)<span class="math">, get </span>\\pi_{\\mathrm{opn}}<span class="math"> Output (Msg, i, (Collect, </span>c^{*}, t, (\\pi_{1\\text{-many}}, \\pi_{\\mathrm{opn}})), 0<span class="math">) on </span>\\mathcal{F}_{Comm}<span class="math">. Leak (pick random id for </span>\\mathcal{F}_{Anon}$)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Create/collect coin (corrupt sender/receiver): Since the contents of the coin <span class="math">(id&#x27;, j, i, v)</span> is revealed during both Create and Collect, simulation is trivial.</p>

    <p class="text-gray-300">Deliver On input (Deliver, id) on <span class="math">\\mathcal{F}_{Comm}</span>. infl. Lookup id (from <span class="math">\\mathcal{F}_{Comm}</span>) and retrieve the associated broadcast message <span class="math">B</span>. If <span class="math">\\mathrm{Vfy}(\\mathrm{pp}, B, \\mathcal{L}) = \\text{reject ignore the message}</span>. If <span class="math">\\mathrm{Vfy}(\\mathrm{pp}, B, \\mathcal{L}) = \\text{accept, input (Process}, id)</span> on <span class="math">\\mathcal{F}_{Anon}</span>. infl, update the ledger <span class="math">\\mathcal{L} \\gets \\text{Process}(\\mathrm{pp}, B, \\mathcal{L})</span> and set of coins <span class="math">S_{\\text{coins}}</span>.</p>

    <p class="text-gray-300">Note that the simulator only simulates proofs for ZK-1-many, for the other proofs a random statement and witness is sampled, which is intuitively why witness indistinguishability is sufficient. Now formally showing <span class="math">\\operatorname{Sim}_{Anon} \\diamond \\mathcal{F}_{Anon} \\leq \\Pi_{Anon} \\diamond \\mathcal{F}_{Comm}</span> using a sequence of hybrids:</p>

    <p class="text-gray-300">(1) Consider the hybrid <span class="math">\\mathcal{H}^{(\\mathrm{Create})}</span> which extracts <span class="math">(v,i)</span> from <span class="math">\\mathcal{F}_{Anon}</span> during Create (rather than fixing <span class="math">v = 0</span> and <span class="math">i = 0</span>) and creates coins <span class="math">c \\gets \\mathrm{Comm}^{\\square}((t,v,i);r)</span> for honest parties with the real denomination and destination. Observe that <span class="math">\\mathcal{H}^{(\\mathrm{Create},v,i)} = \\mathrm{Sim}_{Anon} \\diamond \\mathcal{F}_{Anon}</span> by the perfect hiding of the commitment and witness indistinguishability of ZKRange.</p>

    <p class="text-gray-300">(2) Consider <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{Sim})}</span>, which additionally extracts <span class="math">(id&#x27;, v, j, i)</span> from <span class="math">\\mathcal{F}_{Anon}</span> during Collect and retrieves the generated tag <span class="math">t</span> and <span class="math">r</span> (created during simulated Create) associated with <span class="math">id&#x27;</span>. Reconstructs the coin <span class="math">c \\gets \\mathrm{Comm}^{\\square}((t, v, i); r)</span> (rather than creating a new randomly generated coin), samples <span class="math">r^<em> \\gets \\S \\mathbb{F}</span>, defines <span class="math">c^</em> \\gets c + \\mathrm{Comm}^{\\square}((0, 0); r^<em>)</span> and simulates ZK-1-many with the statement <span class="math">(c^</em>, S_{\\mathrm{coins}})</span>. Observe that <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{Sim})} = \\mathcal{H}^{(\\mathrm{Create}, v, i)}</span>, by the perfect hiding of C (distribution over statements <span class="math">c^*</span> are the same), note also that the distribution over witnesses and statements for ZKOpen NIWI is unchanged.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(3) Observe that in <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect},\\mathrm{Sim})}</span>, $w = (v,t\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">i,r + r^{<em>})<span class="math"> is a witness for the statement </span>x = (c^{</em>},S_{\\mathrm{coins}})<span class="math">. Define </span>\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect})}<span class="math"> which generates </span>\\pi_{1\\text{-many}}<span class="math"> by running the prover (rather than simulation) with the witness </span>w<span class="math">. Observe that </span>\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect},\\mathrm{Sim})} \\approx \\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect})}$ by simulation indistinguishability and simulation soundness of ZK-1-many.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(4) Consider <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{CRS})}</span> which extends <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect})}</span> by sampling the common reference string for the ZK-1-many NIZK without a simulation trapdoor. Observe <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect})} \\approx \\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{CRS})}</span> by reference string indistinguishability of the ZK-1-many NIZK.</p>

    <p class="text-gray-300">Now use soundness of ZK-1-many, ZKOpen, ZKDblRange to argue that the outputs on <span class="math">\\{\\mathrm{P}_i\\}_{i\\notin C}</span> are indistinguishablity between <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{CRS})}</span> and the real world <span class="math">\\Pi_{\\mathcal{F}_{Anon}}\\diamond \\mathcal{F}_{Comm}</span>: Define <span class="math">Balance_{sim}</span> with the initial entries <span class="math">(v_1,\\dots,v_n)</span>. Maintain a set <span class="math">C = \\{(\\mathrm{c},o,r_{\\mathrm{c}})\\}</span> of created coins computed by extracting from ZKDblRange in every Create broadcast message <span class="math">B</span>:</p>

    <p class="text-gray-300">In Deliver, if <span class="math">B = (\\mathrm{Create},\\mathrm{c},\\pi_{\\mathrm{create}})</span></p>

    <p class="text-gray-300">(1) Extract <span class="math">o_{c} = ((v,t\\parallel j),r_{c})</span> from <span class="math">\\pi_{\\mathrm{create}}</span> (with statement c) (2) Update <span class="math">Balance_{sim}[i] \\gets Balance_{sim}[i] - v</span>. (3) Add <span class="math">(\\mathrm{c},(v,t\\parallel j),r_{\\mathrm{c}})</span> to <span class="math">C</span></p>

    <p class="text-gray-300">The set of coins <span class="math">\\mathbf{c}</span> in <span class="math">C</span> is exactly <span class="math">S_{\\mathrm{coins}}</span>. Additionally maintain a set <span class="math">O = \\{(c,o,r_c)\\}</span> of opened coins computed by extracting from ZK-1-many and ZKOpen in every Collect broadcast message <span class="math">B</span>:</p>

    <p class="text-gray-300">In Deliver, if <span class="math">B = (\\mathrm{Collect},\\mathrm{c}^{*},t,(\\pi_{1\\text{-many}}\\pi_{\\mathrm{opn}}))</span></p>

    <p class="text-gray-300">(1) Extract <span class="math">r^<em></span> from <span class="math">\\pi_{1\\text{-many}}</span> (with the statement <span class="math">c^</em></span> and <span class="math">S_{\\mathrm{coins}}</span>). (2) Extract <span class="math">v</span> and <span class="math">r&#x27;</span> from <span class="math">\\pi_{\\mathrm{opn}}</span> (with the statement <span class="math">c^<em>, c_v, j, t</span>). (3) Compute <span class="math">r_{\\mathrm{c}} = r^{\\prime} - r^{</em>}</span> (4) Recompute <span class="math">c \\gets \\mathrm{Comm}^{\\odot}((v, t \\parallel j), r_c)</span> (5) Define <span class="math">o = (v, t \\parallel j)</span> (6) If <span class="math">(c,o,\\cdot)\\notin C</span>, this violates soundness of <span class="math">\\pi_{1\\text{-many}}</span> or <span class="math">\\pi_{\\mathrm{opn}}</span>: since <span class="math">r^<em></span> is the re-randomization and <span class="math">r&#x27;</span> is the randomness of <span class="math">c^</em></span>, it follows that <span class="math">c</span> is uniquely defined. (7) If <span class="math">(c,o^{\\prime},r_{c}^{\\prime})\\in O</span> for some <span class="math">o^{\\prime},r_{c}^{\\prime}</span> with <span class="math">o^{\\prime}\\neq o</span>, this breaks computational binding of the commitment: stop and output <span class="math">(c,o^{\\prime},o,r_{c},r_{c}^{\\prime})</span> as a collision in the binding game of the commitment scheme C. (8) Update <span class="math">Balance_{sim}[j] \\gets Balance_{sim}[j] + v</span>. (9) Add <span class="math">(c,o,r_c)</span> to <span class="math">O</span></p>

    <p class="text-gray-300">Conclude that every coin <span class="math">c \\in S_{\\mathrm{coins}}</span> can occur at most once in the computation of <span class="math">C</span> and that <span class="math">O \\subseteq C</span>. Construct hybrids:</p>

    <p class="text-gray-300">(1) <span class="math">\\mathcal{H}^{(\\mathrm{Create} + \\mathrm{Collect} + \\mathrm{CRS} + v)}</span>, which on Process of Events <span class="math">[\\text{id}] = (\\text{Create}, j, i, v)</span> outputs <span class="math">(id, v&#x27;)</span> from <span class="math">O</span> on <span class="math">\\mathcal{F}_{\\text{Anon}}</span>. <span class="math">\\mathrm{P}_i</span> rather than <span class="math">(id, v)</span> from the functionality <span class="math">\\mathcal{F}_{\\text{Anon}}</span>. By the previous observation that the committed values claimed <span class="math">O</span> is a subset of <span class="math">O</span> we get that: (a) When the simulator inputs (Process, id) on <span class="math">\\mathcal{F}_{\\text{Anon}}</span> infl it always leads to an output <span class="math">(id,v)</span> on <span class="math">\\mathcal{F}_{\\text{Anon}}</span>. <span class="math">\\mathrm{P}_j</span> (b) By <span class="math">O \\subseteq C</span> and the observation that every <span class="math">(c, (v, t \\parallel j), r_c) \\in C</span> corresponds to a coin <span class="math">(id&#x27;, v, j, i) \\in \\text{Coins}</span> for some <span class="math">j</span>. In conclusion: <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS})} \\lesssim \\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v)}</span> (2) <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v + \\text{Balance})}</span>, which on Process of Events <span class="math">[\\text{id}] = (\\text{Collect}, j, i, v)</span> outputs <span class="math">Balance_{sim}[i]</span> on <span class="math">\\mathcal{F}_{\\text{Anon}}</span>. <span class="math">\\mathrm{P}_i</span> rather than <span class="math">Balance[i]</span> from the functionality <span class="math">\\mathcal{F}_{\\text{Anon}}</span>. Since the balance is just the sum of outputs for the player this follows from <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS})} \\lesssim \\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v)}</span> and by inspection of the 'bookkeeping' done in the functionality and hybrid.</p>

    <p class="text-gray-300">Note that all the ports (input/output) of <span class="math">\\mathcal{F}_{\\text{Anon}}</span> are now completely controlled by the simulator in <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v + \\text{Balance})}</span>. Lastly show that <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v + \\text{Balance})} \\notin \\Pi_{\\text{Anon}} \\diamond \\mathcal{F}_{\\text{Comm}}</span>: the <span class="math">\\mathcal{F}_{\\text{Comm}}</span> functionality ensures that every message to every player is delivered in the same order and simultaneously for all honest</p>

    <p class="text-gray-300">players. Hence the local state of the ledger <span class="math">\\mathcal{L}_i</span> of every honest player <span class="math">P_i</span> is exactly the same at all times. The only distinction between <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v + \\text{Balance})}</span> and <span class="math">\\Pi_{\\text{Anon}} \\diamond \\mathcal{F}_{\\text{Comm}}</span> is that every player maintains its own local ledger state, where hybrid <span class="math">\\mathcal{H}^{(\\text{Create} + \\text{Collect} + \\text{CRS} + v + \\text{Balance})}</span> maintains a single ledger state for simulation.</p>

    <h2 id="sec-47" class="text-2xl font-bold">C BULLETPROOF RELATION FOR <span class="math">\\pi_{\\text{rerand}}</span></h2>

    <p class="text-gray-300">Here we describe how we instantiate <span class="math">\\mathrm{ZKCP}_{\\mathrm{rrnd}\\&amp;amp;\\mathrm{prms}}</span> from Section 4.2. We use Bulletproofs over group <span class="math">\\mathbb{G}^{\\square} = \\mathrm{Curve25519}</span> for a relation (described below) equivalent to <span class="math">R_{\\mathrm{rrnd}\\&amp;amp;\\mathrm{prms}}</span> (section 4.1). Let <span class="math">g_{\\square}, h_{\\circ}</span> from <span class="math">\\mathrm{ck}_{\\circ}</span> and <span class="math">h_{\\circ}</span> from <span class="math">\\mathrm{ck}_{\\circ}</span> (Figure 6). Given randomness <span class="math">r_{\\circ}^{<em>}</span> we parametrize the relation by a fixed group element <span class="math">\\bar{h} = h_{\\circ}^{r_{\\circ}^{</em>}} = (\\bar{\\mathrm{x}},\\bar{\\mathrm{y}})</span>. The family of relations we consider is then:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} R^{\\bar{h}} \\left(c_{\\circ}, c_{\\circ}^{*}; (\\mathrm{x}, \\mathrm{y}), r\\right) \\iff \\\\ c_{\\circ}^{*} = (\\bar{\\mathrm{x}}, \\bar{\\mathrm{y}}) +_{\\mathbb{G}^{\\square}} (\\mathrm{x}, \\mathrm{y}) \\\\ \\wedge c_{\\circ} = g_{\\circ}^{\\mathrm{x}} h_{\\circ}^{r} \\\\ \\wedge (\\mathrm{x}, \\mathrm{y}) \\in \\mathcal{P} \\end{array}</span></div>

    <p class="text-gray-300">Above we use additive notation for <span class="math">\\mathbb{G}^{\\square}</span> to denote explicitly the group operations expressed in the circuit. We consider permissible set <span class="math">\\mathcal{P}</span> from Section 4.3.1 with <span class="math">\\mu = 251</span>. Below we use <span class="math">\\cdot</span> to denote multiplication by constant (linear operation) and <span class="math">\\times</span> to denote multiplication of two free variables. More details follow.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Statement</h2>

    <p class="text-gray-300">The statement is defined by a commitment <span class="math">c_{\\circ} = g_{\\circ}^{\\mathrm{x}}h_{\\circ}^{r}\\in \\mathbb{G}^{\\square}</span> and two field elements <span class="math">(\\mathrm{x}&#x27;,\\mathrm{y}&#x27;)\\in \\mathbb{F}^{\\square}\\times \\mathbb{F}^{\\square}</span> (representing <span class="math">c_{\\circ}^{*}</span>).</p>

    <h2 id="sec-49" class="text-2xl font-bold">Witness</h2>

    <p class="text-gray-300">The witness consists of: a bit-decomposition of the rerandomization scalar, a bitwise decomposition of <span class="math">x</span> (in <span class="math">c_{\\circ}</span>), a bitwise decomposition of <span class="math">y</span>:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(1) A bit-decomposition <span class="math">(r_0, \\ldots, r_{251}) \\in \\{0_{\\mathbb{F}^{\\square}}, 1_{\\mathbb{F}^{\\square}}\\}^{252}</span> of the rerandomization randomness $r = \\sum_{i=0}^{251} r_i \\cdot 2^i \\in \\mathbb{F}_{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}^{\\square}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(2) A bit-decomposition <span class="math">(x_0, \\ldots, x_{249}) \\in \\{0_{\\mathbb{F}^{\\square}}, 1_{\\mathbb{F}^{\\square}}\\}^{250}</span> of the <span class="math">\\mathbf{x}</span> coordinate <span class="math">\\mathbf{x} = \\sum_{i=0}^{249} x_i \\cdot 2^i \\in \\mathbb{F}^{\\square}</span> of the 'input commitment' <span class="math">(\\mathbf{x}, \\mathbf{y}) \\in \\mathcal{P}</span>. (3) A bit-decomposition <span class="math">(y_1, \\ldots, y_{255}) \\in \\{0_{\\mathbb{F}^{\\square}}, 1_{\\mathbb{F}^{\\square}}\\}^{251}</span> of the <span class="math">\\mathbf{y}</span> coordinate <span class="math">\\mathbf{y} = \\sum_{i=1}^{255} y_i \\cdot 2^i \\in \\mathbb{F}^{\\square}</span> of the 'input commitment' <span class="math">(\\mathbf{x}, \\mathbf{y}) \\in \\mathcal{P}</span>.</p>

    <h2 id="sec-50" class="text-2xl font-bold">Relation</h2>

    <p class="text-gray-300">We denote by <span class="math">\\times</span> a product between (linear combinations) of variables and by <span class="math">\\cdot</span> a linear combination of variables. Every line represents a single multiplicative constraint. The relation has a total of 1514 constraints.</p>

    <p class="text-gray-300">Part 1: Permissibility (758 constrains). Check that the point  <span class="math">(\\pi, \\gamma) \\in \\mathcal{P}</span>  (i.e. is 'permissible').</p>

    <p class="text-gray-300"><span class="math">\\forall i \\in [0,251]: 0 = (1 - r_i) \\times r_i</span>  / Bit range check</p>

    <p class="text-gray-300"><span class="math">\\forall i \\in [1, 255]: 0 = (1 - y_i) \\times y_i</span>  / Bit range check</p>

    <p class="text-gray-300"><span class="math">\\forall i \\in [0, 249]: 0 = (1 - x_i) \\times x_i</span>  / Bit range check</p>

    <p class="text-gray-300"><span class="math">\\pi = \\sum_{i=0}^{249} x_i \\cdot 2^i</span>  / Range check of  <span class="math">\\pi</span></p>

    <p class="text-gray-300"><span class="math">\\gamma = \\sum_{i=1}^{255} y_i \\cdot 2^i</span>  / Check  <span class="math">\\gamma</span>  is 'even'</p>

    <p class="text-gray-300"><span class="math">q_{\\pi} = \\pi \\times \\pi</span>  / Curve check</p>

    <p class="text-gray-300"><span class="math">q_{\\gamma} = \\gamma \\times \\gamma</span>  / Curve check</p>

    <p class="text-gray-300"><span class="math">q_{\\pi} \\times q_{\\gamma} = 1 - d \\cdot q_{\\pi} \\times q_{\\gamma}</span>  / Curve check</p>

    <p class="text-gray-300">Part 2: Rerandomization (756 constrains). Rerandomization of  <span class="math">(\\pi, \\gamma) \\in \\mathbb{O}^{\\square}</span>  is done by repeated conditional Edwards addition of  <span class="math">h_{\\circ}^{2^j} \\in \\mathbb{O}^{\\square}</span>  (constants in the circuit). Recall the group law for addition on Edwards curves:</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\pi_ {1}, \\gamma_ {1}\\right) + _ {\\mathbb {O} ^ {\\square}} \\left(\\pi_ {2}, \\gamma_ {2}\\right) = \\left(\\frac {\\pi_ {1} \\gamma_ {2} + \\pi_ {2} \\gamma_ {1}}{1 + d \\pi_ {1} \\pi_ {2} \\gamma_ {1} \\gamma_ {2}}, \\frac {\\gamma_ {1} \\gamma_ {2} - \\pi_ {1} \\pi_ {2}}{1 - d \\pi_ {1} \\pi_ {2} \\gamma_ {1} \\gamma_ {2}}\\right)</span></div>

    <p class="text-gray-300">When  <span class="math">d</span>  is not a square (as in our case), then the formula is complete. The circuit is optimized by borrowing techniques from the Zcash specification ([24], sec. A.3.3.7), employing 'limb-wise addition' with 3-bit limbs. The scalar  <span class="math">r = \\sum_{i=0}^{251} r_i \\cdot 2^i</span>  is split into 84 'windows'  <span class="math">j \\in [0,83)</span>  of 3 bits  <span class="math">(b_0, b_1, b_2) = (r_{3j}, r_{3j+1}, r_{3j+2})</span> , the table of points  <span class="math">T^{(j)} = [(\\mathfrak{u}_i, \\mathfrak{v}_i) = h_\\circ^{2^{3j} + i}]_{i \\in [0,8)}</span>  is precomputed for each window and the circuit does a lookup in  <span class="math">T</span> : verifying  <span class="math">(\\pi^{(j+1)}, \\gamma^{(j+1)}) = T^{(j)}[b^{(j)}] + \\mathbb{O} \\circ (\\pi^{(j)}, \\gamma^{(j)})</span>  where  <span class="math">b^{(j)} = \\sum_{i=0}^{2} 2^i \\cdot b_i = r_{3j} + 2 \\cdot r_{3j+1} + 4 \\cdot r_{3j+2}</span> .</p>

    <p class="text-gray-300">Define the constraint  <span class="math">\\mathcal{R}^{(j)}(b_0, b_1, b_2, \\pi_{in}, \\gamma_{in}, \\pi_{out}, \\gamma_{out})</span> , consisting of two parts, the table lookup (enforcing  <span class="math">(\\mathfrak{u}_b, \\mathfrak{v}_b) = T[b]</span> ) and the point addition (enforcing  <span class="math">(\\pi_{out}, \\gamma_{out}) = (\\mathfrak{u}_b, \\mathfrak{v}_b) + \\mathbb{O} \\circ (\\pi_{in}, \\gamma_{in})</span> ):</p>

    <p class="text-gray-300">Part 2.1: Table Lookup (3 constraints). Let  <span class="math">(\\mathfrak{u}_i, \\mathfrak{v}_i) = h_\\circ^{2^{3j} + i}</span> . Constrain  <span class="math">(\\mathfrak{u}_b, \\mathfrak{v}_b) = T^{(j)}[b]</span>  where  <span class="math">b = \\sum_{i=0}^{2} 2^i \\cdot b_i</span> :</p>

    <p class="text-gray-300"><span class="math">b_{\\&amp;amp;} = b_{1}\\times b_{2}</span></p>

    <p class="text-gray-300"><span class="math">b_{0}\\times (-\\mathfrak{u}_{0}\\cdot b_{\\&amp;amp;} + \\mathfrak{u}_{0}\\cdot b_{2} + \\mathfrak{u}_{0}\\cdot b_{1} - \\mathfrak{u}_{0} + \\mathfrak{u}_{2}\\cdot b_{\\&amp;amp;}</span></p>

    <p class="text-gray-300"><span class="math">-\\mathfrak{u}_2\\cdot b_1 + \\mathfrak{u}_4\\cdot b_\\&amp;amp; -\\mathfrak{u}_4\\cdot b_2 - \\mathfrak{u}_6\\cdot b_\\&amp;amp;</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{u}_1\\cdot b_\\&amp;amp; -\\mathfrak{u}_1\\cdot b_2 - \\mathfrak{u}_1\\cdot b_1 + \\mathfrak{u}_1 - \\mathfrak{u}_3\\cdot s_\\&amp;amp;</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{u}_3\\cdot b_1 - \\mathfrak{u}_5\\cdot b_\\&amp;amp; +\\mathfrak{u}_5\\cdot b_2 + \\mathfrak{u}_7\\cdot b_\\&amp;amp; =</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_b - \\mathfrak{u}_0\\cdot b_\\&amp;amp; +\\mathfrak{u}_0\\cdot \\mathfrak{u}_2 + \\mathfrak{u}_0\\cdot b_1 - \\mathfrak{u}_0 + \\mathfrak{u}_2\\cdot b_\\&amp;amp;</span></p>

    <p class="text-gray-300"><span class="math">-\\mathfrak{u}_2\\cdot b_1 + \\mathfrak{u}_4\\cdot b_\\&amp;amp; -\\mathfrak{u}_4\\cdot b_2 - \\mathfrak{u}_6\\cdot b_\\&amp;amp;</span></p>

    <p class="text-gray-300"><span class="math">b_{0}\\times (-\\nabla_{0}\\cdot b_{\\&amp;amp;} + \\nabla_{0}\\cdot b_{2} + \\nabla_{0}\\cdot b_{1} - \\nabla_{0} + \\nabla_{2}\\cdot b_{\\&amp;amp;}</span></p>

    <p class="text-gray-300"><span class="math">-\\nabla_{2}\\cdot b_{1} + \\nabla_{4}\\cdot b_{\\&amp;amp;} - \\nabla_{4}\\cdot b_{2} - \\nabla_{6}\\cdot b_{\\&amp;amp;}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\nabla_{1}\\cdot b_{\\&amp;amp;} - \\nabla_{1}\\cdot b_{2} - \\nabla_{1}\\cdot b_{1} + \\nabla_{1} - \\nabla_{3}\\cdot s_{\\&amp;amp;}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\nabla_3\\cdot b_1 - \\nabla_5\\cdot b_\\&amp;amp; +\\nabla_5\\cdot b_2 + \\nabla_7\\cdot b_\\&amp;amp;) =</span></li>

    </ul>

    <p class="text-gray-300"><span class="math">\\nabla_{b} - \\nabla_{0}\\cdot b_{\\&amp;amp;} + \\nabla_{0}\\cdot \\nabla_{2} + \\nabla_{0}\\cdot b_{1} - \\nabla_{0} + \\nabla_{2}\\cdot b_{\\&amp;amp;}</span></p>

    <p class="text-gray-300"><span class="math">-\\nabla_{2}\\cdot b_{1} + \\nabla_{4}\\cdot b_{\\&amp;amp;} - \\nabla_{4}\\cdot b_{2} - \\nabla_{6}\\cdot b_{\\&amp;amp;}</span></p>

    <p class="text-gray-300">Part 2.2: Point Addition (6 constraints). Constrain</p>

    <p class="text-gray-300"><span class="math">(\\pi_{out}, \\gamma_{out}) = (\\mathfrak{u}_b, \\mathfrak{v}_b) + \\mathbb{O} \\circ (\\pi_{in}, \\gamma_{in})</span> :</p>

    <p class="text-gray-300"><span class="math">(\\pi_{in} + \\gamma_{in})\\times (\\nabla_{b} - \\mathfrak{u}_{b}) = T</span></p>

    <p class="text-gray-300"><span class="math">\\pi_{in}\\times \\nabla_{b} = A</span></p>

    <p class="text-gray-300"><span class="math">\\gamma_{in}\\times \\mathfrak{u}_b = B</span></p>

    <p class="text-gray-300"><span class="math">(d \\cdot A) \\times B = C</span></p>

    <p class="text-gray-300"><span class="math">(1 + C)\\times \\pi_{out} = (A + B)</span></p>

    <p class="text-gray-300"><span class="math">(1 - C)\\times \\gamma_{out} = (T - A + B)</span></p>

    <p class="text-gray-300">Where  <span class="math">T, A, B, C, \\mathfrak{u}_b, \\mathfrak{v}_b, b_\\&amp;amp;</span>  are otherwise free 'intermediate' variables, local to  <span class="math">\\mathcal{R}^{(j)}</span>  (not used anywhere else).</p>

    <p class="text-gray-300">Part 2.3: Constrain windows (84 × 9 constraints) Constrain every 3-bit window: define  <span class="math">\\pi^{(0)} = \\pi</span> ,  <span class="math">\\gamma^{(0)} = \\gamma</span> ,  <span class="math">\\pi^{(84)} = \\pi&#x27;</span> ,  <span class="math">\\gamma^{(84)} = \\gamma&#x27;</span>  and add the 84 relations  <span class="math">\\forall j \\in [0,84): \\mathcal{R}_j(r_{3j}, r_{3j+1}, r_{3j+2}, \\pi^{(j)}, \\gamma^{(j)}, \\pi^{(j+1)}, \\gamma^{(j+1)})</span></p>

    <p class="text-gray-300">Our construction can be adapted to the UTXO setting obtaining stronger unlinkability properties: rather than having one  <span class="math">\\pi_{1\\text{-many}}</span>  proof every transaction would reference two previous coins[17] and create two new coins. In a UTXO instantiation the  <span class="math">\\pi_{\\text{create}}</span>  and  <span class="math">\\pi_{\\text{opn}}</span>  can be combined into a single Bulletproof. The two  <span class="math">\\pi_{1\\text{-many}}</span>  proofs can be optimized as well: the  <span class="math">\\pi_{\\text{rerand}}</span>  can be extended to rerandomize two commitments in parallel, the two  <span class="math">\\pi_{\\text{modEq}}</span>  proofs can be combined to check congruency of a random linear combination. We estimate the size of such a construction to be  <span class="math">\\approx 10</span>  KB.</p>`;
---

<BaseLayout title="Veksel: Simple, Efficient, Anonymous Payments with Large Ano... (2021/327)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/327
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
