---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/161';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Improvement of Thériault Algorithm of Index Calculus for Jacobian of Hyperelliptic Curves of Small Genus';
const AUTHORS_HTML = 'Koh-ichi Nagao;\\*';

const CONTENT = `    <p class="text-gray-300">Koh-ichi Nagao;*
Dept. of Engineering, Kanto-Gakuin Univ.</p>

    <p class="text-gray-300">May 20, 2004</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Gaudry present a variation of index calculus attack for solving the DLP in the Jacobian of hyperelliptic curves. Harley and Thérialut improve these kind of algorithm. Here, we will present a variation of these kind of algorithm, which is faster than previous ones.</p>

    <p class="text-gray-300">Keywords Index calculus attack, Jacobian, Hyperelliptic curve, DLP,</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">1 Introduction</h3>

    <p class="text-gray-300">Gaudry [3] first present a variation of index calculus attack for hyperelliptic curves that could solve the DLP on the Jacobian of an hyperelliptic curve of small genus. Later, Harley(cf. [2]) and Thériault [1] improve this algorithm. In [1], these algorithms work in time  <span class="math">O(q^{2-\\frac{2}{g+1}+\\epsilon})</span> , and  <span class="math">O(q^{2-\\frac{4}{2g+1}+\\epsilon})</span>  respectively. Thériault's algorithm uses the almost-smooth divisor  <span class="math">D=\\sum D(P_i)</span>  that all but one of the  <span class="math">P_i</span> 's are in the set B called factor base. This technique was often used in the number field sieve factorization algorithm, which uses the almost-smooth integer  <span class="math">n=\\prod p_i</span> , that all but one of the  <span class="math">p_i</span> 's are in the factor base B, which is the set of small primes. In factorization algorithm, the cost of factorizing integer is larger than that of primary testing. So, the cost of factorizing almost-smooth integer is larger than that of normal integer of the same size, and the number that  <span class="math">p_i \\not\\in B</span>  must be one. However, for the index calculus for the Jacobian of curves, we first compute the point of Jacobian and later consult whether it is almost smooth or not. So that, the new algorithm that use the 2-almost smooth divisors, that all but 2 of the  <span class="math">P_i</span> 's are in the set B, is useful. For example, the almost smooth divisor of the form  <span class="math">v_1 = \\sum</span>  terms of  <span class="math">B + D(P_1)</span> , and the 2-almost smooth divisors of the form  <span class="math">v_2 = \\sum</span>  terms of  <span class="math">B + D(P_1) + D(P_2)</span> ,</p>

    <p class="text-gray-300">&lt;sup&gt;*&lt;/sup&gt;nagao@kanto-gakuin.ac.jp</p>

    <p class="text-gray-300"><span class="math">v_3=\\sum</span>  terms of  <span class="math">B+D(P_2)+D(P_3)</span>  are given,  <span class="math">v_1-v_2=\\sum</span>  terms of  <span class="math">B-D(P_2), \\ v_1-v_2+v_3=\\sum</span>  terms of  <span class="math">B+D(P_3)</span>  are other almost smooth divisors. So, we can get much more almost smooth divisors from gathering 2-almost smooth divisors. From this improvement, we get an attack of a running time of  <span class="math">O(q^{2-\\frac{2}{g}+\\epsilon})</span> .</p>

    <p class="text-gray-300">Let C be a hyperelliptic curve of genus g over  <span class="math">\\mathbb{F}_q</span>  of the form  <span class="math">y^2+h(x)y=f(x)</span>  with  <span class="math">\\deg f=2g+1</span>  and  <span class="math">\\deg h\\leq g</span> .</p>

    <p class="text-gray-300">Notation 1. Use  <span class="math">J_q</span>  for  <span class="math">\\mathbf{Jac}_C(\\mathbb{F}_q)</span> .</p>

    <p class="text-gray-300">Further, we will assume that  <span class="math">|J_q|</span>  is odd prime number, for simplicity.</p>

    <p class="text-gray-300"><strong>Definition 1.</strong> Given  <span class="math">D_1, D_2 \\in J_q</span>  such that  <span class="math">D_2 \\in D_1 &gt; DLP</span>  for  <span class="math">(D_1, D_2)</span>  on  <span class="math">J_q</span>  is computing  <span class="math">\\lambda</span>  such that  <span class="math">D_2 = \\lambda D_1</span> .</p>

    <p class="text-gray-300">For an element P = (x, y) in  <span class="math">C(\\bar{\\mathbb{F}}_q)</span> , put -P := (x, -h(x) - y).</p>

    <p class="text-gray-300"><strong>Lemma 1.</strong>  <span class="math">C(\\mathbb{F}_q)</span>  is written by the union of disjoint sets  <span class="math">\\mathcal{P} \\cup -\\mathcal{P} \\cup \\{\\infty\\}</span> , where  <span class="math">\\mathcal{P} := \\{-P | P \\in \\mathcal{P}\\}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Since  <span class="math">|J_q|</span>  is odd prime, we have  <span class="math">2 / |J_q|</span>  and there are no point  <span class="math">P \\in C(\\mathbb{F}_q)</span>  such that P = -P.</p>

    <p class="text-gray-300">Further, we will fix  <span class="math">\\mathcal{P}</span> .</p>

    <p class="text-gray-300">Point of  <span class="math">\\mathbf{Jac}_C</span>  can be represented uniquely by the reduced divisor of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{k} n_i P_i - \\sum_{i=1}^{k} n_i \\infty, \\quad P_i \\in C(\\bar{\\mathbb{F}}_q), \\quad P_i \\neq -P_j \\text{ for } i \\neq j</span>$</p>

    <p class="text-gray-300">with  <span class="math">n_i \\geq 0</span>  and  <span class="math">\\sum n_i \\leq g</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.</strong> The reduced divisor of a point of Jacobian  <span class="math">J_q</span>  is written by the elements of  <span class="math">C(\\mathbb{F}_q)</span>  i.e.</p>

    <p class="text-gray-300"><span class="math">$\\sum_{i=1}^{k} n_i P_i - \\sum_{i=1}^{k} n_i \\infty, \\quad P_i \\in C(\\mathbb{F}_q).</span>$</p>

    <p class="text-gray-300">Then the point is said to be potentially smooth point.</p>

    <p class="text-gray-300">Let  <span class="math">D(P) := P - \\infty</span> . Note that  <span class="math">P + (-P) \\sim 2\\infty</span> . From lemma 1, potentially smooth point v of  <span class="math">J_q</span>  can be represented of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{P \\in \\mathcal{P}} n_P^{(v)} D(P)</span>$</p>

    <p class="text-gray-300">with  <span class="math">n_P^{(v)} \\in \\mathbb{Z}</span>  and  <span class="math">\\sum_{P \\in \\mathcal{P}} |n_P^{(v)}| \\leq g</span> . Further, we will use this representation to potentially smooth points.</p>

    <p class="text-gray-300"><strong>Definition 3.</strong> A subset B of  <span class="math">\\mathcal{P}</span>  used to define smoothness is called factor base.</p>

    <p class="text-gray-300"><strong>Definition 4.</strong> A point  <span class="math">P \\in \\mathcal{P} \\backslash B</span>  is called large prime.</p>

    <p class="text-gray-300"><strong>Definition 5.</strong> A divisor v of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{P \\in B} n_P^{(v)} D(P)</span>$</p>

    <p class="text-gray-300">is called smooth divisor.</p>

    <p class="text-gray-300"><strong>Definition 6.</strong> A divisor v of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{P \\in B} n_P^{(v)} D(P) + n_{P&#x27;}^{(v)} P&#x27;,</span>$</p>

    <p class="text-gray-300">where P' is a large prime, is called 1-almost smooth divisor or almost smooth divisor.</p>

    <p class="text-gray-300"><strong>Definition 7.</strong> A divisor v of the form</p>

    <p class="text-gray-300"><span class="math">$\\sum_{P \\in B} n_P^{(v)} D(P) + n_{P&#x27;}^{(v)} P&#x27; + n_{P&#x27;&#x27;}^{(v)} P&#x27;&#x27;,</span>$</p>

    <p class="text-gray-300">where P', P'' are large primes, is called 2-almost smooth divisor.</p>

    <p class="text-gray-300"><strong>Definition 8.</strong> An element  <span class="math">J \\in J_q</span>  is called c point, if the reduced divisor representing J is smooth (resp. almost smooth, resp. 2-almost smooth) divisor.</p>

    <p class="text-gray-300">Further, we will consider the coefficients  <span class="math">n_P</span>  of a smooth (resp. almost smooth, resp. 2-almost smooth) divisor modulo  <span class="math">|J_q|</span> . For a smooth (resp. almost smooth, resp. 2-almost smooth) divisor v, put</p>

    <p class="text-gray-300"><span class="math">$l(v) := \\#\\{P \\in B | n_P^{(v)} \\neq 0\\}.</span>$</p>

    <p class="text-gray-300"><strong>Lemma 2.</strong> Let  <span class="math">v_1, v_2</span>  be smooth (resp. almost smooth, resp. 2-almost smooth) divisors and let  <span class="math">r_1, r_2</span>  be integers modulo  <span class="math">|J_q|</span> . Then the cost for computing  <span class="math">r_1v_1 + r_2v_2</span>  is  <span class="math">O(g^2(\\log q)^2(l(v_1) + l(v_2))</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> It requires  <span class="math">l(v_1) + l(v_2)</span> -time products and additions modulo  <span class="math">|J_q|</span> . Note that  <span class="math">|J_q| \\doteq q^g</span> . Since the cost of one elementary operation modulo  <span class="math">|J_q|</span>  is  <span class="math">\\log |J_q| = (g \\log q)^2</span> , we have this estimation.  <span class="math">\\square</span></p>

    <p class="text-gray-300">In this section, we present the outline of the proposed algorithm. Let k be a real number satisfying 0 &lt; k &lt; 1/2g. Further in this paper, we will use k as a parameter of this algorithm. Put</p>

    <p class="text-gray-300"><span class="math">$r := r(k) = \\frac{g - 1 + k}{g}.</span>$</p>

    <p class="text-gray-300">We will fix a set of factor base B with  <span class="math">|B| = q^r</span> .</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">Lemma 3.</h3>

    <p class="text-gray-300"><span class="math">$2r &gt; 1 + k &gt; 1 &gt; \\frac{1+r}{2} = \\frac{2g+k-1}{2g} &gt; \\frac{(g-1)+(g+1)k}{g}.</span>$</p>

    <p class="text-gray-300">Proof. trivial.</p>

    <p class="text-gray-300">The whole algorithm consists of the following 7 parts.</p>

    <p class="text-gray-300">Input  <span class="math">C/\\mathbb{F}_q</span>  hyper elliptic curve of small genus  <span class="math">g, D_1, D_2 \\in J_q</span>  such that  <span class="math">D_2 \\in &lt; D_1 &gt; .</span> Output Integer  <span class="math">\\lambda</span>  modulo  <span class="math">|J_q|</span>  such that  <span class="math">D_2 = \\lambda D_1</span> .</p>

    <p class="text-gray-300">1 Computing all points of  <span class="math">C(\\mathbb{F}_q)</span>  and making  <span class="math">\\mathcal{P}</span>  and fix  <span class="math">B \\subset \\mathcal{P}</span>  with  <span class="math">|B| = q^T</span> .</p>

    <p class="text-gray-300">2 Gathering 2-almost smooth divisors and almost smooth divisors</p>

    <p class="text-gray-300">Computing a set  <span class="math">V_2</span>  of 2-almost smooth points and a set  <span class="math">V_1</span>  of almost smooth points of  <span class="math">J_q</span> , of the form  <span class="math">\\alpha D_1 + \\beta D_2</span>  with  <span class="math">|V_1| &gt; 2q^{\\frac{(g-1)+(g+1)k}{g}}</span>  and  <span class="math">|V_2| &gt; q^{1+k}</span> .</p>

    <p class="text-gray-300"><strong>3</strong> Computing a set of almost smooth divisor  <span class="math">H_m</span>  with  <span class="math">|H_m| &gt; q^{(1+r)/2}</span> .</p>

    <p class="text-gray-300">4 Computing a set of smooth divisor H with  <span class="math">|H| &gt; q^r</span> .</p>

    <p class="text-gray-300"><strong>5</strong> Solving linear algebra of the size  <span class="math">q^r \\times q^r</span>  Computing integers  <span class="math">\\{r_h\\}_{h\\in H}</span>  modulo  <span class="math">|J_q|</span> , satisfying  <span class="math">\\sum_{h\\in H} r_h h \\equiv 0</span>  mod</p>

    <p class="text-gray-300"><span class="math">|J_q|</span> . 6 Computing integers  <span class="math">\\{s_v\\}_{v\\in V_1\\cup V_2}</span>  modulo  <span class="math">|J_q|</span> , satisfying  <span class="math">\\sum_{v\\in V_1\\cup V_2} s_v v \\equiv</span></p>

    <p class="text-gray-300"><strong>7</strong> Computing  <span class="math">\\lambda</span> .</p>

    <pre><code class="language-text">Input: C/\\mathbb{F}_q curve of genus g, D_1, D_2 \\in \\mathbf{Jac}_C(\\mathbb{F}_q)

Output: V_1 a set of almost smooth divisors, V_2 a set of 2-almost smooth divisors such that |A_2| &gt; q^{1+k}, |V_1| &gt; 2q^{\\frac{(g-1)+(g+1)k}{g}}, Integers \\{(\\alpha_v, \\beta_v)\\}_{v \\in V_1 \\cup V_2} such that v = \\alpha_v D_1 + \\beta_v D_2

1: V_1 \\leftarrow \\{\\}, V_2 \\leftarrow \\{\\}

2: repeat
   3:
                 Let \\alpha, \\beta be random numbers modulo |J_q|
   4:
                 Compute v = \\alpha J_1 + \\beta J_2
                 if v is almost smooth then
                       V_1 \\leftarrow V_1 \\cup \\{v\\}
(\\alpha_v, \\beta_v) \\leftarrow (\\alpha, \\beta)
   7:
                 end if
   8:
                 if v is 2-almost smooth then
                       V_2 \\leftarrow V_2 \\cup \\{v\\}
(\\alpha_v, \\beta_v) \\leftarrow (\\alpha, \\beta)
 10:
 11:
                 end if
 12:
13: until |A_2| &gt; q^{1+k} and |V_1| &gt; 2q^{\\frac{(g-1)+(g+1)k}{g}}
14: return V_1, V_2, \\{(\\alpha_v, \\beta_v)\\}_{v \\in V_1 \\cup V_2}
</code></pre>

    <p class="text-gray-300"><strong>Lemma 4.</strong> The probability that a point in  <span class="math">J_q</span>  is almost smooth is</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{(g-1)!}q^{(-1+r)(g-1)}</span>$</p>

    <p class="text-gray-300">and the probability that a point is 2-almost smooth is</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2(g-2)!}q^{(-1+r)(g-2)}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We can get above lemma similarly from proposition 3,4,5 in [1]. For example, the probability of 2-almost smooth points is roughly estimated by</p>

    <p class="text-gray-300"><span class="math">$\\frac{(2|B|)^{g-2} \\, (2|\\mathcal{P} \\backslash B|)^2}{2!(g-2)!} \\div |J_q| \\doteq \\frac{(q^r)^{g-2} \\, q^2}{2!(g-2)!q^g} = \\frac{1}{2(g-2)!} q^{(-1+r)(g-2)}.</span>$</p>

    <p class="text-gray-300">From this lemma, the number of the loops that  <span class="math">|V_2| &gt; q^{1+k}</span>  is estimated by</p>

    <p class="text-gray-300"><span class="math">$q^{(1+k)} \\cdot 2(g-2)! q^{(1-r)(g-2)} = 2(g-2)! q^{2r},</span>$</p>

    <p class="text-gray-300">and the number of the loops that  <span class="math">|V_1| &gt; 2q^{\\frac{(g-1)+(g+1)k}{g}}</span>  is estimated by</p>

    <p class="text-gray-300"><span class="math">$2q^{\\frac{(g-1)+(g+1)k}{g}} \\cdot (g-1)!q^{(1-r)(g-1)} = 2(g-1)!q^{2r}.</span>$</p>

    <p class="text-gray-300">Since the cost of computing Jacobian  <span class="math">v = \\alpha D_1 + \\beta D_2</span>  is  <span class="math">O(g^2(\\log q)^2)</span>  and the cost of judging whether v is potentially smooth or not is  <span class="math">O(g^2(\\log q)^3)</span> , the total cost of this part is estimated by</p>

    <p class="text-gray-300"><span class="math">$O(g^2(g-1)!(\\log q)^3q^{2r}).</span>$</p>

    <p class="text-gray-300">Here, we will estimate the required storage. Note that the bit-length of one relative smooth point is  <span class="math">2g \\log q</span> . So, the storage for  <span class="math">V_1</span> , the set of almost smooth divisors, is  <span class="math">O(g \\log q \\, q^{\\frac{(g-1)+(g+1)k}{g}})</span>  and the storage for  <span class="math">V_2</span> , the set of 2-almost smooth divisors, is  <span class="math">O(g \\log q \\, q^{(1+k)})</span> . From lemma 3, we have  <span class="math">g \\log q \\, q^{(1+k)} &gt;&gt; g \\log q \\, q^{\\frac{(g-1)+(g+1)k}{g}}</span> . So the total required storage can be estimated by</p>

    <p class="text-gray-300"><span class="math">$O(g \\log q q^{(1+k)}).</span>$</p>

    <p class="text-gray-300">Let E be a set of smooth divisors, and let F be a set of 2-almost smooth divisors or a set of smooth divisors. Note that element  <span class="math">e \\in E</span>  and  <span class="math">f \\in F</span>  are written by</p>

    <p class="text-gray-300"><span class="math">$e = \\sum_{P \\in B} n_P^{(e)} P + n_{P_1}^{(e)} P_1,</span>$</p>

    <p class="text-gray-300"><span class="math">$f = \\sum_{P \\in B} n_P^{(f)} P + n_{P_2}^{(f)} P_2(+n_{P_3}^{(f)} P_3).</span>$</p>

    <p class="text-gray-300">Put  <span class="math">\\sup(e) := \\{P_1\\}</span>  and  <span class="math">\\sup(f) := \\{P_2, (P_3)\\}</span> . When  <span class="math">P \\in \\sup(e) \\cap \\sup(f)</span> , put</p>

    <p class="text-gray-300"><span class="math">$\\phi(e, f, P) := n_p^{(f)} e - n_p^{(e)} f.</span>$</p>

    <p class="text-gray-300">Trivially,  <span class="math">\\phi(e,f,P)</span>  is almost smooth divisor, if F is a set of 2-almost smooth divisors and  <span class="math">\\phi(e,f,P)</span>  is smooth divisor, if F is a set of almost smooth divisors and e is not of the form constant times f.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Definition 9.</h3>

    <p class="text-gray-300"><span class="math">$e \\heartsuit f := \\begin{cases} \\phi(e, f, P) &amp; \\textit{if } P \\in \\mathbf{sup}(a) \\cap \\mathbf{sup}(b) \\textit{ and } e \\neq \\textit{Const} \\times f \\\\ \\emptyset &amp; \\textit{otherwise}. \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$E \\heartsuit F := \\bigcup_{e \\in E, f \\in F} e \\heartsuit f.</span>$</p>

    <p class="text-gray-300"><strong>Lemma 5.</strong>  <span class="math">E \\heartsuit F</span>  is a set of almost smooth (resp. smooth) divisors, if F is a set of 2-almost smooth (resp. almost smooth) divisors.</p>

    <p class="text-gray-300">We will estimate the size of  <span class="math">E \\heartsuit F</span> .</p>

    <p class="text-gray-300"><strong>Lemma 6.</strong> The size of  <span class="math">E \\heartsuit F</span>  is estimated by</p>

    <p class="text-gray-300"><span class="math">$|E \\heartsuit F| = \\begin{cases} |E||F|/q &amp; \\textit{if } F \\textit{ is 2-almost smooth} \\\\ \\frac{1}{2}|E||F|/q &amp; \\textit{if } F \\textit{ is almost smooth} \\end{cases}</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let  <span class="math">e \\in E</span> ,  <span class="math">f \\in F</span>  be randomly chosen elements. Put  <span class="math">P := \\sup(e)</span> . if F is a set of 2-almost smooth divisors (resp. almost smooth divisors), the probability that  <span class="math">P \\in \\sup(f)</span>  is  <span class="math">\\frac{2}{|\\mathcal{P} \\setminus B|} \\doteq \\frac{1}{q}</span>  (resp.  <span class="math">\\frac{1}{|\\mathcal{P} \\setminus B|} \\doteq \\frac{1}{2q}</span> ), and the size is estimated by  <span class="math">\\frac{1}{q} \\times |E||F|(resp.\\frac{1}{2q} \\times |E||F|)</span> .</p>

    <p class="text-gray-300">In order to compute  <span class="math">E \\heartsuit F</span> , we use this algorithm.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">Algorithm 2 Heartsuit operator</h3>

    <pre><code class="language-text">Input: E, F
Output: E \\heartsuit F
 1: set \\mathcal{P}\\backslash B = \\{R_1, R_2, ..., R_{|\\mathcal{P}\\backslash B|}\\}
 2: for i = 1, 2, ..., |\\mathcal{P} \\setminus B| do
 3: \\quad st[i] \\leftarrow \\{\\}
 4: od
 5: for all e \\in E do
        P = \\sup(e)
 6:
        Compute i s.t. P = R_i
        st[i] \\leftarrow st[i] \\cup \\{e\\}
 8:
 9: od
10: V \\leftarrow \\{\\}
11: for all f \\in F do
        for all P \\in \\sup(f) do
12:
           Compute i s.t. P = R_i
13.
           if st[i] \\neq \\emptyset then
14:
              for all e \\in st[i] s.t. e \\neq Const \\times f do
15:
                 V \\leftarrow V \\cup \\{\\phi(e, f, P)\\}
16:
17:
              od
           end if
18:
19:
        od
20: od
21: return H
</code></pre>

    <p class="text-gray-300">We will estimate the cost and the storage for computing  <span class="math">E \\heartsuit F</span> .</p>

    <p class="text-gray-300"><strong>Lemma 7.</strong> Put  <span class="math">c_1 := \\max\\{l(e)|e \\in E\\}</span>  and  <span class="math">c_2 := \\max\\{l(f)|f \\in F\\}</span> . Assume that |E| &lt;&lt; q. Then the cost of computing  <span class="math">E \\heartsuit F</span>  is</p>

    <p class="text-gray-300"><span class="math">$O(c_1(\\log q)^2|E|) + O((\\log q)^2|F|) + O((c_1 + c_2)(\\log q)^2|E||F|/q)</span>$</p>

    <p class="text-gray-300">. and the required storage is</p>

    <p class="text-gray-300"><span class="math">$O(c_1 \\log q|E|) + O((c_1 + c_2) \\log q|E||F|/q).</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> The required storage for st[i] is  <span class="math">O(c_1 \\log q |E|)</span>  and the required storage for V is  <span class="math">O((c_1 + c_2) \\log q |E||F|/q)</span> , since  <span class="math">|V| \\doteq |E||F|/q</span>  and  <span class="math">\\max\\{l(v)|v \\in V\\} = c_1 + c_2</span>  from lemma 2.</p>

    <p class="text-gray-300">Note that the cost of the routine &quot;Computing index i&quot; is  <span class="math">\\log q \\log |\\mathcal{P} \\setminus B| = O((\\log q)^2)</span> . Also note that  <span class="math">|E \\heartsuit F| = O(|E||F|/q)</span>  and remark that the probability of  <span class="math">st[i] \\neq \\emptyset</span>  is very small,  <span class="math">\\operatorname{since}|E| &lt;&lt; q</span> . Thus, we see that the cost of the 1st loop is  <span class="math">O(c_1(\\log q)^2|E|)</span> , the cost of the part &quot;Computing index i&quot; of the 2nd loop is  <span class="math">O((\\log q)^2|F|)</span> , and the cost of the part &quot;Computing the elements of V&quot; of the 2nd loop is  <span class="math">O((c_1 + c_2)(\\log q)^2|E||F|/q)</span>  from lemma 2.</p>

    <p class="text-gray-300">In this section, we will construct  <span class="math">H_m</span>  a set of almost smooth divisors  <span class="math">|H_m| &gt; 2q^{(1+r)/2}</span> .</p>

    <p class="text-gray-300"><strong>Input:</strong>  <span class="math">V_1</span>  a set of almost smooth divisors s.t.  <span class="math">|V_1| &gt; 2q^{\\frac{(g-1)+(g+1)k}{g}}</span> .  <span class="math">V_2</span>  a set of 2-almost smooth divisors s.t.  <span class="math">|V_2| &gt; q^{(1+k)}</span></p>

    <p class="text-gray-300"><strong>Output:</strong> Integer m &gt; 0 and  <span class="math">H_m</span>  a set of almost smooth divisors s.t.</p>

    <p class="text-gray-300"><span class="math">$|H_m| &gt; 2q^{(1+r)/2}</span>$</p>

    <p class="text-gray-300">1:
<span class="math">$H_1 \\leftarrow V_1</span>$</p>

    <p class="text-gray-300"><span class="math">$i \\leftarrow 1</span>$</p>

    <p class="text-gray-300"><span class="math">$F_i \\leftarrow H_i \\leftarrow H_{i-1} \\heartsuit V_2</span>$</p>

    <p class="text-gray-300">6: <strong>until</strong>
<span class="math">$|H_i| &gt; 2q^{(1+r)/2}</span>$</p>

    <p class="text-gray-300">7:
<span class="math">$m \\leftarrow i</span>$</p>

    <p class="text-gray-300">8: <strong>return</strong>  <span class="math">m,H_m</span></p>

    <p class="text-gray-300">From lemma 6, the size of  <span class="math">H_i</span>  is estimated by</p>

    <p class="text-gray-300"><span class="math">$|H_i| = |H_1| \\times (q^k)^{i-1} = 2q^{\\frac{(g-1)+(g\\,i+1)k}{g}}.</span>$</p>

    <p class="text-gray-300">So, solving the equation  <span class="math">\\frac{(g-1)+(g\\,i+1)k}{g}=(1+r(k))/2</span>  for i, we have the following.</p>

    <p class="text-gray-300">Lemma 8. m is estimated by</p>

    <p class="text-gray-300"><span class="math">$\\frac{1-k}{2ak}</span>$
.</p>

    <p class="text-gray-300">Further, we will assume  <span class="math">m=O(\\frac{1}{gk})</span> . Note that  <span class="math">\\{l(v)|v\\in \\cup_{i\\leq m}H_i\\}\\leq mg</span> . From lemma 7, the cost for computing  <span class="math">H_m</span>  is</p>

    <p class="text-gray-300"><span class="math">$m \\times (O((\\log q)^2 q^{(1+k)}) + O(mg(\\log q)^2 q^{(1+r)/2})))</span>$</p>

    <p class="text-gray-300">and the required storage is</p>

    <p class="text-gray-300"><span class="math">$O(mg\\log q\\,q^{(1+r)/2}).</span>$</p>

    <p class="text-gray-300">In this section, we compute H a set of smooth divisors for  <span class="math">|H| &gt; q^r</span> .</p>

    <p class="text-gray-300"><strong>Input:</strong>  <span class="math">H_m</span>  a set of almost smooth divisors s.t.  <span class="math">|H_m| &gt; 2q^{(1+r)/2}</span></p>

    <p class="text-gray-300"><strong>Output:</strong> H a set of smooth divisors s.t.  <span class="math">|H| &gt; q^r</span> .</p>

    <p class="text-gray-300">1:  <span class="math">\\bar{H} \\leftarrow H_m \\heartsuit H_m</span></p>

    <p class="text-gray-300">2: return H</p>

    <p class="text-gray-300">From lemma 6, the size of H is estimated by</p>

    <p class="text-gray-300"><span class="math">$|H| = |H_m|^2 / 2q = 2q^r</span>$
.</p>

    <p class="text-gray-300">Note that  <span class="math">\\{l(v)|v\\in \\cup_{i\\leq m}H\\}\\leq 2mg</span> . From lemma 7, the cost for computing H is</p>

    <p class="text-gray-300"><span class="math">$O((\\log q)^2 q^{(1+r)/2}) + O(mq(\\log q)^2 q^r)</span>$</p>

    <p class="text-gray-300">and the required storage is</p>

    <p class="text-gray-300"><span class="math">$O(mg\\log q\\,q^{(1+r)/2}).</span>$</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">8 Two ways representation of <span class="math">h \\in H</span></h4>

    <p class="text-gray-300">An element  <span class="math">h \\in H</span>  is written by the form</p>

    <p class="text-gray-300"><span class="math">$h = \\sum_{P \\in B} a_P^{(h)} D(P),</span>$</p>

    <p class="text-gray-300">since it is a smooth divisor. Moreover, form its construction, we see easily that</p>

    <p class="text-gray-300"><span class="math">$l(h) = \\#\\{P \\in B \\mid a_P^{(h)} \\neq 0\\} \\le 2mg.</span>$</p>

    <p class="text-gray-300">Set  <span class="math">B = \\{R_1, R_2, ..., R_{|B|}\\}.</span></p>

    <p class="text-gray-300">Definition 10.</p>

    <p class="text-gray-300"><span class="math">$Put \\qquad \\mathbf{vec}(h) := (a_{R_1}^{(h)}, a_{R_2}^{(h)}, ..., a_{R_{|B|}}^{(h)}).</span>$</p>

    <p class="text-gray-300">The computation of  <span class="math">h(=\\mathbf{vec}(h))</span>  means the set of pairs  <span class="math">\\{(a_{R_i}^{(h)}, R_i)\\}</span></p>

    <p class="text-gray-300">for non-zero  <span class="math">a_{R_i}^{(h)}</span> . Note that the required storage for one h is  <span class="math">O(m g \\log q)</span> . On the other hands, form its construction, h is written by linear</p>

    <p class="text-gray-300">sum of 2m elements of  <span class="math">V_1 \\cup V_2</span> . i.e.</p>

    <p class="text-gray-300"><span class="math">$h = \\sum_{v \\in V_1 \\cup V_2} b_v^{(h)} v, \\qquad \\#\\{v \\mid b_v^{(h)} \\neq 0\\} = 2m.</span>$</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">Definition 11.</h3>

    <p class="text-gray-300">Put
<span class="math">$\\mathbf{v}(h) := \\{(b_v^{(h)}, v) \\mid b_v^{(h)} \\neq 0\\}.</span>$</p>

    <p class="text-gray-300">Note that the required storage for one  <span class="math">\\mathbf{v}(h)</span>  is  <span class="math">O(m \\log q)</span> .</p>

    <p class="text-gray-300">Important Remark By little modifying the algorithm 3,4, we can obtain both representations of h of the forms  <span class="math">\\mathbf{vec}(h)</span>  and  <span class="math">\\mathbf{v}(h)</span> . (The order of the cost and the order of the storage for computing H is essentially the same.)</p>

    <p class="text-gray-300">Further, we will assume that the computations of  <span class="math">\\mathbf{vec}(h)</span>  and  <span class="math">\\mathbf{v}(h)</span> are done.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">9 Linear algebra</h4>

    <p class="text-gray-300">In this section, we will solve the linear algebra and finding a linear relation of H.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">Algorithm 5 Linear algebra</h3>

    <p class="text-gray-300"><strong>Input:</strong> H a set of smooth divisors such that  <span class="math">|H| &gt; q^r</span>  <strong>Output:</strong> Integers  <span class="math">\\{\\gamma_h\\}_{h\\in H}</span>  modulo  <span class="math">|J_q|</span>  s.t.  <span class="math">\\sum_{h\\in H} \\gamma_h h \\equiv 0 \\mod |J_q|</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1: Set  <span class="math">H = \\{h_1, h_2, ..., h_{|H|}\\}</span></li>
      <li>2: Set matrix  <span class="math">M = ({}^{t}\\mathbf{vec}(h_1), {}^{t}\\mathbf{vec}(h_2), ..., {}^{t}\\mathbf{vec}(h_{|H|}))</span></li>
      <li>3: Solve linear algebra of M and compute  <span class="math">(\\gamma_1, \\gamma_2, ..., \\gamma_{|H|})</span>  such that  <span class="math">\\sum_{i=1}^{|H|} \\gamma_i \\mathbf{vec}(h_i) = \\vec{0}</span> 4: <strong>return</strong>  <span class="math">\\{\\gamma_i\\}</span></li>
    </ul>

    <p class="text-gray-300">Note that the elements of matrix is integers modulo  <span class="math">|J_q| \\doteq q^g</span> . So</p>

    <p class="text-gray-300">the cost of elementary operation modulo  <span class="math">J_q</span>  is  <span class="math">O(g^2(\\log q)^2)</span> . M is a sparse matrix of the size  <span class="math">q^r \\times q^r</span> . Note that the number of non-zero elements in one column is 2mg. So, using [4] [5], we can compute  <span class="math">\\{ \\gamma_i \\}</span> . Its cost is</p>

    <p class="text-gray-300"><span class="math">$O(g^{2}(\\log q)^{2} \\cdot 2mg \\cdot q^{r}q^{r}) = O(mg^{3}(\\log q)^{2}q^{2r})</span>$</p>

    <p class="text-gray-300">and the required storage is</p>

    <p class="text-gray-300"><span class="math">$O(\\log(q^g) m g \\cdot q^r) = O(m g^2 \\log q q^r).</span>$</p>

    <p class="text-gray-300">(The required storage for sparse linear algebra is essentially the storage for non-zero data. Note that the bit length of integer modulo  <span class="math">|J_q|</span>  is  <span class="math">\\log(q^g)</span> , the number of nonzero elements of one row is mg.)</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Computing <span class="math">s_v</span> 10</h4>

    <p class="text-gray-300">Remember that each element  <span class="math">h \\in H</span>  is of the form  <span class="math">h = \\sum_{v \\in V_1 \\cup V_2} b_v^{(h)} v</span> . In the previous section, we found  <span class="math">\\{\\gamma_h\\}</span>  such that  <span class="math">\\sum_{h \\in H} \\gamma_h h \\equiv 0</span>  mod</p>

    <p class="text-gray-300"><span class="math">|J_q|</span> . So, put</p>

    <p class="text-gray-300"><span class="math">$s_v := \\sum_{h \\in H} \\gamma_h b_v^{(h)} \\bmod |J_q| \\qquad \\text{for all } v \\in V_1 \\cup V_2</span>$</p>

    <p class="text-gray-300">and we have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{v \\in V_1 \\cup V_2} s_v v \\equiv 0 \\bmod |J_q|.</span>$</p>

    <p class="text-gray-300">Input:  <span class="math">V_1, V_2, H, \\{\\gamma_h\\}_{h \\in H} \\text{ s.t. } \\sum_{h \\in H} \\gamma_h h \\equiv 0</span> Output:  <span class="math">\\{s_v\\}_{v \\in V_1 \\cup V_2}</span> 1: for all  <span class="math">v \\in V_1 \\cup V_2</span>  do
2:  <span class="math">s_v \\leftarrow 0</span> 3: od
4: for all  <span class="math">h \\in H</span>  do
5: for all  <span class="math">v \\in V_1 \\cup V_2</span>  s.t  <span class="math">b_v^{(h)} \\neq 0</span>  do
6:  <span class="math">s_v \\leftarrow s_v + \\gamma_h b_v^{(h)}</span> 7: od
8: od
9: return  <span class="math">\\{s_v\\}</span></p>

    <p class="text-gray-300">The cost of this part is</p>

    <p class="text-gray-300"><span class="math">$O(g \\log q \\, q^{1+k}) + O(m \\, g^2 \\, (\\log q)^2 q^{(1+r)/2})</span>$</p>

    <p class="text-gray-300">and the storage is</p>

    <p class="text-gray-300"><span class="math">$O(g \\log q \\ q^{1+k}).</span>$</p>

    <p class="text-gray-300">In the previous section, we found  <span class="math">\\{s_v\\}</span>  such that  <span class="math">\\sum s_v v \\equiv 0 \\mod |J_q|</span> . In the part 2 of the algorithm, we have computed  <span class="math">(\\alpha_v, \\beta_v)</span>  such that</p>

    <p class="text-gray-300"><span class="math">$v = \\alpha_v D_1 + \\beta_v D_2.</span>$</p>

    <p class="text-gray-300">So, we have</p>

    <p class="text-gray-300"><span class="math">$\\sum_{v \\in V_1 \\cup V_2} s_v(\\alpha_v D_1 + \\beta_v D_2) = (\\sum_{v \\in V_1 \\cup V_2} s_v \\alpha_v) D_1 + (\\sum_{v \\in V_1 \\cup V_2} s_v \\beta_v) D_2 \\equiv 0. \\bmod |J_q|</span>$</p>

    <p class="text-gray-300">So,  <span class="math">-(\\sum_{v \\in V_1 \\cup V_2} s_v \\alpha_v)/(\\sum_{v \\in V_1 \\cup V_2} s_v \\beta_v) \\mod |J_q|</span>  is required discreet log.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8"><strong>Algorithm 7</strong> Computing <span class="math">\\lambda</span></h3>

    <p class="text-gray-300">Input:
<span class="math">$V_1, V_2, \\{\\alpha_v, \\beta_v\\}, \\{s_v\\}</span>$</p>

    <p class="text-gray-300">Output: Integer  <span class="math">\\lambda \\mod |J_q|</span>  s.t.  <span class="math">D_1 = \\lambda D_2</span>
1: return  <span class="math">-(\\sum_{v \\in V_1 \\cup V_2} s_v \\alpha_v)/(\\sum_{v \\in V_1 \\cup V_2} s_v \\beta_v) \\mod |J_q|</span></p>

    <p class="text-gray-300">Note that the cost of this part is  <span class="math">O(g^2 (\\log q)^2 q^{1+k})</span> .</p>

    <p class="text-gray-300">In this section, we will estimate the cost and the required storage of whole algorithm under the assumption of</p>

    <p class="text-gray-300"><span class="math">$k = \\frac{1}{\\log q}.</span>$</p>

    <p class="text-gray-300">First, remember that  <span class="math">m = O(\\frac{1}{gk}) = O(\\frac{\\log q}{g})</span> . By a direct computation, we have</p>

    <p class="text-gray-300"><span class="math">$r = r(k) = \\frac{g - 1 + k}{g} = 1 - \\frac{1}{g} + \\frac{1}{g \\log q},</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$q^{2r} = q^{2-\\frac{2}{g}} \\times \\exp(\\frac{2}{g}) = O(q^{2-\\frac{2}{g}}).</span>$</p>

    <p class="text-gray-300">From our cost estimation, the cost of the routine except part 2 and part 5 is written by the form</p>

    <p class="text-gray-300"><span class="math">$O(g^a (\\log q)^b q^c)</span>$
<span class="math">a, b \\le 4, c \\le 1 + k.</span></p>

    <p class="text-gray-300">On the other hands, the cost of the routine part 2 and part 5 is written by</p>

    <p class="text-gray-300"><span class="math">$O(g^2(g-1)!(\\log q)^3q^{2r})</span>$
and  <span class="math">O(mg^3 (\\log q)^2q^{2r})</span> .</p>

    <p class="text-gray-300">From lemma 3, we see 1+k&lt;2r and the cost of the whole parts can be estimated by</p>

    <p class="text-gray-300"><span class="math">$O(g^2(g-1)!(\\log q)^3\\ q^{2r}) = O(g^2(g-1)!(\\log q)^3q^{2-\\frac{2}{g}}).</span>$</p>

    <p class="text-gray-300">Similarly, we see that the required storage (dominant part is part 2 and part 7, since 1+k&gt;1&gt;(1+r)/2 from lemma 3) is</p>

    <p class="text-gray-300"><span class="math">$O(g \\, \\log q \\, q^{1+k}) = O(g \\log q \\, q^{1+k}) = O(g \\log q \\, q \\, \\exp(1)) = O(g \\log q \\, q).</span>$</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">13 Conclusion</h3>

    <p class="text-gray-300">In ASIACRYPT2003, Thériault presented a variant of index calculus for the Jacobian of hyperelliptic curve of small genus, using almost smooth divisors. Here, we improve Thériault's result, using 2-almost divisors and propose an attack for DLP of the Jacobian of hyperelliptic curves of small genus, which works  <span class="math">O(q^{2-\\frac{2}{g}+\\epsilon})</span>  running time.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>[1] N. Th´eriault, Index calculus attack for hyperelliptic curves of small genus, ASIACRYPT2003, LNCS 2894, Springer-Verlag, 2003, pp. 75– 92.</li>
      <li>[2] A. Enge, P. Gaudry, A general framework for subexponential discrete logarithm algorithms, Acta Arith., 102, no. 1, pp. 83–103,2002.</li>
      <li>[3] P.Gaudry, An algorithm for solving the discrete log problem on hyperelliptic curves, Eurocrypt 2000, LNCS 1807, Springer-Verlag, 2000, pp. 19–34.</li>
      <li>[4] B. A. LaMacchia, A. M. Odlyzko, Solving large sparse linear systems over finite fields, Crypto '90, LNCS 537, Springer-Verlag, 1990, pp. 109–133.</li>
      <li>[5] D. H. Wiedemann, Solving sparse linear equations over finite fields, IEEE Trans. Inform. Theory, IT-32, no.1, pp.54–62, 1986.</li>
    </ul>

`;
---

<BaseLayout title="Improvement of Thériault Algorithm of Index Calculus for Jac... (2004/161)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/161
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="improvement-of-theriault-algorithm-of-index-calculus-for-2004" />
  </article>
</BaseLayout>
