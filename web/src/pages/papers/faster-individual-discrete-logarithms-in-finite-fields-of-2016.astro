---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/684';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-20';
const TITLE_HTML = 'FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS OF COMPOSITE EXTENSION DEGREE';
const AUTHORS_HTML = 'Unknown authors';

const CONTENT = `    <h4 id="sec-1" class="text-lg font-semibold mt-6">AURORE GUILLEVIC</h4>

    <p class="text-gray-300">Abstract. Computing discrete logarithms in finite fields is a main concern in cryptography. The best algorithms in large and medium characteristic fields (e.g., GF(p 2 ), GF(p &lt;sup&gt;12&lt;/sup&gt;)) are the Number Field Sieve and its variants (special, high-degree, tower). The best algorithms in small characteristic finite fields (e.g., GF(36·509)) are the Function Field Sieve, Joux's algorithm, and the quasipolynomial-time algorithm. The last step of this family of algorithms is the individual logarithm computation. It computes a smooth decomposition of a given target in two phases: an initial splitting, then a descent tree. While new improvements have been made to reduce the complexity of the dominating relation collection and linear algebra steps, resulting in a smaller factor basis (database of known logarithms of small elements), the last step remains at the same level of difficulty. Indeed, we have to find a smooth decomposition of a typically large element in the finite field. This work improves the initial splitting phase and applies to any nonprime finite field. It is very efficient when the extension degree is composite. It exploits the proper subfields, resulting in a much more smooth decomposition of the target. This leads to a new trade-off between the initial splitting step and the descent step in small characteristic. Moreover it reduces the width and the height of the subsequent descent tree.</p>

    <p class="text-gray-300">This work is interested in improving the last step of discrete logarithm (DL) computations in nonprime finite fields. The discrete logarithm instances that we target come from Diffie-Hellman (DH) <a href="#page-26-0">[21]</a> key-exchange, or from pairing-based cryptography. In the latter case, the security relies on the hardness of computing discrete logarithms in two groups: the group of points of a particular elliptic curve defined over a finite field, and a small extension of this finite field (in most of the cases of degree 2, 3, 4, 6, or 12).</p>

    <p class="text-gray-300">The finite fields fall in three groups: small, medium and large characteristic finite fields, corresponding to the respective size of the characteristic p compared to the total size Q = p &lt;sup&gt;n&lt;/sup&gt; of the finite field. This is formalized with the L notation:</p>

    <p class="text-gray-300">(1.1)
<span class="math">$L_Q[\\alpha, c] = e^{(c+o(1))(\\log Q)^{\\alpha}(\\log\\log Q)^{1-\\alpha}}</span>$
, where  <span class="math">Q = p^n</span> ,  <span class="math">\\alpha \\in [0, 1]</span> ,  <span class="math">c \\neq 0</span> .</p>

    <p class="text-gray-300">Date: September 16, 2018. This document is the author's version. First published in Mathematics of Computation, 2018, published by the American Mathematical Society. c 2018 American Mathematical Society. Publisher's version available online September 6, 2018, at <a href="https://doi.org/10.1090/mcom/3376">https://doi.org/10.1090/mcom/3376</a>. See <a href="http://www.ams.org/publications/authors/ctp">http://www.ams.org/publications/authors/ctp</a> about AMS copyright.</p>

    <p class="text-gray-300">&lt;sup&gt;2010&lt;/sup&gt; Mathematics Subject Classification. Primary 11T71: Cryptography.</p>

    <p class="text-gray-300">Key words and phrases. Finite field, discrete logarithm, number field sieve, function field sieve, individual logarithm. 1</p>

    <p class="text-gray-300">Small, medium and large characteristic correspond to α &lt; 1/3, 1/3 &lt; α &lt; 2/3, and α &gt; 2/3 respectively. The boundary cases are α = 1/3 and α = 2/3. In large characteristic, that is p = LQ[α, c] where α &gt; 2/3, the Number Field Sieve (NFS) <a href="#page-26-1">[27,</a> <a href="#page-28-0">61,</a> <a href="#page-26-2">37]</a> provides the best expected running time: in LQ[1/3,(64/9)1/&lt;sup&gt;3&lt;/sup&gt; ≈ 1.923] and was used in the latest record computations in a 768-bit prime field <a href="#page-27-0">[47]</a>. Its special variant in expected running time LQ[1/3,(32/9)&lt;sup&gt;1&lt;/sup&gt;/&lt;sup&gt;3&lt;/sup&gt; ≈ 1.526] was used to break a 1024-bit trapdoored prime field <a href="#page-26-3">[25]</a>. In 2015 and 2016, the Tower-NFS construction of Schirokauer was revisited for prime fields <a href="#page-25-0">[14]</a>, then Kim, Barbulescu and Jeong improved it for nonprime finite fields Fp&lt;sup&gt;n&lt;/sup&gt; where the extension degree n is composite <a href="#page-27-1">[45,</a> <a href="#page-27-2">46]</a>, and used the name Extended TNFS algorithm. To avoid a confusion due to the profusion of names denoting variants of the same algorithm, in this paper we will use TNFS as a generic term to denote the family of all the variants of NFS that use a tower of number fields. Small characteristic means p = LQ[α, c] where α &lt; 1/3. The first L[1/3] algorithm was proposed by Coppersmith, and generalized as the Function Field Sieve <a href="#page-25-1">[8,</a> <a href="#page-25-2">9]</a>.</p>

    <p class="text-gray-300">The NFS and FFS algorithms are made of four phases: polynomial selection (two polynomials are chosen), relation collection where relations between small elements are obtained, linear algebra (computing the kernel of a huge sparse matrix over an auxiliary large prime finite field), and individual discrete logarithm computation. In this work, we improve this last step. All the improvements of NFS, FFS, and related variants since the 90's decrease the size of the factor basis, that is, the database of known discrete logarithms of small elements obtained after the linear algebra step, small meaning an element represented by a polynomial of small degree (FFS), resp., an element whose pseudonorm is small (NFS). The effort required in the individual discrete logarithm step increases: one needs to find a decomposition of a given target into small elements, to be able to express its discrete logarithm in terms of already known logarithms of elements in the factor basis, while the factor basis has decreased at each major improvement. In characteristic 2 and 3 where the extension degree is composite, obtaining the discrete logarithms of the factor basis elements can be done in polynomial time. The individual discrete logarithm is the most costly part, in quasi-polynomial -time in the most favorable cases <a href="#page-25-3">[13,</a> <a href="#page-26-4">29]</a>. In practice, the record computations <a href="#page-26-5">[26,</a> <a href="#page-26-6">35,</a> <a href="#page-25-4">5,</a> <a href="#page-25-5">7,</a> <a href="#page-27-3">42,</a> <a href="#page-25-6">4]</a> implement hybrid algorithms made of Joux's L[1/4] algorithm <a href="#page-26-7">[36]</a>, and the individual discrete logarithm is computed with a continued fraction descent, then a classical descent, a QPA descent, and a Gr¨obner basis descent, or a powers-of-two descent algorithm (a.k.a. zig-zag descent) <a href="#page-26-8">[32,</a> <a href="#page-26-9">31,</a> <a href="#page-26-10">30]</a>.</p>

    <p class="text-gray-300">The heart of this paper relies on the following two observations. Firstly, to speed up the individual discrete logarithm phase, we start by speeding up the initial splitting step, and for that we compute a representation of a preimage of the given target of smaller degree, and/or whose coefficients are smaller. It will improve its smoothness probability. Secondly, to compute this preimage of smaller degree, we exploit the proper subfields of the finite field GF(p &lt;sup&gt;n&lt;/sup&gt;), and intensively use this key-ingredient: since we are computing discrete logarithms modulo (a prime divisor of) Φn(p), we can freely multiply or divide the target by any element in a proper subfield without affecting its discrete logarithm modulo Φn(p).</p>

    <p class="text-gray-300">Organization of the paper. The background needed is presented as preliminaries in Section <a href="#page-2-0">2.</a> We present our generic strategy to lower the degree of the polynomial representing a given element in GF(p &lt;sup&gt;n&lt;/sup&gt;) in Section <a href="#page-3-0">3.</a> We apply it to characteristic two and three in Section 4. Preliminaries before the large characteristic case are given in Section 5. We apply our technique to medium and large characteristic finite fields, that is the NFS case and its tower variant in Section 6, and provide examples of cryptographic size in Section 7. Finally in Section 8 we present a more advanced strategy, to exploit several subfields at a time, and we apply it to  <span class="math">\\mathbb{F}_{p^6}</span> .</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2. Preliminaries</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;2.1. <strong>Setting.</strong> In this paper, we are interested in nonprime finite fields  <span class="math">GF(p^n)</span> , n &gt; 1. To keep the same notation between small, medium, and large characteristic finite fields, we assume that the field  <span class="math">\\mathbb{F}_{p^n}</span>  is defined by an extension of degree  <span class="math">n_2</span>  above an extension of degree  <span class="math">n_1</span> , that is,  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span> , and  <span class="math">n = n_1 n_2</span> . The elements are of the form  <span class="math">T = \\sum_{i=0}^{n_2-1} \\sum_{j=0}^{n_1-1} a_{ij} y^j x^i</span> , where the coefficients  <span class="math">a_{ij}</span>  are in  <span class="math">\\mathbb{F}_p</span> , the coefficients  <span class="math">a_i = \\sum_{j=0}^{n_1-1} a_{ij} y^j</span>  are in  <span class="math">\\mathbb{F}_{p^{n_1}} = \\mathbb{F}_p[y]/(h(y))</span> , and  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}} = \\mathbb{F}_{p^{n_1}}[x]/(\\psi(x))</span> , where h is a monic irreducible polynomial of  <span class="math">\\mathbb{F}_p[y]</span>  of degree  <span class="math">n_1</span>  and  <span class="math">\\psi</span>  is a monic irreducible polynomial of  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree  <span class="math">n_2</span> . In other words, T is represented as a polynomial of degree  <span class="math">n_2 - 1</span>  in the variable x, and has coefficients  <span class="math">a_i \\in \\mathbb{F}_{p^{n_1}}</span> . For the FFS and NFS algorithms,  <span class="math">n_1 = 1</span>  and  <span class="math">n_2 = n</span> ; for finite fields from pairing constructions,  <span class="math">n_2 &gt; 1</span>  is a strict divisor of n, and for the original version of TNFS,  <span class="math">n_1 = n</span>  and  <span class="math">n_2 = 1</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.1</strong> (Smoothness). Let B be a positive integer. A polynomial is said to be B-smooth w.r.t. its degree if all its irreducible factors have a degree smaller than B. An integer is said to be B-smooth if all its prime divisors are less than B. An ideal in a number field is said to be B-smooth if it factors into prime ideals whose norms are bounded by B.</p>

    <p class="text-gray-300"><strong>Definition 2.2</strong> (Preimage). The preimage of an element  <span class="math">a = \\sum_{i=0}^{n_2-1} \\sum_{j=0}^{n_1-1} a_{ij} y^j x^i \\in \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  will be, for the NFS and TNFS algorithms, the bivariate polynomial  <span class="math">\\sum_{i=0}^{n_2-1} \\sum_{j=0}^{n_1-1} a&#x27;_{ij} y^j x^i \\in \\mathbb{Z}[x,y]</span> , where each coefficient  <span class="math">a&#x27;_{ij}</span>  is a lift in  <span class="math">\\mathbb{Z}</span>  of the coefficient  <span class="math">a_{ij}</span>  in  <span class="math">\\mathbb{F}_p</span> . It is a preimage for the reduction modulo  <span class="math">(p,h,\\psi)</span> , that we denote by  <span class="math">\\rho: \\mathbb{Z}[x,y] \\to \\mathbb{F}_{(p^{n_1})^{n_2}}</span> . In small characteristic, the preimage of a is a univariate polynomial in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> . It is a preimage for the reduction modulo  <span class="math">\\psi</span> , that we also denote by  <span class="math">\\rho: \\mathbb{F}_{p^{n_1}}[x] \\to \\mathbb{F}_{(p^{n_1})^{n_2}}</span> .</p>

    <p class="text-gray-300"><strong>Definition 2.3</strong> (Pseudonorm). The integral pseudonorm w.r.t. a number field  <span class="math">\\mathbb{Q}[x]/(f(x))</span>  (f monic) of a polynomial  <span class="math">T = \\sum_{i=0}^{\\deg f-1} a_i x^i</span>  of integer coefficients  <span class="math">a_i</span>  is computed as  <span class="math">\\operatorname{Res}_x(T(x), f(x))</span> .</p>

    <p class="text-gray-300">Since there is no chance for a preimage of a target  <span class="math">T_0</span>  to be B-smooth, the individual discrete logarithm is done in two steps: an <em>initial splitting</em> of the target, and then a descent phase. The initial splitting is an iterative process that tries many targets  <span class="math">g^tT_0 \\in \\mathbb{F}_{p^n}^*</span> , where t is a known exponent (taken uniformly at random), until a  <span class="math">B_1</span> -smooth decomposition of the preimage is found. Here smooth stands for a factorization into irreducible polynomials of  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree at most  <span class="math">B_1</span>  in the small characteristic setting, resp., a pseudonorm that factors as an integer into a product of primes smaller than  <span class="math">B_1</span>  in the NFS (and TNFS) settings.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-2&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt;also called <em>boot</em> or <em>smoothing step</em> in large characteristic finite fields</p>

    <p class="text-gray-300">&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;2&lt;/sup&gt;in order to make no confusion with the mathematical <em>descent</em>, which is not involved in this process, we mention that in this step, the norm (with NFS) or the degree (with FFS) of the preimage <em>decreases</em>.</p>

    <p class="text-gray-300">The second phase starts a recursive process for each element less than  <span class="math">B_1</span>  but greater than  <span class="math">B_0</span>  obtained after the initial splitting phase. Each of these medium-sized elements are processed until a complete decomposition over the factor basis is obtained. Each element obtained from the initial splitting is at the root of its descent tree. One finds a relation involving the original one and other ones whose degree, resp., pseudonorm, is strictly smaller than the degree, resp., pseudonorm, of the initial element at the root. These smaller elements form the new leaves of the descent tree. For each leaf, the process is repeated until all the leaves are elements in the factor basis. The discrete logarithm of an element output by the initial splitting can be computed by a tree traversal. This strategy is considered in [19, §6], [48, §7], [38, §3.5], [18, §4].</p>

    <p class="text-gray-300">In small characteristic, the initial splitting step is known as the Waterloo&lt;sup&gt;3&lt;/sup&gt; algorithm [15, 16]. It outputs  <span class="math">T = U(x)/V(x) \\mod I(x)</span> , and U, V are two polynomials of degree  <span class="math">\\lfloor (n_2 - 1)/2 \\rfloor</span> . It uses an Extended GCD computation. For prime fields, the continued fraction algorithm was already used with the Quadratic Sieve and Coppersmith-Odlyzko-Schroeppel algorithm. It expresses an integer N modulo p as a fraction  <span class="math">N \\equiv u/v \\mod p</span> , and the numerator and denominator are of size about the square root of p. The generalization of this technique was used in [39]. As for the Waterloo algorithm, this technique provides a very good practical speed up but does not improve the asymptotic complexity.</p>

    <p class="text-gray-300">this subfield tool was highlighted in [34]; we will intensively use it.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-3&quot;&gt;&lt;/span&gt;<strong>Lemma 2.4</strong> ([34, Lemma 1]). Let  <span class="math">T \\in \\mathbb{F}_{p^n}^*</span> , and let  <span class="math">\\deg T &lt; n</span> . Let  <span class="math">\\ell</span>  be a nontrivial prime divisor of  <span class="math">\\Phi_n(p)</span> . Let  <span class="math">T&#x27; = u \\cdot T</span>  with u in a proper subfield of  <span class="math">\\mathbb{F}_{p^n}</span> . Then</p>

    <p class="text-gray-300">(2.1)
<span class="math">$\\log T&#x27; \\equiv \\log T \\mod \\Phi_n(p)</span>$
and in particular  <span class="math">\\log T&#x27; \\equiv \\log T \\mod \\ell</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;3. The heart of our strategy: representing elements in the cyclotomic subgroup of a nonprime finite field with less coefficients</p>

    <p class="text-gray-300">In the FFS setting,  <span class="math">n_1 = 1</span>  and usually  <span class="math">n_2</span>  is prime and our technique cannot be helpful, but if n is not prime, our algorithm applies, and moreover in favorable cases Joux's L[1/4] algorithm and its variants can be used and our technique can provide a further notable speed-up in the descent. For the implementations in small characteristic, the factor basis is made of the irreducible polynomials of  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of very small degree, e.g., of degrees 1, 2, 3, and 4 in [3]. Our aim is to improve the smoothness probability of a preimage  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  of a given target  <span class="math">T \\in \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  and for that we want to reduce the degree in x of the preimage P (as a lift of T in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> , P has degree at most  <span class="math">n_2 - 1</span>  in x), while keeping the property</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-2&quot;&gt;&lt;/span&gt;
<span class="math">$\\log(\\rho(P)) = \\log T \\mod \\ell ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\rho: \\mathbb{F}_{p^{n_1}}[x] \\to \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  is the reduction modulo  <span class="math">\\psi</span> .</p>

    <p class="text-gray-300">Let d denote the largest proper divisor of n, 1 &lt; d &lt; n (d might sometimes be equal to  <span class="math">n_2</span>  in the QPA setting). We will compute P in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree at most  <span class="math">n_2 - d/n_1</span>  in x (and coefficients in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> ) such that</p>

    <p class="text-gray-300">(3.1)
<span class="math">$P = uT \\pmod{\\psi}</span>$
, where  <span class="math">u^{p^d - 1} = 1</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;3&lt;/sup&gt;the name comes from the authors' affiliation: the University of Waterloo, ON, Canada.</p>

    <p class="text-gray-300">It means that we will cancel the  <span class="math">d/n_1 - 1</span>  higher coefficients (in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> ) of a preimage of T in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> .</p>

    <p class="text-gray-300">There are two strategies: either handle coefficients in  <span class="math">\\mathbb{F}_p</span>  or in  <span class="math">\\mathbb{F}_{p^{\\gcd(d,n_1)}}</span> . We will consider the latter case. Let  <span class="math">d&#x27;=d/\\gcd(d,n_1)</span>  to simplify the notation, and let  <span class="math">[1,U,\\ldots,U^{d&#x27;-1}]</span>  be a polynomial basis of  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span> . Every product  <span class="math">P=U^iT</span>  satisfies (3.1). Define the  <span class="math">d&#x27;\\times n_2</span>  matrix L whose rows are made of the coefficients (in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> ) of  <span class="math">U^iT</span>  for  <span class="math">0\\leq i\\leq d&#x27;-1</span> :</p>

    <p class="text-gray-300"><span class="math">$L_{d&#x27; \\times n_2} = \\begin{bmatrix} T \\\\ UT \\\\ \\vdots \\\\ U^{d&#x27;-1}T \\end{bmatrix} \\in \\mathcal{M}_{d&#x27;,n}(\\mathbb{F}_{p^{n_1}}) .</span>$</p>

    <p class="text-gray-300">Then we compute a row-echelon form of this matrix by performing only  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span> -linear operations over the rows, so that each row of the echeloned matrix is a  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span> -linear combination of the initial rows, that can be expressed as</p>

    <p class="text-gray-300"><span class="math">$P = \\sum_{i=0}^{d&#x27;-1} \\lambda_i U^i T = u T, \\text{ where } \\lambda_i \\in \\mathbb{F}_{p^{\\gcd(n_1,d)}} , \\ U^i \\in \\mathbb{F}_{p^{d/\\gcd(n_1,d)}}</span>$</p>

    <p class="text-gray-300">so that P = uT with  <span class="math">u^{p^d-1} = 1</span> . Assuming that the matrix is lower-triangular (the other option being an upper-triangular matrix), we take the first row of the matrix as the coefficients of a polynomial in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree at most  <span class="math">n_2 - d/n_1</span> . This is formalized in Algorithm 1. We obtain the following Theorem 3.1.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;<strong>Input:</strong> Finite field  <span class="math">\\mathbb{F}_{p^n}</span>  represented as a tower  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}} = \\mathbb{F}_{p^{n_1}}[x]/(\\psi(x))</span>  (one may have  <span class="math">n_1 = 1</span> ), a proper divisor d of n ( <span class="math">d \\mid n, 1 &lt; d &lt; n</span> ),  <span class="math">T \\in \\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300"><strong>Output:</strong>  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  a polynomial of degree  <span class="math">\\leq n_2 - d/n_1</span>  satisfying  <span class="math">P \\mod \\psi = uT</span> , where  <span class="math">u \\in \\mathbb{F}_{p^d}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1  <span class="math">d&#x27; = d/\\gcd(n_1, d)</span></li>
      <li><strong>2</strong> Compute a polynomial basis  <span class="math">(1, U, U^2, \\dots, U^{d&#x27;-1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span></li>
      <li>3 Define  <span class="math">L = \\begin{bmatrix} T \\\\ UT \\\\ \\vdots \\\\ U^{d&#x27;-1}T \\end{bmatrix}</span>  a  <span class="math">d&#x27; \\times n_2</span>  matrix of coefficients in  <span class="math">\\mathbb{F}_{p^{n_1}}</span></li>
      <li>4  <span class="math">M \\leftarrow \\text{RowEchelonForm}(L)</span>  with only  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span> -linear combinations</li>
      <li>5  <span class="math">P(x) \\leftarrow</span>  polynomial from the coefficients of the first row of L</li>
      <li>6 return P(x)</li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-4-2&quot;&gt;&lt;/span&gt;<strong>Theorem 3.1.</strong> Let  <span class="math">\\mathbb{F}_{p^n}</span>  be a finite field represented as a tower  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span> . Let  <span class="math">T \\in \\mathbb{F}_{p^n}^*</span>  be an element which is not in a proper subfield of  <span class="math">\\mathbb{F}_{p^n}</span> . Let d be the largest proper divisor of n, 1 &lt; d &lt; n (n is not prime). Assume that T is represented by a polynomial in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree larger than  <span class="math">n_2 - d/n_1</span> . Then there exists a preimage</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^4&lt;/sup&gt;n_2-d/n_1</span>  is not necessarily an integer, meaning that the leading coefficient of the polynomial is some element in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> . Its degree in x is actually  <span class="math">n_2-\\lceil d/n_1\\rceil</span> .</p>

    <p class="text-gray-300">P of T, in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> , of degree  <span class="math">n_2 - \\lceil d/n_1 \\rceil</span>  in x and coefficients in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , and such that</p>

    <p class="text-gray-300"><span class="math">$\\log(\\rho(P)) = \\log T \\mod \\Phi_n(p) .</span>$</p>

    <p class="text-gray-300">Proof. We use Algorithm 1 to compute P. The matrix has full rank since the  <span class="math">U^i</span> s form a polynomial basis of  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span> . The linear combinations involve T and elements in  <span class="math">\\mathbb{F}_{p^{d/\\gcd(n_1,d)}}</span>  and  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span>  that are in the proper subfield  <span class="math">\\mathbb{F}_{p^d}</span>  by construction. The first row after Gaussian elimination will have at least  <span class="math">d/n_1 - 1</span>  coefficients equal to zero at the right, and will represent a polynomial P of degree at most  <span class="math">n_2 - d/n_1</span> , that satisfies  <span class="math">P = uT \\pmod{\\psi}</span>  where  <span class="math">u = \\sum \\lambda_i U^i \\in \\mathbb{F}_{p^d}</span> , since in the process, T was multiplied only by elements whose images in  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span>  are in the subfield  <span class="math">\\mathbb{F}_{p^d}</span> . We have  <span class="math">\\rho(P) = uT</span> ,  <span class="math">u \\in \\mathbb{F}_{p^d}</span> , and the equality of logarithms follows by Lemma 2.4.  <span class="math">\\square</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;We can now directly apply Algorithm 1 to improve the initial splitting algorithm in practice.</p>

    <p class="text-gray-300">In all the examples of small characteristic finite fields from pairings, n is not prime, for instance  <span class="math">n=6\\cdot 509</span> . The notation in [6] was n=lk, with the property  <span class="math">p^l\\approx k</span> . With our notation,  <span class="math">n_1=l</span>  and  <span class="math">n_2=k</span> .</p>

    <p class="text-gray-300">4.1. <strong>Algorithm.</strong> We directly use Algorithm 1 as a subroutine of Algorithm 2. Then to improve it in practice, we list valuable modifications.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-1&quot;&gt;&lt;/span&gt;Remark 4.1. As was pointed out to us by F. Rodríguez-Henríquez [56, 3], the elements of the form  <span class="math">x^i R(x)</span>  where R itself is of degree  <span class="math">\\leq n_2 - d/n_1</span>  are evenly interesting because the discrete logarithm of  <span class="math">x^i</span>  can be deduced from the discrete logarithm of x, which is known after linear algebra.</p>

    <p class="text-gray-300">So we can increase the number of elements tested for  <span class="math">B_1</span> -smoothness for each exponent t by a factor d' almost for free in the following way. We again run a Gaussian elimination algorithm on the matrix M but in the reverse side, for instance from row one to row d' and left to right if it was done from row d' to row one and right to left the first time. The matrix is in row-echelon form on the left-hand side and on the right-hand side (the upper right and lower left corners are filled with zeros). We obtain a matrix N of the form</p>

    <p class="text-gray-300"><span class="math">$N = \\begin{bmatrix} * &amp; \\dots &amp; * &amp; * &amp; 0 &amp; \\dots &amp; 0 \\\\ 0 &amp; \\ddots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; \\ddots &amp; \\ddots &amp; &amp; &amp; \\ddots &amp; 0 \\\\ 0 &amp; \\dots &amp; 0 &amp; * &amp; \\dots &amp; * &amp; * \\end{bmatrix} .</span>$</p>

    <p class="text-gray-300">The <em>i</em>-th row represents a polynomial  <span class="math">P&#x27;_i = x^{e_i}P_i</span> , where  <span class="math">P_i</span>  is of degree at most  <span class="math">n_2 - d/n_1</span> , and  <span class="math">e_i \\approx (i-1)\\gcd(n_1,d)/n_1</span> . Since x is in the factor basis (by construction, like all the degree one polynomials), its logarithm is known at this point (after the relation collection and linear algebra steps), hence the logarithm of any power  <span class="math">x^{e_i}</span>  is known. It remains to compute the discrete logarithm of  <span class="math">P_i</span> .</p>

    <p class="text-gray-300">In practice there are some technicalities: in the second Gaussian elimination, if the leading coefficient is zero, then two rows are swapped, and it cancels the previous Gaussian elimination (computed at the other end of the matrix) for that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-0&quot;&gt;&lt;/span&gt;Algorithm 2: Initial splitting in small characteristic with the subfield technique</p>

    <pre><code class="language-text">Input: Finite field \\mathbb{F}_{p^n} of small characteristic (e.g., p=2,3), with a tower
                representation \\mathbb{F}_{p^n} = \\mathbb{F}_{(p^{n_1})^{n_2}} = \\mathbb{F}_{p^{n_1}}[x]/(I(x)) (one may have n_1 = 1),
                generator g (of the order \\ell subgroup of the cyclotomic subgroup of \\mathbb{F}_{p^n}),
                target T_0 \\in \\mathbb{F}_{(p^{n_1})^{n_2}}, smoothness bound B_1
    Output: t, P \\in \\mathbb{F}_{p^{n_1}}[x] a polynomial of degree \\leq n_2 - d/n_1 such that
                   \\operatorname{vlog}_a \\rho(P) = t + \\operatorname{vlog}_a T_0 \\mod \\ell, and P(x) is B_1-smooth (w.r.t. its
                   degree in x)
 1 d \\leftarrow the largest divisor of n, 1 &lt; d &lt; n
 \\mathbf{2} \\ d&#x27; \\leftarrow d/\\gcd(d, n_1)
 3 Compute U(x) \\in \\mathbb{F}_{(p^{n_1})^{n_2}} s.t. (1, U, U^2, \\dots, U^{d&#x27;-1}) is a polynomial basis of the
      subfield \\mathbb{F}_{n^{d&#x27;}}
 4 repeat
         take t \\in \\{1, \\dots, \\ell - 1\\} at random
          T \\leftarrow g^t T_0 \\text{ in } \\mathbb{F}_{(p^{n_1})^{n_2}}
        Define L = \\begin{bmatrix} T \\\\ UT \\\\ \\vdots \\\\ U^{d&#x27;-1}T \\end{bmatrix} a d&#x27; \\times n_2 matrix of coefficients in \\mathbb{F}_{p^{n_1}}
         M \\leftarrow \\text{RowEchelonForm}(L) \\text{ (with } \\mathbb{F}_{p^{\\gcd(d,n_1)}}\\text{-linear Gaussian elimination)}
         P(x) \\leftarrow the polynomial of lowest degree made of the first row of L
10 until P(x) is B_1-smooth
11 return t, P(x)
</code></pre>

    <p class="text-gray-300">row. We end up with a matrix which is in row-echelon form on the right and almost row-echelon form on the left (or vice-versa). Since each set of subsequent  <span class="math">n_1/\\gcd(n_1,d)</span>  rows produces polynomials of the same degree, swapping two rows from the same set will not change the degree in x of the polynomial. In average (this is what we observed in our experiments for  <span class="math">\\mathbb{F}_{3^{6\\cdot509}}</span>  and  <span class="math">\\mathbb{F}_{3^{5\\cdot479}}</span> ), some rare polynomials will have a degree in x increased by one or two. This second Gaussian elimination increases the number of tests by a factor d' at a very cheap cost, since in fact it allows one to share the cost of computing the  <span class="math">U^iT</span>  and the two Gaussian eliminations over d' tests.</p>

    <p class="text-gray-300">Remark 4.2. If  <span class="math">\\gcd(d,n_1)&gt;1</span>  we can increase the number of rows by a small factor. We perform linear combinations of  <span class="math">n_1/\\gcd(d,n_1)</span>  subsequent rows (all giving a polynomial of same degree):  <span class="math">\\sum_{0\\leq j\\leq n_1/\\gcd(d,n_1)}\\mu_jr_j</span>  where  <span class="math">\\mu\\in\\mathbb{F}_{p^{\\gcd(d,n_1)}}</span> , and it will result in new rows and new polynomials of same degree.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-6-1&quot;&gt;&lt;/span&gt;Remark 4.3. Other improvements are possible [56, 3], for instance computing  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span> -linear combinations over a small number of rows corresponding to polynomials of almost the same degree. The resulting polynomial will have degree increased by one or two, which does not significantly affect its  <span class="math">B_1</span> -smoothness probability in practice for cryptographic sizes. This technique allows one to produce many more candidates, at a very cheap cost of linear operations in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> .</p>

    <h2 id="sec-3" class="text-2xl font-bold">4.2. Complexity analysis.</h2>

    <p class="text-gray-300">4.2.1. Cost of computing one preimage  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  in the initial splitting step. We use the notation of Algorithm 2: let d be the largest proper divisor of n (d | n, 1 &lt; d &lt; n), and let  <span class="math">d&#x27; = d/\\gcd(d, n_1)</span> . Since  <span class="math">d&#x27; \\mid d \\mid n = n_1 n_2</span>  and  <span class="math">\\gcd(d&#x27;, n_1) = 1</span> , then  <span class="math">d&#x27; \\mid n_2</span>  and  <span class="math">d&#x27; \\leq n_2</span> . The computation of all the  <span class="math">U^iT</span>  of the matrix L costs at most  <span class="math">d&#x27;n_2^2</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , since a schoolbook multiplication in  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span> costs  <span class="math">n_2^2</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> . There are d' such multiplications. The complexity of a reduced row-echelon form computation of a  <span class="math">(d&#x27; \\times n_2)</span> -matrix,  <span class="math">d&#x27; \\leq n_2</span> , is less than  <span class="math">O(d&#x27;^2n_2)</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  [23, §13.4.2]. To simplify, we consider that the computation of the matrix L and of two Gaussian eliminations is done in time at most  <span class="math">O(d&#x27;n_2^2)</span> . This cost is shared over d' polynomials  <span class="math">P_i</span>  to be tested for  <span class="math">B_1</span> -smoothness. In this way, the complexity of computing a preimage P with our initial splitting algorithm is the same as in the Waterloo algorithm:  <span class="math">O(n_2^2)</span> , and moreover the smoothness probabilities are much higher for the targeted cryptographic cases coming from supersingular pairing-friendly curves. We also replace two  <span class="math">B_1</span> smoothness tests by only one, and that might save some time in practice (this saving disappears in the O notation). We present the theoretical costs in Tables 1 and 2 from [24]. XGCD stands for extended Euclidean algorithm, SQF stands for SQuare-free Factorization, DDF stands for Distinct Degree Factorization, and EDF stands for Equal Degree Factorization. All the polynomials to be factored are of degree smaller than  <span class="math">n_2</span> ; we take  <span class="math">n_2</span>  as an upper bound to get the costs of Table 2.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;TABLE 1. Costs for the initial splitting step. The preimage obtained with Algorithm 2 has degree  <span class="math">d_P \\leq n_2 - d/n_1</span> . The Waterloo algorithm [15, 16] produces two polynomials of degree  <span class="math">d_P = \\lfloor n_2/2 \\rfloor</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Factorization</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">cost</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Square-free (SQF)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(d_P^2)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Distinct degree (DDF)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(d_P^3 \\log p^{n_1})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Equal degree (EDF)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(d_P^2 \\log p^{n_1})</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">&lt;span id=&quot;page-7-1&quot;&gt;&lt;/span&gt;TABLE 2. Cost in multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  to compute one preimage to be tested for smoothness, in the initial splitting step.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Computation</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">XGCD(T, I)</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">matrix <span class="math">[U^iT]_{0 \\le i \\le c}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">d'-1 and row echelon form</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Waterloo</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">this work, Alg. 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">this work <span class="math">+</span> Rem. <span class="math">4.1</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Cost</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(n_{2}^{2})</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(d&#x27;n_2^2)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">O(n_2^2)</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">4.2.2. running time of the initial splitting step. To start, we recall some results on the smoothness probability of a polynomial of given degree.</p>

    <p class="text-gray-300"><strong>Definition 4.4.</strong> Let  <span class="math">N_q(b;d)</span>  denote the number of monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degree d which are b-smooth. Let  <span class="math">N_q(b;d_1,d_2)</span>  denote the number of coprime pairs of monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degrees  <span class="math">d_1</span>  and  <span class="math">d_2</span> , respectively, which are b-smooth.</p>

    <p class="text-gray-300">Let  <span class="math">\\Pr_q(b;d)</span>  denote the probability of a monic polynomial over  <span class="math">\\mathbb{F}_q</span>  of degree d to be b-smooth. Let  <span class="math">\\Pr_q(b;d_1,d_2)</span>  denote the probability of two coprime monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degrees  <span class="math">d_1</span>  and  <span class="math">d_2</span>  to be both b-smooth.</p>

    <p class="text-gray-300">Odlyzko gave the following estimation for  <span class="math">Pr_q(b;d)</span>  in [54, (4.5), p. 14].</p>

    <p class="text-gray-300">(4.1)
<span class="math">$\\Pr_q(b,d)^{-1} = \\exp\\left((1+o(1))\\frac{d}{b}\\log_e\\frac{d}{b}\\right) \\text{ for } d^{1/100} \\le b \\le d^{99/100} \\ .</span>$</p>

    <p class="text-gray-300">Writing the smoothness bound degree  <span class="math">b = \\log L_Q[\\alpha_b, c_b]/\\log p^{n_1}</span>  to match Odlyzko's convention  <span class="math">b = c_b n_2^{\\alpha_b} (\\log n_2)^{1-\\alpha_b}</span> , and the degree of the polynomial to be tested for smoothness  <span class="math">d = an_2</span> , where  <span class="math">a \\in ]0,1[</span>  and  <span class="math">n_2 = \\log Q/\\log p^{n_1}</span> , one obtains</p>

    <p class="text-gray-300"><span class="math">$\\Pr_{p^{n_1}}(b,d) = L_Q \\left[1 - \\alpha_b, -(1 - \\alpha_b)a/\\gamma\\right], \\text{ where } Q = p^{n_1 n_2}.</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;<strong>Theorem 4.5</strong> ([22, Theorem 1]). Let  <span class="math">\\delta &gt; 0</span>  be given. Then we have, uniformly for  <span class="math">b, d_1, d_2 \\to \\infty</span>  with  <span class="math">d_1^{\\delta} \\leq b \\leq d_1^{1-\\delta}</span>  and  <span class="math">d_2^{\\delta} \\leq b \\leq d_2^{1-\\delta}</span> ,</p>

    <p class="text-gray-300"><span class="math">$N_q(b;d_1,d_2) \\sim \\left(1 - \\frac{1}{q}\\right) N_q(b;d_1) N_q(b;d_2) \\ .</span>$</p>

    <p class="text-gray-300"><strong>Corollary 4.6</strong> ([22, Theorem 1]). Let  <span class="math">\\delta &gt; 0</span>  be given. Then we have, uniformly for  <span class="math">b, d_1, d_2 \\to \\infty</span>  with  <span class="math">d_1^{\\delta} \\leq b \\leq d_1^{1-\\delta}</span>  and  <span class="math">d_2^{\\delta} \\leq b \\leq d_2^{1-\\delta}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr_q(b; d_1, d_2) \\sim \\left(1 - \\frac{1}{q}\\right) \\Pr_q(b; d_1) \\Pr_q(b; d_2)</span>$
.</p>

    <p class="text-gray-300">We can now compare the Waterloo algorithm with this work. Assuming that  <span class="math">B_1 = \\log_{p^{n_1}} L_{p^n}[2/3, \\gamma]</span>  for a certain  <span class="math">\\gamma</span> , then the probability of a polynomial of degree  <span class="math">an_2</span> ,  <span class="math">0 &lt; a &lt; n_2</span> , to be  <span class="math">B_1</span> -smooth is  <span class="math">L_{p^n}[1/3, -a/(3\\gamma)]</span> . In the Waterloo algorithm, two polynomials of degree  <span class="math">n_2/2</span>  should be  <span class="math">B_1</span> -smooth at the same time, and the expected running time to find such a pair is  <span class="math">L_{p^n}[1/3, 1/(3\\gamma)]</span>  (the square of  <span class="math">L_{p^n}[1/3, 1(6\\gamma)]</span> ). In our algorithm, a polynomial of degree  <span class="math">\\lfloor n_2 - d/n_1 \\rfloor = \\lfloor n_2(1 - d/n) \\rfloor</span>  is tested for  <span class="math">B_1</span> -smoothness, so finding a good one requires</p>

    <p class="text-gray-300">(4.2)
<span class="math">$L_{n^n}[1/3, a/(3\\gamma)]</span>$
tests, where  <span class="math">a \\approx 1 - d/n</span> ,</p>

    <p class="text-gray-300">which is always faster than the Waterloo algorithm, for which a=1. When n is even (this is always the case for finite fields of supersingular pairing-friendly curves), one can choose d=n/2, hence a=1/2 and our algorithm has running time the square root of the running time of the Waterloo algorithm.</p>

    <p class="text-gray-300">4.3. Improving the record computation in  <span class="math">\\mathbf{GF}(3^{6\\cdot 509})</span> . Adj, Menezes, Oliveira, and Rodríguez-Henríquez estimated in [6] the cost to compute discrete logarithms in the 4841-bit finite field  <span class="math">\\mathbf{GF}(3^{6\\cdot 509})</span>  and announced their record computation in July 2016 [4]. The details of the computations are available in Adj's PhD thesis [2] and the details for initial splitting and descent can be found in [17]. The elements are represented by polynomials of degree at most 508 whose coefficients are in  <span class="math">\\mathbb{F}_{3^6}</span> . In this case  <span class="math">n_1 = 6</span>  and  <span class="math">n_2 = 509</span> . The initial splitting made with the Waterloo algorithm outputs two polynomials of degree 254. The probability that two independent and relatively prime polynomials of degree 254 over  <span class="math">\\mathbb{F}_{3^6}</span>  are simultaneously b-smooth is  <span class="math">(1 - 1/3^6) \\, \\mathrm{Pr}_{3^6}^2(254, b)</span>  [22]. The term  <span class="math">(1 - 1/3^6)</span>  is negligible in practice for the values that we are considering.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>4.3.1. Improvements. Our Algorithm 2 outputs one polynomial of degree 254, whose probability to be b-smooth is  <span class="math">\\Pr_{3^6}(n,b)</span> , i.e., the square root of the previous one. So we can take a much smaller b while reaching the same probability as before with the Waterloo algorithm. We list in Table 3a, p. 11, the values of b to obtain a probability between  <span class="math">2^{-40}</span>  and  <span class="math">2^{-20}</span> . For instance, if we allow  <span class="math">2^{30}</span>  trials, then we can set b=28 with our algorithm, instead of b=43 previously: we have  <span class="math">\\Pr_{3^6}(254,43)=2^{-30.1}</span> , and we only need to take b=28 to get the same probability with this work:  <span class="math">\\Pr_{3^6}(254,28)=2^{-29.6}</span> . This will provide a good practical speed-up of the descent phase: much fewer elements need to be &quot;reduced&quot;: this reduces the initial width of the tree, and they are of much smaller degree: this reduces the depth of the descent tree.</li>
      <li>4.3.2. A 30-smooth initial splitting. The finite field is represented with  <span class="math">n_1=6</span>  and  <span class="math">n_2=509</span> , that is, as a first extension  <span class="math">\\mathbb{F}_{3^6}=\\mathbb{F}_{p^{n_1}}=\\mathbb{F}_3[y]/(y^6+2y^4+y^2+2y+2)</span> , then a second extension  <span class="math">\\mathbb{F}_{3^{6\\cdot509}}=\\mathbb{F}_{3^6}[x]/(I(x))</span> , where I(x) is the degree 509 irreducible factor of  <span class="math">h_1x^{q_1}-h_0</span> , where  <span class="math">q_1=p^{n_1}</span> ,  <span class="math">h_1=x^2+y^{424}x</span> , and  <span class="math">h_0=y^{316}x+y^{135}</span> . The generator is  <span class="math">g=x+y^2</span> . As a proof of concept, we computed a 30-smooth initial splitting of the target  <span class="math">T_0=\\sum_{i=0}^{508}(y^{\\lfloor\\pi(3^6)^{i+1}\\rfloor}\\bmod 3^6)x^i</span> , with the parameters  <span class="math">d=3\\times509</span> ,  <span class="math">d&#x27;=d/\\gcd(d,n_1)=509</span> . Each trial  <span class="math">g^tT_0</span>  produces d'=509 polynomials to test for smoothness. We found that  <span class="math">g^{47233}T_0=uvx^{230}P</span> , where  <span class="math">u=1\\in\\mathbb{F}_{3^6},\\ v\\in\\mathbb{F}_{3^3\\cdot509}</span> , and P is of degree 255 and 30-smooth. The equality  <span class="math">(g^{47233}T_0)^{\\frac{p^n-1}{\\ell}}=(uvx^{230}P)^{\\frac{p^n-1}{\\ell}}</span>  is satisfied. The explicit value of P is available at https://members.loria.fr/AGuillevic/files/F3_6_509_30smooth.mag.txt.</li>
    </ul>

    <p class="text-gray-300">The whole computation took less than 6 days (real time) on 48 cores Intel Xeon E5-2609 at  <span class="math">2.40 \\,\\mathrm{GHz}</span>  (274 core days, i.e., 0.75 core-years). This is obviously an overshot compared to the estimate of  <span class="math">2^{26.6}</span> , but this was done with a nonoptimized Magma implementation.</p>

    <p class="text-gray-300">As a comparison, with the classical Waterloo algorithm, Adj et al. computed a 40-smooth initial splitting in 51.71 CPU (at 2.87GHz) years [2, Table 5.2, p. 87] and [4]. They obtained irreducible polynomials of degree 40, 40, 39, 38, 37, and seven polynomials of degree between 22 and 35. They needed another 9.99 CPU years (at 2.66 GHz) to compute a classical descent from 40-smooth to 21-smooth polynomials. A complete comparison can be found in [3] and [1]. In [3], Adj et al. estimated that with our Algorithm 2 enriched as in Remarks 4.1 and 4.3, it is possible to compute discrete logarithms in  <span class="math">\\mathbb{F}_{3^{6-709}}</span>  at the same cost as in  <span class="math">\\mathbb{F}_{3^{6-509}}</span>  with the former Waterloo algorithm.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>4.4. Computing discrete logarithms in  <span class="math">\\mathbb{F}_{2^{512}}</span>  and  <span class="math">\\mathbb{F}_{2^{1024}}</span> . In [28, §3.6] discrete logarithms in  <span class="math">\\mathbb{F}_{2^{512}}</span>  and  <span class="math">\\mathbb{F}_{2^{1024}}</span>  need to be computed modulo the full multiplicative group order  <span class="math">2^n-1</span> . As pointed to us by R. Granger, our technique can be used to compute discrete logarithms in  <span class="math">\\mathbb{F}_{2^{1024}}</span> . Our algorithm provides a decomposition of the target as the product uR where u is an element in the largest proper subfield  <span class="math">\\mathbb{F}_{2^{512}}</span> , and P is an element of  <span class="math">\\mathbb{F}_{2^{1024}}</span>  of degree 512 instead of 1023. The discrete logarithm of the subfield cofactor u can be obtained by a discrete logarithm computation in  <span class="math">\\mathbb{F}_{2^{512}}</span> . More generally, our technique is useful when discrete logarithms in nested finite fields such as  <span class="math">\\mathbb{F}_{2^{2^i}}</span>  are computed recursively.</li>
      <li>4.5. Improving the record computation in  <span class="math">GF(3^{5\\cdot479})</span> . Joux and Pierrot announced a discrete logarithm record computation in  <span class="math">GF(3^{5\\cdot479})</span>  in [42] (then published in [40]). They defined a first degree 5 extension  <span class="math">\\mathbb{F}_{3^5} = \\mathbb{F}_3[y]/(y^5 y + 1)</span></li>
    </ul>

    <p class="text-gray-300">TABLE 3. Smoothness probabilities of polynomials over finite fields, comparison of the Waterloo algorithm and Algorithm 2. The values were computed with Odlyzko's induction formula [54] and Drmota and Panario's Theorem 4.5, as in [17].</p>

    <p class="text-gray-300">(A) Probabilities for  <span class="math">GF(3^{6.509})</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;(B) For  <span class="math">GF(3^{5\\cdot479})</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Weterles alm</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Almonithm 2</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">&lt;b&gt;VV&lt;/b&gt; 7-411</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">A1:41 0</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Waterloo alg.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Waterloo alg.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Algorithm 2</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Pr_{3^6}^2(254,b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">Pr_{36}(254, b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">b</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Pr_{3^5}^2(239,b)</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Pr_{3^5}(383,b)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-40.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-42.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-67.96}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-67.59}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-38.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-39.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-63.95}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-63.86}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-36.8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">24</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-37.2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-60.30}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-60.45}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-35.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">25</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-35.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-56.95}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-57.32}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-33.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-53.89}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-54.44}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-32.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">26</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-33.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-51.07}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-51.79}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-31.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">27</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-31.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-48.46}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-49.34}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-30.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-29.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-46.06}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-47.06}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-28.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-43.83}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-44.95}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-27.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">29</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-28.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-41.76}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-42.99}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-26.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-39.83}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-41.16}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-25.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">30</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-26.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-38.03}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-39.44}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-25.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">31</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-25.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-36.35}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-37.84}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-34.77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-36.34}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-23.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">33</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-23.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-33.30}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-34.92}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">51</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-22.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-31.91}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-33.60}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">52</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.8}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">34</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-30.61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-32.34}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">53</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">35</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-29.39}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-31.16}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">54</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-20.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">36</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-20.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-28.23}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-30.05}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">55</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-19.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">43</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-27.14}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-28.99}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">56</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-19.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">37</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-19.2}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-26.11}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-27.99}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">57</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-18.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-25.13}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-27.04}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">58</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-18.0}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">38</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-18.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.21}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-26.14}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">59</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-17.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">39</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-17.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">47</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-23.33}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-25.29}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">60</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-16.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">40</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-16.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-22.50}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-24.47}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">61</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-16.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">41</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-16.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">49</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-21.71}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-23.70}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">62</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-15.9}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">42</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-15.6}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">50</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-20.96}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{-22.96}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">and then a degree 479 extension on top of  <span class="math">\\mathbb{F}_{3^5}</span> . With our notation, we have  <span class="math">p=3,\\ n_1=5,</span>  and  <span class="math">n_2=479.</span>  The irreducible degree 479 polynomial I(x) is a divisor of  <span class="math">xh_1(x^{q_1})-h_0(x^{q_1})</span> , where  <span class="math">q_1=p^{n_1}=3^5,\\ h_0=x^2+y^{111}x</span>  and  <span class="math">h_1=yx+1.</span>  Given a target  <span class="math">T\\in\\mathbb{F}_{3^{5\\cdot479}}</span> , the Waterloo initial splitting outputs two polynomials  <span class="math">u(x),v(x)\\in\\mathbb{F}_{3^5}[x]</span>  of degree  <span class="math">\\lfloor 478/2\\rfloor=239.</span>  Our Algorithm 1 outputs one polynomial of degree  <span class="math">\\lfloor \\frac{4}{5}479\\rfloor=383.</span>  This example is interesting because the smoothness probabilities are very close. We computed the exact values with Drmota–Panario's formulas, and give them in Table 3b, p. 11. We obtain  <span class="math">\\Pr_{3^5}(239,50)=2^{-20.96}</span>  (Waterloo) and  <span class="math">\\Pr_{3^5}(383,50)=2^{-22.96}</span> , i.e., our Algorithm 2 would be four times slower compared to Joux's and Pierrot's record;  <span class="math">\\Pr_{3^5}(239,40)=2^{-30.61}</span>  and  <span class="math">\\Pr_{3^5}(383,40)=2^{-32.34};</span>   <span class="math">\\Pr_{3^5}^2(239,30)=2^{-48.46}</span>  and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{3^5}(383,30) = 2^{-49.34}</span> ; and the cross-over point is for b = 24: in this case, we have  <span class="math">\\Pr_{3^5}^2(239,24) = 2^{-67.96}</span>  and  <span class="math">\\Pr_{3^5}(383,24) = 2^{-67.59}</span> , which is slightly larger.</p>

    <p class="text-gray-300">The probabilities would advise using the classical initial splitting with the Waterloo (extended GCD) algorithm. We remark that this algorithm would output two  <span class="math">B_1</span> -smooth polynomials of degree  <span class="math">(n_2-1)/2</span> . Each would factor into at least  <span class="math">(n_2-1)/(2B_1)</span>  irreducible polynomials of degree at most  <span class="math">B_1</span> . Each such factor is sent as an input to the second step (descent step), that is, roughly  <span class="math">n_2B_1</span>  factors. If we use Algorithm 2, the initial splitting will outputs one polynomial of degree  <span class="math">4/5n_2=383</span>  that factors into at least  <span class="math">4/5n_2/B_1</span>  polynomials of degree at most  <span class="math">B_1</span> , each of them sent as input to the second step, that is, the descent step is called 20% time less, and that would reduce the total width of the descent tree in the same proportion. Since the descent is the most costly part, and in particular, the memory size required is huge, this remark would need to be taken into consideration for a practical implementation.</p>

    <p class="text-gray-300">As a proof of concept of our algorithm, we implemented in Magma our algorithm, took the same parameters, generator, and target as in [42], and found a 50-smooth decomposition for the target given by the 471-th row of the matrix computed for  <span class="math">g^{23940}T_0</span>  in 1239 core-hours (22.12 hours over 56 cores) on an Intel Xeon E5-2609 at 2.40GHz (compared to 5000 core-hours announced in [42]).</p>

    <p class="text-gray-300">The value can be found at https://members.loria.fr/AGuillevic/files/F3_5_479_50smooth.mag.txt. In our technique, we compute  <span class="math">g^tT_0 = uvR</span>  where  <span class="math">u \\in \\mathbb{F}_{3^5}</span>  (this is the leading term of the polynomial),  <span class="math">v \\in \\mathbb{F}_{3^{479}}</span> , and R is 50-smooth. The discrete logarithm of u can be tabulated, however it remains quite hard to compute the discrete logarithm of v. Our technique is useful if it is easy (or not required) to compute discrete logarithms in the subfields.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;5. Preliminaries before medium and large characteristic cases</h3>

    <p class="text-gray-300">In the first part of this paper, we were considering polynomials, and we wanted polynomials of smallest possible degree. Now we turn to the medium and large characteristic cases, where we do not have polynomials but ideals in number fields, and we want ideals of small norm. It requires testing whether large integers (norms) are smooth as fast as possible. We recall the results of Pomerance and Barbulescu on the <em>early abort strategy</em>.</p>

    <p class="text-gray-300">5.1. Pomerance's Early Abort Strategy. Pomerance in [55] introduced the Early Abort Strategy (EAS) to speed up the factorization of large integers, within Dixon's algorithm, the Morrison-Brillhart (continued fraction) algorithm, and the Schroeppel (linear sieve) and quadratic sieve, with several variations in the factorization sub-routine (trial-division, Pollard-Strassen method). The Early Abort Strategy provides an asymptotic improvement in the expected running time. Two versions are studied in [55]: one early-abort test, then many tests. In the relation collection step of the NFS algorithm, the partial factorization of the pseudonorms is done with ECM in time  <span class="math">L_Q[1/6]</span>  ( <span class="math">Q = p^n</span> ), which is negligible compared to the total cost in  <span class="math">L_Q[1/3]</span> . So Pomerance's EAS does not provide an asymptotic speed-up, but a practical one. However, in the individual discrete logarithm computation, the initial splitting requires to find smooth integers (pseudonorms) of larger size:  <span class="math">L_Q[1]</span> . This time the ECM cost is not negligible, and Pomerance's EAS matters. The speed-up was analyzed by Barbulescu in [10].</p>

    <p class="text-gray-300">Remark 5.1. Instead of the ECM test, it could be possible to use the hyperelliptic curve method test of H. Lenstra, Pila and Pomerance [51, 52]. This was investigated for instance by Cosset [20, Chapter 4].</p>

    <p class="text-gray-300">Pomerance's analysis is presented in the general framework of testing integers for smoothness. This is named <em>smoothing problem</em> in [10, Chapter 4]. In the individual discrete logarithm context, the numbers we want to test for smoothness are not integers in an interval, but pseudonorms, and their chances of being smooth do not exactly match the chances of random integers of the same size. However, we will make the usual heuristic assumption that for our asymptotic computations, the pseudonorms considered behave as integers of the same size. We give Pomerance's Early Abort Strategy with one test in Algorithm 3 and with k tests in Algorithm 4.</p>

    <pre><code class="language-text">Algorithm 3: Pomerance&#x27;s Early Abort Strategy (EAS)
</code></pre>

    <pre><code class="language-text">Input: Integer m, smoothness bound B_1, real numbers \\theta, b \\in ]0, 1[
  Output: B_1-smooth decomposition of m, or \\perp
                                                                  // cost: L_{B_1^{\\theta}}[1/2, \\sqrt{2}]
1 (m_0, m_1) \\leftarrow \\text{ECM} (m, B_1^{\\theta})
                                                   // m_0 is a B_1^{\\theta}-smooth part of m
                                          // m_1 is the non-factorized part of m
2 if m_1 \\le m^{1-b} then
    (m_2,m_3) \\leftarrow \\mathtt{ECM}(m_1,B_1)
                                                                   // cost: L_{B_1}[1/2, \\sqrt{2}]
     if m_3 = 1 then

return B_1-smooth decomposition m_1, m_2 of m
6 return ⊥
</code></pre>

    <p class="text-gray-300">Writing the complexities as in Pomerance's paper, in terms of k early-abort tests, one obtains Theorems 5.2 and 5.3.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;<strong>Theorem 5.2</strong> ([10,  <span class="math">\\S</span>  4.3]). The expected running time of the smoothing problem of an integer N with Pomerance's EAS and the ECM smoothness test is  <span class="math">L_N[1/3,c]</span> where  <span class="math">c = (23/3)^{2/3}/3</span> , the smoothness bound is  <span class="math">B = L_N[2/3, \\gamma]</span> , where  <span class="math">\\gamma = 1/c</span> ,  <span class="math">\\theta = 4/9</span> , and b = 8/23.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-12-2&quot;&gt;&lt;/span&gt;<strong>Theorem 5.3</strong> ([10,  <span class="math">\\S</span>  4.5 Th. 4.5.1]). The expected running time of the smoothing problem of an integer N with k tests of Pomerance's EAS and the ECM smoothness test is  <span class="math">L_N[1/3,c]</span>  where</p>

    <p class="text-gray-300"><span class="math">$c = 3^{1/3}((15 + 4(2/3)^{3k})/19)^{2/3}</span>$
,</p>

    <p class="text-gray-300">the smoothness bound is  <span class="math">B = L_N[2/3, \\gamma]</span> , where</p>

    <p class="text-gray-300"><span class="math">$\\gamma = 1/c</span>$
,</p>

    <p class="text-gray-300">the bound  <span class="math">b_i</span>  for  <span class="math">0 \\le i \\le k-1</span>  on the remaining part  <span class="math">m_i</span>  in Algorithm 4 is</p>

    <p class="text-gray-300"><span class="math">$b_i = (2/3)^{3(k-i)} 19/(15 + 4(2/3)^{3k})</span>$
,</p>

    <p class="text-gray-300">and the exponent  <span class="math">\\theta_i</span>  for  <span class="math">0 \\le i \\le k</span>  is</p>

    <p class="text-gray-300"><span class="math">$\\theta_i = (4/9)^{k-i} .</span>$</p>

    <p class="text-gray-300">In Section 6.3, we will consider that pseudonorms behave in terms of smoothness like integers bounded by  <span class="math">N^e</span>  (instead of N). We will need the following lemmas.</p>

    <p class="text-gray-300"><strong>Algorithm 4:</strong> Pomerance's Early Abort Strategy with k tests (k-EAS)</p>

    <pre><code class="language-text">Input: Integer m, smoothness bound B_1, number of tests k &gt; 0,
    array of positive real numbers \\mathbf{b} = [b_0, b_1, \\dots, b_k] where 0 &lt; b_i \\le 1, and
    array of positive real numbers \\theta = [\\theta_0, \\dots, \\theta_k = 1] where \\theta_i &lt; \\theta_{i+1}
    Output: B_1-smooth decomposition of m, or \\perp
 1 m_i \\leftarrow m
 i \\leftarrow 0
 з S \\leftarrow \\emptyset
 4 repeat
       (s_i, m_{i+1}) \\leftarrow \\texttt{ECM}\\ (m_i, B_1^{\\theta_i})
        // cost: L_{B_1^{\\theta_i}}[1/2,\\sqrt{2}] // s_i is a B_1^{\\theta_i}-smooth part of m_i, m_{i+1} is not factorized S\\leftarrow S\\cup s_i
                                                                            // cost: L_{B_1^{\\theta_i}}[1/2,\\sqrt{2}]
        m_i \\leftarrow m_{i+1}i \\leftarrow i+1
 9 until (i &gt; k) OR (m_i = 1) OR (m_i &gt; m^{1 - \\sum_{j=0}^{i-1} b_j})
10 if m_i == 1 then
11 | return B_1-smooth decomposition S of m
12 return ⊥
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-13-1&quot;&gt;&lt;/span&gt;<strong>Lemma 5.4</strong> ([18, §4.1], [34, Lemma 1] Running time of <em>B</em>-smooth decomposition of integers with ECM). Let  <span class="math">N_i</span>  be integers taken uniformly at random and bounded by  <span class="math">N^e</span> , for a fixed real number e &gt; 0. Write  <span class="math">B = L_N[\\alpha_B, \\gamma]</span>  the smoothness bound. Then the expected running time to obtain a <em>B</em>-smooth  <span class="math">N_i</span> , using ECM for <em>B</em>-smooth tests, is  <span class="math">L_N[1/3, (3e)^{1/3}]</span> , obtained with  <span class="math">B = L_N[2/3, e/c = (e^2/3)^{1/3}]</span> .</p>

    <p class="text-gray-300"><strong>Lemma 5.5</strong> ([55, 10] Running time of <em>B</em>-smooth decomposition of integers with ECM and <em>k</em>-EAS). Let  <span class="math">N_i</span>  be integers taken uniformly at random and bounded by  <span class="math">N^e</span> , for a fixed real number e&gt;0. Write  <span class="math">B=L_N[\\alpha_B,\\gamma]</span>  for the smoothness bound. Then the expected running time to obtain a <em>B</em>-smooth  <span class="math">N_i</span> , using ECM for <em>B</em>-smooth tests and Pomerance's Early Abort Strategy with one test, is  <span class="math">L_N[1/3,c=(3e)^{1/3}(23/27)^{2/3}]</span> , obtained with  <span class="math">B=L_N[2/3,e/c]</span> . The expected running time with k-EAS is  <span class="math">L_N[1/3,c=(3e)^{1/3}((15+4(2/3)^{3k})/19)^{2/3}]</span> , with  <span class="math">B=L_N[2/3,e/c]</span> .</p>

    <p class="text-gray-300">We will mix Pomerance' strategy with our new initial splitting step to improve its running time.</p>

    <p class="text-gray-300">5.2. <strong>LLL algorithm.</strong> We recall an important property of the LLL algorithm [49] that we will widely use in this paper. Given a lattice  <span class="math">\\mathcal{L}</span>  of  <span class="math">\\mathbb{Z}^n</span>  defined by a basis given by an  <span class="math">n \\times n</span>  matrix L, and parameters  <span class="math">\\frac{1}{4} &lt; \\delta &lt; 1</span> ,  <span class="math">\\frac{1}{2} &lt; \\eta &lt; \\sqrt{\\delta}</span> , the LLL algorithm outputs a  <span class="math">(\\eta, \\delta)</span> -reduced basis of the lattice. the coefficients of the first (shortest) vector are bounded by</p>

    <p class="text-gray-300"><span class="math">$(\\delta - \\eta^2)^{\\frac{n-1}{4}} \\det(L)^{1/n}</span>$
.</p>

    <p class="text-gray-300">In the remainder of this paper, we will simply denote by  <span class="math">{\\cal C}</span>  this LLL approximation factor.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">5.3. NFS and Tower variants.</h3>

    <p class="text-gray-300">5.3.1. Settings. There exist many polynomial selection methods to initialize the NFS algorithm for large and medium characteristic finite fields. We give in Table 4 the properties of the polynomials that we need (degree and coefficient size) to deduce an upper bound of the pseudonorm, as in (5.3), and (5.4).</p>

    <p class="text-gray-300">    <img src="_page_14_Figure_3.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">FIGURE 1. Extensions of number fields for NFS and tower variants</p>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;    <img src="_page_14_Figure_5.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">FIGURE 2. NFS and tower variant diagrams for  <span class="math">\\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300">Three polynomials define the NFS setting:  <span class="math">\\psi</span> ,  <span class="math">f_0</span> ,  <span class="math">f_1</span> , where  <span class="math">f_0</span> ,  <span class="math">f_1</span>  are two polynomials of integer coefficients, irreducible over  <span class="math">\\mathbb{Q}</span> , of degree  <span class="math">\\geq n</span> , defining two non-isomorphic number fields, and whose GCD modulo p is an irreducible polynomial  <span class="math">\\psi</span>  of degree n, used to define the extension  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_p[x]/(\\psi(x))</span> .</p>

    <p class="text-gray-300">In a tower-NFS setting, one has  <span class="math">n=n_1n_2,\\,n_1,n_2\\neq 1</span>  and four polynomials are defined:  <span class="math">h,\\psi,f_0,f_1</span> , where  <span class="math">\\deg h=n_1</span>  and h is irreducible modulo p,  <span class="math">\\deg \\psi=n_2</span>  and  <span class="math">\\psi</span>  is irreducible modulo p, and  <span class="math">\\gcd(f_0 \\bmod (p,h),f_1 \\bmod (p,h))=\\psi</span> . It can be seen as a generalization of the NFS setting as follows: writing  <span class="math">n=n_1n_2</span> , one starts by defining a field extension  <span class="math">\\mathbb{F}_{p^{n_1}}=\\mathbb{F}_p[y]/(h(y))</span>  and then adapting any previously available polynomial selection designed for NFS in  <span class="math">\\mathrm{GF}(p^{n_2})</span> , using  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  as the base field instead of  <span class="math">\\mathbb{F}_p</span> . When  <span class="math">\\gcd(n_1,n_2)&gt;1</span> , the polynomials  <span class="math">f_0,f_1</span> , resp.,  <span class="math">\\psi</span> , will have coefficients in  <span class="math">\\mathbb{Q}[y]/(h(y))</span> , resp.,  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , instead of  <span class="math">\\mathbb{Q}</span> , resp.,  <span class="math">\\mathbb{F}_p</span> . Then one defines the second extension  <span class="math">\\mathbb{F}_{p_1^n}[x]/(\\psi(x))</span>  of degree  <span class="math">n_2=\\deg_x\\psi</span> .</p>

    <p class="text-gray-300">Again, to cover all the cases, we consider  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_{(p^{n_1})^{n_2}}</span> . The NFS case will correspond to  <span class="math">n_1 = 1</span> ,  <span class="math">n_2 = n</span>  and the original TNFS case to  <span class="math">n_1 = n</span> ,  <span class="math">n_2 = 1</span> .</p>

    <p class="text-gray-300">5.3.2. Pseudonorm and upper bound. Let f be a monic irreducible polynomial over  <span class="math">\\mathbb{Q}</span> , and let  <span class="math">K = \\mathbb{Q}[x]/(f(x))</span>  be a number field. Write  <span class="math">T \\in K</span>  as a polynomial in x:</p>

    <p class="text-gray-300"><span class="math">T = \\sum_{i=0}^{\\deg f - 1} a_i x^i</span> . The norm is defined by a resultant computation:</p>

    <p class="text-gray-300">(5.1)
<span class="math">$\\operatorname{Norm}_{K/\\mathbb{O}}(T) = \\operatorname{Res}(f, T) .</span>$</p>

    <p class="text-gray-300">In the NFS case, we will consider elements expressed as polynomials in x whose coefficients are integers. We define the pseudonorm as the resultant of the element with the given polynomial f:</p>

    <p class="text-gray-300"><span class="math">$T = \\sum_{i=0}^{\\deg f - 1} a_i x^i</span>$
, pseudonorm <span class="math">(T(x)) = \\operatorname{Res}(T(x), f(x))</span> .</p>

    <p class="text-gray-300">We use Kalkbrener's bound [43, Corollary 2] for an upper bound:</p>

    <p class="text-gray-300"><span class="math">$(5.2) |\\operatorname{Res}(f,T)| \\le \\kappa (\\operatorname{deg} f,\\operatorname{deg} T) ||f||_{\\infty}^{\\operatorname{deg} T} ||T||_{\\infty}^{\\operatorname{deg} f},</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\kappa(n,m) = \\binom{n+m}{n} \\binom{n+m-1}{n}</span>  and  <span class="math">||f||_{\\infty} = \\max_{0 \\le j \\le \\deg f} |f_j|</span>  is the absolute value of the largest coefficient. An upper bound for  <span class="math">\\kappa(n,m)</span>  is (n+m)!. We will use the following bound in Section 6:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;
<span class="math">$(5.3) \\operatorname{Norm}_{K_f/\\mathbb{Q}}(T) \\le (\\deg f + \\deg T)! \\|f\\|_{\\infty}^{\\deg T} \\|T\\|_{\\infty}^{\\deg f}.</span>$</p>

    <p class="text-gray-300">In a Tower-NFS case, we nest two resultants:</p>

    <p class="text-gray-300"><span class="math">$T = \\sum_{i=0}^{\\deg f - 1} \\sum_{j=0}^{\\deg h - 1} a_{ij} y^j x^i, \\text{ pseudonorm}(T(x, y)) = \\text{Res}_y(\\text{Res}_x(T(x), f(x)), h(y)) .</span>$</p>

    <p class="text-gray-300">A bound is [45, §A Lemma 2]</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;
<span class="math">$(5.4) \\qquad \\frac{|N_{K_f/\\mathbb{Q}} \\sum_{i=0}^{\\deg_x P} \\sum_{j=0}^{\\deg h-1} a_{ij} \\alpha_h^j \\alpha_f^i|}{&lt;||a_{ij}||_{\\infty}^{\\deg h \\deg f}||f||_{\\infty}^{\\deg_x P \\deg h}||h||_{\\infty}^{(\\deg_x P + \\deg f)(\\deg h - 1)} D(\\deg h, \\deg f)},</span>$</p>

    <p class="text-gray-300">where  <span class="math">||a_{ij}||_{\\infty} = \\max_{i,j} |a_{ij}|</span>  and  <span class="math">D(d_1, d_2)</span>  is a combinatorial term,  <span class="math">D(d_1, d_2) = ((2d_2 - 1)(d_1 - 1) + 1)^{d_1/2}(d_1 + 1)^{(2d_2 - 1)(d_1 - 1)/2}((2d_2 - 1)!d_1^{2d_2})^{d_1}</span> .</p>

    <p class="text-gray-300">We apply Algorithm 1 to the medium and large characteristic cases. For a general exposition, we assume that we are in a tower setting, where  <span class="math">Q = p^n = (p^{n_1})^{n_2}</span> . The elements of  <span class="math">\\mathbb{F}_{p^n}</span>  are represented as  <span class="math">T = \\sum_{i=0}^{n_1-1} \\sum_{j=0}^{n_2-1} a_{i,j} y^j x^i</span> . the NFS setting corresponds to  <span class="math">n_1 = 1</span> ,  <span class="math">n_2 = n</span> . When n is prime, the tower setting is  <span class="math">n_1 = n</span> ,  <span class="math">n_2 = 1</span>  but our algorithm does not apply. Denote by h(y) the polynomial defining the field  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  and by  <span class="math">\\psi</span>  the polynomial defining the degree  <span class="math">n_2</span>  extension  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span> . Here we are not interested (only) in computing a preimage of degree as small as possible, but more generally one whose size of pseudonorm is as small as possible. According to the bounds (5.3), (5.4), we need to combine small coefficients  <span class="math">a_{i,j}</span>  (to reduce the contribution of  <span class="math">\\|a_{ij}\\|_{\\infty}^{\\deg h \\deg f}</span> ) with a small degree in x (to reduce the contribution of  <span class="math">\\|f\\|_{\\infty}^{\\deg_x P \\deg h}</span> ), and balance the two terms to find a pseudonorm of smaller size.</p>

    <p class="text-gray-300">6.1. <strong>The algorithm.</strong> We start again with the same idea as in Algorithm 1: let d be the largest proper divisor of n, with 1 &lt; d &lt; n.&lt;sup&gt;5&lt;/sup&gt; Assume we want to obtain a preimage  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  of the target, of degree  <span class="math">(n-d)/n_1 \\le \\deg P &lt; \\deg f</span> . We will use relations of the form</p>

    <p class="text-gray-300"><span class="math">$P = uT \\pmod{\\psi}</span>$
, where  <span class="math">u^{p^d - 1} = 1</span>  as in (3.1).</p>

    <p class="text-gray-300">We use the relations</p>

    <p class="text-gray-300"><span class="math">$x^i y^j p = 0 \\pmod{p, h, \\psi} \\text{ for } 0 \\le ij &lt; d \\ ,</span>$</p>

    <p class="text-gray-300"><span class="math">$P = U^i T \\pmod{p, h, \\psi} \\ ,</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\{1, U, \\dots, U^{d-1}\\}</span>  is a polynomial basis of  <span class="math">\\mathbb{F}_{p^d}</span>  and where</p>

    <p class="text-gray-300"><span class="math">$x^{i}y^{j}\\psi = 0 \\pmod{p, h, \\psi}</span>$
for  <span class="math">0 \\le j &lt; n_1, \\ 0 \\le i &lt; \\deg(P) - n_2</span> .</p>

    <p class="text-gray-300">We define the lattice of these relations and we obtain a matrix</p>

    <p class="text-gray-300"><span class="math">$L_{n_1(\\deg P+1)\\times n_1(\\deg P+1)} = \\begin{bmatrix} p &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; \\\\ &amp; p &amp; &amp; \\\\ &amp; \\operatorname{coeff}(UT) &amp; &amp; \\\\ &amp; \\vdots &amp; &amp; \\\\ &amp; \\operatorname{coeff}(U^{d-1}T) &amp; &amp; \\\\ &amp; &amp; \\operatorname{coeff}(\\psi) &amp; &amp; \\\\ &amp; &amp; \\ddots &amp; \\\\ &amp; \\operatorname{coeff}(x^i(y^j\\psi \\bmod h(y))) \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">We want to obtain a matrix in row-echelon form. The d first rows and the  <span class="math">n_1(\\deg P - n_2)</span>  last rows are in row-echelon form by construction. We compute Gaussian elimination to obtain a reduced row-echelon form for the rows  <span class="math">U^iT</span> . We use  <span class="math">\\mathbb{F}_p</span> -linear combinations of these rows, and we allow divisions in  <span class="math">\\mathbb{F}_p</span>  so that the leading coefficient is one. We then obtain a square matrix of dimension  <span class="math">n_1(\\deg P + 1)</span>  in row-echelon form. Now at this point we apply a lattice reduction algorithm such as LLL or BKZ to reduce the size of the coefficients of L. We obtain a matrix R whose first row has coefficients bounded by  <span class="math">C_{\\text{LLL}} \\det(L)^{1/(n_1(\\deg P + 1))} = p^{(n-d)/(n_1(\\deg P + 1))}</span> .</p>

    <h2 id="sec-6" class="text-2xl font-bold">6.2. Properties and pseudonorm size bound.</h2>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;<strong>Proposition 6.1.</strong> The preimage P output by Algorithm 5 satisfies  <span class="math">\\log_g \\rho(P) \\equiv \\log_g g^t T_0 = \\log_g T_0 + t \\mod \\Phi_n(p)</span> , where  <span class="math">\\rho : \\mathbb{Z}[x,y] \\to \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  was defined in Figure 2.</p>

    <p class="text-gray-300">Proof of Proposition 6.1. Each row of the row-echelon matrix M represents a  <span class="math">\\mathbb{F}_p</span> -linear combination of the d elements  <span class="math">U^iT</span> ,  <span class="math">0 \\leq i \\leq d-1</span> , i.e., an element  <span class="math">\\sum_{i=0}^{d-1} \\lambda_i U^iT</span> , where  <span class="math">\\lambda_i \\in \\mathbb{F}_p</span> . We can factor T in the expression. Each element  <span class="math">u_j = \\sum_{i=0}^{d-1} \\lambda_i U^i</span>  satisfies  <span class="math">u_j^{p^d-1} = 1</span> , i.e., is in  <span class="math">\\mathbb{F}_{p^d}</span>  by construction. So each row represents an</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt; <span class="math">&lt;sup&gt;^5&lt;/sup&gt;d = \\deg(h) = n_1</span>  is the case studied independently in the preprint [64]. Since an earlier version of this work was presented at Asiacrypt 2015 and ECC 2015, and the question of how to use larger subfields raised in discussions at these conferences, it is not surprising that other researchers though of similar ideas to improve individual discrete logarithms in the same time period.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">Algorithm 5: Initial splitting, Tower-NFS setting</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;Input: Finite field  <span class="math">\\mathbb{F}_{p^n}</span> ,  <span class="math">n=n_1n_2</span> , monic irreducible polynomials  <span class="math">h,\\psi</span>  s.t.  <span class="math">\\mathbb{F}_{p^{n_1}}=\\mathbb{F}_p[y]/(h(y)), \\, \\mathbb{F}_{(p^{n_1})^{n_2}}=\\mathbb{F}_{p^{n_1}}[x]/(\\psi(x)), \\, \\text{prime order subgroup}</span>   <span class="math">\\ell\\mid \\Phi_n(p), \\, \\text{generator} \\, g \\, (\\text{of the order} \\, \\ell \\, \\text{subgroup}), \\, \\text{target} \\, T_0\\in \\mathbb{F}_{p^n}, \\, \\text{degree}</span>  of the preimage  <span class="math">\\deg P</span> , polynomial  <span class="math">f_i</span> , smoothness bound  <span class="math">B_1</span> Output:  <span class="math">t\\in\\{1,\\ldots,\\ell-1\\},\\, P\\in\\mathbb{Z}[x]\\,\\, \\text{s.t. log}_g\\, \\rho(P)\\equiv t+\\log_g T_0, \\, \\text{and the}</span>  pseudonorm  <span class="math">\\mathrm{Res}_y(\\mathrm{Res}_x(P,f_i),h)</span>  is  <span class="math">B_1</span> -smooth 1  <span class="math">d\\leftarrow \\text{the largest divisor of} \\, n,\\, 1\\leq d&lt; n</span> 2 Compute a polynomial basis  <span class="math">(1,U,U^2,\\ldots,U^{d-1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^d}</span> , where U satisfies  <span class="math">U^{p^d-1}=1\\in\\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300">s repeat</p>

    <p class="text-gray-300">take
<span class="math">$t \\in \\{1, \\dots, \\ell - 1\\}</span>$
uniformly at random
<span class="math">$T \\leftarrow g^t T_0 \\in \\mathbb{F}_{p^n}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} p &amp; &amp; &amp; \\\\ &amp; \\ddots &amp; &amp; \\\\ &amp; &amp; p &amp; \\\\ &amp; &amp; \\cot(UT) &amp; \\\\ &amp; &amp; &amp; \\vdots \\\\ &amp; &amp; \\cot(U^{d-1}T) &amp; \\\\ &amp; &amp; &amp; \\cot(\\psi) &amp; \\\\ &amp; &amp; &amp; \\ddots &amp; \\\\ &amp; &amp; &amp; &amp; \\ddots &amp; \\\\ &amp; &amp; &amp; &amp; &amp;</span>$</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>7</strong> Compute a  <span class="math">\\mathbb{F}_p</span>  reduced row echelon form of the rows n-d+1 to n of L</li>
      <li>8  <span class="math">N \\leftarrow \\texttt{LatticeReduction}(L)</span></li>
      <li>9  <span class="math">P \\leftarrow \\text{polynomial in } \\mathbb{Z}[y,x] \\text{ made of the shortest vector output by the LatticeReduction algorithm}</span></li>
      <li>10 until  <span class="math">\\mathrm{Res}_y(\\mathrm{Res}_x(P,f_i),h)</span>  is  <span class="math">B_1</span> -smooth // ECM, ECM+EAS, or ECM+k-EAS</li>
      <li>11 <strong>return</strong> t, P, factorization of  <span class="math">Res_y(Res_x(P, f_i), h)</span></li>
    </ul>

    <p class="text-gray-300">element  <span class="math">T_j = u_j T</span> , where  <span class="math">u_j^{p^d-1} = 1</span>   <span class="math">(u_j \\in \\mathbb{F}_{p^d})</span> , so that  <span class="math">\\log T_j \\equiv \\log T \\mod \\Phi_n(p)</span>  by Lemma 2.4.</p>

    <p class="text-gray-300">The second part of the proof uses the same argument: the short vector output by the LLL algorithm is a linear combination of the rows of the matrix N. Each row represents either 0 or a  <span class="math">\\mathbb{F}_{p^d}</span> -multiple  <span class="math">T_j</span>  of T, hence the short vector is also a  <span class="math">\\mathbb{F}_{p^d}</span> -multiple of T. We conclude thanks to Lemma 2.4, that  <span class="math">\\log \\rho(P) \\equiv \\log T \\mod \\Phi_n(p)</span> .</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-1&quot;&gt;&lt;/span&gt;<strong>Proposition 6.2.</strong> The pseudonorm of P in Algorithm 5 has size</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-2&quot;&gt;&lt;/span&gt;(6.1)
<span class="math">$|\\operatorname{Res}_{y}(\\operatorname{Res}_{x}(P, f_{i}), h)| = O\\left(Q^{(1-\\frac{d}{n})\\frac{\\operatorname{deg} f_{i}}{\\operatorname{deg}_{x}P+1}} ||f_{i}||_{\\infty}^{n_{1}\\operatorname{deg}_{x}P}\\right)</span>$
assuming that  <span class="math">||h||_{\\infty} = O(1)</span> .</p>

    <p class="text-gray-300">Proof of Proposition 6.2. The matrix N computed in Algorithm 5 is a square matrix of  <span class="math">(\\deg_x P + 1)n_1</span>  rows and columns, whose coefficients are in  <span class="math">\\mathbb{F}_p</span> . Its determinant</p>

    <p class="text-gray-300">is det  <span class="math">N = p^{n-d} = Q^{1-d/n}</span> . Using the LLL algorithm for the lattice reduction, the coefficients of the shortest vector P are bounded by  <span class="math">CQ^{(1-d/n)/((\\deg_x P+1)n_1)}</span> , where C is the LLL factor. We obtain the bound (6.1) according to the bound formula (5.4), and neglecting the combinatorial factor  <span class="math">D(n_1, \\deg f_i)</span> . Moreover in the Tower-NFS setting, the polynomial selection is designed such that  <span class="math">||h||_{\\infty} = O(1)</span> .</p>

    <p class="text-gray-300">We finally obtain the following.</p>

    <p class="text-gray-300"><strong>Theorem 6.3.</strong> Let  <span class="math">GF(p^n)</span>  be a finite field, and let d be the largest divisor of n, d &lt; n, and d = 1 if n is prime. Let  <span class="math">n = n_1 n_2</span>  and  <span class="math">h, \\psi, f_i</span>  be given by a polynomial selection method. Let  <span class="math">T \\in \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  be an element which is not in a proper subfield of  <span class="math">\\mathbb{F}_{p^n}</span> . Then there exists a preimage  <span class="math">P \\in \\mathbb{Z}[x,y]</span>  of T, of any degree (in x) between  <span class="math">\\lfloor n_2 - d/n_1 \\rfloor</span>  and  <span class="math">\\deg f_i - 1</span> , of coefficients bounded by  <span class="math">O(Q^{(1-\\frac{d}{n})\\frac{1}{(\\deg P+1)n_1}})</span> , and such that when P is mapped in  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span>  as  <span class="math">\\rho(P)</span> , its discrete logarithm is equal to the discrete logarithm of T modulo  <span class="math">\\Phi_n(p)</span>  (and in particular modulo any prime divisor  <span class="math">\\ell</span>  of  <span class="math">\\Phi_n(p)</span> ), that is,</p>

    <p class="text-gray-300"><span class="math">$\\log \\rho(P) \\equiv \\log T \\bmod \\Phi_n(p) .</span>$</p>

    <p class="text-gray-300">The degree of P in x and the polynomial  <span class="math">f_i</span>  can be chosen to minimize the resultant (pseudonorm):</p>

    <p class="text-gray-300"><span class="math">$\\min_{i} \\min_{\\lfloor n_2 - d/n_1 \\rfloor \\leq \\deg_x P \\leq \\deg f_i - 1} \\|f_i\\|_{\\infty}^{n_1 \\deg_x P} Q^{(1 - \\frac{d}{n}) \\frac{\\deg f_i}{\\deg_x P + 1}}.</span>$</p>

    <p class="text-gray-300">We recall in Table 4 the degree and coefficient sizes of the polynomial selections published as of July 2017.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;<strong>Corollary 6.4.</strong> With the notation of Table 4 and the NFS setting corresponding to  <span class="math">n_2 = n</span>  and  <span class="math">n_1 = 1</span> ,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">(1) For the polynomial selection methods where there is a side i such that  <span class="math">||f_i||_{\\infty} = O(1)</span>  (GJL, Conjugation, Joux-Pierrot and Sarkar-Singh up to now), we do the initial splitting on this side and choose  <span class="math">\\deg_x P = \\deg_x f_i 1</span>  to obtain the smallest norm:  <span class="math">|\\operatorname{Res}_y(\\operatorname{Res}_x(P, f_i), h)| = O\\left(Q^{1-\\frac{d}{n}}\\right)</span> . We obtain the same bound for NFS and its tower variants.</p></li>
      <li><p class="text-gray-300">the same bound for NFS and its tower variants.</p>

    <p class="text-gray-300">(2) When  <span class="math">||f_i||_{\\infty} = Q^{1/(2n)}</span>  as for the JLSV&lt;sub&gt;1&lt;/sub&gt; method, the bound is  <span class="math">Q^{(1-\\frac{d}{n})\\frac{n_2}{\\deg_x P+1} + \\frac{\\deg_x P}{2n_2}}</span> . When  <span class="math">\\deg_x P = \\deg_x f_i 1 = n_2 1</span> , one obtains  <span class="math">Q^{\\frac{3}{2} \\frac{d}{n} \\frac{1}{2n_2}}</span> . In the NFS setting,  <span class="math">n_2 = n</span> , while in the tower setting,  <span class="math">n_2 &lt; n</span>  and the pseudonorm is slightly smaller.</p></li>
      <li><p class="text-gray-300">and the pseudonorm is slightly smaller.</p>

    <p class="text-gray-300">(3) When  <span class="math">||f_i||_{\\infty} = Q^{1/(n_1(D+1))}</span>  as for the JLSV&lt;sub&gt;2&lt;/sub&gt; method, the lower bound is  <span class="math">Q^{\\frac{\\deg_x P}{D+1} + (1-\\frac{d}{n})\\frac{n_2}{\\deg_x P+1}}</span>  on the  <span class="math">f_0</span> -side where  <span class="math">\\deg f_0 = n_2</span> , and it is  <span class="math">Q^{\\frac{\\deg_x P}{D+1} + (1-\\frac{d}{n})\\frac{D}{\\deg_x P+1}}</span>  on the  <span class="math">f_1</span> -side, where  <span class="math">\\deg f_1 = D \\ge n_2</span> . According to the value of n, one can decide which value of  <span class="math">\\deg_x P</span>  will produce a smaller norm.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;6.3. <strong>running time.</strong> To apply Lemma 5.4 to the initial splitting case, we make the usual heuristic assumption that the pseudonorms of the elements  <span class="math">g^tT_0</span>  behave asymptotically like random integers of the same size. Their size is  <span class="math">O(Q^e)</span> , so we replace  <span class="math">N^e</span>  by  <span class="math">Q^e</span> . The basis  <span class="math">\\{1, U, \\ldots, U^{d-1}\\}</span>  can be precomputed. The cost of computing the  <span class="math">U^iT</span>  for  <span class="math">0 \\le i \\le d-1</span>  is at most  <span class="math">dn^2</span>  multiplications in  <span class="math">\\mathbb{F}_p</span>  with a schoolbook multiplication algorithm. We can roughly upper-bound it by  <span class="math">O(n^3)</span> .</p></li>
    </ul>

    <p class="text-gray-300">&lt;span id=&quot;page-19-0&quot;&gt;&lt;/span&gt;Table 4. Properties: degree and coefficient size of the main polynomial selection methods for NFS-DL in FQ, where Q = p n.</p>

    <p class="text-gray-300">We give a bound on the coefficient size of the polynomials with the notation kfik&lt;sup&gt;∞&lt;/sup&gt; = O(x). To lighten the notation, we only write x, without O(). In the Joux–Pierrot method, the prime p can be written p = px(x0), where p&lt;sup&gt;x&lt;/sup&gt; is a polynomial of tiny coefficients and degree at least 2. This table takes into account</p>

    <p class="text-gray-300">the methods published until July 2017.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">method</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">deg h</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">deg f0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">deg f1</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">kf0k∞</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">kf1k∞</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">NFS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">JLSV1&lt;br&gt;[39]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">JLSV2&lt;br&gt;[39]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D &gt; n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(D+1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(D+1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GJL [53, 10, 12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D ≥ n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(D+1)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Conjugation [12]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/2n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Joux-Pierrot [41]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n(deg px)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n deg px)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">p = px(x0)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Sarkar-Singh [59]&lt;br&gt;n = n1n2, D ≥ n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(D + 1)n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Dn1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n1(D+1))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-NFS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">TNFS + base-m [14]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/D&lt;br&gt;p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1/D&lt;br&gt;p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-JLSV1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(2n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(2n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-JLSV2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D ≥ n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n1(D+1))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n1(D+1))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2&lt;br&gt;[44, 45]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-GJL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D + 1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">D ≥ n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n1(D+1))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2&lt;br&gt;[45]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-Conjugation</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(2n)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2&lt;br&gt;[11, 45, 46]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-Joux–Pierrot</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2, p = px(x0)&lt;br&gt;[45, 46]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2(deg px)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n deg px)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Tower-Sarkar–Singh</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n = n1n2n3, D ≥ n3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">n1</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(D + 1)n2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Dn2</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">log p</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Q1/(n1n2(D+1))</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[57, 60, 58]</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">The time needed to compute the reduced row-echelon form of a d × n matrix is in O(n 3 ) which is polynomial in n <a href="#page-26-14">[23]</a>. These two complexities are asymptotically negligible compared to any LQ[α &gt; 0]. We obtain the following.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-19-1&quot;&gt;&lt;/span&gt;Corollary 6.5. The running time of the initial splitting step with Algorithm <a href="#page-17-0">5</a> to find a B-smooth pseudonorm, where the pseudonorm has size O(Q&lt;sup&gt;e&lt;/sup&gt; ) for a fixed real number e &gt; 0 determined by the polynomial selection (Table <a href="#page-19-0">4</a>, two right-most columns), is</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) LQ[1/3, c = (3e) 1/3 ] with ECM to perform the smoothness tests;</li>
      <li>(2) LQ[1/3, c = (3e) 1/3 (23/27)&lt;sup&gt;2&lt;/sup&gt;/&lt;sup&gt;3&lt;/sup&gt; ] with ECM and EAS;</li>
      <li>(3) LQ[1/3, c = (3e) 1/3 ((15 + 4(2/3)&lt;sup&gt;3&lt;/sup&gt;&lt;sup&gt;k&lt;/sup&gt; )/19)&lt;sup&gt;2&lt;/sup&gt;/&lt;sup&gt;3&lt;/sup&gt; ] with ECM and k-EAS.</li>
    </ul>

    <p class="text-gray-300">For each case, the lower bound was obtained for B = LQ[2/3, e/c].</p>

    <p class="text-gray-300">Corollary 6.4 gives a bound on the size of the pseudonorms, from which we can deduce e to apply Corollary 6.5, and get the expected running time.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">7. Examples</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;<strong>Example 7.1.</strong> Let  <span class="math">p = \\lfloor 10^{25}\\pi \\rfloor + 7926 = 31415926535897932384634359</span>  be a 85-bit prime made of the first 26 decimals of  <span class="math">\\pi</span>  so that  <span class="math">\\mathbb{F}_{p^6}</span>  is a 509-bit finite field. Moreover,  <span class="math">\\Phi_6(p) = p^2 - p + 1</span>  is a 170-bit prime, we denote it by  <span class="math">\\ell = 986960440108935861883947021513080740536833738706523</span> . We want to compute discrete logarithms in the order- <span class="math">\\ell</span>  cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^6}</span> . The JLSV&lt;sub&gt;1&lt;/sub&gt; method computes two polynomials  <span class="math">f_0, f_1</span> , where  <span class="math">\\deg f_0 = \\deg f_1 = 6</span> , and  <span class="math">||f_i||_{\\infty} \\approx p^{1/2}</span> . In our example, we have  <span class="math">\\log_2 ||f_0||_{\\infty} = 44.67</span>  and  <span class="math">\\log_2 ||f_1||_{\\infty} = 46.67</span>  (and  <span class="math">\\log_2 p/2 = 42.35</span> ):</p>

    <pre><code class="language-text">f_0 = x^6 - 11209975711932 \\ x^5 - 28024939279845 \\ x^4 - 20 \\ x^3 \\\\ + 28024939279830 \\ x^2 + 11209975711938 \\ x + 1 \\\\ f_1 = 5604994576830 \\ x^6 + 20986447533158 \\ x^5 - 31608799819555 \\ x^4 \\\\ - 112099891536600 \\ x^3 - 52466118832895 \\ x^2 + 12643519927822 \\ x \\\\ + 5604994576830.
</code></pre>

    <p class="text-gray-300">Since  <span class="math">f_0</span>  is already of degree 6 and monic, it can define the extension  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_p[x]/(f_0(x))</span> . Let  <span class="math">T_0</span>  be our target in  <span class="math">\\mathbb{F}_{p^6}</span>  whose coefficients are made of the decimals of  <span class="math">\\pi</span>  (starting at the 26-th decimal, since the first 25 ones were already used for p):</p>

    <pre><code class="language-text">T_0 = 6427704988581508162162455 \\ x^5 + 16240052432693899613177738 \\ x^4 \\\\ + 4509390283780949909020139 \\ x^3 + 3868374359445757647591444 \\ x^2 \\\\ + 8209755913602112920808122 \\ x + 3279502884197169399375105.
</code></pre>

    <p class="text-gray-300">Let g = x + 3 be a generator of  <span class="math">\\mathbb{F}_{p^6}</span> . Let  <span class="math">(1, U, U^2)</span>  be a polynomial basis of  <span class="math">\\mathbb{F}_{p^3}</span>  considered as an implicit subfield of  <span class="math">\\mathbb{F}_{p^6}</span> , where  <span class="math">U = g^{1+p^3} = \\operatorname{Norm}_{\\mathbb{F}_{p^6}/\\mathbb{F}_{p^3}}(g)</span> . We run Algorithm 5 and find that the fourth preimage of  <span class="math">T = g^{812630}T_0</span>  gives a 61-smooth pseudonorm. We compute the reduced row-echelon form</p>

    <p class="text-gray-300"><span class="math">$M = \\begin{bmatrix} m_{00} &amp; m_{01} &amp; m_{02} &amp; 1 &amp; 0 &amp; 0 \\\\ m_{10} &amp; m_{11} &amp; m_{12} &amp; m_{13} &amp; 1 &amp; 0 \\\\ m_{20} &amp; m_{21} &amp; m_{22} &amp; m_{23} &amp; m_{24} &amp; 1 \\end{bmatrix} \\text{ of the matrix } \\begin{bmatrix} T \\\\ UT \\\\ U^2T \\end{bmatrix} \\ ,</span>$</p>

    <p class="text-gray-300">where</p>

    <pre><code class="language-text">\\begin{array}{lll} m_{00} = 30930778358987253373198053 &amp; m_{01} = 16172276732961477886471865, \\\\ m_{02} = 251875570676859576731124 &amp; m_{10} = 8981071706647180870633008, \\\\ m_{11} = 26297121233008662476505921 &amp; m_{12} = 4999545867425989707589927, \\\\ m_{13} = 4380553940470247124926451 &amp; m_{20} = 4787502941827866787698085, \\\\ m_{21} = 18855419729462744536987506 &amp; m_{22} = 15450347628775338768673252, \\\\ m_{23} = 31092163492444411597011243 &amp; m_{24} = 9824382756181109886988461. \\end{array}
</code></pre>

    <p class="text-gray-300">Then we reduce with the LLL algorithm the following lattice defined by the  <span class="math">(6 \\times 6)</span> -matrix, where  <span class="math">m_{ij}</span>  stands for the coefficient at row i and column j of the above</p>

    <p class="text-gray-300">matrix M, and  <span class="math">m_{i,3+i} = 1</span> :</p>

    <p class="text-gray-300"><span class="math">$N = \\begin{bmatrix} p &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; p &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; p &amp; 0 &amp; 0 &amp; 0 \\\\ m_{00} &amp; m_{01} &amp; m_{02} &amp; 1 &amp; 0 &amp; 0 \\\\ m_{10} &amp; m_{11} &amp; m_{12} &amp; m_{13} &amp; 1 &amp; 0 \\\\ m_{20} &amp; m_{21} &amp; m_{22} &amp; m_{23} &amp; m_{24} &amp; 1 \\end{bmatrix} .</span>$</p>

    <p class="text-gray-300">Each row of LLL(N) gives us a preimage  <span class="math">P \\in \\mathbb{Z}[x]</span>  of short coefficients such that  <span class="math">\\log_2 \\|P\\|_{\\infty} \\approx \\log_2 p/2 = 42.34</span>  bits and  <span class="math">\\log \\rho(P) \\equiv \\log T \\mod \\ell</span>  (in other words,  <span class="math">(T/\\rho(P))^{\\frac{p^6-1}{\\ell}} = 1</span> ). The fourth row has coefficients of at most 41.82 bits and gives</p>

    <p class="text-gray-300"><span class="math">$P = 482165402365 \\ x^5 + 3892831179802 \\ x^4 + 2694050932529 \\ x^3 + 2325450478817 \\ x^2 + 1117470283668 \\ x + 3688595236671 \\ .</span>$</p>

    <p class="text-gray-300">The pseudonorm of P w.r.t.  <span class="math">f_0</span>  is</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Res}(P, f_0) =</span></p>

    <p class="text-gray-300"><span class="math">32601551184187978602887820222780280368556791213406352787959859478882009 \\\\ 89411710052105812763285379877699363515358275429392312189582741360186561</span></p>

    <p class="text-gray-300">of 471 bits, which is very close to  <span class="math">\\log_2 Q^{11/12} = 466</span>  bits. Its factorization in prime ideals of  <span class="math">K_{f_0}</span>  is</p>

    <pre><code class="language-text"> \\begin{array}{l} \\langle 3,x+2\\rangle^3 \\langle 11,x+5\\rangle \\langle 17,x+4\\rangle \\langle 67,x+44\\rangle \\langle 2011,x+463\\rangle \\langle 501997,x+18312\\rangle \\\\ \\langle 340575947,x+27999767\\rangle \\langle 506032577,x+177467846\\rangle \\langle 604579099,x+309800481\\rangle \\\\ \\langle 1402910243559283,x+1034551157262971\\rangle \\\\ \\langle 1587503571970639,x+524543605465730\\rangle \\\\ \\langle 36834399852305717,x+24916507207930752\\rangle \\\\ \\langle 242270403627311729,x+170018299727614229\\rangle \\\\ \\langle 1070632553963863603,x+408232161861505290\\rangle \\\\ \\langle 4305864084909925127,x+3252872861595329896\\rangle. \\end{array}
</code></pre>

    <p class="text-gray-300">A common choice for the factor basis would be to set its smoothness bound to 30 or 32 bits. There are six prime ideals whose norm is larger than 30 bits, and that should be retreated to reach the factor basis. This initial splitting, testing all pseudonorms obtained for  <span class="math">g^iT_0</span> , i from 0 to 930000, that is,  <span class="math">5.58 \\cdot 10^6</span>  pseudonorms, with our Magma implementation, took 0.95 day on one node of 16 physical cores (32 virtual cores thanks to hyperthreading) Intel Xeon E5-2650 at 2.0GHz, that is, 15.2 core-days.</p>

    <p class="text-gray-300"><strong>Example 7.2</strong> (A more general example with NFS). Assume that n is even and let  <span class="math">T \\in \\mathbb{F}_{p^n}</span> . Compute a polynomial basis  <span class="math">(1, U, U^2, \\dots, U^{n/2-1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^{n/2}}</span> . Let</p>

    <p class="text-gray-300"><span class="math">$L = \\begin{bmatrix} T \\\\ UT \\\\ \\vdots \\\\ U^{n/2-1}T \\end{bmatrix} \\text{ and compute } M = \\begin{bmatrix} m_{1,1} &amp; \\dots &amp; m_{1,\\frac{n}{2}-1} &amp; 1 &amp; 0 &amp; \\dots &amp; 0 \\\\ \\vdots &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; \\vdots \\\\ \\vdots &amp; &amp; &amp; &amp; &amp; \\ddots &amp; \\ddots &amp; 0 \\\\ m_{\\frac{n}{2}} &amp; &amp; &amp; \\dots &amp; &amp; m_{\\frac{n}{2},\\frac{n}{2}-1} &amp; 1 \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">to be the reduced echelon form of L. Then we define the lower triangular matrix made of the  <span class="math">n/2 \\times n/2</span>  identity matrix with p on the diagonal in the upper left quarter, the  <span class="math">n/2 \\times n/2</span>  zero matrix in the upper right quarter, and the  <span class="math">n/2 \\times n</span>  matrix</p>

    <p class="text-gray-300">M in reduced echelon form in the lower half. Moreover, if  <span class="math">\\deg(f) &gt; n</span> , then we add  <span class="math">(\\deg f - n - 1)</span>  rows made of the coefficients of  <span class="math">x^i \\psi</span>  where  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_p[x]/(\\psi(x))</span> , for  <span class="math">0 \\le i &lt; \\deg f - n - 1</span> . Finally we apply the LLL algorithm to this matrix. The short vector gives us a preimage P whose pseudonorm is bounded by  <span class="math">Q^{1/2}</span> , with a polynomial selection such that  <span class="math">||f||_{\\infty} = O(1)</span>  (such as conjugation or GJL). Applying Lemma 5.4, we set the bound  <span class="math">B_1</span>  to be  <span class="math">B_1 = L_Q[2/3, ((1/2)^2/3)^{1/3} \\approx 0.436]</span> . The running time of Algorithm 5 will be  <span class="math">L_q[1/3, (3/2)^{1/3} \\approx 1.144]</span> . We obtain preimages P whose pseudonorm is bounded by  <span class="math">Q^{1-\\frac{1}{2n}}</span>  with the JLSV&lt;sub&gt;1&lt;/sub&gt; polynomial selection method as shown in Example 7.1. Applying Lemma 5.4, we set the bound  <span class="math">B_1</span>  to be  <span class="math">B_1 = L_Q[2/3, ((1-\\frac{1}{2n})^2/3)^{1/3}]</span> . The running time of Algorithm 5 will be  <span class="math">L_Q[1/3, (3(1-\\frac{1}{2n}))^{1/3}]</span> .</p>

    <h2 id="sec-9" class="text-2xl font-bold">8. Optimal representation: Monic Polynomial of Degree <span class="math">\\varphi(n)</span></h2>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;In Section 3, we exploited the largest proper subfield  <span class="math">\\mathbb{F}_{p^d}</span>  of  <span class="math">\\mathbb{F}_{p^n}</span>  to find an alternative representation of a given element  <span class="math">T \\in \\mathbb{F}_{p^n}</span> , with n-d nonzero coefficients, and d-1 coefficients (in  <span class="math">\\mathbb{F}_p</span> ) set to zero. The key ingredient was to compute an expression of the form P=uT, where P has d-1 coefficients set to zero, and  <span class="math">u \\in \\mathbb{F}_{p^d}</span> , so that we have the equality  <span class="math">(P/T)^{(p^n-1)/\\Phi_n(p)}=1</span> . We can generalize this strategy: given an element T in the cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^n}</span> , of order  <span class="math">\\Phi_n(p)</span> , we would like to compute an element  <span class="math">P \\in \\mathbb{F}_{p^n}</span>  such that  <span class="math">(P/T)^{(p^n-1)/\\Phi_n(p)}=1</span>  and P has only  <span class="math">\\varphi_n(p)=\\deg \\Phi_n(x)</span>  non-zero coefficients in  <span class="math">\\mathbb{F}_p</span> . To achieve that, we would like to compute an expression</p>

    <p class="text-gray-300"><span class="math">$T=u_1u_2\\dots u_iP,\\;\\; \\text{where each}\\; u_i \\; \\text{is in a proper subfield}\\; \\mathbb{F}_{p^{d_i}} \\; \\text{of}\\; \\mathbb{F}_{p^n} \\; .</span>$</p>

    <p class="text-gray-300">Given an element  <span class="math">T \\in \\mathbb{F}_{p^n}</span>  such that  <span class="math">T^{(p^n-1)/\\Phi_n(p)} \\neq 1</span>  (in other words, its order in the cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^n}</span>  is not zero), we can sometimes compute an element P with  <span class="math">\\varphi(n)</span>  non-zero coefficients, where  <span class="math">\\varphi(n)</span>  is the Euler totient function, plus a monic leading term. Since in Algorithm 5 we do not need a one-to-one correspondence between the given elements of the cyclotomic subgroup on one hand, and their representation with only  <span class="math">\\varphi(n)</span>  non-zero non-one coefficients on the other hand, we can just solve a system of equations even if we do not expect a solution at all times. If no such compact representation is found, one picks a new t and tests for the next  <span class="math">g^tT_0</span> . To define the system we need to solve, we list all the distinct subfields  <span class="math">\\mathbb{F}_{p^d}</span>  of  <span class="math">\\mathbb{F}_{p^n}</span>  that are not themselves contained in another proper subfield, compute a polynomial basis for each of them, and allow a degree of freedom for the coefficients to be  <span class="math">\\varphi(d)</span>  for each subfield  <span class="math">\\mathbb{F}_{p^d}</span> . If we consider the system as a Gröbner basis computation, it becomes very costly even for  <span class="math">\\mathbb{F}_{p^{30}}</span> , where we need to handle  <span class="math">n-\\varphi(n)-1=21</span>  variables. We give a numerical example for  <span class="math">\\mathbb{F}_{p^6}</span> .</p>

    <p class="text-gray-300">What we do is different than what is done in XTR and CEILIDH compact representations. In the XTR cryptosystem [50], the elements of the cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^6}</span>  are represented with an optimal normal basis over  <span class="math">\\mathbb{F}_{p^2}</span> , also in normal basis representation. Only their trace over  <span class="math">\\mathbb{F}_{p^2}</span>  is considered for representation, storage, and transmission. In [63, 62], the aim is to define a one-to-one correspondence between the elements in the torus of  <span class="math">\\mathbb{F}_{p^n}</span>  and the set of coefficients  <span class="math">(\\mathbb{F}_p)^{\\varphi(n)}</span> . This optimal compression was achieved for n=6 but not for n=30. These techniques are not compatible with the representation of the elements in the NFS algorithm: one chooses a representation by choosing two polynomials  <span class="math">f_0, f_1</span>  that define the two number fields involved in the algorithm. One cannot change the</p>

    <p class="text-gray-300">representation afterwards: the elements in the individual discrete logarithm phase should be represented in the same way as the elements of the factor basis.</p>

    <p class="text-gray-300">8.1. Compressed representation of elements in the cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^6}</span>  by a monic polynomial of degree 2. We consider the finite field  <span class="math">\\mathbb{F}_{p^6}</span> . We will use the two subfields  <span class="math">\\mathbb{F}_{p^2}</span>  and  <span class="math">\\mathbb{F}_{p^3}</span>  to cancel three coefficients. Let  <span class="math">U \\in \\mathbb{F}_{p^6}</span>  such that  <span class="math">(1, U, U^2)</span>  is a basis of  <span class="math">\\mathbb{F}_{p^3} \\subset \\mathbb{F}_{p^6}</span> . Let  <span class="math">V \\in \\mathbb{F}_{p^6}</span>  such that (1, V) is a basis of  <span class="math">\\mathbb{F}_{p^2} \\subset \\mathbb{F}_{p^6}</span> . We want to solve</p>

    <p class="text-gray-300"><span class="math">$uvwT = (u_0 + u_1U + u_2U^2)(v_0 + v_1V)wT = P,</span>$</p>

    <p class="text-gray-300">where  <span class="math">u=u_0+u_1U+u_2U^2\\in\\mathbb{F}_{p^3},\\ v=v_0+v_1V\\in\\mathbb{F}_{p^2},\\ w\\in\\mathbb{F}_p</span> , and  <span class="math">P\\in\\mathbb{F}_{p^6}</span>  is represented by a monic polynomial in x of degree 2. To simplify, we set  <span class="math">u_2=v_1=1</span>  so that we obtain equations where we can recursively eliminate the variables by computing resultants. We compute u,v,w such that uvwT=P, where  <span class="math">P=a_0+a_1x+x^2</span>  is monic of degree 2. We define the lattice</p>

    <p class="text-gray-300"><span class="math">$L = \\begin{bmatrix} p &amp; 0 &amp; 0 \\\\ 0 &amp; p &amp; 0 \\\\ a_0 &amp; a_1 &amp; 1 \\end{bmatrix} \\ .</span>$</p>

    <p class="text-gray-300">The determinant of L is  <span class="math">p^2</span>  hence  <span class="math">\\mathrm{LLL}(L)</span>  computes a short vector P of coefficient size bounded by  <span class="math">Cp^{2/3}</span> , where C is the LLL approximation factor (we can take  <span class="math">C\\approx 1</span>  in this practical case). The pseudonorm of P will be in the JLSV&lt;sub&gt;1&lt;/sub&gt; case  <span class="math">|\\mathrm{Res}(P,f)|\\approx \\|P\\|_{\\infty}^6 \\|f\\|_{\\infty}^2 = p^5 = Q^{5/6}</span> . This is better than the bound  <span class="math">Q^{11/12}</span>  obtained with the cubic subfield cofactor method. This specific method can be generalized to specific cases of finite fields where reducing as much as possible the degree of the target is the best strategy, as in Example 8.1. This technique was implemented in [33] for computing a new discrete logarithm record in  <span class="math">\\mathbb{F}_{p^6}</span>  of 422 bits.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;<strong>Example 8.1.</strong> We take the same finite field parameters as in Example 7.1, where  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_p[x]/(f(x))</span> . g = x + 3 is a generator of  <span class="math">\\mathbb{F}_{p^6}</span> .  <span class="math">(1, U, U^2)</span>  where  <span class="math">U = g^{1+p^3}</span>  is a basis of  <span class="math">\\mathbb{F}_{p^3}</span>  and (1, V) where  <span class="math">V = g^{1+p^2+p^4}</span>  is a basis of  <span class="math">\\mathbb{F}_{p^2}</span> . We solve the system  <span class="math">(u_0 + u_1 U + U^2)(v_0 + V)T = P</span>  where  <span class="math">u_i, v_i \\in \\mathbb{F}_p</span>  and P is monic and represented by a polynomial of degree 2 instead of 5. We ran Algorithm 5 with this modification on the same machine (Intel Xeon E5-2650 at 2.0GHz with hyperthreading turned on), from  <span class="math">g^0T_0</span>  to  <span class="math">g^{90000}T_0</span> . On average, the set of I candidates  <span class="math">g^iT_0</span>  led to six times more monic degree two polynomials  <span class="math">P_i</span> . We found that the third polynomial output for  <span class="math">T = g^{60928}T_0</span>  has a 64-bit-smooth pseudonorm. Testing the 90000  <span class="math">g^iT_0</span>  (that is,  <span class="math">2.7 \\cdot 10^5</span>  pseudonorms) took 1.2 core-day:</p>

    <pre><code class="language-text">u = 12307232765040677532260293 + 18116887363761988927417497 \\ U + U^2 \\ v = 30422514788629575495025401 + V
</code></pre>

    <p class="text-gray-300">w = 21470888563719305004900851</p>

    <p class="text-gray-300">P = uvwT</p>

    <p class="text-gray-300"><span class="math">= x^2 + 479190487430850236087613 \\ x + 6943966382910680737931850 \\ .</span></p>

    <p class="text-gray-300">We checked that  <span class="math">(P/T)^{\\frac{p^6-1}{\\ell}}=1</span> , meaning that  <span class="math">\\log_g P=\\log_g T=60928+\\log_g T_0</span> . Then we reduce the lattice defined by the matrix</p>

    <p class="text-gray-300"><span class="math">$\\begin{bmatrix} p &amp; 0 &amp; 0 \\\\ 0 &amp; p &amp; 0 \\\\ 6943966382910680737931850 &amp; 479190487430850236087613 &amp; 1 \\end{bmatrix}</span>$</p>

    <p class="text-gray-300">to get three polynomials of smaller coefficients, the third one being</p>

    <p class="text-gray-300"><span class="math">R = 107301402613441938 \\ x^2 - 32014642452727111 \\ x + 60125316588415598</span>  whose pseudonorm is</p>

    <pre><code class="language-text">\\begin{split} \\operatorname{Res}(R,f) &amp;= \\\\ 12474200655939339762647720853686893930822373172685245800138935320 \\\\ 22514918959041066623605301421497621878867497302294873400285994921 \\end{split}
</code></pre>

    <p class="text-gray-300">of 429 bits, which corresponds to the estimate  <span class="math">\\log_2 Q^{5/6}=423</span>  bits. We still have  <span class="math">\\log_g \\rho(P)\\equiv \\log_g T_0+60928 \\bmod \\ell</span> . The pseudonorm is 64-bit-smooth, and its factorization into prime ideals is</p>

    <pre><code class="language-text"> \\begin{array}{l} \\langle 11,x+8\\rangle\\langle 23,x+15\\rangle\\langle 12239,x+482\\rangle \\text{ (small)} \\\\ \\langle 1144616018827,x+218590032699\\rangle \\\\ \\langle 2682498999539,x+1582479651452\\rangle \\\\ \\langle 42175797334421,x+14828919302862\\rangle \\\\ \\langle 1195156519724071,x+966160984838340\\rangle \\\\ \\langle 13533793331200309,x+12224259030902272\\rangle \\\\ \\langle 92644276473186311,x+5754482791048201\\rangle \\\\ \\langle 101186915694167857,x+42826432866764905\\rangle \\\\ \\langle 20516170632026633467,x+14633926248916275064\\rangle \\ . \\end{array}
</code></pre>

    <p class="text-gray-300">The first three ideals are small enough to be in the factor basis, and eight ideals on side 0 remain to be descended.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Conclusion</h4>

    <p class="text-gray-300">The algorithms presented in this paper were implemented in Magma and used for cryptographic-size record computations. It was shown in [3] that combined with a practical variant of Joux's algorithm, our Algorithm 2 allows to compute a discrete logarithm in the finite field  <span class="math">\\mathbb{F}_{3^{6-709}}</span>  at the same cost as in  <span class="math">\\mathbb{F}_{3^{6-509}}</span>  with the previous state of the art. The large characteristic variant (Algorithm 5) was used in [33] for a 422-bit record computation in  <span class="math">\\mathbb{F}_{p^6}</span> . It would be interesting to be able to generalize it further, to be able to exploit at the same time several subfields, and provide a practical implementation of it for cryptographic sizes.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">ACKNOWLEDGMENTS</h3>

    <p class="text-gray-300">The author is grateful to Francisco Rodríguez-Henríquez, Frederik Vercauteren, Robert Granger and Thorsten Kleinjung, François Morain, Pierrick Gaudry, Laurent Grémy, Luca De Feo, and the other researchers who helped to improve this work. All these very fruitful discussions started at the ECC 2015 conference, the CATREL workshop and the Asiacrypt 2015 conference; in particular, the author would like to thank the anonymous reviewers of Asiacrypt 2015 who suggested a generalization.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">References</h3>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-13&quot;&gt;&lt;/span&gt;1. Gora Adj, Discrete logarithms in the cryptographically-interesting field GF(36∗509), Elliptic Curve Cryptography Conference (ECC), Invited talk, September 2016, slides available at <a href="http://ecc2016.yasar.edu.tr/slides/ecc2016-gora.pdf">http://ecc2016.yasar.edu.tr/slides/ecc2016-gora.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-11&quot;&gt;&lt;/span&gt;2. , Logaritmo discreto en campos finitos de caracter´ıstica peque˜na: atacando la criptogrf´ıa basada en emparejamientos de tipo 1, Phd thesis, Centro de Investigaci´on y de Estudios Avanzados del Instituto Polit´ecnico Nacional, Mexico, July 2016, <a href="http://delta.cs.cinvestav.mx/~francisco/Thesis_Gora_adj.pdf">http://delta.cs.cinvestav.</a> <a href="http://delta.cs.cinvestav.mx/~francisco/Thesis_Gora_adj.pdf">mx/~francisco/Thesis\\_Gora\\_adj.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-9&quot;&gt;&lt;/span&gt;3. Gora Adj, Isaac Canales-Mart´ınez, Nareli Cruz-Cort´es, Alfred Menezes, Thomaz Oliveira, Luis Rivera-Zamarripa, and Francisco Rodr´ıguez-Henr´ıquez, Computing discrete logarithms in cryptographically-interesting characteristic-three finite fields, Cryptology ePrint Archive, Report 2016/914, 2016, <a href="http://eprint.iacr.org/2016/914">http://eprint.iacr.org/2016/914</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-6&quot;&gt;&lt;/span&gt;4. Gora Adj, Isaac Canales-Martinez, Nareli Cruz-Cortes, Alfred Menezes, Thomaz Oliveira, Francisco Rodriguez-Henriquez, and Luis Rivera-Zamarripa, Discrete logarithms in GF(36∗509), Number Theory list, item 004923, July 18 2016, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;65bedfc8.1607">https://listserv.nodak.edu/cgi-bin/wa.</a> <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;65bedfc8.1607">exe?A2=NMBRTHRY;65bedfc8.1607</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-4&quot;&gt;&lt;/span&gt;5. Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodr´ıguez-Henr´ıquez, Computing discrete logarithms in &lt;sup&gt;F&lt;/sup&gt;36·&lt;sup&gt;137&lt;/sup&gt; and &lt;sup&gt;F&lt;/sup&gt;36·&lt;sup&gt;163&lt;/sup&gt; using Magma, Arithmetic of Finite Fields (WAIFI 2014) (C¸ etin Kaya Ko¸c, Sihem Mesnager, and Erkay Savas, eds.), LNCS, vol. 9061, Springer, Heidelberg, 2014, <a href="https://eprint.iacr.org/2014/057">https://eprint.iacr.org/2014/057</a>, pp. 3–22.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-10&quot;&gt;&lt;/span&gt;6. , Weakness of &lt;sup&gt;F&lt;/sup&gt;3&lt;sup&gt;6509&lt;/sup&gt; for discrete logarithm cryptography, PAIRING 2013 (Zhenfu Cao and Fangguo Zhang, eds.), LNCS, vol. 8365, Springer, Heidelberg, November 2014, pp. 20–44.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-5&quot;&gt;&lt;/span&gt;7. Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodr´ıguez-Henr´ıquez, Weakness of &lt;sup&gt;F&lt;/sup&gt;66·&lt;sup&gt;1429&lt;/sup&gt; and &lt;sup&gt;F&lt;/sup&gt;24·&lt;sup&gt;3041&lt;/sup&gt; for discrete logarithm cryptography, Finite Fields and Their Applications 32 (2015), 148–170.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-1&quot;&gt;&lt;/span&gt;8. Leonard Adleman, The function field sieve, Algorithmic Number Theory (ANTS-I) (Leonard M. Adleman and Ming-Deh Huang, eds.), LNCS, vol. 877, Springer, Heidelberg, 1994, pp. 141–154.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-2&quot;&gt;&lt;/span&gt;9. Leonard M. Adleman and Ming-Deh A. Huang, Function field sieve method for discrete logarithms over finite fields, Information and Computation 151 (1999), no. 1/2, 5–16, <a href="https://dl.acm.org/citation.cfm?id=305383.305385">https://</a> <a href="https://dl.acm.org/citation.cfm?id=305383.305385">dl.acm.org/citation.cfm?id=305383.305385</a>, <a href="https://doi.org/10.1006/inco.1998.2761">https://doi.org/10.1006/inco.1998.2761</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-14&quot;&gt;&lt;/span&gt;10. Razvan Barbulescu, Algorithmes de logarithmes discrets dans les corps finis, th\`ese de doctorat, Universit´e de Lorraine, Nancy, France, 2013, <a href="https://tel.archives-ouvertes.fr/tel-00925228">https://tel.archives-ouvertes.fr/</a> <a href="https://tel.archives-ouvertes.fr/tel-00925228">tel-00925228</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-16&quot;&gt;&lt;/span&gt;11. Razvan Barbulescu, An appendix for a recent paper of Kim, Cryptology ePrint Archive, Report 2015/1076, 2015, <a href="http://eprint.iacr.org/2015/1076">http://eprint.iacr.org/2015/1076</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-15&quot;&gt;&lt;/span&gt;12. Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and Fran¸cois Morain, Improving NFS for the discrete logarithm problem in non-prime finite fields, EUROCRYPT 2015, Part I (Elisabeth Oswald and Marc Fischlin, eds.), LNCS, vol. 9056, Springer, Heidelberg, April 2015, <a href="https://hal.inria.fr/hal-01112879v2">https://hal.inria.fr/hal-01112879v2</a>, pp. 129–155.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-3&quot;&gt;&lt;/span&gt;13. Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thom´e, A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic, EU-ROCRYPT 2014 (Phong Q. Nguyen and Elisabeth Oswald, eds.), LNCS, vol. 8441, Springer, Heidelberg, May 2014, pp. 1–16.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;14. Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung, The tower number field sieve, ASIACRYPT 2015, Part II (Tetsu Iwata and Jung Hee Cheon, eds.), LNCS, vol. 9453, Springer, Heidelberg, November / December 2015, pp. 31–55.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-7&quot;&gt;&lt;/span&gt;15. Ian F. Blake, Ryoh Fuji-Hara, Ronald C. Mullin, and Scott A. Vanstone, Computing logarithms in finite fields of characteristic two, SIAM Journal on Algebraic Discrete Methods 5 (1984), no. 2, 276–285, <a href="http://epubs.siam.org/doi/abs/10.1137/0605029">http://epubs.siam.org/doi/abs/10.1137/0605029</a>, <a href="https://doi.org/10.1137/0605029">https:</a> <a href="https://doi.org/10.1137/0605029">//doi.org/10.1137/0605029</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-8&quot;&gt;&lt;/span&gt;16. Ian F. Blake, Ronald C. Mullin, and Scott A. Vanstone, Computing logarithms in GF(2n), CRYPTO'84 (G. R. Blakley and David Chaum, eds.), LNCS, vol. 196, Springer, Heidelberg, August 1984, <a href="https://doi.org/10.1007/3-540-39568-7_8">https://doi.org/10.1007/3-540-39568-7\\_8</a>, pp. 73–82.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-25-12&quot;&gt;&lt;/span&gt;17. Isaac Andr´es Canales-Mart´ınez, Implementaci´on eficiente de prueba de suavidad para polinomios, Master thesis, Centro de Investigaci´on y de Estudios Avanzados del Instituto, Polit´ecnico Nacional, Departamento de Computaci´on, M´exico, Distrito Federal, Diciembre 2015, <a href="http://delta.cs.cinvestav.mx/~francisco/Thesis_IAC.pdf">http://delta.cs.cinvestav.mx/~francisco/Thesis\\_IAC.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-12&quot;&gt;&lt;/span&gt;18. An Commeine and Igor Semaev, An algorithm to solve the discrete logarithm problem with the number field sieve, PKC 2006 (Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, eds.), LNCS, vol. 3958, Springer, Heidelberg, April 2006, pp. 174–190.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-11&quot;&gt;&lt;/span&gt;19. Don Coppersmith, Andrew M. Odlyzko, and Richard Schroeppel, Discrete logarithms in GF(p), Algorithmica 1 (1986), no. 1, 1–15, <a href="https://dl.acm.org/citation.cfm?id=6835">https://dl.acm.org/citation.cfm?id=6835</a>, <a href="https://doi.org/10.1007/BF01840433">https://</a> <a href="https://doi.org/10.1007/BF01840433">doi.org/10.1007/BF01840433</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-18&quot;&gt;&lt;/span&gt;20. Romain Cosset, Applications of theta functions for hyperelliptic curve cryptography, Th\`ese de doctorat, Universit´e Henri Poincar´e - Nancy I, Nancy, France, November 2011, <a href="https://tel.archives-ouvertes.fr/tel-00642951">https:</a> <a href="https://tel.archives-ouvertes.fr/tel-00642951">//tel.archives-ouvertes.fr/tel-00642951</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;21. Whitfield Diffie and Martin E. Hellman, New directions in cryptography, IEEE Transactions on Information Theory 22 (1976), no. 6, 644–654.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-16&quot;&gt;&lt;/span&gt;22. Michael Drmota and Daniel Panario, A rigorous proof of the Waterloo algorithm for the discrete logarithm problem, Designs, Codes and Cryptography 26 (2002), no. 1, 229–241.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-14&quot;&gt;&lt;/span&gt;23. Jean-Guillaume Dumas and Clement Pernet, Handbook of finite fields, ch. Computational linear algebra over finite fields, pp. 520–535, CRC Press Taylor &amp; Francis Group, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-15&quot;&gt;&lt;/span&gt;24. P. Flajolet, X. Gourdon, and D. Panario, The complete analysis of a polynomial factorization algorithm over finite fields, Journal of Algorithms 40 (2001), 37–81, <a href="http://algo.inria.fr/flajolet/Publications/FlGoPa01.pdf">http://algo.inria.fr/</a> <a href="http://algo.inria.fr/flajolet/Publications/FlGoPa01.pdf">flajolet/Publications/FlGoPa01.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-3&quot;&gt;&lt;/span&gt;25. Joshua Fried, Pierrick Gaudry, Nadia Heninger, and Emmanuel Thom´e, A kilobit hidden SNFS discrete logarithm computation, EUROCRYPT 2017, Part I (Jean-S´ebastien Coron and Jesper Buus Nielsen, eds.), LNCS, vol. 10210, Springer, Heidelberg, April / May 2017, pp. 202–231.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-5&quot;&gt;&lt;/span&gt;26. Faruk G¨ologlu, Robert Granger, Gary McGuire, and Jens Z¨umbragel, Discrete logarithms in GF(26120), Number Theory list, April 11 2013, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;fe9605d9.1304">https://listserv.nodak.edu/cgi-bin/wa.</a> <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;fe9605d9.1304">exe?A2=NMBRTHRY;fe9605d9.1304</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-1&quot;&gt;&lt;/span&gt;27. Daniel M. Gordon, Discrete logarithms in GF(p) using the number field sieve, SIAM Journal on Discrete Mathematics 6 (1993), no. 1, 124–138, <a href="https://www.ccrwest.org/gordon/log.pdf">https://www.ccrwest.org/gordon/log.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-17&quot;&gt;&lt;/span&gt;28. Robert Granger, Philipp Jovanovic, Bart Mennink, and Samuel Neves, Improved masking for tweakable blockciphers with applications to authenticated encryption, EUROCRYPT 2016, Part I (Marc Fischlin and Jean-S´ebastien Coron, eds.), LNCS, vol. 9665, Springer, Heidelberg, May 2016, pp. 263–293.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-4&quot;&gt;&lt;/span&gt;29. Robert Granger, Thorsten Kleinjung, and Jens Zumbr¨agel, Breaking '128-bit secure' supersingular binary curves - (or how to solve discrete logarithms in &lt;sup&gt;F&lt;/sup&gt;24·&lt;sup&gt;1223&lt;/sup&gt; and &lt;sup&gt;F&lt;/sup&gt;212·&lt;sup&gt;367&lt;/sup&gt; ), CRYPTO 2014, Part II (Juan A. Garay and Rosario Gennaro, eds.), LNCS, vol. 8617, Springer, Heidelberg, August 2014, <a href="http://eprint.iacr.org/2014/119">http://eprint.iacr.org/2014/119</a>, pp. 126–145.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-10&quot;&gt;&lt;/span&gt;30. Robert Granger, Thorsten Kleinjung, and Jens Zumbragel, Discrete logarithms in GF(29234), Number Theory list, item 004666, January 31 2014, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;9aa2b043.1401">https://listserv.nodak.edu/cgi-bin/</a> <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;9aa2b043.1401">wa.exe?A2=NMBRTHRY;9aa2b043.1401</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-9&quot;&gt;&lt;/span&gt;31. , Discrete logarithms in the Jacobian of a genus 2 supersingular curve over GF(2367) (dl in GF(24404)), Number Theory list, item 004665, January 30 2014, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;23651c2.1401">https://listserv.</a> <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;23651c2.1401">nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;23651c2.1401</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-8&quot;&gt;&lt;/span&gt;32. Robert Granger, Thorsten Kleinjung, and Jens Zumbr¨agel, On the powers of 2, Cryptology ePrint Archive, Report 2014/300, 2014, <a href="http://eprint.iacr.org/2014/300">http://eprint.iacr.org/2014/300</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-19&quot;&gt;&lt;/span&gt;33. Laurent Gr´emy, Aurore Guillevic, Fran¸cois Morain, and Emmanuel Thom´e, Computing discrete logarithms in &lt;sup&gt;F&lt;/sup&gt;p&lt;sup&gt;6&lt;/sup&gt; , SAC 2017 (Carlisle Adams and Jan Camenisch, eds.), LNCS, vol. 10719, Springer, Heidelberg, August 2017, pp. 85–105.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-13&quot;&gt;&lt;/span&gt;34. Aurore Guillevic, Computing individual discrete logarithms faster in GF(p &lt;sup&gt;n&lt;/sup&gt;) with the NFS-DL algorithm, ASIACRYPT 2015, Part I (Tetsu Iwata and Jung Hee Cheon, eds.), LNCS, vol. 9452, Springer, Heidelberg, November / December 2015, pp. 149–173.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-6&quot;&gt;&lt;/span&gt;35. Antoine Joux, Discrete logarithms in GF(26168) = GF((2257) &lt;sup&gt;24&lt;/sup&gt;), Number Theory list, May 21 2013, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;49bb494e.1305">https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;49bb494e.1305</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-7&quot;&gt;&lt;/span&gt;36. , A new index calculus algorithm with complexity L(1/4 + o(1)) in small characteristic, SAC 2013 (Tanja Lange, Kristin Lauter, and Petr Lisonek, eds.), LNCS, vol. 8282, Springer, Heidelberg, August 2014, pp. 355–379.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-26-2&quot;&gt;&lt;/span&gt;37. Antoine Joux and Reynald Lercier, The function field sieve is quite special, Algorithmic Number Theory (ANTS-V) (Claus Fieker and David R. Kohel, eds.), LNCS, vol. 2369, Springer, Heidelberg, 2002, <a href="https://perso.univ-rennes1.fr/reynald.lercier/file/JL02.pdf">https://perso.univ-rennes1.fr/reynald.lercier/file/JL02.</a> <a href="https://perso.univ-rennes1.fr/reynald.lercier/file/JL02.pdf">pdf</a>, pp. 431–445.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-5&quot;&gt;&lt;/span&gt;38. , Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the Gaussian integer method, Math. Comp. 72 (2003), no. 242, 953–967, <a href="http://www.ams.org/journals/mcom/2003-72-242/S0025-5718-02-01482-5">http://www.ams.org/journals/mcom/2003-72-242/S0025-5718-02-01482-5</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-6&quot;&gt;&lt;/span&gt;39. Antoine Joux, Reynald Lercier, Nigel Smart, and Frederik Vercauteren, The number field sieve in the medium prime case, CRYPTO 2006 (Cynthia Dwork, ed.), LNCS, vol. 4117, Springer, Heidelberg, August 2006, <a href="https://www.iacr.org/archive/crypto2006/41170323/41170323.pdf">https://www.iacr.org/archive/crypto2006/41170323/</a> <a href="https://www.iacr.org/archive/crypto2006/41170323/41170323.pdf">41170323.pdf</a>, pp. 326–344.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-9&quot;&gt;&lt;/span&gt;40. Antoine Joux and C´ecile Pierrot, Improving the polynomial time precomputation of frobenius representation discrete logarithm algorithms - simplified setting for small characteristic finite fields, ASIACRYPT 2014, Part I (Palash Sarkar and Tetsu Iwata, eds.), LNCS, vol. 8873, Springer, Heidelberg, December 2014, pp. 378–397.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-16&quot;&gt;&lt;/span&gt;41. , The special number field sieve in Fp&lt;sup&gt;n&lt;/sup&gt; - application to pairing-friendly constructions, PAIRING 2013 (Zhenfu Cao and Fangguo Zhang, eds.), LNCS, vol. 8365, Springer, Heidelberg, November 2014, pp. 45–61.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-3&quot;&gt;&lt;/span&gt;42. Antoine Joux and C´ecile Pierrot, Discrete logarithm record in characteristic 3, GF(35·479) a 3796-bit field, Number Theory list, item 004745, September 15 2014, <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;1ff78abb.1409">https://listserv.nodak.</a> <a href="https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;1ff78abb.1409">edu/cgi-bin/wa.exe?A2=NMBRTHRY;1ff78abb.1409</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-14&quot;&gt;&lt;/span&gt;43. Michael Kalkbrener, An upper bound on the number of monomials in determinants of sparse matrices with symbolic entries, Mathematica Pannonica 8 (1997), 73–82, <a href="http://kalkbrener.at/Selected_publications_files/Kalkbrener97b.pdf">http://kalkbrener.</a> <a href="http://kalkbrener.at/Selected_publications_files/Kalkbrener97b.pdf">at/Selected\\_publications\\_files/Kalkbrener97b.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-17&quot;&gt;&lt;/span&gt;44. Taechan Kim, Extended tower number field sieve: A new complexity for medium prime case, Cryptology ePrint Archive, Report 2015/1027, 2015, <a href="http://eprint.iacr.org/2015/1027">http://eprint.iacr.org/2015/1027</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-1&quot;&gt;&lt;/span&gt;45. Taechan Kim and Razvan Barbulescu, Extended tower number field sieve: A new complexity for the medium prime case, CRYPTO 2016, Part I (Matthew Robshaw and Jonathan Katz, eds.), LNCS, vol. 9814, Springer, Heidelberg, August 2016, pp. 543–571.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-2&quot;&gt;&lt;/span&gt;46. Taechan Kim and Jinhyuck Jeong, Extended tower number field sieve with application to finite fields of arbitrary composite extension degree, PKC 2017, Part I (Serge Fehr, ed.), LNCS, vol. 10174, Springer, Heidelberg, March 2017, pp. 388–408.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;47. Thorsten Kleinjung, Claus Diem, Arjen K. Lenstra, Christine Priplata, and Colin Stahlke, Computation of a 768-bit prime field discrete logarithm, EUROCRYPT 2017, Part I (Jean-S´ebastien Coron and Jesper Buus Nielsen, eds.), LNCS, vol. 10210, Springer, Heidelberg, April / May 2017, pp. 185–201.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-4&quot;&gt;&lt;/span&gt;48. Brian A. LaMacchia and Andrew M. Odlyzko, Computation of discrete logarithms in prime fields, Des. Codes Cryptography 1 (1991), no. 1, 47–62, <a href="https://doi.org/10.1007/BF00123958">https://doi.org/10.1007/BF00123958</a>, &lt;www.dtc.umn.edu/~odlyzko/doc/arch/prime.discrete.logs.pdf&gt;.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-13&quot;&gt;&lt;/span&gt;49. A.K. Lenstra, Jr. Lenstra, H.W., and L. Lov´asz, Factoring polynomials with rational coefficients, Mathematische Annalen 261 (1982), no. 4, 515–534 (English), <a href="https://ir.cwi.nl/pub/9304/9304A.pdf">https://ir.cwi.nl/pub/9304/</a> <a href="https://ir.cwi.nl/pub/9304/9304A.pdf">9304A.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-18&quot;&gt;&lt;/span&gt;50. Arjen K. Lenstra and Eric R. Verheul, The XTR public key system, CRYPTO 2000 (Mihir Bellare, ed.), LNCS, vol. 1880, Springer, Heidelberg, August 2000, pp. 1–19.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-11&quot;&gt;&lt;/span&gt;51. H. W. Lenstra, Jr., J. Pila, and C. Pomerance, A hyperelliptic smoothness test, I, Philos. Trans. Roy. Soc. London Ser. A 345 (1993), 397–408, <a href="https://math.dartmouth.edu/~carlp/hyperI.pdf">https://math.dartmouth.edu/~carlp/hyperI.</a> <a href="https://math.dartmouth.edu/~carlp/hyperI.pdf">pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-12&quot;&gt;&lt;/span&gt;52. , A hyperelliptic smoothness test. II, Proc. London Math. Soc. 84 (2002), no. 3, 105–146, <a href="https://math.dartmouth.edu/~carlp/PDF/paper129.pdf">https://math.dartmouth.edu/~carlp/PDF/paper129.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-15&quot;&gt;&lt;/span&gt;53. D. Matyukhin, Effective version of the number field sieve for discrete logarithms in the field GF(p &lt;sup&gt;k&lt;/sup&gt;) (in Russian), Trudy po Discretnoi Matematike 9 (2006), 121–151, <a href="http://m.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=tdm&paperid=144&option_lang=eng">http://m.mathnet.</a> <a href="http://m.mathnet.ru/php/archive.phtml?wshow=paper&jrnid=tdm&paperid=144&option_lang=eng">ru/php/archive.phtml?wshow=paper&amp;jrnid=tdm&amp;paperid=144&amp;option\\_lang=eng</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-8&quot;&gt;&lt;/span&gt;54. Andrew M. Odlyzko, Discrete logarithms in finite fields and their cryptographic significance, EUROCRYPT'84 (Thomas Beth, Norbert Cot, and Ingemar Ingemarsson, eds.), LNCS, vol. 209, Springer, Heidelberg, April 1985, <a href="https://doi.org/10.1007/3-540-39757-4_20">https://doi.org/10.1007/3-540-39757-4\\_20</a>, <a href="http://www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf">http:</a> <a href="http://www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf">//www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf</a>, pp. 224–314.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-10&quot;&gt;&lt;/span&gt;55. C. Pomerance, Analysis and comparison of some integer factoring algorithms, Computational methods in number theory, part I (H. W. Jr Lenstra and R. Tijdeman, eds.), Mathematical Centre Tracts, vol. 154, Mathematisch Centrum, Amsterdam, 1982, <a href="http://oai.cwi.nl/oai/asset/19571/19571A.pdf">http://oai.cwi.nl/oai/</a> <a href="http://oai.cwi.nl/oai/asset/19571/19571A.pdf">asset/19571/19571A.pdf</a>, pp. 89–139.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-27-7&quot;&gt;&lt;/span&gt;56. Francisco Rodr´ıguez-Henr´ıquez, Another initial splitting in small characteristic finite fields, Personal communication, November 30, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-3&quot;&gt;&lt;/span&gt;57. Palash Sarkar and Shashank Singh, A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm, ASIACRYPT 2016, Part I (Jung Hee Cheon and Tsuyoshi Takagi, eds.), LNCS, vol. 10031, Springer, Heidelberg, December 2016, pp. 37–62.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-5&quot;&gt;&lt;/span&gt;58. , A generalisation of the conjugation method for polynomial selection for the extended tower number field sieve algorithm, Cryptology ePrint Archive, Report 2016/537, 2016, <a href="http://eprint.iacr.org/">http:</a> <a href="http://eprint.iacr.org/">//eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-2&quot;&gt;&lt;/span&gt;59. , New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields, EUROCRYPT 2016, Part I (Marc Fischlin and Jean-S´ebastien Coron, eds.), LNCS, vol. 9665, Springer, Heidelberg, May 2016, <a href="https://eprint.iacr.org/2015/944">https://eprint.iacr.org/2015/944</a>, pp. 429–458.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-4&quot;&gt;&lt;/span&gt;60. , Tower number field sieve variant of a recent polynomial selection method, Cryptology ePrint Archive, Report 2016/401, 2016, <a href="http://eprint.iacr.org/">http://eprint.iacr.org/</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;61. O. Schirokauer, Discrete logarithms and local units, Philos. Trans. Roy. Soc. London Ser. A 345 (1993), no. 1676, 409–423, <a href="http://rsta.royalsocietypublishing.org/content/345/1676/409">http://rsta.royalsocietypublishing.org/content/345/</a> <a href="http://rsta.royalsocietypublishing.org/content/345/1676/409">1676/409</a>, <a href="http://doi.org/10.1098/rsta.1993.0139">http://doi.org/10.1098/rsta.1993.0139</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-7&quot;&gt;&lt;/span&gt;62. Marten van Dijk, Robert Granger, Dan Page, Karl Rubin, Alice Silverberg, Martijn Stam, and David P. Woodruff, Practical cryptography in high dimensional tori, EUROCRYPT 2005 (Ronald Cramer, ed.), LNCS, vol. 3494, Springer, Heidelberg, May 2005, pp. 234–250.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-6&quot;&gt;&lt;/span&gt;63. Marten van Dijk and David P. Woodruff, Asymptotically optimal communication for torusbased cryptography, CRYPTO 2004 (Matthew Franklin, ed.), LNCS, vol. 3152, Springer, Heidelberg, August 2004, pp. 157–178.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;64. Yuqing Zhu, Jincheng Zhuang, Chang Lv, and Dongdai Lin, Improvements on the individual logarithm step in extended tower number field sieve, Cryptology ePrint Archive, Report 2016/727, 2016, <a href="http://eprint.iacr.org/2016/727">http://eprint.iacr.org/2016/727</a>.</p></li>
    </ul>

    <p class="text-gray-300">Inria Nancy–Grand Est, Equipe Caramba, 615 rue du jardin botanique, CS 20101, ´ 54603 Villers-les-Nancy Cedex, France \`</p>

    <p class="text-gray-300">E-mail address: aurore.guillevic@inria.fr URL: <a href="https://members.loria.fr/AGuillevic">https://members.loria.fr/AGuillevic</a></p>

`;
---

<BaseLayout title="FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS OF CO... (2016/684)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/684
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="faster-individual-discrete-logarithms-in-finite-fields-of-2016" />
  </article>
</BaseLayout>
