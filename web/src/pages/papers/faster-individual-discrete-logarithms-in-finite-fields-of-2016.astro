---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/684';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Faster individual discrete logarithms in finite fields of composite extension degree';
const AUTHORS_HTML = 'Aurore Guillevic';

const CONTENT = `    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS OF COMPOSITE EXTENSION DEGREE</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300">ABSTRACT. Computing discrete logarithms in finite fields is a main concern in cryptography. The best algorithms in large and medium characteristic fields (e.g.,  <span class="math">\\mathrm{GF}(p^2)</span> ,  <span class="math">\\mathrm{GF}(p^{12})</span> ) are the Number Field Sieve and its variants (special, high-degree, tower). The best algorithms in small characteristic finite fields (e.g.,  <span class="math">\\mathrm{GF}(3^{6-509})</span> ) are the Function Field Sieve, Joux's algorithm, and the quasipolynomial-time algorithm. The last step of this family of algorithms is the individual logarithm computation. It computes a smooth decomposition of a given target in two phases: an initial splitting, then a descent tree. While new improvements have been made to reduce the complexity of the dominating relation collection and linear algebra steps, resulting in a smaller factor basis (database of known logarithms of small elements), the last step remains at the same level of difficulty. Indeed, we have to find a smooth decomposition of a typically large element in the finite field. This work improves the initial splitting phase and applies to any nonprime finite field. It is very efficient when the extension degree is composite. It exploits the proper subfields, resulting in a much more smooth decomposition of the target. This leads to a new trade-off between the initial splitting step and the descent step in small characteristic. Moreover it reduces the width and the height of the subsequent descent tree.</p>

    <p class="text-gray-300">This work is interested in improving the last step of discrete logarithm (DL) computations in nonprime finite fields. The discrete logarithm instances that we target come from Diffie-Hellman (DH) [21] key-exchange, or from pairing-based cryptography. In the latter case, the security relies on the hardness of computing discrete logarithms in two groups: the group of points of a particular elliptic curve defined over a finite field, and a small extension of this finite field (in most of the cases of degree 2, 3, 4, 6, or 12).</p>

    <p class="text-gray-300">The finite fields fall in three groups: small, medium and large characteristic finite fields, corresponding to the respective size of the characteristic  <span class="math">p</span>  compared to the total size  <span class="math">Q = p^n</span>  of the finite field. This is formalized with the  <span class="math">L</span>  notation:</p>

    <div class="my-4 text-center"><span class="math-block">(1.1) \\quad L _ {Q} [ \\alpha , c ] = e ^ {(c + o (1)) (\\log Q) ^ {\\alpha} (\\log \\log Q) ^ {1 - \\alpha}}, \\mathrm {w h e r e} Q = p ^ {n}, \\alpha \\in [ 0, 1 ], c \\neq 0.</span></div>

    <p class="text-gray-300">Date: September 16, 2018. This document is the author's version. First published in Mathematics of Computation, 2018, published by the American Mathematical Society. ©2018 American Mathematical Society. Publisher's version available online September 6, 2018, at https://doi.org/10.1090/mcom/3376. See http://www.ams.org/publications/authors/ctp about AMS copyright.</p>

    <p class="text-gray-300">2010 Mathematics Subject Classification. Primary 11T71: Cryptography.</p>

    <p class="text-gray-300">Key words and phrases. Finite field, discrete logarithm, number field sieve, function field sieve, individual logarithm.</p>

    <p class="text-gray-300">Small, medium and large characteristic correspond to <span class="math">\\alpha&lt;1/3</span>, <span class="math">1/3&lt;\\alpha&lt;2/3</span>, and <span class="math">\\alpha&gt;2/3</span> respectively. The boundary cases are <span class="math">\\alpha=1/3</span> and <span class="math">\\alpha=2/3</span>. In large characteristic, that is <span class="math">p=L_{Q}[\\alpha,c]</span> where <span class="math">\\alpha&gt;2/3</span>, the Number Field Sieve (NFS) <em>[27, 61, 37]</em> provides the best expected running time: in <span class="math">L_{Q}[1/3,(64/9)^{1/3}\\approx 1.923]</span> and was used in the latest record computations in a 768-bit prime field <em>[47]</em>. Its special variant in expected running time <span class="math">L_{Q}[1/3,(32/9)^{1/3}\\approx 1.526]</span> was used to break a 1024-bit trapdoored prime field <em>[25]</em>. In 2015 and 2016, the Tower-NFS construction of Schirokauer was revisited for prime fields <em>[14]</em>, then Kim, Barbulescu and Jeong improved it for nonprime finite fields <span class="math">\\mathbb{F}_{p^{n}}</span> where the extension degree <span class="math">n</span> is composite <em>[45, 46]</em>, and used the name Extended TNFS algorithm. To avoid a confusion due to the profusion of names denoting variants of the same algorithm, in this paper we will use TNFS as a generic term to denote the family of all the variants of NFS that use a tower of number fields. Small characteristic means <span class="math">p=L_{Q}[\\alpha,c]</span> where <span class="math">\\alpha&lt;1/3</span>. The first <span class="math">L[1/3]</span> algorithm was proposed by Coppersmith, and generalized as the Function Field Sieve <em>[8, 9]</em>.</p>

    <p class="text-gray-300">The NFS and FFS algorithms are made of four phases: polynomial selection (two polynomials are chosen), relation collection where relations between small elements are obtained, linear algebra (computing the kernel of a huge sparse matrix over an auxiliary large prime finite field), and individual discrete logarithm computation. In this work, we improve this last step. All the improvements of NFS, FFS, and related variants since the 90’s decrease the size of the factor basis, that is, the database of known discrete logarithms of <em>small</em> elements obtained after the linear algebra step, <em>small</em> meaning an element represented by a polynomial of small degree (FFS), resp., an element whose pseudonorm is small (NFS). The effort required in the individual discrete logarithm step increases: one needs to find a decomposition of a given target into <em>small</em> elements, to be able to express its discrete logarithm in terms of already known logarithms of elements in the factor basis, while the factor basis has decreased at each major improvement. In characteristic 2 and 3 where the extension degree is composite, obtaining the discrete logarithms of the factor basis elements can be done in polynomial time. The individual discrete logarithm is the most costly part, in quasi-polynomial -time in the most favorable cases <em>[13, 29]</em>. In practice, the record computations <em>[26, 35, 5, 7, 42, 4]</em> implement hybrid algorithms made of Joux’s <span class="math">L[1/4]</span> algorithm <em>[36]</em>, and the individual discrete logarithm is computed with a continued fraction descent, then a classical descent, a QPA descent, and a Gröbner basis descent, or a <em>powers-of-two</em> descent algorithm (a.k.a. zig-zag descent) <em>[32, 31, 30]</em>.</p>

    <p class="text-gray-300">The heart of this paper relies on the following two observations. Firstly, to speed up the individual discrete logarithm phase, we start by speeding up the initial splitting step, and for that we compute a representation of a preimage of the given target of smaller degree, and/or whose coefficients are smaller. It will improve its smoothness probability. Secondly, to compute this preimage of smaller degree, we exploit the proper subfields of the finite field <span class="math">\\mathrm{GF}(p^{n})</span>, and intensively use this key-ingredient: since we are computing discrete logarithms modulo (a prime divisor of) <span class="math">\\Phi_{n}(p)</span>, we can freely multiply or divide the target by any element in a proper subfield without affecting its discrete logarithm modulo <span class="math">\\Phi_{n}(p)</span>.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">Organization of the paper</h3>

    <p class="text-gray-300">The background needed is presented as preliminaries in Section 2. We present our generic strategy to lower the degree of the polynomial representing a given element in <span class="math">\\mathrm{GF}(p^{n})</span> in Section 3. We apply it to characteristic</p>

    <p class="text-gray-300">two and three in Section 4. Preliminaries before the large characteristic case are given in Section 5. We apply our technique to medium and large characteristic finite fields, that is the NFS case and its tower variant in Section 6, and provide examples of cryptographic size in Section 7. Finally in Section 8 we present a more advanced strategy, to exploit several subfields at a time, and we apply it to <span class="math">\\mathbb{F}_{p^{6}}</span>.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2. Preliminaries</h2>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">2.1. Setting</h3>

    <p class="text-gray-300">In this paper, we are interested in nonprime finite fields <span class="math">\\mathrm{GF}(p^{n})</span>, <span class="math">n&gt;1</span>. To keep the same notation between small, medium, and large characteristic finite fields, we assume that the field <span class="math">\\mathbb{F}_{p^{n}}</span> is defined by an extension of degree <span class="math">n_{2}</span> above an extension of degree <span class="math">n_{1}</span>, that is, <span class="math">\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span>, and <span class="math">n=n_{1}n_{2}</span>. The elements are of the form <span class="math">T=\\sum_{i=0}^{n_{2}-1}\\sum_{j=0}^{n_{1}-1}a_{ij}y^{j}x^{i}</span>, where the coefficients <span class="math">a_{ij}</span> are in <span class="math">\\mathbb{F}_{p}</span>, the coefficients <span class="math">a_{i}=\\sum_{j=0}^{n_{1}-1}a_{ij}y^{j}</span> are in <span class="math">\\mathbb{F}_{p^{n_{1}}}=\\mathbb{F}_{p}[y]/(h(y))</span>, and <span class="math">\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}=\\mathbb{F}_{p^{n_{1}}}[x]/(\\psi(x))</span>, where <span class="math">h</span> is a monic irreducible polynomial of <span class="math">\\mathbb{F}_{p}[y]</span> of degree <span class="math">n_{1}</span> and <span class="math">\\psi</span> is a monic irreducible polynomial of <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span> of degree <span class="math">n_{2}</span>. In other words, <span class="math">T</span> is represented as a polynomial of degree <span class="math">n_{2}-1</span> in the variable <span class="math">x</span>, and has coefficients <span class="math">a_{i}\\in\\mathbb{F}_{p^{n_{1}}}</span>. For the FFS and NFS algorithms, <span class="math">n_{1}=1</span> and <span class="math">n_{2}=n</span>; for finite fields from pairing constructions, <span class="math">n_{2}&gt;1</span> is a strict divisor of <span class="math">n</span>, and for the original version of TNFS, <span class="math">n_{1}=n</span> and <span class="math">n_{2}=1</span>.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Definition 2.1 (Smoothness).</h6>

    <p class="text-gray-300">Let <span class="math">B</span> be a positive integer. A polynomial is said to be <span class="math">B</span>-smooth w.r.t. its degree if all its irreducible factors have a degree smaller than <span class="math">B</span>. An integer is said to be <span class="math">B</span>-smooth if all its prime divisors are less than <span class="math">B</span>. An ideal in a number field is said to be <span class="math">B</span>-smooth if it factors into prime ideals whose norms are bounded by <span class="math">B</span>.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Definition 2.2 (Preimage).</h6>

    <p class="text-gray-300">The preimage of an element <span class="math">a=\\sum_{i=0}^{n_{2}-1}\\sum_{j=0}^{n_{1}-1}a_{ij}y^{j}x^{i}</span> <span class="math">\\in\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span> will be, for the NFS and TNFS algorithms, the bivariate polynomial <span class="math">\\sum_{i=0}^{n_{2}-1}\\sum_{j=0}^{n_{1}-1}a_{ij}^{\\prime}y^{j}x^{i}\\in\\mathbb{Z}[x,y]</span>, where each coefficient <span class="math">a_{ij}^{\\prime}</span> is a lift in <span class="math">\\mathbb{Z}</span> of the coefficient <span class="math">a_{ij}</span> in <span class="math">\\mathbb{F}_{p}</span>. It is a preimage for the reduction modulo <span class="math">(p,h,\\psi)</span>, that we denote by <span class="math">\\rho:\\mathbb{Z}[x,y]\\to\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span>. In small characteristic, the preimage of <span class="math">a</span> is a univariate polynomial in <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span>. It is a preimage for the reduction modulo <span class="math">\\psi</span>, that we also denote by <span class="math">\\rho:\\mathbb{F}_{p^{n_{1}}}[x]\\to\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Definition 2.3 (Pseudonorm).</h6>

    <p class="text-gray-300">The integral pseudonorm w.r.t. a number field <span class="math">\\mathbb{Q}[x]/(f(x))</span> (<span class="math">f</span> monic) of a polynomial <span class="math">T=\\sum_{i=0}^{\\deg f-1}a_{i}x^{i}</span> of integer coefficients <span class="math">a_{i}</span> is computed as <span class="math">\\mathrm{Res}_{x}(T(x),f(x))</span>.</p>

    <p class="text-gray-300">Since there is no chance for a preimage of a target <span class="math">T_{0}</span> to be <span class="math">B</span>-smooth, the individual discrete logarithm is done in two steps: an <em>initial splitting</em> of the target, and then a <em>descent</em> phase. The initial splitting is an iterative process that tries many targets <span class="math">g^{t}T_{0}\\in\\mathbb{F}_{p^{n}}^{<em>}</span>, where <span class="math">t</span> is a known exponent (taken uniformly at random), until a <span class="math">B_{1}</span>-smooth decomposition of the preimage is found. Here </em>smooth* stands for a factorization into irreducible polynomials of <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span> of degree at most <span class="math">B_{1}</span> in the small characteristic setting, resp., a pseudonorm that factors as an integer into a product of primes smaller than <span class="math">B_{1}</span> in the NFS (and TNFS) settings.</p>

    <p class="text-gray-300">The second phase starts a recursive process for each element less than <span class="math">B_{1}</span> but greater than <span class="math">B_{0}</span> obtained after the initial splitting phase. Each of these medium-sized elements are processed until a complete decomposition over the factor basis is obtained. Each element obtained from the initial splitting is at the root of its descent tree. One finds a relation involving the original one and other ones whose degree, resp., pseudonorm, is strictly smaller than the degree, resp., pseudonorm, of the initial element at the root. These smaller elements form the new leaves of the descent tree. For each leaf, the process is repeated until all the leaves are elements in the factor basis. The discrete logarithm of an element output by the initial splitting can be computed by a tree traversal. This strategy is considered in <em>[19, §6]</em>, <em>[48, §7]</em>, <em>[38, §3.5]</em>, <em>[18, §4]</em>.</p>

    <p class="text-gray-300">In small characteristic, the initial splitting step is known as the Waterloo algorithm <em>[15, 16]</em>. It outputs <span class="math">T=U(x)/V(x)\\mod I(x)</span>, and <span class="math">U,V</span> are two polynomials of degree <span class="math">\\lfloor(n_{2}-1)/2\\rfloor</span>. It uses an Extended GCD computation. For prime fields, the continued fraction algorithm was already used with the Quadratic Sieve and Coppersmith-Odlyzko-Schroeppel algorithm. It expresses an integer <span class="math">N</span> modulo <span class="math">p</span> as a fraction <span class="math">N\\equiv u/v\\bmod p</span>, and the numerator and denominator are of size about the square root of <span class="math">p</span>. The generalization of this technique was used in <em>[39]</em>. As for the Waterloo algorithm, this technique provides a very good practical speed up but does not improve the asymptotic complexity.</p>

    <p class="text-gray-300">this subfield tool was highlighted in <em>[34]</em>; we will intensively use it.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Lemma 2.4 (<em>[34, Lemma 1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">T\\in\\mathbb{F}_{p^{n}}^{*}</span>, and let <span class="math">\\deg T&lt;n</span>. Let <span class="math">\\ell</span> be a nontrivial prime divisor of <span class="math">\\Phi_{n}(p)</span>. Let <span class="math">T^{\\prime}=u\\cdot T</span> with <span class="math">u</span> in a proper subfield of <span class="math">\\mathbb{F}_{p^{n}}</span>. Then</p>

    <p class="text-gray-300">(2.1) <span class="math">\\log T^{\\prime}\\equiv\\log T\\bmod\\Phi_{n}(p)\\text{ and in particular }\\log T^{\\prime}\\equiv\\log T\\bmod\\ell\\ .</span></p>

    <h2 id="sec-9" class="text-2xl font-bold">3. The heart of our strategy: representing elements in the cyclotomic subgroup of a nonprime finite field with less coefficients</h2>

    <p class="text-gray-300">In the FFS setting, <span class="math">n_{1}=1</span> and usually <span class="math">n_{2}</span> is prime and our technique cannot be helpful, but if <span class="math">n</span> is not prime, our algorithm applies, and moreover in favorable cases Joux’s <span class="math">L[1/4]</span> algorithm and its variants can be used and our technique can provide a further notable speed-up in the descent. For the implementations in small characteristic, the factor basis is made of the irreducible polynomials of <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span> of very small degree, e.g., of degrees 1, 2, 3, and 4 in <em>[3]</em>. Our aim is to improve the smoothness probability of a preimage <span class="math">P\\in\\mathbb{F}_{p^{n_{1}}}[x]</span> of a given target <span class="math">T\\in\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span> and for that we want to reduce the degree in <span class="math">x</span> of the preimage <span class="math">P</span> (as a lift of <span class="math">T</span> in <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span>, <span class="math">P</span> has degree at most <span class="math">n_{2}-1</span> in <span class="math">x</span>), while keeping the property</p>

    <p class="text-gray-300"><span class="math">\\log(\\rho(P))=\\log T\\mod\\ell\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">\\rho:\\mathbb{F}_{p^{n_{1}}}[x]\\to\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span> is the reduction modulo <span class="math">\\psi</span>.</p>

    <p class="text-gray-300">Let <span class="math">d</span> denote the largest proper divisor of <span class="math">n</span>, <span class="math">1&lt;d&lt;n</span> (<span class="math">d</span> might sometimes be equal to <span class="math">n_{2}</span> in the QPA setting). We will compute <span class="math">P</span> in <span class="math">\\mathbb{F}_{p^{n_{1}}}[x]</span> of degree at most <span class="math">n_{2}-d/n_{1}</span> in <span class="math">x</span> (and coefficients in <span class="math">\\mathbb{F}_{p^{n_{1}}}</span>) such that</p>

    <p class="text-gray-300">(3.1) <span class="math">P=uT\\pmod{\\psi},\\text{ where }u^{p^{d}-1}=1\\ .</span></p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">It means that we will cancel the  <span class="math">d / n_1 - 1</span>  higher coefficients (in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> ) of a preimage of  <span class="math">T</span>  in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> .</p>

    <p class="text-gray-300">There are two strategies: either handle coefficients in  <span class="math">\\mathbb{F}_p</span>  or in  <span class="math">\\mathbb{F}_{p^{\\mathrm{gcd}}(d,n_1)}</span> . We will consider the latter case. Let  <span class="math">d&#x27; = d / \\gcd(d,n_1)</span>  to simplify the notation, and let  <span class="math">[1,U,\\ldots ,U^{d&#x27; - 1}]</span>  be a polynomial basis of  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span> . Every product  <span class="math">P = U^i T</span>  satisfies (3.1). Define the  <span class="math">d^{\\prime}\\times n_{2}</span>  matrix  <span class="math">L</span>  whose rows are made of the coefficients (in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> ) of  <span class="math">U^i T</span>  for  <span class="math">0\\leq i\\leq d^{\\prime} - 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">L _ {d ^ {\\prime} \\times n _ {2}} = \\left[ \\begin{array}{c} T \\\\ U T \\\\ \\vdots \\\\ U ^ {d ^ {\\prime} - 1} T \\end{array} \\right] \\in \\mathcal {M} _ {d ^ {\\prime}, n} (\\mathbb {F} _ {p ^ {n _ {1}}})  .</span></div>

    <p class="text-gray-300">Then we compute a row-echelon form of this matrix by performing only  <span class="math">\\mathbb{F}_{p^{\\mathrm{gcd}(n_1,d)}}</span> -linear operations over the rows, so that each row of the echeloned matrix is a  <span class="math">\\mathbb{F}_{p^{\\mathrm{gcd}(n_1,d)}}</span> -linear combination of the initial rows, that can be expressed as</p>

    <div class="my-4 text-center"><span class="math-block">P = \\sum_ {i = 0} ^ {d ^ {\\prime} - 1} \\lambda_ {i} U ^ {i} T = u T, \\text {w h e r e} \\lambda_ {i} \\in \\mathbb {F} _ {p ^ {\\mathrm {g c d}} (n _ {1}, d)}, U ^ {i} \\in \\mathbb {F} _ {p ^ {d / \\mathrm {g c d}} (n _ {1}, d)}</span></div>

    <p class="text-gray-300">so that  <span class="math">P = uT</span>  with  <span class="math">u^{p^d - 1} = 1</span> . Assuming that the matrix is lower-triangular (the other option being an upper-triangular matrix), we take the first row of the matrix as the coefficients of a polynomial in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree at most  <span class="math">n_2 - d / n_1</span> . This is formalized in Algorithm 1. We obtain the following Theorem 3.1.</p>

    <p class="text-gray-300">Input: Finite field  <span class="math">\\mathbb{F}_{p^n}</span>  represented as a tower  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}} = \\mathbb{F}_{p^{n_1}}[x] / (\\psi (x))</span>  (one may have  <span class="math">n_1 = 1</span> ), a proper divisor  <span class="math">d</span>  of  <span class="math">n</span>  ( <span class="math">d \\mid n, 1 &amp;lt; d &amp;lt; n</span> ),  <span class="math">T \\in \\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300">Output:  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  a polynomial of degree  <span class="math">\\leq n_2 - d / n_1</span>  satisfying  <span class="math">P \\bmod \\psi = uT</span> , where  <span class="math">u \\in \\mathbb{F}_{p^d}</span></p>

    <p class="text-gray-300">1  <span class="math">d^{\\prime} = d / \\gcd (n_{1},d)</span> 2 Compute a polynomial basis  <span class="math">(1,U,U^{2},\\ldots ,U^{d^{\\prime} - 1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span></p>

    <p class="text-gray-300">3 Define  <span class="math">L = \\left[ \\begin{array}{c} T \\\\ UT \\\\ \\vdots \\\\ U^{d&#x27; - 1}T \\end{array} \\right]</span>  a  <span class="math">d&#x27; \\times n_2</span>  matrix of coefficients in  <span class="math">\\mathbb{F}_{p^{n_1}}</span></p>

    <p class="text-gray-300">4  <span class="math">M \\gets \\operatorname{RowEchelonForm}(L)</span>  with only  <span class="math">\\mathbb{F}_{p^{\\mathrm{gcd}(n_1,d)}}</span> -linear combinations 5  <span class="math">P(x)\\gets</span>  polynomial from the coefficients of the first row of  <span class="math">L</span> 6 return  <span class="math">P(x)</span></p>

    <p class="text-gray-300">Theorem 3.1. Let  <span class="math">\\mathbb{F}_{p^n}</span>  be a finite field represented as a tower  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span> . Let  <span class="math">T \\in \\mathbb{F}_{p^n}^*</span>  be an element which is not in a proper subfield of  <span class="math">\\mathbb{F}_{p^n}</span> . Let  <span class="math">d</span>  be the largest proper divisor of  <span class="math">n</span> ,  <span class="math">1 &amp;lt; d &amp;lt; n</span>  ( <span class="math">n</span>  is not prime). Assume that  <span class="math">T</span>  is represented by a polynomial in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span>  of degree larger than  <span class="math">n_2 - d / n_1</span> . Then there exists a preimage</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300"><span class="math">P</span>  of  <span class="math">T</span> , in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> , of degree  <span class="math">n_2 - \\lceil d / n_1 \\rceil</span>  in  <span class="math">x</span>  and coefficients in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , and such that</p>

    <div class="my-4 text-center"><span class="math-block">\\log (\\rho (P)) = \\log T \\mod \\Phi_ {n} (p).</span></div>

    <p class="text-gray-300">Proof. We use Algorithm 1 to compute  <span class="math">P</span> . The matrix has full rank since the  <span class="math">U^i</span> s form a polynomial basis of  <span class="math">\\mathbb{F}_{p^{d&#x27;}}</span> . The linear combinations involve  <span class="math">T</span>  and elements in  <span class="math">\\mathbb{F}_{p^{d / \\gcd(n_1, d)}}</span>  and  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1, d)}}</span>  that are in the proper subfield  <span class="math">\\mathbb{F}_{p^d}</span>  by construction. The first row after Gaussian elimination will have at least  <span class="math">d / n_1 - 1</span>  coefficients equal to zero at the right, and will represent a polynomial  <span class="math">P</span>  of degree at most  <span class="math">n_2 - d / n_1</span> , that satisfies  <span class="math">P = uT \\pmod{\\psi}</span>  where  <span class="math">u = \\sum \\lambda_i U^i \\in \\mathbb{F}_{p^d}</span> , since in the process,  <span class="math">T</span>  was multiplied only by elements whose images in  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span>  are in the subfield  <span class="math">\\mathbb{F}_{p^d}</span> . We have  <span class="math">\\rho(P) = uT</span> ,  <span class="math">u \\in \\mathbb{F}_{p^d}</span> , and the equality of logarithms follows by Lemma 2.4.</p>

    <p class="text-gray-300">We can now directly apply Algorithm 1 to improve the initial splitting algorithm in practice.</p>

    <p class="text-gray-300">In all the examples of small characteristic finite fields from pairings,  <span class="math">n</span>  is not prime, for instance  <span class="math">n = 6 \\cdot 509</span> . The notation in [6] was  <span class="math">n = lk</span> , with the property  <span class="math">p^l \\approx k</span> . With our notation,  <span class="math">n_1 = l</span>  and  <span class="math">n_2 = k</span> .</p>

    <p class="text-gray-300">4.1. Algorithm. We directly use Algorithm 1 as a subroutine of Algorithm 2. Then to improve it in practice, we list valuable modifications.</p>

    <p class="text-gray-300">Remark 4.1. As was pointed out to us by F. Rodríguez-Henriquez [56, 3], the elements of the form  <span class="math">x^i R(x)</span>  where  <span class="math">R</span>  itself is of degree  <span class="math">\\leq n_2 - d / n_1</span>  are evenly interesting because the discrete logarithm of  <span class="math">x^i</span>  can be deduced from the discrete logarithm of  <span class="math">x</span> , which is known after linear algebra.</p>

    <p class="text-gray-300">So we can increase the number of elements tested for  <span class="math">B_{1}</span> -smoothness for each exponent  <span class="math">t</span>  by a factor  <span class="math">d&#x27;</span>  almost for free in the following way. We again run a Gaussian elimination algorithm on the matrix  <span class="math">M</span>  but in the reverse side, for instance from row one to row  <span class="math">d&#x27;</span>  and left to right if it was done from row  <span class="math">d&#x27;</span>  to row one and right to left the first time. The matrix is in row-echelon form on the left-hand side and on the right-hand side (the upper right and lower left corners are filled with zeros). We obtain a matrix  <span class="math">N</span>  of the form</p>

    <div class="my-4 text-center"><span class="math-block">N = \\left[ \\begin{array}{c c c c c c c} * &amp;amp; \\ldots &amp;amp; * &amp;amp; * &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ 0 &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; 0 \\\\ 0 &amp;amp; \\ldots &amp;amp; 0 &amp;amp; * &amp;amp; \\ldots &amp;amp; * &amp;amp; * \\end{array} \\right]  .</span></div>

    <p class="text-gray-300">The  <span class="math">i</span> -th row represents a polynomial  <span class="math">P_{i}^{\\prime} = x^{e_{i}}P_{i}</span> , where  <span class="math">P_{i}</span>  is of degree at most  <span class="math">n_2 - d / n_1</span> , and  <span class="math">e_i \\approx (i - 1)\\gcd(n_1, d) / n_1</span> . Since  <span class="math">x</span>  is in the factor basis (by construction, like all the degree one polynomials), its logarithm is known at this point (after the relation collection and linear algebra steps), hence the logarithm of any power  <span class="math">x^{e_i}</span>  is known. It remains to compute the discrete logarithm of  <span class="math">P_{i}</span> .</p>

    <p class="text-gray-300">In practice there are some technicalities: in the second Gaussian elimination, if the leading coefficient is zero, then two rows are swapped, and it cancels the previous Gaussian elimination (computed at the other end of the matrix) for that</p>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">|  Algorithm 2: Initial splitting in small characteristic with the subfield technique  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Input: Finite field Fpn of small characteristic (e.g., p = 2,3), with a tower representation Fpn = F(pn1)n2 = Fpn1[x]/(I(x)) (one may have n1 = 1), generator g (of the order ℓ subgroup of the cyclotomic subgroup of Fpn), target T0 ∈ F(pn1)n2, smoothness bound B1  |   |</p>

    <p class="text-gray-300">|  Output: t, P ∈ Fpn1[x] a polynomial of degree ≤ n2 - d/n1 such that vlogg ρ(P) = t + vlogg T0 mod ℓ, and P(x) is B1-smooth (w.r.t. its degree in x)  |   |</p>

    <p class="text-gray-300">|  1 d ← the largest divisor of n, 1 < d < n  |   |</p>

    <p class="text-gray-300">|  2 d' ← d/gcd(d,n1)  |   |</p>

    <p class="text-gray-300">|  3 Compute U(x) ∈ F(pn1)n2 s.t. (1,U,U2,...,Ud'-1) is a polynomial basis of the subfield Fpd'  |   |</p>

    <p class="text-gray-300">|  4 repeat  |   |</p>

    <p class="text-gray-300">|  5 take t ∈ {1,...,ℓ-1} at random  |   |</p>

    <p class="text-gray-300">|  6 T ← gtT0 in F(pn1)n2  |   |</p>

    <p class="text-gray-300">|  7 Define L = [TUT/↓Ud'-1T] a d' × n2 matrix of coefficients in Fpn1  |   |</p>

    <p class="text-gray-300">|  8 M ← RowEchelonForm(L) (with Fp gcd(d,n1)-linear Gaussian elimination)  |   |</p>

    <p class="text-gray-300">|  9 P(x) ← the polynomial of lowest degree made of the first row of L  |   |</p>

    <p class="text-gray-300">|  10 until P(x) is B1-smooth  |   |</p>

    <p class="text-gray-300">|  11 return t, P(x)  |   |</p>

    <p class="text-gray-300">row. We end up with a matrix which is in row-echelon form on the right and almost row-echelon form on the left (or vice-versa). Since each set of subsequent  <span class="math">n_1 / \\gcd(n_1, d)</span>  rows produces polynomials of the same degree, swapping two rows from the same set will not change the degree in  <span class="math">x</span>  of the polynomial. In average (this is what we observed in our experiments for  <span class="math">\\mathbb{F}_{3^{6.509}}</span>  and  <span class="math">\\mathbb{F}_{3^{5.479}}</span> ), some rare polynomials will have a degree in  <span class="math">x</span>  increased by one or two. This second Gaussian elimination increases the number of tests by a factor  <span class="math">d&#x27;</span>  at a very cheap cost, since in fact it allows one to share the cost of computing the  <span class="math">U^i T</span>  and the two Gaussian eliminations over  <span class="math">d&#x27;</span>  tests.</p>

    <p class="text-gray-300">Remark 4.2. If  <span class="math">\\gcd(d, n_1) &amp;gt; 1</span>  we can increase the number of rows by a small factor. We perform linear combinations of  <span class="math">n_1 / \\gcd(d, n_1)</span>  subsequent rows (all giving a polynomial of same degree):  <span class="math">\\sum_{0 \\leq j \\leq n_1 / \\gcd(d, n_1)} \\mu_j r_j</span>  where  <span class="math">\\mu \\in \\mathbb{F}_{p^{\\gcd(d, n_1)}}</span> , and it will result in new rows and new polynomials of same degree.</p>

    <p class="text-gray-300">Remark 4.3. Other improvements are possible [56, 3], for instance computing  <span class="math">\\mathbb{F}_{p^{\\gcd(n_1,d)}}</span> -linear combinations over a small number of rows corresponding to polynomials of almost the same degree. The resulting polynomial will have degree increased by one or two, which does not significantly affect its  <span class="math">B_1</span> -smoothness probability in practice for cryptographic sizes. This technique allows one to produce many more candidates, at a very cheap cost of linear operations in  <span class="math">\\mathbb{F}_{p^{n_1}}[x]</span> .</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300">4.2.1. Cost of computing one preimage  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  in the initial splitting step. We use the notation of Algorithm 2: let  <span class="math">d</span>  be the largest proper divisor of  <span class="math">n</span>  ( <span class="math">d \\mid n</span> ,  <span class="math">1 &amp;lt; d &amp;lt; n</span> ), and let  <span class="math">d&#x27; = d / \\gcd(d, n_1)</span> . Since  <span class="math">d&#x27; \\mid d \\mid n = n_1n_2</span>  and  <span class="math">\\gcd(d&#x27;, n_1) = 1</span> , then  <span class="math">d&#x27; \\mid n_2</span>  and  <span class="math">d&#x27; \\leq n_2</span> . The computation of all the  <span class="math">U^i T</span>  of the matrix  <span class="math">L</span>  costs at most  <span class="math">d&#x27;n_2^2</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , since a schoolbook multiplication in  <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}}</span>  costs  <span class="math">n_2^2</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span> . There are  <span class="math">d&#x27;</span>  such multiplications. The complexity of a reduced row-echelon form computation of a  <span class="math">(d&#x27; \\times n_2)</span> -matrix,  <span class="math">d&#x27; \\leq n_2</span> , is less than  <span class="math">O(d&#x27;^2n_2)</span>  multiplications in  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  [23, §13.4.2]. To simplify, we consider that the computation of the matrix  <span class="math">L</span>  and of two Gaussian eliminations is done in time at most  <span class="math">O(d&#x27;n_2^2)</span> . This cost is shared over  <span class="math">d&#x27;</span>  polynomials  <span class="math">P_i</span>  to be tested for  <span class="math">B_1</span> -smoothness. In this way, the complexity of computing a preimage  <span class="math">P</span>  with our initial splitting algorithm is the same as in the Waterloo algorithm:  <span class="math">O(n_2^2)</span> , and moreover the smoothness probabilities are much higher for the targeted cryptographic cases coming from supersingular pairing-friendly curves. We also replace two  <span class="math">B_1</span> -smoothness tests by only one, and that might save some time in practice (this saving disappears in the  <span class="math">O</span>  notation). We present the theoretical costs in Tables 1 and 2 from [24]. XGCD stands for extended Euclidean algorithm, SQF stands for SQuare-free Factorization, DDF stands for Distinct Degree Factorization, and EDF stands for Equal Degree Factorization. All the polynomials to be factored are of degree smaller than  <span class="math">n_2</span> ; we take  <span class="math">n_2</span>  as an upper bound to get the costs of Table 2.</p>

    <p class="text-gray-300">TABLE 1. Costs for the initial splitting step. The preimage obtained with Algorithm 2 has degree  <span class="math">d_P \\leq n_2 - d / n_1</span> . The Waterloo algorithm [15, 16] produces two polynomials of degree  <span class="math">d_P = \\lfloor n_2 / 2 \\rfloor</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Factorization</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">cost</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Square-free (SQF)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2P)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Distinct degree (DDF)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d3P log pn1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Equal degree (EDF)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d2P log pn1)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE 2. Cost in multiplications in  <span class="math">{\\mathbb{F}}_{{p}^{n}1}</span>  to compute one preimage to be tested for smoothness,in the initial splitting step.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Computation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">XGCD(T,I)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">matrix [U^iT]0≤i≤d'-1 and row echelon form</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Algorithm</td>

            <td class="px-3 py-2 border-b border-gray-700">Waterloo</td>

            <td class="px-3 py-2 border-b border-gray-700">this work, Alg. 2</td>

            <td class="px-3 py-2 border-b border-gray-700">this work + Rem. 4.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Cost</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n_2^2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(d'n_2^2)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(n_2^2)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4.2.2. running time of the initial splitting step. To start, we recall some results on the smoothness probability of a polynomial of given degree.</p>

    <p class="text-gray-300">Definition 4.4. Let  <span class="math">N_{q}(b;d)</span>  denote the number of monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degree  <span class="math">d</span>  which are  <span class="math">b</span> -smooth. Let  <span class="math">N_{q}(b;d_{1},d_{2})</span>  denote the number of coprime pairs of monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degrees  <span class="math">d_{1}</span>  and  <span class="math">d_{2}</span> , respectively, which are  <span class="math">b</span> -smooth.</p>

    <p class="text-gray-300">Let  <span class="math">\\operatorname{Pr}_q(b;d)</span>  denote the probability of a monic polynomial over  <span class="math">\\mathbb{F}_q</span>  of degree  <span class="math">d</span>  to be  <span class="math">b</span> -smooth. Let  <span class="math">\\operatorname{Pr}_q(b;d_1,d_2)</span>  denote the probability of two coprime monic polynomials over  <span class="math">\\mathbb{F}_q</span>  of degrees  <span class="math">d_1</span>  and  <span class="math">d_2</span>  to be both  <span class="math">b</span> -smooth.</p>

    <p class="text-gray-300">.</p>

    <p class="text-gray-300">Odlyzko gave the following estimation for <span class="math">\\Pr_{q}(b;d)</span> in <em>[54, (4.5), p. 14]</em>.</p>

    <p class="text-gray-300">(4.1) <span class="math">\\Pr_{q}(b,d)^{-1}=\\exp\\left((1+o(1))\\frac{d}{b}\\log_{e}\\frac{d}{b}\\right)\\text{ for }d^{1/100}\\leq b\\leq d^{99/100}\\ .</span></p>

    <p class="text-gray-300">Writing the smoothness bound degree <span class="math">b=\\log L_{Q}[\\alpha_{b},c_{b}]/\\log p^{n_{1}}</span> to match Odlyzko’s convention <span class="math">b=c_{b}n_{2}^{\\alpha_{b}}(\\log n_{2})^{1-\\alpha_{b}}</span>, and the degree of the polynomial to be tested for smoothness <span class="math">d=an_{2}</span>, where <span class="math">a\\in]0,1[</span> and <span class="math">n_{2}=\\log Q/\\log p^{n_{1}}</span>, one obtains</p>

    <p class="text-gray-300"><span class="math">\\Pr_{p^{n_{1}}}(b,d)=L_{Q}\\left[1-\\alpha_{b},-(1-\\alpha_{b})a/\\gamma\\right]\\ ,\\text{ where }Q=p^{n_{1}n_{2}}.</span></p>

    <h6 id="sec-13" class="text-base font-medium mt-4">Theorem 4.5 (<em>[22, Theorem 1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\delta&gt;0</span> be given. Then we have, uniformly for <span class="math">b,d_{1},d_{2}\\to\\infty</span> with <span class="math">d_{1}^{\\delta}\\leq b\\leq d_{1}^{1-\\delta}</span> and <span class="math">d_{2}^{\\delta}\\leq b\\leq d_{2}^{1-\\delta}</span>,</p>

    <p class="text-gray-300"><span class="math">N_{q}(b;d_{1},d_{2})\\sim\\left(1-\\frac{1}{q}\\right)N_{q}(b;d_{1})N_{q}(b;d_{2})\\ .</span></p>

    <h6 id="sec-14" class="text-base font-medium mt-4">Corollary 4.6 (<em>[22, Theorem 1]</em>).</h6>

    <p class="text-gray-300">Let <span class="math">\\delta&gt;0</span> be given. Then we have, uniformly for <span class="math">b,d_{1},d_{2}\\to\\infty</span> with <span class="math">d_{1}^{\\delta}\\leq b\\leq d_{1}^{1-\\delta}</span> and <span class="math">d_{2}^{\\delta}\\leq b\\leq d_{2}^{1-\\delta}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{q}(b;d_{1},d_{2})\\sim\\left(1-\\frac{1}{q}\\right)\\Pr_{q}(b;d_{1})\\Pr_{q}(b;d_{2})\\ .</span></p>

    <p class="text-gray-300">We can now compare the Waterloo algorithm with this work. Assuming that <span class="math">B_{1}=\\log_{p^{n_{1}}}L_{p^{n}}[2/3,\\gamma]</span> for a certain <span class="math">\\gamma</span>, then the probability of a polynomial of degree <span class="math">an_{2}</span>, <span class="math">0&lt;a&lt;n_{2}</span>, to be <span class="math">B_{1}</span>-smooth is <span class="math">L_{p^{n}}[1/3,-a/(3\\gamma)]</span>. In the Waterloo algorithm, two polynomials of degree <span class="math">n_{2}/2</span> should be <span class="math">B_{1}</span>-smooth at the same time, and the expected running time to find such a pair is <span class="math">L_{p^{n}}[1/3,1/(3\\gamma)]</span> (the square of <span class="math">L_{p^{n}}[1/3,1(6\\gamma)]</span>). In our algorithm, a polynomial of degree <span class="math">\\lfloor n_{2}-d/n_{1}\\rfloor=\\lfloor n_{2}(1-d/n)\\rfloor</span> is tested for <span class="math">B_{1}</span>-smoothness, so finding a good one requires</p>

    <p class="text-gray-300">(4.2) <span class="math">L_{p^{n}}[1/3,a/(3\\gamma)]\\text{ tests, where }a\\approx 1-d/n\\ ,</span></p>

    <p class="text-gray-300">which is always faster than the Waterloo algorithm, for which <span class="math">a=1</span>. When <span class="math">n</span> is even (this is always the case for finite fields of supersingular pairing-friendly curves), one can choose <span class="math">d=n/2</span>, hence <span class="math">a=1/2</span> and our algorithm has running time the square root of the running time of the Waterloo algorithm.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">4.3. Improving the record computation in GF(<span class="math">3^{6\\cdot 509}</span>)</h3>

    <p class="text-gray-300">Adj, Menezes, Oliveira, and Rodríguez-Henríquez estimated in <em>[6]</em> the cost to compute discrete logarithms in the 4841-bit finite field GF(<span class="math">3^{6\\cdot 509}</span>) and announced their record computation in July 2016 <em>[4]</em>. The details of the computations are available in Adj’s PhD thesis <em>[2]</em> and the details for initial splitting and descent can be found in <em>[17]</em>. The elements are represented by polynomials of degree at most 508 whose coefficients are in <span class="math">\\mathbb{F}_{3^{6}}</span>. In this case <span class="math">n_{1}=6</span> and <span class="math">n_{2}=509</span>. The initial splitting made with the Waterloo algorithm outputs two polynomials of degree 254. The probability that two independent and relatively prime polynomials of degree 254 over <span class="math">\\mathbb{F}_{3^{6}}</span> are simultaneously <span class="math">b</span>-smooth is <span class="math">(1-1/3^{6})\\Pr_{3^{6}}^{2}(254,b)</span> <em>[22]</em>. The term <span class="math">(1-1/3^{6})</span> is negligible in practice for the values that we are considering.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">4.3.1. Improvements</h4>

    <p class="text-gray-300">Our Algorithm 2 outputs <em>one</em> polynomial of degree <span class="math">254</span>, whose probability to be <span class="math">b</span>-smooth is <span class="math">\\Pr_{3^{6}}(n,b)</span>, i.e., the square root of the previous one. So we can take a much smaller <span class="math">b</span> while reaching the same probability as before with the Waterloo algorithm. We list in Table 3(a), p. 11, the values of <span class="math">b</span> to obtain a probability between <span class="math">2^{-40}</span> and <span class="math">2^{-20}</span>. For instance, if we allow <span class="math">2^{30}</span> trials, then we can set <span class="math">b=28</span> with our algorithm, instead of <span class="math">b=43</span> previously: we have <span class="math">\\Pr_{3^{6}}^{2}(254,43)=2^{-30.1}</span>, and we only need to take <span class="math">b=28</span> to get the same probability with this work: <span class="math">\\Pr_{3^{6}}(254,28)=2^{-29.6}</span>. This will provide a good practical speed-up of the descent phase: much fewer elements need to be “reduced”: this reduces the initial width of the tree, and they are of much smaller degree: this reduces the depth of the descent tree.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">4.3.2. A 30-smooth initial splitting</h4>

    <p class="text-gray-300">The finite field is represented with <span class="math">n_{1}=6</span> and <span class="math">n_{2}=509</span>, that is, as a first extension <span class="math">\\mathbb{F}_{3^{6}}=\\mathbb{F}_{p^{n_{1}}}=\\mathbb{F}_{3}[y]/(y^{6}+2y^{4}+y^{2}+2y+2)</span>, then a second extension <span class="math">\\mathbb{F}_{3^{6\\cdot 509}}=\\mathbb{F}_{3^{6}}[x]/(I(x))</span>, where <span class="math">I(x)</span> is the degree <span class="math">509</span> irreducible factor of <span class="math">h_{1}x^{q_{1}}-h_{0}</span>, where <span class="math">q_{1}=p^{n_{1}}</span>, <span class="math">h_{1}=x^{2}+y^{424}x</span>, and <span class="math">h_{0}=y^{316}x+y^{135}</span>. The generator is <span class="math">g=x+y^{2}</span>. As a proof of concept, we computed a 30-smooth initial splitting of the target <span class="math">T_{0}=\\sum_{i=0}^{508}(y^{\\lfloor\\pi(3^{6})^{i+1}\\rfloor}\\bmod 3^{6})x^{i}</span>, with the parameters <span class="math">d=3\\times 509</span>, <span class="math">d^{\\prime}=d/\\gcd(d,n_{1})=509</span>. Each trial <span class="math">g^{t}T_{0}</span> produces <span class="math">d^{\\prime}=509</span> polynomials to test for smoothness. We found that <span class="math">g^{47233}T_{0}=uvx^{230}P</span>, where <span class="math">u=1\\in\\mathbb{F}_{3^{6}}</span>, <span class="math">v\\in\\mathbb{F}_{3^{5\\cdot 509}}</span>, and <span class="math">P</span> is of degree <span class="math">255</span> and <span class="math">30</span>-smooth. The equality <span class="math">(g^{47233}T_{0})^{\\frac{p^{n}-1}{t}}=(uvx^{230}P)^{\\frac{p^{n}-1}{t}}</span> is satisfied. The explicit value of <span class="math">P</span> is available at https://members.loria.fr/AGuillevic/files/F3_6_509_30smooth.mag.txt.</p>

    <p class="text-gray-300">The whole computation took less than 6 days (real time) on 48 cores Intel Xeon E5-2609 at 2.40GHz (274 core days, i.e., 0.75 core-years). This is obviously an overshot compared to the estimate of <span class="math">2^{26.6}</span>, but this was done with a nonoptimized Magma implementation.</p>

    <p class="text-gray-300">As a comparison, with the classical Waterloo algorithm, Adj et al. computed a 40-smooth initial splitting in 51.71 CPU (at 2.87GHz) years <em>[2, Table 5.2, p. 87]</em> and <em>[4]</em>. They obtained irreducible polynomials of degree 40, 40, 39, 38, 37, and seven polynomials of degree between 22 and 35. They needed another 9.99 CPU years (at 2.66 GHz) to compute a classical descent from 40-smooth to 21-smooth polynomials. A complete comparison can be found in <em>[3]</em> and <em>[1]</em>. In <em>[3]</em>, Adj et al. estimated that with our Algorithm 2 enriched as in Remarks 4.1 and 4.3, it is possible to compute discrete logarithms in <span class="math">\\mathbb{F}_{3^{6\\cdot 709}}</span> at the same cost as in <span class="math">\\mathbb{F}_{3^{6\\cdot 509}}</span> with the former Waterloo algorithm.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.4. Computing discrete logarithms in <span class="math">\\mathbb{F}_{2^{512}}</span> and <span class="math">\\mathbb{F}_{2^{1024}}</span></h3>

    <p class="text-gray-300">In <em>[28, §3.6]</em> discrete logarithms in <span class="math">\\mathbb{F}_{2^{512}}</span> and <span class="math">\\mathbb{F}_{2^{1024}}</span> need to be computed modulo the full multiplicative group order <span class="math">2^{n}-1</span>. As pointed to us by R. Granger, our technique can be used to compute discrete logarithms in <span class="math">\\mathbb{F}_{2^{1024}}</span>. Our algorithm provides a decomposition of the target as the product <span class="math">uR</span> where <span class="math">u</span> is an element in the largest proper subfield <span class="math">\\mathbb{F}_{2^{512}}</span>, and <span class="math">P</span> is an element of <span class="math">\\mathbb{F}_{2^{1024}}</span> of degree 512 instead of 1023. The discrete logarithm of the subfield cofactor <span class="math">u</span> can be obtained by a discrete logarithm computation in <span class="math">\\mathbb{F}_{2^{512}}</span>. More generally, our technique is useful when discrete logarithms in nested finite fields such as <span class="math">\\mathbb{F}_{2^{2^{i}}}</span> are computed recursively.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.5. Improving the record computation in <span class="math">\\mathbf{GF}(3^{5\\cdot 479})</span></h3>

    <p class="text-gray-300">Joux and Pierrot announced a discrete logarithm record computation in <span class="math">\\mathrm{GF}(3^{5\\cdot 479})</span> in <em>[42]</em> (then published in <em>[40]</em>). They defined a first degree 5 extension <span class="math">\\mathbb{F}_{3^{5}}=\\mathbb{F}_{3}[y]/(y^{5}-y+1)</span></p>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">TABLE 3. Smoothness probabilities of polynomials over finite fields, comparison of the Waterloo algorithm and Algorithm 2. The values were computed with Odlyzko's induction formula [54] and Drmota and Panario's Theorem 4.5, as in [17]. (A) Probabilities for  <span class="math">\\mathrm{GF}(3^{6\\cdot 509})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Waterloo alg.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr235(254,b)</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr35(254,b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">2-40.1</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">2-42.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">2-38.4</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">2-39.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">2-36.8</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">2-37.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">2-35.3</td>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">2-35.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">2-33.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">2-32.5</td>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">2-33.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">2-31.3</td>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2-31.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">2-30.1</td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2-29.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">2-28.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">2-27.9</td>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">2-28.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">2-26.9</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">2-25.9</td>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">2-26.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">2-25.0</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2-25.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">2-24.1</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">2-24.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2-23.3</td>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">2-23.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">51</td>

            <td class="px-3 py-2 border-b border-gray-700">2-22.5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">52</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.8</td>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">53</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.1</td>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.0</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">54</td>

            <td class="px-3 py-2 border-b border-gray-700">2-20.4</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">2-20.1</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">55</td>

            <td class="px-3 py-2 border-b border-gray-700">2-19.7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">56</td>

            <td class="px-3 py-2 border-b border-gray-700">2-19.1</td>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">2-19.2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">57</td>

            <td class="px-3 py-2 border-b border-gray-700">2-18.5</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">58</td>

            <td class="px-3 py-2 border-b border-gray-700">2-18.0</td>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">2-18.4</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">59</td>

            <td class="px-3 py-2 border-b border-gray-700">2-17.4</td>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">2-17.6</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">60</td>

            <td class="px-3 py-2 border-b border-gray-700">2-16.9</td>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">2-16.9</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">61</td>

            <td class="px-3 py-2 border-b border-gray-700">2-16.4</td>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">2-16.3</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">62</td>

            <td class="px-3 py-2 border-b border-gray-700">2-15.9</td>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">2-15.6</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(B) For  <span class="math">\\mathrm{GF}(3^{5\\cdot 479})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Waterloo alg.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Algorithm 2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr235(239,b)</td>

            <td class="px-3 py-2 border-b border-gray-700">Pr35(383,b)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">2-67.96</td>

            <td class="px-3 py-2 border-b border-gray-700">2-67.59</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25</td>

            <td class="px-3 py-2 border-b border-gray-700">2-63.95</td>

            <td class="px-3 py-2 border-b border-gray-700">2-63.86</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">26</td>

            <td class="px-3 py-2 border-b border-gray-700">2-60.30</td>

            <td class="px-3 py-2 border-b border-gray-700">2-60.45</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">27</td>

            <td class="px-3 py-2 border-b border-gray-700">2-56.95</td>

            <td class="px-3 py-2 border-b border-gray-700">2-57.32</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2-53.89</td>

            <td class="px-3 py-2 border-b border-gray-700">2-54.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">29</td>

            <td class="px-3 py-2 border-b border-gray-700">2-51.07</td>

            <td class="px-3 py-2 border-b border-gray-700">2-51.79</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">30</td>

            <td class="px-3 py-2 border-b border-gray-700">2-48.46</td>

            <td class="px-3 py-2 border-b border-gray-700">2-49.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2-46.06</td>

            <td class="px-3 py-2 border-b border-gray-700">2-47.06</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">2-43.83</td>

            <td class="px-3 py-2 border-b border-gray-700">2-44.95</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">33</td>

            <td class="px-3 py-2 border-b border-gray-700">2-41.76</td>

            <td class="px-3 py-2 border-b border-gray-700">2-42.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">34</td>

            <td class="px-3 py-2 border-b border-gray-700">2-39.83</td>

            <td class="px-3 py-2 border-b border-gray-700">2-41.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">35</td>

            <td class="px-3 py-2 border-b border-gray-700">2-38.03</td>

            <td class="px-3 py-2 border-b border-gray-700">2-39.44</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">2-36.35</td>

            <td class="px-3 py-2 border-b border-gray-700">2-37.84</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">37</td>

            <td class="px-3 py-2 border-b border-gray-700">2-34.77</td>

            <td class="px-3 py-2 border-b border-gray-700">2-36.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">38</td>

            <td class="px-3 py-2 border-b border-gray-700">2-33.30</td>

            <td class="px-3 py-2 border-b border-gray-700">2-34.92</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">39</td>

            <td class="px-3 py-2 border-b border-gray-700">2-31.91</td>

            <td class="px-3 py-2 border-b border-gray-700">2-33.60</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">40</td>

            <td class="px-3 py-2 border-b border-gray-700">2-30.61</td>

            <td class="px-3 py-2 border-b border-gray-700">2-32.34</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">41</td>

            <td class="px-3 py-2 border-b border-gray-700">2-29.39</td>

            <td class="px-3 py-2 border-b border-gray-700">2-31.16</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">42</td>

            <td class="px-3 py-2 border-b border-gray-700">2-28.23</td>

            <td class="px-3 py-2 border-b border-gray-700">2-30.05</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">43</td>

            <td class="px-3 py-2 border-b border-gray-700">2-27.14</td>

            <td class="px-3 py-2 border-b border-gray-700">2-28.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">44</td>

            <td class="px-3 py-2 border-b border-gray-700">2-26.11</td>

            <td class="px-3 py-2 border-b border-gray-700">2-27.99</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">45</td>

            <td class="px-3 py-2 border-b border-gray-700">2-25.13</td>

            <td class="px-3 py-2 border-b border-gray-700">2-27.04</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">46</td>

            <td class="px-3 py-2 border-b border-gray-700">2-24.21</td>

            <td class="px-3 py-2 border-b border-gray-700">2-26.14</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">47</td>

            <td class="px-3 py-2 border-b border-gray-700">2-23.33</td>

            <td class="px-3 py-2 border-b border-gray-700">2-25.29</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">48</td>

            <td class="px-3 py-2 border-b border-gray-700">2-22.50</td>

            <td class="px-3 py-2 border-b border-gray-700">2-24.47</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">49</td>

            <td class="px-3 py-2 border-b border-gray-700">2-21.71</td>

            <td class="px-3 py-2 border-b border-gray-700">2-23.70</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">50</td>

            <td class="px-3 py-2 border-b border-gray-700">2-20.96</td>

            <td class="px-3 py-2 border-b border-gray-700">2-22.96</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and then a degree 479 extension on top of  <span class="math">\\mathbb{F}_{3^5}</span> . With our notation, we have  <span class="math">p = 3</span> ,  <span class="math">n_1 = 5</span> , and  <span class="math">n_2 = 479</span> . The irreducible degree 479 polynomial  <span class="math">I(x)</span>  is a divisor of  <span class="math">xh_1(x^{q_1}) - h_0(x^{q_1})</span> , where  <span class="math">q_1 = p^{n_1} = 3^5</span> ,  <span class="math">h_0 = x^2 + y^{111}x</span>  and  <span class="math">h_1 = yx + 1</span> . Given a target  <span class="math">T \\in \\mathbb{F}_{3^5 \\cdot 479}</span> , the Waterloo initial splitting outputs two polynomials  <span class="math">u(x), v(x) \\in \\mathbb{F}_{3^5}[x]</span>  of degree  <span class="math">\\lfloor 478 / 2 \\rfloor = 239</span> . Our Algorithm 1 outputs one polynomial of degree  <span class="math">\\lfloor \\frac{4}{5} 479 \\rfloor = 383</span> . This example is interesting because the smoothness probabilities are very close. We computed the exact values with Drmota-Panario's formulas, and give them in Table 3b, p. 11. We obtain  <span class="math">\\mathrm{Pr}_{3^5}^2(239, 50) = 2^{-20.96}</span>  (Waterloo) and  <span class="math">\\mathrm{Pr}_{3^5}(383, 50) = 2^{-22.96}</span> , i.e., our Algorithm 2 would be four times slower compared to Joux's and Pierrot's record;  <span class="math">\\mathrm{Pr}_{3^5}^2(239, 40) = 2^{-30.61}</span>  and  <span class="math">\\mathrm{Pr}_{3^5}(383, 40) = 2^{-32.34}</span> ;  <span class="math">\\mathrm{Pr}_{3^5}^2(239, 30) = 2^{-48.46}</span>  and</p>

    <p class="text-gray-300"><span class="math">\\Pr_{3^{5}}(383,30)=2^{-49.34}</span> ; and the cross-over point is for <span class="math">b=24</span>: in this case, we have <span class="math">\\Pr_{3^{5}}^{2}(239,24)=2^{-67.96}</span> and <span class="math">\\Pr_{3^{5}}(383,24)=2^{-67.59}</span>, which is slightly larger.</p>

    <p class="text-gray-300">The probabilities would advise using the classical initial splitting with the Waterloo (extended GCD) algorithm. We remark that this algorithm would output two <span class="math">B_{1}</span>-smooth polynomials of degree <span class="math">(n_{2}-1)/2</span>. Each would factor into at least <span class="math">(n_{2}-1)/(2B_{1})</span> irreducible polynomials of degree at most <span class="math">B_{1}</span>. Each such factor is sent as an input to the second step (descent step), that is, roughly <span class="math">n_{2}B_{1}</span> factors. If we use Algorithm 2, the initial splitting will outputs one polynomial of degree <span class="math">4/5n_{2}=383</span> that factors into at least <span class="math">4/5n_{2}/B_{1}</span> polynomials of degree at most <span class="math">B_{1}</span>, each of them sent as input to the second step, that is, the descent step is called 20% time less, and that would reduce the total width of the descent tree in the same proportion. Since the descent is the most costly part, and in particular, the memory size required is huge, this remark would need to be taken into consideration for a practical implementation.</p>

    <p class="text-gray-300">As a proof of concept of our algorithm, we implemented in Magma our algorithm, took the same parameters, generator, and target as in <em>[42]</em>, and found a 50-smooth decomposition for the target given by the 471-th row of the matrix computed for <span class="math">g^{23940}T_{0}</span> in 1239 core-hours (22.12 hours over 56 cores) on an Intel Xeon E5-2609 at 2.40GHz (compared to 5000 core-hours announced in <em>[42]</em>).</p>

    <p class="text-gray-300">The value can be found at https://members.loria.fr/AGuillevic/files/F3_5_479_50smooth.mag.txt. In our technique, we compute <span class="math">g^{t}T_{0}=uvR</span> where <span class="math">u\\in\\mathbb{F}_{3^{5}}</span> (this is the leading term of the polynomial), <span class="math">v\\in\\mathbb{F}_{3^{479}}</span>, and <span class="math">R</span> is 50-smooth. The discrete logarithm of <span class="math">u</span> can be tabulated, however it remains quite hard to compute the discrete logarithm of <span class="math">v</span>. Our technique is useful if it is easy (or not required) to compute discrete logarithms in the subfields.</p>

    <h2 id="sec-20" class="text-2xl font-bold">5. Preliminaries before medium and large characteristic cases</h2>

    <p class="text-gray-300">In the first part of this paper, we were considering polynomials, and we wanted polynomials of smallest possible degree. Now we turn to the medium and large characteristic cases, where we do not have polynomials but ideals in number fields, and we want ideals of small norm. It requires testing whether large integers (norms) are smooth as fast as possible. We recall the results of Pomerance and Barbulescu on the <em>early abort strategy</em>.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.1. Pomerance’s Early Abort Strategy</h3>

    <p class="text-gray-300">Pomerance in <em>[55]</em> introduced the <em>Early Abort Strategy</em> (EAS) to speed up the factorization of large integers, within Dixon’s algorithm, the Morrison–Brillhart (continued fraction) algorithm, and the Schroeppel (linear sieve) and quadratic sieve, with several variations in the factorization sub-routine (trial-division, Pollard–Strassen method). The Early Abort Strategy provides an asymptotic improvement in the expected running time. Two versions are studied in <em>[55]</em>: one early-abort test, then many tests. In the relation collection step of the NFS algorithm, the partial factorization of the pseudonorms is done with ECM in time <span class="math">L_{Q}[1/6]</span> (<span class="math">Q=p^{n}</span>), which is negligible compared to the total cost in <span class="math">L_{Q}[1/3]</span>. So Pomerance’s EAS does not provide an asymptotic speed-up, but a practical one. However, in the individual discrete logarithm computation, the initial splitting requires to find smooth integers (pseudonorms) of larger size: <span class="math">L_{Q}[1]</span>. This time the ECM cost is not negligible, and Pomerance’s EAS matters. The speed-up was analyzed by Barbulescu in *[10]</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <p class="text-gray-300">Instead of the ECM test, it could be possible to use the hyperelliptic curve method test of H. Lenstra, Pila and Pomerance <em>[51, 52]</em>. This was investigated for instance by Cosset <em>[20, Chapter 4]</em>.</p>

    <p class="text-gray-300">Pomerance’s analysis is presented in the general framework of testing integers for smoothness. This is named <em>smoothing problem</em> in <em>[10, Chapter 4]</em>. In the individual discrete logarithm context, the numbers we want to test for smoothness are not integers in an interval, but pseudonorms, and their chances of being smooth do not exactly match the chances of random integers of the same size. However, we will make the usual heuristic assumption that for our asymptotic computations, the pseudonorms considered behave as integers of the same size. We give Pomerance’s Early Abort Strategy with one test in Algorithm 3 and with <span class="math">k</span> tests in Algorithm 4.</p>

    <p class="text-gray-300">Algorithm 3 Pomerance’s Early Abort Strategy (EAS) 0: Integer <span class="math">m</span>, smoothness bound <span class="math">B_{1}</span>, real numbers <span class="math">\\theta,b\\in]0,1[</span> 0: <span class="math">B_{1}</span>-smooth decomposition of <span class="math">m</span>, or <span class="math">\\bot</span> 1 <span class="math">(m_{0},m_{1})\\leftarrow\\texttt{ECM}\\;(m,B_{1}^{\\theta})</span> <span class="math">//\\ \\textsc{cost:}\\quad L_{B_{1}^{\\theta}}[1/2,\\sqrt{2}]</span> <span class="math">//\\ m_{0}\\ \\text{is a </span>B_{1}^{\\theta}<span class="math">-smooth part of </span>m<span class="math">}</span> <span class="math">//\\ m_{1}\\ \\text{is the non-factorized part of </span>m<span class="math">}</span> 2 if <span class="math">m_{1}\\leq m^{1-b}</span> then 3 <span class="math">(m_{2},m_{3})\\leftarrow\\texttt{ECM}(m_{1},B_{1})</span> <span class="math">//\\ \\textsc{cost:}\\quad L_{B_{1}}[1/2,\\sqrt{2}]</span> 4 if <span class="math">m_{3}=1</span> then 5 return <span class="math">B_{1}</span>-smooth decomposition <span class="math">m_{1},m_{2}</span> of <span class="math">m</span> 6 return <span class="math">\\bot</span></p>

    <p class="text-gray-300">Writing the complexities as in Pomerance’s paper, in terms of <span class="math">k</span> early-abort tests, one obtains Theorems 5.2 and 5.3.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Theorem 5.2 (<em>[10, § 4.3]</em>).</h6>

    <p class="text-gray-300">The expected running time of the smoothing problem of an integer <span class="math">N</span> with Pomerance’s EAS and the ECM smoothness test is <span class="math">L_{N}[1/3,c]</span> where <span class="math">c=(23/3)^{2/3}/3</span>, the smoothness bound is <span class="math">B=L_{N}[2/3,\\gamma]</span>, where <span class="math">\\gamma=1/c</span>, <span class="math">\\theta=4/9</span>, and <span class="math">b=8/23</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Theorem 5.3 (<em>[10, § 4.5 Th. 4.5.1]</em>).</h6>

    <p class="text-gray-300">The expected running time of the smoothing problem of an integer <span class="math">N</span> with <span class="math">k</span> tests of Pomerance’s EAS and the ECM smoothness test is <span class="math">L_{N}[1/3,c]</span> where</p>

    <p class="text-gray-300"><span class="math">c=3^{1/3}((15+4(2/3)^{3k})/19)^{2/3}\\ ,</span></p>

    <p class="text-gray-300">the smoothness bound is <span class="math">B=L_{N}[2/3,\\gamma]</span>, where</p>

    <p class="text-gray-300"><span class="math">\\gamma=1/c\\ ,</span></p>

    <p class="text-gray-300">the bound <span class="math">b_{i}</span> for <span class="math">0\\leq i\\leq k-1</span> on the remaining part <span class="math">m_{i}</span> in Algorithm 4 is</p>

    <p class="text-gray-300"><span class="math">b_{i}=(2/3)^{3(k-i)}19/(15+4(2/3)^{3k})\\ ,</span></p>

    <p class="text-gray-300">and the exponent <span class="math">\\theta_{i}</span> for <span class="math">0\\leq i\\leq k</span> is</p>

    <p class="text-gray-300"><span class="math">\\theta_{i}=(4/9)^{k-i}\\ .</span></p>

    <p class="text-gray-300">In Section 6.3, we will consider that pseudonorms behave in terms of smoothness like integers bounded by <span class="math">N^{e}</span> (instead of <span class="math">N</span>). We will need the following lemmas</p>

    <p class="text-gray-300">Algorithm 4: Pomerance’s Early Abort Strategy with <span class="math">k</span> tests (<span class="math">k</span>-EAS) 0: Integer <span class="math">m</span>, smoothness bound <span class="math">B_{1}</span>, number of tests <span class="math">k\\geq 0</span>, array of positive real numbers <span class="math">\\mathbf{b}=[b_{0},b_{1},\\ldots,b_{k}]</span> where <span class="math">0&lt;b_{i}\\leq 1</span>, and <span class="math">\\sum_{i=0}^{k}b_{i}=1</span> array of positive real numbers <span class="math">\\boldsymbol{\\theta}=[\\theta_{0},\\ldots,\\theta_{k}=1]</span> where <span class="math">\\theta_{i}&lt;\\theta_{i+1}</span> Output: <span class="math">B_{1}</span>-smooth decomposition of <span class="math">m</span>, or <span class="math">\\bot</span> 1<span class="math">m_{i}\\leftarrow m</span> 2<span class="math">i\\leftarrow 0</span> 3<span class="math">S\\leftarrow\\emptyset</span> 4repeat 5 <span class="math">(s_{i},m_{i+1})\\leftarrow</span> ECM <span class="math">(m_{i},B_{1}^{\\theta_{i}})</span> <span class="math">//\\ \\text{cost:}\\ \\ L_{B_{i}^{\\theta_{i}}}[1/2,\\sqrt{2}]</span> <span class="math">//\\ s_{i}\\ \\text{is a}\\ B_{1}^{\\theta_{i}}\\text{-smooth part of}\\ m_{i},\\ m_{i+1}\\ \\text{is not factorized}</span> 6 <span class="math">S\\leftarrow S\\cup s_{i}</span> 7 <span class="math">m_{i}\\leftarrow m_{i+1}</span> 8 <span class="math">i\\leftarrow i+1</span> 9until <span class="math">(i&gt;k)\\ OR\\ (m_{i}=1)\\ OR\\ (m_{i}&gt;m^{1-\\sum_{j=0}^{i-1}b_{j}})</span> 10if <span class="math">m_{i}==1</span> then 11 return <span class="math">B_{1}</span>-smooth decomposition <span class="math">S</span> of <span class="math">m</span> 12return <span class="math">\\bot</span></p>

    <p class="text-gray-300">Lemma 5.4 (<em>[18, §4.1]</em>, <em>[34, Lemma 1]</em> Running time of <span class="math">B</span>-smooth decomposition of integers with ECM). Let <span class="math">N_{i}</span> be integers taken uniformly at random and bounded by <span class="math">N^{e}</span>, for a fixed real number <span class="math">e&gt;0</span>. Write <span class="math">B=L_{N}[\\alpha_{B},\\gamma]</span> the smoothness bound. Then the expected running time to obtain a <span class="math">B</span>-smooth <span class="math">N_{i}</span>, using ECM for <span class="math">B</span>-smooth tests, is <span class="math">L_{N}[1/3,(3e)^{1/3}]</span>, obtained with <span class="math">B=L_{N}[2/3,e/c=(e^{2}/3)^{1/3}]</span>.</p>

    <p class="text-gray-300">Lemma 5.5 (<em>[55, 10]</em> Running time of <span class="math">B</span>-smooth decomposition of integers with ECM and <span class="math">k</span>-EAS). Let <span class="math">N_{i}</span> be integers taken uniformly at random and bounded by <span class="math">N^{e}</span>, for a fixed real number <span class="math">e&gt;0</span>. Write <span class="math">B=L_{N}[\\alpha_{B},\\gamma]</span> for the smoothness bound. Then the expected running time to obtain a <span class="math">B</span>-smooth <span class="math">N_{i}</span>, using ECM for <span class="math">B</span>-smooth tests and Pomerance’s Early Abort Strategy with one test, is <span class="math">L_{N}[1/3,c=(3e)^{1/3}(23/27)^{2/3}]</span>, obtained with <span class="math">B=L_{N}[2/3,e/c]</span>. The expected running time with <span class="math">k</span>-EAS is <span class="math">L_{N}[1/3,c=(3e)^{1/3}((15+4(2/3)^{3k})/19)^{2/3}]</span> , with <span class="math">B=L_{N}[2/3,e/c]</span>.</p>

    <p class="text-gray-300">We will mix Pomerance’ strategy with our new initial splitting step to improve its running time.</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.2. LLL algorithm</h3>

    <p class="text-gray-300">We recall an important property of the LLL algorithm <em>[49]</em> that we will widely use in this paper. Given a lattice <span class="math">\\mathcal{L}</span> of <span class="math">\\mathbb{Z}^{n}</span> defined by a basis given by an <span class="math">n\\times n</span> matrix <span class="math">L</span>, and parameters <span class="math">\\frac{1}{4}&lt;\\delta&lt;1</span>, <span class="math">\\frac{1}{2}&lt;\\eta&lt;\\sqrt{\\delta}</span>, the LLL algorithm outputs a <span class="math">(\\eta,\\delta)</span>-reduced basis of the lattice. the coefficients of the first (shortest) vector are bounded by</p>

    <p class="text-gray-300"><span class="math">(\\delta-\\eta^{2})^{\\frac{n-1}{4}}\\det(L)^{1/n}\\ .</span></p>

    <p class="text-gray-300">In the remainder of this paper, we will simply denote by <span class="math">C</span> this LLL approximation factor.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.3. NFS and Tower variants</h3>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">5.3.1. Settings. There exist many polynomial selection methods to initialize the NFS algorithm for large and medium characteristic finite fields. We give in Table 4 the properties of the polynomials that we need (degree and coefficient size) to deduce an upper bound of the pseudonorm, as in (5.3), and (5.4).</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (A) NFS number fields</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (B) Tower-NFS number fields FIGURE 1. Extensions of number fields for NFS and tower variants</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> (A) NFS diagram for  <span class="math">\\mathbb{F}_{p^n}</span> FIGURE 2. NFS and tower variant diagrams for  <span class="math">\\mathbb{F}_{p^n}</span></p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (B) Tower-NFS diagram</p>

    <p class="text-gray-300">Three polynomials define the NFS setting:  <span class="math">\\psi, f_0, f_1</span> , where  <span class="math">f_0, f_1</span>  are two polynomials of integer coefficients, irreducible over  <span class="math">\\mathbb{Q}</span> , of degree  <span class="math">\\geq n</span> , defining two non-isomorphic number fields, and whose GCD modulo  <span class="math">p</span>  is an irreducible polynomial  <span class="math">\\psi</span>  of degree  <span class="math">n</span> , used to define the extension  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_p[x] / (\\psi(x))</span> .</p>

    <p class="text-gray-300">In a tower-NFS setting, one has  <span class="math">n = n_1n_2</span> ,  <span class="math">n_1, n_2 \\neq 1</span>  and four polynomials are defined:  <span class="math">h, \\psi, f_0, f_1</span> , where  <span class="math">\\deg h = n_1</span>  and  <span class="math">h</span>  is irreducible modulo  <span class="math">p</span> ,  <span class="math">\\deg \\psi = n_2</span>  and  <span class="math">\\psi</span>  is irreducible modulo  <span class="math">p</span> , and  <span class="math">\\gcd(f_0 \\bmod (p,h), f_1 \\bmod (p,h)) = \\psi</span> . It can be seen as a generalization of the NFS setting as follows: writing  <span class="math">n = n_1n_2</span> , one starts by defining a field extension  <span class="math">\\mathbb{F}_{p^{n_1}} = \\mathbb{F}_p[y] / (h(y))</span>  and then adapting any previously available polynomial selection designed for NFS in  <span class="math">\\mathrm{GF}(p^{n_2})</span> , using  <span class="math">\\mathbb{F}_{p^{n_1}}</span>  as the base field instead of  <span class="math">\\mathbb{F}_p</span> . When  <span class="math">\\gcd(n_1, n_2) &amp;gt; 1</span> , the polynomials  <span class="math">f_0, f_1</span> , resp.,  <span class="math">\\psi</span> , will have coefficients in  <span class="math">\\mathbb{Q}[y] / (h(y))</span> , resp.,  <span class="math">\\mathbb{F}_{p^{n_1}}</span> , instead of  <span class="math">\\mathbb{Q}</span> , resp.,  <span class="math">\\mathbb{F}_p</span> . Then one defines the second extension  <span class="math">\\mathbb{F}_{p_1^n}[x] / (\\psi(x))</span>  of degree  <span class="math">n_2 = \\deg_x \\psi</span> .</p>

    <p class="text-gray-300">Again, to cover all the cases, we consider  <span class="math">\\mathbb{F}_{p^n} = \\mathbb{F}_{(p^{n_1})^{n_2}}</span> . The NFS case will correspond to  <span class="math">n_1 = 1</span> ,  <span class="math">n_2 = n</span>  and the original TNFS case to  <span class="math">n_1 = n</span> ,  <span class="math">n_2 = 1</span> .</p>

    <p class="text-gray-300">5.3.2. Pseudonorm and upper bound. Let  <span class="math">f</span>  be a monic irreducible polynomial over  <span class="math">\\mathbb{Q}</span> , and let  <span class="math">K = \\mathbb{Q}[x] / (f(x))</span>  be a number field. Write  <span class="math">T \\in K</span>  as a polynomial in  <span class="math">x</span> :</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{i=0}^{\\deg f-1}a_{i}x^{i}</span>. The norm is defined by a resultant computation:</p>

    <p class="text-gray-300">(5.1) <span class="math">\\mathrm{Norm}_{K/\\mathbb{Q}}(T)=\\mathrm{Res}(f,T)\\ .</span></p>

    <p class="text-gray-300">In the NFS case, we will consider elements expressed as polynomials in <span class="math">x</span> whose coefficients are integers. We define the pseudonorm as the resultant of the element with the given polynomial <span class="math">f</span>:</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{i=0}^{\\deg f-1}a_{i}x^{i},\\ \\mathrm{pseudonorm}(T(x))=\\mathrm{Res}(T(x),f(x))\\ .</span></p>

    <p class="text-gray-300">We use Kalkbrener’s bound <em>[43, Corollary 2]</em> for an upper bound:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(5.2) $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,\\mathrm{Res}(f,T)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\kappa(\\deg f,\\deg T)\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg T}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg f},$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">\\kappa(n,m)=\\binom{n+m}{n}\\binom{n+m-1}{n}</span> and $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\max_{0\\leq j\\leq\\deg f}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the absolute value of the largest coefficient. An upper bound for </span>\\kappa(n,m)<span class="math"> is </span>(n+m)!$. We will use the following bound in Section 6:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(5.3) $\\mathrm{Norm}_{K_{f}/\\mathbb{Q}}(T)\\leq(\\deg f+\\deg T)!\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg T}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg f}\\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In a Tower-NFS case, we nest two resultants:</p>

    <p class="text-gray-300"><span class="math">T=\\sum_{i=0}^{\\deg f-1}\\sum_{j=0}^{\\deg h-1}a_{ij}y^{j}x^{i},\\ \\mathrm{pseudonorm}(T(x,y))=\\mathrm{Res}_{y}(\\mathrm{Res}_{x}(T(x),f(x)),h(y))\\ .</span></p>

    <p class="text-gray-300">A bound is <em>[45, §A Lemma 2]</em></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(5.4) \\[ \\begin{array}[]{l}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">N_{K_{f}/\\mathbb{Q}}\\sum_{i=0}^{\\deg_{x}P}\\sum_{j=0}^{\\deg h-1}a_{ij}\\alpha_{h}^{j}\\alpha_{f}^{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{ij}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=\\max_{i,j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{ij}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and </span>D(d_{1},d_{2})<span class="math"> is a combinatorial term, </span>D(d_{1},d_{2})=((2d_{2}-1)(d_{1}-1)+1)^{d_{1}/2}(d_{1}+1)^{(2d_{2}-1)(d_{1}-1)/2}((2d_{2}-1)!d_{1}^{2d_{2}})^{d_{1}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-27" class="text-2xl font-bold">6. Faster Initial Splitting with NFS and Tower variants for medium and large characteristic finite fields</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We apply Algorithm 1 to the medium and large characteristic cases. For a general exposition, we assume that we are in a tower setting, where <span class="math">Q=p^{n}=(p^{n_{1}})^{n_{2}}</span>. The elements of <span class="math">\\mathbb{F}_{p^{n}}</span> are represented as <span class="math">T=\\sum_{i=0}^{n_{1}-1}\\sum_{j=0}^{n_{2}-1}a_{i,j}y^{j}x^{i}</span>. the NFS setting corresponds to <span class="math">n_{1}=1</span>, <span class="math">n_{2}=n</span>. When <span class="math">n</span> is prime, the tower setting is <span class="math">n_{1}=n</span>, <span class="math">n_{2}=1</span> but our algorithm does not apply. Denote by <span class="math">h(y)</span> the polynomial defining the field <span class="math">\\mathbb{F}_{p^{n_{1}}}</span> and by <span class="math">\\psi</span> the polynomial defining the degree <span class="math">n_{2}</span> extension <span class="math">\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span>. Here we are not interested (only) in computing a preimage of degree as small as possible, but more generally one whose size of pseudonorm is as small as possible. According to the bounds (5.3), (5.4), we need to combine small coefficients <span class="math">a_{i,j}</span> (to reduce the contribution of $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{ij}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg h\\deg f}<span class="math">) with a small degree in </span>x<span class="math"> (to reduce the contribution of </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{\\deg_{x}P\\deg h}$), and balance the two terms to find a pseudonorm of smaller size.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">6.1. The algorithm. We start again with the same idea as in Algorithm 1: let  <span class="math">d</span>  be the largest proper divisor of  <span class="math">n</span> , with  <span class="math">1 &amp;lt; d &amp;lt; n</span> . Assume we want to obtain a preimage  <span class="math">P \\in \\mathbb{F}_{p^{n_1}}[x]</span>  of the target, of degree  <span class="math">(n - d) / n_1 \\leq \\deg P &amp;lt; \\deg f</span> . We will use relations of the form</p>

    <div class="my-4 text-center"><span class="math-block">P = u T \\quad (\\mathrm {m o d} \\psi), \\mathrm {w h e r e} u ^ {p ^ {d} - 1} = 1 \\mathrm {a s i n (3 . 1)}.</span></div>

    <p class="text-gray-300">We use the relations</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {i} y ^ {j} p = 0 \\quad (\\mathrm {m o d} p, h, \\psi) \\mathrm {f o r} 0 \\leq i j &amp;lt;   d,</span></div>

    <div class="my-4 text-center"><span class="math-block">P = U ^ {i} T \\quad (\\mathrm {m o d} p, h, \\psi),</span></div>

    <p class="text-gray-300">where  <span class="math">\\{1,U,\\ldots ,U^{d - 1}\\}</span>  is a polynomial basis of  <span class="math">\\mathbb{F}_{p^d}</span>  and where</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {i} y ^ {j} \\psi = 0 \\quad (\\mathrm {m o d} p, h, \\psi) \\mathrm {f o r} 0 \\leq j &amp;lt;   n _ {1}, 0 \\leq i &amp;lt;   \\deg (P) - n _ {2}.</span></div>

    <p class="text-gray-300">We define the lattice of these relations and we obtain a matrix</p>

    <div class="my-4 text-center"><span class="math-block">L _ {n _ {1} (\\deg P + 1) \\times n _ {1} (\\deg P + 1)} = \\left[ \\begin{array}{c c c} p &amp;amp; &amp;amp; \\\\ &amp;amp; \\ddots &amp;amp; \\\\ &amp;amp; &amp;amp; p \\\\ &amp;amp; \\mathrm {c o e f f} (T) \\\\ &amp;amp; \\mathrm {c o e f f} (U T) \\\\ &amp;amp; &amp;amp; \\vdots \\\\ \\mathrm {c o e f f} (U ^ {d - 1} T) \\\\ &amp;amp; &amp;amp; \\mathrm {c o e f f} (\\psi) \\\\ &amp;amp; &amp;amp; \\ddots \\\\ \\mathrm {c o e f f} (x ^ {i} (y ^ {j} \\psi \\bmod h (y))) \\end{array} \\right]</span></div>

    <p class="text-gray-300">We want to obtain a matrix in row-echelon form. The  <span class="math">d</span>  first rows and the  <span class="math">n_1(\\deg P - n_2)</span>  last rows are in row-echelon form by construction. We compute Gaussian elimination to obtain a reduced row-echelon form for the rows  <span class="math">U^i T</span> . We use  <span class="math">\\mathbb{F}_p</span> -linear combinations of these rows, and we allow divisions in  <span class="math">\\mathbb{F}_p</span>  so that the leading coefficient is one. We then obtain a square matrix of dimension  <span class="math">n_1(\\deg P + 1)</span>  in row-echelon form. Now at this point we apply a lattice reduction algorithm such as LLL or BKZ to reduce the size of the coefficients of  <span class="math">L</span> . We obtain a matrix  <span class="math">R</span>  whose first row has coefficients bounded by  <span class="math">C_{\\mathrm{LLL}}\\operatorname*{det}(L)^{1 / (n_1(\\deg P + 1))} = p^{(n - d) / (n_1(\\deg P + 1))}</span> .</p>

    <h2 id="sec-28" class="text-2xl font-bold">6.2. Properties and pseudonorm size bound.</h2>

    <p class="text-gray-300">Proposition 6.1. The preimage  <span class="math">P</span>  output by Algorithm 5 satisfies  <span class="math">\\log_g\\rho (P)\\equiv \\log_g g^t T_0 = \\log_gT_0 + t\\bmod \\Phi_n(p)</span> , where  <span class="math">\\rho :\\mathbb{Z}[x,y]\\to \\mathbb{F}_{(p^{n_1})^{n_2}}</span>  was defined in Figure 2.</p>

    <p class="text-gray-300">Proof of Proposition 6.1. Each row of the row-echelon matrix  <span class="math">M</span>  represents a  <span class="math">\\mathbb{F}_p</span> -linear combination of the  <span class="math">d</span>  elements  <span class="math">U^i T</span> ,  <span class="math">0 \\leq i \\leq d-1</span> , i.e., an element  <span class="math">\\sum_{i=0}^{d-1} \\lambda_i U^i T</span> , where  <span class="math">\\lambda_i \\in \\mathbb{F}_p</span> . We can factor  <span class="math">T</span>  in the expression. Each element  <span class="math">u_j = \\sum_{i=0}^{d-1} \\lambda_i U^i</span>  satisfies  <span class="math">u_j^{p^d-1} = 1</span> , i.e., is in  <span class="math">\\mathbb{F}_{p^d}</span>  by construction. So each row represents an</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300">Algorithm 5: Initial splitting, Tower-NFS setting Input: Finite field  <span class="math">\\mathbb{F}_{p^n}</span> <span class="math">n = n_1n_2</span>  , monic irreducible polynomials  <span class="math">h,\\psi</span>  s.t.  <span class="math">\\mathbb{F}_{p^{n_1}} = \\mathbb{F}_p[y] / (h(y))</span> <span class="math">\\mathbb{F}_{(p^{n_1})^{n_2}} = \\mathbb{F}_{p^{n_1}}[x] / (\\psi (x))</span>  , prime order subgroup  <span class="math">\\ell \\mid \\Phi_n(p)</span>  , generator  <span class="math">g</span>  (of the order  <span class="math">\\ell</span>  subgroup), target  <span class="math">T_{0}\\in \\mathbb{F}_{p^{n}}</span>  , degree of the preimage deg  <span class="math">P</span>  , polynomial  <span class="math">f_{i}</span>  , smoothness bound  <span class="math">B_{1}</span> Output:  <span class="math">t\\in \\{1,\\dots ,\\ell -1\\}</span> <span class="math">P\\in \\mathbb{Z}[x]</span>  s.t.  <span class="math">\\log_g\\rho (P)\\equiv t + \\log_gT_0</span>  , and the pseudonorm Resy(Res  <span class="math">x(P,f_i),h)</span>  is  <span class="math">B_{1}</span>  -smooth 1  <span class="math">d\\gets</span>  the largest divisor of  <span class="math">n</span> <span class="math">1\\leq d &amp;lt;   n</span> 2 Compute a polynomial basis  <span class="math">(1,U,U^2,\\ldots ,U^{d - 1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^d}</span>  , where  <span class="math">U</span>  satisfies  <span class="math">U^{p^d -1} = 1\\in \\mathbb{F}_{p^n}</span> 3 repeat 4 take  <span class="math">t\\in \\{1,\\dots ,\\ell -1\\}</span>  uniformly at random 5  <span class="math">T\\gets g^{t}T_{0}\\in \\mathbb{F}_{p^{n}}</span> 6  <span class="math">L\\gets \\left[ \\begin{array}{c}p\\\\ \\ddots \\\\ p\\\\ \\mathrm{coeff}(T)\\\\ \\mathrm{coeff}(UT)\\\\ \\vdots \\\\ \\mathrm{coeff}(U^{d - 1}T)\\\\ \\mathrm{coeff}(\\psi)\\\\ \\ddots \\\\ \\mathrm{coeff}(x^{i}(y^{j}\\psi \\bmod h(y)))\\end{array} \\right]</span> 7 Compute a  <span class="math">\\mathbb{F}_p</span>  - reduced row echelon form of the rows  <span class="math">n - d + 1</span>  to  <span class="math">n</span>  of  <span class="math">L</span> 8  <span class="math">N\\gets</span>  LatticeReduction(L) 9  <span class="math">P\\gets</span>  polynomial in  <span class="math">\\mathbb{Z}[y,x]</span>  made of the shortest vector output by the LatticeReduction algorithm 10 until Resy(Res  <span class="math">x(P,f_i),h)</span>  is  <span class="math">B_{1}</span>  -smooth // ECM, ECM+EAS, or ECM+k-EAS 11 return t,  <span class="math">P</span>  , factorization of Resy(Res  <span class="math">x(P,f_i),h)</span></p>

    <p class="text-gray-300">element  <span class="math">T_{j} = u_{j}T</span> , where  <span class="math">u_{j}^{p^{d} - 1} = 1</span>  ( <span class="math">u_{j} \\in \\mathbb{F}_{p^{d}}</span> ), so that  <span class="math">\\log T_{j} \\equiv \\log T \\mod \\Phi_{n}(p)</span>  by Lemma 2.4.</p>

    <p class="text-gray-300">The second part of the proof uses the same argument: the short vector output by the LLL algorithm is a linear combination of the rows of the matrix  <span class="math">N</span> . Each row represents either 0 or a  <span class="math">\\mathbb{F}_{p^d}</span> -multiple  <span class="math">T_j</span>  of  <span class="math">T</span> , hence the short vector is also a  <span class="math">\\mathbb{F}_{p^d}</span> -multiple of  <span class="math">T</span> . We conclude thanks to Lemma 2.4, that  <span class="math">\\log \\rho(P) \\equiv \\log T \\mod \\Phi_n(p)</span> .</p>

    <p class="text-gray-300">Proposition 6.2. The pseudonorm of  <span class="math">P</span>  in Algorithm 5 has size</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(6.1)  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}_y(\\operatorname{Res}_x(P, f_i), h)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O\\left(Q^{(1 - \\frac{d}{n}) \\frac{\\deg f_i}{\\deg x} P + 1} \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{n_1 \\deg x P}\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assuming that  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(1)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proof of Proposition 6.2. The matrix  <span class="math">N</span>  computed in Algorithm 5 is a square matrix of  <span class="math">(\\deg_x P + 1)n_1</span>  rows and columns, whose coefficients are in  <span class="math">\\mathbb{F}_p</span> . Its determinant</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">is <span class="math">\\det N=p^{n-d}=Q^{1-d/n}</span>. Using the LLL algorithm for the lattice reduction, the coefficients of the shortest vector <span class="math">P</span> are bounded by <span class="math">CQ^{(1-d/n)/((\\deg_{x}P+1)n_{1})}</span>, where <span class="math">C</span> is the LLL factor. We obtain the bound (6.1) according to the bound formula (5.4), and neglecting the combinatorial factor <span class="math">D(n_{1},\\deg f_{i})</span>. Moreover in the Tower-NFS setting, the polynomial selection is designed such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)$. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We finally obtain the following.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Theorem 6.3.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathrm{GF}(p^{n})</span> be a finite field, and let <span class="math">d</span> be the largest divisor of <span class="math">n</span>, <span class="math">d&lt;n</span>, and <span class="math">d=1</span> if <span class="math">n</span> is prime. Let <span class="math">n=n_{1}n_{2}</span> and <span class="math">h,\\psi,f_{i}</span> be given by a polynomial selection method. Let <span class="math">T\\in\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span> be an element which is not in a proper subfield of <span class="math">\\mathbb{F}_{p^{n}}</span>. Then there exists a preimage <span class="math">P\\in\\mathbb{Z}[x,y]</span> of <span class="math">T</span>, of any degree (in <span class="math">x</span>) between <span class="math">\\lfloor n_{2}-d/n_{1}\\rfloor</span> and <span class="math">\\deg f_{i}-1</span>, of coefficients bounded by <span class="math">O(Q^{(1-\\frac{d}{n})}\\frac{1}{(\\deg P+1)n_{1}})</span>, and such that when <span class="math">P</span> is mapped in <span class="math">\\mathbb{F}_{(p^{n_{1}})^{n_{2}}}</span> as <span class="math">\\rho(P)</span>, its discrete logarithm is equal to the discrete logarithm of <span class="math">T</span> modulo <span class="math">\\Phi_{n}(p)</span> (and in particular modulo any prime divisor <span class="math">\\ell</span> of <span class="math">\\Phi_{n}(p)</span>), that is,</p>

    <p class="text-gray-300"><span class="math">\\log\\rho(P)\\equiv\\log T\\bmod\\Phi_{n}(p)\\ .</span></p>

    <p class="text-gray-300">The degree of <span class="math">P</span> in <span class="math">x</span> and the polynomial <span class="math">f_{i}</span> can be chosen to minimize the resultant (pseudonorm):</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\min_{i}\\min_{\\lfloor n_{2}-d/n_{1}\\rfloor\\leq\\deg_{x}P\\leq\\deg f_{i}-1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}^{n_{1}\\deg_{x}P}Q^{(1-\\frac{d}{n})\\frac{\\deg f_{i}}{\\deg_{x}P+1}}\\ .$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We recall in Table 4 the degree and coefficient sizes of the polynomial selections published as of July 2017.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Corollary 6.4.</h6>

    <p class="text-gray-300">With the notation of Table 4 and the NFS setting corresponding to <span class="math">n_{2}=n</span> and <span class="math">n_{1}=1</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. For the polynomial selection methods where there is a side <span class="math">i</span> such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{i}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)<span class="math"> (GJL, Conjugation, Joux–Pierrot and Sarkar–Singh up to now), we do the initial splitting on this side and choose </span>\\deg_{x}P=\\deg_{x}f_{i}-1<span class="math"> to obtain the smallest norm: </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}_{y}(\\operatorname{Res}_{x}(P,f_{i}),h)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O\\left(Q^{1-\\frac{d}{n}}\\right)$. We obtain the same bound for NFS and its tower variants.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">3. When $\\</td>

            <td class="px-3 py-2 border-b border-gray-700">f_{i}\\</td>

            <td class="px-3 py-2 border-b border-gray-700">_{\\infty}=Q^{1/(n_{1}(D+1))}<span class="math"> as for the JLSV_{2} method, the lower bound is </span>Q^{\\frac{\\deg_{x}P}{D+1}+(1-\\frac{d}{n})\\frac{n_{2}}{\\deg_{x}P+1}}<span class="math"> on the </span>f_{0}<span class="math">-side where </span>\\deg f_{0}=n_{2}<span class="math">, and it is </span>Q^{\\frac{\\deg_{x}P}{D+1}+(1-\\frac{d}{n})\\frac{D}{\\deg_{x}P+1}}<span class="math"> on the </span>f_{1}<span class="math">-side, where </span>\\deg f_{1}=D\\geq n_{2}<span class="math">. According to the value of </span>n<span class="math">, one can decide which value of </span>\\deg_{x}P$ will produce a smaller norm.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">6.3. running time</h3>

    <p class="text-gray-300">To apply Lemma 5.4 to the initial splitting case, we make the usual heuristic assumption that the pseudonorms of the elements <span class="math">g^{t}T_{0}</span> behave asymptotically like random integers of the same size. Their size is <span class="math">O(Q^{e})</span>, so we replace <span class="math">N^{e}</span> by <span class="math">Q^{e}</span>. The basis <span class="math">\\{1,U,\\ldots,U^{d-1}\\}</span> can be precomputed. The cost of computing the <span class="math">U^{i}T</span> for <span class="math">0\\leq i\\leq d-1</span> is at most <span class="math">dn^{2}</span> multiplications in <span class="math">\\mathbb{F}_{p}</span> with a schoolbook multiplication algorithm. We can roughly upper-bound it by <span class="math">O(n^{3})</span></p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300">TABLE 4. Properties: degree and coefficient size of the main polynomial selection methods for NFS-DL in  <span class="math">\\mathbb{F}_Q</span> , where  <span class="math">Q = p^n</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We give a bound on the coefficient size of the polynomials with the notation  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = O(x)<span class="math"> . To lighten the notation, we only write  </span>x<span class="math"> , without  </span>O()$ . In the</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Joux-Pierrot method, the prime  <span class="math">p</span>  can be written  <span class="math">p = p_x(x_0)</span> , where  <span class="math">p_x</span>  is a polynomial of tiny coefficients and degree at least 2. This table takes into account the methods published until July 2017.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">method</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg f0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">deg f1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">∞</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  NFS |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">JLSV1 [39]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/2n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/2n</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">GJL [53, 10, 12]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">D + 1</td>

            <td class="px-3 py-2 border-b border-gray-700">D ≥ n</td>

            <td class="px-3 py-2 border-b border-gray-700">log p</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/(D+1)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Conjugation [12]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">2n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log p</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/2n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Joux-Pierrot [41]</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n(deg px)</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">log p</td>

            <td class="px-3 py-2 border-b border-gray-700">Q1/(n deg px)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  p = px(x0) |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Sarkar-Singh [59]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(D + 1)n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dn1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n1(D+1))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2, D ≥ n2 |  |  |  |  |   |</p>

    <p class="text-gray-300">|  Tower-NFS |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">TNFS + base-m [14]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p1/D</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p1/D</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2 |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tower-JLSV2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ≥ n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n1(D+1))</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n1(D+1))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2 [44, 45] |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tower-GJL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D + 1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">D ≥ n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n1(D+1))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2 [45] |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tower-Conjugation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(2n)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2 [11, 45, 46] |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tower-Joux-Pierrot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n2(deg px)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n deg px)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2, p = px(x0) [45, 46] |  |  |  |  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Tower-Sarkar-Singh</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(D + 1)n2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Dn2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">log p</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Q1/(n1n2(D+1))</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  n = n1n2n3, D ≥ n3 [57, 60, 58] |  |  |  |  |   |</p>

    <p class="text-gray-300">The time needed to compute the reduced row-echelon form of a  <span class="math">d \\times n</span>  matrix is in  <span class="math">O(n^3)</span>  which is polynomial in  <span class="math">n</span>  [23]. These two complexities are asymptotically negligible compared to any  <span class="math">L_{Q}[\\alpha &amp;gt; 0]</span> . We obtain the following.</p>

    <p class="text-gray-300">Corollary 6.5. The running time of the initial splitting step with Algorithm 5 to find a  <span class="math">B</span> -smooth pseudonorm, where the pseudonorm has size  <span class="math">O(Q^e)</span>  for a fixed real number  <span class="math">e &amp;gt; 0</span>  determined by the polynomial selection (Table 4, two right-most columns), is</p>

    <p class="text-gray-300">(1)  <span class="math">L_{Q}[1 / 3,c = (3e)^{1 / 3}]</span>  with ECM to perform the smoothness tests; (2)  <span class="math">L_{Q}[1 / 3,c = (3e)^{1 / 3}(23 / 27)^{2 / 3}]</span>  with ECM and EAS; (3)  <span class="math">L_{Q}[1 / 3,c = (3e)^{1 / 3}((15 + 4(2 / 3)^{3k}) / 19)^{2 / 3}]</span>  with ECM and  <span class="math">k</span> -EAS.</p>

    <p class="text-gray-300">For each case, the lower bound was obtained for  <span class="math">B = L_{Q}[2/3, e/c]</span> .</p>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <p class="text-gray-300">Corollary 6.4 gives a bound on the size of the pseudonorms, from which we can deduce  <span class="math">e</span>  to apply Corollary 6.5, and get the expected running time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Example 7.1. Let  <span class="math">p = \\lfloor 10^{25}\\pi \\rfloor + 7926 = 31415926535897932384634359</span>  be a 85-bit prime made of the first 26 decimals of  <span class="math">\\pi</span>  so that  <span class="math">\\mathbb{F}_{p^6}</span>  is a 509-bit finite field. Moreover,  <span class="math">\\Phi_6(p) = p^2 - p + 1</span>  is a 170-bit prime, we denote it by  <span class="math">\\ell = 986960440108935861883947021513080740536833738706523</span> . We want to compute discrete logarithms in the order-  <span class="math">\\ell</span>  cyclotomic subgroup of  <span class="math">\\mathbb{F}_{p^6}</span> . The JLSV <span class="math">_1</span>  method computes two polynomials  <span class="math">f_0, f_1</span> , where  <span class="math">\\deg f_0 = \\deg f_1 = 6</span> , and  $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_i\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} \\approx p^{1/2}<span class="math"> . In our example, we have  </span>\\log_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_0\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 44.67<span class="math">  and  </span>\\log_2 \\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_1\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty} = 46.67<span class="math">  (and  </span>\\log_2 p/2 = 42.35$ ):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {0} = x ^ {6} - 1 1 2 0 9 9 7 5 7 1 1 9 3 2 x ^ {5} - 2 8 0 2 4 9 3 9 2 7 9 8 4 5 x ^ {4} - 2 0 x ^ {3} \\\\ + 2 8 0 2 4 9 3 9 2 7 9 8 3 0 x ^ {2} + 1 1 2 0 9 9 7 5 7 1 1 9 3 8 x + 1 \\\\ \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} f _ {1} = 5 6 0 4 9 9 4 5 7 6 8 3 0 x ^ {6} + 2 0 9 8 6 4 4 7 5 3 3 1 5 8 x ^ {5} - 3 1 6 0 8 7 9 9 8 1 9 5 5 5 x ^ {4} \\\\ - 1 1 2 0 9 9 8 9 1 5 3 6 6 0 0 x ^ {3} - 5 2 4 6 6 1 1 8 8 3 2 8 9 5 x ^ {2} + 1 2 6 4 3 5 1 9 9 2 7 8 2 2 x \\\\ + 5 6 0 4 9 9 4 5 7 6 8 3 0. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since  <span class="math">f_0</span>  is already of degree 6 and monic, it can define the extension  <span class="math">\\mathbb{F}_{p^6} = \\mathbb{F}_p[x] / (f_0(x))</span> . Let  <span class="math">T_0</span>  be our target in  <span class="math">\\mathbb{F}_{p^6}</span>  whose coefficients are made of the decimals of  <span class="math">\\pi</span>  (starting at the 26-th decimal, since the first 25 ones were already used for  <span class="math">p</span> ):</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} T _ {0} = 6 4 2 7 7 0 4 9 8 8 5 8 1 5 0 8 1 6 2 1 6 2 4 5 5 x ^ {5} + 1 6 2 4 0 0 5 2 4 3 2 6 9 3 8 9 9 6 1 3 1 7 7 7 3 8 x ^ {4} \\\\ + 4 5 0 9 3 9 0 2 8 3 7 8 0 9 4 9 9 0 9 0 2 0 1 3 9 x ^ {3} + 3 8 6 8 3 7 4 3 5 9 4 4 5 7 5 7 6 4 7 5 9 1 4 4 4 x ^ {2} \\\\ + 8 2 0 9 7 5 5 9 1 3 6 0 2 1 1 2 9 2 0 8 0 8 1 2 2 x + 3 2 7 9 5 0 2 8 8 4 1 9 7 1 6 9 3 9 9 3 7 5 1 0 5. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Let  <span class="math">g = x + 3</span>  be a generator of  <span class="math">\\mathbb{F}_{p^6}</span> . Let  <span class="math">(1, U, U^2)</span>  be a polynomial basis of  <span class="math">\\mathbb{F}_{p^3}</span>  considered as an implicit subfield of  <span class="math">\\mathbb{F}_{p^6}</span> , where  <span class="math">U = g^{1 + p^3} = \\mathrm{Norm}_{\\mathbb{F}_{p^6} / \\mathbb{F}_{p^3}}(g)</span> . We run Algorithm 5 and find that the fourth preimage of  <span class="math">T = g^{812630}T_0</span>  gives a 61-smooth pseudonorm. We compute the reduced row-echelon form</p>

    <div class="my-4 text-center"><span class="math-block">M = \\left[ \\begin{array}{c c c c c} m _ {0 0} &amp;amp; m _ {0 1} &amp;amp; m _ {0 2} &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ m _ {1 0} &amp;amp; m _ {1 1} &amp;amp; m _ {1 2} &amp;amp; m _ {1 3} &amp;amp; 1 &amp;amp; 0 \\\\ m _ {2 0} &amp;amp; m _ {2 1} &amp;amp; m _ {2 2} &amp;amp; m _ {2 3} &amp;amp; m _ {2 4} &amp;amp; 1 \\end{array} \\right] \\text {o f t h e m a t r i x} \\left[ \\begin{array}{c} T \\\\ U T \\\\ U ^ {2} T \\end{array} \\right],</span></div>

    <p class="text-gray-300">where</p>

    <div class="my-4 text-center"><span class="math-block">m _ {0 0} = 3 0 9 3 0 7 7 8 3 5 8 9 8 7 2 5 3 3 7 3 1 9 8 0 5 3 \\quad m _ {0 1} = 1 6 1 7 2 2 7 6 7 3 2 9 6 1 4 7 7 8 8 6 4 7 1 8 6 5,</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {0 2} = 2 5 1 8 7 5 5 7 0 6 7 6 8 5 9 5 7 6 7 3 1 1 2 4 \\quad m _ {1 0} = 8 9 8 1 0 7 1 7 0 6 6 4 7 1 8 0 8 7 0 6 3 3 0 0 8,</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {1 1} = 2 6 2 9 7 1 2 1 2 3 3 0 0 8 6 6 2 4 7 6 5 0 5 9 2 1 \\quad m _ {1 2} = 4 9 9 9 5 4 5 8 6 7 4 2 5 9 8 9 7 0 7 5 8 9 9 2 7,</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {1 3} = 4 3 8 0 5 5 3 9 4 0 4 7 0 2 4 7 1 2 4 9 2 6 4 5 1 \\quad m _ {2 0} = 4 7 8 7 5 0 2 9 4 1 8 2 7 8 6 6 7 8 7 6 9 8 0 8 5,</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {2 1} = 1 8 8 5 5 4 1 9 7 2 9 4 6 2 7 4 4 5 3 6 9 8 7 5 0 6 \\quad m _ {2 2} = 1 5 4 5 0 3 4 7 6 2 8 7 7 5 3 3 8 7 6 8 6 7 3 2 5 2,</span></div>

    <div class="my-4 text-center"><span class="math-block">m _ {2 3} = 3 1 0 9 2 1 6 3 4 9 2 4 4 4 4 1 1 5 9 7 0 1 1 2 4 3 \\quad m _ {2 4} = 9 8 2 4 3 8 2 7 5 6 1 8 1 1 0 9 8 8 6 9 8 8 4 6 1.</span></div>

    <p class="text-gray-300">Then we reduce with the LLL algorithm the following lattice defined by the  <span class="math">(6\\times 6)</span> -matrix, where  <span class="math">m_{ij}</span>  stands for the coefficient at row  <span class="math">i</span>  and column  <span class="math">j</span>  of the above</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <p class="text-gray-300">matrix  <span class="math">M</span> , and  <span class="math">m_{i,3 + i} = 1</span> :</p>

    <div class="my-4 text-center"><span class="math-block">N = \\left[ \\begin{array}{c c c c c c} p &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; p &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ 0 &amp;amp; 0 &amp;amp; p &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\ m _ {0 0} &amp;amp; m _ {0 1} &amp;amp; m _ {0 2} &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\ m _ {1 0} &amp;amp; m _ {1 1} &amp;amp; m _ {1 2} &amp;amp; m _ {1 3} &amp;amp; 1 &amp;amp; 0 \\\\ m _ {2 0} &amp;amp; m _ {2 1} &amp;amp; m _ {2 2} &amp;amp; m _ {2 3} &amp;amp; m _ {2 4} &amp;amp; 1 \\end{array} \\right]  .</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Each row of  <span class="math">\\mathrm{LLL}(N)</span>  gives us a preimage  <span class="math">P\\in \\mathbb{Z}[x]</span>  of short coefficients such that  $\\log_2\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}\\approx \\log_2p / 2 = 42.34<span class="math">  bits and  </span>\\log \\rho (P)\\equiv \\log T\\bmod \\ell<span class="math">  (in other words,  </span>(T / \\rho (P))^{\\frac{p^2 - 1}{\\ell}} = 1)$ . The fourth row has coefficients of at most 41.82 bits and gives</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} P = 4 8 2 1 6 5 4 0 2 3 6 5 x ^ {5} + 3 8 9 2 8 3 1 1 7 9 8 0 2 x ^ {4} + 2 6 9 4 0 5 0 9 3 2 5 2 9 x ^ {3} \\\\ + 2 3 2 5 4 5 0 4 7 8 8 1 7 x ^ {2} + 1 1 1 7 4 7 0 2 8 3 6 6 8 x + 3 6 8 8 5 9 5 2 3 6 6 7 1. \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The pseudonorm of  <span class="math">P</span>  w.r.t.  <span class="math">f_{0}</span>  is</p>

    <p class="text-gray-300"><span class="math">\\operatorname{Res}(P, f_0) =</span></p>

    <p class="text-gray-300">32601551184187978602887820222780280368556791213406352787959859478882009\\89411710052105812763285379877699363515358275429392312189582741360186561</p>

    <p class="text-gray-300">of 471 bits, which is very close to  <span class="math">\\log_2Q^{11 / 12} = 466</span>  bits. Its factorization in prime ideals of  <span class="math">K_{f_0}</span>  is</p>

    <p class="text-gray-300"><span class="math">\\langle 3,x + 2\\rangle^3\\langle 11,x + 5\\rangle \\langle 17,x + 4\\rangle \\langle 67,x + 44\\rangle \\langle 2011,x + 463\\rangle \\langle 501997,x + 18312\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 340575947,x + 27999767\\rangle \\langle 506032577,x + 177467846\\rangle \\langle 604579099,x + 309800481\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 1402910243559283,x + 1034551157262971\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 1587503571970639,x + 524543605465730\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 36834399852305717,x + 24916507207930752\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 242270403627311729,x + 170018299727614229\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 1070632553963863603,x + 408232161861505290\\rangle</span></p>

    <p class="text-gray-300"><span class="math">\\langle 4305864084909925127,x + 3252872861595329896\\rangle</span></p>

    <p class="text-gray-300">A common choice for the factor basis would be to set its smoothness bound to 30 or 32 bits. There are six prime ideals whose norm is larger than 30 bits, and that should be retreated to reach the factor basis. This initial splitting, testing all pseudonorms obtained for  <span class="math">g^i T_0</span> ,  <span class="math">i</span>  from 0 to 930000, that is,  <span class="math">5.58 \\cdot 10^6</span>  pseudonorms, with our Magma implementation, took 0.95 day on one node of 16 physical cores (32 virtual cores thanks to hyperthreading) Intel Xeon E5-2650 at 2.0GHz, that is, 15.2 core-days.</p>

    <p class="text-gray-300">Example 7.2 (A more general example with NFS). Assume that  <span class="math">n</span>  is even and let  <span class="math">T \\in \\mathbb{F}_{p^n}</span> . Compute a polynomial basis  <span class="math">(1, U, U^2, \\ldots, U^{n/2-1})</span>  of the subfield  <span class="math">\\mathbb{F}_{p^{n/2}}</span> . Let</p>

    <div class="my-4 text-center"><span class="math-block">L = \\left[ \\begin{array}{c} T \\\\ U T \\\\ \\vdots \\\\ U ^ {n / 2 - 1} T \\end{array} \\right] \\text {a n d c o m p u t e} M = \\left[ \\begin{array}{c c c c c c c} m _ {1, 1} &amp;amp; \\ldots &amp;amp; m _ {1, \\frac {n}{2} - 1} &amp;amp; 1 &amp;amp; 0 &amp;amp; \\ldots &amp;amp; 0 \\\\ \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; \\ddots &amp;amp; \\vdots \\\\ \\vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \\ddots &amp;amp; 0 \\\\ m _ {\\frac {n}{2}} &amp;amp; &amp;amp; &amp;amp; \\ldots &amp;amp; &amp;amp; m _ {\\frac {n}{2}, \\frac {n}{2} - 1} &amp;amp; 1 \\end{array} \\right]</span></div>

    <p class="text-gray-300">to be the reduced echelon form of  <span class="math">L</span> . Then we define the lower triangular matrix made of the  <span class="math">n/2 \\times n/2</span>  identity matrix with  <span class="math">p</span>  on the diagonal in the upper left quarter, the  <span class="math">n/2 \\times n/2</span>  zero matrix in the upper right quarter, and the  <span class="math">n/2 \\times n</span>  matrix</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">M</span> in reduced echelon form in the lower half. Moreover, if <span class="math">\\deg(f)&gt;n</span>, then we add <span class="math">(\\deg f-n-1)</span> rows made of the coefficients of <span class="math">x^{i}\\psi</span> where <span class="math">\\mathbb{F}_{p^{n}}=\\mathbb{F}_{p}[x]/(\\psi(x))</span>, for <span class="math">0\\leq i&lt;\\deg f-n-1</span>. Finally we apply the LLL algorithm to this matrix. The short vector gives us a preimage <span class="math">P</span> whose pseudonorm is bounded by <span class="math">Q^{1/2}</span>, with a polynomial selection such that $\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\infty}=O(1)<span class="math"> (such as conjugation or GJL). Applying Lemma 5.4, we set the bound </span>B_{1}<span class="math"> to be </span>B_{1}=L_{Q}[2/3,((1/2)^{2}/3)^{1/3}\\approx 0.436]<span class="math">. The running time of Algorithm 5 will be </span>L_{q}[1/3,(3/2)^{1/3}\\approx 1.144]<span class="math">. We obtain preimages </span>P<span class="math"> whose pseudonorm is bounded by </span>Q^{1-\\frac{1}{2n}}<span class="math"> with the </span>\\mathrm{JLSV}_{1}<span class="math"> polynomial selection method as shown in Example 7.1. Applying Lemma 5.4, we set the bound </span>B_{1}<span class="math"> to be </span>B_{1}=L_{Q}[2/3,((1-\\frac{1}{2n})^{2}/3)^{1/3}]<span class="math">. The running time of Algorithm 5 will be </span>L_{Q}[1/3,(3(1-\\frac{1}{2n}))^{1/3}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-33" class="text-2xl font-bold">8. Optimal representation: monic polynomial of degree <span class="math">\\varphi(n)</span></h2>

    <p class="text-gray-300">In Section 3, we exploited the largest proper subfield <span class="math">\\mathbb{F}_{p^{d}}</span> of <span class="math">\\mathbb{F}_{p^{n}}</span> to find an alternative representation of a given element <span class="math">T\\in\\mathbb{F}_{p^{n}}</span>, with <span class="math">n-d</span> nonzero coefficients, and <span class="math">d-1</span> coefficients (in <span class="math">\\mathbb{F}_{p}</span>) set to zero. The key ingredient was to compute an expression of the form <span class="math">P=uT</span>, where <span class="math">P</span> has <span class="math">d-1</span> coefficients set to zero, and <span class="math">u\\in\\mathbb{F}_{p^{d}}</span>, so that we have the equality <span class="math">(P/T)^{(p^{n}-1)/\\Phi_{n}(p)}=1</span>. We can generalize this strategy: given an element <span class="math">T</span> in the cyclotomic subgroup of <span class="math">\\mathbb{F}_{p^{n}}</span>, of order <span class="math">\\Phi_{n}(p)</span>, we would like to compute an element <span class="math">P\\in\\mathbb{F}_{p^{n}}</span> such that <span class="math">(P/T)^{(p^{n}-1)/\\Phi_{n}(p)}=1</span> and <span class="math">P</span> has only <span class="math">\\varphi_{n}(p)=\\deg\\Phi_{n}(x)</span> non-zero coefficients in <span class="math">\\mathbb{F}_{p}</span>. To achieve that, we would like to compute an expression</p>

    <p class="text-gray-300"><span class="math">T=u_{1}u_{2}\\ldots u_{i}P,\\ \\ \\text{where each </span>u_{i}<span class="math"> is in a proper subfield </span>\\mathbb{F}_{p^{d_{i}}}<span class="math"> of </span>\\mathbb{F}_{p^{n}}<span class="math">}\\ .</span></p>

    <p class="text-gray-300">Given an element <span class="math">T\\in\\mathbb{F}_{p^{n}}</span> such that <span class="math">T^{(p^{n}-1)/\\Phi_{n}(p)}\\neq 1</span> (in other words, its order in the cyclotomic subgroup of <span class="math">\\mathbb{F}_{p^{n}}</span> is not zero), we can sometimes compute an element <span class="math">P</span> with <span class="math">\\varphi(n)</span> non-zero coefficients, where <span class="math">\\varphi(n)</span> is the Euler totient function, plus a monic leading term. Since in Algorithm 5 we do not need a one-to-one correspondence between the given elements of the cyclotomic subgroup on one hand, and their representation with only <span class="math">\\varphi(n)</span> non-zero non-one coefficients on the other hand, we can just solve a system of equations even if we do not expect a solution at all times. If no such compact representation is found, one picks a new <span class="math">t</span> and tests for the next <span class="math">g^{t}T_{0}</span>. To define the system we need to solve, we list all the distinct subfields <span class="math">\\mathbb{F}_{p^{d}}</span> of <span class="math">\\mathbb{F}_{p^{n}}</span> that are not themselves contained in another proper subfield, compute a polynomial basis for each of them, and allow a degree of freedom for the coefficients to be <span class="math">\\varphi(d)</span> for each subfield <span class="math">\\mathbb{F}_{p^{d}}</span>. If we consider the system as a Gröbner basis computation, it becomes very costly even for <span class="math">\\mathbb{F}_{p^{30}}</span>, where we need to handle <span class="math">n-\\varphi(n)-1=21</span> variables. We give a numerical example for <span class="math">\\mathbb{F}_{p^{6}}</span>.</p>

    <p class="text-gray-300">What we do is different than what is done in XTR and CEILIDH compact representations. In the XTR cryptosystem <em>[50]</em>, the elements of the cyclotomic subgroup of <span class="math">\\mathbb{F}_{p^{6}}</span> are represented with an optimal normal basis over <span class="math">\\mathbb{F}_{p^{2}}</span>, also in normal basis representation. Only their trace over <span class="math">\\mathbb{F}_{p^{2}}</span> is considered for representation, storage, and transmission. In <em>[63, 62]</em>, the aim is to define a one-to-one correspondence between the elements in the torus of <span class="math">\\mathbb{F}_{p^{n}}</span> and the set of coefficients <span class="math">(\\mathbb{F}_{p})^{\\varphi(n)}</span>. This optimal compression was achieved for <span class="math">n=6</span> but not for <span class="math">n=30</span>. These techniques are not compatible with the representation of the elements in the NFS algorithm: one chooses a representation by choosing two polynomials <span class="math">f_{0},f_{1}</span> that define the two number fields involved in the algorithm. One cannot change the</p>

    <p class="text-gray-300">representation afterwards: the elements in the individual discrete logarithm phase should be represented in the same way as the elements of the factor basis.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">8.1. Compressed representation of elements in the cyclotomic subgroup of <span class="math">\\mathbb{F}_{p^{6}}</span> by a monic polynomial of degree 2</h3>

    <p class="text-gray-300">We consider the finite field <span class="math">\\mathbb{F}_{p^{6}}</span>. We will use the two subfields <span class="math">\\mathbb{F}_{p^{2}}</span> and <span class="math">\\mathbb{F}_{p^{3}}</span> to cancel three coefficients. Let <span class="math">U\\in\\mathbb{F}_{p^{6}}</span> such that <span class="math">(1,U,U^{2})</span> is a basis of <span class="math">\\mathbb{F}_{p^{3}}\\subset\\mathbb{F}_{p^{6}}</span>. Let <span class="math">V\\in\\mathbb{F}_{p^{6}}</span> such that <span class="math">(1,V)</span> is a basis of <span class="math">\\mathbb{F}_{p^{2}}\\subset\\mathbb{F}_{p^{6}}</span>. We want to solve</p>

    <p class="text-gray-300"><span class="math">uvwT=(u_{0}+u_{1}U+u_{2}U^{2})(v_{0}+v_{1}V)wT=P\\ ,</span></p>

    <p class="text-gray-300">where <span class="math">u=u_{0}+u_{1}U+u_{2}U^{2}\\in\\mathbb{F}_{p^{3}}</span>, <span class="math">v=v_{0}+v_{1}V\\in\\mathbb{F}_{p^{3}}</span>, <span class="math">w\\in\\mathbb{F}_{p}</span>, and <span class="math">P\\in\\mathbb{F}_{p^{6}}</span> is represented by a monic polynomial in <span class="math">x</span> of degree 2. To simplify, we set <span class="math">u_{2}=v_{1}=1</span> so that we obtain equations where we can recursively eliminate the variables by computing resultants. We compute <span class="math">u,v,w</span> such that <span class="math">uvwT=P</span>, where <span class="math">P=a_{0}+a_{1}x+x^{2}</span> is monic of degree 2. We define the lattice</p>

    <p class="text-gray-300">\\[ L=\\begin{bmatrix}p&0&0\\\\ 0&p&0\\\\ a_{0}&a_{1}&1\\end{bmatrix}\\ . \\]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The determinant of <span class="math">L</span> is <span class="math">p^{2}</span> hence <span class="math">\\mathrm{LLL}(L)</span> computes a short vector <span class="math">P</span> of coefficient size bounded by <span class="math">Cp^{2/3}</span>, where <span class="math">C</span> is the LLL approximation factor (we can take <span class="math">C\\approx 1</span> in this practical case). The pseudonorm of <span class="math">P</span> will be in the <span class="math">\\mathrm{JLSV}_{1}</span> case $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\operatorname{Res}(P,f)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{6}_{\\infty}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{2}_{\\infty}=p^{5}=Q^{5/6}<span class="math">. This is better than the bound </span>Q^{11/12}<span class="math"> obtained with the cubic subfield cofactor method. This specific method can be generalized to specific cases of finite fields where reducing as much as possible the degree of the target is the best strategy, as in Example 8.1. This technique was implemented in <em>[33]</em> for computing a new discrete logarithm record in </span>\\mathbb{F}_{p^{6}}$ of 422 bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-35" class="text-base font-medium mt-4">Example 8.1.</h6>

    <p class="text-gray-300">We take the same finite field parameters as in Example 7.1, where <span class="math">\\mathbb{F}_{p^{6}}=\\mathbb{F}_{p}[x]/(f(x))</span>. <span class="math">g=x+3</span> is a generator of <span class="math">\\mathbb{F}_{p^{6}}</span>. <span class="math">(1,U,U^{2})</span> where <span class="math">U=g^{1+p^{3}}</span> is a basis of <span class="math">\\mathbb{F}_{p^{3}}</span> and <span class="math">(1,V)</span> where <span class="math">V=g^{1+p^{2}+p^{4}}</span> is a basis of <span class="math">\\mathbb{F}_{p^{2}}</span>. We solve the system <span class="math">(u_{0}+u_{1}U+U^{2})(v_{0}+V)T=P</span> where <span class="math">u_{i},v_{i}\\in\\mathbb{F}_{p}</span> and <span class="math">P</span> is monic and represented by a polynomial of degree 2 instead of 5. We ran Algorithm 5 with this modification on the same machine (Intel Xeon E5-2650 at 2.0GHz with hyperthreading turned on), from <span class="math">g^{0}T_{0}</span> to <span class="math">g^{90000}T_{0}</span>. On average, the set of <span class="math">I</span> candidates <span class="math">g^{i}T_{0}</span> led to six times more monic degree two polynomials <span class="math">P_{i}</span>. We found that the third polynomial output for <span class="math">T=g^{60928}T_{0}</span> has a 64-bit-smooth pseudonorm. Testing the 90000 <span class="math">g^{i}T_{0}</span> (that is, <span class="math">2.7\\cdot 10^{5}</span> pseudonorms) took 1.2 core-day:</p>

    <p class="text-gray-300"><span class="math">u</span> <span class="math">=12307232765040677532260293+18116887363761988927417497\\ U+U^{2}</span> <span class="math">v</span> <span class="math">=30422514788629575495025401+V</span> <span class="math">w</span> <span class="math">=21470888563719305004900851</span> <span class="math">P</span> <span class="math">=uvwT</span> <span class="math">=x^{2}+479190487430850236087613\\ x+6943966382910680737931850\\ .</span></p>

    <p class="text-gray-300">We checked that <span class="math">(P/T)^{\\frac{p^{6}-1}{\\ell}}=1</span>, meaning that <span class="math">\\log_{g}P=\\log_{g}T=60928+\\log_{g}T_{0}</span>. Then we reduce the lattice defined by the matrix</p>

    <p class="text-gray-300">\\[ \\begin{bmatrix}p&0&0\\\\ 0&p&0\\\\ 6943966382910680737931850&479190487430850236087613&1\\end{bmatrix} \\]</p>

    <p class="text-gray-300">to get three polynomials of smaller coefficients, the third one being</p>

    <p class="text-gray-300"><span class="math">R=107301402613441938\\ x^{2}-32014642452727111\\ x+60125316588415598</span></p>

    <p class="text-gray-300">whose pseudonorm is</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Res}(R,f)=</span> <span class="math">12474200655939339762647720853686893930822373172685245800138935320</span> <span class="math">22514918959041066623605301421497621878867497302294873400285994921</span></p>

    <p class="text-gray-300">of <span class="math">429</span> bits, which corresponds to the estimate <span class="math">\\log_{2}Q^{5/6}=423</span> bits. We still have <span class="math">\\log_{g}\\rho(P)\\equiv\\log_{g}T_{0}+60928\\bmod\\ell</span>. The pseudonorm is <span class="math">64</span>-bit-smooth, and its factorization into prime ideals is</p>

    <p class="text-gray-300"><span class="math">\\langle 11,x+8\\rangle\\langle 23,x+15\\rangle\\langle 12239,x+482\\rangle\\ \\mathrm{(small)}</span> <span class="math">\\langle 1144616018827,x+218590032699\\rangle</span> <span class="math">\\langle 2682498999539,x+1582479651452\\rangle</span> <span class="math">\\langle 42175797334421,x+14828919302862\\rangle</span> <span class="math">\\langle 1195156519724071,x+966160984838340\\rangle</span> <span class="math">\\langle 13533793331200309,x+12224259030902272\\rangle</span> <span class="math">\\langle 92644276473186311,x+5754482791048201\\rangle</span> <span class="math">\\langle 101186915694167857,x+42826432866764905\\rangle</span> <span class="math">\\langle 20516170632026633467,x+14633926248916275064\\rangle\\ .</span></p>

    <p class="text-gray-300">The first three ideals are small enough to be in the factor basis, and eight ideals on side <span class="math">0</span> remain to be descended.</p>

    <h2 id="sec-36" class="text-2xl font-bold">Conclusion</h2>

    <p class="text-gray-300">The algorithms presented in this paper were implemented in Magma and used for cryptographic-size record computations. It was shown in <em>[3]</em> that combined with a practical variant of Joux’s algorithm, our Algorithm 2 allows to compute a discrete logarithm in the finite field <span class="math">\\mathbb{F}_{2^{6}\\cdot 7^{99}}</span> at the same cost as in <span class="math">\\mathbb{F}_{2^{6}\\cdot 509}</span> with the previous state of the art. The large characteristic variant (Algorithm 5) was used in <em>[33]</em> for a <span class="math">422</span>-bit record computation in <span class="math">\\mathbb{F}_{p^{6}}</span>. It would be interesting to be able to generalize it further, to be able to exploit at the same time several subfields, and provide a practical implementation of it for cryptographic sizes.</p>

    <h2 id="sec-37" class="text-2xl font-bold">Acknowledgments</h2>

    <p class="text-gray-300">The author is grateful to Francisco Rodríguez-Henríquez, Frederik Vercauteren, Robert Granger and Thorsten Kleinjung, François Morain, Pierrick Gaudry, Laurent Grémy, Luca De Feo, and the other researchers who helped to improve this work. All these very fruitful discussions started at the ECC 2015 conference, the CATREL workshop and the Asiacrypt 2015 conference; in particular, the author would like to thank the anonymous reviewers of Asiacrypt 2015 who suggested a generalization.</p>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Gora Adj, Discrete logarithms in the cryptographically-interesting field GF(<span class="math">3^{6*509}</span>), Elliptic Curve Cryptography Conference (ECC), Invited talk, September 2016, slides available at http://ecc2016.yasar.edu.tr/slides/ecc2016-gora.pdf.</li>

      <li>[2] by same author, Logaritmo discreto en campos finitos de característica pequeña: atacando la criptogrfía basada en emparejamientos de tipo 1, Phd thesis, Centro de Investigación y de Estudios Avanzados del Instituto Politécnico Nacional, Mexico, July 2016, http://delta.cs.cinvestav.mx/~francisco/Thesis_Gora_adj.pdf.</li>

      <li>[3] Gora Adj, Isaac Canales-Martínez, Nareli Cruz-Cortés, Alfred Menezes, Thomaz Oliveira, Luis Rivera-Zamarripa, and Francisco Rodríguez-Henríquez, Computing discrete logarithms in cryptographically-interesting characteristic-three finite fields, Cryptology ePrint Archive, Report 2016/914, 2016, http://eprint.iacr.org/2016/914.</li>

      <li>[4] Gora Adj, Isaac Canales-Martinez, Nareli Cruz-Cortes, Alfred Menezes, Thomaz Oliveira, Francisco Rodríguez-Henríquez, and Luis Rivera-Zamarripa, Discrete logarithms in GF(<span class="math">3^{6*509}</span>), Number Theory list, item 004923, July 18 2016, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;65bedfc8.1607.</li>

      <li>[5] Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodríguez-Henríquez, Computing discrete logarithms in <span class="math">\\mathbb{F}_{3^{6}\\text{-}137}</span> and <span class="math">\\mathbb{F}_{3^{6}\\text{-}163}</span> using Magma, Arithmetic of Finite Fields (WAIFI 2014) (Çetin Kaya Koç, Sihem Mesnager, and Erkay Savas, eds.), LNCS, vol. 9061, Springer, Heidelberg, 2014, https://eprint.iacr.org/2014/057, pp. 3–22.</li>

      <li>[6] by same author, Weakness of <span class="math">\\mathbb{F}_{3^{6509}}</span> for discrete logarithm cryptography, PAIRING 2013 (Zhenfu Cao and Fangguo Zhang, eds.), LNCS, vol. 8365, Springer, Heidelberg, November 2014, pp. 20–44.</li>

      <li>[7] Gora Adj, Alfred Menezes, Thomaz Oliveira, and Francisco Rodríguez-Henríquez, Weakness of <span class="math">\\mathbb{F}_{6^{6}\\text{-}1429}</span> and <span class="math">\\mathbb{F}_{3^{4}\\text{-}3041}</span> for discrete logarithm cryptography, Finite Fields and Their Applications 32 (2015), 148–170.</li>

      <li>[8] Leonard Adleman, The function field sieve, Algorithmic Number Theory (ANTS-I) (Leonard M. Adleman and Ming-Deh Huang, eds.), LNCS, vol. 877, Springer, Heidelberg, 1994, pp. 141–154.</li>

      <li>[9] Leonard M. Adleman and Ming-Deh A. Huang, Function field sieve method for discrete logarithms over finite fields, Information and Computation 151 (1999), no. 1/2, 5–16, https://dl.acm.org/citation.cfm?id=305383.305385, https://doi.org/10.1006/inco.1998.2761.</li>

      <li>[10] Razvan Barbulescu, Algorithmes de logarithmes discrets dans les corps finis, thèse de doctorat, Université de Lorraine, Nancy, France, 2013, https://tel.archives-ouvertes.fr/tel-00925228.</li>

      <li>[11] Razvan Barbulescu, An appendix for a recent paper of Kim, Cryptology ePrint Archive, Report 2015/1076, 2015, http://eprint.iacr.org/2015/1076.</li>

      <li>[12] Razvan Barbulescu, Pierrick Gaudry, Aurore Guillevic, and François Morain, Improving NFS for the discrete logarithm problem in non-prime finite fields, EUROCRYPT 2015, Part I (Elisabeth Oswald and Marc Fischlin, eds.), LNCS, vol. 9056, Springer, Heidelberg, April 2015, https://hal.inria.fr/hal-01112879v2, pp. 129–155.</li>

      <li>[13] Razvan Barbulescu, Pierrick Gaudry, Antoine Joux, and Emmanuel Thomé, A heuristic quasi-polynomial algorithm for discrete logarithm in finite fields of small characteristic, EUROCRYPT 2014 (Phong Q. Nguyen and Elisabeth Oswald, eds.), LNCS, vol. 8441, Springer, Heidelberg, May 2014, pp. 1–16.</li>

      <li>[14] Razvan Barbulescu, Pierrick Gaudry, and Thorsten Kleinjung, The tower number field sieve, ASIACRYPT 2015, Part II (Tetsu Iwata and Jung Hee Cheon, eds.), LNCS, vol. 9453, Springer, Heidelberg, November / December 2015, pp. 31–55.</li>

      <li>[15] Ian F. Blake, Ryoh Fuji-Hara, Ronald C. Mullin, and Scott A. Vanstone, Computing logarithms in finite fields of characteristic two, SIAM Journal on Algebraic Discrete Methods 5 (1984), no. 2, 276–285, http://epubs.siam.org/doi/abs/10.1137/0605029, https://doi.org/10.1137/0605029.</li>

      <li>[16] Ian F. Blake, Ronald C. Mullin, and Scott A. Vanstone, Computing logarithms in GF(<span class="math">2^{n}</span>), CRYPTO’84 (G. R. Blakley and David Chaum, eds.), LNCS, vol. 196, Springer, Heidelberg, August 1984, https://doi.org/10.1007/3-540-39568-7_8, pp. 73–82.</li>

      <li>[17] Isaac Andrés Canales-Martínez, Implementación eficiente de prueba de suavidad para polinomios, Master thesis, Centro de Investigación y de Estudios Avanzados del Instituto, Politécnico Nacional, Departamento de Computación, México, Distrito Federal, Diciembre 2015, http://delta.cs.cinvestav.mx/~francisco/Thesis_IAC.pdf.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An Commeine and Igor Semaev, An algorithm to solve the discrete logarithm problem with the number field sieve, PKC 2006 (Moti Yung, Yevgeniy Dodis, Aggelos Kiayias, and Tal Malkin, eds.), LNCS, vol. 3958, Springer, Heidelberg, April 2006, pp. 174–190.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>19. Don Coppersmith, Andrew M. Odlyzko, and Richard Schroeppel, Discrete logarithms in <span class="math">\\mathrm{GF}(p)</span>, Algorithmica 1 (1986), no. 1, 1–15, https://dl.acm.org/citation.cfm?id=6835, https://doi.org/10.1007/BF01840433.</li>

      <li>20. Romain Cosset, Applications of theta functions for hyperelliptic curve cryptography, Thèse de doctorat, Université Henri Poincaré - Nancy I, Nancy, France, November 2011, https://tel.archives-ouvertes.fr/tel-00642951.</li>

      <li>21. Whitfield Diffie and Martin E. Hellman, New directions in cryptography, IEEE Transactions on Information Theory 22 (1976), no. 6, 644–654.</li>

      <li>22. Michael Drmota and Daniel Panario, A rigorous proof of the Waterloo algorithm for the discrete logarithm problem, Designs, Codes and Cryptography 26 (2002), no. 1, 229–241.</li>

      <li>23. Jean-Guillaume Dumas and Clement Pernet, Handbook of finite fields, ch. Computational linear algebra over finite fields, pp. 520–535, CRC Press Taylor & Francis Group, 2013.</li>

      <li>24. P. Flajolet, X. Gourdon, and D. Panario, The complete analysis of a polynomial factorization algorithm over finite fields, Journal of Algorithms 40 (2001), 37–81, http://algo.inria.fr/flajolet/Publications/FlGoPa01.pdf.</li>

      <li>25. Joshua Fried, Pierrick Gaudry, Nadia Heninger, and Emmanuel Thomé, A kilobit hidden SNFS discrete logarithm computation, EUROCRYPT 2017, Part I (Jean-Sébastien Coron and Jesper Buus Nielsen, eds.), LNCS, vol. 10210, Springer, Heidelberg, April / May 2017, pp. 202–231.</li>

      <li>26. Faruk Göloglu, Robert Granger, Gary McGuire, and Jens Zümbragel, Discrete logarithms in GF(2^{6}120), Number Theory list, April 11 2013, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;fe9605d9.1304.</li>

      <li>27. Daniel M. Gordon, Discrete logarithms in <span class="math">\\mathrm{GF}(p)</span> using the number field sieve, SIAM Journal on Discrete Mathematics 6 (1993), no. 1, 124–138, https://www.ccrwest.org/gordon/log.pdf.</li>

      <li>28. Robert Granger, Philipp Jovanovic, Bart Mennink, and Samuel Neves, Improved masking for tweakable blockciphers with applications to authenticated encryption, EUROCRYPT 2016, Part I (Marc Fischlin and Jean-Sébastien Coron, eds.), LNCS, vol. 9665, Springer, Heidelberg, May 2016, pp. 263–293.</li>

      <li>29. Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel, Breaking ‘128-bit secure’ supersingular binary curves - (or how to solve discrete logarithms in <span class="math">\\mathbb{F}_{2^{4.1223}}</span> and <span class="math">\\mathbb{F}_{2^{12.367}}</span>), CRYPTO 2014, Part II (Juan A. Garay and Rosario Gennaro, eds.), LNCS, vol. 8617, Springer, Heidelberg, August 2014, http://eprint.iacr.org/2014/119, pp. 126–145.</li>

      <li>30. Robert Granger, Thorsten Kleinjung, and Jens Zumbragel, Discrete logarithms in GF(2^{9234}), Number Theory list, item 004666, January 31 2014, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;9aa2b043.1401.</li>

      <li>31. , Discrete logarithms in the Jacobian of a genus 2 supersingular curve over GF(2^{367}) (dl in GF(2^{4404})), Number Theory list, item 004665, January 30 2014, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;23651c2.1401.</li>

      <li>32. Robert Granger, Thorsten Kleinjung, and Jens Zumbrägel, On the powers of 2, Cryptology ePrint Archive, Report 2014/300, 2014, http://eprint.iacr.org/2014/300.</li>

      <li>33. Laurent Grémy, Aurore Guillevic, François Morain, and Emmanuel Thomé, Computing discrete logarithms in <span class="math">\\mathbb{F}_{p^{6}}</span>, SAC 2017 (Carlisle Adams and Jan Camenisch, eds.), LNCS, vol. 10719, Springer, Heidelberg, August 2017, pp. 85–105.</li>

      <li>34. Aurore Guillevic, Computing individual discrete logarithms faster in GF(<span class="math">p^{n}</span>) with the NFS-DL algorithm, ASIACRYPT 2015, Part I (Tetsu Iwata and Jung Hee Cheon, eds.), LNCS, vol. 9452, Springer, Heidelberg, November / December 2015, pp. 149–173.</li>

      <li>35. Antoine Joux, Discrete logarithms in GF(2^{6168}) = GF((2^{257})^{24}), Number Theory list, May 21 2013, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=NMBRTHRY;49bb494e.1305.</li>

      <li>36. , A new index calculus algorithm with complexity L(1/4 + o(1)) in small characteristic, SAC 2013 (Tanja Lange, Kristin Lauter, and Petr Lisonek, eds.), LNCS, vol. 8282, Springer, Heidelberg, August 2014, pp. 355–379.</li>

      <li>37. Antoine Joux and Reynald Lercier, The function field sieve is quite special, Algorithmic Number Theory (ANTS-V) (Claus Fieker and David R. Kohel, eds.), LNCS, vol. 2369, Springer, Heidelberg, 2002, https://perso.univ-rennes1.fr/reynald.lercier/file/JL02.pdf, pp. 431–445.</li>

    </ul>

    <p class="text-gray-300">AURORE GUILLEVIC</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[38] , <em>Improvements to the general number field sieve for discrete logarithms in prime fields. A comparison with the Gaussian integer method</em>, Math. Comp. 72 (2003), no. 242, 953–967, http://www.ams.org/journals/mcom/2003-72-242/S0025-5718-02-01482-5.</li>

      <li>[39] Antoine Joux, Reynald Lercier, Nigel Smart, and Frederik Vercauteren, <em>The number field sieve in the medium prime case</em>, CRYPTO 2006 (Cynthia Dwork, ed.), LNCS, vol. 4117, Springer, Heidelberg, August 2006, https://www.iacr.org/archive/crypto2006/41170323/41170323.pdf, pp. 326–344.</li>

      <li>[40] Antoine Joux and Cécile Pierrot, <em>Improving the polynomial time precomputation of frobenius representation discrete logarithm algorithms - simplified setting for small characteristic finite fields</em>, ASIACRYPT 2014, Part I (Palash Sarkar and Tetsu Iwata, eds.), LNCS, vol. 8873, Springer, Heidelberg, December 2014, pp. 378–397.</li>

      <li>[41] , <em>The special number field sieve in <span class="math">\\mathbb{F}_{p^{n}}</span> - application to pairing-friendly constructions</em>, PAIRING 2013 (Zhenfu Cao and Fangguo Zhang, eds.), LNCS, vol. 8365, Springer, Heidelberg, November 2014, pp. 45–61.</li>

      <li>[42] Antoine Joux and Cécile Pierrot, <em>Discrete logarithm record in characteristic 3, GF<span class="math">(3^{5\\cdot 479})</span> a 3796-bit field</em>, Number Theory list, item 004745, September 15 2014, https://listserv.nodak.edu/cgi-bin/wa.exe?A2=8MBRTHRY;1ff78abb.1409.</li>

      <li>[43] Michael Kalkbrener, <em>An upper bound on the number of monomials in determinants of sparse matrices with symbolic entries</em>, Mathematica Pannonica 8 (1997), 73–82, http://kalkbrener.at/Selected_publications_files/Kalkbrener97b.pdf.</li>

      <li>[44] Taechan Kim, <em>Extended tower number field sieve: A new complexity for medium prime case</em>, Cryptology ePrint Archive, Report 2015/1027, 2015, http://eprint.iacr.org/2015/1027.</li>

      <li>[45] Taechan Kim and Razvan Barbulescu, <em>Extended tower number field sieve: A new complexity for the medium prime case</em>, CRYPTO 2016, Part I (Matthew Robshaw and Jonathan Katz, eds.), LNCS, vol. 9814, Springer, Heidelberg, August 2016, pp. 543–571.</li>

      <li>[46] Taechan Kim and Jinhyuck Jeong, <em>Extended tower number field sieve with application to finite fields of arbitrary composite extension degree</em>, PKC 2017, Part I (Serge Fehr, ed.), LNCS, vol. 10174, Springer, Heidelberg, March 2017, pp. 388–408.</li>

      <li>[47] Thorsten Kleinjung, Claus Diem, Arjen K. Lenstra, Christine Priplata, and Colin Stahlke, <em>Computation of a 768-bit prime field discrete logarithm</em>, EUROCRYPT 2017, Part I (Jean-Sébastien Coron and Jesper Buus Nielsen, eds.), LNCS, vol. 10210, Springer, Heidelberg, April / May 2017, pp. 185–201.</li>

      <li>[48] Brian A. LaMacchia and Andrew M. Odlyzko, <em>Computation of discrete logarithms in prime fields</em>, Des. Codes Cryptography 1 (1991), no. 1, 47–62, https://doi.org/10.1007/BF00123958, www.dtc.umn.edu/~odlyzko/doc/arch/prime.discrete.logs.pdf.</li>

      <li>[49] A.K. Lenstra, Jr. Lenstra, H.W., and L. Lovász, <em>Factoring polynomials with rational coefficients</em>, Mathematische Annalen 261 (1982), no. 4, 515–534 (English), https://ir.cwi.nl/pub/9304/9304A.pdf.</li>

      <li>[50] Arjen K. Lenstra and Eric R. Verheul, <em>The XTR public key system</em>, CRYPTO 2000 (Mihir Bellare, ed.), LNCS, vol. 1880, Springer, Heidelberg, August 2000, pp. 1–19.</li>

      <li>[51] H. W. Lenstra, Jr., J. Pila, and C. Pomerance, <em>A hyperelliptic smoothness test, I</em>, Philos. Trans. Roy. Soc. London Ser. A 345 (1993), 397–408, https://math.dartmouth.edu/~carlp/hyperI.pdf.</li>

      <li>[52] , <em>A hyperelliptic smoothness test. II</em>, Proc. London Math. Soc. 84 (2002), no. 3, 105–146, https://math.dartmouth.edu/~carlp/PDF/paper129.pdf.</li>

      <li>[53] D. Matyukhin, <em>Effective version of the number field sieve for discrete logarithms in the field GF<span class="math">(p^{k})</span> (in Russian)</em>, Trudy po Discretnoi Matematike 9 (2006), 121–151, http://m.mathnet.ru/php/archive.p?wshow=paper&amp;jrnid=tdm&amp;paperid=144&amp;option_lang=eng.</li>

      <li>[54] Andrew M. Odlyzko, <em>Discrete logarithms in finite fields and their cryptographic significance</em>, EUROCRYPT’84 (Thomas Beth, Norbert Cot, and Ingemar Ingemarsson, eds.), LNCS, vol. 209, Springer, Heidelberg, April 1985, https://doi.org/10.1007/3-540-39757-4_20, http://www.dtc.umn.edu/~odlyzko/doc/arch/discrete.logs.pdf, pp. 224–314.</li>

      <li>[55] C. Pomerance, <em>Analysis and comparison of some integer factoring algorithms</em>, Computational methods in number theory, part I (H. W. Jr Lenstra and R. Tijdeman, eds.), Mathematical Centre Tracts, vol. 154, Mathematisch Centrum, Amsterdam, 1982, http://oai.cwi.nl/oai/asset/19571/19571A.pdf, pp. 89–139.</li>

      <li>[56] Francisco Rodríguez-Henríquez, <em>Another initial splitting in small characteristic finite fields</em>, Personal communication, November 30, 2015.</li>

    </ul>

    <p class="text-gray-300">FASTER INDIVIDUAL DISCRETE LOGARITHMS IN FINITE FIELDS</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[57] Palash Sarkar and Shashank Singh, <em>A general polynomial selection method and new asymptotic complexities for the tower number field sieve algorithm</em>, ASIACRYPT 2016, Part I (Jung Hee Cheon and Tsuyoshi Takagi, eds.), LNCS, vol. 10031, Springer, Heidelberg, December 2016, pp. 37–62.</li>

      <li>[58] , <em>A generalisation of the conjugation method for polynomial selection for the extended tower number field sieve algorithm</em>, Cryptology ePrint Archive, Report 2016/537, 2016, http://eprint.iacr.org/.</li>

      <li>[59] , <em>New complexity trade-offs for the (multiple) number field sieve algorithm in non-prime fields</em>, EUROCRYPT 2016, Part I (Marc Fischlin and Jean-Sébastien Coron, eds.), LNCS, vol. 9665, Springer, Heidelberg, May 2016, https://eprint.iacr.org/2015/944, pp. 429–458.</li>

      <li>[60] , <em>Tower number field sieve variant of a recent polynomial selection method</em>, Cryptology ePrint Archive, Report 2016/401, 2016, http://eprint.iacr.org/.</li>

      <li>[61] O. Schirokauer, <em>Discrete logarithms and local units</em>, Philos. Trans. Roy. Soc. London Ser. A 345 (1993), no. 1676, 409–423, http://rsta.royalsocietypublishing.org/content/345/1676/409, http://doi.org/10.1098/rsta.1993.0139.</li>

      <li>[62] Marten van Dijk, Robert Granger, Dan Page, Karl Rubin, Alice Silverberg, Martijn Stam, and David P. Woodruff, <em>Practical cryptography in high dimensional tori</em>, EUROCRYPT 2005 (Ronald Cramer, ed.), LNCS, vol. 3494, Springer, Heidelberg, May 2005, pp. 234–250.</li>

      <li>[63] Marten van Dijk and David P. Woodruff, <em>Asymptotically optimal communication for torus-based cryptography</em>, CRYPTO 2004 (Matthew Franklin, ed.), LNCS, vol. 3152, Springer, Heidelberg, August 2004, pp. 157–178.</li>

      <li>[64] Yuqing Zhu, Jincheng Zhuang, Chang Lv, and Dongdai Lin, <em>Improvements on the individual logarithm step in extended tower number field sieve</em>, Cryptology ePrint Archive, Report 2016/727, 2016, http://eprint.iacr.org/2016/727.</li>

    </ul>

    <p class="text-gray-300">India Nancy–Grand Est, Équipe Caramba, 615 rue du jardin botanique, CS 20101, 54603 Villers-lès-Nancy Cedex, France E-mail address: aurore.guillevic@inria.fr URL: https://members.loria.fr/AGuillevic</p>`;
---

<BaseLayout title="Faster individual discrete logarithms in finite fields of co... (2016/684)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/684
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
