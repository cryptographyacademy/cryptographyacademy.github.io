---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2004/193';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'The Security and Performance of the Galois/Counter Mode of Operation (Full Version)';
const AUTHORS_HTML = 'David A.  McGrew, John Viega';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">The recently introduced Galois/Counter Mode (GCM) of operation for block ciphers provides both encryption and message authentication, using universal hashing based on multiplication in a binary finite field.  We analyze its security and performance, and show that it is the most efficient mode of operation for high speed packet networks, by using a realistic model of a network crypto module and empirical data from studies of Internet traffic in conjunction with software experiments and hardware designs.  GCM has several useful features: it can accept IVs of arbitrary length, can act as a stand-alone message authentication code (MAC), and can be used as an incremental MAC.  We show that GCM is secure in the standard model of concrete security, even when these features are used.
We also consider several of its important system-security aspects.</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The Galois/Counter Mode (GCM) of operation for block ciphers was designed to meet the need for an authenticated encryption mode that can efficiently achieve speeds of 10 gigabits per second and higher in hardware, can perform well in software, and is free of intellectual property restrictions. It was recently submitted to several standards venues, including the NIST Modes of Operation process [19], IEEE 802.1AE Link Security [23], where it is the mandatory-to-implement cryptoalgorithm in the current draft standard, and IPsec [26]. In the following, we consider its performance and security.</p>

    <p class="text-gray-300">The counter mode of operation (CTR) has become the mode of choice for high speed applications, because it can be efficiently pipelined in hardware implementations. However, it provides no message authentication. GCM incorporates CTR and builds on it by adding a message authentication code (MAC) based on universal hashing [27, 17]. It uses polynomial hashing in the finite field GF(2<sup>w</sup>), the core operation of which is multiplication by a fixed field element. The binary field multiplication can be implemented easily in hardware, and can be made surprisingly efficient in software via table-driven methods. Additionally, GCM can be used as a stand-alone MAC, and can be used as an incremental MAC [3].</p>

    <p class="text-gray-300">This paper is structured as follows. In Section 1.1 we review existing work on authenticated encryption with associated data (AEAD) methods [21]. In Section 2 we briefly review the GCM definition. In Section 3 we analyze and describe its performance in hardware are software, and compare it to other AEAD modes of operation. In Section 4, we review our analysis of GCM in the concrete model; proofs of our results are provided in the Appendices. In Section 5 we consider several important system-security aspects. An abridged version of this paper appeared as an extended abstract [20], in which the appendices were omitted.</p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8">1.1 Overview of Authenticated Encryption Modes</h3>

    <p class="text-gray-300">Recently, many authenticated encryption modes have been proposed, because of the efficiency and usability benefits of the combined approach. The first such mode was Jutla's IAPM (Integrity-Aware Parallelizable) mode [14]. The better known OCB (Offset Code Book) mode [22] is a refinement of IAPM. Both of these modes are parallelizable, making them suitable for high-speed hardware implementations (though they cannot take complete advantage of pipelining; see Section 3). Independently, Gligor and Donescu proposed several authenticated encryption modes [12]. All of the above modes are covered by patents, which has motivated some other work in this space. CCM [28] uses a single key and combines CTR mode with CBC-MAC to produce an authenticated encryption scheme. However, CCM is not suited to high-speed implementations, because CBC-MAC is neither pipelinable nor parallelizable. EAX [7] is a patent-free mode similar to CCM, combining CTR with the OMAC [13] variant of CBC-MAC. OMAC cannot be pipelined or parallelized, so neither can EAX. However, EAX solves some minor issues unique to CCM: it is not on-line, meaning that the message length must be known before one can start processing the message, and there are cases in which it does not preserve word alignment. CWC mode [16] is both patent-free and fully parallelizable; it combines CTR with a MAC based on a universal hash function over GF(2<sup>127</sup>&minus;1). Due to its use of an integer multiply operation, CWC is relatively expensive to implement in hardware.</p>

    <p class="text-gray-300">One useful feature of many authenticated encryption schemes is the ability to authenticate associated data that is not part of the message, such as packet headers. IAPM and OCB are the only two modes we have discussed that have no facilities for this. Another interesting feature, introduced by EAX, is the ability to accept arbitrary-length IVs (most modes use IVs no longer than the cipher block width). This facility increases the usability of the mode, but has the disadvantage of requiring additional processing - particularly in hardware, where a pipeline stall caused by IV processing can significantly impact throughput. GCM supports arbitrary sized IVs, but is optimized for the 12-byte case. As with most modes, GCM uses a single key, supports additional authenticated data, preserves data alignment in all cases, and is on-line.</p>

    <p class="text-gray-300">GCM's design draws from several sources. It uses CTR for encryption, and uses a polynomial hash, like CWC, but with a relatively inexpensive binary field. Its architecture follows that of the Universal Security Transform [18], which enables it to be efficiently pipelined.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 GCM Definition</h2>

    <p class="text-gray-300">We briefly review the definition of GCM, closely following its specification [19], but considering a block cipher with a width of  <span class="math">w \\ge 64</span>  bits, instead of focusing on the 128-bit wide Advanced Encryption Standard (AES) [25]. We assume that w is even. The two main functions that GCM uses are block cipher encryption and multiplication over the field  <span class="math">GF(2^w)</span> ; it defines a particular field, but its details are irrelevant to our analysis. The block cipher encryption of the value  <span class="math">X \\in \\{0,1\\}^w</span>  with the key K is denoted as E(K,X). The multiplication of two elements  <span class="math">X,Y \\in GF(2^w)</span>  is denoted as  <span class="math">X \\cdot Y</span> , and the addition of X and Y is denoted as  <span class="math">X \\oplus Y</span> . The function len(S) takes a bit string S with a length between zero and  <span class="math">2^{w/2} - 1</span> , inclusive, and returns a w/2-bit string containing the nonnegative integer describing the number of bits in its argument, with the least significant bit on the right. The expression  <span class="math">0^l</span>  denotes a string of l zero bits, and  <span class="math">A \\parallel B</span>  denotes the concatenation of two bit strings A and B. The function  <span class="math">MSB_t(S)</span>  takes a bit string S and returns the bit string containing only the leftmost t bits of S, and the symbol  <span class="math">\\{\\}</span>  denotes the bit string with zero length.</p>

    <p class="text-gray-300">The authenticated encryption operation takes as inputs a secret key K, initialization vector IV, a plaintext P, and additional authenticated data A, and gives as its outputs a ciphertext C and an authentication tag T. These values are bit strings with lengths given as follows:</p>

    <p class="text-gray-300"><span class="math">$0 \\le \\text{len}(P) \\le (2^{32} - 2)w</span>$</p>

    <p class="text-gray-300"><span class="math">$0 \\le \\text{len}(A) \\le 2^{w/2}</span>$</p>

    <p class="text-gray-300"><span class="math">$0 &lt; \\text{len}(IV) \\le 2^{w/2}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{len}(C) = \\text{len}(P)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{len}(T) = t &lt; w,</span>$
(1)</p>

    <p class="text-gray-300">where the parameter t is fixed for each instance of the key. The secret key has a length appropriate to the block cipher, and is only used as an input to that cipher. For each fixed value of K, each value of the IV must be distinct, but those values need not have equal lengths. The authenticated decryption operation has five inputs: K, IV, C, A, and T, as defined above. It has only one output, either the plaintext value P or the special symbol <strong>FAIL</strong> that indicates that its inputs are not authentic.</p>

    <p class="text-gray-300">During the encryption and decryption processes, the bit strings P, C, and A are broken up into w-bit blocks. We let n and u denote the unique pair of positive integers such that the total number of bits in the plaintext is (n-1)w+u, where  <span class="math">1 \\leq u \\leq w</span> , when len(P) &gt; 0; otherwise n = u = 0. The plaintext consists of a sequence of n bit strings, in which the bit length of the last bit string is u, and the bit length of the other bit strings is w. The sequence is denoted  <span class="math">P_1, P_2, \\ldots, P_{n-1}, P_n^*</span> , and the bit strings are called data blocks, although the last bit string,  <span class="math">P_n^*</span> , may not be a complete block. Similarly, the ciphertext is denoted as  <span class="math">C_1, C_2, \\ldots, C_{n-1}, C_n^*</span> , where the number of bits in the final block  <span class="math">C_n^*</span>  is u. The additional authenticated data A is denoted as  <span class="math">A_1, A_2, \\ldots, A_{m-1}, A_m^*</span> ,</p>

    <p class="text-gray-300">where the last bit string A<sup>&lowast;</sup> <sup>m</sup> may be a partial block of length v, and m and v denote the unique pair of positive integers such that the total number of bits in A is (m &minus; 1)w + v and 1 &le; v &le; w, when len(A) &gt; 0; otherwise m = v = 0. The authenticated encryption operation is defined by the following equations:</p>

    <p class="text-gray-300"><span class="math">$H = E(K, 0^{w})</span>$</p>

    <p class="text-gray-300"><span class="math">$Y_{0} = \\begin{cases} IV || 0^{31}1 &amp; \\text{if len}(IV) = w - 32\\\\ \\text{GHASH}(H, \\{\\}, IV) &amp; \\text{otherwise.} \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$Y_{i} = \\text{incr}(Y_{i-1}) \\text{ for } i = 1, \\dots, n</span>$</p>

    <p class="text-gray-300"><span class="math">$C_{i} = P_{i} \\oplus E(K, Y_{i}) \\text{ for } i = 1, \\dots, n - 1</span>$</p>

    <p class="text-gray-300"><span class="math">$C_{n}^{*} = P_{n}^{*} \\oplus \\text{MSB}_{u}(E(K, Y_{n}))</span>$</p>

    <p class="text-gray-300"><span class="math">$T = \\text{MSB}_{t}(\\text{GHASH}(H, A, C) \\oplus E(K, Y_{0}))</span>$
(2)</p>

    <p class="text-gray-300">Successive counter values are generated using the function incr(), which treats the rightmost 32 bits of its argument as a nonnegative integer with the least significant bit on the right, and increments this value modulo 2<sup>32</sup>. More formally, the value of incr(FkI) is Fk(I + 1 mod 2<sup>32</sup>). The function GHASH is defined by GHASH(H, A, C) = Xm+n+1, where the inputs A and C are formatted as described above, and the variables X<sup>i</sup> for i = 0, . . . , m + n + 1 are defined as</p>

    <p class="text-gray-300"><span class="math">$X_{i} = \\begin{cases} 0 &amp; \\text{for } i = 0\\\\ (X_{i-1} \\oplus A_{i}) \\cdot H &amp; \\text{for } i = 1, \\dots, m-1\\\\ (X_{m-1} \\oplus (A_{m}^{*} || 0^{w-v})) \\cdot H &amp; \\text{for } i = m\\\\ (X_{i-1} \\oplus C_{i-m}) \\cdot H &amp; \\text{for } i = m+1, \\dots, m+n-1\\\\ (X_{m+n-1} \\oplus (C_{n}^{*} || 0^{w-u})) \\cdot H &amp; \\text{for } i = m+n\\\\ (X_{m+n} \\oplus (\\text{len}(A) || \\text{len}(C))) \\cdot H &amp; \\text{for } i = m+n+1. \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$(3)</span>$</p>

    </section>

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3 Performance</h2>

    <p class="text-gray-300">We considered the performance of various modes of operation of the AES-128 block cipher in both hardware and software. We use a simple model of a network crypto module in order to analyze the performance of different AEAD modes under realistic conditions. The module consists of a device that accepts a continuous stream unprotected data packets on one interface and then outputs the stream of encrypted and authenticated packets out another interface. We assume that the key is present in the module, and that the mode and data encapsulation are fixed, in order to focus on the data processing performance. We assume that the module contains a clock which runs at a fixed rate. In general, the number of clock cycles C(s) required to process a packet with s bytes varies as a function of s. We assume that the packet sizes are distributed probabilistically, where the probability of having size s is P[S = s]. The expected number of clocks per byte C of the module is  <span class="math">C = \\sum_{s} C(s) f(s)</span> , where</p>

    <p class="text-gray-300"><span class="math">$f(s) = \\frac{\\mathbf{P}[S=s]}{\\sum_{r} r\\mathbf{P}[S=r]}</span>$
(4)</p>

    <p class="text-gray-300">is the expected fraction of bytes that are carried in packets of size s. The function f(s) is important because it can be empirically observed. Studies of Internet traffic reveal a predominance of small packets, with peaks in the distribution of packet sizes at 44, 552, 576, and 1500 bytes, and very few packets with larger sizes [10], reflecting the nature of the TCP/IP protocol family. About half of the data on the Internet is carried in packets of 576 bytes or less, and most of the remainder is carried in packets of about 1500 bytes. We defined the Internet Performance Index (IPI) as the expected number of bits processed per clock cycle when the packet distribution has the values f(1500) = .6, f(576) = .2, f(552) = .15, and f(44) = .05, using data from [10]. This index is a useful indicator of the performance of a crypto module that protects IP traffic using e.g. the Encapsulating Security Payload (ESP) [15] in tunnel mode, the protocol which underlies most Virtual Private Networks.</p>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8">3.1 Hardware</h3>

    <p class="text-gray-300">A typical high-speed AES-128 implementation consists of a pipeline of ten units, each of which implements a single AES round. At each clock cycle, data moves from one unit to the next, and 128 bits enter the pipeline and the same number leave the pipeline as output. In the following, we describe and analyze the best GCM, CWC, and OCB implementations that use a single instance of this AES pipeline. We disregard the other modes, since they use cipher block chaining and thus cannot be implemented in this manner. We require that packets be processed sequentially, rather than concurrently, because the complexity and circuit cost of the concurrent approach makes sequential processing more desirable in practice. In our performance analysis we determine the value of C(s) for each mode and tabulate the results, and also compare the circuit costs for the modes. Data from multiple packets may be in the module simultaneously. To account for this fact, we measure C(s) by counting the number of cycles between the time when the last data from one protected packet leaves the module and when the initial data from the next protected packet leaves the module. Our hardware implementation model is not detailed, but it very effectively reveals the effects of pipeline stalls on performance; a stall occurs when a circuit is not generating outputs for some number of clock cycles.</p>

    <p class="text-gray-300">GCM can easily take advantage of the AES pipeline (Figure 1, top), as long as a 96-bit IV is used (as is recommended for high-speed implementations). We use a finite-field multiplier over  <span class="math">GF(2^w)</span>  that executes in a single clock cycle. An important property of the mode is that the counter  <span class="math">Y_0</span>  that is used to encrypt the GHASH output can immediately follow the other counters through the AES pipeline, so that after the plaintext is encrypted, only one additional clock is needed to compute the authentication tag. Thus GCM can achieve</p>

    <p class="text-gray-300">C(s) = ds/16e + 1 by having the data from each packet immediately follow that of the previous packet through the pipeline. CWC is similar but requires an additional AES encryption to process the authentication tag. This causes a pipeline stall of 10 clock cycles during which the tag passes through the AES pipeline; thus for CWC, C(s) = ds/16e + 11.</p>

    <p class="text-gray-300">In OCB (Figure 1, bottom), the AES pipline is used in three distinct ways: to encrypt the IV, to encrypt the plaintext, and to compute the authentication tag. The pipeline stalls for ten clock cycles while the IV is being encrypted. After that computation, the stall continues for another ten clock cycles, until the plaintext that is being encrypted appears at the output of the pipeline as ciphertext. After all of the plaintext has been encrypted, the 'checksum' value is encrypted; this operation requires only a single clock cycle, because the data from the IVencryption of the next packet can follow the data from the checksum-encryption through the pipeline. Thus OCB can achieve COCB = ds/16e + 21. In Table</p>

    <p class="text-gray-300">    <img src="_page_5_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Pipelined high-speed implementations of AES-128 GCM (top) and AES-128 OCB (bottom). During each clock cycle, 128 bits of data move across each arrow. Some details have been omitted for clarity.</p>

    <p class="text-gray-300">1, we compare the GCM, CWC, and OCB implementations described above. Various data sizes are included, along with the Internet Performance Index, and throughput is shown in bits per clock cycle. GCM excels the other modes in every category, especially at shorter lengths, because it keeps its pipeline full. In a crypto module that can process 128 bits per clock cycle, an ten-cycle pipeline stall has a considerable opportunity cost: 160 bytes could be encrypted during that time. GCM performance on the IPI is over twice that of CWC and over three times that of OCB. The circuit cost of GCM is higher than that of OCB because of its finite-field multiplier, but GCM is still the most economical mode for highspeed operation. Even in the unlikely case that this multiplier required a circuit as large as the entire AES pipeline, a single GCM instance would have higher throughput on Internet data than three OCB implementations, while having less total circuit area. The cost of a single-clock GF(2<sup>128</sup>)-multiplier has been estimated at 30% of the cost of the AES-128 pipeline; a detailed analysis of this cost is beyond the scope of this paper. The circuit cost of CWC is significantly higher than that of GCM because it uses an integer multiplier rather than a binary-field multiplier.</p>

    <p class="text-gray-300">Table 1. Hardware performance in bits per clock cycle, with three significant digits, for a variety of packet sizes and the Internet Performance Index (IPI).</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bytes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">20</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">40</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">44</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">64 128 256 552 576 1024 1500 8192</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">IPI</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCM 64.0 71.1 91.4 93.9 102 114 120 124 124</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">126</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">127</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">128 77.7</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CWC 10.7 13.1 23.7 25.6 34.1 53.9 75.9 97.0 98.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">109</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">115</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">125 35.3</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OCB 5.82 7.19 13.6 14.8 20.5 35.3 55.4 79.6 80.8 96.4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">105</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">123 22.8</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 Software</h3>

    <p class="text-gray-300">We tested software implementations of GCM, EAX, CCM, CWC, and OCB, each instantiated with the AES-128 cipher [25]. We also included CBC with HMAC-SHA1 to represent common current practice. We used the best available implementation of each mode, modified to use the fastest available AES implementation. All experiments took place on a 1Ghz Motorola G4 CPU using the GNU C compiler version 3.3 with full optimization. In this enviornment, AES-128 itself ran at 25 cycles per byte<sup>1</sup> . Qualitatively similar results were found on an Intel P4 [11], though CWC performed better on that CPU<sup>2</sup> . We tested GCM with both of the GHASH implementation strategies described in its specification, using 256 byte and 4Kb tables with Shoup's method [24] and 64Kb with the straightforward method. Table 2 shows our results. GCM has the best performance for the Internet Performance Index and on packets up to 576 bytes, while OCB has the best performance on larger packets. This result is easy to understand: OCB uses one more AES encryption per packet, while GCM does a GF(2<sup>w</sup>)-multiply operation per block that OCB does not. The point at which</p>

    <p class="text-gray-300"><sup>1</sup> Faster implementations have been reported for some CPUs, but are not publicly available. The table-driven GHASH algorithm, which uses the same basic operations as AES, may be able to benefit from similar implementation techniques.</p>

    <p class="text-gray-300"><sup>2</sup> Gladman's Intel implementations used Bernstein's floating-point multiplication techniques [?], which provide significant advantages on some processors.</p>

    <p class="text-gray-300">their performance is equal reflects the number of multiplies that can be done in the time taken for a single AES encryption.</p>

    <p class="text-gray-300">Table 2. Software performance in bits per kilocycle (or equivalently, megabits per second on a 1GHz processor) to three significant digits, on various packet sizes, and the Internet Performance Index (IPI), for various AES-128 modes of operation. GCM256, GCM4K, and GCM64K refer to GCM with 256, 4K, and 64K byte table sizes, respectively. The highest entry in each column is highlighted.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Bytes</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">16</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">20</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">40</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">44</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">64 128 256 552 576 1024 1500 8192</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">IPI</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCM64K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">136 167 227 253 223 263 267 273 273</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">266</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">266</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">258 268</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCM4K</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">116 140 190 207 192 213 229 237 233</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">239</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">247</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">240 240</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">GCM256</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">88.4 107 148 160 177 162 171 183 184</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">181</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">183</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">182 182</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">OCB</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">89.5 85.7 140 150 185 225 255 261 265 273 275 282 260</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CWC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">45.7 51.9 73.4 75.5 88.1 104 116 127 126</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">131</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">124</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">135 121</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">EAX</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">46.0 44.9 73.4 80.0 102 129 148 157 160</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">165</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">167</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">174 156</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CCM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">91.3 88.9 123 133 142 171 163 168 168</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">174</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">172</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">175 168</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">CBC-HMAC</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">6.3</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">8.0 15.2 16.6 23.4 39.0 64.5 96.0 97.0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">117</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">129</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">156 88.6</td>
          </tr>
        </tbody>
      </table>
    </div>

      <h3 id="sec-3.3" class="text-xl font-semibold mt-8">3.3 Other Applications</h3>

    <p class="text-gray-300">GCM can be used in an authentication-only mode, in which the data to be authenticated is included in A and the plaintext has zero length. In this mode (called GMAC), GCM has even more compelling advantages over most other modes because it avoids calling the block cipher once per block of data. (CWC is the only other mode with this property.) For instance, GMAC in our software test environment can process 1500-byte packets in 10.2 cycles per byte, whereas PMAC, a stand-alone MAC based on OCB [8], requires 27.6 cycles per byte.</p>

    <p class="text-gray-300">The Secure Real-time Transport Protocol (SRTP) encrypts and authenticates real-time traffic, such as conversational voice, at the transport layer [1]. Typical plaintext sizes for this traffic include 20 bytes for the G.729 encoding, and 80 bytes for the G.721 encoding; GCM's performance on short packets makes it ideal for this application.</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Security</h2>

    <p class="text-gray-300">The security of GCM stands on a single cryptographic conjecture: the block cipher E is assumed to be a secure pseudorandom permutation (PRP). To paraphrase Occam, we do not multiply conjectures beyond necessity. This requirement is met when E cannot be distinguished from a random permutation by an adversary that can choose its inputs and view its outputs. To formalize this idea, we use standard definitions from concrete security analysis, following [4]. The permutation oracle has the same interface as does the block cipher E with a fixed key. It takes as input a plaintext in {0, 1} <sup>w</sup> and returns a ciphertext in  <span class="math">\\{0,1\\}^w</span> . We consider the experiment in which the adversary is given access to a permutation oracle and is challenged to determine whether it is the block cipher E with a randomly selected key (we denote this event as  <span class="math">B_E</span> ), or a random permutation (which we denote as  <span class="math">B_E^c</span> ). Each of these cases occurs with probability of 1/2. During the experiment, the adversary makes queries to the oracle and receives its responses. Afterwards, the adversary returns a bit that indicates its guess as to the content of the oracle. We denote as D the event that it guesses that  <span class="math">B_E</span>  occurred, and denote as  <span class="math">D^c</span>  the guess that  <span class="math">B_E^c</span>  occurred.</p>

    <p class="text-gray-300">We define the distinguishing advantage  <span class="math">A_E</span>  as the adversary's true positive probability less her false positive probability, that is,</p>

    <p class="text-gray-300"><span class="math">$A_E = \\mathbf{P}[D \\mid B_E] - \\mathbf{P}[D \\mid B_E^c]. \\tag{5}</span>$</p>

    <p class="text-gray-300">Here we use the conventional notation that  <span class="math">\\mathbf{P}[\\mathcal{X}]</span>  denotes the probability that the event  <span class="math">\\mathcal{X}</span>  occurs, and  <span class="math">\\mathbf{P}[\\mathcal{X} \\mid \\mathcal{Y}] = \\mathbf{P}[\\mathcal{X} \\cap \\mathcal{Y}]/\\mathbf{P}[\\mathcal{Y}]</span>  denotes the probability that  <span class="math">\\mathcal{X}</span>  occurs, given that the event  <span class="math">\\mathcal{Y}</span>  has occured. We also use  <span class="math">\\mathcal{X} \\cap \\mathcal{Y}</span>  to denote the event in which both events  <span class="math">\\mathcal{X}</span>  and  <span class="math">\\mathcal{Y}</span>  occur, and use  <span class="math">\\mathcal{X}^c</span>  to denote the complement of  <span class="math">\\mathcal{X}</span> , that is, the event that  <span class="math">\\mathcal{X}</span>  does not occur. We make the simplifying assumption that  <span class="math">A_E &gt; 0</span> , because an adversary that is consistently wrong can turn itself into one that is consistently right by just inverting its output. Thus the value  <span class="math">A_E</span>  ranges between 0 and 1, inclusive.</p>

    <p class="text-gray-300">Our model for the security of an AEAD system follows Rogaway [21]. The authenticated encryption oracle models the GCM authenticated encryption operation. It takes as input the bit strings IV, A, and P and returns the bit strings C and T, whose lengths obey the restrictions of Equations 1. The authenticated decryption oracle accepts inputs of the form (IV, A, C, T) and returns as its outputs either the special symbol <strong>FAIL</strong> or the plaintext P, where all of the bit strings are as defined above. We let the adversary choose the IVs, but assume that she is nonce-respecting and will not submit the same IV value to the same oracle multiple times (though she is free to submit a value to both oracles). We allow the adversary to interleave queries to these oracles. For our definition of confidentiality, we use the indistinguishability of ciphertext from random under a chosen plaintext attack and indistinguishability of plaintext from random under a chosen ciphertext attack. This strong definition has been shown to be equivalent to several other definitions [2]. Under these assumptions, GCM encryption is secure if an adversary presented with these oracles cannot tell if they contain GCM with a randomly selected key ( we denote this event as  <span class="math">B_{\\text{GCM}}</span> ) or if C and T are a random function of the other inputs (which we denote as  <span class="math">B_{\\text{GCM}}^c</span> ). Each of these cases occurs with probability 1/2. Because GCM is not a generic composition of a cipher and a MAC, we cannot use the results of Bellare and Namprempre [5]. Most importantly, the use of the same secret value H for both hashing the IV and for computing the authentication tag provides the adversary a potential attack vector against confidentiality. For this reason, we need to give adversary access to the authenticated decryption oracle.</p>

    <p class="text-gray-300">GCM uses E as a pseudorandom function (PRF). In our analysis, we make use of the well-known result on the use of a PRP as a PRF [4]. Our definition of PRF security considers the experiment in which we are given access to</p>

    <p class="text-gray-300">the function oracle, and are challenged to determine whether it contains a true random function or a PRF. That oracle has the same interface as does the permutation oracle; unlike that oracle, the function oracle may not be invertible. We use the convention that  <span class="math">B_{\\rm PRF}</span>  denotes the PRF case and  <span class="math">B_{\\rm PRF}^c</span>  denotes the random function case. The advantage of a PRF-distinguisher is given by  <span class="math">A_{\\rm PRF} = \\mathbf{P}[D \\mid B_{\\rm PRF}] - \\mathbf{P}[D \\mid B_{\\rm PRF}]</span> . The distinguishing advantage against a PRF is similar to that against a PRP, and has similar properties. The following Lemma bounds  <span class="math">A_{\\rm PRF}</span>  in terms of  <span class="math">A_E</span> .</p>

    <p class="text-gray-300"><strong>Lemma 1 (A PRP can be a good PRF).</strong> The advantage  <span class="math">A_{PRF}</span>  of an adversary in distinguishing a w-bit PRP E from a random function is bounded by  <span class="math">A_{PRF} \\leq A_E + q(q-1)2^{-w-1}</span> , where  <span class="math">A_E</span>  is the adversary's advantage in distinguishing E from a random permutation, and the value q is the number of queries to the function oracle.</p>

    <p class="text-gray-300"><strong>Theorem 1 (GCM Encryption is Secure).</strong> If there is an adversary that can distinguish GCM encryption from a random function with advantage  <span class="math">A_{GCM}</span> , when the output of that function is limited to q queries to the authenticated encryption and decryption oracles, where the total number of plaintext bits processed is  <span class="math">l_P</span>  and where  <span class="math">len(C) + len(A) \\leq l</span>  and  <span class="math">len(IV) \\leq l_{IV}</span>  for each query, then that adversary can distinguish E from a random permutation with advantage  <span class="math">A_E</span> , where</p>

    <p class="text-gray-300"><span class="math">$A_E \\ge A_{GCM} - (l_P/w + 2q)^2 2^{-w-1} - q((l_P/w + 2q)\\lceil l_{IV}/w + 1\\rceil 2^{1-w} + \\lceil l/w + 1\\rceil 2^{-t}).</span>$</p>

    <p class="text-gray-300">This result is similar to that for counter mode, with a term that is quadratic in  <span class="math">l_{\\rm P}</span> . It also has a term that is linear in both  <span class="math">l_{\\rm P}</span>  and  <span class="math">ql_{\\rm IV}</span> , which is due to the fact that collisions in the counter values are more likely when the lengths of the IVs that are hashed becomes greater. This term is dominant when  <span class="math">ql_{\\rm IV}&gt;l_{\\rm P}</span> . The implication is that when long IVs are used, fewer queries should be made before a key is changed. However, in most cases  <span class="math">l_{\\rm IV}</span>  will be no greater than l, and thus the accommodation of variable length IVs comes at negligible security cost.</p>

    <p class="text-gray-300">The authentication tag size t affects the security of GCM encryption, but its effect is relatively weak. The term containing  <span class="math">2^{-t}</span>  in the bound on  <span class="math">A_E</span>  does not dominate that value as long as t is greater than about  <span class="math">w - \\lg (q \\lceil l/w \\rceil + \\lceil l_{\\text{IV}}/w \\rceil)</span> .</p>

      <h3 id="sec-4.1" class="text-xl font-semibold mt-8">4.1 Authentication</h3>

    <p class="text-gray-300">We use the standard model for the security of a MAC in the presence of a chosen-message attack, in which an adversary is given access to a tag generation oracle and a message/tag verification oracle. The adversary can pass messages to the tag generation oracle and construct any message/tag pairs that it likes and send these to the verification oracle. Queries to the oracles can be interleaved by the adversary, if desired. The forgery advantage  <span class="math">F_{\\rm GCM}</span>  is the probability that the adversary can get the verification oracle to accept a message/tag pair other than one generated by the tag generation oracle, after making q queries to the tag-generation oracle and the verification oracle.</p>

    <p class="text-gray-300"><strong>Theorem 2 (GCM authentication is secure).</strong> An adversary with forgery advantage  <span class="math">F_{GCM}</span>  against GCM, when q,  <span class="math">l_P</span> , l and  <span class="math">l_{IV}</span>  are as defined in Theorem 1, has a distinguishing advantage  <span class="math">A_E</span>  against the pseudorandom permutation E used in GCM of at least  <span class="math">F_{GCM} - (l_P/w + 2q)^2 2^{-w-1} - q((l_P/w + 2q + 1)\\lceil l_{IV}/w + 1\\rceil 2^{1-w} + \\lceil l/w + 1\\rceil 2^{-t})</span> .</p>

    <p class="text-gray-300">Like most authentication modes, the forgery advantage has a term that is quadratic in the amount of data that is authenticated. This term is dominant whenever many short messages are processed, as is typical for network crypto modules. When very long messages are processed, the term proportional to l will dominate. This term is characteristic of MACs that are based on universal hashing.</p>

      <h3 id="sec-4.2" class="text-xl font-semibold mt-8">4.2 AES GCM Security</h3>

    <p class="text-gray-300">To tie our analysis to current practice, we apply it to the AES GCM specification for IPsec [26], for which  <span class="math">l_{\\rm IV}=96</span>  and t=96. Any of the AES key lengths (of 128, 192, and 256 bits) can be used; for each variant, the block width w=128. We use the typical Internet maximum packet size of 1500 bytes ( <span class="math">l \\leq 12000</span> ). The security of AES-N-GCM (for N=128, 192, or 256) is captured in the following corollary.</p>

    <p class="text-gray-300"><strong>Corollary 1.</strong> If there are no attacks against AES-N that can distinguish it from a random permutation with advantage greater than  <span class="math">A_{AES-N}</span> , and no more than q packets are processed, then</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>there are no distinguishing attacks against AES-N-GCM that work with distinguishing advantage greater than  <span class="math">A_{AES-N} + q^2 2^{-116} q 2^{-89.4}</span> , and</li>
      <li>there are no forgery attacks against AES-N-GCM that work with forgery advantage greater than  <span class="math">A_{AES-N}+q^22^{-116}-q2^{-89.4}-q2^{-128}</span> .</li>
    </ul>

    <p class="text-gray-300">In these equations, the key size appears implicitly in the value of  <span class="math">A_{AES-N}</span> . To provide a concrete example, these results show that, if AES is indistinguishable from a random permutation, and fewer than  <span class="math">2^{48}</span>  packets are protected, then the attacker's advantage is no more than  <span class="math">2^{-18}</span> .</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Other Security Aspects</h2>

    <p class="text-gray-300">We next consider system-security aspects. Having shown GCM secure when used properly, we consider what can go wrong. One often overlooked aspect of mode security is the consequence of IV misuse. It is well known that reusing a key/IV pair in CTR results in a loss of confidentiality for the messages that used the common IV value. Since GCM is built on top of CTR, it shares this property. However, the reuse of an IV in the GCM authenticated encryption operation (e.g. on the sender's side) causes even worse problems. It allows the attacker to solve for the underlying GHASH key H, making subsequent forgeries trivial and also enabling the attacker to choose IVs that will cause colliding counters. However, the reuse of an IV in the authenticated decryption operation (on the</p>

    <p class="text-gray-300">receiver's side) does not cause this problem. If an attacker convinces a receiver to decrypt multiple messages with the same IV, she still cannot exploit this situation to glean information about H efficiently. Fortunately, it is often comparatively easy for a sender to protect against IV reuse, for example, by using a simple message counter as an IV. Additionally, GCM's ability to accept an arbitrary-length IVs makes it easier to ensure all IVs are unique, by including any possible distinguishing information, no matter how verbose. Interestingly, CWC avoids some of these issues by using the underlying block cipher to encrypt the output of its universal hash function. But this aspect of its design is responsible for causing the pipeline stalls that significantly degrade CWC's performance.</p>

    <p class="text-gray-300">It is possible that H = E(K, 0 <sup>w</sup>) = 0, and in this case, GHASH(H, A, C) = 0 <sup>w</sup> for all values of A and C. If E behaves as a random permutation, then the expected number of keys for which H = 0<sup>w</sup> is the fraction 2<sup>&minus;</sup><sup>w</sup> times the number of keys. This fact does not degrade the effectiveness of the message authentication; it is implicitly dealt with in the proof of security. When H = 0<sup>w</sup>, the authentication tags will not be predictable; that case is no easier to detect than any other value of the key. However, that value causes all IVs to hash to the same value (if 96-bit IVs are not used). For this reason, some users may want to avoid using that key, e.g. by using the convention that H is set to a fixed value whenever the zero value is detected at key setup time. Of course, that key is so unlikely to arise in practice that its effect on the bounds in the security proofs are negligible, and it is equally reasonable not to bother to check for it.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Baugher , D. McGrew, M. Naslund, E. Carrara, K. Norrman. &quot;The Secure Real-time Transport Protocol,&quot; IETF RFC 3711, March 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. &quot;A concrete security treatment of symmetric encryption,&quot; In Proceedings of the 38th FOCS, IEEE Computer Society Press, 1997.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, O. Goldreich, and S. Goldwasser, &quot;Incremental cryptography: the case of hashing and signing&quot;, CRYPTO '94, LNCS, Springer-Verlag, Aug. 1994.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, J. Kilian, P. Rogaway, &quot;The Security of the Cipher Block Chaining Message Authentication Code,&quot; J. Comput. Syst. Sci. 61(3). pg. 362-399 (2000).</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare and C. Namprempre, &quot;Authenticated encryption: Relations among notions and analysis of the generic composition paradigm,&quot; ASIACRYPT '00, Springer-Verlag, LNCS, 2000.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Bernstein. Floating-point arithmetic and message a uthentication, Manuscript, 2000. Available online at http://cr.yp.to/p apers.html#hash127.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Bellare, P. Rogaway, and D. Wagner, &quot;A conventional authenticatedencryption mode&quot;, Submission to NIST Modes of Operation process, 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Black and P. Rogaway, &quot;A Block-Cipher Mode of Operation for Parallelizable Message Authentication,&quot; EUROCRYPT '02, LNCS, Springer-Verlag, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>N. Biggs. Discrete Mathematics, Revised Edition, Oxford Science Publications, Oxford University Press. 1993.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>K. Claffy, G. Miller, K. Thompson, &quot;The nature of the beast: recent traffic measurements from an Internet backbone,&quot; INET '98, ISOC, 1998.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>B. Gladman, &quot;AES and Combined Encryption/Authentication Modes,&quot; Web Page, http://fp.gladman.plus.com/AES/index.htm, February, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Gligor and P. Donescu, &quot;Fast encryption and authentication: XCBC encryption and XECB authentication modes,&quot; Proceedings of the Fast Software Encryption Workshop - FSE '01. Springer-Verlag, 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>T. Iwata, K. Kurosawa, &quot;OMAC: One-Key CBC MAC,&quot; Submission to NIST Modes of Operation Process, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>C. Jutla, &quot;Encryption modes with almost free message integrity,&quot; Advanced in Cryptology - EUROCRYPT '01, Springer-Verlag, 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>S. Kent, R. Atkinson, &quot;IP Encapsulating Security Payload (ESP),&quot; IETF Request For Comments (RFC) 2406, November 1998.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>T. Kohno, J. Viega, and D. Whiting, &quot;The CWC-AES Dual-use Mode,&quot; Submission to NIST Modes of Operation Process, 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>H. Krawczyk, &quot;LFSR-based hashing and authentication,&quot; In Y. Desmedt, editor, CRYPTO '94, LNCS, Springer-Verlag, Aug. 1994.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. McGrew, &quot;The Universal Security Transform,&quot; IETF Internet Draft, Work in Progress. Oct. 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. McGrew and J. Viega, &quot;The Galois/Counter Mode of Operation (GCM),&quot; Submission to NIST Modes of Operation Process, January, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. McGrew and J. Viega, &quot;The Security and Performance of the Galois/Counter Mode (GCM) of Operation,&quot; INDOCRYPT '04, LNCS, Springer-Verlag, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. Rogaway. &quot;Authenticated encryption with associated data,&quot; In Proceedings of the 9th CCS, Nov. 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>P. Rogaway, M. Bellare, J. Black, and T. Krovitz, &quot;OCB: a block-cipher mode of operation for efficient authenticated encryption,&quot; ACM CCS, 2001.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Romanow, Ed. &quot;Media Access Control (MAC) Security&quot;, IEEE 802.1AE, Draft Standard, July, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>V. Shoup, &quot;On Fast and Provably Secure Message Authentication Based on Universal Hashing,&quot; CRYPTO '96, LNCS, Springer-Verlag, 1996.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>U.S. National Institute of Standards and Technology. The Advanced Encryption Standard. Federal Information Processing Standard (FIPS) 197, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>J. Viega and D. McGrew, &quot;The Use of Galois/Counter Mode (GCM) in IPsec ESP,&quot; IETF Internet Draft, Work in Progress, April, 2004.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>M. Wegman and L. Carter, &quot;New hash functions and their use in authentication and set equality,&quot; Journal of Computer and System Sciences, 22:265279, 1981.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>D. Whiting, N. Ferguson, and R. Housley, &quot;Counter with CBC-MAC (CCM),&quot; Submission to NIST Modes of Operation Process, 2002.</li>
    </ul></li>
    </ul>

    </section>

    <section id="app-a" class="mb-10">
      <h2 class="text-2xl font-bold">A Properties of GHASH</h2>

    <p class="text-gray-300">We now show that GHASH has the properties that we need, in the next three straightforward lemmas.</p>

    <p class="text-gray-300">Lemma 2 (GHASH is almost xor universal). The function GHASH is  <span class="math">\\lceil l/w+1 \\rceil 2^{-t}</span> -almost xor universal when its second and third inputs are restricted so that their lengths sum to l or fewer bits and its output is truncated to t bits.</p>

    <p class="text-gray-300"><em>Proof.</em> We consider two distinct inputs (A, C) and (A', C'), then analyze the probability of the event that</p>

    <p class="text-gray-300"><span class="math">$GHASH(H, A, C) \\oplus GHASH(H, A&#x27;, C&#x27;) = a||z,</span>$
(6)</p>

    <p class="text-gray-300">for some fixed t-bit value a and any value of the t-bit variable z (which we use to account for the truncation of the GHASH ouput). We assume that these inputs are formatted as described in Section 2, in which A, C, A', and C' consist of m, n, m', and n' w-bit blocks, respectively, the final blocks of which have lengths v, u, v', and u', respectively. We let  <span class="math">p = \\max(m+n, m&#x27;+n&#x27;)</span>  denote the number of blocks in the longer input. We define the blocks  <span class="math">D_i, D_i&#x27;</span>  for  <span class="math">1 \\le i \\le p+1</span>  as</p>

    <p class="text-gray-300"><span class="math">$D_{i} = \\begin{cases} A_{i} &amp; \\text{for } i = 1, \\dots, m - 1 \\\\ A_{m}^{*} \\| 0^{w-v} &amp; \\text{for } i = m \\\\ C_{i-m} &amp; \\text{for } i = m + 1, \\dots, m + n - 1 \\\\ C_{n}^{*} \\| 0^{w-u} &amp; \\text{for } i = m + n \\\\ \\operatorname{len}(A) \\| \\operatorname{len}(C) &amp; \\text{for } i = m + n + 1 \\\\ 0^{w} &amp; \\text{for } m + n + 2, \\dots, p + 1. \\end{cases}</span>$</p>

    <p class="text-gray-300"><span class="math">$(7)</span>$</p>

    <p class="text-gray-300">We similarly define the blocks  <span class="math">D&#x27;_i</span>  for based on the input (A', C').</p>

    <p class="text-gray-300">The condition that  <span class="math">GHASH(H, A, C) \\oplus GHASH(H, A&#x27;, C&#x27;) = a||z|</span>  can be expressed as R(H) = 0, where the polynomial R of degree at most p + 1 over  <span class="math">GF(2^w)</span>  is defined by</p>

    <p class="text-gray-300"><span class="math">$R(H) = (a||z) \\oplus \\bigoplus_{i=1}^{p} (D_i \\oplus D&#x27;_i) \\cdot H^i.</span>$
(8)</p>

    <p class="text-gray-300">The polynomial R must be nonzero, because the strings A||C and A'||C' are distinct. There are at most p+1 values of  <span class="math">H \\in G</span>  for which R(H)=0 holds. This follows from the fact that an  <span class="math">d^{th}</span>  degree polynomial over  <span class="math">GF(2^w)</span>  has at most d distinct roots (this is the fundamental theorem of algebra over a finite field; see, for example, [9, Theorem 15.8.2]), and the fact that R is nonzero. The probability that R(H)=0 holds, given that H is chosen at random from  <span class="math">GF(2^w)</span> , is  <span class="math">(p+1)/2^w \\leq \\lceil l/w+1 \\rceil 2^{-w}</span> , when the cumulative length of the inputs is restricted to l bits.</p>

    <p class="text-gray-300">For each vector D, there is a unique pair (A, C) where both A and C are bit strings as described in Section 1, and vice-versa. This is because the last</p>

    <p class="text-gray-300">element of D unambiguously encodes the lengths of both A and C. Thus, the probability that R(H)=0 holds for any two given messages (A,C) and (A',C'), and a given vector  <span class="math">a\\|z</span> , is equal to the probability that  <span class="math">GHASH(H,A,C) \\oplus GHASH(H,A&#x27;,C&#x27;)=a\\|z</span> . Because there are  <span class="math">2^{w-t}</span>  possible values for z, Equation 6 holds with probability  <span class="math">\\lceil l/w+1 \\rceil 2^{-w} \\times 2^{w-t} = \\lceil l/w+1 \\rceil 2^{-t}</span>  for any given values of (A,C),(A',C'), and  <span class="math">a \\in \\{0,1\\}^t</span> .</p>

    <p class="text-gray-300">We define the function h, which is (implicitly) used in GCM to compute the initial counter value  <span class="math">Y_0</span>  based on the IV, so that we can analyze its properties:</p>

    <p class="text-gray-300"><span class="math">$h(H, M) = \\begin{cases} M \\|0^{31}\\|1 &amp; \\text{if len}(M) = w - 32\\\\ \\text{GHASH}(H, \\{\\}, M) &amp; \\text{otherwise.} \\end{cases}</span>$
(9)</p>

    <p class="text-gray-300">Lemma 3 (h is unlikely to collide). The bound</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[h(H,IV) = \\mathrm{incr}^{j}(h(H,IV&#x27;)) \\mid H \\stackrel{R}{\\leftarrow} GF(2^{w})] \\le \\lceil l/w + 1 \\rceil 2^{-w}, \\tag{10}</span>$</p>

    <p class="text-gray-300">holds for the function h defined in Equation 9, for any values of j, IV, and IV', where the inputs IV and IV' are distinct and are allowed to have any lengths up to  <span class="math">l_{IV}</span>  bits.</p>

    <p class="text-gray-300"><em>Proof.</em> We call the event that  <span class="math">h(H, IV) = \\operatorname{incr}^{j}(h(H, IV&#x27;))</span>  as  <span class="math">\\mathcal{E}</span> , for short. We separately consider the following cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>len(IV) = len(IV') = w 32,</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>len(IV) = w 32 and  <span class="math">len(IV&#x27;) \\neq w 32</span> , and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">len(IV) \\neq w 32</span>  and len(IV') = w 32, and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">len(IV) \\neq w 32</span>  and  <span class="math">len(IV&#x27;) \\neq w 32</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">In case 1,  <span class="math">h(H, IV) = IV \\|0^{31}\\|1</span>  and  <span class="math">h(H, IV&#x27;) = IV&#x27; \\|0^{31}\\|1</span> . Because of the fact that IV and IV' are distinct and the fact that the increment function does not alter the leftmost w-32 bits of its input, the probability of a collision is zero. In case 2 when  <span class="math">\\mathcal{E}</span>  occurs it follows that</p>

    <p class="text-gray-300"><span class="math">$h(H, IV&#x27;) = \\operatorname{incr}^{-j}(IV||0^{31}||1) = IV||(1 - j \\mod 2^{32}).</span>$</p>

    <p class="text-gray-300">(Here we rely on the implicit conversion of non-negative integers to their representation as binary vectors; the important fact is that this conversion is unique and invertible.) This condition can be re-expressed as R(H) = 0, where the polynomial R of degree n' + 1 over  <span class="math">GF(2^w)</span>  is defined by  <span class="math">R = \\bigoplus_{i=1}^{n&#x27;+1} R_i \\cdot H^i</span>  with the coefficients</p>

    <p class="text-gray-300"><span class="math">$R_{i} = \\begin{cases} IV \\| (1 - j \\mod 2^{32}) &amp; \\text{for } i = 0, \\\\ IV&#x27;_{i} \\| 0^{p} &amp; \\text{for } 1 &lt; i \\le n&#x27;, \\\\ (0^{w/2} \\| \\text{len}(IV&#x27;)) &amp; \\text{for } i = n&#x27; + 1 \\end{cases}</span>$
(11)</p>

    <p class="text-gray-300">where  <span class="math">n&#x27; = \\lceil \\operatorname{len}(IV&#x27;)/w \\rceil</span>  and  <span class="math">p = \\operatorname{len}(IV&#x27;) \\mod w</span>  is the number of padding bits in the n'th coefficient. There are at most n' + 1 values of  <span class="math">H \\in G</span>  for which</p>

    <p class="text-gray-300">R(H)=0 holds, since that it is the number of distinct roots of R. This fact is true for any value of j, since each value of j corresponds to a distinct polynomial. Thus the probability of  <span class="math">\\mathcal{E}</span> , given that H is chosen at random from  <span class="math">GF(2^w)</span> , is  <span class="math">(n&#x27;+1)/2^w \\leq \\lceil l_{\\text{IV}}/w+1 \\rceil 2^{-w}</span> . Case 3 is identical to case 2 after a relabeling of IV and IV'. In Case 4, the probability that h(H, IV) = h(H, IV') is equal to the probability that  <span class="math">GHASH(H, \\{\\}, IV) = GHASH(H, \\{\\}, IV&#x27;)</span> , which is no greater than  <span class="math">\\lceil l_{\\text{IV}}/w+1 \\rceil 2^{-w}</span>  from Lemma 2. The claimed result holds in all four</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> (h is unlikely to return zero). The function h defined in Equation 9 satisfies</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[h(H,IV) = 0^w \\mid H \\stackrel{R}{\\leftarrow} GF(2^w)] \\le \\lceil l_{IV}/w + 1 \\rceil 2^{-w} \\text{ for all } IV : \\operatorname{len}(IV) \\le l_{IV}.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> When len(IV) = w - 32, then the probability is equal to zero. Otherwise, the condition that h(H, IV) = 0 can be re-expressed as R(H) = 0, where the polynomial R has the coefficients</p>

    <p class="text-gray-300"><span class="math">$R_{i} = \\begin{cases} 0 &amp; \\text{for } i = 0, \\\\ IV_{i-1} &amp; \\text{for } i = 1 \\le n+1 \\\\ 0^{w/2} || \\text{len}(IV) &amp; \\text{for } i = n+1, \\end{cases}</span>$
(12)</p>

    <p class="text-gray-300">and  <span class="math">n = \\lceil \\operatorname{len}(N)/w \\rceil</span> . There are no more than  <span class="math">\\lceil l_{\\text{IV}}/w + 1 \\rceil</span>  values of H that satisfy this equation, because each of those values is a root of R(H) = 0 over  <span class="math">GF(2^w)</span> . Because H is chosen at random, the probability that R(H) = 0 is no more than  <span class="math">\\lceil l_{\\text{IV}}/w + 1 \\rceil 2^{-w}</span> .</p>

    </section>

    <section id="app-b" class="mb-10">
      <h2 class="text-2xl font-bold">B Proofs of Theorems 1 and 2</h2>

    <p class="text-gray-300">We first prove Theorem 2, which shows that GCM is a good MAC, then we prove Theorem 1, which shows that GCM's encryption is effective. This order is important, since we use results from the analysis of the forgery probability when analyzing encryption. We start by reviewing message authentication based on universal hashing.</p>

    <p class="text-gray-300">A function g(K, M) is  <span class="math">\\epsilon</span> -almost xor universal [17] if</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[g(K,M) \\oplus g(K,M&#x27;) = a \\mid K \\stackrel{R}{\\leftarrow} \\{0,1\\}^n] \\le \\epsilon \\text{ for all } M \\ne M&#x27; \\text{ and } a.</span>$
(13)</p>

    <p class="text-gray-300">Here the expression  <span class="math">K \\stackrel{R}{\\leftarrow} \\{0,1\\}^n</span>  denotes the event that K is chosen at random from the set  <span class="math">\\{0,1\\}^n</span> . We diverge slightly from the usual definition in order to make our exposition more explicit<sup>3</sup>.</p>

    <p class="text-gray-300"><sup>&amp;</sup>lt;sup&gt;3</sup> In the standard definition, g would define a family of (unkeyed) hash functions, and we would select a function from that family. Our keyed hash function corresponds to the hash function family, and a particular value of the key K corresponds to a particular function in that family.</p>

    <p class="text-gray-300">An  <span class="math">\\epsilon</span> -almost xor universal function can be combined with a pseudorandom function to make a strong MAC. First, we analyze the security of the ideal case, following Krawczyk [17]. We consider the message authentication code AXUMAC defined by  <span class="math">T = R(N) \\oplus H(K,M)</span> , where the hash function H(K,M) is  <span class="math">\\epsilon</span> -almost xor universal and R is a random function. Here M is a message, N is a nonce and T is the tag corresponding to M and N.</p>

    <p class="text-gray-300"><strong>Lemma 5 (AXU-MAC is secure).</strong> If H is  <span class="math">\\epsilon</span> -almost xor universal, then the probability of success of a single forgery attempt against AXU-MAC is no greater than  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The lemma follows directly from the properties of an xor-universal hash function. We denote as (N, M', T') the 3-tuple that represents a forgery attempt, and we assume that the adversary has access to a valid 3-tuple (N, M, T), with  <span class="math">T = R(N) \\oplus H(K, M)</span> , for the same nonce value N. Then</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[\\ (N, M, T) \\text{ accepted }] = \\mathbf{P}[T&#x27; \\oplus T = H(K, M&#x27;) \\oplus H(K, M)] \\le \\epsilon. \\ \\Box</span>$
(14)</p>

    <p class="text-gray-300">The best strategy for forging messages is to choose values of  <span class="math">M \\oplus M&#x27;</span>  and  <span class="math">T&#x27; \\oplus T</span>  such that the lower bound on the probability is met. A simple but important corollary follows.</p>

    <p class="text-gray-300">Corollary 2. The forgery advantage against AXU-MAC is no greater than  <span class="math">q\\epsilon</span> , whenever q queries to the authentication and verification oracles are allowed.</p>

    <p class="text-gray-300"><em>Proof.</em> We define the event  <span class="math">U_i</span>  as the case in which the adversary does not produce a successful forgery against AXU-MAC on the i query to the message/tag-verification oracle. If  <span class="math">U_1 \\cap U_2 \\dots \\cap U_i</span>  occurs, then the probability of the adversary succeeding in its next forgery attempt is limited by Lemma 5; thus</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[U_{i+1} \\mid U_i \\cap U_{i-1} \\cap \\ldots \\cap U_1] \\ge 1 - \\epsilon. \\tag{15}</span>$</p>

    <p class="text-gray-300">This fact holds independent from the number of queries that have been made to the tag-generation oracle. For any set of events  <span class="math">A_1, A_2, \\ldots, A_n</span>  such that  <span class="math">\\mathbf{P}[A_1 \\cap A_2 \\cap \\ldots \\cap A_n] &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[A_1 \\cap A_2 \\cap \\ldots \\cap A_n] = \\mathbf{P}[A_n \\mid A_1 \\cap A_2 \\cap \\ldots \\cap A_{n-1}] \\times \\mathbf{P}[A_{n-1} \\mid A_1 \\cap \\ldots \\cap A_{n-2}] \\times \\mathbf{P}[A_{n-2} \\mid A_1 \\cap \\ldots \\cap A_{n-3}] \\times \\cdots \\times \\mathbf{P}[A_1].</span>$</p>

    <p class="text-gray-300">The probability  <span class="math">\\mathbf{P}[U_1 \\cap U_2 \\dots \\cap U_q]</span>  that there are no successful forgeries after q queries to each oracle is at least  <span class="math">(1-\\epsilon)^q</span> . The forgery advantage is no more than  <span class="math">1-(1-\\epsilon)^q \\leq q\\epsilon</span> , with the inequality following from using Taylor's theorem with remainder.</p>

    <p class="text-gray-300">Proof of Theorem 2. We proceed by treating E as a PRF, not a PRP, then rationalize this assumption using Lemma 1. We assume that we have a machine that generates GCM message/tag pairs with forgery advantage  <span class="math">F_{\\rm GCM}</span> , using a chosen-message attack. We use this machine to distinguish between the case that</p>

    <p class="text-gray-300">the oracle contains GCM implemented with E, which we denote as  <span class="math">B_{\\rm PRF}</span> , and the case of GCM implemented with a random function, which we denote as  <span class="math">B_{\\rm PRF}^c</span> . We measure the advantage  <span class="math">A_{\\rm PRF}</span>  defined above. We use the function oracle to implement GCM, by replacing each invocation of E with an invocation to that oracle, then run the machine and provide it with access to a tag-generation oracle and a message/tag verification oracle. If the machine succeeds in forging a message/tag pair, then we guess that event  <span class="math">B_{\\rm PRF}</span>  occurred, otherwise, we guess that  <span class="math">B_{\\rm PRF}^c</span>  occurred. We compute the hash key H by querying the function oracle with the input value  <span class="math">0^w</span>  at the very outset of the experiment, and set that key to the value returned by the oracle. We denote the event that none of the counter values  <span class="math">Y_i</span>  input to the function oracle during the experiment are equal to the zero value  <span class="math">0^w</span>  as  <span class="math">\\mathcal{Z}</span> . We also consider the event  <span class="math">\\mathcal{Y}</span>  that all counter values are distinct, for the entire run of the experiment, as used in the proof of Theorem 1. Our analysis uses the following facts:</p>

    <p class="text-gray-300">Fact 1.  <span class="math">F_{GCM} = \\mathbf{P}[D \\mid B_{PRF}]</span> , which follows directly from the definition of the forgery advantage.</p>

    <p class="text-gray-300"><strong>Fact 2.</strong> For any three events A, B and C (with  <span class="math">P[B] \\neq 0</span> ),</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[A \\mid B] = \\frac{\\mathbf{P}[A \\cap B]}{\\mathbf{P}[B]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\mathbf{P}[A \\cap B \\cap C]}{\\mathbf{P}[B]} + \\frac{\\mathbf{P}[A \\cap B \\cap C^{c}]}{\\mathbf{P}[B]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\mathbf{P}[A \\cap B \\cap C]}{\\mathbf{P}[B \\cap C]} \\frac{\\mathbf{P}[B \\cap C]}{\\mathbf{P}[B]} + \\frac{\\mathbf{P}[A \\cap B \\cap C^{c}]}{\\mathbf{P}[B \\cap C^{c}]} \\frac{\\mathbf{P}[B \\cap C^{c}]}{\\mathbf{P}[B]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{P}[A \\mid B \\cap C] \\mathbf{P}[C \\mid B] + \\mathbf{P}[A \\mid B \\cap C^{c}] \\mathbf{P}[C^{c} \\mid B]. \\quad (16)</span>$</p>

    <p class="text-gray-300">Fact 3.  <span class="math">\\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^c \\cap \\mathcal{Y} \\cap \\mathcal{Z}] \\leq q\\lceil l/w+1\\rceil 2^{-t}</span> , because when the events  <span class="math">B_{\\mathrm{PRF}}^c, \\mathcal{Y}</span> , and  <span class="math">\\mathcal{Z}</span>  occur in conjunction, Lemma 5 applies. When  <span class="math">B_{\\mathrm{PRF}}^c</span>  occurs, the hash key H is chosen uniformly at random, as required by that lemma. When  <span class="math">\\mathcal{Z}</span>  occurs, H is not used to encrypt any plaintext block, and the adversary has no information about its value. Event  <span class="math">\\mathcal{Y}</span>  ensures that no output from g is used more than once. We also know from Lemma 2 that GHASH is  <span class="math">\\lceil l/w+1 \\rceil 2^{-t}</span>  almost xor universal.</p>

    <p class="text-gray-300">Fact 4.  <span class="math">\\mathbf{P}[\\mathcal{Z}^c \\mid B_{\\mathrm{PRF}}^c] \\leq (q-1)\\lceil l_{\\mathrm{IV}}/w + 1\\rceil 2^{-w}</span>  from Corollary 2.</p>

    <p class="text-gray-300">We can express the PRF-distinguishing advantage  <span class="math">A_{PRF}</span>  in terms of  <span class="math">A_{GCM}</span>  as</p>

    <p class="text-gray-300"><span class="math">$A_{\\text{PRF}} = \\mathbf{P}[D \\mid B_{\\text{PRF}}] - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$= F_{\\text{GCM}} - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$= F_{\\text{GCM}} - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c} \\cap (\\mathcal{Y} \\cap \\mathcal{Z})^{c}] \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^{c} \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\mathbf{P}[D \\cap (\\mathcal{Y} \\cap \\mathcal{Z}) \\mid B_{\\text{PRF}}^{c}] \\mathbf{P}[\\mathcal{Y} \\cap \\mathcal{Z} \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq F_{\\text{GCM}} - \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^{c} \\mid B_{\\text{PRF}}^{c}] - \\mathbf{P}[D \\cap (\\mathcal{Y} \\cap \\mathcal{Z}) \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq F_{\\text{GCM}} - \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^{c} \\mid B_{\\text{PRF}}^{c}] - \\mathbf{P}[D \\cap (\\mathcal{Y} \\cap \\mathcal{Z}) \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq F_{\\text{GCM}} - \\mathbf{P}[(\\mathcal{Y} \\cap \\mathcal{Z})^{c} \\mid B_{\\text{PRF}}^{c}] - q[l/w + 1]2^{-t}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq F_{\\text{GCM}} - \\mathbf{P}[\\mathcal{Y}^{c} \\mid B_{\\text{PRF}}^{c}] - (q - 1)[l_{\\text{IV}}/w + 1]2^{-w} - q[l/w + 1]2^{-t},</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq F_{\\text{GCM}} - \\mathbf{P}[\\mathcal{Y}^{c} \\mid B_{\\text{PRF}}^{c}] - q([l_{\\text{IV}}/w + 1]2^{-w} + [l/w + 1]2^{-t}). \\tag{17}</span>$</p>

    <p class="text-gray-300">We rely on the fact that  <span class="math">\\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c]</span>  is extremely small to keep the advantage low, and next consider that value.</p>

    <p class="text-gray-300">During the experiment, the adversary makes a series of queries to the authenticated encryption oracle. For each query, there is a sequence of counter values  <span class="math">Y_0, Y_1, \\dots, Y_n</span>  used as the input to E. We denote as  <span class="math">U_i</span>  the event that the counter sequence of the  <span class="math">i^{th}</span>  query is distinct from the counter sequences of all of the previous queries. In order for a sequence of length l to overlap with another sequence, then either the initial counter of the first sequence is contained in the second sequence, or the initial counter of the first sequence is contained in the l counters that precede the second sequence. If the counter sequences for queries r and s overlap, then  <span class="math">h(H, IV_r) = \\operatorname{incr}^j(h(H, IV_s))</span>  for some value of j such that  <span class="math">-b_r &lt; j &lt; b_s</span> , where we let  <span class="math">b_i</span>  denote the number of counters used during the  <span class="math">i^{th}</span>  query. From Lemma 3, we know that the probability of this event, for any fixed value of j, is no greater than  <span class="math">[l_{IV}/w+1]2^{-w}</span> . (Importantly, when  <span class="math">B_{PRF}^c</span>  occurs, the value of the hash key H is random, as is required by that Lemma.) Summing over all of the previous queries, we find that  <span class="math">\\mathbf{P}[U_r^c] \\leq \\left( (r-1)b_r + \\sum_{i=1}^{r-1} b_i \\right) \\lceil l_{\\text{IV}}/w + 1 \\rceil 2^{-w}</span>  and the probability that there are no collisions across all queries is</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[\\mathcal{Y}^{c} \\mid B_{GCM}^{c}] = \\mathbf{P}[U_{1}^{c} \\cup U_{2}^{c} \\cup \\ldots \\cup U_{q}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\mathbf{P}[U_{1}^{c}] + \\mathbf{P}[U_{2}^{c}] + \\ldots + \\mathbf{P}[U_{q}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\sum_{r=1,}^{q} \\left( (r-1)b_{r} + \\sum_{i=1}^{r-1} b_{i} \\right) \\lceil l_{IV}/w + 1 \\rceil 2^{-w}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq qb \\lceil l_{IV}/w + 1 \\rceil 2^{1-w}, \\tag{18}</span>$</p>

    <p class="text-gray-300">where  <span class="math">b = \\sum_{r=1}^{q} b_r</span>  denotes the total number of counter blocks used during all of the queries. This value is no greater than  <span class="math">l_P/w + 2q</span> , where  <span class="math">l_P</span>  is the total number of bits in all of the plaintexts. The theorem follows from combining Equations 17 and 18 with Lemma 1.</p>

    <p class="text-gray-300">Proof of Theorem 1. We assume that we have a distinguisher  <span class="math">\\mathcal{D}_{GCM}</span>  that can distinguish between those two cases with advantage  <span class="math">A_{GCM}</span>  given by</p>

    <p class="text-gray-300"><span class="math">$A_{\\text{GCM}} = \\mathbf{P}[D \\mid B_{\\text{GCM}}] - \\mathbf{P}[D \\mid B_{\\text{GCM}}^c]. \\tag{19}</span>$</p>

    <p class="text-gray-300">We use  <span class="math">\\mathcal{D}_{GCM}</span>  to discern E from a random function as follows. We assume that we are given access to a function oracle, which contains E if the event  <span class="math">B_{PRF}</span>  occurred and contains a true random function if  <span class="math">B_{PRF}^c</span>  occurred. We replace each invocation of E in Equations 2 with a query to the function oracle. We run  <span class="math">\\mathcal{D}_{GCM}</span>  on the resulting algorithm, and return whatever value that it returns. For each query to this algorithm, there is a sequence of counter values  <span class="math">Y_0, Y_1, \\ldots, Y_n</span>  used as the input to E (as defined in Equation 2). We define the event  <span class="math">\\mathcal{Y}</span>  as the case in which all of these counter values are distinct, across all counter sequences. We also define the event  <span class="math">\\mathcal{F}</span>  as the case in which there are no successful forgeries during the distinguishing experiment. This latter case is important because an attacker can use information gleaned from a chosen-ciphertext or chosen-associated-data forgery to craft two distinct IV values that will cause a counter collision. This attack can be used to distinguish  <span class="math">B_{\\text{GCM}}</span>  from  <span class="math">B_{\\text{GCM}}^c</span> , but cannot be used to distinguish  <span class="math">B_{PRF}</span>  from  <span class="math">B_{PRF}^c</span> . We account for this fact by keeping explicit track of the forgery probability in our bounds. For notational simplicity, we define the event  <span class="math">\\mathcal{G} = \\mathcal{F} \\cap \\mathcal{Y}</span> . Our analysis uses the following facts:</p>

    <p class="text-gray-300">Fact 1.  <span class="math">P[D \\mid B_{PRF}] = P[D \\mid B_{GCM}]</span> , because the two cases  <span class="math">B_{PRF}</span>  and  <span class="math">B_{GCM}</span>  provide equivalent inputs to the distinguisher.</p>

    <p class="text-gray-300">Fact 2.  <span class="math">P[D \\mid B_{PRF}^c \\cap \\mathcal{G}]P[\\mathcal{G} \\mid B_{PRF}^c] \\leq P[D \\mid B_{GCM}^c]</span> , because the two cases  <span class="math">B_{PRF}^c \\cap \\mathcal{Y}</span>  and  <span class="math">B_{GCM}^c</span>  provide equivalent inputs to the distinguisher. When E is replaced by a random function whose inputs are distinct, the set of its outputs form a random function with a larger range. Thus</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{P}[D \\mid B_{\\mathrm{PRF}}^{c} \\cap \\mathcal{G}] \\mathbf{P}[\\mathcal{G} \\mid B_{\\mathrm{PRF}}^{c}] = \\frac{\\mathbf{P}[D \\cap B_{\\mathrm{PRF}}^{c} \\cap \\mathcal{G}]}{\\mathbf{P}[B_{\\mathrm{PRF}}^{c} \\cap \\mathcal{G}]} \\frac{\\mathbf{P}[\\mathcal{G} \\cap B_{\\mathrm{PRF}}^{c}]}{\\mathbf{P}[B_{\\mathrm{PRF}}^{c}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\mathbf{P}[D \\cap \\mathcal{F} \\cap \\mathcal{Y} \\cap B_{\\mathrm{PRF}}^{c}]}{\\mathbf{P}[B_{\\mathrm{PRF}}^{c}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{\\mathbf{P}[D \\cap \\mathcal{F} \\cap B_{\\mathrm{GCM}}^{c}]}{\\mathbf{P}[B_{\\mathrm{GCM}}^{c}]}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{P}[D \\cap \\mathcal{F} \\mid B_{\\mathrm{GCM}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\mathbf{P}[D \\mid B_{\\mathrm{GCM}}^{c}]. \\tag{20}</span>$</p>

    <p class="text-gray-300">The advantage  <span class="math">A_{\\rm PRF}</span>  can be expressed in terms of  <span class="math">A_{\\rm GCM}</span>  as</p>

    <p class="text-gray-300"><span class="math">$A_{\\text{PRF}} = \\mathbf{P}[D \\mid B_{\\text{PRF}}] - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{P}[D \\mid B_{\\text{GCM}}] - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\mathbf{P}[D \\mid B_{\\text{GCM}}] - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c} \\cap \\mathcal{G}] \\mathbf{P}[\\mathcal{G} \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$- \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c} \\cap \\mathcal{G}^{c}] \\mathbf{P}[\\mathcal{G}^{c} \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq \\mathbf{P}[D \\mid B_{\\text{GCM}}] - \\mathbf{P}[D \\mid B_{\\text{GCM}}^{c}] - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c} \\cap \\mathcal{G}^{c}] \\mathbf{P}[\\mathcal{G}^{c} \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$= A_{\\text{GCM}} - \\mathbf{P}[D \\mid B_{\\text{PRF}}^{c} \\cap \\mathcal{G}^{c}] \\mathbf{P}[\\mathcal{G}^{c} \\mid B_{\\text{PRF}}^{c}],</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq A_{\\text{GCM}} - \\mathbf{P}[\\mathcal{G}^{c} \\mid B_{\\text{PRF}}^{c}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\geq A_{\\text{GCM}} - \\mathbf{P}[\\mathcal{Y}^{c} \\mid B_{\\text{PRF}}^{c}] - \\mathbf{P}[\\mathcal{F}^{c} \\mid B_{\\text{PRF}}^{c}].</span>$
(21)</p>

    <p class="text-gray-300">We rely on the fact that the rightmost two terms of Equation 21 are extremely small to keep the advantage low. The probability  <span class="math">\\mathbf{P}[\\mathcal{Y}^c \\mid B_{\\mathrm{PRF}}^c]</span>  was bounded in Equation 18. We next turn to  <span class="math">\\mathbf{P}[\\mathcal{F}^c \\mid B_{\\mathrm{PRF}}^c]</span> . When the event  <span class="math">B_{\\mathrm{PRF}}^c</span>  occurs, Corollary 2 applies, and thus that probability is no more than  <span class="math">q\\lceil l/w+1\\rceil 2^{-t}</span>  (where we also make use of Lemma 2). The result then follows from Equation 21 and Lemma 1.</p>

    </section>
`;
---

<BaseLayout title="The Security and Performance of the Galois/Counter Mode of O... (2004/193)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2004 &middot; eprint 2004/193
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-security-and-performance-of-the-galois-counter-mode-gcm-2004" />
  </article>
</BaseLayout>
