---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/527';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Aggregatable Subvector Commitments for Stateless Cryptocurrencies';
const AUTHORS_HTML = 'Alin Tomescu, Ittai Abraham, Vitalik Buterin, Justin Drake, Dankrad Feist, Dmitry Khovratovich';

const CONTENT = `    <p class="text-gray-300">Alin Tomescu [10000-0002-6896-1380] Ittai Abraham^{1} Vitalik Buterin^{2} Justin Drake^{2} Dankrad Feist^{2} and Dmitry Khovratovich^{2} {alint,iabraham}@vmware.com, {vitalik,justin,dankrad,dmitry.khovratovich}@ethereum.org</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">An <em>aggregatable subvector commitment (aSVC)</em> scheme is a <em>vector commitment (VC)</em> scheme that can aggregate multiple proofs into a single, small subvector proof. In this paper, we formalize aSVCs and give a construction from constant-sized polynomial commitments. Our construction is unique in that it has linear-sized public parameters, it can compute all constant-sized proofs in quasilinear time, it updates proofs in constant time and it can aggregate multiple proofs into a constant-sized subvector proof. Furthermore, our concrete proof sizes are small due to our use of pairing-friendly groups. We use our aSVC to obtain a payments-only stateless cryptocurrency with very low communication and computation overheads. Specifically, our constant-sized, aggregatable proofs reduce each block’s proof overhead to a single group element, which is optimal. Furthermore, our subvector proofs speed up block verification and our smaller public parameters further reduce block size.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">In a <em>stateless cryptocurrency</em>, neither <em>miners</em> nor cryptocurrency <em>users</em> need to store the full <em>ledger state</em>. Instead, this state consisting of users’ account balances is split among all users using an <em>authenticated data structure</em>. This way, miners only store a succinct <em>digest</em> of the ledger state and each user stores their account balance. Nonetheless, miners can still validate transactions sent by users, who now include <em>proofs</em> that they have sufficient balance. Furthermore, miners can still propose new <em>blocks</em> of transactions and users can easily <em>synchronize</em> or <em>update</em> their proofs as new blocks get published.</p>

    <p class="text-gray-300">Stateless cryptocurrencies have received increased attention <em>[x10, x23, x11, x12, x1, x14, x15, x16]</em> due to several advantages. First, stateless cryptocurrencies eliminate hundreds of gigabytes of miner storage needed to validate blocks. Second, statelessness makes scaling consensus via <em>sharding</em> much easier, by allowing miners to efficiently switch from one shard to another <em>[KJG^{+}18, x10]</em>. Third, statelessness lowers the barrier to entry for full nodes, resulting in a much more resilient, distributed cryptocurrency.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Stateless Cryptocurrencies from VCs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">At a high level, a VC scheme allows a <em>prover</em> to compute a succinct <em>commitment c</em> to a <em>vector</em> <span class="math">\\mathbf{v}=[v_{0},v_{1},\\ldots,v_{n-1}]</span> of <span class="math">n</span> <em>elements</em> where <span class="math">v_{i}\\in\\mathbb{Z}_{p}</span>. Importantly, the prover can generate a <em>proof</em> <span class="math">\\pi_{i}</span> that <span class="math">v_{i}</span> is the element at position <span class="math">i</span> in <span class="math">\\mathbf{v}</span>, and any <em>verifier</em> can check it against the commitment <span class="math">c</span>. The prover needs a <em>proving key</em> <span class="math">\\mathsf{prk}</span> to commit to vectors and to compute proofs, while the verifier needs a <em>verification key</em> <span class="math">\\mathsf{vrk}</span> to verify proofs. (Usually $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{vrk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ll</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{prk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">.) Some VC schemes support <em>updates</em>: if one or more elements in the vector change, the commitment and proofs can be updated efficiently. For this, a static <em>update key</em> </span>\\mathsf{upk}_{j}<span class="math"> tied only to the updated position </span>j<span class="math"> is necessary. Alternatively, some schemes require dynamic <em>update hints</em> </span>\\mathsf{uph}_{j}<span class="math">, typically consisting of the actual proof </span>\\pi_{j}<span class="math">. The proving, verification and update keys comprise the VC’s <em>public parameters</em>. Lastly, <em>subvector commitment (SVC)</em> schemes <em>[x18]</em> support computing succinct proofs for <em></span>I<span class="math">-subvectors</em> </span>(v_{i})_{i\\in I}<span class="math"> where </span>I\\subset[0,n)<span class="math">. Furthermore, some schemes are <em>aggregatable</em>: multiple proofs </span>\\pi_{i}<span class="math"> for </span>v_{i},\\forall i\\in I<span class="math"> can be aggregated into a single, succinct </span>I$-subvector proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Chepurnoy, Papamanthou and Zhang pioneered the idea of building <em>account-based</em> <em>[x24]</em>, stateless cryptocurrencies on top of any <em>vector commitment (VC)</em> scheme <em>[x10]</em>. Ideally, such a VC would have (1) sublinear-sized, updatable proofs with sublinear-time verification, (2) updatable commitments and (3) sublinear-sized update keys. In particular, static update keys (rather than dynamic update hints) help reduce interaction and thus simplify the design (see Section 4.1). We say such a VC has “<em>scalable updates</em>.” Unfortunately, most VCs do not have scalable updates (see Section 1.1 and Tables 2 and 3) or, if they do <em>[x10, x25]</em>, they are not optimal in their proof and update key sizes. Lastly, while some schemes in hidden-order groups have scalable updates <em>[CFG^{+}20]</em>, they suffer from larger concrete proof sizes and are likely to require more computation in practice.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">Our Contributions</h3>

    <p class="text-gray-300">In this paper, we formalize a new <em>aggregatable subvector commitment (aSVC)</em> notion that supports commitment updates, proof updates and aggregation of proofs into subvector proofs. Then, we construct</p>

    <p class="text-gray-300">Tomescu et al.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Table 1. Asymptotic comparison of our work with other stateless cryptocurrencies.  <span class="math">n</span>  is the number of users,  <span class="math">\\lambda</span>  is the security parameter, and  <span class="math">b</span>  is the number of transactions in a block.  <span class="math">\\mathbb{G}</span>  is an exponentiation in a known-order group.  <span class="math">\\mathbb{G}_7</span>  is a (slower) exponentiation (of size  <span class="math">2\\lambda</span>  bits) in a hidden-order group.  <span class="math">\\mathbb{P}</span>  is a pairing computation.  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the size of a proof for a user&#x27;s account balance.  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{upk}_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the size of user  </span>i<span class="math"> &#x27;s update key.  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is the size of a proof aggregated from all  </span>\\pi_i<span class="math"> &#x27;s in a block. We give each Miner&#x27;s storage in terms of VC public parameters (e.g., update keys). A miner takes: (1) Check digest time, to check that, by &quot;applying&quot; the transactions from block  </span>t + 1<span class="math">  to block  </span>t<span class="math"> &#x27;s digest, he obtains the correct digest for block  </span>t + 1<span class="math"> , (2) Aggr. proofs time, to aggregate  </span>b<span class="math">  transaction proofs, and (3) Vrfy.  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\pi_I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  time, to verify the aggregated proof. A user takes Proof synchr. time to &quot;synchronize&quot; or update her proof by &quot;applying&quot; all the transactions in a new block. We treat [GRWZ20] and [CFG+20] as a payments-only stateless cryptocurrency without smart contracts. Our aggregation and verification times have an extra  </span>b\\log^2 b$  F term, consisting of very fast field operations. A detailed analysis of the underlying VCs can be found in Appendices D.4, D.6, D.7 and E.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Account-based stateless cryptocurrencies</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Edrax [CPZ18]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pointproofs [GRWZ20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2nd VC of [CFG+20]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Our work</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πi</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">upki</td>

            <td class="px-3 py-2 border-b border-gray-700">log n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">πI</td>

            <td class="px-3 py-2 border-b border-gray-700">b log n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Miner's storage</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">G</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Vrfy.</td>

            <td class="px-3 py-2 border-b border-gray-700">πI</td>

            <td class="px-3 py-2 border-b border-gray-700">time</td>

            <td class="px-3 py-2 border-b border-gray-700">b log n P</td>

            <td class="px-3 py-2 border-b border-gray-700">2 P + b G</td>

            <td class="px-3 py-2 border-b border-gray-700">b log b G7</td>

            <td class="px-3 py-2 border-b border-gray-700">2 P + b G + b lg2 b F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Check digest time</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

            <td class="px-3 py-2 border-b border-gray-700">b G7</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aggr. proofs time</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

            <td class="px-3 py-2 border-b border-gray-700">b log2 b G7</td>

            <td class="px-3 py-2 border-b border-gray-700">b G + b lg2 b F</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Proof synchr. time</td>

            <td class="px-3 py-2 border-b border-gray-700">b log n G</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

            <td class="px-3 py-2 border-b border-gray-700">b G7</td>

            <td class="px-3 py-2 border-b border-gray-700">b G</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">an aSVC with scalable updates over pairing-friendly groups. Compared to other pairing-based VCs, our aSVC has constant-sized, aggregatable proofs that can be updated with constant-sized update keys (see Table 2). Furthermore, our aSVC supports computing all proofs in quasilinear time. We prove security of our aSVC by strengthening (and re-proving) the security definition of KZG polynomial commitments [KZG10].</p>

    <p class="text-gray-300">A Highly-Efficient Stateless Cryptocurrency. We use our aSVC to construct a stateless cryptocurrency based on the elegant design of Edrax [CPZ18]. Our stateless cryptocurrency has very low storage, communication and computation overheads (see Table 1). First, our constant-sized update keys have a smaller impact on block size and help users update their proofs faster. Second, our proof aggregation drastically reduces block size and speeds up block validation. Third, our verifiable update keys remove the need for miners to either (1) store all  <span class="math">O(n)</span>  update keys or (2) interact during transaction validation to check update keys.</p>

    <p class="text-gray-300">Vector Commitments (VCs). The notion of VCs appears early in [CFM08, LY10, KZG10] but Catalano and Fiore [CF13] are the first to formalize it. They introduce schemes based on the Computational Diffie-Hellman (CDH), with  <span class="math">O(n^{2})</span> -sized public parameters, and on the RSA problem, with  <span class="math">O(1)</span> -sized public parameters, which can be specialized into  <span class="math">O(n)</span> -sized ones when needed. Lai and Malavolta [LM19] formalize subvector commitments (SVCs) and extend both constructions from [CF13] with constant-sized  <span class="math">I</span> -subvector proofs. Camenisch et al. [CDHK15] build VCs from KZG commitments [KZG10] to Lagrange polynomials (see Section 2.1) that are not only binding but also hiding. However, their scheme intentionally prevents aggregation of proofs as a security feature. Feist and Khovratovich [FK20] introduce a technique for precomputing all constant-sized evaluation proofs in KZG commitments when the evaluation points are all roots of unity. We use their technique to compute VC proofs fast. Chepurnoy et al. [CPZ18] instantiate VCs using multivariate polynomial commitments [PST13] but with logarithmic rather than constant-sized proofs. Then, they build the first efficient, account-based, stateless cryptocurrency on top of their scheme. Later on, Tomescu [Tom20] presents a very similar scheme but from univariate polynomial commitments [KZG10] which supports subvector proofs.</p>

    <p class="text-gray-300">Boneh et al. [BBF19] instantiate VCs using hidden-order groups. They are the first to support aggregating multiple proofs (under certain conditions; see [BBF18, Sec. 5.2, p. 20]). They are also the first to have constant-sized public parameters, without the need to specialize them into  <span class="math">O(n)</span> -sized ones. However, their VC uses update hints (rather than keys), which is less suitable for stateless cryptocurrencies. Furthermore, they introduce key-value map commitments (KVCs), which support a larger set of positions from  <span class="math">[0, 2^{2\\lambda})</span>  rather than  <span class="math">[0, n)</span> , where  <span class="math">\\lambda</span>  is a security parameter. They argue their KVC can be used for account-based stateless cryptocurrencies, but do not explore a construction in depth. Campanelli et al.  <span class="math">[\\mathrm{CFG}^{+}20]</span>  also formalize SVCs with a more powerful notion of infinite (dis)aggregation of proofs.</p>

    <p class="text-gray-300">In contrast, our aSVC only supports “one hop” aggregation and does not support disaggregation. They also formalize a notion of updatable, distributed VCs as Verified Decentralized Storage (VDS). However, their use of hidden-order groups leads to larger concrete proof sizes. Both of their schemes have <span class="math">O(1)</span>-sized public parameters and can compute all proofs efficiently in quasilinear time. One scheme supports update hints while the other supports update keys.</p>

    <p class="text-gray-300">Concurrent with our work, Gorbunov et al. <em>[x10]</em> also formalize aSVCs with a stronger notion of cross-commitment aggregation. However, their formalization lacks (verifiable) update keys, which hides many complexities that arise in stateless cryptocurrencies (see Section 4.2.2). Their VC scheme extends <em>[x22]</em> with (1) aggregating proofs into <span class="math">I</span>-subvector proofs and (2) aggregating multiple <span class="math">I</span>-subvector proofs with respect to different VCs into a single, constant-sized proof. However, this versatility comes at the cost of (1) losing the ability to precompute all proofs fast, (2) <span class="math">O(n)</span>-sized update keys for updating proofs, and (3) <span class="math">O(n)</span>-sized verification key. This makes it difficult to apply their scheme in a stateless cryptocurrency for payments such as Edrax <em>[x7]</em>. Furthermore, Gorbunov et al. also enhance KZG-based VCs with proof aggregation, but they do not consider proof updates. Lastly, they show it is possible to aggregate <span class="math">I</span>-subvector proofs across different commitments for KZG-based VCs.</p>

    <p class="text-gray-300">Kohlweiss and Rial <em>[x16]</em> extend VCs with zero-knowledge protocols for proving correct computation of a new commitment, for opening elements at secret positions, and for proving secret updates of elements at secret positions.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.0.2 Stateless Cryptocurrencies.</h3>

    <p class="text-gray-300">The concept of stateless validation appeared early in the cryptocurrency community <em>[x20, x11, x9]</em> and later on in the academic community <em>[x23, x6, x7, x1, x12]</em>.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.0.3 UTXO-based.</h4>

    <p class="text-gray-300">Initial proposals for UTXO-based cryptocurrencies used Merkle hash trees <em>[x20, x13, x6, x7]</em>. In particular, Dryja <em>[x6]</em> gives a beautiful Merkle forest construction that significantly reduces communication. Boneh et al. <em>[x3]</em> further reduce communication by using RSA accumulators <em>[x2, x14]</em>.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">2.0.4 Account-based.</h4>

    <p class="text-gray-300">Reyzin et al. <em>[x23]</em> introduce a Merkle-based construction for account-based stateless cryptocurrencies. Unfortunately, their construction relies on <em>proof-serving nodes</em>: every user sending coins has to fetch the recipient’s Merkle proof from a node and include it with her own proof in the transaction. Edrax <em>[x7]</em> obviates the need for proof-serving nodes by using a vector commitment (VC) with update keys (rather than update hints like Merkle trees). Nonetheless, proof-serving nodes can still be used to assist users who do not want to manually update their proofs (which is otherwise very fast). Unfortunately, Edrax’s (non-aggregatable) proofs are logarithmic-sized and thus sub-optimal.</p>

    <p class="text-gray-300">Gorbunov et al. <em>[x10]</em> introduce Pointproofs, a versatile VC scheme which can aggregate proofs across different commitments. They use this power to solve a slightly different problem: stateless block validation for smart contract executions (rather than for payments as in Edrax). Unfortunately, their approach requires miners to store a different commitment for each smart contract, or around 4.5 GBs of (dynamic) state in a system with <span class="math">10^{8}</span> smart contracts. This could be problematic in applications such as sharded cryptocurrencies, where miners would have to download part of this large state from one another when switching shards. Lastly, the verification key in Pointproofs is <span class="math">O(n)</span>-sized, which imposes additional storage requirements on miners. Furthermore, Gorbunov et al. do not discuss how to update nor precompute proofs efficiently. Instead they assume that all contracts have <span class="math">n\\leq 10^{3}</span> memory locations and users can compute all proofs in <span class="math">O(n^{2})</span> time. In contrast, our aSVC can compute all proofs in <span class="math">O(n\\log n)</span> time <em>[x12]</em>. Nonetheless, their approach is a very promising direction for supporting smart contracts in stateless cryptocurrencies.</p>

    <p class="text-gray-300">Bonneau et al. <em>[x1]</em> use recursively-composable, succinct non-interactive arguments of knowledge (SNARKs) <em>[x5]</em> for stateless validation. However, while block validators do not have to store the full state in their system, miners who propose blocks still have to. In contrast, in previous stateless cryptocurrencies (including ours), even miners who propose blocks are stateless.</p>

    <h2 id="sec-10" class="text-2xl font-bold">2 Preliminaries</h2>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">2.1 Notation.</h3>

    <p class="text-gray-300"><span class="math">\\lambda</span> is our security parameter. <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> are groups of prime order <span class="math">p</span> endowed with a pairing <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\rightarrow\\mathbb{G}_{T}</span> <em>[x20, x15]</em>. (We assume symmetric pairings where <span class="math">\\mathbb{G}_{1}=\\mathbb{G}_{2}</span> for simplicity of exposition.) <span class="math">\\mathbb{G}_{?}</span> is a hidden-order group. We use multiplicative notation for all groups. <span class="math">\\omega</span> is a primitive <span class="math">n</span>th root of unity in <span class="math">\\mathbb{Z}_{p}</span> <em>[x24]</em>. <span class="math">\\mathsf{poly}(\\cdot)</span> is any function upper-bounded by some univariate polynomial. <span class="math">\\mathsf{negl}(\\cdot)</span> is any negligible function. <span class="math">\\log x</span> and <span class="math">\\lg x</span> are shorthand for <span class="math">\\log_{2}x</span>. <span class="math">[i,j]=\\{i,i+1,\\ldots,j-1,j\\}</span>, <span class="math">[0,n)=[0,n-1]</span> and <span class="math">[n]=[1,n]</span>. <span class="math">\\mathbf{v}=(v_{i})_{i\\in[0,n)}</span> is a vector of size <span class="math">n</span> with elements <span class="math">v_{i}\\in\\mathbb{Z}_{p}</span>.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">2.2.1 Lagrange Polynomial Interpolation</h3>

    <p class="text-gray-300">Given <span class="math">n</span> pairs <span class="math">(x_{i},y_{i})_{i\\in[0,n)}</span>, we can find or <em>interpolate</em> the <em>unique</em> polynomial <span class="math">\\phi(X)</span> of degree <span class="math">&lt;n</span> such that <span class="math">\\phi(x_{i})=y_{i},\\forall i\\in[0,n)</span> using Lagrange interpolation <em>[x6]</em> in <span class="math">O(n\\log^{2}n)</span> time <em>[x24]</em> as <span class="math">\\phi(X)=\\sum_{i\\in[0,n)}\\mathcal{L}_{i}(X)y_{i}</span>, where</p>

    <p class="text-gray-300"><span class="math">\\mathcal{L}_{i}(X)=\\prod_{j\\in[0,n),j\\neq i}\\frac{X-x_{j}}{x_{i}-x_{j}}</span>. Recall that a <em>Lagrange polynomial</em> <span class="math">\\mathcal{L}_{i}(X)</span> has the property that <span class="math">\\mathcal{L}_{i}(x_{i})=1</span> and <span class="math">\\mathcal{L}_{i}(x_{j})=0,\\forall i,j\\in[0,n)</span> with <span class="math">j\\neq i</span>. Note that <span class="math">\\mathcal{L}_{i}(X)</span> is defined in terms of the <span class="math">x_{i}</span>’s which, throughout this paper, will be either <span class="math">(\\omega^{i})_{i\\in[0,n)}</span> or <span class="math">(\\omega^{i})_{i\\in I},I\\subset[0,n)</span>.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">2.2 KZG Polynomial Commitments</h3>

    <p class="text-gray-300">Kate, Zaverucha and Goldberg (KZG) proposed a <em>constant-sized</em> commitment scheme for degree <span class="math">n</span> polynomials <span class="math">\\phi(X)</span>. Importantly, an <em>evaluation proof</em> for any <span class="math">\\phi(a)</span> is constant-sized and constant-time to verify; it does not depend in any way on the degree of the committed polynomial. KZG requires public parameters <span class="math">(g^{\\tau^{i}})_{i\\in[0,n]}</span>, which can be computed via a decentralized MPC protocol <em>[x10]</em> that hides the <em>trapdoor</em> <span class="math">\\tau</span>. KZG is computationally-hiding under the discrete log assumption and computationally-binding under <span class="math">n</span>-SDH <em>[x11]</em>.</p>

    <p class="text-gray-300">Committing. Let <span class="math">\\phi(X)</span> denote a polynomial of degree <span class="math">d\\leq n</span> with coefficients <span class="math">c_{0},c_{1},\\ldots,c_{d}</span> in <span class="math">\\mathbb{Z}_{p}</span>. A KZG commitment to <span class="math">\\phi(X)</span> is a single group element <span class="math">C=\\prod_{i=0}^{d}\\left(g^{\\tau^{i}}\\right)^{c_{i}}=g^{\\sum_{i=0}^{d}c_{i}\\tau^{i}}=g^{\\phi(\\tau)}</span>. Committing to <span class="math">\\phi(X)</span> takes <span class="math">\\Theta(d)</span> time.</p>

    <p class="text-gray-300">Proving One Evaluation. To compute an <em>evaluation proof</em> that <span class="math">\\phi(a)=y</span>, KZG leverages the polynomial remainder theorem, which says <span class="math">\\phi(a)=y\\Leftrightarrow\\exists q(X)</span> such that <span class="math">\\phi(X)-y=q(X)(X-a)</span>. The proof is just a KZG commitment to <span class="math">q(X)</span>: a single group element <span class="math">\\pi=g^{q(\\tau)}</span>. Computing the proof takes <span class="math">\\Theta(d)</span> time. To verify <span class="math">\\pi</span>, one checks (in constant time) if <span class="math">e(C/g^{y},g)=e(\\pi,g^{\\tau}/g^{a})\\Leftrightarrow e(g^{\\phi(\\tau)-y},g)=e(g^{q(\\tau)},g^{\\tau-a})\\Leftrightarrow e(g,g)^{\\phi(\\tau)-y}=e(g,g)^{q(\\tau)(\\tau-a)}\\Leftrightarrow\\phi(\\tau)-y=q(\\tau)(\\tau-a)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving Multiple Evaluations. Given a set of points <span class="math">I</span> and their evaluations <span class="math">\\{\\phi(i)\\}_{i\\in I}</span>, KZG can prove all evaluations with a constant-sized <em>batch proof</em> rather than $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> individual proofs. The prover computes an <em>accumulator polynomial</em> </span>a(X)=\\prod_{i\\in I}(X-i)<span class="math"> in </span>\\Theta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time and computes </span>\\phi(X)/a(X)<span class="math"> in </span>\\Theta(d\\log d)<span class="math"> time, obtaining a quotient </span>q(X)<span class="math"> and remainder </span>r(X)<span class="math">. The batch proof is </span>\\pi_{I}=g^{q(\\tau)}<span class="math">. To verify </span>\\pi_{I}<span class="math"> and </span>\\{\\phi(i)\\}_{i\\in I}<span class="math"> against </span>C<span class="math">, the verifier first computes </span>a(X)<span class="math"> from </span>I<span class="math"> and interpolates </span>r(X)<span class="math"> such that </span>r(i)=\\phi(i),\\forall i\\in I<span class="math"> in </span>\\Theta(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time (see Section 2.1). Next, she computes </span>g^{a(\\tau)}<span class="math"> and </span>g^{r(\\tau)}<span class="math">. Finally, she checks if </span>e(C/g^{r(\\tau)},g)=e(g^{q(\\tau)},g^{a(\\tau)})<span class="math">. We stress that batch proofs are only useful when </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq d<span class="math">. Otherwise, if </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">>d<span class="math">, the verifier can interpolate </span>\\phi(X)<span class="math"> directly from the evaluations, which makes verifying any </span>\\phi(i)$ trivial.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">2.3 Account-based Stateless Cryptocurrencies</h3>

    <p class="text-gray-300">In a stateless cryptocurrency based on VCs <em>[x16]</em>, there are <em>miners</em> running a permissionless consensus algorithm <em>[x30]</em> and <em>users</em>, numbered from <span class="math">0</span> to <span class="math">n-1</span> who have <em>accounts</em> with a <em>balance</em> of coins. (<span class="math">n</span> can be <span class="math">\\infty</span> if the VC is unbounded.) For simplicity of exposition, we do not give details on the consensus algorithm, on transaction signature verification nor on monetary policy. These all remain the same as in previous stateful cryptocurrencies.</p>

    <p class="text-gray-300">The (Authenticated) State. The <em>state</em> is an <em>authenticated data structure (ADS)</em> mapping each user <span class="math">i</span>’s <em>public key</em> to their account balance <span class="math">\\mathsf{bal}_{i}</span>. (In practice, the mapping is also to a <em>transaction counter</em> <span class="math">c_{i}</span>, which is necessary to avoid transaction replay attacks. We address this in Section 4.3.1.) Importantly, miners and users are <em>stateless</em>: they do not store the state, just its <em>digest</em> <span class="math">d_{t}</span> at the latest block <span class="math">t</span> they are aware of. Additionally, each user <span class="math">i</span> stores a proof <span class="math">\\pi_{i,t}</span> for their account balance that verifies against <span class="math">d_{t}</span>.</p>

    <p class="text-gray-300">Miners. Despite miners being stateless, they can still validate transactions, assemble them into a new <em>block</em>, and propose that block. Specifically, a miner can verify every new transaction spends valid coins by checking the sending user’s balance against the latest digest <span class="math">d_{t}</span>. This requires each user <span class="math">i</span> who sends coins to <span class="math">j</span> to include her proof <span class="math">\\pi_{i,t}</span> in her transaction. Importantly, user <span class="math">i</span> should not have to include the recipient’s proof <span class="math">\\pi_{j,t}</span> in the transaction, since that would require interacting with <em>proof-serving nodes</em> (see Section 4.3.2)</p>

    <p class="text-gray-300">Once the miner has a set <span class="math">V</span> of valid transactions, he can use them to create the next block <span class="math">t+1</span> and propose it. The miner obtains this new block’s digest <span class="math">d_{t+1}</span> by “applying” all transactions in <span class="math">V</span> to <span class="math">d_{t}</span>. When other miners receive this new block <span class="math">t+1</span>, they can validate its transactions from <span class="math">V</span> against <span class="math">d_{t}</span> and check that the new digest <span class="math">d_{t+1}</span> was produced correctly from <span class="math">d_{t}</span> by “reapplying” all the transactions from <span class="math">V</span>.</p>

    <p class="text-gray-300">Users. When creating a transaction <span class="math">\\mathsf{tx}</span> for block <span class="math">t+1</span>, user <span class="math">i</span> includes her proof <span class="math">\\pi_{i,t}</span> for miners to verify she has sufficient balance. When she sees a new block <span class="math">t+1</span>, she can update her proof <span class="math">\\pi_{i,t}</span> to a new proof <span class="math">\\pi_{i,t+1}</span>, which verifies against the new digest <span class="math">d_{t+1}</span>. For this, she will look at all changes in balances <span class="math">(j,\\Delta\\mathsf{bal}_{j})_{j\\in J}</span>, where <span class="math">J</span> is the set of users with transactions in block <span class="math">t+1</span>, and “apply” those changes to her proof. Similarly, miners can also update proofs of pending transactions which did not make it in block <span class="math">t</span> and now need a proof w.r.t. <span class="math">d_{t+1}</span></p>

    <p class="text-gray-300">Users assume that the consensus mechanism produces correct blocks. As a result, they do <em>not</em> need to verify transactions in the block; they only need to update their own proof. Nonetheless, since block verification is stateless and fast, users could easily participate as block validators, should they choose to.</p>

    <p class="text-gray-300">3 Aggregatable Subvector Commitment (aSVC) Schemes</p>

    <p class="text-gray-300">In this section, we introduce the notion of <em>aggregatable subvector commitments (aSVCs)</em> as a natural extension to <em>subvector commitments (SVCs)</em> <em>[x14]</em> where anybody can aggregate <span class="math">b</span> proofs for individual positions into a single constant-sized <em>subvector proof</em> for those positions. Our formalization differs from previous work <em>[x2, x11]</em> in that it accounts for (static) update keys as the <em>verifiable</em> auxiliary information needed to update commitments and proofs. This is useful in distributed settings where the public parameters of the scheme are split amongst many participants, such as in stateless cryptocurrencies. In Section 3.3, we introduce an efficient aSVC construction <em>with scalable updates</em> from KZG commitments to Lagrange polynomials.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.1 aSVC API</h3>

    <p class="text-gray-300">Our API resembles the VC API by Chepurnoy et al. <em>[x7]</em> and the SVC API by Lai and Malavolta <em>[x14]</em>, extended with an API for verifying update keys (see Section 4.2.2) and an API for aggregating proofs. Unlike <em>[x7]</em>, our VC.UpdateProof API receives both <span class="math">\\mathsf{upk}_{i}</span> and <span class="math">\\mathsf{upk}_{j}</span> as input. This is reasonable in the stateless setting, since each user has to store their <span class="math">\\mathsf{upk}_{i}</span> anyway and they extract <span class="math">\\mathsf{upk}_{j}</span> from the transactions (see Section 4).</p>

    <p class="text-gray-300">VC.KeyGen(<span class="math">1^{\\lambda},n</span>) <span class="math">\\rightarrow</span> <span class="math">\\mathsf{prk},\\mathsf{vrk},(\\mathsf{upk}_{j})_{j\\in[0,n)}</span>. Randomized algorithm that, given a security parameter <span class="math">\\lambda</span> and an upper-bound <span class="math">n</span> on vector size, returns a <em>proving key</em> <span class="math">\\mathsf{prk}</span>, a <em>verification key</em> <span class="math">\\mathsf{vrk}</span> and <em>update keys</em> <span class="math">(\\mathsf{upk}_{j})_{j\\in[0,n)}</span>.</p>

    <p class="text-gray-300">VC.Commit(<span class="math">\\mathsf{prk},\\mathbf{v}</span>) <span class="math">\\rightarrow</span> <span class="math">c</span>. Deterministic algorithm that returns a commitment <span class="math">c</span> to any vector <span class="math">\\mathbf{v}</span> of size <span class="math">\\leq n</span>.</p>

    <p class="text-gray-300">VC.ProvePos(<span class="math">\\mathsf{prk},I,\\mathbf{v}</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi_{I}</span>. Deterministic algorithm that returns a proof <span class="math">\\pi_{I}</span> that <span class="math">\\mathbf{v}_{I}=(v_{i})_{i\\in I}</span> is the <span class="math">I</span>-subvector of <span class="math">\\mathbf{v}</span>. For notational convenience, <span class="math">I</span> can be either an index set <span class="math">I\\subseteq[0,n)</span> or an individual index <span class="math">I=i\\in[0,n)</span>.</p>

    <p class="text-gray-300">VC.VerifyPos(<span class="math">\\mathsf{vrk},c,\\mathbf{v}_{I},I,\\pi_{I}</span>) <span class="math">\\rightarrow</span> <span class="math">T/F</span>. Deterministic algorithm that verifies the proof <span class="math">\\pi_{I}</span> that <span class="math">\\mathbf{v}_{I}</span> is the <span class="math">I</span>-subvector of the vector committed in <span class="math">c</span>. As before, <span class="math">I</span> can be either an index set <span class="math">I\\subseteq[0,n)</span> or an individual index <span class="math">I=i\\in[0,n)</span>.</p>

    <p class="text-gray-300">VC.VerifyUPK(<span class="math">\\mathsf{vrk},i,\\mathsf{upk}_{i}</span>) <span class="math">\\rightarrow</span> <span class="math">T/F</span>. Deterministic algorithm that verifies that <span class="math">\\mathsf{upk}_{i}</span> is indeed the <span class="math">i</span>th update key.</p>

    <p class="text-gray-300">VC.UpdateComm(<span class="math">c,\\delta,j,\\mathsf{upk}_{j}</span>) <span class="math">\\rightarrow</span> <span class="math">c^{\\prime}</span>. Deterministic algorithm that returns a new commitment <span class="math">c^{\\prime}</span> to <span class="math">\\mathbf{v^{\\prime}}</span> obtained by updating <span class="math">v_{j}</span> to <span class="math">v_{j}+\\delta</span> in the vector <span class="math">\\mathbf{v}</span> committed in <span class="math">c</span>. Needs <span class="math">\\mathsf{upk}_{j}</span> associated with the updated position <span class="math">j</span>.</p>

    <p class="text-gray-300">VC.UpdateProof(<span class="math">\\pi_{i},\\delta,i,j,\\mathsf{upk}_{i},\\mathsf{upk}_{j}</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi^{\\prime}_{i}</span>. Deterministic algorithm that updates an old proof <span class="math">\\pi_{i}</span> for the <span class="math">i</span>th element <span class="math">v_{i}</span>, given that the <span class="math">j</span>th element was updated to <span class="math">v_{j}+\\delta</span>. Note that <span class="math">i</span> can be equal to <span class="math">j</span>.</p>

    <p class="text-gray-300">VC.AggregateProofs(<span class="math">I,(\\pi_{i})_{i\\in I}</span>) <span class="math">\\rightarrow</span> <span class="math">\\pi_{I}</span> Deterministic algorithm that, given proofs <span class="math">\\pi_{i}</span> for <span class="math">v_{i},\\forall i\\in I</span>, aggregates them into a succinct <span class="math">I</span>-subvector proof <span class="math">\\pi_{I}</span>.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.2 aSVC Correctness and Security Definitions</h3>

    <p class="text-gray-300">We argue why our aSVC from Section 3 satisfies these definitions in Section 3.4.5.</p>

    <h6 id="sec-17" class="text-base font-medium mt-4">Definition 1 (Aggregatable SVC Scheme).</h6>

    <p class="text-gray-300">(VC.KeyGen, VC.Commit, VC.ProvePos, VC.VerifyPos, VC.VerifyUPK, VC.UpdateComm, VC.UpdateProof, VC.AggregateProofs) is a secure aggregatable subvector commitment scheme if <span class="math">\\forall</span> upper-bounds <span class="math">n=\\mathsf{poly}(\\lambda)</span> it satisfies the following properties:</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 2 (Opening Correctness).</h6>

    <p class="text-gray-300"><span class="math">\\forall</span> vectors <span class="math">\\mathbf{v}=(v_{j})_{j\\in[0,n)}</span>, <span class="math">\\forall</span> index sets <span class="math">I\\subseteq[0,n)</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathsf{prk},\\mathsf{vrk},(\\mathsf{upk}_{j})_{j\\in[0,n)}\\leftarrow\\mathsf{VC.KeyGen}(1^{\\lambda},n),\\\\ c\\leftarrow\\mathsf{VC.Commit}(\\mathsf{prk},\\mathbf{v}),\\\\ \\pi_{I}\\leftarrow\\mathsf{VC.ProvePos}(\\mathsf{prk},I,\\mathbf{v}):\\\\ \\mathsf{VC.VerifyPos}(\\mathsf{vrk},c,\\mathbf{v}_{I},I,\\pi_{I})=T\\end{array}\\right]\\geq 1-\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Tomescu et al.</p>

    <p class="text-gray-300">Definition 3 (Commitment and Proof Update Correctness).  <span class="math">\\forall</span>  vectors  <span class="math">\\mathbf{v} = (v_{j})_{j\\in [0,n)}</span> ,  <span class="math">\\forall</span>  positions  <span class="math">i,k\\in [0,n)</span> ,  <span class="math">\\forall</span>  updates  <span class="math">\\delta \\in \\mathbb{Z}_p</span> , let  <span class="math">\\mathbf{u} = (u_j)_{j\\in [0,n)}</span>  be the same vector as  <span class="math">\\mathbf{v}</span>  except with  <span class="math">v_{k} + \\delta</span>  rather than  <span class="math">v_{k}</span>  at position  <span class="math">k</span> . Then:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n), \\\\ c \\leftarrow \\operatorname {V C}. \\operatorname {C o m m i t} (\\operatorname {p r k}, \\mathbf {v}), \\\\ \\hat {c} \\leftarrow \\operatorname {V C}. \\operatorname {U p d a t e C o m m} (c, \\delta , k, \\operatorname {u p k} _ {k}), \\\\ c ^ {\\prime} \\leftarrow \\operatorname {V C}. \\operatorname {C o m m i t} (\\operatorname {p r k}, \\mathbf {u}): \\\\ c ^ {\\prime} = \\hat {c} \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n), \\\\ c \\leftarrow \\operatorname {V C}. \\operatorname {C o m m i t} (\\operatorname {p r k}, \\mathbf {v}), \\\\ c ^ {\\prime} \\leftarrow \\operatorname {V C}. \\operatorname {U p d a t e C o m m} (c, \\delta , k, \\operatorname {u p k} _ {k}), \\\\ \\pi_ {i} \\leftarrow \\operatorname {V C}. \\operatorname {P r o v e P o s} (\\operatorname {p r k}, i, \\mathbf {v}), \\\\ \\pi_ {i} ^ {\\prime} \\leftarrow \\operatorname {V C}. \\operatorname {U p d a t e P r o o f} (\\pi_ {i}, \\delta , i, k, \\operatorname {u p k} _ {i}, \\operatorname {u p k} _ {k}): \\\\ \\operatorname {V C}. \\operatorname {V e r i f y P o s} (\\operatorname {v r k}, c ^ {\\prime}, u _ {i}, i, \\pi_ {i} ^ {\\prime}) = T \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Definition 4 (Aggregation Correctness).  <span class="math">\\forall</span>  vectors  <span class="math">\\mathbf{v} = (v_{j})_{j\\in [0,n)}</span> ,  <span class="math">\\forall</span>  index sets  <span class="math">I\\subseteq [0,n)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n), \\\\ c \\leftarrow \\operatorname {V C}. \\operatorname {C o m m i t} (\\operatorname {p r k}, \\mathbf {v}), \\\\ (\\pi_ {i} \\leftarrow \\operatorname {V C}. \\operatorname {P r o v e P o s} (\\operatorname {p r k}, i, \\mathbf {v})) _ {i \\in I}, \\\\ \\pi_ {I} \\leftarrow \\operatorname {V C}. \\operatorname {A g g r e g a t e P r o o f s} (I, (\\pi_ {i}) _ {i \\in I}): \\\\ \\operatorname {V C}. \\operatorname {V e r i f y P o s} (\\operatorname {v r k}, c, \\mathbf {v} _ {I}, I, \\pi_ {I}) = T \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Definition 5 (Update Key Correctness).  <span class="math">\\forall</span>  positions  <span class="math">i\\in [0,n)</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n): \\\\ \\operatorname {V C}. \\operatorname {V e r i f y U P K} (\\operatorname {v r k}, i, \\operatorname {u p k} _ {i}) = T \\end{array} \\right] \\geq 1 - \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Definition 6 (Update Key Uniqueness).  <span class="math">\\forall</span>  adversaries  <span class="math">\\mathcal{A}</span>  running in time poly  <span class="math">(\\lambda)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n), \\\\ i, \\operatorname {u p k}, \\operatorname {u p k} ^ {\\prime} \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {j}) _ {j \\in [ 0, n)}): \\\\ \\operatorname {V C}. \\operatorname {V e r i f y U P K} (\\operatorname {v r k}, i, \\operatorname {u p k}) = T \\wedge \\\\ \\operatorname {V C}. \\operatorname {V e r i f y U P K} (\\operatorname {v r k}, i, \\operatorname {u p k} ^ {\\prime}) = T \\wedge \\\\ \\operatorname {u p k} \\neq \\operatorname {u p k} ^ {\\prime} \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Observation: Definitions that allow for dynamic update hints rather than unique update keys are possible too, but would be less simple to state and less useful for stateless cryptocurrencies (see Section 4).</p>

    <p class="text-gray-300">Definition 7 (Position Binding Security).  <span class="math">\\forall</span>  adversaries  <span class="math">\\mathcal{A}</span>  running in time poly  <span class="math">(\\lambda)</span> , if  <span class="math">\\mathbf{v}_I = (v_i)_{i\\in I}</span>  and  <span class="math">\\mathbf{v}_J^{\\prime} = (v_j^{\\prime})_{j\\in J}</span> , then:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {i}) _ {i \\in [ 0, n)} \\leftarrow \\operatorname {V C}. \\operatorname {K e y G e n} (1 ^ {\\lambda}, n), \\\\ (c, I, J, \\mathbf {v} _ {I}, \\mathbf {v} _ {J} ^ {\\prime}, \\pi_ {I}, \\pi_ {J}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\operatorname {p r k}, \\operatorname {v r k}, (\\operatorname {u p k} _ {i}) _ {i \\in [ 0, n)}): \\\\ \\operatorname {V C}. \\operatorname {V e r i f y P o s} (\\operatorname {v r k}, c, \\mathbf {v} _ {I}, I, \\pi_ {I}) = T \\wedge \\\\ \\operatorname {V C}. \\operatorname {V e r i f y P o s} (\\operatorname {v r k}, c, \\mathbf {v} _ {J} ^ {\\prime}, J, \\pi_ {J}) = T \\wedge \\\\ \\exists k \\in I \\cap J, \\text {s u c h t h a t} v _ {k} \\neq v _ {k} ^ {\\prime} \\end{array} \\right] \\leq \\operatorname {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">In this subsection, we present our aSVC from KZG commitments to Lagrange polynomials. Similar to previous work, we represent a vector  <span class="math">\\mathbf{v} = [v_0,v_1,\\dots ,v_{n - 1}]</span>  as a polynomial  <span class="math">\\phi (X) = \\sum_{i\\in [0,n)}\\mathcal{L}_i(X)v_i</span>  in Lagrange basis [KZG10,CDHK15, Tom20,GRWZ20]. However, unlike previous work, we add support for efficiently updating and aggregating proofs. For aggregation, we use known techniques for aggregating KZG proofs via partial fraction decomposition [But20]. For updating proofs, we introduce a new mechanism to reduce the update key size from linear to constant. We use roots of unity and "store"  <span class="math">v_{i}</span>  as  <span class="math">\\phi (\\omega^i) = v_i</span> , which means our Lagrange polynomials are  <span class="math">\\mathcal{L}_i(X) = \\prod_{j\\in [0,n),j\\neq i}\\frac{X - \\omega^j}{\\omega^i - \\omega^j}</span> . For this to work efficiently, we assume without loss of generality that  <span class="math">n</span>  is a power of two.</p>

    <p class="text-gray-300">Aggregatable Subvector Commitments for Stateless Cryptocurrencies</p>

    <p class="text-gray-300">Table 2. Asymptotic comparison of our aSVC with other (aS)VCs based on prime-order groups.  <span class="math">n</span>  is the vector size and  <span class="math">b</span>  is the subvector size. See Appendix D for a more detailed analysis. All schemes have  <span class="math">O(n)</span> -sized parameters (except [LM19] has  <span class="math">O(n^2)</span>  and  <span class="math">[\\mathrm{GFG}^{+}20]</span>  has  <span class="math">O(1)</span> ); can update commitments in  <span class="math">O(1)</span>  time (except for [KZG10]); have  <span class="math">O(1)</span> -sized proofs that verify in  <span class="math">O(1)</span>  time (except [CPZ18] and [Tom20] proofs are  <span class="math">O(\\lg n)</span> ). Com. is the time to commit to a size-  <span class="math">n</span>  vector. Proof upd. is the time to update one individual proof  <span class="math">\\pi_i</span>  after a change to one vector element  <span class="math">v_j</span> . Prove one, Prove subv. and Prove each are the times to compute a proof  <span class="math">\\pi_i</span>  for one  <span class="math">v_i</span> , a size-  <span class="math">b</span>  subvector proof  <span class="math">\\pi_I</span>  and proofs for all  <span class="math">(v_i)_{i\\in [0,n)}</span> , respectively.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(aS)VC scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vrk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">upki</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Com.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove one</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof upd.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove subv.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify subv.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggr-egate</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove each</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[LM19]</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">bn</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[KZG10]</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg2n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b + n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CDHK15]</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg2n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg2n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CPZ18]</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[Tom20]</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n + b</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b + n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[GRWZ20]</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">bn</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">n2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">[CFG+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">(n - b) lg (n - b)</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our work</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b + n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our work*</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg2b</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Committing. A commitment to  <span class="math">\\mathbf{v}</span>  is just a KZG commitment  <span class="math">c = g^{\\phi(\\tau)}</span>  to  <span class="math">\\phi(X)</span> , where  <span class="math">\\tau</span>  is the trapdoor of the KZG scheme (see Section 2.2). Similar to previous work [CDHK15], the proving key includes commitments to all Lagrange polynomials  <span class="math">\\ell_i = g^{\\mathcal{L}_i(\\tau)}</span> . Thus, we can compute  <span class="math">c = \\prod_{i=1}^{n} (\\ell_i)^{v_i}</span>  in  <span class="math">O(n)</span>  time without interpolating  <span class="math">\\phi(X)</span>  and update it as  <span class="math">c&#x27; = c \\cdot (\\ell_i)^{\\delta}</span>  after adding  <span class="math">\\delta</span>  to  <span class="math">v_i</span> . Note that  <span class="math">c&#x27;</span>  is just a commitment to an updated  <span class="math">\\phi&#x27;(X) = \\phi(X) + \\delta \\cdot \\mathcal{L}_i(X)</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving. A proof  <span class="math">\\pi_i</span>  for a single element  <span class="math">v_i</span>  is just a KZG evaluation proof for  <span class="math">\\phi(\\omega^i)</span> . A subvector proof  <span class="math">\\pi_I</span>  for  <span class="math">v_I, I \\subseteq [0, n)</span>  is just a KZG batch proof for all  <span class="math">\\phi(\\omega^i)_{i \\in I}</span>  evaluations. Importantly, we use the Feist-Khovratovich (FK) [FK20] technique to compute all proofs  <span class="math">(\\pi_i)_{i \\in [0, n)}</span>  in  <span class="math">O(n \\log n)</span>  time. This allows us to aggregate  <span class="math">I</span> -subvector proofs faster in  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  time (see Table 2).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A key ingredient in our aSVC scheme is partial fraction decomposition [Wik19], which we re-explain from the perspective of Lagrange interpolation. First, let us rewrite the Lagrange polynomial for interpolating  <span class="math">\\phi(X)</span>  given all  <span class="math">(\\phi(\\omega^i))_{i \\in I}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {L} _ {i} (X) = \\prod_ {j \\in I, j \\neq i} \\frac {X - \\omega^ {j}}{\\omega^ {i} - \\omega^ {j}} = \\frac {A _ {I} (X)}{A _ {I} ^ {\\prime} (\\omega^ {i}) (X - \\omega^ {i})}, \\text {w h e r e} A _ {I} (X) = \\prod_ {i \\in I} (X - \\omega^ {i}) \\tag {1}</span></div>

    <p class="text-gray-300">Here,  <span class="math">A_I&#x27;(X) = \\sum_{j \\in I} A_I(X) / (X - \\omega^j)</span>  is the derivative of  <span class="math">A_I(X)</span>  [vzGG13b]. Next, for any  <span class="math">\\phi(X)</span> , we can rewrite the Lagrange interpolation formula as  <span class="math">\\phi(X) = A_I(X) \\sum_{i \\in [0,n)} \\frac{y_i}{A_I&#x27;(\\omega^i)(X - \\omega^i)}</span> . In particular, for  <span class="math">\\phi(X) = 1</span> , this implies  <span class="math">\\frac{1}{A_I(X)} = \\sum_{i \\in [0,n)} \\frac{1}{A_I&#x27;(\\omega^i)(X - \\omega^i)}</span> . In other words, we can decompose  <span class="math">A_I(X)</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {1}{A _ {I} (X)} = \\frac {1}{\\prod_ {i \\in I} (X - \\omega^ {i})} = \\sum_ {i \\in [ 0, n)} c _ {i} \\cdot \\frac {1}{X - \\omega^ {i}}, \\text {w h e r e} c _ {i} = \\frac {1}{A _ {I} ^ {\\prime} (\\omega^ {i})} \\tag {2}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">A_{I}(X)</span>  can be computed in  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time using a subproduct tree and DFT-based polynomial multiplication [vzGG13b]. Its derivative,  </span>A_I'(X)<span class="math"> , can be computed in  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time and evaluated at all  </span>\\omega^i<span class="math"> &#x27;s in  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time [vzGG13b]. Thus, all  </span>c_{i}<span class="math"> &#x27;s can be computed in  </span>O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  time. For the special case of  </span>I = [0,n)<span class="math"> , we have  </span>A_{I}(X) = A(X) = \\prod_{i\\in [0,n)}(X - \\omega^{i}) = X^{n} - 1<span class="math">  and  </span>A^{\\prime}(\\omega^{i}) = n\\omega^{-i}<span class="math">  (see Appendix A). In this case, any  </span>c_{i}<span class="math">  can be computed in  </span>O(1)$  time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We build upon Drake and Buterin's observation [But20] that partial fraction decomposition (see Section 3.4) can be used to aggregate KZG evaluation proofs. Since our VC proofs are KZG proofs, we show how to aggregate a set of proofs  <span class="math">(\\pi_i)_{i\\in I}</span>  for elements  <span class="math">v_{i}</span>  of  <span class="math">\\mathbf{v}</span>  into a constant-sized  <span class="math">I</span>  -subvector proof  <span class="math">\\pi_I</span>  for  <span class="math">(v_{i})_{i\\in I}</span> .</p>

    <p class="text-gray-300">Recall that  <span class="math">\\pi_i</span>  is a commitment to  <span class="math">q_i(X) = \\frac{\\phi(X) - v_i}{X - \\omega^i}</span>  and  <span class="math">\\pi_I</span>  is a commitment to  <span class="math">q(X) = \\frac{\\phi(X) - R(X)}{A_I(X)}</span> , where  <span class="math">A_I(X) = \\prod_{i \\in I} (X - \\omega^i)</span>  and  <span class="math">R(X)</span>  is interpolated such that  <span class="math">R(\\omega^i) = v_i, \\forall i \\in I</span> . Our goal is to find coefficients  <span class="math">c_i \\in \\mathbb{Z}_p</span></p>

    <p class="text-gray-300">Tomescu et al.</p>

    <p class="text-gray-300">such that <span class="math"> q(X) = \\sum_{i \\in I} c_i q_i(X) </span> and thus aggregate <span class="math"> \\pi_I = \\prod_{i \\in I} \\pi_i^{c_i} </span>. We observe that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} q(X) &amp;amp;= \\phi(X) \\frac{1}{A_I(X)} - R(X) \\frac{1}{A_I(X)} \\quad \\text{(3)} \\\\ &amp;amp;= \\phi(X) \\sum_{i \\in I} \\frac{1}{A_I&#x27;(\\omega^i)(X - \\omega^i)} - \\left(A_I(X) \\sum_{i \\in I} \\frac{v_i}{A_I&#x27;(\\omega^i)(X - \\omega^i)}\\right) \\cdot \\frac{1}{A_I(X)} \\quad \\text{(4)} \\\\ &amp;amp;= \\sum_{i \\in I} \\frac{\\phi(X)}{A_I&#x27;(\\omega^i)(X - \\omega^i)} - \\sum_{i \\in I} \\frac{v_i}{A_I&#x27;(\\omega^i)(X - \\omega^i)} = \\sum_{i \\in I} \\frac{1}{A_I&#x27;(\\omega^i)} \\cdot \\frac{\\phi(X) - v_i}{X - \\omega^i} \\quad \\text{(5)} \\\\ &amp;amp;= \\sum_{i \\in I} \\frac{1}{A_I&#x27;(\\omega^i)} \\cdot q_i(X) \\quad \\text{(6)} \\end{aligned}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, we can compute all <span class="math"> c_i = 1 / A_I&#x27;(\\omega^i) </span> using $ O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) <span class="math"> field operations (see Section 3.4) and compute </span> \\pi_I = \\prod_{i \\in I} \\pi_i^{c_i} <span class="math"> with an </span> O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) $-sized multi-exponentiation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-22" class="text-2xl font-bold">3.4.2 Updating Proofs</h2>

    <p class="text-gray-300">When updating <span class="math"> \\pi_i </span> after a change to <span class="math"> v_j </span>, it could be that either <span class="math"> i = j </span> or <span class="math"> i \\neq j </span>. First, recall that <span class="math"> \\pi_i </span> is a KZG commitment to <span class="math"> q_i(X) = \\frac{\\phi(X) - v_i}{X - \\omega^i} </span>. Second, recall that, after a change <span class="math"> \\delta </span> to <span class="math"> v_j </span>, the polynomial <span class="math"> \\phi(X) </span> is updated to <span class="math"> \\phi&#x27;(X) = \\phi(X) + \\delta \\cdot \\mathcal{L}_j(X) </span>. We refer to the party updating their proof <span class="math"> \\pi_i </span> as the proof updater.</p>

    <p class="text-gray-300">The <span class="math"> i = j </span> Case. Consider the quotient polynomial <span class="math"> q_i&#x27;(X) </span> in the updated proof <span class="math"> \\pi_i&#x27; </span> after <span class="math"> v_i </span> changed to <span class="math"> v_i + \\delta </span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} q_i&#x27;(X) &amp;amp;= \\frac{\\phi&#x27;(X) - (v_i + \\delta)}{X - \\omega^i} = \\frac{(\\phi(X) + \\delta \\mathcal{L}_i(X)) - v_i - \\delta}{X - \\omega^i} \\quad \\text{(7)} \\\\ &amp;amp;= \\frac{\\phi(X) - v_i}{X - \\omega^i} + \\frac{\\delta(\\mathcal{L}_i(X) - 1)}{X - \\omega^i} = q_i(X) + \\delta\\left(\\frac{\\mathcal{L}_i(X) - 1}{X - \\omega^i}\\right) \\quad \\text{(8)} \\end{aligned}</span></div>

    <p class="text-gray-300">This means the proof updater needs a KZG commitment to <span class="math"> \\frac{\\mathcal{L}_i(X) - 1}{X - \\omega^i} </span>, which is just a KZG evaluation proof that <span class="math"> \\mathcal{L}_i(\\omega^i) = 1 </span>. This can be addressed very easily by making this commitment part of <span class="math"> \\mathsf{upk}_i </span>. To conclude, to update <span class="math"> \\pi_i </span>, the proof updater obtains <span class="math"> u_i = g^{\\frac{\\mathcal{L}_j(\\tau) - 1}{\\tau - \\omega^i}} </span> from <span class="math"> \\mathsf{upk}_i </span> and computes <span class="math"> \\pi_i&#x27; = \\pi_i \\cdot (u_i)^\\delta </span>. (Remember that the proof updater, who calls VC.UpdateProof( <span class="math">\\pi_i, \\delta, i, i, \\mathsf{upk}_i, \\mathsf{upk}_i </span>), has <span class="math"> \\mathsf{upk}_i </span>.)</p>

    <p class="text-gray-300">The <span class="math"> i \\neq j </span> Case. Now, consider the quotient polynomial <span class="math"> q_i&#x27;(X) </span> after <span class="math"> v_j </span> changed to <span class="math"> v_j + \\delta </span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} q_i&#x27;(X) &amp;amp;= \\frac{\\phi&#x27;(X) - v_i}{X - \\omega^i} = \\frac{(\\phi(X) + \\delta \\mathcal{L}_j(X)) - v_i}{X - \\omega^i} \\quad \\text{(9)} \\\\ &amp;amp;= \\frac{\\phi(X) - v_i}{X - \\omega^i} + \\frac{\\delta \\mathcal{L}_j(X)}{X - \\omega^i} = q_i(X) + \\delta\\left(\\frac{\\mathcal{L}_j(X)}{X - \\omega^i}\\right) \\quad \\text{(10)} \\end{aligned}</span></div>

    <p class="text-gray-300">In this case, the proof updater will need to construct a KZG commitment to <span class="math"> \\frac{\\mathcal{L}_j(X)}{X - \\omega^i} </span>. For this, we put enough information in <span class="math"> \\mathsf{upk}_i </span> and <span class="math"> \\mathsf{upk}_j </span>, which the proof updater has (see Section 3.1), to help her do so.</p>

    <p class="text-gray-300">Since <span class="math"> U_{i,j}(X) = \\frac{A(X)}{A&#x27;(\\omega^j)(X - \\omega^j)(X - \\omega^i)} </span> and <span class="math"> A&#x27;(\\omega^j) = n\\omega^{-j} </span> (see Appendix A), it is sufficient to reconstruct a KZG commitment to <span class="math"> W_{i,j}(X) = \\frac{A(X)}{(X - \\omega^j)(X - \\omega^i)} </span>, which can be decomposed as <span class="math"> W_{i,j}(X) = A(X)\\left(c_i\\frac{1}{X - \\omega^i} + c_j\\frac{1}{X - \\omega_j}\\right) = c_i\\frac{A(X)}{X - \\omega^i} + c_j\\frac{A(X)}{X - \\omega^j} </span>, where <span class="math"> c_i = 1 / (\\omega^i - \\omega^j) </span> and <span class="math"> c_j = 1 / (\\omega^j - \\omega^i) </span> (see Section 3.4). Thus, if we include <span class="math"> a_j = g^{A(\\tau) / (\\tau - \\omega^j)} </span> in each <span class="math"> \\mathsf{upk}_j </span>, the proof updater can first compute <span class="math"> w_{i,j} = a_i^{c_i}a_j^{c_j} </span>, then compute <span class="math"> u_{i,j} = (w_{i,j})^{\\frac{1}{A&#x27;(\\omega^j)}} </span> and finally update the proof as <span class="math"> \\pi_i&#x27; = \\pi_i \\cdot (u_{i,j})^\\delta </span>.</p>

    <h2 id="sec-23" class="text-2xl font-bold">3.4.3 aSVC Algorithms</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Having established the intuition for our aSVC, we can now describe it in detail using the aSVC API from Section 3.1. To support verifying <span class="math"> I </span>-subvector proofs, our verification key is $ O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) $-sized.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">VC.KeyGen(1^λ, n) → prk, vrk, (upk_j)_{j \\in [0,n)}<span class="math">. Generates </span> n <span class="math">-SDH public parameters </span> g, g^{\\tau}, g^{\\tau^2}, \\ldots, g^{\\tau^n} <span class="math">. Computes </span> a = g^{A(\\tau)} <span class="math">, where </span> A(X) = X^n - 1 <span class="math">. Computes </span> a_i = g^{A(\\tau)/(X - \\omega^i)} <span class="math"> and </span> \\ell_i = g^{\\mathcal{L}_i(\\tau)}, \\forall i \\in [0,n) <span class="math">. Computes KZG proofs </span> u_i = g^{\\frac{\\mathcal{L}_i(\\tau) - 1}{X - \\omega^i}} <span class="math"> for </span> \\mathcal{L}_i(\\omega^i) = 1 <span class="math">. Sets </span> \\mathsf{upk}_i = (a_i, u_i) <span class="math">, prk = ((g^{\\tau^i})_{i \\in [0,n]}, (\\ell_i)_{i \\in [0,n}) </span>, (\\mathsf{upk}_i)_{i \\in [0,n)}) <span class="math"> and </span> \\mathsf{vrk} = ((g^{\\tau^i})_{i \\in [0,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]}, a) $.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.Commit}(\\mathsf{prk},\\mathbf{v})\\to c</span>. Returns <span class="math">c=\\prod_{i\\in[0,n)}(\\ell_{i})^{v_{i}}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{VC.ProvePos}(\\mathsf{prk},I,\\mathbf{v})\\to\\pi_{I}</span>. Computes <span class="math">A_{I}(X)=\\prod_{i\\in I}(X-\\omega^{i})</span> in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. Divides </span>\\phi(X)<span class="math"> by </span>A_{I}(X)<span class="math"> in </span>O(n\\log n)<span class="math"> time, obtaining a quotient </span>q(X)<span class="math"> and a remainder </span>r(X)<span class="math">. Returns </span>\\pi_{I}=g^{q(\\tau)}<span class="math">. (We give an </span>O(n)<span class="math"> time algorithm in Appendix D.7 for the </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=1$ case.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\mathsf{VC.VerifyUPK}(\\mathsf{vrk},i,\\mathsf{upk}_{i})\\to T/F</span>. Checks that <span class="math">\\omega^{i}</span> is a root of <span class="math">X^{n}-1</span> (which is committed in <span class="math">a</span>) via <span class="math">e(a_{i},g^{\\tau}/g^{(\\omega^{i})})=e(a,g)</span>. Checks that <span class="math">\\mathcal{L}_{i}(\\omega^{i})=1</span> via <span class="math">e(\\ell_{i}/g^{1},g)=e(u_{i},g^{\\tau}/g^{(\\omega^{i})})</span>, where <span class="math">\\ell_{i}=a_{i}^{1/A^{\\prime}(\\omega^{i})}=g^{\\mathcal{L}_{i}(\\tau)}</span>. <span class="math">\\mathsf{VC.UpdateComm}(c,\\delta,j,\\mathsf{upk}_{j})\\to c^{\\prime}</span>. Returns <span class="math">c^{\\prime}=c\\cdot(\\ell_{j})^{\\delta}</span>, where <span class="math">\\ell_{j}=a_{j}^{1/A^{\\prime}(\\omega^{j})}</span>. <span class="math">\\mathsf{VC.UpdateProof}(\\pi_{i},\\delta,i,j,\\mathsf{upk}_{i},\\mathsf{upk}_{j})\\to\\pi_{i}^{\\prime}</span>. If <span class="math">i=j</span>, returns <span class="math">\\pi_{i}^{\\prime}=\\pi_{i}\\cdot(u_{i})^{\\delta}</span>. If <span class="math">i\\neq j</span>, computes <span class="math">w_{i,j}=a_{i}^{1/(\\omega^{i}-\\omega^{j})}</span> . <span class="math">a_{j}^{1/(\\omega^{j}-\\omega^{i})}</span> and <span class="math">u_{i,j}=w_{i,j}^{1/A^{\\prime}(\\omega^{j})}</span> (see Section 3.4.2) and returns <span class="math">\\pi_{i}^{\\prime}=\\pi_{i}\\cdot(u_{i,j})^{\\delta}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{VC.AggregateProofs}(I,(\\pi_{i})_{i\\in I})\\to\\pi_{I}</span>. Computes <span class="math">A_{I}(X)=\\prod_{i\\in I}(X-\\omega^{i})</span>, its derivative <span class="math">A_{I}^{\\prime}(X)</span> and all <span class="math">c_{i}=(A_{I}^{\\prime}(\\omega^{i}))_{i\\in I}</span> in $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\log^{2}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> time. Returns </span>\\pi_{I}=\\prod_{i\\in I}\\pi_{i}^{c_{i}}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">3.4.4 Distributing the Trusted Setup</h4>

    <p class="text-gray-300">Our aSVC requires a centralized, trusted setup phase that computes its public parameters. We can decentralize this phase using highly-efficient MPC protocols that generate <span class="math">(g^{\\tau^{i}})</span>’s in a distributed fashion <em>[x1]</em>. Then, we can derive the remaining parameters from the <span class="math">(g^{\\tau^{i}})</span>’s, which has the advantage of keeping our parameters <em>updatable</em>. First, the commitment <span class="math">a=g^{A(\\tau)}</span> to <span class="math">A(X)=X^{n}-1</span> can be computed in <span class="math">O(1)</span> time via an exponentiation. Second, the commitments <span class="math">\\ell_{i}=g^{\\mathcal{L}_{i}(\\tau)}</span> to Lagrange polynomials can be computed via a single DFT on the <span class="math">(g^{\\tau^{i}})</span>’s <em>[x27, Sec 3.12.3, pg. 97]</em>. Third, each <span class="math">a_{i}=g^{A(\\tau)/(\\tau-\\omega^{i})}</span> is a bilinear accumulator membership proof for <span class="math">\\omega^{i}</span> w.r.t. <span class="math">A(X)</span> and can all be computed in <span class="math">O(n\\log n)</span> time using FK <em>[x11]</em>. But what about computing each <span class="math">u_{i}=g^{\\frac{\\mathcal{L}_{i}(\\tau)-1}{X-\\omega^{i}}}</span>?</p>

    <p class="text-gray-300">Computing All <span class="math">u_{i}</span>’s Fast. Inspired by the FK technique <em>[x12]</em>, we show how to compute all <span class="math">n</span> <span class="math">u_{i}</span>’s in <span class="math">O(n\\log n)</span> time using a single DFT on group elements. First, note that <span class="math">u_{i}=g^{\\frac{\\mathcal{L}_{i}(\\tau)-1}{X-\\omega^{i}}}</span> is a KZG evaluation proof for <span class="math">\\mathcal{L}_{i}(\\omega^{i})=1</span>. Thus, <span class="math">u_{i}=g^{Q_{i}(\\tau)}</span> where <span class="math">Q_{i}(X)=\\frac{\\mathcal{L}_{i}(X)-1}{X-\\omega^{i}}</span>. Second, let <span class="math">\\psi_{i}(X)=A^{\\prime}(\\omega^{i})\\mathcal{L}_{i}(X)=\\frac{X^{n}-1}{X-\\omega^{i}}</span>. Then, let <span class="math">\\pi_{i}=g^{q_{i}(\\tau)}</span> be an evaluation proof for <span class="math">\\psi_{i}(\\omega^{i})=A^{\\prime}(\\omega^{i})</span> where <span class="math">q_{i}(X)=\\frac{\\psi_{i}(X)-A^{\\prime}(\\omega^{i})}{X-\\omega^{i}}</span> and note that <span class="math">Q_{i}(X)=\\frac{1}{A^{\\prime}(\\omega^{i})}q_{i}(X)</span>. Thus, computing all <span class="math">u_{i}</span>’s reduces to computing all <span class="math">\\pi_{i}</span>’s. However, since each proof <span class="math">\\pi_{i}</span> is for a <em>different</em> polynomial <span class="math">\\psi_{i}(X)</span>, directly applying FK does not work. Instead, we give a new algorithm that leverages the structure of <span class="math">\\psi_{i}(X)</span> when divided by <span class="math">X-\\omega^{i}</span>. Specifically, in Appendix B, we show that:</p>

    <p class="text-gray-300"><span class="math">q_{i}(X)=\\sum_{j\\in[0,n-2]}H_{j}(X)\\omega^{ij},\\forall i\\in[0,n),\\text{ where }H_{j}(X)=(j+1)X^{(n-2)-j}</span> (11)</p>

    <p class="text-gray-300">If we let <span class="math">h_{j}</span> be a KZG commitment to <span class="math">H_{j}(X)</span>, then we have <span class="math">\\pi_{i}=\\prod_{j\\in[0,n-2]}h_{j}^{(\\omega^{ij})}</span>, <span class="math">\\forall i\\in[0,n)</span>. Next, recall that the Discrete Fourier Transform (DFT) <em>on a vector of group elements</em> <span class="math">\\mathbf{a}=[a_{0},a_{1},\\ldots,a_{n-1}]\\in\\mathbb{G}^{n}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{DFT}_{n}(\\mathbf{a})=\\mathbf{\\hat{a}}=[\\hat{a}_{0},\\hat{a}_{1},\\ldots,\\hat{a}_{n-1}]\\in\\mathbb{G}^{n},\\text{ where }\\hat{a}_{i}=\\prod_{j\\in[0,n)}a_{j}^{(\\omega^{ij})}</span> (12)</p>

    <p class="text-gray-300">If we let <span class="math">\\bm{\\pi}=[\\pi_{0},\\pi_{1},\\ldots,\\pi_{n-1}]</span> and <span class="math">\\mathbf{h}=[h_{0},h_{1},\\ldots,h_{n-2},1_{\\mathbb{G}},1_{\\mathbb{G}}]</span>, then <span class="math">\\bm{\\pi}=\\mathsf{DFT}_{\\mathsf{n}}(\\mathbf{h})</span>. Thus, computing all <span class="math">n</span> <span class="math">h_{i}</span>’s takes <span class="math">O(n)</span> time and computing all <span class="math">n</span> <span class="math">\\pi_{i}</span>’s takes an <span class="math">O(n\\log n)</span> time DFT. As a result, computing all <span class="math">u_{i}</span>’s from the <span class="math">(g^{\\tau^{i}})</span>’s takes <span class="math">O(n\\log n)</span> time overall.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">3.4.5 Correctness and Security</h4>

    <p class="text-gray-300">The correctness of our aSVC scheme follows naturally from Lagrange interpolation. Aggregation and proof updates are correct by the arguments laid out in Sections 3.4.1 and 3.4.2, respectively. Subvector proofs are correct by the correctness of KZG batch proofs <em>[x20]</em>.</p>

    <p class="text-gray-300">The security of our aSVC schemes does <em>not</em> follow naturally from the security of KZG polynomial commitments. Specifically, as pointed out in <em>[x16]</em>, two inconsistent subvector proofs do <em>not</em> lead to a direct break of KZG’s <em>batch evaluation binding</em>, as defined in <em>[x20, Sec. 3.4]</em>. To address this, we propose a stronger batch evaluation</p>

    <p class="text-gray-300">binding definition (see Definition 8 in Appendix C.1) and prove KZG satisfies it under <span class="math">n</span>-SBDH. This new definition is directly broken by two inconsistent subvector proofs, which implies our aSVC is secure under <span class="math">n</span>-SBDH. Lastly, we prove update key uniqueness holds unconditionally in Appendix C.2.</p>

    <h2 id="sec-26" class="text-2xl font-bold">4 A Highly-efficient Stateless Cryptocurrency</h2>

    <p class="text-gray-300">In this section, we enhance Edrax’s elegant design by replacing their VC with our secure <em>aggregatable</em> subvector commitment (aSVC) scheme from Section 3.3. As a result, our stateless cryptocurrency has smaller, aggregatable proofs and smaller update keys. This leads to smaller, faster-to-verify blocks for miners and faster proof synchronization for users (see Table 1). Furthermore, our verifiable update keys reduce the storage overhead of miners from <span class="math">O(n)</span> update keys to <span class="math">O(1)</span>. We also address a denial of service (DoS) attack in Edrax’s design.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">4.1 From VCs to Stateless Cryptocurrencies</h3>

    <p class="text-gray-300">Edrax pioneered the idea of building account-based, stateless cryptocurrencies on top of any VC scheme <em>[x10]</em>. In contrast, previous approaches were based on <em>authenticated dictionaries (ADs)</em> <em>[x27, x11]</em>, for which efficient constructions with static update keys are not known. In other words, these AD-based approaches used <em>dynamic update hints</em> <span class="math">\\mathsf{uph}_{j}</span> consisting of the proof for position <span class="math">j</span>. This complicated their design, requiring user <span class="math">i</span> to ask a <em>proof-serving node</em> for user <span class="math">j</span>’s proof in order to create a transaction sending money to <span class="math">j</span>.</p>

    <p class="text-gray-300">Trusted Setup. To support up to <span class="math">n</span> users, public parameters <span class="math">(\\mathsf{prk},\\mathsf{vrk},(\\mathsf{upk}_{i})_{i\\in[0,n)})\\leftarrow\\mathsf{VC}.\\mathsf{KeyGen}(1^{\\lambda},n)</span> are generated via a <em>trusted setup</em>, which can be decentralized using MPC protocols <em>[x5]</em>. Miners need to store all <span class="math">O(n)</span> update keys to propose blocks and to validate blocks (which we fix in Section 4.2.2). The <span class="math">\\mathsf{prk}</span> is only needed for <em>proof-serving nodes</em> (see Section 4.3.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The (Authenticated) State. The state is a vector <span class="math">\\mathsf{v}=(v_{i})_{i\\in[0,n)}</span> of size <span class="math">n</span> that maps user <span class="math">i</span> to $v_{i}=(\\mathsf{addr}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bal}_{i})\\in\\mathbb{Z}_{p}<span class="math">, where </span>\\mathsf{bal}_{i}<span class="math"> is her balance and </span>\\mathsf{addr}_{i}<span class="math"> is her <em>address</em>, which we define later. (We discuss including transaction counters for preventing replay attacks in Section 4.3.1.) Importantly, since </span>p\\approx 2^{256}<span class="math">, the first 224 bits of </span>v_{i}<span class="math"> are used for </span>\\mathsf{addr}_{i}<span class="math"> and the last 32 bits for </span>\\mathsf{bal}_{i}<span class="math">. The genesis block’s state is the all zeros vector with digest </span>d_{0}<span class="math"> (e.g., in our aSVC, </span>d_{0}=g^{0}<span class="math">). Initially, each user </span>i<span class="math"> is <em>unregistered</em> and starts with a proof </span>\\pi_{i,0}<span class="math"> that their </span>v_{i}=0$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">“Full” vs. “Traditional” Public Keys. User <span class="math">i</span>’s address is computed as <span class="math">\\mathsf{addr}_{i}=H(\\mathsf{FPK}_{i})</span>, where <span class="math">\\mathsf{FPK}_{i}=(i,\\mathsf{upk}_{i},\\mathsf{tpk}_{i})</span> is her <em>full public key</em> and <span class="math">H</span> is a collision-resistant hash function. Here, <span class="math">\\mathsf{tpk}_{i}</span> denotes a <em>“traditional” public key</em> for a digital signature scheme, with corresponding secret key <span class="math">\\mathsf{tsk}_{i}</span> used to authorize user <span class="math">i</span>’s transactions. To avoid confusion, we will clearly refer to public keys as either “full” or “traditional.”</p>

    <p class="text-gray-300">Registering via INIT Transactions. INIT transactions are used to <em>register</em> new users and assign them a unique, ever-increasing number from 1 to <span class="math">n</span>. For this, each block <span class="math">t</span> stores a <em>count of users registered so far</em> <span class="math">\\mathsf{cnt}_{t}</span>. To register, a user generates a <em>traditional secret key</em> <span class="math">\\mathsf{tsk}</span> with a corresponding <em>traditional public key</em> <span class="math">\\mathsf{tpk}</span>. Then, she broadcasts an INIT transaction:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tx}=[\\texttt{INIT},\\mathsf{tpk}]</span></p>

    <p class="text-gray-300">A miner working on block <span class="math">t+1</span> who receives <span class="math">\\mathsf{tx}</span>, proceeds as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>He sets <span class="math">i=\\mathsf{cnt}_{t+1}</span> and increments the count <span class="math">\\mathsf{cnt}_{t+1}</span> of registered users,</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. He updates the VC via $d_{t+1}=\\mathsf{VC}.\\mathsf{UpdateComm}(d_{t+1},(\\mathsf{addr}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0),i,\\mathsf{upk}_{i})$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>He incorporates <span class="math">\\mathsf{tx}</span> in block <span class="math">t+1</span> as <span class="math">\\mathsf{tx}^{\\prime}=[\\texttt{INIT},(i,\\mathsf{upk}_{i},\\mathsf{tpk}_{i})]=[\\texttt{INIT},\\mathsf{FPK}_{i}]</span>.</li>

    </ol>

    <p class="text-gray-300">The full public key with <span class="math">\\mathsf{upk}_{i}</span> is included so other users can correctly update their VC when they process <span class="math">\\mathsf{tx}^{\\prime}</span>. (The index <span class="math">i</span> is not necessary, since it can be computed from the block’s <span class="math">\\mathsf{cnt}_{t+1}</span> and the number of INIT transactions processed in the block so far.) Note that to compute <span class="math">\\mathsf{addr}_{i}=H(\\mathsf{FPK}_{i})</span>, the miner needs to have the correct <span class="math">\\mathsf{upk}_{i}</span> which requires <span class="math">O(n)</span> storage. We discuss how to avoid this in Section 4.2.2.</p>

    <p class="text-gray-300">Transferring Coins via SPEND Transactions. When transferring <span class="math">v</span> coins to user <span class="math">j</span>, user <span class="math">i</span> (who has <span class="math">v^{\\prime}\\geq v</span> coins) must first obtain <span class="math">\\mathsf{FPK}_{j}=(j,\\mathsf{upk}_{j},\\mathsf{tpk}_{j})</span>. This is similar to existing cryptocurrencies, except the (full) public key is now slightly larger. Then, user <span class="math">i</span> broadcasts a SPEND transaction, signed with her <span class="math">\\mathsf{tsk}_{i}</span>:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tx}=[\\texttt{SPEND},t,\\mathsf{FPK}_{i},j,\\mathsf{upk}_{j},v,\\pi_{i,t},v^{\\prime}]</span></p>

    <p class="text-gray-300">A miner working on block <span class="math">t+1</span> processes this SPEND transaction as follows:</p>

    <p class="text-gray-300">1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. He checks that <span class="math">v\\leq v^{\\prime}</span> and verifies the proof <span class="math">\\pi_{i,t}</span> that user <span class="math">i</span> has <span class="math">v^{\\prime}</span> coins via VC.VerifyPos(vrk, $d_{t},(\\mathsf{addr}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v^{\\prime}),i,\\pi_{i,t}<span class="math">). (If the miner receives another transaction from user </span>i<span class="math">, it needs to carefully account for </span>i<span class="math">’s new </span>v^{\\prime}-v$ balance.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>He updates <span class="math">i</span>’s balance in block <span class="math">t+1</span> with <span class="math">d_{t+1}=\\mathsf{VC.UpdateComm}(d_{t+1},-v,i,\\mathsf{upk}_{i})</span>, which only sets the lower order bits of <span class="math">v_{i}</span> corresponding to <span class="math">\\mathsf{bal}_{i}</span>, without touching the higher order bits for <span class="math">\\mathsf{addr}_{i}</span>.</li>

      <li>He does the same for <span class="math">j</span> with <span class="math">d_{t+1}=\\mathsf{VC.UpdateComm}(d_{t+1},\\,+v,j,\\mathsf{upk}_{j})</span>.</li>

    </ol>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">4.1.2 Validating Blocks.</h4>

    <p class="text-gray-300">Suppose a miner receives a new block <span class="math">t+1</span> with digest <span class="math">d_{t+1}</span> that has <span class="math">b</span> SPEND transactions:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tx}=[\\mathsf{SPEND},t,\\mathsf{FPK}_{i},j,\\mathsf{upk}_{j},v,\\pi_{i,t},v^{\\prime}]</span></p>

    <p class="text-gray-300">To validate this block, the miner (who has <span class="math">d_{t}</span>) proceeds in three steps (INIT transactions can be handled analogously):</p>

    <h5 id="sec-29" class="text-base font-semibold mt-4">Step 1: Check Balances.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">First, for each <span class="math">\\mathsf{tx}</span>, he checks that <span class="math">v\\leq v^{\\prime}</span> and that user <span class="math">i</span> has balance <span class="math">v^{\\prime}</span> via VC.VerifyPos(vrk, <span class="math">d_{t}</span>, $(\\mathsf{addr}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">v^{\\prime}),i,\\pi_{i,t})=T<span class="math">. Since the sending user </span>i$ might have multiple transactions in the block, the miner has to carefully keep track of each sending user’s balance to ensure it never goes below zero.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h5 id="sec-30" class="text-base font-semibold mt-4">Step 2: Check Digest.</h5>

    <p class="text-gray-300">Second, he checks <span class="math">d_{t+1}</span> has been computed correctly from <span class="math">d_{t}</span> and from the new transactions in block <span class="math">t+1</span>. Specifically, he sets <span class="math">d^{\\prime}=d_{t}</span> and for each <span class="math">\\mathsf{tx}</span>, he computes <span class="math">d^{\\prime}=\\mathsf{VC.UpdateComm}(d^{\\prime},-v,i,\\mathsf{upk}_{i})</span> and <span class="math">d^{\\prime}=\\mathsf{VC.UpdateComm}(d^{\\prime},+v,\\,j,\\mathsf{upk}_{j})</span>. Then, he checks that <span class="math">d^{\\prime}=d_{t+1}</span>.</p>

    <h5 id="sec-31" class="text-base font-semibold mt-4">Step 3: Update Proofs, If Any.</h5>

    <p class="text-gray-300">If the miner lost the race to build block <span class="math">t+1</span>, he can start mining block <span class="math">t+2</span> by “moving over” the SPEND transactions from his unmined block. For this, he updates all proofs in those SPEND transactions, so they are valid against the new digest <span class="math">d_{t+1}</span>. Similarly, the miner must also “move over” all INIT transactions, since block <span class="math">t+1</span> might have registered new users.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">4.1.3 User Proof Synchronization.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Consider a user <span class="math">i</span> who has processed the ledger up to time <span class="math">t</span> and has digest <span class="math">d_{t}</span> and proof <span class="math">\\pi_{i,t}</span>. Eventually, she receives a new block <span class="math">t+1</span> with digest <span class="math">d_{t+1}</span> and needs to update her proof so it verifies against <span class="math">d_{t+1}</span>. Initially, she sets <span class="math">\\pi_{i,t+1}=\\pi_{i,t}</span>. For each <span class="math">[\\mathsf{INIT},\\mathsf{FPK}_{j}]</span> transaction, she updates her proof $\\pi_{i,t+1}=\\mathsf{VC.UpdateProof}(\\pi_{i,t+1},(H(\\mathsf{FPK}_{j})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">0),i,j,\\mathsf{upk}_{i},\\mathsf{upk}_{j})<span class="math">. For each </span>[\\mathsf{SPEND},t,\\mathsf{FPK}_{j},k,\\mathsf{upk}_{k},v,\\pi_{j,t},v^{\\prime}]<span class="math">, she updates her proof twice: </span>\\pi_{i,t+1}=\\mathsf{VC.UpdateProof}(\\pi_{i,t+1},-v,i,j,\\mathsf{upk}_{i},\\mathsf{upk}_{j})<span class="math"> and </span>\\pi_{i,t+1}=\\mathsf{VC.UpdateProof}(\\pi_{i,t+1},\\,+v,i,k,\\mathsf{upk}_{i},\\mathsf{upk}_{k})$. We stress that users can safely be offline and miss new blocks. Eventually, when a user comes back online, she downloads the missed blocks, updates her proof and is ready to transact.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">4.2 Efficient Stateless Cryptocurrencies from aSVCs</h3>

    <p class="text-gray-300">In this subsection, we explain how replacing the Edrax VC with our aSVC from Section 3.3 results in a more efficient stateless cryptocurrency (see Table 1). Then, we address a denial of service attack on user registrations in Edrax.</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">4.2.1 Smaller, Faster, Aggregatable Proofs</h4>

    <p class="text-gray-300">Our aSVC enables miners to aggregate all <span class="math">b</span> proofs in a block of <span class="math">b</span> transactions into a single, constant-sized proof. This drastically reduces Edrax’s per-block proof overhead from <span class="math">O(b\\log n)</span> group elements to just one group element. Unfortunately, the <span class="math">b</span> update keys cannot be aggregated, but we still reduce their overhead from <span class="math">O(b\\log n)</span> to <span class="math">b</span> group elements per block (see Section 4.2.3). Our smaller proofs are also faster to update, taking <span class="math">O(1)</span> time rather than <span class="math">O(\\log n)</span>. While verifying an aggregated proof in our aSVC is <span class="math">O(b\\log^{2}b)</span> time, which is asymptotically slower than the <span class="math">O(b)</span> time for verifying <span class="math">b</span> individual ones, it is still <em>concretely</em> faster as it only requires two, rather than <span class="math">O(b)</span>, cryptographic pairings. This makes validating new blocks much faster in practice.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">4.2.2 Reducing Miner Storage Using Verifiable Update Keys</h4>

    <p class="text-gray-300">We stress that miners must validate update keys before using them to update a digest. Otherwise, they risk corrupting that digest, which results in a denial of service. Edrax miners sidestep this problem by simply storing all <span class="math">O(n)</span> update keys. Alternatively, Edrax proposes outsourcing update keys to an untrusted third party via a static Merkle tree. Unfortunately, this would either require interaction <em>during block proposal and block validation</em> or would double the update key size. For example, miners would need to fetch the correct update key and/or its Merkle proof to process a SPEND transaction. Our implicitly-verifiable update keys avoid these pitfalls, since miners can directly verify the update keys in a SPEND transaction via VC.VerifyUPK. Furthermore, for INIT transactions, miners can fetch (in the background) a running window of the update keys needed for the next <span class="math">k</span> registrations. By carefully upper-bounding the number of registrations expected in the near future, we can avoid interaction during the block proposal. This background fetching could be implemented in Edrax too, either with a small overhead via Merkle proofs or by making their update keys verifiable (which seems possible).</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">4.2.3 Smaller Update Keys</h4>

    <p class="text-gray-300">Although, in our aSVC, <span class="math">\\mathsf{upk}_{i}</span> contains <span class="math">a_{i}=g^{A(\\tau)/(X-\\omega^{i})}</span> and <span class="math">u_{i}=g^{\\frac{\\mathcal{L}_{j}(\\tau)-1}{X-\\omega^{i}}}</span>, miners only need to include <span class="math">a_{i}</span> in the block. This is because of two reasons. First, user <span class="math">i</span> already has <span class="math">u_{i}</span> to update her own proof after changes to her own balance. Second, no other user <span class="math">j\\neq i</span> will need <span class="math">u_{i}</span> to update her proof <span class="math">\\pi_{j}</span>. However, as hinted in Section 4.1, miners actually need <span class="math">u_{i}</span> when only a subset of <span class="math">i</span>’s pending transactions get included in block <span class="math">t</span>. In this case, the excluded transactions must have their proofs updated using <span class="math">u_{i}</span> so they can be included in block <span class="math">t+1</span>. Fortunately, this is not a problem, since miners always receive <span class="math">u_{i}</span> with user <span class="math">i</span>’s transactions. The key observation is that they do not have to include <span class="math">u_{i}</span> in the mined block, since users do not need it.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">4.2.4 Addressing DoS Attacks on User Registrations.</h4>

    <p class="text-gray-300">Unfortunately, the registration process based on INIT transactions is susceptible to Denial of Service (DoS) attacks: an attacker can simply send a large number of INIT transactions and quickly exhaust the free space in the vector <span class="math">\\mathbf{v}</span>. There are several ways to address this. First, one can use an aSVC from hidden-order groups, which supports an unbounded number of elements <em>[CFG^{+}20]</em>. However, that would negatively impact performance. Second, as future work, one could develop and use unbounded, authenticated dictionaries <em>with scalable updates</em>. Third, one could simply use multiple bounded aSVCs together with cross-commitment proof aggregation, which our aSVC supports <em>[x11]</em>. Lastly, one can add a cost to user registrations via a new INITSPEND transaction that registers a user <span class="math">j</span> by having user <span class="math">i</span> send her some coins:</p>

    <p class="text-gray-300"><span class="math">[\\texttt{INITSPEND},t,\\mathsf{FPK}_{i},\\mathsf{tpk},v,\\pi_{i,t},v^{\\prime}],\\text{ where }0&lt;v\\leq v^{\\prime}</span></p>

    <p class="text-gray-300">Miners processing this transaction would first register a new user <span class="math">j</span> with traditional public key <span class="math">\\mathsf{tpk}</span> and then transfer her <span class="math">v</span> coins. We stress that this is how existing cryptocurrencies operate anyway: in order to join, one has to be transferred some coins from existing users. Lastly, we can ensure that each <span class="math">\\mathsf{tpk}</span> is only registered once by including in each INIT/INITSPEND transaction a non-membership proof for <span class="math">\\mathsf{tpk}</span> in a Merkle prefix tree of all TPKs. We leave a careful exploration of this to future work.</p>

    <p class="text-gray-300">Finally, miners (and only miners) will be allowed to create a <em>single</em> <span class="math">[\\texttt{INIT},\\mathsf{FPK}_{i}]</span> transaction per block to register themselves. This has the advantage of letting new miners join, without “permission” from other miners or users, while severely limiting DoS attacks, since malicious miners can only register a new user per block. Furthermore, transaction fees and/or additional proof-of-work can also severely limit the frequency of INITSPEND transactions.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">4.2.5 Minting Coins and Transaction Fees.</h4>

    <p class="text-gray-300">Support for minting new coins can be added with a new MINT transaction type:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{tx}=[\\texttt{MINT},i,\\mathsf{upk}_{i},v]</span></p>

    <p class="text-gray-300">Here, <span class="math">i</span> is the miner’s user account and <span class="math">v</span> is the amount of newly minted coins. (Note that miners must register as users using INIT transactions if they are to receive block rewards.) To support transaction fees, we can extend the SPEND transaction format to include a fee, which is then added to the miner’s block reward specified in the MINT transaction.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">4.3 Discussion</h3>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">4.3.1 Making Room for Transaction Counters</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As mentioned in Section 2.3, to prevent transaction replay attacks, account-based stateless cryptocurrencies such as Edrax should actually map a user <span class="math">i</span> to $v_{i}=(\\mathsf{addr}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bal}_{i})<span class="math">, where </span>c_{i}<span class="math"> is her <em>transaction counter</em>. This change is trivial, but does leave less space in </span>v_{i}<span class="math"> for </span>\\mathsf{addr}_{i}<span class="math">, depending on how many bits are needed for </span>c_{i}<span class="math"> and </span>\\mathsf{bal}_{i}<span class="math">. (Recall that </span>v_{i}\\in\\mathbb{Z}_{p}<span class="math"> typically has </span>\\approx 256<span class="math"> bits.) To address this, we propose using one aSVC for mapping </span>i<span class="math"> to </span>\\mathsf{addr}_{i}<span class="math"> and another aSVC for mapping </span>i<span class="math"> to </span>(c_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{bal}_{i})<span class="math">. Our key observation is that if the two aSVCs use different </span>n<span class="math">-SDH parameters (e.g., </span>(g^{\\tau^{\\prime}})<span class="math">’s and </span>(h^{\\tau^{\\prime}})<span class="math">’s, such that </span>\\log_{g}h<span class="math"> is unknown), then we could aggregate commitments, proofs and update keys so as to introduce zero computational and communication overhead in our stateless cryptocurrency. Security of this scheme could be argued similar to security of perfectly hiding KZG commitments <em>[x20]</em>, which commit to </span>\\phi(X)<span class="math"> as </span>g^{\\phi(\\tau)}h^{r(\\tau)}$ in an analogous fashion. We leave investigating the details of this scheme to future work.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4.3.2 Overhead of Synchronizing Proofs</p>

    <p class="text-gray-300">In a stateless cryptocurrency, users need to keep their proofs updated w.r.t. the latest block. For example, in our scheme, each user spends <span class="math">O(b\\cdot\\Delta t)</span> time updating her proof, if there are <span class="math">\\Delta t</span> new blocks of <span class="math">b</span> transactions each. Fortunately, when the underlying VC scheme supports precomputing all <span class="math">n</span> proofs fast <em>[x23]</em>, this overhead can be shifted to untrusted third parties called <em>proof-serving nodes</em> <em>[x10]</em>. Specifically, a proof-serving node would have access to the proving key <span class="math">\\mathsf{prk}</span> and periodically compute all proofs for all <span class="math">n</span> users. Then, any user with an out-of-sync proof could ask a node for their proof and then manually update it, should it be slightly out of date with the latest block. Proof-serving nodes save users a significant amount of proof update work, which is important for users running on constrained devices such as mobile phones.</p>

    <h2 id="sec-41" class="text-2xl font-bold">5 Conclusion</h2>

    <p class="text-gray-300">In this paper, we formalized a new cryptographic primitive called an <em>aggregatable subvector commitment (aSVC)</em> that supports aggregating and updating proofs (and commitments) using only constant-sized, static auxiliary information referred to as an “update key.” We constructed an efficient aSVC from KZG commitments to Lagrange polynomials which, compared to other pairing-based schemes, can precompute, aggregate and update proofs efficiently and, compared to schemes from hidden-order groups, has smaller proofs and should perform better in practice. Lastly, we continued the study of stateless validation initiated by Chepurnoy et al., improving block validation time and block size, while addressing attacks and limitations. We hope our work will ignite further research into stateless validation for payments and smart contracts and lead to improvements both at the theoretical and practical level.</p>

    <h3 id="sec-42" class="text-xl font-semibold mt-8">Acknowledgements</h3>

    <p class="text-gray-300">The authors want to thank Madars Virza for pointing out the Lagrange-based approach to VCs and the DFT technique for computing all KZG commitments to Lagrange polynomials. We also thank Leonid Reyzin and Dimitris Kolonelos for corrections and productive conversations that helped improve this paper.</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BB08] Dan Boneh and Xavier Boyen. Short Signatures Without Random Oracles and the SDH Assumption in Bilinear Groups. Journal of Cryptology, Apr 2008.</li>

      <li>[BBF18] Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. Cryptology ePrint Archive, Report 2018/1188, 2018. https://eprint.iacr.org/2018/1188.</li>

      <li>[BBF19] Dan Boneh, Benedikt Bünz, and Ben Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. In CRYPTO’19, 2019.</li>

      <li>[BdM94] Josh Benaloh and Michael de Mare. One-Way Accumulators: A Decentralized Alternative to Digital Signatures. In Tor Helleseth, editor, EUROCRYPT ’93, pages 274–285, Berlin, Heidelberg, 1994. Springer Berlin Heidelberg.</li>

      <li>[BGM17] Sean Bowe, Ariel Gabizon, and Ian Miers. Scalable Multi-party Computation for zk-SNARK Parameters in the Random Beacon Model, 2017. https://eprint.iacr.org/2017/1050.</li>

      <li>[BMRS20] Joseph Bonneau, Izaak Meckler, Vanishree Rao, and Evan Shapiro. Coda: Decentralized Cryptocurrency at Scale, 2020. https://eprint.iacr.org/2020/352.</li>

      <li>[BSCTV14] Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Scalable Zero Knowledge via Cycles of Elliptic Curves. In CRYPTO’14, 2014.</li>

      <li>[BT04] J. Berrut and L. Trefethen. Barycentric Lagrange Interpolation. SIAM Review, 46(3):501–517, 2004.</li>

      <li>[But17] Vitalik Buterin. The stateless client concept. ethresear.ch, 2017. https://ethresear.ch/t/the-stateless-client-concept/172.</li>

      <li>[But20] Vitalik Buterin. Using polynomial commitments to replace state roots. https://ethresear.ch/t/using-polynomial-commitments-to-replace-state-roots/7095, 2020.</li>

      <li>[CDHK15] Jan Camenisch, Maria Dubovitskaya, Kristiyan Haralambiev, and Markulf Kohlweiss. Composable and Modular Anonymous Credentials: Definitions and Practical Constructions. In ASIACRYPT’15, 2015.</li>

      <li>[CF13] Dario Catalano and Dario Fiore. Vector Commitments and Their Applications. In PKC’13, 2013.</li>

      <li>[CFG^{+}20] Matteo Campanelli, Dario Fiore, Nicola Greco, Dimitris Kolonelos, and Luca Nizzardo. Vector Commitment Techniques and Applications to Verifiable Decentralized Storage, 2020. https://eprint.iacr.org/2020/149.</li>

      <li>[CFM08] Dario Catalano, Dario Fiore, and Mariagrazia Messina. Zero-Knowledge Sets with Short Proofs. In EUROCRYPT’08, 2008.</li>

      <li>[CLRS09] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Third Edition. The MIT Press, 3rd edition, 2009.</li>

      <li>[Com16] Ethereum Community. Sharding FAQ. https://github.com/ethereum/wiki/wiki/Sharding-FAQ, 2016.</li>

      <li>[CPZ18] Alexander Chepurnoy, Charalampos Papamanthou, and Yupeng Zhang. Edrax: A Cryptocurrency with Stateless Transaction Validation, 2018. https://eprint.iacr.org/2018/968.</li>

      <li>[Dry19] Thaddeus Dryja. Utreexo: A dynamic hash-based accumulator optimized for the Bitcoin UTXO set, 2019. https://eprint.iacr.org/2019/611.</li>

      <li>[FK20] Dankrad Feist and Dmitry Khovratovich. Fast amortized Kate proofs, 2020. https://github.com/khovratovich/Kate.</li>

      <li>[GRWZ20] Sergey Gorbunov, Leonid Reyzin, Hoeteck Wee, and Zhenfei Zhang. Pointproofs: Aggregating Proofs for Multiple Vector Commitments, 2020. https://eprint.iacr.org/2020/419.</li>

      <li>[Jou00] Antoine Joux. A One Round Protocol for Tripartite Diffie–Hellman. In Algorithmic Number Theory, 2000.</li>

      <li>[KJG^{+}18] E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and B. Ford. OmniLedger: A Secure, Scale-Out, Decentralized Ledger via Sharding. In IEEE S&P’18, May 2018.</li>

      <li>[KR13] Markulf Kohlweiss and Alfredo Rial. Optimally Private Access Control. In ACM WPES’13, 2013.</li>

      <li>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. Constant-Size Commitments to Polynomials and Their Applications. In ASIACRYPT’10, 2010.</li>

      <li>[LLX07] Jiangtao Li, Ninghui Li, and Rui Xue. Universal Accumulators with Efficient Nonmembership Proofs. In Jonathan Katz and Moti Yung, editors, Applied Cryptography and Network Security, pages 253–269, Berlin, Heidelberg, 2007. Springer Berlin Heidelberg.</li>

      <li>[LM19] Russell W. F. Lai and Giulio Malavolta. Subvector Commitments with Application to Succinct Arguments. In CRYPTO’19, 2019.</li>

      <li>[LY10] Benoît Libert and Moti Yung. Concise Mercurial Vector Commitments and Independent Zero-Knowledge Sets with Short Proofs. In TCC’10, 2010.</li>

      <li>[Mil12] Andrew Miller. Storing UTXOs in a balanced Merkle tree (zero-trust nodes with O(1)-storage), 2012. https://bitcointalk.org/index.php?topic=101734.msg1117428.</li>

      <li>[MVO91] Alfred Menezes, Scott Vanstone, and Tatsuaki Okamoto. Reducing Elliptic Curve Logarithms to Logarithms in a Finite Field. In ACM STOC, 1991.</li>

      <li>[Nak08] Satoshi Nakamoto. Bitcoin: A Peer-to-Peer Electronic Cash System. https://bitcoin.org/bitcoin.pdf, 2008.</li>

      <li>[PST13] Charalampos Papamanthou, Elaine Shi, and Roberto Tamassia. Signatures of Correct Computation. In TCC’13, 2013.</li>

      <li>[RMCI17] Leonid Reyzin, Dmitry Meshkov, Alexander Chepurnoy, and Sasha Ivanov. Improving Authenticated Dynamic Dictionaries, with Applications to Cryptocurrencies. In FC’17, 2017.</li>

      <li>[Sha81] Adi Shamir. On the generation of cryptographically strong pseudo-random sequences. In Shimon Even and Oded Kariv, editors, Automata, Languages and Programming, pages 544–550, Berlin, Heidelberg, 1981. Springer Berlin Heidelberg.</li>

    </ul>

    <p class="text-gray-300">STS99. Tomas Sander and Amnon Ta-Shma. Auditable, Anonymous Electronic Cash. In Michael Wiener, editor, Advances in Cryptology — CRYPTO’ 99, pages 555–572, Berlin, Heidelberg, 1999. Springer Berlin Heidelberg. STSY01. Tomas Sander, Amnon Ta-Shma, and Moti Yung. Blind, Auditable Membership Proofs. In Yair Frankel, editor, Financial Cryptography, pages 53–71, Berlin, Heidelberg, 2001. Springer Berlin Heidelberg. TCZ^{+}20. Alin Tomescu, Robert Chen, Yiming Zheng, Ittai Abraham, Benny Pinkas, Guy Golan Gueta, and Srinivas Devadas. Towards Scalable Threshold Cryptosystems. In IEEE S&P’20, May 2020. Tod16. Peter Todd. Making UTXO set growth irrelevant with low-latency delayed TXO commitments, 2016. https://petertodd.org/2016/delayed-txo-commitments. Tom20. Alin Tomescu. How to Keep a Secret and Share a Public Key (Using Polynomial Commitments). PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, USA, 2020. Vir17. Madars Virza. On Deploying Succinct Zero-Knowledge Proofs. PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, USA, 2017. vzGG13a. Joachim von zur Gathen and Jurgen Gerhard. Fast Multiplication. In Modern Computer Algebra, chapter 8, pages 221–254. Cambridge University Press, 3rd edition, 2013. vzGG13b. Joachim von zur Gathen and Jurgen Gerhard. Fast polynomial evaluation and interpolation. In Modern Computer Algebra, chapter 10, pages 295–310. Cambridge University Press, 3rd edition, 2013. vzGG13c. Joachim von zur Gathen and Jurgen Gerhard. Newton iteration. In Modern Computer Algebra, chapter 9, pages 257–292. Cambridge University Press, 3rd edition, 2013. Wik19. Wikipedia contributors. Partial fraction decomposition — Wikipedia, the free encyclopedia, 2019. [Online; accessed 11-April-2020]. Woo. Gavin Wood. Ethereum: A Secure Decentralised Generalised Transaction Ledger. http://gavwood.com/paper.pdf.</p>

    <p class="text-gray-300">Tomescu et al.</p>

    <p class="text-gray-300">Let  <span class="math">A(X) = X^n - 1</span>  and recall that  <span class="math">\\mathcal{L}_i(X) = \\frac{A(X)}{A&#x27;(\\omega^i) \\cdot (X - \\omega^i)}</span>  (see Section 3.4). Let  <span class="math">A&#x27;(X)</span>  be the derivative of  <span class="math">X^n - 1</span>  and let  <span class="math">g(x) = A(X) / (X - \\omega^i)</span> .</p>

    <p class="text-gray-300">First, note that  <span class="math">A&#x27;(\\omega^i) = g(\\omega^i)</span> . Second, by carrying out the division of  <span class="math">X^n - 1</span>  by  <span class="math">(X - \\omega^i)</span> , one can verify that:</p>

    <div class="my-4 text-center"><span class="math-block">g (x) = \\left(\\omega^ {i}\\right) ^ {0} X ^ {n - 1} + \\left(\\omega^ {i}\\right) ^ {1} X ^ {n - 2} + \\left(\\omega^ {i}\\right) ^ {2} X ^ {n - 3} + \\dots + \\left(\\omega^ {i}\\right) ^ {n - 2} X ^ {1} + \\left(\\omega^ {i}\\right) ^ {n - 1} X ^ {0} \\tag {13}</span></div>

    <p class="text-gray-300">Third, evaluating  <span class="math">A&#x27;(X)</span>  at  <span class="math">X = \\omega^i</span>  gives:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} A ^ {\\prime} \\left(\\omega^ {i}\\right) = g \\left(\\omega^ {i}\\right) = \\left(\\omega^ {i}\\right) ^ {0} \\omega^ {i (n - 1)} + \\left(\\omega^ {i}\\right) ^ {1} \\omega^ {i (n - 2)} + \\left(\\omega^ {i}\\right) ^ {2} \\omega^ {i (n - 3)} + \\dots + \\left(\\omega^ {i}\\right) ^ {n - 2} \\omega^ {i \\cdot 1} + \\left(\\omega^ {i}\\right) ^ {n - 1} \\omega^ {i \\cdot 0} \\tag {14} \\\\ = n \\omega^ {i (n - 1)} = n \\left(\\omega^ {i \\cdot n - i}\\right) = n \\omega^ {- i} \\tag {15} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">In Section 3.4.4, we argued all  <span class="math">u_{i}</span> 's can be computed in  <span class="math">O(n\\log n)</span>  time. Here, we prove correctness of the formula for the  <span class="math">q_{i}(X)</span> 's from Equation (11). As an example, let us look at the quotient  <span class="math">q_{1}(X)</span>  obtained when dividing  <span class="math">\\psi_{1}(X)</span>  by  <span class="math">X - \\omega^{1}</span> , assuming  <span class="math">n = 8</span> :</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X-ω)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X6 + 2ωX5 + 3ω2X4 + 4ω3X3 + 5ω4X2 + 6ω5X + 7ω6</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  X7 + ωX6 + ω2X5 + ω3X4 + ω4X3 + ω5X2 + ω6X + ω7  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  - X7 + ωX6  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  2ωX6 + ω2X5  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  - 2ωX6 + 2ω2X5  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  3ω2X5 + ω3X4  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  - 3ω2X5 + 3ω3X4  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  4ω3X4 + ω4X3  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  - 4ω3X4 + 4ω4X3  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|   |  5ω4X3 + ω5X2  |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|  - 5ω4X3 + 5ω5X2  |   |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|  6ω5X2 + ω6X  |   |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|  - 6ω5X2 + 6ω6X  |   |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|  7ω6X + ω7  |   |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">|  - 7ω6X + 7ω7  |   |   |   |   |   |   |   |   |   |</p>

    <p class="text-gray-300">In general, we want to show that:</p>

    <div class="my-4 text-center"><span class="math-block">q _ {i} (X) = \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) \\left(\\omega^ {i}\\right) ^ {j} X ^ {(n - 2) - j}, \\forall i \\in [ 0, n) \\tag {16}</span></div>

    <p class="text-gray-300">We do this by showing that the polynomial remainder theorem holds; i.e.,  <span class="math">\\psi_i(X) = q_i(X)(X - \\omega^i) + \\psi_i(\\omega_i)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} q _ {i} (X) \\left(X - \\omega^ {i}\\right) + \\psi_ {i} \\left(\\omega_ {i}\\right) = (17) \\\\ = q _ {i} (X) \\left(X - \\omega^ {i}\\right) + n \\omega^ {- i} (18) \\\\ = n \\omega^ {- i} + (X - \\omega^ {i}) \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) (\\omega^ {i}) ^ {j} X ^ {(n - 2) - j} (19) \\\\ = n \\omega^ {- i} + X \\cdot \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) \\left(\\omega^ {i}\\right) ^ {j} X ^ {(n - 2) - j} - \\omega^ {i} \\cdot \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) \\left(\\omega^ {i}\\right) ^ {j} X ^ {(n - 2) - j} (20) \\\\ = n \\omega^ {- i} + \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) \\left(\\omega^ {i}\\right) ^ {j} X ^ {(n - 1) - j} - \\sum_ {j \\in [ 0, n - 2 ]} (j + 1) \\left(\\omega^ {i}\\right) ^ {j + 1} X ^ {(n - 2) - j} (21) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Aggregatable Subvector Commitments for Stateless Cryptocurrencies</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp;= n \\omega^{-i} + \\sum_{j \\in [0, n-2]} (j+1) \\omega^{ij} X^{(n-1)-j} - \\sum_{j \\in [1, n-1]} j \\omega^{ij} X^{(n-2)-(j-1)} \\quad \\text{(22)} \\\\ &amp;amp;= n \\omega^{-i} + \\sum_{j \\in [0, n-2]} (j+1) \\omega^{ij} X^{(n-1)-j} - \\sum_{j \\in [1, n-1]} j \\omega^{ij} X^{(n-1)-j} \\quad \\text{(23)} \\\\ &amp;amp;= n \\omega^{-i} + \\left( X^{n-1} + \\sum_{j \\in [1, n-2]} (j+1) \\omega^{ij} X^{(n-1)-j} \\right) - \\left( (n-1) \\omega^{i(n-1)} X^0 + \\sum_{j \\in [1, n-2]} j \\omega^{ij} X^{(n-1)-j} \\right) \\quad \\text{(24)} \\\\ &amp;amp;= \\left( X^{n-1} + \\sum_{j \\in [1, n-2]} (j+1) \\omega^{ij} X^{(n-1)-j} - \\sum_{j \\in [1, n-2]} j \\omega^{ij} X^{(n-1)-j} \\right) - \\left( (n-1) \\omega^{i(n-1)} X^0 - n \\omega^{-i} \\right) \\quad \\text{(25)} \\\\ &amp;amp;= \\left( X^{n-1} + \\sum_{j \\in [1, n-2]} \\omega^{ij} X^{(n-1)-j} \\right) - \\left( (n-1) \\omega^{-i} X^0 - n \\omega^{-i} X^0 \\right) \\quad \\text{(26)} \\\\ &amp;amp;= \\sum_{j \\in [0, n-2]} \\omega^{ij} X^{(n-1)-j} + \\omega^{-i} X^0 \\quad \\text{(27)} \\\\ &amp;amp;= \\sum_{j \\in [0, n-2]} \\omega^{ij} X^{(n-1)-j} + \\omega^{in-i} X^0 \\quad \\text{(28)} \\\\ &amp;amp;= \\sum_{j \\in [0, n-2]} \\omega^{ij} X^{(n-1)-j} + \\omega^{i(n-1)} X^0 \\quad \\text{(29)} \\\\ &amp;amp;= \\sum_{j \\in [0, n)} \\omega^{ij} X^{(n-1)-j} \\quad \\text{(30)} \\\\ &amp;amp;= \\psi_i(X) \\quad \\text{(31)} \\end{aligned}</span></div>

    <h2 id="sec-45" class="text-2xl font-bold">C Security Proofs</h2>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">C.1 KZG Batch Opening Binding (Re)definition</h3>

    <p class="text-gray-300">We strengthen the batch opening binding definition of KZG [KZG10, Sec. 3.4, pg. 9] and prove KZG still satisfies it.</p>

    <p class="text-gray-300"><strong>Definition 8 (Batch Opening Binding).</strong> <span class="math">\\forall</span> adversaries <span class="math">\\mathcal{A}</span> running in time <span class="math">\\mathrm{poly}(\\lambda)</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\mathsf{pp} \\leftarrow \\mathsf{KZG}. \\text{Setup}(1^{\\lambda}, n), \\\\ c, I, J, v_I(X), v_J(X), \\pi_I, \\pi_J \\leftarrow \\mathcal{A}(\\mathsf{pp}, 1^{\\lambda}): \\\\ \\mathsf{KZG}. \\text{VerifyEvalBatch}(\\mathsf{pp}, c, I, \\pi_I, v_I(X)) = T \\wedge \\\\ \\mathsf{KZG}. \\text{VerifyEvalBatch}(\\mathsf{pp}, c, J, \\pi_J, v_J(X)) = T \\wedge \\\\ \\exists k \\in I \\cap J, \\text{ such that } v_I(k) \\neq v_J(k) \\end{array} \\right] \\leq \\mathsf{negl}(\\lambda) \\quad \\text{(32)}</span></div>

    <p class="text-gray-300">Suppose an adversary breaks the definition. Let <span class="math">A_I(X) = \\prod_{i \\in I} (X - i)</span>. Then, the following holds:</p>

    <div class="my-4 text-center"><span class="math-block">e(c, g) = e(\\pi_I, g^{A_I(\\tau)}) e(g^{v_I(\\tau)}, g) \\quad \\text{(33)}</span></div>

    <div class="my-4 text-center"><span class="math-block">e(c, g) = e(\\pi_J, g^{A_J(\\tau)}) e(g^{v_J(\\tau)}, g) \\quad \\text{(34)}</span></div>

    <p class="text-gray-300">Divide the top equation by the bottom one to get:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{1}_T = \\frac{e(g^{v_I(\\tau)}, g)}{e(g^{v_J(\\tau)}, g)} \\frac{e(\\pi_I, g^{A_I(\\tau)})}{e(\\pi_J, g^{A_J(\\tau)})} \\Leftrightarrow \\quad \\text{(35)}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{1}_T = e(g^{v_I(\\tau) - v_J(\\tau)}, g) \\frac{e(\\pi_I, g^{A_I(\\tau)})}{e(\\pi_J, g^{A_J(\\tau)})} \\Leftrightarrow \\quad \\text{(36)}</span></div>

    <div class="my-4 text-center"><span class="math-block">e(g^{v_J(\\tau) - v_I(\\tau)}, g) = \\frac{e(\\pi_I, g^{A_I(\\tau)})}{e(\\pi_J, g^{A_J(\\tau)})} \\quad \\text{(37)}</span></div>

    <p class="text-gray-300"><span class="math">v_{k}=v_{I}(k)</span> and <span class="math">v^{\\prime}_{k}=v_{J}(k)</span>. We can rewrite <span class="math">v_{I}(X)</span> using the polynomial remainder theorem as <span class="math">v_{I}(X)=q_{I}(X)(X-k)+v_{k}</span>. Similarly, <span class="math">v_{J}(X)=q_{J}(X)(X-k)+v^{\\prime}_{k}</span>.</p>

    <p class="text-gray-300"><span class="math">e(g^{q_{J}(\\tau)(\\tau-k)+v^{\\prime}_{k}-q_{I}(\\tau)(\\tau-k)-v_{k}},g)=\\frac{e(\\pi_{I},g^{A_{I}(\\tau)})}{e(\\pi_{J},g^{A_{J}(\\tau)})}\\Leftrightarrow</span> (38) <span class="math">e(g^{(\\tau-k)(q_{J}(\\tau)-q_{I}(\\tau))+v^{\\prime}_{k}-v_{k}},g)=\\frac{e(\\pi_{I},g^{A_{I}(\\tau)})}{e(\\pi_{J},g^{A_{J}(\\tau)})}\\Leftrightarrow</span> (39) <span class="math">e(g^{(\\tau-k)(q_{J}(\\tau)-q_{I}(\\tau))},g)e(g^{v^{\\prime}_{k}-v_{k}},g)=\\frac{e(\\pi_{I},g^{A_{I}(\\tau)})}{e(\\pi_{J},g^{A_{J}(\\tau)})}\\Leftrightarrow</span> (40) <span class="math">e(g^{q_{J}(\\tau)-q_{I}(\\tau)},g)^{\\tau-k}e(g,g)^{v^{\\prime}_{k}-v_{k}}=\\frac{e(\\pi_{I},g^{A_{I}(\\tau)})}{e(\\pi_{J},g^{A_{J}(\\tau)})}</span> (41)</p>

    <p class="text-gray-300">Factor out <span class="math">(X-k)</span> in <span class="math">A_{I}(X)</span> to get <span class="math">A_{I}(X)=a_{I}(X)(\\tau-k)</span>. Similarly, <span class="math">A_{J}(X)=a_{J}(X)(\\tau-k)</span>.</p>

    <p class="text-gray-300"><span class="math">e(g^{q_{J}(\\tau)-q_{I}(\\tau)},g)^{\\tau-k}e(g,g)^{v^{\\prime}_{k}-v_{k}}=\\left(\\frac{e(\\pi_{I},g^{a_{I}(\\tau)})}{e(\\pi_{J},g^{a_{J}(\\tau)})}\\right)^{\\tau-k}\\Leftrightarrow</span> (42) <span class="math">e(g^{q_{J}(\\tau)-q_{I}(\\tau)},g)e(g,g)^{\\frac{v^{\\prime}_{k}-v_{k}}{\\tau-k}}=\\frac{e(\\pi_{I},g^{a_{I}(\\tau)})}{e(\\pi_{J},g^{a_{J}(\\tau)})}\\Leftrightarrow</span> (43) <span class="math">e(g,g)^{\\frac{v^{\\prime}_{k}-v_{k}}{\\tau-k}}=\\frac{e(\\pi_{I},g^{a_{I}(\\tau)})}{e(\\pi_{J},g^{a_{J}(\\tau)})e(g^{q_{J}(\\tau)-q_{I}(\\tau)},g)}\\Leftrightarrow</span> (44) <span class="math">e(g,g)^{\\frac{1}{\\tau-k}}=\\left(\\frac{e(\\pi_{I},g^{a_{I}(\\tau)})}{e(\\pi_{J},g^{a_{J}(\\tau)})e(g^{q_{J}(\\tau)-q_{I}(\\tau)},g)}\\right)^{\\frac{1}{v^{\\prime}_{k}-v_{k}}}</span> (45)</p>

    <p class="text-gray-300">Since the commitments to <span class="math">a_{I}(X),a_{J}(X),q_{I}(X),q_{J}(X)</span> can be easily reconstructed from <span class="math">v_{I}(X),v_{J}(X),I</span> and <span class="math">J</span>, and since <span class="math">v^{\\prime}_{k}\\neq v_{k}</span>, this constitutes a direct break of <span class="math">n</span>-SBDH.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">C.2 Update Key Uniqueness</h3>

    <p class="text-gray-300">We prove that our aSVC scheme from Section 3 has <em>Update Key Uniqueness</em> as defined in Definition 6. Let <span class="math">a</span> be the commitment to <span class="math">A(X)=X^{n}-1</span> from the verification key vrk. Suppose an adversary outputs two update keys <span class="math">\\mathsf{upk}_{i}=(a_{i},u_{i})</span> and <span class="math">\\mathsf{upk}^{\\prime}_{i}=(a^{\\prime}_{i},u^{\\prime}_{i})</span> at position <span class="math">i</span> that both pass VC.VerifyUPK but <span class="math">\\mathsf{upk}_{i}\\neq\\mathsf{upk}^{\\prime}_{i}</span>. Then, it must be the case that either <span class="math">a_{i}\\neq a^{\\prime}_{i}</span> or that <span class="math">u_{i}\\neq u^{\\prime}_{i}</span>.</p>

    <p class="text-gray-300"><span class="math">a_{i}\\neq a^{\\prime}_{i}</span> Case: Since both update keys pass verification, the following pairing equations hold:</p>

    <p class="text-gray-300"><span class="math">e(a_{i},g^{\\tau}/g^{\\omega^{i}})=e(a,g)</span> (46) <span class="math">e(a^{\\prime}_{i},g^{\\tau}/g^{\\omega^{i}})=e(a,g)</span> (47)</p>

    <p class="text-gray-300">Thus, it follows that:</p>

    <p class="text-gray-300"><span class="math">e(a_{i},g^{\\tau}/g^{\\omega^{i}})=e(a^{\\prime}_{i},g^{\\tau}/g^{\\omega^{i}})\\Leftrightarrow</span> (48) <span class="math">e(a_{i},g)=e(a^{\\prime}_{i},g)\\Leftrightarrow</span> (49) <span class="math">a_{i}=a^{\\prime}_{i}</span> (50)</p>

    <p class="text-gray-300">Contradiction.</p>

    <p class="text-gray-300"><span class="math">\\bm{u_{i}\\neq u^{\\prime}_{i}}</span> Case: Let <span class="math">A^{\\prime}(X)</span> denote the derivative of <span class="math">A(X)=X^{n}-1</span>. Let <span class="math">\\ell_{i}=a_{i}^{1/A^{\\prime}(\\omega^{i})}=g^{\\mathcal{L}_{i}(\\tau)}</span>.</p>

    <p class="text-gray-300">Since both update keys pass verification, the following pairing equations hold:</p>

    <p class="text-gray-300"><span class="math">e(\\ell_{i}/g^{1},g)=e(u_{i},g^{\\tau}/g^{\\omega^{i}})</span> (51) <span class="math">e(\\ell_{i}/g^{1},g)=e(u^{\\prime}_{i},g^{\\tau}/g^{\\omega^{i}})</span> (52)</p>

    <p class="text-gray-300">Thus, it follows that:</p>

    <p class="text-gray-300"><span class="math">e(u_{i},g^{\\tau}/g^{\\omega^{i}})=e(u^{\\prime}_{i},g^{\\tau}/g^{\\omega^{i}})</span> (53) <span class="math">e(u_{i},g)=e(u^{\\prime}_{i},g)\\Leftrightarrow</span> (54) <span class="math">u_{i}=u^{\\prime}_{i}</span> (55)</p>

    <p class="text-gray-300">Contradiction.</p>

    <p class="text-gray-300">D Complexities of Pairing-based VCs in Table 2</p>

    <p class="text-gray-300">We survey each pairing-based VC scheme from Table 2 and explain its complexities. In Appendix E, we do the same for VCs based on hidden-order groups. Despite our best efforts to understand the complexities of each scheme, we recognize there could be better upper bounds for some of them.</p>

    <h3 id="sec-48" class="text-xl font-semibold mt-8">D.1 Complexities of CDH-based <em>[x14]</em></h3>

    <p class="text-gray-300">This scheme was originally proposed by Catalano and Fiore <em>[x5]</em> and extended by Lai and Malavolta to support subvector proofs <em>[x14]</em>.</p>

    <p class="text-gray-300">Public Parameters. The proving key is <span class="math">\\mathsf{prk}=(h_{i,j})_{i,j\\in[0,n)}</span> and is <span class="math">O(n^{2})</span> sized. Here, <span class="math">h_{i,j}=g^{z_{i}\\cdot z_{j}}</span> when <span class="math">i\\neq j</span> and <span class="math">h_{i,i}=h_{i}=g^{z_{i}}</span>, with each <span class="math">z_{i}\\in\\mathbb{Z}_{p}</span> picked uniformly at random. The verification key is <span class="math">\\mathsf{vrk}=(h_{i})_{i\\in[0,n)}</span> and is <span class="math">O(n)</span>-sized. The <span class="math">i</span>th update key is <span class="math">\\mathsf{upk}_{i}=(h_{i},(h_{i,j})_{j\\in[0,n)})</span>. Note that <span class="math">h_{i,j}=h_{j}^{z_{i}}=h_{i}^{z_{j}}</span>.</p>

    <p class="text-gray-300">Commitment. A commitment is <span class="math">c=\\prod_{i\\in[0,n)}h_{i}^{v_{i}}</span> and can be computed with <span class="math">O(n)</span> exponentiations. If any vector element <span class="math">v_{j}</span> changes to <span class="math">v_{j}+\\delta</span>, the commitment can be updated in <span class="math">O(1)</span> time using <span class="math">h_{j}</span> from <span class="math">\\mathsf{upk}_{j}</span> as <span class="math">c^{\\prime}=c\\cdot(h_{j})^{\\delta}</span>.</p>

    <p class="text-gray-300">Proofs for a <span class="math">v_{i}</span>. A proof for <span class="math">v_{i}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}=\\prod_{j\\in[0,n)\\setminus\\{i\\}}h_{i,j}^{v_{j}}=\\left(\\prod_{j\\in[0,n)\\setminus\\{i\\}}h_{j}^{v_{j}}\\right)^{z_{i}}</span> (56)</p>

    <p class="text-gray-300">The proof is <span class="math">O(1)</span>-sized and can be computed from the <span class="math">h_{i,j}</span>’s in the <span class="math">\\mathsf{prk}</span> with <span class="math">O(n)</span> exponentiations. It can be verified in <span class="math">O(1)</span> time using <span class="math">h_{i}</span> from the <span class="math">\\mathsf{vrk}</span> as:</p>

    <p class="text-gray-300"><span class="math">e(C/h_{i}^{v_{i}},h_{i})=e(\\pi_{i},g)</span> (57)</p>

    <p class="text-gray-300">If any vector element <span class="math">v_{j},j\\neq i</span> changes to <span class="math">v_{j}+\\delta</span>, the proof <span class="math">\\pi_{i}</span> can be updated in <span class="math">O(1)</span> time using <span class="math">h_{i,j}</span> from <span class="math">\\mathsf{upk}_{j}</span> as <span class="math">\\pi_{i}^{\\prime}=\\pi_{i}\\cdot\\big{(}h_{i,j}^{\\delta}\\big{)}</span>. This new <span class="math">\\pi_{i}^{\\prime}</span> will verify against the updated <span class="math">c^{\\prime}</span> commitment defined earlier. If <span class="math">v_{i}</span> changes to <span class="math">v_{i}+\\delta</span>, the proof <span class="math">\\pi_{i}</span> need not be updated.</p>

    <p class="text-gray-300">Subvector Proofs for <span class="math">(v_{i})_{i\\in I}</span> A <span class="math">O(1)</span>-sized subvector proof for <span class="math">\\mathbf{v}_{I}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{I}=\\prod_{i\\in I}\\prod_{j\\in[0,n)\\setminus I}h_{i,j}^{v_{j}}=\\prod_{i\\in I}\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}}\\right)^{z_{i}}=\\prod_{i\\in I}\\pi_{i}^{*}</span> (58)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As intuition, note that the inner product <span class="math">\\pi_{i}^{*}=\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}}\\right)^{z_{i}}</span> is very similar to a proof <span class="math">\\pi_{i}=\\left(\\prod_{j\\in[0,n)\\setminus\\{i\\}}h_{j}^{v_{j}}\\right)^{z_{i}}</span> for <span class="math">v_{i}</span>. Let $b=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The proof can be computed from the </span>h_{i,j}<span class="math">’s in the </span>\\mathsf{prk}<span class="math"> with </span>O(b(n-b))<span class="math"> exponentiations (because each </span>\\pi_{i}^{*}<span class="math"> can be computed in </span>O(n-b)<span class="math"> exponentiations). A subvector proof </span>\\pi_{I}<span class="math"> can be verified using </span>(h_{i})_{i\\in I}<span class="math"> from </span>\\mathsf{vrk}<span class="math"> by checking in </span>O(b)$ time if:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">e\\left(c/\\prod_{j\\in I}h_{j}^{v_{j}},\\prod_{i\\in I}h_{i}\\right)</span> <span class="math">=e(\\pi_{I},g)\\Leftrightarrow</span> (59) <span class="math">e\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}},\\prod_{i\\in I}g^{z_{i}}\\right)</span> <span class="math">=e\\left(\\prod_{i\\in I}\\prod_{j\\in[0,n)\\setminus I}h_{i,j}^{v_{j}},g\\right)</span> (60) <span class="math">e\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}},g^{\\sum_{i\\in I}z_{i}}\\right)</span> <span class="math">=e\\left(\\prod_{i\\in I}\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}}\\right)^{z_{i}},g\\right)</span> (61) <span class="math">e\\left(\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}}\\right)^{\\sum_{i\\in I}z_{i}},g\\right)</span> <span class="math">=e\\left(\\left(\\prod_{j\\in[0,n)\\setminus I}h_{j}^{v_{j}}\\right)^{\\sum_{i\\in I}z_{i}},g\\right)</span> (62)</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed in <em>[x5, x14]</em>, but it seems possible. Finally, precomputing all proofs efficiently is not discussed. Naively, it can be done inefficiently in <span class="math">O(n^{2})</span> time.</p>

    <p class="text-gray-300">###</p>

    <h3 id="sec-49" class="text-xl font-semibold mt-8">D.2 Complexities of KZG <em>[x13]</em></h3>

    <p class="text-gray-300">Kate, Zaverucha and Goldberg also discuss using their polynomial commitment scheme <em>[x13]</em> to commit to a sequence of messages, thus implicitly obtaining a VC scheme. Although they do not analyze its complexity in their paper, we do so here.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Parameters. The proving key is <span class="math">\\mathsf{prk}=(g^{\\tau^{i}})_{i\\in[0,n-1]}</span> and is <span class="math">O(n)</span> sized. The verification key is <span class="math">\\mathsf{vrk}=(g,(g^{\\tau^{i}})_{i\\in b})</span>, where $b=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the largest subvector whose proof the verifier should be able to check, and is thus </span>O(b)$-sized. There is no support for updating commitments and proofs using update keys, although our work shows this is possible (see Section 3.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Commitment. A commitment is <span class="math">c=g^{\\phi(\\tau)}</span> where <span class="math">\\phi(X)=\\sum_{i\\in[0,n)}\\mathcal{L}_{i}(X)v_{i}</span> and can be computed with <span class="math">O(n\\log^{2}n)</span> field operations (see Section 2.1) and <span class="math">O(n)</span> exponentiations. Commitment updates are not discussed, but the scheme could be modified to support them (see Section 3.3).</p>

    <p class="text-gray-300">Proofs for a <span class="math">\\bm{v_{i}}</span>. A proof for <span class="math">v_{i}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}=g^{\\frac{\\phi(\\tau)-v_{i}}{\\tau-i}}=g^{q_{i}(\\tau)}</span> (63)</p>

    <p class="text-gray-300">The proof is <span class="math">O(1)</span>-sized and can be computed by dividing <span class="math">\\phi(X)</span> by <span class="math">(X-i)</span> in <span class="math">O(n)</span> field operations, obtaining <span class="math">q_{i}(X)</span>, and committing to <span class="math">q_{i}(X)</span> using the <span class="math">g^{\\tau^{i}}</span>’s in the <span class="math">\\mathsf{prk}</span> with <span class="math">O(n)</span> exponentiations. The proof can be verified in <span class="math">O(1)</span> time using <span class="math">g^{\\tau}</span> from the <span class="math">\\mathsf{vrk}</span> by computing two pairings:</p>

    <p class="text-gray-300"><span class="math">e(c/g^{v_{i}},g)=e(\\pi_{i},g^{\\tau}/g^{i})</span> (64)</p>

    <p class="text-gray-300">Proof updates are not discussed, but the scheme could be modified to support them (see Section 3.3).</p>

    <p class="text-gray-300">Subvector Proofs for <span class="math">(\\bm{v_{i}})_{i\\in I}</span> A <span class="math">O(1)</span>-sized subvector proof for <span class="math">\\mathbf{v}_{I}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{I}=g^{\\frac{\\phi(\\tau)-R_{I}(\\tau)}{A_{I}(\\tau)}}=g^{q_{I}(\\tau)}</span> (65)</p>

    <p class="text-gray-300">Here, <span class="math">R_{I}(X)</span> of degree <span class="math">\\leq b-1</span> is interpolated in <span class="math">O(b\\log^{2}b)</span> field operations so that <span class="math">R_{I}(i)=v_{i},\\forall i\\in I</span> (see Section 2.1). Also, <span class="math">A_{I}(X)=\\prod_{i\\in I}(X-i)</span> is computed in <span class="math">O(b\\log^{2}b)</span> field operations via a <em>subproduct tree</em> <em>[x17]</em>. The proof leverages the fact that dividing <span class="math">\\phi(X)</span> by <span class="math">A_{I}(X)</span> gives quotient <span class="math">q_{I}(X)</span> and remainder <span class="math">R_{I}(X)</span>. The quotient <span class="math">q_{I}(X)</span> can be obtained in <span class="math">O(n\\log n)</span> field operations via a DFT-based division <em>[x17]</em>. Given <span class="math">g^{\\tau^{i}}</span>’s from the <span class="math">\\mathsf{prk}</span>, committing to <span class="math">q_{I}(X)</span> takes <span class="math">O(n-b)</span> exponentiations, since <span class="math">\\deg(q_{I})=\\deg(\\phi)-\\deg(A_{I})\\leq(n-1)-b</span>. Thus, the overall subvector proving time is <span class="math">O(n\\log n+b\\log^{2}b)</span>.</p>

    <p class="text-gray-300">To verify a subvector proof <span class="math">\\pi_{I}</span>, first, the verifier must recompute <span class="math">R_{I}(X)</span> and <span class="math">A_{I}(X)</span> in <span class="math">O(b\\log^{2}b)</span> field operations. Then, the verifier uses <span class="math">(g^{\\tau^{i}})_{i\\in b}</span> from the <span class="math">\\mathsf{vrk}</span> to compute KZG commitments <span class="math">g^{R_{I}(\\tau)}</span> and <span class="math">g^{A_{I}(\\tau)}</span> in <span class="math">O(b)</span> exponentiations. Finally, the verifier checks using two pairings if:</p>

    <p class="text-gray-300"><span class="math">e(c/g^{R_{I}(\\tau)},g)=e(\\pi_{I},g^{A_{I}(\\tau)})</span> (66)</p>

    <p class="text-gray-300">Thus, the overall subvector proof verification time is <span class="math">O(b\\log^{2}b)</span> time.</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed, but the scheme can be modified to support them (see Section 3.4.1). Finally, precomputing all proofs efficiently is not discussed, but is possible (see Section 3.3). Naively, it can be done inefficiently in <span class="math">O(n^{2})</span> time.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">D.3 Complexity of CDHK <em>[x7]</em></h3>

    <p class="text-gray-300">In this scheme, we assume the vector <span class="math">\\mathbf{v}=[v_{1},v_{2},\\ldots,v_{n}]</span> is indexed from <span class="math">1</span> to <span class="math">n</span>. This scheme is similar to a KZG-based VC, except (1) it is randomized, (2) it computes proofs in a slightly different way and (3) it <em>willfully</em> prevents aggregation of proofs as a security feature.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Parameters. The proving key is <span class="math">\\mathsf{prk}=\\Big{(}(g^{\\tau^{i}})_{i\\in[0,n+1]},(g^{\\mathcal{L}_{i}(\\tau)})_{i\\in[0,n]},g^{P(\\tau)}\\Big{)}</span>, where <span class="math">P(X)=X\\cdot\\prod_{i\\in[n]}(X-i)</span> and is <span class="math">O(n)</span> sized. (Note that the Lagrange polynomials <span class="math">\\mathcal{L}_{i}(X)=\\prod_{j\\in[0,n],j\\neq i}\\frac{X-j}{i-j}</span> are defined over the points <span class="math">[0,n]</span>, not <span class="math">[n]</span>.) The verification key is <span class="math">\\mathsf{vrk}=(g,(g^{\\mathcal{L}_{i}(\\tau)})_{i\\in[n]},(g^{\\tau^{i}})_{i\\in[0,b+1]})</span>, where $b=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the largest subvector whose proof the verifier should be able to check. Unfortunately, the verification key is </span>O(n)$-sized. There is no support for</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">updating commitments and proofs using update keys, although adding it is possible via our techniques (see Section 3.3). As a result, we treat this scheme as if it used an <span class="math">O(n)</span>-sized update key <span class="math">\\mathsf{upk}_{i}=\\left(g^{\\mathcal{L}_{i}(\\tau)},\\left(g^{\\frac{\\mathcal{L}_{j}(\\tau)}{\\tau-i}}\\right)_{j\\in[n]}\\right)</span></p>

    <p class="text-gray-300">Commitment. A commitment is <span class="math">c=\\prod_{i\\in[n]}\\left(g^{\\mathcal{L}_{i}(\\tau)}\\right)^{v_{i}}\\left(g^{P(\\tau)}\\right)^{r}=g^{\\phi(\\tau)+r\\cdot P(\\tau)}</span> where <span class="math">\\phi(X)=\\sum_{i\\in[0,n]}\\mathcal{L}_{i}(X)v_{i}</span>, with <span class="math">v_{0}=0</span>. To compute the commitment, <span class="math">\\phi(X)</span> must first be interpolated using <span class="math">O(n\\log^{2}n)</span> field operations. Then, <span class="math">c</span> can be computed with <span class="math">O(n)</span> exponentiations, given the Lagrange commitments and <span class="math">g^{P(\\tau)}</span> from <span class="math">\\mathsf{prk}</span>. Commitment updates are not discussed, but they can be trivially implemented by setting <span class="math">\\mathsf{upk}_{i}=g^{\\mathcal{L}_{i}(\\tau)}</span> and having <span class="math">c^{\\prime}=c\\cdot\\left(g^{\\mathcal{L}_{j}(\\tau)}\\right)^{\\delta}</span> be the new commitment after a change <span class="math">\\delta</span> to <span class="math">v_{j}</span>. We reflect this in Table 2.</p>

    <p class="text-gray-300">Proofs for a <span class="math">v_{i}</span>. A proof for <span class="math">v_{i}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}=g^{\\frac{(\\phi(\\tau)+r\\cdot P(\\tau))-v_{i}\\mathcal{L}_{i}(\\tau)}{\\tau-i}}=g^{q_{i}(\\tau)}</span> (67)</p>

    <p class="text-gray-300">The proof is <span class="math">O(1)</span>-sized and can be computed by dividing <span class="math">\\phi(X)+r\\cdot P(X)-v_{i}\\mathcal{L}_{i}(X)</span> by <span class="math">(X-i)</span> in <span class="math">O(n)</span> field operations, obtaining <span class="math">q_{i}(X)</span>, and committing to <span class="math">q_{i}(X)</span> using the <span class="math">g^{\\tau^{\\prime}}</span>’s in the <span class="math">\\mathsf{prk}</span> with <span class="math">O(n)</span> exponentiations. The proof can be verified in <span class="math">O(1)</span> time using <span class="math">g^{\\mathcal{L}_{i}(\\tau)}</span> from the <span class="math">\\mathsf{vrk}</span> by computing two pairings:</p>

    <p class="text-gray-300"><span class="math">e\\left(c/\\left(g^{\\mathcal{L}_{i}(\\tau)}\\right)^{v_{i}},g\\right)=e(\\pi_{i},g^{\\tau}/g^{i})</span> (68)</p>

    <p class="text-gray-300">Proof updates are not discussed, but the scheme could be modified to support them (see Section 3.3).</p>

    <p class="text-gray-300">Subvector Proofs for <span class="math">(v_{i})_{i\\in I}</span> A <span class="math">O(1)</span>-sized subvector proof for <span class="math">\\mathbf{v}_{I}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{I}=g^{\\frac{\\phi(\\tau)+r\\cdot P(\\tau)-R_{I}(\\tau)}{A_{I}(\\tau)}}=g^{q_{I}(\\tau)}</span> (69)</p>

    <p class="text-gray-300">Here, <span class="math">R_{I}(X)</span> is defined so that <span class="math">R_{I}(i)=v_{i},\\forall i\\in I</span> and <span class="math">R_{I}(i)=0,\\forall i\\in[0,n]\\setminus I</span>. (In particular, this means <span class="math">R_{I}(0)=0</span>.) Interpolating <span class="math">R_{I}(X)</span> takes <span class="math">O(n\\log^{2}n)</span> field operations. Also, <span class="math">A_{I}(X)=X\\prod_{i\\in I}(X-i)</span> is computed in <span class="math">O(b\\log^{2}b)</span> field operations via a <em>subproduct tree</em> [vzGG13b]. Given <span class="math">g^{\\tau^{\\prime}}</span>’s from the <span class="math">\\mathsf{prk}</span>, committing to <span class="math">q_{I}(X)</span> takes <span class="math">O(n-b)</span> exponentiations (because <span class="math">\\deg(q_{I})=\\deg(\\phi)-\\deg(A_{I})\\leq n-(b+1)</span>). Thus, the overall subvector proving time is <span class="math">O(n\\log^{2}n)</span>.</p>

    <p class="text-gray-300">To verify a subvector proof <span class="math">\\pi_{I}</span>, first, the verifier recomputes the commitment to <span class="math">g^{R_{I}(\\tau)}=\\sum_{i\\in I}\\left(g^{\\mathcal{L}_{i}(\\tau)}\\right)^{v_{i}}</span> using <span class="math">O(b)</span> exponentiations. (Recall that <span class="math">\\mathcal{L}_{i}(X)</span> is defined over <span class="math">[0,n]</span> and has its KZG commitment in the <span class="math">\\mathsf{vrk}</span>.) Then, he computes <span class="math">A_{I}(X)</span> in <span class="math">O(b\\log^{2}b)</span> field operations using a <em>subproduct tree</em> [vzGG13b]. Then, the verifier uses <span class="math">(g^{\\tau^{\\prime}})_{i\\in[0,b+1]}</span> from the <span class="math">\\mathsf{vrk}</span> to compute a KZG commitment to <span class="math">g^{A_{I}(\\tau)}</span> in <span class="math">O(b)</span> exponentiations. Finally, the verifier checks if:</p>

    <p class="text-gray-300"><span class="math">e(c/g^{R_{I}(\\tau)},g)=e(\\pi_{I},g^{A_{I}(\\tau)})</span> (70)</p>

    <p class="text-gray-300">Thus, the overall subvector proof verification time is <span class="math">O(b\\log^{2}b)</span>.</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is <em>willfully</em> prevented by this scheme, as a security feature. Finally, precomputing all proofs efficiently is not discussed, but it can be done inefficiently in <span class="math">O(n^{2})</span> time. Importantly, because the proofs are slightly different from KZG, they are not amenable to known techniques for precomputing all <span class="math">n</span> proofs in <span class="math">O(n\\log n)</span> time <em>[x11]</em>.</p>

    <h3 id="sec-51" class="text-xl font-semibold mt-8">D.4 Complexities of CPZ <em>[x10]</em></h3>

    <p class="text-gray-300">Since the Edrax paper clearly summarizes its performance, we refer the reader to <em>[x10, Table 1]</em>, with one exception discussed below.</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed and it is unclear if the scheme can be modified to support it. Precomputing all proofs efficiently is not discussed either to the best of our knowledge, but could be possible.</p>

    <h3 id="sec-52" class="text-xl font-semibold mt-8">D.5 Complexities of TCZ <em>[TCZ^{+}20, x26]</em></h3>

    <p class="text-gray-300">In their paper on scaling threshold cryptosystems, Tomescu et al. <em>[TCZ^{+}20]</em> present a technique for computing <span class="math">n</span> <em>logarithmic-sized</em> evaluation proofs for a KZG committed polynomial of degree <span class="math">t</span> in <span class="math">O(n\\log t)</span> time. Later on, Tomescu extends these results to obtain a full VC scheme <em>[x26, Sec 9.2]</em>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Parameters. The proving key is <span class="math">\\mathsf{prk}=((g^{\\tau^{i}})_{i\\in[0,n-1]},(g^{\\mathcal{L}_{i}(\\tau)})_{i\\in[0,n)})</span> and is <span class="math">O(n)</span> sized. Importantly, <span class="math">n</span> is assumed to be a power of two, and <span class="math">\\mathcal{L}_{i}(X)=\\prod_{j\\in[0,n),j\\neq i}\\frac{X-\\omega^{j}}{\\omega^{i}-\\omega^{j}}</span> where <span class="math">\\omega</span> is a primitive <span class="math">n</span>th root of unity <em>[x17]</em>. The verification key is <span class="math">\\mathsf{vrk}=(g,(g^{\\tau^{2^{i}}})_{i\\in[\\lfloor\\log_{2}(n-1)\\rfloor]},(g^{\\tau^{i}})_{i\\in[b]})</span>, where $b=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the size of the largest subvector whose proof the verifier should be able to check, and is thus </span>O(b)<span class="math">-sized. The </span>i<span class="math">th update key </span>\\mathsf{upk}_{i}<span class="math"> is the <em>authenticated multipoint evaluation tree (AMT)</em> of </span>\\mathcal{L}_{i}(X)<span class="math"> at all points </span>(\\omega^{i})_{i\\in[0,n)}<span class="math"> (see <em>[TCZ^{+}20, Sec III-B]</em> and <em>[x23, Ch 9]</em>). This AMT will be </span>O(\\log n)<span class="math">-sized, consisting of a single path of non-zero quotient commitments leading to the evaluation of </span>\\mathcal{L}_{i}(\\omega^{i})<span class="math"> <em>[x23, Sec 9.2.2]</em>, since all other evaluations </span>\\mathcal{L}_{i}(\\omega^{j}),j\\neq i$ are zero.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Commitment. A commitment is <span class="math">c=g^{\\phi(\\tau)}</span> where <span class="math">\\phi(\\omega^{i})=v_{i},\\forall i\\in[0,n)</span>. Note that <span class="math">\\phi(X)</span> can be computed with <span class="math">O(n\\log n)</span> field operations via an inverse Discrete Fourier Transform (DFT) <em>[x1, Ch 30.2]</em>. Then, computing <span class="math">c</span> requires <span class="math">O(n)</span> exponentiations. Commitment updates remain the same as in the KZG-based scheme from Appendix D.3: <span class="math">c^{\\prime}=c\\cdot\\big{(}g^{\\mathcal{L}_{j}(\\tau)}\\big{)}^{\\delta}</span>, where <span class="math">\\delta</span> is the change at position <span class="math">j</span> in the vector and the Lagrange polynomial commitment can be obtained from <span class="math">\\mathsf{upk}_{j}</span>.</p>

    <p class="text-gray-300">Proofs for a <span class="math">\\bm{v_{i}}</span>. A proof for <span class="math">v_{i}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}=(g^{q_{w}(\\tau)})_{w\\in[1+\\lfloor\\log{(n-1)}\\rfloor]}</span> (71)</p>

    <p class="text-gray-300">Here, each <span class="math">q_{w}(X)</span> is a quotient polynomial along the AMT tree path to <span class="math">\\phi(\\omega^{i})</span>. The proof is <span class="math">O(\\log n)</span>-sized and can be computed by “repeatedly” dividing <span class="math">\\phi(X)</span> by accumulator polynomials of ever-decreasing sizes <span class="math">n/2,\\ldots,4,2,1</span> in <span class="math">T(n)=O(n\\log n)+T(n/2)=O(n\\log n)</span> field operations, and committing to each <span class="math">q_{w}(X)</span> using the <span class="math">g^{\\tau^{i}}</span>’s in the <span class="math">\\mathsf{prk}</span> with <span class="math">T^{\\prime}(n)=O(n)+T^{\\prime}(n/2)=O(n)</span> exponentiations. (“Repeatedly” dividing means we first divide <span class="math">\\phi(X)</span> by a degree <span class="math">n/2</span> accumulator. Then, we take the remainder of this division and divide it by the degree <span class="math">n/4</span> accumulator. We then take this remainder and divide it by a degree <span class="math">n/8</span> accumulator. And so on. This ensures the remainder degrees always halve.) The proof can be verified in <span class="math">O(\\log n)</span> time using the <span class="math">g^{\\tau^{2^{i}}}</span>’s from the <span class="math">\\mathsf{vrk}</span>:</p>

    <p class="text-gray-300"><span class="math">e(c/g^{v_{i}},g)=\\prod_{w\\in[1+\\lfloor\\log{(n-1)}\\rfloor]}e(g^{q_{w}(\\tau)},g^{a_{w}(\\tau)})</span> (72)</p>

    <p class="text-gray-300">Here, the <span class="math">a_{w}(X)</span>’s denote the accumulator polynomials along the AMT path to <span class="math">\\phi(\\omega^{i})</span>, which are always of the form <span class="math">X^{2^{i}}-c</span> for some constant <span class="math">c</span> and some <span class="math">i\\in[0,\\lfloor\\log{(n-1)}\\rfloor]</span>.</p>

    <p class="text-gray-300">Proof Updates. If any vector element <span class="math">v_{j}</span> changes to <span class="math">v_{j}+\\delta</span>, the proof <span class="math">\\pi_{i}</span> can be updated in <span class="math">O(\\log n)</span> time. (It could be that <span class="math">j=i</span>.) The idea is to consider the quotient commitments <span class="math">g^{q_{w}(\\tau)}</span> along <span class="math">\\pi_{i}</span>’s AMT path and the <span class="math">g^{a_{w}(\\tau)}</span> commitments along <span class="math">\\mathsf{upk}_{j}</span>’s AMT path. For all locations <span class="math">w</span> where the two paths intersect, the quotient commitments are combined in constant time as <span class="math">g^{q^{\\prime}_{w}(\\tau)}=g^{q_{w}(\\tau)}\\cdot\\big{(}g^{a_{w}(\\tau)}\\big{)}^{\\delta}</span>. Since there are at most <span class="math">O(\\log n)</span> locations <span class="math">w</span> to intersect in, this takes <span class="math">O(\\log n)</span> exponentiations. This new <span class="math">\\pi^{\\prime}_{i}</span> with quotient commitments <span class="math">g^{q^{\\prime}_{w}(\\tau)}</span> will verify against the updated <span class="math">c^{\\prime}</span> commitment defined earlier.</p>

    <p class="text-gray-300">Subvector Proofs for <span class="math">(\\bm{v_{i}})_{i\\in I}</span> This scheme uses the same subvector proof as the original KZG-based scheme in Appendix D.2. Thus, the subvector proving time is <span class="math">O(n\\log n+b\\log^{2}b)</span> and the verification time is <span class="math">O(b\\log^{2}b)</span> time.</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating proofs is not discussed and it is unclear if the scheme can be modified to support it. Precomputing all <em>logarithmic-sized</em> proofs efficiently is possible via the AMT technique in <span class="math">O(n\\log n)</span> time.</p>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">D.6 Complexity of Pointproofs <em>[x11, x14]</em></h3>

    <p class="text-gray-300">Gorbunov et al. <em>[x11]</em> enhance the VC by Libert and Yung <em>[x14]</em> with the ability to aggregate multiple VC proofs into a subvector proof. Additionally, they also enable aggregation of subvector proofs across different vector commitments, which they show is useful for stateless smart contract validation in cryptocurrencies. In this scheme, we assume the vector <span class="math">\\mathbf{v}=[v_{1},v_{2},\\ldots,v_{n}]</span> is indexed from <span class="math">1</span> to <span class="math">n</span>.</p>

    <p class="text-gray-300">Public Parameters. Their scheme works over Type III pairings <span class="math">e:\\mathbb{G}_{1}\\times\\mathbb{G}_{2}\\to\\mathbb{G}_{T}</span>. Let <span class="math">g_{1},g_{2},g_{T}</span> be generators of <span class="math">\\mathbb{G}_{1},\\mathbb{G}_{2}</span> and <span class="math">\\mathbb{G}_{T}</span> respectively. The proving key <span class="math">\\mathsf{prk}=(g_{1},(g_{1}^{\\alpha^{i}})_{i\\in[1,2n]\\setminus\\{n+1\\}},g_{2},(g_{2}^{\\alpha^{i}})_{i\\in[1,n]},g_{T}^{\\alpha^{n+1}})</span>. Note that <span class="math">g_{1}^{\\alpha^{n+1}}</span> is “missing” from the proving key, which is essential for security. The verification key <span class="math">\\mathsf{vrk}=((g_{2}^{\\alpha^{i}})_{i\\in[1,n]},g_{T}^{\\alpha^{n+1}})</span> is <span class="math">O(n)</span> -sized. The <span class="math">i</span>th update key is <span class="math">\\mathsf{upk}_{i}=g_{1}^{\\alpha^{i}}</span>. They only support updating commitments, but proofs could be made updatable at the cost of linear-sized update keys.</p>

    <p class="text-gray-300">Aggregatable Subvector Commitments for Stateless Cryptocurrencies</p>

    <p class="text-gray-300"><strong>Commitment.</strong> A commitment is <span class="math">c = \\prod_{i\\in [n]}\\left(g_1^{\\alpha^i}\\right)^{v_i} = g_1^{\\sum_{i\\in [n]}v_i\\alpha^i}</span> and can be computed with <span class="math">O(n)</span> exponentiations. If any vector element <span class="math">v_{j}</span> changes to <span class="math">v_{j} + \\delta</span>, the commitment can be updated in <span class="math">O(1)</span> time as <span class="math">c^{\\prime} = c\\cdot (\\mathsf{upk}_{j})^{\\delta} = c\\cdot (g_{1}^{\\alpha^{j}})^{\\delta}</span>.</p>

    <p class="text-gray-300"><strong>Proofs for a <span class="math">v_i</span>.</strong> A proof for <span class="math">v_i</span> is obtained by re-committing to <span class="math">v</span> so that <span class="math">v_i</span> "lands" at position <span class="math">n + 1</span> (i.e., has coefficient <span class="math">\\alpha^{n + 1}</span>) rather than position <span class="math">i</span> (i.e., has coefficient <span class="math">\\alpha^i</span>). Furthermore, this commitment will not contain <span class="math">v_i</span>: it cannot, since that would require having <span class="math">g_1^{\\alpha^{n + 1}}</span>. To get position <span class="math">i</span> to <span class="math">n + 1</span>, we must "shift" it (and every other position) by <span class="math">(n + 1) - i</span>. Thus, the proof is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\pi_i &amp;amp;= g_1^{\\sum_{j \\in [n] \\setminus \\{i\\}} v_j \\alpha^{j + (n + 1) - i}} \\quad (73) \\\\ &amp;amp;= g_1^{\\sum_{j \\in [n] \\setminus \\{i\\}} v_j \\alpha^j \\alpha^{(n + 1) - i}} \\quad (74) \\\\ &amp;amp;= \\left(g_1^{\\sum_{j \\in [n] \\setminus \\{i\\}} v_j \\alpha^j}\\right)^{\\alpha^{(n + 1) - i}} \\quad (75) \\\\ &amp;amp;= \\left(\\frac{g_1^{\\sum_{j \\in [n]} v_j \\alpha^j}}{g_1^{v_i \\alpha^i}}\\right)^{\\alpha^{(n + 1) - i}} \\quad (76) \\\\ &amp;amp;= \\left(c / g_1^{v_i \\alpha^i}\\right)^{\\alpha^{(n + 1) - i}} \\quad (77) \\end{aligned}</span></div>

    <p class="text-gray-300">The proof is constant-sized and can be computed with <span class="math">O(n)</span> exponentiations. It can be verified in <span class="math">O(1)</span> time using <span class="math">g_2^{\\alpha^{(n + 1) - i}}</span> from <span class="math">\\mathsf{vrk}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(c, g_2^{\\alpha^{(n + 1) - i}}\\right) = e \\left(\\pi_i, g_2\\right) \\left(g_T^{\\alpha^{n + 1}}\\right)^{v_i} \\tag{78}</span></div>

    <p class="text-gray-300">Updating the proof is not discussed but can be done in <span class="math">O(1)</span> time, if the update keys are tweaked to be linear rather than constant-sized.</p>

    <p class="text-gray-300"><strong>Subvector Proofs for <span class="math">(v_i)_{i\\in I}</span></strong> An <span class="math">O(1)</span>-sized subvector proof for <span class="math">\\mathbf{v}_I</span> is just a random linear combination of all proofs <span class="math">\\pi_i, \\forall i\\in I</span>. First, all <span class="math">b</span> proofs <span class="math">\\pi_i</span> are computed in <span class="math">O(bn)</span> exponentiations as described above. Second, for each <span class="math">i\\in I</span>, <span class="math">t_i = H(c,I,(v_i)_{i\\in I})</span> is computed using a random oracle <span class="math">H:\\{0,1\\}^* \\to \\mathbb{Z}_p</span>. Third, the subvector proof <span class="math">\\pi_I</span> is computed as:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_I = \\prod_{i \\in I} \\pi_i^{t_i} \\tag{79}</span></div>

    <p class="text-gray-300">If computed this way, a subvector proof would take <span class="math">O(bn)</span> exponentiations. However, Gorbunov et al. observe that <span class="math">\\pi_I</span> can be computed with an <span class="math">O(n)</span>-sized multi-exponentiation on a subset of the <span class="math">2n</span> generators <span class="math">(g_1^{\\alpha^i})_{i\\in [0,2n]\\setminus \\{n + 1\\}}</span>. The exponents will be a combination of the messages and the <span class="math">t_i</span>'s (see [GRWZ20, Sec 4.1] for more details). However, they do not bound the time to compute these exponents, which appears to be <span class="math">O(bn)</span> field operations in the worst-case.</p>

    <p class="text-gray-300">The subvector proof can be verified in <span class="math">O(b)</span> time using <span class="math">(g_2^{\\alpha^{(n + 1) - i}})_{i\\in I}</span> from <span class="math">\\mathsf{vrk}</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e \\left(c, \\prod_{i \\in I} \\left(g_2^{\\alpha^{(n + 1) - i}}\\right)^{t_i}\\right) &amp;amp;= e \\left(\\pi_I, g_2\\right) \\left(g_T^{\\alpha^{n + 1}}\\right)^{\\sum_{i \\in I} v_i t_i} \\Leftrightarrow \\quad (80) \\\\ e \\left(c, g_2^{\\sum_{i \\in I} t_i \\alpha^{(n + 1) - i}}\\right) &amp;amp;= e \\left(\\prod_{i \\in I} \\pi_i^{t_i}, g_2\\right) g_T^{\\alpha^{n + 1} \\sum_{i \\in I} v_i t_i} \\Leftrightarrow \\quad (81) \\\\ &amp;amp;= e \\left(\\prod_{i \\in I} \\pi_i^{t_i}, g_2\\right) e \\left(g_1^{\\alpha^{n + 1} \\sum_{i \\in I} v_i t_i}, g_2\\right) \\Leftrightarrow \\quad (82) \\\\ &amp;amp;= e \\left(\\prod_{i \\in I} \\pi_i^{t_i} \\cdot g_1^{\\alpha^{n + 1} \\sum_{i \\in I} v_i t_i}, g_2\\right) \\Leftrightarrow \\quad (83) \\\\ &amp;amp;= e \\left(\\prod_{i \\in I} \\pi_i^{t_i} \\cdot \\prod_{i \\in I} g_1^{\\alpha^{n + 1} v_i t_i}, g_2\\right) \\Leftrightarrow \\quad (84) \\\\ &amp;amp;= e \\left(\\prod_{i \\in I} \\left(\\pi_i \\cdot g_1^{\\alpha^{n + 1} v_i}\\right)^{t_i}, g_2\\right) \\quad (85) \\end{aligned}</span></div>

    <p class="text-gray-300">Tomescu et al.</p>

    <p class="text-gray-300">Recall that <span class="math">\\pi_i = (c / g_1^{v_i\\alpha^i})^{\\alpha^{(n + 1) - i}}</span>.</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} e \\left(c, g _ {2} ^ {\\sum_ {i \\in I} t _ {i} \\alpha^ {(n + 1) - i}}\\right) &amp;amp;= e \\left(\\prod_ {i \\in I} \\left((c / g _ {1} ^ {v _ {i} \\alpha^ {i}}) ^ {\\alpha^ {(n + 1) - i}} \\cdot g _ {1} ^ {\\alpha^ {n + 1} v _ {i}}\\right) ^ {t _ {i}}, g _ {2}\\right) \\Leftrightarrow \\\\ &amp;amp;= e \\left(\\prod_ {i \\in I} \\left((c / g _ {1} ^ {v _ {i} \\alpha^ {i}}) \\cdot g _ {1} ^ {\\frac {\\alpha^ {n + 1} v _ {i}}{\\alpha^ {(n + 1) - i}}}\\right) ^ {t _ {i} \\alpha^ {(n + 1) - i}}, g _ {2}\\right) \\Leftrightarrow \\\\ &amp;amp;= e \\left(\\prod_ {i \\in I} \\left((c / g _ {1} ^ {v _ {i} \\alpha^ {i}}) \\cdot g _ {1} ^ {v _ {i} \\alpha^ {i}}\\right) ^ {t _ {i} \\alpha^ {(n + 1) - i}}, g _ {2}\\right) \\Leftrightarrow \\\\ &amp;amp;= e \\left(\\prod_ {i \\in I} c ^ {t _ {i} \\alpha^ {(n + 1) - i}}, g _ {2}\\right) \\Leftrightarrow \\\\ &amp;amp;= e \\left(c ^ {\\sum_ {i \\in I} t _ {i} \\alpha^ {(n + 1) - i}}, g _ {2}\\right) \\Leftrightarrow \\tag {89} \\\\ &amp;amp;= e \\left(c, g _ {2} ^ {\\sum_ {i \\in I} t _ {i} \\alpha^ {(n + 1) - i}}\\right) \\tag {91} \\end{aligned}</span></div>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. A subvector proof requires <span class="math">b</span> hash computations and an <span class="math">O(b)</span>-sized multi-exponentiation and thus takes <span class="math">O(b)</span> time. Precomputing all proofs efficiently is not discussed. Naively, it can be done in <span class="math">O(n^2)</span> time.</p>

    <h2 id="sec-54" class="text-2xl font-bold">D.7 Complexity of our Lagrange-based aSVC from Section 3.3</h2>

    <p class="text-gray-300">Our scheme builds upon previous VCs using KZG commitments [CDHK15,KZG10]. Since we give its full algorithmic description in Section 3.4.3, this section will be briefer than previous ones.</p>

    <p class="text-gray-300">Public Parameters. The proving key, verification key and <span class="math">i</span>th update key are <span class="math">O(n)</span>, <span class="math">O(b)</span> and <span class="math">O(1)</span>-sized, respectively. Similar to Appendix D.5, <span class="math">n</span> is assumed to be a power of two, and <span class="math">\\mathcal{L}_i(X) = \\prod_{j\\in [0,n),j\\neq i}\\frac{X - \\omega^j}{\\omega^i - \\omega^j}</span> where <span class="math">\\omega</span> is a primitive <span class="math">n</span>th root of unity [vzGG13a].</p>

    <p class="text-gray-300"><strong>Commitment.</strong> A commitment is <span class="math">c = \\prod_{i\\in [0,n)}\\ell_i^{v_i} = g^{\\phi (\\tau)}</span> where <span class="math">\\phi (X) = \\sum_{i\\in [0,n)}\\mathcal{L}_i(X)v_i</span> and <span class="math">\\phi (\\omega^i) = v_i</span>. If any vector element <span class="math">v_{j}</span> changes to <span class="math">v_{j} + \\delta</span>, the commitment can be updated in <span class="math">O(1)</span> time using as <span class="math">c^{\\prime} = c\\cdot (\\mathsf{upk}_{j})^{\\delta} = c\\cdot (\\ell_{j})^{\\delta}</span>.</p>

    <p class="text-gray-300"><strong>Proofs for a <span class="math">v_i</span></strong>. A proof for <span class="math">v_i</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {i} = g ^ {\\frac {\\phi (\\tau) - v _ {i}}{\\tau - \\omega^ {i}}} = g ^ {g _ {i} (\\tau)} \\tag {92}</span></div>

    <p class="text-gray-300">However, note that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} \\frac {\\phi (\\tau) - \\phi \\left(\\omega^ {i}\\right)}{\\tau - \\omega^ {i}} &amp;amp;= \\frac {\\sum_ {j \\in [ 0 , n)} \\mathcal {L} _ {j} (\\tau) v _ {j} - v _ {i}}{\\tau - \\omega^ {i}} \\tag {93} \\\\ &amp;amp;= \\frac {\\sum_ {j \\in [ 0 , n) \\backslash \\{i \\}} \\mathcal {L} _ {j} (\\tau) v _ {j}}{\\tau - \\omega^ {i}} + \\frac {\\mathcal {L} _ {i} (\\tau) v _ {i} - v _ {i}}{\\tau - \\omega^ {i}} \\tag {94} \\\\ &amp;amp;= \\sum_ {j \\in [ 0, n) \\backslash \\{i \\}} v _ {j} \\frac {\\mathcal {L} _ {j} (\\tau)}{\\tau - \\omega^ {i}} + v _ {i} \\frac {\\mathcal {L} _ {i} (\\tau) - 1}{\\tau - \\omega^ {i}} \\tag {95} \\end{aligned}</span></div>

    <p class="text-gray-300">Recall from Section 3.4.2 that (1) the <span class="math">i</span>th update key contains a KZG commitment <span class="math">u_{i}</span> to <span class="math">\\frac{\\mathcal{L}_i(\\tau) - 1}{\\tau - \\omega^i}</span> and that (2) the <span class="math">a_{i}</span>'s and <span class="math">a_{j}</span>'s from <span class="math">\\mathsf{upk}_i</span> and <span class="math">\\mathsf{upk}_j</span> can be used to compute in <span class="math">O(1)</span> time a KZG commitment <span class="math">u_{i,j}</span> to <span class="math">\\frac{\\mathcal{L}_j(\\tau)}{\\tau - \\omega^i}</span>. (Note that the partial fraction decomposition only requires evaluating a degree-1 polynomial at two points. Also, computing <span class="math">A&#x27;(\\omega^j)</span> can be done in <span class="math">O(1)</span> time as explained in Appendix A.) Thus, the proof <span class="math">\\pi_{i}</span> can be computed in <span class="math">O(n)</span> field operations and <span class="math">O(n)</span> exponentiations as:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {i} = g ^ {g _ {i} (\\tau)} = \\prod_ {j \\in [ 0, n) \\backslash \\{i \\}} \\left(u _ {i, j}\\right) ^ {v _ {j}} \\cdot \\left(u _ {i}\\right) ^ {v _ {i}} \\tag {96}</span></div>

    <p class="text-gray-300">Aggregatable Subvector Commitments for Stateless Cryptocurrencies</p>

    <p class="text-gray-300">Table 3. Asymptotic comparison of our aSVC with (aS)VCs based on hidden-order groups.  <span class="math">n</span>  is the vector size,  <span class="math">b</span>  is the subvector size,  <span class="math">\\ell</span>  is the length in bits of vector elements,  <span class="math">N = n\\ell</span>  and  <span class="math">\\lambda</span>  is the security parameter. For schemes based on hidden-order groups, the complexities in the table are asymptotic in terms group operations rather than exponentiations. This gives a better sense of performance, since exponents cannot be "reduced" in hidden-order groups as they can in known-order groups. We try to account for field operations (of size 2λ bits), but quantifying them precisely in these schemes can be very cumbersome. Also, since field operations are much faster, they can be mostly ignored. For our aSVC scheme, we give the same complexities in terms of group exponentiations, pairings and field operations (see Appendix D.7 for details). Because of this, the reader must be careful when comparing our scheme with the other schemes in this table: a group exponentiation in our scheme is roughly equivalent to  <span class="math">O(\\lambda)</span>  group operations in the hidden-order group schemes. (*Updating the commitment in CFG <span class="math">_\\ell^1</span>  only works in a weaker security model where the commitment is not produced adversarially.)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(aS)VC scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">prk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">vrk</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">upk_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">or</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">upk_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Com.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Com. upd.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">πi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove one vi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify one vi</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof upd.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove subv. (vi)i∈I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify subv. (vi)i∈I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggr-egate</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove each (vi)i∈[n]</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BBF_ℓ [BBF19]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ lg N bits</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ lg N + λ</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">bℓ lg N + λ</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ b lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg^2 N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CFG_1^1 [CFG+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">1+</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ lg N + λ</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ(n-b) lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">bℓ lg N + λ</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ b lg b lg N</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg^2 N</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CFG_2^2 [CFG+20]</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">G7</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">N lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ(n-b) lg (n-b)</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ b</td>

            <td class="px-3 py-2 border-b border-gray-700">ℓ b lg^2 b</td>

            <td class="px-3 py-2 border-b border-gray-700">N lg n</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our aSVC</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">b</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">n</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg^2 b + n lg n</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg^2 b</td>

            <td class="px-3 py-2 border-b border-gray-700">b lg^2 b</td>

            <td class="px-3 py-2 border-b border-gray-700">n lg n</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The proof can be verified in  <span class="math">O(1)</span>  time using  <span class="math">g^{\\tau}</span>  from the vrk by computing two pairings:</p>

    <div class="my-4 text-center"><span class="math-block">e \\left(c / g ^ {v _ {i}}, g\\right) = e \\left(\\pi_ {i}, g ^ {\\tau} / g ^ {\\omega^ {i}}\\right) \\tag {97}</span></div>

    <p class="text-gray-300">Proof Updates. If any vector element  <span class="math">v_{j}, j \\neq i</span>  changes to  <span class="math">v_{j} + \\delta</span> , the proof  <span class="math">\\pi_{i}</span>  can be updated in  <span class="math">O(1)</span>  time using  <span class="math">a_{i}, a_{j}</span>  from  <span class="math">\\mathsf{upk}_{i}, \\mathsf{upk}_{j}</span> . First, one computes  <span class="math">u_{i,j}</span>  in  <span class="math">O(1)</span>  time as described in the previous paragraph. Then, one updates  <span class="math">\\pi_{i}&#x27; = \\pi_{i} \\cdot (u_{i,j})^{\\delta}</span>  in  <span class="math">O(1)</span>  time. This new  <span class="math">\\pi_{i}&#x27;</span>  will verify against the updated  <span class="math">c&#x27;</span>  commitment defined earlier. If  <span class="math">v_{i}</span>  changes to  <span class="math">v_{i} + \\delta</span> , the proof  <span class="math">\\pi_{i}</span>  is updated in  <span class="math">O(1)</span>  time using  <span class="math">u_{i}</span>  from  <span class="math">\\mathsf{upk}_{i}</span>  as  <span class="math">\\pi_{i}&#x27; = \\pi_{i} \\cdot (u_{i})^{\\delta}</span>  (see Section 3.4.2).</p>

    <p class="text-gray-300">Subvector Proofs for  <span class="math">(v_{i})_{i\\in I}</span>  We use the same style of subvector proofs as in Appendix D.2. Thus, the subvector proving time is  <span class="math">O(n\\log n + b\\log^2 b)</span>  and the subvector proof verification time is  <span class="math">O(b\\log^2 b)</span>  time.</p>

    <p class="text-gray-300">Aggregating Proofs and Precomputing All Proofs. Aggregating all proofs  <span class="math">(\\pi_i)_{i\\in I}</span>  requires computing coefficients  <span class="math">c_{i} = 1 / A_{I}^{\\prime}(\\omega^{i}),\\forall i\\in I</span>  using partial fraction decomposition (see Section 3.4.1). This can be done by (1) computing  <span class="math">A_{I}(X) = \\prod_{i\\in I}(X - \\omega^{i})</span>  in  <span class="math">O(b\\log^2 b)</span>  field operations, (2) computing its derivative  <span class="math">A_I^\\prime (X)</span>  in  <span class="math">O(b)</span>  field operations and (3) evaluating  <span class="math">A_I^\\prime (X)</span>  at all  <span class="math">(\\omega^{i})_{i\\in I}</span>  using a multipoint evaluation in  <span class="math">O(b\\log^2 b)</span>  field operations [vzGG13b]. Then, the subvector proof can be aggregated with  <span class="math">O(b)</span>  exponentiations as:</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {I} = \\prod_ {i \\in I} \\pi_ {i} ^ {e _ {i}} \\tag {98}</span></div>

    <p class="text-gray-300">Thus, aggregation takes  <span class="math">O(b\\log^2 b)</span>  time.</p>

    <p class="text-gray-300">Finally, precomputing all proofs can be done efficiently in  <span class="math">O(n \\log n)</span>  time using the FK technique [FK20].</p>

    <p class="text-gray-300">Slower Commitment Time for Faster (Subvector) Proofs. When committing to a vector, we can use the FK technique to precompute all  <span class="math">n</span>  proofs in  <span class="math">O(n\\log n)</span>  time and store them as auxiliary information. Then, we can serve any individual proof  <span class="math">\\pi_i</span>  in  <span class="math">O(1)</span>  time and any subvector proof in  <span class="math">O(b\\log^2 b)</span>  time by aggregating it from the  <span class="math">\\pi_i</span> 's.</p>

    <p class="text-gray-300">We give complexities of VCs based on hidden-order groups in Table 3. These can be challenging to describe succinctly due to the many variable-length integer operations that arise. In an effort to keep complexities simple without leaving out too much detail, we often measure (and even approximate) complexities in terms of operations in a finite field of size  <span class="math">2^{2\\lambda}</span>  (e.g., additions, multiplications, computing Bézout coefficients, Shamir tricks), where  <span class="math">\\lambda</span>  is our security parameter. Another reason to do so is for fairness with VC schemes in known-order groups, which also use finite fields of size  <span class="math">2^{2\\lambda}</span> . Otherwise, a  <span class="math">2\\lambda</span> -bit multiplication would be counted as  <span class="math">O(\\lambda \\log \\lambda)</span>  in schemes such as  <span class="math">\\mathrm{BBF}_{\\ell}[\\mathrm{BBF18}]^3</span>  and as  <span class="math">O(1)</span>  time for schemes like KZG (see Appendix D.2).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The Shamir Trick. The "Shamir Trick" [Sha81, BBF18] can be used to compute an  <span class="math">e</span> th root of  <span class="math">g</span>  given an  <span class="math">e_1</span> th root and an  <span class="math">e_2</span> th root where  <span class="math">e = e_1e_2</span>  and  <span class="math">\\gcd(e_1, e_2) = 1</span> . The idea is to compute Bézout coefficients  <span class="math">a, b</span>  such that  <span class="math">ae_1 + be_2 = 1</span> . Then,  <span class="math">\\left(g^{\\frac{1}{e_1}}\\right)^b\\left(g^{\\frac{1}{e_2}}\\right)^a = g^{\\frac{be_2}{e_1e_2}}g^{\\frac{ae_1}{e_1e_2}} = g^{\\frac{ae_1 + be_2}{e_1e_2}} = g^{\\frac{1}{e_1e_2}}</span> . Note that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-56" class="text-xl font-semibold mt-8">E.1 Complexity of BBF_{ℓ} <em>[x11]</em></h3>

    <p class="text-gray-300">In this scheme, we assume the vector <span class="math">\\mathbf{v}=[v_{1},v_{2},\\ldots,v_{n}]</span> is indexed from <span class="math">1</span> to <span class="math">n</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Public Parameters. Let <span class="math">\\ell</span> denote the size of vector elements in bits. Let <span class="math">n</span> denote the number of vector elements. Let <span class="math">N=\\ell n</span>. Let <span class="math">\\mathbb{G}_{?}</span> denote a hidden-order group and <span class="math">g</span> be a random group element in <span class="math">\\mathbb{G}_{?}</span>. Let <span class="math">H:[N]\\to\\textsf{Primes}</span> be a bijective function that on input <span class="math">i</span> outputs the <span class="math">i</span>th prime number <span class="math">p_{i}</span>. (Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">p_{N}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\log\\left(\\ell n\\right)<span class="math"> bits.) The </span>\\mathsf{prk}<span class="math"> and </span>\\mathsf{vrk}<span class="math"> consist of only </span>g<span class="math">. This scheme does not use “fixed” update keys compatible with our definitions. Instead, this scheme uses <em>“dynamic” update hints</em>: the </span>i<span class="math">th update hint w.r.t. a commitment </span>c<span class="math"> is a VC proof for </span>v_{i}<span class="math"> that verifies against </span>c<span class="math">. In this sense, similar to Merkle trees, this scheme is less suitable for account-based stateless cryptocurrencies <em>[x13]</em>, since it requires user </span>i<span class="math"> to fetch user </span>j$’s proof too, before sending her money.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment. An <span class="math">\\ell</span>-bit vector element <span class="math">v_{i}</span> can be written as a vector of <span class="math">\\ell</span> bits <span class="math">(v_{i,j})_{j\\in[0,\\ell-1]}</span> Then, each bit <span class="math">v_{i,j}</span> is mapped to the unique prime <span class="math">p_{(i-1)\\cdot\\ell+j}</span>. Put differently, each <span class="math">v_{i}</span> is mapped to <span class="math">\\ell</span> unique primes <span class="math">(p_{(i-1)\\cdot\\ell+0},p_{(i-1)\\cdot\\ell+1},\\ldots,</span> <span class="math">p_{(i-1)\\cdot\\ell+(\\ell-1)})</span>. Then, for each <span class="math">v_{i}</span>, take the product of all primes corresponding to non-zero bits as <span class="math">P_{i}=\\prod_{j\\in[0,\\ell-1]}v_{i,j}\\cdot\\left(p_{(i-1)\\cdot\\ell+j}\\right)</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\ell\\log\\left(\\ell n\\right))<span class="math">. A commitment to the vector </span>\\mathbf{v}=(v_{i})_{i\\in[n]}<span class="math"> will be an RSA accumulator over these </span>P_{i}$’s:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">c</span> <span class="math">=g^{\\prod_{i\\in[n]}\\prod_{j\\in[0,\\ell-1]}v_{i,j}\\cdot\\left(p_{(i-1)\\cdot\\ell+j}\\right)}</span> (99) <span class="math">=g^{\\prod_{i\\in[n]}P_{i}}</span> (100)</p>

    <p class="text-gray-300">The exponent of <span class="math">c</span> is a product of at most <span class="math">\\ell n</span> primes, with the biggest prime having size <span class="math">O(\\log\\left(\\ell n\\right))</span>. Thus, computing the <span class="math">O(1)</span>-sized commitment <span class="math">c</span> takes <span class="math">O(\\ell n\\log\\left(\\ell n\\right))</span> group operations. (Note that, for hidden-order groups, we are counting group operations rather than exponentiations. This is to give a better sense of performance, which varies with the exponent size, since exponents cannot be “reduced” in hidden-order groups.)</p>

    <p class="text-gray-300">Since updating commitments requires update hints, which are VC proofs, we must first discuss VC proofs.</p>

    <h4 id="sec-57" class="text-lg font-semibold mt-6">E.1.1 Proofs for a <span class="math">v_{i}</span></h4>

    <p class="text-gray-300">A proof <span class="math">\\pi_{i}</span> for <span class="math">v_{i}</span> must show two things:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>That <span class="math">P_{i}</span> corresponding to all non-zero bits is accumulated in <span class="math">c</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. That <span class="math">Z_{i}=\\prod_{j\\in[0,\\ell-1]}\\left(1-v_{i,j}\\right)\\cdot\\left(p_{(i-1)\\cdot\\ell+j}\\right)</span> corresponding to all zero bits is <em>not</em> accumulated in <span class="math">c</span>. (Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\ell\\log\\left(\\ell n\\right))$.)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Proving “One” Bits are Accumulated. To prove <span class="math">P_{i}</span> is “in”, an <span class="math">O(1)</span>-sized RSA accumulator subset proof w.r.t. <span class="math">c</span> can be computed with <span class="math">O(\\ell n\\log\\left(\\ell n\\right))</span> group operations (via <em>A.MemWitCreate^{∗}</em> in <em>[x13, Sec 4.2, pg. 15]</em>):</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}^{[1]}=g^{\\prod_{j\\in[n],j\\neq i}P_{j}}=c^{1/P_{i}}</span> (101)</p>

    <p class="text-gray-300">To speed up the verification of this (part of) the proof, a constant-sized <em>proof of exponentiation (PoE)</em> <em>[x13]</em> is computed in <span class="math">O(\\ell\\log\\left(\\ell n\\right))</span> field and group operations. We discuss this later in Appendix E.1.2.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proving “Zero” Bits are Accumulated. To prove <span class="math">Z_{i}</span> is “out”, an <span class="math">O(\\ell\\log\\left(\\ell n\\right))</span>-sized disjointness proof <span class="math">\\pi_{i}^{[0]}</span> can be computed w.r.t. <span class="math">c</span> (via <em>A.NonMemWitCreate</em> in <em>[x13, Sec 4.1, pg. 14]</em>). First, <span class="math">Z_{i}</span> must be computed, but we assume this can be done in <span class="math">O(\\ell\\log\\left(\\ell n\\right))</span> field operations. Second, Bézout coefficients are computed such that <span class="math">\\alpha\\prod_{i\\in n}P_{i}+\\beta Z_{i}=1</span>. Then, the disjointness proof is <span class="math">\\pi_{i}^{[0]}=(g^{\\beta},\\alpha)</span>. Since $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Z_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, the proof is </span>O(\\ell\\log\\left(\\ell n\\right))<span class="math">-sized. Although this disjointness proof can be made </span>O(1)<span class="math">-sized via <em>proofs of knowledge of exponent (PoKE)</em> proofs, this seems to break the ability to aggregate VC proofs in BBF_{ℓ} <em>[x13, Sec 5.2, pg. 20]</em>. However, the prover can still include two constant-sized PoE proofs for </span>(g^{\\beta})^{Z_{i}}<span class="math"> and for </span>c^{\\alpha}<span class="math"> to make the verifier’s job easier, which costs him only </span>O(\\ell\\log\\left(\\ell n\\right))$ field and group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To analyze the time complexity of computing <span class="math">\\pi_{i}^{[0]}</span>, recall that:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The asymptotic complexity of computing Bézout coefficients on <span class="math">b</span>-bit numbers is <span class="math">O(b\\log^{2}b)</span> time.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. $b=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\prod_{i\\in n}P_{i}\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(n\\ell\\log\\left(\\ell n\\right))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">As a result, the Bézout coefficients take <span class="math">O((n\\ell\\log\\left(\\ell n\\right))\\log^{2}\\left(n\\ell\\log\\left(\\ell n\\right)\\right)=O(n\\ell\\log\\left(\\ell n\\right)(\\log n\\ell+\\log\\log\\left(\\ell n\\right))^{2})\\,=O(n\\ell\\log^{3}(\\ell n))</span> time. However, since these are bit operations, we will count them as <span class="math">O(n\\ell\\log\\left(\\ell n\\right))</span> field operations. Furthermore, computing <span class="math">g^{\\beta}</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\prod_{i\\in[n]}P_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(n\\ell\\log\\left(\\ell n\\right))<span class="math"> takes </span>O(n\\ell\\log\\left(\\ell n\\right))$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Overall, the time to compute <span class="math">\\pi_{i}</span> is <span class="math">O(\\ell n\\log\\left(\\ell n\\right))=O(\\ell n\\log n)</span>.</p>

    <h4 id="sec-58" class="text-lg font-semibold mt-6">E.1.2 Verifying a Proof for <span class="math">v_{i}</span></h4>

    <p class="text-gray-300">To verify <span class="math">\\pi_{i}=(\\pi_{i}^{[0]},\\pi_{i}^{[1]})</span>, the verifier proceeds as follows. First, he computes <span class="math">P_{i}</span> in <span class="math">O(\\ell\\log{(\\ell n)})</span> field operations. Second, he checks that <span class="math">\\left(\\pi_{i}^{[1]}\\right)^{P_{i}}=c</span> via the PoE proof in <span class="math">\\pi_{i}^{[1]}</span> using <span class="math">O(\\lambda)</span> group operations and <span class="math">O(\\ell\\log{n})</span> field operations. Third, he parses <span class="math">(g^{\\beta},\\alpha)</span> from <span class="math">\\pi_{i}^{[0]}</span> and checks if <span class="math">(g^{\\beta})^{Z_{i}}c^{\\alpha}=g</span>. Since the prover included PoE proofs, this can be verified with <span class="math">O(\\lambda)</span> group operations and <span class="math">O(\\ell\\log{(\\ell n)})</span> field operations.</p>

    <h4 id="sec-59" class="text-lg font-semibold mt-6">E.1.3 Updates</h4>

    <p class="text-gray-300">Updating Commitments. Suppose <span class="math">v_{i}</span> changes to <span class="math">v_{i}^{\\prime}</span>. For message bits that are changed from 0 to 1, updating the commitment <span class="math">c</span> involves “accumulating” new primes associated with those bits in <span class="math">c</span>. For message bits that are changed from 1 to 0, updating <span class="math">c</span> involves removing the primes associated with those bits from <span class="math">c</span>. Recall that, in BBF_{ℓ}, the <span class="math">i</span>th update hint <span class="math">\\mathsf{up}\\mathsf{h}_{i}</span> is actually the VC proof <span class="math">\\pi_{i}</span> for <span class="math">v_{i}</span> w.r.t. <span class="math">c</span>. Also recall that <span class="math">\\pi_{i}^{[1]}=c^{1/P_{i}}</span> from <span class="math">\\pi_{i}</span> is exactly the commitment <span class="math">c</span> without any of the primes associated with <span class="math">v_{i}</span>. Thus, to update the commitment, we can compute <span class="math">P_{i}^{\\prime}=\\prod_{j\\in[0,\\ell-1]}v_{i,j}^{\\prime}p_{(i-1)\\cdot\\ell+j}</span> in <span class="math">O(\\ell)</span> field operations and set <span class="math">c^{\\prime}=\\left(\\pi_{i}^{[1]}\\right)^{P_{i}^{\\prime}}</span> in <span class="math">O(\\ell\\log{(\\ell n)})</span> group operations.</p>

    <p class="text-gray-300">To process several updates for <span class="math">b</span> updated elements <span class="math">(v_{i})_{i\\in I}</span> with <span class="math">\\mathsf{up}\\mathsf{h}_{i}</span>’s that all verify w.r.t. <span class="math">c</span>, we have to take an additional step. First, we use <span class="math">O(b)</span> Shamir tricks on the <span class="math">\\pi_{i}^{[1]}</span>’s from <span class="math">\\mathsf{up}\\mathsf{h}_{i}</span> to obtain the commitment <span class="math">c^{1/\\prod_{i\\in I}P_{i}}</span>, which no longer accumulates any primes associated with the old elements <span class="math">(v_{i})_{i\\in I}</span>. Then, we can add back the new primes <span class="math">P_{i}^{\\prime}</span> associated with the new elements <span class="math">(v_{i}^{\\prime})_{i\\in I}</span> in <span class="math">O(b\\ell\\log{(\\ell n)})</span> group operations. We assume the <span class="math">O(b)</span> Shamir tricks can be done in <span class="math">O(b)</span> field operations.</p>

    <p class="text-gray-300">Updating Proofs. Proof updates are not discussed in <em>[x1]</em>, but seem possible. We leave it to future work to describe them and their complexity.</p>

    <h4 id="sec-60" class="text-lg font-semibold mt-6">E.1.4 Subvector Proofs for <span class="math">(v_{i})_{i\\in I}</span></h4>

    <p class="text-gray-300">Recall that a normal VC proof for <span class="math">v_{i}</span> reasons about which primes associated with <span class="math">v_{i}</span> are (not) accumulated in <span class="math">c</span>. A subvector proof will do the same, except it will reason about primes associated with all <span class="math">(v_{i})_{i\\in I}</span>. Thus, instead of reasoning about two <span class="math">O(\\ell\\log{(\\ell n)})</span>-sized <span class="math">P_{i}</span> and <span class="math">Z_{i}</span>, it will reason about two <span class="math">O(b\\ell\\log{(\\ell n)})</span>-sized <span class="math">\\prod_{i\\in I}P_{i}</span> and <span class="math">\\prod_{i\\in I}Z_{i}</span>. Specifically, an <span class="math">I</span>-subvector proof consists of:</p>

    <p class="text-gray-300"><span class="math">\\pi_{I}^{[1]}</span> <span class="math">=g^{\\prod_{j\\in[n]\\setminus I}P_{j}}=c^{1/\\prod_{i\\in I}P_{i}}</span> (102) <span class="math">\\pi_{I}^{[0]}</span> <span class="math">=\\left(g^{\\beta},\\alpha\\right)\\text{ such that }(g^{\\beta})^{\\prod_{i\\in I}Z_{i}}c^{\\alpha}=g</span> (103)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let us analyze the proving time and the proof size. First, computing <span class="math">\\pi_{I}^{[1]}</span> can be done in <span class="math">O(\\ell(n-b)\\log{(\\ell n)})</span> group operations, which is slightly faster than the <span class="math">O(\\ell n\\log{(\\ell n)})</span> time for computing <span class="math">\\pi_{i}^{[1]}</span> in an individual proof for <span class="math">v_{i}</span> (see Equation (101)). Second, computing the PoE for <span class="math">\\left(\\pi_{I}^{[1]}\\right)^{\\prod_{i\\in I}P_{i}}=c</span> can be done in <span class="math">O(b\\ell\\log{(\\ell n)})</span> field and group operations. Third, computing <span class="math">\\pi_{I}^{[0]}</span> maintains the same asymptotic complexity, since it is dominated by the time to compute <span class="math">g^{\\beta}</span>, which remains just as expensive. However, <span class="math">\\pi_{I}^{[0]}</span>’s size would increase to <span class="math">O(b\\ell\\log{(\\ell n)})</span>, since the Bézout coefficient <span class="math">\\alpha</span> will be roughly of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\prod_{i\\in I}Z_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Fortunately, the prover can avoid this by giving </span>c^{\\alpha}<span class="math"> rather than </span>\\alpha<span class="math"> along with a PoKE proof (i.e., one group element and one </span>2\\lambda<span class="math">-bit integer), while maintaining the same asymptotic complexity. As before, the prover also gives a PoE proof for </span>\\left(g^{\\beta}\\right)^{Z_{i}}$ to speed up the verifier’s job.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Because of the PoE proof, verification of <span class="math">\\pi_{I}^{[1]}</span> only requires <span class="math">O(\\lambda)</span> group operations as before, but the number of field operations increases to <span class="math">O(b\\ell\\log{(\\ell n)})</span>. Similarly, the PoKE proof will speed up verification of <span class="math">\\pi_{I}^{[0]}</span> to <span class="math">O(\\lambda)</span> group operations, but the <span class="math">O(b\\ell\\log{(\\ell n)})</span> field operations remain for verifying the PoE proof for <span class="math">\\left(g^{\\beta}\\right)^{Z_{i}}</span>.</p>

    <h4 id="sec-61" class="text-lg font-semibold mt-6">E.1.5 Aggregating Proofs</h4>

    <p class="text-gray-300">Since aggregating RSA membership and non-membership witnesses is possible <em>[x1]</em>, and BBF_{ℓ} VC proofs consist of one RSA membership (subset) proof and one non-membership (disjointness) proof, it follows that aggregating proofs is possible. We leave it to future work to analyze the complexity of aggregation, which has to be at least <span class="math">\\Omega(b\\ell\\log{(\\ell n)})</span> since it must read all <span class="math">b</span> VC proofs as input, which are each <span class="math">O(\\ell\\log{(\\ell n)})</span>-sized.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">E.1.6 Precomputing All Proofs</p>

    <p class="text-gray-300">Computing all membership and non-membership witnesses for an RSA accumulators over <span class="math">N</span> elements is possible in <span class="math">O(N\\log N)</span> exponentiations <em>[x1, x21]</em>. Since for <span class="math">\\text{BBF}_{\\ell}</span> we have <span class="math">N=\\ell n</span> and an exponentiation costs <span class="math">O(\\log\\left(\\ell n\\right))</span> group operations, this would take <span class="math">O(\\ell n\\log^{2}\\left(\\ell n\\right))</span> group operations. We are ignoring (1) the overhead of aggregating membership and non-membership witnesses and (2) the overhead of computing PoE proofs, which we assume is dominated by the cost to compute the witnesses.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">E.2 Complexity of <span class="math">\\text{CFG}_{\\ell}^{1}</span> <em>[CFG^{+}20]</em> and <span class="math">\\text{CFG}_{\\ell}^{2}</span> <em>[x10, x16, CFG^{+}20]</em></h3>

    <p class="text-gray-300">We refer the reader to <em>[CFG^{+}20, Table 1, pg. 35]</em> for most of these these complexities.</p>

    <p class="text-gray-300">Aggregating Proofs. For <span class="math">\\text{CFG}_{\\ell}^{1}</span>, aggregating <span class="math">b</span> proofs into an <span class="math">I</span>-subvector proof takes <span class="math">O(b\\log b\\log N)</span> group operations <em>[CFG^{+}20, Sec 5.1, pg. 23]</em>. For <span class="math">\\text{CFG}_{\\ell}^{2}</span>, this takes <span class="math">O(\\ell b\\log^{2}b)</span> group operations <em>[CFG^{+}20, Sec 5.2, pg. 32]</em>.</p>

    <p class="text-gray-300">Precomputing All Proofs. The paper gives a generic technique of using incremental (dis)aggregation to precompute auxiliary information for serving proofs fast. This technique can also be used to precompute all proofs fast in quasilinear time. In <span class="math">\\text{CFG}_{\\ell}^{1}</span>, we believe this will take <span class="math">O(N\\log^{2}N)</span> group operations, dominated by the complexity of computing all <span class="math">N=\\ell n</span> RSA accumulator membership witnesses. In <span class="math">\\text{CFG}_{\\ell}^{2}</span>, we estimate this will take <span class="math">O(\\ell n\\log n)</span> group operations (since disaggregating a proof of size <span class="math">m</span> into two proofs of size <span class="math">m/2</span> takes <span class="math">O(\\ell m)</span> group operations).</p>

    <h2 id="sec-63" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Aggregatable Subvector Commitments for Stateless Cryptocurre... (2020/527)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/527
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
