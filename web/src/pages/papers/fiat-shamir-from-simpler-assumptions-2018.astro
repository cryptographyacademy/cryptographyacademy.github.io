---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2018/1004';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Fiat-Shamir From Simpler Assumptions';
const AUTHORS_HTML = 'Ran Canetti, Yilei Chen, Justin Holmgren, Alex Lombardi, Guy N.  Rothblum, Ron D.  Rothblum';

const CONTENT = `    <p class="text-gray-300">Fiat-Shamir From Simpler Assumptions</p>

    <p class="text-gray-300">Ran Canetti* Yilei Chen† Justin Holmgren‡ Alex Lombardi§ Guy N. Rothblum¶ Ron D. Rothblum∥</p>

    <p class="text-gray-300">October 23, 2018</p>

    <p class="text-gray-300">Abstract</p>

    <p class="text-gray-300">We present two new protocols:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A succinct publicly verifiable non-interactive argument system for log-space uniform NC computations, under the assumption that any one of a broad class of fully homomorphic encryption (FHE) schemes has almost optimal security against polynomial-time adversaries. The class includes all FHE schemes in the literature that are based on the learning with errors (LWE) problem.</li>

      <li>A non-interactive zero-knowledge argument system for NP in the common random string model, assuming almost optimal hardness of search-LWE against polynomial-time adversaries.</li>

    </ul>

    <p class="text-gray-300">Both results are obtained by applying the Fiat-Shamir transform with explicit, efficiently computable functions (specifically, correlation intractable functions) to certain classes of interactive proofs. We improve over prior work by reducing the security of these protocols to qualitatively weaker computational hardness assumptions. Along the way, we also show that the Fiat-Shamir transform can be soundly applied (in the plain model) to a richer class of protocols than was previously known.</p>

    <p class="text-gray-300">*Boston University and Tel Aviv University. Member of CPIIS. Supported by NSF awards 1413920 &amp; 1801564, ISF award 1523/14. canetti@bu.edu. †Visa Research. Email: chenyilei.ra@gmail.com. Research conducted while the author was at Boston University supported by the NSF MACS project and NSF grant CNS-1422965. ‡Princeton University. Email: justin.holmgren@princeton.edu. Research conducted in part while the author was at MIT, supported in part by the NSF MACS project. §MIT. Email: alexjl@mit.edu. Research supported in part by an NDSEG fellowship. Research supported in part by NSF Grants CNS-1350619 and CNS-1414119, and by the Defense Advanced Research Projects Agency (DARPA) and the U.S. Army Research Office under contracts W911NF-15-C-0226 and W911NF-15-C-0236. ¶Weizmann Institute of Science. Email: rothblum@alum.mit.edu. ∥Technion. Email: rothblum@cs.technion.ac.il. Parts of this research were conducted while the author was at MIT. This research was supported in part by the Israeli Science Foundation (Grant No. 1262/18).</p>

    <p class="text-gray-300">1 Introduction 1 1.1 Our Contributions 2 1.2 Related Work 4</p>

    <p class="text-gray-300">2 Our Techniques 6 2.1 Round-By-Round Soundness 7 2.2 Bounded Correlation Intractable Hash Families 8 2.3 Constructing Optimal Bounded-KDM Secure Encryption 9</p>

    <p class="text-gray-300">3 Correlation Intractability from KDM-Secure Encryption 13 3.1 Correlation Intractable Hash Functions 14 3.2 Encryption Schemes and Key-Dependent Message (KDM) Security 15 3.3 Correlation Intractability from Strong KDM Security 16</p>

    <p class="text-gray-300">4 Optimally Secure KDM-Secure Encryption From Simpler Assumptions 18 4.1 Learning with Errors 18 4.2 (P/Poly)-KDM Security via Fully Homomorphic Encryption 19 4.3 SIZE<span class="math">(\\kappa^c)</span>-KDM Security via Randomized Encodings 22</p>

    <p class="text-gray-300">5 Round-by-Round Soundness and Fiat-Shamir 32 5.1 Definitions: Interactive Proofs and Arguments 32 5.2 Round-by-Round Soundness 32 5.3 Round-by-Round Soundness and Fiat-Shamir 35</p>

    <p class="text-gray-300">6 Publicly Verifiable SNARG 36 6.1 Fields and Polynomials 36 6.2 GKR: Round by Round Soundness and Efficient Sampleability 37 6.3 Publicly Verifiable Delegation for Log-Space Uniform NC 40</p>

    <p class="text-gray-300">7 Non-Interactive Zero Knowledge 41 7.1 Non-Interactive Zero Knowledge Arguments 41 7.2 NIZK from Bounded Correlation Intractability 42 7.3 Our NIZK Protocol 47</p>

    <p class="text-gray-300">References 49</p>

    <p class="text-gray-300">A Success probability of polynomial time algorithms on LWE 54 A.1 The success probability of the lattice basis reduction approach 55</p>

    <p class="text-gray-300">The Fiat-Shamir transform <em>[x10]</em> is an attractive template for designing non-interactive argument schemes:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Design a potentially highly interactive proof (or argument) system <span class="math">\\Pi</span> in which the verifier is “public-coin”, meaning that its only messages are fresh random coins.</li>

      <li>Compile <span class="math">\\Pi</span> into a two-message protocol <span class="math">\\Pi_{\\sf FS}</span>, as follows.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The <span class="math">\\Pi_{\\sf FS}</span> verifier first sends a description of a “sufficiently complex” hash function <span class="math">h</span>.</li>

      <li>The <span class="math">\\Pi_{\\sf FS}</span> prover responds with the transcript of an emulated execution of <span class="math">\\Pi</span> (including an input <span class="math">x</span>, as well as all messages exchanged between the prover and verifier), in which each verifier message is set to be the value of <span class="math">h</span> applied to the transcript so far.</li>

      <li>The <span class="math">\\Pi_{\\sf FS}</span> verifier checks that the transcript it received is consistent with <span class="math">h</span>, and that the verifier of <span class="math">\\Pi</span> would have accepted.</li>

    </ul>

    <p class="text-gray-300">The resulting protocol <span class="math">\\Pi_{\\sf FS}</span> is indeed non-interactive (<span class="math">h</span> can be chosen ahead of time, say as part of a common reference string), it is publicly verifiable, and it adds little in communication and computation. In practice, the Fiat-Shamir transform has been heuristically used as the basis for many important protocols, including identification and signature schemes, publicly-verifiable succinct non-interactive arguments (pv-SNARGs) and NIZKs, e.g. <em>[x10, x11, x1, x12, x13]</em>.</p>

    <p class="text-gray-300">A central question in the foundational study of cryptography regards the security of this transformation:</p>

    <p class="text-gray-300">&gt; <em>For which protocols and hash families does the Fiat-Shamir transform preserve soundness? Under what assumptions can we prove this?</em></p>

    <p class="text-gray-300">Security analysis in the random oracle model (ROM) has provided some justification for this design methodology: If <span class="math">h</span> is modeled as a random oracle, then <span class="math">\\Pi_{\\sf FS}</span> is sound as long as <span class="math">\\Pi</span> is computationally sound and either has a constant number of rounds <em>[x10, x11, x2]</em> or more generally, satisfies a stronger soundness property called <em>soundness against state restoration attacks</em> <em>[x3]</em>.</p>

    <p class="text-gray-300">Still, it has remained largely open whether there exist <em>concrete</em> hash families that are “FS-compatible” (i.e. that can guarantee soundness and potentially also zero-knowledge for the transformed protocol). Initial results in this direction were negative. Indeed, Goldwasser and Kalai <em>[x14]</em> (following Barak <em>[x2]</em>) demonstrated a three-round, public-coin argument scheme for which applying the Fiat-Shamir transform with <em>any</em> hash family never yields a sound protocol. Furthermore, Bitansky et al. <em>[BDG^{+}13]</em> show that, even when starting with a three-round <em>proof</em>, soundness of the Fiat-Shamir transform with a concrete hash family cannot be proved via black box reduction to a standard, game-based assumption.</p>

    <p class="text-gray-300">In contrast, a recent line of work <em>[x15, x4, x16]</em> <em>circumvents</em> the <em>[BDG^{+}13]</em> impossibility result by using stronger than standard hardness assumptions to construct FS-compatible hash families. Kalai <em>et al.</em> <em>[x15]</em> gave the first construction of a hash family that is FS-compatible for arbitrary constant-round (public-coin) interactive proofs, albeit from complex obfuscation assumptions. Canetti <em>et al.</em> <em>[x5]</em> then provide alternative constructions of FS-compatible hash</p>

    <p class="text-gray-300">families without obfuscation, but using complex KDM-security assumptions on secret-key encryption schemes.</p>

    <p class="text-gray-300">We emphasize that the assumptions made by <em>[x14, x7]</em> are highly complex in the following sense: both involve an adversary that is in part <em>computationally unbounded</em>. For example, the KDM security of <em>[x7]</em> allows messages to be <em>arbitrary</em> functions of the key (which may not be efficiently computable). These assumptions are problematic: they are not complexity assumptions <em>[x13]</em>, and they are not falsifiable <em>[x20, x15]</em> except with exponential time. Holmgren and Lombardi <em>[x11]</em>, building on <em>[x14]</em>, construct a hash family with a different set of serious drawbacks; it relies on indistinguishability obfuscation and is applicable only to a comparatively limited class of protocols.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">1.1 Our Contributions</h3>

    <p class="text-gray-300">We construct explicit hash functions that are FS-compatible for a rich class of protocols, and we prove their security under assumptions that are qualitatively weaker than what was previously known. Using these hash families, we derive new results for delegation of computation and zero knowledge.</p>

    <p class="text-gray-300">We first describe our delegation protocol, which we obtain by applying Fiat-Shamir to the interactive proof of <em>[x12]</em> using our new FS-compatible hash functions (and overcoming some technical obstacles that will be further discussed below).</p>

    <h6 id="sec-4" class="text-base font-medium mt-4">Theorem 1 (Informally Stated, see Theorem 6.6).</h6>

    <p class="text-gray-300">If any one of the LWE-based fully homomorphic encryption schemes in the literature (such as <em>[x3, x2, x4, x13, x5]</em>) has optimal security against polynomial-size key-recovery attacks, then there is a publicly verifiable succinct non-interactive argument (pv-SNARG) for (log-space uniform) NC. Moreover, there is an efficiently computable hash function family <span class="math">\\mathcal{H}</span> such that applying the Fiat-Shamir transform to the <em>[x12]</em> doubly efficient interactive proof, using <span class="math">\\mathcal{H}</span>, results in such a protocol.</p>

    <p class="text-gray-300">Here and below, by optimal security against poly-size attacks, we mean that every poly-size circuit family breaks the assumption with probability at most <span class="math">\\lambda^{O(1)}/2^{\\lambda}</span>. We identify a range of the LWE parameters in which this assumption seem plausible. (This range, in particular, involves very high noise magnitude. See further discussion in Appendix A).</p>

    <p class="text-gray-300">Note that this is the first time that the Fiat-Shamir transform, with an explicit hash function family, is meaningfully applied to an interactive protocol with a super-constant number of rounds. In particular the results of <em>[x14, x7, x11]</em> only hold when the Fiat-Shamir transform is applied to constant-round protocols. See further discussion in Sections 1.1.2 and 2.1.</p>

    <p class="text-gray-300">Second, by applying the Fiat-Shamir transform to a specific instantiation of the classical <em>[x10]</em> zero-knowledge proof-system we obtain a non-interactive (statistical) zero-knowledge argument for NP from a strong variant of LWE:</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Theorem 2 (Informally Stated, see Theorem 7.8).</h6>

    <p class="text-gray-300">If Search-LWE is optimally hard for polynomial-size adversaries, then there is an (adaptively sound) non-interactive statistical zero-knowledge (NISZK) argument for NP. Moreover, there is an efficiently computable hash family <span class="math">\\mathcal{H}</span> such that applying the Fiat-Shamir transform to the <em>[x10]</em> honest-verifier zero-knowledge proof, using <span class="math">\\mathcal{H}</span> (and a specific commitment scheme), results in such a protocol.</p>

    <p class="text-gray-300">Note that the assumption made in Theorem 2 is weaker than that made in Theorem 1 as it is directly related to the Search-LWE problem (rather than relying on security of the fully homomorphic</p>

    <p class="text-gray-300">encryption schemes which rely on LWE together with a certain circular security assumption). Both assumptions are significantly simpler than those in previous work <em>[x13, x7]</em>. In particular, our assumptions do not involve a universal quantifier over computationally unbounded functions.</p>

    <p class="text-gray-300">The proofs of both Theorems 1 and 2 rely on new <em>correlation intractable hash functions</em> that we construct as well as new insights on interactive proofs. We next describe these in more detail, since we believe they may be of independent interest. To do so, we first recall the notion of correlation intractability and its relation to Fiat-Shamir.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Correlation Intractability.</h4>

    <p class="text-gray-300">Loosely speaking, a hash function family <span class="math">\\mathcal{H}</span> is correlation intractable (CI) for a sparse relation <span class="math">R</span> if any polynomial size adversary, given a description of <span class="math">h\\leftarrow\\mathcal{H}</span>, outputs <span class="math">x</span> such that <span class="math">\\left(x,h(x)\\right)\\in R</span> with only negligible probability <em>[x6]</em>. (A relation is sparse if for every <span class="math">x</span>, the fraction of <span class="math">y</span>’s such that <span class="math">(x,y)\\in R</span>, is negligible.) The hash function is <em>fully</em> correlation intractable if it is <span class="math">R</span>-correlation intractable for <em>all</em> sparse relations <span class="math">R</span>. Halevi <em>et al.</em> <em>[x12]</em> observed that if a hash family <span class="math">\\mathcal{H}</span> is fully correlation intractable then it is also FS-compatible for every <em>constant-round</em> public-coin interactive proof.</p>

    <p class="text-gray-300">Obtaining fully correlation intractable hash functions appears to be quite difficult; as discussed earlier, the only known constructions of such a hash family <em>[x13, x7]</em> require assumptions that are not falsifiable except with exponential time. We circumvent this difficulty by focusing on hash families that are correlation intractable for a rich <em>subclass</em> of relations. Namely, we consider the class of relations <span class="math">R</span> with the property that it is computationally easy, given an input <span class="math">x</span>, to sample a random output <span class="math">y</span> such that <span class="math">(x,y)\\in R</span>. We call such relations <em>efficiently sampleable</em>.</p>

    <p class="text-gray-300">A priori, it is unclear (1) that such hash families are <em>useful</em> for obtaining the desired applications, and (2) that they are any easier to construct than fully correlation intractable hash families. The main focus of this work is showing that both of these are actually the case:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We give new constructions of hash families that are correlation intractable for efficiently sampleable relations, extending the work of <em>[x7]</em>. Crucially, we are able to prove security relying on simple, polynomial time game-based assumptions (albeit with exponentially small winning probability).</li>

      <li>We show that if a hash family <span class="math">\\mathcal{H}</span> is correlation intractable for efficiently sampleable relations, then it suffices to instantiate the Fiat-Shamir transform in order to obtain both pv-SNARGs and NIZKs.</li>

    </ul>

    <p class="text-gray-300">We now describe these two contributions in more detail.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">1.1.1 Correlation Intractability for Efficient Relations</h4>

    <p class="text-gray-300">We construct two types of efficiently computable hash families that are correlation intractable for the class of efficiently sampleable relations. In our first construction, the (polynomial) complexity of the hash family is allowed to depend on the complexity of sampling the relation.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Theorem 3 (Informally Stated, see Theorems 3.11 and 4.11).</h6>

    <p class="text-gray-300">If Search-LWE is optimally hard for polynomial-size circuits, then for every polynomial <span class="math">S(\\lambda)</span>, there is a hash family (whose description size grows with <span class="math">S</span>) that is <span class="math">R</span>-correlation intractable for all relations that are sampleable by size-<span class="math">S</span> circuits.</p>

    <p class="text-gray-300">This theorem suffices for our construction of NIZK arguments (i.e., Theorem 2) because the verifier (which must evaluate a hash function), is allowed to run in any polynomial time, even potentially larger than the time required by the NP verification procedure. In contrast, for our delegation application, we do not know how to use such a non-compact hash function. Rather, we construct a compact correlation intractable hash function (under a stronger assumption).</p>

    <p class="text-gray-300"><strong>Theorem 4 (Informally Stated, see Theorems 3.11 and 4.6).</strong> If any one of the LWE-based fully homomorphic encryption schemes in the literature (such as [BV11, BGV12, Bra12, GSW13, BV14]) has optimal circular security against polynomial-size key-recovery attacks, then there exists a hash family that is  <span class="math">R</span> -correlation intractable for all relations  <span class="math">R</span>  that are sampleable by polynomial-size circuits.</p>

    <h2 id="sec-9" class="text-2xl font-bold">1.1.2 Round-by-Round Soundness</h2>

    <p class="text-gray-300">Toward proving Theorem 1, we would like to apply the Fiat-Shamir transform to the [GKR08] protocol using the hash function that we constructed in Theorem 4. However, we run into a difficulty: correlation intractability is only known to suffice for the Fiat Shamir transform of constant-round interactive proofs, whereas the [GKR08] protocol has a super-constant number of rounds.²</p>

    <p class="text-gray-300">We overcome this difficulty by formulating a stronger soundness requirement for public-coin interactive proofs that we call round-by-round (RBR) soundness. We show that RBR soundness suffices for applying the Fiat-Shamir transform (using a correlation intractable hash function) even for multi-round interactive proofs.³ To complete the proof of Theorem 1, we show that the [GKR08] protocol satisfies RBR soundness and is moreover compatible with our notion of bounded correlation intractable hash functions.</p>

    <p class="text-gray-300">As a side note, we also show that any public-coin interactive proof  <span class="math">\\Pi</span>  can be easily transformed into an interactive proof that has RBR soundness. The transformation simply applies parallel repetition. As an immediate corollary, fully correlation intractable hash families can be used to transform any public-coin, doubly-efficient interactive proof into a publicly verifiable non-interactive argument.</p>

    <p class="text-gray-300">Our main results are summarized in Fig. 1:</p>

    <h2 id="sec-10" class="text-2xl font-bold">1.2 Related Work</h2>

    <p class="text-gray-300"><strong>On Fiat-Shamir and Magic Functions.</strong> Dwork et al. [DNRS99] define magic functions to be FS-compatible hash functions for the case of transforming a three-round honest-verifier zero-</p>

    <p class="text-gray-300">¹The circular security assumption is actually redundant here because all these schemes include an encryption of the secret key to facilitate the bootstrapping procedure [Gen09] and so their security implies that they are also circular secure.</p>

    <p class="text-gray-300">²As a matter of fact, there exist statistically sound interactive proofs with a super constant number of rounds (and negligible soundness), to which the Fiat-Shamir transform cannot be applied securely, even in the random oracle model. Consider for example taking the sequential repetition of any interactive proof with constant soundness. While sequential repetition reduces the soundness at an exponential rate, applying the Fiat-Shamir transform (even in the random oracle model) results in an insecure protocol.</p>

    <p class="text-gray-300">³We remark that soundness against state restoration attacks (which is weaker than RBR soundness) was shown by Ben Sasson et al. [BCS16] to suffice for proving soundness of the Fiat-Shamir transform in the random oracle model, even for protocols with a super-constant number of rounds. In contrast, we are interested in using Fiat-Shamir in the plain model using explicit hash functions, see further discussion in Section 2.1.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 1: Summary of results.</p>

    <p class="text-gray-300">knowledge argument into a signature scheme, and study the relationship between the existence of magic functions and the existence of general three round zero knowledge protocols.</p>

    <p class="text-gray-300">Correlation Intractability and Fiat-Shamir This work continues a series of recent developments [CCR16, KRR17, CCRR18, HL18] focused on instantiating correlation intractable hash functions in the standard model. We discuss the latter three works, which provide instantiations of FS-compatible hash functions in the standard model.</p>

    <p class="text-gray-300">Kalai et al. [KRR17] and Canetti et al. [CCRR18] construct correlation intractable hash families from very strong assumptions. Specifically, [KRR17] assumed input-hiding obfuscation for multi-bit point functions and general-purpose indistinguishability obfuscation. Subsequently, [CCRR18] gave a construction that assumed encryption satisfying a form of nearly optimal key-dependent message (KDM) security. More specifically, they assume that polynomial-size adversaries cannot recover the secret key with significantly better probability than random guessing, even given encryptions of arbitrary (even inefficiently computable) functions of the secret key. [CCRR18] then give candidate encryption schemes satisfying this security property under strong variants of the LWE and CDH assumptions.</p>

    <p class="text-gray-300">We emphasize that both of these assumptions involve an adversary that is in part computationally unbounded. The input-hiding obfuscation in [KRR17] applied to a distribution of point functions</p>

    <div class="my-4 text-center"><span class="math-block">P _ {\\alpha , \\beta} (x) = \\left\\{ \\begin{array}{l l} \\beta &amp;amp; \\text {if} x = \\alpha \\\\ 0 &amp;amp; \\text {otherwise} \\end{array} \\right.</span></div>

    <p class="text-gray-300">must hide  <span class="math">\\alpha</span>  even when  <span class="math">\\beta</span>  is chosen as an arbitrary function of  <span class="math">\\alpha</span> , and the KDM security of [CCRR18] similarly allows messages to be arbitrary functions of the key. This makes these assumptions difficult to analyze, and in particular they are not falsifiable [Nao03, GW11] except with (non-uniform) exponential time.</p>

    <p class="text-gray-300">A first step towards rectifying this situation was taken by Holmgren and Lombardi [HL18], who consider a weakening of full correlation intractability. Their weakening essentially only asks for  <span class="math">R</span> -correlation intractability when  <span class="math">R</span>  is non-uniformly efficiently sampleable - there is a circuit of fixed polynomial size that, given  <span class="math">x</span> , samples approximately uniformly from the set  <span class="math">\\{y : (x, y) \\in</span></p>

    <p class="text-gray-300"><span class="math">R\\}</span>. <em>[x10]</em> constructs this form of “bounded” correlation intractable hash family from a sub-exponentially secure indistinguishability obfuscator and a nearly optimally secure one-way function, and demonstrate that this restricted form of correlation intractability still implies FS-compatibility for the <em>[x14]</em> 3-message zero-knowledge proof system for NP. However, their result still requires subexponentially secure indistinguishability obfuscation and has no implications for pv-SNARGs.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">pv-SNARGs.</h5>

    <p class="text-gray-300">Constructions of pv-SNARGs are known in the random oracle model <em>[x20]</em>, from knowledge assumptions <em>[BCC^{+}17]</em>, or from generic assumptions on strong (noiseless) graded encodings with no known candidates <em>[x22]</em>.</p>

    <p class="text-gray-300">A construction of pv-SNARGs was also given by <em>[x5]</em>: they applied the Fiat-Shamir transform (using their hash family) to the <em>[x23]</em> constant round interactive proof system for bounded space computation.</p>

    <p class="text-gray-300">In very recent independent work, Kalai et al. <em>[x16]</em> also construct a publicly verifiable argument system for (logspace uniform) NC. On the positive side, they rely only on falsifiable assumptions about groups equipped with a bilinear map. However, their argument system is in the preprocessing model. In this model, the prover and verifier have access to a common reference string, which is as long as the computation transcript (and must be generated securely by a trusted party). In contrast, our protocol requires only a short common random string but relies on seemingly stronger assumptions.</p>

    <p class="text-gray-300">Lastly, we remark that privately-verifiable (aka designated verifier) non-interactive arguments for all of <span class="math">\\mathbf{P}</span> are known to exist under LWE <em>[x15, x1]</em>.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">NIZK Arguments for NP.</h5>

    <p class="text-gray-300">NIZK arguments for NP are currently known from trapdoor permutations <em>[x11]</em>, falsifiable assumptions on bilinear maps <em>[x12]</em>, or indistinguishability obfsucation <em>[x24, x6]</em>. The works <em>[x12, x24]</em> also construct NIZK arguments for NP satisfying statistical zero knowledge. Constructing NIZK proofs (or even arguments) for NP from LWE is a long-standing open problem.</p>

    <p class="text-gray-300">NIZK arguments simultaneously satisfying adaptive soundness and statistical zero knowledge are currently only known from knowledge assumptions <em>[x1]</em>, so our construction is the first such NIZK proven secure under a complexity assumption.</p>

    <p class="text-gray-300">Prior works on instantiating the Fiat-Shamir heuristic in the standard model <em>[x16, x5, x10]</em> also give NIZK argument schemes for NP under qualitatively stronger assumptions than what is required in this work.</p>

    <p class="text-gray-300">Finally, while not explicitly noted in prior work, combining results of <em>[x4, x10]</em> yields a construction of NIZK arguments (in the common reference string model) from sub-exponentially secure indistinguishability obfuscation and VGB obfuscation. This is the only standard model application of Fiat-Shamir that we are aware of that does not require assuming nearly optimal hardness.</p>

    <h2 id="sec-13" class="text-2xl font-bold">2 Our Techniques</h2>

    <p class="text-gray-300">We now describe our contributions and high level proof ideas in more detail.</p>

    <p class="text-gray-300">2.1 Round-By-Round Soundness</p>

    <p class="text-gray-300">We provide a new soundness definition for interactive proofs that interacts well with the Fiat-Shamir transform. We say that a public-coin interactive proof <span class="math">\\Pi</span> for a language <span class="math">L</span> is round-by-round (RBR) sound if at any stage of the protocol there is a well-defined <em>state</em> (depending on the transcript thus far) and some of these states are “doomed”; in the sense that once doomed you will forever remain doomed. More specifically, the first requirement is that for <span class="math">x\\not\\in L</span>, the initial state (i.e., corresponding to the empty transcript) is doomed. Second, for every doomed state and every possible next message that a cheating prover might send, with overwhelming probability over the verifier’s next message, the protocol state will still be doomed. Lastly, we require that if at the end of the interaction the state is doomed then the verifier will reject (in particular, the state function is efficiently computable on <em>full</em> transcripts).</p>

    <p class="text-gray-300">An illustrative example of an interactive proof with round-by-round soundness is the celebrated sumcheck protocol of Lund <em>et al.</em> <em>[x13]</em>. Recall that the purpose of the sumcheck protocol is to allow the verifier to check a claim of the form <span class="math">\\sum_{x_{1},\\ldots,x_{m}\\in\\{0,1\\}}P(x_{1},\\ldots,x_{m})=\\mathbbm{v}</span>, where <span class="math">P:\\mathbb{F}^{m}\\to\\mathbb{F}</span> is an <span class="math">m</span>-variate polynomial (to which the verifier has oracle access) over a finite field <span class="math">\\mathbb{F}</span> and <span class="math">\\mathbbm{v}\\in\\mathbb{F}</span> is a fixed field element.</p>

    <p class="text-gray-300">The protocol proceeds as follows - the first message from the prover is the (univariate) polynomial <span class="math">g(\\cdot)=\\sum_{x_{2},\\ldots,x_{m}\\in\\{0,1\\}}P(\\cdot,x_{2},\\ldots,x_{m})</span>. Upon receiving some polynomial <span class="math">\\tilde{g}</span> (which may or may not be equal to the prescribed <span class="math">g</span>) from the prover, the verifier checks that it is indeed a low degree polynomial and that <span class="math">\\tilde{g}(0)+\\tilde{g}(1)=\\mathbbm{v}</span>. Observe that if the initial claim is false, then the prover must send a polynomial <span class="math">\\tilde{g}\\not\\equiv g</span> (or the verifier will immediately reject). Since <span class="math">g</span> and <span class="math">\\tilde{g}</span> are low degree polynomials, they must differ on many points. The idea then is for the verifier to select <span class="math">\\mathbbm{r}_{1}\\in\\mathbb{F}</span> at random and send <span class="math">\\mathbbm{r}_{1}</span> to the prover. Since <span class="math">g</span> and <span class="math">\\tilde{g}</span> differ on many points, with high probability <span class="math">\\tilde{g}(\\mathbbm{r}_{1})\\neq g(\\mathbbm{r}_{1})=\\sum_{x_{2},\\ldots,x_{m}\\in\\{0,1\\}}P(\\mathbbm{r}_{1},x_{2},\\ldots,x_{m})</span>. The point is that the latter equation is a sumcheck instance with respect to an <span class="math">(m-1)</span>-variate polynomial <span class="math">P^{\\prime}(x_{2},\\ldots,x_{m})\\stackrel{{\\scriptstyle\\text{def}}}{{=}}P(\\mathbbm{r}_{1},x_{2},\\ldots,x_{m})</span>, so the parties recursively run the sumcheck protocol on <span class="math">P^{\\prime}</span>.</p>

    <p class="text-gray-300">To see that the sumcheck protocol has round-by-round soundness we define a partial transcript as doomed if the initial claim for the corresponding step in the recursion is false. As explained above, the sumcheck protocol has the property that at any step of the recursion if we start with a false claim then, with overwhelming probability, we end up with a false claim for the next step in the recursion. This is exactly the meaning of round-by-round soundness. For further details, see Section 5.</p>

    <p class="text-gray-300">As one of our contributions, and toward establishing our main delegation result, in Section 6 we show that the GKR protocol for log-space uniform <span class="math">\\mathsf{NC}</span> also has round-by-round soundness.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Round-by-round Soundness and Fiat-Shamir.</h4>

    <p class="text-gray-300">Our primary motivation for defining round-by-round soundness is to instantiate the Fiat-Shamir transform in the standard model for protocols with a possibly super-constant number of rounds. Indeed, we show that a correlation-intractable hash family suffices for the soundness of the FS transform if the initial protocol is RBR-sound.</p>

    <p class="text-gray-300">To see this, fix any RBR-sound interactive proof <span class="math">\\Pi</span> along with an input <span class="math">x\\not\\in L</span>, and consider the</p>

    <p class="text-gray-300">relation:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R \\stackrel {\\text {d e f}} {=} \\left\\{ \\begin{array}{c} \\tau \\text {i s a d o o m e d p a r t i a l t r a n s c r i p t} \\\\ (\\tau , \\beta): \\quad \\text {a n d} \\\\ \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta \\text {i s n o t d o o m e d} \\end{array} \\right\\}</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">(where  <span class="math">\\tau</span>  is a partial transcript ending with a prover message and  <span class="math">\\beta</span>  is a verifier message).</p>

    <p class="text-gray-300">Round-by-round soundness ensures that  <span class="math">R</span>  is a sparse relation. Suppose we now apply the Fiat-Shamir transform to the interactive proof, while using a hash function  <span class="math">h</span>  that is  <span class="math">R</span> -correlation intractable. Suppose further that the (computational) soundness of the resulting non-interactive argument is broken. By definition of RBR soundness, this means that the cheating prover has efficiently found some partial transcript  <span class="math">\\tau</span>  and verifier message  <span class="math">\\beta = h(\\tau)</span>  such that  <span class="math">\\tau</span>  is doomed, but  <span class="math">(\\tau, \\beta)</span>  is not doomed. Thus, the prover can be used to find a pair  <span class="math">(\\tau, h(\\tau)) \\in R</span> , in contradiction to the correlation intractability of the hash function.</p>

    <p class="text-gray-300">Round-by-Round Soundness vs. State Restoration Attacks. A state restoration attack [BCS16] on an interactive proof (or more generally an interactive oracle proof) is a cheating prover strategy that is allowed to rewind the protocol to some previous state a limited number of times. Ben Sasson et al. showed that soundness against state restoration attacks suffices for compiling interactive proofs using the Fiat-Shamir in the random oracle model.[7]</p>

    <p class="text-gray-300">Negligible round-by-round soundness readily implies state restoration soundness for a polynomial number of rewinds. Although it seems reasonable that soundness against state restoration attacks would suffice for instantiating the Fiat-Shamir transform using a correlation interactable hash function (rather than in the random oracle model as shown in [BCS16]), we were unable to prove this.</p>

    <h2 id="sec-15" class="text-2xl font-bold">2.2 Bounded Correlation Intractable Hash Families</h2>

    <p class="text-gray-300">So far, we have shown that correlation intractable hash functions can be used to instantiate the Fiat-Shamir transform for the [GKR08] protocol, yielding pv-SNARGs. In addition, it was already known[8] [CCRR18,HL18] that correlation intractable hash families – with mild additional properties – are also sufficient to yield NIZK argument schemes for NP.</p>

    <p class="text-gray-300">The rest of this work focuses on new constructions of correlation intractable hash families that suffice to yield these applications. These constructions and security reductions all use as a first step (a parameterized version of) the main theorem of [CCRR18] (our Theorem 3.11), which shows how to interpret a secret-key encryption scheme as a correlation intractable hash family if the encryption scheme satisfies two properties (the first being a statistical property and the second a computational one):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Universal Ciphertexts: An encryption of a random message under any fixed secret key is distributed like an encryption of a random message under a random secret key. In particular, this means that ciphertexts are not attached to any one particular key.</li>

    </ol>

    <p class="text-gray-300">8</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. Nearly Optimal Bounded-KDM Security against Poly-size Adversaries: For any function <span class="math">f</span> computable by circuits of a fixed polynomial size, every adversary of arbitrary polynomial size can, given an encryption of <span class="math">f(k)</span> under a (uniformly random) key <span class="math">k</span>, can recover <span class="math">k</span> with probability at most $1/\\tilde{\\Omega}(2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$ - i.e., only a polynomial factor better than guessing.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The above property does not suffice to obtain correlation intractable hash families for <em>all</em> sparse relations; however, it <em>does</em> suffice to obtain hash families that are correlation intractable for all sparse relations that are <em>sampleable</em> in some fixed polynomial time. We note that the notion of “bounded correlation intractability” considered in this work is incomparable to that of <em>[x10]</em>; they consider correlation intractability for relations that are <em>decidable</em> in a fixed polynomial time.</p>

    <p class="text-gray-300">Since the relations arising from the <em>[x21]</em> protocol and a broad class (including <em>[x24]</em>) of 3-message zero knowledge proofs for NP satisfy the above notion of efficient sampleability, we have reduced the overall problem to constructing encryption schemes satisfying this weaker notion of bounded-KDM security.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">2.3 Constructing Optimal Bounded-KDM Secure Encryption</h3>

    <p class="text-gray-300">There is a long line of prior work on constructing bounded-KDM secure encryption schemes <em>[x1, x1, x3, x11, x12]</em>. Unfortunately, the <em>optimal</em> level of security stated above that we require is more stringent than was achieved by prior work (which considered any negligible success probability) and poses a significant technical problem, especially when combined with the universal ciphertexts requirement. Still, we show that some of the techniques and instantiations can be adapted to our setting.</p>

    <h5 id="sec-17" class="text-base font-semibold mt-4">Non-Compact CI from Search-LWE.</h5>

    <p class="text-gray-300">We construct an encryption scheme as above assuming the nearly optimal hardness of search-LWE for poly-time adversaries. Our construction follows the blueprint of <em>[x3]</em>, which shows that the class of functions for which an encryption scheme satisfies KDM security can be <em>amplified</em> using randomized encodings in the regime of polynomial-size adversaries with inverse polynomial success probabilities.</p>

    <p class="text-gray-300">Recall that a randomized encoding <em>[x1]</em> for a function <span class="math">f</span> is a randomized function <span class="math">\\tilde{f}</span> such that <span class="math">\\tilde{f}(x)</span> reveals exactly <span class="math">f(x)</span> and nothing else – i.e., there are algorithms RE.Dec and RE.Sim such that for all <span class="math">x</span>, RE.Dec(<span class="math">\\tilde{f}(x))=f(x)</span>, and RE.Sim(<span class="math">f(x))\\approx\\tilde{f}(x)</span>. The key point is achieving this so that the function <span class="math">\\tilde{f}</span> is significantly simpler than <span class="math">f</span> in some way. For example, Yao’s garbled circuits <em>[x39]</em> are a randomized encoding <span class="math">\\tilde{f}</span> for any polynomial-time computable <span class="math">f</span>, with the special property that for every <span class="math">r</span> and every input length <span class="math">n</span>, each bit of <span class="math">\\tilde{f}(x;r)</span> for <span class="math">x\\in\\{0,1\\}^{n}</span> is a projection of <span class="math">x</span> – that is, either a constant or <span class="math">x_{i}\\oplus b</span> for some fixed <span class="math">i\\in[n]</span> and fixed bit <span class="math">b</span>.</p>

    <p class="text-gray-300">Applebaum’s idea, following <em>[x11]</em>, was to construct an <span class="math">f</span>-KDM secure encryption scheme out of an encryption scheme <span class="math">\\mathcal{E}</span> that is <span class="math">\\tilde{f}(\\cdot\\,;r)</span>-KDM secure for every choice of randomness <span class="math">r</span>. Since <span class="math">\\tilde{f}</span> is simpler than <span class="math">f</span>, we have made progress. Specifically, the constructed scheme <span class="math">\\mathcal{E}^{\\prime}</span> encrypts messages as <span class="math">\\mathcal{E}^{\\prime}.\\texttt{Enc}(m)\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\mathcal{E}.\\texttt{Enc}(\\texttt{RE.Sim}(m))</span>, and correspondingly decrypts ciphertexts as <span class="math">\\mathcal{E}^{\\prime}.\\texttt{Dec}(\\texttt{ct})\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\texttt{RE.Dec}(\\mathcal{E}.\\texttt{Dec}(\\texttt{ct}))</span>. The point is that an adversary for <span class="math">\\mathcal{E}^{\\prime}</span> receives <span class="math">\\mathcal{E}^{\\prime}.\\texttt{Enc}(f(k))\\equiv\\mathcal{E}.\\texttt{Enc}(\\texttt{RE.Sim}(f(k)))\\approx\\mathcal{E}.\\texttt{Enc}(\\tilde{f}(k;r))</span> for some random <span class="math">r</span>, which still “protects” <span class="math">k</span> by the assumed</p>

    <p class="text-gray-300">KDM security of <span class="math">\\mathcal{E}</span>. This construction can also be modified to obtain a (single) encryption scheme that is simultaneously <span class="math">f</span>-KDM secure for all <span class="math">f</span> in a family <span class="math">\\mathcal{F}</span>. What is needed in this case is (1) a randomized encoding for a universal function <span class="math">U_{\\mathcal{F}}</span>, that takes as input a description of <span class="math">f \\in \\mathcal{F}</span> and an input <span class="math">x</span> and outputs <span class="math">f(x)</span>, and (2) an encryption scheme <span class="math">\\mathcal{E}</span> that is <span class="math">\\tilde{U}_{\\mathcal{F}}(f, \\cdot; r)</span>-KDM secure for every <span class="math">f</span> and <span class="math">r</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Crucially, we observe that the additional properties we require of <span class="math">\\mathcal{E}&#x27;</span>, namely universal ciphertexts and nearly optimal security, are inherited from <span class="math">\\mathcal{E}</span> as long as the randomized encoding scheme RE satisfies two additional properties. First (to ensure universal ciphertexts), RE should be blind [BLSV18]: for a uniformly random <span class="math">y</span>, RE.Sim(y) should also be uniformly random. Additionally, RE should be $1 / \\tilde{\\Omega}(2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})$-secure.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Bounded KDM Security from Binary-Secret Search-LWE.</strong> Our first approach for instantiating the above framework is to use point-and-permute garbled circuits [BMR90] in conjunction with the known circular security of binary-secret Regev encryption. Point-and-permute garbled circuits are perfectly blind [BLSV18], they yield a universal randomized encoding <span class="math">\\hat{U}</span> for all circuits of some fixed polynomial size, and Regev encryption with an appropriate noise distribution also has (perfectly) universal ciphertexts.</p>

    <p class="text-gray-300">In terms of security, the randomized encoding <span class="math">\\hat{U}</span> can also be made sufficiently secure if one-way functions exist that are <span class="math">2^{-\\lambda^{\\Omega(1)}}</span>-hard to invert for <span class="math">\\lambda^{O(1)}</span>-size adversaries. This assumption is in turn implied by our nearly-optimal Search-LWE assumption. As mentioned previously, for any fixed circuit <span class="math">C</span> and randomness <span class="math">r</span>, each bit of <span class="math">\\hat{U}(C,x;r)</span> is a projection of <span class="math">x</span>. Regev encryption with binary secrets is known to be KDM-secure with respect to such projections of the key, under the assumption that binary-secret Search-LWE is hard, and the reduction in fact preserves nearly optimal hardness [ACPS09].</p>

    <p class="text-gray-300">Combining point-and-permute garbled circuits with Regev encryption with binary secrets thus yields, for any polynomial <span class="math">S = S(n)</span>, an encryption scheme that has universal ciphertexts and is KDM-secure with respect to any size-<span class="math">S</span> computable functions.</p>

    <p class="text-gray-300"><strong>Bounded KDM Security from More General Search-LWE</strong> One unsettling aspect of the preceding construction is the reliance on binary-secret LWE, a variant for which algorithms empirically perform better [BG14]. Although we are not aware of attacks on binary-secret LWE that are successful enough to refute a nearly-optimal security conjecture, we still wish to base our constructions on a more general setting of parameters.</p>

    <p class="text-gray-300">We do so by turning to the encryption scheme of [ACPS09], a variant of Regev encryption whose KDM security reduces to Search-LWE with a secret distribution in which each coordinate has higher entropy. Specifically, the secret distribution is uniform over <span class="math">\\left[-\\frac{p}{2}, \\frac{p}{2}\\right)^n</span>, and the noise distribution is uniform over <span class="math">\\left[-\\frac{q&#x27;}{2}, \\frac{q&#x27;}{2}\\right)^\\ell</span>, for a modulus <span class="math">q = pq&#x27;</span> and a prime <span class="math">p</span>. Unfortunately, the KDM security of this scheme is with respect to affine functions over <span class="math">\\mathbb{Z}_p</span>. In particular, this scheme is not known to be secure with respect to bit-by-bit encryptions of its secret key.</p>

    <p class="text-gray-300">To address this difficulty, we construct a new blind randomized encoding from sub-exponentially secure one-way functions for the function <span class="math">U_{p}</span> that takes as input a boolean circuit <span class="math">C:\\mathbb{Z}_p^n\\to \\{0,1\\}^\\ell</span> (with elements of <span class="math">\\mathbb{Z}_p^n</span> encoded in binary), an input <span class="math">x\\in \\mathbb{Z}_p^n</span>, and outputs <span class="math">C(x)</span>. Our construction</p>

    <p class="text-gray-300">10Specifically, let the modulus q be even, and take the noise distribution to be uniform on the interval [-q / 4,q / 4) . With a limited number of samples (as is the case in our application), Search-LWE with this setting of parameters reduces to the more typical "narrow discrete Gaussian" noise by a "drowning out the noise" technique.</p>

    <p class="text-gray-300">has the property that for any  <span class="math">C</span>  and any  <span class="math">r</span> , the function  <span class="math">\\hat{U}_p(C, \\cdot; r)</span>  is  <span class="math">\\mathbb{Z}_p</span> -affine, which renders our construction suitable for amplifying the KDM security of [ACPS09].</p>

    <p class="text-gray-300">Our construction composes two (blind) randomized encodings.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Point-and-permute garbled circuits, which give an encoding  <span class="math">\\hat{U}_{\\mathrm{bin}}</span>  of the function  <span class="math">U_{\\mathrm{bin}}</span>  that maps  <span class="math">(C,x)\\mapsto C(x)</span> , where  <span class="math">C:\\mathbb{Z}_p^n\\to \\{0,1\\}^\\ell</span>  is a boolean circuit, and  <span class="math">x\\in \\mathbb{Z}_p^n</span>  is an input. The advantage of this scheme is that it supports arbitrary, e.g. high-depth circuits. On the other hand,  <span class="math">\\hat{U}_{\\mathrm{bin}}(C,\\cdot ;r)</span>  is a projection of the binary representation of  <span class="math">x</span> , instead of a  <span class="math">\\mathbb{Z}_p</span> -affine function of  <span class="math">x</span> .</li>

      <li>An encoding  <span class="math">\\hat{U}_{\\mathrm{proj}}</span>  for projections  <span class="math">\\pi : \\mathbb{Z}_p^n \\to \\{0,1\\}</span> , where for any  <span class="math">\\pi</span> , the function  <span class="math">\\hat{U}_{\\mathrm{proj}}(\\pi, \\cdot; r)</span>  is affine over  <span class="math">\\mathbb{Z}_p</span> . Such a randomized encoding follows from a (modified) result of [AIK11] (hereafter AIK), which states that any function  <span class="math">f</span>  computable by a uniform depth- <span class="math">d</span>  arithmetic circuit (ensemble)  <span class="math">\\{C_n : \\mathbb{Z}_p^n \\to \\mathbb{Z}_p\\}_n</span>  has a perfectly secure, perfectly blind randomized encoding  <span class="math">\\hat{f}</span>  such that  <span class="math">\\hat{f}(\\cdot; r)</span>  is affine over  <span class="math">\\mathbb{Z}_p</span>  for every  <span class="math">r</span> . Specifically, we represent  <span class="math">\\pi</span>  by a vector  <span class="math">\\mathbf{e} \\in \\{0,1\\}^{n \\cdot \\lceil \\log p \\rceil}</span>  (with at most one 1) and a bit  <span class="math">b</span>  such that  <span class="math">\\pi(x) = \\langle \\mathbf{e}, [[x]] \\rangle \\oplus b</span> , where  <span class="math">[[x]]</span>  denotes the binary representation of  <span class="math">x</span> . Then we use the AIK encoding of</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">U _ {\\text {p r o j}} \\left(\\left(\\mathbf {e}, b\\right), x\\right) = \\left\\langle \\mathbf {e}, \\llbracket x \\rrbracket \\right\\rangle \\oplus b = \\begin{array}{c} b \\cdot \\left(\\sum_ {i = 1} ^ {n \\cdot \\lceil \\log p \\rceil} e _ {i} \\cdot \\llbracket x \\rrbracket_ {i}\\right) \\\\ + \\\\ (1 - b) \\cdot \\left(1 - \\sum_ {i = 1} ^ {n \\cdot \\lceil \\log p \\rceil} e _ {i} \\cdot \\llbracket x \\rrbracket_ {i}\\right). \\end{array} \\tag {1}</span></div>

    <p class="text-gray-300"><span class="math">U_{\\mathrm{proj}}</span>  is computable by a depth  <span class="math">O(\\log n + \\log p)</span>  and size  <span class="math">\\tilde{O}(n \\cdot p)</span>  arithmetic circuit over  <span class="math">\\mathbb{Z}_p</span>  by applying the formula</p>

    <div class="my-4 text-center"><span class="math-block">\\llbracket x _ {j} \\rrbracket_ {k} = \\sum_ {y \\in \\mathbb {Z} _ {p}: \\llbracket y \\rrbracket_ {k} = 1} (1 - (y - x _ {j}) ^ {p - 1})</span></div>

    <p class="text-gray-300">to compute each  <span class="math">\\llbracket x\\rrbracket_{i}</span></p>

    <p class="text-gray-300">A first attempt at composition defines  <span class="math">\\hat{U}_p(C,x;r_{\\mathrm{proj}},r_{\\mathrm{bin}})\\stackrel {\\mathrm{def}}{=}\\hat{U}_{\\mathrm{proj}}(\\hat{U}_{\\mathrm{bin}}(C,\\cdot ;r_{\\mathrm{bin}}),x;r_{\\mathrm{proj}})</span> , but this (with the natural simulator) is not blind. The issue is that the simulator for  <span class="math">\\hat{U}_{\\mathrm{bin}}</span>  produces a uniformly random string with alphabet  <span class="math">\\{0,1\\}</span> , but the AIK simulator for  <span class="math">\\hat{U}_{\\mathrm{proj}}</span>  requires a uniformly random string with alphabet  <span class="math">\\mathbb{Z}_p</span>  for its output to be uniformly random (also with alphabet  <span class="math">\\mathbb{Z}_p</span> ).</p>

    <p class="text-gray-300">To remedy this, we modify  <span class="math">\\hat{U}_{\\mathrm{proj}}</span> . To start, we partition  <span class="math">\\mathbb{Z}_p</span>  into two sets of nearly equal size,  <span class="math">\\mathbb{Z}_p = P^{(0)} \\sqcup P^{(1)}</span> , and define a function  <span class="math">U_{\\mathrm{proj}}&#x27;</span>  that, compared to  <span class="math">U_{\\mathrm{proj}}</span>  takes two additional inputs  <span class="math">r^{(0)}</span>  and  <span class="math">r^{(1)}</span> . On input  <span class="math">((\\mathbf{e}, b, r^{(0)}, r^{(1)}), x)</span> ,  <span class="math">U_{\\mathrm{proj}}&#x27;</span>  outputs  <span class="math">r^{(\\langle \\mathbf{e}, [[x]] \\rangle \\oplus b)}</span>  (this can be done by a low-depth circuit analogous to Eq. (1)). We then redefine  <span class="math">\\hat{U}_{\\mathrm{proj}}</span>  so that  <span class="math">\\hat{U}_{\\mathrm{proj}}((\\mathbf{e}, b), x)</span>  samples  <span class="math">r^{(0)} \\gets P^{(0)}</span>  and  <span class="math">r^{(1)} \\gets P^{(1)}</span> , then returns the AIK encoding  <span class="math">\\hat{U}_{\\mathrm{proj}}&#x27;((\\mathbf{e}, b, r^{(0)}, r^{(1)}), x)</span> . The new decoder for  <span class="math">\\hat{U}_{\\mathrm{proj}}</span>  evaluates the AIK decoder for  <span class="math">\\hat{U}_{\\mathrm{proj}}&#x27;</span> , obtaining  <span class="math">y&#x27; \\in \\mathbb{Z}_p</span> , and outputs  <span class="math">b</span>  if  <span class="math">y&#x27; \\in P^{(b)}</span> . The new simulator for  <span class="math">\\hat{U}_{\\mathrm{proj}}</span>  on input  <span class="math">b</span>  samples  <span class="math">y&#x27; \\gets P^{(b)}</span> , and then returns the output of the AIK simulator for  <span class="math">\\hat{U}_{\\mathrm{proj}}&#x27;</span>  on  <span class="math">y&#x27;</span> .</p>

    <p class="text-gray-300">This nearly completes the description of our randomized encoding, except for one subtle issue. For any odd prime  <span class="math">p</span> , it is impossible for a partition  <span class="math">\\mathbb{Z}_p = P^{(0)} \\sqcup P^{(1)}</span>  to be exactly balanced. This</p>

    <p class="text-gray-300">11</p>

    <p class="text-gray-300">causes the randomized encoding to only be approximately blind, where our notion of approximation is the Renyi divergence (rather than statistical difference) between the simulator output distribution and the uniform distribution. To suitably decrease the approximation error, we need to replace <span class="math">\\mathbb{Z}_{p}</span> by <span class="math">\\mathbb{Z}_{p}^{k}</span> for a sufficiently large <span class="math">k</span>.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">A Compact Family From FHE.</h4>

    <p class="text-gray-300">While the above hash families suffice to obtain NIZK argument schemes, they do not yield pv-SNARGs when combined with the <em>[x14]</em> protocol. This is because in the above hash family, the description of a hash function (and the complexity of hashing) grows polynomially with the complexity of the sampling algorithms of the relations <span class="math">R</span> for which correlation intractability holds. In order to obtain pv-SNARGs, we require a hash family (corresponding to an encryption scheme) that is <span class="math">\\mathsf{SIZE}(S)</span>-correlation intractable, but yet consists of functions that are evaluable in time much less than <span class="math">S</span>. We in fact construct something stronger – a single hash family that is correlation intractable against all relations that are sampleable by polynomial-size circuits.</p>

    <p class="text-gray-300">This construction also adapts KDM-security amplification techniques in the literature; instead of using randomized encodings <em>[x1]</em>, we use fully homomorphic encryption to amplify KDM-security. In particular, <em>[x3]</em> observe that any circularly secure FHE scheme satisfying a strong form of evaluation correctness is also KDM-secure for arbitrary polynomial functions of the secret key. The basic <em>[x3]</em> idea is that an adversary can homomorphically generate encryptions of <span class="math">f(k)</span> from the encryption of <span class="math">k</span> (for efficiently computable functions <span class="math">f</span>).</p>

    <p class="text-gray-300">The <em>[x3]</em> observation suggests the following plan to obtain the CI hash families that we desire: start with a FHE scheme that has universal ciphertexts and (sufficiently strong) circular security, and invoke an appropriately modified <em>[x3]</em> argument. However, there are two major flaws in this plan.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>No fully homomorphic encryption scheme in the literature has (anything remotely resembling) universal ciphertexts. Indeed, all schemes in the literature utilize (at the very least) some form of a low-noise Regev encryption, which itself is very far from having universal ciphertexts. A low-noise Regev ciphertext <span class="math">(A,b)</span> under secret key <span class="math">s</span> has the property that <span class="math">s^{t}A-b</span> is close to either <span class="math">0</span> or <span class="math">\\frac{q}{2}</span>, and therefore Regev encryption is not universal.</li>

      <li>It is not clear how to adapt the <em>[x3]</em> security reduction (that relies on a generic FHE scheme) to the setting of (near-)optimal security. This is because <em>[x3]</em> relies on a FHE scheme with the following strong correctness property: the distribution <span class="math">\\mathsf{Eval}(f,\\mathsf{Enc}(x))</span> is statistically indistinguishable from an encryption of <span class="math">f(x)</span>. In the setting of near-optimal security, a naive application of the <em>[x3]</em> argument would require an extreme form of this correctness property that does not hold for existing FHE schemes in the literature.</li>

    </ul>

    <p class="text-gray-300">As a result of these problems, we deviate from the plan above in order to achieve unbounded polynomial correlation intractability. Instead of directly working with a fully homomorphic encryption scheme in the construction, we consider secret-key Regev encryption, with secret keys uniformly distributed over a moderately sized interval <span class="math">[-B,B)^{n}\\subset\\mathbb{Z}_{q}^{n}</span>, and noise distribution <span class="math">[-q/4,q/4)</span>. This setting of parameters (which by design yields a scheme with universal ciphertexts) was proposed</p>

    <p class="text-gray-300">by <em>[x10]</em>, and should be contrasted with the typical Regev encryption scheme in which the secret is uniform in <span class="math">\\mathbb{Z}_{q}^{n}</span> but the noise must be smaller to allow for correct decryption.</p>

    <p class="text-gray-300">We prove that this encryption scheme satisfies unbounded polynomial KDM-security using some associated FHE scheme <em>in the security proof</em>.</p>

    <p class="text-gray-300">The KDM security of Regev encryption with these parameters follows from two main observations.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Many natural fully homomorphic encryption schemes (e.g., <em>[x1, x2, x3, x12, x11]</em>) contain a <em>low-noise</em> instantiation of Regev encryption “embedded” within them. That is, from any homomorphically evaluated ciphertext that decrypts to <span class="math">m</span> under an FHE key <span class="math">s</span>, one can efficiently extract a small-noise <em>Regev</em> encryption of <span class="math">m</span> under <span class="math">s</span>. We call this property Regev-extractability.</li>

      <li>Any Regev ciphertext with small noise (which may be arbitrary and malicious) can be re-randomized to obtain a Regev ciphertext whose noise distribution is statistically approximately uniform over <span class="math">[-q/4,q/4)^{m}</span>.</li>

    </ol>

    <p class="text-gray-300">Combining (1) and (2) yields a multiplicatively advantage-preserving reduction from the KDM security of high-noise Regev to the circular security of the (low-noise) Regev-extractable FHE scheme. At a high level, the reduction works as follows: given FHE-circular ciphertexts <span class="math">\\{\\mathsf{ct}_{i}=\\mathsf{FHE.Enc}(\\mathsf{sk},\\mathsf{sk}_{i})\\}_{i}</span>, one can homomorphically compute a (non-random) FHE-ciphertext corresponding to an arbitrary polynomial function <span class="math">f(\\mathsf{sk})</span>. Then, a secret-key Regev ciphertext of <span class="math">f(\\mathsf{sk})</span> can be extracted from this FHE-ciphertext, and the Regev ciphertext can be re-randomized to obtain an approximately uniform Regev encryption of <span class="math">f(\\mathsf{sk})</span>. Thus, an algorithm that recovers <span class="math">\\mathsf{sk}</span> from a Regev encryption of <span class="math">f(\\mathsf{sk})</span> with better-than-trivial probability can be used to achieve the same key recovery success for the FHE scheme.</p>

    <p class="text-gray-300">We note that a crucial aspect of the analysis is the use of Renyi divergence rather than total variational (aka, statistical) distance in characterizing the re-randomization sampling error.</p>

    <h2 id="sec-19" class="text-2xl font-bold">3 Correlation Intractability from KDM-Secure Encryption</h2>

    <p class="text-gray-300">This section recalls the definitions of correlation intractable (CI) hash functions and encryption schemes that are secure against key-dependent message (KDM) attacks, as well as the <em>[x10]</em> construction of CI hash functions from strong KDM secure encryption.</p>

    <p class="text-gray-300">Since this work crucially relies on finer-grained notions of indistinguishability and security against resource bounded adversaries, we first fix the following notation, which is more fine-grained than the standard one. We say that two distribution ensembles <span class="math">\\{X_{\\lambda}\\}</span> and <span class="math">\\{Y_{\\lambda}\\}</span> are <span class="math">(s(\\lambda),\\delta(\\lambda))</span>-indistinguishable if for all <span class="math">O(s(\\lambda))</span>-sized circuit ensembles <span class="math">\\{\\mathcal{A}_{\\lambda}\\}</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\Pr\\left[\\mathcal{A}_{\\lambda}(X_{\\lambda})=1\\right]-\\Pr\\left[\\mathcal{A}_{\\lambda}(Y_{\\lambda})=1\\right]\\Big{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq O(\\delta(\\lambda)).$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">If <span class="math">\\{X_{\\lambda}\\}</span> and <span class="math">\\{Y_{\\lambda}\\}</span> are <span class="math">(\\lambda^{c},\\delta)</span>-indistinguishable for all <span class="math">c&gt;0</span> then we say they they are <span class="math">\\delta</span>-<em>indistinguishable</em>. If <span class="math">\\{X_{\\lambda}\\}</span> and <span class="math">\\{Y_{\\lambda}\\}</span> are <span class="math">(\\lambda^{c},1/\\lambda^{c})</span>-indistinguishable for all <span class="math">c&gt;0</span> then we say they they are <em>polynomially indistinguishable</em>. Throughout, we extend this notational convention also to other primitives and their security.</p>

    <p class="text-gray-300">3.1 Correlation Intractable Hash Functions</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Definition 3.1.</h6>

    <p class="text-gray-300">A <em>hash family</em> is a collection <span class="math">\\mathcal{H}=\\{h_{\\lambda}:\\mathcal{I}_{\\lambda}\\times X_{\\lambda}\\to Y_{\\lambda}\\}_{\\lambda\\in\\mathbb{Z}^{+}}</span> of keyed hash functions such that <span class="math">\\{\\mathcal{I}_{\\lambda}\\}</span> is uniformly <span class="math">\\operatorname{poly}(\\lambda)</span>-time sampleable and <span class="math">\\{h_{\\lambda}\\}</span> is uniformly <span class="math">\\operatorname{poly}(\\lambda)</span>-time evaluable.</p>

    <p class="text-gray-300">We will also write <span class="math">\\mathcal{H}_{\\lambda}</span> to denote the distribution on functions <span class="math">h_{\\lambda}(I,\\cdot)</span> obtained by sampling <span class="math">I\\leftarrow\\mathcal{I}_{\\lambda}</span>.</p>

    <p class="text-gray-300">The above definition details the <em>functionality</em> of a hash function; there are several security notions that one could require. We focus on (single input) correlation intractability, as put forth by Canetti <em>et al.</em> <em>[x11]</em>.</p>

    <h6 id="sec-21" class="text-base font-medium mt-4">Definition 3.2 (Correlation Intractability).</h6>

    <p class="text-gray-300">For a given relation ensemble <span class="math">R=\\{R_{\\lambda}\\subseteq X_{\\lambda}\\times Y_{\\lambda}\\}</span>, a hash family <span class="math">\\mathcal{H}=\\{h_{\\lambda}:\\mathcal{I}_{\\lambda}\\times X_{\\lambda}\\to Y_{\\lambda}\\}_{\\lambda\\in\\mathbb{Z}^{+}}</span> is said to be <span class="math">R</span>-correlation intractable if for every polynomial-size <span class="math">\\mathcal{A}=\\{\\mathcal{A}_{\\lambda}\\}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}I\\leftarrow\\mathcal{I}_{\\lambda}\\\\ x\\leftarrow\\mathcal{A}_{\\lambda}(I)\\end{subarray}}\\Big{[}\\big{(}x,h_{\\lambda}(I,x)\\big{)}\\in R_{\\lambda}\\Big{]}\\leq\\lambda^{-\\omega(1)}. \\]</p>

    <p class="text-gray-300">Correlation intractability is a useful and versatile property of random oracles that we would like to guarantee in the standard model. However, even a random oracle is only <span class="math">R</span>-correlation intractable for <em>sparse</em> relations <span class="math">R</span>.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Definition 3.3 (Sparsity).</h6>

    <p class="text-gray-300">For any relation ensemble <span class="math">R=\\{R_{\\lambda}\\subseteq X_{\\lambda}\\times Y_{\\lambda}\\}</span>, we say that <span class="math">R</span> is <span class="math">\\rho(\\cdot)</span>-<em>sparse</em> if for <span class="math">\\lambda\\in\\mathbb{Z}^{+}</span> and any <span class="math">x\\in X_{\\lambda}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr_{y\\leftarrow Y_{\\lambda}}\\big{[}(x,y)\\in R_{\\lambda}\\big{]}\\leq\\rho(\\lambda).</span></p>

    <p class="text-gray-300">When <span class="math">\\rho</span> is a negligible function, we say simply that <span class="math">R</span> is <em>sparse</em>.</p>

    <p class="text-gray-300">An important complexity measure of a relation <span class="math">R</span> for the purpose of achieving correlation intractability is the complexity of <em>sampling</em> from the relation. More formally, we define (following <em>[x20]</em>) what it means for a relation <span class="math">R</span> to be <em>efficiently (approximately) samplable</em>.</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Definition 3.4.</h6>

    <p class="text-gray-300">A distribution <span class="math">P</span> <em>multiplicatively</em> <span class="math">\\epsilon</span>-approximates a distribution <span class="math">Q</span> if for all outcomes <span class="math">\\omega</span>, it holds that <span class="math">P(\\omega)\\geq\\epsilon\\cdot Q(\\omega)</span>.</p>

    <p class="text-gray-300">We note that if <span class="math">P</span> multiplicatively <span class="math">\\epsilon</span>-approximates a distribution <span class="math">Q</span>, then it also holds for all <em>events</em> <span class="math">E</span>, that <span class="math">P(E)\\geq\\epsilon\\cdot Q(E)</span>.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition 3.5 (Approximate Samplability of Relations).</h6>

    <p class="text-gray-300">A relation ensemble <span class="math">R=\\{R_{\\lambda}\\subseteq X_{\\lambda}\\times Y_{\\lambda}\\}</span> is <em>non-uniformly efficiently</em> <span class="math">\\epsilon</span>-approximately <em>samplable</em> if there is a <span class="math">\\operatorname{poly}(\\lambda)</span>-sized circuit ensemble <span class="math">\\{\\mathsf{Samp}_{\\lambda}\\}</span> such that for every <span class="math">(x,y)\\in R_{\\lambda}</span>, the distribution <span class="math">\\mathsf{Samp}_{\\lambda}(x)</span> multiplicatively <span class="math">\\epsilon</span>-approximates the uniform distribution on the (by assumption, non-empty) set <span class="math">\\{y^{\\prime}\\in Y_{\\lambda}\\,:\\,(x,y^{\\prime})\\in R\\}</span>.</p>

    <p class="text-gray-300">We say that <span class="math">R</span> is (non-uniformly) efficiently approximately samplable if it is non-uniformly <span class="math">\\epsilon</span>-approximately samplable for some <span class="math">\\epsilon\\geq\\frac{1}{\\operatorname{poly}(n)}</span>.</p>

    <h6 id="sec-25" class="text-base font-medium mt-4">Remark 3.1 (Domain Translation).</h6>

    <p class="text-gray-300">Throughout this paper, we make use of the following fact: if <span class="math">\\mathcal{R}</span> is a sparse ensemble of relations <span class="math">\\{R_{\\lambda}\\subseteq X_{\\lambda}^{\\prime}\\times Y_{\\lambda}\\}</span>, then the ensemble <span class="math">\\mathcal{R}^{\\prime}</span> obtained by viewing each <span class="math">R_{\\lambda}</span> as a subset of <span class="math">X_{\\lambda}\\times Y_{\\lambda}</span> via some embedding <span class="math">f_{\\lambda}:X_{\\lambda}^{\\prime}\\to X_{\\lambda}</span> is also sparse. Moreover, if <span class="math">\\mathcal{R}</span> is efficiently sampleable and if <span class="math">\\{f_{\\lambda}^{-1}\\}</span> is efficiently sampleable, then <span class="math">\\mathcal{R}^{\\prime}</span> is also efficiently sampleable.</p>

    <p class="text-gray-300">This result is used implicitly, e.g. to view a correlation-intractable hash family mapping <span class="math">\\mathbb{Z}_{p}^{n}\\to\\{0,1\\}^{\\ell}</span> as a correlation-intractable hash family mapping <span class="math">\\{0,1\\}^{n\\cdot\\lfloor\\log p\\rfloor}\\to\\{0,1\\}^{\\ell}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">15</p>

    <h2 id="sec-26" class="text-2xl font-bold">3.2 Encryption Schemes and Key-Dependent Message (KDM) Security</h2>

    <p class="text-gray-300"><strong>Definition 3.6.</strong> A secret-key encryption scheme (SKE) <span class="math">\\mathcal{E}</span> with message space <span class="math">\\mathcal{M} = \\{\\mathcal{M}_{\\lambda}\\}</span> consists of <span class="math">\\mathrm{poly}(\\lambda)</span>-time sampleable key distributions <span class="math">\\{\\mathcal{K}_{\\lambda}\\}_{\\lambda}</span> along with <span class="math">\\mathrm{poly}(\\lambda)</span>-time evaluable functions <span class="math">\\mathsf{Enc} = \\{\\mathsf{Enc}_{\\lambda}\\}_{\\lambda}</span> and <span class="math">\\mathsf{Dec} = \\{\\mathsf{Dec}_{\\lambda}\\}_{\\lambda}</span> (where <span class="math">\\mathsf{Enc}_{\\lambda}</span> may be probabilistic) satisfying that for all <span class="math">\\lambda</span>, all <span class="math">m \\in \\mathcal{M}_{\\lambda}</span>, and all <span class="math">k \\in \\mathcal{K}_{\\lambda}</span>, it holds with probability 1 that <span class="math">\\mathsf{Dec}_{\\lambda}(k, \\mathsf{Enc}_{\\lambda}(k, m)) = m</span>.</p>

    <p class="text-gray-300">In the special case that <span class="math">\\mathcal{M}_{\\lambda} = \\{0,1\\}</span> for every <span class="math">\\lambda</span>, we say that <span class="math">\\mathcal{E}</span> is a secret-key bit-encryption scheme.</p>

    <p class="text-gray-300"><strong>Definition 3.7.</strong> A secret-key encryption scheme <span class="math">\\mathcal{E} = \\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\}_{\\lambda}</span> with message space <span class="math">\\mathcal{M}_{\\lambda}</span> has universal ciphertexts if for any secret key <span class="math">k\\in \\mathcal{K}_{\\lambda}</span>, the distribution <span class="math">\\mathsf{Enc}(k,\\mathcal{U}_{\\mathcal{M}_{\\lambda}})</span> multiplicatively <span class="math">\\frac{1}{\\mathrm{poly}(\\lambda)}</span>-approximates the distribution <span class="math">\\mathsf{Enc}(\\mathcal{K}_{\\lambda},\\mathcal{U}_{\\mathcal{M}_{\\lambda}})</span>, where <span class="math">\\mathcal{U}_{\\mathcal{M}_{\\lambda}}</span> denotes the uniform distribution on <span class="math">\\mathcal{M}_{\\lambda}</span>.</p>

    <p class="text-gray-300"><strong>Definition 3.8.</strong> A secret-key fully homomorphic bit-encryption (FHE) scheme consists of distributions <span class="math">\\{\\mathcal{K}_{\\lambda}\\}</span>, probabilistic functions <span class="math">\\{\\mathsf{Enc}_{\\lambda}\\}</span>, and functions <span class="math">\\{\\mathsf{Dec}_{\\lambda},\\mathsf{Eval}_{\\lambda}\\}</span> such that:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1. <span class="math">\\{\\mathcal{K}_{\\lambda}\\}</span> is <span class="math">\\mathrm{poly}(\\lambda)</span>-time sampleable, <span class="math">\\{\\mathsf{Enc}_{\\lambda}\\}</span> and <span class="math">\\{\\mathsf{Dec}_{\\lambda}\\}</span> are <span class="math">\\mathrm{poly}(\\lambda)</span>-time evaluable, and <span class="math">\\mathsf{Eval}_{\\lambda}(\\mathsf{ek}, C, \\mathsf{ct}_1, \\ldots, \\mathsf{ct}_n)</span> is computable in $\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, n, \\lambda)$ time.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{K}_{\\lambda}^{(\\mathrm{sk})}</span> denotes the distribution of <span class="math">\\mathrm{sk}</span> when sampling <span class="math">(\\mathrm{sk}, \\mathrm{ek}) \\gets \\mathcal{K}_{\\lambda}</span>, then <span class="math">\\mathcal{E}&#x27; \\stackrel{\\mathrm{def}}{=} \\{(\\mathcal{K}_{\\lambda}^{(\\mathrm{sk})}, \\mathsf{Enc}_{\\lambda}, \\mathsf{Dec}_{\\lambda})\\}</span> is a secret-key bit-encryption scheme, which we call the underlying secret-key bit-encryption scheme of <span class="math">\\mathcal{E}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">(\\mathsf{sk},\\mathsf{ek})\\in \\mathcal{K}_{\\lambda}</span>, any <span class="math">m_{1},\\ldots ,m_{n}\\in \\{0,1\\}</span>, and any circuit <span class="math">C:\\{0,1\\}^n\\to \\{0,1\\}</span>, it holds with probability 1 that</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Dec}_{\\lambda}\\left(\\operatorname{sk}, \\operatorname{Eval}_{\\lambda}\\left(\\operatorname{ek}, C, \\operatorname{Enc}_{\\lambda}(\\operatorname{sk}, m_{1}), \\dots, \\operatorname{Enc}_{\\lambda}(\\operatorname{sk}, m_{n})\\right)\\right) = C(m_{1}, \\dots, m_{n}).</span></div>

    <p class="text-gray-300"><strong>Definition 3.9.</strong> If <span class="math">\\mathcal{E}</span> is a secret-key encryption scheme <span class="math">\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\}</span> with message space <span class="math">\\mathcal{M}_{\\lambda}</span>, and if <span class="math">f = \\{f_{\\lambda}:\\mathcal{K}_{\\lambda}\\stackrel {\\S}{\\to}\\mathcal{M}_{\\lambda}^{*}\\}</span> is any (potentially probabilistic) function, then <span class="math">\\mathcal{E}</span> is said to be <span class="math">\\delta (\\cdot)</span>-immune to key recovery by an <span class="math">f</span>-KDM query if for all polynomial-size <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}_{\\substack{K\\gets \\mathcal{K}_{\\lambda}\\\\ (M_{1},\\ldots ,M_{\\ell})\\gets f_{\\lambda}(K)\\\\ \\{C_{i}\\gets \\mathsf{Enc}_{\\lambda}(K,M_{i})\\}_{i\\in [\\ell]}}[\\mathcal{A}_{\\lambda}(C_{1},\\ldots ,C_{\\ell}) = K]\\leq \\delta (\\lambda).</span></div>

    <p class="text-gray-300">If <span class="math">\\mathcal{E}</span> is a secret-key fully homomorphic bit-encryption scheme, we say that <span class="math">\\mathcal{E}</span> is <span class="math">\\delta(\\cdot)</span>-immune to key recovery by an <span class="math">f</span>-KDM query if for all polynomial-size <span class="math">\\mathcal{A} = \\{\\mathcal{A}_{\\lambda}\\}</span>, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname{Pr}_{\\substack{(K,E)\\gets \\mathcal{K}_{\\lambda}\\\\ (M_{1},\\ldots ,M_{\\ell})\\gets f_{\\lambda}(K)\\\\ \\{C_{i}\\gets \\mathsf{Enc}_{\\lambda}(K,M_{i})\\}_{i\\in [\\ell]}}[\\mathcal{A}_{\\lambda}(E,C_{1},\\ldots ,C_{\\ell}) = K]\\leq \\delta (\\lambda).</span></div>

    <p class="text-gray-300">In either case, throughout this paper we will abbreviate the above by saying that <span class="math">\\mathcal{E}</span> is <span class="math">f</span>-KDM <span class="math">\\delta</span>-secure. If <span class="math">\\mathcal{F}</span> is a set of functions then we say that <span class="math">\\mathcal{E}</span> is <span class="math">\\mathcal{F}</span>-KDM <span class="math">\\delta</span>-secure if <span class="math">\\mathcal{E}</span> is <span class="math">f</span>-KDM <span class="math">\\delta</span>-secure for all <span class="math">f \\in \\mathcal{F}</span>.</p>

    <p class="text-gray-300">3.3 Correlation Intractability from Strong KDM Security</p>

    <p class="text-gray-300">In this section, we recall the generic transformation of <em>[x1]</em> and state a stronger version of their main theorem (that follows from their security proof). The differences are explained immediately after the theorem statement.</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Construction 3.10 (CCRR Hash Family).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}=\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\}</span> be any secret key encryption scheme with message space <span class="math">\\{0,1\\}^{\\ell}</span> for <span class="math">\\ell=\\ell(\\lambda)</span>. The CCRR hash family associated to this encryption scheme, denoted <span class="math">\\mathcal{H}_{\\mathsf{CCRR}}^{\\mathcal{E}}</span>, is</p>

    <p class="text-gray-300"><span class="math">\\mathcal{H}_{\\mathsf{CCRR}}^{\\mathcal{E}}=\\left\\{h_{\\lambda}:\\mathcal{I}_{\\lambda}\\times\\mathcal{K}_{\\lambda}\\to\\{0,1\\}^{\\ell}\\right\\}_{\\lambda}</span></p>

    <p class="text-gray-300">where</p>

    <p class="text-gray-300"><span class="math">h_{\\lambda}(C,x):=\\mathsf{Dec}_{\\lambda}(x,C),</span></p>

    <p class="text-gray-300">and the distribution <span class="math">\\mathcal{I}_{\\lambda}</span> is a random ciphertext <span class="math">C</span> obtained by sampling <span class="math">K\\leftarrow\\mathcal{K}_{\\lambda}</span> along with <span class="math">M\\leftarrow\\{0,1\\}^{\\ell}</span> and defining <span class="math">C:=\\mathsf{Enc}_{\\lambda}(K,M)</span>.</p>

    <p class="text-gray-300">The following theorem, which is based on <em>[x1]</em>, shows that the hash family associated with any encryption scheme that (1) has universal ciphertexts (see Definition 3.7) and (2) is exponentially KDM secure (see Definition 3.9), is suitable for the Fiat-Shamir transform.</p>

    <h6 id="sec-28" class="text-base font-medium mt-4">Theorem 3.11.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}=\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\}</span> be a secret key encryption scheme with universal ciphertexts, message space <span class="math">\\{0,1\\}^{\\ell}</span>, and key space <span class="math">\\mathcal{K}_{\\lambda}</span> equal to the uniform distribution on <span class="math">\\{0,1\\}^{\\kappa}</span> for some <span class="math">\\kappa=\\kappa(\\lambda)</span>. If <span class="math">\\mathcal{E}</span> is <span class="math">\\mathcal{F}</span>-KDM <span class="math">\\delta</span>-secure and <span class="math">R</span> is a <span class="math">\\rho</span>-sparse relation that is <span class="math">\\lambda^{-O(1)}</span>-approximately <span class="math">\\mathcal{F}</span>-sampleable, then <span class="math">\\mathcal{H}_{\\mathsf{CCRR}}^{\\mathcal{E}}</span> is <span class="math">R</span>-correlation <span class="math">\\frac{2^{-\\kappa}}{\\delta(\\lambda)\\cdot\\rho(\\lambda)}\\cdot\\lambda^{-O(1)}</span>-intractable.</p>

    <h6 id="sec-29" class="text-base font-medium mt-4">Remark 3.2.</h6>

    <p class="text-gray-300">There are two main differences between Theorem 3.11 and the original statement in <em>[x1]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Theorem 3.11 parameterizes what KDM functions are required in order to prove correlation intractability for a given relation <span class="math">R</span> in terms of its (approximate) samplability.</li>

      <li>Theorem 3.11 assumes a weaker notion of “universal ciphertexts” (Definition 3.7) as compared to <em>[x1]</em>.</li>

    </ul>

    <p class="text-gray-300">However, Theorem 3.11 follows directly from the proof given in <em>[x1]</em>, and our proof is included only for completeness.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof of Theorem 3.11.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{H}_{\\mathsf{CCRR}}^{\\mathcal{E}}=\\left\\{h_{\\lambda}:\\mathcal{I}_{\\lambda}\\times\\mathcal{K}_{\\lambda}\\to\\{0,1\\}^{\\ell}\\right\\}_{\\lambda}</span> be as in Construction 3.10. Suppose that for some <span class="math">\\rho</span>-sparse relation ensemble <span class="math">R=\\{R_{\\lambda}\\}</span>, there is a polynomial-size adversary <span class="math">\\mathcal{A}=\\{\\mathcal{A}_{\\lambda}\\}</span> that, given <span class="math">I\\leftarrow\\mathcal{I}_{\\lambda}</span>, finds an input <span class="math">x\\in\\mathcal{K}_{\\lambda}</span> such that <span class="math">(x,h_{\\lambda}(I,x))\\in R_{\\lambda}</span> with probability <span class="math">\\epsilon(\\lambda)&gt;\\frac{2^{-\\kappa}}{\\delta(\\lambda)\\cdot\\rho(\\lambda)}\\cdot\\lambda^{-O(1)}</span>, for infinitely many <span class="math">\\lambda</span>. Recall that <span class="math">\\mathcal{I}_{\\lambda}</span> is sampled as an encryption of a uniformly random message under a uniformly random key. That is, we have <span class="math">I\\leftarrow\\mathsf{Enc}(K,M)</span> where <span class="math">K</span> and <span class="math">M</span> denote random variables whose distributions are uniform over <span class="math">\\{0,1\\}^{\\kappa}</span> and <span class="math">\\{0,1\\}^{\\ell}</span>, respectively.</p>

    <p class="text-gray-300">Consider independently sampling a uniformly random key <span class="math">X^{*}\\leftarrow\\mathcal{K}_{\\lambda}</span>. Then, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{K,X^{*}\\leftarrow \\mathcal{K}_{\\lambda}\\\\ M\\leftarrow \\{0,1\\}^{\\ell}\\\\ I\\leftarrow \\mathsf{Enc}(K,M)}}\\left[\\mathcal{A}(I) = X^{*}\\wedge \\big(X^{*},h_{\\lambda}(I,X^{*})\\big)\\in R_{\\lambda}\\right]\\geq \\frac{\\epsilon}{2^{\\kappa}},</span></div>

    <p class="text-gray-300">because the above expression can be interpreted as the probability that  <span class="math">\\mathcal{A}</span>  wins the correlation intractability game and that  <span class="math">\\mathcal{A}(I) = X^{*}</span> .</p>

    <p class="text-gray-300">The universal ciphertexts property of  <span class="math">\\mathcal{E}</span>  implies that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{X^{*}\\leftarrow \\mathcal{K}_{\\lambda}\\\\ M\\leftarrow \\{0,1\\}^{\\ell}\\\\ I\\leftarrow \\mathsf{Enc}(X^{*},M)}}\\left[\\mathcal{A}(I) = X^{*}\\wedge \\big(X^{*},h_{\\lambda}(I,X^{*})\\big)\\in R_{\\lambda}\\right]\\geq \\frac{\\epsilon}{2^{\\kappa}\\cdot\\mathrm{poly}(\\lambda)},</span></div>

    <p class="text-gray-300">because the distribution  <span class="math">\\mathsf{Enc}(X^{*},M)</span>  multiplicatively  <span class="math">\\frac{1}{\\mathrm{poly}(\\lambda)}</span> -approximates the distribution  <span class="math">\\mathsf{Enc}(K,M)</span> .</p>

    <p class="text-gray-300">Next, we note that for  <span class="math">I \\gets \\mathsf{Enc}(X^{<em>}, M)</span> , we have that  <span class="math">h_{\\lambda}(I, X^{</em>}) \\stackrel{\\mathrm{def}}{=} \\mathsf{Dec}(X^{<em>}, I) = M</span>  by the perfect correctness of  <span class="math">\\mathcal{E}</span> . Thus if  <span class="math">(X^{</em>}, h_{\\lambda}(I, X^{<em>})) \\in R_{\\lambda}</span> , then  <span class="math">(X^{</em>}, M) \\in R_{\\lambda}</span> . Let  <span class="math">S_{x,\\lambda}</span>  denote the set  <span class="math">\\{m : (x, m) \\in R_{\\lambda}\\}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\Pr_{\\substack{X^{*}\\leftarrow \\mathcal{K}_{\\lambda},\\widetilde{M}\\leftarrow S_{X^{*},\\lambda}\\\\ I\\leftarrow \\mathsf{Enc}(X^{*},\\widetilde{M})}}\\left[\\mathcal{A}(I) = X^{*}\\right] = \\sum_{x}\\Pr_{X^{*}\\leftarrow \\mathcal{K}_{\\lambda}}[X^{*} = x]\\cdot \\Pr_{\\substack{\\widetilde{M}\\leftarrow S_{x,\\lambda}\\\\ I\\leftarrow \\mathsf{Enc}(x,\\widetilde{M})}}\\left[\\mathcal{A}(I) = x\\right] \\\\ \\geq \\sum_ {x} \\Pr [ X ^ {*} = x ] \\cdot \\frac {\\Pr_ {M \\leftarrow \\{0 , 1 \\} ^ {\\ell}} [ \\mathcal {A} (I) = x \\wedge (x , M) \\in R _ {\\lambda} ]}{I \\leftarrow \\operatorname {E n c} (x , M)} \\\\ \\geq \\frac{1}{\\rho}\\cdot \\sum_{x}\\Pr [X^{*} = x]\\cdot \\Pr_{\\substack{M\\leftarrow \\{0,1\\}^{\\ell}\\\\ I\\leftarrow \\mathsf{Enc}(x,M)}}\\left[\\mathcal{A}(I) = x\\wedge (x,M)\\in R_{\\lambda}\\right] \\\\ = \\frac{1}{\\rho}\\cdot \\Pr_{\\substack{X^{*}\\leftarrow \\mathcal{K},M\\leftarrow U_{\\lambda}\\\\ I\\leftarrow \\mathsf{Enc}(X^{*},M)}}\\left[\\mathcal{A}(I) = X^{*}\\wedge (X^{*},M)\\in R_{\\lambda}\\right] \\\\ \\geq \\frac {1}{\\rho} \\cdot \\frac {\\epsilon}{2 ^ {\\kappa} \\cdot \\operatorname {p o l y} (\\lambda)}, \\\\ \\end{array}</span></div>

    <p class="text-gray-300">where  <span class="math">\\rho = \\rho (\\lambda)</span>  denotes the sparsity of  <span class="math">R = R_{\\lambda}</span> .</p>

    <p class="text-gray-300">Finally, we let  <span class="math">\\mathsf{Samp} = \\{\\mathsf{Samp}_{\\lambda}\\} \\in \\mathcal{F}</span>  denote an approximate sampler for the relation  <span class="math">R</span> , which exists by assumption. Since the distribution  <span class="math">\\mathsf{Samp}_{\\lambda}(x)</span>  multiplicatively  <span class="math">\\frac{1}{\\mathrm{poly}(\\lambda)}</span> -approximates the uniform distribution on  <span class="math">S_{x,\\lambda}</span>  by definition, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\substack{X^{*}\\leftarrow \\mathcal{K},\\widetilde{M}\\leftarrow \\mathsf{Samp}_{\\lambda}(X^{*})\\\\ I\\leftarrow \\mathsf{Enc}(X^{*},\\widetilde{M})}}[\\mathcal{A}(I) = X^{*}]\\geq \\frac{1}{\\rho}\\cdot \\frac{\\epsilon}{2^{\\kappa}\\cdot\\mathrm{poly}(\\lambda)}.</span></div>

    <p class="text-gray-300">But this contradicts the assumed  <span class="math">\\mathcal{F}</span> -KDM  <span class="math">\\delta</span> -security of  <span class="math">\\mathcal{E}</span> . Thus, we have proved Theorem 3.11.  <span class="math">\\square</span></p>

    <p class="text-gray-300">To avoid ambiguity in the case where  <span class="math">S_{X^{<em>}}</span>  is empty, we note that by “ <span class="math">\\operatorname</em>{Pr}_{\\substack{X^{<em>}\\leftarrow \\mathcal{K}_{\\lambda},\\widetilde{M}\\leftarrow S_{X^{</em>},\\lambda}\\\\ I\\leftarrow \\mathsf{Enc}(X^{<em>},\\widetilde{M})}}[f(X^{</em>},\\widetilde{M})]</span> ” we actually mean “ <span class="math">\\operatorname<em>{E}_{X^{</em>}\\leftarrow \\mathcal{K}_{\\lambda}}\\chi (S_{X^{<em>}}</span>  is nonempty)  <span class="math">\\operatorname</em>{Pr}_{\\substack{\\widetilde{M}\\leftarrow S_{X^{<em>},\\lambda}\\\\ I\\leftarrow \\mathsf{Enc}(X^{</em>},\\widetilde{M})}}[f(X^{*},\\widetilde{M})]</span> ”</p>

    <p class="text-gray-300">4 Optimally Secure KDM-Secure Encryption From Simpler Assumptions</p>

    <p class="text-gray-300">This section presents our two new constructions of KDM-secure encryption schemes from assumptions that are weaker and simpler than previously known. Combined with the results of <em>[x1]</em>, recalled in the previous section, this amounts to proving Theorems 3 and 4 (in Sections 4.2 and 4.3, respectively).</p>

    <h3 id="sec-31" class="text-xl font-semibold mt-8">4.1 Learning with Errors</h3>

    <p class="text-gray-300">The learning with errors (LWE) problem was introduced by Regev <em>[x10]</em>. The following overview is based on Peikert’s survey <em>[x11]</em>.</p>

    <h6 id="sec-32" class="text-base font-medium mt-4">Definition 4.1 (LWE Distribution).</h6>

    <p class="text-gray-300">For any <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> and any distribution <span class="math">\\chi\\subseteq\\mathbb{Z}_{q}</span>, the LWE distribution <span class="math">A_{\\mathbf{s},\\chi}\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> is sampled by choosing <span class="math">\\mathbf{a}\\in\\mathbb{Z}_{q}^{n}</span> uniformly at random, sampling <span class="math">e\\leftarrow\\chi</span>, and outputting <span class="math">(\\mathbf{a},b=\\langle\\mathbf{s},\\mathbf{a}\\rangle+e)</span>.</p>

    <h6 id="sec-33" class="text-base font-medium mt-4">Definition 4.2 (Search LWE).</h6>

    <p class="text-gray-300">Let <span class="math">\\ell=\\ell(n)\\geq 1</span>, <span class="math">q=q(n)\\geq 2</span> be integers, and let <span class="math">\\chi_{\\mathrm{sec}}(n)</span> and <span class="math">\\chi_{\\mathrm{err}}(n)</span> be distributions on <span class="math">\\mathbb{Z}_{q(n)}</span>. The Search-LWE<span class="math">{}_{\\ell,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> problem, parameterized by <span class="math">n</span>, is to output <span class="math">\\mathbf{s}</span> given as input <span class="math">\\ell(n)</span> independent samples from <span class="math">A_{\\mathbf{s},\\chi_{\\mathrm{err}}(n)}</span>, for <span class="math">\\mathbf{s}</span> that is sampled from <span class="math">\\chi_{\\mathrm{sec}}(n)^{n}</span>.</p>

    <p class="text-gray-300">For the rest of this paper, we will write LWE in place of Search-LWE.</p>

    <p class="text-gray-300">All of our lattice based hash functions require (at least) making an assumption of the following form.</p>

    <h6 id="sec-34" class="text-base font-medium mt-4">Assumption 1.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Any <span class="math">\\mathrm{poly}(n)</span>-time algorithm <span class="math">\\mathcal{A}</span> solves Search-LWE<span class="math">{}_{\\ell,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> with probability at most <span class="math">\\mu(\\chi_{\\mathrm{sec}})^{n}\\cdot\\mathrm{poly}(n,\\log(q))</span>, where $\\mu(\\chi_{\\mathrm{sec}}):=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{Supp}(\\chi_{\\mathrm{sec}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-1}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order for this assumption to have any hope of being true, <span class="math">\\chi_{\\mathrm{sec}}</span> must be nearly uniform on its support and it must hold that <span class="math">\\mu(\\chi_{\\mathrm{err}})\\leq\\mu(\\chi_{\\mathrm{sec}})</span> (so that the “error guessing attack” does not violate the assumption).</p>

    <p class="text-gray-300">In Appendix A we describe some basic analysis showing that the best-known polynomial-time algorithms for LWE do not violate our assumption subject to the two conditions above.</p>

    <h6 id="sec-35" class="text-base font-medium mt-4">Definition 4.3 (Secret-Key Regev Encryption).</h6>

    <p class="text-gray-300">For any positive integers <span class="math">q=q(\\lambda)\\leq 2^{\\mathrm{poly}(\\lambda)}</span>, <span class="math">n=n(\\lambda)\\leq\\mathrm{poly}(\\lambda)</span>, and any <span class="math">\\mathrm{poly}(\\lambda)</span>-time sampleable distribution ensembles <span class="math">\\chi_{\\mathrm{sec}}=\\{\\chi_{\\mathrm{sec}}(\\lambda)\\}</span> and <span class="math">\\chi_{\\mathrm{err}}=\\{\\chi_{\\mathrm{err}}(\\lambda)\\}</span> over <span class="math">\\mathbb{Z}_{q(\\lambda)}</span>, we define the encryption scheme <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> to be the secret-key bit-encryption scheme <span class="math">\\left\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\right\\}_{\\lambda}</span>, where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}_{\\lambda}</span> is the distribution <span class="math">\\chi_{\\mathrm{sec}}^{n}</span>.</li>

      <li><span class="math">\\mathsf{Enc}_{\\lambda}:\\mathbb{Z}_{q}^{n}\\times\\{0,1\\}\\xrightarrow{\\S}\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> is defined so that <span class="math">\\mathsf{Enc}_{\\lambda}(\\mathbf{s},m)</span> is obtained by sampling a uniformly random vector <span class="math">\\mathbf{a}\\leftarrow\\mathbb{Z}_{q}^{n}</span>, sampling <span class="math">e\\leftarrow\\chi_{\\mathrm{err}}(\\lambda)</span>, and outputting <span class="math">(\\mathbf{a},\\mathbf{s}^{t}\\cdot\\mathbf{a}+m\\cdot\\lceil\\frac{q}{2}\\rceil+e)</span></li>

      <li><span class="math">\\mathsf{Dec}_{\\lambda}:\\mathbb{Z}_{q}^{n}\\times(\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q})\\rightarrow\\{0,1\\}</span> is defined so that <span class="math">\\mathsf{Dec}(\\mathbf{s},(\\mathbf{a},b))</span> is the bit <span class="math">m</span> for which <span class="math">b-\\mathbf{s}^{t}\\cdot\\mathbf{a}</span> is closer to <span class="math">m\\cdot\\lceil\\frac{q}{2}\\rceil</span> than to <span class="math">(1-m)\\cdot\\lceil\\frac{q}{2}\\rceil</span>.</li>

    </ul>

    <p class="text-gray-300">A pair <span class="math">(\\mathbf{a},b)\\in\\mathbb{Z}_{q}^{n}\\times\\mathbb{Z}_{q}</span> is a Regev encryption of <span class="math">m\\in\\{0,1\\}</span> under <span class="math">\\mathbf{s}\\in\\mathbb{Z}_{q}^{n}</span> with <span class="math">B</span>-bounded noise if <span class="math">b-\\mathbf{s}^{t}\\cdot\\mathbf{a}-m\\cdot\\lceil\\frac{q}{2}\\rceil</span> is in the interval <span class="math">[-B,B)</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">4.2 (P/Poly)-KDM Security via Fully Homomorphic Encryption</p>

    <p class="text-gray-300">In this section, we describe a somewhat generic assumption on the circular security of FHE schemes that implies the existence of a (P/poly)-KDM exponentially-secure encryption scheme with an obliviously sampleable universal ciphertext distribution. Our assumption is <em>efficiently falsifiable</em> <em>[x18, x11]</em>, albeit with exponentially small probability, and is a <em>complexity assumption</em> <em>[x12]</em>. The (P/poly)-KDM secure encryption scheme is simply secret-key Regev encryption (Definition 4.3) where both the secret and the noise distributions are uniform over a relatively large interval in <span class="math">\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">We prove that this scheme achieves (P/poly)-KDM security assuming the security of a LWE-based FHE scheme such as <em>[x3, x4, x2, x10, x11, x5]</em> in which <em>both</em> the secret and the noise are drawn from the uniform distribution on <span class="math">[-B,B)</span>. Our security reduction preserves the kind of exponential security considered in Theorem 3.11, so our assumption can be used as the basis for a candidate correlation intractable hash family.</p>

    <p class="text-gray-300">We now define the notion of homomorphic encryption that suffices for our security reduction. As discussed in Section 2, this notion captures FHE schemes whose ciphertexts in some sense “contain” a (low-noise) secret-key Regev ciphertext.</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Definition 4.4 (Regev-Extractable Secret-Key Homomorphic Encryption).</h6>

    <p class="text-gray-300">A secret-key fully homomorphic bit-encryption scheme <span class="math">\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda},\\mathsf{Eval}_{\\lambda})\\}</span> is <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\text{sec}}}</span>-extractable with <span class="math">B(\\lambda)</span>-bounded noise if it satisfies the following structural properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The distribution of <span class="math">\\mathbf{s}</span> when sampling <span class="math">(\\mathbf{s},\\mathsf{ek})\\leftarrow\\mathcal{K}_{\\lambda}</span> is <span class="math">\\chi_{\\text{sec}}^{n}</span> where <span class="math">\\chi_{\\text{sec}}</span> is a distribution over <span class="math">\\mathbb{Z}_{q}</span>.</li>

      <li>There is a <span class="math">\\operatorname{poly}(\\lambda)</span>-time evaluable function <span class="math">\\mathsf{Extract}=\\{\\mathsf{Extract}_{\\lambda}\\}</span> such that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">\\lambda</span>, any <span class="math">\\mathbf{s}\\in\\chi_{\\text{sec}}^{n}</span>, and any <span class="math">m\\in\\{0,1\\}</span>, it holds that <span class="math">\\mathsf{Extract}_{\\lambda}(\\mathsf{Enc}_{\\lambda}(\\mathbf{s},m))</span> is a Regev encryption <span class="math">(\\mathbf{a},b)</span> of <span class="math">m</span> under <span class="math">\\mathbf{s}</span> with <span class="math">B</span>-bounded noise, and with <span class="math">\\mathbf{a}</span> uniformly random in <span class="math">\\mathbb{Z}_{q}^{n}</span>.</li>

      <li>For any <span class="math">m_{1},\\ldots,m_{n}\\in\\{0,1\\}</span>, any circuit <span class="math">C:\\{0,1\\}^{n}\\rightarrow\\{0,1\\}</span>, and any <span class="math">(\\mathbf{s},\\mathsf{ek})\\in\\mathcal{K}_{\\lambda}</span>, it holds with probability <span class="math">1</span> that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{Extract}_{\\lambda}\\Big{(}\\mathsf{Eval}_{\\lambda}(\\mathsf{ek},C,\\mathsf{Enc}_{\\lambda}(\\mathbf{s},m_{1}),\\ldots,\\mathsf{Enc}_{\\lambda}(\\mathbf{s},m_{n}))\\Big{)}</span></p>

    <p class="text-gray-300">is a Regev encryption <span class="math">(\\mathbf{a},b)</span> of <span class="math">C(m_{1},\\ldots,m_{n})</span> under <span class="math">\\mathbf{s}</span> with <span class="math">B</span>-bounded noise.</p>

    <p class="text-gray-300">We do not assume any particular distribution on the noise of Regev ciphertexts that are extracted from homomorphically evaluated ciphertexts; we assume only that the noise is bounded. For our applications, we require Regev extractable encryption schemes with the following security property.</p>

    <h6 id="sec-37" class="text-base font-medium mt-4">Definition 4.5.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}</span> be a FHE scheme with key distributions <span class="math">\\{\\mathcal{K}_{\\lambda}\\}</span>. For <span class="math">(\\mathsf{sk},\\mathsf{ek})\\in\\mathcal{K}_{\\lambda}</span>, let <span class="math">\\llbracket\\mathsf{sk}\\rrbracket</span> denote the binary representation of <span class="math">\\mathsf{sk}</span>, and let <span class="math">\\kappa=\\kappa(\\lambda)</span> denote the length of such a representation. For any <span class="math">\\ell=\\ell(\\lambda)</span> and any <span class="math">\\Delta</span>, <span class="math">\\mathcal{E}</span> is said to be [<span class="math">\\ell</span>-bit CPA + circular] <span class="math">\\Delta</span>-optimally secure with a <span class="math">\\kappa</span>-bit key (abbreviated <span class="math">(\\kappa,\\ell,\\Delta)</span>-CCO secure) if for every collection of <span class="math">\\ell</span>-bit messages <span class="math">\\left\\{m_{\\lambda}\\right\\}</span>, <span class="math">\\mathcal{E}</span> is <span class="math">f</span>-KDM</p>

    <p class="text-gray-300"><span class="math">\\left(2^{-\\kappa+\\Delta}\\right)</span>-secure for the “augmented bit-by-bit circular security function”</p>

    <div class="my-4 text-center"><span class="math-block">f = \\left\\{f _ {\\lambda}: \\mathcal {K} _ {\\lambda} \\rightarrow \\{0, 1 \\} ^ {\\ell + \\kappa} \\right\\}</span></div>

    <div class="my-4 text-center"><span class="math-block">f _ {\\lambda} (k) = m _ {\\lambda} \\circ [   [ k ]   ] \\quad (\\circ \\text {denotes concatenation})</span></div>

    <p class="text-gray-300"><strong>Discussion.</strong> The requirement that an encryption scheme is <span class="math">(\\kappa, \\ell, \\Delta)</span>-CCO secure becomes stronger as <span class="math">\\kappa</span> or <span class="math">\\ell</span> increases, and weaker as <span class="math">\\Delta</span> decreases. In particular, the requirement is trivially satisfied if <span class="math">\\Delta \\geq \\kappa</span>. This is related to the triviality of constructing a correlation-intractable hash family <span class="math">\\{\\mathcal{H}_{\\lambda}\\}</span> in which the output length of <span class="math">\\mathcal{H}_{\\lambda}</span> is <span class="math">O(\\log \\lambda)</span> – in this case, the only sparse relations are the empty ones.</p>

    <p class="text-gray-300"><strong>Assumption 2 (Dream FHE).</strong> For some <span class="math">n</span>, <span class="math">q</span>, <span class="math">\\chi_{\\mathrm{sec}}</span>, there exists<span class="math">^{17}</span> a <span class="math">(\\kappa, \\ell, \\Delta)</span>-CCO secure secret-key FHE scheme that is <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}}}</span>-extractable with <span class="math">B</span>-bounded noise for <span class="math">\\kappa = \\lambda^{\\Theta(1)}</span>, <span class="math">\\ell = \\lambda^{\\Omega(1)}</span>, <span class="math">\\Delta = O(\\log \\lambda)</span>, <span class="math">B \\leq q / \\bar{\\Omega}(\\lambda)</span>, and <span class="math">\\chi_{\\mathrm{sec}}^{n}</span> that is sampleable in <span class="math">\\tilde{O}(n)</span> time using at most <span class="math">\\kappa + O(\\log \\lambda)</span> random bits.</p>

    <p class="text-gray-300">While Assumption 2 is not itself falsifiable, the (stronger) assumption that any particular Regev-extractable FHE scheme satisfies Definition 4.5 is a falsifiable (with exponentially small probability) complexity assumption, as claimed.</p>

    <p class="text-gray-300">We also note that the security property postulated in Assumption 2 is, even qualitatively, slightly stronger than what is needed for our applications – see the discussion following the proof of Theorem 4.6.</p>

    <p class="text-gray-300"><strong>Possible Instantiations of Assumption 2</strong> As mentioned earlier, a large family of (secret key variants of) LWE-based FHE schemes – such as [BV11, BGV12, Bra12, GSW13, BV14] are Regev-extractable. Like Regev’s encryption scheme, these homomorphic encryption schemes are parameterized by a modulus <span class="math">q</span>, a secret distribution <span class="math">\\chi_{\\mathrm{sec}}</span>, and an error distribution <span class="math">\\chi_{\\mathrm{err}}</span>. All of these schemes, as written, set <span class="math">\\chi_{\\mathrm{sec}}</span> to either be the uniform distribution on <span class="math">\\mathbb{Z}_q</span> or a sufficiently wide discrete Gaussian. These distributions are optimal in the polynomial hardness regime [Reg09, ACPS09], but they are trivially sub-optimal in the regime of exponential hardness. Specifically, if <span class="math">\\chi_{\\mathrm{sec}}</span> is very non-uniform (i.e., a discrete Gaussian), then a key can be directly guessed with probably much better than <span class="math">2^{-\\kappa}</span>. On the other hand, if <span class="math">\\chi_{\\mathrm{sec}}</span> were the uniform distribution over <span class="math">\\mathbb{Z}_q</span>, then given many Regev ciphertexts (where each ciphertext’s noise level is <span class="math">\\frac{q}{4}</span>-bounded), a secret can be relatively efficiently guessed by first guessing the noise and then computing the secret by linear algebra.</p>

    <p class="text-gray-300">We propose instantiating any of the above-mentioned schemes with secret distribution <span class="math">\\chi_{\\mathrm{sec}}</span> and noise distribution <span class="math">\\chi_{\\mathrm{err}}</span> such that both are uniformly random on intervals of length <span class="math">\\ell_{\\mathrm{sec}}</span> and <span class="math">\\ell_{\\mathrm{err}}</span>, respectively, such that <span class="math">\\ell_{\\mathrm{err}} \\geq \\ell_{\\mathrm{sec}}</span> and <span class="math">\\ell_{\\mathrm{sec}}</span> is sufficiently large. We emphasize that, up to a polynomial increase in the modulus-noise ratio, these changes do not affect the polynomial security of the schemes. We are not aware of any algorithm violating Assumption 2 for any of these schemes (with the secret distribution as described above), despite the fact that most of the schemes require a superpolynomial (in the case of [BV11], even sub-exponential) modulus-to-noise ratio. However, we explicitly note that the scheme [BV14] only relies on a polynomial modulus-to-noise ratio in the underlying LWE scheme, which may give us more confidence in the claimed exponential security. We describe the known cryptanalytic results further in Appendix A.</p>

    <p class="text-gray-300"><span class="math">^{17}</span>In fact, it would even suffice for the construction to be <em>non-uniform</em>.</p>

    <p class="text-gray-300"><span class="math">^{18}</span>Abstractly, the description length <span class="math">\\kappa</span> is the Shannon entropy of the secret key, while (the negative log of) the trivial guessing probability is the min-entropy. The two entropies agree only for uniform distributions.</p>

    <p class="text-gray-300">We are now ready to state our security reduction.</p>

    <h6 id="sec-38" class="text-base font-medium mt-4">Theorem 4.6.</h6>

    <p class="text-gray-300">If Assumption 2 is true, then there exist parameters <span class="math">n=n(\\lambda)</span>, <span class="math">q=q(\\lambda)</span>, and <span class="math">\\chi_{\\mathrm{sec}}=\\chi_{\\mathrm{sec}}(\\lambda)</span> such that for some <span class="math">\\ell=\\lambda^{\\Omega(1)}</span>, <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> is <span class="math">(\\mathsf{P}/\\mathsf{poly})^{\\ell}</span>-KDM <span class="math">1/\\tilde{\\Omega}(2^{\\kappa})</span>-secure where <span class="math">(\\mathsf{P}/\\mathsf{poly})^{\\ell}</span> is the class of <span class="math">\\mathrm{poly}(\\lambda)</span>-size circuits with <span class="math">\\ell</span> output bits and <span class="math">\\chi_{\\mathrm{err}}</span> is the uniform distribution on <span class="math">[-q/4,q/4)</span> and <span class="math">\\kappa</span> is the length of the binary representation of an element of <span class="math">\\chi_{\\mathrm{sec}}^{n}</span>.</p>

    <p class="text-gray-300">Our proof of Theorem 4.6 relies on the following lemma, whose proof easily follows from direct computation.</p>

    <h6 id="sec-39" class="text-base font-medium mt-4">Lemma 4.7.</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">For any <span class="math">e\\in\\mathbb{Z}</span> with $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq b<span class="math"> and for any interval </span>I=[c,d]<span class="math"> of length </span>\\ell<span class="math">, the distribution </span>e+U_{[c-b,d+b]}<span class="math"> multiplicatively </span>(\\frac{\\ell}{\\ell+2b})<span class="math">-approximates the distribution </span>U_{I}<span class="math">, where for a set </span>S<span class="math">, </span>U_{S}<span class="math"> denotes the uniform distribution on </span>S$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-40" class="text-base font-medium mt-4">Proof of Theorem 4.6.</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}=\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda},\\mathsf{Eval}_{\\lambda})\\}</span> denote the dream <span class="math">\\mathsf{FHE}</span> scheme that is <span class="math">(\\kappa,\\ell,\\Delta)</span>-CCO secure and <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}}}</span>-extractable with <span class="math">B</span>-bounded noise for <span class="math">B\\leq q/\\tilde{\\Omega}(\\lambda)</span>. Without loss of generality suppose that <span class="math">\\ell\\leq\\lambda</span>. Let <span class="math">\\mathsf{Extract}=\\{\\mathsf{Extract}_{\\lambda}\\}</span> denote the corresponding extraction algorithm.</p>

    <p class="text-gray-300">Let <span class="math">\\chi_{\\mathrm{err}}(\\lambda)</span> denote the uniform distribution on <span class="math">[-q/4,q/4)</span>, and let <span class="math">\\{\\mathcal{K}^{\\prime}_{\\lambda},\\mathsf{Enc}^{\\prime}_{\\lambda},\\mathsf{Dec}^{\\prime}_{\\lambda}\\}</span> denote <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span>. Suppose for contradiction that <span class="math">\\mathbf{Regev}_{n,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> is <em>not</em> <span class="math">(\\mathsf{P}/\\mathsf{poly})^{\\ell}</span>-KDM <span class="math">\\delta</span>-secure.</p>

    <p class="text-gray-300">That is, suppose there exist <span class="math">\\mathrm{poly}(\\lambda)</span>-size evaluable functions <span class="math">\\{f_{\\lambda}:\\mathbb{Z}_{q}^{n}\\to\\{0,1\\}^{\\ell}\\}</span> and <span class="math">\\{\\mathcal{A}_{\\lambda}\\}</span> such that for infinitely many <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathrm{Pr}[\\mathcal{A}_{\\lambda}(\\mathsf{ct}_{1},\\ldots,\\mathsf{ct}_{\\ell})=\\mathbf{s}]&gt;\\delta(\\lambda).</span></p>

    <p class="text-gray-300">in the probability space defined by sampling <span class="math">\\mathbf{s}\\leftarrow\\mathcal{K}^{\\prime}_{\\lambda}</span> and, for each <span class="math">i\\in[\\ell]</span>, independently sampling Regev encryptions <span class="math">\\mathsf{ct}_{i}\\leftarrow\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathbf{s},f_{\\lambda}(\\mathbf{s})_{i})</span>.</p>

    <p class="text-gray-300">We will now describe a <span class="math">\\mathrm{poly}(\\lambda)</span>-size evaluable adversary <span class="math">\\mathcal{B}=\\{\\mathcal{B}_{\\lambda}\\}</span> that contradicts Assumption 2. <span class="math">\\mathcal{B}_{\\lambda}</span> is given as input <span class="math">(\\mathsf{ek},c_{1},\\ldots,c_{\\ell+\\kappa})</span>, and does the following.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For <span class="math">i\\in[\\ell]</span>, define <span class="math">(\\mathbf{a}_{i},b_{i}):=\\mathsf{Extract}_{\\lambda}(c_{i})</span>.</li>

      <li>Compute <span class="math">(c^{\\prime}_{1},\\ldots,c^{\\prime}_{\\ell}):=\\mathsf{Eval}_{\\lambda}(\\mathsf{ek},f_{\\lambda},c_{\\ell+1},\\ldots,c_{\\ell+\\kappa})</span> and define <span class="math">(\\mathbf{y}_{i},z_{i}):=\\mathsf{Extract}_{\\lambda}(c^{\\prime}_{i})</span> for every <span class="math">i\\in[\\ell]</span>.</li>

      <li>For each <span class="math">i\\in[\\ell]</span>, update <span class="math">\\mathbf{y}_{i}:=\\mathbf{y}_{i}+\\mathbf{a}_{i}</span> and <span class="math">z_{i}:=z_{i}+b_{i}</span>.</li>

      <li>For each <span class="math">i\\in[\\ell]</span>, sample <span class="math">e_{i}</span> from the uniform distribution on <span class="math">[-\\frac{q}{4}-2B,\\frac{q}{4}+2B]</span> and update <span class="math">z_{i}:=z_{i}+e_{i}</span>.</li>

      <li>Compute and output <span class="math">\\mathcal{A}_{\\lambda}\\big{(}(\\mathbf{y}_{1},z_{1}),\\ldots,(\\mathbf{y}_{\\ell},z_{\\ell})\\big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">If <span class="math">(\\mathbf{s},\\mathsf{ek})</span> is sampled at random from <span class="math">\\mathcal{K}_{\\lambda}</span>, if <span class="math">c_{\\ell+j}\\leftarrow\\mathsf{Enc}_{\\lambda}(\\mathbf{s},\\llbracket\\mathbf{s}\\rrbracket_{j})</span> for each <span class="math">j\\in[\\kappa]</span>, and if <span class="math">c_{i}\\leftarrow\\mathsf{Enc}_{\\lambda}(\\mathbf{s},0)</span>, then by the definition of extractability, it holds that after Step 2, each <span class="math">(\\mathbf{y}_{i},z_{i})</span> is a Regev encryption of <span class="math">f_{\\lambda}(\\mathbf{s})_{i}</span> under <span class="math">\\mathbf{s}</span> with <span class="math">B</span>-bounded noise, and <span class="math">(\\mathbf{a}_{1},\\ldots,\\mathbf{a}_{\\ell})</span> is uniformly random (and independent of <span class="math">(\\mathbf{y}_{1},\\ldots,\\mathbf{y}_{\\ell})</span>). After Step 3, each <span class="math">(\\mathbf{y}_{i},z_{i})</span> is a Regev encryption of <span class="math">f_{\\lambda}(\\mathbf{s})_{i}</span> under <span class="math">\\mathbf{s}</span> with <span class="math">2B</span>-bounded noise. After Step 4, by Lemma 4.7, it holds that, for</p>

    <p class="text-gray-300"><span class="math">\\epsilon=\\epsilon(\\lambda)\\stackrel{{\\scriptstyle\\mathsf{def}}}{{=}}\\left(\\frac{q/2}{q/2+2B}\\right)^{\\lambda}=\\left(1-\\frac{4B}{q}\\right)^{\\ell}\\geq\\left(1-\\frac{1}{\\tilde{\\Omega}(\\lambda)}\\right)^{\\lambda}=\\lambda^{-O(1)},</span></p>

    <p class="text-gray-300">the distribution of  <span class="math">\\left((\\mathbf{y}_1,z_1),\\ldots ,(\\mathbf{y}_\\ell ,z_\\ell)\\right)</span>  multiplicatively  <span class="math">\\epsilon</span>  -approximates the distribution on  <span class="math">(\\mathsf{ct}_1,</span> <span class="math">\\dots ,\\mathsf{ct}_{\\ell})</span>  obtained by independently sampling  <span class="math">\\mathsf{ct}_i\\gets \\mathsf{Enc}_{\\lambda}^{\\prime}(\\mathbf{s},f_{\\lambda}(\\mathbf{s})_i)</span>  for each  <span class="math">i\\in [\\lambda ]</span>  . Thus  <span class="math">\\mathcal{A}_{\\lambda}</span>  , and therefore  <span class="math">\\mathcal{B}_{\\lambda}</span>  , outputs s with probability at least  <span class="math">\\frac{\\delta}{\\mathrm{poly}(\\lambda)} = 2^{-\\kappa}\\cdot \\lambda^{\\omega (1)}</span></p>

    <p class="text-gray-300">Loosely speaking, what our reduction really requires is the ability to re-randomize Regev encryptions in a somewhat weaker sense than what is typically meant by re-randomization. It can receive this ability in the form of Regev ciphertexts. In contrast,  <span class="math">(\\kappa, \\ell, \\Delta)</span> -CCO security gives the reduction even more, specifically fresh  <span class="math">\\mathcal{E}</span> -ciphertexts from which Regev ciphertexts can be extracted. It would instead suffice for  <span class="math">\\mathcal{E}</span>  to satisfy a version of  <span class="math">(\\kappa, 0, \\Delta)</span> -CCO security in a setting where the adversary is only given  <span class="math">\\ell</span>  Regev encryptions  <span class="math">\\{(\\mathbf{a}_i, b_i)\\}_{i \\in [\\ell]}</span>  for uniform and independent  <span class="math">\\{\\mathbf{a}_i\\}</span> .</p>

    <p class="text-gray-300">In this section, we give two additional constructions of encryption schemes satisfying universal ciphertexts (Definition 3.7) as well as  <span class="math">\\mathsf{SIZE}(\\kappa^c)</span> -KDM  <span class="math">\\delta</span> -security for  <span class="math">\\delta(\\lambda) = 2^{-\\kappa} \\cdot \\mathrm{poly}(\\kappa)</span> . These schemes differ from the encryption scheme in Theorem 4.6 in two (related) ways:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The size bound  <span class="math">S</span>  for the KDM functions must be specified in advance before choosing the encryption scheme; in contrast, Theorem 4.6 gives a single encryption scheme that is (plausibly) KDM-secure for all polynomial-time computable KDM functions.</li>

      <li>Moreover, the encryption schemes in this section are non-compact; that is, the size of a ciphertext depends polynomially on the size bound  <span class="math">S</span> .</li>

    </ul>

    <p class="text-gray-300">While these schemes satisfy weaker efficiency properties than the scheme in Theorem 4.6, we are able to prove security based on the exponential hardness of plain search-LWE (in contrast to the additional circular security assumptions that were required in Theorem 4.6). Since noncompact (exponential) KDM-secure encryption schemes of the above form suffices to instantiate NIZK arguments in the common random string model (as shown in Section 7.2), this yields candidate NIZK arguments based on exponential variants of plain LWE.</p>

    <p class="text-gray-300">To prove our results in this section, we revisit the idea of KDM security amplification via randomized encodings [BHH10, App11]. In particular, we prove that the generic transformation of [App11] allows us to amplify CCRR-compatibility provided that we use a randomized encoding that is perfectly blind (which just means that the simulator applied to a uniformly random string outputs a uniformly random <span class="math">^{20}</span>  string). By modifying (and composing) standard randomized encoding schemes from the literature [BMR90, IK02, AIK11], we therefore reduce the problem to constructing  <span class="math">\\mathcal{F}</span> -KDM  <span class="math">2^{-\\kappa}</span>  poly  <span class="math">(\\kappa)</span> -secure encryption schemes (with universal ciphertexts) for simple function classes  <span class="math">\\mathcal{F}</span>  (namely, some form of affine functions modulo a prime). We then give schemes (based on secret-key Regev encryption or a variant of the [ACPS09] encryption scheme) that satisfy these weaker requirements under an appropriate LWE assumption.</p>

    <p class="text-gray-300">We first recall the generic transformation from [App11] that amplifies (standard) KDM security.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 4.8 (Randomized Encoding).</h6>

    <p class="text-gray-300">A randomized encoding scheme for a circuit class <span class="math">\\mathcal{C}</span> consists of three algorithms <span class="math">(\\mathsf{RE.Enc},\\mathsf{RE.Dec},\\mathsf{RE.Sim})</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE.Enc}</span> takes as input a circuit <span class="math">C</span> and an input <span class="math">x</span>; it outputs an encoding <span class="math">\\langle C,x\\rangle</span>.</li>

      <li><span class="math">\\mathsf{RE.Dec}</span> takes as input an encoding <span class="math">\\langle C,x\\rangle</span>; it outputs an evaluation <span class="math">y</span>.</li>

      <li><span class="math">\\mathsf{RE.Sim}</span> takes as input a size bound <span class="math">1^{S}</span>, a circuit <span class="math">C</span>, and an output <span class="math">y</span>; it outputs an encoding <span class="math">\\tilde{y}</span>.</li>

    </ul>

    <p class="text-gray-300">A randomized encoding scheme must satisfy two properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Correctness: for any circuit <span class="math">C</span> and input <span class="math">x</span>, we have that <span class="math">\\mathsf{RE.Dec}(\\mathsf{RE.Enc}(C,x))=C(x)</span> with probability <span class="math">1</span>.</li>

      <li><span class="math">\\mu</span>-simulation security: For every circuit <span class="math">C</span> of size at most <span class="math">S</span> and any input <span class="math">x</span>, the following two distributions are <span class="math">\\mu</span>-(computationally) indistinguishable.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{RE.Enc}(C,x)\\approx_{c,\\mu}\\mathsf{RE.Sim}(1^{S},C,C(x)).</span></p>

    <p class="text-gray-300">We say that a randomized encoding scheme is universal if there is a simulator <span class="math">\\mathsf{RE.Sim}</span> as above that takes as input only <span class="math">(1^{S},C(x))</span> and not the circuit <span class="math">C</span>.</p>

    <h6 id="sec-44" class="text-base font-medium mt-4">Definition 4.9 (Amplified KDM-secure Encryption Scheme).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathcal{E}^{\\prime}=\\{(\\mathcal{K}^{\\prime}_{\\lambda},\\mathsf{Enc}^{\\prime}_{\\lambda},\\mathsf{Dec}^{\\prime}_{\\lambda})\\}</span> denote a secret key encryption scheme, and let <span class="math">\\mathsf{RE}=(\\mathsf{RE.Enc},\\mathsf{RE.Dec},\\mathsf{RE.Sim})</span> denote a universal randomized encoding scheme for some circuit class <span class="math">\\mathcal{C}</span>. Finally, let <span class="math">S=\\mathrm{poly}(\\kappa)</span> denote some size bound. We then define the <span class="math">\\mathsf{RE}</span>-amplified secret key encryption scheme <span class="math">\\mathsf{AMP}^{\\mathcal{E}^{\\prime}}=\\{(\\mathcal{K}_{\\lambda},\\mathsf{Enc}_{\\lambda},\\mathsf{Dec}_{\\lambda})\\}</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{K}_{\\lambda}</span> is identical to <span class="math">\\mathcal{K}^{\\prime}_{\\lambda}</span>.</li>

      <li>The output of <span class="math">\\mathsf{Enc}_{\\lambda}(\\mathsf{sk},m)</span> is <span class="math">\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathsf{sk},\\mathsf{RE.Sim}(1^{S},m))</span>.</li>

      <li>The output of <span class="math">\\mathsf{Dec}_{\\lambda}(\\mathsf{sk},\\mathsf{ct})</span> is <span class="math">\\mathsf{RE.Dec}(\\mathsf{Dec}^{\\prime}_{\\lambda}(\\mathsf{sk},\\mathsf{ct}))</span>.</li>

    </ul>

    <p class="text-gray-300">In <em>[x1]</em>, it is shown that if <span class="math">\\mathcal{E}^{\\prime}</span> satisfies ordinary KDM security with respect to some function class <span class="math">\\mathcal{G}</span>, and if <span class="math">\\mathcal{F}</span> is some function class with circuit representations such that for any <span class="math">f\\in\\mathcal{F}</span>, the function <span class="math">x\\mapsto\\mathsf{RE.Enc}(f,x;r)</span> lies in <span class="math">\\mathcal{G}</span> for any fixed <span class="math">r</span>, then <span class="math">\\mathsf{AMP}^{\\mathcal{E}^{\\prime}}</span> is KDM secure with respect to <span class="math">\\mathcal{F}</span>. Our goal is to prove an analogous result that also preserves the conditions of Theorem 3.11, namely nearly optimal security and, more challengingly, the universal ciphertexts property. To do this, we will require randomized encoding schemes satisfying the additional property that we call (a relaxation of) <em>blindness</em>, following <em>[x5]</em>.</p>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 4.10 (Blind Randomized Encodings).</h6>

    <p class="text-gray-300">A randomized encoding scheme <span class="math">\\mathsf{RE}=(\\mathsf{RE.Enc}</span>, <span class="math">\\mathsf{RE.Dec},\\mathsf{RE.Sim})</span> is called <span class="math">\\epsilon</span>-approximately blind for output distribution <span class="math">\\chi_{\\mathsf{out}}</span> if for any circuit <span class="math">C</span> of size at most <span class="math">S</span>, the following two distributions <span class="math">\\epsilon</span>-multiplicatively approximate each other:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE.Sim}(1^{S},C,\\chi_{\\mathsf{out}})</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. The uniform distribution on strings of length $\\ell^{\\prime}:=\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{RE.Sim}(1^{S},C,0^{\\ell})\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that <span class="math">\\mathsf{RE}</span> is <em>perfectly blind</em> for output distribution <span class="math">\\chi</span> if it is <span class="math">1</span>-approximately blind for <span class="math">\\chi</span>.</p>

    <p class="text-gray-300">In the context of statistical (or perfect) randomized encodings, <em>[x1]</em> refers to such an encoding scheme as <em>balanced</em>.</p>

    <p class="text-gray-300">Given this additional property, we are able to state our theorem for this subsection.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Theorem 4.11.</h6>

    <p class="text-gray-300">Suppose that <span class="math">\\mathsf{RE}</span> is a universal randomized encoding scheme for a circuit class <span class="math">\\mathcal{C}\\subset\\mathsf{SIZE}(S)</span> satisfying the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}</span> satisfies <span class="math">o(2^{-\\kappa})</span>-simulation security.</li>

      <li><span class="math">\\mathsf{RE}</span> is <span class="math">\\epsilon</span>-approximately blind for the uniform output distribution, where <span class="math">\\epsilon</span> is any non-negligible function.</li>

      <li>For every circuit <span class="math">C\\in\\mathcal{C}</span> and every fixed choice of randomness <span class="math">r</span>, the function <span class="math">\\mathsf{RE.Enc}(C,x;r)</span> is in the class <span class="math">\\mathcal{G}</span>.</li>

    </ul>

    <p class="text-gray-300">Moreover, suppose that <span class="math">\\mathcal{E}^{\\prime}</span> is an encryption scheme with universal ciphertexts that is <span class="math">\\mathcal{G}</span>-KDM <span class="math">\\delta</span>-secure with uniformly random <span class="math">\\kappa</span>-bit keys and message length <span class="math">\\ell^{\\prime}</span>. Then, the amplified encryption scheme <span class="math">\\mathsf{AMP}</span> (Definition 4.9) is an encryption scheme for messages of length <span class="math">\\ell</span> that has universal ciphertexts and is <span class="math">\\mathcal{F}</span>-KDM secure, where <span class="math">\\mathcal{F}</span> denotes the class of all functions computable by circuits in <span class="math">\\mathcal{C}</span>.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We first prove the universal ciphertexts property; that is, that for any fixed secret key <span class="math">\\mathsf{sk}</span>, we have that the distribution <span class="math">\\mathsf{AMP.Enc}(\\mathsf{sk},U_{\\ell})</span> multiplicatively <span class="math">\\epsilon=\\frac{1}{\\mathrm{poly}(\\kappa)}</span>-approximates the distribution <span class="math">\\mathsf{AMP.Enc}(U_{n},U_{\\ell})</span>. To see this, let <span class="math">\\mathsf{Enc}^{\\prime}_{\\lambda}</span> and <span class="math">\\mathsf{Dec}^{\\prime}_{\\lambda}</span> denote the encryption and decryption procedures of <span class="math">\\mathcal{E}^{\\prime}</span>, and note that by the blindness of <span class="math">\\mathsf{RE}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AMP.Enc}(\\mathsf{sk},U_{\\ell})\\equiv\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathsf{sk},\\mathsf{RE.Sim}(1^{S},U_{\\ell}))\\succeq_{\\epsilon}\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathsf{sk},U_{\\ell^{\\prime}}),</span></p>

    <p class="text-gray-300">where <span class="math">\\succeq_{\\epsilon}</span> denotes multiplicative <span class="math">\\epsilon</span>-approximation. Similarly, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{AMP.Enc}(U_{n},U_{\\ell})\\equiv\\mathsf{Enc}^{\\prime}_{\\lambda}(U_{n},\\mathsf{RE.Sim}(1^{S},U_{\\ell}))\\mathop{\\scriptstyle\\epsilon}\\preceq\\mathsf{Enc}^{\\prime}_{\\lambda}(U_{n},U_{\\ell^{\\prime}}).</span></p>

    <p class="text-gray-300">Thus, we conclude that the universal ciphertexts property of <span class="math">\\mathsf{AMP}</span> follows directly from the same property for <span class="math">\\mathcal{E}^{\\prime}</span>.</p>

    <p class="text-gray-300">Next, we prove that the transformation also preserves nearly-optimal KDM security. To see this, suppose that for some <span class="math">f\\in\\mathcal{F}</span>, a ppt adversary <span class="math">\\mathcal{A}</span> that is given</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ct}\\leftarrow\\mathsf{AMP.Enc}(\\mathsf{sk},f(\\mathsf{sk}))\\equiv\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathsf{sk},\\mathsf{RE.Sim}(1^{S},f(\\mathsf{sk})))</span></p>

    <p class="text-gray-300">returns <span class="math">\\mathsf{sk}</span> with probability <span class="math">\\delta=\\omega(2^{-n})</span>. Then, by the <span class="math">o(2^{-n})</span>-simulation security of <span class="math">\\mathsf{RE}</span>, the same is true when <span class="math">\\mathcal{A}</span> is given</p>

    <p class="text-gray-300"><span class="math">\\mathsf{ct}\\leftarrow\\mathsf{Enc}^{\\prime}_{\\lambda}(\\mathsf{sk},\\mathsf{RE.Enc}(C,\\mathsf{sk}))</span></p>

    <p class="text-gray-300">where <span class="math">C\\in\\mathcal{C}</span> is some circuit computing <span class="math">f</span>. This will allow us to break the KDM security of <span class="math">\\mathcal{E}^{\\prime}</span> for some function <span class="math">g\\in\\mathcal{G}</span>. Namely, an adversary <span class="math">\\mathcal{A}^{\\prime}</span> can break the security of <span class="math">\\mathcal{E}^{\\prime}</span> by choosing uniformly random encoding randomness <span class="math">r</span> and submitting the KDM function <span class="math">g(\\mathsf{sk})=\\mathsf{RE.Enc}(C,\\mathsf{sk};r)</span>. By assumption, <span class="math">g</span> lies in the class <span class="math">\\mathcal{G}</span>, and feeding a <span class="math">\\mathsf{SKE}</span>-KDM ciphertext <span class="math">\\mathsf{ct}</span> to <span class="math">\\mathcal{A}</span> will result in recovering <span class="math">\\mathsf{sk}</span> with probability <span class="math">\\delta-o(2^{-\\kappa})=\\Omega(\\delta)</span>. This completes the security reduction. ∎</p>

    <p class="text-gray-300">##</p>

    <h4 id="sec-48" class="text-lg font-semibold mt-6">4.3.2 <span class="math">\\mathsf{SIZE}(\\kappa^{c})</span>-KDM Secure Encryption Schemes with Universal Ciphertexts</h4>

    <p class="text-gray-300">Together with suitable randomized encoding schemes, Theorem 4.11 reduces the problem of constructing (non-compact) <span class="math">\\mathsf{SIZE}(\\kappa^{c})</span>-KDM secure encryption schemes with universal ciphertexts to the problem of constructing <span class="math">\\mathcal{F}</span>-KDM secure encryption schemes for smaller classes of KDM functions. We follow this recipe with two randomized encoding schemes from the literature, combined with KDM-secure encryption schemes for (two classes of) simple functions. The first construction is straight-forward, and assumes the nearly optimal hardness of Search-LWE with binary secrets and a specific noise distribution (uniform on <span class="math">[-q/4,q/4)</span>). The second construction is more involved, but allows more general secret and noise distributions.</p>

    <h5 id="sec-49" class="text-base font-semibold mt-4">Point-and-Permute Garbled Circuits.</h5>

    <p class="text-gray-300">Point-and-Permute garbled circuits, introduced by <em>[x10]</em> in order to achieve constant round secure multiparty computation, are a modification of Yao’s garbling scheme <em>[x19, x16]</em>; in a nutshell, rather than requiring every entry of a garbled table in Yao’s scheme to be decrypted (and that in an honest evaluation only one of the four ciphertexts should be decrypted successfully), point-and-permute garbled circuits augment each wire key <span class="math">k_{g,b}</span> with a random pointer <span class="math">b\\oplus r_{g}</span> indicating which table entries <span class="math">k_{g,b}</span> is able to decrypt. While originally introduced in order to allow for a form of distributed garbling <em>[x10]</em>, and later used for reasons of efficiency (i.e. saving a factor of 4 in evaluation time), <em>[x5]</em> noted and took advantage of the fact that point-and-permute garbled circuits are also perfectly blind.</p>

    <p class="text-gray-300">The following theorem follows from the works <em>[x10, x22, x5]</em>. We refer the reader to <em>[x5]</em> for details on the proof of blindness.</p>

    <h6 id="sec-50" class="text-base font-medium mt-4">Imported Theorem 4.12.</h6>

    <p class="text-gray-300">If one-way functions exist, then there exists a universal randomized encoding scheme RE for the class of all polynomial size circuits with the following properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>RE is perfectly blind.</li>

      <li>For any fixed choice of randomness <span class="math">r</span> and circuit <span class="math">C</span>, the function <span class="math">x\\mapsto\\mathsf{RE.Enc}(C,x;r)</span> is an <span class="math">\\mathbb{F}_{2}</span>-affine projection of <span class="math">x</span>. This means that every output bit of <span class="math">\\mathsf{RE.Enc}(C,x;r)</span> is an <span class="math">\\mathbb{F}_{2}</span>-affine function of <span class="math">x</span> that depends only one bit of <span class="math">x</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The function <span class="math">(C,x)\\mapsto\\mathsf{RE.Enc}(C,x;r)</span> is a concatenation $f_{1}(C,x;r)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{2}(r)<span class="math">, where each bit of </span>f_{1}(C,x;r)$ has constant input locality.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Moreover, if <em>subexponentially secure</em> one-way functions exist, then for any <span class="math">c&gt;0</span>, RE can be modified so that it is <span class="math">2^{-\\kappa^{c}}</span>-simulation secure.</p>

    <h5 id="sec-51" class="text-base font-semibold mt-4">A Scheme from Exponential LWE with Binary Secrets.</h5>

    <p class="text-gray-300">Combining Theorem 4.11 with Imported Theorem 4.12, we conclude that to construct a <span class="math">\\mathsf{SIZE}(\\kappa^{c})</span>-KDM <span class="math">2^{-\\kappa}\\cdot\\operatorname{poly}(\\kappa)</span>-secure encryption scheme with universal ciphertexts, it suffices to construct a <span class="math">\\mathcal{F}</span>-KDM <span class="math">2^{-\\kappa}\\cdot\\operatorname{poly}(\\kappa)</span>-secure encryption scheme (with universal ciphertexts), where <span class="math">\\mathcal{F}</span> is the class of all <span class="math">\\mathbb{Z}_{2}</span>-linear functions and <span class="math">\\kappa</span> is the bit-length of an encryption key.</p>

    <p class="text-gray-300">We now claim that such an encryption scheme exists assuming the nearly optimal hardness of <span class="math">\\mathbf{Search\\text{-LWE}_{n,\\ell,q,\\chi_{\\text{sec}},\\chi_{\\text{err}}}}</span> (Assumption 1) where <span class="math">q</span> is even, <span class="math">\\chi_{\\text{sec}}</span> is the uniform distribution on <span class="math">\\{0,1\\}\\subset\\mathbb{Z}_{q}</span> (so the key length <span class="math">\\kappa</span> is <span class="math">n</span>) and <span class="math">\\chi_{\\text{err}}</span> is the uniform distribution on <span class="math">[-\\frac{q}{4},\\frac{q}{4})\\subset\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">######</p>

    <p class="text-gray-300">Indeed, secret-key Regev encryption (Definition 4.3) with distributions <span class="math">(\\chi_{\\text{sec}},\\chi_{\\text{err}})</span> as above immediately presents itself as a candidate encryption scheme. The reason that we choose <span class="math">\\chi_{\\text{sec}}</span> to be supported on <span class="math">\\{0,1\\}\\subset\\mathbb{Z}_{q}</span> is that <span class="math">\\mathcal{F}</span>-KDM security of this scheme for <span class="math">\\mathbb{Z}_{2}</span>-linear functions tightly follows from <span class="math">\\mathsf{LWE}</span>. The folklore security reduction works as follows. Let <span class="math">\\varphi:\\mathbb{F}_{2}^{n}\\to\\mathbb{F}_{2}^{\\ell}</span> be any affine function parameterized by a matrix <span class="math">C</span> and vector <span class="math">\\mathbf{d}</span> such that <span class="math">\\varphi(x)=\\mathbf{x}C+\\mathbf{d}</span>. Given an <span class="math">\\mathsf{LWE}</span> sample <span class="math">(A,\\mathbf{b}=\\mathbf{s}A+\\mathbf{e})</span> with <span class="math">A\\leftarrow\\mathbb{Z}_{q}^{n\\times\\ell}</span> and <span class="math">\\mathbf{e}^{t}\\leftarrow\\chi_{\\text{err}}</span>, one can efficiently produce a ciphertext, namely <span class="math">(A-\\frac{q}{2}\\cdot C,\\mathbf{b}+\\frac{q}{2}\\cdot\\mathbf{d})</span>, that is <em>identically distributed</em> to a Regev encryption of <span class="math">\\varphi(\\mathbf{s})=\\mathbf{s}C+\\mathbf{d}\\pmod{2}</span> with the above parameters. Therefore, if some adversary <span class="math">\\mathcal{A}</span> when given a Regev encryption <span class="math">\\mathsf{Enc}(\\mathbf{s},\\mathbf{s}B+\\mathbf{c}\\pmod{2})</span> recovers <span class="math">\\mathbf{s}</span> with probability <span class="math">\\epsilon</span>, then the adversary <span class="math">\\mathcal{A}^{\\prime}</span> that is given <span class="math">\\mathsf{LWE}</span> samples <span class="math">(A,\\mathbf{b})</span> and computes <span class="math">\\mathcal{A}(A-\\frac{q}{2}C,\\mathbf{b}+\\frac{q}{2}\\mathbf{d})</span> as above will also recover <span class="math">\\mathbf{s}</span> with probability <span class="math">\\epsilon</span>.</p>

    <p class="text-gray-300">Finally, we note that this scheme has universal ciphertexts (Definition 3.7) – indeed, for any <span class="math">\\mathbf{s}</span>, an encryption of a random bit-string under <span class="math">s</span> is a uniformly random string – so this completes our first construction and security proof.</p>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Arithmetic Randomized Encodings.</h4>

    <p class="text-gray-300">We next generalize the construction from Section 4.3.2 to rely on forms of <span class="math">\\mathsf{LWE}</span> with secrets that are <em>not</em> restricted to be elements of <span class="math">\\{0,1\\}^{n}</span>, and thus more plausibly are nearly optimally secure. Specifically, we will be able to have secrets that are uniformly random on the range <span class="math">[-\\frac{p}{2},\\frac{p}{2})^{n}</span> and errors that are uniformly random in the range <span class="math">[-\\frac{q^{\\prime}}{2},\\frac{q^{\\prime}}{2})^{\\ell}</span>, where <span class="math">p</span> is prime and <span class="math">q=pq^{\\prime}</span>. For example, setting <span class="math">q^{\\prime}=p</span>, we could rely on an <span class="math">\\mathsf{LWE}</span> assumption with secret and noise of order <span class="math">\\frac{1}{\\sqrt{q}}</span>.</p>

    <p class="text-gray-300">For this construction, we combine two tools: the KDM-secure encryption scheme of <em>[x1]</em> (appropriately modified to have the desired statistical property) and a slightly non-standard variant of <em>arithmetic randomized encodings</em> over <span class="math">\\mathbb{Z}_{p}</span> <em>[x1]</em>. We first describe the latter tool.</p>

    <h6 id="sec-53" class="text-base font-medium mt-4">Theorem 4.13.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be an arbitrary prime and let <span class="math">\\epsilon&gt;0</span>. Then, there is an unconditionally and information theoretically secure (non-universal) randomized encoding scheme <span class="math">\\mathsf{RE}_{p}^{\\mathsf{approx}}</span> for <span class="math">\\mathbb{Z}_{p}</span>-arithmetic circuits of depth at most <span class="math">d</span> <em>that compute</em> <span class="math">\\{0,1\\}^{\\ell}</span>-output functions with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}_{p}^{\\mathsf{approx}}</span> is perfectly secure.</li>

      <li><span class="math">\\mathsf{RE}_{p}^{\\mathsf{approx}}</span> is <span class="math">(1-\\epsilon)</span>-approximately blind for the output distribution that is uniform on <span class="math">\\{0,1\\}^{\\ell}\\subset\\mathbb{Z}_{p}^{\\ell}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The size of a randomized encoding of <span class="math">(C,x)</span> is $\\mathrm{poly}(\\log p,2^{d},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,\\log(\\frac{1}{\\epsilon}))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any fixed choice of randomness <span class="math">r</span>, the function <span class="math">\\mathsf{RE}_{p}^{\\mathsf{approx}}.\\mathsf{Enc}(C,x;r)</span> is a <span class="math">\\mathbb{Z}_{p}</span>-affine function of <span class="math">(C,x)</span>.</li>

    </ul>

    <p class="text-gray-300">In order to prove Theorem 4.13, we first construct an intermediate randomized encoding using the techniques of <em>[x1]</em>.</p>

    <h6 id="sec-54" class="text-base font-medium mt-4">Theorem 4.14.</h6>

    <p class="text-gray-300">Let <span class="math">p</span> be an arbitrary prime. Then, there is an unconditionally and information-theoretically secure (non-universal) randomized encoding scheme <span class="math">\\mathsf{RE}_{p}</span> for <span class="math">\\mathbb{Z}_{p}</span>-arithmetic circuits of depth at most <span class="math">d</span> with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}_{p}</span> is perfectly secure.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}_p</span> is perfectly blind for the uniform distribution on <span class="math">\\mathbb{Z}_p^t</span> (when the simulator is called on length-<span class="math">t</span> outputs).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The size of a randomized encoding of <span class="math">(C, x)</span> is $\\mathrm{poly}(\\log p, 2^d,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">C</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any fixed choice of randomness <span class="math">r</span>, the function <span class="math">\\mathsf{RE}_p \\cdot \\mathsf{Enc}(C, x; r)</span> is a <span class="math">\\mathbb{Z}_p</span>-affine function of <span class="math">(C, x)</span>.</li>

    </ul>

    <p class="text-gray-300">Proof. Our construction is a modification of [AIK11], Section 7.1; namely, we remove the key-shrinking gadget to obtain unconditional security.²²</p>

    <p class="text-gray-300">More formally, the construction is as follows: represent an arithmetic circuit</p>

    <div class="my-4 text-center"><span class="math-block">C = B_d \\circ \\dots \\circ B_2 \\circ B_1</span></div>

    <p class="text-gray-300">as a composition of <span class="math">d</span> depth-1 circuits (with fan-in 2). We now inductively define encodings <span class="math">\\mathsf{Enc}_i(C, y^{(i)}; r^{(i)})</span> and simulators <span class="math">\\mathsf{Sim}_i(C, y^{(d)})</span> as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Enc}_d(C, y^{(d)}; r) := y^{(d)}</span> and <span class="math">\\mathsf{Sim}_d(C, y^{(d)}) = y^{(d)}</span>.</li>

      <li>For each <span class="math">i &amp;lt; d</span>, define <span class="math">f_i(C, y^{(i)}; r^{(i+1)}) = \\mathsf{Enc}_{i+1}(C, B_{i+1}(y^{(i)}); r^{(i+1)})</span>. By the inductive hypothesis, each component <span class="math">\\mathbb{Z}_p</span>-element of <span class="math">f_{i,\\ell}(C, y^{(i)}; r^{(i+1)})</span> is either a quadratic or a linear function of (two components of) <span class="math">y^{(i)}</span>, with coefficients that may depend arbitrarily on <span class="math">r^{(i+1)}</span>.</li>

      <li>For every linear component <span class="math">f_i(\\cdot)_\\ell</span> of the form <span class="math">f_i(y^{(i)})_\\ell = a_\\ell \\cdot (y_j^{(i)} + y_k^{(i)}) + b_\\ell</span>, define</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,0}(C, y^{(i)}; r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r) = a_\\ell \\cdot y_j^{(i)} + r</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,1}(C, y^{(i)}, r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r) = a_\\ell \\cdot y_k^{(i)} + b_\\ell - r,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">where <span class="math">r \\in \\mathbb{Z}_p</span> is uniformly random. Define corresponding simulators</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Sim}_{i,\\ell,0}(C, \\tilde{y}_\\ell^{(i+1)}; r) = r</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Sim}_{i,\\ell,1}(C, y_\\ell^{(i+1)}; r) = \\tilde{y}_\\ell^{(i+1)} - r,</span></div>

    <p class="text-gray-300">where <span class="math">r \\in \\mathbb{Z}_p</span> is uniformly random.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For every quadratic component <span class="math">f_i(\\cdot)_\\ell</span> of the form <span class="math">a_\\ell \\cdot y_j^{(i)} \\cdot y_k^{(i)} + b_\\ell</span>, define</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,1,1}(C, y^{(i)}; r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r, s, t) = a_\\ell \\cdot y_j^{(i)} - r,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,1,2}(C, y^{(i)}, r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r, s, t) = s \\cdot a_\\ell \\cdot y_j^{(i)} + t,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,2,1}(C, y^{(i)}, r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r, s, t) = y_k^{(i)} - s,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{Enc}_{i,\\ell,2,2}(C, y^{(i)}, r^{(i+1)}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r, s, t) = r y_k^{(i)} + b_\\ell - t,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">²² [AIK11] notes that the construction with the key-shrinking gadget removed should give a randomized encoding scheme but does not actually analyze it. [AIK11] also notes that previous works give perfect randomized encodings with the parameters that we want, but it remains unclear if those schemes can be made perfectly blind.</p>

    <p class="text-gray-300">where <span class="math">r,s</span> and <span class="math">t</span> are uniformly random <span class="math">\\mathbb{Z}_{p}</span>-elements. Define corresponding simulators</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}_{i,\\ell,1,1}(C,\\tilde{y}_{\\ell}^{(i+1)};r,s,t)=r,</span> <span class="math">\\mathsf{Sim}_{i,\\ell,1,2}(C,\\tilde{y}_{\\ell}^{(i+1)},r,s,t)=t,</span> <span class="math">\\mathsf{Sim}_{i,\\ell,2,1}(C,\\tilde{y}_{\\ell}^{(i+1)},r,s,t)=s,</span> <span class="math">\\mathsf{Sim}_{i,\\ell,2,2}(C,\\tilde{y}_{\\ell}^{(i+1)},r,s,t)=\\tilde{y}_{\\ell}^{(i+1)}-rs-t,</span></p>

    <p class="text-gray-300">where <span class="math">r,s</span> and <span class="math">t</span> are uniformly random <span class="math">\\mathbb{Z}_{p}</span>-elements.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define the encoding algorithm</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Enc}_{i}(C,y^{(i)})=\\left(\\mathsf{Enc}_{i,\\ell,b,c}(C,y^{(i)};r^{(i+1)}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r_{\\ell},s_{\\ell},t_{\\ell})\\right)_{\\ell,b,c}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">and simulator</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\mathsf{Sim}_{i}(C,y^{(d)})=\\left(\\mathsf{Sim}_{i,\\ell,b,c}(C,\\tilde{y}_{\\ell}^{(i+1)};r_{\\ell}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">s_{\\ell},t_{\\ell})\\right)_{\\ell,b,c}$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where <span class="math">\\tilde{y}^{(i+1)}=(\\tilde{y}_{\\ell}^{(i+1)})\\leftarrow\\mathsf{Sim}_{i+1}(C,y^{(d)})</span>.</p>

    <p class="text-gray-300">Finally, the overall encoding algorithm <span class="math">\\mathsf{RE}_{p}.\\mathsf{Enc}</span> is defined to be <span class="math">\\mathsf{Enc}_{0}</span> with associated simulator <span class="math">\\mathsf{RE}_{p}.\\mathsf{Sim}=\\mathsf{Sim}_{0}</span>.</p>

    <p class="text-gray-300">For decoding, <span class="math">\\mathsf{Dec}_{d}(\\tilde{y}_{d})</span> is defined to output <span class="math">\\tilde{y}_{d}</span>, and <span class="math">\\mathsf{Dec}_{i}</span> is defined to add every pair of “additive” encodings <span class="math">(z_{1},z_{2})\\mapsto z_{1}+z_{2}</span>, combine multiplicative encodings by computing <span class="math">(z_{1},z_{2},z_{3},z_{4})\\mapsto z_{1}z_{3}+z_{2}+z_{4}</span>, and then iteratively call <span class="math">\\mathsf{Dec}_{i+1}</span> on the resulting concatenation of <span class="math">\\mathbb{Z}_{p}</span>-elements. The algorithm <span class="math">\\mathsf{Dec}_{0}</span> is then defined to be the decoding algorithm associated to <span class="math">\\mathsf{RE}_{p}.\\mathsf{Enc}</span>.</p>

    <p class="text-gray-300">Correctness of the above scheme is clear by inspection. We argue by induction that this scheme is perfectly private and perfectly blind.</p>

    <p class="text-gray-300">Perfect blindness is shown inductively as follows: <span class="math">\\mathsf{Sim}_{d}(C,y^{(d)}):=y^{(d)}</span> is a uniformly random string when <span class="math">y^{(d)}</span> is uniformly random. Moreover, if <span class="math">\\mathsf{Sim}_{i+1}(C,y^{(d)})</span> is a uniformly random string when <span class="math">y^{(d)}</span> is a uniformly random string, then <span class="math">\\mathsf{Sim}_{i}(C,y^{(d)})</span> is also uniformly random, as for each <span class="math">\\mathbb{Z}_{p}</span>-element <span class="math">\\tilde{y}_{\\ell}^{(i+1)}</span> of <span class="math">\\mathsf{Sim}_{i+1}</span>, the four (or two, in the additive case) <span class="math">\\mathbb{Z}_{p}</span>-elements in the corresponding <span class="math">\\mathsf{Sim}_{i}</span>-simulation are sampled to be uniformly random strings <span class="math">(r,s,t,u)</span> subject to the equation <span class="math">rs+t+u=\\tilde{y}_{\\ell}^{(i+1)}</span> (or <span class="math">r+s=\\tilde{y}_{\\ell}^{(i+1)}</span> in the additive case). Thus, by induction we conclude that <span class="math">\\mathsf{Sim}_{0}</span> is perfectly blind.</p>

    <p class="text-gray-300">Perfect privacy follows by a similar inductive argument; namely, <span class="math">\\mathsf{Sim}_{d}(C,y^{(d)})</span> is clearly a perfectly private simulator for the identity function, and if <span class="math">\\mathsf{Sim}_{i+1}(C,y^{(d)})</span> is a perfectly private simulator for the function <span class="math">B_{d}\\circ\\ldots\\circ B_{i+2}</span>, then we see that <span class="math">\\mathsf{Sim}_{i}(C,y^{(d)})</span> is a perfectly private simulator for the function <span class="math">B_{d}\\circ\\ldots\\circ B_{i+1}</span>. To see this, we note that for every circuit-input pair <span class="math">(C,y^{(i)})</span>, we have</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Sim}_{i}\\big{(}C,y_{d}:=(B_{d}\\circ\\ldots\\circ B_{i+1})(y^{(i)})\\big{)}\\equiv\\Big{(}\\mathsf{Sim}_{i,\\ell,b,c}(C,\\tilde{y}_{\\ell}^{(i+1)};r_{\\ell},s_{\\ell},t_{\\ell})\\Big{)}_{\\ell,b,c}</span></p>

    <p class="text-gray-300">for <span class="math">\\tilde{y}^{(i+1)}\\leftarrow\\mathsf{Sim}_{i+1}(C,y^{(i)})</span>. By the induction hypothesis, we know that <span class="math">\\mathsf{Sim}_{i+1}(C,y_{d})</span> is identically distributed to <span class="math">\\tilde{y}^{(i+1)}\\leftarrow\\mathsf{Enc}_{i+1}\\big{(}C,B_{i+1}(y^{(i)})\\big{)}</span>. Thus, it suffices to show that the distribution <span class="math">\\Big{(}\\mathsf{Sim}_{i,\\ell,b,c}(C,\\tilde{y}_{\\ell}^{(i+1)};r_{\\ell},s_{\\ell},t_{\\ell})\\Big{)}_{\\ell,b,c}</span> is identical to the distribution <span class="math">\\Big{(}\\mathsf{Enc}_{i,\\ell,b,c}(C,y^{(i)};r^{(i+1)},(r_{\\ell},s_{\\ell},t_{\\ell}))\\Big{)}_{\\ell,b,c}</span>.</p>

    <p class="text-gray-300">But for each <span class="math">\\ell</span>, the corresponding component <span class="math">\\left(\\mathsf{Enc}_{i,\\ell,b,c}(C,y^{(i)};r^{(i+1)},(r_{\\ell},s_{\\ell},t_{\\ell}))\\right)_{b,c}</span> is simply a uniformly random tuple <span class="math">(\\alpha,\\beta,\\gamma,\\delta)\\in\\mathbb{Z}_p^4</span> subject to the constraint that <span class="math">\\alpha\\gamma+\\beta+\\delta=\\tilde{y}_{\\ell}^{(i+1)}</span> (or a random tuple <span class="math">(\\alpha,\\beta)</span> subject to <span class="math">\\alpha+\\beta=\\tilde{y}_{\\ell}^{(i+1)}</span> in the additive case), which exactly matches the corresponding distribution <span class="math">\\left(\\mathsf{Sim}_{i,\\ell,b,c}(C,\\tilde{y}_{\\ell}^{(i+1)};r_{\\ell},s_{\\ell},t_{\\ell})\\right)_{b,c}</span>. This completes the induction, and hence the proof of Theorem 4.14.</p>

    <p class="text-gray-300">Using Theorem 4.14, we now prove Theorem 4.13.</p>

    <p class="text-gray-300">Proof. The randomized encoding scheme <span class="math">\\mathsf{RE}_p^{\\mathsf{approx}}</span> for circuits of output length <span class="math">\\ell</span> is defined as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}_p^{\\mathsf{approx}}.\\mathsf{Enc}(C,x;\\mathbf{R},\\mathbf{r}_0,\\mathbf{r}_1)</span> uses as randomness <span class="math">\\mathbf{R}</span> for <span class="math">\\mathsf{RE}_p.\\mathsf{Enc}</span> as in Theorem 4.14 along with (for each <span class="math">i\\in[\\ell]</span>) <span class="math">\\mathbb{Z}_p^{\\log(\\frac{\\ell}{\\epsilon})}</span>-elements <span class="math">r_{0,i}</span> sampled uniformly from the set <span class="math">\\{0,1,\\ldots,\\frac{p^{\\log(\\frac{\\ell}{\\epsilon})}-1}{2}\\}</span> and <span class="math">\\mathbb{Z}_p^{\\log(\\frac{\\ell}{\\epsilon})}</span>-elements <span class="math">r_{1,i}</span> sampled uniformly from the set <span class="math">\\{\\frac{p^{\\log(\\frac{\\ell}{\\epsilon})}+1}{2},\\ldots,p^{\\log(\\frac{\\ell}{\\epsilon})}-1\\}</span>. It outputs</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {R E} _ {p}. \\mathsf {E n c} (C ^ {\\prime}, (x, \\mathbf {r} _ {0}, \\mathbf {r} _ {1}); \\mathbf {R})</span></div>

    <p class="text-gray-300">where <span class="math">C&#x27;(x, \\mathbf{r}_0, \\mathbf{r}_1) = \\mathbf{r}[y] := (r_{y_i,i})_i \\in \\mathbb{Z}_p^{\\ell \\log(\\frac{\\ell}{\\epsilon})}</span> for <span class="math">y = C(x)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{RE}_p^{\\mathsf{approx}}.\\mathsf{Dec}(C,\\tilde{y})</span> computes <span class="math">\\mathbf{r} = \\mathsf{RE}_p.\\mathsf{Dec}(C&#x27;,\\tilde{y})</span> and then sets output bit <span class="math">y_i</span> to 0 if and only if <span class="math">0 \\leq r_i \\leq \\frac{p^{\\log(\\frac{\\ell}{\\epsilon})} - 1}{2}</span> (and sets <span class="math">y_i = 1</span> otherwise).</li>

      <li>The simulator <span class="math">\\mathsf{RE}_p^{\\mathsf{approx}}.\\mathsf{Sim}(C,y)</span> will sample <span class="math">(\\mathbf{r}_0,\\mathbf{r}_1)</span> as above and output <span class="math">\\mathsf{RE}_p.\\mathsf{Sim}(C&#x27;,\\mathbf{r}_y)</span>.</li>

    </ul>

    <p class="text-gray-300">Perfect correctness of the above scheme is clear by inspection. Moreover, perfect privacy is also clear: for any <span class="math">(C,x,\\mathbf{r}_0,\\mathbf{r}_1)</span>, we know that <span class="math">\\mathsf{RE}_p.\\mathsf{Sim}(C&#x27;,\\mathbf{r}[C(x)])</span> is identical to the distribution <span class="math">\\mathsf{RE}_p.\\mathsf{Enc}(C&#x27;,(x,\\mathbf{r}_0,\\mathbf{r}_1))</span>, which immediately implies perfect privacy of the new scheme.</p>

    <p class="text-gray-300">Finally, we see that the scheme is <span class="math">(1 - \\epsilon)</span>-approximately blind, as for a uniformly random bit <span class="math">y_{i}</span>, the resulting distribution on <span class="math">r = r_{y_i}</span> is a <span class="math">(1 - \\frac{1}{p^{\\log(\\frac{\\ell}{\\epsilon})}})</span>-multiplicative approximation of the uniform distribution on <span class="math">\\mathbb{Z}_p</span> (and is <span class="math">(1 - \\frac{1}{p^{\\log(\\frac{\\ell}{\\epsilon})}})</span>-multiplicatively approximated by the same distribution). By repetition, we see that for a uniformly random <span class="math">y</span>, the resulting distribution on <span class="math">\\mathbf{r} = \\mathbf{r}[y]</span> is <span class="math">(1 - \\epsilon)</span>-multiplicatively comparable to the uniform distribution on <span class="math">\\mathbb{Z}_p^{\\ell \\log (\\frac{\\ell}{\\epsilon})}</span>. Thus, <span class="math">(1 - \\epsilon)</span>-approximate blindness follows from the perfect blindness of <span class="math">\\mathsf{RE}_p</span>.</p>

    <p class="text-gray-300">We now combine Theorem 4.13 with Imported Theorem 4.12 to obtain a randomized encoding scheme <span class="math">\\widetilde{\\mathsf{RE}}_p</span> satisfying the structural and security properties required to be used with an [ACPS09]-like encryption scheme. In this scheme, we consider the following notion of evaluating boolean circuits on <span class="math">\\mathbb{Z}_p</span>-inputs: if <span class="math">C</span> is a boolean circuit with input length <span class="math">\\kappa \\cdot \\lceil \\log(p) \\rceil</span> and <span class="math">x \\in \\mathbb{Z}_p^\\kappa</span>, we define <span class="math">C(x) := C(\\llbracket x \\rrbracket := (\\llbracket x \\rrbracket_1, \\ldots, \\llbracket x \\rrbracket_{\\kappa \\lceil \\log(p) \\rceil}))</span>, where <span class="math">\\llbracket x \\rrbracket_i</span> is defined to be the <span class="math">i</span>th bit of <span class="math">x</span> in the representation <span class="math">[0, p-1]^\\kappa \\subset (\\{0, 1\\}^{\\lceil \\log(p) \\rceil})^\\kappa</span>. We consider randomized encodings of circuit-input pairs <span class="math">(C, x)</span> of this form, in which encodings are strings over the alphabet <span class="math">\\mathbb{Z}_p</span>.</p>

    <p class="text-gray-300">29</p>

    <h6 id="sec-55" class="text-base font-medium mt-4">Theorem 4.15.</h6>

    <p class="text-gray-300">Let <span class="math">p=p(\\kappa)</span> be an arbitrary prime (sequence) and <span class="math">\\epsilon=\\epsilon(\\kappa)&gt;0</span>. If sub-exponentially secure one-way functions exist, there is a universal randomized encoding scheme <span class="math">\\widetilde{\\mathsf{RE}}_{p}</span> for polynomial-size boolean circuits with <span class="math">\\mathbb{Z}_{p}</span>-inputs with the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\widetilde{\\mathsf{RE}}_{p}</span> is <span class="math">o(2^{-\\kappa})</span>-secure, and all operations run in time <span class="math">\\mathrm{poly}(\\kappa,p)</span>.</li>

      <li><span class="math">\\widetilde{\\mathsf{RE}}_{p}</span> is <span class="math">(1-\\epsilon)</span>-approximately blind.</li>

      <li>For any fixed choice of randomness <span class="math">r</span> and circuit <span class="math">C</span>, the function <span class="math">\\widetilde{\\mathsf{RE}}_{p}.\\mathsf{Enc}(C,x;r)</span> is a <span class="math">\\mathbb{Z}_{p}</span>-affine function of <span class="math">x</span>.</li>

    </ul>

    <h6 id="sec-56" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The randomized encoding scheme <span class="math">\\widetilde{\\mathsf{RE}}_{p}</span> is a certain kind of composition of <span class="math">\\mathsf{RE}_{p}</span> with point-and-permute garbled circuits (which we denote by <span class="math">\\mathsf{RE}</span>). More specifially, <span class="math">\\widetilde{\\mathsf{RE}}_{p}</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A circuit <span class="math">C</span>, input <span class="math">x\\in\\mathbb{Z}_{p}^{n}</span>, and randomness <span class="math">r_{1},r_{2}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Compute <span class="math">f_{2}(r_{1})</span>, where $\\mathsf{RE}.\\mathsf{Enc}(C,\\llbracket x\\rrbracket\\,;r_{1})=f_{1}(C,\\llbracket x\\rrbracket\\,;r_{1})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f_{2}(r_{1})$ as in Imported Theorem 4.12.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output <span class="math">\\mathsf{RE}_{p}.\\mathsf{Enc}(\\tilde{f}_{1},(C,x,r_{1},f_{2}(r_{1});r_{2})</span>, where <span class="math">\\tilde{f}_{1}(C,x,r,r^{\\prime})\\overset{\\mathsf{def}}{=}(f_{1}(C,\\llbracket x\\rrbracket\\,;r),r^{\\prime})</span> is interpreted as a <span class="math">\\mathbb{Z}_{p}</span>-arithmetic circuit and the bit-strings <span class="math">C</span> and <span class="math">r</span> are interpreted as strings over the alphabet <span class="math">\\{0,1\\}\\subset\\mathbb{Z}_{p}</span>.</li>

    </ul>

    <p class="text-gray-300">To see that this scheme is efficient, we note that <span class="math">\\mathsf{RE}_{p}</span> is only used to compute randomized encodings of a function <span class="math">\\tilde{f}_{1}(C,x,r,r^{\\prime})</span> with the property that each output bit depends on a constant number of bits of <span class="math">\\llbracket x\\rrbracket</span> and a constant number of bits of <span class="math">(C,r,r^{\\prime})</span>. This in turn depends on only a constant number of <span class="math">\\mathbb{Z}_{p}</span>-blocks of the input <span class="math">(C,x,r,r^{\\prime})</span>. We claim that any such function can be computed by a <span class="math">O(\\log(p))</span>-depth <span class="math">\\mathbb{Z}_{p}</span>-arithmetic circuit: a function <span class="math">\\tilde{f}(z_{1},\\ldots,z_{c})</span> of <span class="math">c</span>-many <span class="math">\\mathbb{Z}_{p}</span> symbols can be expressed in the following form:</p>

    <p class="text-gray-300"><span class="math">\\tilde{f}(z_{1},\\ldots,z_{c})=\\sum_{a_{1},\\ldots,a_{c}\\in\\mathbb{Z}_{p}}\\tilde{f}(a_{1},\\ldots,a_{c})\\prod_{i=1}^{c}(1-(z_{i}-a_{i})^{p-1}).</span></p>

    <p class="text-gray-300">The outer sum can be computed in <span class="math">\\log(p)</span> depth, and each term can be computed in at most <span class="math">1+\\log(c)+\\log(p)</span> depth with repeated squaring. Thus, <span class="math">\\mathsf{RE}_{p}</span> can be used to encode the function <span class="math">\\tilde{f}</span> with the desired efficiency.</p>

    <p class="text-gray-300">The simulator for this scheme <span class="math">\\widetilde{\\mathsf{RE}}_{p}.\\mathsf{Sim}(y)</span> will simply call <span class="math">\\mathsf{RE}_{p}.\\mathsf{Sim}(\\mathsf{RE}.\\mathsf{Sim}(y))</span>. Simulation security follows from a standard hybrid argument.</p>

    <p class="text-gray-300">Finally, <span class="math">(1-\\epsilon)</span>-approximate blindness follows because <span class="math">\\mathsf{RE}.\\mathsf{Sim}(U_{\\ell})</span> is identical to the uniform distribution on binary strings of the appropriate length by the perfect blindness of <span class="math">\\mathsf{RE}</span>, and so <span class="math">\\widetilde{\\mathsf{RE}}_{p}.\\mathsf{Sim}(\\mathsf{RE}.\\mathsf{Sim}(U_{\\ell}))</span> is <span class="math">(1-\\epsilon)</span>-approximately comparable to the uniform distribution on <span class="math">\\mathbb{Z}_{p}</span>-strings of the appropriate length by the <span class="math">(1-\\epsilon)</span>-approximate blindness of <span class="math">\\widetilde{\\mathsf{RE}}_{p}</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">A Scheme from Exponential LWE with Moderately Small Secrets.</p>

    <p class="text-gray-300">Combining Theorem 4.11 with Theorem 4.15, we conclude that to construct a <span class="math">\\mathsf{SIZE}(\\kappa^{c})</span>-KDM <span class="math">2^{-\\kappa}\\mathrm{poly}(\\kappa)</span>-secure encryption scheme with universal ciphertexts, it suffices to construct a <span class="math">\\mathcal{F}</span>-KDM <span class="math">2^{-\\kappa}\\mathrm{poly}(\\kappa)</span>-secure encryption scheme (with universal ciphertexts), where <span class="math">\\mathcal{F}</span> is the class of all <span class="math">\\mathbb{Z}_{p}</span>-linear functions.</p>

    <p class="text-gray-300">We now claim that such an encryption scheme exists assuming the exponential hardness of <span class="math">\\mathsf{LWE}_{n,\\ell,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> (Assumption 1) where <span class="math">q=pq^{\\prime}</span> for some <span class="math">q^{\\prime}</span>, <span class="math">\\chi_{\\mathrm{sec}}</span> is the uniform distribution on <span class="math">[-\\frac{p}{2},\\frac{p}{2})\\subset\\mathbb{Z}_{q}</span> and <span class="math">\\chi_{\\mathrm{err}}</span> is the uniform distribution on <span class="math">[-\\frac{q}{2p},\\frac{q}{2p})\\subset\\mathbb{Z}_{q}</span>.</p>

    <p class="text-gray-300">To do this, we will use a modification of secret-key Regev encryption in the spirit of <em>[x1]</em>. Our scheme <span class="math">(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})</span> is as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Gen}(1^{n},q,p)</span> samples a uniformly random <span class="math">s\\leftarrow[-\\frac{p}{2},\\frac{p}{2})^{n}\\subset\\mathbb{Z}_{q}^{n}</span>.</li>

      <li><span class="math">\\mathsf{Enc}(s,m\\in\\mathbb{Z}_{p}^{\\ell})</span> samples a uniformly random matrix <span class="math">A\\leftarrow\\mathbb{Z}_{q}^{n\\times\\ell}</span> and error <span class="math">e\\leftarrow[-\\frac{q}{2p},\\frac{q}{2p})^{\\ell}</span> and outputs <span class="math">(A,s^{t}A+e^{t}+q^{\\prime}\\cdot m)</span>.</li>

      <li><span class="math">\\mathsf{Dec}(s,\\mathsf{ct})</span> interprets <span class="math">\\mathsf{ct}=(A,b)</span>, computes <span class="math">b-s^{t}A\\pmod{q}</span>, rounds each entry to the nearest multiple of <span class="math">q^{\\prime}</span>, and divides each entry by <span class="math">q^{\\prime}</span>.</li>

    </ul>

    <p class="text-gray-300">Correctness of the encryption scheme is clear. Moreover, <span class="math">(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})</span> satisfies the statistical property required of a CCRR-compatible encryption scheme, as for any fixed <span class="math">s</span>, a random encryption <span class="math">\\mathsf{Enc}(s,U_{\\ell,p})</span> is identical to a uniformly random element of <span class="math">\\mathbb{Z}_{q}^{n\\times\\ell}\\times\\mathbb{Z}_{q}^{\\ell}</span>.</p>

    <p class="text-gray-300">Finally, we see that our scheme satisfies exponential KDM-security for <span class="math">\\mathbb{F}_{p}</span>-affine functions of the secret key by a similar reduction to that of Section 4.3.2. Namely, for a secret <span class="math">s\\leftarrow[-\\frac{p}{2},\\frac{p}{2})^{n}</span>, given an <span class="math">\\mathsf{LWE}_{n,\\ell,q,\\chi_{\\mathrm{sec}},\\chi_{\\mathrm{err}}}</span> sample <span class="math">(A,b=s^{t}A+e^{t})</span> with <span class="math">A\\leftarrow\\mathbb{Z}_{q}^{n\\times\\ell^{\\prime}}</span>, one can efficiently produce a ciphertext <span class="math">(A-2q^{\\prime}B,b+c)</span> that is <em>identically distributed</em> to a Regev encryption of <span class="math">s^{t}B+c\\pmod{p}</span> with the above parameters. Therefore, if some adversary <span class="math">\\mathcal{A}</span> that is given a Regev encryption <span class="math">\\mathsf{Enc}(s,s^{t}B+c\\pmod{p})</span> recovers <span class="math">s</span> with probability <span class="math">\\epsilon</span>, then the adversary <span class="math">\\mathcal{A}^{\\prime}</span> that is given an LWE sample <span class="math">(A,b)</span> and computes <span class="math">\\mathcal{A}(A-2q^{\\prime}B,b+c)</span> as above will also recover <span class="math">s</span> with probability <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-57" class="text-base font-medium mt-4">Discussion.</h6>

    <p class="text-gray-300">Our scheme most notably differs from that of <em>[x1]</em> in our choice of error distribution (which is also made possible by the fact that we consider a secret-key variant). Namely, <em>[x1]</em> takes the error distribution <span class="math">\\chi_{\\mathrm{err}}</span> to be the same as <span class="math">\\chi_{\\mathrm{sec}}</span> (and they use Gaussian distributions of width <span class="math">\\Theta(p)</span> rather than uniform distributions as well). Using uniformly random secrets (over intervals) and errors is required for the exponential security and statistical properties of our encryption scheme to plausibly hold. However, we note that it is also possible to rely on an LWE assumption in which our error distribution <span class="math">\\chi_{\\mathrm{err}}</span> is instead uniform on <span class="math">[-\\frac{p}{2},\\frac{p}{2})</span> (i.e. the same as <span class="math">\\chi_{\\mathrm{sec}}</span>). Namely, this LWE variant actually follows from the LWE variant that we assume here, with the caveat that we must then take <span class="math">q&gt;\\ell\\cdot p</span>. The reduction is similar to the high-noise-to-low-noise reduction in Theorem 4.6.</p>

    <h5 id="sec-58" class="text-base font-semibold mt-4">A Scheme from ElGamal Encryption.</h5>

    <p class="text-gray-300">In addition to our LWE-based constructions, we note that by combining our amplification theorem (Theorem 4.11) with point-and-permute garbled circuits, we can generically reduce the problem of constructing <span class="math">\\mathsf{SIZE}(\\kappa^{c})</span>-KDM secure encryption schemes (with universal ciphertexts and almost optimal security) to constructing <em>circular</em> secure encryption schemes (with the same properties). In particular, we can plug in the variant of ElGamal encryption defined in <em>[x10]</em>. We immediately conclude that if this variant of ElGamal</p>

    <p class="text-gray-300">encryption satisfies almost optimal circular security, then NIZK arguments exist (combining Theorem 4.11 and Theorem 7.7).</p>

    <h2 id="sec-59" class="text-2xl font-bold">5 Round-by-Round Soundness and Fiat-Shamir</h2>

    <p class="text-gray-300">In this section we define the notion of an interactive proof with <em>round-by-round</em> soundness, and prove that correlation intractability for a specific related relation is sufficient for a hash family to ensure that the associated Fiat-Shamir heuristic is sound.</p>

    <h3 id="sec-60" class="text-xl font-semibold mt-8">5.1 Definitions: Interactive Proofs and Arguments</h3>

    <p class="text-gray-300">We being by recalling the definitions of interactive proofs and arguments. We focus on <em>doubly-efficient</em> proof-systems, in which the prover is polynomial-time and the verifier is quasi-linear.</p>

    <h6 id="sec-61" class="text-base font-medium mt-4">Definition 5.1.</h6>

    <p class="text-gray-300">A <em>doubly-efficient interactive proof</em> (resp., <em>interactive argument</em>) for a promise problem <span class="math">\\mathcal{L}=(\\mathcal{L}_{\\textsf{yes}},\\mathcal{L}_{\\textsf{no}})</span> is a pair <span class="math">(P,V)</span> of interactive algorithms satisfying:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Completeness. For any <span class="math">x\\in\\mathcal{L}_{\\textsf{yes}}</span>, when <span class="math">P</span> and <span class="math">V</span> interact on common input <span class="math">x</span>, the verifier <span class="math">V</span> outputs <span class="math">1</span> with probability <span class="math">1</span>.</li>

      <li>Soundness. For any <span class="math">x\\in\\mathcal{L}_{\\textsf{no}}\\cap\\{0,1\\}^{n}</span> and any <em>unbounded</em> (resp., <em>polynomial-time</em>) interactive <span class="math">P^{<em>}</span>, when <span class="math">P^{</em>}</span> and <span class="math">V(x)</span> interact, the probability that <span class="math">V</span> outputs <span class="math">1</span> is a negligible function of <span class="math">n</span>.</li>

      <li>Efficiency. <span class="math">V</span> runs in time <span class="math">\\tilde{O}(n)</span> and <span class="math">P</span> runs in <span class="math">\\operatorname{poly}(n)</span> time, where <span class="math">n</span> is the input length.</li>

    </ul>

    <p class="text-gray-300">The protocol is <em>public coin</em> if each of <span class="math">V</span>’s messages is an independent uniformly random string of some length (and the verifier’s decision to accept or reject does not use any secret state).</p>

    <h6 id="sec-62" class="text-base font-medium mt-4">Definition 5.2.</h6>

    <p class="text-gray-300">A <em>two-message</em> argument scheme is one in which the interaction consists of a single message from the verifier to the prover followed by a single message from the prover to the verifier. The scheme is <em>delayed input</em> if the joint distribution of the first message <em>together with the resulting verifier state</em> also depends only on <span class="math">n</span>.</p>

    <p class="text-gray-300">A delayed-input two-message argument scheme is said to be <em>adaptively sound</em> if soundness holds for a cheating prover that chooses <span class="math">x</span> <em>after</em> seeing the verifier’s first message. The scheme is <em>publicly verifiable</em> if the verifier’s first message includes the verifier’s subsequent state.</p>

    <h3 id="sec-63" class="text-xl font-semibold mt-8">5.2 Round-by-Round Soundness</h3>

    <h6 id="sec-64" class="text-base font-medium mt-4">Definition 5.3 (Round-by-Round Soundness).</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(P,V)</span> be a <span class="math">2r</span>-message public coin interactive proof system for a language <span class="math">L</span>. For any <span class="math">x\\in\\{0,1\\}^{*}</span>, and any prefix <span class="math">\\tau</span> of a protocol transcript, let <span class="math">V(x,\\tau)</span> denote the distribution of the next message (or output) of <span class="math">V</span> when the transcript so far is <span class="math">\\tau</span> and <span class="math">V</span> was executed on input <span class="math">x</span>.</p>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> has <em>round-by-round soundness error</em> <span class="math">\\epsilon(\\cdot)</span> if there exists a deterministic (not necessarily efficiently computable) function <span class="math">\\mathsf{State}</span> that takes as input an instance <span class="math">x</span> and a transcript prefix <span class="math">\\tau</span> and outputs either <em>accept</em> or <em>reject</em> such that the following properties hold:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x\\not\\in L</span>, then <span class="math">\\mathsf{State}(x,\\emptyset)=\\mathsf{reject}</span>, where <span class="math">\\emptyset</span> denotes the empty transcript.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathsf{State}(x,\\tau)=\\mathsf{reject}</span> for a transcript prefix <span class="math">\\tau</span>, then for every potential prover message <span class="math">\\alpha</span>, it holds that</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta\\leftarrow V(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha)}\\Big{[}\\mathsf{State}(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta)=\\mathsf{accept}\\Big{]}\\leq\\epsilon(n)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <em>full</em> transcript <span class="math">\\tau</span>, if <span class="math">\\mathsf{State}(x,\\tau)=\\mathsf{reject}</span> then <span class="math">V(x,\\tau)=0</span>.</li>

    </ol>

    <p class="text-gray-300">We say that <span class="math">\\Pi</span> is round-by-round sound if it has round-by-round soundness error <span class="math">\\epsilon</span> for some <span class="math">\\epsilon(n)=\\mathrm{negl}(n)</span>.</p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Remark 5.1.</h6>

    <p class="text-gray-300">The completeness condition of the interactive proof implies that for <span class="math">x\\in L</span> (i.e., a YES instance) and an honestly generated transcript <span class="math">\\tau</span>, with high probability over the coins tossed, it holds that <span class="math">\\mathsf{State}(x,\\tau)=\\mathsf{accept}</span>.</p>

    <p class="text-gray-300">Before diving into the proof that the Fiat-Shamir paradigm can be applied to any interactive proof with round-by-round soundness (in Section 5.3), we first discuss some basic properties of these type of protocols.</p>

    <h4 id="sec-66" class="text-lg font-semibold mt-6">Round-by-round Soundness vs. Standard Soundness.</h4>

    <p class="text-gray-300">A first basic observation is that round-by-round soundness implies standard soundness (with a loss proportional to the number of rounds).</p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proposition 5.4.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be <span class="math">2r</span>-message interactive proof with round-by-round soundness error <span class="math">\\epsilon</span>. Then, <span class="math">\\Pi</span> has standard soundness error <span class="math">r\\cdot\\epsilon</span>.</p>

    <h6 id="sec-68" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By a union bound over the error in all of the rounds. ∎</p>

    <p class="text-gray-300">Conversely, standard soundness implies <em>some</em> (smaller) amount of round-by-round soundness.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Proposition 5.5.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi</span> be a <span class="math">2r</span>-message interactive proof with soundness error <span class="math">\\mu</span>. Then, <span class="math">\\Pi</span> has round-by-round soundness error <span class="math">\\mu^{\\frac{1}{r}}</span>.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Let <span class="math">\\Pi=(P,V)</span> denote a <span class="math">2r</span>-message (public coin) interactive proof with soundness error <span class="math">\\mu</span>. We associate to <span class="math">\\Pi</span> the following <span class="math">\\mathsf{State}</span> function, defined inductively for partial transcripts of length <span class="math">2i</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given a full transcript <span class="math">\\tau</span>, we define <span class="math">\\mathsf{State}(x,\\tau)=\\mathsf{accept}</span> if and only if <span class="math">V(x,\\tau)</span> accepts.</li>

      <li>Inductively, given a transcript <span class="math">\\tau</span> of length <span class="math">2i</span>, we define <span class="math">\\mathsf{State}(x,\\tau)=\\mathsf{accept}</span> if and only if there exists a message <span class="math">\\alpha_{i+1}^{*}</span> such that</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\Pr_{\\beta_{i+1}}\\big{[}\\mathsf{State}(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i+1}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i+1})=\\mathsf{accept}\\big{]}>\\mu^{\\frac{1}{r}}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We claim that <span class="math">\\Pi</span> has round-by-round soundness error <span class="math">\\mu^{\\frac{1}{r}}</span> with respect to this <span class="math">\\mathsf{State}</span> function. We note that properties (2) and (3) of round-by-round soundness are satisfied by construction. All that we need to verify is property (1), i.e., that <span class="math">\\mathsf{State}(x,\\emptyset)=\\mathsf{reject}</span> for <span class="math">x\\not\\in L</span>. To see this, we note</p>

    <p class="text-gray-300">that if <span class="math">x \\notin L</span> but <span class="math">\\mathsf{State}(x, \\emptyset) = \\mathsf{accept}</span>, then by definition of <span class="math">\\mathsf{State}</span>, there exists a prover strategy <span class="math">P^*</span> such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr_{\\beta = (\\beta_1, \\dots, \\beta_r)} \\left[ \\mathsf{State}(x, \\tau_{P^*, \\beta}) = \\mathsf{accept} \\right] &amp;gt; (\\mu^{\\frac{1}{r}})^r = \\mu,</span></div>

    <p class="text-gray-300">where <span class="math">\\tau_{P^<em>,\\beta}</span> denotes the transcript associated to prover strategy <span class="math">P^</em></span> and verifier messages <span class="math">\\beta</span>. This contradicts the <span class="math">\\mu</span>-soundness of <span class="math">\\Pi</span> (since if <span class="math">\\mathsf{State}(x, \\tau_{P^*,\\beta}) = \\mathsf{accept}</span> then the verifier accepts). Thus, we conclude that <span class="math">\\Pi</span> satisfies round-by-round <span class="math">\\mu^{\\frac{1}{r}}</span>-soundness with respect to <span class="math">\\mathsf{State}</span>, as desired.</p>

    <p class="text-gray-300">Finally, we note that Proposition 5.5 is tight in its security loss.</p>

    <p class="text-gray-300"><strong>Proposition 5.6.</strong> There exists an <span class="math">r</span>-round interactive proof with soundness error <span class="math">2^{-r}</span> that does not have round-by-round soundness error <span class="math">\\frac{1}{2} - \\epsilon</span> for any <span class="math">\\epsilon &amp;gt; 0</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Consider the following interactive proof for the empty language. On input <span class="math">x \\in \\{0,1\\}^n</span>, the protocol proceeds as follows. In each round the prover sends nothing, then the verifier tosses a fresh coin and sends the result to the prover. After <span class="math">r</span> rounds the verifier accepts if and only if all coin tosses were 0.</p>

    <p class="text-gray-300">Clearly this constitutes an interactive proof for the empty language (with soundness error <span class="math">2^{-r}</span>). Suppose that the protocol has round-by-round soundness error <span class="math">1/2 - \\epsilon</span> and let <span class="math">\\mathsf{State}</span> be a corresponding state function. Fix also an arbitrary input <span class="math">x^*</span> (a NO input, needless to say).</p>

    <p class="text-gray-300">By the first property of round-by-round soundness <span class="math">\\mathsf{State}(x^<em>, \\emptyset) = \\mathsf{reject}</span>. On the other hand, by the third property, it holds that <span class="math">\\mathsf{State}(x^</em>, 0^r) = \\mathsf{accept}</span> (since the verifier accepts in case all coin tosses were 0).</p>

    <p class="text-gray-300">Thus, there must exist <span class="math">i \\in [r]</span> such that <span class="math">\\mathsf{State}(x^<em>, 0^i) = \\mathsf{reject}</span> and <span class="math">\\mathsf{State}(x^</em>, 0^{i+1}) = \\mathsf{accept}</span>. This means that</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr_{b \\in \\{0, 1\\}} \\left[ \\mathsf{State}(x^*, 0^i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">b) = \\mathsf{accept} \\right] \\geq \\frac{1}{2},</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">in contradiction to the second property of round-by-round soundness.</p>

    <p class="text-gray-300"><strong>Parallel Repetition and Round-by-Round Soundness.</strong> Given an interactive proof <span class="math">\\Pi = (P, V)</span> we can consider the <span class="math">k</span>-fold parallel repetition of <span class="math">\\Pi</span>, denoted by <span class="math">\\Pi^k = (P^k, V^k)</span>, in which <span class="math">(P, V)</span> is executed <span class="math">k</span> times independently and the verifier accepts if and only if a majority of executions accept.²⁷ It is known that parallel repetition reduces the completeness error and soundness error of interactive proofs at an exponential rate (see [Gol99, Lemma C.1]).²⁸ Together with Proposition 5.5, this implies that any sound public coin proof system can be converted into one satisfying round-by-round soundness.</p>

    <p class="text-gray-300"><strong>Corollary 5.7.</strong> Suppose that <span class="math">\\Pi</span> is a <span class="math">2r</span>-round (public coin) proof system with soundness error <span class="math">\\mu</span>. Then, <span class="math">\\Pi^k</span> has round-by-round soundness error <span class="math">\\mu^{\\frac{k}{r}}</span>.</p>

    <p class="text-gray-300">²⁷ In case the base protocol <span class="math">(P, V)</span> has perfect completeness, it suffices for <span class="math">V^k</span> to check that all executions accept.</p>

    <p class="text-gray-300">²⁸ The fact that the completeness error is reduced at an exponential rate is trivial. Soundness is more difficult to analyze though since a cheating prover for <span class="math">V^k</span> does not have to act independently on the <span class="math">k</span> executions. Nevertheless, it was shown [Gol99, Lemma C.1] that the soundness error is reduced at an exponential rate.</p>

    <p class="text-gray-300">34</p>

    <p class="text-gray-300">The main result of this section is that the Fiat-Shamir transform for compressing a public-coin interactive proof  <span class="math">\\Pi</span>  into a non-interactive transform is provably (adaptively) sound when applied to round-by-round sound interactive proofs using a hash family satisfying a restricted form of correlation intractability.</p>

    <p class="text-gray-300">Specifically, we show that it suffices for the hash family to be correlation intractable with respect to a specific relation, which we now define. Let  <span class="math">\\Pi</span>  be an interactive proof with round-by-round soundness error  <span class="math">\\epsilon</span>  and let  <span class="math">\\mathsf{State}</span>  be a corresponding state function. For every  <span class="math">n\\in \\mathbb{N}</span> , we define a relation  <span class="math">R_{\\mathsf{State}}^{(n)}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R _ {\\mathsf {S t a t e}} ^ {(n)} \\stackrel {{\\mathrm {d e f}}} {{=}} \\left\\{\\left((x, \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha), \\beta\\right): \\begin{array}{c} x \\in \\{0, 1 \\} ^ {n}, \\\\ \\mathsf {S t a t e} (x, \\tau) = \\mathsf {r e j e c t} \\\\ \\text {a n d} \\\\ \\mathsf {S t a t e} (x, \\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta) = \\mathsf {a c c e p t} \\end{array} \\right\\}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">We define the relation ensemble  <span class="math">R_{\\mathrm{State}} = (R_{\\mathrm{State}}^{(n)})_{n \\in \\mathbb{N}}</span> .</p>

    <p class="text-gray-300">Note that  <span class="math">R_{\\text{State}}</span>  is  <span class="math">\\epsilon</span> -sparse, since  <span class="math">\\Pi</span>  has round-by-round soundness  <span class="math">\\epsilon</span> . When there is a canonical choice of the function  <span class="math">\\text{State}</span>  for a protocol  <span class="math">\\Pi</span> , we will often write  <span class="math">R_{\\Pi}</span>  to denote  <span class="math">R_{\\text{State}}</span> .</p>

    <p class="text-gray-300">Theorem 5.8. Suppose that  <span class="math">\\Pi = (P,V)</span>  is a  <span class="math">2r</span> -message public-coin interactive proof for a language  <span class="math">L</span>  with perfect completeness,  <span class="math">\\mathsf{polylog}(n)</span>  total bits of prover-to-verifier communication, and round-by-round soundness with a corresponding state function  <span class="math">\\mathsf{State}</span> . Let  <span class="math">X_{n}</span>  denote the set of partial transcripts (including the input and all messages sent) and let  <span class="math">Y_{n}</span>  denote the set of verifier messages when  <span class="math">\\Pi</span>  is executed on an input of length  <span class="math">n</span> . If a hash family  <span class="math">\\mathcal{H} = \\{\\mathcal{H}_n : X_n \\to Y_n\\}</span>  is  <span class="math">R_{\\mathsf{State}}</span> -correlation intractable and evaluable in time  <span class="math">\\tilde{O}(n)</span> , then the algorithms  <span class="math">(\\mathsf{Gen}, \\tilde{P}, \\tilde{V})</span>  as defined below constitute an adaptively sound publicly verifiable argument for  <span class="math">L</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input  <span class="math">1^n</span> , Gen samples  <span class="math">H \\gets \\mathcal{H}_n</span> , and publishes  <span class="math">H</span>  as a common reference string (or common random string if  <span class="math">H \\gets \\mathcal{H}_n</span>  is a uniformly random binary string of some length.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- On input  <span class="math">x</span> , the prover  <span class="math">\\tilde{P}</span>  sends the  <span class="math">r</span>  strings  <span class="math">\\alpha_{1},\\ldots ,\\alpha_{r}</span>  that  <span class="math">P</span>  would send on input  <span class="math">x</span>  if the verifier's messages were given by  $\\beta_{j} = H(x,\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{j})<span class="math">  for  </span>j\\in [r]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier  <span class="math">\\tilde{V}</span> , on input  <span class="math">x^{<em>}</span>  and  <span class="math">\\alpha_{1}^{</em>},\\ldots ,\\alpha_{r}^{*}</span>  (which might be chosen maliciously) iteratively computes</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_ {j} ^ {<em>} = H \\left(x ^ {</em>}, \\alpha_ {1} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_ {1} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {2} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_ {j - 1} ^ {*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_ {j} ^ {*}\\right)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">for each  <span class="math">j \\in [r]</span> . The verifier then accepts if and only if  $V(x^{<em>},\\alpha_{1}^{</em>}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ldots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{r}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{r}^{*}) = 1$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Remark 5.2 (On Interactive Proofs with Imperfect Completeness). Theorem 5.8 applies to protocols with perfect completeness. However, it can be easily extended to protocols with imperfect completeness by further requiring that the correlation intractable hash function is  <span class="math">r</span> -wise independent (so as to assure the correct distribution of verifier messages). This can be done without loss of generality by xor-ing the (bounded) correlation intractable hash function with an  <span class="math">r</span> -wise independent hash function, which preserves (bounded) correlation intractability.</p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof of Theorem 5.8.</h6>

    <p class="text-gray-300">Completeness follows immediately from the perfect completeness of <span class="math">(P,V)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We proceed to show the adaptive soundness of the argument scheme. Suppose that a cheating prover <span class="math">P^{<em>}</span> given input <span class="math">(1^{n},H)</span> produces, with probability at least <span class="math">\\epsilon=\\epsilon(n)</span>, a string <span class="math">x^{</em>}\\in\\{0,1\\}^{n}\\setminus L</span> and <span class="math">(\\alpha_{1}^{<em>},\\ldots,\\alpha_{r}^{</em>})</span> such that <span class="math">V</span> accepts the transcript derived from <span class="math">H(\\cdot)</span>. Let <span class="math">\\tau_{i}</span> denote the transcript prefix $\\alpha_{1}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots\\alpha_{i}^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}^{<em>}<span class="math"> with </span>\\beta_{j}^{</em>}$ defined as above.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Properties 1 and 3 of round-by-round soundness (see Definition 5.3) imply that for any accepting transcript <span class="math">\\tau</span> for <span class="math">x\\notin L</span> there is at least one index <span class="math">i\\in[r]</span> such that <span class="math">\\mathsf{State}(x,\\tau_{i})=\\mathsf{reject}</span> and <span class="math">\\mathsf{State}(x,\\tau_{i+1})=\\mathsf{accept}</span>. Thus, there must exist some index <span class="math">i_{n}^{<em>}\\in[r]</span> such that with probability at least <span class="math">\\frac{\\epsilon}{r}</span>, the output of <span class="math">P^{</em>}</span> satisfies that <span class="math">\\mathsf{State}(x,\\tau_{i^{<em>}})=\\mathsf{reject}</span> and <span class="math">\\mathsf{State}(x,\\tau_{i^{</em>}+1})=\\mathsf{accept}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">This fact can be used to construct an adversary <span class="math">\\mathcal{A}=\\{\\mathcal{A}_{\\lambda}\\}</span> that violates the <span class="math">R_{\\mathsf{State}}</span>-correlation intractability of <span class="math">\\mathcal{H}</span>: on input <span class="math">H\\leftarrow\\mathcal{H}_{n}</span>, <span class="math">\\mathcal{A}_{\\lambda}</span> runs <span class="math">P^{<em>}(1^{n},H)</span> to obtain <span class="math">x^{</em>}</span> and <span class="math">(\\alpha_{1}^{<em>},\\ldots,\\alpha_{r}^{</em>})</span>, computes $\\beta_{j}=H(x^{*},\\tau_{j-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{j})<span class="math"> for all </span>j<span class="math">, and outputs </span>\\tau_{i^{*}}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i+1}^{*}$. This is a contradiction, so the protocol must be adaptively sound. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-73" class="text-2xl font-bold">6 Publicly Verifiable <span class="math">\\mathsf{SNARG}</span></h2>

    <p class="text-gray-300">We present our construction of a publicly verifiable <span class="math">\\mathsf{SNARG}</span> based on the <span class="math">\\mathsf{GKR}</span> interactive protocol. We begin in Section 6.1 by recalling some standard algebraic facts and notations.</p>

    <h5 id="sec-74" class="text-base font-semibold mt-4">Font Conventions.</h5>

    <p class="text-gray-300">Throughout this section we will use the convention that blackboard bold lowercase (e.g., <span class="math">\\mathbb{z}</span>) is used for field elements whereas standard bold lowercase (e.g., <span class="math">\\mathbf{z}</span>) is used for bits. Likewise, we use <span class="math">\\bar{\\mathbb{z}}</span> to denote vectors of field elements and <span class="math">\\bar{\\mathbf{z}}</span> to denote bit strings.</p>

    <h3 id="sec-75" class="text-xl font-semibold mt-8">6.1 Fields and Polynomials</h3>

    <p class="text-gray-300">We recall the definition of the multilinear extension and explicit representations of finite fields.</p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Definition 6.1 (Multilinear Extension).</h6>

    <p class="text-gray-300">For any function <span class="math">f:\\{0,1\\}^{n}\\to\\{0,1\\}</span> and any field <span class="math">\\mathbb{F}</span>, the multilinear extension of <span class="math">f</span> over <span class="math">\\mathbb{F}</span> is the (uniquely) defined multilinear polynomial <span class="math">\\hat{f}:\\mathbb{F}^{n}\\to\\mathbb{F}</span> satisfying <span class="math">\\hat{f}(x)=f(x)</span> for each <span class="math">x\\in\\{0,1\\}^{n}</span>.</p>

    <p class="text-gray-300">The polynomial <span class="math">\\hat{f}(\\mathbb{z})</span> is given explicitly by the formula</p>

    <p class="text-gray-300"><span class="math">\\hat{f}(\\mathbb{z})=\\sum_{x\\in\\{0,1\\}^{n}}f(x)\\cdot\\beta_{x\\to\\bar{\\mathbb{z}}}</span></p>

    <p class="text-gray-300">where <span class="math">\\beta_{x\\to\\bar{\\mathbb{z}}}\\stackrel{{\\scriptstyle\\textsf{def}}}{{=}}\\prod_{i\\in[n]}\\left(x_{i}\\cdot\\mathbb{z}_{i}+(1-x_{i})\\cdot(1-\\mathbb{z}_{i})\\right)</span>.</p>

    <p class="text-gray-300">When the field <span class="math">\\mathbb{F}</span> is clear from the context, we will omit it and simply say that <span class="math">\\hat{f}</span> is the multilinear extension of <span class="math">f</span>.</p>

    <h6 id="sec-77" class="text-base font-medium mt-4">Definition 6.2.</h6>

    <p class="text-gray-300">A <span class="math">T_{\\mathbb{F}}(\\cdot)</span>-time explicit representation of a finite field ensemble <span class="math">\\mathbb{F}=\\{\\mathbb{F}_{i}\\}_{i\\in\\mathcal{I}}</span> is an algorithm for solving each of the following problems in time <span class="math">T_{\\mathbb{F}}(i)</span> given an index <span class="math">i\\in\\mathcal{I}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Field Membership. Given an additional string <span class="math">z</span>, decide whether or not <span class="math">z\\in\\mathbb{F}_{i}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Enumerability. Evaluate some bijection $\\varphi_{i}:[</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]\\to\\mathbb{F}_{i}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Explicit 0 and 1. Compute <span class="math">0\\in\\mathbb{F}_{i}</span> and <span class="math">1\\in\\mathbb{F}_{i}</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Efficient Field Operations. Evaluate the operations <span class="math">+</span>, <span class="math">-</span>, <span class="math">\\times</span>, and <span class="math">\\div</span> on <span class="math">\\mathbb{F}_{i}</span>.</li>

      <li>Sampleable. Sample from the uniform distribution on <span class="math">\\mathbb{F}_{i}</span>.</li>

    </ul>

    <p class="text-gray-300">When a <span class="math">T_{\\mathbb{F}}(\\cdot)</span>-time explicit representation exists, we say that <span class="math">\\mathbb{F}</span> is <span class="math">T_{\\mathbb{F}}(\\cdot)</span>-time representable.</p>

    <h3 id="sec-78" class="text-xl font-semibold mt-8">6.2 GKR: Round by Round Soundness and Efficient Sampleability</h3>

    <p class="text-gray-300">In this section, we briefly describe the interactive proof system of Goldwasser, Kalai, and Rothblum <em>[x10]</em>, hereafter referred to as GKR. We explain why GKR (or rather a simplification due to Goldreich <em>[x11]</em>) has round-by-round soundness, and we show that the corresponding relation (as defined in Section 5) can be sampled in polynomial time.</p>

    <p class="text-gray-300">We start by using a result from <em>[x11]</em> that allows one to transform uniform low depth circuits into a form that is convenient for the GKR protocol.</p>

    <h6 id="sec-79" class="text-base font-medium mt-4">Imported Lemma 6.3 (<em>[x11]</em>).</h6>

    <p class="text-gray-300">If <span class="math">\\mathcal{L}</span> is a promise problem decidable by an ensemble of log-space uniform boolean circuits of size <span class="math">S^{\\prime}=S^{\\prime}(n)</span> (without loss of generality <span class="math">S^{\\prime}(n)\\geq n</span>) and depth <span class="math">d^{\\prime}=d^{\\prime}(n)</span>, then <span class="math">\\mathcal{L}</span> is also decidable by an ensemble <span class="math">\\{C_{n}\\}</span> of boolean circuits that satisfies the following uniformity properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">C_{n}</span> has size <span class="math">S(n)\\leq\\operatorname{poly}(S^{\\prime}(n))</span> and depth <span class="math">d(n)\\leq d^{\\prime}(n)\\cdot\\operatorname{polylog}(S^{\\prime}(n))</span>. Assume without loss of generality that <span class="math">S(n)</span> is a power of two, and define <span class="math">s(n)\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\log_{2}S(n)</span>.</li>

      <li>The gates of <span class="math">C_{n}</span> have fan-in 2, and each compute either <span class="math">\\oplus</span> or <span class="math">\\wedge</span>.</li>

      <li>The gates of <span class="math">C_{n}</span> can be (uniquely) partitioned into layers such that the inputs to a gate in layer <span class="math">i</span> are outputs of gates in layer <span class="math">i-1</span>, with the input wires viewed as layer <span class="math">0</span>.</li>

      <li>The wires of <span class="math">C_{n}</span> can be labeled with the numbers <span class="math">1</span> through <span class="math">S(n)</span> (equivalently with <span class="math">s(n)</span>-bit strings) so that:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first <span class="math">n</span> wires of <span class="math">C_{n}</span> are the input wires.</li>

      <li>The last wire of <span class="math">C_{n}</span> is the output wire.</li>

      <li>Let “wiring predicates” <span class="math">\\mathsf{add}_{n},\\mathsf{mult}_{n}:\\left(\\{0,1\\}^{s(n)}\\right)^{3}\\to\\{0,1\\}</span> be defined so that <span class="math">\\mathsf{add}_{n}</span> (respectively, <span class="math">\\mathsf{mult}_{n}</span>) applied to <span class="math">(w_{1},w_{2},w_{3})</span> is <span class="math">1</span> iff <span class="math">w_{3}</span> is an <span class="math">\\oplus</span> (respectively, <span class="math">\\wedge</span>) gate whose input wires are <span class="math">w_{1}</span> and <span class="math">w_{2}</span>, in that order.</li>

    </ul>

    <p class="text-gray-300">Then both <span class="math">\\mathsf{add}_{n}</span> and <span class="math">\\mathsf{mult}_{n}</span> are computable by <span class="math">\\mathsf{polylog}(n)</span>-sized boolean formulas that themselves are computable from <span class="math">n</span> in <span class="math">\\mathsf{polylog}(n)</span> time. In particular this implies that over any <span class="math">T_{\\mathbb{F}}(\\cdot)</span>-time representable finite field ensemble <span class="math">\\mathbb{F}=\\{\\mathbb{F}_{i}\\}</span>, there exist <span class="math">\\mathsf{polylog}(n)</span>-degree extensions <span class="math">\\widetilde{\\mathsf{add}}_{n,i},\\widetilde{\\mathsf{mult}}_{n,i}:\\left(\\mathbb{F}_{i}^{s(n)}\\right)^{3}\\to\\mathbb{F}_{i}</span> that are evaluable in time <span class="math">\\mathsf{polylog}(n)\\cdot T_{\\mathbb{F}}(i)</span>.</p>

    <h5 id="sec-80" class="text-base font-semibold mt-4">Low-Degree Arithmetization.</h5>

    <p class="text-gray-300">GKR depends on several polynomials, which we now define. Fix <span class="math">\\mathcal{L}=(\\mathcal{L}_{\\mathsf{yes}},\\mathcal{L}_{\\mathsf{no}})</span> to be any promise problem that is decidable by log-space uniform circuits of size <span class="math">S^{\\prime}(n)</span> and depth <span class="math">d^{\\prime}(n)</span>. Let <span class="math">\\{C_{n}\\}</span> denote a circuit family that decides <span class="math">\\mathcal{L}</span> as in the conclusion of Imported Lemma 6.3.</p>

    <p class="text-gray-300">For any <span class="math">x \\in \\{0,1\\}^n</span>, any field <span class="math">\\mathbb{F}</span>, any <span class="math">i \\in \\{0,\\dots,d(n)\\}</span>, and any <span class="math">j \\in [3 \\cdot s(n)]</span>, we define polynomials <span class="math">\\hat{V}_{x,\\mathbb{F}}^{(i)}: \\mathbb{F}^{s(n)} \\to \\mathbb{F}</span> and <span class="math">P_{x,j,\\mathbb{F}}^{(i)}: \\mathbb{F}^j \\times \\mathbb{F}^{s(n)} \\to \\mathbb{F}</span> as follows.</p>

    <p class="text-gray-300">We first define a function <span class="math">V_{x}^{(i)}: \\{0,1\\}^{s(n)} \\to \\{0,1\\}</span> so that <span class="math">V_{x}^{(i)}(w)</span> is 1 iff wire <span class="math">w</span> is in layer <span class="math">i</span> and carries the value 1 when <span class="math">C_n</span> is evaluated on <span class="math">x</span>. The polynomial <span class="math">\\hat{V}_{x,\\mathbb{F}}^{(i)}</span> is defined as the multi-linear extension of <span class="math">V_{x}^{(i)}</span> over the field <span class="math">\\mathbb{F}</span> (see Definition 6.1 for the definition of the multilinear extension).</p>

    <p class="text-gray-300">The polynomial <span class="math">P_{x,3s(n),\\mathbb{F}}^{(i)}:\\mathbb{F}^{4s(n)}\\to \\mathbb{F}</span> is defined as</p>

    <div class="my-4 text-center"><span class="math-block">P _ {x, 3 s (n), \\mathbb {F}} ^ {(i)} (\\bar {\\mathbf {w}} _ {1}, \\bar {\\mathbf {w}} _ {2}, \\bar {\\mathbf {w}} _ {3}, \\bar {\\mathbf {w}}) \\stackrel {\\text {d e f}} {=} \\left( \\begin{array}{c} \\widetilde {\\mathbf {a d d}} _ {n} (\\bar {\\mathbf {w}} _ {1}, \\bar {\\mathbf {w}} _ {2}, \\bar {\\mathbf {w}} _ {3}) \\cdot \\left(\\hat {V} _ {x} ^ {(i - 1)} (\\bar {\\mathbf {w}} _ {1}) + \\hat {V} _ {x} ^ {(i - 1)} (\\bar {\\mathbf {w}} _ {2})\\right) \\\\ + \\\\ \\widetilde {\\mathbf {m u l t}} _ {n} (\\bar {\\mathbf {w}} _ {1}, \\bar {\\mathbf {w}} _ {2}, \\bar {\\mathbf {w}} _ {3}) \\cdot \\hat {V} _ {x} ^ {(i - 1)} (\\bar {\\mathbf {w}} _ {1}) \\cdot \\hat {V} _ {x} ^ {(i - 1)} (\\bar {\\mathbf {w}} _ {2}) \\end{array} \\right) \\cdot \\beta_ {\\bar {\\mathbf {w}} _ {3} \\to \\bar {\\mathbf {w}}}. \\quad (2)</span></div>

    <p class="text-gray-300">with <span class="math">\\beta_{\\bar{\\mathbf{w}}_3\\to \\bar{\\mathbf{w}}}</span> as in Definition 6.1 on page 36. For <span class="math">j\\in \\{0,\\dots ,3s(n) - 1\\}</span>, the we define a polynomial <span class="math">P_{x,j,\\mathbb{F}}^{(i)}</span> as follows</p>

    <div class="my-4 text-center"><span class="math-block">P _ {x, j, \\mathbb {F}} ^ {(i)} \\left(\\mathbb {z} _ {1}, \\dots , \\mathbb {z} _ {j}, \\bar {\\mathbf {w}}\\right) \\stackrel {\\text {d e f}} {=} \\sum_ {z _ {j + 1} \\in \\{0, 1 \\}} P _ {x, j + 1, \\mathbb {F}} ^ {(i)} \\left(\\mathbb {z} _ {1}, \\dots , \\mathbb {z} _ {j}, z _ {j + 1}, \\bar {\\mathbf {w}}\\right) \\tag {3}</span></div>

    <p class="text-gray-300">for <span class="math">\\mathbb{z}_1, \\ldots, \\mathbb{z}_j \\in \\mathbb{F}</span> and <span class="math">\\bar{\\mathbf{w}} \\in \\mathbb{F}^{s(n)}</span>. The polynomials <span class="math">P_{x,j,\\mathbb{F}}^{(i)}</span> are often referred to as the "sumcheck polynomials", arising from the sumcheck protocol of [LFKN92] that we are implicitly using.</p>

    <p class="text-gray-300">By the definitions of the wiring predicates and multi-linear extension, it holds for any <span class="math">i</span>, any <span class="math">\\bar{\\mathbf{w}}</span>, and any field <span class="math">\\mathbb{F}</span> of characteristic two that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\hat {V} _ {x, \\mathbb {F}} ^ {(i)} (\\bar {\\mathbf {w}}) = P _ {x, 0, \\mathbb {F}} ^ {(i)} (\\bar {\\mathbf {w}}) \\tag {4} \\\\ = \\sum_ {\\bar {w} _ {1}, \\bar {w} _ {2}, \\bar {w} _ {3} \\in \\{0, 1 \\} ^ {s (n)}} P _ {x, 3 s (n), \\mathbb {F}} ^ {(i)} (\\bar {w} _ {1}, \\bar {w} _ {2}, \\bar {w} _ {3}, \\bar {\\mathbf {w}}) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">These polynomials each have degree <span class="math">\\mathsf{polylog}(n)</span>, and the relations between them are at the heart of the GKR interactive proof scheme, which we now describe.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The Protocol and Round-by-Round Soundness. Let <span class="math">\\{\\mathbb{F}_n\\}_n</span> be a <span class="math">\\mathsf{polylog}(n)</span>-time explicit representation of finite fields of characteristic two and order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq n^{\\omega(1)}<span class="math">, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}_n</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq 2^{\\mathsf{polylog}(n)}<span class="math">. When executed on input </span>x \\in \\{0,1\\}^n<span class="math">, the protocol will only involve polynomials over the field </span>\\mathbb{F}_n$, and we omit subscripts accordingly.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Throughout the GKR protocol, both the prover and verifier maintain a list of pending claims. The initial claim, corresponding to the assertion that <span class="math">x \\in \\mathcal{L}_{\\mathrm{yes}}</span>, is that <span class="math">\\hat{V}_x^{d(n)}(w_{\\mathrm{out}}) = 1</span>, where <span class="math">w_{\\mathrm{out}}</span> is the label of the output wire of <span class="math">C_n</span>. In general claims will be of the form <span class="math">p(\\bar{\\mathbf{u}}) = \\mathbf{v}</span> where <span class="math">p</span> is one of the above polynomials, and <span class="math">\\bar{\\mathbf{u}}</span> and <span class="math">\\mathbf{v}</span> are arbitrary.</p>

    <p class="text-gray-300">In each round, the prover and verifier: (1) reduce multiple claims regarding some polynomial <span class="math">p</span> to a single claim regarding <span class="math">p</span>, and (2) reduce that claim to several claims about a "simpler" polynomial.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Suppose that the currently pending claims are <span class="math">p(\\bar{\\mathbf{u}}_1) = \\mathbb{v}_1, \\ldots, p(\\bar{\\mathbf{u}}_k) = \\mathbb{v}_k</span> (<span class="math">k</span> will in fact always be at most 2). For some canonical association of the set <span class="math">[k]</span> with a subset of <span class="math">\\mathbb{F}</span>, the prover and verifier construct the unique degree <span class="math">k - 1</span> polynomial curve for which <span class="math">\\gamma(i) = \\bar{\\mathbf{u}}_i</span></li>

    </ol>

    <p class="text-gray-300">38</p>

    <p class="text-gray-300">for all <span class="math">i\\in[k]</span>. The prover sends to the verifier an explicitly represented univariate polynomial <span class="math">g^{<em>}</span> that has degree at most <span class="math">(k-1)\\cdot\\deg(p)</span> and is purportedly equal to <span class="math">p\\circ\\gamma</span>. The verifier checks that <span class="math">g^{</em>}(i)=\\mathbbm{v}_{i}</span> for each <span class="math">i\\in[k]</span>, and responds with a random challenge <span class="math">\\mathbbm{r}\\leftarrow\\mathbb{F}</span>. All claims about <span class="math">p</span> are then replaced with the single claim that <span class="math">p(\\bar{\\mathbbm{u}}^{<em>})=\\mathbbm{v}^{</em>}</span>, where <span class="math">\\bar{\\mathbbm{u}}^{<em>}=\\gamma(\\mathbbm{r})</span> and <span class="math">\\mathbbm{v}^{</em>}=g^{*}(\\mathbbm{r})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The polynomial <span class="math">p</span> has a defining equation – either Equation (2), (3), or (4) – that expresses <span class="math">p(\\bar{\\mathbbm{u}}^{<em>})</span> as a function <span class="math">\\varphi</span> applied to a constant number of other polynomial evaluations. The prover sends these other evaluations, and the verifier checks that applying <span class="math">\\varphi</span> yields <span class="math">\\mathbbm{v}^{</em>}</span>.</li>

    </ol>

    <p class="text-gray-300">After <span class="math">r(n)=O\\big{(}d(n)\\cdot s(n)\\big{)}</span> rounds a single claim remains, regarding <span class="math">\\hat{X}_{x}^{(0)}</span>. Such a claim is directly checkable by the verifier in <span class="math">\\tilde{O}(n)</span> field operations.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Theorem 6.4.</h6>

    <p class="text-gray-300">For every promise problem <span class="math">\\mathcal{L}=(\\mathcal{L}_{\\textsf{yes}},\\mathcal{L}_{\\textsf{no}})</span> in log-space uniform <span class="math">\\mathsf{NC}</span>, there is a public-coin interactive proof <span class="math">\\Pi</span> for <span class="math">\\mathcal{L}</span> with verifier running time <span class="math">\\tilde{O}(n)</span>, prover running time <span class="math">\\mathrm{poly}(n)</span>, and round-by-round soundness error <span class="math">\\mathrm{negl}(n)</span>. Moreover, the corresponding relation <span class="math">R_{\\Pi}</span> is sampleable in <span class="math">\\mathrm{poly}(n)</span> time.</p>

    <h6 id="sec-82" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The prover and verifier efficiency claims follow directly from examination of the above protocol.</p>

    <p class="text-gray-300">We define <span class="math">\\mathsf{State}</span> so that <span class="math">\\mathsf{State}(x,\\tau_{i-1})</span> is accept if each pending claim after <span class="math">\\tau_{i-1}</span> is true, and otherwise <span class="math">\\mathsf{State}(x,\\tau_{i-1})</span> is reject. All the polynomials involved are evaluable in time <span class="math">\\mathrm{poly}(S)</span>, which by log-space uniformity is <span class="math">\\mathrm{poly}(n)</span>, so <span class="math">\\mathsf{State}</span> is too.</p>

    <p class="text-gray-300">We analyze the round-by-round soundness error of steps 1 and 2 of the protocol, described above.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The round-by-round soundness error incurred in step 1 is the fraction of <span class="math">\\mathbbm{r}</span>’s for which <span class="math">g^{<em>}(\\mathbbm{r})=p(\\gamma(\\mathbbm{r}))</span>. The assumption that the currently pending claims are not all true implies that the polynomials <span class="math">g^{</em>}</span> and <span class="math">p\\circ\\gamma</span> are not equal, so the fraction of “bad <span class="math">\\mathbbm{r}</span>’s” is bounded by $\\frac{k\\cdot\\deg(p)}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. With our choice of </span>\\mathbb{F}<span class="math">, this is negligible in </span>n$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Step 2 incurs no round-by-round soundness error: if <span class="math">\\mathbbm{v}^{<em>}\\neq p(\\bar{\\mathbbm{u}}^{</em>})</span>, then at least one of the right-hand-side claims must be false.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To write the relation <span class="math">R_{\\Pi}</span> more explicitly, we first observe by inspection of Eqs. (2) to (4) that there is a fixed sequence of polynomials <span class="math">Q_{1},\\ldots,Q_{r}</span> such that claims in the <span class="math">i^{th}</span> round are about <span class="math">Q_{i}</span>. <span class="math">R_{\\Pi}</span> consists of the pairs $\\big{(}(x,\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha),\\mathbbm{r}\\big{)}$ for which:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\alpha</span> and <span class="math">\\beta</span> are in <span class="math">\\mathbb{F}_{n}</span>, where <span class="math">n</span> is the length of <span class="math">x</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\tau</span> is of the form $\\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{i}<span class="math"> for some </span>0\\leq i<r(n)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each <span class="math">\\alpha_{j}</span> is of the form <span class="math">(\\mathbbm{v}_{j,1},\\mathbbm{v}_{j,2},g_{j})</span>, for some <span class="math">\\mathbbm{v}_{j,1},\\mathbbm{v}_{j,2}\\in\\mathbb{F}_{n}</span> and some <span class="math">g_{j}</span> that is a degree-<span class="math">\\mathsf{polylog}(n)</span> univariate polynomial, represented as a list of coefficients in <span class="math">\\mathbb{F}_{n}</span>.</li>

      <li>Each <span class="math">\\beta_{j}</span> lies in <span class="math">\\mathbb{F}_{n}</span>.</li>

      <li>Of the claims “<span class="math">Q_{i+1}(\\bar{\\mathbbm{u}}_{i+1,1})=\\mathbbm{v}_{i+1,1}</span>” and “<span class="math">Q_{i+1}(\\bar{\\mathbbm{u}}_{i+1,2})=\\mathbbm{v}_{i+1,2}</span>” that are pending after the prover sends <span class="math">\\alpha_{i+1}</span>, at least one claim is false, but <span class="math">g_{i+1}(1)=\\mathbbm{v}_{i+1,1}</span> and <span class="math">g_{i+1}(2)=\\mathbbm{v}_{i+1,2}</span>.</li>

      <li><span class="math">g_{i+1}(\\mathbbm{r})=Q_{i+1}\\big{(}(1-\\mathbbm{r})\\cdot\\mathbbm{v}_{i+1,1}+\\mathbbm{r}\\cdot\\mathbbm{v}_{i+1,2}\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">##</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The algorithm for sampling  <span class="math">R_{\\Pi}</span>  works as follows. Given a transcript  $\\tau_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_i<span class="math"> , compute the list of pending claims  </span>p(\\bar{\\mathfrak{u}}_1) = \\mathbb{V}_1, \\ldots, p(\\bar{\\mathfrak{u}}_k) = \\mathbb{V}_k<span class="math">  that follow  </span>\\tau_{i-1}<span class="math"> . If all pending claims are correct, then there is nothing to do. Otherwise, let  </span>\\gamma<span class="math">  denote the unique degree  </span>k-1<span class="math">  polynomial curve for which  </span>\\gamma(i) = \\bar{\\mathfrak{u}}_i<span class="math">  for all  </span>i \\in [k]<span class="math"> , and parse  </span>\\alpha_i<span class="math">  as a univariate polynomial  </span>g^*<span class="math"> . A verifier message  </span>\\beta_i \\in \\mathbb{F}<span class="math">  is bad – that is,  </span>((x, \\tau_{i-1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_i), \\beta_i) \\in R_{\\Pi}<span class="math">  – if and only if  </span>g^*(\\beta_i) = p(\\gamma(\\beta_i))$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Thus, to sample from  <span class="math">R_{\\Pi}</span> , we just need to output a random root of  <span class="math">g^{*} - p \\circ \\gamma</span> . Using the Cantor-Zassenhaus algorithm [CZ81], we can enumerate all roots with probability  <span class="math">\\frac{2}{3}</span> , and therefore with any probability arbitrarily exponentially close to 1 (i.e.,  <span class="math">1 - e^{-\\mathrm{poly}(n)}</span>  for any desired poly). If this factorization succeeds, we can sample an element from the set of all roots with arbitrarily exponentially small sampling error, giving the stated result.</p>

    <p class="text-gray-300">Theorem 6.5. If Assumption 2 holds, then every promise problem in log-space uniform NC has a publicly verifiable non-interactive argument scheme with adaptive soundness such that for inputs of length  <span class="math">n</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The scheme uses a common random string of length  <span class="math">\\tilde{O}(n)</span> .</li>

      <li>Proofs are of length  <span class="math">\\mathsf{polylog}(n)</span>  and are generatable in time  <span class="math">\\mathrm{poly}(n)</span> .</li>

      <li>Proofs are publicly verifiable in time  <span class="math">\\tilde{O}(n)</span> .</li>

    </ul>

    <p class="text-gray-300">Proof. Our construction uses the following building blocks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The round-by-round sound interactive proof of Theorem 6.4.</li>

      <li>A secret-key encryption scheme  <span class="math">\\mathsf{SKE} = (\\mathsf{SKE.Gen},\\mathsf{SKE.Enc},\\mathsf{SKE.Dec})</span>  with keys of length  <span class="math">\\kappa = \\kappa (\\lambda)\\geq \\lambda^{\\Omega (1)}</span>  and universal ciphertexts that are  <span class="math">2^{-\\kappa}\\cdot \\mathrm{poly}(\\kappa)</span> -KDM-secure for arbitrary poly  <span class="math">(\\lambda)</span> -size computable functions of the secret key. Specifically, Assumption 2 implies that secret-key Regev encryption satisfies these properties, with secret distribution  <span class="math">\\chi_{\\mathrm{sec}}</span>  that is uniform on  <span class="math">[-B,B)</span>  for some  <span class="math">B</span>  specified below and error distribution  <span class="math">\\chi_{\\mathrm{err}}</span>  that is uniform on  <span class="math">[- \\frac{q}{4}, \\frac{q}{4})</span> .</li>

    </ul>

    <p class="text-gray-300">Furthermore, the proof of security of our delegation scheme uses an additional building block:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A (secret-key) fully homomorphic encryption scheme FHE that is  $2^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\cdot \\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> -circular secure. We instantiate FHE using the [BV14] FHE scheme in which the underlying LWE secret and error distributions ( </span>\\chi_{\\mathrm{sec}}<span class="math">  and  </span>\\chi_{\\mathrm{err}}<span class="math"> ) are uniform in the range  </span>[-B, B)<span class="math">  for  </span>B \\approx \\frac{q}{n \\cdot 51 \\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . Here,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\mathsf{polylog}(n)<span class="math">  denotes the length of the  </span>i$ th verifier message in the [GKR08] protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Combining Theorem 3.11, Theorem 5.8, Theorem 6.4, and Theorem 4.6, we conclude that the following protocol is a succinct non-interactive argument system for log-space uniform NC.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: An instance  <span class="math">x \\in \\mathcal{L}_{\\mathrm{yes}} \\cup \\mathcal{L}_{\\mathrm{no}}</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Random String: A uniformly random string <span class="math">h</span> that describes a Regev ciphertext <span class="math">\\mathbf{ct} \\in \\mathbb{Z}_q^{(n&#x27; + 1) \\times m}</span> where <span class="math">n&#x27; \\cdot \\lfloor \\log(2B + 1) \\rfloor</span> is at least the length of a [GKR08] transcript (including the input <span class="math">x</span>), and <span class="math">m</span> is at least as large as any verifier message.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Proof: messages <span class="math">\\alpha_{i}</span> computed according to the [GKR08] prover algorithm, where the verifier messages <span class="math">\\beta_{1},\\ldots ,\\beta_{r}</span> are computed inductively by first padding the transcript prefix $\\tau_{j} \\stackrel{\\mathrm{def}}{=} \\alpha_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\beta_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\dots</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\alpha_{j}<span class="math"> so that it can be viewed as an element of </span>[-B,B)^{n'}<span class="math">, and then computing </span>\\beta_{j} = \\mathsf{SKE.Dec}(\\tau_{j},h)$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Security follows from the exponential KDM-security of SKE (and the universal ciphertexts property of SKE, which holds unconditionally), which in turn follows from the exponential circular security of FHE.</p>

    <p class="text-gray-300">We are able to achieve an even shorter CRS (any <span class="math">n^{\\epsilon}</span> rather than <span class="math">\\tilde{O}(n)</span>) if we are willing to settle for non-adaptive soundness.</p>

    <p class="text-gray-300"><strong>Theorem 6.6.</strong> If Assumption 2 holds, then for every promise problem <span class="math">\\mathcal{L} = (\\mathcal{L}_{\\mathrm{yes}},\\mathcal{L}_{\\mathrm{no}})</span> in log-space uniform NC and every <span class="math">\\epsilon &amp;gt;0</span>, there is a publicly verifiable non-interactive argument scheme with non-adaptive soundness such that for inputs of length <span class="math">n</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The scheme uses a common random string of length <span class="math">O(n^{\\epsilon})</span>.</li>

      <li>Proofs are of length <span class="math">\\mathsf{polylog}(n)</span> and are generatable in time <span class="math">\\mathrm{poly}(n)</span>.</li>

      <li>Proofs are publicly verifiable in time <span class="math">\\tilde{O}(n)</span>.</li>

    </ul>

    <h2 id="sec-84" class="text-2xl font-bold">7 Non-Interactive Zero Knowledge</h2>

    <p class="text-gray-300">We present the construction of Non-Interactive Zero Knowledge (NIZK) Arguments assuming that LWE holds with exponentially small inversion probability (and suitable parameters). We begin by recalling the definition of NIZK.</p>

    <h2 id="sec-85" class="text-2xl font-bold">7.1 Non-Interactive Zero Knowledge Arguments</h2>

    <p class="text-gray-300"><strong>Definition 7.1.</strong> A non-interactive zero knowledge (NIZK) argument system <span class="math">\\Pi</span> for an NP relation <span class="math">R</span> consists of three ppt algorithms <span class="math">(\\mathsf{Setup}, P, V)</span> with the following syntax.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^n)</span> takes as input a statement length <span class="math">n</span> and outputs a common reference string <span class="math">\\mathsf{crs}</span>.</li>

      <li><span class="math">P(\\mathsf{crs}, x, w)</span> takes as input the common reference string, as well as <span class="math">x</span> and <span class="math">w</span> such that <span class="math">(x, w) \\in R</span>. It outputs a proof <span class="math">\\pi</span>.</li>

    </ul>

    <p class="text-gray-300">32Under stronger but still plausible assumptions, the common random string can instead have length <span class="math">\\mathsf{polylog}(n)</span>; this would correspond to assuming FHE satisfying almost-optimal security against subexponential-time adversaries.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">V(\\mathsf{crs},x,\\pi)</span> takes as input the common reference string, a statement <span class="math">x</span>, and a proof <span class="math">\\pi</span>. It outputs a bit <span class="math">b</span>. If <span class="math">b=1</span>, we say that <span class="math">V</span> accepts, and otherwise we say that <span class="math">V</span> rejects.</li>

    </ul>

    <p class="text-gray-300">The proof system <span class="math">\\Pi</span> must satisfy the following requirements. Recall that <span class="math">\\mathcal{L}(R)</span> denotes the language <span class="math">\\{x:\\exists w\\text{ s.t. }(x,w)\\in R\\}</span> and <span class="math">R_{n}</span> denotes the set <span class="math">R\\cap(\\{0,1\\}^{n}\\times\\{0,1\\}^{*})</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Completeness. For every <span class="math">(x,w)\\in R</span>, it holds with probability <span class="math">1</span> that <span class="math">V(\\mathsf{crs},x,\\pi)=1</span> in the probability space defined by sampling $\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">})<span class="math"> and </span>\\pi\\leftarrow P(\\mathsf{crs},x,w)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Soundness. For every <span class="math">\\{x_{n}\\in\\{0,1\\}^{n}\\setminus\\mathcal{L}(R)\\}</span> and every polynomial size <span class="math">P^{<em>}=\\{P_{n}^{</em>}\\}</span>, there is a negligible function <span class="math">\\nu</span> such that</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{n})\\\\ \\pi\\leftarrow P_{n}^{*}(\\mathsf{crs})\\end{subarray}}\\bigl{[}V(\\mathsf{crs},x_{n},\\pi)=1\\bigr{]}\\leq\\nu(n). \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Zero Knowledge. There is a ppt simulator <span class="math">\\mathsf{Sim}</span> such that for every ensemble <span class="math">\\{(x_{n},w_{n})\\in R_{n}\\}</span>, the distribution ensembles</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Bigl{\\{}(\\mathsf{crs}_{n},P(\\mathsf{crs}_{n},x_{n},w_{n}))\\Bigr{\\}}_{n}</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\bigl{\\{}\\mathsf{Sim}(x_{n}))\\bigr{\\}}_{n}</span></p>

    <p class="text-gray-300">are computationally indistinguishable in the probability space defined by sampling <span class="math">\\mathsf{crs}_{n}\\leftarrow\\mathsf{Setup}(1^{n})</span> (and evaluating <span class="math">P</span> and <span class="math">\\mathsf{Sim}</span> with independent and uniformly randomness).</p>

    <p class="text-gray-300">If the distributions are statistically indistinguishable, then <span class="math">\\Pi</span> is said to be statistically zero knowledge.</p>

    <p class="text-gray-300">A NIZK argument system can also satisfy various stronger properties. We list two important variants below.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Coin (or “Common Random String”): <span class="math">\\Pi</span> is called public coin (aka, a NIZK in the common random string model) if <span class="math">\\mathsf{Setup}(1^{n})</span> simply samples and outputs a uniformly random string.</li>

      <li>Adaptive Soundness: <span class="math">\\Pi</span> is adaptively sound if for every polynomial size algorithm <span class="math">P^{<em>}=\\{P_{n}^{</em>}\\}</span>, there is a negligible function <span class="math">\\nu</span> such that for all <span class="math">n</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr_{\\begin{subarray}{c}\\mathsf{crs}\\leftarrow\\mathsf{Setup}(1^{n})\\\\ (x,\\pi):=P_{n}^{*}(\\mathsf{crs})\\end{subarray}}\\bigl{[}x\\notin\\mathcal{L}(R)\\wedge V(\\mathsf{crs},x,\\pi)=1\\bigr{]}\\leq\\nu(n). \\]</p>

    <h3 id="sec-86" class="text-xl font-semibold mt-8">7.2 NIZK from Bounded Correlation Intractability</h3>

    <p class="text-gray-300">In this section, we construct NIZK arguments in the common random string (CRS) model from hash families that are correlation intractable with respect to efficiently samplable relations. We obtain these NIZK arguments by applying the Fiat-Shamir transform to an instantiation of the <em>[x10]</em> proof system (repeated in parallel) in which the underlying commitment scheme is encryption under a public key that is included as part of the CRS).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">With a generic public-key encryption scheme or with a secret-coin hash family, this approach yields NIZKs with a common reference string.³³ However, if the public key encryption scheme and the hash family both have pseudorandom (public) keys, then this approach yields NIZK arguments in the common random string model. Also, we show that if encryption under a uniformly random public key³⁴ is lossy [KN08, PVW08, BHY09], then this argument system is statistical zero knowledge (rather than just computational zero knowledge). Finally, we note that we can also obtain adaptive soundness if the Fiat-Shamir hash function is applied to the concatenation $x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{a}<span class="math"> (where </span>\\mathbf{a}<span class="math"> is the first message of a three-round protocol) rather than just to </span>\\mathbf{a}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We begin by recalling the folklore notion of a “commit-challenge-response” proof system. In particular, the [GMW91] protocol for the (NP-complete) problem of 3-coloring falls into this framework. We include for completeness an explicit definition that is taken verbatim from [HL18].</p>

    <p class="text-gray-300"><strong>Definition 7.2 (Commit-Challenge-Response Proof System).</strong> A 3-message proof system <span class="math">\\Pi = (P, V)</span> for a language <span class="math">L</span> with witness relation <span class="math">R</span> is called <em>commit-challenge-response</em> if it satisfies the following properties.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first message is sent by the prover to the verifier. This message, which we denote by <span class="math">\\mathbf{a}</span>, consists of a block-wise commitment (under a statistically binding commitment scheme) to a string <span class="math">y</span> that is a function of both the common input <span class="math">x</span> and the prover’s private input <span class="math">w</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2. The second message, which we denote by <span class="math">\\mathbf{e}</span> and refer to as the verifier’s “challenge”, is sent by the verifier to the prover and is sampled uniformly at random from a poly $(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-size alphabet </span>\\Sigma$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The third and final message, which we denote by <span class="math">\\mathbf{z}</span>, is sent by the prover to the verifier, and consists of a decommitment to <span class="math">y_{T}</span>, i.e., a subset <span class="math">T</span> of the blocks of <span class="math">y</span>. Here, <span class="math">T</span> is a function of the challenge <span class="math">e</span>.</li>

      <li>The verifier <span class="math">V</span> accepts if and only if (1) <span class="math">\\mathbf{z}</span> is a valid decommitment of <span class="math">\\mathbf{a}_T</span>, and (2) the tuple <span class="math">(x, y_T, \\mathbf{e})</span> passes some efficient test Check, where <span class="math">y_T</span> is the value to which <span class="math">\\mathbf{a}_T</span> was decommitted.</li>

    </ol>

    <p class="text-gray-300">In order to obtain our result on statistical zero knowledge, we also define a specific kind of honest-verifier zero knowledge for commit-challenge-response protocols.</p>

    <p class="text-gray-300"><strong>Definition 7.3 (Special Honest-Verifier Zero Knowledge).</strong> We say that a commit-challenge-response proof system <span class="math">\\Pi</span> is <em>special honest-verifier zero knowledge</em> if there is a ppt simulator <span class="math">\\mathsf{SHVSim}</span> that on input <span class="math">x</span> produces a string <span class="math">(e, y_{T(e)})</span> that is <em>identical</em> to the distribution of <span class="math">(e, y_{T(e)})</span> where <span class="math">e</span> is uniformly random and <span class="math">y</span> is produced by the honest proving algorithm <span class="math">P(x, w)</span>.</p>

    <p class="text-gray-300">We note that if a commit-challenge-response protocol <span class="math">\\Pi</span> is special honest-verifier zero knowledge, then it is also honest-verifier zero knowledge; the simulator simply runs <span class="math">\\mathsf{SHVSim}(x)</span> and then commits to a string <span class="math">\\tilde{y}</span> that matches <span class="math">y_{T(e)}</span> in the locations corresponding to <span class="math">T(e)</span> and satisfies <span class="math">\\tilde{y}_j = 0</span> otherwise.</p>

    <p class="text-gray-300">Given any commit-challenge-response proof system <span class="math">\\Pi = (P, V)</span> and any public key encryption scheme <span class="math">\\mathsf{PKE} = (\\mathsf{PKE.Gen}, \\mathsf{PKE.PKE.Enc}, \\mathsf{PKE.Dec})</span>, we instantiate the commitment scheme in <span class="math">\\Pi</span></p>

    <p class="text-gray-300">³³In the common reference string model, the prover and verifier have shared access to a CRS sampled by some trusted setup algorithm. In the common random string model, the CRS is required to be a uniformly random string.</p>

    <p class="text-gray-300">³⁴By “uniformly random public key”, we mean a public key that is a uniformly random string, rather than a public key sampled according to the key generation algorithm.</p>

    <p class="text-gray-300">43</p>

    <p class="text-gray-300">using PKE. That is, <span class="math">\\Pi</span> is augmented with a common reference string <span class="math">\\mathsf{pk}</span> (a public key sampled using PKE.Gen) and a commitment <span class="math">\\mathsf{commit}(\\mathsf{pk}, b)</span> is sampled by calling PKE.Enc(<span class="math">\\mathsf{pk}, b</span>). The encryption randomness used in the call to PKE.Enc(<span class="math">\\mathsf{pk}, b</span>) serves as a decommitment for the bit <span class="math">b</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We will apply the Fiat-Shamir transform to <span class="math">\\Pi</span> repeated $\\lambda \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> times in parallel.³⁵ The repeated protocol </span>\\Pi^{\\lambda \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> consists of three messages </span>(\\mathbf{a}, \\mathbf{e}, \\mathbf{z})<span class="math">, and for a fixed secret key </span>\\mathsf{sk}<span class="math"> and instance </span>x \\notin L$, we consider the relation</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block">R_{x,\\mathsf{sk}} = \\left\\{(\\mathbf{a}, \\mathbf{e}): \\operatorname{Check} \\left(x, y_{T(e^{(i)})}^{(i)}, e^{(i)}\\right) = 1 \\text{ for all } i, \\text{ where } \\mathbf{y} = \\mathsf{Dec}(\\mathsf{sk}, \\mathbf{a}) \\right\\}.</span></div>

    <p class="text-gray-300">In [HL18], it was shown that</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Imported Theorem 7.4</strong> ([HL18], see Theorem 6.6). If <span class="math">\\mathcal{H}</span> is correlation intractable with respect to all relations of the form <span class="math">R_{x,\\mathsf{sk}}</span>, then applying the Fiat-Shamir transform to $\\Pi^{\\lambda \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ yields a sound two-message protocol.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to obtain adaptive soundness, we define a new relation <span class="math">R_{\\mathsf{sk}}</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">R_{\\mathsf{sk}} = \\left\\{((x, \\mathbf{a}), \\mathbf{e}): x \\notin L \\text{ and } \\operatorname{Check} \\left(x, y_{T(e^{(i)})}^{(i)}, e^{(i)}\\right) = 1 \\text{ for all } i, \\text{ where } \\mathbf{y} = \\mathsf{Dec}(\\mathsf{sk}, \\mathbf{a}) \\right\\}.</span></div>

    <p class="text-gray-300">As written, the length of the "output" <span class="math">\\mathbf{e}</span> may depend on the input <span class="math">x</span> (i.e. not just its length); however, we can extend this relation by padding the output up to the maximum length of <span class="math">\\mathbf{e}</span> as a function of <span class="math">n</span>.</p>

    <p class="text-gray-300">We first note the following.</p>

    <p class="text-gray-300"><strong>Lemma 7.5.</strong> <span class="math">R_{\\mathsf{sk}}</span> is sparse and non-uniformly efficiently samplable for every <span class="math">(\\mathsf{pk}, \\mathsf{sk})</span> in the support of PKE.Gen.³⁶</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Proof.</strong> The sparsity of <span class="math">R_{\\mathsf{sk}}</span> follows from the <span class="math">2^{-\\Omega(\\lambda)}</span>-soundness of $\\Pi^{\\lambda \\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">.³⁷ To see this, note that because </span>\\Pi<span class="math"> is sound, we have in particular that for every </span>x \\notin L<span class="math"> and every string </span>y<span class="math">, with </span>1 - 2^{-\\Omega(\\lambda)}<span class="math"> probability over the choice of </span>\\mathbf{e}<span class="math">, we have that </span>\\operatorname{Check}\\left(x, y_{T(e^{(i)})}^{(i)}, e^{(i)}\\right) = 0<span class="math"> for some </span>i<span class="math">. Therefore, we have that for every </span>\\mathbf{a}<span class="math">, the same statement holds for </span>y = \\mathsf{PKE.Dec}(\\mathsf{sk}, \\mathbf{a})<span class="math"> (and every </span>x \\notin L<span class="math">). Thus, </span>R_{\\mathsf{sk}}<span class="math"> is </span>2^{-\\Omega(\\lambda)}$-sparse.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">To see that <span class="math">R_{\\mathsf{sk}}</span> is efficiently samplable, we note that given <span class="math">x, \\mathbf{a}</span> and <span class="math">\\mathsf{sk}</span>, we can compute <span class="math">y = \\mathsf{Dec}(\\mathsf{sk}, \\mathbf{a})</span>; then, for each block <span class="math">y^{(i)}</span>, we can enumerate over all challenges <span class="math">e^{(i)}</span>, compute <span class="math">\\operatorname{Check}(x, y_{T(e^{(i)})}^{(i)})</span>, and then sample a uniformly random <span class="math">e^{(i)}</span> subject to passing the check.</p>

    <p class="text-gray-300">We will use this fact to construct a NIZK argument system for NP assuming public-key encryption and programmable hash functions that are correlation intractable for all efficiently samplable relations. This follows the NIZK constructions of [CCRR18,HL18]. In addition, and as noted above, we prove that for special PKE schemes such as Regev encryption, the NIZK can be made to satisfy statistical zero knowledge and rely on a common random string.</p>

    <p class="text-gray-300"><strong>Construction 7.6.</strong> Suppose that:</p>

    <p class="text-gray-300">³⁵ Parallel repetition is done so that the soundness error is reduced to <span class="math">2^{-\\Omega(\\lambda)}</span>.</p>

    <p class="text-gray-300">³⁶ It is worth noting that <span class="math">R_{\\mathsf{sk}}</span> may not be efficiently decidable, as this would require deciding whether <span class="math">x \\in L</span>. We only need to be able to sample a uniformly random "bad" challenge when promised that <span class="math">x \\notin L</span>.</p>

    <p class="text-gray-300">³⁷ We technically need the fact that <span class="math">2^{-\\Omega(\\lambda)}</span>-soundness holds for every fixed choice of <span class="math">(\\mathsf{pk}, \\mathsf{sk})</span>.</p>

    <p class="text-gray-300">44</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi=(P,V)</span> is a commit-challenge-response proof system for a language <span class="math">L</span>,</li>

      <li><span class="math">\\mathsf{PKE}=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})</span> is a public key encryption scheme, and</li>

      <li><span class="math">\\mathcal{H}</span> is a hash family.</li>

    </ul>

    <p class="text-gray-300">We then define <span class="math">\\mathsf{NIZK}_{\\mathsf{FS}}^{\\Pi,\\mathsf{PKE},\\mathcal{H}}=(\\mathsf{Setup},\\tilde{P},\\tilde{V})</span> as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}</span>: On input <span class="math">1^{n}</span>, the setup algorithm samples <span class="math">\\mathsf{pk}\\leftarrow\\mathsf{Gen}(1^{n})</span> and <span class="math">h\\leftarrow\\mathcal{H}_{n}</span>, and then outputs the common reference string <span class="math">(\\mathsf{pk},h)</span>.</li>

      <li><span class="math">\\tilde{P}</span>: On input <span class="math">((\\mathsf{pk},h),x,w)</span>, the prover <span class="math">\\tilde{P}</span> generates a proof <span class="math">\\pi</span> that consists of:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- $\\lambda\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> independently sampled first messages (commitments) </span>\\mathbf{a}=\\left(a^{(1)},\\ldots,a^{(\\lambda\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right)<span class="math"> that arise from instantiating </span>P<span class="math"> with the non-interactive commitment </span>\\mathsf{Enc}(\\mathsf{pk},\\cdot)$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- <span class="math">\\tilde{V}</span>: On input <span class="math">((\\mathsf{pk},h),x,\\pi)</span>, the verifier accepts iff <span class="math">V</span> accepts the $\\lambda\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Sigma</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> transcripts </span>\\left(\\mathsf{pk},x,a^{(i)},e^{(i)},z^{(i)}\\right)<span class="math"> where </span>\\mathbf{e}<span class="math"> is again the first </span>\\lambda\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">\\cdot\\log(</td>

            <td class="px-3 py-2 border-b border-gray-700">\\Sigma</td>

            <td class="px-3 py-2 border-b border-gray-700">)<span class="math"> bits of </span>h(x</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">\\mathbf{a})$.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <h6 id="sec-87" class="text-base font-medium mt-4">Theorem 7.7.</h6>

    <p class="text-gray-300">Suppose that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Pi=(P,V)</span> is an honest-verifier zero knowledge commit-challenge-response proof system for an <span class="math">\\mathsf{NP}</span> language <span class="math">L</span>.</li>

      <li><span class="math">\\mathsf{PKE}=(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})</span> is a public key encryption scheme.</li>

      <li><span class="math">\\mathcal{H}</span> is a hash family (with appropriate input and output lengths) that is correlation intractable for all efficiently samplable relations, and in addition satisfies the following additional property:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Approximate Average-Case Programmability: There is an efficient sampling algorithm <span class="math">h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span> such that for any fixed <span class="math">\\mathbf{a}</span>, the distribution <span class="math">\\{h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})\\}</span> for uniformly random <span class="math">\\mathbf{e}</span> is statistically indistinguishable from <span class="math">h\\leftarrow\\mathcal{H}</span>.</li>

    </ul>

    <p class="text-gray-300">Then, the protocol <span class="math">\\widetilde{\\Pi}</span> (as in Construction 7.6) is an adaptively sound <span class="math">\\mathsf{NIZK}</span> argument scheme for <span class="math">L</span>.</p>

    <p class="text-gray-300">Moreover:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If public keys <span class="math">\\mathsf{pk}</span> generated using <span class="math">\\mathsf{PKE}.\\mathsf{Gen}</span> are (computationally) pseudorandom and <span class="math">\\mathcal{H}</span> has (computationally) pseudorandom keys, then <span class="math">\\widetilde{\\Pi}</span> is an adaptively sound <span class="math">\\mathsf{NIZK}</span> when the CRS is instead sampled to be a uniformly random string.</li>

      <li>If a uniformly random public key <span class="math">\\mathsf{pk}</span> of the scheme is <span class="math">\\mathsf{lossy}</span> – meaning that <span class="math">(\\mathsf{pk},\\mathsf{Enc}(\\mathsf{pk},0))\\approx_{s}(\\mathsf{pk},\\mathsf{Enc}(\\mathsf{pk},1))</span> when <span class="math">\\mathsf{pk}</span> is sampled uniformly at random – and <span class="math">\\Pi</span> satisfies special honest-verifier zero knowledge, then <span class="math">\\widetilde{\\Pi}</span> is an adaptively sound non-interactive statistical zero knowledge (NISZK) argument system.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If condition (2) holds and <span class="math">\\mathcal{H}</span> has <em>statistically</em> pseudorandom keys, then <span class="math">\\widetilde{\\Pi}</span> is an adaptively sound NISZK argument when the CRS is sampled to be a uniformly random string.</li>

    </ol>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Completeness of the protocol follows directly from the completeness of <span class="math">\\Pi</span>.</p>

    <p class="text-gray-300">We next argue (adaptive) soundness. Suppose that some efficient algorithm <span class="math">\\mathcal{A}</span>, given <span class="math">(\\mathsf{pk},h)</span>, is able to produce <span class="math">(x,\\mathbf{a},\\mathbf{z})</span> such that, with non-negligible probability, it holds that <span class="math">x\\not\\in L</span> and <span class="math">\\widetilde{\\Pi}.V(\\mathsf{pk},h,x,\\mathbf{a},\\mathbf{z})=1</span>. We then define the following algorithm <span class="math">\\mathcal{A}^{\\prime}</span> breaking the correlation intractability of <span class="math">\\mathcal{H}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{A}^{\\prime}</span> first samples <span class="math">(\\mathsf{pk},\\mathsf{sk})\\leftarrow\\mathsf{PKE}.{\\sf Gen}(1^{\\lambda})</span> and chooses the relation <span class="math">R_{\\mathsf{sk}}</span> defined as above.</li>

      <li><span class="math">\\mathcal{A}^{\\prime}</span> is then given a hash function <span class="math">h\\leftarrow\\mathcal{H}</span>. It runs <span class="math">\\mathcal{A}(\\mathsf{pk},h)</span>, obtaining <span class="math">(x,\\mathbf{a},\\mathbf{z})</span> and outputs <span class="math">(x,\\mathbf{a})</span>.</li>

    </ul>

    <p class="text-gray-300">To see that this breaks the correlation intractability of <span class="math">\\mathcal{H}</span> with respect to <span class="math">R_{\\mathsf{sk}}</span>, we note that whenever <span class="math">\\widetilde{\\Pi}.V(\\mathsf{pk},h,x,\\mathbf{a},\\mathbf{z})=1</span>, <span class="math">\\mathbf{z}</span> must contain valid decommitments to some strings <span class="math">\\tilde{y}^{(i)}_{T(e_{i})}</span> for each <span class="math">i</span> (where <span class="math">\\mathbf{e}</span> is computed as in Construction 7.6), which are necessarily the corresponding blocks of <span class="math">\\mathsf{PKE}.{\\sf Dec}(\\mathsf{sk},\\mathbf{a})</span> by perfect decryption correctness. Then, the fact that <span class="math">\\widetilde{\\Pi}.V(\\mathsf{pk},h,x,\\mathbf{a},\\mathbf{z})=1</span> implies by definition that <span class="math">R_{\\mathsf{sk}}(x,\\mathbf{a},h(x,\\mathbf{a}))=1</span>.</p>

    <p class="text-gray-300">Therefore, since we know by Lemma 7.5 that <span class="math">R_{\\mathsf{sk}}</span> is sparse and efficiently samplable and <span class="math">\\mathcal{H}</span> is correlation intractable for all such relations, we conclude that <span class="math">\\widetilde{\\Pi}</span> is adaptively sound.</p>

    <p class="text-gray-300">If the CRS is instead sampled to be a uniformly random string and <span class="math">\\mathsf{PKE}</span> and <span class="math">\\mathcal{H}</span> have pseudorandom (public) keys, then soundness follows by a hybrid argument: if an efficient cheating prover could break the (adaptive) soundness of the protocol with a uniformly random CRS, then the same prover would break (adaptive) soundness of the protocol <span class="math">\\widetilde{\\Pi}</span> where the CRS is generated using <span class="math">\\mathsf{PKE}.{\\sf Gen}</span> and <span class="math">\\mathcal{H}.{\\sf Gen}</span>. This would contradict soundness of the basic protocol, hence the modified protocol is sound.</p>

    <p class="text-gray-300">Finally, we show that our scheme is zero knowledge. To do so, we write down the following simulator <span class="math">\\mathsf{Sim}(x,\\mathsf{pk})</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given <span class="math">x</span>, first sample a uniformly random challenge vector <span class="math">\\mathbf{e}</span>.</li>

      <li>Then, run the honest verifier simulator <span class="math">\\Pi.\\mathsf{HVSim}(x,\\mathsf{pk},\\mathbf{e})</span> associated to <span class="math">\\Pi</span> to produce a simulated first message <span class="math">\\mathbf{a}</span> and third message <span class="math">\\mathbf{z}</span></li>

      <li>Finally, sample a hash function <span class="math">h</span> using the sampler <span class="math">\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span> and output <span class="math">(\\mathsf{CRS},\\mathbf{a},\\mathbf{z})</span> where <span class="math">\\mathsf{CRS}=(\\mathsf{pk},h)</span>.</li>

    </ul>

    <p class="text-gray-300">The claim is that when <span class="math">x\\in L</span> and <span class="math">\\mathsf{pk}</span> is generated using <span class="math">\\mathsf{PKE}.{\\sf Gen}</span>, <span class="math">\\mathsf{Sim}(x,\\mathsf{pk})</span> is computationally indistinguishable from an honest proof (using <span class="math">x</span> and a witness <span class="math">w</span>). This follows by a hybrid argument. First, we note that <span class="math">(\\mathbf{a},\\mathbf{e},\\mathbf{z})</span> as sampled by <span class="math">\\mathsf{HVSim}</span> is computationally indistinguishable from an honest proof <span class="math">(\\mathbf{a},\\mathbf{e},\\mathbf{z})</span> (using a uniformly random <span class="math">\\mathbf{e}</span>) by the simulation security of <span class="math">\\Pi</span>, which implies that the output of <span class="math">\\mathsf{Sim}(x,\\mathsf{pk})</span> is computationally indistinguishable from <span class="math">(\\mathsf{CRS},\\mathbf{a},\\mathbf{z})</span> where <span class="math">(\\mathbf{a},\\mathbf{e},\\mathbf{z})</span> is an honest proof and <span class="math">h</span> is sampled from the distribution <span class="math">h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span>. The approximate average-case samplability of <span class="math">\\mathcal{H}</span> then implies that this distribution is indistinguishable from an honest (CRS, proof) pair in the round-compressed protocol.</p>

    <p class="text-gray-300">Finally, suppose that <span class="math">\\mathsf{PKE}</span> is a lossy encryption scheme in which lossy public keys are uniformly random. We again consider the modified protocol in which the public key portion of the CRS is sampled uniformly at random, and our simulator will operate as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a public key <span class="math">\\mathsf{pk}</span> uniformly at random.</li>

      <li>Repeatedly call the special simulator <span class="math">\\Pi.\\mathsf{SHVSim}(x)</span>, producing <span class="math">(e^{(i)},y^{(i)}_{T(e^{(i)})})_{i}</span>.</li>

      <li>Set <span class="math">\\mathbf{a}</span> to be a commitment to strings <span class="math">\\tilde{y}^{(i)}</span> matching the substrings above (and 0 otherwise), and <span class="math">\\mathbf{z}</span> to be decommitments to <span class="math">(y^{(i)}_{T(e^{(i)})})_{i}</span>.</li>

      <li>Sample <span class="math">h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span>.</li>

    </ul>

    <p class="text-gray-300">In this situation, the commitment scheme used to instantiate <span class="math">\\Pi</span> is actually <em>statistically hiding</em> by the lossiness of <span class="math">\\mathsf{PKE}</span>, which implies that the simulated distribution <span class="math">(\\mathbf{a},\\mathbf{e},\\mathbf{z})</span> is statistically indistinguishable from a honest (parallel repeated) <span class="math">\\Pi</span>-proof. This implies that our simulated proof <span class="math">(\\mathsf{pk},h,\\mathbf{a},\\mathbf{z})</span> is statistically indistinguishable from the distribution <span class="math">(\\mathsf{pk},h,\\mathbf{a},\\mathbf{z})</span> in which <span class="math">(\\mathbf{a},\\mathbf{e},\\mathbf{z})</span> is an honest (parallel repeated) <span class="math">\\Pi</span>-proof and <span class="math">h</span> is sampled from <span class="math">h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span>. Then, the approximate average-case samplability of <span class="math">\\mathcal{H}</span> (along with the fact that <span class="math">\\mathcal{H}</span> has statistically pseudorandom keys) again tells us that this is statistically indistinguishable from an honest proof in the round-compressed protocol. This completes the proof of statistical zero knowledge, and of Theorem 7.7. ∎</p>

    <h4 id="sec-89" class="text-lg font-semibold mt-6">7.2.1 Instantiations</h4>

    <p class="text-gray-300">If the (standard) LWE assumption holds, then a variant of Regev public-key encryption satisfies all the conditions required by Theorem 7.7 to ensure that the resulting <span class="math">\\mathsf{NIZK}</span> argument is statistically zero knowledge in the common <em>random</em> string model:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Regev public-key encryption <em>[x10]</em> is a lossy public key encryption scheme.</li>

      <li>To ensure that decryption is perfectly correct, we will use a truncated Gaussian distribution for the noise distribution in our variant of Regev encryption. The polynomial security of this variant (which is all that we require of our commitment scheme) follows from this follows from the security of standard Regev encryption, i.e. from LWE.</li>

    </ul>

    <p class="text-gray-300">The hash family <span class="math">\\mathcal{H}</span> in Theorem 7.7 can be instantiated using any of the KDM-secure encryption schemes from Section 4.2 or Section 4.3. It is clear by inspection that the hash family from Section 4.2 satisfies (perfect) programmbility (this was already noted in <em>[x1]</em>). Moreover, the hash families from Section 4.3 satisfies approximate programmability. An approximate sampling algorithm for the hash family using a secret-key Regev (or <em>[x1]</em>) encryption scheme <span class="math">(\\mathsf{Gen},\\mathsf{Enc},\\mathsf{Dec})</span> and randomized encoding scheme <span class="math">(\\mathsf{RE}.\\mathsf{Enc},\\mathsf{RE}.\\mathsf{Dec},\\mathsf{RE}.\\mathsf{Sim})</span> samples <span class="math">h\\leftarrow\\mathsf{Samp}(\\mathbf{a},\\mathbf{e})</span> by calling <span class="math">\\mathbf{E}\\leftarrow\\mathsf{RE}.\\mathsf{Sim}(\\mathbf{e})</span> and then sampling from the conditional distribution <span class="math">h\\mid\\mathsf{Dec}(\\mathbf{a},h)=\\mathbf{E}</span>. If the randomized encoding is <span class="math">(1-\\text{negl}(\\lambda))</span>-approximately blind, then this sampling algorithm satisfies the desired property.</p>

    <h3 id="sec-90" class="text-xl font-semibold mt-8">7.3 Our <span class="math">\\mathsf{NIZK}</span> Protocol</h3>

    <p class="text-gray-300">We conclude this section by giving an explicit description of our NIZK protocol.</p>

    <h6 id="sec-91" class="text-base font-medium mt-4">Theorem 7.8.</h6>

    <p class="text-gray-300">If Assumption 1 holds with modulus <span class="math">q=pq^{\\prime}</span> for some prime <span class="math">p</span>, secret distribution uniform over <span class="math">[-\\frac{p}{2},\\frac{p}{2})</span>, and noise distribution uniform over <span class="math">[-\\frac{q^{\\prime}}{2},\\frac{q^{\\prime}}{2})</span>, then every language <span class="math">\\mathcal{L}\\in\\mathsf{NP}</span> has a (publicly verifiable) <span class="math">\\mathsf{NIZK}</span> argument scheme <span class="math">\\Pi</span>. Moreover, <span class="math">\\Pi</span> has adaptive soundness and is statistical zero knowledge.</p>

    <p class="text-gray-300">Proof. For simplicity, we describe the NIZK argument system assuming the exponential hardness of Search-LWE with binary secrets, but our argument system that considers Search-LWE for larger secrets follows the same blueprint.</p>

    <p class="text-gray-300">Our NIZK argument scheme for NP uses the following building blocks.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The 3-coloring protocol of <em>[x12]</em>.</li>

      <li>A public-key encryption scheme <span class="math">\\mathsf{PKE}=(\\mathsf{PKE.Gen},\\mathsf{PKE.Enc},\\mathsf{PKE.Dec})</span> with perfect decryption correctness, which we instantiate with standard public-key Regev encryption. The only constraint placed on this instantiation is that the error distribution <span class="math">\\chi_{\\mathrm{err}}</span> for this scheme must be <span class="math">\\frac{q}{4n}</span>-bounded with probability 1.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A secret-key encryption scheme <span class="math">\\widetilde{\\mathsf{SKE}}=(\\widetilde{\\mathsf{SKE.Gen}},\\widetilde{\\mathsf{SKE.Enc}},\\widetilde{\\mathsf{SKE.Dec}})</span> with universal ciphertexts that is $2^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-KDM-secure for </span>S(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-size computable functions of the secret key, where </span>S(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$ is an explicit polynomial function dictated by the protocol below.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In order to instantiate <span class="math">\\widetilde{\\mathsf{SKE}}</span>, we use two additional building blocks</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A secret-key encryption scheme <span class="math">\\mathsf{SKE}=(\\mathsf{SKE.Gen},\\mathsf{SKE.Enc},\\mathsf{SKE.Dec})</span> with universal ciphertexts that is $2^{-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\cdot\\mathrm{poly}(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{sk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">-KDM secure for key-dependent messages that are </span>\\mathbb{Z}_{2}<span class="math">-linear functions of the secret key. This is instantiated with secret-key Regev encryption in which the secret </span>s\\leftarrow\\{0,1\\}^{n}<span class="math"> is a uniformly random binary string, and the error distribution </span>\\chi_{\\mathrm{err}}<span class="math"> is uniform on the set </span>[-\\frac{q}{4},\\frac{q}{4})<span class="math"> (and </span>q$ is even).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A randomized encoding scheme <span class="math">\\mathsf{RE}=(\\mathsf{RE.Enc},\\mathsf{RE.Dec},\\mathsf{RE.Sim})</span> for <span class="math">\\mathsf{P/poly}</span> that is perfectly blind and <span class="math">2^{-\\omega(n\\log(q))}</span>-secure. This is instantiated with point-and-permute garbled circuits (see Imported Theorem 4.12) instantiated with a subexponentially-secure one-way function.</li>

    </ul>

    <p class="text-gray-300">Combining Theorem 3.11, Theorem 7.7, Theorem 4.11, and Imported Theorem 4.12, we conclude that the following protocol is a NIZK argument scheme for NP. In fact, it relies on a common <em>random</em> string and satisfies <em>statistical</em> zero knowledge.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Input: A graph <span class="math">x=(V,E)</span>. The prover receives as additional input a 3-coloring <span class="math">w</span> of <span class="math">x</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Common Random String: A pair <span class="math">(\\mathsf{pk},h)</span>, where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{pk}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the length of a Regev public key and </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">h</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the length of a </span>\\widetilde{\\mathsf{SKE}}<span class="math"> ciphertext corresponding to a message of length </span>\\lambda\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{RE.Sim}(0^{O(\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Proof: A proof <span class="math">\\pi</span> consists of</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- A sequence of $\\lambda\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Sigma</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> independently sampled first messages </span>\\mathbf{a}=(a^{(1)},\\ldots,a^{(\\lambda</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)})<span class="math"> using the <em>[x12]</em> proof system, where commitment is instantiated using </span>\\mathsf{PKE.Enc}$.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">- Verification: The verifier accepts <span class="math">\\pi</span> if the <em>[x12]</em> verifier accepts the $\\lambda\\cdot</td>

            <td class="px-3 py-2 border-b border-gray-700">E</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math"> transcripts </span>(\\mathsf{pk},x,a^{(i)},e^{(i)},z^{(i)})<span class="math"> where </span>\\mathbf{e}$ computed as above. ∎</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[AABN02] Michel Abdalla, Jee Hea An, Mihir Bellare, and Chanathip Namprempre, From identification to signatures via the fiat-shamir transform: Minimizing assumptions for security and forward-security, International Conference on the Theory and Applications of Cryptographic Techniques, Springer, 2002, pp. 418–433.</li>

      <li>[ACPS09] Benny Applebaum, David Cash, Chris Peikert, and Amit Sahai, Fast cryptographic primitives and circular-secure encryption based on hard learning problems, Advances in Cryptology-CRYPTO 2009, Springer, 2009, pp. 595–618.</li>

      <li>[AF07] Masayuki Abe and Serge Fehr, Perfect nizk with adaptive soundness, Theory of Cryptography Conference, Springer, 2007, pp. 118–136.</li>

      <li>[AG11] Sanjeev Arora and Rong Ge, New algorithms for learning in presence of errors, Automata, Languages and Programming - 38th International Colloquium, ICALP 2011, Zurich, Switzerland, July 4-8, 2011, Proceedings, Part I, 2011, pp. 403–415.</li>

      <li>[AIK04] Benny Applebaum, Yuval Ishai, and Eyal Kushilevitz, Cryptography in nc0, Foundations of Computer Science, 2004. Proceedings. 45th Annual IEEE Symposium on, IEEE, 2004, pp. 166–175.</li>

      <li>[AIK11] , How to garble arithmetic circuits, Proceedings of the 2011 IEEE 52nd Annual Symposium on Foundations of Computer Science, IEEE Computer Society, 2011, pp. 120–129.</li>

      <li>[AKS01] Miklós Ajtai, Ravi Kumar, and Dandapani Sivakumar, A sieve algorithm for the shortest lattice vector problem, Proceedings of the thirty-third annual ACM symposium on Theory of computing, ACM, 2001, pp. 601–610.</li>

      <li>[App11] Benny Applebaum, Key-dependent message security: Generic amplification and completeness, Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), Springer, 2011, pp. 527–546.</li>

      <li>[Bar01] Boaz Barak, How to go beyond the black-box simulation barrier, FOCS, IEEE, 2001, p. 106.</li>

      <li>[BCC^{+}17] Nir Bitansky, Ran Canetti, Alessandro Chiesa, Shafi Goldwasser, Huijia Lin, Aviad Rubinstein, and Eran Tromer, The hunting of the SNARK, Journal of Cryptology 30 (2017), no. 4, 989–1066.</li>

      <li>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner, Interactive oracle proofs, Theory of Cryptography Conference, Springer, 2016, pp. 31–60.</li>

      <li>[BDG^{+}13] Nir Bitansky, Dana Dachman-Soled, Sanjam Garg, Abhishek Jain, Yael Tauman Kalai, Adriana López-Alt, and Daniel Wichs, Why "fiat-shamir for proofs" lacks a proof, Theory of Cryptography - 10th Theory of Cryptography Conference, TCC 2013, Tokyo, Japan, March 3-6, 2013. Proceedings, 2013, pp. 182–201.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[BG10] Zvika Brakerski and Shafi Goldwasser, <em>Circular and leakage resilient public-key encryption under subgroup indistinguishability</em>, Annual Cryptology Conference, Springer, 2010, pp. 1–20.</li>

      <li>[BG14] Shi Bai and Steven D. Galbraith, <em>Lattice decoding attacks on binary LWE</em>, ACISP, Lecture Notes in Computer Science, vol. 8544, Springer, 2014, pp. 322–337.</li>

      <li>[BGV12] Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan, <em>(leveled) fully homomorphic encryption without bootstrapping</em>, Proceedings of the 3rd Innovations in Theoretical Computer Science Conference, ACM, 2012, pp. 309–325.</li>

      <li>[BHHI10] Boaz Barak, Iftach Haitner, Dennis Hofheinz, and Yuval Ishai, <em>Bounded key-dependent message security</em>, Annual International Conference on the Theory and Applications of Cryptographic Techniques (EUROCRYPT), Springer, 2010, pp. 423–444.</li>

      <li>[BHHO08] Dan Boneh, Shai Halevi, Mike Hamburg, and Rafail Ostrovsky, <em>Circular-secure encryption from decision diffie-hellman</em>, Annual International Cryptology Conference, Springer, 2008, pp. 108–125.</li>

      <li>[BHK17] Zvika Brakerski, Justin Holmgren, and Yael Tauman Kalai, <em>Non-interactive delegation and batch NP verification from standard computational assumptions</em>, Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, STOC 2017, Montreal, QC, Canada, June 19-23, 2017, 2017, pp. 474–482.</li>

      <li>[BHY09] Mihir Bellare, Dennis Hofheinz, and Scott Yilek, <em>Possibility and impossibility results for encryption and commitment secure under selective opening</em>, Annual International Conference on the Theory and Applications of Cryptographic Techniques, Springer, 2009, pp. 1–35.</li>

      <li>[BKW03] Avrim Blum, Adam Kalai, and Hal Wasserman, <em>Noise-tolerant learning, the parity problem, and the statistical query model</em>, Journal of the ACM (JACM) 50 (2003), no. 4, 506–519.</li>

      <li>[BLSV18] Zvika Brakerski, Alex Lombardi, Gil Segev, and Vinod Vaikuntanathan, <em>Anonymous IBE, leakage resilience and circular security from new assumptions</em>, Annual International Conference on the Theory and Applications of Cryptographic Techniques, Springer, 2018, pp. 535–564.</li>

      <li>[BMR90] Donald Beaver, Silvio Micali, and Phillip Rogaway, <em>The round complexity of secure protocols</em>, Proceedings of the twenty-second annual ACM symposium on Theory of computing, ACM, 1990, pp. 503–513.</li>

      <li>[BP15] Nir Bitansky and Omer Paneth, <em>ZAPs and Non-Interactive Witness Indistinguishability from Indistinguishability Obfuscation</em>, Theory of Cryptography - TCC 2015, 2015.</li>

      <li>[Bra12] Zvika Brakerski, <em>Fully homomorphic encryption without modulus switching from classical GapSVP</em>, Advances in Cryptology–CRYPTO 2012, Springer, 2012, pp. 868–886.</li>

      <li>[BV11] Zvika Brakerski and Vinod Vaikuntanathan, <em>Efficient fully homomorphic encryption from (standard) LWE</em>, Proceedings of the 2011 IEEE 52nd Annual Symposium on Foundations of Computer Science, IEEE Computer Society, 2011, pp. 97–106.</li>

    </ul>

    <p class="text-gray-300">[BV14] , <em>Lattice-based FHE as secure as PKE</em>, Proceedings of the 5th conference on Innovations in theoretical computer science, ACM, 2014, pp. 1–12.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[CCR16] Ran Canetti, Yilei Chen, and Leonid Reyzin, <em>On the correlation intractability of obfuscated pseudorandom functions</em>, Theory of Cryptography Conference, Springer, 2016, pp. 389–415.</li>

      <li>[CCRR18] Ran Canetti, Yilei Chen, Leonid Reyzin, and Ron D Rothblum, <em>Fiat-Shamir and correlation intractability from strong KDM-secure encryption</em>, Annual International Conference on the Theory and Applications of Cryptographic Techniques – EUROCRYPT 2018, Springer, 2018, pp. 91–122.</li>

      <li>[CGH04] Ran Canetti, Oded Goldreich, and Shai Halevi, <em>The random oracle methodology, revisited</em>, Journal of the ACM (JACM) 51 (2004), no. 4, 557–594.</li>

      <li>[CN11] Yuanmi Chen and Phong Q Nguyen, <em>BKZ 2.0: Better lattice security estimates</em>, International Conference on the Theory and Application of Cryptology and Information Security, Springer, 2011, pp. 1–20.</li>

      <li>[CZ81] David G Cantor and Hans Zassenhaus, <em>A new algorithm for factoring polynomials over finite fields</em>, Mathematics of Computation (1981), 587–592.</li>

      <li>[DNRS99] Cynthia Dwork, Moni Naor, Omer Reingold, and Larry J. Stockmeyer, <em>Magic functions</em>, FOCS, IEEE Computer Society, 1999, pp. 523–534.</li>

      <li>[FLS99] Uriel Feige, Dror Lapidot, and Adi Shamir, <em>Multiple noninteractive zero knowledge proofs under general assumptions</em>, SIAM Journal on Computing 29 (1999), no. 1, 1–28.</li>

      <li>[FS86] Amos Fiat and Adi Shamir, <em>How to prove yourself: Practical solutions to identification and signature problems</em>, Conference on the Theory and Application of Cryptographic Techniques, Springer, 1986, pp. 186–194.</li>

      <li>[Gen09] Craig Gentry, <em>Fully homomorphic encryption using ideal lattices</em>, STOC, ACM, 2009, pp. 169–178.</li>

      <li>[GK03] Shafi Goldwasser and Yael Tauman Kalai, <em>On the (in) security of the Fiat-Shamir paradigm</em>, Foundations of Computer Science, 2003. Proceedings. 44th Annual IEEE Symposium on, IEEE, 2003, pp. 102–113.</li>

      <li>[GK16] , <em>Cryptographic assumptions: A position paper</em>, Theory of Cryptography Conference, Springer, 2016, pp. 505–522.</li>

      <li>[GKR08] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum, <em>Delegating computation: interactive proofs for muggles</em>, Proceedings of the fortieth annual ACM symposium on Theory of computing, ACM, 2008, pp. 113–122.</li>

      <li>[GMW91] Oded Goldreich, Silvio Micali, and Avi Wigderson, <em>Proofs that yield nothing but their validity or all languages in NP have zero-knowledge proof systems</em>, Journal of the ACM (JACM) 38 (1991), no. 3, 690–728.</li>

    </ul>

    <p class="text-gray-300">[GN08] Nicolas Gama and Phong Q. Nguyen, <em>Predicting lattice reduction</em>, EUROCRYPT, Lecture Notes in Computer Science, vol. 4965, Springer, 2008, pp. 31–51.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[Gol99] Oded Goldreich, <em>Modern cryptography, probabilistic proofs and pseudorandomness</em>, Algorithms and Combinatorics, vol. 17, Springer-Verlag, 1999.</li>

      <li>[Gol17] , <em>On the doubly-efficient interactive proof systems of GKR</em>, Electronic Colloquium on Computational Complexity (ECCC) 24 (2017), 101.</li>

      <li>[GOS06] Jens Groth, Rafail Ostrovsky, and Amit Sahai, <em>Non-interactive zaps and new techniques for nizk</em>, Annual International Cryptology Conference, Springer, 2006, pp. 97–111.</li>

      <li>[GSW13] Craig Gentry, Amit Sahai, and Brent Waters, <em>Homomorphic encryption from learning with errors: Conceptually-simpler, asymptotically-faster, attribute-based</em>, Advances in Cryptology–CRYPTO 2013, Springer, 2013, pp. 75–92.</li>

      <li>[GW11] Craig Gentry and Daniel Wichs, <em>Separating succinct non-interactive arguments from all falsifiable assumptions</em>, Proceedings of the forty-third annual ACM symposium on Theory of computing, ACM, 2011, pp. 99–108.</li>

      <li>[HL18] Justin Holmgren and Alex Lombardi, <em>Cryptographic hashing from strong one-way functions</em>, Proceedings - Annual IEEE Symposium on Foundations of Computer Science, FOCS, 2018, to appear.</li>

      <li>[HMR08] Shai Halevi, Steven Myers, and Charles Rackoff, <em>On seed-incompressible functions</em>, Theory of Cryptography Conference, Springer, 2008, pp. 19–36.</li>

      <li>[IK02] Yuval Ishai and Eyal Kushilevitz, <em>Perfect constant-round secure computation via perfect randomizing polynomials</em>, International Colloquium on Automata, Languages, and Programming, Springer, 2002, pp. 244–256.</li>

      <li>[Kan87] Ravi Kannan, <em>Minkowski’s convex body theorem and integer programming</em>, Mathematics of operations research 12 (1987), no. 3, 415–440.</li>

      <li>[KN08] Gillat Kol and Moni Naor, <em>Cryptography and game theory: Designing protocols for exchanging information</em>, Theory of Cryptography Conference, Springer, 2008, pp. 320–339.</li>

      <li>[KPY18] Yael Kalai, Omer Paneth, and Lisa Yang, <em>On publicly verifiable delegation from standard assumptions</em>, IACR Cryptology ePrint Archive 2018 (2018), 776.</li>

      <li>[KRR14] Yael Tauman Kalai, Ran Raz, and Ron D. Rothblum, <em>How to delegate computations: the power of no-signaling proofs</em>, Symposium on Theory of Computing, STOC 2014, New York, NY, USA, May 31 - June 03, 2014, 2014, pp. 485–494.</li>

      <li>[KRR17] Yael Tauman Kalai, Guy N. Rothblum, and Ron D. Rothblum, <em>From obfuscation to the security of fiat-shamir for proofs</em>, CRYPTO (2), Lecture Notes in Computer Science, vol. 10402, Springer, 2017, pp. 224–251.</li>

      <li>[KV16] Seungki Kim and Akshay Venkatesh, <em>The behavior of random reduced bases</em>, International Mathematics Research Notices (2016).</li>

    </ul>

    <p class="text-gray-300">[LFKN92] Carsten Lund, Lance Fortnow, Howard J. Karloff, and Noam Nisan, <em>Algebraic methods for interactive proof systems</em>, J. ACM 39 (1992), no. 4, 859–868.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[LLL82] Arjen Klaas Lenstra, Hendrik Willem Lenstra, and László Lovász, <em>Factoring polynomials with rational coefficients</em>, Mathematische Annalen 261 (1982), no. 4, 515–534.</li>

      <li>[LP09] Yehuda Lindell and Benny Pinkas, <em>A proof of security of Yao’s protocol for two-party computation</em>, Journal of Cryptology 22 (2009), no. 2, 161–188.</li>

      <li>[Mic00] Silvio Micali, <em>Computationally sound proofs</em>, SIAM Journal on Computing 30 (2000), no. 4, 1253–1298.</li>

      <li>[MP13] Daniele Micciancio and Chris Peikert, <em>Hardness of SIS and LWE with small parameters</em>, Advances in Cryptology–CRYPTO 2013, Springer, 2013, pp. 21–39.</li>

      <li>[MR09] Daniele Micciancio and Oded Regev, <em>Lattice-based cryptography</em>, Post-quantum cryptography, Springer, 2009, pp. 147–191.</li>

      <li>[MW16] Daniele Micciancio and Michael Walter, <em>Practical, predictable lattice basis reduction</em>, Annual International Conference on the Theory and Applications of Cryptographic Techniques, Springer, 2016, pp. 820–849.</li>

      <li>[Nao03] Moni Naor, <em>On cryptographic assumptions and challenges</em>, Annual International Cryptology Conference – CRYPTO 2003, Springer, 2003, pp. 96–109.</li>

      <li>[NS06] Phong Q. Nguyen and Damien Stehlé, <em>LLL on the average</em>, ANTS, Lecture Notes in Computer Science, vol. 4076, Springer, 2006, pp. 238–256.</li>

      <li>[Pei16] Chris Peikert, <em>A decade of lattice cryptography</em>, Foundations and Trends in Theoretical Computer Science 10 (2016), no. 4, 283–424.</li>

      <li>[PR17] Omer Paneth and Guy N. Rothblum, <em>On zero-testable homomorphic encryption and publicly verifiable non-interactive arguments</em>, TCC (2), Lecture Notes in Computer Science, vol. 10678, Springer, 2017, pp. 283–315.</li>

      <li>[PS96] David Pointcheval and Jacques Stern, <em>Security proofs for signature schemes</em>, International Conference on the Theory and Applications of Cryptographic Techniques, Springer, 1996, pp. 387–398.</li>

      <li>[PVW08] Chris Peikert, Vinod Vaikuntanathan, and Brent Waters, <em>A framework for efficient and composable oblivious transfer</em>, Annual international cryptology conference, Springer, 2008, pp. 554–571.</li>

      <li>[Reg09] Oded Regev, <em>On lattices, learning with errors, random linear codes, and cryptography</em>, Journal of the ACM (JACM) 56 (2009), no. 6, 34.</li>

      <li>[Rog91] Phillip Rogaway, <em>The round complexity of secure protocols</em>, Ph.D. thesis, Massachusetts Institute of Technology, 1991.</li>

      <li>[RRR16] Omer Reingold, Guy N Rothblum, and Ron D Rothblum, <em>Constant-round interactive proofs for delegating computation</em>, Proceedings of the forty-eighth annual ACM symposium on Theory of Computing, ACM, 2016, pp. 49–62.</li>

    </ul>

    <p class="text-gray-300">[Sch87] Claus-Peter Schnorr, <em>A hierarchy of polynomial time lattice basis reduction algorithms</em>, Theor. Comput. Sci. 53 (1987), 201–224.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[SE94] Claus-Peter Schnorr and Martin Euchner, <em>Lattice basis reduction: Improved practical algorithms and solving subset sum problems</em>, Mathematical programming 66 (1994), no. 1-3, 181–199.</li>

      <li>[SW14] Amit Sahai and Brent Waters, <em>How to use indistinguishability obfuscation: deniable encryption, and more</em>, Proceedings of the forty-sixth annual ACM symposium on Theory of computing, ACM, 2014, pp. 475–484.</li>

      <li>[WTS^{+}18] Riad S Wahby, Ioanna Tzialla, Abhi Shelat, Justin Thaler, and Michael Walfish, <em>Doubly-efficient zkSNARKs without trusted setup</em>, 2018 IEEE Symposium on Security and Privacy (SP), IEEE, 2018, pp. 926–943.</li>

      <li>[Yao86] Andrew Chi-Chih Yao, <em>How to generate and exchange secrets</em>, Foundations of Computer Science, 1986., 27th Annual Symposium on, IEEE, 1986, pp. 162–167.</li>

      <li>[YD17] Yang Yu and Léo Ducas, <em>Second order statistical behavior of LLL and BKZ</em>, International Conference on Selected Areas in Cryptography, Springer, 2017, pp. 3–22.</li>

    </ul>

    <h2 id="sec-93" class="text-2xl font-bold">Appendix A Success probability of polynomial time algorithms on LWE</h2>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We provide a survey of the existing algorithms for breaking LWE and their success probabilities when restricted to run in polynomial time. Recall from Assumption 1, we assume the success probability of a polynomial time secret-recovery attack is at most $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{Supp}(\\chi_{\\text{sec}})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">^{-n}\\cdot\\text{poly}(n,\\log(q))<span class="math">. For example, achieving the success probability of </span>2^{-0.99\\lambda}<span class="math"> would violate this assumption (w.r.t. a search space of size </span>2^{\\lambda}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Loosely speaking, all known algorithms for LWE use one or more of the following techniques:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Lattice basis reduction (e.g. <em>[x14, x23, x19]</em>),</li>

      <li>Enumeration (since <em>[x15]</em>)</li>

      <li>Sieving (since <em>[x1]</em>)</li>

      <li>Combinatorial (since <em>[x4]</em>)</li>

      <li>Algebraic (since <em>[x2]</em>).</li>

    </ul>

    <p class="text-gray-300">These algorithms are typically optimized to run in the smallest possible running time while still solving LWE with overwhelming (or at least noticeable) probability. In contrast, we are concerned with the complexity of solving LWE with tiny (but non-trivial) probability. It is in general not clear if existing algorithms can be adapted to this setting. In particular, we do not know of any way to scale enumeration, sieving, or combinatorial algorithms down to the polynomial-time regime while achieving better success probability than guessing. Let us remark that any polynomial time algorithm with success probability of <span class="math">2^{-c\\lambda}</span> can be turned into an algorithm that in <span class="math">\\tilde{O}(2^{c\\lambda})</span> time and <em>polynomial space</em> that succeeds with overwhelming probability, which would be a surprising improvement to these types of algorithms.</p>

    <p class="text-gray-300">We further narrow down the scope of our discussion by restricting each entry of the error vector <span class="math">\\mathbf{e}</span> to be sampled from a distribution of standard deviation <span class="math">\\sigma</span> greater or equal to <span class="math">2\\sqrt{n}</span>. This is justified by both the worst-case to average-case reduction <em>[x20]</em> which requires <span class="math">\\sigma</span> to be greater or equal to <span class="math">2\\sqrt{n}</span>, and the Arora-Ge attack <em>[x1]</em> which is only effective when <span class="math">\\sigma&lt;O(\\sqrt{n})</span>. We remark that the Arora-Ge attack also requires sufficiently many samples. Meanwhile, <em>[x22]</em> shows when limited number of LWE samples are given out, LWE with small errors is as secure as standard LWE. Still, we choose to restrict ourselves to the high noise regime, given that we need the search space of the noise to be larger than the one for the secret anyway.</p>

    <h3 id="sec-94" class="text-xl font-semibold mt-8">A.1 The success probability of the lattice basis reduction approach</h3>

    <p class="text-gray-300">In the rest of the survey we analyze the success probabilities of the basis reduction algorithms. The flexible parameters in the LWE instance are the secret distribution <span class="math">\\chi_{\\text{sec}}</span>, the modulus <span class="math">q</span>, and noise/modulus ratio. We assume the secret distribution is uniform over <span class="math">[-B,B]^{n}</span> where <span class="math">B</span> is a bound that is typically much smaller than <span class="math">q/2</span>, and <span class="math">(2B+1)^{n}</span> is chosen to be close to <span class="math">2^{\\lambda}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given an <span class="math">n</span>-dimensional lattice <span class="math">\\mathcal{L}</span>. The quality of the basis <span class="math">\\mathbf{B}</span> produced by a lattice basis reduction algorithm is typically measured by the root Hermite factor <span class="math">\\delta</span>, defined as $\\left(\\frac{\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{b}_{1}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{\\det(\\Lambda)^{1/n}}\\right)^{1/n}<span class="math"> where </span>\\mathbf{b}_{1}<span class="math"> is the shortest vector in </span>\\mathbf{B}<span class="math">. The probabilistic polynomial time version of the LLL algorithm <em>[x18]</em> achieves </span>\\delta=1.0746<span class="math"> in the worst case. Furthermore, Schnorr’s algorithm offers a trade-off of finding a </span>2^{n/k}<span class="math">-approximate shortest vector with the running time </span>2^{k}<span class="math"> <em>[x26]</em>. Within polynomial time, Schnorr’s algorithm outputs a </span>2^{O\\left(\\frac{n\\log\\log n}{\\log n}\\right)}<span class="math">-approximate shortest vector in </span>\\mathcal{L}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In practice, it is widely observed that the basis reduction algorithms perform much better than the worst-case bound in theory. Nguyen and Stehlé <em>[x23]</em> suggest that the root Hermite factor achieved by LLL is <span class="math">1.02</span> on average. So to give a proper estimation of the hardness of LWE, we consider both the theoretical bounds and the experimental evidences.</p>

    <h5 id="sec-95" class="text-base font-semibold mt-4">Choosing a proper basis.</h5>

    <p class="text-gray-300">Let <span class="math">\\mathbf{A}\\in\\mathbb{Z}_{q}^{m\\times n}</span>, <span class="math">\\mathbf{y}=\\mathbf{A}\\mathbf{s}+\\mathbf{e}\\pmod{q}</span> be our target LWE instance. Considering the following lattice <span class="math">\\mathcal{L}_{\\mathbf{A}}</span> with basis <span class="math">\\mathbf{B}</span>:</p>

    <p class="text-gray-300">\\[ \\mathbf{B}=\\begin{pmatrix}q\\mathbf{I}^{m\\times m}&\\mathbf{A}\\\\ \\mathbf{0}&\\mathbf{I}^{n\\times n}\\end{pmatrix}. \\]</p>

    <p class="text-gray-300">Expressing <span class="math">\\mathbf{y}</span> as <span class="math">\\mathbf{A}\\mathbf{s}+\\mathbf{e}+q\\mathbf{k}</span> gives us $\\mathbf{B}\\cdot\\begin{pmatrix}\\mathbf{k}\\\\ \\mathbf{s}\\end{pmatrix}-\\begin{pmatrix}\\mathbf{y}\\\\ \\mathbf{0}\\end{pmatrix}=\\begin{pmatrix}-\\mathbf{e}\\\\</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\end{pmatrix}<span class="math">. If </span>\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{s}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is small (which is the interesting case in our applications), then LWE can be solved by running a CVP solver on given the basis </span>\\mathbf{B}<span class="math"> and target </span>\\mathbf{t}:=\\begin{pmatrix}\\mathbf{y}\\\\</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">\\mathbf{0}\\end{pmatrix}<span class="math">, or running an SVP solver on \\[ \\begin{pmatrix}\\mathbf{B}&amp;\\mathbf{t}\\\\ \\mathbf{0}&amp;M\\end{pmatrix} \\] where </span>M<span class="math"> is a relatively small integer (e.g. </span>M=1$). This is referred to as the primal approach.</p>

    <p class="text-gray-300">Alternatively, we can try to solve the SIS problem for <span class="math">\\mathbf{A}</span>, then conduct a distinguishing attack. This is referred to as the dual approach.</p>

    <p class="text-gray-300">For both approaches, when <span class="math">m</span> (i.e. the number of LWE samples) is sufficiently large, the success probability (or the running time) of the basis reduction algorithm can be optimized by throwing away a few samples and working with a smaller <span class="math">m</span>. From now we assume <span class="math">m</span> is the optimized number of LWE samples. According to <em>[x21]</em>, for the dual approach, given a desired root Hermite factor <span class="math">\\delta</span>, the optimal choice for <span class="math">m</span> is to set <span class="math">m\\approx\\sqrt{n\\log q/\\log\\delta}</span>, then the state-of-art basis reduction</p>

    <p class="text-gray-300">algorithm outputs a vector of length <span class="math">\\min\\{q,2^{2\\sqrt{n\\log q\\log\\delta}}\\}</span>. For the primal approach the estimation is similar.</p>

    <h4 id="sec-96" class="text-lg font-semibold mt-6">The distribution of the reduced basis.</h4>

    <p class="text-gray-300">Recall our goal is to estimate the success probability of the secret-recovery attack, in an extreme setting where a success probability of say <span class="math">2^{-0.99\\lambda}</span> would be considered non-trivial w.r.t. a search space of size <span class="math">2^{\\lambda}</span>. So we would like to estimate the probability of finding a “significantly short” vector via the basis reduction algorithms. To keep the discussion concrete, we stick with the following meaning of “significantly short”: the root Hermite factor is <span class="math">(1+\\epsilon)</span> where <span class="math">\\epsilon&gt;0</span> is an arbitrarily small constant.</p>

    <p class="text-gray-300">However, understanding the distribution of the outputs produced by LLL/BKZ is known as a challenging problem. Below we survey a few recent studies that tackle the problem from different directions. Jumping ahead, currently we are not able to draw a solid conclusion from these studies to our assumption.</p>

    <p class="text-gray-300">Fixing two target root Hermite factors <span class="math">\\delta_{0}&gt;\\delta_{1}&gt;1</span>. Suppose the LLL/BKZ algorithm outputs a <em>random</em> basis among all the <span class="math">\\delta_{0}</span>-reduced bases (under a well-defined probability measure), then the probability of achieving root Hermite factor <span class="math">\\delta_{1}</span> can be estimated by counting the number of <span class="math">\\delta_{1}</span>-reduced bases out of all the <span class="math">\\delta_{0}</span>-reduced bases. To this end, Kim and Venkatesh <em>[10]</em> study the statistical behavior of <span class="math">\\delta</span>-Siegel-reduced bases (the Siegel-reduced bases satisfy a slightly weaker condition than the LLL-reduced bases). Their study shows that most of the <span class="math">\\delta</span>-Siegel-reduced bases have root Hermit factors very close to <span class="math">\\delta</span>. Formally, let <span class="math">N_{\\delta}(L)</span> be the number of the Siegel-reduced bases for a lattice <span class="math">L</span> of <span class="math">n</span>-dimension with reduction parameter <span class="math">\\delta</span>. The expectation of <span class="math">N_{\\delta}(L)</span> satisfies <span class="math">\\lim_{n}\\frac{\\log\\mathrm{EN}_{\\delta}(\\mathrm{L})}{n^{3}}=\\frac{1}{6}\\log\\delta</span>. Assuming Riemann hypothesis, the standard deviation of <span class="math">N_{\\delta}(L)</span> is at most <span class="math">e^{-O(n^{2})}</span> times its mean. This means for a fixed lattice <span class="math">L</span>, by Chebyshev’s inequality, with probability greater than <span class="math">1-e^{-O(n^{2})}</span>, the portion of <span class="math">(\\delta_{0}-0.0001)</span>-reduced bases out of all the <span class="math">\\delta_{0}</span>-reduced bases is <span class="math">e^{-O(n^{3})}</span>.</p>

    <p class="text-gray-300">However, the result of <em>[10]</em> indeed justifies that the bases produced by the LLL/BKZ algorithm in practice are largely biased, since otherwise the average root Hermite factor would be closer to <span class="math">1.0746</span> but not <span class="math">1.02</span>. The precise statistical behavior of LLL/BKZ remains largely elusive. Recent experimental studies (cf. <em>[11, 12, 13, 14]</em>, and more) provide more predictions on the standard deviation and other parameters, which suggest that the basis reduction algorithms might produce an extremely short vector “more often than expected”. But at this moment, we are not able to conclude that the basis reduction algorithms achieve root Hermite factor <span class="math">(1+\\epsilon)</span> for an arbitrarily small constant <span class="math">\\epsilon&gt;0</span> with non-trivial probability.</p>

    <h4 id="sec-97" class="text-lg font-semibold mt-6">Summary.</h4>

    <p class="text-gray-300">Under the current understanding of the statistical behavior of LLL/BKZ, if the modulus <span class="math">q</span> is chosen to be smaller or equal to <span class="math">2^{\\mathsf{polylog}(n)}</span>, then the existing lattice reduction algorithms do not seem to achieve non-trivial success probabilities in breaking LWE. As a precautionary measure, the modulus <span class="math">q</span> can be chosen as a polynomial in <span class="math">n</span>, which implies the modulus/noise ratio is polynomial. All of the applications in our paper can use such a choice of <span class="math">q</span>.</p>

    <p class="text-gray-300">##</p>`;
---

<BaseLayout title="Fiat-Shamir From Simpler Assumptions (2018/1004)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2018 &middot; eprint 2018/1004
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
