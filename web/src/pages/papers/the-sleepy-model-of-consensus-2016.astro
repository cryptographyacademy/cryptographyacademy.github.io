---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/918';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'The Sleepy Model of Consensus';
const AUTHORS_HTML = 'Rafael Pass, Elaine Shi';

const CONTENT = `    <p class="text-gray-300">Rafael Pass Elaine Shi CornellTech Cornell</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">The literature on distributed computing (as well as the cryptography literature) typically considers two types of players—<em>honest</em> players and <em>corrupted</em> players. Resilience properties are then analyzed assuming a lower bound on the fraction of honest players. Honest players, however, are not only assumed to follow the prescribed the protocol, but also assumed to be <em>online</em> throughout the whole execution of the protocol. The advent of “large-scale” consensus protocols (e.g., the blockchain protocol) where we may have millions of players, makes this assumption unrealistic. In this work, we initiate a study of distributed protocols in a “sleepy” model of computation where players can be either <em>online</em> (alert) or <em>offline</em> (asleep), and their online status may change at any point during the protocol. The main question we address is:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p><em>Can we design consensus protocols that remain resilient under “sporadic participation”, where at any given point, only a subset of the players are actually online?</em></p>
    </blockquote>

    <p class="text-gray-300">As far as we know, all standard consensus protocols break down under such sporadic participation, even if we assume that 99% of the online players are honest.</p>

    <p class="text-gray-300">Our main result answers the above question in the affirmative. We present a construction of a consensus protocol in the sleepy model, which is resilient assuming only that a <em>majority of the online players are honest</em>. Our protocol relies on a Public-Key Infrastructure (PKI), a Common Random String (CRS) and is proven secure in the timing model of Dwork-Naor-Sahai (STOC’98) where all players are assumed to have weakly-synchronized clocks (all clocks are within <span class="math">\\Delta</span> of the “real time”) and all messages sent on the network are delivered within <span class="math">\\Delta</span> time, and assuming the existence of sub-exponentially secure collision-resistant hash functions and enhanced trapdoor permutations. Perhaps surprisingly, our protocol significantly departs from the standard approaches to distributed consensus, and we instead rely on key ideas behind Nakamoto’s blockchain protocol (while dispensing the need for “proofs-of-work”). We finally observe that sleepy consensus is impossible in the presence of a dishonest majority of online players.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Consensus protocols are at the core of distributed computing and also provide a foundational building protocol for multi-party cryptographic protocols. In this paper, we consider consensus protocols for realizing a "linearly ordered log" abstraction—often referred to as state machine replication or linearizability in the distributed systems literature. Such protocols must respect two important resiliency properties, consistency and liveness. Consistency ensures that all honest nodes have the same view of the log, whereas liveness requires that transactions will be incorporated into the log quickly.</p>

    <p class="text-gray-300">The literature on distributed computing as well as the cryptography literature typically consider two types of players—honest players and corrupted/adversarial players. The above-mentioned resiliency properties are then analyzed assuming a lower bound on the fraction of honest players (e.g., assuming that at least a majority of the players are honest). Honest players, however, are not only assumed to follow the prescribed the protocol, but also assumed to be online throughout the whole execution of the protocol. Whereas this is a perfectly reasonable assumption for the traditional environments in which consensus protocols typically were deployed (e.g., within a company, say "Facebook", to support an application, say "Fackbuck Credit", where the number of nodes/players is roughly a dozen), the advent of "large-scale" consensus protocols (such as e.g., the blockchain protocol)—where want to achieve consensus among millions of players—makes this latter assumption unrealistic. (For instance, in bitcoin, only a small fraction of users having bitcoins are actually participating as miners.)</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.1 The Sleepy Model of Consensus</h2>

    <p class="text-gray-300">Towards addressing this issue, we here initiate a study of distributed protocols in a "sleepy" model of computation. In this model, players can be either online ("awake/active") or offline ("asleep"), and their online status may change at any point during the protocol execution. The main question we address is:</p>

    <p class="text-gray-300">Can we design consensus protocols that remain resilient under "sporadic participation"—where at any given point, only a subset of the players are actually online—assuming an appropriate fraction (e.g., majority) of the online players are honest?</p>

    <p class="text-gray-300">As far as we know, this question was first raised by Micali [31] in a recent manuscript¹ —he writes “... a user missing to participate in even a single round is pessimistically judged malicious—although, in reality, he may have only experienced a network-connection problem, or simply taken a break. [...] One possibility would be to revise the current Honest Majority of Users assumption so as it applies only to the “currently active” users rather than the “currently existing” users.” In Micali’s work, however, a different path is pursued.² In contrast, our goal here is to address this question. It is easy to see that consensus is impossible in this model unless we assume that at least a majority of the awake players are honest (if the set of awake players can arbitrarily change throughout the execution)—briefly, the reason for this is that a player that wakes up after being asleep for a long time cannot distinguish the real execution by the honest player and an emulated</p>

    <p class="text-gray-300">¹ Although our paper is subsequent, at the original time of writing this paper, we were actually not aware of this; this discussion was present in the arXiv version from August 2016, but is no longer present in the most recent version of his manuscript.</p>

    <p class="text-gray-300">² Briefly, rather than designing a protocol that remains resilient under this relaxed honesty assumption, he designs a protocol under an incomparable “honest-but-lazy” assumption, where honest players only are required to participate at infrequent but individually prescribed rounds (and if they miss participation in their prescribed round, they are deemed corrupted). Looking forward, the honest strategy in our protocols also satisfies such a laziness property.</p>

    <p class="text-gray-300">“fake” execution by the malicious players, and thus must choose the “fake” one with probability at least <span class="math">\\frac{1}{2}</span>. We formalize this in Theorem 10 (in Section 8).</p>

    <p class="text-gray-300">We then consider the following question:</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
      <p>Can we design a consensus protocol that achieves consistency and liveness assuming only that a majority of the online players are honest?</p>
    </blockquote>

    <p class="text-gray-300">As far as we know, all standard consensus protocols break down in the sleepy model, even if we assume that 99% of the online players are honest! Briefly, the standard protocols can be divided into two types: 1) protocols that assume synchronous communication, where all messages sent by honest players are guaranteed to be received by all other honest nodes in the next round; or, 2) protocols handling partially synchronous or asynchronous communication, but in this case require knowledge of a tight bound on the number of actually participating honest players. In more detail:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Traditional synchronous protocols (e.g., <em>[13, 17, 22]</em>) crucially rely on messages being delivered in the next round (or within a known, bounded delay <span class="math">\\Delta</span>) to reach agreement. By contrast, in the sleepy model, consider an honest player that falls asleep for a long time (greater than <span class="math">\\Delta</span>) and then wakes up at some point in the future; it now receives all “old” messages with a significantly longer delay (breaking the synchrony assumption). In these protocols, such a player rejects all these old messages and would never reach agreement with the other players. It may be tempting to modify e.g., the protocol of <em>[13]</em> to have the players reach agreement on some transaction if some threshold (e.g., majority) of players have approved it—but the problem then becomes how to set the threshold, as the protocol is not aware of how many players are actually awake!</li>

      <li>The partially synchronous or asynchronous protocols (e.g., <em>[8, 12, 14, 30, 33, 39]</em>) a-priori seem to handle the above-mentioned issue with the synchronous protocol: we can simply view the sleeping player as receiving messages with a long delay (which is allowed in the asynchronous model of communication). Here, the problem instead is the fact that the number of awake players may be significantly smaller than the total number of players, and this means that no transactions will even be approved! A bit more concretely, these protocols roughly speaking approve transactions when a certain number of nodes have “acknowledged” them–for instance, in the classic BFT protocol of Castro and Liskov <em>[12]</em> (which is resilient in the standard model assuming a fraction <span class="math">\\frac{2}{3}</span> of all players are honest), players only approve a transaction when they have heard <span class="math">\\frac{2N}{3}</span> “confirmations” of some message where <span class="math">N</span> is the total number of parties. The problem here is that if, say, only half of the <span class="math">N</span> players are awake, the protocols stalls. And again, as for the case of synchronous protocols, it is not clear how to modify this threshold without knowledge of the number of awake players.</li>

    </ul>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Main Result</h3>

    <p class="text-gray-300">Our main result answers the above question in the affirmative. We present constructions of consensus protocols in the sleepy model, which are resilient assuming only that a majority of the awake players are honest. Our protocols relies on the existence of a “bare” Public-Key Infrastructure (PKI), the existence of Common Random String (CRS) and is proven secure in a simple</p>

    <p class="text-gray-300">version of the timing model of Dwork-Naor-Sahai <em>[34]</em> where all players are assumed to have weakly-synchronized clocks—all clocks are within <span class="math">\\Delta</span> of the “real time”, and all messages sent on the network are delivered within <span class="math">\\Delta</span> time.</p>

    <p class="text-gray-300">Our first protocol relies only on the existence of collision-resistant hash functions (and it is both practical and extremely simple to implement, compared to standard consensus protocols); it, however, only supports static corruptions and a static (fixed) schedule of which nodes are awake at what time step—we refer to this as a “static online schedule”.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Theorem 1 (Informal).</h6>

    <p class="text-gray-300">Assume the existence of families of a collision-resistant hash functions (CRH). Then, there exists a protocol for state-machine replication in the Bare PKI, CRS and in the timing model, which achieves consistency and liveness assuming a static online schedule and static corruptions, as long as at any point in the execution, a majority of the awake players are honest.</p>

    <p class="text-gray-300">Our next construction, enhances the first one by achieving also resilience with an arbitrary adversarial selection of which nodes are online at what time; this protocol also handles adaptive corruptions of players. This new protocol, however, does so at the price of assuming subexponentially secure collision-resistant hash functions and enhanced trapdoor permutations (the latter are needed for the constructions of non-interactive zero-knowledge proofs).</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Theorem 2 (Informal).</h6>

    <p class="text-gray-300">Assume the existence of families of sub-exponentially secure collision-resistant hash functions (CRH), and enhanced trapdoor permutations (TDP). Then, there exists a state-machine replication protocol in the Bare PKI, CRS and timing model, which achieves consistency and liveness under adaptive corruptions as long as at any point in the execution, a majority of the awake players are honest.</p>

    <p class="text-gray-300">Perhaps surprisingly, our protocols significantly departs from the standard approaches to distributed consensus, and we instead rely on key ideas behind Nakamoto’s beautiful blockchain protocol <em>[35]</em>, while dispensing the need for “proofs-of-work” <em>[15]</em>. As far as we know, our work demonstrates for the first time how the ideas behind Nakamoto’s protocol are instrumental in solving “standard” problems in distributed computing; we view this as our main conceptual contribution (and hopefully one that will be useful also in other contexts).</p>

    <p class="text-gray-300">Our proof will leverage and build on top of the formal analysis of the Nakamoto blockchain by Pass et al. <em>[36]</em>, but since we no longer rely on proofs-of-work, several new obstacles arise. Our main technical contribution, and the bulk of our analysis, is a new combinatorial analysis for dealing with these issues.</p>

    <p class="text-gray-300">We finally mention that ad-hoc solutions for achieving consensus using ideas behind the blockchain (but without proof-of-work) have been proposed <em>[25, 4, 2]</em>, none of these come with an analysis, and it is not clear to what extent they improve upon standard state-machine replication protocols (and more seriously, whether they even achieve the standard notion of consensus).</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">1.3 Technical Overview</h3>

    <p class="text-gray-300">We start by providing an overview of our consensus protocol which only handles a static online schedule and static corruptions; we next show how to enhance this protocol to achieve adaptive security.</p>

    <p class="text-gray-300">As mentioned, the design of our consensus protocols draws inspiration from Bitcoin’s proof-of-work based blockchain <em>[35]</em>—the so-called “Nakamoto consensus” protocol. This protocol is designed to work in a so-called “permissionless setting” where anyone can join the protocol execution. In contrast, we here study consensus in the classic “permissioned” model of computation</p>

    <p class="text-gray-300">with a fixed set <span class="math">[N]</span> of participating players; additionally, we are assuming that the players can register public keys (whose authenticity can be verified). Our central idea is to eliminate the use of proofs of work in this protocol. Towards this goal, let us start by providing a brief overview of Nakamoto’s beautiful blockchain protocol.</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Nakamoto consensus in a nutshell.</h4>

    <p class="text-gray-300">Roughly speaking, in Nakamoto’s blockchain, players “confirm” transactions by “mining blocks” through solving some computational puzzle that is a function of the transactions and the history so far. More precisely, each participant maintains its own local “chain” of “blocks” of transactions—called the <em>blockchain</em>. Each block consists of a triple <span class="math">(h_{-1},\\eta,\\texttt{txs})</span> where <span class="math">h_{-1}</span> is a pointer to the previous block in chain, <span class="math">\\texttt{txs}</span> denotes the transactions confirmed, and <span class="math">\\eta</span> is a “proof-of-work”— a solution to a computational puzzle that is derived from the pair <span class="math">(h_{-1},\\texttt{txs})</span>. The proof of work can be thought of as a “key-less digital signature” on the whole blockchain up until this point. At any point of time, nodes pick the <em>longest</em> valid chain they have seen so far and try to extend this longest chain.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Removing proofs-of-work.</h4>

    <p class="text-gray-300">Removing the proof-of-work from the Nakamoto blockchain while maintaining provable guarantees turns out to be subtle and the proof non-trivial. To remove the proof-of-work from Nakamoto’s protocol, we proceed as follows: instead of rate limiting through computational power, we impose limits on the type of puzzle solutions that are admissible for each player. More specifically, we redefine the puzzle solution to be of the form <span class="math">(\\mathcal{P},t)</span> where <span class="math">\\mathcal{P}</span> is the player’s identifier and <span class="math">t</span> is referred to as the block-time. An honest player will always embed the current time step as the block-time. The pair <span class="math">(\\mathcal{P},t)</span> is a “valid puzzle solution” if <span class="math">\\mathsf{H}(\\mathcal{P},t)&lt;D_{p}</span> where <span class="math">\\mathsf{H}</span> denotes a random oracle (for now, we provide a protocol in the random oracle model, but as we shall see shortly, the random oracle can be instantiated with a CRS and a pseudorandom function), and <span class="math">D_{p}</span> is a parameter such that the hash outcome is only smaller than <span class="math">D_{p}</span> with probability <span class="math">p</span>. If <span class="math">\\mathsf{H}(\\mathcal{P},t)&lt;D_{p}</span>, we say that <span class="math">\\mathcal{P}</span> is <em>elected leader at time <span class="math">t</span></em>. Note that several nodes may be elected leaders at the same time steps.</p>

    <p class="text-gray-300">Now, a node <span class="math">\\mathcal{P}</span> that is elected leader at time step <span class="math">t</span> can extend a chain with a block that includes the “solution” <span class="math">(\\mathcal{P},t)</span>, as well as the previous block’s hash <span class="math">h_{-1}</span> and the transactions <span class="math">\\texttt{txs}</span> to be confirmed. To verify that the block indeed came from <span class="math">\\mathcal{P}</span>, we require that the entire contents of the block, i.e., <span class="math">(h_{-1},\\texttt{txs},t,\\mathcal{P})</span>, are signed under <span class="math">\\mathcal{P}</span>’s public key. Similarly to Nakamoto’s protocol, nodes then choose the longest valid chain they have seen and extend this longest chain.</p>

    <p class="text-gray-300">Whereas honest players will only attempt to mine solutions of the form <span class="math">(\\mathcal{P},t)</span> where <span class="math">t</span> is the current time step, so far there is nothing that prevents the adversary from using incorrect block-times (e.g., time steps in past or the future). To prevent this from happening, we additionally impose the following restriction on the block-times in a valid chain:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A valid chain must have strictly increasing block-times;</li>

      <li>A valid chain cannot contain any block-times for the “future” (where “future” is adjusted to account for nodes’ clock offsets)</li>

    </ol>

    <p class="text-gray-300">There are now two important technical issues to resolve. First, it is important to ensure that the block-time rules do not hamper liveness. In other words, there should not be any way for an adversary to leverage the block-time mechanism to cause alert nodes to get stuck (e.g., by injecting false block-times).</p>

    <p class="text-gray-300">Second, although our block-time rules severely constrain the adversary, the adversary is still left with some wiggle room, and gets more advantage than alert nodes. Specifically, as mentioned earlier, the alert nodes only “mine” in the present (i.e., at the actual time-step), and moreover they</p>

    <p class="text-gray-300">never try to extend different chains of the same length. By contrast, the adversary can try to reuse past block-times in multiple chains. (In the proof of work setting, these types of attacks are not possible since there the hash function is applied also to the history of the chain, so “old” winning solutions cannot be reused over multiple chains; in contrast, in our protocol, the hash function is no longer applied to the history of the chain as this would give the attacker too many opportunities to become elected a leader by simply trying to add different transactions.)</p>

    <p class="text-gray-300">Our main technical result shows that this extra wiggle room in some sense is insignificant, and the adversary cannot leverage the wiggle room to break the protocol’s consistency guarantees. It turns out that dealing with this extra wiggle room becomes technically challenging, and none of the existing analysis for proof-of-work blockchains <em>[20, 36]</em> apply. More precisely, since we are using a blockchain-style protocol, a natural idea is to see whether we can directly borrow proof ideas from existing analyses of the Nakamoto blockchains <em>[20, 36]</em>. Existing works <em>[20, 36]</em> define three properties of blockchains—<em>chain growth</em> (roughly speaking that the chain grows at a certain speed), <em>chain quality</em> (that the adversary cannot control the content of the chain) and <em>consistency</em> (that honest players always agree on appropriate prefix of the chain)—which, as shown in earlier works <em>[36, 38]</em> imply the consistency and liveness properties needed for state-machine replication. Thus, by these results, it will suffice to demonstrate that our protocol satisfies these properties.</p>

    <p class="text-gray-300">The good news is that chain growth and chain quality properties can be proven in almost identically the same way as in earlier Nakamoto blockchain analysis <em>[36]</em>. The bad news is that the consistency proofs of prior works <em>[20, 36]</em> break down in our setting (as the attacker we consider is now more powerful as described above). The core of our proof is a new, and significantly more sophisticated analysis for dealing with this.</p>

    <h5 id="sec-11" class="text-base font-semibold mt-4">Removing the random oracle.</h5>

    <p class="text-gray-300">The above-described protocol relies on a random oracle. We note that we can in fact instantiate the random oracle with a PRF whose seed is selected in a common reference string (CRS). Roughly speaking, the reason for this is that in our proof we actually demonstrate the existence of some simple polynomial-time computable events—which only depend on the output of the hash function/PRF—that determine whether <em>any</em> (even unbounded) attacks can succeed. Our proof shows that with overwhelming probability over the choice of the random oracle, these events do not happen. By the security of the PRF, these events thus also happen only with negligible probability over the choice of the seed of the PRF.</p>

    <h5 id="sec-12" class="text-base font-semibold mt-4">Dealing with adaptive sleepiness and corruption.</h5>

    <p class="text-gray-300">We remark that the above-described protocol only works if the choice of when nodes are awake is made before PRF seed is selected. If not, honest players that are elected leaders could simply be put to sleep at the time step when they need to act. The problem is that it is preditcable when a node will become a leader. To overcome this problem, we take inspiration from a beautiful idea from Micali’s work <em>[31]</em>—we let each player pick its own <em>secret seed</em> to a PRF and publish a commitment to the seed as part of its public key; the player can then evaluate its own private PRF and also prove in zero-knowledge that the PRF was correctly evaluated (so everyone else can verify the correctness of outputs of the PRF);. Finally, each player now instantiates the random oracle with their own “private” PRF. Intuitively, this prevents the above-mentioned attack, since even if the adversary can adaptively select which honest nodes go to sleep, it has no idea which of them will become elected leaders before they broadcast their block.</p>

    <p class="text-gray-300">Formalizing this, however, is quite tricky (and we will need to modify the protocol). The problem is that if users pick their own seed for the PRF, then they may be able to select a “bad seed” which makes them the leader for a long period of time (there is nothing in the definition of a PRF that prevents this). To overcome this issue, we instead perform a “coin-tossing into the well” for the evaluation of random oracle: As before, the CRS specifies the seed <span class="math">k_{0}</span> of a PRF, and additionally, each user <span class="math">\\mathcal{P}</span> commits to the seed <span class="math">k[\\mathcal{P}]</span> of a PRF as part of their public key; node <span class="math">\\mathcal{P}</span> can then use the following function to determine if it is elected in time <span class="math">t</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{PRF}_{k_{0}}(\\mathcal{P},t)\\oplus\\mathsf{PRF}_{k[\\mathcal{P}]}(t)&lt;D_{p}</span></p>

    <p class="text-gray-300">where <span class="math">D_{p}</span> is a difficulty parameter selected such that any single node is elected with probability <span class="math">p</span> in a given time step. Further, <span class="math">\\mathcal{P}</span> additionally proves in zero-knowledge that it evaluated the above leader election function correctly in any block it produces.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">But, have we actually gained anything? A malicious user may still pick its seed <span class="math">k[\\mathcal{P}]</span> after seeing <span class="math">k_{0}</span> and this may potentially cancel out the effect of having <span class="math">\\mathsf{PRF}_{k_{0}}(\\cdot)</span> there in the first place! (For instance, the string <span class="math">\\mathsf{PRF}_{k_{0}}(\\mathcal{P},t)\\oplus\\mathsf{PRF}_{k[\\mathcal{P}]}(t)</span> clearly is not random any more.) We note, however, that if the user seed <span class="math">k[\\mathcal{P}]</span> is significantly shorter than the seed <span class="math">k_{0}</span>, and the cryptographic primitives are subexponentially secure, we can rely on the same method that we used to replace the random oracle with a PRF to argue that even if <span class="math">k[\\mathcal{P}]</span> is selected as a function of <span class="math">k_{0}</span>, this only increases the adversaries success probability by a factor <span class="math">2^{L}</span> for each possibly corrupted user where $L:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k[\\mathcal{P}]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is the bit-length of each user’s seed (and thus at most </span>2^{NL}<span class="math"> where </span>N<span class="math"> is the number of players) which still will not be enough to break security, if using a sufficiently big security parameter for the underlying protocol. We can finally use a similar style of a union bound to deal also with adaptive corruptions. (Note, however, that the loss in efficiency due to these complexity leveraging is non-trivial: the security parameter must now be greater than </span>N$; if we only require static corruption, and allow the CRS to be selected after all public keys are registered—which would be reasonable in practice—then, we can deal with adaptive sleepiness without this complexity leveraging and thus without the loss in efficiency).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">1.4 Applications in Permissioned and Permissionless Settings</h3>

    <p class="text-gray-300">As mentioned earlier, the variants of our protocols that deal with static corruption (and static or adaptive sleepiness) need not employ complexity leveraging, thus they can be implemented and adopted in real-world systems. We believe that our sleepy consensus protocol would be highly desirable in the following application scenarios and the alike.</p>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Permissioned setting: consortium blockchains.</h5>

    <p class="text-gray-300">At the present, there is a major push where blockchain companies are helping banks across the world build “consortium blockchains”. A consortium blockchain is where a consortium of banks each contribute some nodes and jointly run a consensus protocol, on top of which one can run distributed ledger and smart contract applications. Since enrollment is controlled, consortium blockchain falls in the classical “permissioned” model of consensus. Since the number of participating nodes may be large (e.g., typically involve hundreds of banks and possibly hundreds to thousands of nodes), many conjecture that classical protocols such as PBFT <em>[12]</em>, Byzantine Paxos <em>[27]</em>, and others where the total bandwidth scales quadratically w.r.t. the number of players might not be ideal in such settings. Our sleepy consensus protocol provides a compelling alternative in this setting — with sleepy consensus, tasks such as committee re-configuration can be achieved simply without special program paths like in classical protocols <em>[28]</em>, and each bank can also administer their nodes without much coordination with other banks.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Permissionless setting: proof-of-stake.</h4>

    <p class="text-gray-300">The subsequent work Snow White by Bentov, Pass, and Shi <em>[5]</em> adapted our protocol to a permissionless setting, and obtained one of the first provably secure proof-of-stake protocols. A proof-of-stake protocol is a permissionless consensus protocol to be run in an open, decentralized setting, where roughly speaking, each player has voting power proportional to their amount of stake in the cryptocurrency system (c.f. proof-of-work is where players have voting power proportional to their available computing power). Major cryptocurrencies such as Ethereum are eager to switch to a proof-of-stake model rather than proof-of-work to dispense with wasteful computation. To achieve proof-of-stake, the Snow White <em>[5]</em> extended the our sleepy consensus protocol by introducing a mechanism that relies the distribution of stake in the system to periodically rotate the consensus committee. Further Snow White dealt with other issues such as “nothing at stake” and posterior corruption that are well-known for proof-of-stake systems — note that these issues pertain only to proof-of-stake systems and are thus out of scope for our paper.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Comparison with independent work.</h4>

    <p class="text-gray-300">Although proof-of-stake is not a focus of our paper, we compare with a few independent works on proof-of-stake <em>[24, 31]</em> due to the superficial resemblance of some elements of their protocol in comparison with ours. Specificaly, the elegant work by Micali proposes to adapt classical style consensus protocols to realize a proof-of-stake protocol <em>[31]</em>; the concurrent and independent work by Kiayias et al. <em>[24]</em> proposes to use a combination of blockchain-style protocol and classical protocols such as coin toss to realize proof-of-stake. Both these works would fail in the sleepy model like any classical style protocol. In comparison, we use a blockchain style protocol in a pure manner which is essential to achieving consensus in the sleepy model. We also point out that even when we replace Kiayias’s coin toss protocol with an ideal random beacon, Kiayias’s proof would still fail in the sleepy model — and there does not seem to be a trivial way to reinterpret their proof such that it works in the sleepy model. Other proof-of-stake protocols <em>[2, 4, 25]</em> may also bear superficial resemblance but they do not have formal security models or provable guarantees, and these protocols may also miss elements that turned out essential in our proofs.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">1.5 Related Work</h3>

    <p class="text-gray-300">We briefly review the rich body of literature on consensus, particularly focusing on protocols that achieve security against Byzantine faults where corrupt nodes can deviate arbitrarily from the prescribed behavior.</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">Models for permissioned consensus.</h4>

    <p class="text-gray-300">Consensus in the permissioned setting <em>[3, 6, 7, 8, 12, 13, 14, 17, 18, 19, 22, 26, 27, 28, 29, 30, 39]</em> has been actively studied for the past three decades; and we can roughly classify these protocols based on their network synchrony, their cryptographic assumptions, and various other dimensions.</p>

    <p class="text-gray-300">Roughly speaking, two types of network models are typically considered, the synchronous model, where messages sent by honest nodes are guaranteed to be delivered to all other honest nodes in the next round; and partially synchronous or asynchronous protocols where message delays may be unbounded, and the protocol must nonetheless achieve consistency and liveness despite not knowing any a-priori upper bound on the networks’ delay. In terms of cryptographic assumptions, two main models have been of interest, the “unauthenticated Byzantine” model <em>[29]</em> where nodes are interconnected with authenticated channels; and the “authenticated Byzantine” model <em>[13]</em>, where</p>

    <p class="text-gray-300">a public-key infrastructure exists, such that nodes can sign messages and such digital signatures can then be transferred.</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">Permissioned, synchronous protocols.</h4>

    <p class="text-gray-300">Many feasibility and infeasibility results have been shown. Notably, Lamport et al. <em>[29]</em> show that it is impossible to achieve secure consensus in the presence of a <span class="math">\\frac{1}{3}</span> coalition in the “unauthenticated Byzantine” model (even when assuming synchrony). However, as Dolev and Strong show <em>[13]</em>, in a synchronous, authenticated Byzantine model, it is possible to design protocols that tolerate an arbitrary number of corruptions. It is also understood that no deterministic protocol fewer than <span class="math">f</span> rounds can tolerate <span class="math">f</span> faulty nodes <em>[13]</em> — however, if randomness is allowed, existing works have demonstrated expected constant round protocols that can tolerate up to a half corruptions <em>[17, 22]</em>.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">Permissioned, asynchronous protocols.</h4>

    <p class="text-gray-300">A well-known lower bound by Fischer, Lynch, and Paterson <em>[18]</em> shows if we restrict ourselves to protocols that are deterministic and where nodes do not read clocks, then consensus would be impossible even when only a single node may crash. Known feasibility results typically circumvent this well-known lower bound by making two types of assumptions: 1) randomness assumptions, where randomness may come from various sources, e.g., a common coin in the sky <em>[8, 19, 33]</em>, nodes’ local randomness <em>[3, 39]</em>, or randomness in network delivery <em>[7]</em>; and 2) clocks and timeouts, where nodes are allowed to read a clock and make actions based on the clock’s value. This approach has been taken by well-known protocols such as PBFT <em>[12]</em> and FaB <em>[30]</em> that use timeouts to re-elect leaders and thus ensure liveness even when the previous leader may be corrupt.</p>

    <p class="text-gray-300">Another well-known lower bound in the partially synchronous or asynchronous setting is due to Dwork et al. <em>[14]</em>, who showed that no protocol (even when allowing randomness or clocks) can achieve security in the presence of a <span class="math">\\frac{1}{3}</span> (or larger) corrupt coalition.</p>

    <p class="text-gray-300">Guerraoui et al. <em>[21]</em> propose a technique to dynamically partition nodes into clusters with nice properties, such that they can achieve consensus in a hostile environment where nodes join and leave dynamically. Their scheme also fails in the sleepy model, when the set of online honest nodes in adjacent time steps can be completely disjoint.</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">Permissionless consensus.</h4>

    <p class="text-gray-300">The permissionless model did not receive sufficient academic attention, perhaps partly due to the existence of strong lower bounds such as what Canetti et al. showed <em>[1]</em>. Roughly speaking, we understand that without making additional trust assumptions, not many interesting tasks can be achieved in the permissionless model where authenticated channels do not exist between nodes.</p>

    <p class="text-gray-300">Amazingly, cryptocurrencies such as Bitcoin and Ethereum have popularized the permissionless setting, and have demonstrated to us, that perhaps contrary to the common belief, highly interesting and non-trivial tasks can be attained in the permissionless setting. Underlying these cryptocurrency systems is a fundamentally new type of consensus protocol commonly referred to as proof-of-work blockchains <em>[35]</em>. Upon closer examination, these protocols circumvent known lower bounds such as those by Canetti et al. <em>[1]</em> and Lamport et al. <em>[29]</em> since they rely on a new trust assumption, namely, proofs-of-work, that was not considered in traditional models.</p>

    <p class="text-gray-300">Formal understanding of the permissionless model has just begun <em>[36, 37, 38, 20]</em>. Notably, Garay et al. <em>[20]</em> formally analyze the Nakamoto blockchain protocol in synchronous networks. Pass et al. <em>[36]</em> extend their analysis to asynchronous networks. More recently, Pass and Shi <em>[38]</em> show how to perform committee election using permissionless consensus and then bootstrap instances of</p>

    <p class="text-gray-300">permissioned consensus — in this way, they show how to asymptotically improve the response time for permissionless consensus.</p>

    <p class="text-gray-300">Finally, existing blockchains are known to suffer from a selfish mining attack <em>[16]</em>, where a coalition wielding <span class="math">\\frac{1}{3}</span> of the computation power can reap up to a half of the rewards. Pass and Shi <em>[37]</em> recently show how to design a fair blockchain (called Fruitchains) from any blockchain protocol with positive chain quality. Since our Sleepy consensus protocol is a blockchain-style protocol, we also inherit the same selfish mining attack. However, we can leverage the same techniques as Pass and Shi <em>[37]</em> to build a fair blockchain from Sleepy.</p>

    <h2 id="sec-22" class="text-2xl font-bold">2 Definitions</h2>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">2.1 Protocol Execution Model</h3>

    <p class="text-gray-300">We assume a standard Interactive Turing Machine (ITM) model <em>[9, 10, 11]</em> often adopted in the cryptography literature.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">(Weakly) synchronized clocks.</h4>

    <p class="text-gray-300">We assume that all nodes can access a clock that ticks over time. In the more general form, we allow nodes clocks to be offset by a bounded amount — commonly referred to as weakly synchronized clocks. We point out, that it is possible to apply a general transformation such that we can translate the clock offset into the network delay, and consequently in the formal model we may simply assume that nodes have synchronized clocks without loss of generality.</p>

    <p class="text-gray-300">Specifically, without loss of generality, assume nodes’ clocks are offset by at most <span class="math">\\Delta</span>, where <span class="math">\\Delta</span> is also the maximum network delay — if the two parameters are different, we can always take the maximum of the two incurring only constant loss. Below we show a transformation such that we can treat weakly synchronized clocks with maximum offset <span class="math">\\Delta</span> as setting with synchronized clocks but with network delay <span class="math">3\\Delta</span>. Imagine the following transformation: honest nodes always queue every message they receive for exactly <span class="math">\\Delta</span> time before “locally delivering” them. In other words, suppose a node <span class="math">i</span> receives a message from the network at local time <span class="math">t</span>, it will ignore this message for <span class="math">\\Delta</span> time, and only act upon the received message at local time <span class="math">t+\\Delta</span>. Now, if the sender of the message (say, node <span class="math">j</span>) is honest, then <span class="math">j</span> must have sent this message during its own local time <span class="math">[t-2\\Delta,t+\\Delta]</span>. This suggests that if an honest node <span class="math">j</span> sends a message at its local time <span class="math">t</span>, then any honest node <span class="math">i</span> must locally deliver the message during its local time frame <span class="math">[t,t+3\\Delta]</span>.</p>

    <p class="text-gray-300">Therefore henceforth in this paper we consider a model with a globally synchronized clocks (without losing the ability to express weak synchrony). Each clock tick is referred to as an atomic time step. Nodes can perform unbounded polynomial amount of computation in each atomic time step, as well as send and receive polynomially many messages.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Public-key infrastructure.</h4>

    <p class="text-gray-300">We assume the existence of a public-key infrastructure (PKI). Specifically, we adopt the same technical definition of a PKI as in the Universal Composition framework <em>[9]</em>. Specifically, we shall assume that the PKI is an ideal functionality <span class="math">\\mathcal{F}_{\\text{CA}}</span> (available only to the present protocol instance) that does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On receive register(upk) from <span class="math">\\mathcal{P}</span>: remember (upk, <span class="math">\\mathcal{P}</span>) and ignore any future message from <span class="math">\\mathcal{P}</span>.</li>

      <li>On receive lookup(<span class="math">\\mathcal{P}</span>): return the stored upk corresponding to <span class="math">\\mathcal{P}</span> or <span class="math">\\bot</span> if none is found.</li>

    </ul>

    <p class="text-gray-300">In this paper, we will consider a Bare PKI model, nodes are allowed register their public keys with <span class="math">\\mathcal{F}_{\\text{CA}}</span> any time during the exection — although typically, the honest protocol may specify</p>

    <p class="text-gray-300">that honest nodes register their public keys upfront at the beginning of the protocol execution (nonetheless, corrupt nodes may still register late).</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">Corruption model.</h4>

    <p class="text-gray-300">At the beginning of any time step <span class="math">t</span>, <span class="math">\\mathcal{Z}</span> can issue instructions of the form</p>

    <p class="text-gray-300"><span class="math">(\\texttt{corrupt},i)\\text{ or }(\\texttt{sleep},i,t_{0},t_{1})\\text{ where }t_{1}\\geq t_{0}\\geq t</span></p>

    <p class="text-gray-300"><span class="math">(\\texttt{corrupt},i)</span> causes node <span class="math">i</span> to become corrupt at the current time, whereas <span class="math">(\\texttt{sleep},i,t_{0},t_{1})</span> where <span class="math">t_{1}\\geq t_{0}\\geq t</span> will cause node <span class="math">i</span> to sleep during <span class="math">[t_{0},t_{1}]</span>. Note that since corrupt or sleep instructions must be issued at the very beginning of a time step, <span class="math">\\mathcal{Z}</span> cannot inspect an honest node’s message to be sent in the present time step, and then retroactively make the node sleep in this time step and erase its message.</p>

    <p class="text-gray-300">Following standard cryptographic modeling approaches <em>[9, 10, 11]</em>, at any time, the environment <span class="math">\\mathcal{Z}</span> can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted <span class="math">\\mathcal{A}</span>, and the adversary can see the internal states of corrupt nodes. For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition.</p>

    <p class="text-gray-300">To summarize, a node can be in one of the following states:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Honest.</em> An honest node can either be awake or asleep (or sleeping/sleepy). Henceforth we say that a node is alert if it is honest and awake. When we say that a node is asleep (or sleeping/sleepy), it means that the node is honest and asleep.</li>

      <li><em>Corrupt.</em> Without loss of generality, we assume that all corrupt nodes are awake.</li>

    </ol>

    <p class="text-gray-300">Henceforth, we say that corruption (or sleepiness resp.) is static if <span class="math">\\mathcal{Z}</span> must issue all corrupt (or sleep resp.) instructions before the protocol execution starts. We say that corruption (or sleepiness resp.) is adaptive if <span class="math">\\mathcal{Z}</span> can issue corrupt (or sleep resp.) instructions at any time during the protocol’s execution.</p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">Network delivery.</h4>

    <p class="text-gray-300">The adversary is responsible for delivering messages between nodes. We assume that the adversary <span class="math">\\mathcal{A}</span> can delay or reorder messages arbitrarily, as long as it respects the constraint that all messages sent from honest nodes must be received by all honest nodes in at most <span class="math">\\Delta</span> time steps.</p>

    <p class="text-gray-300">When a sleepy node wakes up, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is required to deliver an unordered set of messages containing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>all the pending messages that node <span class="math">i</span> would have received (but did not receive) had it not slept; and</li>

      <li>any polynomial number of adversarially inserted messages of <span class="math">(\\mathcal{A},\\mathcal{Z})</span>’s choice.</li>

    </ul>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">2.2 Compliant Exections</h3>

    <h4 id="sec-29" class="text-lg font-semibold mt-6">Randomized protocol execution.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We use the notation view<span class="math">\\leftarrow_{\\S}\\texttt{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda)^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda)</span> to denote a randomized execution of the protocol <span class="math">\\Pi</span> with security parameter <span class="math">\\lambda</span> and w.r.t. to an <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair. Specifically, view is a random variable containing an ordered sequence of all inputs, outputs, and messages sent and received by all Turing Machines during the protocol’s execution. We use the notation $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\texttt{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ to denote the number of time steps in the execution trace view.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Parameters of an execution.</p>

    <p class="text-gray-300">Globally, we will use <span class="math">N</span> to denote (an upper bound on) the total number of nodes, and <span class="math">N_{\\text{erupt}}</span> to denote (an upper bound on) the number of corrupt nodes, and <span class="math">\\Delta</span> to denote the maximum delay of messages between alert nodes. More formally, we can define a <span class="math">(N,N_{\\text{erupt}},\\Delta)</span>-respecting <span class="math">(\\mathcal{A},\\mathcal{Z})</span> as follows.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Definition 1 (<span class="math">(N,N_{\\text{erupt}},\\Delta)</span>-respecting <span class="math">(\\mathcal{A},\\mathcal{Z})</span>).</h6>

    <p class="text-gray-300">Henceforth, we say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(N,N_{\\text{erupt}},\\Delta)</span>-respecting w.r.t. protocol <span class="math">\\Pi</span>, iff the following holds: for any <span class="math">\\mathsf{view}\\in\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda)</span> with non-zero support,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(\\mathcal{A},\\mathcal{Z})</span> spawns a total of <span class="math">N</span> nodes in <span class="math">\\mathsf{view}</span> among which <span class="math">N_{\\text{erupt}}</span> are corrupt and the remaining are honest.</li>

      <li>If an alert node <span class="math">i</span> gossips a message at time <span class="math">t</span> in <span class="math">\\mathsf{view}</span>, then any node <span class="math">j</span> alert at time <span class="math">t^{\\prime}\\geq t+\\Delta</span> (including ones that wake up after <span class="math">t</span>) will have received the message.</li>

    </ul>

    <p class="text-gray-300">Henceforth when the context is clear, we often say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(N,N_{\\text{erupt}},\\Delta)</span>-respecting omitting stating explicitly the protocol <span class="math">\\Pi</span> of interest.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">Protocol-specific compliance rules.</h4>

    <p class="text-gray-300">A protocol <span class="math">\\Pi</span> may formally ensure certain security guarantees only in executions that respect certain compliance rules. Compliance rules can be regarded as constraints imposed on the <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair. Henceforth, we assume that besides specifying the instructions of honest parties, a protocol <span class="math">\\Pi</span> will additionally specify a set of compliance rules. We will use the notation a</p>

    <p class="text-gray-300"><span class="math">\\Pi\\text{-compliant }(\\mathcal{A},\\mathcal{Z})\\text{ pair}</span></p>

    <p class="text-gray-300">to denote an <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair that respects the compliance rules of protocol <span class="math">\\Pi</span> — we also say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant w.r.t. to the protocol <span class="math">\\Pi</span>.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Additional protocol conventions.</h4>

    <p class="text-gray-300">We adopt the universal composition framework <em>[9, 10, 11]</em> for formal modeling. Each protocol instance and functionality is associated with a session identifier <span class="math">sid</span>. We omit writing this session identifier explicitly without risk of ambiguity. We assume that ideal functionalities simply ignore all messages from parties not pertaining to the protocol instance of interest.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">2.3 Notational Conventions</h3>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">Negligible functions.</h4>

    <p class="text-gray-300">A function <span class="math">\\mathsf{negl}(\\cdot)</span> is said to be <em>negligible</em> if for every polynomial <span class="math">p(\\cdot)</span>, there exists some <span class="math">\\lambda_{0}</span> such that <span class="math">\\mathsf{negl}(\\lambda)\\leq\\frac{1}{p(\\lambda)}</span> for every <span class="math">\\lambda\\geq\\lambda_{0}</span>.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">Variable conventions.</h4>

    <p class="text-gray-300">In this paper, unless otherwise noted, all variables are by default functions of the security parameter <span class="math">\\lambda</span>. Whenever we say <span class="math">\\mathsf{var}_{0}&gt;\\mathsf{var}_{1}</span>, this means that <span class="math">\\mathsf{var}_{0}(\\lambda)&gt;\\mathsf{var}_{1}(\\lambda)</span> for every <span class="math">\\lambda\\in\\mathbb{N}</span>. Similarly, if we say that a variable <span class="math">\\mathsf{var}</span> is positive or non-negative, it means positive or non-negative for every input <span class="math">\\lambda</span>. Variables may also be functions of each other. How various variables are related will become obvious when we define derived variables and when we state parameters’ admissible rules for each protocol. Importantly, <em>whenever a parameter does not depend on <span class="math">\\lambda</span>, we shall explicitly state it by calling it a constant</em>.</p>

    <p class="text-gray-300">Unless otherwise noted, we assume that all variables are non-negative (functions of <span class="math">\\lambda</span>). Further, unless otherwise noted, all variables are <em>polynomially bounded</em> (or <em>inverse polynomially bounded</em> if smaller than <span class="math">1</span>) functions of <span class="math">\\lambda</span></p>

    <p class="text-gray-300">3 Problem Definitions</p>

    <p class="text-gray-300">In this section, we formally define a state machine replication protocol. State machine replication has been studied by the distributed systems literature for 30 years. In state machine replication, nodes agree on a linearly ordered log over time, in a way that satisfies consistency and liveness. In this section, we make explicit the formal abstraction for state machine replication. We then define an alternative blockchain abstraction first proposed by <em>Garay et al. [26]</em> and <em>Pass et al. [36]</em>. We point out that a blockchain abstraction implies the classical state machine replication abstraction as shown by <em>Pass and Shi [38]</em>. Therefore, while our final goal is to achieve classical state machine replication, we will construct a blockchain protocol as a stepping stone. Separately, this connection between modern blockchains and classical state machine replication is also interesting in its own right — this has been the common wisdom in the community, but we formalize this intuition.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">3.1 State Machine Replication</h3>

    <p class="text-gray-300">We will aim to realize a state machine replication abstraction, also frequently referred to as a “totally ordered log” or “linearity” by the distributed systems literature. In a replicated state machine, nodes agree on a LOG over time that is basically a list of transactions; and further, consistency and liveness are guaranteed.</p>

    <p class="text-gray-300">More formally, a state machine replication abstraction satisfies the following — here we adopt the same definitions as <em>Pass and Shi [38]</em>.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">Inputs and outputs.</h4>

    <p class="text-gray-300">The environment <span class="math">\\mathcal{Z}</span> may input a set of transactions <span class="math">\\mathsf{txs}</span> to each alert node in every time step. In each time step, an alert node outputs to the environment <span class="math">\\mathcal{Z}</span> a totally ordered LOG of transactions (possibly empty).</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">Security definitions.</h4>

    <p class="text-gray-300">Let <span class="math">T_{\\text{confirm}}</span> be a polynomial function in in <span class="math">\\lambda,N,N_{\\text{crupt}}</span>, and <span class="math">\\Delta</span>. We say that a state machine replication protocol <span class="math">\\Pi</span> is secure and has transaction conformation time <span class="math">T_{\\text{confirm}}</span> if for every <span class="math">\\Pi</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">(N,N_{\\text{crupt}},\\Delta)</span>-respecting, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for every sufficiently large <span class="math">\\lambda\\in\\mathbb{N}</span>, all but <span class="math">\\mathsf{negl}(\\lambda)</span> fraction of the views sampled from <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda)</span> satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Consistency: An execution trace view satisfies consistency if the following holds:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common prefix. Suppose that in view, an alert node <span class="math">i</span> outputs LOG to <span class="math">\\mathcal{Z}</span> at time <span class="math">t</span>, and an alert node <span class="math">j</span> (same or different) outputs <span class="math">\\mathsf{LOG^{\\prime}}</span> to <span class="math">\\mathcal{Z}</span> at time <span class="math">t^{\\prime}</span>, it holds that either <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span> or <span class="math">\\mathsf{LOG^{\\prime}}\\prec\\mathsf{LOG}</span>. Here the relation <span class="math">\\prec</span> means “is a prefix of”. By convention we assume that <span class="math">\\emptyset\\prec x</span> and <span class="math">x\\prec x</span> for any <span class="math">x</span>.</li>

      <li>Self-consistency. Suppose that in view, a node <span class="math">i</span> is alert at time <span class="math">t</span> and <span class="math">t^{\\prime}\\geq t</span>, and outputs <span class="math">\\mathsf{LOG}</span> and <span class="math">\\mathsf{LOG^{\\prime}}</span> at times <span class="math">t</span> and <span class="math">t^{\\prime}</span> respectively, it holds that <span class="math">\\mathsf{LOG}\\prec\\mathsf{LOG^{\\prime}}</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Liveness: An execution trace view satisfies <span class="math">T_{\\text{confirm}}</span>-liveness if the following holds: suppose that in view, the environment <span class="math">\\mathcal{Z}</span> inputs <span class="math">\\mathsf{txs}</span> to an alert node at time $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-T_{\\text{confirm}}<span class="math">. Then, for any node </span>i<span class="math"> alert at any time </span>t^{\\prime}\\geq t+T_{\\text{confirm}}<span class="math">, let </span>\\mathsf{LOG}<span class="math"> be the output of node </span>i<span class="math"> at time </span>t^{\\prime}<span class="math">, it holds that any </span>\\mathsf{tx}\\in\\mathsf{txs}<span class="math"> is included in </span>\\mathsf{LOG}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Intuitively, liveness says that transactions input to an alert node get included in their <span class="math">\\mathsf{LOG}</span>s within <span class="math">T_{\\text{confirm}}</span> time.</p>

    <p class="text-gray-300">3.2 Blockchain Formal Abstraction</p>

    <p class="text-gray-300">In this section, we define the formal abstraction and security properties of a blockchain. As Pass and Shi <em>[38]</em> recently show, a blockchain abstraction implies a classical state machine replication abstraction. Our definitions follow the approach of Pass et al. <em>[36]</em>, which in turn are based on earlier definitions from Garay et al. <em>[20]</em>, and Kiayias and Panagiotakos <em>[23]</em>.</p>

    <p class="text-gray-300">Since our model distinguishes between two types of honest nodes, alert and sleepy ones, we define chain growth, chain quality, and consistency for alert nodes. However, we point out the following: 1) if chain quality holds for alert nodes, it would also hold for sleepy nodes; 2) if consistency holds for alert nodes, then sleepy nodes’ chains should also satisfy common prefix and future self-consistency, although obviously sleepy nodes’ chains can be much shorter than alert ones.</p>

    <h4 id="sec-39" class="text-lg font-semibold mt-6">Inputs and outputs.</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We assume that in every time step, the environment <span class="math">\\mathcal{Z}</span> provides a possibly empty input to every alert node. Further, in every time step, an alert node sends an output to the environment <span class="math">\\mathcal{Z}</span>. Given a specific execution trace view with non-zero support where $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq t<span class="math">, let </span>i<span class="math"> denote a node that is alert at time </span>t<span class="math"> in view, we use the following notation to denote the output of node </span>i<span class="math"> to the environment </span>\\mathcal{Z}<span class="math"> at time step </span>t$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\text{output to }\\mathcal{Z}\\text{ by node }i\\text{ at time }t\\text{ in view: }\\quad\\textsf{chain}_{i}^{t}(\\textsf{view})</span></p>

    <p class="text-gray-300">where chain denotes an extracted ideal blockchain where each block contains an ordered list of transactions. Sleepy nodes stop outputting to the environment until they wake up again.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">3.2.1 Chain Growth</h4>

    <p class="text-gray-300">The first desideratum is that the chain grows proportionally with the number of time steps. Let,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\textsf{min-chain-increase}^{t,t^{\\prime}}(\\textsf{view})</span> $=\\min_{i,j}\\left(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}_{j}^{t+t^{\\prime}}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}_{i}^{t}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\right)$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">where we quantify over nodes <span class="math">i,j</span> such that <span class="math">i</span> is alert in time step <span class="math">t</span> and <span class="math">j</span> is alert in time <span class="math">t+t^{\\prime}</span> in view.</p>

    <p class="text-gray-300">Let <span class="math">\\textsf{growth}^{t_{0},t_{1}}(\\textsf{view},\\Delta,T)=1</span> iff the following two properties hold:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (consistent length) for all time steps $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta<span class="math">, </span>t+\\Delta\\leq t^{\\prime}\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, for every two players </span>i,j<span class="math"> such that in view </span>i<span class="math"> is alert at </span>t<span class="math"> and </span>j<span class="math"> is alert at </span>t^{\\prime}<span class="math">, we have that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}_{j}^{t^{\\prime}}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}_{i}^{t}(\\textsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\textsf{min-chain-increase}^{t,t_{0}}(\\textsf{view})\\geq T.</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (chain growth upper bound) for every time step $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-t_{1}$, we have</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\textsf{max-chain-increase}^{t,t_{1}}(\\textsf{view})\\leq T.</span></p>

    <p class="text-gray-300">In other words, <span class="math">\\textsf{growth}^{t_{0},t_{1}}</span> is a predicate which tests that a) alert parties have chains of roughly the same length, and b) during any <span class="math">t_{0}</span> time steps in the execution, all alert parties’ chains increase by at least <span class="math">T</span>, and c) during any <span class="math">t_{1}</span> time steps in the execution, alert parties’ chains increase by at most <span class="math">T</span></p>

    <h6 id="sec-41" class="text-base font-medium mt-4">Definition 2 (Chain growth).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, if for all <span class="math">\\Pi</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a negligible function <span class="math">\\mathsf{negl}</span> such that for every sufficiently large <span class="math">\\lambda\\in\\mathbb{N}</span>, <span class="math">T\\geq T_{0}</span>, <span class="math">t_{0}\\geq\\frac{T}{g_{0}}</span> and <span class="math">t_{1}\\leq\\frac{T}{g_{1}}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathsf{growth}^{t_{0},t_{1}}(\\mathsf{view},\\Delta,\\lambda)=1\\right]\\geq 1-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth w.r.t. failure probability <span class="math">\\mathsf{negl}(\\cdot)</span> if the above definition is satisfied when the negligible function is fixed to <span class="math">\\mathsf{negl}(\\cdot)</span> for any <span class="math">\\Pi</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h4 id="sec-42" class="text-lg font-semibold mt-6">3.2.2 Chain Quality</h4>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a chain, we say that a block <span class="math">B:=\\mathsf{chain}[j]</span> is honest w.r.t. <span class="math">\\mathsf{view}</span> and prefix <span class="math">\\mathsf{chain}[:j^{\\prime}]</span> where <span class="math">j^{\\prime}&lt;j</span> if in <span class="math">\\mathsf{view}</span> there exists some node <span class="math">i</span> alert at some time $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, such that 1) </span>\\mathsf{chain}[:j^{\\prime}]\\prec\\mathsf{chain}_{i}^{t}(\\mathsf{view})<span class="math">, and 2) </span>\\mathcal{Z}<span class="math"> input </span>B<span class="math"> to node </span>i<span class="math"> at time </span>t<span class="math">. Informally, for an honest node’s chain denoted chain, a block </span>B:=\\mathsf{chain}[j]<span class="math"> is honest w.r.t. a prefix </span>\\mathsf{chain}[:j^{\\prime}]<span class="math"> where </span>j^{\\prime}<j<span class="math">, if earlier there is some alert node who received </span>B<span class="math"> as input when its local chain contains the prefix </span>\\mathsf{chain}[:j^{\\prime}]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Let <span class="math">\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1</span> iff for every time <span class="math">t</span> and every player <span class="math">i</span> such that <span class="math">i</span> is alert at <span class="math">t</span> in <span class="math">\\mathsf{view}</span>, among any consecutive sequence of <span class="math">T</span> blocks <span class="math">\\mathsf{chain}[j+1..j+T]\\subseteq\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span>, the fraction of blocks that are honest w.r.t. <span class="math">\\mathsf{view}</span> and <span class="math">\\mathsf{chain}[:j]</span> is at least <span class="math">\\mu</span>.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Definition 3 (Chain quality).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> has <span class="math">(T_{0},\\mu)-</span>chain quality, if for all <span class="math">\\Pi</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every sufficiently large <span class="math">\\lambda\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathsf{quality}^{T}(\\mathsf{view},\\mu)=1\\right]\\geq 1-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">(T_{0},\\mu)</span>-chain quality w.r.t. failure probability <span class="math">\\mathsf{negl}(\\cdot)</span> if the above definition is satisfied when the negligible function is fixed to <span class="math">\\mathsf{negl}(\\cdot)</span> for any <span class="math">\\Pi</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">3.2.3 Consistency</h4>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes’ chains, except for roughly <span class="math">O(\\lambda)</span> number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node’s present chain, except for roughly <span class="math">O(\\lambda)</span> number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two alert nodes’ chains must be of similar length).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathsf{consistent}^{T}(\\mathsf{view})=1</span> iff for all times <span class="math">t\\leq t^{\\prime}</span>, and all players <span class="math">i,j</span> (potentially the same) such that <span class="math">i</span> is alert at <span class="math">t</span> and <span class="math">j</span> is alert at <span class="math">t^{\\prime}</span> in <span class="math">\\mathsf{view}</span>, we have that the prefixes of <span class="math">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</span> and <span class="math">\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})</span> consisting of the first $\\ell=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{chain}_{i}^{t}(\\mathsf{view})</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-T<span class="math"> records are identical — this also implies that the following must be true: </span>\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})>\\ell<span class="math">, i.e., </span>\\mathsf{chain}_{j}^{t^{\\prime}}(\\mathsf{view})<span class="math"> cannot be too much shorter than </span>\\mathsf{chain}_{i}^{t}(\\mathsf{view})<span class="math"> given that </span>t^{\\prime}\\geq t$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-45" class="text-base font-medium mt-4">Definition 4 (Consistency).</h6>

    <p class="text-gray-300">A blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">T_{0}</span>-consistency, if for all <span class="math">\\Pi</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some negligible function <span class="math">\\mathsf{negl}</span> such that for every sufficiently large <span class="math">\\lambda\\in\\mathbb{N}</span> and every <span class="math">T\\geq T_{0}</span> the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow\\mathsf{EXEC}^{\\Pi}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathsf{consistent}^{T}(\\mathsf{view})=1\\right]\\geq 1-\\mathsf{negl}(\\lambda)</span></p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol <span class="math">\\Pi</span> satisfies <span class="math">T_{0}</span>-consistency w.r.t. failure probability <span class="math">\\mathsf{negl}(\\cdot)</span> if the above definition is satisfied when the negligible function is fixed to <span class="math">\\mathsf{negl}(\\cdot)</span> for any <span class="math">\\Pi</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>.</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain <em>lengths</em> of any two alert players can differ by at most <span class="math">T</span> (except with negligible probability).</p>

    <h3 id="sec-46" class="text-xl font-semibold mt-8">3.3 Blockchain Implies State Machine Replication</h3>

    <p class="text-gray-300">We note that a blockchain protocol implies state machine replication, if alert nodes simply output the stablized part of their respective chains (i.e., <span class="math">\\mathsf{chain}[:-\\lambda]</span>) as their <span class="math">\\mathsf{LOG}</span>. This draws a tight connection between modern blockchains and classical consensus (i.e., state machine replication) protocols that have been studied by the distributed systems literature for 30 years. In this paper, to obtain a classical state machine replication protocol, we will instead construct a blockchain protocol as a stepping stone.</p>

    <h6 id="sec-47" class="text-base font-medium mt-4">Lemma 1 (Blockchains imply state machine replication <em>[38]</em>).</h6>

    <p class="text-gray-300">If there exists a blockchain protocol that satisfies <span class="math">(T_{G},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{Q},\\mu)</span>-chain quality, and <span class="math">T_{C}</span>-consistency, then there exists a secure state machine replication protocol with confirmation time <span class="math">T_{\\mathrm{confirm}}:=O(\\frac{T_{G}+T_{Q}+T_{C}}{g_{0}}+\\Delta)</span>.</p>

    <h6 id="sec-48" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">This lemma was proved in the hybrid consensus paper <em>[38]</em> for a different execution model, but the same proof effectively holds in our sleepy execution model. Specifically, let <span class="math">\\Pi_{\\mathrm{blockchain}}</span> be such a blockchain protocol. We can consider the following state machine replication protocol denoted <span class="math">\\Pi^{\\prime}</span>: whenever an alert node is about to output <span class="math">\\mathsf{chain}</span> to the environment <span class="math">\\mathcal{Z}</span> in <span class="math">\\Pi_{\\mathrm{blockchain}}</span>, it instead outputs <span class="math">\\mathsf{chain}[:-T_{C}]</span>. Further, suppose that <span class="math">\\Pi^{\\prime}</span>’s compliance rules are the same as <span class="math">\\Pi_{\\mathrm{blockchain}}</span>’s. Using the same argument as the hybrid consensus paper <em>[38]</em>, it is not hard to see that the resulting protocol is a secure state machine replication protocol with confirmation time <span class="math">O(\\frac{T_{G}+T_{Q}+T_{C}}{g_{0}}+\\Delta)</span>. ∎</p>

    <p class="text-gray-300">Therefore, henceforth in this paper, we will focus on realizing a blockchain protocol as a stepping stone towards realizing the standard notion of state machine replication.</p>

    <h2 id="sec-49" class="text-2xl font-bold">4 Sleepy Consensus under Static Corruptions</h2>

    <p class="text-gray-300">In this section, we will describe our basic Sleepy consensus protocol that is secure under static corruptions and static sleepiness. In other words, the adversary (and the environment) must declare upfront which nodes are corrupt as well as which nodes will go to sleep during which intervals. Furthermore, the adversary (and the environment) must respect the constraint that at any moment of time, roughly speaking the majority of online nodes are honest.</p>

    <p class="text-gray-300">For simplicity, we will first describe our scheme pretending that there is a random oracle <span class="math">\\mathsf{H}</span>; and then describe how to remove the random oracle assuming a common reference string. We assume that the random oracle <span class="math">\\mathsf{H}</span> instance is not shared with other protocols, and that the environment <span class="math">\\mathcal{Z}</span> is not allowed to query the random oracle <span class="math">\\mathsf{H}</span> directly, although it can query the oracle indirectly through <span class="math">\\mathcal{A}</span>.</p>

    <h3 id="sec-50" class="text-xl font-semibold mt-8">4.1 Valid Blocks and Blockchains</h3>

    <p class="text-gray-300">Before we describe our protocol, we first define the format of valid blocks and valid blockchains.</p>

    <p class="text-gray-300">We use the notation <em>chain</em> to denote a real-world blockchain. Our protocol relies on an extract function that extracts an ordered list of transactions from <em>chain</em> which alert nodes shall output to</p>

    <p class="text-gray-300">the environment <span class="math">\\mathcal{Z}</span> at each time step. A blockchain is obviously a chain of blocks. We now define a valid block and a valid blockchain.</p>

    <h4 id="sec-51" class="text-lg font-semibold mt-6">Valid blocks.</h4>

    <p class="text-gray-300">We say that a tuple</p>

    <p class="text-gray-300"><span class="math">B:=(h_{-1},\\texttt{txs},\\texttt{time},\\mathcal{P},\\sigma,h)</span></p>

    <p class="text-gray-300">is a valid block iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Sigma.\\texttt{ver}_{\\texttt{pk}}((\\texttt{h}_{-1},\\texttt{txs},\\texttt{time});\\sigma)=1</span> where <span class="math">\\texttt{pk}:=\\mathcal{F}_{\\text{CA}}.\\texttt{lookup}(\\mathcal{P})</span>; and</li>

      <li><span class="math">h=\\texttt{d}(h_{-1},\\texttt{txs},\\texttt{time},\\mathcal{P},\\sigma)</span>, where <span class="math">\\texttt{d}:\\{0,1\\}^{*}\\rightarrow\\{0,1\\}^{\\lambda}</span> is a collision-resistant hash function — technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore d is a single function.</li>

    </ol>

    <h4 id="sec-52" class="text-lg font-semibold mt-6">Valid blockchain.</h4>

    <p class="text-gray-300">Let <span class="math">\\texttt{eligible}^{t}(\\mathcal{P})</span> be a function that determines whether a party <span class="math">\\mathcal{P}</span> is an eligible leader for time step <span class="math">t</span> (see Figure 1 for its definition). Let <em>chain</em> denote an ordered chain of real-world blocks, we say that <em>chain</em> is a valid blockchain w.r.t. eligible and time <span class="math">t</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>chain</em><span class="math">[0]=genesis=(\\bot,\\bot,\\texttt{time}=0,\\bot,\\bot,h=\\vec{0})</span>, commonly referred to as the genesis block;</li>

      <li><em>chain</em><span class="math">[-1].\\texttt{time}\\leq t</span>; and</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- for all <span class="math">i\\in[1..\\ell]</span> where $\\ell:=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, the following holds:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>chain</em><span class="math">[i]</span> is a valid block;</li>

      <li><em>chain</em><span class="math">[i].h_{-1}=chain[i-1].h</span>;</li>

      <li><em>chain</em><span class="math">[i].\\texttt{time}&gt;chain[i-1].\\texttt{time}</span>, i.e., block-times are strictly increasing; and</li>

      <li>let <span class="math">t:=chain[i].\\texttt{time}</span>, <span class="math">\\mathcal{P}:=chain[i].\\mathcal{P}</span>, it holds that <span class="math">\\texttt{eligible}^{t}(\\mathcal{P})=1</span>.</li>

    </ol>

    <h3 id="sec-53" class="text-xl font-semibold mt-8">4.2 The Basic Sleepy Consensus Protocol</h3>

    <p class="text-gray-300">We present our basic Sleepy consensus protocol in Figure 1. The protocol takes a parameter <span class="math">p</span> as input, where <span class="math">p</span> corresponds to the probability each node is elected leader in a single time step. All nodes that just spawned will invoke the init entry point. During initialization, a node generates a signature key pair and registers the public key with the public-key infrastructure <span class="math">\\mathcal{F}_{\\text{CA}}</span>.</p>

    <p class="text-gray-300">Now, our basic Sleepy protocol proceeds very much like a proof-of-work blockchain, except that instead of solving computational puzzles, in our protocol a node can extend the chain at time <span class="math">t</span> iff it is elected leader at time <span class="math">t</span>. To extend the chain with a block, a leader of time <span class="math">t</span> simply signs a tuple containing the previous block’s hash, the node’s own party identifier, the current time <span class="math">t</span>, as well as a set of transactions to be confirmed. Leader election can be achieved through a public hash function H that is modeled as a random oracle.</p>

    <h4 id="sec-54" class="text-lg font-semibold mt-6">Removing the random oracle.</h4>

    <p class="text-gray-300">Although we described our scheme assuming a random oracle H, it is not hard to observe that we can replace the random oracle with a common reference string crs and a pseudo-random function PRF. Specifically, the common reference string <span class="math">k_{0}\\leftarrow_{\\S}\\{0,1\\}^{\\lambda}</span> is randomly generated after <span class="math">\\mathcal{Z}</span> spawns all corrupt nodes and commits to when each honest node shall sleep. Then, we can simply replace calls to H(<span class="math">\\cdot</span>) with with <span class="math">\\texttt{PRF}_{k_{0}}(\\cdot)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathrm{sleepy}}(p)</span> On input init() from  <span class="math">\\mathcal{Z}</span> : let  <span class="math">(\\mathsf{pk},\\mathsf{sk}):=\\Sigma.\\mathsf{gen}()</span> , register pk with  <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span> , let chain := genesis On receive chain':</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assert  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and chain&#x27; is valid w.r.t. eligible and the current time  </span>t$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">chain := chain' and gossip chain Every time step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>receive input transactions(txs) from  <span class="math">\\mathcal{Z}</span></li>

      <li>let  <span class="math">t</span>  be the current time, if  <span class="math">\\text{eligible}^t(\\mathcal{P})</span>  where  <span class="math">\\mathcal{P}</span>  is the current node's party identifier:</li>

    </ul>

    <p class="text-gray-300">let  <span class="math">\\sigma := \\Sigma.\\text{sign}(\\mathsf{sk}, chain[-1].h, \\mathsf{txs}, t)</span> ,  <span class="math">h&#x27; := \\mathsf{d}(chain[-1].h, \\mathsf{txs}, t, \\mathcal{P}, \\sigma)</span> ,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">let  <span class="math">B := (chain[-1].h, \\mathsf{txs}, t, \\mathcal{P}, \\sigma, h&#x27;)</span> , let chain := chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B and gossip chain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>output extract(chain) to  <span class="math">\\mathcal{Z}</span>  where extract is the function outputs an ordered list containing the txs extracted from each block in chain</li>

    </ul>

    <p class="text-gray-300">Subroutine eligible <span class="math">^t(\\mathcal{P})</span> : return 1 if  <span class="math">\\mathsf{H}(\\mathcal{P}, t) &amp;lt; D_p</span>  and  <span class="math">\\mathcal{P}</span>  is a valid party of this protocol; else return 0</p>

    <p class="text-gray-300">Figure 1: The sleepy consensus protocol. The difficulty parameter  <span class="math">D_{p}</span>  is defined such that the hash outcome is less than  <span class="math">D_{p}</span>  with probability  <span class="math">p</span> . For simplicity, here we describe the scheme with a random oracle  <span class="math">\\mathsf{H}</span>  — however as we explain in this section,  <span class="math">\\mathsf{H}</span>  can be removed and replaced with a pseudorandom function and a common reference string.</p>

    <p class="text-gray-300">Remark on how to interpret the protocol for weakly synchronized clocks. As mentioned earlier, in practice, we would typically adopt the protocol assuming nodes have weakly synchronized clocks instead of perfect synchronized clocks. Section 2.1 described a general protocol transformation that allows us to treat weakly synchronized clocks as synchronized clocks in formal reasoning (but adopting a larger network delay). Specifically, when deployed in practice assuming weakly synchronized clocks with up to  <span class="math">\\Delta</span>  clock offset, alert nodes would actually queue each received message for  <span class="math">\\Delta</span>  time before locally delivering the message. This ensures that alert nodes will not reject other alert nodes' chains mistakenly thinking that the block-time is in the future (due to clock offsets).</p>

    <p class="text-gray-300">Remark on foreknowledge of  <span class="math">\\Delta</span> . Note that our protocol  <span class="math">\\Pi_{\\mathrm{sleepy}}(p)</span>  is parametrized with a parameter  <span class="math">p</span> , that is, the probability that any node is elected leader in any time step. Looking ahead, due to our compliance rules explained later in Section 4.3, it is sufficient for the protocol to have foreknowledge of both  <span class="math">N</span>  and  <span class="math">\\Delta</span> , then to attain a targeted resilience (i.e., the minimum ratio of alert nodes over corrupt ones in any time step), the protocol can choose an appropriate value for  <span class="math">p</span>  based on the "resilience" compliance rules (see Section 4.3).</p>

    <p class="text-gray-300">Later in Section 8, we will justify why foreknowledge of  <span class="math">\\Delta</span>  is necessary: we prove a lower bound showing that any protocol that does not have foreknowledge of  <span class="math">\\Delta</span>  cannot achieve state machine replication even when all nodes are honest.</p>

    <p class="text-gray-300">4.3 Compliant Executions</p>

    <p class="text-gray-300">Our protocol can be proven secure as long as a set of constraints are expected, such as the number of alert vs. corrupt nodes. Below we formally define the complete set of rules that we expect <span class="math">(\\mathcal{A},\\mathcal{Z})</span> to respect to prove security.</p>

    <h5 id="sec-55" class="text-base font-semibold mt-4">Compliant executions.</h5>

    <p class="text-gray-300">We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{sleepy}}(p)</span>-compliant if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Static corruption and sleepiness. <span class="math">\\mathcal{Z}</span> must issue all corrupt and sleep instructions prior to the start of the protocol execution. We assume that <span class="math">\\mathcal{A}</span> cannot query the random oracle H prior to protocol start.</li>

      <li>Resilience. There are parameters <span class="math">(N,N_{\\text{crupt}},\\Delta)</span> such that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">(N,N_{\\text{crupt}},\\Delta)</span>-respecting w.r.t. <span class="math">\\Pi_{\\text{sleepy}}(p)</span>, and moreover, the following conditions are respected:</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- There is a positive consant <span class="math">\\phi</span>, such that for any <span class="math">\\textsf{view}\\in\\textsf{EXEC}^{\\Pi_{\\text{sleepy}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span> with non-zero support, for every $t\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\frac{\\textsf{alert}^{t}(\\textsf{view})}{N_{\\text{crupt}}}\\geq\\frac{1+\\phi}{1-2pN\\Delta}</span></p>

    <p class="text-gray-300">where <span class="math">\\textsf{alert}^{t}(\\textsf{view})</span> denotes the number of nodes that are alert at time <span class="math">t</span> in view.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Further, there is some constant <span class="math">0&lt;c&lt;1</span> such that <span class="math">2pN\\Delta&lt;1-c</span>.</li>

    </ul>

    <p class="text-gray-300">Informally, we require that at any point of time, there are more alert nodes than corrupt ones by a constant margin.</p>

    <h5 id="sec-56" class="text-base font-semibold mt-4">Useful notations.</h5>

    <p class="text-gray-300">We define additional notations that will become useful later.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">N_{\\text{alert}}:=N_{\\text{crupt}}\\cdot\\frac{1+\\phi}{1-2pN\\Delta}</span> be a lower bound on the number of alert nodes in every time step;</li>

      <li>Let <span class="math">\\alpha:=pN_{\\text{alert}}</span> be a lower bound on the expected number of alert nodes elected leader in any single time step;</li>

      <li>Let <span class="math">\\beta:=pN_{\\text{crupt}}\\geq 1-(1-p)^{N_{\\text{crupt}}}</span> be the expected number of corrupt nodes elected leader in any single time step; notice that <span class="math">\\beta</span> is also an upper bound on the probability that some corrupt node is elected leader in one time step.</li>

    </ol>

    <h3 id="sec-57" class="text-xl font-semibold mt-8">4.4 Theorem Statement</h3>

    <p class="text-gray-300">We now state our theorem for static corruption.</p>

    <h6 id="sec-58" class="text-base font-medium mt-4">Theorem 3 (Security of <span class="math">\\Pi_{\\text{sleepy}}</span> under static corruption).</h6>

    <p class="text-gray-300">Assume the existence of a common reference string (CRS), a bare public-key infrastructure (PKI), and that the signature scheme <span class="math">\\Sigma</span> is secure against any p.p.t. adversary. Then, for any constants <span class="math">\\epsilon,\\epsilon_{0}&gt;0</span>, any <span class="math">0&lt;p&lt;1</span>, any <span class="math">T_{0}\\geq\\epsilon_{0}\\lambda</span>, <span class="math">\\Pi_{\\text{sleepy}}(p)</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}^{2}</span> consistency with <span class="math">\\exp(-\\Omega(\\lambda))</span> failure probability for the following set of parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter <span class="math">g_{0}=(1-\\epsilon)(1-2pN\\Delta)\\alpha</span>;</li>

      <li>chain growth upper bound parameter <span class="math">g_{1}=(1+\\epsilon)Np</span>; and</li>

      <li>chain quality parameter <span class="math">\\mu=1-\\frac{1-\\epsilon}{1+\\phi}</span>.</li>

    </ul>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Figure 2: Ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span></p>

    <p class="text-gray-300">where  <span class="math">N, \\Delta, \\alpha</span>  and  <span class="math">\\phi</span>  are parameters that can be determined by  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  as well as  <span class="math">p</span>  as mentioned earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be presented in Section 5.</p>

    <p class="text-gray-300">Corollary 1 (Statically secure state machine replication in the sleepy model.). Assume the existence of a common reference string (CRS), a bare public-key infrastructure (PKI), and that the signature scheme  <span class="math">\\Sigma</span>  is secure against any p.p.t. adversary. For any constant  <span class="math">\\epsilon &amp;gt; 0</span> , there exists a protocol that achieves state machine replication assuming static corruptions and static sleepiness, and that  <span class="math">\\frac{1}{2} + \\epsilon</span>  fraction of awake nodes are honest in any time step.</p>

    <p class="text-gray-300">Proof. Straightforward from Theorem 3 and Lemma 1.  <span class="math">\\square</span></p>

    <p class="text-gray-300">In this section, we present the proofs for the basic sleepy consensus protocol presented in Section 6. We assume static corruption and static sleepiness and the random oracle model. Later in our paper, we will describe how to remove the random oracle, and further extend our protocol and proofs to adaptive sleepiness and adaptive corruptions.</p>

    <p class="text-gray-300">We start by analyzing a very simple ideal protocol denoted  <span class="math">\\Pi_{\\mathrm{ideal}}</span> , where nodes interact with an ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  that keeps track of all valid chains at any moment of time. Later in Section 5.8, we will show that the real-world protocol  <span class="math">\\Pi_{\\mathrm{sleepy}}</span>  securely emulates the ideal-world protocol.</p>

    <p class="text-gray-300">Ideal protocol. We first define a simplified protocol  <span class="math">\\Pi_{\\mathrm{ideal}}</span>  parametrized with an ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  — see Figures 2 and 3.  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  flips random coins to decide whether a node is the elected</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Figure 3: Ideal protocol  <span class="math">\\Pi_{\\mathrm{ideal}}</span></p>

    <p class="text-gray-300">leader for every time step, and an adversary  <span class="math">\\mathcal{A}</span>  can query this information (i.e., whether any node is a leader in any time step) through the leader query interface. Finally, alert and corrupt nodes can call  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> . extend to extend known chains with new blocks —  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  will then check if the caller is a leader for the time step to decide if the extend operation is allowed.  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  keeps track of all valid chains, such that alert nodes will call  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> . verify to decide if any chain they receive is valid. Alert nodes always store the longest valid chains they have received, and try to extend it.</p>

    <p class="text-gray-300">Observe that  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  has two entry points named extend — one of them is the honest version and the other is the corrupt version. In this ideal protocol, alert nodes always mine in the present, i.e., they always call the honest version of extend that uses the current time  <span class="math">t</span> . In this case, if the honest node succeeds in mining a new chain denoted chain,  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  records the current time  <span class="math">t</span>  as chain's block-time by setting  <span class="math">\\mathcal{F}_{\\mathrm{tree}}(\\mathrm{view}).\\mathrm{time}(\\mathrm{chain}) = t</span> . On the other hand, corrupt nodes are allowed to call a malicious version of extend and supply a past time step  <span class="math">t&#x27;</span> . When receiving an input from the adversarial version of extend,  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  verifies that the new block's purported time  <span class="math">t&#x27;</span>  respects the strictly increasing rule. If the corrupt node succeeds in mining a new block, then  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  records the purported time  <span class="math">t&#x27;</span>  as the chain's block-time.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Notations. Given some view sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{ideal}}}(\\mathcal{A},\\mathcal{Z},\\lambda)</span> , we say that a chain  <span class="math">\\in \\mathcal{F}_{\\mathrm{tree}}(\\mathrm{view}).\\mathrm{tree}</span>  has an block-time of  <span class="math">t</span>  if  <span class="math">\\mathcal{F}_{\\mathrm{tree}}(\\mathrm{view}).\\mathrm{time}(\\mathrm{chain}) = t</span> . We say that a node  <span class="math">\\mathcal{P}</span>  (alert or corrupt) mines a chain' = chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B in time  <span class="math">t</span>  if  <span class="math">\\mathcal{P}</span>  called  <span class="math">\\mathcal{F}_{\\mathrm{tree}}.\\mathrm{extend}(\\mathrm{chain},\\mathsf{B})</span>  or  <span class="math">\\mathcal{F}_{\\mathrm{tree}}.\\mathrm{extend}(\\mathrm{chain},\\mathsf{B}, - )</span>  at time  <span class="math">t</span> , and the call returned "succ". Note that if an alert node mines a chain at time  <span class="math">t</span> , then the chain's block-time must be  <span class="math">t</span>  as well. By contrast, if a corrupt node mines a chain at time  <span class="math">t</span> , the chain's block-time may not be truthful — it may be smaller than  <span class="math">t</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We say that  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\mathrm{ideal}}(p)</span> -compliant iff the pair is  <span class="math">\\Pi_{\\mathrm{sleepy}}(p)</span> -compliant. Since the protocols' compliance rules are the same, we sometimes just write compliant for short.</p>

    <p class="text-gray-300">Theorem 4 (Security of  <span class="math">\\Pi_{\\mathrm{ideal}}</span> ). For any constant  <span class="math">\\epsilon_0, \\epsilon &amp;gt; 0</span> , any  <span class="math">T_0 \\geq \\epsilon_0 \\lambda</span> ,  <span class="math">\\Pi_{\\mathrm{sleepy}}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span> -consistency against any  <span class="math">\\Pi_{\\mathrm{ideal}}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , with  <span class="math">\\exp(-\\Omega(\\lambda))</span>  failure probability and the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 - \\epsilon)(1 - 2pN\\Delta)\\alpha</span> ;</li>

      <li>chain growth upper bound parameter  <span class="math">g_{1} = (1 + \\epsilon)Np</span> ; and</li>

      <li>chain quality parameter  <span class="math">\\mu = 1 - \\frac{1 - \\epsilon}{1 + \\phi}</span> .</li>

    </ul>

    <p class="text-gray-300">where <span class="math">N,\\Delta,\\alpha</span> and <span class="math">\\phi</span> are parameters that can be determined by <span class="math">(\\mathcal{A},\\mathcal{Z})</span> as well as <span class="math">p</span> as mentioned earlier.</p>

    <p class="text-gray-300">In the remainder of this section, we will now prove the above Theorem 4. We first explain a high-level roadmap and why, despite the similarity of our protocol in comparison with the Nakamoto proof-of-work blockchain, our proofs are nonetheless non-trivial and not implied by earlier formal analyses of the Nakamoto blockchain <em>[20, 36]</em>.</p>

    <h5 id="sec-61" class="text-base font-semibold mt-4">Intuitions and differences from Nakamoto’s ideal protocol.</h5>

    <p class="text-gray-300">The key difference between our ideal protocol and Nakamoto’s ideal protocol as described by Pass et al. <em>[36]</em> is the following. In Nakamoto’s ideal protocol, if the adversary succeeds in extending a chain with a block, he cannot reuse this block and concatenate it with other chains. Here in our ideal protocol, if a corrupt node is elected leader in some time slot, he can reuse the elected slot in many possible chains. He can also instruct <span class="math">\\mathcal{F}_{\\text{tree}}</span> to extend chains with times in the past, as long as the chain’s block-times are strictly increasing.</p>

    <p class="text-gray-300">Although our <span class="math">\\mathcal{F}_{\\text{tree}}</span> allows the adversary to claim potentially false block-times, we can rely on the following block-time invariants in our proofs: 1) honest blocks always have faithful block-times; and 2) any chain in <span class="math">\\mathcal{F}_{\\text{tree}}</span> must have strictly increasing block-times. Having observed these, we show that Pass et al.’s chain growth and chain quality proofs <em>[36]</em> can be adapted for our scenario.</p>

    <p class="text-gray-300">Unfortunately, the main challenge is how to prove consistency. As mentioned earlier, our adversary is much more powerful than the adversary for the Nakamoto blockchain and can launch a much wider range of attacks where he reuses the time slots during which he is elected. In Sections 5.5 and 5.6, we present new techniques for analyzing the induced stochastic process.</p>

    <h3 id="sec-62" class="text-xl font-semibold mt-8">5.2 Convergence Opportunities</h3>

    <p class="text-gray-300">We now define a useful pattern called convergence opportunities, which we shall later use in both our chain growth lower bound proof as well as consistency proof. Intuitively, a convergence opportunity is a <span class="math">\\Delta</span>-period of silence in which no alert node is elected leader, followed by a time step in which a single alert node is elected leader, followed by another <span class="math">\\Delta</span>-period of silence in which no alert node is elected leader. We formalize this notion below.</p>

    <h5 id="sec-63" class="text-base font-semibold mt-4">Convergence opportunity.</h5>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a view, suppose $T\\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\Delta<span class="math">, we say that </span>[T-\\Delta,T+\\Delta]$ is a convergence opportunity iff</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any <span class="math">t\\in[\\max(0,T-\\Delta),T)</span>, no node alert at time <span class="math">t</span> is elected leader;</li>

      <li>A single node alert at <span class="math">T</span> is elected leader at time <span class="math">T</span>;</li>

      <li>For any <span class="math">t\\in(T,T+\\Delta]</span>, no node alert at time <span class="math">t</span> is elected leader.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">T</span> denote the time in which a single alert node is elected leader during a convergence opportunity. For convenience, we often use <span class="math">T</span> to refer to the convergence opportunity. We say that a convergence opportunity <span class="math">T</span> is contained within a window <span class="math">[t^{\\prime}:t]</span> if <span class="math">T\\in[t^{\\prime}:t]</span>.</p>

    <p class="text-gray-300">Henceforth, we use the notation <span class="math">\\mathbf{C}(\\textsf{view})[t^{\\prime}:t]</span> to denote the number of convergence opportunities contained within the window <span class="math">[t^{\\prime}:t]</span> in view.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Many convergence opportunities.</p>

    <p class="text-gray-300">We now show that convergence opportunities happen sufficiently often.</p>

    <h6 id="sec-64" class="text-base font-medium mt-4">Lemma 2 (Number of convergence opportunities for any fixed window).</h6>

    <p class="text-gray-300">For any <span class="math">t_{0},t_{1}\\geq 0</span> such that <span class="math">t:=t_{1}-t_{0}&gt;0</span>, any <span class="math">\\Pi_{ideal}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, for any positive constant <span class="math">\\eta</span>, there exists a constant <span class="math">\\eta^{\\prime}</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\text{view}\\leftarrow{}_{\\mathbb{\\S}}EXEC^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathbf{C}(\\text{view})[t_{0}:t_{1}]\\leq(1-\\eta)(1-2pN\\Delta)\\alpha t\\Big{]}&lt;\\exp(-\\eta^{\\prime}\\alpha t)</span></p>

    <h6 id="sec-65" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider some view, and imagine that <span class="math">\\mathcal{F}_{\\text{tree}}</span> flips alert^{r}(view) coins for alert nodes (henceforth referred to as alert coins for short) in some time step <span class="math">r</span>, where alert^{r}(view) denotes the number of alert nodes in time step <span class="math">r</span> in view. Henceforth, we imagine all these alert coins are sequentialized.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{X}</span> denote the total number of heads in all the alert coins during <span class="math">[t_{0},t_{1}]</span>. Due to the Chernoff bound, it is not hard to see that for any <span class="math">\\epsilon&gt;0</span>, it holds that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathbf{X}&lt;(1-\\epsilon)\\cdot\\alpha t]\\leq\\exp(-\\Omega(\\alpha t))</span></p>

    <p class="text-gray-300">Henceforth let <span class="math">L:=(1-\\epsilon)\\cdot\\alpha t</span> for a sufficiently small constant <span class="math">\\epsilon</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{Y}_{i}=1</span> iff after the <span class="math">i</span>-th heads in the alert coin sequence during <span class="math">[t_{0},t_{1}]</span>, there exists a heads in the next <span class="math">N_{\\text{alert}}\\Delta</span> coin flips. Notice that all of the <span class="math">\\mathbf{Y}_{i}</span>’s are independent — to see this, another way to think of <span class="math">\\mathbf{Y}_{i}</span> is that <span class="math">\\mathbf{Y}_{i}=0</span> iff the <span class="math">i</span>-th coin flip and the <span class="math">(i+1)</span>-th coin flip are at least <span class="math">N_{\\text{alert}}\\Delta</span> apart from each other.</li>

    </ul>

    <p class="text-gray-300">Let <span class="math">\\mathbf{Y}:=\\sum_{i=1}^{L}\\mathbf{Y}_{i}</span>. We have that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{E}[\\mathbf{Y}]\\leq(1-(1-p)^{N_{\\text{alert}}\\Delta})\\cdot L\\leq pN_{\\text{alert}}\\Delta\\cdot L=\\alpha\\Delta L</span></p>

    <p class="text-gray-300">By Chernoff bound, it holds that for any <span class="math">\\epsilon_{0}&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathbf{Y}&gt;\\alpha\\Delta L+\\epsilon_{0}L]\\leq\\exp(-\\Omega(L))=\\exp(-\\Omega(\\alpha t))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\mathbf{Z}_{i}=1</span> iff before the <span class="math">i</span>-th heads in the alert coin sequence during <span class="math">[t_{0},t_{1}]</span>, there exists a heads in the previous <span class="math">N_{\\text{alert}}\\Delta</span> coin flips. Similar as before, all of the <span class="math">\\mathbf{Z}_{i}</span>’s are independent. Let <span class="math">\\mathbf{Z}:=\\sum_{i=1}^{L}\\mathbf{Z}_{i}</span>. We have that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{E}[\\mathbf{Z}]\\leq(1-(1-p)^{N_{\\text{alert}}\\Delta})\\cdot L\\leq pN_{\\text{alert}}\\Delta\\cdot L=\\alpha\\Delta L</span></p>

    <p class="text-gray-300">By Chernoff bound, it holds that for any <span class="math">\\epsilon_{0}&gt;0</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathbf{Z}&gt;\\alpha\\Delta L+\\epsilon_{0}L]\\leq\\exp(-\\Omega(L))=\\exp(-\\Omega(\\alpha t))</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Observe that for any view,</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathbf{C}(\\text{view})[t_{0}:t_{1}]\\geq\\mathbf{X}(\\text{view})-\\mathbf{Y}(\\text{view})-\\mathbf{Z}(\\text{view})</span></p>

    <p class="text-gray-300">Recall that our compliance rule implies that <span class="math">\\alpha\\Delta\\leq pN\\Delta&lt;\\frac{1}{2}</span>. For any view where the aforementioned relevant bad events do not happen, we have that for any <span class="math">\\eta&gt;0</span>, there exist sufficiently small positive constants <span class="math">\\epsilon_{0}</span> and <span class="math">\\epsilon</span> such that the following holds:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{X}-\\mathbf{Y}-\\mathbf{Z}</span> <span class="math">\\geq</span> <span class="math">(1-2\\alpha\\Delta-2\\epsilon_{0})L=(1-2\\alpha\\Delta-2\\epsilon_{0})\\cdot(1-\\epsilon)\\cdot\\alpha t</span> <span class="math">\\geq</span> <span class="math">(1-\\eta)(1-2\\alpha\\Delta)\\cdot\\alpha t</span> <span class="math">\\geq</span> <span class="math">(1-\\eta)(1-2pN\\Delta)\\cdot\\alpha t</span></p>

    <p class="text-gray-300">The proof concludes by observing that there are at most <span class="math">\\exp(-\\Omega(\\alpha t))</span> fraction of bad views that we could have ignored in the above.</p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">The above lemma was to bound the number of convergence opportunities for any fixed window. By taking a union bound, we can conclude that except for a negligible fraction of bad views, in all good views, it must hold that any sufficiently long window has many convergence opportunities. This is formally stated below.</p>

    <h6 id="sec-66" class="text-base font-medium mt-4">Corollary 2 (Many convergence opportunities everywhere).</h6>

    <p class="text-gray-300">For any positive constant <span class="math">\\epsilon_{0}</span>, any <span class="math">t\\geq\\frac{\\epsilon_{0}\\lambda}{\\alpha}</span>, for any <span class="math">\\Pi_{ideal}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, any positive constant <span class="math">\\eta</span>, there exists a positive constant <span class="math">\\eta^{\\prime}</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta^{\\prime}\\lambda)</span> fraction of views sampled from <span class="math">\\textsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, the following property holds:</p>

    <p class="text-gray-300"><span class="math">\\text{For any }t_{0},\\;\\mathbf{C}(\\textsf{view})[t_{0}:t_{0}+t]&gt;(1-\\eta)(1-2pN\\Delta)\\alpha t</span></p>

    <h6 id="sec-67" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows in a straightforward manner from Lemma 2 by taking a union bound over all windows of length <span class="math">t</span>. ∎</p>

    <h3 id="sec-68" class="text-xl font-semibold mt-8">5.3 Chain Growth Lower Bound</h3>

    <p class="text-gray-300">To prove chain growth lower bound, we observe that for any view, whenever there is a convergence opportunity, the shortest honest chain must grow by at least <span class="math">1</span> (see Fact 1). Since earlier, we proved that except with negligible probability over the choice of view, there are many convergence opportunities, it naturally follows that honest chains must grow not too slowly. We now formalize this intuition.</p>

    <h6 id="sec-69" class="text-base font-medium mt-4">Fact 1.</h6>

    <p class="text-gray-300">For any view, any <span class="math">t_{0}</span>, any <span class="math">t_{1}\\geq t_{0}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}(\\textsf{view})[t_{0}:t_{1}-\\Delta]\\leq\\textsf{min\\_chain\\_increase}(\\textsf{view})[t_{0}:t_{1}]</span></p>

    <p class="text-gray-300">where <span class="math">\\textsf{min\\_chain\\_increase}(\\textsf{view})[t_{0}:t_{1}]</span> is the length of the shortest honest chain at the beginning of time step <span class="math">t_{1}</span> minus the length of the longest honest chain at the beginning of time step <span class="math">t_{0}</span> in view.</p>

    <h6 id="sec-70" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By simple induction: given any view, any <span class="math">t_{0}</span>, suppose that the fact holds for any <span class="math">t_{1}\\leq t^{<em>}</span>. We now show that it holds for time <span class="math">t_{1}=t^{</em>}+1</span> as well. If time <span class="math">t^{<em>}-\\Delta+1</span> does not correspond to a convergence opportunity, the induction step is trivial. Otherwise, if time <span class="math">t^{</em>}-\\Delta+1</span> corresponds to a convergence opportunity, by definition of convergence opportunity, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathbf{C}(\\textsf{view})[t_{0}:t^{<em>}+1-\\Delta]=\\mathbf{C}(\\textsf{view})[t_{0}:t^{</em>}-\\Delta]+1=\\mathbf{C}(\\textsf{view})[t_{0}:t^{*}+1-2\\Delta]+1</span></p>

    <p class="text-gray-300">By induction hypothesis, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_{0}:t^{<em>}+1-\\Delta]+1\\geq\\mathbf{C}(\\mathsf{view})[t_{0}:t^{</em>}+1-2\\Delta]+1=\\mathbf{C}(\\mathsf{view})[t_{0}:t^{*}+1-\\Delta]</span> (1)</p>

    <p class="text-gray-300">Additionally, we have that at the end of time step <span class="math">t^{<em>}+1-\\Delta</span>, there is an honest chain whose length is at least <span class="math">\\mathsf{min\\_alert\\_len}^{t^{</em>}+1-\\Delta}(\\mathsf{view})+1</span>, where <span class="math">\\mathsf{min\\_alert\\_len}^{t^{<em>}+1-\\Delta}(\\mathsf{view})</span> denotes the length of the shortest alert chain at the beginning time <span class="math">t^{</em>}+1-\\Delta</span>. Since network delay is bounded by <span class="math">\\Delta</span>, at the beginning of time time <span class="math">t^{<em>}+1</span>, every alert node’s chain must be at least <span class="math">\\mathsf{min\\_alert\\_len}^{t^{</em>}+1-\\Delta}(\\mathsf{view})+1</span> blocks long. In other words, we have that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_{0}:t^{<em>}+1]\\geq\\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_{0}:t^{</em>}+1-\\Delta]+1</span> (2)</p>

    <p class="text-gray-300">The remainder of the induction step follows directly from Equations 1 and 2. ∎</p>

    <h6 id="sec-71" class="text-base font-medium mt-4">Lemma 3 (Chain growth lower bound).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, for any positive constants <span class="math">\\epsilon_{0},\\epsilon</span> and any <span class="math">t\\geq\\frac{\\epsilon_{0}\\lambda}{\\alpha}</span>, there exists a positive constant <span class="math">\\eta</span>, such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\alpha t)</span> fraction of the <span class="math">\\mathsf{views}</span> sampled from <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\text{For any }t_{0},\\;\\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_{0}:t_{0}+t]\\geq(1-\\epsilon)(1-2pN\\Delta)\\alpha t-1</span></p>

    <h6 id="sec-72" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Ignore the <span class="math">\\exp(-\\Omega(\\lambda))</span> fraction of <span class="math">\\mathsf{views}</span> where bad events pertaining to Corollary 2 take place. For every remaining good <span class="math">\\mathsf{view}</span>, due to Fact 1 and Corollary 2, it holds that for every positive constant <span class="math">\\epsilon</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_{0}:t_{0}+t]&gt;(1-\\epsilon)(1-2pN\\Delta)\\alpha(t-\\Delta)</span> <span class="math">=(1-\\epsilon)(1-2pN\\Delta)\\alpha t-(1-\\epsilon)(1-2pN\\Delta)\\alpha\\Delta\\geq(1-\\epsilon)(1-2pN\\Delta)\\alpha t-1</span></p>

    <p class="text-gray-300">where the last inequality is due to the fact <span class="math">\\alpha\\Delta&lt;2pN\\Delta&lt;1</span> which stems from the compliance rules. ∎</p>

    <h3 id="sec-73" class="text-xl font-semibold mt-8">5.4 Chain Quality</h3>

    <p class="text-gray-300">Intuitively, we will prove chain quality by comparing how often corrupt nodes are elected leaders with the honest chain growth lower bound. If corrupt nodes are elected leaders less often than minimum honest chain growth, we can thus conclude that there cannot be too many corrupt blocks in an honest node’s chain. We formalize this intuition below.</p>

    <h4 id="sec-74" class="text-lg font-semibold mt-6">Upper bound on adversarial time slots.</h4>

    <p class="text-gray-300">Given a <span class="math">\\mathsf{view}</span>, let <span class="math">\\mathbf{A}(\\mathsf{view})[t_{0}:t_{1}]</span> denote the number of time steps in which at least one corrupt node is elected leader during the window <span class="math">[t_{0}:t_{1}]</span>. Let <span class="math">\\mathbf{A}^{t}(\\mathsf{view})</span> denote the maximum number of time steps in which at least one corrupt node is elected leader in any <span class="math">t</span>-sized window in <span class="math">\\mathsf{view}</span>.</p>

    <h6 id="sec-75" class="text-base font-medium mt-4">Fact 2 (Upper bound on adversarial time slots for any fixed window).</h6>

    <p class="text-gray-300">For any <span class="math">t_{0}</span> and <span class="math">t_{1}</span> such that <span class="math">t:=t_{1}-t_{0}\\geq 0</span>, for any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, for any constant <span class="math">0&lt;\\epsilon&lt;1</span> and any <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\mathbb{S}}\\mathsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathbf{A}(\\mathsf{view})[t_{0}:t_{1}]&gt;(1+\\epsilon)\\beta t\\right]\\leq\\exp(-\\frac{\\epsilon^{2}\\beta t}{3})</span></p>

    <h6 id="sec-76" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">From a straightforward application of the Chernoff bound. ∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Fact 3 (Upper bound on adversarial time slots everywhere). For any <span class="math">\\Pi_{\\mathrm{ideal}}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, any positive constant <span class="math">\\epsilon_0</span>, any <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\beta}</span>, for any constant <span class="math">0 &amp;lt; \\epsilon &amp;lt; 1</span>, there exists a positive constant <span class="math">\\eta</span> such that for any <span class="math">\\lambda \\in \\mathbb{N}</span>,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow_{\\S} \\text{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda): \\mathbf{A}^t(\\text{view}) &amp;gt; (1 + \\epsilon) \\beta t \\right] \\leq \\exp(-\\eta \\lambda)</span></div>

    <p class="text-gray-300">Proof. Straightforward by Fact 2 and taking union bound over all possible windows of length <span class="math">t</span> in view.</p>

    <p class="text-gray-300">Lemma 4 (Chain quality). For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>, any positive constant <span class="math">\\epsilon_0, \\epsilon</span>, any <span class="math">T \\geq \\epsilon_0 \\lambda</span>, there exists a positive constant <span class="math">\\eta</span> such that for all <span class="math">\\lambda \\in \\mathbb{N}</span>, the following holds for <span class="math">\\mu := 1 - \\frac{1 + \\epsilon}{1 + \\phi}</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\text{view} \\leftarrow \\text{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda): \\text{quality}^T(\\text{view}, \\mu) = 1 \\right] \\geq 1 - \\exp(-\\eta \\lambda)</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Let <span class="math">r</span> be any time step, let <span class="math">i</span> be any node honest at $r \\leq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{view}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. Consider an arbitrary honest chain </span>\\text{chain} := \\text{chain}_i^r(\\text{view})<span class="math">, and an arbitrary sequence of </span>T<span class="math"> blocks </span>\\text{chain}[j + 1..j + T] \\subset \\text{chain}_i^r<span class="math">, such that </span>\\text{chain}[j]<span class="math"> is not adversarial (either an honest block or genesis); and </span>\\text{chain}[j + T + 1]<span class="math"> is not adversarial either (either an honest block or </span>\\text{chain}[j + T]<span class="math"> is end of </span>\\text{chain}_i^r$). Note that if a sequence of blocks is not sandwiched between two honest blocks (including genesis or end of chain), we can always expand the sequence to the left and right to find a maximal sequence sandwiched by honest blocks (including genesis or end of chain). Such an expansion will only worsen chain quality.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">For an honest block, its block-time must be faithful, i.e., corresponding to the time step in which the block was mined (recall that the block-time of genesis is 0). Consequently, by definition of <span class="math">\\Pi_{\\mathrm{ideal}}</span> and <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>, the block-times of all blocks in <span class="math">\\text{chain}[j + 1..j + T]</span> must be bounded in between <span class="math">r&#x27;</span> and <span class="math">r&#x27; + t</span>, where <span class="math">r&#x27;</span> denotes the time step in which the honest (or genesis) block <span class="math">\\text{chain}[j]</span> was mined, and <span class="math">r&#x27; + t</span> denotes the time step in which <span class="math">\\text{chain}[j + T + 1]</span> is mined (or let <span class="math">r&#x27; + t := r</span> if <span class="math">\\text{chain}[j + T]</span> is end of <span class="math">\\text{chain}_i^r</span>).</p>

    <p class="text-gray-300">We ignore any views where bad events related to chain growth lower bound or adversarial time slot upper bound take place. The fraction of views ignored is upper bounded by <span class="math">\\exp(-\\Omega(T)) \\cdot \\text{poly}(\\lambda)</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now, due to chain growth lower bound, for any positive constant <span class="math">\\epsilon</span>, we have that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">t &amp;lt; \\frac{T}{(1 - \\epsilon)(1 - 2 p N \\Delta) \\alpha}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Due to adversarial time slot upper bound (Fact 3), for any positive constant <span class="math">\\epsilon&#x27;&#x27; &amp;gt; 0</span>, there exists a sufficiently small positive constants <span class="math">\\epsilon&#x27;</span> (which depends on <span class="math">\\epsilon</span>, <span class="math">\\epsilon&#x27;&#x27;</span>, and <span class="math">\\phi</span>), such that</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{A}[r&#x27;: r&#x27; + t] \\leq \\mathbf{A}[r&#x27;: r&#x27; + \\frac{T}{(1 - \\epsilon)(1 - 2 p N \\Delta) \\alpha}] \\\\ \\leq \\frac{(1 + \\epsilon&#x27;) \\beta T}{(1 - \\epsilon)(1 - 2 p N \\Delta) \\alpha} \\\\ \\leq \\frac{(1 + \\epsilon&#x27;)(1 - 2 p N \\Delta) T}{(1 - \\epsilon)(1 - 2 p N \\Delta)(1 + \\phi)} \\\\ \\leq \\frac{(1 + \\epsilon&#x27;&#x27;) T}{1 + \\phi} \\end{array}</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Therefore, the fraction of honest blocks in this length <span class="math">T</span> sequence is lower bounded by</li>

    </ul>

    <p class="text-gray-300"><span class="math">1-\\frac{1+\\epsilon^{\\prime\\prime}}{1+\\phi}</span></p>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-77" class="text-xl font-semibold mt-8">5.5 Consistency: Proof Intuition</h3>

    <p class="text-gray-300">Since this is the most non-trivial part of our proof and where we significantly depart from earlier blockchain proofs <em>[20, 36]</em>, we will first explain the intuition before presenting the formal proof.</p>

    <h5 id="sec-78" class="text-base font-semibold mt-4">Review: consistency proof for the Nakamoto blockchain.</h5>

    <p class="text-gray-300">We first review how Pass et al. <em>[36]</em> proved consistency for the Nakamoto blockchain, and explain why their proof fails in our setting. This will help to clarify the challenges of the proof. To prove consistency, Pass et al. rely on the notion of a convergence opportunity. Recall that we formally defined a convergence opportunity in Section 5.2 (Pass et al.’s notion is almost identical except that in their model alert nodes and honest nodes mean the same): a convergence opportunity is a period of time in which 1) there is a <span class="math">\\Delta</span>-long period of silence in which no honest node mines a block; and 2) followed by a time step in which a single honest node mines a block; and 3) followed by yet another <span class="math">\\Delta</span>-long period of silence in which no honest node mines a block. Whenever there is a convergence period, and suppose that at the beginning of the convergence period the maximum chain length of any honest node is <span class="math">\\ell</span>. Then, it is not hard to see that there can be at most one honest block (if any) in position <span class="math">\\ell+1</span> in any honest node’s chain — since after the first period of silence, all honest nodes’ chain must be of length at least <span class="math">\\ell</span>; and after the second period of silence, all honest nodes’ chain length must be at least <span class="math">\\ell+1</span>. Therefore, after the convergence period, no honest node will ever mine at position <span class="math">\\ell+1</span> again. However, recall that within the convergence period, only a single honest node ever mines a block.</p>

    <p class="text-gray-300">Now, Pass et al. <em>[36]</em> observes that for the adversary to cause divergence at some time <span class="math">s</span> or earlier, for every convergence opportunity after time <span class="math">s</span>, the adversary must mine a chain of length <span class="math">\\ell+1</span> where <span class="math">\\ell</span> is the maximum chain length of any honest node at the beginning of the convergence period. This means that from time</p>

    <p class="text-gray-300"><span class="math">(s-[\\text{small block withholding window}])</span></p>

    <p class="text-gray-300">onward, the adversary must have mined more blocks than the number of convergence opportunities since <span class="math">s</span>.</p>

    <p class="text-gray-300">Pass et al. <em>[36]</em> then goes to show that if <span class="math">s</span> is sufficiently long ago, this cannot happen — in other words, there has to be more convergence opportunities than adversarially mined blocks in any sufficiently long time window, even when adjusted for block withholding attacks. Proving an upper bound on adversarially mined blocks in any window is relatively easy, therefore most of their proof focuses on lower bounding the number of convergence opportunities within any time window (our Lemma 2 earlier provided a simplified proof adapted to our sleepy model).</p>

    <h5 id="sec-79" class="text-base font-semibold mt-4">Why their proof breaks in our setting.</h5>

    <p class="text-gray-300">The consistency proof by Pass et al. <em>[36]</em> crucially relies on the following fact: when an adversary successfully extends a chain with a block, he cannot simply transfer this block at no cost to extend any other chain. For this reason, to mine a chain of length <span class="math">\\ell+1</span> for each different <span class="math">\\ell</span> will require separate computational effort, and no effort can ever be reused.</p>

    <p class="text-gray-300">Unfortunately, this crucial observation no longer holds in our protocol when proof-of-work is removed. If a corrupt node is elected in a certain time step <span class="math">t</span>, he can now reuse this earned time slot to extend multiple chains, <em>possibly at different lengths</em>. Recall that Pass et al’s consistency proof relies on arguing that the adversary cannot have mined chains of many different lengths. Unfortunately, in our case, such an argument will not work. In particular, how many times the adversary is elected leader (the direct analogy of how many times an adversary mines a block in a proof-of-work blockchain) does not translate to how many chain lengths the adversary can attack (by composing an adversarial chain of that length). It now appears that a fundamentally new proof strategy is necessary.</p>

    <h5 id="sec-80" class="text-base font-semibold mt-4">Roadmap of our proof.</h5>

    <p class="text-gray-300">Our proof strategy is the following. We will define a good event called a (strong) pivot point. Roughly speaking, a (strong) pivot is a point of time <span class="math">t</span>, such that if one draws any window of time <span class="math">[t_{0},t_{1}]</span> that contains <span class="math">t</span>, the number of adversarial time slots in that window, if non-zero, must be strictly smaller than the number of convergence opportunities in the same window. We will show the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>A pivot forces convergence:</em> for any view where certain negligible-probability bad events do not happen: if there is such a pivot point <span class="math">t</span> in view, then the adversary cannot have caused divergence prior to <span class="math">t</span>.</li>

      <li><em>Pivots happen frequently:</em> for all but negligible fraction of the views, pivot points happen frequently in time — particularly,</li>

    </ul>

    <p class="text-gray-300">in any sufficiently long time window there must exist such a pivot point. This then implies that if one removes sufficiently many trailing blocks from an alert node’s chain (recall that by chain growth, block numbers and time roughly translate to each other), the remaining prefix must be consistent with any other alert node.</p>

    <h6 id="sec-81" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">For clarity, we first present a somewhat loose version of the consistency proof, where we need to chop of <span class="math">\\mathsf{poly}(\\lambda)</span> trailing blocks for consistency. Later in Appendix A, we present a tighter version of the analysis, where we only need to chop off <span class="math">\\lambda</span> trailing blocks to obtain <span class="math">\\exp(-\\Omega(\\lambda))</span> security failure.</p>

    <h3 id="sec-82" class="text-xl font-semibold mt-8">5.6 Consistency: the Proof</h3>

    <h4 id="sec-83" class="text-lg font-semibold mt-6">5.6.1 Definition of Pivots and Strong Pivots</h4>

    <p class="text-gray-300">We first define two good events called a <em>pivot</em> and a <em>strong pivot</em> respectively. As mentioned, a <em>strong pivot</em> is a point of time in view such that in any window that contains the time <span class="math">t</span>, the number of adversarial slots, if not zero, must be strictly smaller than the number of convergence opportunities in the same window. A pivot is a slightly weakened version of a strong pivot, requiring that the above condition hold for any window containing <span class="math">t</span> that is not too long.</p>

    <h6 id="sec-84" class="text-base font-medium mt-4">Definition 5 (Strong pivot).</h6>

    <p class="text-gray-300">Given a view, a time step <span class="math">t</span> is said to be a strong pivot in view, if for any <span class="math">t_{0}\\leq t\\leq t_{1}</span>, it holds that <span class="math">\\mathbf{C}(\\textsf{view})[t_{0}:t_{1}]&gt;\\mathbf{A}(\\textsf{view})[t_{0}:t_{1}]</span> or <span class="math">\\mathbf{A}(\\textsf{view})[t_{0}:t_{1}]=0</span>.</p>

    <h6 id="sec-85" class="text-base font-medium mt-4">Definition 6 (Pivot).</h6>

    <p class="text-gray-300">Given a view, a time step <span class="math">t</span> is said to be a <span class="math">w</span>-pivot in view, if for any <span class="math">t_{0}\\leq t\\leq t_{1}</span> such that <span class="math">t_{1}-t_{0}\\leq w</span>, it holds that <span class="math">\\mathbf{C}(\\textsf{view})[t_{0}:t_{1}]&gt;\\mathbf{A}(\\textsf{view})[t_{0}:t_{1}]</span> or <span class="math">\\mathbf{A}(\\textsf{view})[t_{0}:t_{1}]=0</span>.</p>

    <p class="text-gray-300">####</p>

    <p class="text-gray-300">5.6.2 Strong Pivots Force Convergence</p>

    <p class="text-gray-300">We first define what it means for two valid chains to diverge at some time <span class="math">t</span>, this is defined in the most natural manner as below:</p>

    <h6 id="sec-86" class="text-base font-medium mt-4">Definition 7 (Divergence).</h6>

    <p class="text-gray-300">Given any two chains <span class="math">\\mathsf{chain}_{0},\\mathsf{chain}_{1}\\in\\mathcal{F}_{\\text{tree}}.\\mathsf{tree}</span>, we say that they diverge at time <span class="math">t</span> if their longest common prefix has an block-time before <span class="math">t</span>.</p>

    <p class="text-gray-300">We now prove that a strong pivot will force convergence, i.e., divergence cannot happen before a strong pivot in any view.</p>

    <h6 id="sec-87" class="text-base font-medium mt-4">Lemma 5 (Divergence cannot happen before a strong pivot).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a positive constant <span class="math">\\eta</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\lambda)</span> fraction of the views sampled from <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, the following must hold: Let <span class="math">i</span> be alert at time any <span class="math">r</span> and <span class="math">j</span> be alert at any <span class="math">r^{\\prime}\\geq r</span> in view; let <span class="math">t&lt;r-\\frac{\\lambda}{\\beta}</span> be a strong pivot in view. Then, <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> cannot diverge at <span class="math">t</span> in view.</p>

    <h6 id="sec-88" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose that <span class="math">T</span> is a convergence opportunity in view, and that a single alert node that mines a block at length <span class="math">\\ell</span> at time <span class="math">T</span> in view. Henceforth, we say that such a length <span class="math">\\ell</span> corresponds to a convergence opportunity in view. We first present a simple fact about convergence opportunities that follows directly from the definition of convergence opportunities.</p>

    <h6 id="sec-89" class="text-base font-medium mt-4">Fact 4 (Uniqueness of an honest block in any convergence opportunity).</h6>

    <p class="text-gray-300">Given any view, let <span class="math">i</span> be alert at time <span class="math">r</span> and <span class="math">j</span> be alert at <span class="math">r^{\\prime}\\geq r</span> in view. If the length <span class="math">\\ell</span> corresponds to a convergence opportunity in view, and <span class="math">\\mathsf{chain}_{i}^{r}[\\ell]</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}[\\ell]</span> are both honest blocks, then it follows that <span class="math">\\mathsf{chain}_{i}^{r}[\\ell]=\\mathsf{chain}_{j}^{r^{\\prime}}[\\ell]</span>.</p>

    <p class="text-gray-300">Henceforth, we ignore the <span class="math">\\exp(-\\Omega(\\lambda))</span> fraction of bad views where bad events related to Corollary 2 take place. For the remaining good views, since <span class="math">t&lt;r-\\frac{\\lambda}{\\beta}</span>, it must hold that <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> both contain a position (i.e., length) corresponding to a convergence opportunity whose block-time is after <span class="math">t</span>.</p>

    <p class="text-gray-300">Now, for both <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span>, we look to the left and right of <span class="math">t</span>, and identify the first honest block that corresponds to a convergence opportunity on both sides. In other words, in both <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span>, we identify</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The last honest block that corresponds to a convergence opportunity and moreover, whose block-time is <span class="math">\\leq t</span>. Let <span class="math">\\mathsf{B}_{i}</span> and <span class="math">\\mathsf{B}_{j}</span> denote the blocks found in this manner for <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> respectively.</li>

      <li>The first honest block that corresponds to a convergence opportunity and moreover, whose block-time is <span class="math">\\geq t</span>. Let <span class="math">\\widehat{\\mathsf{B}}_{i}</span> and <span class="math">\\widehat{\\mathsf{B}}_{j}</span> denote the blocks found in this manner for <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> respectively.</li>

    </ol>

    <p class="text-gray-300">Now there are two cases:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 1: <span class="math">t</span> is a convergence opportunity. In this case, the adversary cannot be leader at time <span class="math">t</span> since otherwise it violates the definition of <span class="math">t</span> being a strong pivot. Further, if <span class="math">t</span> is a convergence opportunity, there can only be a unique honest block denoted <span class="math">\\mathsf{B}^{<em>}</span> mined at time <span class="math">t</span> in view by Fact 4. Summarizing the above, we conclude that <span class="math">\\mathsf{B}_{i}=\\widehat{\\mathsf{B}}_{i}=\\mathsf{B}_{j}=\\widehat{\\mathsf{B}}_{j}=\\mathsf{B}^{</em>}</span>, and thus <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> cannot diverge at <span class="math">t</span> in view.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Case 2: <span class="math">t</span> is not a convergence opportunity. In this case, by the definition of a strong pivot, we claim that in <span class="math">\\mathsf{chain}_{i}^{r}</span>, in between <span class="math">\\mathsf{B}_{i}</span> and <span class="math">\\widehat{\\mathsf{B}}_{i}</span>, there cannot be any adversarial blocks — since otherwise for the window <span class="math">[\\mathsf{B}_{i}.\\mathsf{time}+1,\\mathsf{B}_{j}.\\mathsf{time}-1]</span> there will be more adversarial blocks than convergence opportunities. This means that there cannot be any convergence opportunity between <span class="math">[\\mathsf{B}_{i}.\\mathsf{time}+1,\\mathsf{B}_{j}.\\mathsf{time}-1]</span> in <span class="math">\\mathsf{view}</span>, since otherwise, either <span class="math">\\mathsf{B}_{i}</span> is not the nearest honest block corresponding to a convergence opportunity to the left of <span class="math">t</span> in <span class="math">\\mathsf{chain}_{i}^{r}</span>, or <span class="math">\\widehat{\\mathsf{B}}_{i}</span> is not the nearest honest block corresponding to a convergence opportunity to the right of <span class="math">t</span> in <span class="math">\\mathsf{chain}_{i}^{r}</span>. To summarize, <span class="math">\\mathsf{B}_{i}.\\mathsf{time}</span> and <span class="math">\\widehat{\\mathsf{B}}_{i}.\\mathsf{time}</span> must be the two convergence opportunities closest in time to <span class="math">t</span> on either side of <span class="math">t</span> in <span class="math">\\mathsf{view}</span>.</li>

    </ul>

    <p class="text-gray-300">Similarly, we can conclude that <span class="math">\\mathsf{B}_{j}.\\mathsf{time}</span> and <span class="math">\\widehat{\\mathsf{B}}_{j}.\\mathsf{time}</span> must be the two convergence opportunities closest in time to <span class="math">t</span> on either side of <span class="math">t</span> in <span class="math">\\mathsf{view}</span>. Therefore, we know that <span class="math">\\widehat{\\mathsf{B}}_{i}</span> and <span class="math">\\widehat{\\mathsf{B}}_{j}</span> are honest blocks correspond to the same convergence opportunity in <span class="math">\\mathsf{view}</span>, and thus <span class="math">\\widehat{\\mathsf{B}}_{i}=\\widehat{\\mathsf{B}}_{j}</span> since there can only be a unique honest block corresponding to every convergence opportunity by Fact 4. This also implies that <span class="math">\\mathsf{chain}_{i}^{r}</span> and <span class="math">\\mathsf{chain}_{j}^{r^{\\prime}}</span> cannot have diverged at <span class="math">t</span>.</p>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-90" class="text-lg font-semibold mt-6">5.6.3 Strong Pivots Recur Frequently</h4>

    <p class="text-gray-300">We proceed in several steps to show that strong pivots happen frequently in almost all <span class="math">\\mathsf{views}</span>.</p>

    <h5 id="sec-91" class="text-base font-semibold mt-4">Convergence opportunities vs. adversarial time slots.</h5>

    <p class="text-gray-300">First, we prove a lemma showing that given a window <span class="math">[t_{0},t_{1}]</span>, it is likely that there are more convergence opportunities in this window than adversarial time slots. In particular, the longer the window is, the more likely that convergence opportunities “win” in comparison with adversarial time slots. In other words, for sufficiently long windows, convergence opportunities win almost surely. For shorter windows, convergence opportunities are nonetheless likely to win although not almost surely.</p>

    <h6 id="sec-92" class="text-base font-medium mt-4">Lemma 6 (Adversarial time slots vs. convergence opportunities for any fixed window).</h6>

    <p class="text-gray-300">For any <span class="math">t_{0},t_{1}</span> such that <span class="math">t:=t_{1}-t_{0}\\geq 0</span>, for any <span class="math">\\Pi_{ideal}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some positive constant <span class="math">\\eta</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\</span>}\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathbf{A}(\\mathsf{view})[t_{0}:t_{1}]\\geq\\mathbf{C}(\\mathsf{view})[t_{0}:t_{1}]\\right]<\\exp(-\\eta\\beta t)$</p>

    <h6 id="sec-93" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Due to Fact 2, for any <span class="math">0&lt;\\epsilon_{1}&lt;1</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbf{A}[t_{0}:t_{1}]&gt;(1+\\epsilon_{1})\\beta t\\right]&lt;\\exp(-\\frac{\\epsilon_{1}^{2}\\beta t}{3})</span></p>

    <p class="text-gray-300">Due to Lemma 2, for any positive <span class="math">\\epsilon_{2}</span>, there exists positive <span class="math">\\epsilon^{\\prime}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbf{C}[t_{0}:t_{1}]&lt;(1-\\epsilon_{2})(1-2pN\\Delta)\\alpha t\\right]&lt;\\exp(-\\epsilon^{\\prime}\\beta t)</span></p>

    <p class="text-gray-300">Since we know that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\alpha}{\\beta}&gt;\\frac{1+\\phi}{1-2pN\\Delta}</span></p>

    <p class="text-gray-300">there must exist sufficiently small positive constants <span class="math">\\epsilon_{1}</span> and <span class="math">\\epsilon_{2}</span> such that</p>

    <p class="text-gray-300"><span class="math">(1+\\epsilon_{1})\\beta t&lt;(1-\\epsilon_{2})(1-2pN\\Delta)\\alpha t</span></p>

    <p class="text-gray-300">∎</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Now by taking a union bound over all possible windows of sufficient length, we obtain the following corollary.</p>

    <h6 id="sec-94" class="text-base font-medium mt-4">Corollary 3 (Convergence opportunities outnumber adversarial slots for all sufficiently long windows).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{ideal}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, for any positive constant <span class="math">\\epsilon_{0}</span>, for any <span class="math">t\\geq\\frac{\\epsilon_{0}\\lambda}{\\beta}</span>, there exists a positive constant <span class="math">\\eta</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\lambda)</span> fraction of the views sampled from <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\text{For any }t_{0}\\colon\\textbf{A}(\\text{view})[t_{0}:t_{0}+t]&lt;\\textbf{C}(\\text{view})[t_{0}:t_{0}+t]</span></p>

    <h4 id="sec-95" class="text-lg font-semibold mt-6"><span class="math">w</span>-pivots are strong pivots.</h4>

    <p class="text-gray-300">Based on Corollary 3, we know that except for negligible fraction of the views, in any sufficiently long window, the number of convergence opportunities must be larger than the number of adversarial blocks. This immediately implies that for a suitably large choice of <span class="math">w</span>, except for negligible fraction of the views, every <span class="math">w</span>-pivot must be a strong pivot as well. This is formalized in the following fact.</p>

    <h6 id="sec-96" class="text-base font-medium mt-4">Fact 5.</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a positive constant <span class="math">\\eta</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\lambda)</span> fraction of the views sampled from <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, every <span class="math">w</span>-pivot is a strong pivot for <span class="math">w=\\frac{\\lambda}{\\beta}</span>.</p>

    <h6 id="sec-97" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows in a straightforward fashion from Corollary 3 which indicates that for any sufficiently long window, convergence opportunities must outnumber adversarial time slots except for a negligible fraction of the views. ∎</p>

    <p class="text-gray-300">Due to Fact 5, to show that strong pivots happen frequently in almost all views, it suffices to show that <span class="math">w</span>-pivots happen frequently in almost all views where <span class="math">w=\\frac{\\lambda}{\\beta}</span>.</p>

    <h4 id="sec-98" class="text-lg font-semibold mt-6">Any fixed time is somewhat likely a pivot.</h4>

    <p class="text-gray-300">To show that <span class="math">w</span>-pivots happen frequently in almost all views, we first show that any fixed time is a pivot with reasonable probability in almost all views.</p>

    <h6 id="sec-99" class="text-base font-medium mt-4">Lemma 7 (Any fixed time is a likely pivot).</h6>

    <p class="text-gray-300">For any <span class="math">t</span>, for any <span class="math">\\Pi_{ideal}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there is a polynomial function <span class="math">\\mathsf{poly}(\\cdot)</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds for <span class="math">w=\\frac{\\lambda}{\\beta}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{view}\\leftarrow_{\\</span>}\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\ t\\text{ is a }w\\text{-pivot}\\right]>\\frac{1}{\\mathsf{poly}(\\lambda)}$</p>

    <h6 id="sec-100" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We define the following event <span class="math">\\mathsf{good}^{t,v}(\\text{view})=1</span> iff both of the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{G}_{1}^{t,v}(\\text{view})</span>: <span class="math">\\mathcal{A}</span> is never elected leader during <span class="math">[t-v,t+v]</span> in view; and</li>

      <li><span class="math">\\mathsf{G}_{2}^{t,v}(\\text{view})</span>: in any window <span class="math">[t_{0},t_{1}]</span> containing <span class="math">t</span> of length <span class="math">v\\leq t_{1}-t_{0}\\leq w</span>, it holds that <span class="math">\\textbf{C}(\\text{view})[t_{0}:t_{1}]&gt;\\textbf{A}(\\text{view})[t_{0}:t_{1}]</span>.</li>

    </ul>

    <p class="text-gray-300">First, it is not hard to see that for any view and any <span class="math">v</span>, if <span class="math">\\mathsf{good}^{t,v}(\\text{view})=1</span>, then <span class="math">t</span> must be a <span class="math">w</span>-pivot in view.</p>

    <p class="text-gray-300">Next, let <span class="math">v=\\frac{c\\log\\lambda}{2\\beta}</span> for an appropriate constant <span class="math">c</span> to be determined later. Thus, there exists some polynomial <span class="math">\\mathsf{poly}(\\cdot)</span> related to <span class="math">c</span> such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{G}_{1}^{t,v}(\\text{view})\\right]\\geq(1-\\beta)^{2v}=(1-\\beta)^{\\frac{c\\log\\lambda}{\\beta}}=\\frac{1}{\\mathsf{poly}(\\lambda)}</span></p>

    <p class="text-gray-300">Further, since there are at most <span class="math">w^{2}</span> windows containing <span class="math">t</span> of length between <span class="math">v</span> and <span class="math">w</span>, by Lemma 6 and the union bound, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})\\right]\\geq 1-\\exp(-\\eta\\beta v)\\cdot w^{2}=1-\\exp(-c\\eta\\log\\lambda)\\cdot w^{2}</span></p>

    <p class="text-gray-300">Recall that since <span class="math">\\beta</span> is inverse polynomially bounded in <span class="math">\\lambda</span>, it holds that <span class="math">w</span> is polynomially bounded in <span class="math">\\lambda</span>. Therefore, there exists a sufficiently large constant <span class="math">c</span> such that <span class="math">\\exp(-c\\eta\\log\\lambda)\\cdot w^{2}&lt;\\frac{1}{2}</span>. Thus for a sufficiently large constant <span class="math">c</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})\\right]\\geq\\frac{1}{2}</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Finally, it is not hard to see that $\\Pr[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})]\\leq\\Pr[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{G}_{1}^{t,v}(\\mathsf{view})\\right.\\!\\!]<span class="math">, i.e., </span>\\mathsf{G}_{2}<span class="math"> is more likely conditioned on </span>\\mathsf{G}_{1}<span class="math">. We therefore conclude that for some polynomial function </span>\\mathsf{poly}^{\\prime}(\\cdot)$, it holds that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\Pr\\left[\\mathsf{good}^{t,v}(\\mathsf{view})=1\\right]</span> $=\\Pr\\left[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathsf{G}_{1}^{t,v}(\\mathsf{view})\\right.\\right]\\cdot\\Pr\\left[\\mathsf{G}_{1}^{t,v}(\\mathsf{view})\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq\\Pr\\left[\\mathsf{G}_{2}^{t,v}(\\mathsf{view})\\right]\\cdot\\Pr\\left[\\mathsf{G}_{1}^{t,v}(\\mathsf{view})\\right]\\geq\\frac{1}{\\mathsf{poly}^{\\prime}(\\lambda)}</span></p>

    <p class="text-gray-300">∎</p>

    <h5 id="sec-101" class="text-base font-semibold mt-4">Pivots are frequently recurring.</h5>

    <p class="text-gray-300">Given a <span class="math">\\mathsf{view}</span>, we say that <span class="math">\\mathsf{many-pivots}^{w,W}(\\mathsf{view})=1</span> iff for any <span class="math">s,r</span> such that <span class="math">r-s&gt;W\\geq 0</span>, there must exist a <span class="math">w</span>-pivot during the window <span class="math">[s,r]</span>.</p>

    <h6 id="sec-102" class="text-base font-medium mt-4">Theorem 5 (There are many pivots).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{ideal}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a polynomial <span class="math">W(\\cdot)</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds where <span class="math">w=\\frac{\\lambda}{\\beta}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathsf{many-pivots}^{w,W}(\\mathsf{view})=1\\right]\\geq 1-\\exp(-\\frac{\\lambda}{2})</span></p>

    <h6 id="sec-103" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Given <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, let <span class="math">\\mathsf{poly}(\\cdot)</span> denote the polynomial corresponding to Lemma 7 for <span class="math">w=\\frac{\\lambda}{\\beta}</span>. Now let <span class="math">W(\\cdot):=4(w+\\Delta)\\cdot\\lambda\\cdot\\mathsf{poly}(\\cdot)</span>. Consider a window <span class="math">(s,r)</span> of length at least <span class="math">W(\\lambda)</span>, and a sequence of events <span class="math">\\mathsf{G}_{0},\\mathsf{G}_{1},\\ldots</span> where <span class="math">\\mathsf{G}_{i}</span> denote the good event that the time <span class="math">s+i\\cdot 2(w+\\Delta)</span> is a <span class="math">w</span>-pivot, where <span class="math">i</span> can range from <span class="math">0</span> to <span class="math">2\\lambda\\cdot\\mathsf{poly}(\\lambda)</span>. By the definition of <span class="math">w</span>-pivots and that of convergence opportunities, it is not hard to see that all these events <span class="math">\\mathsf{G}_{0},\\mathsf{G}_{1},\\ldots</span> are independent. The probability that all these good events do not happen is upper bounded by</p>

    <p class="text-gray-300"><span class="math">\\left(1-\\frac{1}{\\mathsf{poly}(\\lambda)}\\right)^{2\\lambda\\cdot\\mathsf{poly}(\\lambda)}\\leq\\exp(-\\lambda)</span></p>

    <p class="text-gray-300">The remainder of the proof follows from a simple union bound over all possible such windows. ∎</p>

    <p class="text-gray-300">Given a <span class="math">\\mathsf{view}</span>, we say that <span class="math">\\mathsf{many\\_strong\\_pivots}^{W}(\\mathsf{view})=1</span> iff for any <span class="math">s,r</span> such that <span class="math">r-s&gt;W\\geq 0</span>, there must exist a strong pivot during the window <span class="math">(s,r)</span>.</p>

    <h6 id="sec-104" class="text-base font-medium mt-4">Corollary 4 (There are many strong pivots).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{ideal}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a polynomial <span class="math">W(\\cdot)</span> and a positive constant <span class="math">\\eta</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathsf{view}\\leftarrow_{\\S}\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathsf{many\\_strong\\_pivots}^{W}(\\mathsf{view})=1\\right]\\geq 1-\\exp(-\\eta\\lambda)</span></p>

    <h6 id="sec-105" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Follows in a straightforward manner from Theorem 5 and Fact 5.</p>

    <p class="text-gray-300">5.6.4 Proof of Consistency</p>

    <p class="text-gray-300">At this point, it is relatively easy to prove a weak version of the consistency property. Intuitively, given an honest chain, as long as we remove <span class="math">\\poly(\\lambda)</span> blocks from the end for an appropriate polynomial function <span class="math">\\poly(\\cdot)</span>, there must be a strong pivot in the last <span class="math">\\poly(\\lambda)</span> blocks worth of time. Thus the honest chain cannot have diverged from other honest chains prior to this strong pivot. We now formalize this intuition, and prove a weak version of consistency with somewhat loose parameters. We defer a tighter proof to Appendix A.</p>

    <h6 id="sec-106" class="text-base font-medium mt-4">Fact 6 (Total block upper bound).</h6>

    <p class="text-gray-300">For any positive constants <span class="math">\\epsilon,\\epsilon_{0}</span>, there exists a positive constant <span class="math">\\eta</span> such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\lambda)</span> fraction of the views sampled from <span class="math">\\EXEC^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, it holds that there cannot be more than <span class="math">(1+\\epsilon)Npt</span> slots in which any node (honest or corrupt) is elected leader, in any window <span class="math">[s,r]</span> of length <span class="math">t:=r-s\\geq\\epsilon_{0}\\lambda</span>.</p>

    <h6 id="sec-107" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">By a straightforward application of the Chernoff bound over any fixed window of sufficient length, and then taking a union bound over all windows. ∎</p>

    <h6 id="sec-108" class="text-base font-medium mt-4">Theorem 6 (Weak consistency).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a polynomial <span class="math">T(\\lambda)</span> and a positive constant <span class="math">\\eta</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\text{view}\\leftarrow_{\\S}\\EXEC^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\consistent^{T}(\\text{view})=1\\Big{]}\\geq 1-\\exp(-\\eta\\lambda)</span></p>

    <h6 id="sec-109" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For simplicity, we ignore <span class="math">\\exp(-\\Omega(\\lambda)</span> fraction of bad views where all relevant bad events take place. Given any two honest chains <span class="math">\\chain_{i}^{r}</span> and <span class="math">\\chain_{j}^{r^{\\prime}}</span> where <span class="math">r\\leq r^{\\prime}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Corollary 4, there is at least a strong pivot between <span class="math">[r-W(\\lambda)-\\frac{\\lambda}{\\beta},r-\\frac{\\lambda}{\\beta}]</span> where <span class="math">W(\\cdot)</span> is a polynomial function defined by Corollary 4.</li>

      <li>By Lemma 5, <span class="math">\\chain_{i}^{r}</span> and <span class="math">\\chain_{j}^{r^{\\prime}}</span> cannot have diverged at time <span class="math">r-W(\\lambda)-\\frac{\\lambda}{\\beta}</span>.</li>

      <li>Finally, by Fact 6, for an appropriate polynomial <span class="math">T(\\lambda)</span>, <span class="math">\\chain_{i}^{r}</span> cannot have more than <span class="math">T(\\lambda)</span> blocks after time <span class="math">r-W(\\lambda)-\\frac{\\lambda}{\\beta}</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h4 id="sec-110" class="text-lg font-semibold mt-6">5.6.5 Tighter Consistency Analysis</h4>

    <p class="text-gray-300">As mentioned earlier, the above analysis actually can be tightened to obtain the following, tighter version of the consistency theorem. The proof of this tighter consistency theorem will be provided in Appendix A.</p>

    <h6 id="sec-111" class="text-base font-medium mt-4">Theorem 7 (Consistency).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists positive constants <span class="math">\\eta</span> and <span class="math">C</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds for <span class="math">T=C\\lambda^{2}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\text{view}\\leftarrow_{\\S}\\EXEC^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\consistent^{T}(\\text{view})=1\\Big{]}\\geq 1-\\exp(-\\eta\\lambda)</span></p>

    <p class="text-gray-300">5.7 Chain Growth Upper Bound</p>

    <p class="text-gray-300">We now prove chain growth upper bound.</p>

    <h6 id="sec-112" class="text-base font-medium mt-4">Lemma 8 (Chain growth upper bound).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{ideal}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, for any positive constants <span class="math">\\epsilon_{0},\\epsilon</span> and any <span class="math">t\\geq\\frac{\\epsilon_{0}\\lambda}{\\alpha}</span>, there exists a positive constant <span class="math">\\eta</span>, such that for every <span class="math">\\lambda\\in\\mathbb{N}</span>, except for <span class="math">\\exp(-\\eta\\lambda)</span> fraction of the views sampled from <span class="math">\\textsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, the following holds:</p>

    <p class="text-gray-300"><span class="math">\\text{For any }t_{0}\\text{, max\\_chain\\_increase}(\\textsf{view})[t_{0}:t_{0}+t]\\leq(1+\\epsilon)\\textsf{Npt}</span></p>

    <p class="text-gray-300">where <span class="math">\\textsf{max\\_chain\\_increase}(\\textsf{view})[t_{0}:t_{0}+t]</span> denotes the length of the shortest honest chain at time <span class="math">t_{0}+t</span> minus the length of the longest honest chain at time <span class="math">t_{0}</span>.</p>

    <h6 id="sec-113" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Henceforth we ignore any view where relevant bad events take place. For any remaining good view, we prove that there cannot exist positive constant <span class="math">\\epsilon_{0}</span>, constant <span class="math">0&lt;\\epsilon&lt;1</span>, some <span class="math">t\\geq\\frac{\\epsilon_{0}\\lambda}{\\alpha}</span>, and some <span class="math">t_{0}</span>, such that <span class="math">\\textsf{max\\_chain\\_increase}(\\textsf{view})[t_{0}:t_{0}+t]&gt;(1+\\epsilon)\\textsf{Npt}</span>. Suppose for the sake of contradiction the above is not true. Let chain denote the shortest chain belonging to an alert node at time <span class="math">t_{0}</span>, let <span class="math">\\textsf{chain}^{\\prime}</span> denote the longest chain belonging to an alert node at time <span class="math">t_{0}+t</span>. Let <span class="math">r:=\\textsf{chain}[-1].\\textsf{time}</span>, and <span class="math">r^{\\prime}:=\\textsf{chain}^{\\prime}[-1].\\textsf{time}</span>; by definition of honest protocol, it holds that <span class="math">r\\leq t_{0}</span> and <span class="math">r^{\\prime}\\leq t_{0}+t</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By Fact 6, there exists a positive constant <span class="math">\\eta\\geq\\epsilon</span> such that <span class="math">r^{\\prime}-r\\geq(1+\\eta)t</span> — since otherwise, by Fact 6, there cannot be more than <span class="math">(1+\\epsilon)\\textsf{Npt}</span> total elected time slots between <span class="math">r</span> and <span class="math">r^{\\prime}</span>.</li>

      <li>Since <span class="math">r^{\\prime}\\leq t_{0}+t</span>, it must hold that <span class="math">r\\leq t_{0}+t-(1+\\eta)t=t_{0}-\\eta t\\leq t_{0}-\\epsilon t</span>.</li>

      <li>By chain quality, for any positive constant <span class="math">\\eta^{\\prime}</span>, there must be an honest block in <span class="math">\\textsf{chain}[-\\eta^{\\prime}\\lambda:]</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The above means that there exists an alert node whose chain length is at least $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-\\eta^{\\prime}\\lambda<span class="math"> at some time </span>\\widetilde{r}<r$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We also know that there is an alert node whose chain length is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\textsf{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> at </span>t_{0}<span class="math">. This means that the minimal honest chain growth between </span>\\widetilde{r}<r<span class="math"> and </span>t_{0}<span class="math"> is at most </span>\\eta^{\\prime}\\lambda<span class="math">. For a sufficiently small constant </span>\\eta^{\\prime}$, this would be impossible due to chain growth lower bound, and thus we reach a contradiction.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-114" class="text-xl font-semibold mt-8">5.8 Real World Emulates the Ideal World</h3>

    <p class="text-gray-300">We now show that the real-world protocol <span class="math">\\Pi_{\\text{sleepy}}</span> securely emulates the ideal-world protocol <span class="math">\\Pi_{\\text{ideal}}</span>. This can be shown using a standard simulation paradigm as described below. We construct the following simulator <span class="math">\\mathcal{S}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> internally simulates <span class="math">\\mathcal{F}_{\\text{CA}}</span>. At the start of execution, <span class="math">\\mathcal{S}</span> honestly generates a <span class="math">(\\textsf{pk}_{i},\\textsf{sk}_{i})</span> pair for each honest node <span class="math">i</span>, and registers <span class="math">\\textsf{pk}_{i}</span> on behalf of honest node <span class="math">i</span> with the internally simulated <span class="math">\\mathcal{F}_{\\text{CA}}</span>.</li>

    </ul>

    <p class="text-gray-300">Whenever <span class="math">\\mathcal{A}</span> wishes to interact with <span class="math">\\mathcal{F}_{\\text{CA}}</span>, <span class="math">\\mathcal{S}</span> simply forwards messages in between <span class="math">\\mathcal{A}</span> and the internally simulated <span class="math">\\mathcal{F}_{\\text{CA}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{S}</span> receives a hash query of the form <span class="math">\\mathsf{H}(\\mathcal{P},t)</span> from <span class="math">\\mathcal{A}</span> or from internally, <span class="math">\\mathcal{S}</span> checks if the query has been asked before. If so, simply return the same answer as before.</li>

    </ul>

    <p class="text-gray-300">If not, <span class="math">\\mathcal{S}</span> checks if <span class="math">\\mathcal{P}</span> is a party identifier corresponding to this protocol instance. If not, <span class="math">\\mathcal{S}</span> generates a random number of appropriate length and returns it. Else if the mapping succeeds, <span class="math">\\mathcal{S}</span> queries <span class="math">b \\leftarrow \\mathcal{F}_{\\text{tree}.leader}(\\mathcal{P}, t)</span>. If <span class="math">b = 1</span>, <span class="math">\\mathcal{S}</span> rejection samples a random string <span class="math">h</span> of appropriate length, until <span class="math">h &amp;lt; D_p</span>; it then returns <span class="math">h</span>. Else if <span class="math">b = 0</span>, <span class="math">\\mathcal{S}</span> rejection samples a random string <span class="math">h</span> of appropriate length, until <span class="math">h \\geq D_p</span>; it then returns <span class="math">h</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> keeps track of the "real-world" chain for every honest node <span class="math">i</span>. Whenever it sends chain to <span class="math">\\mathcal{A}</span> on behalf of <span class="math">i</span>, it updates this state for node <span class="math">i</span>. Whenever <span class="math">\\mathcal{A}</span> sends chain to honest node <span class="math">i</span>, <span class="math">\\mathcal{S}</span> checks the simulation validity (see Definition 8) of chain. If chain is simulation valid and moreover chain is longer than the current real-world chain for node <span class="math">i</span>, <span class="math">\\mathcal{S}</span> also saves chain as the new real-world chain for node <span class="math">i</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever an honest node with the party identifier <span class="math">\\mathcal{P}</span> sends chain to <span class="math">\\mathcal{S}</span>, <span class="math">\\mathcal{S}</span> looks up the current real-world state chain for node <span class="math">\\mathcal{P}</span>. The simulator now computes a new chain using the real-world algorithm: let <span class="math">(\\mathsf{pk},\\mathsf{sk})</span> be the key pair for node <span class="math">\\mathcal{P}</span>, let <span class="math">t</span> be the current time, and let <span class="math">\\mathsf{B} := \\text{chain}[-1]</span>.</li>

    </ul>

    <p class="text-gray-300">If eligible<span class="math">^t(\\mathcal{P})</span> where the hash function <span class="math">\\mathsf{H}</span> is through internal query to the simulator itself:</p>

    <p class="text-gray-300">let <span class="math">\\sigma := \\Sigma.\\text{sign}(\\mathsf{sk}, \\text{chain}[-1].h, \\mathsf{B}, t)</span>, <span class="math">h&#x27; := \\mathsf{d}(\\text{chain}[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\sigma)</span>,</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">let <span class="math">B := (\\text{chain}[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\sigma, h&#x27;)</span>, let chain' := chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, the simulator <span class="math">\\mathcal{S}</span> sends chain' to <span class="math">\\mathcal{A}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Whenever <span class="math">\\mathcal{A}</span> sends a chain to an honest node <span class="math">i</span>, <span class="math">\\mathcal{S}</span> intercepts the message. <span class="math">\\mathcal{S}</span> ignores the message if chain is not simulation valid. Otherwise, let chain := extract(chain), and let chain[: <span class="math">\\ell</span>] <span class="math">\\prec</span> chain be the longest prefix such that <span class="math">\\mathcal{F}_{\\text{tree}.\\text{verify}}(\\text{chain}[: \\ell]) = 1</span>. The simulator checks to see if there exists a block in chain[<span class="math">\\ell + 1</span> :] signed by an honest <span class="math">\\mathcal{P}</span>. If so, abort outputting sig-failure. Else, for each $k \\in [\\ell + 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\text{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\mathcal{P}^<em> := \\text{chain}[k].\\mathcal{P}</span>, let <span class="math">t^</em> := \\text{chain}[k].\\text{time}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> then calls <span class="math">\\mathcal{F}_{\\text{tree}.\\text{extend}}(\\text{chain}[: k - 1], \\text{chain}[k], t^<em>)</span> on behalf of corrupt party <span class="math">\\mathcal{P}^</em></span>.</li>

    </ol>

    <p class="text-gray-300">Notice that if the current chain is simulation valid, then the new chain' must be simulation valid as well. Finally, <span class="math">\\mathcal{S}</span> forwards chain to honest node <span class="math">i</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point of time, if <span class="math">\\mathcal{S}</span> observes two different simulation valid (real-world) chains that contain identical (real-world) blocks, abort outputting duplicate-block-failure.</li>

    </ul>

    <p class="text-gray-300">Definition 8 (Simulation valid chains). We say that a chain is simulation valid if it passes the real-world validity checks, but using the H and the <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span> implemented by the simulator <span class="math">\\mathcal{S}</span>.</p>

    <p class="text-gray-300">Fact 7. The simulated execution never aborts with duplicate-block-failure except with negligible probability.</p>

    <p class="text-gray-300">Proof. For this bad event to happen, it must be the case that two distinct queries to the hash function <span class="math">\\mathsf{d}</span> returns the same result. Since there can be only polynomially many such queries, this happens with negligible probability.</p>

    <p class="text-gray-300">Fact 8. The simulated execution never aborts with sig-failure except with negligible probability.</p>

    <p class="text-gray-300">34</p>

    <h6 id="sec-115" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We ignore all views where the bad event duplicate-block-failure happens.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose some block <span class="math">B</span> is signed by the simulator <span class="math">\\mathcal{S}</span>. Then, some honest node <span class="math">i</span> must have sent chain$</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">extract</span>(B)<span class="math"> to </span>\\mathcal{S}<span class="math"> earlier, and this means that chain must be in </span>\\mathcal{F}_{\\text{tree}}<span class="math">. Therefore, if sig-failure ever happens, it means that the adversary </span>\\mathcal{A}<span class="math"> has produced a signature on a different message that </span>\\mathcal{S}$ never signed (due to no duplicate-block-failure). We can now easily construct a reduction that breaks signature security if sig-failure happens with non-negligible probability. ∎</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-116" class="text-base font-medium mt-4">Lemma 9 (Indistinguishability).</h6>

    <p class="text-gray-300">Conditioned on the fact that all of the aforementioned bad events do not happen, then the simulated execution is identically distributed as the real-world execution from the perspective of <span class="math">\\mathcal{Z}</span>.</p>

    <h6 id="sec-117" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Observe that the simulator’s H coins are always consistent with <span class="math">\\mathcal{F}_{\\text{tree}}</span>’s leader coins. Further, as long as there is no sig-failure, if the simulator receives any simulation valid chain from <span class="math">\\mathcal{A}</span>, either chain := extract(chain) already exists in <span class="math">\\mathcal{F}_{\\text{tree}}</span>, or else <span class="math">\\mathcal{S}</span> must succeed in adding chain to <span class="math">\\mathcal{F}_{\\text{tree}}</span>.</p>

    <p class="text-gray-300">The rest of the proof works through a standard repartitioning argument. ∎</p>

    <h6 id="sec-118" class="text-base font-medium mt-4">Fact 9.</h6>

    <p class="text-gray-300">If <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{sleepy}}</span>-compliant, then <span class="math">(\\mathcal{S}^{\\mathcal{A}},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\text{ideal}}</span>-compliant.</p>

    <h6 id="sec-119" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300"><span class="math">\\Pi_{\\text{sleepy}}</span> and <span class="math">\\Pi_{\\text{ideal}}</span> have identical compliance rules. The only rule to verify is <span class="math">\\Delta</span>-bounded network delay rule — every other rule is straightforward to verify. Observe that whenever an honest node sends <span class="math">\\mathcal{S}</span> an ideal-world chain, <span class="math">\\mathcal{S}</span> will transform it to a real-world chain and forward it to <span class="math">\\mathcal{A}</span>. Since <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is compliant, for each alert node <span class="math">j</span>, within <span class="math">\\Delta</span> steps <span class="math">\\mathcal{A}</span> will ask <span class="math">\\mathcal{S}</span> to forward chain to <span class="math">j</span>. Similarly, for any sleepy node <span class="math">j</span> that wakes up after <span class="math">\\Delta</span> time, at the time it wakes up, <span class="math">\\mathcal{A}</span> will ask <span class="math">\\mathcal{S}</span> to forward chain to <span class="math">j</span>. Note that <span class="math">\\mathcal{S}</span> will never drop such a request since all chain sent from <span class="math">\\mathcal{S}</span> to <span class="math">\\mathcal{A}</span> are simulation valid. Therefore <span class="math">\\mathcal{S}</span> respects the <span class="math">\\Delta</span>-delay rule as well, and further <span class="math">\\mathcal{S}</span> respects the rule to forward waking nodes all pending messages. ∎</p>

    <p class="text-gray-300">Finally, since the simulated execution is compliant, it respects all the desired properties as Theorem 4 states. Now, since real-world execution and the simulated execution are indistiguishable, it holds that all the desired properties hold in the same way for the real-world execution.</p>

    <p class="text-gray-300">We thus complete the proof of main theorem assuming a random oracle. In the next subsection, we describe how to adapt our proof when we replace the random oracle with a CRS and a PRF.</p>

    <h3 id="sec-120" class="text-xl font-semibold mt-8">5.9 Removing the Random Oracle in the Proof</h3>

    <p class="text-gray-300">It is not hard to modify the proof when we remove the random oracle, and instead use <span class="math">\\textsf{PRF}_{k_{0}}(\\mathcal{P},t)&lt;D_{p}</span> as the leader election function, where <span class="math">k_{0}</span> is a random string to be included in the common reference string. We state the modifications necessary to the proof below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, we introduce an intermediate hybrid protocol where the ideal functionality <span class="math">\\mathcal{F}_{\\text{tree}}</span> selects <span class="math">k_{0}</span> at random prior to protocol start, and discloses <span class="math">k_{0}</span> to the adversary <span class="math">\\mathcal{A}</span>. Meanwhile, instead of generating random bits to determine leader for both honest and corrupt nodes, the ideal functionality <span class="math">\\mathcal{F}_{\\text{tree}}</span> instead uses <span class="math">\\textsf{PRF}_{k_{0}}(\\mathcal{P},t)&lt;D_{p}</span>.</li>

    </ul>

    <p class="text-gray-300">We can argue that such a hybrid protocol is also secure against computationally unbounded, compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>. In particular, observe that in our previous ideal protocol analysis, once we fix the random bits <span class="math">\\vec{\\nu}</span> of the random oracle (RO), we can define certain bad events (that depend only on the random bits of the random oracle, but those not of <span class="math">(\\mathcal{A},\\mathcal{Z})</span>). Provided that these bad events do not happen, even a computationally unbounded <span class="math">(\\mathcal{A},\\mathcal{Z})</span> cannot break the chain growth, chain quality, or consistency properties. Further, observe that there is a polynomial-time algorithm that can efficient check for bad events given the random bits of the random oracle.</p>

    <p class="text-gray-300">Therefore, when we replace the random oracle with <span class="math">\\mathsf{PRF}_{k_{0}}(\\cdot)</span>, over the probability space defined over the choice of <span class="math">k_{0}</span>, these bad events should not happen except with negligible probability as well — otherwise the algorithm that checks for the bad events can be used as an efficient adversary that distinguishes the PRF from the random oracle. Similarly, in the PRF case, as long as the bad events do not happen, even a computationally unbounded adversary should not be able to break the security properties.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now, we can modify our simulation proof to prove that the real-world protocol emulates the modified hybrid protocol as mentioned above. Most of the simulation proof is identical to the random oracle case presented above, except that now when the simulator learns <span class="math">k_{0}</span> from <span class="math">\\mathcal{F}_{\\text{tree}}</span>, it simply gives <span class="math">k_{0}</span> to <span class="math">\\mathcal{A}</span>, and the simulator no longer needs to simulate random oracle queries for <span class="math">\\mathcal{A}</span>.</li>

    </ul>

    <h2 id="sec-121" class="text-2xl font-bold">6 Achieving Adaptive Security</h2>

    <p class="text-gray-300">So far, we have assumed that the adversary issues both corrupt and sleep instructions statically upfront. In this section, we will show how to achieve adaptive security with complexity leveraging. It turns out even with complexity leveraging the task is non-trivial.</p>

    <h3 id="sec-122" class="text-xl font-semibold mt-8">6.1 Intuition: Achieving Adaptive Sleepiness</h3>

    <p class="text-gray-300">To simplify the problem, let us first consider how to achieve adaptive sleepiness (but static corruption). In our statically secure protocol <span class="math">\\Pi_{\\text{sleepy}}</span>, the adversary can see into the future for all honest and corrupt players. In particular, the adversary can see exactly in which time steps each honest node is elected leader. If sleep instructions could be adaptively issued, the adversary could simply put a node to sleep whenever he is elected leader, and wake up him when he is not leader. This way, the adversary can easily satisfy the constraint that at any time, the majority of the online nodes must be honest, while ensuring that no alert nodes are ever elected leader (with extremely high probability).</p>

    <p class="text-gray-300">To defeat such an attack and achieve adaptive sleepiness (but static corruption), we borrow an idea that was (informally) suggested by Micali <em>[31]</em>. Basically, instead of computing a “leader ticket” <span class="math">\\eta</span> by hashing the party’s (public) identifier and the time step <span class="math">t</span> and by checking <span class="math">\\eta&lt;D_{p}</span> to determine if the node is elected leader, we will instead have an honest node compute a pseudorandom “leader ticket” itself using some secret known only to itself. In this way, the adversary is no longer able to observe honest nodes’ future. The adversary is only able to learn that an honest node is elected leader in time step <span class="math">t</span> when the node actually sends out a new chain in <span class="math">t</span> — but by then, it will be too late for the adversary to (retroactively) put that node to sleep in <span class="math">t</span>.</p>

    <h4 id="sec-123" class="text-lg font-semibold mt-6">A naïve attempt.</h4>

    <p class="text-gray-300">Therefore, a naïve attempt would be the following.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Each node <span class="math">\\mathcal{P}</span> picks its own PRF key <span class="math">k[\\mathcal{P}]</span>, and computes a commitment <span class="math">c:=\\mathsf{comm}(k[\\mathcal{P}];r)</span> and registers <span class="math">c</span> as part of its public key with the public-key infrastructure <span class="math">\\mathcal{F}_{\\text{CA}}</span>. To determine whether it is elected leader in a time step <span class="math">t</span>, the node computes</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathsf{PRF}_{k[\\mathcal{P}]}(t)&lt;D_{p}</span></p>

    <p class="text-gray-300">where <span class="math">D_{p}</span> is a difficulty parameter related to <span class="math">p</span>, such that any node gets elected with probability <span class="math">p</span> in a given time step.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Now for <span class="math">\\mathcal{P}</span> to prove to others that it is elected leader in a certain time step <span class="math">t</span>, <span class="math">\\mathcal{P}</span> can compute a non-interactive zero-knowledge proof that the above evaluation is done correctly (w.r.t. to the commitment <span class="math">c</span> that is part of <span class="math">\\mathcal{P}</span>’s public key).</li>

    </ul>

    <h5 id="sec-124" class="text-base font-semibold mt-4">A second attempt.</h5>

    <p class="text-gray-300">This indeed hides honest nodes’ future from the adversary; however, the adversary may not generate <span class="math">k[\\mathcal{P}^{<em>}]</span> at random for a corrupt player <span class="math">\\mathcal{P}^{</em>}</span>. In particular, the adversary can try to generate <span class="math">k[\\mathcal{P}^{<em>}]</span> such that <span class="math">\\mathcal{P}^{</em>}</span> can get elected in more time steps. To defeat such an attack, we include a relatively long randomly chosen string <span class="math">k_{0}</span> in the common reference string. For a node <span class="math">\\mathcal{P}</span> to be elected leader in a time step <span class="math">t</span>, the following must hold:</p>

    <p class="text-gray-300"><span class="math">\\mathsf{PRF}_{k_{0}}(\\mathcal{P},t)\\oplus\\mathsf{PRF}_{k[\\mathcal{P}]}(t)&lt;D_{p}</span></p>

    <p class="text-gray-300">As before, a node can compute a non-interactive zero-knowledge proof (to be included in a block) to convince others that it computed the leader election function correctly.</p>

    <p class="text-gray-300">Now the adversary can still adaptively choose <span class="math">k[\\mathcal{P}^{<em>}]</span> after seeing the common reference string <span class="math">k_{0}</span> for a corrupt node <span class="math">\\mathcal{P}^{</em>}</span> to be elected in more time steps; however, it can only manipulate the outcome to a limited extent: in particular, since <span class="math">k_{0}</span> is much longer than <span class="math">k[\\mathcal{P}^{<em>}]</span>, the adversary does not have enough bits in <span class="math">k[\\mathcal{P}^{</em>}]</span> to manipulate to defeat all the entropy in <span class="math">k_{0}</span>.</p>

    <h5 id="sec-125" class="text-base font-semibold mt-4">Parametrization and analysis.</h5>

    <p class="text-gray-300">Using the above scheme, we can argue for security against an adaptive sleepiness attack. However, as mentioned above, the adversary can still manipulate the outcome of the leader election to some extent. For example, one specific attack is the following: suppose that the adversary controls <span class="math">O(N)</span> corrupt nodes denoted <span class="math">\\mathcal{P}^{<em>}_{0},\\ldots,\\mathcal{P}^{</em>}_{O(N)}</span> respectively. With high probability, the adversary can aim for the corrupt nodes to be elected for <span class="math">O(N)</span> consecutive time slots during which period the adversary can sustain a consistency and a chain quality attack. To succeed in such an attack, say for time steps <span class="math">[t:t+O(N)]</span>, the adversary can simply try random user PRF keys on behalf of <span class="math">\\mathcal{P}^{<em>}_{0}</span> until it finds one that gets <span class="math">\\mathcal{P}^{</em>}_{0}</span> to be elected in time <span class="math">t</span> (in expectation only <span class="math">O(\\frac{1}{p})</span> tries are needed); then the adversary tries the same for node <span class="math">\\mathcal{P}^{*}_{1}</span> and time <span class="math">t+1</span>, and so on.</p>

    <p class="text-gray-300">Therefore we cannot hope to obtain consistency and chain quality for <span class="math">O(N)</span>-sized windows. Fortunately, as we argued earlier, since the adversary can only manipulate the leader election outcome to a limited extent given that the length of <span class="math">k_{0}</span> is much greater than the length of each user’s PRF key, it cannot get corrupt nodes to be consecutively elected for too long. In our proof, we show that as long as we consider sufficiently long windows of <span class="math">N^{c}</span> blocks in length (for an appropriate constant <span class="math">c</span> and assuming for simplicity that <span class="math">N=\\omega(\\log\\lambda)</span>), then consistency and chain quality will hold except with negligible probability.</p>

    <h3 id="sec-126" class="text-xl font-semibold mt-8">6.2 Intuition: Achieving Adaptive Corruption</h3>

    <p class="text-gray-300">Once we know how to achieve adaptive sleepiness and static corruption, we can rely on complexity leveraging to achieve adaptive corruption. This part of the argument is standard: suppose that given an adversary under static corruption that can break the security properties of the consensus protocol, there exists a reduction that breaks some underlying complexity assumption. We now modify the reduction to guess upfront which nodes will become corrupt during the course of execution, and it guesses correctly with probability <span class="math">\\frac{1}{2^{N}}</span>. This results in a <span class="math">2^{N}</span> loss in the security reduction, and therefore if we assume that our cryptographic primitives, including the PRF, the digital signature scheme, the non-interactive zero-knowledge proof, the commitment scheme, and the collision-resistant hash family have sub-exponential hardness, we can lift the static corruption to adaptive corruption.</p>

    <p class="text-gray-300">Below, we put the aforementioned ideas together and present our adaptively secure scheme formally.</p>

    <h3 id="sec-127" class="text-xl font-semibold mt-8">6.3 Preliminary: Non-Interactive Zero-Knowledge Proofs</h3>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the remainder of this section, <span class="math">f(\\lambda)\\approx g(\\lambda)</span> means that there exists a negligible function <span class="math">\\nu(\\lambda)</span> such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">f(\\lambda)-g(\\lambda)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\nu(\\lambda)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A non-interactive proof system henceforth denoted NIZK for an NP language <span class="math">\\mathcal{L}</span> consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\texttt{crs}\\leftarrow\\texttt{gen}(1^{\\lambda},\\mathcal{L})</span>: Takes in a security parameter <span class="math">\\lambda</span>, a description of the language <span class="math">\\mathcal{L}</span>, and generates a common reference string <span class="math">\\texttt{crs}</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\texttt{prove}(\\texttt{crs},\\texttt{stmt},w)</span>: Takes in <span class="math">\\texttt{crs}</span>, a statement <span class="math">\\texttt{stmt}</span>, a witness <span class="math">w</span> such that <span class="math">(\\texttt{stmt},w)\\in\\mathcal{L}</span>, and produces a proof <span class="math">\\pi</span>.</li>

      <li><span class="math">b\\leftarrow\\texttt{ver}(\\texttt{crs},\\texttt{stmt},\\pi)</span>: Takes in a <span class="math">\\texttt{crs}</span>, a statement <span class="math">\\texttt{stmt}</span>, and a proof <span class="math">\\pi</span>, and outputs <span class="math">0</span> or <span class="math">1</span>, denoting accept or reject.</li>

      <li><span class="math">(\\overline{\\texttt{crs}},\\tau)\\leftarrow\\overline{\\texttt{gen}}(1^{\\lambda},\\mathcal{L})</span>: Generates a simulated common reference string <span class="math">\\overline{\\texttt{crs}}</span> and a trapdoor <span class="math">\\tau</span>.</li>

      <li><span class="math">\\pi\\leftarrow\\overline{\\texttt{prove}}(\\overline{\\texttt{crs}},\\tau,\\texttt{stmt})</span>: Uses trapdoor <span class="math">\\tau</span> to produce a proof <span class="math">\\pi</span> without needing a witness.</li>

    </ul>

    <h4 id="sec-128" class="text-lg font-semibold mt-6">Perfect completeness.</h4>

    <p class="text-gray-300">A non-interactive proof system is said to be perfectly complete, if an honest prover with a valid witness can always convince an honest verifier. More formally, for any <span class="math">(\\texttt{stmt},w)\\in\\mathcal{L}</span>, we have that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\texttt{~{}crs}\\leftarrow\\texttt{setup}(1^{\\lambda},\\mathcal{L}),~{}\\pi\\leftarrow\\texttt{prove}(\\texttt{crs},\\texttt{stmt},w):\\texttt{ver}(\\texttt{crs},\\texttt{stmt},\\pi)=1~{}\\big{]}=1</span></p>

    <h4 id="sec-129" class="text-lg font-semibold mt-6">Computational zero-knowlege.</h4>

    <p class="text-gray-300">Informally, an NIZK system is computationally zero-knowledge if the proof does not reveal any information about the witness to any polynomial-time (or subexponential time resp.) adversary. More formally, a NIZK system is said to have computational zero-knowledge, if for all non-uniform polynomial-time adversary <span class="math">\\mathcal{A}</span> (or subexponential-time <span class="math">\\mathcal{A}</span> resp.),</p>

    <p class="text-gray-300"><span class="math">\\Pr\\big{[}\\texttt{crs}\\leftarrow\\texttt{gen}(1^{\\lambda},\\mathcal{L}):\\mathcal{A}^{\\texttt{prove}(\\texttt{crs},\\cdot,\\cdot)}\\texttt{(crs)}=1\\big{]}\\approx\\Pr\\big{[}(\\overline{\\texttt{crs}},\\tau,\\_)\\leftarrow\\overline{\\texttt{gen}}(1^{\\lambda},\\mathcal{L}):\\mathcal{A}^{\\texttt{prove}_{1}(\\overline{\\texttt{crs}},\\tau,\\cdot,\\cdot)}\\texttt{(crs)}=1\\big{]}</span></p>

    <p class="text-gray-300">In the above, <span class="math">\\texttt{prove}_{1}(\\overline{\\texttt{crs}},\\tau,\\texttt{stmt},w)</span> verifies that <span class="math">(\\texttt{stmt},w)\\in\\mathcal{L}</span>, and if so, outputs <span class="math">\\overline{\\texttt{prove}(\\texttt{crs}},\\tau,\\texttt{stmt})</span> which simulates a proof without knowing a witness. Otherwise, if <span class="math">(\\texttt{stmt},w)\\notin\\mathcal{L}</span>, the experiment aborts.</p>

    <h4 id="sec-130" class="text-lg font-semibold mt-6">Computational soundness.</h4>

    <p class="text-gray-300">We say that a NIZK scheme is computationally sound against any p.p.t. (or subexponential-time resp.) adversary, if for any p.p.t. (or subexponential-time resp.) adversary <span class="math">\\mathcal{A}</span>, it holds that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\Big{[}\\texttt{crs}\\leftarrow\\texttt{gen}(1^{\\lambda},\\mathcal{L}),(\\texttt{stmt},\\pi)\\leftarrow\\mathcal{A}(\\texttt{crs}):\\texttt{ver}(\\texttt{crs},\\texttt{stmt},\\pi)=1\\text{ but }\\texttt{stmt}\\notin\\mathcal{L}\\Big{]}\\approx 0</span></p>

    <h4 id="sec-131" class="text-lg font-semibold mt-6">NP language used in our construction.</h4>

    <p class="text-gray-300">In our construction, we will use the following NP language <span class="math">\\mathcal{L}</span>. A pair <span class="math">(\\texttt{stmt},w)\\in\\mathcal{L}</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>parse <span class="math">\\texttt{stmt}:=(\\eta,c,k_{0},\\mathcal{P},\\texttt{time})</span>, parse <span class="math">w:=(k,r)</span>;</li>

      <li>it holds that <span class="math">c=\\texttt{comm}(k;r)</span> and <span class="math">\\texttt{PRF}_{k}(\\texttt{time})\\oplus\\texttt{PRF}_{k_{0}}(\\mathcal{P},\\texttt{time})=\\eta</span></li>

    </ul>

    <p class="text-gray-300">6.4 Sleepy Consensus with Adaptive Security</p>

    <p class="text-gray-300">Henceforth we use the shorthand <span class="math">\\mathcal{P}.\\mathsf{upk}</span> to mean <span class="math">\\mathcal{F}_{\\mathrm{CA}}.\\mathsf{lookup}(\\mathcal{P})</span>. Specifically, <span class="math">\\mathcal{P}.\\mathsf{upk}</span> can be parsed as <span class="math">\\mathcal{P}.\\mathsf{upk}:=(\\mathsf{pk},c)</span> where <span class="math">\\mathsf{pk}</span> denotes a signature public key, and <span class="math">c</span> corresponds to a perfectly binding commitment of a user’s PRF key.</p>

    <p class="text-gray-300">Valid blocks and valid blockchains are defined in a similar fashion as in the earlierstatically secure scheme — but we need to make minor changes to block format and validity rules to incorporate the fact that now each block carries its own zero-knowledge proof to vouch for its validity.</p>

    <h4 id="sec-132" class="text-lg font-semibold mt-6">Valid blocks.</h4>

    <p class="text-gray-300">We say that a tuple</p>

    <p class="text-gray-300"><span class="math">B:=(h_{-1},\\mathsf{B},\\mathsf{time},\\mathcal{P},\\eta,\\pi,\\sigma,h)</span></p>

    <p class="text-gray-300">is a valid block with respect to the difficulty parameter <span class="math">D_{p}</span> and public parameters <span class="math">\\mathsf{params}</span> iff</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span> is a valid node of the current protocol instance and has registered with <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>;</li>

      <li>Parse <span class="math">\\mathcal{P}.\\mathsf{upk}:=(\\mathsf{pk},\\_)</span>, it holds that <span class="math">\\Sigma.\\mathsf{ver}_{\\mathsf{pk}}((h_{-1},\\mathsf{B},\\mathsf{time},\\pi);\\sigma)=1</span>;</li>

      <li>Parse <span class="math">\\mathcal{P}.\\mathsf{upk}:=(\\_,c)</span>, parse <span class="math">\\mathsf{params}:=(k_{0},\\mathsf{crs})</span>, it holds that <span class="math">\\mathsf{NIZK}.\\mathsf{ver}(\\mathsf{crs},\\mathsf{stmt})=1</span> where <span class="math">\\mathsf{stmt}:=(\\eta,c,k_{0},\\mathcal{P},\\mathsf{time})</span>;</li>

      <li><span class="math">\\eta&lt;D_{p}</span>; and</li>

      <li><span class="math">h=\\mathsf{d}(h_{-1},\\mathsf{B},\\mathsf{time},\\mathcal{P},\\eta,\\pi,\\sigma)</span>, where <span class="math">\\mathsf{d}:\\{0,1\\}^{*}\\to\\{0,1\\}^{\\lambda}</span> is a collision-resistant hash function — technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore <span class="math">\\mathsf{d}</span> is a single function.</li>

    </ol>

    <h4 id="sec-133" class="text-lg font-semibold mt-6">Valid blockchain.</h4>

    <p class="text-gray-300">Let <em>chain</em> denote an ordered chain of real-world blocks, we say that <em>chain</em> is a valid blockchain w.r.t. the difficulty parameter <span class="math">D_{p}</span>, public parameters <span class="math">\\mathsf{params}</span>, and <span class="math">t</span> iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>chain</em><span class="math">[0]=\\textit{genesis}=(\\bot,\\bot,\\mathsf{time}=0,\\bot,\\bot,h=\\vec{0})</span>, commonly referred to as the genesis block;</li>

      <li><em>chain</em><span class="math">[-1].\\mathsf{time}\\leq t</span>; and</li>

      <li>for all <span class="math">i\\in[1..\\ell]</span>, the following holds:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>chain</em><span class="math">[i]</span> is a valid block w.r.t. the difficulty parameter <span class="math">D_{p}</span> and public parameters <span class="math">\\mathsf{params}</span>;</li>

      <li><em>chain</em><span class="math">[i].h_{-1}=\\textit{chain}[i-1].h</span>; and</li>

      <li><em>chain</em><span class="math">[i].\\mathsf{time}&gt;\\textit{chain}[i-1].\\mathsf{time}</span>, i.e., block-times are strictly increasing.</li>

    </ol>

    <h4 id="sec-134" class="text-lg font-semibold mt-6">Protocol description.</h4>

    <p class="text-gray-300">We present our adaptively secure scheme <span class="math">\\Pi_{\\mathrm{sleepy}}^{*}</span> in Figure 4. The main differences from the previous statically secure protocol are the following. As mentioned earlier, each node <span class="math">\\mathcal{P}</span> picks a PRF secret key <span class="math">k[\\mathcal{P}]</span> and registers a commitment <span class="math">c</span> of <span class="math">k[\\mathcal{P}]</span> with the public-key infrastructure <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>. Further, there is a longer random seed <span class="math">k_{0}</span> included in the common reference string. To determine whether a node <span class="math">\\mathcal{P}</span> is elected leader in a given time step <span class="math">t</span>, <span class="math">\\mathcal{P}</span> checks whether <span class="math">\\mathsf{PRF}_{k_{0}}(\\mathcal{P},t)\\oplus\\mathsf{PRF}_{k[\\mathcal{P}]}(t)&lt;D_{p}</span>. If <span class="math">\\mathcal{P}</span> is elected leader, it can extend the chain with a block, and it includes a non-interactive zero-knowledge proof <span class="math">\\pi</span> in the block proving that it computed the leader election function correctly.</p>

    <p class="text-gray-300">Protocol  <span class="math">\\Pi_{\\mathrm{sleepy}}^{*}(p,\\mathrm{params}:= (k_0,\\mathrm{crs}))</span></p>

    <p class="text-gray-300">On input init() from  <span class="math">\\mathcal{Z}</span> :</p>

    <p class="text-gray-300">let  <span class="math">(\\mathsf{pk},\\mathsf{sk}):= \\Sigma .\\mathsf{gen}(1^L)</span>  , let  <span class="math">k\\gets_{\\mathbb{S}}\\{0,1\\}^{L}</span>  , let  <span class="math">c\\coloneqq \\mathsf{comm}(k;r)</span>  for  <span class="math">r\\gets_{\\mathbb{S}}\\{0,1\\}^{L}</span></p>

    <p class="text-gray-300">let chain := genesis, let  <span class="math">\\mathsf{usk} := (\\mathsf{sk}, c, k, r)</span> , register  <span class="math">\\mathsf{upk} := (\\mathsf{pk}, c)</span>  with  <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span> ;</p>

    <p class="text-gray-300">On receive chain':</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">assert  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&gt;</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  and  </span>chain'<span class="math">  is valid w.r.t.  </span>D_p<span class="math"> , params, and the current time  </span>t$ ;</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">chain := chain' and gossip chain</p>

    <p class="text-gray-300">Every time step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>receive input transactions(B) from  <span class="math">\\mathcal{Z}</span></li>

      <li>let  <span class="math">t</span>  be the current time, let  <span class="math">\\mathcal{P}</span>  be the current party's identifier, parse  <span class="math">\\mathsf{usk} := (\\mathsf{sk}, c, k, r)</span> .</li>

      <li>let  <span class="math">\\eta := \\mathsf{PRF}_k(t) \\oplus \\mathsf{PRF}_{k_0}(\\mathcal{P}, t)</span> , if  <span class="math">\\eta &amp;lt; D_p</span> :</li>

    </ul>

    <p class="text-gray-300">let  <span class="math">\\pi := \\mathsf{NIZK.prove}(\\mathsf{crs},\\mathsf{stmt},w)</span>  where  <span class="math">\\mathsf{stmt} := (\\eta, c, k_0, \\mathcal{P}, t)</span> ,  <span class="math">w := (k, r)</span></p>

    <p class="text-gray-300">let  <span class="math">\\sigma := \\Sigma .\\mathrm{sign}_{\\mathrm{sk}}(chain[-1].h,\\mathsf{B},t,\\eta ,\\pi)</span> <span class="math">h^\\prime \\coloneqq \\mathsf{d}(chain[-1].h,\\mathsf{B},t,\\mathcal{P},\\eta ,\\pi ,\\sigma)</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">let  <span class="math">B\\coloneqq (chain[-1].h,\\mathsf{B},t,\\mathcal{P},\\eta ,\\pi ,\\sigma ,h^{\\prime})</span>  , let chain  <span class="math">\\coloneqq</span>  chain</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B and gossip chain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>output extract(chain) to  <span class="math">\\mathcal{Z}</span>  where extract is the function outputs an ordered list containing the B extracted from each block in chain</li>

    </ul>

    <p class="text-gray-300">Figure 4: The sleepy consensus protocol with adaptive security. The common reference string params is generated as follows:  <span class="math">k_{0} \\gets_{\\mathbb{S}} \\{0,1\\}^{L_{0}}</span> , and  <span class="math">\\mathsf{crs} \\gets \\mathsf{NIZK.gen}(1^{L}, \\mathcal{L})</span> .</p>

    <p class="text-gray-300">Compliant executions. We say that a pair  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\mathrm{sleepy}}^{*}(p)</span> -compliant if  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\mathrm{sleepy}}(p)</span> -compliant — except that now we allow  <span class="math">\\mathcal{Z}</span>  to adaptively corrupt nodes and make nodes sleep during the protocol execution. Recall that  <span class="math">\\mathcal{A}</span>  is allowed to register corrupt nodes' public keys with  <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>  after seeing the common reference string.</p>

    <p class="text-gray-300">Parameter choices for cryptographic building blocks. We assume that the PRF function, the collision resistance hash, the signature scheme, and the NIZK have sub-exponential hardness. Throughout this paper, sub-exponential hardness means that except with  <span class="math">2^{-k^{\\delta}}</span>  probability, the cryptographic primitive with input length  <span class="math">k</span>  is secure against any adversary running in time  <span class="math">2^{k^{\\delta}}</span>  for a fixed constant  <span class="math">\\delta &amp;lt; 1</span> . We will use the following parameters:</p>

    <p class="text-gray-300">Each user's PRF key  <span class="math">k</span>  has bit length  <span class="math">L = (2N + \\log^2\\lambda)^{\\frac{1}{\\delta}}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The common reference string  <span class="math">k_{0}</span>  has bit length  <span class="math">L_{0} = (2LN)^{\\frac{1}{\\delta}}</span> ;</li>

      <li>All other cryptographic schemes such as the hash function, the digital signature scheme, and the NIZK have input length  <span class="math">L = (2N + \\log^2\\lambda)^{\\frac{1}{\\delta}}</span> .</li>

    </ul>

    <p class="text-gray-300">Theorem 8 (Security of  <span class="math">\\Pi_{\\mathrm{sleepy}}^*</span>  under adaptive corruption). Assume that the PRF, the collision resistant hash family, and the signature scheme  <span class="math">\\Sigma</span>  all have subexponential security, and that the NIZK is perfectly complete, computational zero-knowledge and computationally sound against subexponential adversaries. Then, for any positive constant  <span class="math">\\epsilon &amp;gt;0</span> , any  <span class="math">0 &amp;lt; p &amp;lt; 1</span> , any p.p.t. pair</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{A},\\mathcal{Z})</span> that is <span class="math">\\Pi^{<em>}_{sleepy}(p)</span>-compliant, there is a constant <span class="math">c</span> such that for any <span class="math">T_{0}\\geq cLN</span>, protocol <span class="math">\\Pi^{</em>}_{sleepy}(p)</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}^{2}</span> consistency w.r.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> where relevant parameters are defined below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter <span class="math">g_{0}=(1-\\epsilon)(1-2pN\\Delta)\\alpha</span>;</li>

      <li>chain growth upper bound parameter <span class="math">g_{1}=(1+\\epsilon)Np</span>; and</li>

      <li>chain quality parameter <span class="math">\\mu=1-\\frac{1-\\epsilon}{1+\\phi}</span>.</li>

    </ul>

    <p class="text-gray-300">where <span class="math">N,\\Delta,\\alpha</span> and <span class="math">\\phi</span> are parameters that can be determined by <span class="math">(\\mathcal{A},\\mathcal{Z})</span> as well as <span class="math">p</span> as mentioned earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be presented in Section 7.</p>

    <h6 id="sec-136" class="text-base font-medium mt-4">Corollary 5 (Adaptively secure state machine replication in the sleepy model.).</h6>

    <p class="text-gray-300">Assume the existence of a Bare PKI, a CRS; the existence of sub-exponentially hard collision-resistant hash functions, and sub-exponentially hard enhanced trapdoor permutations. Then, for any constant <span class="math">\\epsilon&gt;0</span>, there exists a protocol that achieves state machine replication against adaptive corruptions and adaptive sleepiness, as long as <span class="math">\\frac{1}{2}+\\epsilon</span> fraction of awake nodes are honest in any time step.</p>

    <h6 id="sec-137" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward from Theorem 8 and Lemma 1. ∎</p>

    <h6 id="sec-138" class="text-base font-medium mt-4">Remark 2 (A variant of practical interest.).</h6>

    <p class="text-gray-300">Our complexity leveraging makes the security parameter dependent on <span class="math">N</span>, the total number of players. This necessarily means that transaction confirmation will need to wait for <span class="math">\\mathsf{poly}(N)</span> blocks.</p>

    <p class="text-gray-300">We point out a different variant that is of practical interest and which does not incur such blowup in security parameter and transaction confirmation time — this variant is directly implied by our proofs in Section 7. Specifically, if we are willing to assume adaptive sleepiness and static corruption, and assume that the CRS may be chosen after registration of all public keys, then we will not need complexity leveraging, and therefore we can achieve state machine replication with the same protocol as in Figure 4, but with a tight security parameter <span class="math">\\lambda</span> that is independent of <span class="math">N</span>. This also means that the transaction confirmation time is independent of <span class="math">N</span>.</p>

    <h2 id="sec-139" class="text-2xl font-bold">7 Proofs for Adaptive Sleepiness and Adaptive Corruption</h2>

    <p class="text-gray-300">We first describe how to prove security under adaptive sleepiness but static corruption: this will be the more interesting part of the proof, and to achieve this, we will need to rely on complexity leveraging, but in this case how to do complexity leveraging turns out to be rather subtle. Once we are able to do this, we then describe how to leverage additional, standard complexity leveraging techniques (Section 7.4) to upgrade the security to the case of adaptive sleepiness and corruption.</p>

    <h3 id="sec-140" class="text-xl font-semibold mt-8">7.1 Ideal-World Protocol: Adaptive Sleepiness and Static Corruption</h3>

    <p class="text-gray-300">Ideal functionality <span class="math">\\mathcal{F}^{<em>}_{\\mathbf{tree}}</span>. In Figure 5, we modify the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> for static corruption (see Section 5) to <span class="math">\\mathcal{F}^{</em>}_{\\mathrm{tree}}</span>. The main difference between <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span> and <span class="math">\\mathcal{F}^{<em>}_{\\mathrm{tree}}</span> is the highlighted blue line: in <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>, the adversary <span class="math">\\mathcal{A}</span> is allowed to query the ideal functionality to check if anyone (including honest nodes) is elected leader at any time. However, in <span class="math">\\mathcal{F}^{</em>}_{\\mathrm{tree}}</span>, each party can only make such queries for itself. In other words, the adversary <span class="math">\\mathcal{A}</span> can see into the future for corrupt parties but not for honest parties. In our new ideal protocol, the adversary <span class="math">\\mathcal{A}</span> can only learn that an honest party <span class="math">\\mathcal{P}</span> is elected for a time step <span class="math">t</span> when <span class="math">\\mathcal{P}</span> actually announces a valid new block in time step <span class="math">t</span>.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 5: Modified ideal functionality  <span class="math">\\mathcal{F}_{\\mathrm{tree}}^*</span> .</p>

    <p class="text-gray-300">Ideal protocol  <span class="math">\\Pi_{\\mathrm{ideal}}^<em></span> . The ideal protocol  <span class="math">\\Pi_{\\mathrm{ideal}}^</em></span>  is identical to  <span class="math">\\Pi_{\\mathrm{ideal}}</span>  except that now  <span class="math">\\mathcal{F}_{\\mathrm{tree}}</span>  is replaced with  <span class="math">\\mathcal{F}_{\\mathrm{tree}}^*</span> .</p>

    <p class="text-gray-300">Compliant executions: adaptive sleepiness and static corruption. A  <span class="math">\\Pi_{\\mathrm{ideal}}^{<em>}(p)</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  is defined in exactly the same way as a  <span class="math">\\Pi_{\\mathrm{ideal}}^{</em>}(p)</span> -compliant  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  except that now we allow  <span class="math">\\mathcal{Z}</span>  to make nodes sleep adaptively. However, we require that  <span class="math">\\mathcal{Z}</span>  still declares corruptions statically upfront.</p>

    <p class="text-gray-300">Theorem 9 (Security of the protocol  <span class="math">\\Pi_{\\mathrm{ideal}}^*</span>  under adaptive sleepiness and static corruption). For any constant  <span class="math">\\epsilon_0, \\epsilon &amp;gt; 0</span> , any  <span class="math">T_0 \\geq \\epsilon_0 \\lambda</span> ,  <span class="math">\\Pi_{\\mathrm{sleepy}}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span>  consistency against any  <span class="math">\\Pi_{\\mathrm{ideal}}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  with  <span class="math">\\exp(-\\Omega(\\lambda))</span>  failure probability and the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 - \\epsilon)(1 - 2pN\\Delta)\\alpha</span> ;</li>

      <li>chain growth upper bound parameter  <span class="math">g_{1} = (1 + \\epsilon)Np</span> ; and</li>

      <li>chain quality parameter  <span class="math">\\mu = 1 - \\frac{1 - \\epsilon}{1 + \\phi}</span> ;</li>

    </ul>

    <p class="text-gray-300">Proof. Notice that in comparison with  <span class="math">\\Pi_{\\mathrm{ideal}}</span> , here our  <span class="math">\\Pi_{\\mathrm{ideal}}^*</span>  does not allow the adversary to see into future random bits of honest parties, however, we allow the adversary to adaptively make nodes sleep. It is not hard to observe that this change does not matter to the stochastic analysis for the  <span class="math">\\Pi_{\\mathrm{ideal}}</span>  protocol presented in Section 5, and the same proof still holds.</p>

    <p class="text-gray-300">We make a few modifications to the ideal-world protocol  <span class="math">\\Pi_{\\mathrm{ideal}}^*</span> , and introduce the following hybrid protocols.</p>

    <p class="text-gray-300">Hybrid protocol <span class="math">\\Pi_{\\mathbf{hyb}}^{\\langle 1\\rangle}</span>. Recall that in the ideal-world protocol <span class="math">\\Pi_{\\mathrm{ideal}}^{<em>}</span>, the ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{tree}}^{</em>}</span> generates fresh coins to decide of a player is elected leader for a time step. In the hybrid protocol <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>, we modify <span class="math">\\mathcal{F}_{\\mathrm{tree}}^{*}</span> to obtain a new <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> that works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any any time during the protocol execution, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> allows the adversary <span class="math">\\mathcal{A}</span> to specify what <span class="math">k[\\mathcal{P}]</span> value to use for a corrupt party <span class="math">\\mathcal{P}</span> (if one has not been chosen before).</li>

      <li>The function <span class="math">\\mathsf{leader}(\\mathcal{P},t)</span> is implemented as the following instead. On receive <span class="math">\\mathsf{leader}(\\mathcal{P},t)</span> from <span class="math">\\mathcal{P}</span> or internally: If <span class="math">\\Gamma[\\mathcal{P},t]</span> has been populated, return <span class="math">\\Gamma[\\mathcal{P},t]</span>. Else,</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathcal{P}</span> is honest, choose <span class="math">\\Gamma[\\mathcal{P},t]</span> at random as before, and return <span class="math">\\Gamma[\\mathcal{P},t]</span>.</li>

      <li>else if <span class="math">\\mathcal{P}</span> is corrupt: if <span class="math">\\mathcal{A}</span> has not registered <span class="math">k[\\mathcal{P}]</span> with <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>, return <span class="math">0</span> (and without populating table <span class="math">\\Gamma</span>); else let <span class="math">\\Gamma[\\mathcal{P},t]:=(\\mathsf{H}(\\mathcal{P},t)\\oplus\\mathsf{PRF}_{k[\\mathcal{P}]}(t)&lt;D_{p})</span> where <span class="math">\\mathsf{H}</span> denotes a random function, and return <span class="math">\\Gamma[\\mathcal{P},t]</span>.</li>

      <li><span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> is otherwise identical to <span class="math">\\mathcal{F}_{\\mathrm{tree}}^{*}</span>.</li>

    </ul>

    <p class="text-gray-300">The protocol <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> is identical to <span class="math">\\Pi_{\\mathrm{ideal}}^{<em>}</span> except that the players interact with the new <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> instead of <span class="math">\\mathcal{F}_{\\mathrm{tree}}^{</em>}</span>. We say that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> is <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}(p)</span>-compliant iff the pair is <span class="math">\\Pi_{\\mathrm{ideal}}^{*}(p)</span>-compliant.</p>

    <p class="text-gray-300">Note that the main difference between <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> and <span class="math">\\Pi_{\\mathrm{ideal}}^{*}</span> is the following: in <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>, corrupt nodes can influence the choice of the coins used to decide whether corrupt nodes are leaders, by setting the values of <span class="math">k[\\mathcal{P}]</span>. In particular, the adversary can choose the values of <span class="math">k[\\mathcal{P}]</span> after querying <span class="math">\\mathsf{H}(\\mathcal{P},\\_)</span> for varying <span class="math">t</span>’s for any corrupt party <span class="math">\\mathcal{P}</span>. Below, we argue that despite this ability, since the number of bits <span class="math">\\vec{k}_{\\mathrm{corrupt}}:=\\{k[\\mathcal{P}]:\\mathcal{P}\\ \\mathrm{corrupt}\\}</span> that can be controlled by the adversary is small, there is still a significantly large fraction of random strings <span class="math">\\mathsf{H}</span> that are good even for the worst-case choice of <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>.</p>

    <h6 id="sec-142" class="text-base font-medium mt-4">Claim 1 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>).</h6>

    <p class="text-gray-300">For any <span class="math">T_{0}\\geq cLN</span> where <span class="math">c</span> is an appropriate constant, protocol <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> satisfies <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}^{2}</span> consistency against any <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>-compliant, computationally unbounded pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, where <span class="math">g_{0},g_{1},\\mu</span> are defined in the same way as in Theorem 9, and moreover, with security failure probability <span class="math">\\exp(-\\Omega(LN))</span>.</p>

    <h6 id="sec-143" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We abuse notation and sometimes use <span class="math">\\mathsf{H}</span> to denote the random string generated by <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span>. We use the notation <span class="math">\\upsilon</span> to denote the random bits <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1\\rangle}</span> generated to decide whether honest nodes are elected leaders.</p>

    <p class="text-gray-300">Given a fixed <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, we say that the random string <span class="math">(\\mathsf{H},\\upsilon)</span> is good for <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, if in any view consistent with <span class="math">\\mathsf{H},\\upsilon</span>, and <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, no bad events related to <span class="math">(T_{0},g_{0},g_{1})</span>-chain growth, <span class="math">(T_{0},\\mu)</span>-chain quality, and <span class="math">T_{0}^{2}</span>-consistency occur where the paramters <span class="math">T_{0},g_{0},g_{1},\\mu</span> are as given in the theorem statement. In other words, <span class="math">(\\mathsf{H},\\upsilon)</span> is good for <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span> if the combination of <span class="math">\\mathsf{H},\\upsilon</span>, and <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span> does not permit any bad events.</p>

    <p class="text-gray-300">Due to Theorem 9, for every fixed <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span> and an appropriate choice of <span class="math">c</span>, all but <span class="math">e^{-LN}</span> fraction of random strings <span class="math">(\\mathsf{H},\\upsilon)</span> are good for <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>.</p>

    <p class="text-gray-300">Now by union bound over the choice of <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, we conclude that at least <span class="math">1-e^{-LN}\\cdot 2^{LN}</span> fraction of random strings <span class="math">(\\mathsf{H},\\upsilon)</span> are good for all choices of <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>. ∎</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Hybrid protocol <span class="math">\\Pi_{\\mathbf{hyb}}^{(2)}</span>. Almost identical to <span class="math">\\Pi_{\\mathrm{hyb}}^{(1)}</span> except that now, the new ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(2)}</span> generates a random PRF key <span class="math">k_{0}</span>, discloses it to <span class="math">\\mathcal{A}</span>; and further <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(2)}</span> replaces calls to the random function <span class="math">\\mathsf{H}(\\_,\\_)</span> with calls to <span class="math">\\mathsf{PRF}_{k_{0}}(\\_,\\_)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Claim 2 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{(2)}</span>).</strong> Suppose that the PRF function with input length <span class="math">k</span> is secure against all <span class="math">2^{k^{\\delta}}</span>-time adversaries for some fixed constant <span class="math">\\delta &amp;lt; 1</span>. Suppose that <span class="math">L \\geq \\log^2 \\lambda</span>, $L_0 :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq (2LN)^{\\frac{1}{\\delta}}<span class="math">. Then, for any </span>T_0 \\geq cLN<span class="math"> where </span>c<span class="math"> is an appropriate constant, protocol </span>\\Pi_{\\mathrm{hyb}}^{(2)}<span class="math"> satisfies </span>(T_0, g_0, g_1)<span class="math">-chain growth, </span>(T_0, \\mu)<span class="math">-chain quality, and </span>T_0^2<span class="math"> consistency against any </span>\\Pi_{\\mathrm{hyb}}^{(2)}<span class="math">-compliant, computationally unbounded pair </span>(\\mathcal{A}, \\mathcal{Z})<span class="math">, where </span>g_0, g_1, \\mu<span class="math"> are defined in the same way as in Theorem 9, and moreover with security failure probability </span>\\exp(-\\Omega(LN))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Proof.</strong> Given a random or pseudorandom string <span class="math">r \\in \\{0,1\\}^{\\mathsf{poly}(\\lambda, N)}</span> either sampled at random from <span class="math">\\mathsf{H}(\\cdot)</span>, or generated from <span class="math">\\mathsf{PRF}_{k_0}(\\cdot)</span> for a randomly chosen <span class="math">k_0</span>, and a random string <span class="math">\\upsilon</span> corresponding to randomness used for honest leader election, and a fixed <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, there is an algorithm running in time <span class="math">\\mathsf{poly}(\\lambda, N)</span> that checks if <span class="math">(r, \\upsilon)</span> is good for <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>.</p>

    <p class="text-gray-300">Therefore, given <span class="math">(r,\\upsilon)</span>, there is an algorithm running in time <span class="math">\\mathsf{poly}(\\lambda,N) \\cdot 2^{LN}</span> that can check if <span class="math">(r,\\upsilon)</span> is good for all <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>. Specifically, this algorithm brute-force enumerates all possible <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>, and checks if <span class="math">(r,\\upsilon)</span> is good for every <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span>.</p>

    <p class="text-gray-300">When the PRF's input length <span class="math">L_0 = (2LN)^{\\frac{1}{\\delta}}</span>, clearly the above algorithm runs in time that is subexponential in the PRF's input length. Due to the subexponential hardness of PRF, it holds that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp;amp; \\Pr \\left[ k_0 \\leftarrow_{\\S} \\{0, 1\\}^{L_0}, r \\leftarrow \\mathsf{PRF}_{k_0}(\\cdot), \\upsilon \\leftarrow_{\\S} \\{0, 1\\}^{\\mathsf{poly}(N, \\lambda)}: (r, \\upsilon) \\text{ good for every } \\vec{k}_{\\mathrm{corrupt}} \\right] \\right. \\\\ &amp;amp; \\leq \\Pr \\left[ r \\leftarrow_{\\S} \\mathsf{H}, \\upsilon \\leftarrow_{\\S} \\{0, 1\\}^{\\mathsf{poly}(N, \\lambda)}: (r, \\upsilon) \\text{ good for every } \\vec{k}_{\\mathrm{corrupt}} \\right] - 2^{-L_0^{\\delta}} \\end{aligned}</span></div>

    <p class="text-gray-300">Since otherwise, one can easily construct a reduction, such that when given a string <span class="math">r</span>, the reduction generates a random <span class="math">\\upsilon</span>, and calls the above algorithm to check if <span class="math">(r, \\upsilon)</span> is good for all <span class="math">\\vec{k}_{\\mathrm{corrupt}}</span> — in this way, the reduction can effectively distinguish whether <span class="math">r</span> is truly random or pseudorandom, and thus break the security of the PRF.</p>

    <p class="text-gray-300"><span class="math">\\square</span></p>

    <p class="text-gray-300">Hybrid protocol <span class="math">\\Pi_{\\mathbf{hyb}}^{(3)}</span>. <span class="math">\\Pi_{\\mathrm{hyb}}^{(3)}</span> is almost the same as <span class="math">\\Pi_{\\mathrm{hyb}}^{(2)}</span>, except now the ideal functionality computes honest parties' random strings using pseudorandomness too, whereas earlier in <span class="math">\\Pi_{\\mathrm{hyb}}^{(2)}</span>, the ideal functionality uses true randomness when deciding if honest parties are leaders.</p>

    <p class="text-gray-300">More formally, in <span class="math">\\Pi_{\\mathrm{hyb}}^{(3)}</span>, we modify the ideal functionality to obtain a new ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(3)}</span> that works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>During initialization, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(3)}</span> generates a fresh <span class="math">k[\\mathcal{P}] \\leftarrow_{\\S} \\{0,1\\}^{L}</span> for every honest player <span class="math">\\mathcal{P}</span>.</li>

      <li>Next, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(3)}</span> generates a random seed <span class="math">k_0 \\leftarrow_{\\S} \\{0,1\\}^{L_0}</span>, and discloses <span class="math">k_0</span> to the adversary <span class="math">\\mathcal{A}</span>.</li>

      <li>At any time during the protocol execution, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(3)}</span> allows the adversary <span class="math">\\mathcal{A}</span> to specify what <span class="math">k[\\mathcal{P}]</span> value to use for a corrupt party <span class="math">\\mathcal{P}</span> (if one has not been chosen before).</li>

      <li>The function <span class="math">\\mathsf{leader}(\\mathcal{P}, t)</span> is implemented as the following instead. On receive <span class="math">\\mathsf{leader}(\\mathcal{P}, t)</span> from <span class="math">\\mathcal{P}</span> or internally: If <span class="math">\\Gamma[\\mathcal{P}, t]</span> has been populated, return <span class="math">\\Gamma[\\mathcal{P}, t]</span>. Else,</li>

    </ul>

    <p class="text-gray-300">44</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">\\mathcal{P}</span> is corrupt and <span class="math">\\mathcal{A}</span> has not registered <span class="math">k[\\mathcal{P}]</span> with <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span>, then return 0 without populating the <span class="math">\\Gamma</span> table;</li>

      <li>else, compute <span class="math">\\eta := \\mathsf{PRF}_{k_0}(\\mathcal{P}, t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t)</span>, populate the table <span class="math">\\Gamma[\\mathcal{P}, t] := (\\eta &amp;lt; D_p)</span>, notify <span class="math">\\mathcal{A}</span> of the tuple <span class="math">(\\mathcal{P}, t, \\eta)</span> and return <span class="math">\\Gamma[\\mathcal{P}, t]</span>.</li>

      <li><span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span> is otherwise identical to <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span>.</li>

    </ul>

    <p class="text-gray-300">Recall that we use <span class="math">L</span> to denote the input length of each player's PRF and all other cryptographic primitives. We now have the following claim.</p>

    <p class="text-gray-300"><strong>Claim 3 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span> under adaptive sleepiness and static corruption).</strong> Assume that the PRF is subexponentially hard. Then, if there is a <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span>-compliant <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> running in time subexponential in <span class="math">L</span> that can cause bad events related to chain growth, quality, or consistency to happen with probability <span class="math">\\epsilon</span> in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>, then there exists a <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 2\\rangle}</span>-compliant <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> that can cause the same bad events to happen in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{\\langle 2\\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span> with probability <span class="math">\\epsilon - 2^{-L^{\\delta}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By straightforward reduction to the subexponential security of PRF — in particular, we can have a sequence of hybrids and replace each honest nodes' random coins one by one with pseudorandom bits.</p>

    <p class="text-gray-300"><strong>Hybrid protocol <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span>.</strong> <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> is almost identical to <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span> except that now, we modify the ideal functionality slightly as follows and obtain <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>During initialization, the new <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> will honestly compute commitments <span class="math">k[\\mathcal{P}]</span> for every honest node <span class="math">\\mathcal{P}</span>, and send the committed value to <span class="math">\\mathcal{A}</span>.</li>

      <li>During initialization, the new <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> will call <span class="math">\\mathsf{crs} \\gets \\mathsf{gen}(1^L, \\mathcal{L})</span> and send <span class="math">\\mathsf{crs}</span> to the adversary <span class="math">\\mathcal{A}</span>.</li>

      <li>The new <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> allows <span class="math">\\mathcal{A}</span> to additionally query <span class="math">\\mathsf{nizk}(\\mathcal{P}, t&#x27;)</span> at time <span class="math">t &amp;gt; t&#x27;</span> and for an honest party <span class="math">\\mathcal{P}</span>. Upon such a query, if <span class="math">\\mathcal{P}</span> was not elected a leader in time <span class="math">t&#x27;</span>, return <span class="math">\\bot</span>. Otherwise, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> computes <span class="math">\\eta := \\mathsf{PRF}_{k[\\mathcal{P}]}(t&#x27;) \\oplus \\mathsf{PRF}_{k_0}(\\mathcal{P}, t&#x27;)</span>, and <span class="math">\\pi := \\mathsf{NIZK.prove}(\\mathsf{crs}, \\mathsf{stmt}, w)</span> where <span class="math">\\mathsf{stmt} := (\\eta, c[\\mathcal{P}], k_0, \\mathcal{P}, t&#x27;)</span>, <span class="math">w := (k[\\mathcal{P}], r[\\mathcal{P}])</span>, and sends <span class="math">\\eta, \\pi</span> to <span class="math">\\mathcal{A}</span>. In the above, <span class="math">k[\\mathcal{P}]</span> is the honest party's key chosen for <span class="math">\\mathcal{P}</span> by <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span>, <span class="math">c[\\mathcal{P}]</span> was the commitment for party <span class="math">\\mathcal{P}</span> computed by <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> and revealed to <span class="math">\\mathcal{A}</span>, and <span class="math">r[\\mathcal{P}]</span> was the randomness used in this commitment.</li>

    </ul>

    <p class="text-gray-300"><strong>Claim 4 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span> under adaptive sleepiness and static corruption).</strong> Assume that the commitment scheme is hiding both against subexponential adversaries, and the NIZK scheme satisfies computational zero-knowledge against subexponential adversaries. Then, if there is a <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 4\\rangle}</span>-compliant <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> running in time subexponential in <span class="math">L</span> that can cause bad events related to chain growth, quality, or consistency to happen with probability <span class="math">\\epsilon</span> in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{\\langle 4\\rangle}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>, then there exists a subexponential, <span class="math">\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}</span>-compliant <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span> that can cause the same bad events to happen in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{\\langle 3\\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span> with probability <span class="math">\\epsilon - 2^{-L^{\\delta}}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> By straightforward reduction to the hiding property of the commitment scheme and the computational zero-knowledge property of the zero-knowledge proof against subexponential adversaries.</p>

    <p class="text-gray-300">45</p>

    <p class="text-gray-300">Hybrid protocol <span class="math">\\Pi_{\\mathbf{hyb}}^{(5)}</span>. <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span> is almost identical to <span class="math">\\Pi_{\\mathrm{hyb}}^{(4)}</span> except with the following changes (we call the new ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span> in <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span>):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Instead of having <span class="math">\\mathcal{A}</span> register <span class="math">k[\\mathcal{P}]</span> with <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span> for a corrupt party <span class="math">\\mathcal{P}</span>, we now have <span class="math">\\mathcal{A}</span> register <span class="math">(k[\\mathcal{P}],r[\\mathcal{P}],c[\\mathcal{P}])</span> with <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span> (if such a tuple has not been chosen before) such that <span class="math">c[\\mathcal{P}]=\\mathsf{com}(k[\\mathcal{P}];r[\\mathcal{P}])</span>.</li>

      <li>Whenever <span class="math">\\mathcal{A}</span> or <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span> internall calls <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span>. leader<span class="math">(\\mathcal{P},t)</span> on for a corrupt party <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{(5)}</span> performs the following:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{A}</span> has earlier supplied i) a tuple <span class="math">(k[\\mathcal{P}],r[\\mathcal{P}],c[\\mathcal{P}])</span> for corrupt party <span class="math">\\mathcal{P}</span>, ii) a value <span class="math">\\eta&lt;D_{p}</span>, and iii) a valid NIZK proof <span class="math">\\pi</span> for the statement <span class="math">\\mathsf{stmt}:=(\\eta,c[\\mathcal{P}],k_{0},\\mathcal{P},t)</span>, then if <span class="math">w=(k[\\mathcal{P}],r[\\mathcal{P}])</span> is not a valid witness for <span class="math">\\mathsf{stmt}</span>, abort outputting soundness-failure; else return 1.</li>

      <li>In all other cases, return 0.</li>

    </ol>

    <p class="text-gray-300">Claim 5 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span> under adaptive sleepiness and static corruption). If there is a <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> running in time subexponential in <span class="math">L</span> that can cause bad events related to chain growth, quality, or consistency to happen with probability <span class="math">\\epsilon</span> in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{(5)}}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, then there exists a subexponential, <span class="math">\\Pi_{\\mathrm{hyb}}^{(4)}</span>-compliant <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> that can cause the same bad events to happen in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{(4)}}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\lambda)</span> with probability <span class="math">\\epsilon</span>.</p>

    <h6 id="sec-144" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is trivial. ∎</p>

    <p class="text-gray-300">Hybrid protocol <span class="math">\\Pi_{\\mathbf{hyb}}^{<em>}</span>. <span class="math">\\Pi_{\\mathrm{hyb}}^{</em>}</span> is almost identical to <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span> except that the new ideal functionality <span class="math">\\mathcal{F}_{\\mathrm{tree}}^{*}</span> does not check for soundness-failure, and the adversary <span class="math">\\mathcal{A}</span> only registers <span class="math">c[\\mathcal{P}]</span> for corrupt party <span class="math">\\mathcal{P}</span> without having to explain the commitment with <span class="math">k[\\mathcal{P}],r[\\mathcal{P}]</span>.</p>

    <p class="text-gray-300">Claim 6 (Security of <span class="math">\\Pi_{\\mathrm{hyb}}^{<em>}</span> under adaptive sleepiness and static corruption). Assume that the commitment scheme is perfectly binding and that the NIZK scheme satisfies computational soundness against subexponential adversaries. Then, if there is a <span class="math">\\Pi_{\\mathrm{hyb}}^{</em>}</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span> running in time subexponential in <span class="math">L</span> that can cause bad events related to chain growth, quality, or consistency to happen with probability <span class="math">\\epsilon</span> in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{*}}(\\mathcal{A},\\mathcal{Z},\\lambda)</span>, then there exists a subexponential, <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span>-compliant <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> that can cause the same bad events to happen in <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathrm{hyb}}^{(5)}}(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime},\\lambda)</span> with probability <span class="math">\\epsilon-2^{-L^{\\delta}}</span>.</p>

    <h6 id="sec-145" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">First, we show that <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span> does not abort with soundness-failure except with <span class="math">2^{-L^{\\delta}}</span> probability. Since the commitment scheme is perfectly binding, if there is a valid witness, it must be <span class="math">(k[\\mathcal{P}],r[\\mathcal{P}])</span>. Therefore, if <span class="math">(k[\\mathcal{P}],r[\\mathcal{P}])</span> is not a valid witness then the statement must be false; but if <span class="math">\\mathcal{A}</span> can forge a valid NIZK proof for such a statement with more than <span class="math">2^{-L^{\\delta}}</span> probability, we can easily build a reduction that breaks the computational soundness of the NIZK.</p>

    <p class="text-gray-300">Due to the above, we may consider a version of <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{<em>}</span> does not check for soundness-failure but <span class="math">\\mathcal{A}</span> still submits a valid explanation <span class="math">k[\\mathcal{P}],r[\\mathcal{P}]</span> along with <span class="math">c[\\mathcal{P}]</span>. Since soundness-failure happens only with <span class="math">2^{-L^{\\delta}}</span> failure probability, for any <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, any bad event (related to chain quality, chain growth, or consistency) that happens in <span class="math">\\Pi_{\\mathrm{hyb}}^{(5)}</span> with probability <span class="math">\\epsilon</span> can happen with probability at most <span class="math">\\epsilon+2^{-L^{\\delta}}</span> here. Now, since <span class="math">k[\\mathcal{P}],r[\\mathcal{P}]</span> is never used by <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{</em>}</span>, we do not require <span class="math">\\mathcal{A}</span> to submit <span class="math">k[\\mathcal{P}],r[\\mathcal{P}]</span>, and this should not affect the probability of any bad event (related to chain growth, quality, or consistency).</p>

    <p class="text-gray-300">7.3 The Real World Emulates the Hybrid World</p>

    <p class="text-gray-300">Simulator construction. We construct the following simulator <span class="math">\\mathcal{S}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>In the beginning, the simulator <span class="math">\\mathcal{S}</span> learns from <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^*</span> the value of <span class="math">k_0</span>, NIZK.crs, as well as commitments of <span class="math">k[\\mathcal{P}]</span> for every honest node <span class="math">\\mathcal{P}</span>. The simulator sets <span class="math">\\mathsf{params} := (k_0, \\mathsf{NIZK.crs})</span> as the common reference string, and supplies it to <span class="math">\\mathcal{A}</span> any time upon query.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each honest node <span class="math">\\mathcal{P}</span>, the simulator <span class="math">\\mathcal{S}</span> chooses a signing key pair <span class="math">(\\mathsf{pk}[\\mathcal{P}], \\mathsf{sk}[\\mathcal{P}])</span> honestly.</li>

    </ul>

    <p class="text-gray-300">The simulator simulates <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>. At the start of the execution, for each honest party <span class="math">\\mathcal{P}</span>: the simulator and registers <span class="math">(\\mathsf{pk}[\\mathcal{P}], c[\\mathcal{P}])</span> on behalf of <span class="math">\\mathcal{P}</span> with the internally simulated <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>, where <span class="math">\\mathsf{pk}[\\mathcal{P}]</span> was chosen earlier by <span class="math">\\mathcal{S}</span> and <span class="math">c[\\mathcal{P}]</span> denotes the commitment <span class="math">\\mathcal{S}</span> received earlier from <span class="math">\\mathcal{F}_{\\mathrm{tree}}^*</span> for honest party <span class="math">\\mathcal{P}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\mathcal{A}</span> tries to register the pair <span class="math">(\\mathsf{pk}[\\mathcal{P}], c[\\mathcal{P}])</span> with <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span> on behalf of corrupt party <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{S}</span> simply forwards the request to the simulated <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span> and registers <span class="math">c[\\mathcal{P}]</span> with <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^*</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{S}</span> keeps track of the "real-world" chain for every honest node <span class="math">\\mathcal{P}</span>. Whenever it sends chain to <span class="math">\\mathcal{A}</span> on behalf of an honest <span class="math">\\mathcal{P}</span>, it updates this state for node <span class="math">\\mathcal{P}</span>. Whenever <span class="math">\\mathcal{A}</span> sends chain to honest node <span class="math">\\mathcal{P}</span>, it may also update <span class="math">\\mathcal{P}</span>'s state in ways to be described later.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever <span class="math">\\mathcal{A}</span> sends chain on behalf of corrupt party <span class="math">\\mathcal{P}&#x27;</span> to honest node <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{S}</span> checks the (real-world) validity of chain w.r.t. params and the current state of <span class="math">\\mathcal{F}_{\\mathrm{CA}}</span>. If the check fails, the simulator simply ignores this message. Otherwise, do the following.</li>

    </ul>

    <p class="text-gray-300">(a) If chain is longer than the current real-world chain for the honest recipient <span class="math">\\mathcal{P}</span>, <span class="math">\\mathcal{S}</span> saves chain as the new real-world chain for <span class="math">\\mathcal{P}</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(b) Let chain := extract(chain), and let chain[: <span class="math">\\ell</span>] <span class="math">\\prec</span> chain be the longest prefix such that <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^*</span>. verify(chain[: <span class="math">\\ell</span>]) = 1. The simulator checks to see if there exists a block in chain[<span class="math">\\ell + 1</span> :] signed by an honest <span class="math">\\mathcal{P}</span>. If so, abort outputting sig-failure. Else, for each $j \\in [\\ell + 1,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">]$,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(i) Let <span class="math">\\mathcal{P}^<em> := \\text{chain}[j].\\mathcal{P}</span>, let <span class="math">t^</em> := \\text{chain}[j].\\text{time}</span>, <span class="math">\\pi := \\text{chain}[j].\\pi</span>, and <span class="math">\\eta := \\text{chain}[j].\\eta</span>.</p>

    <p class="text-gray-300">(ii) Note that since the chain verifies it must be the case that <span class="math">\\mathcal{A}</span> has registered <span class="math">(\\mathsf{pk}[\\mathcal{P}^<em>], c[\\mathcal{P}^</em>])</span> with <span class="math">\\mathcal{S}</span>. Now, <span class="math">\\mathcal{S}</span> supplies <span class="math">\\pi</span> to <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^<em></span> for the statement <span class="math">\\mathsf{stmt} := (\\eta, c[\\mathcal{P}^</em>], k_0, \\mathcal{P}^<em>, t^</em>)</span>.</p>

    <p class="text-gray-300">(iii) <span class="math">\\mathcal{S}</span> then calls <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^<em></span>. extend(chain[: <span class="math">j - 1</span>], chain[<span class="math">j</span>], <span class="math">t^</em></span>) on behalf of corrupt party <span class="math">\\mathcal{P}^*</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Whenever an honest node <span class="math">\\mathcal{P}</span> sends chain to <span class="math">\\mathcal{S}</span>, <span class="math">\\mathcal{S}</span> looks up the current real-world state chain for node <span class="math">\\mathcal{P}</span>. The simulator now computes a new chain using the real-world algorithm: let <span class="math">\\mathsf{usk} := (\\mathsf{sk}, c, \\rightarrow, \\rightarrow)</span> be the secret key for the node <span class="math">\\mathcal{P}</span>, let <span class="math">t</span> be the current time, and let <span class="math">\\mathsf{B} := \\mathsf{chain}[-1]</span>.</li>

    </ul>

    <p class="text-gray-300">let <span class="math">(\\eta, \\pi) := \\mathcal{F}_{\\mathrm{hyb}}^*</span>. nizk<span class="math">(\\mathcal{P}, t)</span>.</p>

    <p class="text-gray-300">let <span class="math">\\sigma := \\Sigma</span>. <span class="math">\\mathsf{sign}_{\\mathsf{sk}}(\\text{chain}[-1].h, \\mathsf{B}, t, \\eta, \\pi)</span>, <span class="math">h&#x27; := \\mathsf{d}(\\text{chain}[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\eta, \\pi, \\sigma)</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">let <span class="math">B := (\\text{chain}[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\eta, \\pi, \\sigma, h&#x27;)</span>, let $\\text{chain}' := \\text{chain}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">B$ and gossip chain.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Now, the simulator <span class="math">\\mathcal{S}</span> sends chain' to <span class="math">\\mathcal{A}</span>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At any point of time, if <span class="math">\\mathcal{S}</span> observes two different (real-world) valid chains that contain identical (real-world) blocks, abort outputting duplicate-block-failure.</li>

    </ul>

    <p class="text-gray-300">47</p>

    <h4 id="sec-146" class="text-lg font-semibold mt-6">Indistinguishability.</h4>

    <p class="text-gray-300">We now prove that the simulated execution and the real-world executions are computationally indistinguishable.</p>

    <h6 id="sec-147" class="text-base font-medium mt-4">Fact 10.</h6>

    <p class="text-gray-300">Assume that the collision resistant hash function and the signature scheme are secure. The simulated execution never aborts with duplicate-block-failure or sig-failure except with negligible probability.</p>

    <h6 id="sec-148" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Same as the proofs of Facts 7 and 8. If the above bad events happen with non-negligible probability, we can construct a polynomial-time reduction that breaks the collision resistance of the hash family or the signature scheme. ∎</p>

    <h6 id="sec-149" class="text-base font-medium mt-4">Fact 11.</h6>

    <p class="text-gray-300">Conditioned on no duplicate-block-failure and no sig-failure the simulated execution is identically distributed as the real execution from the view of <span class="math">\\mathcal{Z}</span>.</p>

    <h6 id="sec-150" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Straightforward to observe. In particular, we point out that whenever <span class="math">\\mathcal{S}</span> receives a valid <em>chain</em> from <span class="math">\\mathcal{A}</span>, either <span class="math">\\textsf{extract}(chain)</span> is already in <span class="math">\\mathcal{F}^{<em>}_{\\textsf{hyb}}</span> or the simulator <span class="math">\\mathcal{S}</span> must succeed in adding <span class="math">\\textsf{extract}(chain)</span> to <span class="math">\\mathcal{F}^{</em>}_{\\textsf{hyb}}</span>. ∎</p>

    <h3 id="sec-151" class="text-xl font-semibold mt-8">7.4 Proofs for Adaptive Sleepiness and Adaptive Corruption</h3>

    <p class="text-gray-300">So far, we have proved security under static corruption but adaptive sleepiness. Now, we would like to prove security under adaptive corruption — here rely on standard complexity leveraging techniques.</p>

    <p class="text-gray-300">Our earlier proof shows the following: if there is a real-world p.p.t. <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that statically corrupts nodes and can break the security properties of <span class="math">\\Pi^{*}_{\\text{sleepy}}</span>, then we can construct a p.p.t. reduction that interacts with <span class="math">(\\mathcal{A},\\mathcal{Z})</span> and breaks either the security of either the PRF, the hash function, the NIZK, or the digital signature scheme.</p>

    <p class="text-gray-300">Now, suppose we have an adaptive adversary <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span> that can break the security properties of <span class="math">\\Pi^{<em>}_{\\text{sleepy}}</span> with probability <span class="math">\\epsilon=\\frac{1}{\\textsf{poly}(\\lambda,N)}</span>. We can construct a static adversary <span class="math">(\\mathcal{A},\\mathcal{Z})</span> that makes random guesses as to what <span class="math">(\\mathcal{A}^{\\prime},\\mathcal{Z}^{\\prime})</span>. If the guess turns out to be wrong later, <span class="math">(\\mathcal{A},\\mathcal{Z})</span> simply aborts. Such a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair can break the security properties of <span class="math">\\Pi^{</em>}_{\\text{sleepy}}</span> with probability <span class="math">\\frac{\\epsilon}{2^{N}}</span> since <span class="math">(\\mathcal{A},\\mathcal{Z})</span> can guess correctly with probability <span class="math">2^{-N}</span>. It holds that <span class="math">(\\mathcal{A},\\mathcal{Z})</span> must be able to break either the PRF, the hash function, the NIZK, or the digital signature scheme with probability <span class="math">\\frac{\\epsilon}{2^{N}}</span>. Therefore, if we choose the security parameter of these cryptographic schemes to be <span class="math">L:=(2N+\\log^{2}\\lambda)^{\\frac{1}{2}}</span>, we have that <span class="math">\\textsf{poly}(\\lambda,N)\\cdot 2^{N}\\ll 2^{((2N+\\log^{2}\\lambda)^{\\frac{1}{2}})^{\\delta}}+\\exp(-\\Omega(LN))</span>, then this should not be possible by our subexponential hardness assumptions.</p>

    <h2 id="sec-152" class="text-2xl font-bold">8 Lower Bounds</h2>

    <h3 id="sec-153" class="text-xl font-semibold mt-8">8.1 Lower Bound on Resilience</h3>

    <p class="text-gray-300">We show that in the sleepy model, honest majority (among awake nodes) is necessary for achieving consensus. Intuitively, imagine that there is a sleepy node who sleeps from protocol start to some time <span class="math">t^{*}</span> at which point it wakes up. If there are more corrupt nodes than alert ones, the adversary can always simulate a fake execution trace that is identically distributed as the real one; and now the sleepy node that just woke up cannot discern which one is real and which one simulated.</p>

    <h6 id="sec-154" class="text-base font-medium mt-4">Theorem 10 (Majority honest is necessary).</h6>

    <p class="text-gray-300">In the sleepy execution model, it is not possible to realize state machine replication if there can be as many corrupt nodes than alert nodes — and this</p>

    <p class="text-gray-300">lower bound holds even assuming static corruption and the existence of a public-key infrastructure.</p>

    <h6 id="sec-155" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For any protocol that achieves liveness (or in the case of blockchains, chain growth), there exists a <span class="math">(\\mathcal{A},\\mathcal{Z})</span> pair that can break consistency with constant probability if there are as many corrupt nodes as alert ones:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At the beginning of protocol execution, <span class="math">\\mathcal{Z}</span> spawns <span class="math">k</span> alert nodes, and <span class="math">k</span> corrupt ones as well. Additionally, <span class="math">\\mathcal{Z}</span> spawns a sleepy node denoted <span class="math">i^{<em>}</span> and makes it sleep from protocol start to some future time <span class="math">t^{</em>}</span>.</li>

      <li>When protocol execution starts, <span class="math">\\mathcal{A}</span> first has all corrupt nodes remain silent and not participate in the actual protocol execution;</li>

      <li>However, <span class="math">\\mathcal{A}</span> simulates a protocol execution with the <span class="math">k</span> corrupt nodes. Suppose that <span class="math">\\mathcal{Z}</span> generates transaction inputs following some distribution <span class="math">\\mathcal{D}</span> for the real execution. Now <span class="math">\\mathcal{A}</span> uses the same distribution to generate simulated transactions for the simulated execution. We henceforth assume that two random samples from <span class="math">\\mathcal{D}</span> are different with constant probability.</li>

      <li>When the sleepy node <span class="math">i^{<em>}</span> wakes up at time <span class="math">t^{</em>}</span>, <span class="math">\\mathcal{A}</span> delivers node <span class="math">i</span> protocol messages from both the real and simulated executions.</li>

      <li>Since the real and simulated executions are identically distributed to the newly joining node <span class="math">i</span>, there cannot exist an algorithm that can output the correct log with probability more than <span class="math">\\frac{1}{2}</span>.</li>

    </ul>

    <p class="text-gray-300">∎</p>

    <h3 id="sec-156" class="text-xl font-semibold mt-8">8.2 Foreknowledge of <span class="math">\\Delta</span> is Necessary</h3>

    <p class="text-gray-300">Recall that in our model, we assume that alert nodes can receive messages from other alert nodes within at most <span class="math">\\Delta</span> delay. Further, we assume that <span class="math">\\Delta</span> (or an upper bound on the network delay) is known to our protocol. Below, we show that making this assumption is necessary, since any protocol that does not have a-priori knowledge of <span class="math">\\Delta</span> cannot securely realize state machine replication in the sleepy model.</p>

    <h6 id="sec-157" class="text-base font-medium mt-4">Theorem 11.</h6>

    <p class="text-gray-300">In the sleepy model, any protocol that does not take an upper bound on the network delay <span class="math">\\Delta</span> as input cannot realize state machine replication even when all awake nodes are honest (and the adversary therefore is merely a network adversary).</p>

    <h6 id="sec-158" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Consider any such protocol that has no foreknowledge of <span class="math">\\Delta</span>. Consider the following adversary <span class="math">\\mathcal{A}</span>: it does not corrupt any nodes or make any nodes sleep; however, it divides the alert nodes into two camps, with a large <span class="math">\\Delta=\\mathsf{poly}(\\lambda,N)</span> in between the two camps.</p>

    <p class="text-gray-300">After executing the protocol for some <span class="math">\\mathsf{poly}(\\lambda,N)</span> time, due to the requirement of achieving liveness even when a polynomial fraction of the nodes are sleeping, alert nodes in both camps must output a non-empty LOG — since nodes in one camp cannot distinguish if there is a long network delay between the camps, or if the other camp has fallen asleep. However, if the environment <span class="math">\\mathcal{Z}</span> sent different inputs to the nodes in the two camps, their output LOGs will be different. This breaks consistency.</p>

    <p class="text-gray-300">Acknowledgments</p>

    <p class="text-gray-300">We thank Rachit Agarwal, Hubert Chan, Kai-Min Chung, Naomi Ephraim, Ittay Eyal, and Andrew Morgan for helpful and supportive discussions. This work is supported in part by NSF grant number CNS-1561209.</p>

    <h2 id="sec-159" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO, pages 361–377, 2005.</li>

      <li>[2] User ”BCNext”. NXT. http://wiki.nxtcrypto.org/wiki/Whitepaper:Nxt, 2014.</li>

      <li>[3] Michael Ben-Or. Another advantage of free choice (extended abstract): Completely asynchronous agreement protocols. In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, PODC ’83, pages 27–30, New York, NY, USA, 1983. ACM.</li>

      <li>[4] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. In Financial Cryptography Bitcoin Workshop, 2016.</li>

      <li>[5] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. https://eprint.iacr.org/2016/919.pdf.</li>

      <li>[6] Alysson Neves Bessani, João Sousa, and Eduardo Adílio Pelinson Alchieri. State machine replication for the masses with BFT-SMART. In DSN, 2014.</li>

      <li>[7] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824–840, October 1985.</li>

      <li>[8] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and efficient asynchronous broadcast protocols. In CRYPTO, pages 524–541, 2001.</li>

      <li>[9] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</li>

      <li>[10] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography. 2007.</li>

      <li>[11] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.</li>

      <li>[12] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</li>

      <li>[13] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656–666, 1983.</li>

      <li>[14] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</li>

      <li>[15] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO, 1992.</li>

    </ul>

    <p class="text-gray-300">[16] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[17] Pesech Feldman and Silvio Micali. An optimal probabilistic protocol for synchronous byzantine agreement. In SIAM Journal of Computing, 1997.</li>

      <li>[18] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, April 1985.</li>

      <li>[19] Roy Friedman, Achour Mostefaoui, and Michel Raynal. Simple and efficient oracle-based consensus protocols for asynchronous byzantine systems. IEEE Trans. Dependable Secur. Comput., 2(1):46–56, January 2005.</li>

      <li>[20] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Eurocrypt, 2015.</li>

      <li>[21] Rachid Guerraoui, Florian Huc, and Anne-Marie Kermarrec. Highly dynamic distributed computing with byzantine failures. In PODC, pages 176–183, 2013.</li>

      <li>[22] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91–112, February 2009.</li>

      <li>[23] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive, 2015:1019, 2015.</li>

      <li>[24] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. http://eprint.iacr.org/2016/889.</li>

      <li>[25] Sunny King and Scott Nadal. PPCoin: Peer-to-Peer Crypto-Currency with Proof-of-Stake, August 2012.</li>

      <li>[26] Leslie Lamport. The weak byzantine generals problem. J. ACM, 30(3):668–676, 1983.</li>

      <li>[27] Leslie Lamport. Fast paxos. Distributed Computing, 19(2):79–103, 2006.</li>

      <li>[28] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In PODC, pages 312–313, 2009.</li>

      <li>[29] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, July 1982.</li>

      <li>[30] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</li>

      <li>[31] Silvio Micali. Algorand: The efficient and democratic ledger. https://arxiv.org/abs/1607.01341, 2016.</li>

      <li>[32] Silvio Micali, Salil Vadhan, and Michael Rabin. Verifiable random functions. In FOCS, 1999.</li>

      <li>[33] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of BFT protocols. In ACM CCS, 2016.</li>

      <li>[34] P. Mockapetris and K. Dunlap. Development of the Domain Name System. In SIGCOMM, pages 123–133, Stanford, CA, 1988.</li>

    </ul>

    <p class="text-gray-300">[35] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[36] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. https://eprint.iacr.org/2016/454.</li>

      <li>[37] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</li>

      <li>[38] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permissionless model. Manuscript, 2016.</li>

      <li>[39] Yee Jiun Song and Robbert van Renesse. Bosco: One-step byzantine asynchronous consensus. In DISC, pages 438–450, 2008.</li>

    </ul>

    <h2 id="sec-160" class="text-2xl font-bold">Appendix A Tighter Consistency Proof</h2>

    <h3 id="sec-161" class="text-xl font-semibold mt-8">A.1 Strong Pivots Recur Frequently</h3>

    <p class="text-gray-300">Earlier, for clarity, we presented a loose version of the consistency proof. In this section, we will present a tighter, but somewhat more involved consistency analysis.</p>

    <p class="text-gray-300">First, we need a stronger version of Lemma 6 and Corollary 3. Informally speaking, the stronger version says the following: given any sufficiently long window, very likely there are more convergence opportunities in this window than adversarial time slots — even when the adversary is given <span class="math">\\Delta</span> extra time. The proof of the stronger version is similar to those of Lemma 6 and Corollary 3 but now also accouting for the extra <span class="math">\\Delta</span> time given to the adversary. As will become obvious later, this <span class="math">\\Delta</span> extra time given to the adversary will later allow us to perform a union bound for a sequence of times with a <span class="math">\\Delta</span> skip (rather than performing a union bound over all time steps); and this is important for tightening up the analysis.</p>

    <h6 id="sec-162" class="text-base font-medium mt-4">Lemma 10 (Adversarial time slots vs. convergence opportunities for any fixed window).</h6>

    <p class="text-gray-300">For any <span class="math">t_{0},t_{1}</span> such that <span class="math">t:=t_{1}-t_{0}\\geq c^{\\prime}\\Delta</span> for a sufficiently large constant <span class="math">c^{\\prime}</span>, for any <span class="math">\\Pi_{ideal}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists some positive constant <span class="math">\\eta</span>, such that for any positive <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textit{view}\\leftarrow_{\\S}\\textit{EXEC}^{\\Pi_{ideal}}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathbf{A}(\\textit{view})[t_{0}-\\Delta:t_{1}]\\geq\\mathbf{C}(\\textit{view})[t_{0}:t_{1}]\\right]&lt;\\exp(-\\eta\\beta t)</span></p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textit{view}\\leftarrow_{\\S}\\textit{EXEC}^{\\Pi_{ideal}}(\\mathcal{A},\\mathcal{Z},\\lambda):\\mathbf{A}(\\textit{view})[t_{0}:t_{1}+\\Delta]\\geq\\mathbf{C}(\\textit{view})[t_{0}:t_{1}]\\right]&lt;\\exp(-\\eta\\beta t)</span></p>

    <h6 id="sec-163" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We prove one of the above cases with the extra <span class="math">\\Delta</span> given to the adversary at the beginning. The other case is similar. Due to Fact 2, for any positive <span class="math">\\epsilon_{1}</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbf{A}[t_{0}-\\Delta:t_{0}+t]&gt;(1+\\epsilon_{1})\\beta(t+\\Delta)\\right]&lt;\\exp(-\\frac{\\epsilon_{1}^{2}\\beta t}{3})</span></p>

    <p class="text-gray-300">Due to Lemma 2, for any positive <span class="math">\\epsilon_{2}</span>, there exists positive <span class="math">\\epsilon^{\\prime}</span> that depends on <span class="math">\\epsilon_{2}</span>, such that</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\mathbf{C}[t_{0}:t_{0}+t]&lt;(1-\\epsilon_{2})(1-2pN\\Delta)\\alpha t\\right]\\leq\\exp(-\\epsilon^{\\prime}\\beta t)</span></p>

    <p class="text-gray-300">Since we know that</p>

    <p class="text-gray-300"><span class="math">\\frac{\\alpha}{\\beta}&gt;\\frac{1+\\phi}{1-2pN\\Delta}</span></p>

    <p class="text-gray-300">and moreover <span class="math">2\\beta\\Delta&lt;2pN\\Delta&lt;1</span>, it holds that for sufficiently small constants <span class="math">\\epsilon_{1}</span> and <span class="math">\\epsilon_{2}</span>, and <span class="math">t\\geq c^{\\prime}\\cdot\\Delta</span> for a sufficiently large constant <span class="math">c^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">(1+\\epsilon_{1})\\beta(t+\\Delta)&lt;(1-\\epsilon_{2})(1-2pN\\Delta)\\alpha t</span></p>

    <p class="text-gray-300">The rest of the proof is straightforward. ∎</p>

    <h6 id="sec-164" class="text-base font-medium mt-4">Fact 12.</h6>

    <p class="text-gray-300">Let <span class="math">t^{\\prime}&lt;t</span>. For any view, if for every non-negative integer <span class="math">k</span>, <span class="math">\\mathbf{C}(\\textsf{view})[t^{\\prime}-k\\Delta:t]&gt;\\mathbf{A}(\\textsf{view})[t^{\\prime}-(k+1)\\Delta:t]</span> or <span class="math">\\mathbf{A}(\\textsf{view})[t^{\\prime}-(k+1)\\Delta:t]=0</span>, then, it holds that for any <span class="math">r\\leq t^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}(\\textsf{view})[r:t]&lt;\\mathbf{C}(\\textsf{view})[r:t]\\text{ or }\\mathbf{A}(\\textsf{view})[r:t]=0</span></p>

    <h6 id="sec-165" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Basically for every <span class="math">s\\in[t^{\\prime}-(k+1)\\Delta,t^{\\prime}-k\\Delta]</span>, we use <span class="math">\\mathbf{C}(\\textsf{view})[t^{\\prime}-k\\Delta:t]</span> as a lower bound of <span class="math">\\mathbf{C}(\\textsf{view})[s:t]</span>; and we use <span class="math">\\mathbf{A}(\\textsf{view})[t^{\\prime}-(k+1)\\Delta:t]</span> as an upper bound of <span class="math">\\mathbf{A}(\\textsf{view})[s:t]</span>. The rest of the proof is straightforward. ∎</p>

    <p class="text-gray-300">Intuitively, the above fact says that to make sure in every window (starting no later than <span class="math">t^{\\prime}</span> and) ending at <span class="math">t</span>, the convergence opportunities always outnumber adversarial time slots, it suffices to check every window but with a <span class="math">\\Delta</span> skip, that the convergence opportunities win even when the adversary is given <span class="math">\\Delta</span> extra time. This fact later allows us to do a union bound with a <span class="math">\\Delta</span> skip, making the union bound tighter.</p>

    <p class="text-gray-300">Similarly, we could also prove the following fact that is symmetric to Fact 12.</p>

    <h6 id="sec-166" class="text-base font-medium mt-4">Fact 13.</h6>

    <p class="text-gray-300">Let <span class="math">t^{\\prime}&gt;t</span>. For any view, if for every non-negative integer <span class="math">k</span>, <span class="math">\\mathbf{C}(\\textsf{view})[t:t^{\\prime}+k\\Delta]&gt;\\mathbf{A}(\\textsf{view})[t:t^{\\prime}+(k+1)\\Delta]</span> or <span class="math">\\mathbf{A}(\\textsf{view})[t:t^{\\prime}+(k+1)\\Delta]=0</span>, then, it holds that for any <span class="math">r\\geq t^{\\prime}</span>,</p>

    <p class="text-gray-300"><span class="math">\\mathbf{A}(\\textsf{view})[t:r]&lt;\\mathbf{C}(\\textsf{view})[t:r]\\text{ or }\\mathbf{A}(\\textsf{view})[t:r]=0</span></p>

    <h6 id="sec-167" class="text-base font-medium mt-4">Lemma 11 (Any given time is likely a strong pivot).</h6>

    <p class="text-gray-300">For any <span class="math">t</span>, for any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a positive constant <span class="math">c</span>, such that for any positive <span class="math">\\lambda</span>,</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textsf{view}\\leftarrow{}_{\\S}\\textsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):t\\text{ is a strong pivot in </span>\\textsf{view}<span class="math">}\\right]\\geq c</span></p>

    <p class="text-gray-300">Note that since every strong pivot must also be a <span class="math">w</span>-pivot, it holds that for any <span class="math">w</span>, the following also holds:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\textsf{view}\\leftarrow{}_{\\S}\\textsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):t\\text{ is a </span>w<span class="math">-pivot in </span>\\textsf{view}<span class="math">}\\right]\\geq c</span></p>

    <h6 id="sec-168" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">For simplicity, for <span class="math">t^{\\prime}&lt;t</span>, let <span class="math">\\mathsf{bad}(t^{\\prime})</span> denote the bad event that <span class="math">\\mathbf{C}[t^{\\prime}:t]\\leq\\mathbf{A}[t^{\\prime}-\\Delta:t]</span>. For <span class="math">t^{\\prime}&gt;t</span>, let <span class="math">\\mathsf{bad}(t^{\\prime})</span> denote the bad event that <span class="math">\\mathbf{C}[t:t^{\\prime}]\\leq\\mathbf{A}[t:t^{\\prime}+\\Delta]</span>.</p>

    <p class="text-gray-300">Let <span class="math">t_{c}:=\\frac{c_{1}}{\\beta\\eta}</span> where <span class="math">c_{1}</span> is a suitable constant and <span class="math">\\eta</span> is the positive constant corresponding to Lemma 10. Observe also since <span class="math">2\\beta\\Delta&lt;2pN&lt;1</span> and hence <span class="math">\\beta&lt;0.5</span>, it holds that <span class="math">(1-\\beta)^{\\frac{1}{\\beta}}&gt;0.25</span>.</p>

    <p class="text-gray-300">We now have the following:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[t\\text{ is a strong pivot}\\right]\\geq\\Pr\\left[t\\text{ is a strong pivot and }\\mathbf{A}[t-t_{c}:t+t_{c}]=0\\right]</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\geq</span> $\\Pr\\left[\\mathbf{A}[t-t_{c}:t+t_{c}]=0\\right]\\cdot\\Pr\\left[\\text{for any }t^{\\prime}<t-t_{c}\\text{ or }t^{\\prime}>t+t_{c}\\colon\\overline{\\text{bad}}(t^{\\prime})\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbf{A}[t-t_{c}:t+t_{c}]=0\\right.\\right]$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\geq</span> <span class="math">\\Pr\\left[\\mathbf{A}[t-t_{c}:t+t_{c}]=0\\right]\\cdot\\Pr\\left[\\text{for any }t^{\\prime}&lt;t-t_{c}\\text{ or }t^{\\prime}&gt;t+t_{c}\\colon\\overline{\\text{bad}}(t^{\\prime})\\right]</span></p>

    <p class="text-gray-300">\\[ \\geq\\left((1-\\beta)^{\\frac{1}{\\beta}}\\right)^{\\frac{c_{1}}{\\eta}}\\cdot\\left(\\begin{array}[]{c}1-\\Pr\\left[\\text{bad}(t-t_{c})\\right]-\\Pr\\left[\\text{bad}(t-t_{c}-\\Delta)\\right]-\\Pr\\left[\\text{bad}(t-t_{c}-2\\Delta)\\right]\\ldots\\\\ -\\Pr\\left[\\text{bad}(t+t_{c})\\right]-\\Pr\\left[\\text{bad}(t+t_{c}+\\Delta)\\right]-\\Pr\\left[\\text{bad}(t+t_{c}+2\\Delta)\\right]\\ldots\\end{array}\\right)\\begin{array}[]{c}\\text{union}\\\\ \\text{bound,}\\\\ \\text{Fact 12}\\end{array} \\]</p>

    <p class="text-gray-300"><span class="math">\\geq\\left(\\frac{1}{4}\\right)^{\\Theta(1)}\\cdot\\left(1-2e^{-c_{1}}-2e^{-c_{1}+\\eta\\beta\\Delta}-2e^{-c_{1}+2\\eta\\beta\\Delta}-\\ldots\\right)\\quad\\text{Lemma 10, }c_{1}\\text{ sufficiently large const}</span></p>

    <p class="text-gray-300"><span class="math">=\\left(\\frac{1}{4}\\right)^{\\Theta(1)}\\cdot\\left(1-\\frac{2e^{-c_{1}}}{1-e^{-\\eta\\beta\\Delta}}\\right)</span></p>

    <p class="text-gray-300">Since <span class="math">\\beta\\Delta=\\Theta(1)</span>, as long as we pick constant <span class="math">c_{1}</span> such that <span class="math">2e^{-c_{1}}&lt;1-e^{-\\eta\\beta\\Delta}</span>, the last line above is a constant greater than 0. ∎</p>

    <p class="text-gray-300">Recall that given a view, we say that many-pivots<span class="math">{}^{w,W}(\\text{view})=1</span> iff for any <span class="math">s,r</span> such that <span class="math">r-s&gt;W\\geq 0</span>, there must exist a <span class="math">w</span>-pivot during the window <span class="math">[s,r]</span>.</p>

    <h6 id="sec-169" class="text-base font-medium mt-4">Theorem 12 (There are many pivot points).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant pair <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists a constant <span class="math">C</span>, such that for any <span class="math">\\lambda</span>, the following holds for <span class="math">W=\\frac{C\\lambda^{2}}{\\beta}</span> and <span class="math">w=\\frac{\\lambda}{\\beta}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{view}\\leftarrow{}_{\\S}EXEC^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\text{\\tt many-pivots}^{w,W}(\\text{view})=1\\right]&lt;\\exp(-\\lambda)</span></p>

    <h6 id="sec-170" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Recall that <span class="math">\\beta\\Delta&lt;2pN\\Delta&lt;1</span>, therefore, <span class="math">W=\\frac{C\\lambda^{2}}{\\beta}=C\\cdot w\\cdot\\lambda=\\frac{C}{2}\\cdot 2w\\cdot\\lambda&lt;\\frac{C}{2}\\cdot(w+\\Delta)\\cdot\\lambda</span>. Consider a window <span class="math">(s,r)</span> of length at least <span class="math">W</span>, and a sequence of events <span class="math">\\mathsf{G}_{0},\\mathsf{G}_{1},\\ldots</span> where <span class="math">\\mathsf{G}_{i}</span> denote the good event that the time <span class="math">s+i\\cdot 2(w+\\Delta)</span> is a <span class="math">w</span>-pivot, where <span class="math">i</span> can range from 0 to <span class="math">\\frac{C}{4}\\cdot\\lambda</span>. By the definition of <span class="math">w</span>-pivots and that of convergence opportunities, it is not hard to see that all these events <span class="math">\\mathsf{G}_{0},\\mathsf{G}_{1},\\ldots</span> are independent. The probability that all these good events do not happen is upper bounded by the following where <span class="math">c</span> is the constant from Lemma 11, and <span class="math">C</span> is sufficiently large w.r.t. <span class="math">c</span>.</p>

    <p class="text-gray-300"><span class="math">\\left(1-\\frac{1}{c}\\right)^{\\frac{C}{4}\\cdot\\lambda}\\leq\\exp(-\\lambda)</span></p>

    <p class="text-gray-300">The remainder of the proof follows from a simple union bound over all possible such windows. ∎</p>

    <h3 id="sec-171" class="text-xl font-semibold mt-8">A.2 Proof of Consistency</h3>

    <h6 id="sec-172" class="text-base font-medium mt-4">Theorem 13 (Consistency).</h6>

    <p class="text-gray-300">For any <span class="math">\\Pi_{\\text{ideal}}(p)</span>-compliant <span class="math">(\\mathcal{A},\\mathcal{Z})</span>, there exists positive constants <span class="math">\\eta</span> and <span class="math">C</span>, such that for any <span class="math">\\lambda\\in\\mathbb{N}</span>, the following holds for <span class="math">T=C\\lambda^{2}</span>:</p>

    <p class="text-gray-300"><span class="math">\\Pr\\left[\\text{view}\\leftarrow{}_{\\S}EXEC^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A},\\mathcal{Z},\\lambda):\\text{\\tt consistent}^{T}(\\text{view})=1\\right]\\geq 1-\\exp(-\\eta\\lambda)</span></p>

    <h6 id="sec-173" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">The proof is identical to that of Theorem 6, except that now, we use a tighter value of <span class="math">W</span> as given in Theorem 12. ∎</p>

    <p class="text-gray-300">B Chernoff Bound</p>

    <p class="text-gray-300">For completeness, we quote the version of Chernoff Bound adopted in this paper.</p>

    <p class="text-gray-300">Theorem 14 (Chernoff bound). Let <span class="math">\\mathbf{X} := \\sum_{i=1}^{n} \\mathbf{X}_i</span>, where each <span class="math">\\mathbf{X}_i = 1</span> with probability <span class="math">p_i</span>, and <span class="math">\\mathbf{X}_i = 0</span> with probability <span class="math">1 - p_i</span>; and further, all <span class="math">\\mathbf{X}_i</span>'s are independent. Let <span class="math">\\mu := \\mathbf{E}[\\mathbf{X}] = \\sum_{i=1}^{n} p_i</span>. Then, we have that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathbf {X} &amp;gt; (1 + \\delta) \\mu \\right] \\leq e ^ {- \\frac {\\delta^ {2}}{2 + \\delta} \\mu} \\text{ for all } \\delta &amp;gt; 0</span></div>

    <p class="text-gray-300">55</p>`;
---

<BaseLayout title="The Sleepy Model of Consensus (2016/918)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/918
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
