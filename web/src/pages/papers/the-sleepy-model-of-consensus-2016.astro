---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2016/918';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-21';
const TITLE_HTML = 'The Sleepy Model of Consensus';
const AUTHORS_HTML = 'Rafael Pass CornellTech';

const CONTENT = `    <p class="text-gray-300">Rafael Pass CornellTech</p>

    <p class="text-gray-300">Elaine Shi Cornell</p>

    <p class="text-gray-300">May 11, 2017</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">The literature on distributed computing (as well as the cryptography literature) typically considers two types of players—honest players and corrupted players. Resilience properties are then analyzed assuming a lower bound on the fraction of honest players. Honest players, however, are not only assumed to follow the prescribed the protocol, but also assumed to be online throughout the whole execution of the protocol. The advent of &quot;large-scale&quot; consensus protocols (e.g., the blockchain protocol) where we may have millions of players, makes this assumption unrealistic. In this work, we initiate a study of distributed protocols in a &quot;sleepy&quot; model of computation where players can be either online (alert) or offline (asleep), and their online status may change at any point during the protocol. The main question we address is:</p>

    <p class="text-gray-300">Can we design consensus protocols that remain resilient under &quot;sporadic participation&quot;, where at any given point, only a subset of the players are actually online?</p>

    <p class="text-gray-300">As far as we know, all standard consensus protocols break down under such sporadic participation, even if we assume that 99% of the online players are honest.</p>

    <p class="text-gray-300">Our main result answers the above question in the affirmative. We present a construction of a consensus protocol in the sleepy model, which is resilient assuming only that a majority of the online players are honest. Our protocol relies on a Public-Key Infrastructure (PKI), a Common Random String (CRS) and is proven secure in the timing model of Dwork-Naor-Sahai (STOC'98) where all players are assumed to have weakly-synchronized clocks (all clocks are within ∆ of the &quot;real time&quot;) and all messages sent on the network are delivered within ∆ time, and assuming the existence of sub-exponentially secure collision-resistant hash functions and enhanced trapdoor permutations. Perhaps surprisingly, our protocol significantly departs from the standard approaches to distributed consensus, and we instead rely on key ideas behind Nakamoto's blockchain protocol (while dispensing the need for &quot;proofs-of-work&quot;). We finally observe that sleepy consensus is impossible in the presence of a dishonest majority of online players.</p>

    <p class="text-gray-300">Consensus protocols are at the core of distributed computing and also provide a foundational building protocol for multi-party cryptographic protocols. In this paper, we consider consensus protocols for realizing a &quot;linearly ordered log&quot; abstraction—often referred to as state machine replication or linearizability in the distributed systems literature. Such protocols must respect two important resiliency properties, consistency and liveness. Consistency ensures that all honest nodes have the same view of the log, whereas liveness requires that transactions will be incorporated into the log quickly.</p>

    <p class="text-gray-300">The literature on distributed computing as well as the cryptography literature typically consider two types of players—honest players and corrupted/adversarial players. The above-mentioned resiliency properties are then analyzed assuming a lower bound on the fraction of honest players (e.g., assuming that at least a majority of the players are honest). Honest players, however, are not only assumed to follow the prescribed the protocol, but also assumed to be online throughout the whole execution of the protocol. Whereas this is a perfectly reasonable assumption for the traditional environments in which consensus protocols typically were deployed (e.g., within a company, say &quot;Facebuck&quot;, to support an application, say &quot;Fackbuck Credit&quot;, where the number of nodes/players is roughly a dozen), the advent of &quot;large-scale&quot; consensus protocols (such as e.g., the blockchain protocol)—where want to achieve consensus among millions of players—makes this latter assumption unrealistic. (For instance, in bitcoin, only a small fraction of users having bitcoins are actually participating as miners.)</p>

    <p class="text-gray-300">Towards addressing this issue, we here initiate a study of distributed protocols in a &quot;sleepy&quot; model of computation. In this model, players can be either online (&quot;awake/active&quot;) or offline (&quot;asleep&quot;), and their online status may change at any point during the protocol execution. The main question we address is:</p>

    <p class="text-gray-300">Can we design consensus protocols that remain resilient under &quot;sporadic participation&quot; where at any given point, only a subset of the players are actually online—assuming an appropriate fraction (e.g., majority) of the online players are honest?</p>

    <p class="text-gray-300">As far as we know, this question was first raised by Micali <a href="#page-51-0">[31]</a> in a recent manuscript<a href="#page-1-0">1</a> —he writes &quot;... a user missing to participate in even a single round is pessimistically judged malicious although, in reality, he may have only experienced a network-connection problem, or simply taken a break. [..] One possibility would be to revise the current Honest Majority of Users assumption so as it applies only to the &quot;currently active&quot; users rather than the &quot;currently existing&quot; users.&quot; In Micali's work, however, a different path is pursued.<a href="#page-1-1">2</a> In contrast, our goal here is to address this question. It is easy to see that consensus is impossible in this model unless we assume that at least a majority of the awake players are honest (if the set of awake players can arbitrarily change throughout the execution)—briefly, the reason for this is that a player that wakes up after being asleep for a long time cannot distinguish the real execution by the honest player and an emulated</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;1&lt;/sup&gt;Although our paper is subsequent, at the original time of writing this paper, we were actually not aware of this; this discussion was present in the arXiv version from August 2016, but is no longer present in the most recent version of his manuscript.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-1-1&quot;&gt;&lt;/span&gt;&lt;sup&gt;2&lt;/sup&gt;Briefly, rather than designing a protocol that remains resilient under this relaxed honesty assumption, he designs a protocol under an incomparable &quot;honest-but-lazy&quot; assumption, where honest players only are required to participate at infrequent but individually prescribed rounds (and if they miss participation in their prescribed round, they are deemed corrupted). Looking forward, the honest strategy in our protocols also satisfies such a laziness property.</p>

    <p class="text-gray-300">&quot;fake&quot; execution by the malicious players, and thus must choose the &quot;fake&quot; one with probability at least  <span class="math">\\frac{1}{2}</span> . We formalize this in Theorem 10 (in Section 8).</p>

    <p class="text-gray-300">We then consider the following question:</p>

    <p class="text-gray-300">Can we design a consensus protocol that achieves consistency and liveness assuming only that a majority of the online players are honest?</p>

    <p class="text-gray-300">As far as we know, all standard consensus protocols break down in the sleepy model, even if we assume that 99% of the online players are honest! Briefly, the standard protocols can be divided into two types: 1) protocols that assume synchronous communication, where all messages sent by honest players are guaranteed to be received by all other honest nodes in the next round; or, 2) protocols handling partially synchronous or asynchronous communication, but in this case require knowledge of a tight bound on the number of actually participating honest players. In more detail:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Traditional synchronous protocols (e.g., [13,17,22]) crucially rely on messages being delivered in the next round (or within a known, bounded delay  <span class="math">\\Delta</span> ) to reach agreement. By contrast, in the sleepy model, consider an honest player that falls asleep for a long time (greater than  <span class="math">\\Delta</span> ) and then wakes up at some point in the future; it now receives all &quot;old&quot; messages with a significantly longer delay (breaking the synchrony assumption). In these protocols, such a player rejects all these old messages and would never reach agreement with the other players. It may be tempting to modify e.g., the protocol of [13] to have the players reach agreement on some transaction if some threshold (e.g., majority) of players have approved it—but the problem then becomes how to set the threshold, as the protocol is not aware of how many players are actually awake!</li>
      <li>The partially synchronous or asynchronous protocols (e.g., [8, 12, 14, 30, 33, 39]) a-priori seem to handle the above-mentioned issue with the synchronous protocol: we can simply view the sleeping player as receiving messages with a long delay (which is allowed in the asynchronous model of communication). Here, the problem instead is the fact that the number of awake players may be significantly smaller than the total number of players, and this means that no transactions will even be approved! A bit more concretely, these protocols roughly speaking approve transactions when a certain <em>number</em> of nodes have &quot;acknowledged&quot; them-for instance, in the classic BFT protocol of Castro and Liskov [12] (which is resilient in the standard model assuming a fraction  <span class="math">\\frac{2}{3}</span>  of all players are honest), players only approve a transaction when they have heard  <span class="math">\\frac{2N}{3}</span>  &quot;confirmations&quot; of some message where N is the total number of parties. The problem here is that if, say, only half of the N players are awake, the protocols stalls. And again. as for the case of synchronous protocols, it is not clear how to modify this threshold without knowledge of the number of awake players.</li>
    </ul>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1.2 Main Result</h4>

    <p class="text-gray-300">Our main result answers the above question in the affirmative. We present constructions of consensus protocols in the sleepy model, which are resilient assuming only that a majority of the awake players are honest. Our protocols relies on the existence of a &quot;bare&quot; Public-Key Infrastructure  <span class="math">(PKI)^3</span> , the existence of Common Random String  <span class="math">(CRS)^4</span>  and is proven secure in a simple</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;3&lt;/sup&gt;That is, players have some way of registering public keys; for honest players, this registration happens before the beginning of the protocol, whereas corrupted players may register their key at any point. We do not need players to e.g., prove knowledge of their secret-key.  <span class="math">$^4{\\rm That}</span>  is a commonly known truly random string &quot;in the sky&quot;.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-2-1&quot;&gt;&lt;/span&gt;</p>

    <p class="text-gray-300">version of the timing model of Dwork-Naor-Sahai <a href="#page-51-5">[34]</a> where all players are assumed to have weaklysynchronized clocks—all clocks are within ∆ of the &quot;real time&quot;, and all messages sent on the network are delivered within ∆ time.</p>

    <p class="text-gray-300">Our first protocol relies only on the existence of collision-resistant hash functions (and it is both practical and extremely simple to implement, compared to standard consensus protocols); it, however, only supports static corruptions and a static (fixed) schedule of which nodes are awake at what time step—we refer to this as a &quot;static online schedule&quot;.</p>

    <p class="text-gray-300">Theorem 1 (Informal). Assume the existence of families of a collision-resistant hash functions (CRH). Then, there exists a protocol for state-machine replication in the Bare PKI, CRS and in the timing model, which achieves consistency and liveness assuming a static online schedule and static corruptions, as long as at any point in the execution, a majority of the awake players are honest.</p>

    <p class="text-gray-300">Our next construction, enhances the first one by achieving also resilience with an arbitrary adversarial selection of which nodes are online at what time; this protocol also handles adaptive corruptions of players. This new protocol, however, does so at the price of assuming subexponentially secure collision-resistant hash functions and enhanced trapdoor permutations (the latter are needed for the constructions of non-interactive zero-knowledge proofs).</p>

    <p class="text-gray-300">Theorem 2 (Informal). Assume the existence of families of sub-exponentially secure collisionresistant hash functions (CRH), and enhanced trapdoor permutations (TDP). Then, there exists a state-machine replication protocol in the Bare PKI, CRS and timing model, which achieves consistency and liveness under adaptive corruptions as long as at any point in the execution, a majority of the awake players are honest.</p>

    <p class="text-gray-300">Perhaps surprisingly, our protocols significantly departs from the standard approaches to distributed consensus, and we instead rely on key ideas behind Nakamoto's beautiful blockchain protocol <a href="#page-52-1">[35]</a>, while dispensing the need for &quot;proofs-of-work&quot; <a href="#page-50-4">[15]</a>. As far as we know, our work demonstrates for the first time how the ideas behind Nakamoto's protocol are instrumental in solving &quot;standard&quot; problems in distributed computing; we view this as our main conceptual contribution (and hopefully one that will be useful also in other contexts).</p>

    <p class="text-gray-300">Our proof will leverage and build on top of the formal analysis of the Nakamoto blockchain by Pass et al. <a href="#page-52-2">[36]</a>, but since we no longer rely on proofs-of-work, several new obstacles arise. Our main technical contribution, and the bulk of our analysis, is a new combinatorial analysis for dealing with these issues.</p>

    <p class="text-gray-300">We finally mention that ad-hoc solutions for achieving consensus using ideas behind the blockchain (but without proof-of-work) have been proposed <a href="#page-50-5">[2,</a> <a href="#page-50-6">4,</a> <a href="#page-51-6">25]</a>, none of these come with an analysis, and it is not clear to what extent they improve upon standard state-machine replication protocols (and more seriously, whether they even achieve the standard notion of consensus).</p>

    <p class="text-gray-300">We start by providing an overview of our consensus protocol which only handles a static online schedule and static corruptions; we next show how to enhance this protocol to achieve adaptive security.</p>

    <p class="text-gray-300">As mentioned, the design of our consensus protocols draws inspiration from Bitcoin's proofof-work based blockchain <a href="#page-52-1">[35]</a>—the so-called &quot;Nakamoto consensus&quot; protocol. This protocol is designed to work in a so-called &quot;permissionless setting&quot; where anyone can join the protocol execution. In contrast, we here study consensus in the classic &quot;permissioned&quot; model of computation with a fixed set [N] of participating players; additionally, we are assuming that the players can register public keys (whose authenticity can be verified). Our central idea is to eliminate the use of proofs of work in this protocol. Towards this goal, let us start by providing a brief overview of Nakamoto's beautiful blockchain protocol.</p>

    <p class="text-gray-300">Nakamoto consensus in a nutshell. Roughly speaking, in Nakamoto's blockchain, players &quot;confirm&quot; transactions by &quot;mining blocks&quot; through solving some computational puzzle that is a function of the transactions and the history so far. More precisely, each participant maintains its own local &quot;chain&quot; of &quot;blocks&quot; of transactions—called the blockchain. Each block consists of a triple (h−1, η,txs) where h−&lt;sup&gt;1&lt;/sup&gt; is a pointer to the previous block in chain, txs denotes the transactions confirmed, and η is a &quot;proof-of-work&quot;— a solution to a computational puzzle that is derived from the pair (h−1,txs). The proof of work can be thought of as a &quot;key-less digital signature&quot; on the whole blockchain up until this point. At any point of time, nodes pick the longest valid chain they have seen so far and try to extend this longest chain.</p>

    <p class="text-gray-300">Removing proofs-of-work. Removing the proof-of-work from the Nakamoto blockchain while maintaining provable guarantees turns out to be subtle and the proof non-trivial. To remove the proof-of-work from Nakamoto's protocol, we proceed as follows: instead of rate limiting through computational power, we impose limits on the type of puzzle solutions that are admissible for each player. More specifically, we redefine the puzzle solution to be of the form (P, t) where P is the player's identifier and t is referred to as the block-time. An honest player will always embed the current time step as the block-time. The pair (P, t) is a &quot;valid puzzle solution&quot; if H(P, t) &lt; D&lt;sup&gt;p&lt;/sup&gt; where H denotes a random oracle (for now, we provide a protocol in the random oracle model, but as we shall see shortly, the random oracle can be instantiated with a CRS and a pseudorandom function), and D&lt;sup&gt;p&lt;/sup&gt; is a parameter such that the hash outcome is only smaller than D&lt;sup&gt;p&lt;/sup&gt; with probability p. If H(P, t) &lt; Dp, we say that P is elected leader at time t. Note that several nodes may be elected leaders at the same time steps.</p>

    <p class="text-gray-300">Now, a node P that is elected leader at time step t can extend a chain with a block that includes the &quot;solution&quot; (P, t), as well as the previous block's hash h−&lt;sup&gt;1&lt;/sup&gt; and the transactions txs to be confirmed. To verify that the block indeed came from P, we require that the entire contents of the block, i.e., (h−1,txs, t,P), are signed under P's public key. Similarly to Nakamoto's protocol, nodes then choose the longest valid chain they have seen and extend this longest chain.</p>

    <p class="text-gray-300">Whereas honest players will only attempt to mine solutions of the form (P, t) where t is the current time step, so far there is nothing that prevents the adversary from using incorrect blocktimes (e.g., time steps in past or the future). To prevent this from happening, we additionally impose the following restriction on the block-times in a valid chain:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A valid chain must have strictly increasing block-times;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A valid chain cannot contain any block-times for the &quot;future&quot; (where &quot;future&quot; is adjusted to account for nodes' clock offsets)</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">There are now two important technical issues to resolve. First, it is important to ensure that the block-time rules do not hamper liveness. In other words, there should not be any way for an adversary to leverage the block-time mechanism to cause alert nodes to get stuck (e.g., by injecting false block-times).</p>

    <p class="text-gray-300">Second, although our block-time rules severely constrain the adversary, the adversary is still left with some wiggle room, and gets more advantage than alert nodes. Specifically, as mentioned earlier, the alert nodes only &quot;mine&quot; in the present (i.e., at the actual time-step), and moreover they never try to extend different chains of the same length. By contrast, the adversary can try to reuse past block-times in multiple chains. (In the proof of work setting, these types of attacks are not possible since there the hash function is applied also to the history of the chain, so &quot;old&quot; winning solutions cannot be reused over multiple chains; in contrast, in our protocol, the hash function is no longer applied to the history of the chain as this would give the attacker too many opportunities to become elected a leader by simply trying to add different transactions.)</p>

    <p class="text-gray-300">Our main technical result shows that this extra wiggle room in some sense is insignificant, and the adversary cannot leverage the wiggle room to break the protocol's consistency guarantees. It turns out that dealing with this extra wiggle room becomes technically challenging, and none of the existing analysis for proof-of-work blockchains <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a> apply. More precisely, since we are using a blockchain-style protocol, a natural idea is to see whether we can directly borrow proof ideas from existing analyses of the Nakamoto blockchains <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a>. Existing works <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a> define three properties of blockchains—chain growth (roughly speaking that the chain grows at a certain speed), chain quality (that the adversary cannot control the content of the chain) and consistency (that honest players always agree on appropriate prefix of the chain)—which, as shown in earlier works <a href="#page-52-2">[36,</a> <a href="#page-52-3">38]</a> imply the consistency and liveness properties needed for state-machine replication. Thus, by these results, it will suffice to demonstrate that our protocol satisfies these properties.</p>

    <p class="text-gray-300">The good news is that chain growth and chain quality properties can be proven in almost identically the same way as in earlier Nakamoto blockchain analysis <a href="#page-52-2">[36]</a>. The bad news is that the consistency proofs of prior works <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a> break down in our setting (as the attacker we consider is now more powerful as described above). The core of our proof is a new, and significantly more sophisticated analysis for dealing with this.</p>

    <p class="text-gray-300">Removing the random oracle. The above-described protocol relies on a random oracle. We note that we can in fact instantiate the random oracle with a PRF whose seed is selected in a common reference string (CRS). Roughly speaking, the reason for this is that in our proof we actually demonstrate the existence of some simple polynomial-time computable events—which only depend on the output of the hash function/PRF—that determine whether any (even unbounded) attacks can succeed. Our proof shows that with overwhelming probability over the choice of the random oracle, these events do not happen. By the security of the PRF, these events thus also happen only with negligible probability over the choice of the seed of the PRF.</p>

    <p class="text-gray-300">Dealing with adaptive sleepiness and corruption. We remark that the above-described protocol only works if the choice of when nodes are awake is made before PRF seed is selected. If not, honest players that are elected leaders could simply be put to sleep at the time step when they need to act. The problem is that it is preditcable when a node will become a leader. To overcome this problem, we take inspiration from a beautiful idea from Micali's work <a href="#page-51-0">[31]</a>—we let each player pick its own secret seed to a PRF and publish a commitment to the seed as part of its public key; the player can then evaluate its own private PRF and also prove in zero-knowledge that the PRF was correctly evaluated (so everyone else can verify the correctness of outputs of the PRF);<a href="#page-5-0">5</a> . Finally, each player now instantiates the random oracle with their own &quot;private&quot; PRF. Intuitively, this prevents the above-mentioned attack, since even if the adversary can adaptively select which honest nodes go to sleep, it has no idea which of them will become elected leaders before they broadcast their block.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;5&lt;/sup&gt; In essence, what we need is a VRF <a href="#page-51-8">[32]</a>, just like Micali <a href="#page-51-0">[31]</a>, but since we anyway have a CRS, we can rely on weaker primitives.</p>

    <p class="text-gray-300">Formalizing this, however, is quite tricky (and we will need to modify the protocol). The problem is that if users pick their own seed for the PRF, then they may be able to select a &quot;bad seed&quot; which makes them the leader for a long period of time (there is nothing in the definition of a PRF that prevents this). To overcome this issue, we instead perform a &quot;coin-tossing into the well&quot; for the evaluation of random oracle: As before, the CRS specifies the seed k&lt;sup&gt;0&lt;/sup&gt; of a PRF, and additionally, each user P commits to the seed k[P] of a PRF as part of their public key; node P can then use the following function to determine if it is elected in time t</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PRF}_{k_0}(\\mathcal{P}, t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t) &lt; D_p</span>$</p>

    <p class="text-gray-300">where D&lt;sup&gt;p&lt;/sup&gt; is a difficulty parameter selected such that any single node is elected with probability p in a given time step. Further, P additionally proves in zero-knowledge that it evaluated the above leader election function correctly in any block it produces.</p>

    <p class="text-gray-300">But, have we actually gained anything? A malicious user may still pick its seed k[P] after seeing k&lt;sup&gt;0&lt;/sup&gt; and this may potentially cancel out the effect of having PRFk&lt;sup&gt;0&lt;/sup&gt; (·) there in the first place! (For instance, the string PRFk&lt;sup&gt;0&lt;/sup&gt; (P, t) ⊕ PRFk[P] (t) clearly is not random any more.) We note, however, that if the user seed k[P] is significantly shorter than the seed k0, and the cryptographic primitives are subexponentially secure, we can rely on the same method that we used to replace the random oracle with a PRF to argue that even if k[P] is selected as a function of k0, this only increases the adversaries success probability by a factor 2&lt;sup&gt;L&lt;/sup&gt; for each possibly corrupted user where L := |k[P]| is the bit-length of each user's seed (and thus at most 2NL where N is the number of players) which still will not be enough to break security, if using a sufficiently big security parameter for the underlying protocol. We can finally use a similar style of a union bound to deal also with adaptive corruptions. (Note, however, that the loss in efficiency due to these complexity leveraging is nontrivial: the security parameter must now be greater than N; if we only require static corruption, and allow the CRS to be selected after all public keys are registered—which would be reasonable in practice—then, we can deal with adaptive sleepiness without this complexity leveraging and thus without the loss in efficiency).</p>

    <h2 id="sec-3" class="text-2xl font-bold">1.4 Applications in Permissioned and Permissionless Settings</h2>

    <p class="text-gray-300">As mentioned earlier, the variants of our protocols that deal with static corruption (and static or adaptive sleepiness) need not employ complexity leveraging, thus they can be implemented and adopted in real-world systems. We believe that our sleepy consensus protocol would be highly desirable in the following application scenarios and the alike.</p>

    <p class="text-gray-300">Permissioned setting: consortium blockchains. At the present, there is a major push where blockchain companies are helping banks across the world build &quot;consortium blockchains&quot;. A consortium blockchain is where a consortium of banks each contribute some nodes and jointly run a consensus protocol, on top of which one can run distributed ledger and smart contract applications. Since enrollment is controlled, consortium blockchain falls in the classical &quot;permissioned&quot; model of consensus. Since the number of participating nodes may be large (e.g., typically involve hundreds of banks and possibly hundreds to thousands of nodes), many conjecture that classical protocols such as PBFT <a href="#page-50-2">[12]</a>, Byzantine Paxos <a href="#page-51-9">[27]</a>, and others where the total bandwidth scales quadratically w.r.t. the number of players might not be ideal in such settings. Our sleepy consensus protocol provides a compelling alternative in this setting — with sleepy consensus, tasks such as committee re-configuration can be achieved simply without special program paths like in classical protocols <a href="#page-51-10">[28]</a>, and each bank can also administer their nodes without much coordination with other banks.</p>

    <p class="text-gray-300">Permissionless setting: proof-of-stake. The subsequent work Snow White by Bentov, Pass, and Shi <a href="#page-50-7">[5]</a> adapted our protocol to a permissionless setting, and obtained one of the first provably secure proof-of-stake protocols. A proof-of-stake protocol is a permissionless consensus protocol to be run in an open, decentralized setting, where roughly speaking, each player has voting power proportional to their amount of stake in the cryptocurrency system (c.f. proof-of-work is where players have voting power proportional to their available computing power). Major cryptocurrencies such as Ethereum are eager to switch to a proof-of-stake model rather than proof-of-work to dispense with wasteful computation. To achieve proof-of-stake, the Snow White <a href="#page-50-7">[5]</a> extended the our sleepy consensus protocol by introducing a mechanism that relies the distribution of stake in the system to periodically rotate the consensus committee. Further Snow White dealt with other issues such as &quot;nothing at stake&quot; and posterior corruption that are well-known for proof-of-stake systems — note that these issues pertain only to proof-of-stake systems and are thus out of scope for our paper.</p>

    <p class="text-gray-300">Comparison with independent work. Although proof-of-stake is not a focus of our paper, we compare with a few independent works on proof-of-stake <a href="#page-51-11">[24,</a> <a href="#page-51-0">31]</a> due to the superficial resemblance of some elements of their protocol in comparison with ours. Specificaly, the elegant work by Micali proposes to adapt classical style consensus protocols to realize a proof-of-stake protocol <a href="#page-51-0">[31]</a>; the concurrent and independent work by Kiayias et al. <a href="#page-51-11">[24]</a> proposes to use a combination of blockchainstyle protocol and classical protocols such as coin toss to realize proof-of-stake. Both these works would fail in the sleepy model like any classical style protocol. In comparison, we use a blockchain style protocol in a pure manner which is essential to achieving consensus in the sleepy model. We also point out that even when we replace Kiayias's coin toss protocol with an ideal random beacon, Kiayias's proof would still fail in the sleepy model — and there does not seem to be a trivial way to reinterpret their proof such that it works in the sleepy model. Other proof-of-stake protocols <a href="#page-50-5">[2,</a><a href="#page-50-6">4,</a><a href="#page-51-6">25]</a> may also bear superficial resemblance but they do not have formal security models or provable guarantees, and these protocols may also miss elements that turned out essential in our proofs.</p>

    <h2 id="sec-4" class="text-2xl font-bold">1.5 Related Work</h2>

    <p class="text-gray-300">We briefly review the rich body of literature on consensus, particularly focusing on protocols that achieve security against Byzantine faults where corrupt nodes can deviate arbitrarily from the prescribed behavior.</p>

    <p class="text-gray-300">Models for permissioned consensus. Consensus in the permissioned setting <a href="#page-50-8">[3,</a><a href="#page-50-9">6–</a><a href="#page-50-1">8,</a><a href="#page-50-2">12–</a><a href="#page-50-3">14,</a><a href="#page-51-1">17–</a> <a href="#page-51-12">19,</a> <a href="#page-51-2">22,</a> <a href="#page-51-13">26</a><a href="#page-51-3">–30,</a> <a href="#page-52-0">39]</a> has been actively studied for the past three decades; and we can roughly classify these protocols based on their network synchrony, their cryptographic assumptions, and various other dimensions.</p>

    <p class="text-gray-300">Roughly speaking, two types of network models are typically considered, the synchronous model, where messages sent by honest nodes are guaranteed to be delivered to all other honest nodes in the next round; and partially synchronous or asynchronous protocols where message delays may be unbounded, and the protocol must nonetheless achieve consistency and liveness despite not knowing any a-priori upper bound on the networks' delay. In terms of cryptographic assumptions, two main models have been of interest, the &quot;unauthenticated Byzantine&quot; model <a href="#page-51-14">[29]</a> where nodes are interconnected with authenticated channels<a href="#page-7-0">6</a> ; and the &quot;authenticated Byzantine&quot; model <a href="#page-50-0">[13]</a>, where</p>

    <p class="text-gray-300">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;6&lt;/sup&gt;This terminology clash stems from different terminology adopted by the distributed systems and cryptography communities.</p>

    <p class="text-gray-300">a public-key infrastructure exists, such that nodes can sign messages and such digital signatures can then be transferred.</p>

    <p class="text-gray-300">Permissioned, synchronous protocols. Many feasibility and infeasibility results have been shown. Notably, Lamport et al. [29] show that it is impossible to achieve secure consensus in the presence of a  <span class="math">\\frac{1}{3}</span>  coalition in the &quot;unauthenticated Byzantine&quot; model (even when assuming synchrony). However, as Dolev and Strong show [13], in a synchronous, authenticated Byzantine model, it is possible to design protocols that tolerate an arbitrary number of corruptions. It is also understood that no deterministic protocol fewer than f rounds can tolerate f faulty nodes [13] — however, if randomness is allowed, existing works have demonstrated expected constant round protocols that can tolerate up to a half corruptions [17,22].</p>

    <p class="text-gray-300">Permissioned, asynchronous protocols. A well-known lower bound by Fischer, Lynch, and Paterson [18] shows if we restrict ourselves to protocols that are deterministic and where nodes do not read clocks, then consensus would be impossible even when only a single node may crash. Known feasibility results typically circumvent this well-known lower bound by making two types of assumptions: 1) randomness assumptions, where randomness may come from various sources, e.g., a common coin in the sky [8,19,33], nodes' local randomness [3,39], or randomness in network delivery [7]; and 2) clocks and timeouts, where nodes are allowed to read a clock and make actions based on the clock's value. This approach has been taken by well-known protocols such as PBFT [12] and FaB [30] that use timeouts to re-elect leaders and thus ensure liveness even when the previous leader may be corrupt.</p>

    <p class="text-gray-300">Another well-known lower bound in the partially synchronous or asynchronous setting is due to Dwork et al. [14], who showed that no protocol (even when allowing randomness or clocks) can achieve security in the presence of a  <span class="math">\\frac{1}{3}</span>  (or larger) corrupt coalition.</p>

    <p class="text-gray-300">Guerraoui et al. [21] propose a technique to dynamically partition nodes into clusters with nice properties, such that they can achieve consensus in a hostile environment where nodes join and leave dynamically. Their scheme also fails in the sleepy model, when the set of online honest nodes in adjacent time steps can be completely disjoint.</p>

    <p class="text-gray-300"><strong>Permissionless consensus.</strong> The permissionless model did not receive sufficient academic attention, perhaps partly due to the existence of strong lower bounds such as what Canetti et al. showed [1]. Roughly speaking, we understand that without making additional trust assumptions, not many interesting tasks can be achieved in the permissionless model where authenticated channels do not exist between nodes.</p>

    <p class="text-gray-300">Amazingly, cryptocurrencies such as Bitcoin and Ethereum have popularized the permissionless setting, and have demonstrated to us, that perhaps contrary to the common belief, highly interesting and non-trivial tasks can be attained in the permissionless setting. Underlying these cryptocurrency systems is a fundamentally new type of consensus protocol commonly referred to as proof-of-work blockchains [35]. Upon closer examination, these protocols circumvent known lower bounds such as those by Canetti et al. [1] and Lamport et al. [29] since they rely on a new trust assumption, namely, proofs-of-work, that was not considered in traditional models.</p>

    <p class="text-gray-300">Formal understanding of the permissionless model has just begun [20,36–38]. Notably, Garay et al. [20] formally analyze the Nakamoto blockchain protocol in synchronous networks. Pass et al. [36] extend their analysis to asynchronous networks. More recently, Pass and Shi [38] show how to perform committee election using permissionless consensus and then bootstrap instances of</p>

    <p class="text-gray-300">permissioned consensus — in this way, they show how to asymptotically improve the response time for permissionless consensus.</p>

    <p class="text-gray-300">Finally, existing blockchains are known to suffer from a selfish mining attack [16], where a coalition wielding  <span class="math">\\frac{1}{3}</span>  of the computation power can reap up to a half of the rewards. Pass and Shi [37] recently show how to design a fair blockchain (called Fruitchains) from any blockchain protocol with positive chain quality. Since our Sleepy consensus protocol is a blockchain-style protocol, we also inherit the same selfish mining attack. However, we can leverage the same techniques as Pass and Shi [37] to build a fair blockchain from Sleepy.</p>

    <h2 id="sec-5" class="text-2xl font-bold">2 Definitions</h2>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;2.1 Protocol Execution Model</h3>

    <p class="text-gray-300">We assume a standard Interactive Turing Machine (ITM) model [9–11] often adopted in the cryptography literature.</p>

    <p class="text-gray-300">(Weakly) synchronized clocks. We assume that all nodes can access a clock that ticks over time. In the more general form, we allow nodes clocks to be offset by a bounded amount — commonly referred to as weakly synchronized clocks. We point out, that it is possible to apply a general transformation such that we can translate the clock offset into the network delay, and consequently in the formal model we may simply assume that nodes have synchronized clocks without loss of generality.</p>

    <p class="text-gray-300">Specifically, without loss of generality, assume nodes' clocks are offset by at most  <span class="math">\\Delta</span> , where  <span class="math">\\Delta</span>  is also the maximum network delay — if the two parameters are different, we can always take the maximum of the two incurring only constant loss. Below we show a transformation such that we can treat weakly synchronized clocks with maximum offset  <span class="math">\\Delta</span>  as setting with synchronized clocks but with network delay  <span class="math">3\\Delta</span> . Imagine the following transformation: honest nodes always queue every message they receive for exactly  <span class="math">\\Delta</span>  time before &quot;locally delivering&quot; them. In other words, suppose a node i receives a message from the network at local time t, it will ignore this message for  <span class="math">\\Delta</span>  time, and only act upon the received message at local time t, Now, if the sender of the message (say, node j) is honest, then j must have sent this message during its own local time  <span class="math">[t-2\\Delta, t+\\Delta]</span> . This suggests that if an honest node j sends a message at its local time t, then any honest node i must locally deliver the message during its local time frame  <span class="math">[t, t+3\\Delta]</span> .</p>

    <p class="text-gray-300">Therefore henceforth in this paper we consider a model with a globally synchronized clocks (without losing the ability to express weak synchrony). Each clock tick is referred to as an atomic <em>time step</em>. Nodes can perform unbounded polynomial amount of computation in each atomic time step, as well as send and receive polynomially many messages.</p>

    <p class="text-gray-300"><strong>Public-key infrastructure.</strong> We assume the existence of a public-key infrastructure (PKI). Specifically, we adopt the same technical definition of a PKI as in the Universal Composition framework [9]. Specifically, we shall assume that the PKI is an ideal functionality  <span class="math">\\mathcal{F}_{CA}</span>  (availabile only to the present protocol instance) that does the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>On receive register(upk) from  <span class="math">\\mathcal{P}</span> : remember (upk,  <span class="math">\\mathcal{P}</span> ) and ignore any future message from  <span class="math">\\mathcal{P}</span> .</li>
      <li>On receive  <span class="math">lookup(\\mathcal{P})</span> : return the stored upk corresponding to  <span class="math">\\mathcal{P}</span>  or  <span class="math">\\bot</span>  if none is found.</li>
    </ul>

    <p class="text-gray-300">In this paper, we will consider a Bare PKI model, nodes are allowed register their public keys with  <span class="math">\\mathcal{F}_{CA}</span>  any time during the exection — although typically, the honest protocol may specify</p>

    <p class="text-gray-300">that honest nodes register their public keys upfront at the beginning of the protocol execution (nonetheless, corrupt nodes may still register late).</p>

    <p class="text-gray-300">Corruption model. At the beginning of any time step t, Z can issue instructions of the form</p>

    <p class="text-gray-300">(corrupt, i) or (sleep,
<span class="math">$i, t_0, t_1</span>$
) where  <span class="math">t_1 \\ge t_0 \\ge t</span></p>

    <p class="text-gray-300">(corrupt, i) causes node i to become corrupt at the current time, whereas (sleep, i, t0, t1) where t&lt;sup&gt;1&lt;/sup&gt; ≥ t&lt;sup&gt;0&lt;/sup&gt; ≥ t will cause node i to sleep during [t0, t1]. Note that since corrupt or sleep instructions must be issued at the very beginning of a time step, Z cannot inspect an honest node's message to be sent in the present time step, and then retroactively make the node sleep in this time step and erase its message.</p>

    <p class="text-gray-300">Following standard cryptographic modeling approaches <a href="#page-50-12">[9–</a><a href="#page-50-13">11]</a>, at any time, the environment Z can communicate with corrupt nodes in arbitrary manners. This also implies that the environment can see the internal state of corrupt nodes. Corrupt nodes can deviate from the prescribed protocol arbitrarily, i.e., exhibit byzantine faults. All corrupt nodes are controlled by a probabilistic polynomial-time adversary denoted A, and the adversary can see the internal states of corrupt nodes. For honest nodes, the environment cannot observe their internal state, but can observe any information honest nodes output to the environment by the protocol definition.</p>

    <p class="text-gray-300">To summarize, a node can be in one of the following states:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Honest. An honest node can either be awake or asleep (or sleeping/sleepy). Henceforth we say that a node is alert if it is honest and awake. When we say that a node is asleep (or sleeping/sleepy), it means that the node is honest and asleep.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Corrupt. Without loss of generality, we assume that all corrupt nodes are awake.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Henceforth, we say that corruption (or sleepiness resp.) is static if Z must issue all corrupt (or sleep resp.) instructions before the protocol execution starts. We say that corruption (or sleepiness resp.) is adaptive if Z can issue corrupt (or sleep resp.) instructions at any time during the protocol's execution.</p>

    <p class="text-gray-300">Network delivery. The adversary is responsible for delivering messages between nodes. We assume that the adversary A can delay or reorder messages arbitrarily, as long as it respects the constraint that all messages sent from honest nodes must be received by all honest nodes in at most ∆ time steps.</p>

    <p class="text-gray-300">When a sleepy node wakes up, (A, Z) is required to deliver an unordered set of messages containing</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>all the pending messages that node i would have received (but did not receive) had it not slept; and</li>
      <li>any polynomial number of adversarially inserted messages of (A, Z)'s choice.</li>
    </ul>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Compliant Exections</h3>

    <p class="text-gray-300">Randomized protocol execution. We use the notation view←$EXECΠ(A, Z, λ) &lt;sup&gt;Π&lt;/sup&gt;(A, Z, λ) to denote a randomized execution of the protocol Π with security parameter λ and w.r.t. to an (A, Z) pair. Specifically, view is a random variable containing an ordered sequence of all inputs, outputs, and messages sent and received by all Turing Machines during the protocol's execution. We use the notation |view| to denote the number of time steps in the execution trace view.</p>

    <p class="text-gray-300">Parameters of an execution. Globally, we will use N to denote (an upper bound on) the total number of nodes, and Ncrupt to denote (an upper bound on) the number of corrupt nodes, and ∆ to denote the maximum delay of messages between alert nodes. More formally, we can define a (N, Ncrupt, ∆)-respecting (A, Z) as follows.</p>

    <p class="text-gray-300">Definition 1 ((N, Ncrupt, ∆)-respecting (A, Z)). Henceforth, we say that (A, Z) is (N, Ncrupt, ∆) respecting w.r.t. protocol Π, iff the following holds: for any view ∈ EXECΠ(A, Z, λ) with non-zero support,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(A, Z) spawns a total of N nodes in view among which Ncrupt are corrupt and the remaining are honest.</li>
      <li>If an alert node i gossips a message at time t in view, then any node j alert at time t &lt;sup&gt;0&lt;/sup&gt; ≥ t + ∆ (including ones that wake up after t) will have received the message.</li>
    </ul>

    <p class="text-gray-300">Henceforth when the context is clear, we often say that (A, Z) is (N, Ncrupt, ∆)-respecting omitting stating explicitly the protocol Π of interest.</p>

    <p class="text-gray-300">Protocol-specific compliance rules. A protocol Π may formally ensure certain security guarantees only in executions that respect certain compliance rules. Compliance rules can be regarded as constraints imposed on the (A, Z) pair. Henceforth, we assume that besides specifying the instructions of honest parties, a protocol Π will additionally specify a set of compliance rules. We will use the notation a</p>

    <p class="text-gray-300"><span class="math">$\\Pi</span>$
-compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  pair</p>

    <p class="text-gray-300">to denote an (A, Z) pair that respects the compliance rules of protocol Π — we also say that (A, Z) is compliant w.r.t. to the protocol Π.</p>

    <p class="text-gray-300">Additional protocol conventions. We adopt the universal composition framework <a href="#page-50-12">[9–</a><a href="#page-50-13">11]</a> for formal modeling. Each protocol instance and functionality is associated with a session identifier sid. We omit writing this session identifier explicitly without risk of ambiguity. We assume that ideal functionalities simply ignore all messages from parties not pertaining to the protocol instance of interest.</p>

    <p class="text-gray-300">Negligible functions. A function negl(·) is said to be negligible if for every polynomial p(·), there exists some λ&lt;sup&gt;0&lt;/sup&gt; such that negl(λ) ≤ 1 p(λ) for every λ ≥ λ0.</p>

    <p class="text-gray-300">Variable conventions. In this paper, unless otherwise noted, all variables are by default functions of the security parameter λ. Whenever we say var&lt;sup&gt;0&lt;/sup&gt; &gt; var1, this means that var0(λ) &gt; var1(λ) for every λ ∈ N. Similarly, if we say that a variable var is positive or non-negative, it means positive or non-negative for every input λ. Variables may also be functions of each other. How various variables are related will become obvious when we define derived variables and when we state parameters' admissible rules for each protocol. Importantly, whenever a parameter does not depend on λ, we shall explicitly state it by calling it a constant.</p>

    <p class="text-gray-300">Unless otherwise noted, we assume that all variables are non-negative (functions of λ). Further, unless otherwise noted, all variables are polynomially bounded (or inverse polynomially bounded if smaller than 1) functions of λ.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">3 Problem Definitions</h3>

    <p class="text-gray-300">In this section, we formally define a state machine replication protocol. State machine replication has been studied by the distributed systems literature for 30 years. In state machine replication, nodes agree on a linearly ordered log over time, in a way that satisfies consistency and liveness. In this section, we make explicit the formal abstraction for state machine replication. We then define an alternative blockchain abstraction first proposed by Garay et al. [20] and Pass et al. [36]. We point out that a blockchain abstraction implies the classical state machine replication abstraction as shown by Pass and Shi [38]. Therefore, while our final goal is to achieve classical state machine replication, we will construct a blockchain protocol as a stepping stone. Separately, this connection between modern blockchains and classical state machine replication is also interesting in its own right — this has been the common wisdom in the community, but we formalize this intuition.</p>

    <p class="text-gray-300">We will aim to realize a state machine replication abstraction, also frequently referred to as a &quot;totally ordered log&quot; or &quot;linearity&quot; by the distributed systems literature. In a replicated state machine, nodes agree on a LOG over time that is basically a list of transactions; and further, consistency and liveness are guaranteed.</p>

    <p class="text-gray-300">More formally, a state machine replication abstraction satisfies the following — here we adopt the same definitions as Pass and Shi [38].</p>

    <p class="text-gray-300">Inputs and outputs. The environment  <span class="math">\\mathcal{Z}</span>  may input a set of transactions txs to each alert node in every time step. In each time step, an alert node outputs to the environment  <span class="math">\\mathcal{Z}</span>  a totally ordered LOG of transactions (possibly empty).</p>

    <p class="text-gray-300">Security definitions. Let  <span class="math">T_{\\text{confirm}}</span>  be a polynomial function in in  <span class="math">\\lambda, N, N_{\\text{crupt}}</span> , and  <span class="math">\\Delta</span> . We say that a state machine replication protocol  <span class="math">\\Pi</span>  is secure and has transaction conformation time  <span class="math">T_{\\text{confirm}}</span>  if for every  <span class="math">\\Pi</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is  <span class="math">(N, N_{\\text{crupt}}, \\Delta)</span> -respecting, there exists a negligible function negl such that for every sufficiently large  <span class="math">\\lambda \\in \\mathbb{N}</span> , all but  <span class="math">\\text{negl}(\\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span>  satisfy the following properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Consistency: An execution trace view satisfies consistency if the following holds:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common prefix. Suppose that in view, an alert node i outputs LOG to  <span class="math">\\mathcal Z</span>  at time t, and an alert node j (same or different) outputs LOG' to  <span class="math">\\mathcal Z</span>  at time t', it holds that either LOG  <span class="math">\\prec</span>  LOG' or LOG'  <span class="math">\\prec</span>  LOG. Here the relation  <span class="math">\\prec</span>  means &quot;is a prefix of&quot;. By convention we assume that  <span class="math">\\emptyset \\prec x</span>  and  <span class="math">x \\prec x</span>  for any x.</li>
      <li>Self-consistency. Suppose that in view, a node i is alert at time t and  <span class="math">t&#x27; \\geq t</span> , and outputs LOG and LOG' at times t and t' respectively, it holds that LOG  <span class="math">\\prec</span>  LOG'.</li>
    </ul></li>
      <li>Liveness: An execution trace view satisfies  <span class="math">T_{\\text{confirm}}</span> -liveness if the following holds: suppose that in view, the environment  <span class="math">\\mathcal{Z}</span>  inputs txs to an alert node at time  <span class="math">t \\leq |\\text{view}| T_{\\text{confirm}}</span> . Then, for any node i alert at any time  <span class="math">t&#x27; \\geq t + T_{\\text{confirm}}</span> , let LOG be the output of node i at time t', it holds that any  <span class="math">\\text{tx} \\in \\text{txs}</span>  is included in LOG.</li>
    </ul>

    <p class="text-gray-300">Intuitively, liveness says that transactions input to an alert node get included in their LOGs within  <span class="math">T_{\\rm confirm}</span>  time.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.2 Blockchain Formal Abstraction</h3>

    <p class="text-gray-300">In this section, we define the formal abstraction and security properties of a blockchain. As Pass and Shi <a href="#page-52-3">[38]</a> recently show, a blockchain abstraction implies a classical state machine replication abstraction. Our definitions follow the approach of Pass et al. <a href="#page-52-2">[36]</a>, which in turn are based on earlier definitions from Garay et al. <a href="#page-51-7">[20]</a>, and Kiayias and Panagiotakos <a href="#page-51-18">[23]</a>.</p>

    <p class="text-gray-300">Since our model distinguishes between two types of honest nodes, alert and sleepy ones, we define chain growth, chain quality, and consistency for alert nodes. However, we point out the following: 1) if chain quality holds for alert nodes, it would also hold for sleepy nodes; 2) if consistency holds for alert nodes, then sleepy nodes' chains should also satisfy common prefix and future self-consistency, although obviously sleepy nodes' chains can be much shorter than alert ones.</p>

    <p class="text-gray-300">Inputs and outputs. We assume that in every time step, the environment Z provides a possibly empty input to every alert node. Further, in every time step, an alert node sends an output to the environment Z. Given a specific execution trace view with non-zero support where |view| ≥ t, let i denote a node that is alert at time t in view, we use the following notation to denote the output of node i to the environment Z at time step t,</p>

    <p class="text-gray-300">output to
<span class="math">$\\mathcal Z</span>$
by node  <span class="math">i</span>  at time  <span class="math">t</span>  in view:  <span class="math">\\mathsf{chain}_i^t(\\mathsf{view})</span></p>

    <p class="text-gray-300">where chain denotes an extracted ideal blockchain where each block contains an ordered list of transactions. Sleepy nodes stop outputting to the environment until they wake up again.</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">3.2.1 Chain Growth</h3>

    <p class="text-gray-300">The first desideratum is that the chain grows proportionally with the number of time steps. Let,</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{min\\text{-}chain\\text{-}increase}^{t,t&#x27;}(\\mathsf{view}) = \\min_{i,j} \\left( |\\mathsf{chain}_j^{t+t&#x27;}(\\mathsf{view})| - |\\mathsf{chain}_i^t(\\mathsf{view})| \\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{max-chain-increase}^{t,t&#x27;}(\\mathsf{view}) = \\max_{i,j} \\left( |\\mathsf{chain}_j^{t+t&#x27;}(\\mathsf{view})| - |\\mathsf{chain}_i^t(\\mathsf{view})| \\right)</span>$</p>

    <p class="text-gray-300">where we quantify over nodes i, j such that i is alert in time step t and j is alert in time t + t 0 in view.</p>

    <p class="text-gray-300">Let growtht0,t&lt;sup&gt;1&lt;/sup&gt; (view, ∆, T) = 1 iff the following two properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(consistent length) for all time steps t ≤ |view| − ∆, t + ∆ ≤ t &lt;sup&gt;0&lt;/sup&gt; ≤ |view|, for every two players i, j such that in view i is alert at t and j is alert at t 0 , we have that |chain&lt;sup&gt;t&lt;/sup&gt; 0 j (view)| ≥ |chain&lt;sup&gt;t&lt;/sup&gt; i (view)|</li>
      <li>(chain growth lower bound) for every time step t ≤ |view| − t0, we have</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mbox{min-chain-increase}^{t,t_0}(\\mbox{view}) \\geq T.</span>$</p>

    <p class="text-gray-300">• (chain growth upper bound) for every time step t ≤ |view| − t1, we have</p>

    <p class="text-gray-300"><span class="math">$\\max</span>$
-chain-increase <span class="math">^{t,t_1}(\\text{view}) \\leq T</span> .</p>

    <p class="text-gray-300">In other words, growtht0,t&lt;sup&gt;1&lt;/sup&gt; is a predicate which tests that a) alert parties have chains of roughly the same length, and b) during any t&lt;sup&gt;0&lt;/sup&gt; time steps in the execution, all alert parties' chains increase by at least T, and c) during any t&lt;sup&gt;1&lt;/sup&gt; time steps in the execution, alert parties' chains increase by at most T.</p>

    <p class="text-gray-300">Definition 2 (Chain growth). A blockchain protocol Π satisfies (T0, g0, g1)-chain growth, if for all Π-compliant pair (A, Z), there exists a negligible function negl such that for every sufficiently large λ ∈ N, T ≥ T0, t&lt;sup&gt;0&lt;/sup&gt; ≥ T g0 and t&lt;sup&gt;1&lt;/sup&gt; ≤ T g1 the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}^\\Pi(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{growth}^{t_0, t_1}(\\mathsf{view}, \\Delta, \\lambda) = 1\\right] \\geq 1 - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol Π satisfies (T0, g0, g1)-chain growth w.r.t. failure probability negl(·) if the above definition is satisfied when the negligible function is fixed to negl(·) for any Π-compliant (A, Z).</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2.2 Chain Quality</h2>

    <p class="text-gray-300">The second desideratum is that the number of blocks contributed by the adversary is not too large. Given a chain, we say that a block B := chain[j] is honest w.r.t. view and prefix chain[: j 0 ] where j &lt;sup&gt;0&lt;/sup&gt; &lt; j if in view there exists some node i alert at some time t ≤ |view|, such that 1) chain[: j 0 ] ≺ chain&lt;sup&gt;t&lt;/sup&gt; i (view), and 2) Z input B to node i at time t. Informally, for an honest node's chain denoted chain, a block B := chain[j] is honest w.r.t. a prefix chain[: j 0 ] where j &lt;sup&gt;0&lt;/sup&gt; &lt; j, if earlier there is some alert node who received B as input when its local chain contains the prefix chain[: j 0 ].</p>

    <p class="text-gray-300">Let quality&lt;sup&gt;T&lt;/sup&gt; (view, µ) = 1 iff for every time t and every player i such that i is alert at t in view, among any consecutive sequence of T blocks chain[j + 1..j +T] ⊆ chain&lt;sup&gt;t&lt;/sup&gt; i (view), the fraction of blocks that are honest w.r.t. view and chain[: j] is at least µ.</p>

    <p class="text-gray-300">Definition 3 (Chain quality). A blockchain protocol Π has (T0, µ)−chain quality, if for all Πcompliant pair (A, Z), there exists some negligible function negl such that for every sufficiently large λ ∈ N and every T ≥ T&lt;sup&gt;0&lt;/sup&gt; the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}^\\Pi(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{quality}^T(\\mathsf{view}, \\mu) = 1\\right] \\geq 1 - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol Π satisfies (T0, µ)-chain quality w.r.t. failure probability negl(·) if the above definition is satisfied when the negligible function is fixed to negl(·) for any Π-compliant (A, Z).</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.2.3 Consistency</h3>

    <p class="text-gray-300">Roughly speaking, consistency stipulates common prefix and future self-consistency. Common prefix requires that all honest nodes' chains, except for roughly O(λ) number of trailing blocks that have not stabilized, must all agree. Future self-consistency requires that an honest node's present chain, except for roughly O(λ) number of trailing blocks that have not stabilized, should persist into its own future. These properties can be unified in the following formal definition (which additionally requires that at any time, two alert nodes' chains must be of similar length).</p>

    <p class="text-gray-300">Let consistent&lt;sup&gt;T&lt;/sup&gt; (view) = 1 iff for all times t ≤ t 0 , and all players i, j (potentially the same) such that i is alert at t and j is alert at t 0 in view, we have that the prefixes of chain&lt;sup&gt;t&lt;/sup&gt; i (view) and chain&lt;sup&gt;t&lt;/sup&gt; 0 j (view) consisting of the first <code>= |chain&lt;sup&gt;t&lt;/sup&gt; i (view)| − T records are identical — this also implies that the following must be true: chain&lt;sup&gt;t&lt;/sup&gt; 0 j (view) &gt;</code>, i.e., chain&lt;sup&gt;t&lt;/sup&gt; 0 j (view) cannot be too much shorter than chain&lt;sup&gt;t&lt;/sup&gt; i (view) given that t &lt;sup&gt;0&lt;/sup&gt; ≥ t.</p>

    <p class="text-gray-300">Definition 4 (Consistency). A blockchain protocol Π satisfies T0-consistency, if for all Π-compliant pair (A, Z), there exists some negligible function negl such that for every sufficiently large λ ∈ N and every T ≥ T&lt;sup&gt;0&lt;/sup&gt; the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow \\mathsf{EXEC}^\\Pi(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{consistent}^T(\\mathsf{view}) = 1\\right] \\geq 1 - \\mathsf{negl}(\\lambda)</span>$</p>

    <p class="text-gray-300">Additionally, we say that a blockchain protocol Π satisfies T0-consistency w.r.t. failure probability negl(·) if the above definition is satisfied when the negligible function is fixed to negl(·) for any Π-compliant (A, Z).</p>

    <p class="text-gray-300">Note that a direct consequence of consistency is that at any time, the chain lengths of any two alert players can differ by at most T (except with negligible probability).</p>

    <p class="text-gray-300">We note that a blockchain protocol implies state machine replication, if alert nodes simply output the stablized part of their respective chains (i.e., chain[: −λ]) as their LOG. This draws a tight connection between modern blockchains and classical consensus (i.e., state machine replication) protocols that have been studied by the distributed systems literature for 30 years. In this paper, to obtain a classical state machine replication protocol, we will instead construct a blockchain protocol as a stepping stone.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;Lemma 1 (Blockchains imply state machine replication <a href="#page-52-3">[38]</a>). If there exists a blockchain protocol that satisfies (TG, g0, g1)-chain growth, (TQ, µ)-chain quality, and TC-consistency, then there exists a secure state machine replication protocol with confirmation time Tconfirm := O( TG+TQ+T&lt;sup&gt;C&lt;/sup&gt; g0 + ∆).</p>

    <p class="text-gray-300">Proof. This lemma was proved in the hybrid consensus paper <a href="#page-52-3">[38]</a> for a different execution model, but the same proof effectively holds in our sleepy execution model. Specifically, let Πblockchain be such a blockchain protocol. We can consider the following state machine replication protocol denoted Π&lt;sup&gt;0&lt;/sup&gt; : whenever an alert node is about to output chain to the environment Z in Πblockchain, it instead outputs chain[: −TC]. Further, suppose that Π&lt;sup&gt;0&lt;/sup&gt; 's compliance rules are the same as Πblockchain's. Using the same argument as the hybrid consensus paper <a href="#page-52-3">[38]</a>, it is not hard to see that the resulting protocol is a secure state machine replication protocol with confirmation time O( TG+TQ+T&lt;sup&gt;C&lt;/sup&gt; g0 + ∆).</p>

    <p class="text-gray-300">Therefore, henceforth in this paper, we will focus on realizing a blockchain protocol as a stepping stone towards realizing the standard notion of state machine replication.</p>

    <p class="text-gray-300">In this section, we will describe our basic Sleepy consensus protocol that is secure under static corruptions and static sleepiness. In other words, the adversary (and the environment) must declare upfront which nodes are corrupt as well as which nodes will go to sleep during which intervals. Furthermore, the adversary (and the environment) must respect the constraint that at any moment of time, roughly speaking the majority of online nodes are honest.</p>

    <p class="text-gray-300">For simplicity, we will first describe our scheme pretending that there is a random oracle H; and then describe how to remove the random oracle assuming a common reference string. We assume that the random oracle H instance is not shared with other protocols, and that the environment Z is not allowed to query the random oracle H directly, although it can query the oracle indirectly through A.</p>

    <h2 id="sec-13" class="text-2xl font-bold">4.1 Valid Blocks and Blockchains</h2>

    <p class="text-gray-300">Before we describe our protocol, we first define the format of valid blocks and valid blockchains.</p>

    <p class="text-gray-300">We use the notation chain to denote a real-world blockchain. Our protocol relies on an extract function that extracts an ordered list of transactions from chain which alert nodes shall output to the environment Z at each time step. A blockchain is obviously a chain of blocks. We now define a valid block and a valid blockchain.</p>

    <p class="text-gray-300">Valid blocks. We say that a tuple</p>

    <p class="text-gray-300"><span class="math">$B := (h_{-1}, \\mathsf{txs}, \\mathsf{time}, \\mathcal{P}, \\sigma, h)</span>$</p>

    <p class="text-gray-300">is a valid block iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Σ.verpk((h−1,txs,time); σ) = 1 where pk := FCA.lookup(P); and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>h = d(h−1,txs,time,P, σ), where d : {0, 1} &lt;sup&gt;∗&lt;/sup&gt; → {0, 1} λ is a collision-resistant hash function technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore d is a single function.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Valid blockchain. Let eligible&lt;sup&gt;t&lt;/sup&gt; (P) be a function that determines whether a party P is an eligible leader for time step t (see Figure <a href="#page-17-0">1</a> for its definition). Let chain denote an ordered chain of real-world blocks, we say that chain is a valid blockchain w.r.t. eligible and time t iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[0] = genesis = (⊥, ⊥,time = 0, ⊥, ⊥, h = ~0), commonly referred to as the genesis block;</li>
      <li>chain[−1].time ≤ t; and</li>
      <li>for all i ∈ [1..<code>] where </code> := |chain|, the following holds:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i] is a valid block;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i].h−&lt;sup&gt;1&lt;/sup&gt; = chain[i − 1].h;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i].time &gt; chain[i − 1].time, i.e., block-times are strictly increasing; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let t := chain[i].time, P := chain[i].P, it holds that eligible&lt;sup&gt;t&lt;/sup&gt; (P) = 1.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">We present our basic Sleepy consensus protocol in Figure <a href="#page-17-0">1.</a> The protocol takes a parameter p as input, where p corresponds to the probability each node is elected leader in a single time step. All nodes that just spawned will invoke the init entry point. During initialization, a node generates a signature key pair and registers the public key with the public-key infrastructure FCA.</p>

    <p class="text-gray-300">Now, our basic Sleepy protocol proceeds very much like a proof-of-work blockchain, except that instead of solving computational puzzles, in our protocol a node can extend the chain at time t iff it is elected leader at time t. To extend the chain with a block, a leader of time t simply signs a tuple containing the previous block's hash, the node's own party identifier, the current time t, as well as a set of transactions to be confirmed. Leader election can be achieved through a public hash function H that is modeled as a random oracle.</p>

    <p class="text-gray-300">Removing the random oracle. Although we described our scheme assuming a random oracle H, it is not hard to observe that we can replace the random oracle with a common reference string crs and a pseudo-random function PRF. Specifically, the common reference string k0←\${0, 1} λ is randomly generated after Z spawns all corrupt nodes and commits to when each honest node shall sleep. Then, we can simply replace calls to H(·) with with PRFk&lt;sup&gt;0&lt;/sup&gt; (·).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-17-0&quot;&gt;&lt;/span&gt;On input init() from Z:</p>

    <p class="text-gray-300">let (pk,sk) := Σ.gen(), register pk with FCA, let chain := genesis</p>

    <p class="text-gray-300">On receive chain&lt;sup&gt;0&lt;/sup&gt; :</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">assert |chain&lt;sup&gt;0&lt;/sup&gt; | &gt; |chain| and chain&lt;sup&gt;0&lt;/sup&gt; is valid w.r.t. eligible and the current time t; chain := chain&lt;sup&gt;0&lt;/sup&gt; and gossip chain</p>

    </blockquote>

    <p class="text-gray-300">Every time step:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>receive input transactions(txs) from Z</li>
      <li>let t be the current time, if eligible&lt;sup&gt;t&lt;/sup&gt; (P) where P is the current node's party identifier:</li>
    </ul>

    <pre><code class="language-text">let σ := Σ.sign(sk, chain[−1].h,txs, t), h
                                           0
                                            := d(chain[−1].h,txs, t,P, σ),
let B := (chain[−1].h,txs, t,P, σ, h0
                                     ), let chain := chain||B and gossip chain
</code></pre>

    <p class="text-gray-300">• output extract(chain) to Z where extract is the function outputs an ordered list containing the txs extracted from each block in chain</p>

    <p class="text-gray-300">Subroutine eligible&lt;sup&gt;t&lt;/sup&gt; (P):</p>

    <p class="text-gray-300">return 1 if H(P, t) &lt; D&lt;sup&gt;p&lt;/sup&gt; and P is a valid party of this protocol; else return 0</p>

    <p class="text-gray-300">Figure 1: The sleepy consensus protocol. The difficulty parameter D&lt;sup&gt;p&lt;/sup&gt; is defined such that the hash outcome is less than D&lt;sup&gt;p&lt;/sup&gt; with probability p. For simplicity, here we describe the scheme with a random oracle H — however as we explain in this section, H can be removed and replaced with a pseurdorandom function and a common reference string.</p>

    <p class="text-gray-300">Remark on how to interpret the protocol for weakly synchronized clocks. As mentioned earlier, in practice, we would typically adopt the protocol assuming nodes have weakly synchronized clocks instead of perfect synchronized clocks. Section <a href="#page-9-0">2.1</a> described a general protocol transformation that allows us to treat weakly synchronized clocks as synchronized clocks in formal reasoning (but adopting a larger network delay). Specifically, when deployed in practice assuming weakly synchronized clocks with up to ∆ clock offset, alert nodes would actually queue each received message for ∆ time before locally delivering the message. This ensures that alert nodes will not reject other alert nodes' chains mistakenly thinking that the block-time is in the future (due to clock offsets).</p>

    <p class="text-gray-300">Remark on foreknowledge of ∆. Note that our protocol Πsleepy(p) is parametrized with a parameter p, that is, the probability that any node is elected leader in any time step. Looking ahead, due to our compliance rules explained later in Section <a href="#page-18-0">4.3,</a> it is sufficient for the protocol to have foreknowledge of both N and ∆, then to attain a targeted resilience (i.e., the minimum ratio of alert nodes over corrupt ones in any time step), the protocol can choose an appropriate value for p based on the &quot;resilience&quot; compliance rules (see Section <a href="#page-18-0">4.3)</a>.</p>

    <p class="text-gray-300">Later in Section <a href="#page-48-1">8,</a> we will justify why foreknowledge of ∆ is necessary: we prove a lower bound showing that any protocol that does not have foreknowledge of ∆ cannot achieve state machine replication even when all nodes are honest.</p>

    <h2 id="sec-14" class="text-2xl font-bold">&lt;span id=&quot;page-18-0&quot;&gt;&lt;/span&gt;4.3 Compliant Executions</h2>

    <p class="text-gray-300">Our protocol can be proven secure as long as a set of constraints are expected, such as the number of alert vs. corrupt nodes. Below we formally define the complete set of rules that we expect (A, Z) to respect to prove security.</p>

    <p class="text-gray-300">Compliant executions. We say that (A, Z) is Πsleepy(p)-compliant if the following holds:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Static corruption and sleepiness. Z must issue all corrupt and sleep instructions prior to the start of the protocol execution. We assume that A cannot query the random oracle H prior to protocol start.</li>
      <li>Resilience. There are parameters (N, Ncrupt, ∆) such that (A, Z) is (N, Ncrupt, ∆)-respecting w.r.t. Πsleepy(p), and moreover, the following conditions are respected:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>There is a positive consant φ, such that for any view ∈ EXECΠsleepy(p) (A, Z, λ) with non-zero support, for every t ≤ |view|,</li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\frac{\\mathsf{alert}^t(\\mathsf{view})}{N_{\\mathsf{crupt}}} \\geq \\frac{1+\\phi}{1-2pN\\Delta}</span>$</p>

    <p class="text-gray-300">where alert&lt;sup&gt;t&lt;/sup&gt; (view) denotes the number of nodes that are alert at time t in view.</p>

    <p class="text-gray-300">– Further, there is some constant 0 &lt; c &lt; 1 such that 2pN∆ &lt; 1 − c.</p>

    <p class="text-gray-300">Informally, we require that at any point of time, there are more alert nodes than corrupt ones by a constant margin.</p>

    <p class="text-gray-300">Useful notations. We define additional notations that will become useful later.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let Nalert := Ncrupt · 1+φ 1−2pN∆ be a lower bound on the number of alert nodes in every time step;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let α := pNalert be a lower bound on the expected number of alert nodes elected leader in any single time step;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Let β := pNcrupt ≥ 1 − (1 − p) &lt;sup&gt;N&lt;/sup&gt;crupt be the expected number of corrupt nodes elected leader in any single time step; notice that β is also an upper bound on the probability that some corrupt node is elected leader in one time step.</li>
    </ol></li>
    </ul>

    <h2 id="sec-15" class="text-2xl font-bold">4.4 Theorem Statement</h2>

    <p class="text-gray-300">We now state our theorem for static corruption.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-18-1&quot;&gt;&lt;/span&gt;Theorem 3 (Security of Πsleepy under static corruption). Assume the existence of a common reference string (CRS), a bare public-key infrastructure (PKI), and that the signature scheme Σ is secure against any p.p.t. adversary. Then, for any constants , &lt;sup&gt;0&lt;/sup&gt; &gt; 0, any 0 &lt; p &lt; 1, any T&lt;sup&gt;0&lt;/sup&gt; ≥ 0λ, Πsleepy(p) satisfies (T0, g0, g1)-chain growth, (T0, µ)-chain quality, and T 2 0 consistency with exp(−Ω(λ)) failure probability for the following set of parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter g&lt;sup&gt;0&lt;/sup&gt; = (1 − )(1 − 2pN∆)α;</li>
      <li>chain growth upper bound parameter g&lt;sup&gt;1&lt;/sup&gt; = (1 + )N p; and</li>
      <li>chain quality parameter µ = 1 − 1− 1+φ .</li>
    </ul>

    <pre><code class="language-text">Ftree(p)
On init: tree := genesis, time(genesis) := 0
On receive leader(P, t) from A or internally:
   if Γ[P, t] has not been set, let Γ[P, t] := (
                                               1 with probability p
                                               0 o.w.
   return Γ[P, t]
On receive extend(chain, B) from P: let t be the current time:
   assert chain ∈ tree, chain||B ∈/ tree, and leader(P, t) outputs 1
   append B to chain in tree, record time(chain||B) := t, and return &quot;succ&quot;
On receive extend(chain, B, t0
                              ) from corrupt party P
                                                      ∗
                                                       : let t be the current time
   assert chain ∈ tree, chain||B ∈/ tree, leader(P
                                                  ∗
                                                   , t0
                                                      ) outputs 1, and time(chain) &lt; t0 ≤ t
   append B to chain in tree, record time(chain||B) = t
                                                         0
                                                         , and return &quot;succ&quot;
On receive verify(chain) from P: return (chain ∈ tree)
</code></pre>

    <p class="text-gray-300">Figure 2: Ideal functionality Ftree.</p>

    <p class="text-gray-300">where N, ∆, α and φ are parameters that can be determined by (A, Z) as well as p as mentioned earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be presented in Section <a href="#page-19-0">5.</a></p>

    <p class="text-gray-300">Corollary 1 (Statically secure state machine replication in the sleepy model.). Assume the existence of a common reference string (CRS), a bare public-key infrastructure (PKI), and that the signature scheme Σ is secure against any p.p.t. adversary. For any constant &gt; 0, there exists a protocol that achieves state machine replication assuming static corruptions and static sleepiness, and that &lt;sup&gt;1&lt;/sup&gt; &lt;sup&gt;2&lt;/sup&gt; + fraction of awake nodes are honest in any time step.</p>

    <p class="text-gray-300">Proof. Straightforward from Theorem <a href="#page-18-1">3</a> and Lemma <a href="#page-15-0">1.</a></p>

    <p class="text-gray-300">In this section, we present the proofs for the basic sleepy consensus protocol presented in Section <a href="#page-36-0">6.</a> We assume static corruption and static sleepiness and the random oracle model. Later in our paper, we will describe how to remove the random oracle, and further extend our protocol and proofs to adaptive sleepiness and adaptive corruptions.</p>

    <p class="text-gray-300">We start by analyzing a very simple ideal protocol denoted Πideal, where nodes interact with an ideal functionality Ftree that keeps track of all valid chains at any moment of time. Later in Section <a href="#page-33-0">5.8,</a> we will show that the real-world protocol Πsleepy securely emulates the ideal-world protocol.</p>

    <p class="text-gray-300">Ideal protocol. We first define a simplified protocol Πideal parametrized with an ideal functionality Ftree — see Figures <a href="#page-19-1">2</a> and <a href="#page-20-0">3.</a> Ftree flips random coins to decide whether a node is the elected</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Protocol <span class="math">\\Pi_{ideal}</span></h4>

    <p class="text-gray-300">&lt;span id=&quot;page-20-0&quot;&gt;&lt;/span&gt;On init: chain := genesis</p>

    <p class="text-gray-300">On receive chain': if |chain'| &gt; |chain| and  <span class="math">\\mathcal{F}_{tree}</span> .verify(chain') = 1: chain := chain', gossip chain</p>

    <p class="text-gray-300">Every time step:</p>

    <p class="text-gray-300"><span class="math">\\bullet\\,</span>  receive input B from  <span class="math">\\mathcal Z</span></p>

    <p class="text-gray-300"><span class="math">\\bullet \\ \\, \\mathrm{if} \\,\\, \\mathcal{F}_{\\mathrm{tree}}.\\mathtt{extend}(\\mathsf{chain},\\mathsf{B}) \\,\\, \\mathrm{outputs} \\,\\, \\text{\`\`succ&#x27;&#x27;} \\colon \\,\\, \\mathsf{chain} := \\mathsf{chain} || \\mathsf{B} \\,\\, \\mathrm{and} \\,\\, \\mathrm{gossip} \\,\\, \\mathsf{chain} \\\\</span></p>

    <p class="text-gray-300"><span class="math">\\bullet</span>  output chain to  <span class="math">{\\mathcal Z}</span></p>

    <p class="text-gray-300">Figure 3: Ideal protocol  <span class="math">\\Pi_{\\text{ideal}}</span></p>

    <p class="text-gray-300">leader for every time step, and an adversary  <span class="math">\\mathcal{A}</span>  can query this information (i.e., whether any node is a leader in any time step) through the leader query interface. Finally, alert and corrupt nodes can call  <span class="math">\\mathcal{F}_{\\text{tree}}</span> .extend to extend known chains with new blocks —  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  will then check if the caller is a leader for the time step to decide if the extend operation is allowed.  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  keeps track of all valid chains, such that alert nodes will call  <span class="math">\\mathcal{F}_{\\text{tree}}</span> .verify to decide if any chain they receive is valid. Alert nodes always store the longest valid chains they have received, and try to extend it.</p>

    <p class="text-gray-300">Observe that  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  has two entry points named extend — one of them is the honest version and the other is the corrupt version. In this ideal protocol, alert nodes always mine in the present, i.e., they always call the honest version of extend that uses the current time t. In this case, if the honest node succeeds in mining a new chain denoted chain,  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  records the current time t as chain's block-time by setting  <span class="math">\\mathcal{F}_{\\text{tree}}(\\text{view}).\\text{time}(\\text{chain}) = t</span> . On the other hand, corrupt nodes are allowed to call a malicious version of extend and supply a past time step t'. When receiving an input from the adversarial version of extend,  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  verifies that the new block's purported time t' respects the strictly increasing rule. If the corrupt node succeeds in mining a new block, then  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  records the purported time t' as the chain's block-time.</p>

    <p class="text-gray-300"><strong>Notations.</strong> Given some view sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{ideal}}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , we say that a chain  <span class="math">\\in \\mathcal{F}_{\\mathsf{tree}}(\\mathsf{view})</span> .tree has an block-time of t if  <span class="math">\\mathcal{F}_{\\mathsf{tree}}(\\mathsf{view})</span> .time(chain) = t. We say that a node  <span class="math">\\mathcal{P}</span>  (alert or corrupt) mines a chain'  <span class="math">= \\mathsf{chain}||\\mathsf{B}</span>  in time t if  <span class="math">\\mathcal{P}</span>  called  <span class="math">\\mathcal{F}_{\\mathsf{tree}}.\\mathsf{extend}(\\mathsf{chain}, \\mathsf{B})</span>  or  <span class="math">\\mathcal{F}_{\\mathsf{tree}}.\\mathsf{extend}(\\mathsf{chain}, \\mathsf{B}, \\_)</span>  at time t, and the call returned &quot;succ&quot;. Note that if an alert node mines a chain at time t, then the chain's block-time must be t as well. By contrast, if a corrupt node mines a chain at time t, the chain's block-time may not be truthful — it may be smaller than t.</p>

    <p class="text-gray-300">We say that  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{ideal}(p)</span> -compliant iff the pair is  <span class="math">\\Pi_{sleepy}(p)</span> -compliant. Since the protocols' compliance rules are the same, we sometimes just write compliant for short.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-20-1&quot;&gt;&lt;/span&gt;<strong>Theorem 4</strong> (Security of  <span class="math">\\Pi_{ideal}</span> ). For any constant  <span class="math">\\epsilon_0, \\epsilon &gt; 0</span> , any  <span class="math">T_0 \\geq \\epsilon_0 \\lambda</span> ,  <span class="math">\\Pi_{sleepy}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span> -consistency against any  <span class="math">\\Pi_{ideal}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , with  <span class="math">\\exp(-\\Omega(\\lambda))</span>  failure probability and the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 \\epsilon)(1 2pN\\Delta)\\alpha</span> ;</li>
      <li>chain growth upper bound parameter  <span class="math">g_1 = (1 + \\epsilon)Np</span> ; and</li>
      <li>chain quality parameter  <span class="math">\\mu = 1 \\frac{1-\\epsilon}{1+\\phi}</span> .</li>
    </ul>

    <p class="text-gray-300">where N, ∆, α and φ are parameters that can be determined by (A, Z) as well as p as mentioned earlier.</p>

    <p class="text-gray-300">In the remainder of this section, we will now prove the above Theorem <a href="#page-20-1">4.</a> We first explain a high-level roadmap and why, despite the similarity of our protocol in comparison with the Nakamoto proof-of-work blockchain, our proofs are nonetheless non-trivial and not implied by earlier formal analyses of the Nakamoto blockchain <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a>.</p>

    <p class="text-gray-300">Intuitions and differences from Nakamoto's ideal protocol. The key difference between our ideal protocol and Nakamoto's ideal protocol as described by Pass et al. <a href="#page-52-2">[36]</a> is the following. In Nakamoto's ideal protocol, if the adversary succeeds in extending a chain with a block, he cannot reuse this block and concatenate it with other chains. Here in our ideal protocol, if a corrupt node is elected leader in some time slot, he can reuse the elected slot in many possible chains. He can also instruct Ftree to extend chains with times in the past, as long as the chain's block-times are strictly increasing.</p>

    <p class="text-gray-300">Although our Ftree allows the adversary to claim potentially false block-times, we can rely on the following block-time invariants in our proofs: 1) honest blocks always have faithful block-times; and 2) any chain in Ftree must have strictly increasing block-times. Having observed these, we show that Pass et al.'s chain growth and chain quality proofs <a href="#page-52-2">[36]</a> can be adapted for our scenario.</p>

    <p class="text-gray-300">Unfortunately, the main challenge is how to prove consistency. As mentioned earlier, our adversary is much more powerful than the adversary for the Nakamoto blockchain and can launch a much wider range of attacks where he reuses the time slots during which he is elected. In Sections <a href="#page-26-0">5.5</a> and <a href="#page-27-0">5.6,</a> we present new techniques for analyzing the induced stochastic process.</p>

    <p class="text-gray-300">We now define a useful pattern called convergence opportunities, which we shall later use in both our chain growth lower bound proof as well as consistency proof. Intuitively, a convergence opportunity is a ∆-period of silence in which no alert node is elected leader, followed by a time step in which a single alert node is elected leader, followed by another ∆-period of silence in which no alert node is elected leader. We formalize this notion below.</p>

    <p class="text-gray-300">Convergence opportunity. Given a view, suppose T ≤ |view| − ∆, we say that [T − ∆, T + ∆] is a convergence opportunity iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For any t ∈ [max(0, T − ∆), T), no node alert at time t is elected leader;</li>
      <li>A single node alert at T is elected leader at time T;</li>
      <li>For any t ∈ (T, T + ∆], no node alert at time t is elected leader.</li>
    </ul>

    <p class="text-gray-300">Let T denote the time in which a single alert node is elected leader during a convergence opportunity. For convenience, we often use T to refer to the convergence opportunity. We say that a convergence opportunity T is contained within a window [t 0 : t] if T ∈ [t 0 : t].</p>

    <p class="text-gray-300">Henceforth, we use the notation C(view)[t 0 : t] to denote the number of convergence opportunities contained within the window [t 0 : t] in view.</p>

    <p class="text-gray-300">Many convergence opportunities. We now show that convergence opportunities happen sufficiently often.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-22-0&quot;&gt;&lt;/span&gt;<strong>Lemma 2</strong> (Number of convergence opportunities for any fixed window). For any  <span class="math">t_0, t_1 \\geq 0</span>  such that  <span class="math">t := t_1 - t_0 &gt; 0</span> , any  <span class="math">\\Pi_{ideal}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for any positive constant  <span class="math">\\eta</span> , there exists a constant  <span class="math">\\eta&#x27;</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{C}(\\textit{view})[t_0 : t_1] \\leq (1 - \\eta)(1 - 2pN\\Delta)\\alpha t\\right] &lt; \\exp(-\\eta'\\alpha t)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Consider some view, and imagine that  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  flips  <span class="math">\\operatorname{alert}^r(\\operatorname{view})</span>  coins for alert nodes (henceforth referred to as alert coins for short) in some time step r, where  <span class="math">\\operatorname{alert}^r(\\operatorname{view})</span>  denotes the number of alert nodes in time step r in view. Henceforth, we imagine all these alert coins are sequentialized.</p>

    <p class="text-gray-300">• Let <strong>X</strong> denote the total number of heads in all the alert coins during  <span class="math">[t_0, t_1]</span> . Due to the Chernoff bound, it is not hard to see that for any  <span class="math">\\epsilon &gt; 0</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{X} &lt; (1 - \\epsilon) \\cdot \\alpha t] \\le \\exp(-\\Omega(\\alpha t))</span>$</p>

    <p class="text-gray-300">Henceforth let  <span class="math">L := (1 - \\epsilon) \\cdot \\alpha t</span>  for a sufficiently small constant  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300">• Let  <span class="math">\\mathbf{Y}_i = 1</span>  iff after the <em>i</em>-th heads in the alert coin sequence during  <span class="math">[t_0, t_1]</span> , there exists a heads in the next  <span class="math">N_{\\text{alert}}\\Delta</span>  coin flips. Notice that all of the  <span class="math">\\mathbf{Y}_i</span> 's are independent — to see this, another way to think of  <span class="math">\\mathbf{Y}_i</span>  is that  <span class="math">\\mathbf{Y}_i = 0</span>  iff the <em>i</em>-th coin flip and the (i+1)-th coin flip are at least  <span class="math">N_{\\text{alert}}\\Delta</span>  apart from each other.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathbf{Y} := \\sum_{i=1}^{L} \\mathbf{Y}_{i}</span> . We have that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[\\mathbf{Y}] \\le (1 - (1 - p)^{N_{\\text{alert}}\\Delta}) \\cdot L \\le pN_{\\text{alert}}\\Delta \\cdot L = \\alpha \\Delta L</span>$</p>

    <p class="text-gray-300">By Chernoff bound, it holds that for any  <span class="math">\\epsilon_0 &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{Y} &gt; \\alpha \\Delta L + \\epsilon_0 L] \\le \\exp(-\\Omega(L)) = \\exp(-\\Omega(\\alpha t))</span>$</p>

    <p class="text-gray-300">• Let  <span class="math">\\mathbf{Z}_i = 1</span>  iff before the <em>i</em>-th heads in the alert coin sequence during  <span class="math">[t_0, t_1]</span> , there exists a heads in the previous  <span class="math">N_{\\text{alert}}\\Delta</span>  coin flips. Similar as before, all of the  <span class="math">\\mathbf{Z}_i</span> 's are independent. Let  <span class="math">\\mathbf{Z} := \\sum_{i=1}^{L} \\mathbf{Z}_i</span> . We have that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{E}[\\mathbf{Z}] \\le (1 - (1 - p)^{N_{\\text{alert}}\\Delta}) \\cdot L \\le pN_{\\text{alert}}\\Delta \\cdot L = \\alpha \\Delta L</span>$</p>

    <p class="text-gray-300">By Chernoff bound, it holds that for any  <span class="math">\\epsilon_0 &gt; 0</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{Z} &gt; \\alpha \\Delta L + \\epsilon_0 L] \\le \\exp(-\\Omega(L)) = \\exp(-\\Omega(\\alpha t))</span>$</p>

    <p class="text-gray-300">• Observe that for any view,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}(\\mathsf{view})[t_0:t_1] \\geq \\mathbf{X}(\\mathsf{view}) - \\mathbf{Y}(\\mathsf{view}) - \\mathbf{Z}(\\mathsf{view})</span>$</p>

    <p class="text-gray-300">Recall that our compliance rule implies that  <span class="math">\\alpha \\Delta \\leq pN\\Delta &lt; \\frac{1}{2}</span> . For any view where the aforementioned relevant bad events do not happen, we have that for any  <span class="math">\\eta &gt; 0</span> , there exist sufficiently small positive constants  <span class="math">\\epsilon_0</span>  and  <span class="math">\\epsilon</span>  such that the following holds:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{X} - \\mathbf{Y} - \\mathbf{Z} \\ge (1 - 2\\alpha\\Delta - 2\\epsilon_0)L = (1 - 2\\alpha\\Delta - 2\\epsilon_0) \\cdot (1 - \\epsilon) \\cdot \\alpha t</span>$
<span class="math">$\\ge (1 - \\eta)(1 - 2\\alpha\\Delta) \\cdot \\alpha t</span>$
<span class="math">$\\ge (1 - \\eta)(1 - 2pN\\Delta) \\cdot \\alpha t</span>$</p>

    <p class="text-gray-300">The proof concludes by observing that there are at most  <span class="math">\\exp(-\\Omega(\\alpha t))</span>  fraction&lt;sup&gt;7&lt;/sup&gt; of bad views that we could have ignored in the above.</p>

    <p class="text-gray-300">The above lemma was to bound the number of convergence opportunities for any fixed window. By taking a union bound, we can conclude that except for a negligible fraction of bad views, in all good views, it must hold that any sufficiently long window has many convergence opportunities. This is formally stated below.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-2&quot;&gt;&lt;/span&gt;Corollary 2 (Many convergence opportunities everywhere). For any positive constant  <span class="math">\\epsilon_0</span> , any  <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\alpha}</span> , for any  <span class="math">\\prod_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , any positive constant  <span class="math">\\eta</span> , there exists a positive constant  <span class="math">\\eta&#x27;</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta&#x27;\\lambda)</span>  fraction of views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , the following property holds:</p>

    <p class="text-gray-300">For any
<span class="math">$t_0</span>$
,  <span class="math">\\mathbf{C}(\\text{view})[t_0: t_0 + t] &gt; (1 - \\eta)(1 - 2pN\\Delta)\\alpha t</span></p>

    <p class="text-gray-300"><em>Proof.</em> Follows in a straightforward manner from Lemma 2 by taking a union bound over all windows of length t.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">5.3 Chain Growth Lower Bound</h4>

    <p class="text-gray-300">To prove chain growth lower bound, we observe that for any view, whenever there is a convergence opportunity, the shortest honest chain must grow by at least 1 (see Fact 1). Since earlier, we proved that except with negligible probability over the choice of view, there are many convergence opportunities, it naturally follows that honest chains must grow not too slowly. We now formalize this intuition.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-1&quot;&gt;&lt;/span&gt;<strong>Fact 1.</strong> For any view, any  <span class="math">t_0</span> , any  <span class="math">t_1 \\ge t_0</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}(\\mathsf{view})[t_0:t_1-\\Delta] \\leq \\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_0:t_1]</span>$</p>

    <p class="text-gray-300">where min_chain_increase(view)[ <span class="math">t_0:t_1</span> ] is the length of the shortest honest chain at the beginning of time step  <span class="math">t_1</span>  minus the length of the longest honest chain at the beginning of time step  <span class="math">t_0</span>  in view.</p>

    <p class="text-gray-300"><em>Proof.</em> By simple induction: given any view, any  <span class="math">t_0</span> , suppose that the fact holds for any  <span class="math">t_1 \\leq t^*</span> . We now show that it holds for time  <span class="math">t_1 = t^* + 1</span>  as well. If time  <span class="math">t^* - \\Delta + 1</span>  does not correspond to a convergence opportunity, the induction step is trivial. Otherwise, if time  <span class="math">t^* - \\Delta + 1</span>  corresponds to a convergence opportunity, by definition of convergence opportunity, we have that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{C}(\\mathsf{view})[t_0:t^*+1-\\Delta] = \\mathbf{C}(\\mathsf{view})[t_0:t^*-\\Delta] + 1 = \\mathbf{C}(\\mathsf{view})[t_0:t^*+1-2\\Delta] + 1</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-23-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;7&lt;/sup&gt;Whenever we refer to the fraction of views, we mean the total probability mass of all views of interest.</p>

    <p class="text-gray-300">By induction hypothesis, we have that</p>

    <p class="text-gray-300"><span class="math">$\\min_{\\text{chain\\_increase}(\\text{view})}[t_0:t^*+1-\\Delta]+1 \\ge \\mathbf{C}(\\text{view})[t_0:t^*+1-2\\Delta]+1 = \\mathbf{C}(\\text{view})[t_0:t^*+1-\\Delta]</span>$
(1)</p>

    <p class="text-gray-300">Additionally, we have that at the end of time step  <span class="math">t^*+1-\\Delta</span> , there is an honest chain whose length is at least min_alert_len&lt;sup&gt;t*+1-\\Delta&lt;/sup&gt;(view) + 1, where min_alert_len&lt;sup&gt;t*+1-\\Delta&lt;/sup&gt;(view) denotes the length of the shortest alert chain at the beginning time  <span class="math">t^*+1-\\Delta</span> . Since network delay is bounded by  <span class="math">\\Delta</span> , at the beginning of time time  <span class="math">t^*+1</span> , every alert node's chain must be at least min_alert_len&lt;sup&gt;t*+1-\\Delta&lt;/sup&gt;(view)+1 blocks long. In other words, we have that</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-0&quot;&gt;&lt;/span&gt;
<span class="math">$\\label{eq:min_chain_increase} \\begin{aligned} &amp; \\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_0:t^*+1] \\geq &amp; \\mathsf{min\\_chain\\_increase}(\\mathsf{view})[t_0:t^*+1-\\Delta] + 1 \\end{aligned} \\end{aligned} \\tag{2}</span>$</p>

    <p class="text-gray-300">The remainder of the induction step follows directly from Equations 1 and 2.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Lemma 3</strong> (Chain growth lower bound). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for any positive constants  <span class="math">\\epsilon_0</span> ,  <span class="math">\\epsilon</span>  and any  <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\alpha}</span> , there exists a positive constant  <span class="math">\\eta</span> , such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\alpha t)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , the following holds:</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-1&quot;&gt;&lt;/span&gt;For any
<span class="math">$t_0</span>$
, min_chain_increase(view)[ <span class="math">t_0:t_0+t</span> ]  <span class="math">\\geq (1-\\epsilon)(1-2pN\\Delta)\\alpha t-1</span></p>

    <p class="text-gray-300"><em>Proof.</em> Ignore the  <span class="math">\\exp(-\\Omega(\\lambda))</span>  fraction of views where bad events pertaining to Corollary 2 take place. For every remaining good view, due to Fact 1 and Corollary 2, it holds that for every positive constant  <span class="math">\\epsilon</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\begin{aligned} &amp; \\text{min\\_chain\\_increase(view)}[t_0:t_0+t] &gt; (1-\\epsilon)(1-2pN\\Delta)\\alpha(t-\\Delta) \\\\ = &amp; (1-\\epsilon)(1-2pN\\Delta)\\alpha t - (1-\\epsilon)(1-2pN\\Delta)\\alpha\\Delta \\geq (1-\\epsilon)(1-2pN\\Delta)\\alpha t - 1 \\end{aligned}</span>$</p>

    <p class="text-gray-300">where the last inequality is due to the fact  <span class="math">\\alpha\\Delta &lt; 2pN\\Delta &lt; 1</span>  which stems from the compliance rules.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">5.4 Chain Quality</h3>

    <p class="text-gray-300">Intuitively, we will prove chain quality by comparing how often corrupt nodes are elected leaders with the honest chain growth lower bound. If corrupt nodes are elected leaders less often than minimum honest chain growth, we can thus conclude that there cannot be too many corrupt blocks in an honest node's chain. We formalize this intuition below.</p>

    <p class="text-gray-300">Upper bound on adversarial time slots. Given a view, let  <span class="math">\\mathbf{A}(\\text{view})[t_0:t_1]</span>  denote the number of time steps in which at least one corrupt node is elected leader during the window  <span class="math">[t_0:t_1]</span> . Let  <span class="math">\\mathbf{A}^t(\\text{view})</span>  denote the <em>maximum</em> number of time steps in which at least one corrupt node is elected leader in any t-sized window in view.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-24-2&quot;&gt;&lt;/span&gt;Fact 2 (Upper bound on adversarial time slots for any fixed window). For any  <span class="math">t_0</span>  and  <span class="math">t_1</span>  such that  <span class="math">t := t_1 - t_0 \\ge 0</span> , for any  <span class="math">\\Pi_{\\text{ideal}}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for any constant  <span class="math">0 &lt; \\epsilon &lt; 1</span>  and any  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathrm{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{A}(\\mathsf{view})[t_0:t_1] &gt; (1+\\epsilon)\\beta t\\right] \\leq \\exp(-\\frac{\\epsilon^2 \\beta t}{3})$$</p>

    <p class="text-gray-300"><em>Proof.</em> From a straightforward application of the Chernoff bound.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-25-0&quot;&gt;&lt;/span&gt;Fact 3 (Upper bound on adversarial time slots everywhere). For any  <span class="math">\\Pi_{\\text{ideal}}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , any positive constant  <span class="math">\\epsilon_0</span> , any  <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\beta}</span> , for any constant  <span class="math">0 &lt; \\epsilon &lt; 1</span> , there exists a positive constant  <span class="math">\\eta</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathsf{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{A}^t(\\mathsf{view}) &gt; (1+\\epsilon)\\beta t\\right] \\leq \\exp(-\\eta \\lambda)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward by Fact 2 and taking union bound over all possible windows of length t in view.</p>

    <p class="text-gray-300"><strong>Lemma 4</strong> (Chain quality). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , any positive constant  <span class="math">\\epsilon_0, \\epsilon</span> , any  <span class="math">T \\geq \\epsilon_0 \\lambda</span> , there exists a positive constant  <span class="math">\\eta</span>  such that for all  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds for  <span class="math">\\mu := 1 - \\frac{1+\\epsilon}{1+\\phi}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\textit{quality}^T(\\textit{view}, \\mu) = 1\\right] \\geq 1 - \\exp(-\\eta \\lambda)</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let r be any time step, let i be any node honest at  <span class="math">r \\leq |\\mathsf{view}|</span> . Consider an arbitrary honest chain  <span class="math">\\mathsf{chain} := \\mathsf{chain}_i^r(\\mathsf{view})</span> , and an arbitrary sequence of T blocks  <span class="math">\\mathsf{chain}[j+1..j+T] \\subset \\mathsf{chain}_i^r</span> , such that  <span class="math">\\mathsf{chain}[j]</span>  is not adversarial (either an honest block or  <span class="math">\\mathsf{genesis}</span> ); and  <span class="math">\\mathsf{chain}[j+T+1]</span>  is not adversarial either (either an honest block or  <span class="math">\\mathsf{chain}[j+T]</span>  is end of  <span class="math">\\mathsf{chain}_i^r</span> ). Note that if a sequence of blocks is not sandwiched between two honest blocks (including genesis or end of  <span class="math">\\mathsf{chain}</span> ), we can always expand the sequence to the left and right to find a maximal sequence sandwiched by honest blocks (including genesis or end of  <span class="math">\\mathsf{chain}</span> ). Such an expansion will only worsen chain quality.</p>

    <p class="text-gray-300">For an honest block, its block-time must be faithful, i.e., corresponding to the time step in which the block was mined (recall that the block-time of genesis is 0). Consequently, by definition of  <span class="math">\\Pi_{\\text{ideal}}</span>  and  <span class="math">\\mathcal{F}_{\\text{tree}}</span> , the block-times of all blocks in chain[j+1..j+T] must be bounded in between r' and r'+t, where r' denotes the time step in which the honest (or genesis) block chain[j] was mined, and r'+t denotes the time step in which chain[j+T+1] is mined (or let r'+t:=r if chain[j+T] is end of chain[r]).</p>

    <p class="text-gray-300">We ignore any views where bad events related to chain growth lower bound or adversarial time slot upper bound take place. The fraction of views ignored is upper bounded by  <span class="math">\\exp(-\\Omega(T)) \\cdot \\operatorname{poly}(\\lambda)</span> .</p>

    <p class="text-gray-300">• Now, due to chain growth lower bound, for any positive constant  <span class="math">\\epsilon</span> , we have that</p>

    <p class="text-gray-300"><span class="math">$t &lt; \\frac{T}{(1-\\epsilon)(1-2pN\\Delta)\\alpha}</span>$</p>

    <p class="text-gray-300">• Due to adversarial time slot upper bound (Fact 3), for any positive constant  <span class="math">\\epsilon&#x27;&#x27; &gt; 0</span> , there exists a sufficiently small positive constants  <span class="math">\\epsilon&#x27;</span>  (which depends on  <span class="math">\\epsilon</span> ,  <span class="math">\\epsilon&#x27;&#x27;</span> , and  <span class="math">\\phi</span> ), such that</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}[r&#x27;:r&#x27;+t] \\leq \\mathbf{A}[r&#x27;:r&#x27; + \\frac{T}{(1-\\epsilon)(1-2pN\\Delta)\\alpha}]</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{(1+\\epsilon&#x27;)\\beta T}{(1-\\epsilon)(1-2pN\\Delta)\\alpha}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{(1+\\epsilon&#x27;)(1-2pN\\Delta)T}{(1-\\epsilon)(1-2pN\\Delta)(1+\\phi)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq \\frac{(1+\\epsilon&#x27;&#x27;)T}{1+\\phi}</span>$</p>

    <p class="text-gray-300">• Therefore, the fraction of honest blocks in this length T sequence is lower bounded by</p>

    <p class="text-gray-300"><span class="math">$1 - \\frac{1 + \\epsilon&#x27;&#x27;}{1 + \\phi}</span>$</p>

    <h2 id="sec-19" class="text-2xl font-bold">&lt;span id=&quot;page-26-0&quot;&gt;&lt;/span&gt;5.5 Consistency: Proof Intuition</h2>

    <p class="text-gray-300">Since this is the most non-trivial part of our proof and where we significantly depart from earlier blockchain proofs <a href="#page-51-7">[20,</a> <a href="#page-52-2">36]</a>, we will first explain the intuition before presenting the formal proof.</p>

    <p class="text-gray-300">Review: consistency proof for the Nakamoto blockchain. We first review how Pass et al. <a href="#page-52-2">[36]</a> proved consistency for the Nakamoto blockchain, and explain why their proof fails in our setting. This will help to clarify the challenges of the proof. To prove consistency, Pass et al. rely on the notion of a convergence opportunity. Recall that we formally defined a convergence opportunity in Section <a href="#page-21-0">5.2</a> (Pass et al.'s notion is almost identical except that in their model alert nodes and honest nodes mean the same): a convergence opportunity is a period of time in which 1) there is a ∆-long period of silence in which no honest node mines a block; and 2) followed by a time step in which a single honest node mines a block; and 3) followed by yet another ∆-long period of silence in which no honest node mines a block. Whenever there is a convergence period, and suppose that at the beginning of the convergence period the maximum chain length of any honest node is <code>. Then, it is not hard to see that there can be at most one honest block (if any) in position </code> + 1 in any honest node's chain — since after the first period of silence, all honest nodes' chain must be of length at least <code>; and after the second period of silence, all honest nodes' chain length must be at least </code> + 1. Therefore, after the convergence period, no honest node will ever mine at position \` + 1 again. However, recall that within the convergence period, only a single honest node ever mines a block.</p>

    <p class="text-gray-300">Now, Pass et al. <a href="#page-52-2">[36]</a> observes that for the adversary to cause divergence at some time s or earlier, for every convergence opportunity after time s, the adversary must mine a chain of length <code>+ 1 where</code> is the maximum chain length of any honest node at the beginning of the convergence period. This means that from time</p>

    <p class="text-gray-300"><span class="math">$(s - [small block withholding window])</span>$</p>

    <p class="text-gray-300">onward, the adversary must have mined more blocks than the number of convergence opportunities since s.</p>

    <p class="text-gray-300">Pass et al. <a href="#page-52-2">[36]</a> then goes to show that if s is sufficiently long ago, this cannot happen — in other words, there has to be more convergence opportunities than adversarially mined blocks in any sufficiently long time window, even when adjusted for block withholding attacks. Proving an upper bound on adversarially mined blocks in any window is relatively easy, therefore most of their proof focuses on lower bounding the number of convergence opportunities within any time window (our Lemma <a href="#page-22-0">2</a> earlier provided a simplified proof adapted to our sleepy model).</p>

    <p class="text-gray-300">Why their proof breaks in our setting. The consistency proof by Pass et al. <a href="#page-52-2">[36]</a> crucially relies on the following fact: when an adversary successfully extends a chain with a block, he cannot simply transfer this block at no cost to extend any other chain. For this reason, to mine a chain of length <code>+ 1 for each different</code> will require separate computational effort, and no effort can ever be reused.</p>

    <p class="text-gray-300">Unfortunately, this crucial observation no longer holds in our protocol when proof-of-work is removed. If a corrupt node is elected in a certain time step t, he can now reuse this earned time slot to extend multiple chains, possibly at different lengths. Recall that Pass et al's consistency proof relies on arguing that the adversary cannot have mined chains of many different lengths. Unfortunately, in our case, such an argument will not work. In particular, how many times the adversary is elected leader (the direct analogy of how many times an adversary mines a block in a proof-of-work blockchain) does not translate to how many chain lengths the adversary can attack (by composing an adversarial chain of that length). It now appears that a fundamentally new proof strategy is necessary.</p>

    <p class="text-gray-300">Roadmap of our proof. Our proof strategy is the following. We will define a good event called a (strong) pivot point. Roughly speaking, a (strong) pivot is a point of time t, such that if one draws any window of time [t0, t1] that contains t, the number of adversarial time slots in that window, if non-zero, must be strictly smaller than the number of convergence opportunities in the same window. We will show the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A pivot forces convergence: for any view where certain negligible-probability bad events do not happen: if there is such a pivot point t in view, then the adversary cannot have caused divergence prior to t.</li>
      <li>Pivots happen frequently: for all but negligible fraction of the views, pivot points happen frequently in time — particularly,</li>
    </ul>

    <p class="text-gray-300">in any sufficiently long time window there must exist such a pivot point. This then implies that if one removes sufficiently many trailing blocks from an alert node's chain (recall that by chain growth, block numbers and time roughly translate to each other), the remaining prefix must be consistent with any other alert node.</p>

    <p class="text-gray-300">Remark 1. For clarity, we first present a somewhat loose version of the consistency proof, where we need to chop of poly(λ) trailing blocks for consistency. Later in Appendix <a href="#page-52-5">A,</a> we present a tighter version of the analysis, where we only need to chop off λ trailing blocks to obtain exp(−Ω(λ)) security failure.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-27-0&quot;&gt;&lt;/span&gt;5.6 Consistency: the Proof</h3>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">5.6.1 Definition of Pivots and Strong Pivots</h3>

    <p class="text-gray-300">We first define two good events called a pivot and a strong pivot respectively. As mentioned, a strong pivot is a point of time in view such that in any window that contains the time t, the number of adversarial slots, if not zero, must be strictly smaller than the number of convergence opportunities in the same window. A pivot is a slightly weakened version of a strong pivot, requiring that the above condition hold for any window containing t that is not too long.</p>

    <p class="text-gray-300">Definition 5 (Strong pivot). Given a view, a time step t is said to be a strong pivot in view, if for any t&lt;sup&gt;0&lt;/sup&gt; ≤ t ≤ t1, it holds that C(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] &gt; A(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] or A(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] = 0.</p>

    <p class="text-gray-300">Definition 6 (Pivot). Given a view, a time step t is said to be a w-pivot in view, if for any t&lt;sup&gt;0&lt;/sup&gt; ≤ t ≤ t&lt;sup&gt;1&lt;/sup&gt; such that t&lt;sup&gt;1&lt;/sup&gt; − t&lt;sup&gt;0&lt;/sup&gt; ≤ w, it holds that C(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] &gt; A(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] or A(view)[t&lt;sup&gt;0&lt;/sup&gt; : t1] = 0.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">5.6.2 Strong Pivots Force Convergence</h4>

    <p class="text-gray-300">We first define what it means for two valid chains to diverge at some time t, this is defined in the most natural manner as below:</p>

    <p class="text-gray-300"><strong>Definition 7</strong> (Divergence). Given any two chains  <span class="math">\\mathsf{chain}_0, \\mathsf{chain}_1 \\in \\mathcal{F}_{\\mathsf{tree}}.\\mathsf{tree}</span> , we say that they diverge at time t if their longest common prefix has an block-time before t.</p>

    <p class="text-gray-300">We now prove that a strong pivot will force convergence, i.e., divergence cannot happen before a strong pivot in any view.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-1&quot;&gt;&lt;/span&gt;<strong>Lemma 5</strong> (Divergence cannot happen before a strong pivot). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a positive constant  <span class="math">\\eta</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , the following must hold: Let i be alert at time any r and j be alert at any  <span class="math">r&#x27; \\geq r</span>  in view; let  <span class="math">t &lt; r - \\frac{\\lambda}{\\beta}</span>  be a strong pivot in view. Then,  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span>  cannot diverge at t in view.</p>

    <p class="text-gray-300"><em>Proof.</em> Suppose that T is a convergence opportunity in view, and that a single alert node that mines a block at length  <span class="math">\\ell</span>  at time T in view. Henceforth, we say that such a length  <span class="math">\\ell</span>  corresponds to a convergence opportunity in view. We first present a simple fact about convergence opportunities that follows directly from the definition of convergence opportunities.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-28-0&quot;&gt;&lt;/span&gt;Fact 4 (Uniqueness of an honest block in any convergence opportunity). Given any view, let i be alert at time r and j be alert at  <span class="math">r&#x27; \\geq r</span>  in view. If the length  <span class="math">\\ell</span>  corresponds to a convergence opportunity in view, and  <span class="math">\\mathrm{chain}_i^r[\\ell]</span>  and  <span class="math">\\mathrm{chain}_i^r[\\ell]</span>  are both honest blocks, then it follows that  <span class="math">\\mathrm{chain}_i^r[\\ell] = \\mathrm{chain}_i^r[\\ell]</span> .</p>

    <p class="text-gray-300">Henceforth, we ignore the  <span class="math">\\exp(-\\Omega(\\lambda))</span>  fraction of bad views where bad events related to Corollary 2 take place. For the remaining good views, since  <span class="math">t &lt; r - \\frac{\\lambda}{\\beta}</span> , it must hold that  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span>  both contain a position (i.e., length) corresponding to a convergence opportunity whose block-time is after t.</p>

    <p class="text-gray-300">Now, for both  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span> , we look to the left and right of t, and identify the first honest block that corresponds to a convergence opportunity on both sides. In other words, in both  <span class="math">\\mathsf{chain}_i^{r&#x27;}</span>  and  <span class="math">\\mathsf{chain}_i^{r&#x27;}</span> , we identify</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The last honest block that corresponds to a convergence opportunity and moreover, whose block-time is  <span class="math">\\leq t</span> . Let  <span class="math">\\mathsf{B}_i</span>  and  <span class="math">\\mathsf{B}_j</span>  denote the blocks found in this manner for  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span>  respectively.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>The first honest block that corresponds to a convergence opportunity and moreover, whose block-time is  <span class="math">\\geq t</span> . Let  <span class="math">\\widehat{\\mathsf{B}}_i</span>  and  <span class="math">\\widehat{\\mathsf{B}}_j</span>  denote the blocks found in this manner for  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span>  respectively.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Now there are two cases:</p>

    <p class="text-gray-300">• Case 1: t is a convergence opportunity. In this case, the adversary cannot be leader at time t since otherwise it violates the definition of t being a strong pivot. Further, if t is a convergence opportunity, there can only be a unique honest block denoted  <span class="math">B^*</span>  mined at time t in view by Fact 4. Summarizing the above, we conclude that  <span class="math">B_i = \\widehat{B}_i = B_j = \\widehat{B}_j = B^*</span> , and thus chain and chain and chain cannot diverge at t in view.</p>

    <p class="text-gray-300">• Case 2: t is not a convergence opportunity. In this case, by the definition of a strong pivot, we claim that in  <span class="math">\\mathsf{chain}_i^r</span> , in between  <span class="math">\\mathsf{B}_i</span>  and  <span class="math">\\widehat{\\mathsf{B}}_i</span> , there cannot be any adversarial blocks — since otherwise for the window  <span class="math">[\\mathsf{B}_i.\\mathsf{time}+1,\\mathsf{B}_j.\\mathsf{time}-1]</span>  there will be more adversarial blocks than convergence opportunities. This means that there cannot be any convergence opportunity between  <span class="math">[\\mathsf{B}_i.\\mathsf{time}+1,\\mathsf{B}_j.\\mathsf{time}-1]</span>  in view, since otherwise, either  <span class="math">\\mathsf{B}_i</span>  is not the nearest honest block corresponding to a convergence opportunity to the left of t in  <span class="math">\\mathsf{chain}_i^r</span> , or  <span class="math">\\widehat{\\mathsf{B}}_i</span>  is not the nearest honest block corresponding to a convergence opportunity to the right of t in  <span class="math">\\mathsf{chain}_i^r</span> . To summarize,  <span class="math">\\mathsf{B}_i.\\mathsf{time}</span>  and  <span class="math">\\widehat{\\mathsf{B}}_i.\\mathsf{time}</span>  must be the two convergence opportunities closest in time to t on either side of t in view.</p>

    <p class="text-gray-300">Similarly, we can conclude that  <span class="math">B_j</span>  time and  <span class="math">\\widehat{B}_j</span>  time must be the two convergence opportunities closest in time to t on either side of t in view. Therefore, we know that  <span class="math">\\widehat{B}_i</span>  and  <span class="math">\\widehat{B}_j</span>  are honest blocks correspond to the same convergence opportunity in view, and thus  <span class="math">\\widehat{B}_i = \\widehat{B}_j</span>  since there can only be a unique honest block corresponding to every convergence opportunity by Fact 4. This also implies that  <span class="math">\\operatorname{chain}_i^r</span>  and  <span class="math">\\operatorname{chain}_i^{r&#x27;}</span>  cannot have diverged at t.</p>

    <h2 id="sec-23" class="text-2xl font-bold">5.6.3 Strong Pivots Recur Frequently</h2>

    <p class="text-gray-300">We proceed in several steps to show that strong pivots happen frequently in almost all views.</p>

    <p class="text-gray-300">Convergence opportunities vs. adversarial time slots. First, we prove a lemma showing that given a window  <span class="math">[t_0, t_1]</span> , it is likely that there are more convergence opportunities in this window than adversarial time slots. In particular, the longer the window is, the more likely that convergence opportunities &quot;win&quot; in comparison with adversarial time slots. In other words, for sufficiently long windows, convergence opportunities win almost surely. For shorter windows, convergence opportunities are nonetheless likely to win although not almost surely.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-29-0&quot;&gt;&lt;/span&gt;<strong>Lemma 6</strong> (Adversarial time slots vs. convergence opportunities for any fixed window). For any  <span class="math">t_0, t_1</span>  such that  <span class="math">t := t_1 - t_0 \\ge 0</span> , for any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists some positive constant  <span class="math">\\eta</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{A}(\\textit{view})[t_0 : t_1] \\geq \\mathbf{C}(\\textit{view})[t_0 : t_1]\\right] &lt; \\exp(-\\eta \\beta t)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Due to Fact 2, for any  <span class="math">0 &lt; \\epsilon_1 &lt; 1</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{A}[t_0:t_1] &gt; (1+\\epsilon_1)\\beta t\\right] &lt; \\exp\\left(-\\frac{\\epsilon_1^2\\beta t}{3}\\right)</span>$</p>

    <p class="text-gray-300">Due to Lemma 2, for any positive  <span class="math">\\epsilon_2</span> , there exists positive  <span class="math">\\epsilon&#x27;</span> , such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{C}[t_0:t_1] &lt; (1 - \\epsilon_2)(1 - 2pN\\Delta)\\alpha t\\right] &lt; \\exp(-\\epsilon&#x27;\\beta t)</span>$</p>

    <p class="text-gray-300">Since we know that</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\alpha}{\\beta} &gt; \\frac{1+\\phi}{1-2pN\\Delta}</span>$</p>

    <p class="text-gray-300">there must exist sufficiently small positive constants  <span class="math">\\epsilon_1</span>  and  <span class="math">\\epsilon_2</span>  such that</p>

    <p class="text-gray-300"><span class="math">$(1 + \\epsilon_1)\\beta t &lt; (1 - \\epsilon_2)(1 - 2pN\\Delta)\\alpha t</span>$</p>

    <p class="text-gray-300">Now by taking a union bound over all possible windows of sufficient length, we obtain the following corollary.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-0&quot;&gt;&lt;/span&gt;Corollary 3 (Convergence opportunities outnumber adversarial slots for all sufficiently long windows). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for any positive constant  <span class="math">\\epsilon_0</span> , for any  <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\beta}</span> , there exists a positive constant  <span class="math">\\eta</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , the following holds:</p>

    <p class="text-gray-300">For any
<span class="math">$t_0</span>$
: <strong>A</strong>(view)[ <span class="math">t_0: t_0 + t</span> ] &lt; <strong>C</strong>(view)[ <span class="math">t_0: t_0 + t</span> ]</p>

    <p class="text-gray-300">w-pivots are strong pivots. Based on Corollary 3, we know that except for negligible fraction of the views, in any sufficiently long window, the number of convergence opportunities must be larger than the number of adversarial blocks. This immediately implies that for a suitably large choice of w, except for negligible fraction of the views, every w-pivot must be a strong pivot as well. This is formalized in the following fact.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-1&quot;&gt;&lt;/span&gt;<strong>Fact 5.</strong> For any  <span class="math">\\Pi_{\\text{ideal}}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a positive constant  <span class="math">\\eta</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , every w-pivot is a strong pivot for  <span class="math">w = \\frac{\\lambda}{\\beta}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Follows in a straightforward fashion from Corollary 3 which indicates that for any sufficiently long window, convergence opportunities must outnumber adversarial time slots except for a negligible fraction of the views.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Due to Fact 5, to show that strong pivots happen frequently in almost all views, it suffices to show that w-pivots happen frequently in almost all views where  <span class="math">w = \\frac{\\lambda}{\\beta}</span> .</p>

    <p class="text-gray-300">Any fixed time is somewhat likely a pivot. To show that w-pivots happen frequently in almost all views, we first show that any fixed time is a pivot with reasonable probability in almost all views.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-30-2&quot;&gt;&lt;/span&gt;<strong>Lemma 7</strong> (Any fixed time is a likely pivot). For any t, for any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there is a polynomial function  <span class="math">poly(\\cdot)</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds for  <span class="math">w = \\frac{\\lambda}{\\beta}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\ t \\ \\textit{is a <span class="math">w</span>-pivot}\\right] &gt; \\frac{1}{\\mathsf{poly}(\\lambda)}$$</p>

    <p class="text-gray-300"><em>Proof.</em> We define the following event  <span class="math">good^{t,v}(view) = 1</span>  iff both of the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathsf{G}_{1}^{t,v}(\\mathsf{view})</span> :  <span class="math">\\mathcal{A}</span>  is never elected leader during [t-v,t+v] in  <span class="math">\\mathsf{view};</span>  and</li>
      <li><span class="math">\\mathsf{G}_2^{t,v}(\\mathsf{view})</span> : in any window  <span class="math">[t_0,t_1]</span>  containing t of length  <span class="math">v \\leq t_1 t_0 \\leq w</span> , it holds that  <span class="math">\\mathbf{C}(\\mathsf{view})[t_0:t_1] &gt; \\mathbf{A}(\\mathsf{view})[t_0:t_1]</span> .</li>
    </ul>

    <p class="text-gray-300">First, it is not hard to see that for any view and any v, if  <span class="math">good^{t,v}(view) = 1</span> , then t must be a w-pivot in view.</p>

    <p class="text-gray-300">Next, let  <span class="math">v = \\frac{c \\log \\lambda}{2\\beta}</span>  for an appropriate constant c to be determined later. Thus, there exists some polynomial  <span class="math">\\mathsf{poly}(\\cdot)</span>  related to c such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{G}_1^{t,v}(\\mathsf{view})\\right] \\geq (1-\\beta)^{2v} = (1-\\beta)^{\\frac{c\\log\\lambda}{\\beta}} = \\frac{1}{\\mathsf{poly}(\\lambda)}</span>$</p>

    <p class="text-gray-300">Further, since there are at most  <span class="math">w^2</span>  windows containing t of length between v and w, by Lemma 6 and the union bound, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{G}_2^{t,v}(\\mathsf{view})\\right] \\geq 1 - \\exp(-\\eta \\beta v) \\cdot w^2 = 1 - \\exp(-c\\eta \\log \\lambda) \\cdot w^2</span>$</p>

    <p class="text-gray-300">Recall that since  <span class="math">\\beta</span>  is inverse polynomially bounded in  <span class="math">\\lambda</span> , it holds that w is polynomially bounded in  <span class="math">\\lambda</span> . Therefore, there exists a sufficiently large constant c such that  <span class="math">\\exp(-c\\eta \\log \\lambda) \\cdot w^2 &lt; \\frac{1}{2}</span> . Thus for a sufficiently large constant c, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{G}_2^{t,v}(\\mathsf{view})\\right] \\geq \\frac{1}{2}</span>$</p>

    <p class="text-gray-300">Finally, it is not hard to see that  <span class="math">\\Pr[\\mathsf{G}_2^{t,v}(\\mathsf{view})] \\leq \\Pr[\\mathsf{G}_2^{t,v}(\\mathsf{view}) \\, \\Big| \\, \\mathsf{G}_1^{t,v}(\\mathsf{view})]</span> , i.e.,  <span class="math">\\mathsf{G}_2</span>  is more likely conditioned on  <span class="math">\\mathsf{G}_1</span> . We therefore conclude that for some polynomial function  <span class="math">\\mathsf{poly}&#x27;(\\cdot)</span> , it holds that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr\\left[\\mathsf{good}^{t,v}(\\mathsf{view}) = 1\\right] &amp;= \\Pr\\left[\\mathsf{G}_2^{t,v}(\\mathsf{view}) \\left| \\mathsf{G}_1^{t,v}(\\mathsf{view}) \\right] \\cdot \\Pr\\left[\\mathsf{G}_1^{t,v}(\\mathsf{view})\\right] \\\\ &amp;\\geq \\Pr\\left[\\mathsf{G}_2^{t,v}(\\mathsf{view})\\right] \\cdot \\Pr\\left[\\mathsf{G}_1^{t,v}(\\mathsf{view})\\right] \\geq \\frac{1}{\\mathsf{poly}&#x27;(\\lambda)} \\end{split}</span>$</p>

    <p class="text-gray-300"><strong>Pivots are frequently recurring.</strong> Given a view, we say that many-pivots&lt;sup&gt;w,W&lt;/sup&gt;(view) = 1 iff for any s, r such that  <span class="math">r - s &gt; W \\ge 0</span> , there must exist a w-pivot during the window [s, r].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-0&quot;&gt;&lt;/span&gt;<strong>Theorem 5</strong> (There are many pivots). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a polynomial  <span class="math">W(\\cdot)</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds where  <span class="math">w = \\frac{\\lambda}{\\beta}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{many-pivots}^{w,W}(\\textit{view}) = 1\\right] \\geq 1 - \\exp(-\\frac{\\lambda}{2})$$</p>

    <p class="text-gray-300">Proof. Given  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , let  <span class="math">\\mathsf{poly}(\\cdot)</span>  denote the polynomial corresponding to Lemma 7 for  <span class="math">w = \\frac{\\lambda}{\\beta}</span> . Now let  <span class="math">W(\\cdot) := 4(w + \\Delta) \\cdot \\lambda \\cdot \\mathsf{poly}(\\cdot)</span> . Consider a window (s, r) of length at least  <span class="math">W(\\lambda)</span> , and a sequence of events  <span class="math">\\mathsf{G}_0, \\mathsf{G}_1, \\ldots</span>  where  <span class="math">\\mathsf{G}_i</span>  denote the good event that the time  <span class="math">s + i \\cdot 2(w + \\Delta)</span>  is a w-pivot, where i can range from 0 to  <span class="math">2\\lambda \\cdot \\mathsf{poly}(\\lambda)</span> . By the definition of w-pivots and that of convergence opportunities, it is not hard to see that all these events  <span class="math">\\mathsf{G}_0, \\mathsf{G}_1, \\ldots</span>  are independent. The probability that all these good events do not happen is upper bounded by</p>

    <p class="text-gray-300"><span class="math">$\\left(1 - \\frac{1}{\\mathsf{poly}(\\lambda)}\\right)^{2\\lambda \\cdot \\mathsf{poly}(\\lambda)} \\leq \\exp(-\\lambda)</span>$</p>

    <p class="text-gray-300">The remainder of the proof follows from a simple union bound over all possible such windows.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Given a view, we say that  <span class="math">\\mathsf{many\\_strong\\_pivots}^W(\\mathsf{view}) = 1</span>  iff for any s, r such that  <span class="math">r - s &gt; W \\ge 0</span> , there must exist a strong pivot during the window (s, r).</p>

    <p class="text-gray-300">&lt;span id=&quot;page-31-1&quot;&gt;&lt;/span&gt;<strong>Corollary 4</strong> (There are many strong pivots). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a polynomial  <span class="math">W(\\cdot)</span>  and a positive constant  <span class="math">\\eta</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{many_strong_pivots}^W(\\textit{view}) = 1\\right] \\geq 1 - \\exp(-\\eta \\lambda)$$</p>

    <p class="text-gray-300"><em>Proof.</em> Follows in a straightforward manner from Theorem 5 and Fact 5.</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">5.6.4 Proof of Consistency</h4>

    <p class="text-gray-300">At this point, it is relatively easy to prove a weak version of the consistency property. Intuitively, given an honest chain, as long as we remove  <span class="math">poly(\\lambda)</span>  blocks from the end for an appropriate polynomial function  <span class="math">poly(\\cdot)</span> , there must be a strong pivot in the last  <span class="math">poly(\\lambda)</span>  blocks worth of time. Thus the honest chain cannot have diverged from other honest chains prior to this strong pivot. We now formalize this intuition, and prove a weak version of consistency with somewhat loose parameters. We defer a tighter proof to Appendix A.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-32-0&quot;&gt;&lt;/span&gt;Fact 6 (Total block upper bound). For any positive constants  <span class="math">\\epsilon</span> ,  <span class="math">\\epsilon_0</span> , there exists a positive constant  <span class="math">\\eta</span>  such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\mathsf{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , it holds that there cannot be more than  <span class="math">(1+\\epsilon)Npt</span>  slots in which any node (honest or corrupt) is elected leader, in any window [s,r] of length  <span class="math">t:=r-s\\geq \\epsilon_0\\lambda</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By a straightforward application of the Chernoff bound over any fixed window of sufficient length, and then taking a union bound over all windows.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">&lt;span id=&quot;page-32-1&quot;&gt;&lt;/span&gt;<strong>Theorem 6</strong> (Weak consistency). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a polynomial  <span class="math">T(\\lambda)</span>  and a positive constant  <span class="math">\\eta</span> , such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{consistent}^T(\\textit{view}) = 1\\right] \\geq 1 - \\exp(-\\eta \\lambda)$$</p>

    <p class="text-gray-300"><em>Proof.</em> For simplicity, we ignore  <span class="math">\\exp(-\\Omega(\\lambda))</span>  fraction of bad views where all relevant bad events take place. Given any two honest chains  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_i^{r&#x27;}</span>  where  <span class="math">r \\leq r&#x27;</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By Corollary 4, there is at least a strong pivot between  <span class="math">[r W(\\lambda) \\frac{\\lambda}{\\beta}, r \\frac{\\lambda}{\\beta}]</span>  where  <span class="math">W(\\cdot)</span>  is a polynomial function defined by Corollary 4.</li>
      <li>By Lemma 5,  <span class="math">\\mathsf{chain}_i^r</span>  and  <span class="math">\\mathsf{chain}_j^{r&#x27;}</span>  cannot have diverged at time  <span class="math">r-W(\\lambda)-\\frac{\\lambda}{\\beta}</span> .</li>
      <li>Finally, by Fact 6, for an appropriate polynomial  <span class="math">T(\\lambda)</span> ,  <span class="math">\\operatorname{chain}_i^r</span>  cannot have more than  <span class="math">T(\\lambda)</span>  blocks after time  <span class="math">r W(\\lambda) \\frac{\\lambda}{\\beta}</span> .</li>
    </ul>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">5.6.5 Tighter Consistency Analysis</h3>

    <p class="text-gray-300">As mentioned earlier, the above analysis actually can be tightened to obtain the following, tighter version of the consistency theorem. The proof of this tighter consistency theorem will be provided in Appendix A.</p>

    <p class="text-gray-300"><strong>Theorem 7</strong> (Consistency). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists positive constants  <span class="math">\\eta</span>  and C, such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds for  <span class="math">T = C\\lambda^2</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{consistent}^T(\\textit{view}) = 1\\right] \\geq 1 - \\exp(-\\eta \\lambda)$$</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.7 Chain Growth Upper Bound</h3>

    <p class="text-gray-300">We now prove chain growth upper bound.</p>

    <p class="text-gray-300"><strong>Lemma 8</strong> (Chain growth upper bound). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , for any positive constants  <span class="math">\\epsilon_0</span> ,  <span class="math">\\epsilon</span>  and any  <span class="math">t \\geq \\frac{\\epsilon_0 \\lambda}{\\alpha}</span> , there exists a positive constant  <span class="math">\\eta</span> , such that for every  <span class="math">\\lambda \\in \\mathbb{N}</span> , except for  <span class="math">\\exp(-\\eta \\lambda)</span>  fraction of the views sampled from  <span class="math">\\mathsf{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , the following holds:</p>

    <p class="text-gray-300">For any
<span class="math">$t_0</span>$
, max_chain_increase(view)[ <span class="math">t_0: t_0 + t</span> ]  <span class="math">\\leq (1 + \\epsilon)Npt</span></p>

    <p class="text-gray-300">where max_chain_increase(view)[ <span class="math">t_0: t_0 + t</span> ] denotes the length of the shortest honest chain at time  <span class="math">t_0 + t</span>  minus the length of the longest honest chain at time  <span class="math">t_0</span> .</p>

    <p class="text-gray-300">Proof. Henceforth we ignore any view where relevant bad events take place. For any remaining good view, we prove that there cannot exist positive constant  <span class="math">\\epsilon_0</span> , constant  <span class="math">0 &lt; \\epsilon &lt; 1</span> , some  <span class="math">t \\ge \\frac{\\epsilon_0 \\lambda}{\\alpha}</span> , and some  <span class="math">t_0</span> , such that max_chain_increase(view)[ <span class="math">t_0: t_0+t</span> ] &gt;  <span class="math">(1+\\epsilon)Npt</span> . Suppose for the sake of contradiction the above is not true. Let chain denote the shortest chain belonging to an alert node at time  <span class="math">t_0</span> , let chain' denote the longest chain belonging to an alert node at time  <span class="math">t_0+t</span> . Let r:=chain[-1].time, and r':=chain'[-1].time; by definition of honest protocol, it holds that  <span class="math">r \\le t_0</span>  and  <span class="math">r&#x27; \\le t_0+t</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>By Fact 6, there exists a positive constant  <span class="math">\\eta \\ge \\epsilon</span>  such that  <span class="math">r&#x27; r \\ge (1 + \\eta)t</span>  since otherwise, by Fact 6, there cannot be more than  <span class="math">(1 + \\epsilon)Npt</span>  total elected time slots between r and r'.</li>
      <li>Since  <span class="math">r&#x27; \\le t_0 + t</span> , it must hold that  <span class="math">r \\le t_0 + t (1 + \\eta)t = t_0 \\eta t \\le t_0 \\epsilon t</span> .</li>
      <li>By chain quality, for any positive constant  <span class="math">\\eta&#x27;</span> , there must be an honest block in chain  <span class="math">[-\\eta&#x27;\\lambda:]</span> .</li>
      <li>The above means that there exists an alert node whose chain length is at least  <span class="math">|chain| \\eta&#x27;\\lambda</span>  at some time  <span class="math">\\tilde{r} &lt; r</span> .</li>
    </ul>

    <p class="text-gray-300">We also know that there is an alert node whose chain length is  <span class="math">|\\mathsf{chain}|</span>  at  <span class="math">t_0</span> . This means that the minimal honest chain growth between  <span class="math">\\tilde{r} &lt; r</span>  and  <span class="math">t_0</span>  is at most  <span class="math">\\eta&#x27; \\lambda</span> . For a sufficiently small constant  <span class="math">\\eta&#x27;</span> , this would be impossible due to chain growth lower bound, and thus we reach a contradiction.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-33-0&quot;&gt;&lt;/span&gt;5.8 Real World Emulates the Ideal World</h3>

    <p class="text-gray-300">We now show that the real-world protocol  <span class="math">\\Pi_{\\text{sleepy}}</span>  securely emulates the ideal-world protocol  <span class="math">\\Pi_{\\text{ideal}}</span> . This can be shown using a standard simulation paradigm as described below. We construct the following simulator S.</p>

    <p class="text-gray-300">• S internally simulates  <span class="math">\\mathcal{F}_{CA}</span> . At the start of execution, S honestly generates a  <span class="math">(\\mathsf{pk}_i, \\mathsf{sk}_i)</span>  pair for each honest node i, and registers  <span class="math">\\mathsf{pk}_i</span>  on behalf of honest node i with the internally simulated  <span class="math">\\mathcal{F}_{CA}</span> .</p>

    <p class="text-gray-300">Whenever  <span class="math">\\mathcal{A}</span>  wishes to interact with  <span class="math">\\mathcal{F}_{CA}</span> ,  <span class="math">\\mathcal{S}</span>  simply forwards messages in between  <span class="math">\\mathcal{A}</span>  and the internally simulated  <span class="math">\\mathcal{F}_{CA}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever S receives a hash query of the form H(P, t) from A or from internally, S checks if the query has been asked before. If so, simply return the same answer as before.    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If not, S checks if P is a party identifier corresponding to this protocol instance. If not, S generates a random number of appropriate length and returns it. Else if the mapping succeeds, S queries b ← Ftree.leader(P, t). If b = 1, S rejection samples a random string h of appropriate length, until h &lt; Dp; it then returns h. Else if b = 0, S rejection samples a random string h of appropriate length, until h ≥ Dp; it then returns h.</li>
    </ul></li>
      <li>S keeps track of the &quot;real-world&quot; chain for every honest node i. Whenever it sends chain to A on behalf of i, it updates this state for node i. Whenever A sends chain to honest node i, S checks the simulation validity (see Definition <a href="#page-34-0">8)</a> of chain. If chain is simulation valid and moreover chain is longer than the current real-world chain for node i, S also saves chain as the new real-world chain for node i.</li>
      <li>Whenever an honest node with the party identifier P sends chain to S, S looks up the current real-world state chain for node P. The simulator now computes a new chain using the realworld algorithm: let (pk,sk) be the key pair for node P, let t be the current time, and let B := chain[−1].</li>
    </ul>

    <p class="text-gray-300">If eligible&lt;sup&gt;t&lt;/sup&gt; (P) where the hash function H is through internal query to the simulator itself:</p>

    <pre><code class="language-text">let σ := Σ.sign(sk, chain[−1].h, B, t), h
                                           0
                                            := d(chain[−1].h, B, t,P, σ),
let B := (chain[−1].h, B, t,P, σ, h0
                                     ), let chain0
                                                  := chain||B.
</code></pre>

    <p class="text-gray-300">Now, the simulator S sends chain&lt;sup&gt;0&lt;/sup&gt; to A.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Whenever A sends a chain to an honest node i, S intercepts the message. S ignores the message if chain is not simulation valid. Otherwise, let chain := extract(chain), and let chain[: <code>] ≺ chain be the longest prefix such that Ftree.verify(chain[: </code>]) = 1. The simulator checks to see if there exists a block in chain[<code> + 1 :] signed by an honest P. If so, abort outputting sig-failure. Else, for each k ∈ [</code> + 1, |chain|],    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>let P ∗ := chain[k].P, let t ∗ := chain[k].time.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>S then calls Ftree.extend(chain[: k − 1], chain[k], t&lt;sup&gt;∗&lt;/sup&gt; ) on behalf of corrupt party P ∗ .</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Notice that if the current chain is simulation valid, then the new chain&lt;sup&gt;0&lt;/sup&gt; must be simulation valid as well. Finally, S forwards chain to honest node i.</p>

    <p class="text-gray-300">• At any point of time, if S observes two different simulation valid (real-world) chains that contain identical (real-world) blocks, abort outputting duplicate-block-failure.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-0&quot;&gt;&lt;/span&gt;Definition 8 (Simulation valid chains). We say that a chain is simulation valid if it passes the real-world validity checks, but using the H and the FCA implemented by the simulator S.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-1&quot;&gt;&lt;/span&gt;Fact 7. The simulated execution never aborts with duplicate-block-failure except with negligible probability.</p>

    <p class="text-gray-300">Proof. For this bad event to happen, it must be the case that two distinct queries to the hash function d returns the same result. Since there can be only polynomially many such queries, this happens with negligible probability.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-34-2&quot;&gt;&lt;/span&gt;Fact 8. The simulated execution never aborts with sig-failure except with negligible probability.</p>

    <p class="text-gray-300">Proof. We ignore all views where the bad event duplicate-block-failure happens.</p>

    <p class="text-gray-300">Suppose some block B is signed by the simulator S. Then, some honest node i must have sent chain||extract(B) to S earlier, and this means that chain must be in Ftree. Therefore, if sig-failure ever happens, it means that the adversary A has produced a signature on a different message that S never signed (due to no duplicate-block-failure). We can now easily construct a reduction that breaks signature security if sig-failure happens with non-negligible probability.</p>

    <p class="text-gray-300">Lemma 9 (Indistinguishability). Conditioned on the fact that all of the aforementioned bad events do not happen, then the simulated execution is identically distributed as the real-world execution from the perspective of Z.</p>

    <p class="text-gray-300">Proof. Observe that the simulator's H coins are always consistent with Ftree's leader coins. Further, as long as there is no sig-failure, if the simulator receives any simulation valid chain from A, either chain := extract(chain) already exists in Ftree, or else S must succeed in adding chain to Ftree. The rest of the proof works through a standard repartitioning argument.</p>

    <p class="text-gray-300">Fact 9. If (A, Z) is Πsleepy-compliant, then (S &lt;sup&gt;A&lt;/sup&gt;, Z) is Πideal-compliant.</p>

    <p class="text-gray-300">Proof. Πsleepy and Πideal have identical compliance rules. The only rule to verify is ∆-bounded network delay rule — every other rule is straightforward to verify. Observe that whenever an honest node sends S an ideal-world chain, S will transform it to a real-world chain and forward it to A. Since (A, Z) is compliant, for each alert node j, within ∆ steps A will ask S to forward chain to j. Similarly, for any sleepy node j that wakes up after ∆ time, at the time it wakes up, A will ask S to forward chain to j. Note that S will never drop such a request since all chain sent from S to A are simulation valid. Therefore S respects the ∆-delay rule as well, and further S respects the rule to forward waking nodes all pending messages.</p>

    <p class="text-gray-300">Finally, since the simulated execution is compliant, it respects all the desired properties as Theorem <a href="#page-20-1">4</a> states. Now, since real-world execution and the simulated execution are indistiguishable, it holds that all the desired properties hold in the same way for the real-world execution.</p>

    <p class="text-gray-300">We thus complete the proof of main theorem assuming a random oracle. In the next subsection, we describe how to adapt our proof when we replace the random oracle with a CRS and a PRF.</p>

    <h2 id="sec-28" class="text-2xl font-bold">5.9 Removing the Random Oracle in the Proof</h2>

    <p class="text-gray-300">It is not hard to modify the proof when we remove the random oracle, and instead use PRFk&lt;sup&gt;0&lt;/sup&gt; (P, t) &lt; D&lt;sup&gt;p&lt;/sup&gt; as the leader election function, where k&lt;sup&gt;0&lt;/sup&gt; is a random string to be included in the common reference string. We state the modifications necessary to the proof below:</p>

    <p class="text-gray-300">• First, we introduce an intermediate hybrid protocol where the ideal functionality Ftree selects k&lt;sup&gt;0&lt;/sup&gt; at random prior to protocol start, and discloses k&lt;sup&gt;0&lt;/sup&gt; to the adversary A. Meanwhile, instead of generating random bits to determine leader for both honest and corrupt nodes, the ideal functionality Ftree instead uses PRFk&lt;sup&gt;0&lt;/sup&gt; (P, t) &lt; Dp.</p>

    <p class="text-gray-300">We can argue that such a hybrid protocol is also secure against computationally unbounded, compliant (A, Z). In particular, observe that in our previous ideal protocol analysis, once we fix the random bits ~ν of the random oracle (RO), we can define certain bad events (that depend only on the random bits of the random oracle, but those not of (A, Z)). Provided that these bad events do not happen, even a computationally unbounded (A, Z) cannot break the chain growth, chain quality, or consistency properties. Further, observe that there is a polynomial-time algorithm that can efficient check for bad events given the random bits of the random oracle.</p>

    <p class="text-gray-300">Therefore, when we replace the random oracle with PRFk&lt;sup&gt;0&lt;/sup&gt; (·), over the probability space defined over the choice of k0, these bad events should not happen except with negligible probability as well — otherwise the algorithm that checks for the bad events can be used as an efficient adversary that distinguishes the PRF from the random oracle. Similarly, in the PRF case, as long as the bad events do not happen, even a computationally unbounded adversary should not be able to break the security properties.</p>

    <p class="text-gray-300">• Now, we can modify our simulation proof to prove that the real-world protocol emulates the modified hybrid protocol as mentioned above. Most of the simulation proof is identical to the random oracle case presented above, except that now when the simulator learns k&lt;sup&gt;0&lt;/sup&gt; from Ftree, it simply gives k&lt;sup&gt;0&lt;/sup&gt; to A, and the simulator no longer needs to simulate random oracle queries for A.</p>

    <p class="text-gray-300">So far, we have assumed that the adversary issues both corrupt and sleep instructions statically upfront. In this section, we will show how to achieve adaptive security with complexity leveraging. It turns out even with complexity leveraging the task is non-trivial.</p>

    <p class="text-gray-300">To simplify the problem, let us first consider how to achieve adaptive sleepiness (but static corruption). In our statically secure protocol Πsleepy, the adversary can see into the future for all honest and corrupt players. In particular, the adversary can see exactly in which time steps each honest node is elected leader. If sleep instructions could be adaptively issued, the adversary could simply put a node to sleep whenever he is elected leader, and wake up him when he is not leader. This way, the adversary can easily satisfy the constraint that at any time, the majority of the online nodes must be honest, while ensuring that no alert nodes are ever elected leader (with extremely high probability).</p>

    <p class="text-gray-300">To defeat such an attack and achieve adaptive sleepiness (but static corruption), we borrow an idea that was (informally) suggested by Micali <a href="#page-51-0">[31]</a>. Basically, instead of computing a &quot;leader ticket&quot; η by hashing the party's (public) identifier and the time step t and by checking η &lt; D&lt;sup&gt;p&lt;/sup&gt; to determine if the node is elected leader, we will instead have an honest node compute a pseudorandom &quot;leader ticket&quot; itself using some secret known only to itself. In this way, the adversary is no longer able to observe honest nodes' future. The adversary is only able to learn that an honest node is elected leader in time step t when the node actually sends out a new chain in t — but by then, it will be too late for the adversary to (retroactively) put that node to sleep in t.</p>

    <p class="text-gray-300">A na¨ıve attempt. Therefore, a na¨ıve attempt would be the following.</p>

    <p class="text-gray-300">• Each node P picks its own PRF key k[P], and computes a commitment c := comm(k[P]; r) and registers c as part of its public key with the public-key infrastructure FCA. To determine whether it is elected leader in a time step t, the node computes</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PRF}_{k[\\mathcal{P}]}(t) &lt; D_p</span>$</p>

    <p class="text-gray-300">where D&lt;sup&gt;p&lt;/sup&gt; is a difficulty parameter related to p, such that any node gets elected with probability p in a given time step.</p>

    <p class="text-gray-300">• Now for  <span class="math">\\mathcal{P}</span>  to prove to others that it is elected leader in a certain time step t,  <span class="math">\\mathcal{P}</span>  can compute a non-interactive zero-knowledge proof that the above evaluation is done correctly (w.r.t. to the commitment c that is part of  <span class="math">\\mathcal{P}</span> 's public key).</p>

    <p class="text-gray-300"><strong>A second attempt.</strong> This indeed hides honest nodes' future from the adversary; however, the adversary may not generate  <span class="math">k[\\mathcal{P}^*]</span>  at random for a corrupt player  <span class="math">\\mathcal{P}^*</span> . In particular, the adversary can try to generate  <span class="math">k[\\mathcal{P}^*]</span>  such that  <span class="math">\\mathcal{P}^*</span>  can get elected in more time steps. To defeat such an attack, we include a relatively long randomly chosen string  <span class="math">k_0</span>  in the common reference string. For a node  <span class="math">\\mathcal{P}</span>  to be elected leader in a time step t, the following must hold:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{PRF}_{k_0}(\\mathcal{P},t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t) &lt; D_p</span>$</p>

    <p class="text-gray-300">As before, a node can compute a non-interactive zero-knowledge proof (to be included in a block) to convince others that it computed the leader election function correctly.</p>

    <p class="text-gray-300">Now the adversary can still adaptively choose  <span class="math">k[\\mathcal{P}^*]</span>  after seeing the common reference string  <span class="math">k_0</span>  for a corrupt node  <span class="math">\\mathcal{P}^*</span>  to be elected in more time steps; however, it can only manipulate the outcome to a limited extent: in particular, since  <span class="math">k_0</span>  is much longer than  <span class="math">k[\\mathcal{P}^*]</span> , the adversary does not have enough bits in  <span class="math">k[\\mathcal{P}^*]</span>  to manipulate to defeat all the entropy in  <span class="math">k_0</span> .</p>

    <p class="text-gray-300">Parametrization and analysis. Using the above scheme, we can argue for security against an adaptive sleepiness attack. However, as mentioned above, the adversary can still manipulate the outcome of the leader election to some extent. For example, one specific attack is the following: suppose that the adversary controls O(N) corrupt nodes denoted  <span class="math">\\mathcal{P}_0^*, \\ldots, \\mathcal{P}_{O(N)}^*</span>  respectively. With high probability, the adversary can aim for the corrupt nodes to be elected for O(N) consecutive time slots during which period the adversary can sustain a consistency and a chain quality attack. To succeed in such an attack, say for time steps [t:t+O(N)], the adversary can simply try random user PRF keys on behalf of  <span class="math">\\mathcal{P}_0^*</span>  until it finds one that gets  <span class="math">\\mathcal{P}_0^*</span>  to be elected in time t (in expectation only  <span class="math">O(\\frac{1}{p})</span>  tries are needed); then the adversary tries the same for node  <span class="math">\\mathcal{P}_1^*</span>  and time t+1, and so on.</p>

    <p class="text-gray-300">Therefore we cannot hope to obtain consistency and chain quality for O(N)-sized windows. Fortunately, as we argued earlier, since the adversary can only manipulate the leader election outcome to a limited extent given that the length of  <span class="math">k_0</span>  is much greater than the length of each user's PRF key, it cannot get corrupt nodes to be consecutively elected for too long. In our proof, we show that as long as we consider sufficiently long windows of  <span class="math">N^c</span>  blocks in length (for an appropriate constant c and assuming for simplicity that  <span class="math">N = \\omega(\\log \\lambda)</span> ), then consistency and chain quality will hold except with negligible probability.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">6.2 Intuition: Achieving Adaptive Corruption</h3>

    <p class="text-gray-300">Once we know how to achieve adaptive sleepiness and static corruption, we can rely on complexity leveraging to achieve adaptive corruption. This part of the argument is standard: suppose that given an adversary under static corruption that can break the security properties of the consensus protocol, there exists a reduction that breaks some underlying complexity assumption. We now modify the reduction to guess upfront which nodes will become corrupt during the course of execution, and it guesses correctly with probability  <span class="math">\\frac{1}{2^N}</span> . This results in a  <span class="math">2^N</span>  loss in the security reduction, and therefore if we assume that our cryptographic primitives, including the PRF, the digital signature scheme, the non-interactive zero-knowledge proof, the commitment scheme, and the collision-resistant hash family have sub-exponential hardness, we can lift the static corruption to adaptive corruption.</p>

    <p class="text-gray-300">Below, we put the aforementioned ideas together and present our adaptively secure scheme formally.</p>

    <p class="text-gray-300">In the remainder of this section, f(λ) ≈ g(λ) means that there exists a negligible function ν(λ) such that |f(λ) − g(λ)| &lt; ν(λ).</p>

    <p class="text-gray-300">A non-interactive proof system henceforth denoted NIZK for an NP language L consists of the following algorithms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>crs ← gen(1&lt;sup&gt;λ&lt;/sup&gt; ,L): Takes in a security parameter λ, a description of the language L, and generates a common reference string crs.</li>
      <li>π ← prove(crs,stmt, w): Takes in crs, a statement stmt, a witness w such that (stmt, w) ∈ L, and produces a proof π.</li>
      <li>b ← ver(crs,stmt, π): Takes in a crs, a statement stmt, and a proof π, and outputs 0 or 1, denoting accept or reject.</li>
      <li>(crs, τ ) ← gen(1&lt;sup&gt;λ&lt;/sup&gt; ,L): Generates a simulated common reference string crs and a trapdoor τ .</li>
      <li>π ← prove(crs, τ,stmt): Uses trapdoor τ to produce a proof π without needing a witness.</li>
    </ul>

    <p class="text-gray-300">Perfect completeness. A non-interactive proof system is said to be perfectly complete, if an honest prover with a valid witness can always convince an honest verifier. More formally, for any (stmt, w) ∈ L, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\big[ \\text{ crs} \\leftarrow \\mathtt{setup}(1^{\\lambda}, \\mathcal{L}), \\ \\pi \\leftarrow \\mathtt{prove}(\\mathtt{crs}, \\mathtt{stmt}, w) : \\mathtt{ver}(\\mathtt{crs}, \\mathtt{stmt}, \\pi) = 1 \\ \\big] = 1</span>$</p>

    <p class="text-gray-300">Computational zero-knowlege. Informally, an NIZK system is computationally zero-knowledge if the proof does not reveal any information about the witness to any polynomial-time (or subexponential time resp.) adversary. More formally, a NIZK system is said to have computational zero-knowledge, if for all non-uniform polynomial-time adversary A (or subexponential-time A resp.),</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{crs} \\leftarrow \\mathsf{gen}(1^{\\lambda}, \\mathcal{L}) : \\mathcal{A}^{\\mathsf{prove}(\\mathsf{crs}, \\cdot, \\cdot)}(\\mathsf{crs}) = 1\\right] \\approx \\Pr\\left[\\left(\\overline{\\mathsf{crs}}, \\tau, \\_\\right) \\leftarrow \\overline{\\mathsf{gen}}(1^{\\lambda}, \\mathcal{L}) : \\mathcal{A}^{\\overline{\\mathsf{prove}}_1(\\overline{\\mathsf{crs}}, \\tau, \\cdot, \\cdot)}(\\overline{\\mathsf{crs}}) = 1\\right]</span>$</p>

    <p class="text-gray-300">In the above, prove&lt;sup&gt;1&lt;/sup&gt; (crs, τ,stmt, w) verifies that (stmt, w) ∈ L, and if so, outputs prove(crs, τ,stmt) which simulates a proof without knowing a witness. Otherwise, if (stmt, w) ∈ L / , the experiment aborts.</p>

    <p class="text-gray-300">Computational soundness. We say that a NIZK scheme is computationally sound against any p.p.t. (or subexponential-time resp.) adversary, if for any p.p.t. (or subexponential-time resp.) adversary A, it holds that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{crs} \\leftarrow \\mathsf{gen}(1^\\lambda, \\mathcal{L}), (\\mathsf{stmt}, \\pi) \\leftarrow \\mathcal{A}(\\mathsf{crs}) : \\mathsf{ver}(\\mathsf{crs}, \\mathsf{stmt}, \\pi) = 1 \\text{ but } \\mathsf{stmt} \\notin \\mathcal{L}\\right] \\approx 0</span>$</p>

    <p class="text-gray-300">NP language used in our construction. In our construction, we will use the following NP language L. A pair (stmt, w) ∈ L iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>parse stmt := (η, c, k0,P,time), parse w := (k, r);</li>
      <li>it holds that c = comm(k; r) and PRFk(time) ⊕ PRFk&lt;sup&gt;0&lt;/sup&gt; (P,time) = η</li>
    </ul>

    <h3 id="sec-30" class="text-xl font-semibold mt-8">6.4 Sleepy Consensus with Adaptive Security</h3>

    <p class="text-gray-300">Henceforth we use the shorthand  <span class="math">\\mathcal{P}.\\mathsf{upk}</span>  to mean  <span class="math">\\mathcal{F}_{\\mathrm{CA}}.\\mathsf{lookup}(\\mathcal{P})</span> . Specifically,  <span class="math">\\mathcal{P}.\\mathsf{upk}</span>  can be parsed as  <span class="math">\\mathcal{P}.\\mathsf{upk} := (\\mathsf{pk}, c)</span>  where  <span class="math">\\mathsf{pk}</span>  denotes a signature public key, and c corresponds to a perfectly binding commitment of a user's PRF key.</p>

    <p class="text-gray-300">Valid blocks and valid blockchains are defined in a similar fashion as in the earlier statically secure scheme — but we need to make minor changes to block format and validity rules to incorporate the fact that now each block carries its own zero-knowledge proof to vouch for its validity.</p>

    <p class="text-gray-300">Valid blocks. We say that a tuple</p>

    <p class="text-gray-300"><span class="math">$B:=(h_{-1},\\mathsf{B},\\mathsf{time},\\mathcal{P},\\eta,\\pi,\\sigma,h)</span>$</p>

    <p class="text-gray-300">is a valid block with respect to the difficulty parameter  <span class="math">D_p</span>  and public parameters params iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\mathcal{P}</span>  is a valid node of the current protocol instance and has registered with  <span class="math">\\mathcal{F}_{CA}</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">\\mathcal{P}.\\mathsf{upk} := (\\mathsf{pk}, \\_)</span> , it holds that  <span class="math">\\Sigma.\\mathsf{ver}_{\\mathsf{pk}}((h_{-1}, \\mathsf{B}, \\mathsf{time}, \\pi); \\sigma) = 1</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Parse  <span class="math">\\mathcal{P}.\\mathsf{upk} := (.,c)</span> , parse params  <span class="math">:= (k_0,\\mathsf{crs})</span> , it holds that  <span class="math">\\mathsf{NIZK}.\\mathsf{ver}(\\mathsf{crs},\\mathsf{stmt}) = 1</span>  where  <span class="math">\\mathsf{stmt} := (\\eta,c,k_0,\\mathcal{P},\\mathsf{time})</span> ;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\eta &lt; D_p</span> ; and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">h = d(h_{-1}, B, time, \\mathcal{P}, \\eta, \\pi, \\sigma)</span> , where  <span class="math">d : \\{0, 1\\}^* \\to \\{0, 1\\}^{\\lambda}</span>  is a collision-resistant hash function technically collision resistant hash functions must be defined for a family, but here for simplicity we pretend that the sampling from the family has already been done before protocol start, and therefore d is a single function.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><strong>Valid blockchain.</strong> Let <em>chain</em> denote an ordered chain of real-world blocks, we say that <em>chain</em> is a valid blockchain w.r.t. the difficulty parameter  <span class="math">D_p</span> , public parameters params, and t iff</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">chain[0] = genesis = (\\bot, \\bot, time = 0, \\bot, \\bot, h = \\vec{0})</span> , commonly referred to as the genesis block;</li>
      <li>chain[-1].time  <span class="math">\\leq t</span> ; and</li>
      <li>for all  <span class="math">i \\in [1..\\ell]</span> , the following holds:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i] is a valid block w.r.t. the difficulty parameter  <span class="math">D_p</span>  and public parameters params;</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">chain[i].h_{-1} = chain[i-1].h;</span>  and</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain[i].time &gt; chain[i-1].time, i.e., block-times are strictly increasing.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300"><strong>Protocol description.</strong> We present our adaptively secure scheme  <span class="math">\\Pi_{\\text{sleepy}}^*</span>  in Figure 4. The main differences from the previous statically secure protocol are the following. As mentioned earlier, each node  <span class="math">\\mathcal{P}</span>  picks a PRF secret key  <span class="math">k[\\mathcal{P}]</span>  and registers a commitment c of  <span class="math">k[\\mathcal{P}]</span>  with the public-key infrastructure  <span class="math">\\mathcal{F}_{\\text{CA}}</span> . Further, there is a longer random seed  <span class="math">k_0</span>  included in the common reference string. To determine whether a node  <span class="math">\\mathcal{P}</span>  is elected leader in a given time step t,  <span class="math">\\mathcal{P}</span>  checks whether  <span class="math">\\mathsf{PRF}_{k_0}(\\mathcal{P},t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t) &lt; D_p</span> . If  <span class="math">\\mathcal{P}</span>  is elected leader, it can extend the chain with a block, and it includes a non-interactive zero-knowledge proof  <span class="math">\\pi</span>  in the block proving that it computed the leader election function correctly.</p>

    <pre><code class="language-text">\\mathbf{Protocol}\\ \\Pi^*_{\\mathrm{sleepy}}(p,\\mathsf{params}:=(k_0,\\mathsf{crs})) On input init() from \\mathcal{Z}: let (\\mathsf{pk},\\mathsf{sk}):=\\Sigma.\\mathsf{gen}(1^L), let k\\leftarrow_{\\$}\\{0,1\\}^L, let c:=\\mathsf{comm}(k;r) for r\\leftarrow_{\\$}\\{0,1\\}^L; let \\mathit{chain}:=\\mathit{genesis}, let \\mathsf{usk}:=(\\mathsf{sk},c,k,r), register \\mathsf{upk}:=(\\mathsf{pk},c) with \\mathcal{F}_{\\mathrm{CA}}; On receive \\mathit{chain}&#x27;: assert |\\mathit{chain}&#x27;|&gt;|\\mathit{chain}| and \\mathit{chain}&#x27; is valid w.r.t. D_p, \\mathsf{params}, and the current time t; \\mathit{chain}:=\\mathit{chain}&#x27; and \\mathit{gossip}\\ \\mathit{chain}
</code></pre>

    <h2 id="sec-31" class="text-2xl font-bold">Every time step:</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>receive input transactions(B) from  <span class="math">\\mathcal{Z}</span></li>
      <li>let t be the current time, let  <span class="math">\\mathcal{P}</span>  be the current party's identifier, parse  <span class="math">\\mathsf{usk} := (\\mathsf{sk}, c, k, r)</span></li>
      <li>let  <span class="math">\\eta := \\mathsf{PRF}_k(t) \\oplus \\mathsf{PRF}_{k_0}(\\mathcal{P}, t)</span> , if  <span class="math">\\eta &lt; D_p</span> :</li>
    </ul>

    <pre><code class="language-text">let \\pi := \\mathsf{NIZK.prove}(\\mathsf{crs}, \\mathsf{stmt}, w) where \\mathsf{stmt} := (\\eta, c, k_0, \\mathcal{P}, t), \\ w := (k, r) let \\sigma := \\Sigma.\\mathsf{sign}_{\\mathsf{sk}}(chain[-1].h, \\mathsf{B}, t, \\eta, \\pi), \\ h&#x27; := \\mathsf{d}(chain[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\eta, \\pi, \\sigma), let B := (chain[-1].h, \\mathsf{B}, t, \\mathcal{P}, \\eta, \\pi, \\sigma, h&#x27;), let chain := chain||B| and gossip chain
</code></pre>

    <p class="text-gray-300">• output extract(chain) to  <span class="math">\\mathcal{Z}</span>  where extract is the function outputs an ordered list containing the B extracted from each block in chain</p>

    <p class="text-gray-300">Figure 4: The sleepy consensus protocol with adaptive security. The common reference string params is generated as follows:  <span class="math">k_0 \\leftarrow_{\\</span>} {0,1}^{L_0}$ , and  <span class="math">\\operatorname{crs} \\leftarrow \\mathsf{NIZK.gen}(1^L,\\mathcal{L})</span> .</p>

    <p class="text-gray-300">Compliant executions. We say that a pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi^*_{\\text{sleepy}}(p)</span> -compliant if  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{sleepy}}(p)</span> -compliant — except that now we allow  <span class="math">\\mathcal{Z}</span>  to adaptively corrupt nodes and make nodes sleep during the protocol execution. Recall that  <span class="math">\\mathcal{A}</span>  is allowed to register corrupt nodes' public keys with  <span class="math">\\mathcal{F}_{\\text{CA}}</span>  after seeing the common reference string.</p>

    <p class="text-gray-300">Parameter choices for cryptographic building blocks. We assume that the the PRF function, the collision resistance hash, the signature scheme, and the NIZK have sub-exponential hardness. Throughout this paper, sub-exponential hardness means that except with  <span class="math">2^{-k^{\\delta}}</span>  probability, the cryptographic primitive with input length k is secure against any adversary running in time  <span class="math">2^{k^{\\delta}}</span>  for a fixed constant  <span class="math">\\delta &lt; 1</span> . We will use the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Each user's PRF key k has bit length  <span class="math">L = (2N + \\log^2 \\lambda)^{\\frac{1}{\\delta}}</span> :</li>
      <li>The common reference string  <span class="math">k_0</span>  has bit length  <span class="math">L_0 = (2LN)^{\\frac{1}{\\delta}}</span> ;</li>
      <li>All other cryptographic schemes such as the hash function, the digital signature scheme, and the NIZK have input length  <span class="math">L = (2N + \\log^2 \\lambda)^{\\frac{1}{\\delta}}</span> .</li>
    </ul>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">6.5 Theorem Statement</h3>

    <p class="text-gray-300">&lt;span id=&quot;page-40-1&quot;&gt;&lt;/span&gt;<strong>Theorem 8</strong> (Security of  <span class="math">\\Pi_{\\text{sleepy}}^*</span>  under adaptive corruption). Assume that the PRF, the collision resistant hash family, and the signature scheme  <span class="math">\\Sigma</span>  all have subexponential security, and that the NIZK is perfectly complete, computational zero-knowledge and computationally sound against subexponential adversaries. Then, for any positive constant  <span class="math">\\epsilon &gt; 0</span> , any 0 , any p.p.t. pair</p>

    <p class="text-gray-300"><span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that is  <span class="math">\\Pi^*_{sleepy}(p)</span> -compliant, there is a constant c such that for any  <span class="math">T_0 \\geq cLN</span> , protocol  <span class="math">\\Pi^*_{sleepy}(p)</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span>  consistency w.r.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  where relevant parameters are defined below:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 \\epsilon)(1 2pN\\Delta)\\alpha</span> ;</li>
      <li>chain growth upper bound parameter  <span class="math">g_1 = (1 + \\epsilon)Np</span> ; and</li>
      <li>chain quality parameter  <span class="math">\\mu = 1 \\frac{1-\\epsilon}{1+\\phi}</span> .</li>
    </ul>

    <p class="text-gray-300">where  <span class="math">N, \\Delta, \\alpha</span>  and  <span class="math">\\phi</span>  are parameters that can be determined by  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  as well as p as mentioned earlier.</p>

    <p class="text-gray-300">The proof of this theorem will be presented in Section 7.</p>

    <p class="text-gray-300">Corollary 5 (Adaptively secure state machine replication in the sleepy model.). Assume the existence of a Bare PKI, a CRS; the existence of sub-exponentially hard collision-resistant hash functions, and sub-exponentially hard enhanced trapdoor permutations. Then, for any constant  <span class="math">\\epsilon &gt; 0</span> , there exists a protocol that achieves state machine replication against adaptive corruptions and adaptive sleepiness, as long as  <span class="math">\\frac{1}{2} + \\epsilon</span>  fraction of awake nodes are honest in any time step.</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward from Theorem 8 and Lemma 1.</p>

    <p class="text-gray-300"><strong>Remark 2</strong> (A variant of practical interest.). Our complexity leveraging makes the security parameter dependent on N, the total number of players. This necessarily means that transaction confirmation will need to wait for poly(N) blocks.</p>

    <p class="text-gray-300">We point out a different variant that is of practical interest and which does not incur such blowup in security parameter and transaction confirmation time — this variant is directly implied by our proofs in Section 7. Specifically, if we are willing to assume adaptive sleepiness and static corruption, and assume that the CRS may be chosen after registration of all public keys, then we will not need complexity leveraging, and therefore we can achieve state machine replication with the same protocol as in Figure 4, but with a tight security parameter  <span class="math">\\lambda</span>  that is independent of N. This also means that the transaction confirmation time is independent of N.</p>

    <p class="text-gray-300">We first describe how to prove security under adaptive sleepiness but static corruption: this will be the more interesting part of the proof, and to achieve this, we will need to rely on complexity leveraging, but in this case how to do complexity leveraging turns out to be rather subtle. Once we are able to do this, we then describe how to leverage additional, standard complexity leveraging techniques (Section 7.4) to upgrade the security to the case of adaptive sleepiness and corruption.</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">7.1 Ideal-World Protocol: Adaptive Sleepiness and Static Corruption</h4>

    <p class="text-gray-300">Ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span> . In Figure 5, we modify the ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  for static corruption (see Section 5) to  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span> . The main difference between  <span class="math">\\mathcal{F}_{\\text{tree}}</span>  and  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span>  is the highlighted blue line: in  <span class="math">\\mathcal{F}_{\\text{tree}}</span> , the adversary  <span class="math">\\mathcal{A}</span>  is allowed to query the ideal functionality to check if anyone (including honest nodes) is elected leader at any time. However, in  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span> , each party can only make such queries for itself. In other words, the adversary  <span class="math">\\mathcal{A}</span>  can see into the future for corrupt parties but not for honest parties. In our new ideal protocol, the adversary  <span class="math">\\mathcal{A}</span>  can only learn that an honest party  <span class="math">\\mathcal{P}</span>  is elected for a time step t when  <span class="math">\\mathcal{P}</span>  actually announces a valid new block in time step t.</p>

    <pre><code class="language-text">\\mathcal{F}^*_{\\mathrm{tree}}(p) On init: tree := genesis, time(genesis) := 0
On receive leader(\\mathcal{P},t) from \\mathcal{P} itself or internally:  \\nif \\Gamma[\\mathcal{P},t] has not been set, let \\Gamma[\\mathcal{P},t] := \\begin{cases} 1 &amp; \\text{with probability } p \\\\ 0 &amp; \\text{o.w.} \\end{cases}
return \\Gamma[\\mathcal{P},t] On receive extend(chain, B) from \\mathcal{P}: let t be the current time:
assert chain \\in tree, chain||B \\notin tree, and leader(\\mathcal{P},t) outputs 1
append B to chain in tree, record time(chain||B) := t, and return &quot;succ&quot;
On receive extend(chain, B, t&#x27;) from corrupt party \\mathcal{P}^*: let t be the current time
assert chain \\in tree, chain||B \\notin tree, leader(\\mathcal{P}^*,t&#x27;) outputs 1, and time(chain) &lt; t&#x27; \\le t
append B to chain in tree, record time(chain||B) = t&#x27;, and return &quot;succ&quot;
On receive verify(chain) from \\mathcal{P}: return (chain \\in tree)
</code></pre>

    <p class="text-gray-300">Figure 5: Modified ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span> .</p>

    <p class="text-gray-300">Ideal protocol  <span class="math">\\Pi_{ideal}^*</span> . The ideal protocol  <span class="math">\\Pi_{ideal}^*</span>  is identical to  <span class="math">\\Pi_{ideal}</span>  except that now  <span class="math">\\mathcal{F}_{tree}</span>  is replaced with  <span class="math">\\mathcal{F}_{tree}^*</span> .</p>

    <p class="text-gray-300">Compliant executions: adaptive sleepiness and static corruption. A  <span class="math">\\Pi^*_{ideal}(p)</span> -compliant p.p.t. pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is defined in exactly the same way as a  <span class="math">\\Pi^*_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  except that now we allow  <span class="math">\\mathcal{Z}</span>  to make nodes sleep adaptively. However, we require that  <span class="math">\\mathcal{Z}</span>  still declares corruptions statically upfront.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-42-1&quot;&gt;&lt;/span&gt;<strong>Theorem 9</strong> (Security of the protocol  <span class="math">\\Pi_{ideal}^*</span>  under adaptive sleepiness and static corruption). For any constant  <span class="math">\\epsilon_0, \\epsilon &gt; 0</span> , any  <span class="math">T_0 \\geq \\epsilon_0 \\lambda</span> ,  <span class="math">\\Pi_{sleepy}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span>  consistency against any  <span class="math">\\Pi_{ideal}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  with  <span class="math">\\exp(-\\Omega(\\lambda))</span>  failure probability and the following parameters:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>chain growth lower bound parameter  <span class="math">g_0 = (1 \\epsilon)(1 2pN\\Delta)\\alpha</span> ;</li>
      <li>chain growth upper bound parameter  <span class="math">g_1 = (1 + \\epsilon)Np</span> ; and</li>
      <li>chain quality parameter  <span class="math">\\mu = 1 \\frac{1-\\epsilon}{1+\\phi}</span> ;</li>
    </ul>

    <p class="text-gray-300"><em>Proof.</em> Notice that in comparison with  <span class="math">\\Pi_{ideal}</span> , here our  <span class="math">\\Pi_{ideal}^*</span>  does not allow the adversary to see into future random bits of honest parties, however, we allow the adversary to adaptively make nodes sleep. It is not hard to observe that this change does not matter to the stochastic analysis for the  <span class="math">\\Pi_{ideal}</span>  protocol presented in Section 5, and the same proof still holds.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">7.2 Intermediate Hybrid Protocol</h3>

    <p class="text-gray-300">We make a few modifications to the ideal-world protocol  <span class="math">\\Pi_{\\text{ideal}}^*</span> , and introduce the following hybrid protocols.</p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span> . Recall that in the ideal-world protocol  <span class="math">\\Pi_{\\text{ideal}}^*</span> , the ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span>  generates fresh coins to decide of a player is elected leader for a time step. In the hybrid protocol  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span> , we modify  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span>  to obtain a new  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  that works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Any any time during the protocol execution,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  allows the adversary  <span class="math">\\mathcal{A}</span>  to specify what  <span class="math">k[\\mathcal{P}]</span>  value to use for a corrupt party  <span class="math">\\mathcal{P}</span>  (if one has not been chosen before).</li>
      <li>The function  <span class="math">\\mathtt{leader}(\\mathcal{P},t)</span>  is implemented as the following instead. On receive  <span class="math">\\mathtt{leader}(\\mathcal{P},t)</span>  from  <span class="math">\\mathcal{P}</span>  or internally: If  <span class="math">\\Gamma[\\mathcal{P},t]</span>  has been populated, return  <span class="math">\\Gamma[\\mathcal{P},t]</span> . Else,    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>if  <span class="math">\\mathcal{P}</span>  is honest, choose  <span class="math">\\Gamma[\\mathcal{P},t]</span>  at random as before, and return  <span class="math">\\Gamma[\\mathcal{P},t]</span> .</li>
      <li>else if  <span class="math">\\mathcal{P}</span>  is corrupt: if  <span class="math">\\mathcal{A}</span>  has not registered  <span class="math">k[\\mathcal{P}]</span>  with  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 1 \\rangle}</span> , return 0 (and without populating table Γ); else let  <span class="math">\\Gamma[\\mathcal{P}, t] := (\\mathsf{H}(\\mathcal{P}, t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t) &lt; D_p)</span>  where H denotes a random function, and return  <span class="math">\\Gamma[\\mathcal{P}, t]</span> .</li>
    </ul></li>
      <li><span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 1 \\rangle}</span>  is otherwise identical to  <span class="math">\\mathcal{F}_{\\mathrm{tree}}^*</span> .</li>
    </ul>

    <p class="text-gray-300">The protocol  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  is identical to  <span class="math">\\Pi_{\\text{ideal}}^*</span>  except that the players interact with the new  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  instead of  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span> . We say that  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  is  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}(p)</span> -compliant iff the pair is  <span class="math">\\Pi_{\\text{ideal}}^*(p)</span> -compliant.</p>

    <p class="text-gray-300">Note that the main difference between  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  and  <span class="math">\\Pi_{\\text{ideal}}^*</span>  is the following: in  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span> , corrupt nodes can influence the choice of the coins used to decide whether corrupt nodes are leaders, by setting the values of  <span class="math">k[\\mathcal{P}]</span> . In particular, the adversary can choose the values of  <span class="math">k[\\mathcal{P}]</span>  after querying  <span class="math">H(\\mathcal{P}, \\bot)</span>  for varying t's for any corrupt party  <span class="math">\\mathcal{P}</span> . Below, we argue that despite this ability, since the number of bits  <span class="math">\\vec{k}_{\\text{corrupt}} := \\{k[\\mathcal{P}] : \\mathcal{P} \\text{ corrupt}\\}</span>  that can be controlled by the adversary is small, there is still a significantly large fraction of random strings H that are good even for the worst-case choice of  <span class="math">\\vec{k}_{\\text{corrupt}}</span> .</p>

    <p class="text-gray-300">Claim 1 (Security of  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span> ). For any  <span class="math">T_0 \\geq cLN</span>  where c is an appropriate constant, protocol  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span>  consistency against any  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , where  <span class="math">g_0, g_1, \\mu</span>  are defined in the same way as in Theorem 9, and moreover, with security failure probability  <span class="math">\\exp(-\\Omega(LN))</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> We abuse notation and sometimes use H to denote the random string generated by  <span class="math">\\mathcal{F}_{hyb}^{\\langle 1 \\rangle}</span> . We use the notation v to denote the random bits  <span class="math">\\mathcal{F}_{hyb}^{\\langle 1 \\rangle}</span>  generated to decide whether honest nodes are elected leaders.</p>

    <p class="text-gray-300">Given a fixed  <span class="math">\\vec{k}_{\\text{corrupt}}</span> , we say that the random string  <span class="math">(\\mathsf{H}, v)</span>  is good for  <span class="math">\\vec{k}_{\\text{corrupt}}</span> , if in any view consistent with  <span class="math">\\mathsf{H}, v</span> , and  <span class="math">\\vec{k}_{\\text{corrupt}}</span> , no bad events related to  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span> -consistency occur where the parameters  <span class="math">T_0, g_0, g_1, \\mu</span>  are as given in the theorem statement. In other words,  <span class="math">(\\mathsf{H}, v)</span>  is good for  <span class="math">\\vec{k}_{\\text{corrupt}}</span>  if the combination of  <span class="math">\\mathsf{H}, v</span> , and  <span class="math">\\vec{k}_{\\text{corrupt}}</span>  does not permit any bad events.</p>

    <p class="text-gray-300">Due to Theorem 9, for every fixed  <span class="math">\\vec{k}_{\\text{corrupt}}</span>  and an appropriate choice of c, all but  <span class="math">e^{-LN}</span>  fraction of random strings  <span class="math">(\\mathsf{H}, v)</span>  are good for  <span class="math">\\vec{k}_{\\text{corrupt}}</span> .</p>

    <p class="text-gray-300">Now by union bound over the choice of  <span class="math">\\vec{k}_{\\text{corrupt}}</span> , we conclude that at least  <span class="math">1 - e^{-LN} \\cdot 2^{LN}</span>  fraction of random strings  <span class="math">(\\mathsf{H}, v)</span>  are good for all choices of  <span class="math">\\vec{k}_{\\text{corrupt}}</span> .</p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> . Almost identical to  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 1 \\rangle}</span>  except that now, the new ideal functionality  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 2 \\rangle}</span>  generates a random PRF key  <span class="math">k_0</span> , discloses it to  <span class="math">\\mathcal{A}</span> ; and further  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 2 \\rangle}</span>  replaces calls to the random function  <span class="math">\\mathsf{H}(\\_,\\_)</span>  with calls to  <span class="math">\\mathsf{PRF}_{k_0}(\\_,\\_)</span> .</p>

    <p class="text-gray-300">Claim 2 (Security of  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> ). Suppose that the PRF function with input length k is secure against all  <span class="math">2^{k^{\\delta}}</span> -time adversaries for some fixed constant  <span class="math">\\delta &lt; 1</span> . Suppose that  <span class="math">L \\geq \\log^2 \\lambda</span> ,  <span class="math">L_0 := |k_0| \\geq (2LN)^{\\frac{1}{\\delta}}</span> . Then, for any  <span class="math">T_0 \\geq cLN</span>  where c is an appropriate constant, protocol  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span>  satisfies  <span class="math">(T_0, g_0, g_1)</span> -chain growth,  <span class="math">(T_0, \\mu)</span> -chain quality, and  <span class="math">T_0^2</span>  consistency against any  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> -compliant, computationally unbounded pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , where  <span class="math">g_0, g_1, \\mu</span>  are defined in the same way as in Theorem 9, and moreover with security failure probability  <span class="math">\\exp(-\\Omega(LN))</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Given a random or pseudorandom string  <span class="math">r \\in \\{0,1\\}^{\\mathsf{poly}(\\lambda,N)}</span>  either sampled at random from  <span class="math">\\mathsf{H}(\\cdot)</span> , or generated from  <span class="math">\\mathsf{PRF}_{k_0}(\\cdot)</span>  for a randomly chosen  <span class="math">k_0</span> , and a random string v corresponding to randomness used for honest leader election, and a fixed  <span class="math">\\vec{k}_{\\mathsf{corrupt}}</span> , there is an algorithm running in time  <span class="math">\\mathsf{poly}(\\lambda,N)</span>  that checks if (r,v) is good for  <span class="math">\\vec{k}_{\\mathsf{corrupt}}</span> .</p>

    <p class="text-gray-300">Therefore, given (r, v), there is an algorithm running in time  <span class="math">\\mathsf{poly}(\\lambda, N) \\cdot 2^{LN}</span>  that can check if (r, v) is good for all  <span class="math">\\vec{k}_{\\text{corrupt}}</span> . Specifically, this algorithm brute-force enumerates all possible  <span class="math">\\vec{k}_{\\text{corrupt}}</span> , and checks if (r, v) is good for every  <span class="math">\\vec{k}_{\\text{corrupt}}</span> .</p>

    <p class="text-gray-300">When the PRF's input length  <span class="math">L_0 = (2LN)^{\\frac{1}{\\delta}}</span> , clearly the above algorithm runs in time that is subexponential in the PRF's input length. Due to the subexponential hardness of PRF, it holds that</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp; \\text{Pr}\\left[k_0 \\leftarrow_{\\</span>} {0,1}^{L_0}, r \\leftarrow \\mathsf{PRF}<em>{k_0}(\\cdot), \\upsilon \\leftarrow</em>{$} {0,1}^{\\mathsf{poly}(N,\\lambda)} : (r,\\upsilon) \\text{ good for every } \\vec{k}<em>{\\text{corrupt}} \\right] \\ \\leq &amp; \\text{Pr}\\left[r \\leftarrow</em>{$} \\mathsf{H}, \\upsilon \\leftarrow_{$} {0,1}^{\\mathsf{poly}(N,\\lambda)} : (r,\\upsilon) \\text{ good for every } \\vec{k}_{\\text{corrupt}} \\right] - 2^{-L_0^{\\delta}} \\end{split}$$</p>

    <p class="text-gray-300">Since otherwise, one can easily construct a reduction, such that when given a string r, the reduction generates a random v, and calls the above algorithm to check if (r, v) is good for all  <span class="math">\\vec{k}_{\\text{corrupt}}</span>  — in this way, the reduction can effectively distinguish whether r is truly random or pseudorandom, and thus break the security of the PRF.</p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span> .  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  is almost the same as  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> , except now the ideal functionality computes honest parties' random strings using pseudorandomness too, whereas earlier in  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> , the ideal functionality uses true randomness when deciding if honest parties are leaders.</p>

    <p class="text-gray-300">More formally, in  <span class="math">\\Pi_{hyb}^{\\langle 3 \\rangle}</span> , we modify the ideal functionality to obtain a new ideal functionality  <span class="math">\\mathcal{F}_{hyb}^{\\langle 3 \\rangle}</span>  that works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">During initialization,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  generates a fresh  <span class="math">k[\\mathcal{P}] \\leftarrow_{\\</span>} {0,1}^L$  for every honest player  <span class="math">\\mathcal{P}</span> .</p></li>
      <li><p class="text-gray-300">Next,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  generates a random seed  <span class="math">k_0 \\leftarrow_{\\</span>} {0, 1}^{L_0}$ , and discloses  <span class="math">k_0</span>  to the adversary  <span class="math">\\mathcal{A}</span> .</p></li>
      <li><p class="text-gray-300">At any time during the protocol execution,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  allows the adversary  <span class="math">\\mathcal{A}</span>  to specify what  <span class="math">k[\\mathcal{P}]</span>  value to use for a corrupt party  <span class="math">\\mathcal{P}</span>  (if one has not been chosen before).</p></li>
      <li><p class="text-gray-300">The function  <span class="math">\\mathtt{leader}(\\mathcal{P},t)</span>  is implemented as the following instead. On receive  <span class="math">\\mathtt{leader}(\\mathcal{P},t)</span>  from  <span class="math">\\mathcal{P}</span>  or internally: If  <span class="math">\\Gamma[\\mathcal{P},t]</span>  has been populated, return  <span class="math">\\Gamma[\\mathcal{P},t]</span> . Else,</p></li>
      <li><p class="text-gray-300">if  <span class="math">\\mathcal{P}</span>  is corrupt and  <span class="math">\\mathcal{A}</span>  has not registered  <span class="math">k[\\mathcal{P}]</span>  with  <span class="math">\\mathcal{F}_{\\text{hyb}}^{(3)}</span> , then return 0 without populating the  <span class="math">\\Gamma</span>  table;</p></li>
      <li><p class="text-gray-300">else, compute  <span class="math">\\eta := \\mathsf{PRF}_{k_0}(\\mathcal{P}, t) \\oplus \\mathsf{PRF}_{k[\\mathcal{P}]}(t)</span> , populate the table  <span class="math">\\Gamma[\\mathcal{P}, t] := (\\eta &lt; D_p)</span> , notify  <span class="math">\\mathcal{A}</span>  of the tuple  <span class="math">(\\mathcal{P}, t, \\eta)</span>  and return  <span class="math">\\Gamma[\\mathcal{P}, t]</span> .</p></li>
      <li><p class="text-gray-300"><span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 3 \\rangle}</span>  is otherwise identical to  <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 3 \\rangle}</span> .</p></li>
    </ul>

    <p class="text-gray-300">Recall that we use L to denote the input length of each player's PRF and all other cryptographic primitives. We now have the following claim.</p>

    <p class="text-gray-300">Claim 3 (Security of  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  under adaptive sleepiness and static corruption). Assume that the PRF is subexponentially hard. Then, if there is a  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  running in time subexponential in L that can cause bad events related to chain growth, quality, or consistency to happen with probability  <span class="math">\\epsilon</span>  in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , then there exists a  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}</span> -compliant  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that can cause the same bad events to happen in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 2 \\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span>  with probability  <span class="math">\\epsilon - 2^{-L^{\\delta}}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By straightforward reduction to the subexponential security of PRF — in particular, we can have a sequence of hybrids and replace each honest nodes' random coins one by one with pseudorandom bits.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}</span> .  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  is almost identical to  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span>  except that now, we modify the ideal functionality slightly as follows and obtain  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span> :</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>During initialization, the new  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  will honestly compute commitments  <span class="math">k[\\mathcal{P}]</span>  for every honest node  <span class="math">\\mathcal{P}</span> , and send the committed value to  <span class="math">\\mathcal{A}</span> .</li>
      <li>During initialization, the new  <span class="math">\\mathcal{F}_{\\mathrm{hyb}}^{\\langle 4 \\rangle}</span>  will call  <span class="math">\\mathsf{crs} \\leftarrow \\mathsf{gen}(1^L, \\mathcal{L})</span>  and send  <span class="math">\\mathsf{crs}</span>  to the adversary  <span class="math">\\mathcal{A}</span> .</li>
      <li>The new  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  allows  <span class="math">\\mathcal{A}</span>  to additionally query  <span class="math">\\text{nizk}(\\mathcal{P}, t&#x27;)</span>  at time t &gt; t' and for an honest party  <span class="math">\\mathcal{P}</span> . Upon such a query, if  <span class="math">\\mathcal{P}</span>  was not elected a leader in time t', return  <span class="math">\\bot</span> . Otherwise,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  computes  <span class="math">\\eta := \\mathsf{PRF}_{k[\\mathcal{P}]}(t&#x27;) \\oplus \\mathsf{PRF}_{k_0}(\\mathcal{P}, t&#x27;)</span> , and  <span class="math">\\pi := \\mathsf{NIZK.prove}(\\mathsf{crs}, \\mathsf{stmt}, w)</span>  where  <span class="math">\\mathsf{stmt} := (\\eta, c[\\mathcal{P}], k_0, \\mathcal{P}, t&#x27;)</span> ,  <span class="math">w := (k[\\mathcal{P}], r[\\mathcal{P}])</span> , and sends  <span class="math">\\eta, \\pi</span>  to  <span class="math">\\mathcal{A}</span> . In the above,  <span class="math">k[\\mathcal{P}]</span>  is the honest party's key chosen for  <span class="math">\\mathcal{P}</span>  by  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span> ,  <span class="math">c[\\mathcal{P}]</span>  was the commitment for party  <span class="math">\\mathcal{P}</span>  computed by  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  and revealed to  <span class="math">\\mathcal{A}</span> , and  <span class="math">r[\\mathcal{P}]</span>  was the randomness used in this commitment.</li>
    </ul>

    <p class="text-gray-300">Claim 4 (Security of  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  under adaptive sleepiness and static corruption). Assume that the commitment scheme is hiding both against subexponential adversaries, and the NIZK scheme satisfies computational zero-knowledge against subexponential adversaries. Then, if there is a  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}</span>  compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  running in time subexponential in L that can cause bad events related to chain growth, quality, or consistency to happen with probability  <span class="math">\\epsilon</span>  in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , then there exists a subexponential,  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}</span> -compliant  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that can cause the same bad events to happen in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 3 \\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span>  with probability  <span class="math">\\epsilon - 2^{-L^{\\delta}}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> By straightforward reduction to the hiding property of the commitment scheme and the computational zero-knowledge property of the zero-knowledge proof against subexponential adversaries.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\mathbf{hyb}}^{\\langle 5 \\rangle}</span> .  <span class="math">\\Pi_{\\mathbf{hyb}}^{\\langle 5 \\rangle}</span>  is almost identical to  <span class="math">\\Pi_{\\mathbf{hyb}}^{\\langle 4 \\rangle}</span>  except with the following changes (we call the new ideal functionality  <span class="math">\\mathcal{F}_{\\mathbf{hyb}}^{\\langle 5 \\rangle}</span>  in  <span class="math">\\Pi_{\\mathbf{hyb}}^{\\langle 5 \\rangle}</span> ):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Instead of having  <span class="math">\\mathcal{A}</span>  register  <span class="math">k[\\mathcal{P}]</span>  with  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  for a corrupt party  <span class="math">\\mathcal{P}</span> , we now have  <span class="math">\\mathcal{A}</span>  register  <span class="math">(k[\\mathcal{P}], r[\\mathcal{P}], c[\\mathcal{P}])</span>  with  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  (if such a tuple has not been chosen before) such that  <span class="math">c[\\mathcal{P}] = \\text{com}(k[\\mathcal{P}]; r[\\mathcal{P}])</span> .</li>
      <li>Whenever  <span class="math">\\mathcal{A}</span>  or  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  internall calls  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 5 \\rangle}</span> .leader( <span class="math">\\mathcal{P}, t</span> ) on for a corrupt party  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{F}_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  performs the following:    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">\\mathcal{A}</span>  has earlier supplied i) a tuple  <span class="math">(k[\\mathcal{P}], r[\\mathcal{P}], c[\\mathcal{P}])</span>  for corrupt party  <span class="math">\\mathcal{P}</span> , ii) a value  <span class="math">\\eta &lt; D_p</span> , and iii) a valid NIZK proof  <span class="math">\\pi</span>  for the statement stmt :=  <span class="math">(\\eta, c[\\mathcal{P}], k_0, \\mathcal{P}, t)</span> , then if  <span class="math">w = (k[\\mathcal{P}], r[\\mathcal{P}])</span>  is not a valid witness for stmt, abort outputting soundness-failure; else return 1.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In all other cases, return 0.</li>
    </ol></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">Claim 5 (Security of  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  under adaptive sleepiness and static corruption). If there is a  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  running in time subexponential in L that can cause bad events related to chain growth, quality, or consistency to happen with probability  <span class="math">\\epsilon</span>  in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , then there exists a subexponential,  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}</span> -compliant  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that can cause the same bad events to happen in  <span class="math">\\mathsf{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 4 \\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span>  with probability  <span class="math">\\epsilon</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is trivial.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><strong>Hybrid protocol</strong>  <span class="math">\\Pi_{\\text{hyb}}^*</span> .  <span class="math">\\Pi_{\\text{hyb}}^*</span>  is almost identical to  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  except that the new ideal functionality  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span>  does not check for soundness-failure, and the adversary  <span class="math">\\mathcal{A}</span>  only registers  <span class="math">c[\\mathcal{P}]</span>  for corrupt party  <span class="math">\\mathcal{P}</span>  without having to explain the commitment with  <span class="math">k[\\mathcal{P}], r[\\mathcal{P}]</span> .</p>

    <p class="text-gray-300">Claim 6 (Security of  <span class="math">\\Pi_{\\text{hyb}}^*</span>  under adaptive sleepiness and static corruption). Assume that the commitment scheme is perfectly binding and that the NIZK scheme satisfies computational soundness against subexponential adversaries. Then, if there is a  <span class="math">\\Pi_{\\text{hyb}}^*</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  running in time subexponential in L that can cause bad events related to chain growth, quality, or consistency to happen with probability  <span class="math">\\epsilon</span>  in  <span class="math">\\text{EXEC}^{\\Pi_{\\text{hyb}}^*}(\\mathcal{A}, \\mathcal{Z}, \\lambda)</span> , then there exists a subexponential,  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span> -compliant  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that can cause the same bad events to happen in  <span class="math">\\text{EXEC}^{\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}}(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;, \\lambda)</span>  with probability  <span class="math">\\epsilon - 2^{-L^{\\delta}}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> First, we show that  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  does not abort with soundness-failure except with  <span class="math">2^{-L^{\\delta}}</span>  probability. Since the commitment scheme is perfectly binding, if there is a valid witness, it must be  <span class="math">(k[\\mathcal{P}], r[\\mathcal{P}])</span> . Therefore, if  <span class="math">(k[\\mathcal{P}], r[\\mathcal{P}])</span>  is not a valid witness then the statement must be false; but if  <span class="math">\\mathcal{A}</span>  can forge a valid NIZK proof for such a statement with more than  <span class="math">2^{-L^{\\delta}}</span>  probability, we can easily build a reduction that breaks the computational soundness of the NIZK.</p>

    <p class="text-gray-300">Due to the above, we may consider a version of  <span class="math">\\mathcal{F}_{\\text{hyb}}^*</span>  does not check for soundness-failure but  <span class="math">\\mathcal{A}</span>  still submits a valid explanation  <span class="math">k[\\mathcal{P}], r[\\mathcal{P}]</span>  along with  <span class="math">c[\\mathcal{P}]</span> . Since soundness-failure happens only with  <span class="math">2^{-L^{\\delta}}</span>  failure probability, for any  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , any bad event (related to chain quality, chain growth, or consistency) that happens in  <span class="math">\\Pi_{\\text{hyb}}^{\\langle 5 \\rangle}</span>  with probability  <span class="math">\\epsilon</span>  can happen with probability at most  <span class="math">\\epsilon + 2^{-L^{\\delta}}</span>  here. Now, since  <span class="math">k[\\mathcal{P}], r[\\mathcal{P}]</span>  is never used by  <span class="math">\\mathcal{F}_{\\text{hyb}}^*</span> , we do not require  <span class="math">\\mathcal{A}</span>  to submit  <span class="math">k[\\mathcal{P}], r[\\mathcal{P}]</span> , and this should not affect the probability of any bad event (related to chain growth, quality, or consistency).</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">7.3 The Real World Emulates the Hybrid World</h4>

    <p class="text-gray-300"><strong>Simulator construction.</strong> We construct the following simulator S.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>In the beginning, the simulator S learns from  <span class="math">\\mathcal{F}_{\\text{hyb}}^*</span>  the value of  <span class="math">k_0</span> , NIZK.crs, as well as commitments of  <span class="math">k[\\mathcal{P}]</span>  for every honest node  <span class="math">\\mathcal{P}</span> . The simulator sets params :=  <span class="math">(k_0, \\text{NIZK.crs})</span>  as the common reference string, and supplies it to  <span class="math">\\mathcal{A}</span>  any time upon query.</li>
      <li>For each honest node  <span class="math">\\mathcal{P}</span> , the simulator  <span class="math">\\mathcal{S}</span>  chooses a signing key pair  <span class="math">(\\mathsf{pk}[\\mathcal{P}], \\mathsf{sk}[\\mathcal{P}])</span>  honestly. The simulator simulates  <span class="math">\\mathcal{F}_{CA}</span> . At the start of the execution, for each honest party  <span class="math">\\mathcal{P}</span> : the simulator and registers  <span class="math">(\\mathsf{pk}[\\mathcal{P}], c[\\mathcal{P}])</span>  on behalf of  <span class="math">\\mathcal{P}</span>  with the internally simulated  <span class="math">\\mathcal{F}_{CA}</span> , where  <span class="math">\\mathsf{pk}[\\mathcal{P}]</span>  was chosen earlier by  <span class="math">\\mathcal{S}</span>  and  <span class="math">c[\\mathcal{P}]</span>  denotes the commitment  <span class="math">\\mathcal{S}</span>  received earlier from  <span class="math">\\mathcal{F}_{\\text{tree}}^*</span>  for honest party  <span class="math">\\mathcal{P}</span> .</li>
      <li>If  <span class="math">\\mathcal{A}</span>  tries to register the pair  <span class="math">(\\mathsf{pk}[\\mathcal{P}], c[\\mathcal{P}])</span>  with  <span class="math">\\mathcal{F}_{CA}</span>  on behalf of corrupt party  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{S}</span>  simply forwards the request to the simulated  <span class="math">\\mathcal{F}_{CA}</span>  and registers  <span class="math">c[\\mathcal{P}]</span>  with  <span class="math">\\mathcal{F}_{hyb}^*</span> .</li>
      <li><span class="math">\\mathcal{S}</span>  keeps track of the &quot;real-world&quot; chain for every honest node  <span class="math">\\mathcal{P}</span> . Whenever it sends <em>chain</em> to  <span class="math">\\mathcal{A}</span>  on behalf of an honest  <span class="math">\\mathcal{P}</span> , it updates this state for node  <span class="math">\\mathcal{P}</span> . Whenever  <span class="math">\\mathcal{A}</span>  sends <em>chain</em> to honest node  <span class="math">\\mathcal{P}</span> , it may also update  <span class="math">\\mathcal{P}</span> 's state in ways to be described later.</li>
      <li>Whenever  <span class="math">\\mathcal{A}</span>  sends <em>chain</em> on behalf of corrupt party  <span class="math">\\mathcal{P}&#x27;</span>  to to honest node  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{S}</span>  checks the (real-world) validity of <em>chain</em> w.r.t. params and the current state of  <span class="math">\\mathcal{F}_{CA}</span> . If the check fails, the simulator simply ignores this message. Otherwise, do the following.</li>
      <li>(a) If <em>chain</em> is longer than the current real-world chain for the honest recipient  <span class="math">\\mathcal{P}</span> ,  <span class="math">\\mathcal{S}</span>  saves <em>chain</em> as the new real-world chain for  <span class="math">\\mathcal{P}</span> .</li>
      <li>(b) Let chain := extract(chain), and let chain[:  <span class="math">\\ell</span> ]  <span class="math">\\prec</span>  chain be the longest prefix such that  <span class="math">\\mathcal{F}^*_{\\text{hyb}}.\\text{verify}(\\text{chain}[:\\ell]) = 1</span> . The simulator checks to see if there exists a block in  <span class="math">chain[\\ell+1:]</span>  signed by an honest  <span class="math">\\mathcal{P}</span> . If so, abort outputting sig-failure. Else, for each  <span class="math">j \\in [\\ell+1,|\\text{chain}|]</span> ,    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(i) Let  <span class="math">\\mathcal{P}^* := chain[j].\\mathcal{P}</span> , let  <span class="math">t^* := chain[j].\\mathsf{time}</span> ,  <span class="math">\\pi := chain[j].\\pi</span> , and  <span class="math">\\eta := chain[j].\\eta</span> .</li>
      <li>(ii) Note that since the <em>chain</em> verifies it must be the case that  <span class="math">\\mathcal{A}</span>  has registered  <span class="math">(\\mathsf{pk}[\\mathcal{P}^*], c[\\mathcal{P}^*])</span>  with  <span class="math">\\mathcal{S}</span> . Now,  <span class="math">\\mathcal{S}</span>  supplies  <span class="math">\\pi</span>  to  <span class="math">\\mathcal{F}^*_{\\text{hyb}}</span>  for the statement  <span class="math">\\mathsf{stmt} := (\\eta, c[\\mathcal{P}^*], k_0, \\mathcal{P}^*, t^*)</span></li>
      <li>(iii)  <span class="math">\\mathcal{S}</span>  then calls  <span class="math">\\mathcal{F}^*_{\\text{hyb}}</span> .extend(chain[: j-1], chain[j],  <span class="math">t^*</span> ) on behalf of corrupt party  <span class="math">\\mathcal{P}^*</span> .</li>
    </ul></li>
      <li>Whenever an honest node  <span class="math">\\mathcal{P}</span>  sends chain to  <span class="math">\\mathcal{S}</span> ,  <span class="math">\\mathcal{S}</span>  looks up the current real-world state <em>chain</em> for node  <span class="math">\\mathcal{P}</span> . The simulator now computes a new chain using the real-world algorithm: let usk := (sk, c, -, -) be the secret key for the node  <span class="math">\\mathcal{P}</span> , let t be the current time, and let B := chain[-1].</li>
    </ul>

    <pre><code class="language-text">\\begin{split} &amp; \\text{let } (\\eta,\\pi) := \\mathcal{F}^*_{\\text{hyb}}.\\texttt{nizk}(\\mathcal{P},t) \\\\ &amp; \\text{let } \\sigma := \\Sigma.\\texttt{sign}_{\\text{sk}}(chain[-1].h, \\mathsf{B},t,\\eta,\\pi), \\ h&#x27; := \\mathsf{d}(chain[-1].h, \\mathsf{B},t,\\mathcal{P},\\eta,\\pi,\\sigma) \\\\ &amp; \\text{let } B := (chain[-1].h, \\mathsf{B},t,\\mathcal{P},\\eta,\\pi,\\sigma,h&#x27;), \\ \\text{let } chain&#x27; := chain||B \\ \\text{and gossip } chain \\end{split}
</code></pre>

    <p class="text-gray-300">Now, the simulator S sends chain' to A.</p>

    <p class="text-gray-300">• At any point of time, if S observes two different (real-world) valid chains that contain identical (real-world) blocks, abort outputting duplicate-block-failure.</p>

    <p class="text-gray-300"><strong>Indistinguishability.</strong> We now prove that the simulated execution and the real-world executions are computationally indistinguishable.</p>

    <p class="text-gray-300"><strong>Fact 10.</strong> Assume that the collision resistant hash function and the signature scheme are secure. The simulated execution never aborts with duplicate-block-failure or sig-failure except with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> Same as the proofs of Facts 7 and 8. If the above bad events happen with non-negligible probability, we can construct a polynomial-time reduction that breaks the collision resistance of the hash family or the signature scheme.  <span class="math">\\Box</span></p>

    <p class="text-gray-300">Fact 11. Conditioned on no duplicate-block-failure and no sig-failure the simulated execution is identically distributed as the real execution from the view of  <span class="math">\\mathcal{Z}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Straightforward to observe. In particular, we point out that whenever  <span class="math">\\mathcal{S}</span>  receives a valid <em>chain</em> from  <span class="math">\\mathcal{A}</span> , either  <span class="math">\\mathsf{extract}(\\mathit{chain})</span>  is already in  <span class="math">\\mathcal{F}^*_{\\mathsf{hyb}}</span>  or the simulator  <span class="math">\\mathcal{S}</span>  must succeed in adding  <span class="math">\\mathsf{extract}(\\mathit{chain})</span>  to  <span class="math">\\mathcal{F}^*_{\\mathsf{hyb}}</span> .</p>

    <p class="text-gray-300">So far, we have proved security under static corruption but adaptive sleepiness. Now, we would like to prove security under adaptive corruption — here rely on standard complexity leveraging techniques.</p>

    <p class="text-gray-300">Our earlier proof shows the following: if there is a real-world p.p.t.  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  that statically corrupts nodes and can break the security properties of  <span class="math">\\Pi_{\\text{sleepy}}^*</span> , then we can construct a p.p.t. reduction that interacts with  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span>  and breaks either the security of either the PRF, the hash function, the NIZK, or the digital signature scheme.</p>

    <p class="text-gray-300">Now, suppose we have an adaptive adversary  <span class="math">(\\mathcal{A}&#x27;, \\mathcal{Z}&#x27;)</span>  that can break the security properties of  <span class="math">\\Pi^*_{\\text{sleepy}}</span>  with probability  <span class="math">\\epsilon = \\frac{1}{\\text{poly}(\\lambda,N)}</span> . We can construct a static adversary  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  that makes random guesses as to what  <span class="math">(\\mathcal{A}&#x27;,\\mathcal{Z}&#x27;)</span> . If the guess turns out to be wrong later,  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  simply aborts. Such a  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  pair can break the security properties of  <span class="math">\\Pi^*_{\\text{sleepy}}</span>  with probability  <span class="math">\\frac{\\epsilon}{2^N}</span>  since  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  can guess correctly with probability  <span class="math">2^{-N}</span> . It holds that  <span class="math">(\\mathcal{A},\\mathcal{Z})</span>  must be able to break either the PRF, the hash function, the NIZK, or the digital signature scheme with probability  <span class="math">\\frac{\\epsilon}{2^N}</span> . Therefore, if we choose the security parameter of these cryptographic schemes to be  <span class="math">L := (2N + \\log^2 \\lambda)^{\\frac{1}{\\delta}}</span> , we have that  <span class="math">\\text{poly}(\\lambda, N) \\cdot 2^N \\ll 2^{((2N + \\log^2 \\lambda)^{\\frac{1}{\\delta}})^{\\delta}} + \\exp(-\\Omega(LN))</span> , then this should not be possible by our subexponential hardness assumptions.</p>

    <h3 id="sec-36" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-48-1&quot;&gt;&lt;/span&gt;8 Lower Bounds</h3>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">8.1 Lower Bound on Resilience</h4>

    <p class="text-gray-300">We show that in the sleepy model, honest majority (among awake nodes) is necessary for achieving consensus. Intuitively, imagine that there is a sleepy node who sleeps from protocol start to some time  <span class="math">t^*</span>  at which point it wakes up. If there are more corrupt nodes than alert ones, the adversary can always simulate a fake execution trace that is identically distributed as the real one; and now the sleepy node that just woke up cannot discern which one is real and which one simulated.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-48-0&quot;&gt;&lt;/span&gt;<strong>Theorem 10</strong> (Majority honest is necessary). In the sleepy execution model, it is not possible to realize state machine replication if there can be as many corrupt nodes than alert nodes — and this</p>

    <p class="text-gray-300">lower bound holds even assuming static corruption and the existence of a public-key infrastructure.</p>

    <p class="text-gray-300">Proof. For any protocol that achieves liveness (or in the case of blockchains, chain growth), there exists a (A, Z) pair that can break consistency with constant probability if there are as many corrupt nodes as alert ones:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>At the beginning of protocol execution, Z spawns k alert nodes, and k corrupt ones as well. Additionally, Z spawns a sleepy node denoted i &lt;sup&gt;∗&lt;/sup&gt; and makes it sleep from protocol start to some future time t ∗ .</li>
      <li>When protocol execution starts, A first has all corrupt nodes remain silent and not participate in the actual protocol execution;</li>
      <li>However, A simulates a protocol execution with the k corrupt nodes. Suppose that Z generates transaction inputs following some distribution D for the real execution. Now A uses the same distribution to generate simulated transactions for the simulated execution. We henceforth assume that two random samples from D are different with constant probability.</li>
      <li>When the sleepy node i &lt;sup&gt;∗&lt;/sup&gt; wakes up at time t ∗ , A delivers node i protocol messages from both the real and simulated executions.</li>
      <li>Since the real and simulated executions are identically distributed to the newly joining node i, there cannot exist an algorithm that can output the correct log with probability more than &lt;sup&gt;1&lt;/sup&gt; 2 .</li>
    </ul>

    <p class="text-gray-300">Recall that in our model, we assume that alert nodes can receive messages from other alert nodes within at most ∆ delay. Further, we assume that ∆ (or an upper bound on the network delay) is known to our protocol. Below, we show that making this assumption is necessary, since any protocol that does not have a-priori knowledge of ∆ cannot securely realize state machine replication in the sleepy model.</p>

    <p class="text-gray-300">Theorem 11. In the sleepy model, any protocol that does not take an upper bound on the network delay ∆ as input cannot realize state machine replication even when all awake nodes are honest (and the adversary therefore is merely a network adversary).</p>

    <p class="text-gray-300">Proof. Consider any such protocol that has no foreknowledge of ∆. Consider the following adversary A: it does not corrupt any nodes or make any nodes sleep; however, it divides the alert nodes into two camps, with a large ∆ = poly(λ, N) in between the two camps.</p>

    <p class="text-gray-300">After executing the protocol for some poly(λ, N) time, due to the requirement of achieving liveness even when a polynomial fraction of the nodes are sleeping, alert nodes in both camps must output a non-empty LOG — since nodes in one camp cannot distinguish if there is a long network delay between the camps, or if the other camp has fallen asleep. However, if the environment Z sent different inputs to the nodes in the two camps, their output LOGs will be different. This breaks consistency.</p>

    <p class="text-gray-300">We thank Rachit Agarwal, Hubert Chan, Kai-Min Chung, Naomi Ephraim, Ittay Eyal, and Andrew Morgan for helpful and supportive discussions. This work is supported in part by NSF grant number CNS-1561209.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-11&quot;&gt;&lt;/span&gt;[1] Boaz Barak, Ran Canetti, Yehuda Lindell, Rafael Pass, and Tal Rabin. Secure computation without authentication. In CRYPTO, pages 361–377, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-5&quot;&gt;&lt;/span&gt;[2] User &quot;BCNext&quot;. NXT. <a href="http://wiki.nxtcrypto.org/wiki/Whitepaper:Nxt">http://wiki.nxtcrypto.org/wiki/Whitepaper:Nxt</a>, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-8&quot;&gt;&lt;/span&gt;[3] Michael Ben-Or. Another advantage of free choice (extended abstract): Completely asynchronous agreement protocols. In Proceedings of the Second Annual ACM Symposium on Principles of Distributed Computing, PODC '83, pages 27–30, New York, NY, USA, 1983. ACM.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-6&quot;&gt;&lt;/span&gt;[4] Iddo Bentov, Ariel Gabizon, and Alex Mizrahi. Cryptocurrencies without proof of work. In Financial Cryptography Bitcoin Workshop, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-7&quot;&gt;&lt;/span&gt;[5] Iddo Bentov, Rafael Pass, and Elaine Shi. Snow white: Provably secure proofs of stake. <a href="https://eprint.iacr.org/2016/919.pdf">https://eprint.iacr.org/2016/919.pdf</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-9&quot;&gt;&lt;/span&gt;[6] Alysson Neves Bessani, Jo˜ao Sousa, and Eduardo Ad´ılio Pelinson Alchieri. State machine replication for the masses with BFT-SMART. In DSN, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-10&quot;&gt;&lt;/span&gt;[7] Gabriel Bracha and Sam Toueg. Asynchronous consensus and broadcast protocols. J. ACM, 32(4):824–840, October 1985.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-1&quot;&gt;&lt;/span&gt;[8] Christian Cachin, Klaus Kursawe, Frank Petzold, and Victor Shoup. Secure and efficient asynchronous broadcast protocols. In CRYPTO, pages 524–541, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-12&quot;&gt;&lt;/span&gt;[9] R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In FOCS, 2001.</p></li>
      <li><p class="text-gray-300">[10] Ran Canetti, Yevgeniy Dodis, Rafael Pass, and Shabsi Walfish. Universally composable security with global setup. In Theory of Cryptography. 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-13&quot;&gt;&lt;/span&gt;[11] Ran Canetti and Tal Rabin. Universal composition with joint state. In CRYPTO, 2003.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-2&quot;&gt;&lt;/span&gt;[12] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In OSDI, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-0&quot;&gt;&lt;/span&gt;[13] Danny Dolev and H. Raymond Strong. Authenticated algorithms for byzantine agreement. Siam Journal on Computing - SIAMCOMP, 12(4):656–666, 1983.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-3&quot;&gt;&lt;/span&gt;[14] Cynthia Dwork, Nancy Lynch, and Larry Stockmeyer. Consensus in the presence of partial synchrony. J. ACM, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-50-4&quot;&gt;&lt;/span&gt;[15] Cynthia Dwork and Moni Naor. Pricing via processing or combatting junk mail. In CRYPTO, 1992.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-17&quot;&gt;&lt;/span&gt;[16] Ittay Eyal and Emin Gun Sirer. Majority is not enough: Bitcoin mining is vulnerable. In FC, 2014.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-1&quot;&gt;&lt;/span&gt;[17] Pesech Feldman and Silvio Micali. An optimal probabilistic protocol for synchronous byzantine agreement. In SIAM Journal of Computing, 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-15&quot;&gt;&lt;/span&gt;[18] Michael J. Fischer, Nancy A. Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. J. ACM, 32(2):374–382, April 1985.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-12&quot;&gt;&lt;/span&gt;[19] Roy Friedman, Achour Mostefaoui, and Michel Raynal. Simple and efficient oracle-based consensus protocols for asynchronous byzantine systems. IEEE Trans. Dependable Secur. Comput., 2(1):46–56, January 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-7&quot;&gt;&lt;/span&gt;[20] Juan A. Garay, Aggelos Kiayias, and Nikos Leonardos. The bitcoin backbone protocol: Analysis and applications. In Eurocrypt, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-16&quot;&gt;&lt;/span&gt;[21] Rachid Guerraoui, Florian Huc, and Anne-Marie Kermarrec. Highly dynamic distributed computing with byzantine failures. In PODC, pages 176–183, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-2&quot;&gt;&lt;/span&gt;[22] Jonathan Katz and Chiu-Yuen Koo. On expected constant-round protocols for byzantine agreement. J. Comput. Syst. Sci., 75(2):91–112, February 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-18&quot;&gt;&lt;/span&gt;[23] Aggelos Kiayias and Giorgos Panagiotakos. Speed-security tradeoffs in blockchain protocols. IACR Cryptology ePrint Archive, 2015:1019, 2015.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-11&quot;&gt;&lt;/span&gt;[24] Aggelos Kiayias, Alexander Russell, Bernardo David, and Roman Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain protocol. Cryptology ePrint Archive, Report 2016/889, 2016. <a href="http://eprint.iacr.org/2016/889">http://eprint.iacr.org/2016/889</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-6&quot;&gt;&lt;/span&gt;[25] Sunny King and Scott Nadal. PPCoin: Peer-to-Peer Crypto-Currency with Proof-of-Stake, August 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-13&quot;&gt;&lt;/span&gt;[26] Leslie Lamport. The weak byzantine generals problem. J. ACM, 30(3):668–676, 1983.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-9&quot;&gt;&lt;/span&gt;[27] Leslie Lamport. Fast paxos. Distributed Computing, 19(2):79–103, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-10&quot;&gt;&lt;/span&gt;[28] Leslie Lamport, Dahlia Malkhi, and Lidong Zhou. Vertical paxos and primary-backup replication. In PODC, pages 312–313, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-14&quot;&gt;&lt;/span&gt;[29] Leslie Lamport, Robert Shostak, and Marshall Pease. The byzantine generals problem. ACM Trans. Program. Lang. Syst., 4(3):382–401, July 1982.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-3&quot;&gt;&lt;/span&gt;[30] Jean-Philippe Martin and Lorenzo Alvisi. Fast byzantine consensus. IEEE Trans. Dependable Secur. Comput., 3(3), 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-0&quot;&gt;&lt;/span&gt;[31] Silvio Micali. Algorand: The efficient and democratic ledger. https://arxiv.org/abs/1607.01341, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-8&quot;&gt;&lt;/span&gt;[32] Silvio Micali, Salil Vadhan, and Michael Rabin. Verifiable random functions. In FOCS, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-4&quot;&gt;&lt;/span&gt;[33] Andrew Miller, Yu Xia, Kyle Croman, Elaine Shi, and Dawn Song. The honey badger of BFT protocols. In ACM CCS, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-51-5&quot;&gt;&lt;/span&gt;[34] P. Mockapetris and K. Dunlap. Development of the Domain Name System. In SIGCOMM, pages 123–133, Stanford, CA, 1988.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-52-1&quot;&gt;&lt;/span&gt;[35] Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-52-2&quot;&gt;&lt;/span&gt;[36] Rafael Pass, Lior Seeman, and Abhi Shelat. Analysis of the blockchain protocol in asynchronous networks. <a href="https://eprint.iacr.org/2016/454">https://eprint.iacr.org/2016/454</a>.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-52-4&quot;&gt;&lt;/span&gt;[37] Rafael Pass and Elaine Shi. Fruitchains: A fair blockchain. Manuscript, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-52-3&quot;&gt;&lt;/span&gt;[38] Rafael Pass and Elaine Shi. Hybrid consensus: Efficient consensus in the permissionless model. Manuscript, 2016.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-52-0&quot;&gt;&lt;/span&gt;[39] Yee Jiun Song and Robbert van Renesse. Bosco: One-step byzantine asynchronous consensus. In DISC, pages 438–450, 2008.</p></li>
    </ul>

    <p class="text-gray-300">Earlier, for clarity, we presented a loose version of the consistency proof. In this section, we will present a tighter, but somewhat more involved consistency analysis.</p>

    <p class="text-gray-300">First, we need a stronger version of Lemma <a href="#page-29-0">6</a> and Corollary <a href="#page-30-0">3.</a> Informally speaking, the stronger version says the following: given any sufficiently long window, very likely there are more convergence opportunities in this window than adversarial time slots — even when the adversary is given ∆ extra time. The proof of the stronger version is similar to those of Lemma <a href="#page-29-0">6</a> and Corollary <a href="#page-30-0">3</a> but now also accouting for the extra ∆ time given to the adversary. As will become obvious later, this ∆ extra time given to the adversary will later allow us to perform a union bound for a sequence of times with a ∆ skip (rather than performing a union bound over all time steps); and this is important for tightening up the analysis.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-52-7&quot;&gt;&lt;/span&gt;Lemma 10 (Adversarial time slots vs. convergence opportunities for any fixed window). For any t0, t&lt;sup&gt;1&lt;/sup&gt; such that t := t&lt;sup&gt;1&lt;/sup&gt; − t&lt;sup&gt;0&lt;/sup&gt; ≥ c &lt;sup&gt;0&lt;/sup&gt;∆ for a sufficiently large constant c 0 , for any Πideal(p)-compliant pair (A, Z), there exists some positive constant η, such that for any positive λ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{A}(\\textit{view})[t_0 - \\Delta : t_1] \\geq \\mathbf{C}(\\textit{view})[t_0 : t_1]\\right] &lt; \\exp(-\\eta \\beta t)$$</p>

    <p class="text-gray-300">and<a href="#page-52-6">8</a></p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathbf{A}(\\textit{view})[t_0 : t_1 + \\Delta] \\geq \\mathbf{C}(\\textit{view})[t_0 : t_1]\\right] &lt; \\exp(-\\eta \\beta t)$$</p>

    <p class="text-gray-300">Proof. We prove one of the above cases with the extra ∆ given to the adversary at the beginning. The other case is similar. Due to Fact <a href="#page-24-2">2,</a> for any positive 1,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{A}[t_0 - \\Delta : t_0 + t] &gt; (1 + \\epsilon_1)\\beta(t + \\Delta)\\right] &lt; \\exp\\left(-\\frac{\\epsilon_1^2 \\beta t}{3}\\right)</span>$</p>

    <p class="text-gray-300">Due to Lemma <a href="#page-22-0">2,</a> for any positive 2, there exists positive 0 that depends on 2, such that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathbf{C}[t_0:t_0+t]&lt;(1-\\epsilon_2)(1-2pN\\Delta)\\alpha t\\right]\\leq \\exp(-\\epsilon&#x27;\\beta t)</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-52-6&quot;&gt;&lt;/span&gt;&lt;sup&gt;8&lt;/sup&gt; In this section, if the array bounds are ever negative or greater than |view|, they are rounded to 0 or |view| automatically.</p>

    <p class="text-gray-300">Since we know that</p>

    <p class="text-gray-300"><span class="math">$\\frac{\\alpha}{\\beta} &gt; \\frac{1+\\phi}{1-2pN\\Delta}</span>$</p>

    <p class="text-gray-300">and moreover  <span class="math">2\\beta\\Delta &lt; 2pN\\Delta &lt; 1</span> , it holds that for sufficiently small constants  <span class="math">\\epsilon_1</span>  and  <span class="math">\\epsilon_2</span> , and  <span class="math">t \\geq c&#x27; \\cdot \\Delta</span>  for a sufficiently large constant c',</p>

    <p class="text-gray-300"><span class="math">$(1 + \\epsilon_1)\\beta(t + \\Delta) &lt; (1 - \\epsilon_2)(1 - 2pN\\Delta)\\alpha t</span>$</p>

    <p class="text-gray-300">The rest of the proof is straightforward.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-53-0&quot;&gt;&lt;/span&gt;<strong>Fact 12.</strong> Let t' &lt; t. For any view, if for every non-negative integer k,  <span class="math">\\mathbf{C}(\\text{view})[t&#x27; - k\\Delta : t] &gt; \\mathbf{A}(\\text{view})[t&#x27; - (k+1)\\Delta : t]</span>  or  <span class="math">\\mathbf{A}(\\text{view})[t&#x27; - (k+1)\\Delta : t] = 0</span> , then, it holds that for any  <span class="math">t \\leq t&#x27;</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}(\\mathsf{view})[r:t] &lt; \\mathbf{C}(\\mathsf{view})[r:t] \\text{ or } \\mathbf{A}(\\mathsf{view})[r:t] = 0</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Basically for every  <span class="math">s \\in [t&#x27; - (k+1)\\Delta, t&#x27; - k\\Delta]</span> , we use  <span class="math">\\mathbf{C}(\\mathsf{view})[t&#x27; - k\\Delta : t]</span>  as a lower bound of  <span class="math">\\mathbf{C}(\\mathsf{view})[s : t]</span> ; and we use  <span class="math">\\mathbf{A}(\\mathsf{view})[t&#x27; - (k+1)\\Delta : t]</span>  as an upper bound of  <span class="math">\\mathbf{A}(\\mathsf{view})[s : t]</span> . The rest of the proof is straightforward.</p>

    <p class="text-gray-300">Intuitively, the above fact says that to make sure in every window (starting no later than t' and) ending at t, the convergence opportunities always outnumber adversarial time slots, it suffices to check every window but with a  <span class="math">\\Delta</span>  skip, that the convergence opportunities win even when the adversary is given  <span class="math">\\Delta</span>  extra time. This fact later allows us to do a union bound with a  <span class="math">\\Delta</span>  skip, making the union bound tighter.</p>

    <p class="text-gray-300">Similarly, we could also prove the following fact that is symmetric to Fact 12.</p>

    <p class="text-gray-300"><strong>Fact 13.</strong> Let t' &gt; t. For any view, if for every non-negative integer k,  <span class="math">\\mathbf{C}(\\text{view})[t:t&#x27;+k\\Delta] &gt; \\mathbf{A}(\\text{view})[t:t&#x27;+(k+1)\\Delta]</span>  or  <span class="math">\\mathbf{A}(\\text{view})[t:t&#x27;+(k+1)\\Delta] = 0</span> , then, it holds that for any  <span class="math">t \\geq t&#x27;</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{A}(\\mathsf{view})[t:r] &lt; \\mathbf{C}(\\mathsf{view})[t:r] \\text{ or } \\mathbf{A}(\\mathsf{view})[t:r] = 0</span>$</p>

    <p class="text-gray-300">&lt;span id=&quot;page-53-1&quot;&gt;&lt;/span&gt;<strong>Lemma 11</strong> (Any given time is likely a strong pivot). For any t, for any  <span class="math">\\Pi_{ideal}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a positive constant c, such that for any positive  <span class="math">\\lambda</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : t \\text{ is a strong pivot in view}\\right] \\geq c$$</p>

    <p class="text-gray-300">Note that since every strong pivot must also be a w-pivot, it holds that for any w, the following also holds:</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathsf{view} \\leftarrow_{\\</span>} \\mathsf{EXEC}^{\\Pi_{\\mathsf{ideal}}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : t \\text{ is a } w\\text{-pivot in view}\\right] \\geq c$$</p>

    <p class="text-gray-300"><em>Proof.</em> For simplicity, for t' &lt; t, let  <span class="math">\\mathsf{bad}(t&#x27;)</span>  denote the bad event that  <span class="math">\\mathbf{C}[t&#x27;:t] \\leq \\mathbf{A}[t&#x27;-\\Delta:t]</span> . For t' &gt; t, let  <span class="math">\\mathsf{bad}(t&#x27;)</span>  denote the bad event that  <span class="math">\\mathbf{C}[t:t&#x27;] \\leq \\mathbf{A}[t:t&#x27;+\\Delta]</span> .</p>

    <p class="text-gray-300">Let  <span class="math">t_c := \\frac{c_1}{\\beta \\eta}</span>  where  <span class="math">c_1</span>  is a suitable constant and  <span class="math">\\eta</span>  is the positive constant corresponding to Lemma 10. Observe also since  <span class="math">2\\beta \\Delta &lt; 2pN &lt; 1</span>  and hence  <span class="math">\\beta &lt; 0.5</span> , it holds that  <span class="math">(1 - \\beta)^{\\frac{1}{\\beta}} &gt; 0.25</span> .</p>

    <p class="text-gray-300">We now have the following:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} &amp;\\Pr\\left[t\\text{ is a strong pivot}\\right] \\geq \\Pr\\left[t\\text{ is a strong pivot and }\\mathbf{A}[t-t_c:t+t_c]=0\\right] \\\\ &amp;\\geq \\Pr\\left[\\mathbf{A}[t-t_c:t+t_c]=0\\right] \\cdot \\Pr\\left[\\text{for any }t&#x27; &lt; t-t_c \\text{ or }t&#x27; &gt; t+t_c \\text{: }\\overline{\\text{bad}}(t&#x27;) \\left|\\mathbf{A}[t-t_c:t+t_c]=0\\right] \\right] \\\\ &amp;\\geq \\Pr\\left[\\mathbf{A}[t-t_c:t+t_c]=0\\right] \\cdot \\Pr\\left[\\text{for any }t&#x27; &lt; t-t_c \\text{ or }t&#x27; &gt; t+t_c \\text{: }\\overline{\\text{bad}}(t&#x27;)\\right] \\\\ &amp;\\geq \\left((1-\\beta)^{\\frac{1}{\\beta}}\\right)^{\\frac{c_1}{\\eta}} \\cdot \\left(\\begin{array}{cc} 1-\\Pr\\left[\\text{bad}(t-t_c)\\right]-\\Pr\\left[\\text{bad}(t-t_c-\\Delta)\\right]-\\Pr\\left[\\text{bad}(t-t_c-2\\Delta)\\right]\\dots\\right) &amp; \\text{union bound,} \\\\ -\\Pr\\left[\\text{bad}(t+t_c)\\right]-\\Pr\\left[\\text{bad}(t+t_c+\\Delta)\\right]-\\Pr\\left[\\text{bad}(t+t_c+2\\Delta)\\right]\\dots\\right) &amp; \\text{Fact } 12 \\\\ &amp;\\geq \\left(\\frac{1}{4}\\right)^{\\Theta(1)} \\cdot \\left(1-2e^{-c_1}-2e^{-c_1+\\eta\\beta\\Delta}-2e^{-c_1+2\\eta\\beta\\Delta}-\\dots\\right) &amp; \\text{Lemma } 10, \\ c_1 \\text{ sufficiently large const} \\\\ &amp;= \\left(\\frac{1}{4}\\right)^{\\Theta(1)} \\cdot \\left(1-\\frac{2e^{-c_1}}{1-e^{-\\eta\\beta\\Delta}}\\right) \\end{split}</span>$</p>

    <p class="text-gray-300">Since  <span class="math">\\beta\\Delta = \\Theta(1)</span> , as long as we pick constant  <span class="math">c_1</span>  such that  <span class="math">2e^{-c_1} &lt; 1 - e^{-\\eta\\beta\\Delta}</span> , the last line above is a constant greater than 0.</p>

    <p class="text-gray-300">Recall that given a view, we say that  <span class="math">\\mathsf{many-pivots}^{w,W}(\\mathsf{view}) = 1</span>  iff for any s, r such that  <span class="math">r - s &gt; W \\ge 0</span> , there must exist a w-pivot during the window [s, r].</p>

    <p class="text-gray-300">&lt;span id=&quot;page-54-0&quot;&gt;&lt;/span&gt;<strong>Theorem 12</strong> (There are many pivot points). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant pair  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists a constant C, such that for any  <span class="math">\\lambda</span> , the following holds for  <span class="math">W = \\frac{C\\lambda^2}{\\beta}</span>  and  <span class="math">w = \\frac{\\lambda}{\\beta}</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{many-pivots}^{w,W}(\\textit{view}) = 1\\right] &lt; \\exp(-\\lambda)$$</p>

    <p class="text-gray-300">Proof. Recall that  <span class="math">\\beta \\Delta &lt; 2pN\\Delta &lt; 1</span> , therefore,  <span class="math">W = \\frac{C\\lambda^2}{\\beta} = C \\cdot w \\cdot \\lambda = \\frac{C}{2} \\cdot 2w \\cdot \\lambda &lt; \\frac{C}{2} \\cdot (w + \\Delta) \\cdot \\lambda</span> . Consider a window (s,r) of length at least W, and a sequence of events  <span class="math">\\mathsf{G}_0, \\mathsf{G}_1, \\ldots</span>  where  <span class="math">\\mathsf{G}_i</span>  denote the good event that the time  <span class="math">s+i\\cdot 2(w+\\Delta)</span>  is a w-pivot, where i can range from 0 to  <span class="math">\\frac{C}{4} \\cdot \\lambda</span> . By the definition of w-pivots and that of convergence opportunities, it is not hard to see that all these events  <span class="math">\\mathsf{G}_0, \\mathsf{G}_1, \\ldots</span>  are independent. The probability that all these good events do not happen is upper bounded by the following where c is the constant from Lemma 11, and C is sufficiently large w.r.t. c.</p>

    <p class="text-gray-300"><span class="math">$\\left(1 - \\frac{1}{c}\\right)^{\\frac{C}{4} \\cdot \\lambda} \\le \\exp(-\\lambda)</span>$</p>

    <p class="text-gray-300">The remainder of the proof follows from a simple union bound over all possible such windows.  <span class="math">\\Box</span></p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">A.2 Proof of Consistency</h4>

    <p class="text-gray-300"><strong>Theorem 13</strong> (Consistency). For any  <span class="math">\\Pi_{ideal}(p)</span> -compliant  <span class="math">(\\mathcal{A}, \\mathcal{Z})</span> , there exists positive constants  <span class="math">\\eta</span>  and C, such that for any  <span class="math">\\lambda \\in \\mathbb{N}</span> , the following holds for  <span class="math">T = C\\lambda^2</span> :</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\textit{view} \\leftarrow_{\\</span>} \\textit{EXEC}^{\\Pi_{ideal}(p)}(\\mathcal{A}, \\mathcal{Z}, \\lambda) : \\mathsf{consistent}^T(\\textit{view}) = 1\\right] \\geq 1 - \\exp(-\\eta \\lambda)$$</p>

    <p class="text-gray-300"><em>Proof.</em> The proof is identical to that of Theorem 6, except that now, we use a tighter value of W as given in Theorem 12.</p>

    <p class="text-gray-300">For completeness, we quote the version of Chernoff Bound adopted in this paper.</p>

    <p class="text-gray-300"><strong>Theorem 14</strong> (Chernoff bound). Let  <span class="math">\\mathbf{X} := \\sum_{i=1}^{n} \\mathbf{X}_{i}</span> , where each  <span class="math">\\mathbf{X}_{i} = 1</span>  with probability  <span class="math">p_{i}</span> , and  <span class="math">\\mathbf{X}_{i} = 0</span>  with probability  <span class="math">1 - p_{i}</span> ; and further, all  <span class="math">\\mathbf{X}_{i}</span> 's are independent. Let  <span class="math">\\mu := \\mathbf{E}[\\mathbf{X}] = \\sum_{i=1}^{n} p_{i}</span> . Then, we have that</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathbf{X} &gt; (1+\\delta)\\mu] \\le e^{-\\frac{\\delta^2}{2+\\delta}\\mu} \\text{ for all } \\delta &gt; 0</span>$</p>

`;
---

<BaseLayout title="The Sleepy Model of Consensus (2016/918)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2016 &middot; eprint 2016/918
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="the-sleepy-model-of-consensus-2016" />
  </article>
</BaseLayout>
