---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/1784';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Succinct Arguments over Towers of Binary Fields';
const AUTHORS_HTML = 'Benjamin E. Diamond, Jim Posen';

const CONTENT = `    <p class="text-gray-300">Benjamin E. Diamond</p>

    <p class="text-gray-300">Jim Posen</p>

    <p class="text-gray-300">Irreducible</p>

    <p class="text-gray-300">Irreducible</p>

    <p class="text-gray-300"><a href="mailto:bdiamond@irreducible.com">bdiamond@irreducible.com</a></p>

    <p class="text-gray-300"><a href="mailto:jposen@irreducible.com">jposen@irreducible.com</a></p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">We introduce an efficient SNARK for towers of binary fields. Adapting Brakedown (CRYPTO '23), we construct a multilinear polynomial commitment scheme suitable for polynomials over tiny fields, including that with just two elements. Our commitment scheme, unlike those of previous works, treats small-field polynomials with no embedding overhead. We further introduce binary-field adaptations of HyperPlonk (EUROCRYPT '23)'s product and permutation checks and of Lasso (EUROCRYPT '24)'s lookup. Our binary PLONKish variant captures standard hash functions—like Keccak-256 and Grøstl extremely efficiently. With recourse to thorough performance benchmarks, we argue that our scheme can efficiently generate precisely those Keccak-256-proofs which critically underlie modern efforts to scale Ethereum.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Succinct noninteractive arguments of knowledge, or SNARKs, have recently surged in relevance. Though long hindered by poor prover performance, SNARKs now plausibly stand to make blockchains more scalable, thanks to a recent, renewed effort to make these schemes more concretely efficient.</p>

    <p class="text-gray-300">Many modern SNARKs proceed according to a framework which compiles polynomial interactive oracle proofs into succinct arguments of knowledge using polynomial commitment schemes. This framework's formalization appears in B¨unz, Fisch and Szepieniec [\\[BFS20\\]](#page-44-0) and Chiesa et al. [\\[Chi+20\\]](#page-45-0). That latter work along with several previous works, like Maller, Bowe, Kohlweiss, and Meiklejohn's Sonic [\\[MBKM19\\]](#page-46-0) and Gabizon, Williamson, and Ciobotaru's PlonK [\\[GWC19\\]](#page-45-1), in which the polynomial IOP framework is implicit uses the celebrated polynomial commitment scheme of Kate, Zaverucha, and Goldberg (KZG) [\\[KZG10\\]](#page-45-2), which relies on the hardness of the discrete logarithm problem in elliptic curve groups.</p>

    <p class="text-gray-300">Ben-Sasson et al.'s highly influential Fast Reed–Solomon IOP of Proximity (FRI) [\\[BBHR18a\\]](#page-43-0) has reenergized an alternative approach—dating originally to Kilian [\\[Kil92\\]](#page-45-3)—which, in contrast with that based on elliptic curves, achieves succinct arguments with the aid of linear error-correcting codes and collision-resistant hash functions. The most popular exemplar of this latter approach is the Scalable Transparent Arguments of Knowledge (STARK) protocol of Ben-Sasson, Bentov, Horesh, and Riabzev [\\[BBHR18b\\]](#page-43-1). Subsequent expositions of this line of work have reinterpreted STARKs in the polynomial IOP framework discussed above (see for example Hab¨ock [\\[Hab22\\]](#page-45-4)); in this light, we freely refer henceforth to the FRI polynomial commitment scheme (FRI-PCS).</p>

    <p class="text-gray-300">FRI-PCS is not the sole polynomial commitment scheme that leverages linear codes and hash functions. Golovnev et al.'s Brakedown polynomial commitment scheme [\\[Gol+23\\]](#page-45-5), which distills ideas from Bootle, Chiesa, and Groth [\\[BCG20\\]](#page-43-2) and Ames, Hazay, Ishai, and Venkitasubramaniam [\\[AHIV23\\]](#page-43-3), also uses linear error-correcting codes, and operates within the IOP model. Asymptotically, Brakedown's verifier complexity and proof size both grow on the order of the square root of the size of the polynomial being evaluated. (We use terminology somewhat permissively in this work, by classifying as "SNARKs" those protocols whose verifiers scale merely sublinearly, as opposed to strictly polylogarithmically, in their witness sizes.) Diamond and Posen [\\[DP24\\]](#page-45-6) improve the concrete efficiency of Brakedown by a factor of roughly two. While Brakedown's asymptotic verifier complexity is inferior to FRI's, in many settings of practical interest, the concrete extent of this inferiority is mild, so that Brakedown's highly efficient prover makes it a practical alternative.</p>

    <p class="text-gray-300">Recursive proof composition stands to further mitigate the impact of Brakedown's less-efficient verifier. Instead of proving an entire statement or virtual machine execution in a single SNARK, one can often split up the statement in such a manner that it may be verified incrementally. Valiant [Val08] shows that incrementally verifiable computation can be realized through recursive SNARK composition, so that a long virtual machine execution, say, might be proven with recourse just to SNARKs for circuits of bounded size. By composing a series of inner SNARKs with large proof sizes but fast proving times with an outer SNARK with a small proof and a relatively slower proving time, one might obtain a hybrid system that features both a small proof and a fast proving time.</p>

    <p class="text-gray-300">Three major factors account for the performance advantage enjoyed by FRI-PCS and Brakedown-based SNARKs over those based on elliptic curve assumptions.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Small fields. Elliptic curve groups must be large—on the order of 256 bits—to attain standard security levels. The ethSTARK [Sta21] and Plonky2 [Pol22] systems pioneer an alternative design, characterized by the use of smaller fields (specifically, of prime fields on the order of 64 bits). By leveraging the relative efficiency of small-field arithmetic, these systems achieve state-of-the-art proving performance. Moreover, these protocols' use only of small-field elements reduces their storage requirements, which in turn leads to better cache-efficiency on CPUs.</li>

      <li>Structured fields. These schemes tend to use fields that are not just small, but also computationally structured. Plonky2 [Pol22], for example, highlights the Goldilocks field  <span class="math">\\mathbb{F}_p</span> , where  <span class="math">p = 2^{64} 2^{32} + 1</span> . This prime modulus is a Solinas prime—that is, a prime of the form  <span class="math">\\phi^2 \\phi + 1</span> , where here  <span class="math">\\phi = 2^{32}</span> —and so admits an especially efficient modular reduction algorithm.</li>

      <li>Efficient primitives. Standard-issue collision-resistant hash functions are much faster than elliptic curve primitives.</li>

    </ul>

    <p class="text-gray-300">As a rough comparison, the FRI-PCS scheme parameterized with Goldilocks and Keccak-256 commits 1 MiB of data about 7-fold faster than does KZG [KZG10] over the BN254 bilinear group. We note that polynomial commitment accounts for the bulk of the prover's cost in most SNARKs.</p>

    <p class="text-gray-300">In view of the performance gains that smaller finite fields stand to unlock, in this work, we extend this trend to its logical conclusion: SNARKs over the smallest field,  <span class="math">\\mathbb{F}_2</span> .</p>

    <p class="text-gray-300">Binary fields. Finite fields of characteristic 2, or binary fields, have a rich history in cryptography. The AES block cipher and the GMAC message authentication code, standardized for use alongside AES, famously use the binary fields  <span class="math">\\mathbb{F}_{2^8}</span>  and  <span class="math">\\mathbb{F}_{2^{128}}</span> , respectively. A further important line of research pertains to cryptographically secure elliptic curves over binary fields; these curves feature highly efficient circuit instantiations. We recall some basic properties of binary fields that account for their applicability in cryptography. The elements of the field  <span class="math">\\mathbb{F}_{2^k}</span>  can be unambiguously represented as k-bit strings; for example, there is a bijection between the set of bytes of data and the finite field  <span class="math">\\mathbb{F}_{2^8}</span> . Field addition corresponds to the logical exclusive or (XOR) operation on these bit representations. Also, squaring elements of a binary field is significantly less expensive than multiplying two distinct elements is, thanks to the fact that  <span class="math">(x+y)^2 = x^2 + y^2</span>  for each pair of elements x and y in these fields (an identity sometimes called the "freshman's dream").</p>

    <p class="text-gray-300">In this work, we present a SNARK construction over the field  <span class="math">\\mathbb{F}_2</span>  which competes favorably with state-of-the-art systems built with prime fields. Moreover, we argue that when proving computations that depend heavily on bitwise operations, such as the SHA-256 and Keccak-256 hash functions, our system outperforms its prime field-based peers. We acknowledge that our work is not the first to consider SNARKs over characteristic-2 fields; it is the first we are aware of, however, which delivers an implementation-oriented SNARK construction over  <span class="math">\\mathbb{F}_2</span>  specifically, and which moreover avoids embedding overhead, a phenomenon we now explain. While [BBHR18b] develops a STARK construction over characteristic-2 fields, the naïve use of small field techniques cannot deliver superior concrete efficiency over  <span class="math">\\mathbb{F}_2</span> , for a simple reason: the alphabet of each Reed-Solomon code must be at least as large as its block length. Separately from this limitation, which pertains to the FRI IOP of proximity, the ALI protocol in STARK—as well as the DEEP-ALI protocol of the successor work Ben-Sasson, Goldberg, Kopparty, and Saraf [BGKS19]—uses fast polynomial multiplication techniques. Fast multiplication techniques for polynomials over  <span class="math">\\mathbb{F}_2</span>  embed those polynomials  <span class="math">\\mathbb{F}_2</span> -coefficients into an extension field, and so mandate the use of a field at least as large as the witness.</p>

    <p class="text-gray-300">An influential line of recent works—which includes Spartan [Set20], HyperPlonk [CBBZ23], and CCS [STW23]—raises the prospect of overcoming these limitations. These works develop SNARKs that by-pass polynomial multiplication; instead, they leverage the classical multivariate sumcheck protocol of Lund, Fortnow, Karloff, and Nisan [LFKN92], developed further in key work of Goldwasser, Kalai and Rothblum [GKR15]. These protocols use multilinear polynomial IOPs and multilinear polynomial commitment schemes, as opposed to these objects' univariate analogues. Equipped with the polynomial commitment schemes of [Gol+23] and [DP24]—which do not mandate the use of Reed–Solomon codes, and in fact work for general linear codes—the multilinear regime stands to deliver efficient SNARKs over  <span class="math">\\mathbb{F}_2</span>  with no embedding overhead.</p>

    <p class="text-gray-300">While Reed–Solomon codes represent far from the only available choice, they nonetheless remain attractive. They are efficiently encodable and maximum-distance separable, and, moreover, admit a proximity-gap result—due to Ben-Sasson et al. [Ben+23]—which strengthens the best-available analogues currently known for general linear codes.</p>

    <p class="text-gray-300">We propose two concrete polynomial commitment schemes over  <span class="math">\\mathbb{F}_2</span> , both based on Brakedown. We recall that Brakedown works roughly by shaping its input polynomial's coefficients into a two-dimensional matrix, encoding it row-wise, and then randomly testing the resulting matrix's columns for proximity to the code and for consistency with prover-supplied messages. One candidate  <span class="math">\\mathbb{F}_2</span> -multilinear polynomial commitment would opt to instantiate Brakedown with a concatenated code, itself constructed using a Reed–Solomon outer code and an ad-hoc inner code (that inner code's message and block lengths are so small that it can be selected using ad-hoc techniques). Targeting prover efficiency and implementation simplicity, we propose a second option, which—in virtue of a technique we call block-level encoding—allows us to use Reed–Solomon codes simpliciter. Our second scheme draws inspiration from the concatenated code-based approach, but simplifies that approach by omitting its inner code. The idea is to pack the elements of each message into extension field elements, to encode each resulting message using a Reed–Solomon code, and finally to randomly sample and test blocks of contiguous columns from the encoded matrix—which themselves correspond to Reed–Solomon symbols in the extension field—as opposed to sampling and testing individual columns. Though this approach yields slightly larger proofs than the concatenated code-based method does, its implementation advantages compensate for that shortcoming.</p>

    <p class="text-gray-300">Using this technique, our protocol attains the remarkable property whereby its commitment phase imposes zero embedding overhead. That is, the cost of committing an  <span class="math">\\ell</span> -variate multilinear polynomial  <span class="math">t(X_0, ..., X_{\\ell-1})</span>  over  <span class="math">\\mathbb{F}_2</span>  is nearly identical under our scheme—i.e., aside from small data transposes—to that of committing an  <span class="math">\\ell - \\kappa</span> -variate polynomial  <span class="math">t&#x27;(X_0, ..., X_{\\ell-\\kappa-1})</span>  over the extension field  <span class="math">\\mathbb{F}_{2^{2^{\\kappa}}}</span>  (which contains the same quantity of information). On the other hand,  <span class="math">t(X_0, ..., X_{\\ell-1})</span> 's evaluation proofs are still more expensive than  <span class="math">t&#x27;(X_0, ..., X_{\\ell-\\kappa-1})</span> 's are, for both the prover and the verifier. Finally, the sumcheck protocol also runs less efficiently on  <span class="math">t(X_0, ..., X_{\\ell-1})</span>  than it does on  <span class="math">t&#x27;(X_0, ..., X_{\\ell-\\kappa-1})</span> , a consequence of the fact that that protocol draws its challenges from a cryptographically-sized extension field (like  <span class="math">\\mathbb{F}_{2^{128}}</span> ). This latter issue is remediated in part by certain optimizations to the sumcheck protocol available only in the small-field setting, which we discuss in Subsection 4.2.</p>

    <p class="text-gray-300">For these reasons, we decline to end our investigation of binary SNARKs at  <span class="math">\\mathbb{F}_2</span> . Rather, we push this approach further, by using a full tower of extensions over  <span class="math">\\mathbb{F}_2</span> , of the form  <span class="math">\\mathbb{F}_2 \\subset \\mathbb{F}_{2^2} \\subset \\mathbb{F}_{2^4} \\subset \\mathbb{F}_{2^8} \\subset \\cdots \\subset \\mathbb{F}_{2^{128}}</span> . In this way, we introduce a new sort of flexibility into our scheme's arithmetization procedure, whereby it may use finite fields that appropriately capture the respective data types that the high-level program it is arithmetizing uses.</p>

    <p class="text-gray-300">One key illustration of the utility of tower fields at the constraint system level appears in connection with the hash function  <span class="math">Gr \\not o stl</span>  [Gau+11]. Gr ostl has undergone extensive cryptanalysis and was a finalist candidate in the SHA-3 competition. The hash function's design is based on AES's and uses the same  <span class="math">Rijndael\\ S</span> -box as AES does. Like AES, Gr ostl is, in a sense, natively defined over  <span class="math">\\mathbb{F}_{2^8}</span> , and so admits an efficient arithmetization in any constraint system that features native  <span class="math">\\mathbb{F}_{2^8}</span> -operations. We believe that this fact makes Gr ostl an attractive candidate hash function for our SNARK system. This observation resembles one made by Ben-Sasson, Bentov, Horesh, and Riabzev [BBHR18b, § E], who note that hash functions based on the Rijndael-160 cipher possess simple arithmetic descriptions. Accordingly, we expect to encounter low recursion overheads in those SNARKs that use this work's techniques and are instantiated with Gr ostl. This fact marks a notable benefit over prime field-based SNARKs, which rely, for the sake of efficient recursive verification, on more recent—and less battle-tested—arithmetization-optimized hash functions like Poseidon [Gra+19].</p>

    <p class="text-gray-300">Our use of binary towers serves us beyond the arithmetization layer. In Subsection 2.3 below, we resurface an explicit, iterated tower construction due to Wiedemann [Wie88]. That tower boasts remarkable computational advantages, as Fan and Paar [FP97] first noticed. In Wiedemann's tower level  <span class="math">\\mathbb{F}_{2^k}</span> , multiplication, and even inversion, can be carried out with asymptotic complexity just  <span class="math">O(k^{\\log_2 3})</span> , a consequence of Karatsuba-based techniques. The multiplication of field elements with subfield elements has still better computational complexity, as we explain in Subsection 2.3. Chen et al. [Che+18] have exploited precisely this property of tower fields to improve the performance of polynomial multiplication in binary fields. In our performance evaluation in Section 6 below, we discuss the implications of the recently introduced Intel Galois Field New Instructions (GFNI) instruction set extension on software implementations of Wiedemann's tower that target capable processors.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">1.1 Our Contributions</h4>

    <p class="text-gray-300">We summarize our contributions in this work as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. A formal definition of small-field polynomial commitment schemes. While small field techniques appear in several existing SNARKs—such as Plonky2 [Pol22] and RISC Zero [BGR23]—the security of these schemes depends on a certain undocumented soundness property, whereby the committed polynomial's coefficients actually reside in the required ground field, as opposed to in the extension field from which the polynomial's evaluation query is drawn. (See Definition 3.3.)</li>

      <li>2. A proof that [DP24] achieves a small-field polynomial commitment scheme. We prove that the construction [DP24, Cons. 3]—with appropriate minor modifications—actually yields a small-field scheme in the strong sense outlined above, and so provides "better-than-advertised" security. (See Theorem 3.13.)</li>

      <li>3. A generalization of [DP24] which uses block-level testing. Our construction yields an efficient small-field polynomial commitment scheme for  <span class="math">\\mathbb{F}_2</span> -polynomials which uses Reed-Solomon codes alone, and which encounters zero embedding overhead during its commitment phase. (See Subsection 3.4.)</li>

      <li>4. An efficient shift argument for polynomials over the boolean hypercube. We define an operator which, on input a multivariate polynomial t, yields a multilinear polynomial whose values on the cube are exactly t's, but circularly rotated by an arbitrary amount of steps. Our construction answers an open problem posed by HyperPlonk (see [CBBZ23, p. 52] of the full version). (See Subsection 4.3.)</li>

      <li>5. An adaptation of the Lasso lookup argument [STW24] to the binary tower setting. Setty, Thaler and Wahby's Lasso [STW24] differs from prior lookup arguments—including that given in HyperPlonk [CBBZ23, § 3.7]—in that it explicitly exploits the relative cheapness of committing to small-valued elements. While the authors of [STW24] highlight this benefit only in the setting of elliptic curve-based polynomial commitments, we show how to capture it moreover in our tower setting. (See Subsection 4.4.)</li>

      <li>6. An adaptation of <em>PLONKish</em> to the binary tower setting, and a SNARK for it. We adapt the <em>PLONKish</em> arithmetization relation of HyperPlonk [CBBZ23, Def. 4.1] to our setting, enriching it in various ways (we introduce a constraint system defined over a tower of fields, as opposed to just one). (See Subsection 5.1.)</li>

      <li>7. An arithmetization of the Keccak-f[1600] permutation. This permutation resides at the core of the Keccak-256 hash function enshrined in the Ethereum protocol, and represents a key a bottleneck facing attempts to prove statements about the Ethereum blockchain. (See Subsection 5.4.)</li>

      <li>8. A performance evaluation of field arithmetic, our polynomial commitment scheme, and the sumcheck protocol, all in the tower setting. We moreover compare our software implementation to those of state-of-the-art prime field SNARKs. Our multilinear polynomial commitment scheme can commit a  <span class="math">2^{28}</span> -coefficient  <span class="math">\\mathbb{F}_2</span> -polynomial about 30-fold faster than can Plonky3's Baby Bear-based implementation of FRI-PCS, and about 40-fold faster than Hyrax [Wah+18]. (See Section 6.)</li>

    </ul>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">1.2 Prior Works</h4>

    <p class="text-gray-300">We discuss various relevant previous works. We have already mentioned above the <em>ethSTARK</em> [Sta21] and <em>Plonky2</em> [Pol22] systems, which introduce the use of 64-bit prime fields (and extensions thereof). The ALI [BBHR18b] and DEEP-ALI [BGKS19] protocols—also discussed above—appear to work even over binary fields, albeit with embedding overhead.</p>

    <p class="text-gray-300">The ECFFT sequence of works of Ben-Sasson, Carmon, Kopparty and Levit [BCKL23; BCKL22] presents an alternative to ALI and DEEP-ALI which makes applicable DEEP-ALI's cyclic-group-based approach in arbitrary fields (i.e., as opposed to merely in FFT-friendly prime fields). We note that ECFFT entails a form of embedding overhead twice as burdensome as that which DEEP-ALI imposes, as we now explain. Indeed, for a characteristic p (say, 2) and a witness size parameter k fixed, that work [BCKL22, Prop. 1] guarantees the existence of an acceptably sized elliptic curve E—that is, one whose group of  <span class="math">\\mathbb{F}_q</span> -rational points contains an order-2<sup>k</sup> cyclic subgroup—only over a doubly large field extension of  <span class="math">\\mathbb{F}_p</span> , of size  <span class="math">q \\geq \\Omega(2^{2 \\cdot k})</span> . In other words, it requires that the curve's field of definition  <span class="math">\\mathbb{F}_q</span>  be roughly as large as the square of the witness. (This fact relates to the Hasse–Weil bound; we refer to the proof of [BCKL22, Cor. 1].) Moreover, the work's Reed–Solomon codewords (in the sense of [BCKL22, Thm. 12]) have  <span class="math">\\mathbb{F}_q</span> -entries, in general. We see that messages with entries in  <span class="math">\\mathbb{F}_2</span> , say, stand to yield codewords that are  <span class="math">2 \\cdot k</span> -fold larger than rate considerations alone demand that they be. For this reason, we find that work unlikely to be competitive with ours.</p>

    <p class="text-gray-300">An interesting work of Cascudo and Giunta [CG22] directly targets the use of Ligero on witnesses valued in  <span class="math">\\mathbb{F}_2</span> . We briefly recall the approach of that work. Key to that work is the idea of a reverse multiplication-friendly embedding, a notion which originates with Cascudo, Cramer, Xing and Yuan [CCXY18]. In short—and we restrict our discussion to the case p := 2—a  <span class="math">(k, e)_2</span> -RMFE is a pair of  <span class="math">\\mathbb{F}_2</span> -linear maps  <span class="math">\\varphi : \\mathbb{F}_2^k \\to \\mathbb{F}_{2^e}</span>  and  <span class="math">\\psi : \\mathbb{F}_{2^e} \\to \\mathbb{F}_2^k</span>  for which, for each pair of elements x and y of  <span class="math">\\mathbb{F}_2^k</span> ,  <span class="math">x <em> y = \\psi(\\varphi(x) \\cdot \\varphi(y))</span>  holds (here, we denote by \\</em> componentwise multiplication, or bitwise AND). The insight of [CG22] is that RMFEs serve to export R1CSs relations defined over  <span class="math">\\mathbb{F}_2</span>  to related ones defined over  <span class="math">\\mathbb{F}_{2^e}</span> ; crucially, in this latter field, e is sufficiently large that Ligero can be applied off-the-shelf. Specifically, that work replaces each R1CS relation  <span class="math">A \\cdot w * B \\cdot w = C \\cdot w + b</span> , where  <span class="math">w \\in \\mathbb{F}_2^n</span>  say, with a related relation defined on the image  <span class="math">\\widetilde{w} := \\Phi(w) \\in \\mathbb{F}_{2^e}^{n/k}</span>  (here,  <span class="math">\\Phi</span>  denotes the block-wise extension of  <span class="math">\\varphi</span> ). On the one hand, Ligero can be used to decide this latter relation. On the other, the latter relation moreover implies the former, provided that  <span class="math">\\widetilde{w}</span>  is indeed in the image of  <span class="math">\\Phi</span> ; [CG22] describes further "lincheck" protocols which serve to convince the verifier of this fact.</p>

    <p class="text-gray-300">The first key question is how small e can be taken, relative to k. Cascudo and Giunta [CG22, § 2.2] note, first of all, the lower bound  <span class="math">e \\ge 2k-1</span> , so that a blowup of at least twofold is inevitable. On the positive side, using sophisticated techniques, [CCXY18, Thm. 5] shows that asymptotically,  <span class="math">e = \\Theta(k)</span>  can be achieved; moreover, when p := 2, the implicit constant can be taken to be less than 5 [CCXY18, Cor. 2]. Finally, [CG22, § A.1] presents practical constructions which show that, in essentially all parameter regimes of practical interest, e/k can be taken to be less than 4.</p>

    <p class="text-gray-300">In any case, we find that [CG22] stands to induce a factor-of-4 blowup in the size of the statement upon which Ligero is run, as well as to impose further computational costs associated with its linchecks. Our work, on the other hand, adapts Ligero so as to make that work applicable "natively" to  <span class="math">\\mathbb{F}_2</span> -elements, and induces no blowup. For these reasons, we find that work unlikely to compare favorably with ours.</p>

    <p class="text-gray-300">We finally note various works which build zero-knowledge proofs specifically for the boolean circuit model of computation, and which moreover feature asymptotically linear-time provers. Ron-Zewi and Rothblum [RR22] and Holmgren and Rothblum [HR22] develop an interesting approach based on tensor codes and "code switching"; their approach internally invokes a sequence of Spielman codes respectively defined over successive extension fields of characteristic 2. A further line of work applies techniques from MPC; we refer for example to Weng, Yang, Katz and Wang's Wolverine [WYKW21], as well as to the survey of Baum, Dittmer, Scholl and Wang [BDSW23]. These works, while interesting, face various limits as far as practical usability is concerned. They feature either private-coin verifiers [WYKW21; RR22; BDSW23], linearly-sized proofs [WYKW21; RR22; BDSW23], non-negligible soundness error [RR22], or else unspecified large constants [HR22]. We note finally that our PLONKish arithmetization (see Subsection 5.1 below) exposes a computational model significantly richer than that made available by boolean circuits. Indeed, our arithmetization features native  <span class="math">\\mathbb{F}_{2^{2^k}}</span> -operations (for arbitrary k), as well as custom gates, copy constraints, and lookups. For these reasons, our computational model can capture with much less overhead those statements of practical interest in blockchains.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">1.3 Technical Overview</h4>

    <p class="text-gray-300">We roughly sketch our work's main ideas. We begin with our polynomial commitment scheme. For simplicity, we sketch here only our scheme's behavior on  <span class="math">\\mathbb{F}_2</span> -polynomials; in general, our protocol supports polynomials over arbitrary binary fields of power-of-two degree.</p>

    <p class="text-gray-300">Review of Brakedown. To explain our scheme, we first recall the Ligero polynomial commitment scheme [AHIV23], as expressed by Brakedown [Gol+23], and further simplified by Diamond and Posen [DP24, § 4]. We fix an integer  <span class="math">\\ell \\geq 0</span>  and an  <span class="math">\\ell</span> -variate multilinear polynomial  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in \\mathbb{F}_{2^{128}}[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span> . We moreover partition  <span class="math">\\ell = \\ell_0 + \\ell_1</span> . For expository purposes, we in fact assume that  <span class="math">\\ell</span>  is even and that  <span class="math">\\ell_0 = \\ell_1</span>  (the real-world considerations governing this partition are subtler). Brakedown begins by writing  <span class="math">t(X_0,\\ldots,X_{\\ell-1})</span> 's list  <span class="math">(t(v))_{v\\in\\mathcal{B}_\\ell}</span>  of Lagrange coefficients into a square,  <span class="math">2^{\\ell_0}\\times 2^{\\ell_1}</span>  matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  in row-major order (we write  <span class="math">m_0 \\coloneqq 2^{\\ell_0}</span>  and  <span class="math">m_1 \\coloneqq 2^{\\ell_1}</span> ). For each evaluation point  <span class="math">(r_0,\\ldots,r_{\\ell-1}) \\in \\mathbb{F}_{2^{128}}^{\\ell}</span> , we recall the standard vector-matrix-vector identity:</p>

    <div class="my-4 text-center"><span class="math-block">t(r_0, \\dots, r_{\\ell-1}) = \\begin{bmatrix} &amp; \\bigotimes_{i=\\ell_0}^{\\ell-1} (1 - r_i, r_i) &amp; \\end{bmatrix} \\cdot \\begin{bmatrix} - &amp; t_0 &amp; - \\\\ &amp; \\vdots &amp; \\\\ - &amp; t_{m-1} &amp; - \\end{bmatrix} \\cdot \\begin{bmatrix} &amp; \\bigotimes_{i=0}^{\\ell_0-1} (1 - r_i, r_i) &amp; \\end{bmatrix}^T.</span></div>

    <p class="text-gray-300">In light of this identity, it suffices for the verifier to obtain the row-product  <span class="math">t&#x27; := \\bigotimes_{i=\\ell_0}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}</span> ; given this value, the verifier may learn its desired quantity  <span class="math">t(r_0, \\ldots, r_{\\ell-1}) = t&#x27; \\cdot \\bigotimes_{i=0}^{\\ell_0-1} (1-r_i, r_i)</span>  using just  <span class="math">O(m_0) = O\\left(\\sqrt{2^\\ell}\\right)</span>  further field operations. In Brakedown, the prover opts in fact to send the verifier t' directly (it computes t' immediately after receiving  <span class="math">(r_0, \\ldots, r_{\\ell-1})</span> ).</p>

    <p class="text-gray-300">To make this procedure secure, Brakedown must bind its prover to its matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  (that is, before it sees  <span class="math">(r_0, \\ldots, r_{\\ell-1})</span> ). To do this, Brakedown demands that its prover encode each row of  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  using a fixed, global error-correcting code. The prover finally Merkle-commits the resulting matrix, say  <span class="math">(u_i)_{i=0}^{m_0-1}</span> .</p>

    <p class="text-gray-300">Upon choosing its evaluation point  <span class="math">(r_0,\\ldots,r_{\\ell-1})</span> , sending it to the prover, and receiving t' in return, the verifier, finally, launches its  <span class="math">testing\\ phase</span> . In this phase, the verifier locally encodes t' itself, so obtaining the codeword u', say. The verifier begins selecting random codeword indices  <span class="math">j\\in\\{0,\\ldots,n-1\\}</span> , requesting in each instance the  <span class="math">j^{\\text{th}}</span>  column  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span>  of the prover's Merkle-committed matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span> . Upon obtaining each such column—itself certified by an appropriate Merkle path—the verifier checks whether it relates as it should to its local codeword u'; that is, it checks whether  <span class="math">u&#x27;_j \\stackrel{?}{=} \\bigotimes_{i=\\ell_0}^{\\ell-1} (1-r_i,r_i) \\cdot (u_{i,j})_{i=0}^{m_0-1}</span>  holds. (By the linearity of the error-correcting code,  <span class="math">u&#x27; = \\bigotimes_{i=\\ell_0}^{\\ell-1} (1-r_i,r_i) \\cdot (u_i)_{i=0}^{m_0-1}</span>  must hold if the prover is honest.) Each such check takes roughly  <span class="math">O(m_1) = O\\left(\\sqrt{2^\\ell}\\right)</span>  work for the verifier. By means of coding-theoretic analyses, [AHIV23], [Gol+23] and [DP24, § 4] show that, if the code at hand is of constant relative distance, then, provided that it manages to successfully run  <span class="math">\\Theta(\\lambda)</span>  checks of this form, the verifier may certify with confidence that  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  is interleaved-close to the code—so that  <span class="math">(t_i)_{i=0}^{m_0-1}</span> , and hence  <span class="math">t(X_0,\\ldots,X_{\\ell-1})</span>  too, is well-defined—as well as that t' is correct, so that the verifier's final result  <span class="math">t(r_0,\\ldots,r_{\\ell-1})</span>  also is. The total work for the verifier on the order of  <span class="math">O(m_0+\\lambda\\cdot m_1)=O\\left(\\lambda\\cdot\\sqrt{2^\\ell}\\right)</span> .</p>

    <p class="text-gray-300">The small-field case. We turn our attention to the small-field case; in fact, we fix a polynomial  <span class="math">t(X_0,\\ldots,X_{\\ell-1})</span>  with coefficients in  <span class="math">\\mathbb{F}_2</span> . We attempt to recapitulate, in this latter setting, the recipe sketched above. The Lagrange vector  <span class="math">(t(v))_{v\\in\\mathcal{B}_\\ell}</span>  is now a vector of mere bits. We may well write these bits, as before, into a square matrix, provided we tacitly interpret each bit as an  <span class="math">\\mathbb{F}_{2^{128}}</span> -element (here, we use the embedding  <span class="math">\\mathbb{F}_2\\subset\\mathbb{F}_{2^{128}}</span> ). If, following Brakedown's prescription, we picked a generic error-correcting code over  <span class="math">\\mathbb{F}_{2^{128}}</span> , we would impose upon our prover an extremely inefficient encoding procedure. Indeed, its messages would not be general elements of the message space  <span class="math">\\mathbb{F}_{2^{128}}^{m_1}</span> ; rather, their symbols would reside exclusively in the much-smaller subfield  <span class="math">\\mathbb{F}_2\\subset\\mathbb{F}_{2^{128}}</span> . The "information density" of these messages would be unusually low. On the other hand, the symbols of its resulting codewords would be general elements of  <span class="math">\\mathbb{F}_{2^{128}}</span> . These codewords, then, would be huge, relative to the prover's initial messages; that is, those messages would expand, upon being encoded, not just by a factor of  <span class="math">\\frac{1}{\\rho}</span> , as is typical, but moreover by a further factor of 128.</p>

    <p class="text-gray-300">One preliminary remedy would opt to choose a strictly binary code—that is, a code over the alphabet  <span class="math">\\mathbb{F}_2</span> —and to proceed otherwise as in Brakedown where possible. In Subsection 3.3 below, we show that this approach can be made to work, granting some coding-theoretic effort (see Subsection 3.1). Indeed, despite beginning with messages  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  over  <span class="math">\\mathbb{F}_2</span> , our prover—in this Brakedown variant—would obtain a row-sum t' defined rather over  <span class="math">\\mathbb{F}_{2^{128}}</span> . By which device should the verifier "encode" this latter vector, whose symbols reside in not in the code's alphabet, but in a vector space over that alphabet? We resolve this matter by means of a coding-theoretic construction we call the <em>extension code</em> (see Definition 3.1); using that construction, we record our first, preliminary small-field Brakedown variant (see Construction 3.7). We moreover establish security notions appropriate for such "small-field polynomial commitment schemes" as ours; in short, we must demand that our emulator reliably extract a polynomial defined indeed over  <span class="math">\\mathbb{F}_2</span> , as opposed to over some larger field (our security definitions are given in Subsection 3.2 below).</p>

    <p class="text-gray-300">Binary codes of constant distance and rate are inconvenient. The most well-known construction of these objects uses <em>concatenated codes</em> (see e.g. Guruswami [Gur06, § 2.3]), which require that an ad-hoc "inner code" be supplied. In Subsection 3.4 below, we explain at length our insistence on developing a construction which supports polynomials over tiny fields and uses only standard Reed–Solomon codes.</p>

    <p class="text-gray-300">Reed–Solomon codes over  <span class="math">\\mathbb{F}_2</span>  itself, of course, don't exist; those codes definitionally demand alphabets larger than or equal to their block lengths. One could, as in the straw-man solution above, pick rather a Reed–Solomon code whose alphabet was as small as circumstances allowed—say,  <span class="math">\\mathbb{F}_{2^{16}}</span> —and once again apply Brakedown otherwise unchanged. This approach, however, would again induce embedding overhead, albeit of a more moderate sort; indeed, it would entail a message-expansion factor merely 16-fold too large, as opposed to 128-fold too large.</p>

    <p class="text-gray-300">We present our main technical solution in Subsection 3.4 below (see specifically Construction 3.11). Our key idea involves a certain sort of data-casting operation, which we call packing. Given its usual binary,  <span class="math">m_0 \\times m_1</span>  matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span> —with rows each of  <span class="math">m_1 = 2^{\\ell_1}</span>  bits—our prover groups each such row's bits into 16-bit chunks. In this way, our prover may "pretend" that its matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  were rather an  <span class="math">m_0 \\times \\frac{m_1}{16}</span>  matrix over the field  <span class="math">\\mathbb{F}_{2^{16}}</span> . Our prover then proceeds as in Brakedown on this matrix, using now a Reed–Solomon code over  <span class="math">\\mathbb{F}_{2^{16}}</span> . We note that this commitment procedure again eliminates embedding overhead.</p>

    <p class="text-gray-300">To attach to this commitment procedure a meaningful evaluation protocol, we must overcome various obstacles. We must first deal—as we had to above—with the verifier's encoding of t'. Indeed, it is simply not clear how the verifier should encode t'—itself a length- <span class="math">m_1</span>  vector, with components in  <span class="math">\\mathbb{F}_{2^{128}}</span> —so as to obtain a result u' which relates meaningfully to the prover's matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span> . The perhaps-most-direct route would observe simply that our packing procedure above is nothing other than that attached to Construction 3.7's specialization to a <em>certain</em> concatenated code—namely, to that built out of a Reed–Solomon outer code and a trivial inner code. On the other hand, that latter specialization would mandate that the verifier sample random bit-columns in the codeword index space  <span class="math">\\left\\{0,\\ldots,\\frac{m_1}{\\rho}-1\\right\\}</span>  during its testing phase. Our construction, rather, encourages the verifier to query and test random size-16 blocks of columns in the shortened index space  <span class="math">\\left\\{0,\\ldots,\\frac{1}{16}\\cdot\\frac{m_1}{\\rho}-1\\right\\}</span> ; below, we call this idea <em>block-level testing</em>. Fascinatingly, our block-testing mechanism delivers smaller, sounder proofs than that based on independent bit-columns can; we explain this counterintuitive fact in Subsection 3.5 below (see also Examples 3.15 and 3.16).</p>

    <p class="text-gray-300">By introducing a new algebraic object—which we call the <em>tower algebra</em> (see Definition 3.8)—we achieve a more conceptual, albeit technically trickier, characterization of our main Brakedown variant. The tower algebra is an algebraic object whose elements are, essentially, bundles of  <span class="math">16 \\mathbb{F}_{2^{128}}</span> -elements. Its multiplicative structure, moreover, makes the prover's and verifier's row-combination and encoding steps both linear (albeit over different subfields of the algebra!). Most importantly, it captures the precisely the framework within which our security analysis might best proceed. In Theorem 3.10 below, we record the <em>proximity gap</em> at the heart of that analysis, which adapts a result of Diamond and Posen [DP24, Thm. 2].</p>

    <p class="text-gray-300">The role of towers. Our discussion thus far has proceeded with heed just to the single base field  <span class="math">\\mathbb{F}_2</span> . In applications, however, we must deal simultaneously with polynomials over multiple fields. To make these fields interoperate, we work with towers of binary fields, which we discuss at length in Subsection 2.3. Our tower-based approach allows us to view  <span class="math">\\mathbb{F}_{2^{128}}</span>  simultaneously as a vector space over each of its intermediate subfields, and to efficiently multiply elements of that field by elements of its subfields.</p>

    <p class="text-gray-300">To showcase the utility of our tower-based approach, we develop a case study. We imagine using our</p>

    <p class="text-gray-300">scheme to commit to two different multilinears, both  <span class="math">\\ell</span> -variate, defined over  <span class="math">\\mathbb{F}_{2^8}</span>  and  <span class="math">\\mathbb{F}_{2^{16}}</span> , respectively. In both commitments, we use the same matrix shape configuration  <span class="math">\\ell_0 + \\ell_1 = \\ell</span> . Those polynomials' commitment procedures will begin by reshaping their respective Lagrange coefficient vectors into matrices of shape  <span class="math">2^{\\ell_0} \\times 2^{\\ell_1}</span>  (over  <span class="math">\\mathbb{F}_{2^8}</span>  and over  <span class="math">\\mathbb{F}_{2^{16}}</span> , respectively). Finally, we imagine evaluating both committed polynomials at the single point  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\in \\mathbb{F}_{2^{128}}</span> . This situation is plausible, say after a batched sumcheck.</p>

    <p class="text-gray-300">The prover's first step, in its two evaluation protocols, will be to tensor-expand the suffix  <span class="math">(r_{\\ell_0},\\ldots,r_{\\ell-1})</span>  and to independently row-combine both of its matrices using the single tensor vector  <span class="math">\\bigotimes_{i=\\ell_0}^{\\ell-1}(1-r_i,r_i)</span> . These two row-combinations will involve  <span class="math">\\mathbb{F}_{2^{128}}\\times\\mathbb{F}_{2^8}</span>  operations and  <span class="math">\\mathbb{F}_{2^{128}}\\times\\mathbb{F}_{2^{16}}</span>  operations, respectively. In our tower-centric setting, the prover can do both of these sorts of operations efficiently, without conversions. That is, the prover can multiply elements of  <span class="math">\\mathbb{F}_{2^{128}}</span>  with elements of each of that field's subfields efficiently. The cost of each  <span class="math">\\mathbb{F}_{2^{128}}\\times\\mathbb{F}_{2^8}</span>  multiplication, in the tower setting, is exactly that of  <span class="math">\\frac{128}{8}=16</span>   <span class="math">\\mathbb{F}_{2^8}\\times\\mathbb{F}_{2^8}</span>  multiplications. The cost of each  <span class="math">\\mathbb{F}_{2^{128}}\\times\\mathbb{F}_{2^{16}}</span>  multiplication is that of  <span class="math">\\frac{128}{16}=8</span>   <span class="math">\\mathbb{F}_{2^{16}}\\times\\mathbb{F}_{2^{16}}</span>  multiplications.</p>

    <p class="text-gray-300">If we didn't use towers, then there would be no way for the prover to do both of these row-combinations efficiently (i.e. without linear-algebraic conversions). The parties could always permanently express  <span class="math">\\mathbb{F}_{2^{128}}</span>  as a direct algebraic extension of  <span class="math">\\mathbb{F}_{2^8}</span> , say. This representation would make the prover's  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^8}</span>  multiplications efficient. Unfortunately, it would make its  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^{16}}</span>  multiplications costly. To perform those, the prover would have two choices. On the one hand, it could first embed each right-hand operand along some field embedding  <span class="math">\\mathbb{F}_{2^{16}} \\hookrightarrow \\mathbb{F}_{2^{128}}</span> , before performing its multiplications rather in that latter field. This approach would face the cost of these embeddings, for one, and moreover would fail to exploit fact of its right-hand operands' membership in the proper subfield  <span class="math">\\mathbb{F}_{2^{16}} \\subset \\mathbb{F}_{2^{128}}</span> . On the other hand, it could re-express each left-hand  <span class="math">\\mathbb{F}_{2^{128}}</span> -element in coordinates with respect to an appropriate  <span class="math">\\mathbb{F}_{2^{16}}</span> -basis of  <span class="math">\\mathbb{F}_{2^{128}}</span> , perform its multiplications componentwise, and then convert the results back. The resulting multiplications would be efficient, but the conversions would be costly (quadratic in the extension degree  <span class="math">\\deg(\\mathbb{F}_{2^{128}} / \\mathbb{F}_{2^8}) = 16</span> ).</p>

    <p class="text-gray-300">A similar problem afflicts the alternative approach in which  <span class="math">\\mathbb{F}_{2^{128}}</span>  is expressed as a direct algebraic extension of  <span class="math">\\mathbb{F}_{2^{16}}</span> . In that setting,  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^{16}}</span>  multiplications would become efficient. To carry out  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^8}</span>  multiplications, on the other hand, the prover would have to first embed  <span class="math">\\mathbb{F}_{2^8} \\hookrightarrow \\mathbb{F}_{2^{16}}</span> , and then carry out the resulting  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^{16}}</span>  multiplications in the usual way. These embeddings again wouldn't be free, for one; moreover, the ensuing  <span class="math">\\mathbb{F}_{2^{128}} \\times \\mathbb{F}_{2^{16}}</span>  multiplications would fail to exploit their right-hand arguments' membership in the proper subfield  <span class="math">\\mathbb{F}_{2^8} \\subset \\mathbb{F}_{2^{16}}</span> .</p>

    <p class="text-gray-300">Multiplying an element of  <span class="math">\\mathbb{F}_{2^{128}}</span>  with an element of one of its subfields is efficient when  <span class="math">\\mathbb{F}_{2^{128}}</span>  is expressed as an explicit algebraic extension of that subfield. The only way to ensure this state of affairs simultaneously for all subfields of  <span class="math">\\mathbb{F}_{2^{128}}</span>  is to use towers. In fact, this is more-or-less the definition of a tower.</p>

    <p class="text-gray-300">In practice, we use a particular tower construction, developed mathematically by Wiedemann [Wie88] and algorithmically by Fan and Paar [FP97]. That construction is even more efficient than general towers are; we discuss it in Subsection 2.3.</p>

    <p class="text-gray-300">Beyond the PCS. In Section 4, we build a toolkit for multilinear polynomials in the binary setting. In Subsection 4.1, we define <em>virtual polynomials</em>, a crucial notion. A virtual polynomial is a polynomial assembled from raw, committed polynomials, which the verifier—given access to these underlying polynomials—can evaluate efficiently. While an important special case of this notion—namely, that of <em>composition</em> (see Example 4.9)—is implicit in prior work, our variant allows even virtual polynomials whose evaluation procedures are interactive (say, involving a sumcheck). This latter sort of flexibility proves essential in our Subsection 4.3, where we define various new virtual polynomials. These serve to <em>pack</em> and <em>shift</em> raw, committed polynomials. In fact, our shifting construction—itself a virtual polynomial of our more general variety—answers an open problem posed by HyperPlonk (see Remark 4.26). In Subsection 4.4, we develop a lookup argument, adapting Setty, Thaler and Wahby's <em>Lasso</em> [STW24] to the binary setting.</p>

    <p class="text-gray-300">In Section 5, we put the pieces together, assembling a full SNARK for binary towers. We first describe a top-level IOP for our binary <em>PLONKish</em> variant (see Protocol 5.1). In Subsection 5.3, we describe various <em>gadgets</em>, designed to achieve unsigned integer arithmetic operations. Our addition gadget (see Protocol 5.3) effects a ripple-carry adder, using our shift construction internally. Our multiplication gadget (see Protocol 5.5) is still more complicated; it emulates the schoolbook algorithm on its arguments, using our lookup protocol to effect its limb-by-limb products and our addition gadget to accumulate its internal rows. Our gadgets stand to address the concerns of those who—citing the difficulty of unsigned integer arithmetic—have historically deemed implausible the prospect of concretely efficient, binary-field-based SNARKs.</p>

    <p class="text-gray-300"><strong>Performance and benchmarks.</strong> In Section 6, we benchmark an end-to-end, Rust implementation of our protocol. Our benchmarks demonstrate that our protocol performs competitively against the state-of-the-art <em>Plonky3</em> and <em>Hyrax</em> polynomial commitment schemes, especially on polynomials over tiny fields. We moreover benchmark our scheme's performance on our binary-native arithmetization of the Keccak-f permutation (itself given in Subsection 5.4). On a benchmark task in which 8,192 independent Keccak-f permutations are proved valid, our scheme outperforms Plonky3 by roughly twofold in the singlethreaded setting and fourfold in the multithreaded setting (see Tables 5 and 6 below).</p>

    <p class="text-gray-300">Acknowledgements. This work would not have been possible without the support of our colleagues at Irreducible. Their perspectives and insights regarding computational efficiency, as well as the thorough hardware prototypes they built, guided our investigation. We would like to gratefully acknowledge the contributions of Justin Thaler to this work, which arose throughout the course of many fruitful discussions. We would finally like to thank Eli Ben-Sasson for answering several questions pertaining to zk-STARKs over binary fields.</p>

    <h2 id="sec-7" class="text-2xl font-bold">2 Background and Notation</h2>

    <p class="text-gray-300">We write  <span class="math">\\mathbb{N}</span>  for the set of nonnegative integers. For sets A and B, we write  <span class="math">B^A</span>  for the set of maps  <span class="math">A \\to B</span> . Below, we consider only finite fields. We fix an arbitrary finite field K (we focus on the case in which K is of characteristic 2). For each  <span class="math">\\ell \\in \\mathbb{N}</span> , we write  <span class="math">\\mathcal{B}_{\\ell}</span>  for the  <span class="math">\\ell</span> -dimensional boolean hypercube  <span class="math">\\{0,1\\}^{\\ell} \\subset K^{\\ell}</span> . We occasionally identify  <span class="math">\\mathcal{B}_{\\ell}</span>  with the integer range  <span class="math">\\{0,\\ldots 2^{\\ell}-1\\}</span>  lexicographically. That is, we identify each  <span class="math">v=(v_0,\\ldots,v_{\\ell-1})</span>  in  <span class="math">\\mathcal{B}_{\\ell}</span>  with the integer  <span class="math">\\sum_{i=0}^{\\ell-1} 2^i \\cdot v_i</span> ; we moreover write  <span class="math">\\{v\\}</span>  for this latter integer.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">2.1 Polynomials</h3>

    <p class="text-gray-300">We recall certain basic facts pertaining to multivariate polynomials, referring throughout to Thaler [Tha22, § 3.5]. We recall the ring  <span class="math">K[X_0,\\ldots,X_{\\ell-1}]</span>  of  <span class="math">\\ell</span> -variate polynomials over K. We write  <span class="math">K[X_0,\\ldots,X_{\\ell-1}]^{\\preceq d}</span>  for the set of  <span class="math">\\ell</span> -variate polynomials over K of individual degree at most d in each variable. Multilinear polynomials are multivariate polynomials of individual degree at most 1 in each variable (see [Tha22, Def. 3.4]); the set of all such polynomials is  <span class="math">K[X_0,\\ldots,X_{\\ell-1}]^{\\preceq 1}</span> . A degree-d multivariate extension of a map  <span class="math">t\\in K^{\\mathcal{B}_\\ell}</span>  is a polynomial  <span class="math">\\hat{t}\\in K[X_0,\\ldots,X_{\\ell-1}]^{\\preceq d}</span>  for which  <span class="math">\\hat{t}(x)=t(x)</span>  holds for each  <span class="math">x\\in \\mathcal{B}_\\ell</span> .</p>

    <p class="text-gray-300">Each map  <span class="math">t \\in K^{\\mathcal{B}_{\\ell}}</span>  admits a unique degree-1 multivariate extension  <span class="math">\\hat{t} \\in K[X_0, \\dots, X_{\\ell-1}]^{\\leq 1}</span>  (see [Tha22, Fact 3.5]). We thus refer freely to the degree-1 multivariate extension of t; we write  <span class="math">\\tilde{t}</span>  for this polynomial and call it t's multilinear extension (MLE). We recall the equality indicator function  <span class="math">eq : \\mathcal{B}_{\\ell} \\times \\mathcal{B}_{\\ell} \\to K</span> , which sends  <span class="math">(x, y) \\mapsto x \\stackrel{?}{=} y</span> , as well as its MLE, the equality indicator polynomial (see [Tha22, Lem. 3.6]):</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\operatorname{eq}}(X_0, \\dots, X_{\\ell-1}, Y_0, \\dots, Y_{\\ell-1}) = \\prod_{i=0}^{\\ell-1} (1-X_i) \\cdot (1-Y_i) + X_i \\cdot Y_i.</span></div>

    <p class="text-gray-300">For each  <span class="math">t \\in K^{\\mathcal{B}_{\\ell}}</span> , we have the following explicit representation of t's multilinear extension  <span class="math">\\widetilde{t} \\in K[X_0, \\dots, X_{\\ell-1}]^{\\leq 1}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{t}(X_0,\\dots,X_{\\ell-1}) = \\sum_{v \\in \\mathcal{B}_\\ell} t(v) \\cdot \\widetilde{\\operatorname{eq}}(X_0,\\dots,X_{\\ell-1},v_0,\\dots,v_{\\ell-1}).</span></div>

    <p class="text-gray-300">The proof that  <span class="math">\\widetilde{t}</span>  is t's multilinear extension is straightforward (see [Tha22, Lem. 3.6], for example). For each fixed  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\in K^{\\ell}</span> , the vector  <span class="math">(\\widetilde{eq}(r_0, \\ldots, r_{\\ell-1}, v_0, \\ldots, v_{\\ell-1}))_{v \\in \\mathcal{B}_{\\ell}}</span>  takes the form</p>

    <div class="my-4 text-center"><span class="math-block">\\left(\\prod_{i=0}^{\\ell-1} r_i \\cdot v_i + (1-r_i) \\cdot (1-v_i)\\right)_{v \\in \\mathcal{B}_{\\ell}} = ((1-r_0) \\cdot \\dots \\cdot (1-r_{\\ell-1}), \\dots, r_0 \\cdot \\dots \\cdot r_{\\ell-1}).</span></div>

    <p class="text-gray-300">We call this vector the tensor product expansion of the point  <span class="math">(r_0,\\ldots,r_{\\ell-1})\\in K^\\ell</span> , and denote it by  <span class="math">\\bigotimes_{i=0}^{\\ell-1}(1-r_i,r_i)</span> . We note the recursive description  <span class="math">\\bigotimes_{i=0}^{\\ell-1}(1-r_i,r_i)=(1-r_0)\\cdot\\bigotimes_{i=1}^{\\ell-1}(1-r_i,r_i)\\parallel r_0\\cdot\\bigotimes_{i=1}^{\\ell-1}(1-r_i,r_i)</span> . This description yields a  <span class="math">\\Theta(2^\\ell)</span> -time algorithm which computes  <span class="math">\\bigotimes_{i=0}^{\\ell-1}(1-r_i,r_i)</span>  (see e.g. [Tha22, Lem. 3.8]).</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">2.2 Error-Correcting Codes</h4>

    <p class="text-gray-300">We adapt the notation of Diamond and Posen [DP24, § 2]. A code of block length n over the alphabet  <span class="math">\\Sigma</span>  is a subset of  <span class="math">\\Sigma^n</span> . In  <span class="math">\\Sigma^n</span> , we write d for the Hamming distance between two vectors (i.e., the number of components at which they differ). We again fix a field K. A linear [n, k, d]-code over K is a k-dimensional linear subspace  <span class="math">C \\subset K^n</span>  for which  <span class="math">d(v_0, v_1) \\geq d</span>  holds for each pair of unequal elements  <span class="math">v_0</span>  and  <span class="math">v_1</span>  of C.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Given a linear code  <span class="math">C \\subset K^n</span>  and an integer  <span class="math">m \\geq 1</span> , we have C's m-fold interleaved code, defined as the subset  <span class="math">C^m \\subset (K^n)^m \\cong (K^m)^n</span> . We understand this latter set as a length-n block code over the alphabet  <span class="math">K^m</span> . In particular, its elements are naturally identified with those matrices in  <span class="math">K^{m \\times n}</span>  each of whose rows is a C-element. We write matrices  <span class="math">(u_i)_{i=0}^{m-1} \\in K^{m \\times n}</span>  row-wise. By definition of  <span class="math">C^m</span> , two matrices in  <span class="math">K^{m \\times n}</span>  differ at a column if they differ at any of that column's components. That a matrix  <span class="math">(u_i)_{i=0}^{m-1} \\in K^{m \\times n}</span>  is within distance e to the code  <span class="math">C^m</span> —in which event we write  <span class="math">d^m \\left( (u_i)_{i=0}^{m-1}, C^m \\right) \\leq e</span> —thus entails precisely that there exists a subset  <span class="math">D := \\Delta^m \\left( (u_i)_{i=0}^{m-1}, C^m \\right)</span> , say, of  <span class="math">\\{0, \\dots, n-1\\}</span> , of size at most e, for which, for each  <span class="math">i \\in \\{0, \\dots, m-1\\}</span> , the row  <span class="math">u_i</span>  admits a codeword  <span class="math">v_i \\in C</span>  for which  $u_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{0,\\dots,n-1\\}\\setminus D} = v_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\{0,\\dots,n-1\\}\\setminus D}<span class="math"> . We emphasize that the subset  </span>D \\subset \\{0,\\dots,n-1\\}<span class="math">  is fixed, and does not vary as the row-index  </span>i \\in \\{0,\\dots,m-1\\}<span class="math">  varies. In this circumstance, following the terminology of [Ben+23], we say that the vectors  </span>(u_i)_{i=0}^{m-1}<span class="math">  feature correlated agreement outside of the set D, or that they feature e-correlated agreement. We note that the condition whereby the vectors  </span>(u_i)_{i=0}^{m-1}<span class="math">  feature e-correlated agreement with  </span>C^m<span class="math">  implies a fortiori that every element in  </span>(u_i)_{i=0}^{m-1}$ 's row-span is itself within distance at most e from C.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We recall Reed–Solomon codes. For each subset  <span class="math">S = \\{s_0, \\ldots, s_{n-1}\\}</span>  of K and message length  <span class="math">k \\leq n</span> , the Reed–Solomon code  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span>  is defined as  <span class="math">\\mathsf{RS}_{K,S}[n,k] = \\{(p(s_0),\\ldots,p(s_{n-1})) \\mid p(X) \\in K[X]^{\\leq k}\\}</span> . In words,  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span>  is the set of n-tuples which arise as the evaluations, over the n points of S, of some polynomial  <span class="math">p(X) \\in K[X]</span>  of degree less than k. Here, we identify  <span class="math">K[X]^{\\leq k}</span>  with  <span class="math">K^k</span>  using the monomial K-basis  <span class="math">1,X,\\ldots,X^{k-1}</span>  of  <span class="math">K[X]^{\\leq k}</span> . The code  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span>  is of distance d=n-k+1 (see e.g. Guruswami [Gur06, Def. 2.3]). Lin, Chung, and Han show in recent work [LCH14] that, for K a binary field, and  <span class="math">S \\subset K</span>  an appropriately chosen  <span class="math">\\mathbb{F}_2</span> -affine linear subspace, the encoding function of  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span> —or at least of a code isomorphic to it—can be computed in  <span class="math">\\Theta(n \\cdot \\log k)</span>  time. (The code  <span class="math">C \\subset K^n</span>  of [LCH14] differs from  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span>  by precomposition with a K-isomorphism on  <span class="math">K^k</span> , and so inherits  <span class="math">\\mathsf{RS}_{K,S}[n,k]</span> 's properties in full.)</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">2.3 Binary Towers</h4>

    <p class="text-gray-300">We review towers of field extensions. The following explicit construction is due to Wiedemann [Wie88], and appears also in Cohen [Coh92] and Fan and Paar [FP97], for example; we refer to Blake et al. [Bla+93, § 3.4] for further historical remarks. We define a sequence of rings inductively, by setting  <span class="math">\\mathcal{T}_0 := \\mathbb{F}_2</span> ,  <span class="math">\\mathcal{T}_1 := \\mathbb{F}_2[X_0] / (X_0^2 + X_0 + 1)</span> , and, for each  <span class="math">\\iota &gt; 1</span> ,  <span class="math">\\mathcal{T}_\\iota := \\mathcal{T}_{\\iota-1}[X_{\\iota-1}] / (X_{\\iota-1}^2 + X_{\\iota-2} \\cdot X_{\\iota-1} + 1)</span> . It is shown in [Wie88, Thm. 1] that, for each  <span class="math">\\iota &gt; 1</span> , the polynomial  <span class="math">X_{\\iota-1}^2 + X_{\\iota-2} \\cdot X_{\\iota-1} + 1</span>  is irreducible in  <span class="math">\\mathcal{T}_{\\iota-1}[X_{\\iota-1}]</span> . We conclude by induction that, for each  <span class="math">\\iota \\geq 0</span> , the ring  <span class="math">\\mathcal{T}_\\iota</span>  is a field, isomorphic to  <span class="math">\\mathbb{F}_{2^2}</span> .</p>

    <p class="text-gray-300">For each  <span class="math">\\iota &gt; 0</span> ,  <span class="math">\\mathcal{T}_{\\iota-1}</span>  arises naturally as the subfield of  <span class="math">\\mathcal{T}_{\\iota}</span>  consisting of (the equivalence classes of) constant polynomials. Applying induction, we obtain a tower construction  <span class="math">\\mathcal{T}_0 \\subset \\mathcal{T}_1 \\subset \\cdots \\subset \\mathcal{T}_{\\iota}</span> . Moreover, for each  <span class="math">\\iota \\geq 0</span> , we have a straightforward identification of rings:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal{T}_{\\iota} = \\mathbb{F}_2[X_0, \\dots, X_{\\iota-1}] / (X_0^2 + X_0 + 1, \\dots, X_{\\iota-1}^2 + X_{\\iota-2} \\cdot X_{\\iota-1} + 1).</span></div>

    <p class="text-gray-300">This identification respects the tower structure in the obvious way; indeed,  <span class="math">\\mathcal{T}_{\\iota-1} \\subset \\mathcal{T}_{\\iota}</span>  is precisely the subring consisting of the equivalence classes of those polynomials in which only the variables  <span class="math">X_0, \\ldots, X_{\\iota-2}</span>  appear.</p>

    <p class="text-gray-300">It holds—say, by Gröbner basis considerations—that, for each  <span class="math">\\iota \\geq 0</span> , each equivalence class in  <span class="math">\\mathcal{T}_{\\iota}</span>  has a unique multilinear representative. We conclude that the set of monomials  <span class="math">1, X_0, X_1, X_0 \\cdot X_1, \\ldots, X_0 \\cdot \\cdots \\cdot X_{\\iota-1}</span>  gives a basis of  <span class="math">\\mathcal{T}_{\\iota}</span>  as an  <span class="math">\\mathbb{F}_2</span> -vector space; we call this basis the multilinear basis. For each  <span class="math">u \\in \\mathcal{B}_{\\iota}</span> , with boolean components  <span class="math">(u_0, \\ldots, u_{\\iota-1})</span> , say, we write  <span class="math">\\beta_u := \\prod_{i=0}^{\\iota-1} ((1-u_i) + u_i \\cdot X_i)</span> ; that is,  <span class="math">\\beta_u</span>  is that basis vector corresponding to the product of precisely those indeterminates among the list  <span class="math">X_0, \\ldots, X_{\\iota-1}</span>  indexed by u's components. More generally, for each pair of integers  <span class="math">\\iota \\geq 0</span>  and  <span class="math">\\kappa \\geq 0</span> , the set  <span class="math">1, X_{\\iota}, X_{\\iota+1}, X_{\\iota} \\cdot X_{\\iota+1}, \\ldots, X_{\\iota} \\cdot \\cdots \\cdot X_{\\iota+\\kappa-1}</span>  gives a  <span class="math">\\mathcal{T}_{\\iota}</span> -basis of  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> ; we again write  <span class="math">(\\beta_u)_{u \\in \\mathcal{B}_{\\kappa}}</span>  for this basis. That is, for each  <span class="math">u \\in \\mathcal{B}_{\\kappa}</span> , we write  <span class="math">\\beta_u := \\prod_{i=0}^{\\kappa-1} ((1-u_i) + u_i \\cdot X_{\\iota+i})</span> .</p>

    <p class="text-gray-300">We briefly survey the efficiency of tower-field arithmetic. In practice, we represent all  <span class="math">\\mathcal{T}_{\\iota}</span> -elements in coordinates with respect to the multilinear  <span class="math">\\mathbb{F}_2</span> -basis, which we moreover sort in lexicographic order. In particular, each  <span class="math">\\mathcal{T}_{\\iota}</span> -element  <span class="math">\\alpha</span>  admits a length-2 <span class="math">^{\\iota}</span>  coordinate vector  <span class="math">(a_0, \\ldots, a_{2^{\\iota}-1})</span> , with components in  <span class="math">\\mathbb{F}_2</span> ; we note, in light of our lexicographic basis-ordering, that this vector's 0<sup>th</sup> and 1<sup>st</sup> halves respectively define  <span class="math">\\mathcal{T}_{\\iota-1}</span> -elements  <span class="math">\\alpha_0</span>  and  <span class="math">\\alpha_1</span>  for which  <span class="math">\\alpha = \\alpha_1 \\cdot X_{\\iota-1} + \\alpha_0</span>  in fact holds.</p>

    <p class="text-gray-300">Throughout, addition amounts to bitwise XOR. We multiply  <span class="math">\\mathcal{T}_{\\iota}</span> -elements in the following way. To multiply the elements  <span class="math">\\alpha_1 \\cdot X_{\\iota-1} + \\alpha_0</span>  and  <span class="math">\\alpha&#x27;_1 \\cdot X_{\\iota-1} + \\alpha&#x27;_0</span>  of  <span class="math">\\mathcal{T}_{\\iota}</span> , say, we first use the Karatsuba technique—that is, we use three recursive multiplications in  <span class="math">\\mathcal{T}_{\\iota-1}</span> —to obtain the expression  <span class="math">\\alpha_1 \\cdot \\alpha&#x27;_1 \\cdot X^2_{\\iota-1} + (\\alpha_0 \\cdot \\alpha&#x27;_1 + \\alpha_1 \\cdot \\alpha&#x27;_0) \\cdot X_{\\iota-1} + \\alpha_0 \\cdot \\alpha&#x27;_0</span> . We then reduce this latter polynomial by subtracting  <span class="math">\\alpha_1 \\cdot \\alpha&#x27;_1 \\cdot \\left(X^2_{\\iota-1} + X_{\\iota-2} \\cdot X_{\\iota-1} + 1\\right)</span>  from it; this step itself entails computing the product  <span class="math">\\alpha_1 \\cdot \\alpha&#x27;_1 \\cdot X_{\\iota-2}</span>  in  <span class="math">\\mathcal{T}_{\\iota-1}</span> .</p>

    <p class="text-gray-300">Fan and Paar [FP97, § III] show that, in the Wiedemann tower, each such "constant multiplication"—that is, each multiplication of a  <span class="math">\\mathcal{T}_{\\iota}</span> -element by the constant  <span class="math">X_{\\iota-1}</span> —can be carried out in linear time  <span class="math">\\Theta(2^{\\iota})</span> . In light of this fact, and using the "master theorem" for recurrence relations (see e.g. Cormen, Leiserson, Rivest, and Stein [CLRS22, Thm. 4.1]), we conclude that this recursive, Karatsuba-based approach features complexity  <span class="math">\\Theta(2^{\\log(3) \\cdot \\iota})</span>  (we refer also to [FP97, § IV] for a thorough analysis).</p>

    <p class="text-gray-300">We finally record a further key property, whereby field-elements may be multiplied by subfield-elements especially efficiently. In slightly more detail, the complexity of multiplying a  <span class="math">\\mathcal{T}_{\\iota}</span> -element by a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element grows just linearly in the extension degree of  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span>  over  <span class="math">\\mathcal{T}_{\\iota}</span> . We express this precisely as follows. For each element  <span class="math">\\alpha \\in \\mathcal{T}_{\\iota+\\kappa}</span> , with coordinate representation  <span class="math">(a_u)_{u \\in \\mathcal{B}_{\\kappa}}</span>  with respect to the multilinear  <span class="math">\\mathcal{T}_{\\iota}</span> -basis of  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , say, and each scalar  <span class="math">b \\in \\mathcal{T}_{\\iota}</span> , the representation of  <span class="math">b \\cdot \\alpha</span>  with respect to this basis is  <span class="math">(b \\cdot a_u)_{u \\in \\mathcal{B}_{\\kappa}}</span> . We conclude that the multiplication of a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element by a  <span class="math">\\mathcal{T}_{\\iota}</span> -element can be carried out in  <span class="math">2^{\\kappa} \\cdot \\Theta(2^{\\log(3) \\cdot \\iota})</span>  time. This property—whereby elements of differently-sized fields can be efficiently multiplied—has been noted by previous authors; we refer for example to Bernstein and Chou [BC14, § 2.4].</p>

    <p class="text-gray-300">Comparison with classical binary fields. We contrast this work's tower-based approach with the classical, univariate treatment of binary fields. Informally, towers feature both efficient embeddings and efficient small-by-large multiplications; classical binary fields lack both of these properties. We record the details. For  <span class="math">f_{\\iota}(X) \\in \\mathbb{F}_2[X]</span>  irreducible of degree  <span class="math">2^{\\iota}</span> , the quotient ring  <span class="math">\\mathbb{F}_2[X] / (f_{\\iota}(X))</span>  is isomorphic to  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span> , and admits the  <span class="math">\\mathbb{F}_2</span> -basis  <span class="math">1, X, \\ldots, X^{2^{\\iota}-1}</span> , which we call the (univariate) monomial basis. We again fix  <span class="math">\\iota</span>  and  <span class="math">\\kappa</span>  in  <span class="math">\\mathbb{N}</span> . Clearly, there exists an embedding  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}} \\hookrightarrow \\mathbb{F}_{2^{2^{\\iota+\\kappa}}}</span>  of abstract fields (in fact, we have  <span class="math">2^{\\iota}</span>  choices, by Galois-theoretic considerations). Identifying these objects with  <span class="math">\\mathbb{F}_2^{2^{\\iota}}</span>  and  <span class="math">\\mathbb{F}_2^{2^{\\iota+\\kappa}}</span> , respectively—by means of their monomial bases—we obtain a mapping  <span class="math">\\mathbb{F}_2^{2^{\\iota}} \\hookrightarrow \\mathbb{F}_2^{2^{\\iota+\\kappa}}</span>  of  <span class="math">\\mathbb{F}_2</span> -vector spaces. What is the bit-complexity of this mapping? When  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span>  and  <span class="math">\\mathbb{F}_{2^{2^{\\iota+\\kappa}}}</span>  are constructed as univariate quotients, the answer is complicated. (Informally, given  <span class="math">a_0 + \\cdots + a_{2^{\\iota}-1} \\cdot X^{2^{\\iota}-1}</span> , how do we determine the coefficients of its image in  <span class="math">\\mathbb{F}_{2^{2^{\\iota+\\kappa}}}</span> ?) Obviously, in view of the complexity of binary matrix multiplication, we cannot do worse than  <span class="math">O(2^{2^{\\iota+\\kappa}})</span>  bit-operations. Given irreducible polynomials  <span class="math">f_{\\iota}(X)</span>  and  <span class="math">f_{\\iota+\\kappa}(X)</span>  sufficiently carefully chosen, one may be able to do better; we refer to Bosma, Cannon and Steel [BCS97] for a thorough treatment of this issue.</p>

    <p class="text-gray-300">In our tower setting, the embedding  <span class="math">\\mathcal{T}_{\\iota} \\hookrightarrow \\mathcal{T}_{\\iota+\\kappa}</span>  of fields again induces—via these fields' respective multilinear bases—a mapping  <span class="math">\\mathbb{F}_2^{2^{\\iota}} \\hookrightarrow \\mathbb{F}_2^{2^{\\iota+\\kappa}}</span>  of  <span class="math">\\mathbb{F}_2</span> -vector spaces. This latter mapping, on the other hand, is free! Indeed, it amounts to a trivial zero-padding operation.</p>

    <p class="text-gray-300">A similar issue affects the multiplication of  <span class="math">\\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span> -elements by  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span> -elements. Indeed, to multiply an element  <span class="math">\\alpha \\in \\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span>  by  <span class="math">b \\in \\mathbb{F}_{2^{2^{\\iota}}}</span> , say (and in fact, even to give sense to this operation), we could fix a particular embedding  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}} \\hookrightarrow \\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span> , and multiply  <span class="math">\\alpha</span>  by b's image under this embedding. The cost of this operation, however, would be—beyond that of embedding b—the same as that of a standard  <span class="math">\\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span> -multiplication; in other words, it would fail to exploit the fact that b belongs to the proper subfield  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}} \\subset \\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span> . Alternatively, we could pick an arbitrary  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span> -basis of  <span class="math">\\mathbb{F}_{2^{2^{\\iota}+\\kappa}}</span> , express  <span class="math">\\alpha=(a_0,\\ldots,a_{2^{\\kappa}-1})</span>  in coordinates with respect to this basis, multiply  <span class="math">\\alpha</span>  by b componentwise, and finally convert the result back, let's say. This approach, however, would require two conversion operations, which could each cost as many as  <span class="math">\\Omega(2^{2^{\\iota\\kappa}})</span>  (i.e., quadratically many)  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span> -operations in the worst case. In fact, our tower approach, arguably, begins with precisely the insight whereby, by representing  <span class="math">\\mathbb{F}_{2^{2^{\\iota+\\kappa}}}</span> -elements continually in coordinates with respect to some  <span class="math">\\mathbb{F}_{2^{2^{\\iota}}}</span> -basis, we might avoid these conversions.</p>

    <p class="text-gray-300">A family of bases at multiple scales. To illustrate this point, we fix quantities  <span class="math">\\iota</span>  and  <span class="math">\\kappa</span>  as above, as well as an element  <span class="math">\\alpha \\in \\mathcal{T}_{\\iota+\\kappa}</span> . Of course,  <span class="math">\\alpha = (a_0, \\ldots, a_{2^{\\kappa}-1})</span>  admits some representation with respect to the multilinear  <span class="math">\\mathcal{T}_{\\iota}</span> -basis of  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> ; on the other hand, both  <span class="math">\\mathcal{T}_{\\iota}</span>  and  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span>  have their own respective multilinear  <span class="math">\\mathbb{F}_2</span> -bases, so that both  <span class="math">\\alpha</span>  and its components  <span class="math">(a_0, \\ldots, a_{2^{\\kappa}-1})</span>  in  <span class="math">\\mathcal{T}_{\\iota}</span>  have corresponding representations as  <span class="math">2^{\\iota+\\kappa}</span> -bit and  <span class="math">2^{\\iota}</span> -bit strings (respectively). We phrase the key compatibility property at hand as follows. Indeed, the respective  <span class="math">\\mathbb{F}_2</span> -basis representations of  <span class="math">\\alpha</span>  itself and of its components  <span class="math">(a_0, \\ldots, a_{2^{\\kappa}-1})</span>  are related by concatenation, so that the equality  <span class="math">\\alpha = a_0 \\parallel \\cdots \\parallel a_{2^{\\kappa}-1}</span>  of  <span class="math">2^{\\iota+\\kappa}</span> -bit strings holds (here, we interpret each symbol as a string of bits, using in each case the appropriate multilinear  <span class="math">\\mathbb{F}_2</span> -basis). In other words, we may express each given  <span class="math">\\alpha \\in \\mathcal{T}_{\\iota+\\kappa}</span> —given by its  <span class="math">\\mathbb{F}_2</span> -coordinates—in coordinates with respect to  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> 's multilinear  <span class="math">\\mathcal{T}_{\\iota}</span> -basis simply by splitting its coordinate representation into  <span class="math">2^{\\iota}</span> -bit substrings.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3 Small-Field Polynomial Commitments</h3>

    <p class="text-gray-300">In this section, we introduce <em>small-field polynomial commitment schemes</em>, and moreover supply several instantiations based on binary tower fields. In Subsection 3.2 below, we define the basic cryptographic abstraction. We then instantiate this abstraction in two different ways. In Subsection 3.3 below, we outline a simple instantiation, suitable for polynomials whose coefficient field coincides with the alphabet of an available code. In Subsection 3.4 below, we introduce a further variant, designed to support the commitment of polynomials over fields even smaller than the alphabet of the code selected for use. Both schemes follow the Brakedown-inspired scheme of Diamond and Posen [DP24, § 4], with appropriate adaptations.</p>

    <h3 id="sec-12" class="text-xl font-semibold mt-8">3.1 The Extension Code</h3>

    <p class="text-gray-300">Before proceeding, we pause to record a certain key coding-theoretic construction, which figures prominently in what follows. Informally, given some fixed code, with symbols in a field, our construction "lifts" the code to one with symbols in a vector space over that field. The resulting object inherits many of the same properties—most essentially, the distance—of the original code.</p>

    <p class="text-gray-300"><span id="page-11-1"></span><strong>Definition 3.1.</strong> We fix an [n, k, d]-code  <span class="math">C \\subset K^n</span> , with generator matrix  <span class="math">M \\in K^{n \\times k}</span> , say, and a K-vector space V over K. The extension code  <span class="math">\\widehat{C} \\subset V^n</span>  of C is the image of the map  <span class="math">V^k \\to V^n</span>  which sends  <span class="math">t \\mapsto M \\cdot t</span> .</p>

    <p class="text-gray-300">In other words, the code  <span class="math">\\widehat{C} \\subset V^n</span>  simply reuses C's generator matrix; we note that the action of a K-matrix on a V-vector is well-defined.</p>

    <p class="text-gray-300">The object  <span class="math">\\widehat{C} \\subset V^n</span>  isn't, strictly speaking, a linear code; indeed, its symbols take values in V, which is not in general a field. On the other hand,  <span class="math">\\widehat{C}</span>  inherits C's distance, as the following theorem shows:</p>

    <p class="text-gray-300"><span id="page-11-2"></span><strong>Theorem 3.2.</strong> The extension code  <span class="math">\\widehat{C} \\subset V^n</span>  has distance d.</p>

    <p class="text-gray-300">Proof. We write  <span class="math">\\eta</span>  for the dimension of V over K, and fix a K-basis  <span class="math">(\\alpha_0, \\ldots, \\alpha_{\\eta-1})</span>  of V, as well as two unequal messages  <span class="math">t_0</span>  and  <span class="math">t_1</span>  in  <span class="math">V^k</span> . Expressing these messages' components in coordinates with respect to this basis, we obtain corresponding vectors  <span class="math">t_{0,h}</span>  and  <span class="math">t_{1,h}</span> , in  <span class="math">K^k</span> , for each index  <span class="math">h \\in \\{0, \\ldots, \\eta - 1\\}</span> . Our hypothesis  <span class="math">t_0 \\neq t_1</span>  implies that, for at least one index  <span class="math">h^<em> \\in \\{0, \\ldots, \\eta - 1\\}</span> , the slices  <span class="math">t_{0,h^</em>}</span>  and  <span class="math">t_{1,h^<em>}</span>  are unequal as elements of  <span class="math">K^k</span> . Since  <span class="math">\\widehat{C}</span> 's generator matrix consists of K-elements, the encodings  <span class="math">u_0 \\coloneqq \\mathsf{Enc}(t_0)</span>  and  <span class="math">u_1 \\coloneqq \\mathsf{Enc}(t_1)</span>  of  <span class="math">t_0</span>  and  <span class="math">t_1</span>  are themselves given, slice-wise, by the respective encodings of the slices  <span class="math">(t_{0,h})_{h=0}^{\\eta-1}</span>  and  <span class="math">(t_{1,h})_{h=0}^{\\eta-1}</span> . We conclude that the slices  <span class="math">u_{0,h^</em>}</span>  and  <span class="math">u_{1,h^*}</span> , viewed as elements of  <span class="math">K^n</span> , differ at at least d positions, and thus finally that the elements  <span class="math">u_0</span>  and  <span class="math">u_1</span>  of  <span class="math">V^n</span>  also do. We see that the distance of  <span class="math">\\widehat{C}</span>  is at least d. Conversely, we may easily construct unequal codewords in  <span class="math">V^n</span>  of distance exactly d. Indeed, given unequal messages  <span class="math">t_0</span>  and  <span class="math">t_1</span>  in  <span class="math">K^k</span>  whose encodings differ at exactly d positions, we embed both  <span class="math">t_0</span>  and  <span class="math">t_1</span>  componentwise into V along the basis vector  <span class="math">\\alpha_0</span> . We see that the resulting messages' encodings  <span class="math">u_0</span>  and  <span class="math">u_1</span>  in  <span class="math">V^n</span>  differ at exactly d positions; indeed, their discrepancies all arise from their respective  <span class="math">0^{\\text{th}}</span> -indexed slices, since these codewords' positive-indexed slices are all identically zero. This completes the proof.</p>

    <p class="text-gray-300">As V isn't necessarily itself a field,  <span class="math">\\widehat{C}</span> 's "dimension" over V is of course not well-defined in general; we note, however, that  <span class="math">\\widehat{C} \\subset V^n</span>  is a V-linear [n,k,d]-code whenever V / K is a degree- <span class="math">\\eta</span>  field extension.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">3.2 Definition of Small-Field Polynomial Commitment Schemes</h4>

    <p class="text-gray-300">We now define small-field polynomial commitment schemes, adapting the definitions [DP24, Defs. 1–3], which themselves closely follow Setty [Set20, § 2.4]. Our adaptation demands that each multilinear polynomial  <span class="math">t(X_0, \\ldots, X_{\\ell-1})</span>  at hand reside in  <span class="math">K[X_0, \\ldots, X_{\\ell-1}]</span> , for a user-specified field K, allowed to be arbitrarily small. On the other hand, we allow each evaluation query point  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\in L^{\\ell}</span> , as well as each claimed evaluation result  <span class="math">s \\in L</span> , to be defined over an extension L / K of K. Thus, in short, Definition 3.3 below yields a commitment scheme for polynomials over small fields, which can nonetheless be queried at points over large extension fields of the polynomial's field of definition.</p>

    <p class="text-gray-300"><span id="page-12-0"></span><strong>Definition 3.3.</strong> A small-field multilinear polynomial commitment scheme is a tuple of algorithms  <span class="math">\\Pi = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Prove}, \\mathsf{Verify})</span> , with the following syntax:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>params  <span class="math">\\leftarrow \\Pi.\\mathsf{Setup}(1^\\lambda, \\ell, K)</span> . On input the security parameter  <span class="math">\\lambda</span> , a size parameter  <span class="math">\\ell</span> , and a field K,  <span class="math">\\Pi.\\mathsf{Setup}</span>  samples params, which includes (possibly among other things) a field extension L / K.</li>

      <li><span class="math">(c,u) \\leftarrow \\Pi.\\mathsf{Commit}(\\mathsf{params},t)</span> . On input a multilinear polynomial  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in K[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span> ,  <span class="math">\\Pi.\\mathsf{Commit}</span>  returns a commitment c to t, together with an opening hint u.</li>

      <li><span class="math">b \\leftarrow \\Pi</span> .Open(params, c; t, u). On input a commitment c, a multilinear polynomial  <span class="math">t(X_0, \\ldots, X_{\\ell-1}) \\in K[X_0, \\ldots, X_{\\ell-1}]^{\\leq 1}</span> , and an opening hint u,  <span class="math">\\Pi</span> .Open verifies the claimed decommitment t of c, using u.</li>

      <li><span class="math">\\pi \\leftarrow \\Pi</span> .Prove(params,  <span class="math">c, s, (r_0, \\dots, r_{\\ell-1}); t, u</span> ). On input a commitment c, a purported evaluation  <span class="math">s \\in L</span> , an evaluation point  <span class="math">(r_0, \\dots, r_{\\ell-1}) \\in L^{\\ell}</span> , a multilinear polynomial  <span class="math">t(X_0, \\dots, X_{\\ell-1}) \\in K[X_0, \\dots, X_{\\ell-1}]^{\\leq 1}</span> , and an opening hint u,  <span class="math">\\Pi</span> .Prove generates an evaluation proof  <span class="math">\\pi</span> .</li>

      <li><span class="math">b \\leftarrow \\Pi</span> .Verify(params,  <span class="math">c, s, (r_0, \\dots, r_{\\ell-1}), \\pi</span> ). On input a commitment c, a purported evaluation s, an evaluation point  <span class="math">(r_0, \\dots, r_{\\ell-1}) \\in L^{\\ell}</span> , and a proof  <span class="math">\\pi</span> ,  <span class="math">\\Pi</span> .Verify outputs a success bit  <span class="math">b \\in \\{0, 1\\}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that, for  <span class="math">\\Pi</span>  to be efficiently computable, it's necessary that  <span class="math">\\ell = O(\\log \\lambda)</span> , as well as that the sizes  $\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  and  </span>\\log(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  grow at most polynomially in  </span>\\lambda$ . We assume as much throughout what follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define the security properties of <em>binding</em> and <em>extractability</em> for small-field multilinear polynomial commitment schemes, adapting [DP24, Def. 2] and [DP24, Def. 3], respectively.</p>

    <p class="text-gray-300"><strong>Definition 3.4.</strong> For each small-field multilinear polynomial commitment scheme  <span class="math">\\Pi</span> , size parameter  <span class="math">\\ell</span> , input field K, and PPT adversary  <span class="math">\\mathcal{A}</span> , we define the <em>binding experiment Binding</em>  <span class="math">\\Pi_{A}^{\\Pi,\\ell,K}(\\lambda)</span>  as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The experimenter samples params  <span class="math">\\leftarrow \\Pi.\\mathsf{Setup}(1^{\\lambda}, \\ell, K)</span> , and gives params to  <span class="math">\\mathcal{A}</span> .</li>

      <li>2. The adversary outputs  <span class="math">(c, t^0, t^1, u^0, u^1) \\leftarrow \\mathcal{A}(\\mathsf{params})</span> , where c is a commitment,  <span class="math">t^0(X_0, \\dots, X_{\\ell-1})</span>  and  <span class="math">t^1(X_0, \\dots, X_{\\ell-1})</span>  are multilinear polynomials in  <span class="math">K[X_0, \\dots, X_{\\ell-1}]^{\\leq 1}</span> , and  <span class="math">u^0</span>  and  <span class="math">u^1</span>  are opening hints.</li>

      <li>3. The output of the experiment is defined to be 1 if  <span class="math">\\Pi</span> .Open(params, c;  <span class="math">t^0</span> ,  <span class="math">u^0</span> ),  <span class="math">\\Pi</span> .Open(params, c;  <span class="math">t^1</span> ,  <span class="math">u^1</span> ), and  <span class="math">t^0 \\neq t^1</span>  all hold; otherwise, it is defined to be 0.</li>

    </ul>

    <p class="text-gray-300">The scheme  <span class="math">\\Pi</span>  is said to be <em>binding</em> if, for each PPT adversary  <span class="math">\\mathcal{A}</span> , there is a negligible function  <span class="math">\\mathsf{negl}(\\lambda)</span>  for which, for each security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span>  and each  <span class="math">\\ell</span>  and K, it holds that  <span class="math">\\mathsf{Pr}\\left[\\mathsf{Binding}_{\\mathcal{A}}^{\\Pi,\\ell,K}(\\lambda)\\right] \\leq \\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300"><span id="page-12-2"></span><strong>Definition 3.5.</strong> For each small-field multilinear polynomial commitment scheme  <span class="math">\\Pi</span> , security parameter  <span class="math">\\lambda</span> , values  <span class="math">\\ell</span>  and K, PPT query sampler  <span class="math">\\mathcal{Q}</span> , PPT adversary  <span class="math">\\mathcal{A}</span> , expected PPT emulator  <span class="math">\\mathcal{E}</span> , and PPT distinguisher  <span class="math">\\mathcal{D}</span> , we define two random variables  <span class="math">\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)</span>  and  <span class="math">\\mathsf{Ideal}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)</span> , each valued in  <span class="math">\\{0,1\\}</span> , as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. The experimenter samples params  <span class="math">\\leftarrow \\Pi.\\mathsf{Setup}(1^{\\lambda}, \\ell, K)</span> , and gives params to  <span class="math">\\mathcal{A}, \\mathcal{Q}</span>  and  <span class="math">\\mathcal{E}</span> .</li>

      <li>2. The adversary outputs a commitment  <span class="math">c \\leftarrow \\mathcal{A}(\\mathsf{params})</span> .</li>

      <li>3. The query sampler outputs  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\leftarrow \\mathcal{Q}(\\mathsf{params})</span> .</li>

      <li>4. The experimenter proceeds in one of two separate ways:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)</span> :  <span class="math">\\mathsf{Run}\\ (s,\\pi) \\leftarrow \\mathcal{A}(r_0,\\ldots,r_{\\ell-1})</span> . Output the single bit  <span class="math">\\mathcal{D}(c,s,\\pi)</span> .</li>

      <li>Ideal <span class="math">_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)</span> : Run  <span class="math">(s,\\pi;t,u)\\leftarrow\\mathcal{E}^{\\mathcal{A}}(r_0,\\ldots,r_{\\ell-1})</span> . Output the single bit  <span class="math">\\mathcal{D}(c,s,\\pi)\\wedge(\\Pi.\\mathsf{Verify}(\\mathsf{params},c,s,(r_0,\\ldots,r_{\\ell-1}),\\pi)\\Longrightarrow(\\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)\\wedge t(r_0,\\ldots,r_{\\ell-1})=s)).</span></li>

    </ul>

    <p class="text-gray-300">The scheme  <span class="math">\\Pi</span>  is said to be <em>extractable</em> with respect to the query sampler  <span class="math">\\mathcal{Q}</span>  if, for each PPT adversary  <span class="math">\\mathcal{A}</span> , there is an expected PPT emulator  <span class="math">\\mathcal{E}</span>  such that, for each PPT distinguisher  <span class="math">\\mathcal{D}</span> , the distributions  <span class="math">\\left\\{\\mathsf{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)\\right\\}_{(\\ell,K),\\lambda}</span>  and  <span class="math">\\left\\{\\mathsf{Ideal}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell,K}(\\lambda)\\right\\}_{(\\ell,K),\\lambda}</span>  are statistically close.</p>

    <p class="text-gray-300">We note that, critically, the polynomial  <span class="math">t(X_0, \\ldots, X_{\\ell-1})</span>  extracted by  <span class="math">\\mathcal{E}</span>  must reside in  <span class="math">K[X_0, \\ldots, X_{\\ell-1}]</span> , by definition of  <span class="math">\\Pi</span> . Open.</p>

    <p class="text-gray-300">The following definition is analogous to [DP24, Def. 4].</p>

    <p class="text-gray-300"><strong>Definition 3.6.</strong> The query sampler  <span class="math">\\mathcal{Q}</span>  is admissible if, for each  <span class="math">\\lambda</span> ,  <span class="math">\\ell</span>  and K, and each parameter set params  <span class="math">\\leftarrow</span>   <span class="math">\\Pi</span> . Setup( <span class="math">1^{\\lambda}</span> ,  <span class="math">\\ell</span> , K), containing L/K, say, the evaluation point  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\leftarrow \\mathcal{Q}(\\mathsf{params})</span>  is uniform over  <span class="math">L^{\\ell}</span> .</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.3 Basic Small-Field Construction</h3>

    <p class="text-gray-300">We now give our simple small-field construction. This construction generalizes [DP24, Cons. 3] in such a way as to make that scheme instantiate the small-field abstraction of Definition 3.3. In our generalization, we allow the polynomial's coefficient field and the code's alphabet to be small, though we require that these fields be equal to each other (cf. Subsection 3.4 below). We obtain security by the means of a cryptographically sized field extension. Our construction closely follows [DP24, Cons. 3], making only minor modifications throughout.</p>

    <p class="text-gray-300"><span id="page-13-1"></span><strong>CONSTRUCTION 3.7</strong> (Simple small-field polynomial commitment scheme). We define  <span class="math">\\Pi = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Prove}, \\mathsf{Verify})</span>  as follows.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- params  <span class="math">\\leftarrow</span>   <span class="math">\\Pi.\\mathsf{Setup}(1^\\lambda,\\ell,K)</span> . On input  <span class="math">1^\\lambda,\\ell</span> , and K, choose integers  <span class="math">\\ell_0</span>  and  <span class="math">\\ell_1</span>  for which  <span class="math">\\ell_0+\\ell_1=\\ell</span> , and write  <span class="math">m_0 \\coloneqq 2^{\\ell_0}</span>  and  <span class="math">m_1 \\coloneqq 2^{\\ell_1}</span> . Return an extension field L / K for which  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">L</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge 2^{\\omega(\\log \\lambda)}<span class="math"> , an  </span>[n,m_1,d]<span class="math"> -code  </span>C \\subset K^n<span class="math">  for which  </span>n=2^{O(\\ell)}<span class="math">  and  </span>d=\\Omega(n)<span class="math"> , and a repetition parameter  </span>\\gamma=\\Theta(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">(c,u) \\leftarrow \\Pi.\\mathsf{Commit}(\\mathsf{params},t)</span> . On input  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in K[X_0,\\ldots,X_{\\ell-1}]^{\\preceq 1}</span> , express  <span class="math">t=(t_0,\\ldots,t_{2^\\ell-1})</span>  in coordinates with respect to the Lagrange basis on  <span class="math">\\{0,1\\}^\\ell</span> , collate the resulting vector into an  <span class="math">m_0 \\times m_1</span>  matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span> , and encode  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  row-wise, so obtaining a further matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span> . Output a Merkle commitment c to  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  and the opening hint  <span class="math">u \\coloneqq (u_i)_{i=0}^{m_0-1}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">b \\leftarrow \\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)</span> . On input the root c, opening  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in K[X_0,\\ldots,X_{\\ell-1}]^{\\preceq 1}</span> , and opening hint a set of distinct Merkle paths against c, missing the columns  <span class="math">M \\subset \\{0,\\ldots,n-1\\}</span> , say, write t into a matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  and check  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^{m_0}\\left((u_i)_{i=0}^{m_0-1},(\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}\\right)\\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel{?}{<} \\frac{d}{2}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define  <span class="math">\\Pi</span> .Prove and  <span class="math">\\Pi</span> .Verify by applying the Fiat-Shamir heuristic to the following interactive protocol, where  <span class="math">\\mathcal{P}</span>  has  <span class="math">t(X_0,\\ldots,X_{\\ell-1})</span>  and  <span class="math">(u_i)_{i=0}^{m_0-1}</span> , and  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  have  <span class="math">c,s\\in L</span> , and  <span class="math">(r_0,\\ldots,r_{\\ell-1})\\in L^\\ell</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  the matrix-vector product  <span class="math">t&#x27; := \\bigotimes_{i=\\ell_1}^{\\ell-1} (1 r_i, r_i) \\cdot (t_i)_{i=0}^{m_0 1}</span>  in the clear.</li>

      <li>For each  <span class="math">i \\in \\{0, \\dots, \\gamma 1\\}</span> ,  <span class="math">\\mathcal{V}</span>  samples  <span class="math">j_i \\leftarrow \\{0, \\dots, n 1\\}</span> .  <span class="math">\\mathcal{V}</span>  sends  <span class="math">\\mathcal{P}</span>  the set  <span class="math">J \\coloneqq \\{j_0, \\dots, j_{\\gamma 1}\\}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  the columns  <span class="math">\\left\\{ (u_{i,j})_{i=0}^{m_0-1} \\right\\}_{j \\in J}</span> , each featuring an accompanying Merkle path against c.</li>

      <li><span class="math">\\mathcal{V}</span>  computes  <span class="math">u&#x27; \\coloneqq \\widehat{\\mathsf{Enc}}(t&#x27;)</span> . For each  <span class="math">j \\in J</span> ,  <span class="math">\\mathcal{V}</span>  verifies the Merkle path attesting to  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span> , and moreover checks  <span class="math">\\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i,r_i) \\cdot (u_{i,j})_{i=0}^{m_0-1} \\stackrel{?}{=} u&#x27;_j</span> . Finally,  <span class="math">\\mathcal{V}</span>  requires  <span class="math">s \\stackrel{?}{=} t&#x27; \\cdot \\bigotimes_{i=0}^{\\ell_1-1} (1-r_i,r_i)</span> .</li>

    </ul>

    <p class="text-gray-300">In the last step, we write  <span class="math">\\widehat{\\mathsf{Enc}}</span>  for the encoding function of the extension code  <span class="math">\\widehat{C} \\subset L^n</span>  (see Subsection 3.1).</p>

    <p class="text-gray-300">Though Construction 3.7 is both binding and extractable, we refrain from proving as much; instead, we defer our proofs of security to Subsection 3.4 below. The proof of security of Construction 3.7 above can be obtained by specializing that subsection's scheme's proof to the case  <span class="math">\\kappa := 0</span> .</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.4 Block-Level Encoding</h3>

    <p class="text-gray-300">In this subsection, we describe a variant of the polynomial commitment scheme of Subsection 3.3 above suitable for polynomials over fields smaller than the alphabet of the linear block code selected for use. We refer throughout to Guruswami [Gur06].</p>

    <p class="text-gray-300">The simple scheme given in Construction 3.7 mandates the internal use of a code  <span class="math">C \\subset K^n</span>  over the same field K as that passed into  <span class="math">\\Pi.\\mathsf{Setup}(1^\\lambda,\\ell,K)</span> . In other words, it requires that  <span class="math">\\Pi.\\mathsf{Setup}</span>  return a code C whose alphabet K is identical to the coefficient field K of the commitment scheme's message space  <span class="math">K[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span> . This restriction presents no obstacle in theory, since constant-distance, constant-rate families of codes exist even over arbitrarily small, fixed-size fields (this fact follows from the Gilbert-Varshamov bound; see [Gur06, § 2.1]). Moreover, concretely good codes over small alphabets may be obtained constructively using concatenated codes (see [Gur06, § 2.3]).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the other hand, this restriction precludes the use of plain Reed–Solomon codes in Construction 3.7, at least for certain combinations  <span class="math">\\ell</span>  and K; indeed, a Reed–Solomon [n,k,d]-code over K can exist only when  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq n<span class="math"> . Reed–Solomon codes remain attractive, however, for various practical reasons. They attain the Singleton bound, and so maximally favorably negotiate the tension between distance and rate. Separately, they admit efficient encoding algorithms. Specifically, each code  </span>\\mathsf{RS}_{K,S}[n,k]<span class="math"> &#x27;s encoding function  </span>K^k \\to K^n<span class="math">  may be computed in  </span>\\Theta(n \\cdot \\log k)<span class="math">  time, at least for certain alphabets K and evaluation sets  </span>S \\subset K<span class="math"> . Crucially, we may number among these favorable alphabets the fields K of characteristic 2, due to relatively recent work of Lin, Chung and Han [LCH14] (in that work, the evaluation sets  </span>S \\subset K<span class="math">  are certain  </span>\\mathbb{F}_2$ -affine linear subspaces of K). We specialize from this point onwards to the binary tower setting (see Subsection 2.3).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Concatenated codes. In order to develop certain intuitions essential to our packing scheme, we first examine the effect of instantiating Construction 3.7, as written, on a concatenated code. A concatenated code  <span class="math">C \\subset \\mathcal{T}_{\\iota}^{n}</span>  is defined in terms of an outer  <span class="math">[n_{\\text{out}}, k_{\\text{out}}]</span> -code  <span class="math">C_{\\text{out}} \\subset \\mathcal{T}_{\\iota+\\kappa}^{n_{\\text{out}}}</span> , say, where  <span class="math">\\kappa \\in \\mathbb{N}</span> , and an inner  <span class="math">[n_{\\text{in}}, k_{\\text{in}}, d_{\\text{in}}]</span> -code  <span class="math">C_{\\text{in}} \\subset \\mathcal{T}_{\\iota}^{n_{\\text{in}}}</span> , where here we require  <span class="math">k_{\\text{in}} = 2^{\\kappa}</span> . The resulting concatenated code is an [n, k, d]-code over  <span class="math">C \\subset \\mathcal{T}_{\\iota}^{n}</span> , where here we write  <span class="math">n := n_{\\text{out}} \\cdot n_{\\text{in}}</span> ,  <span class="math">k := k_{\\text{out}} \\cdot k_{\\text{in}}</span> , and  <span class="math">d := d_{\\text{out}} \\cdot d_{\\text{in}}</span>  (we refer to [Gur06, § 2.3] for further details). For example, upon concatenating the outer  <span class="math">[2^{15}, 2^{14}, 2^{14} + 1]</span> -code  <span class="math">\\mathsf{RS}_{\\mathcal{T}_4}[2^{15}, 2^{14}]</span>  over  <span class="math">\\mathcal{T}_4</span>  with the inner  <span class="math">[2^5, 2^4, 2^3]</span> -code  <span class="math">\\mathsf{RM}_{\\mathcal{T}_0}[2, 5]</span>  over  <span class="math">\\mathcal{T}_0</span> , we would obtain a  <span class="math">[2^{20}, 2^{18}, 2^{17} + 2^3]</span> -code over  <span class="math">\\mathcal{T}_0</span>  (here,  <span class="math">\\mathsf{RM}_{\\mathcal{T}_0}[2, 5]</span>  denotes a certain  <span class="math">\\mathit{Reed-Muller code}</span> ).</p>

    <p class="text-gray-300">The concatenated code construction requires that the inner code's message space coincide with the outer code's alphabet. Indeed, above, we leverage the natural identification  <span class="math">\\mathcal{T}_{\\iota}^{2^{\\kappa}} \\cong \\mathcal{T}_{\\iota+\\kappa}</span>  of  <span class="math">\\mathcal{T}_{\\iota}</span> -vector spaces (see Subsection 2.3). In different words, we may interpret blocks of adjacent tower-field elements as elements of a larger tower field. That is, given integers  <span class="math">\\iota</span>  and  <span class="math">\\kappa</span>  in  <span class="math">\\mathbb{N}</span> , we may "pack" each block of  <span class="math">2^{\\kappa}</span>   <span class="math">\\mathcal{T}_{\\iota}</span> -elements into a single  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element.</p>

    <p class="text-gray-300">We recall that the concatenated code  <span class="math">C \\subset \\mathcal{T}_{\\iota}^{n}</span> 's encoding procedure entails the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>pack the initial message in  <span class="math">\\mathcal{T}_{\\iota}^{k}</span>  into a vector in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}^{k_{\\text{out}}}</span> ,</li>

      <li>encode the resulting vector using the outer code  <span class="math">C_{\\text{out}}</span> 's encoder, so obtaining a codeword in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}^{n_{\\text{out}}}</span> ,</li>

      <li>unpack each individual symbol of the resulting codeword into a message, in  <span class="math">\\mathcal{T}_{\\iota}^{k_{\\mathrm{in}}}</span> , and finally</li>

      <li>encode each such message, using the inner code  <span class="math">C_{\\rm in}</span> , into a codeword in  <span class="math">\\mathcal{T}_{\\iota}^{n_{\\rm in}}</span> , and concatenate them.</li>

    </ul>

    <p class="text-gray-300">Construction 3.7, upon being instantiated with a concatenated code  <span class="math">C \\subset \\mathcal{T}_{\\iota}^{n}</span> , and with the extension field  <span class="math">\\mathcal{T}_{\\tau} / \\mathcal{T}_{\\iota}</span> , say, would stipulate that the verifier perform the encoding operation attached to the extension code  <span class="math">\\widehat{C} \\subset \\mathcal{T}_{\\tau}^{n}</span> . This code is clearly well-defined (we recall Subsection 3.1); on the other hand, its encoding procedure is significantly more complicated than C's is. We have already discussed above how one might pack blocks of  <span class="math">2^{\\kappa}</span>   <span class="math">\\mathcal{T}_{\\iota}</span> -elements into  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -elements; in contrast, the corresponding packing operation on blocks of  <span class="math">2^{\\kappa}</span>   <span class="math">\\mathcal{T}_{\\tau}</span> -elements is more subtle.</p>

    <p class="text-gray-300">The subtlety arises from the interplay of the three fields  <span class="math">\\mathcal{T}_{\\iota}</span> ,  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , and  <span class="math">\\mathcal{T}_{\\tau}</span> . In a sense, the packing operation operates over a different dimension than does the field extension  <span class="math">\\mathcal{T}_{\\tau} / \\mathcal{T}_{\\iota}</span> ; that is, it acts across  <span class="math">\\mathcal{T}_{\\iota}</span> -elements, instead of extending them. For the sake of intuition, we suggest imagining the parameterization  <span class="math">\\iota := 0</span> ,  <span class="math">\\kappa := 4</span> , and  <span class="math">\\tau := 7</span> , as well as the concatenated code sketched above, throughout our treatment below.</p>

    <p class="text-gray-300"><span id="page-15-0"></span><strong>Sketch of our approach.</strong> We explain the encoding procedure of a concatenated code's extension code in the following way. We again fix a concatenated code  <span class="math">C \\subset \\mathcal{T}_{\\iota}^{n}</span>  and write  <span class="math">\\widehat{C} \\subset \\mathcal{T}_{\\tau}^{n}</span>  for its extension code. We define a certain data structure which "packs" a number of  <span class="math">\\mathcal{T}_{\\iota}</span> -elements into a rectangular array. This data structure is depicted in Figure 1 below.</p>

    <p class="text-gray-300"><img src="_page_15_Picture_2.jpeg" alt="" class="my-4 max-w-full" /></p>

    <p class="text-gray-300">Figure 1: A depiction of our "tower algebra" data structure.</p>

    <p class="text-gray-300">Figure 1 depicts an array of  <span class="math">2^{\\tau-\\iota}</span>  rows and  <span class="math">2^{\\kappa}</span>  columns (where, again, each cell is a  <span class="math">\\mathcal{T}_{\\iota}</span> -element). The extension code  <span class="math">\\widehat{C}</span> 's encoding procedure would pack each block of  <span class="math">2^{\\kappa}</span>  consecutive  <span class="math">\\mathcal{T}_{\\tau}</span> -elements of its message into exactly such an array, apply the outer code (whose alphabet is  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> ) row-wise, and then finally apply the inner code, again row-wise, to each component of the result.</p>

    <p class="text-gray-300">In pursuit of an even simpler construction, we simply omit the inner code—that is, we use the identity inner code—and use the Reed–Solomon outer code. Were we to instantiate Construction 3.7 naïvely on the resulting concatenated code, we would encounter a relatively inefficient verifier; indeed, that concatenated code features a relative distance  <span class="math">k_{\\rm in}</span> -fold worse than the simple Reed–Solomon code's. Instead, though we do omit the inner code, we compensate by decreeing that the verifier test entire packed blocks of the prover's committed matrix, as opposed to testing individual columns. Crucially, we no longer view our code's encoding procedure as a  <span class="math">\\mathcal{T}_t</span> -linear one; rather, our code's "symbols" are, now, packed chunks of  <span class="math">\\mathcal{T}_t</span> -elements. To resuscitate our security analysis—which itself depends fundamentally on the proximity gap phenomenon exhibited by error-correcting codes—we must investigate the sense in which the rows of our committed matrix are, in fact, codewords of some different code. As it turns out, the array of Figure 1 can be endowed with a certain algebraic structure—which we describe thoroughly throughout what follows—which, serving in the capacity of the alphabet of a certain extension code, makes possible our adaptation of [DP24]'s security analysis.</p>

    <p class="text-gray-300">Interestingly, our block-level testing scheme achieves a proof size profile close to that which Construction 3.7 can attain even on a nontrivial concatenated code. (Comparing these approaches is of course difficult—and in the limit, impossible—since the latter approach mandates the selection of an ad-hoc inner code for each statement size. We opt simply to select the highest-distance known inner code for each statement size we benchmark, and to avoid asymptotic comparisons.) At the same time, it's significantly simpler, as well as more efficient for the prover. These observations affirm our contention that, taken in full, this section's construction presents a compelling proposition. Indeed, we seek first of all to deliver a highly efficient prover; on the other hand, our approach imposes only a mild cost on the verifier. We thoroughly benchmark these schemes' proof sizes in Table 1 below.</p>

    <p class="text-gray-300">The tower algebra. We discuss, first informally and then precisely, two distinct multiplication operations, defined on  <span class="math">2^{\\tau-\\iota} \\times 2^{\\kappa}</span> -sized arrays over  <span class="math">\\mathcal{T}_{\\iota}</span>  like that in Figure 1. To multiply the entire array by a  <span class="math">\\mathcal{T}_{\\iota}</span> -element, we may simply proceed cell-wise. We may moreover coherently define multiplication operations involving elements of certain larger fields. For example, to multiply the entire array by a  <span class="math">\\mathcal{T}_{\\tau}</span> -element  <span class="math">r \\in \\mathcal{T}_{\\tau}</span> , we may interpret the array's columns as  <span class="math">\\mathcal{T}_{\\tau}</span> -elements—respectively called  <span class="math">\\varsigma_0, \\ldots, \\varsigma_{2^{\\kappa}-1}</span> , say—and overwrite  <span class="math">\\varsigma_i \\times = r</span>  for each column index  <span class="math">i \\in \\{0, \\ldots, 2^{\\kappa}-1\\}</span> . On the other hand, we may moreover interpret each of the array's rows as a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element. We thus further define multiplication by  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -elements; that is, to multiply the entire matrix by an element  <span class="math">s \\in \\mathcal{T}_{\\iota+\\kappa}</span> , we interpret the array's rows as  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -elements—called  <span class="math">(\\vartheta_0, \\ldots, \\vartheta_{2^{\\tau-\\iota}-1})</span> , say—and overwrite  <span class="math">\\vartheta_i \\times = s</span>  for each  <span class="math">i \\in \\{0, \\ldots, 2^{\\tau-\\iota}-1\\}</span> .</p>

    <p class="text-gray-300">This "dual view" of the array—that is, either as an array of  <span class="math">2^{\\kappa} \\mathcal{T}_{\\tau}</span> -elements, with a  <span class="math">\\mathcal{T}_{\\tau}</span> -vector space structure or as an array of  <span class="math">2^{\\tau-\\iota} \\mathcal{T}_{\\iota+\\kappa}</span> -elements, with a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -vector space structure—will prove crucial throughout our exposition of the packing scheme. Essentially, our packing scheme entails packing  <span class="math">\\mathcal{T}_{\\iota}</span> -elements "horizontally", into  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -elements, in order to encode them; in order to obtain cryptographic security, on the other hand, we moreover extend them "vertically", into  <span class="math">\\mathcal{T}_{\\tau}</span> -elements.</p>

    <p class="text-gray-300">To make precise our packing scheme, we introduce a certain polynomial ring.</p>

    <p class="text-gray-300"><span id="page-16-0"></span><strong>Definition 3.8.</strong> For parameters  <span class="math">\\iota</span> ,  <span class="math">\\kappa</span> , and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span> , where  <span class="math">\\tau \\geq \\iota</span> , we define the tower algebra  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  as:</p>

    <div class="my-4 text-center"><span class="math-block">A_{\\iota,\\kappa,\\tau} := \\mathcal{T}_{\\tau}[Y_0,\\ldots,Y_{\\kappa-1}] / (Y_0^2 + X_{\\iota-1} \\cdot Y_0 + 1, Y_1^2 + Y_0 \\cdot Y_1 + 1,\\ldots,Y_{\\kappa-1}^2 + Y_{\\kappa-2} \\cdot Y_{\\kappa-1} + 1),</span></div>

    <p class="text-gray-300">where we understand  <span class="math">X_{\\iota-1}</span>  as a  <span class="math">\\mathcal{T}_{\\tau}</span> -element (and slightly abuse notation by letting  <span class="math">X_{-1} := 1</span>  in case  <span class="math">\\iota = 0</span> ).</p>

    <p class="text-gray-300">We note that  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  admits a natural description as a  <span class="math">2^{\\kappa}</span> -dimensional vector space over  <span class="math">\\mathcal{T}_{\\tau}</span> , via the basis  <span class="math">1, Y_0, Y_1, Y_0 \\cdot Y_1, \\dots, Y_0 \\cdot \\dots \\cdot Y_{\\kappa-1}</span> . This basis yields an isomorphism  <span class="math">a_{\\iota,\\kappa,\\tau} : \\mathcal{T}_{\\tau}^{2^{\\kappa}} \\to A_{\\iota,\\kappa,\\tau}</span>  of  <span class="math">\\mathcal{T}_{\\tau}</span> -vector spaces, which we call the <em>natural embedding</em>. The restriction of this embedding to its domain's  <span class="math">0^{\\text{th}}</span>  factor  <span class="math">\\mathcal{T}_{\\tau} \\subset \\mathcal{T}_{\\tau}^{2^{\\kappa}}</span>  maps  <span class="math">\\mathcal{T}_{\\tau}</span>  isomorphically to the subring  <span class="math">A_{\\iota,0,\\tau} \\subset A_{\\iota,\\kappa,\\tau}</span>  consisting of the constant polynomials in the indeterminates  <span class="math">Y_0, \\dots, Y_{\\kappa-1}</span> .</p>

    <p class="text-gray-300">We understand the tower algebra in the following way. The formal variables  <span class="math">Y_0, \\ldots, Y_{\\kappa-1}</span>  define "synthetic analogues" of the variables  <span class="math">X_{\\iota}, \\ldots, X_{\\iota+\\kappa-1}</span> , which would—upon being adjoined to  <span class="math">\\mathcal{T}_{\\iota}</span> —yield the field extension  <span class="math">\\mathcal{T}_{\\iota} \\subset \\mathcal{T}_{\\iota+\\kappa}</span> ; moreover, these synthetic variables are designed to behave like their genuine analogues (by means of the relations defining  <span class="math">A_{\\iota,\\kappa,\\tau}</span> ). In fact, this design gives rise to a certain key property of the tower algebra, whereby the subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span>  consisting of those polynomials whose coefficients reside exclusively in the subfield  <span class="math">\\mathcal{T}_{\\iota} \\subset \\mathcal{T}_{\\tau}</span>  is precisely  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> . We restate this essential property as follows:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-16-1"></span><strong>Theorem 3.9.</strong> The restriction  $a_{\\iota,\\kappa,\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">_{\\mathcal{T}_{\\iota}^{2^{\\kappa}}}: \\mathcal{T}_{\\iota}^{2^{\\kappa}} \\to A_{\\iota,\\kappa,\\tau}<span class="math">  of the natural embedding to the subset  </span>\\mathcal{T}_{\\iota}^{2^{\\kappa}} \\subset \\mathcal{T}_{\\tau}^{2^{\\kappa}}<span class="math">  is an injection of  </span>\\mathcal{T}_{\\iota}<span class="math"> -vector spaces, whose image, the subring  </span>A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}<span class="math"> , is isomorphic as a ring to  </span>\\mathcal{T}_{\\iota+\\kappa}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof.</em> Indeed, the subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span>  is easily seen to be identical to  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , albeit with the variables  <span class="math">X_{\\iota},\\ldots,X_{\\iota+\\kappa-1}</span>  respectively renamed to  <span class="math">Y_0,\\ldots,Y_{\\kappa-1}</span> .</p>

    <p class="text-gray-300">We implicitly, and unambiguously, understand  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  as a  <span class="math">\\mathcal{T}_{\\iota}</span> -vector space in the first part of the statement of Theorem 3.9; indeed, this action arises from the subring  <span class="math">\\mathcal{T}_{\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span>  consisting of those constant polynomials in the indeterminates  <span class="math">Y_0, \\ldots, Y_{\\kappa-1}</span>  whose constant—i.e., only—term resides in the subfield  <span class="math">\\mathcal{T}_{\\iota} \\subset \\mathcal{T}_{\\tau}</span> .</p>

    <p class="text-gray-300">On the other hand, Theorem 3.9 shows that, over certain fields strictly larger than  <span class="math">\\mathcal{T}_{\\iota}</span> , the ring  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  admits multiple—and incompatible—vector space structures, a fact which we now take pains to explain carefully. Of course,  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  has an obvious  <span class="math">\\mathcal{T}_{\\tau}</span> -action—already noted above—coming from the subring  <span class="math">\\mathcal{T}_{\\tau} \\cong A_{\\iota,0,\\tau} \\subset A_{\\iota,\\kappa,\\tau}</span>  consisting of constant polynomials in the indeterminates  <span class="math">Y_0, \\ldots, Y_{\\kappa-1}</span> . To distinguish this subring from Theorem 3.9's, we call it the constant subring throughout what follows. On the other hand, Theorem 3.9 further realizes the field  <span class="math">\\mathcal{T}_{\\iota+\\kappa} \\cong A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span>  as the subring consisting of those arbitrary-degree polynomials in the indeterminates  <span class="math">Y_0, \\ldots, Y_{\\kappa-1}</span>  whose coefficients, on the other hand, reside in  <span class="math">\\mathcal{T}_{\\iota} \\subset \\mathcal{T}_{\\tau}</span> . We refer to Theorem 3.9's subring, throughout what follows, as the synthetic subring. We take care below, whenever we understand  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  as an algebra or as a vector space, to carefully specify the particular field, and the particular vector space structure, that we intend. As a rule, whenever we speak of  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  as a  <span class="math">\\mathcal{T}_{\\tau}</span> -algebra, we understand the constant subring; whenever we speak of it as a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -algebra, we understand the synthetic subring. (The constant and synthetic subrings appear in Figure 1 as the vertical and horizontal shaded regions, respectively.)</p>

    <p class="text-gray-300">We write  <span class="math">(\\beta_u)_{u \\in \\mathcal{B}_{\\tau-\\iota}}</span>  for the multilinear  <span class="math">\\mathcal{T}_{\\iota}</span> -basis of  <span class="math">\\mathcal{T}_{\\tau}</span>  (i.e., for the basis  <span class="math">1, X_{\\iota}, X_{\\iota+1}, X_{\\iota} \\cdot X_{\\iota+1}, \\dots, X_{\\iota} \\cdot \\dots \\cdot X_{\\tau-1}</span> ). We finally note that  <span class="math">(\\beta_u)_{u \\in \\mathcal{B}_{\\tau-\\iota}}</span>  simultaneously yields a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -basis of  <span class="math">A_{\\iota,\\kappa,\\tau}</span> —where we endow the latter ring with the synthetic  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -vector space structure—provided that we identify each  <span class="math">\\beta_u</span>  with the constant polynomial  <span class="math">\\beta_u</span>  in the indeterminates  <span class="math">Y_0, \\dots, Y_{\\kappa-1}</span> .</p>

    <p class="text-gray-300">For each  <span class="math">\\iota</span> ,  <span class="math">\\kappa</span> , and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span> , each tower algebra  <span class="math">A_{\\iota,\\kappa,\\tau}</span> , and each standard [n,k,d]-code  <span class="math">C\\subset\\mathcal{T}^n_{\\iota+\\kappa}</span>  over the alphabet  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , we recall the extension code construction of Definition 3.1. That is, in view of the synthetic  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -vector space structure—i.e., that of Theorem 3.9—on  <span class="math">A_{\\iota,\\kappa,\\tau}</span> , C's generator matrix induces a map  <span class="math">\\widehat{\\mathsf{Enc}}:A^k_{\\iota,\\kappa,\\tau}\\to A^n_{\\iota,\\kappa,\\tau}</span>  of  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -vector spaces; we write  <span class="math">\\widehat{C}\\subset A^n_{\\iota,\\kappa,\\tau}</span>  for this map's image. (Equivalently, we may simply embed C's generator matrix entry-wise along the subring  <span class="math">\\mathcal{T}_{\\iota+\\kappa}\\subset A_{\\iota,\\kappa,\\tau}</span>  of Theorem 3.9, and view it as an  <span class="math">A_{\\iota,\\kappa,\\tau}</span> -matrix.) It is shown in Theorem 3.2 above that  <span class="math">\\widehat{C}\\subset A^n_{\\iota,\\kappa,\\tau}</span>  has distance d.</p>

    <p class="text-gray-300">Importantly, we note that  <span class="math">\\widehat{\\mathsf{Enc}}</span>  is simultaneously  <span class="math">\\mathcal{T}_{\\tau}</span> -linear, where now we understand both  <span class="math">A^k_{\\iota,\\kappa,\\tau}</span>  and  <span class="math">A^n_{\\iota,\\kappa,\\tau}</span>  as  <span class="math">\\mathcal{T}_{\\tau}</span> -vector spaces (via the constant embedding on each component). To show this, we observe first that  <span class="math">\\widehat{\\mathsf{Enc}}</span>  amounts to a matrix-vector product over the ring  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  (where we again synthetically embed  <span class="math">\\mathcal{T}_{\\iota+\\kappa}\\subset A_{\\iota,\\kappa,\\tau}</span> ). On the other hand, any  <span class="math">\\mathcal{T}_{\\tau}</span> -linear combination of  <span class="math">A^k_{\\iota,\\kappa,\\tau}</span> -vectors can itself be expressed as a scalar-vector combination over the ring  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  (where we now embed  <span class="math">\\mathcal{T}_{\\tau}\\subset A_{\\iota,\\kappa,\\tau}</span> ). The  <span class="math">\\mathcal{T}_{\\tau}</span> -linearity of  <span class="math">\\widehat{\\mathsf{Enc}}</span>  thus amounts to a distributive matrix identity over  <span class="math">A_{\\iota,\\kappa,\\tau}</span> ; on the other hand, matrix multiplication is certainly distributive for arbitrary commutative rings.</p>

    <p class="text-gray-300">We finally prepare the ground for our packing construction by recording a proximity gap result—that is, an analogue of [DP24, Thm. 2]—for tower algebras. In the below theorem, we give meaning to the row-combination  <span class="math">\\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)\\cdot(u_i)_{i=0}^{m_0-1}</span>  by means of the constant  <span class="math">\\mathcal{T}_{\\tau}</span> -vector space structure on  <span class="math">A_{\\iota,\\kappa,\\tau}</span> . The key difference between [DP24, Thm. 2] and Theorem 3.10 below, then, is that the code at hand has symbols in the  <span class="math">\\mathcal{T}_{\\tau}</span> -vector space  <span class="math">A_{\\iota,\\kappa,\\tau}</span> , though the combination vector  <span class="math">\\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)</span>  nonetheless still has entries in the ground field  <span class="math">\\mathcal{T}_{\\tau}</span> .</p>

    <p class="text-gray-300"><span id="page-17-0"></span><strong>Theorem 3.10</strong> (Diamond–Posen [DP24, Thm. 2]). Fix an arbitrary [n, k, d]-code  <span class="math">C \\subset \\mathcal{T}_{\\iota+\\kappa}^n</span> , with extension code  <span class="math">\\widehat{C} \\subset A_{\\iota,\\kappa,\\tau}^n</span> , and a proximity parameter  <span class="math">e \\in \\{0,\\ldots, \\left\\lfloor \\frac{d-1}{3} \\right\\rfloor\\}</span> . If elements  <span class="math">u_0,\\ldots,u_{m_0-1}</span>  of  <span class="math">A_{\\iota,\\kappa,\\tau}^n</span>  satisfy</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$\\Pr_{(r_{\\ell_1},\\dots,r_{\\ell-1})\\in\\mathcal{T}_{\\tau}^{\\ell_0}}\\left[d\\left(\\left[\\begin{array}{cc}\\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)\\end{array}\\right]\\cdot\\begin{bmatrix}-&u_0&-\\\\&\\vdots&\\\\&u_{m_0-1}&-\\end{array}\\right],\\widehat{C}\\right)\\leq e\\right]>2\\cdot\\log m_0\\cdot\\frac{e+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">},$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">then <span class="math-block">d^{m_0}((u_i)_{i=0}^{m_0-1}, \\widehat{C}^{m_0}) \\leq e</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. The proof goes through almost exactly as does that of [DP24, Thm. 2], with select modifications. Indeed, we require only a substitute for the Schwartz–Zippel-based argument given in [DP24, Lem. 3]. In our setting, each locus  <span class="math">R_{b,j} \\subset \\mathcal{T}_{\\tau}^{\\ell_0-1}</span>  is, now, the vanishing locus in  <span class="math">\\mathcal{T}_{\\tau}^{\\ell_0-1}</span>  of a certain polynomial expression in the variables  <span class="math">(r_{\\ell_1}, \\ldots, r_{\\ell-1})</span> , whose coefficients, on the other hand, reside in  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  (and moreover are not all zero). Decomposing each such coefficient into a  <span class="math">2^{\\kappa}</span> -tuple of  <span class="math">\\mathcal{T}_{\\tau}</span> -elements, using the natural  <span class="math">\\mathcal{T}_{\\tau}</span> -basis  <span class="math">1, Y_0, Y_1, \\ldots, Y_0 \\cdots Y_{\\kappa-1}</span>  of  <span class="math">A_{\\iota,\\kappa,\\tau}</span> , we see that the vanishing locus  <span class="math">R_{b,j}</span>  is the intersection in  <span class="math">\\mathcal{T}_{\\tau}^{\\ell_0-1}</span>  of  <span class="math">2^{\\kappa}</span>  vanishing loci, each itself the vanishing locus of a certain combination of the  <span class="math">\\ell_0</span>  – 1-variate, multilinear Lagrange basis polynomials in the standard polynomial ring  <span class="math">\\mathcal{T}_{\\tau}[R_{\\ell_1}, \\ldots, R_{\\ell-2}]</span> . Moreover, at least one among these latter combinations features a nonzero combination vector. Applying Schwartz–Zippel to all  <span class="math">2^{\\kappa}</span>  loci, then, we see that at least one among these loci is bounded from above in mass by  $\\frac{\\ell_0-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , so that their intersection also is. This completes the argument that  </span>\\mu(R_{b,j}) \\leq \\frac{\\ell_0-1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ . We note that an identical adaptation, in the univariate setting, must also be made to the proof of [DP24, Thm. 1]. Up to these adjustments, the proof of [DP24, Thm. 2] otherwise goes through in our setting without change.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Our construction. We now record our packing-based construction, which adapts and extends Construction 3.7 above. Slightly restricting that construction's signature, we require that K take the form  <span class="math">\\mathcal{T}_{\\iota}</span> , for some  <span class="math">\\iota</span>  (and that  <span class="math">\\Pi</span> .Setup directly accept the parameter  <span class="math">\\iota</span> , instead of K).</p>

    <p class="text-gray-300"><span id="page-18-0"></span><strong>CONSTRUCTION 3.11</strong> (Block-level encoding-based polynomial commitment scheme). We define  <span class="math">\\Pi = (\\mathsf{Setup}, \\mathsf{Commit}, \\mathsf{Open}, \\mathsf{Prove}, \\mathsf{Verify})</span>  as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>params  <span class="math">\\leftarrow \\Pi</span> . Setup <span class="math">(1^{\\lambda}, \\ell, \\iota)</span> . On input  <span class="math">1^{\\lambda}, \\ell</span> , and  <span class="math">\\iota</span> , choose integers  <span class="math">\\ell_0</span>  and  <span class="math">\\ell_1</span>  for which  <span class="math">\\ell_0 + \\ell_1 = \\ell</span> , and write  <span class="math">m_0 := 2^{\\ell_0}</span>  and  <span class="math">m_1 := 2^{\\ell_1}</span> . Return an integer  <span class="math">\\kappa \\geq 0</span> , a tower height  <span class="math">\\tau \\geq \\log(\\omega(\\log \\lambda))</span> , an  <span class="math">\\left[n, \\frac{m_1}{2^{\\kappa}}, d\\right]</span> -code  <span class="math">C \\subset \\mathcal{T}_{\\iota+\\kappa}^n</span>  for which  <span class="math">n = 2^{O(\\ell)}</span>  and  <span class="math">d = \\Omega(n)</span> , and a repetition parameter  <span class="math">\\gamma = \\Theta(\\lambda)</span> .</li>

      <li><span class="math">(c,u) \\leftarrow \\Pi.\\mathsf{Commit}(\\mathsf{params},t)</span> . On input  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in \\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span> , express  <span class="math">t=(t_0,\\ldots,t_{2^{\\ell}-1})</span>  in coordinates with respect to the multilinear Lagrange basis and collate the result row-wise into an  <span class="math">m_0 \\times m_1</span>  matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span> . By grouping the column indices  <span class="math">\\{0,\\ldots,m_1-1\\}</span>  into  <span class="math">2^{\\kappa}</span> -sized chunks and, for each row, applying the natural embedding chunk-wise, realize  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  as an  <span class="math">m_0 \\times \\frac{m_1}{2^{\\kappa}}</span>  matrix with entries in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> . Apply C's encoding function row-wise to each of  <span class="math">(t_i)_{i=0}^{m_0-1}</span> 's rows; obtain in this way a further,  <span class="math">m_0 \\times n</span>  matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span> , again with entries in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> . Output a Merkle commitment c to  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  and the opening hint  <span class="math">u:=(u_i)_{i=0}^{m_0-1}</span> .</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">b \\leftarrow \\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)</span> . On input the root c, opening  <span class="math">t(X_0,\\ldots,X_{\\ell-1}) \\in \\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]^{\\preceq 1}</span> , and opening hint a set of distinct Merkle paths against c, missing the columns  <span class="math">M \\subset \\{0,\\ldots,n-1\\}</span> , say, write t into a matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  and check  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^{m_0}\\left((u_i)_{i=0}^{m_0-1},(\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}\\right)\\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\stackrel{?}{<} \\frac{d}{2}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We define  <span class="math">\\Pi</span> .Prove and  <span class="math">\\Pi</span> .Verify by applying the Fiat-Shamir heuristic to the following interactive protocol, where  <span class="math">\\mathcal{P}</span>  has  <span class="math">t(X_0,\\ldots,X_{\\ell-1})</span>  and  <span class="math">(u_i)_{i=0}^{m_0-1}</span> , and  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  have c, s, and  <span class="math">(r_0,\\ldots,r_{\\ell-1}) \\in \\mathcal{T}_{\\tau}^{\\ell}</span> .</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  computes the matrix-vector product  <span class="math">t&#x27; := \\bigotimes_{i=\\ell_1}^{\\ell-1} (1 r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}</span> , here interpreting the matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  as an unpacked,  <span class="math">m_0 \\times m_1</span>  matrix with entries in  <span class="math">\\mathcal{T}_{\\iota}</span> .  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  t' in the clear.</li>

      <li>For each  <span class="math">i \\in \\{0, \\ldots, \\gamma 1\\}</span> ,  <span class="math">\\mathcal{V}</span>  samples  <span class="math">j_i \\leftarrow \\{0, \\ldots, n 1\\}</span> .  <span class="math">\\mathcal{V}</span>  sends  <span class="math">\\mathcal{P}</span>  the set  <span class="math">J := \\{j_0, \\ldots, j_{\\gamma 1}\\}</span> .</li>

      <li>For each  <span class="math">j \\in J</span> ,  <span class="math">\\mathcal{P}</span>  sends  <span class="math">\\mathcal{V}</span>  the column  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span> , which it now interprets as a vector with entries in the subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> , as well as an accompanying Merkle authentication path against c.</li>

      <li><span class="math">\\mathcal{V}</span>  requires  <span class="math">s \\stackrel{?}{=} t&#x27; \\cdot \\bigotimes_{i=0}^{\\ell_1-1} (1-r_i, r_i)</span>  (i.e., a simple dot-product over  <span class="math">\\mathcal{T}_{\\tau}</span> ).  <span class="math">\\mathcal{V}</span>  then applies the natural embedding to the  <span class="math">\\mathcal{T}_{\\tau}</span> -vector t', chunk-wise, so realizing it as a length- <span class="math">\\frac{m_1}{2^{\\kappa}}</span>  vector with entries in  <span class="math">A_{\\iota,\\kappa,\\tau}</span> .  <span class="math">\\mathcal{V}</span>  encodes this latter vector under  <span class="math">\\widehat{C}</span> , writing  <span class="math">u&#x27; \\coloneqq \\widehat{\\mathsf{Enc}}(t&#x27;)</span> , say. For each  <span class="math">j \\in J</span> ,  <span class="math">\\mathcal{V}</span>  verifies the Merkle path attesting to  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span> , and moreover checks  <span class="math">\\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (u_{i,j})_{i=0}^{m_0-1} \\stackrel{?}{=} u&#x27;_j</span> , where we use the constant  <span class="math">\\mathcal{T}_{\\tau}</span> -action on  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  on the left, and the equality is one of  <span class="math">A_{\\iota,\\kappa,\\tau}</span> -elements.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We again require that  <span class="math">\\iota = O(\\log(\\lambda))</span> , lest the scheme fail to be efficiently computable; we moreover assume that  <span class="math">\\tau \\geq \\iota</span> , so that the tower algebra  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  is well-defined. We note that the growth requirement  <span class="math">\\tau \\geq \\log(\\omega(\\log \\lambda))</span>  captures precisely the condition whereby  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  is negligible in  </span>\\lambda<span class="math"> . Indeed, while requiring  </span>\\tau \\geq \\Omega(\\log \\lambda)<span class="math"> , say, would more-than-guarantee our scheme&#x27;s asymptotic security, the more delicate allowance  </span>\\tau \\geq \\log(\\omega(\\log \\lambda))$  in fact suffices, and moreover figures centrally in our sharp asymptotic efficiency analysis below (see Theorem 3.14).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We emphasize that Construction 3.11's setup routine  <span class="math">\\Pi</span> . Setup returns a code C over the alphabet  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , which—in general—is larger than the coefficient field  <span class="math">\\mathcal{T}_{\\iota}</span>  at hand. On the other hand, the efficiency of Construction 3.11's commitment phase is identical to that which Construction 3.7's would achieve if that construction were run on a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -matrix of size  <span class="math">m_0 \\times \\frac{m_1}{2^{\\kappa}}</span> . In other words, Construction 3.11 makes possible the use of a code over an alphabet larger than  <span class="math">\\mathcal{T}_{\\iota}</span> , by  <span class="math">2^{\\kappa}</span> -fold, say; it compensates for that expense by shrinking the prover's matrix  <span class="math">2^{\\kappa}</span> -fold.</p>

    <p class="text-gray-300">Construction 3.11's completeness amounts to the "commutativity" of a certain sequence of actions on the  <span class="math">\\mathcal{T}_{\\iota}</span> -matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span> ; that is,  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  either is combined, packed, and then encoded, or else is packed, encoded, and then combined. Since the natural embedding is  <span class="math">\\mathcal{T}_{\\tau}</span> -linear, the first pathway's combination and packing operations can be interchanged. On the other hand, the interchangability of the combination and encoding operations amounts exactly to the  <span class="math">\\mathcal{T}_{\\tau}</span> -linearity of  <span class="math">\\widehat{\\mathsf{Enc}}</span> , which we have already established.</p>

    <p class="text-gray-300">The proofs of the security results below draw heavily from [DP24, § 4].</p>

    <p class="text-gray-300"><span id="page-19-3"></span><strong>Theorem 3.12.</strong> The scheme of Construction 3.11 is binding.</p>

    <p class="text-gray-300"><em>Proof.</em> Deferred to Appendix A.</p>

    <p class="text-gray-300"><span id="page-19-0"></span><strong>Theorem 3.13.</strong> If the query sampler Q is admissible, then the scheme of Construction 3.11 is extractable.</p>

    <p class="text-gray-300">Proof. Deferred to Appendix A.</p>

    <h3 id="sec-16" class="text-xl font-semibold mt-8">3.5 Efficiency</h3>

    <p class="text-gray-300">In this subsection, we discuss the concrete efficiency of Construction 3.11; to do this, we must also examine its concrete soundness. A rudimentary treatment of this section's material appears in [DP24, § 4.3].</p>

    <p class="text-gray-300"><strong>Verifier cost.</strong> Departing slightly from standard efficiency analyses, we analyze both <em>proof size</em> and <em>verifier runtime</em> under one banner; indeed, we view both metrics as disparate aspects of a unified <em>verifier cost</em>. (This approach reflects the cost structure of Ethereum, say, in which each transaction's <em>calldata size</em> and <em>verification complexity</em> contribute jointly to its gas cost.) We define the relevant variables as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>b: The cost, to the verifier, of each bit transmitted to it.</li>

      <li><span class="math">\\mathfrak{T}_{\\iota}</span> : The cost, to the verifier, of multiplying two  <span class="math">\\mathcal{T}_{\\iota}</span> -elements.</li>

      <li><span class="math">\\mathfrak{T}_{\\tau}</span> : The cost, to the verifier, of multiplying two  <span class="math">\\mathcal{T}_{\\tau}</span> -elements.</li>

      <li><span class="math">\\mathfrak{Enc}</span> : The cost, to the verifier, of encoding a message in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}^{m_1/2^{\\kappa}}</span> .</li>

      <li><span class="math">\\mathfrak{Hash}</span> . The cost, to the verifier, of hashing a single  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element.</li>

    </ul>

    <p class="text-gray-300">We recall that a  <span class="math">\\mathcal{T}_{\\tau}</span> -element and a  <span class="math">\\mathcal{T}_{\\iota}</span> -element can be multiplied together with cost  <span class="math">2^{\\tau-\\iota} \\cdot \\mathfrak{T}_{\\iota}</span> . Finally, we ignore throughout the cost of addition (which amounts to bitwise XOR).</p>

    <p class="text-gray-300">We reckon the verifier's costs as follows. The prover must transmit to the verifier the message t', which consists of  <span class="math">m_1</span>   <span class="math">\\mathcal{T}_{\\tau}</span> -elements, as well as the  <span class="math">\\gamma</span>   <span class="math">m_0</span> -element columns  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span> , for  <span class="math">j \\in J</span> , each valued in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> . The total proof size is thus  <span class="math">2^{\\tau} \\cdot m_1 + 2^{\\iota+\\kappa} \\cdot m_0 \\cdot \\gamma</span>  bits. Computationally, the verifier must first compute the tensor-expansions  <span class="math">\\bigotimes_{i=0}^{\\ell_1-1} (1-r_i,r_i)</span>  and  <span class="math">\\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i,r_i)</span> . Using the algorithm [Tha22, Lem. 3.8], the verifier can compute these using  <span class="math">m_1</span>  and  <span class="math">m_0</span>   <span class="math">\\mathcal{T}_{\\tau}</span> -multiplications, respectively. To encode the message t', the verifier must perform  <span class="math">C \\subset \\mathcal{T}_{\\iota+\\kappa}^n</span> 's encoding operation  <span class="math">2^{\\tau-\\iota}</span>  times. In addition, the verifier must perform  <span class="math">\\gamma \\cdot 2^{\\kappa} \\mathcal{T}_{\\tau}</span> -by- <span class="math">\\mathcal{T}_{\\iota}</span>  dot products, each of length  <span class="math">m_0</span> . The total cost of these latter dot-products equals that of  <span class="math">m_0 \\cdot \\gamma \\cdot 2^{\\kappa} \\cdot 2^{\\tau-\\iota}</span>   <span class="math">\\mathcal{T}_{\\iota}</span> -multiplications. Finally, the verifier must perform  <span class="math">\\gamma</span>  Merkle-path verifications. Each such verification entails hashing a column of  <span class="math">m_0</span>   <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -elements (as well as performing  <span class="math">l_1</span>  further hash evaluations, which we ignore).</p>

    <p class="text-gray-300">Adding all of these components, we obtain the following total verifier costs:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{b}</span> :  <span class="math">2^{\\tau} \\cdot m_1 + 2^{\\iota + \\kappa} \\cdot m_0 \\cdot \\gamma</span> .</li>

      <li><span class="math">\\mathfrak{T}_{\\iota}</span> :  <span class="math">m_0 \\cdot \\gamma \\cdot 2^{\\tau \\iota + \\kappa}</span> .</li>

      <li><span class="math">\\mathfrak{T}_{\\tau}</span> :  <span class="math">m_0 + m_1</span> .</li>

      <li><span class="math">\\mathfrak{Enc}</span> :  <span class="math">2^{\\tau-\\iota}</span> .</li>

      <li><span class="math">\\mathfrak{Hash}</span> .  <span class="math">\\gamma \\cdot m_0</span> .</li>

    </ul>

    <p class="text-gray-300">We pause to record to the following fundamental asymptotic guarantee:</p>

    <p class="text-gray-300"><span id="page-19-2"></span><strong>Theorem 3.14.</strong> For each fixed  <span class="math">\\iota \\in \\mathbb{N}</span> , and arbitrary  <span class="math">\\ell</span>  and  <span class="math">\\lambda</span>  in  <span class="math">\\mathbb{N}</span> , Construction 3.11 can be instantiated in such a way as to impose verifier cost  <span class="math">\\widetilde{O}\\left(\\sqrt{\\lambda \\cdot 2^{\\ell}}\\right)</span> , counting both bits transferred and bit-operations performed.</p>

    <p class="text-gray-300">Proof. Deferred to Appendix A.</p>

    <p class="text-gray-300">The analyses of Brakedown [Gol+23, Thm. 1] and Diamond and Posen [DP24, § 4.3] both measure just field-elements transferred and field-operations. Theorem 3.14 performs a sharper asymptotic analysis; it shows that—provided that it chooses  <span class="math">\\tau</span>  sufficiently carefully—Construction 3.11 in fact attains square-root verifier efficiency, in both in the security parameter and the polynomial's size, even at the level of bits.</p>

    <p class="text-gray-300">Concrete soundness. We identify and discuss, in concrete terms, the various sources of soundness error which arise throughout Theorem 3.13. We refer throughout to the parameters d, n,  <span class="math">\\gamma</span> ,  <span class="math">\\iota</span> ,  <span class="math">\\kappa</span> ,  <span class="math">\\tau</span> ,  <span class="math">m_0</span>  and  <span class="math">m_1</span> , recalling their roles in  <span class="math">\\Pi</span> .Setup.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Tensor batching error  <span class="math">\\Xi_B</span> . This is the probability, taken over the query sampler's choice of  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\leftarrow \\mathcal{T}_{\\tau}^{\\ell}</span> , that, though  <span class="math">d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, \\widehat{C}^{m_0}\\right) \\geq \\frac{d}{3}</span> , we nonetheless have  <span class="math">d\\left(u&#x27;, \\widehat{C}\\right) &lt; \\frac{d}{3}</span> , where we write  <span class="math">u&#x27; \\coloneqq \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (u_i)_{i=0}^{m_0-1}</span> . By Theorem 3.10 (see also Lemma A.1),  $\\Xi_B \\leq 2 \\cdot \\ell_0 \\cdot \\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Non-proximal per-query error  <span class="math">\\Xi_N</span> . This is the probability, taken over the verifier's choice of a single index  <span class="math">j \\leftarrow \\{0, \\dots, n-1\\}</span> , that, though  <span class="math">d\\left(u&#x27;, \\widehat{C}\\right) \\geq \\frac{d}{3}</span> , nonetheless  <span class="math">u&#x27;_j = \\mathsf{Enc}(t&#x27;)_j</span>  holds. The analysis of Lemma A.1 shows that  <span class="math">\\Xi_N \\leq 1 \\frac{d}{3 \\cdot n}</span> .</li>

      <li>Proximal per-query error  <span class="math">\\Xi_P</span> . This is the probability, taken over the verifier's choice of a single index  <span class="math">j \\leftarrow \\{0, \\ldots, n-1\\}</span> , that, in case  <span class="math">d\\left(u&#x27;, \\widehat{C}\\right) &lt; \\frac{d}{3}</span>  but the message  <span class="math">t&#x27; \\neq \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}</span>  is wrong, nonetheless  <span class="math">u&#x27;_j = \\operatorname{Enc}(t&#x27;)_j</span>  holds. The analysis of Lemma A.2 shows that  <span class="math">\\Xi_P \\leq 1 \\frac{2 \\cdot d}{3 \\cdot n}</span> .</li>

    </ul>

    <p class="text-gray-300">Putting these three sources of error together, and following the analyses of Lemmas A.1 and A.2, we define the protocol's <em>total soundness error</em> as follows:</p>

    <p class="text-gray-300"><span id="page-20-1"></span> <span class="math-block">\\Xi := \\Xi(d, n, \\gamma, \\tau, \\ell_0, \\ell_1) = \\max(\\Xi_B + \\Xi_N^{\\gamma}, \\Xi_P^{\\gamma}). \\tag{1}</span></p>

    <p class="text-gray-300">We justify this definition in the following way (in fact, this is a very rough summary of the proof of Theorem 3.13). We note that either the prover's committed matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  satisfies  <span class="math">d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, \\widehat{C}^{m_0}\\right) &lt; \\frac{d}{3}</span>  or it doesn't, then the analysis of Lemma A.1 bounds the verifier's acceptance probability from above by  <span class="math">\\Xi_B + \\Xi_N^{\\gamma}</span> . If it does, then the message list  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  is well-defined, so that t' is either correct or it's not; in that latter case, Lemma A.2 bounds the verifier's probability of acceptance by  <span class="math">\\Xi_P^{\\gamma}</span> . Barring all of these failure events, we indeed have that  <span class="math">s = t(r_0, \\dots, r_{\\ell-1})</span> . We note that we slightly simplify our treatment here by analyzing Construction 3.11 as an IOP, and ignoring the runtime of the emulator  <span class="math">\\mathcal{E}</span> , as well as the probability that  <span class="math">\\mathcal{E}</span>  aborts on a successful proof (say, because it fails to extract  <span class="math">(u_i)_{i=0}^{m_0-1}</span> ). This simplification, in the setting of concrete analysis, is justified in Brakedown [Gol+23, p. 211], for example.</p>

    <p class="text-gray-300">We define the bits of security obtained by Construction 3.11 as  <span class="math">-\\log(\\Xi)</span> .</p>

    <p class="text-gray-300">Case studies. In order to concretely assess the performance characteristics of Construction 3.11, we study various instantiations of that scheme. For comparison, we also explore various approaches based on the use of concatenated codes in Construction 3.7. In each the following examples, we set  <span class="math">\\iota := 0</span>  (that is, we commit to  <span class="math">\\mathbb{F}_2</span> -polynomials), as well as  <span class="math">\\ell := 32</span> , so that the total size of the polynomial at hand is 512 MiB. Throughout each example, we attain 100 bits of security. To standardize the case studies' respective prover complexities, we consider only codes with the fixed rate  <span class="math">\\rho := \\frac{1}{4}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-20-0"></span>Example 3.15 (Reed–Solomon code with block-level testing). We begin with the efficiency of Construction 3.11. We first remark that the alphabet size parameter  <span class="math">\\kappa \\coloneqq 4</span>  makes available only those width parameters  <span class="math">\\ell_1</span>  at most 18; indeed, the Reed–Solomon requirement  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge n<span class="math">  amounts to  </span>2^{2^{\\kappa}} =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge \\frac{1}{\\rho} \\cdot \\frac{2^{\\ell_1}}{2^{\\kappa}}<span class="math"> , or in other words  </span>2^{\\kappa} \\ge 2 + \\ell_1 - \\kappa<span class="math"> . In fact, we set  </span>\\kappa \\coloneqq 4<span class="math"> ,  </span>\\ell_0 \\coloneqq 14<span class="math">  and  </span>\\ell_1 \\coloneqq 18<span class="math">  (these choices yield the smallest possible proofs). We thus have  </span>m_1 = 2^{18}<span class="math"> ,  </span>k = 2^{14}<span class="math"> , and  </span>n = 2^{16}<span class="math"> . Setting  </span>\\tau \\coloneqq 7<span class="math"> —and using  </span>d = n - k + 1 = 2^{16} - 2^{14} + 1 = 49{,}153<span class="math"> —we compute  </span>\\Xi_B \\le 2 \\cdot 14 \\cdot \\frac{d}{2^{128}} \\approx 2^{-107.608}<span class="math"> . Moreover, we compute the non-proximal per-query error  </span>\\Xi_N \\le 1 - \\frac{d}{3 \\cdot n} \\approx 0.75<span class="math">  and the proximal per-query error  </span>\\Xi_P \\le 1 - \\frac{2 \\cdot d}{3 \\cdot n} \\approx 0.5<span class="math"> . Using a direct computation, we see that the total soundness error  </span>\\Xi<span class="math">  of equation (1) drops below  </span>2^{-100}<span class="math">  just when the number of block-queries  </span>\\gamma<span class="math">  becomes 241 or greater. Using the expression for  </span>\\mathfrak b<span class="math">  given above, we compute directly the proof size of 11.531 MiB, or about  </span>2^{26.527}$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-21-0"></span><strong>Example 3.16</strong> (Concatenated code with trivial inner code). For reference, we compare Example 3.15 to the construction whereby a trivial concatenated code—i.e., with Reed–Solomon outer code and identity inner code—is used in Construction 3.7 (i.e., without block-level testing). We again set  <span class="math">\\kappa := 4</span> ,  <span class="math">\\ell_0 := 14</span>  and  <span class="math">\\ell_1 := 18</span> . In this setting, the resulting binary code has distance d = 49,153 identical to the code of the above construction; on the other hand, its message length  <span class="math">k = 2^{18}</span>  and block length  <span class="math">n = 2^{20}</span>  are both  <span class="math">2^{\\kappa}</span> -fold higher. We thus obtain the identical batching error  <span class="math">\\Xi_B \\approx 2^{-107,608}</span> ; our non-proximal and proximal per-query errors, on the other hand, are  <span class="math">\\Xi_N = 1 - \\frac{d}{3 \\cdot n} \\approx 0.984</span>  and  <span class="math">\\Xi_P = 1 - \\frac{2 \\cdot d}{3 \\cdot n} \\approx 0.969</span> . Again calculating directly, we see that 4,402 single-column queries suffice to guarantee 100 bits of soundness. This scheme's queries are each 16-fold cheaper than Example 3.15's are; we obtain a total proof size of 12.598 MiB, or about  <span class="math">2^{26.655}</span>  bits.</p>

    <p class="text-gray-300"><span id="page-21-3"></span>Example 3.17 (Nontrivial concatenated code). We finally examine the efficiency of Construction 3.7's instantiation on a nontrivial concatenated code (i.e., with nonidentity inner code). In order to run an apples-to-apples comparison—i.e., between schemes whose prover costs are comparable—we set both our inner and our outer codes' rates to be  <span class="math">\\frac{1}{2}</span> , so that our concatenated code has rate  <span class="math">\\frac{1}{4}</span> . Specifically, we set  <span class="math">\\kappa := 4</span> , and set  <span class="math">C_{\\text{out}} \\subset \\mathcal{T}_4^{n_{\\text{out}}}</span>  to be the Reed–Solomon code  <span class="math">\\mathsf{RS}_{\\mathcal{T}_4}[2^{15}, 2^{14}]</span> ; for  <span class="math">C_{\\text{in}} \\subset \\mathcal{T}_0^{k_{\\text{in}}}</span> , we use the Reed–Muller [32, 16, 8]-code  <span class="math">\\mathsf{RM}_{\\mathcal{T}_0}[2, 5]</span> . (We note that 8 is actually the best possible distance that a binary [32, 16]-code can attain; we refer to the database of Grassl [Gra].) We see that our concatenated code satisfies  <span class="math">k=2^{18}</span>  and  <span class="math">n=2^{20}</span> , and has distance  <span class="math">d=8\\cdot(2^{14}+1)=131,080</span> . We accordingly compute  <span class="math">\\Xi_B \\leq 2\\cdot 14\\cdot \\frac{d}{2^{128}}\\approx 2^{-106.193}</span> , as well as  <span class="math">\\Xi_N=1-\\frac{d}{3\\cdot n}\\approx 0.958</span>  and  <span class="math">\\Xi_P=1-\\frac{2\\cdot d}{3\\cdot n}\\approx 0.917</span> . We calculate that 1,629 queries suffice to deliver 100 bits of soundness, and obtain a proof size of 7.182 MiB, or  <span class="math">2^{25.844}</span>  bits.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-21-2"></span>Remark 3.18. We find it plausible that, in the setting of Example 3.15, the stronger proximity gap result of Ben-Sasson, Carmon, Ishai, Kopparty, and Saraf [Ben+23, Thm. 4.1] could be brought to bear. That result guarantees that, in the Reed–Solomon setting, for  <span class="math">e \\in \\{0, \\dots, \\left\\lfloor \\frac{d-1}{2} \\right\\rfloor\\}</span>  up to the unique decoding radius, we obtain a proximity gap, albeit with the false witness probability  $\\frac{n}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  slightly worse than that of  </span>\\frac{e+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  guaranteed by [DP24, Thm. 1] (we refer to [DP24, § 2] for further comparison of these results). Of course, to apply that result to Example 3.15, we would need an analogue of Theorem 3.10 above; that is, we would need a result in the algebra setting which adapts [Ben+23, Thm. 4.1] precisely as Theorem 3.10 adapts [DP24, Thm. 2]. While we feel confident that such an adaptation should be possible, we have not undertaken it. Alternatively, a strengthening of the general result [DP24, Thm. 2] to the larger range  </span>e \\in \\{0, \\dots, \\left\\lfloor \\frac{d-1}{2} \\right\\rfloor\\}<span class="math">  would have the same effect (we note the conjecture [DP24, Conj. 1]). If either of these expedients were available, then, in Example 3.15, we would obtain the rather better proof size of 8.625 MiB, or  </span>2^{26.109}$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">In Table 1, we record the benchmarks derived above, which pertain to the case  <span class="math">\\ell = 32</span>  (and thus 512 MiB of total data), as well as benchmarks for the further case  <span class="math">\\ell = 36</span>  (corresponding to 8 GiB of total data).</p>

    <p class="text-gray-300"><span id="page-21-1"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Construction Used</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Num. Variables <span class="math">\\ell</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameters <span class="math">(\\ell_0, \\ell_1, \\kappa)</span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (MiB)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Reed–Solomon with block-level testing.</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">(14, 18, 4)</td>

            <td class="px-3 py-2 border-b border-gray-700">11.598</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(See Example 3.15.)</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">(15, 21, 5)</td>

            <td class="px-3 py-2 border-b border-gray-700">62.206</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Reed–Solomon, assum. prox-gap <span class="math">\\lfloor \\frac{d-1}{2} \\rfloor</span> .</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">(14, 18, 4)</td>

            <td class="px-3 py-2 border-b border-gray-700">8.669</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(See Remark 3.18.)</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">(15, 21, 5)</td>

            <td class="px-3 py-2 border-b border-gray-700">50.553</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Concatenated code w/ ad-hoc inner code.</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">(14, 18, 4)</td>

            <td class="px-3 py-2 border-b border-gray-700">7.278</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(See Example 3.17.)</td>

            <td class="px-3 py-2 border-b border-gray-700">36</td>

            <td class="px-3 py-2 border-b border-gray-700">(16, 20, 5)</td>

            <td class="px-3 py-2 border-b border-gray-700">33.173</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Proof size benchmarks in the setting  <span class="math">\\rho = \\frac{1}{4}</span> .</p>

    <p class="text-gray-300">In the final benchmark—that describing a concatenated code with  <span class="math">\\kappa := 5</span> —we use the ad-hoc inner [64, 32, 12]-code of Grassl [Gra] (this code is a subcode of an <em>extended BCH code</em>). As Grassl's database indicates, we are able neither to construct nor to rule out the existence of a binary [64, 32, 16]-code. The existence of just such a code would further improve the benchmark given in the last row.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4 Polynomial IOPs for Binary Tower Fields</h3>

    <p class="text-gray-300">In this section, we review and develop several interactive protocols and polynomial IOPs, which we moreover specialize to the setting of binary tower fields. We refer throughout to Chen, Bünz, Boneh and Zhang's <em>HyperPlonk</em> [CBBZ23, Def. 4.1], though we modify rather significantly that work's formalisms.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">4.1 Definitions and Notions</h3>

    <p class="text-gray-300">We fix throughout what follows a maximal tower height  <span class="math">\\tau \\in \\mathbb{N}</span> ; we understand  <span class="math">\\tau \\coloneqq \\tau(\\lambda)</span>  as depending on an available security parameter.</p>

    <p class="text-gray-300"><strong>Definition 4.1.</strong> A polynomial IOP  <span class="math">\\Pi = (\\mathcal{I}, \\mathcal{P}, \\mathcal{V})</span>  is an interactive protocol in which the parties may freely use a certain multilinear polynomial oracle, which operates as follows, on the security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span> :</p>

    <h4 id="sec-19" class="text-lg font-semibold mt-6">FUNCTIONALITY 4.2 (polynomial oracle).</h4>

    <p class="text-gray-300">A tower height  <span class="math">\\tau := \\tau(\\lambda)</span>  and a binary tower  <span class="math">\\mathcal{T}_0 \\subset \\mathcal{T}_1 \\subset \\cdots \\subset \\mathcal{T}_{\\tau}</span>  are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>On input (submit,  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , t) from  <span class="math">\\mathcal{I}</span>  or  <span class="math">\\mathcal{P}</span> , where  <span class="math">\\iota \\in \\{0, \\ldots, \\tau\\}</span> ,  <span class="math">\\ell \\in \\mathbb{N}</span> , and  <span class="math">t \\in \\mathcal{T}_{\\iota}[X_0, \\ldots, X_{\\ell-1}]^{\\leq 1}</span> , output (receipt,  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , [t]) to  <span class="math">\\mathcal{I}</span> ,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span> , where [t] is some unique handle onto the polynomial t.</li>

      <li>On input (query, [t], r) from  <span class="math">\\mathcal{V}</span> , where  <span class="math">r \\in \\mathcal{T}_{\\tau}^{\\ell}</span> , send  <span class="math">\\mathcal{V}</span>  (evaluation,  <span class="math">t(r_0, \\ldots, r_{\\ell-1})</span> ).</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-22-2"></span><strong>Definition 4.3.</strong> The polynomial IOP  <span class="math">\\Pi = (\\mathcal{I}, \\mathcal{P}, \\mathcal{V})</span>  for the indexed relation R is <em>secure</em> if, for each PPT adversary  <span class="math">\\mathcal{A}</span> , there exists an expected PPT emulator  <span class="math">\\mathcal{E}</span>  and a negligible function negl, such that, for each security parameter  <span class="math">\\lambda \\in \\mathbb{N}</span>  and each pair (i, x), provided that the protocol is run on the security parameter  <span class="math">\\lambda</span> , writing  <span class="math">\\mathsf{vp} := \\mathcal{I}(i)</span>  and  <span class="math">\\mathsf{w} \\leftarrow \\mathcal{E}^{\\mathcal{A}}(i, x)</span> , we have  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\langle \\mathcal{A}(i, x), \\mathcal{V}(\\mathsf{vp}, x) \\rangle = 1] - \\Pr[R(i, x, w) = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq \\mathsf{negl}(\\lambda)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that we grant  <span class="math">\\mathcal{E}</span>  full internal access to  <span class="math">\\mathcal{A}</span> . In particular,  <span class="math">\\mathcal{E}</span>  may intercept all outbound messages sent by  <span class="math">\\mathcal{A}</span> , including those messages (submit,  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , t)  <span class="math">\\mathcal{A}</span>  sends directly to the polynomial oracle, as well as, of course, those it sends to  <span class="math">\\mathcal{V}</span> . We note that, in practice, our emulator  <span class="math">\\mathcal{E}</span>  will be <em>straight-line</em> (i.e., non-rewinding) and strict polynomial-time, though these latter properties aren't required by Definition 4.3.</p>

    <p class="text-gray-300">It is shown by Bünz, Fisch and Szepieniec [BFS20,  <span class="math">\\S</span>  E] that, by inlining an extractable polynomial commitment scheme (in the sense of Definition 3.5) into a secure polynomial IOP (in the sense of Definition 4.3), one obtains a secure argument of knowledge for the relation R.</p>

    <p class="text-gray-300"><strong>Definition 4.4.</strong> For parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\mu</span>  in  <span class="math">\\mathbb{N}</span> ,  <span class="math">\\ell</span> -variate,  <span class="math">\\mu</span> -ary polynomial predicate over  <span class="math">\\mathcal{T}_{\\iota}</span>  is a boolean-valued function  <span class="math">\\Phi_{\\iota,\\ell}: \\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]^{\\mu} \\to \\{0,1\\}.</span></p>

    <p class="text-gray-300"><strong>Example 4.5.</strong> We record certain key polynomial predicates, roughly following HyperPlonk [CBBZ23].</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. Query. On parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> ,  <span class="math">s \\in \\mathcal{T}_{\\tau}</span> , and  <span class="math">r \\in \\mathcal{T}_{\\tau}^{\\ell}</span> , sends  <span class="math">\\operatorname{Query}(r,s)_{\\iota,\\ell} : T \\mapsto T(r_0,\\ldots,r_{\\ell-1}) = s</span> .</li>

      <li>2. Sum. On parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span>  and  <span class="math">e \\in \\mathcal{T}_{\\iota}</span> , sends  <span class="math">\\mathsf{Sum}(e)_{\\iota,\\ell} : T \\mapsto \\sum_{v \\in \\mathcal{B}_{\\ell}} T(v) = e</span> .</li>

      <li>3. <strong>Zero.</strong> On parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> , sends  <span class="math">\\mathsf{Zero}_{\\iota,\\ell}: T \\mapsto \\bigwedge_{v \\in \\mathcal{B}_{\\ell}} T(v) = 0</span> .</li>

      <li>4. <strong>Product.</strong> On parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> , the binary product predicate sends  <span class="math">\\mathsf{Product}_{\\iota,\\ell}:(T,U)\\mapsto \\prod_{v\\in\\mathcal{B}_\\ell}T(v)=\\prod_{v\\in\\mathcal{B}_\\ell}U(v)\\wedge\\bigwedge_{v\\in\\mathcal{B}_\\ell}(T(v)=0\\iff U(v)=0).</span></li>

      <li>5. <strong>Multiset.</strong> On parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\mu</span>  in  <span class="math">\\mathbb{N}</span> , the  <span class="math">2 \\cdot \\mu</span> -ary multiset predicate sends  <span class="math">\\mathsf{Multiset}(\\mu)_{\\iota,\\ell} : (T_0, \\ldots, T_{\\mu-1}, U_0, \\ldots, U_{\\mu-1}) \\mapsto \\{(T_0(v), \\ldots, T_{\\mu-1}(v)) \\mid v \\in \\mathcal{B}_\\ell\\} = \\{(U_0(v), \\ldots, U_{\\mu-1}(v)) \\mid v \\in \\mathcal{B}_\\ell\\},</span>  where we understand both objects on the right-hand side as multisets (counted with multiplicity).</li>

      <li>6. <strong>Permutation.</strong> On parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\mu</span>  in  <span class="math">\\mathbb{N}</span> , and a bijection  <span class="math">\\sigma: \\{0, \\ldots, \\mu 1\\} \\times \\mathcal{B}_{\\ell} \\to \\{0, \\ldots, \\mu 1\\} \\times \\mathcal{B}_{\\ell}</span> , the  <span class="math">\\mu</span> -ary permutation predicate sends  <span class="math">\\mathsf{Permutation}(\\sigma)_{\\iota,\\ell}: (T_0, \\ldots, T_{\\mu-1}) \\mapsto \\bigwedge_{(i,v)\\in\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_{\\ell}} T_{i&#x27;}(v&#x27;) = T_i(v)</span> , where we write  <span class="math">(i&#x27;,v&#x27;) \\coloneqq \\sigma(i,v)</span>  for each  <span class="math">(i,v)\\in\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_{\\ell}</span> .</li>

      <li>7. Lookup. On parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> , sends Lookup<sub> <span class="math">\\iota,\\ell</span> </sub>:  <span class="math">(T,U)\\mapsto \\bigwedge_{v\\in\\mathcal{B}_{\\ell}}\\exists v&#x27;\\in\\mathcal{B}_{\\ell}:U(v)=T(v&#x27;)</span> .</li>

    </ul>

    <p class="text-gray-300">We note that each predicate  <span class="math">\\mathsf{Query}(r,s)_{\\iota,\\ell}</span>  can be evaluated directly by the verifier, on any handle [t], by means of a single query to the polynomial oracle.</p>

    <p class="text-gray-300">Our product predicate diverges from HyperPlonk's [CBBZ23, § 3.3] in various respects. Their predicate requires that the "denominator" U be everywhere-nonzero on the cube, as well as that the product  <span class="math">\\prod_{v \\in \\mathcal{B}_{\\ell}} \\frac{T(v)}{U(v)}</span>  equal a prescribed value. We simplify that predicate by specializing this prescribed value to 1; on the other hand, we also more correctly handle the case of "division by zero" (their protocol actually fails to assert that U is everywhere-nonvanishing on the cube). We discuss this matter further in Remark 4.15 below. Finally, we present a permutation predicate slightly more sophisticated than HyperPlonk's [CBBZ23, § 3.5]; specifically, ours supports permutations which act across multiple "columns".</p>

    <p class="text-gray-300">The following notational abstraction figures extensively in what follows.</p>

    <p class="text-gray-300"><span id="page-23-3"></span><strong>Definition 4.6.</strong> An  <span class="math">\\ell</span> -variate virtual polynomial over  <span class="math">\\mathcal{T}_{\\iota}</span>  is a list  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span>  of handles, each representing a polynomial defined over  <span class="math">\\mathcal{T}_{\\iota}</span> , together with an arithmetic circuit, whose leaves are either indeterminates in the list  <span class="math">X_0, \\ldots X_{\\ell-1}</span>  or else constants in  <span class="math">\\mathcal{T}_{\\iota}</span> , and in which we permit not just the binary gates + and  <span class="math">\\times</span> , but moreover, for each  <span class="math">i \\in \\{0, \\ldots, \\mu-1\\}</span> , the  <span class="math">\\ell_i</span> -ary gate  <span class="math">t_i(X_0, \\ldots, X_{\\ell_i-1})</span>  (assuming that  <span class="math">t_i</span>  is  <span class="math">\\ell_i</span> -variate). We write  <span class="math">T \\in \\mathcal{T}_{\\iota}[X_0, \\ldots, X_{\\ell-1}]</span>  for the polynomial represented by the circuit, and [T] for the virtual polynomial.</p>

    <p class="text-gray-300">We note that each virtual polynomial [T] may be evaluated at any input in  <span class="math">\\mathcal{T}_{\\iota}^{\\ell}</span> —albeit in general, not efficiently—by any machine that can query the handles  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span> . We now treat efficient protocols for virtual polynomials.</p>

    <p class="text-gray-300"><span id="page-23-1"></span><strong>Definition 4.7.</strong> A virtual polynomial protocol for the  <span class="math">\\mu</span> -ary polynomial predicate  <span class="math">\\Phi_{\\iota,\\ell}</span>  is an interactive protocol  <span class="math">\\Sigma = (\\mathcal{P}, \\mathcal{V})</span>  which takes as common input a list  <span class="math">([T_0], \\ldots, [T_{\\mu-1}])</span>  of  <span class="math">\\ell</span> -variate virtual polynomials. The protocol  <span class="math">\\Sigma</span>  is secure with respect to  <span class="math">\\Phi_{\\iota,\\ell}</span>  if, for each PPT adversary  <span class="math">\\mathcal{A}</span> , there is a negligible function negl for which, for each  <span class="math">\\lambda \\in \\mathbb{N}</span>  and each input list  <span class="math">([T_0], \\ldots, [T_{\\mu-1}])</span> , if the protocol is run on the security parameter  <span class="math">\\lambda</span> , then we have  <span class="math">\\Pr[\\langle \\mathcal{A}(T_0, \\ldots, T_{\\mu-1}), \\mathcal{V}([T_0], \\ldots, [T_{\\mu-1}]) \\rangle = 1 \\land \\Phi_{\\iota,\\ell}(T_0, \\ldots, T_{\\mu-1}) = 0] \\leq \\mathsf{negl}(\\lambda)</span> .</p>

    <p class="text-gray-300">We highlight, in particular, the special case of Definition 4.7 in which  <span class="math">\\Phi_{\\iota,\\ell}</span>  takes the form  <span class="math">\\mathsf{Query}(r,s)_{\\iota,\\ell}</span> .</p>

    <p class="text-gray-300"><strong>Definition 4.8.</strong> An evaluation protocol for the  <span class="math">\\ell</span> -variate virtual polynomial [T] over  <span class="math">\\mathcal{T}_{\\iota}</span>  is a family of virtual polynomial protocols, parameterized by  <span class="math">r \\in \\mathcal{T}_{\\tau}^{\\ell}</span>  and  <span class="math">s \\in \\mathcal{T}_{\\tau}</span> , for the predicates  <span class="math">\\mathsf{Query}(r,s)_{\\iota,\\ell}</span>  on the input [T].</p>

    <p class="text-gray-300">In practice, we often attach to each virtual polynomial T an appropriate evaluation protocol, and refer to the resulting bundle as an evaluable virtual polynomial.</p>

    <p class="text-gray-300"><span id="page-23-0"></span><strong>Example 4.9</strong> (Compositions). A certain simple sort of virtual polynomial arises from a list of  <span class="math">\\ell</span> -variate handles  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span>  and a  <span class="math">\\mu</span> -variate composition polynomial  <span class="math">g \\in \\mathcal{T}_{\\ell}[X_0, \\ldots, X_{\\mu-1}]</span> . From these, we obtain the composition virtual polynomial  <span class="math">T := g(t_0(X_0, \\ldots, X_{\\ell-1}), \\ldots, t_{\\mu-1}(X_0, \\ldots, X_{\\ell-1}))</span> . We note that [T] admits an efficient evaluation protocol, at least if g is succinct; indeed, to decide the predicate Query <span class="math">(r, s)_{\\ell, \\ell}</span> ,  <span class="math">\\mathcal{V}</span>  may query each of the handles at r, evaluate g itself on the results, and finally compare the result to s.</p>

    <p class="text-gray-300"><span id="page-23-2"></span>Example 4.10 (Piecewise multilinears). A further sort of virtual polynomial arises in the following way. For integers  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\mu</span>  in  <span class="math">\\mathbb{N}</span> , where  <span class="math">\\mu = 2^{\\alpha}</span>  is a power of 2, say, and  <span class="math">\\ell</span> -variate handles  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span>  over  <span class="math">\\mathcal{T}_{\\iota}</span> , we introduce a piecewise function  <span class="math">T \\in \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell+\\alpha}}</span> , defined so that, for each  <span class="math">v \\in \\mathcal{B}_{\\ell}</span>  and  <span class="math">u \\in \\mathcal{B}_{\\alpha}</span> ,  <span class="math">T(u \\parallel v) = t_{\\{u\\}}(v)</span>  holds (we recall the identification  <span class="math">\\{u\\} \\coloneqq \\sum_{i=0}^{\\alpha-1} 2^i \\cdot u_i</span> ). We finally identify T with its multilinear extension  <span class="math">T(X_0, \\ldots, X_{\\ell+\\alpha-1}) \\in \\mathcal{T}_{\\iota}[X_0, \\ldots, X_{\\ell+\\alpha-1}]^{\\leq 1}</span> . We note that T defines a valid virtual polynomial in the handles  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span> ; moreover, T is evaluable, provided  <span class="math">\\mu</span>  is small. Indeed, to decide Query <span class="math">(r, s)_{\\iota,\\ell+\\alpha}</span> , say,  <span class="math">\\mathcal{V}</span>  may destructure  <span class="math">(r_0, \\ldots, r_{\\ell+\\alpha-1}) \\coloneqq r</span> , query the polynomials  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span>  at  <span class="math">(r_{\\alpha}, \\ldots, r_{\\ell+\\alpha-1})</span> , obtaining the results  <span class="math">s_0, \\ldots, s_{\\mu-1}</span> , say, and finally output  <span class="math">s \\stackrel{?}{=} \\bigotimes_{i=0}^{\\alpha-1} (1-r_i, r_i) \\cdot (s_i)_{i=0}^{\\mu-1}</span>  (here,  <span class="math">\\bigotimes_{i=0}^{\\alpha-1} (1-r_i, r_i)</span>  is a tensor product expansion in the sense of Subsection 2.2, and can be computed in  <span class="math">\\Theta(\\mu)</span>  time). The correctness of this procedure is essentially [Tha22, Lem. 3.6]. We write  <span class="math">[T] \\coloneqq \\mathtt{merge}([t_0], \\ldots, [t_{\\mu-1}])</span>  for this construction.</p>

    <p class="text-gray-300">We finally note that virtual polynomials can be composed. Indeed, upon replacing some among the handles  <span class="math">[t_0], \\ldots, [t_{\\mu-1}]</span>  of some virtual polynomial [T] with further virtual polynomials, we may nonetheless "unroll" the resulting object into a proper virtual polynomial [T'] in its own right. Finally, if [T] and all of the sub-virtual polynomials are efficiently evaluable, then the composed virtual polynomial [T'] also is.</p>

    <h4 id="sec-20" class="text-lg font-semibold mt-6">4.2 Prior Virtual Polynomial Protocols</h4>

    <p class="text-gray-300">We develop various virtual protocols, following Thaler [Tha22] and HyperPlonk [CBBZ23, § 3]. We adapt generally without great change that latter work's techniques, though we variously clarify and refine them.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><strong>Sumcheck.</strong> The sumcheck protocol is a virtual polynomial protocol for the predicate  <span class="math">\\mathsf{Sum}(e)_{\\iota,\\ell}: T \\mapsto \\sum_{v \\in \\mathcal{B}_\\ell} T(v) = e</span> . Internally, on input an evaluable,  <span class="math">\\ell</span> -variate virtual polynomial [T], sumcheck invokes [T]'s implicit  <span class="math">\\mathsf{Query}(r,s)_{\\iota,\\ell}</span>  protocol, on parameters  <span class="math">r \\in \\mathcal{T}^\\ell_\\tau</span>  and  <span class="math">s \\in \\mathcal{T}_\\tau</span>  derived during the course of the sumcheck. The definition of the sumcheck protocol, as well as a proof that it securely evaluates  <span class="math">\\mathsf{Sum}(e)_{\\iota,\\ell}</span>  in the sense of Definition 4.7, appear in Thaler [Tha22, § 4.1]. The protocol's soundness error is at most  $\\frac{\\ell \\cdot d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , where d is the maximum individual degree exhibited by any of T&#x27;s variables (plus the error inherent to [T]&#x27;s evaluation protocol). We emphasize that the known, highly-efficient algorithms for the sumcheck protocol&#x27;s prover require that [T] take the particular form given in Example 4.9 (i.e., that [T] be a composition of multilinears); we refer to  </span>[\\mathsf{Tha22}$ , Lem. 4.5] for a discussion of these algorithms.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Zerocheck.</strong> We recall the predicate  <span class="math">\\mathsf{Zero}_{\\iota,\\ell}: T \\mapsto \\bigwedge_{v \\in \\mathcal{B}_{\\ell}} T(v) = 0</span> , as well as the <em>zerocheck</em> protocol of HyperPlonk [CBBZ23, § 3.2] (see also <em>Spartan</em> [Set20]).</p>

    <h4 id="sec-21" class="text-lg font-semibold mt-6">PROTOCOL 4.11 (Zerocheck).</h4>

    <p class="text-gray-300">Parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span>  and an  <span class="math">\\ell</span> -variate virtual polynomial [T] over  <span class="math">\\mathcal{T}_{\\iota}</span>  is fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  samples  <span class="math">r \\leftarrow \\mathcal{T}_{\\ell}^{\\tau}</span> , and sends r to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run the sumcheck protocol, with statement 0, on the virtual polynomial  <span class="math">[T&#x27;] := T(X_0, \\ldots, X_{\\ell-1}) \\cdot \\widetilde{eq}(r_0, \\ldots, r_{\\ell-1}, X_0, \\ldots, X_{\\ell-1}).</span></li>

    </ul>

    <p class="text-gray-300">We note first of all that [T'] is a valid virtual polynomial, which moreover admits its own evaluation protocol. Indeed, to decide  <span class="math">\\operatorname{Query}(r&#x27;,s&#x27;)_{\\tau,\\ell}(T&#x27;)</span> , say,  <span class="math">\\mathcal V</span>  may, after first locally evaluating  <span class="math">a\\coloneqq \\widetilde{\\operatorname{eq}}(r,r&#x27;)</span> —which takes  <span class="math">O(\\ell)</span>  work—immediately return  <span class="math">s&#x27;\\stackrel{?}{=}0</span>  in case a=0, and otherwise proceed with the appropriate protocol (i.e., that attached to [T]) deciding  <span class="math">\\operatorname{Query}\\left(r&#x27;,\\frac{s&#x27;}{a}\\right)_{r,\\ell}(T)</span> .</p>

    <p class="text-gray-300"><strong>Theorem 4.12.</strong> Protocol 4.11 securely decides the predicate  <span class="math">\\mathsf{Zero}_{\\iota,\\ell}</span>  on T.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. Assuming that  <span class="math">\\mathsf{Zero}_{\\iota,\\ell}(T) = 0</span> , we show that  <span class="math">\\mathsf{Sum}(0)_{\\tau,\\ell}(T&#x27;) = 1</span>  holds with negligible probability over  <span class="math">\\mathcal{V}</span> 's random coins. Our hypothesis implies precisely that T's multilinear extension  <span class="math">\\widetilde{T}(X_0,\\ldots,X_{\\ell-1}) = \\sum_{v \\in \\mathcal{B}_\\ell} T(v) \\cdot \\widetilde{\\mathsf{eq}}(X_0,\\ldots,X_{\\ell-1},v_0,\\ldots,v_{\\ell-1})</span>  is not identically zero. By the Schwartz-Zippel lemma, the probability, over  <span class="math">\\mathcal{V}</span> 's choice of  <span class="math">r \\leftarrow \\mathcal{T}_\\tau^\\ell</span> , that  <span class="math">\\widetilde{T}(r) = 0</span>  is thus at most  $\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_\\tau</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . On the other hand, if  </span>\\widetilde{T}(r) \\neq 0<span class="math"> , then  </span>\\sum_{v \\in \\mathcal{B}_\\ell} T(v) \\cdot \\widetilde{\\mathsf{eq}}(r_0,\\ldots,r_{\\ell-1},v_0,\\ldots,v_{\\ell-1}) \\neq 0<span class="math">  holds, so that  </span>\\mathsf{Sum}(0)_{\\tau,\\ell}(T')<span class="math">  is false, as required.  </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The soundness error of the zerocheck protocol thus  $\\frac{\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} + \\frac{(d+1)\\cdot\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> , where d, again, is the maximum individual degree exhibited by any of T&#x27;s variables (plus, again, the error inherent to [T]&#x27;s implicit evaluation protocol). The first of these two terms is a zerocheck-specific soundness error; the term  </span>\\frac{(d+1)\\cdot\\ell}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$  arises from zerocheck's internal use of the sumcheck on [T'].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Product check.</strong> We now record a protocol for the product predicate  <span class="math">\\mathsf{Product}_{\\iota,\\ell}: (T,U) \\mapsto \\prod_{v \\in \\mathcal{B}_{\\ell}} T(v) = \\prod_{v \\in \\mathcal{B}_{\\ell}} U(v) \\land \\bigwedge_{v \\in \\mathcal{B}_{\\ell}} (T(v) = 0 \\iff U(v) = 0)</span>  above, roughly following Setty and Lee's <em>Quarks</em> [SL20, § 5] and HyperPlonk [CBBZ23, § 3.3].</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">PROTOCOL 4.13 (Product check).</h4>

    <p class="text-gray-300">Parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> , and  <span class="math">\\ell</span> -variate virtual polynomials [T] and [U] over  <span class="math">\\mathcal{T}_{\\iota}</span> , are fixed.</p>

    <p class="text-gray-300">•  <span class="math">\\mathcal{P}</span>  defines the function  <span class="math">f \\in \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span>  as follows. For each  <span class="math">v \\in \\mathcal{B}_{\\ell}</span> ,  <span class="math">\\mathcal{P}</span>  sets  <span class="math">f(v) := \\frac{T(v)}{U(v)}</span>  if  <span class="math">U(v) \\neq 0</span>  and</p>

    <p class="text-gray-300">f(v) := 1 otherwise.  <span class="math">\\mathcal{P}</span>  submits (submit,  <span class="math">\\iota, \\ell + 1, f&#x27;</span> ) to the oracle, where  <span class="math">f&#x27; \\in \\mathcal{T}_{\\iota}[X_0, \\ldots, X_{\\ell}]^{\\leq 1}</span>  is such that, for each  <span class="math">v \\in \\mathcal{B}_{\\ell}</span> , both  <span class="math">f&#x27;(v \\parallel 0) = f(v)</span>  and  <span class="math">f&#x27;(v \\parallel 1) = f&#x27;(0 \\parallel v) \\cdot f&#x27;(1 \\parallel v)</span>  hold.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Upon receiving (receipt,  <span class="math">\\iota</span> ,  <span class="math">\\ell+1</span> , [f']) from the oracle,  <span class="math">\\mathcal V</span>  submits (query, [f'],  <span class="math">(0,1,\\ldots,1)</span> ) to the oracle;  <span class="math">\\mathcal V</span>  requires that the response (evaluation,  <span class="math">f&#x27;(0,1,\\ldots,1)</span> ) satisfy  <span class="math">f&#x27;(0,1,\\ldots,1)\\stackrel{?}{=}1</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  define an  <span class="math">\\ell + 1</span> -variate virtual polynomial [T'] as follows:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">[T&#x27;] \\coloneqq \\mathtt{merge}([T], [f&#x27;](\\cdot \\parallel 1)) - \\mathtt{merge}([U], [f&#x27;](0 \\parallel \\cdot)) \\cdot \\mathtt{merge}([f&#x27;](\\cdot \\parallel 0), [f&#x27;](1 \\parallel \\cdot)).</span></div>

    <p class="text-gray-300"> <span class="math">{\\mathcal P}</span>  and  <span class="math">{\\mathcal V}</span>  run a zerocheck on the virtual polynomial [T'].</p>

    <p class="text-gray-300">Above, the virtual polynomial expression  <span class="math"><a href="\\cdot \\parallel 0">f&#x27;</a></span>  denotes the  <span class="math">\\ell</span> -variate partial evaluation of [f'] which specializes that polynomial's last variable to 0; its variants are analogous.</p>

    <p class="text-gray-300">We modify the protocol given in [CBBZ23, § 3.3] in two distinct ways. On the one hand, our prover constructs the auxiliary function f in such a way as to appropriately handle the vanishing of the "denominator" U within the cube; we discuss this issue further in Remark 4.15. Separately, we define the virtual polynomial [T'] above—that is, the target of the zerocheck reduction—differently than does [CBBZ23, § 3.3], as we presently explain. The work [CBBZ23, § 3.3] sets (adapting their notation to ours)  <span class="math">[T&#x27;] := \\text{merge}([T] - [U] \\cdot <a href="\\cdot \\parallel 0">f&#x27;</a>, <a href="\\cdot \\parallel 1">f&#x27;</a> - <a href="0 \\parallel \\cdot">f&#x27;</a> \\cdot <a href="1 \\parallel \\cdot">f&#x27;</a>)</span> . While this construction is correct—and in fact agrees with our [T'] identically on  <span class="math">\\mathcal{B}_{\\ell+1}</span> —it suffers from the defect whereby [T'] is not a composition of multilinears in the sense of Example 4.9 (even if T and U are themselves multilinear), and so fails to admit an obvious efficient sumcheck. Our construction remedies this issue, in that our [T'] is a composition of multilinears, at least if T and U are themselves multilinear. We emphasize that our protocol is correct and secure regardless of T and U; on the other hand, the efficiency of its implementation may require that T and U be multilinear (as they will be in our applications below).</p>

    <h3 id="sec-23" class="text-xl font-semibold mt-8"><strong>Theorem 4.14.</strong> Protocol 4.13 securely decides the predicate <span class="math">Product_{\\iota,\\ell}</span> on [T] and [U].</h3>

    <p class="text-gray-300">Proof. Assuming that  <span class="math">\\mathcal{V}</span>  accepts and that  <span class="math">\\mathsf{Zero}_{\\iota,\\ell+1}(T&#x27;)=1</span> , where T' is the virtual polynomial constructed during Protocol 4.13, we show that  <span class="math">\\mathsf{Product}_{\\iota,\\ell}(T,U)=1</span>  holds with probability 1. It follows directly from the definition of merge that, under our hypothesis  <span class="math">\\mathsf{Zero}_{\\iota,\\ell+1}(T&#x27;)=1</span>  we have, for each  <span class="math">v\\in\\mathcal{B}_\\ell</span> , that both  <span class="math">T(v)=U(v)\\cdot f&#x27;(v\\parallel 0)</span>  and  <span class="math">f&#x27;(v\\parallel 1)=f&#x27;(0\\parallel v)\\cdot f&#x27;(1\\parallel v)</span>  hold. This latter equality, in light of [SL20, Lem 5.1], implies that  <span class="math">\\prod_{v\\in\\mathcal{B}_\\ell}f&#x27;(v\\parallel 0)=f&#x27;(0,1,\\ldots,1)</span> , which in turn equals 1 whenever  <span class="math">\\mathcal V</span>  accepts. Taking the product of the former equality over all  <span class="math">v\\in\\mathcal{B}_\\ell</span> , we thus conclude immediately that  <span class="math">\\prod_{v\\in\\mathcal{B}_\\ell}T(v)=\\prod_{v\\in\\mathcal{B}_\\ell}U(v)</span> . Separately, from the relation  <span class="math">\\prod_{v\\in\\mathcal{B}_\\ell}f&#x27;(v\\parallel 0)=1</span> , we conclude that, for each  <span class="math">v\\in\\mathcal{B}_\\ell</span> ,  <span class="math">f&#x27;(v\\parallel 0)</span>  is individually nonzero, so that the guarantee  <span class="math">T(v)=U(v)\\cdot f&#x27;(v\\parallel 0)</span>  in particular implies  <span class="math">T(v)=0\\iff U(v)=0</span> .</p>

    <p class="text-gray-300">The product check protocol—once fully unrolled—makes just one query each to [T] and [U]. Its soundness error is thus that of the zerocheck protocol (when run on [T']), together with whatever error arises from [T] [U]'s respective implicit query protocols.</p>

    <p class="text-gray-300"><span id="page-25-0"></span>Remark 4.15. We compare our treatment of the product and multiset predicates to HyperPlonk's [CBBZ23, §§ 3.3–3.4]. HyperPlonk's product protocol [CBBZ23, § 3.3] purports to securely decide the predicate  <span class="math">(T,U)\\mapsto \\bigwedge_{v\\in\\mathcal{B}_\\ell}U(v)\\neq 0 \\wedge \\prod_{v\\in\\mathcal{B}_\\ell}\\frac{T(v)}{U(v)}=e</span> , where  <span class="math">e\\in\\mathcal{T}_\\iota</span>  is a statement. In words, HyperPlonk's stated predicate requires that the denominator U be nowhere-vanishing on the cube, as well as that the product, over the cube, of the pointwise quotient between T and U equal e. In actuality, that protocol decides a more-complicated predicate, as we now explain. The predicate actually decided by that protocol allows U to vanish on the cube, albeit with caveats. Indeed, it requires in that case merely that the numerator T also vanish wherever U does, as well as that, if U happens to vanish anywhere, then T and U fulfill a weaker variant of the product relationship whereby, if  <span class="math">e\\neq 0</span> , then T is nonzero wherever U is. In simple terms, by setting T and U both equal to 0 at  <span class="math">v^*\\in\\mathcal{B}_\\ell</span> , say, the prover may cause the verifier to accept for arbitrary e (provided, again, that T is nonzero wherever U is, a circumstance which the prover can easily arrange). This attack breaks the security of [CBBZ23, § 3.3] as stated. We note that, in this situation, our relation  <span class="math">\\prod_{v\\in\\mathcal{B}_\\ell}T(v)=\\prod_{v\\in\\mathcal{B}_\\ell}U(v)\\wedge\\bigwedge_{v\\in\\mathcal{B}_\\ell}(T(v)=0\\iff U(v)=0)</span>  does hold, while HyperPlonk's does not; the issue is an illegal "division by 0". In fact, our relation Product,  <span class="math">\\ell</span>  above is precisely the specialization of the "complicated" relation just described to the case  <span class="math">\\ell</span> := 1 (where significant simplifications emerge).</p>

    <p class="text-gray-300"><span id="page-26-1"></span>Remark 4.16. Were we to remove the conjunct  <span class="math">\\bigwedge_{v \\in \\mathcal{B}_{\\ell}} (T(v) = 0 \\iff U(v) = 0)</span>  from the predicate Product<sub> <span class="math">\\iota,\\ell</span> </sub> above, Protocol 4.13 would cease to be complete. Indeed, upon initiating Protocol 4.13 on polynomials T and U for which, at the point  <span class="math">v^<em> \\in \\mathcal{B}_{\\ell}</span>  let's say,  <span class="math">U(v^</em>) \\neq 0</span>  and  <span class="math">T(v^<em>) = 0</span>  both held—and for which  <span class="math">\\prod_{v \\in \\mathcal{B}_{\\ell}} T(v) = \\prod_{v \\in \\mathcal{B}_{\\ell}} U(v)</span>  moreover held, let's say (so that U(v) = 0 for some  <span class="math">v \\in \\mathcal{B}_{\\ell} \\setminus \\{v^</em>\\}</span> )— <span class="math">\\mathcal{P}</span>  would find itself unable to generate a passing proof. Indeed, to pass,  <span class="math">\\mathcal{P}</span>  would have to set  <span class="math">f&#x27;(v^<em> \\parallel 0) = 0</span> ; this would necessitate, in turn, that  <span class="math">\\prod_{v \\in \\mathcal{B}_{\\ell}} f&#x27;(v \\parallel 0) = f&#x27;(0, 1, \\ldots, 1) = 0</span> . Separately, assuming  <span class="math">U(v^</em>) = 0</span>  and  <span class="math">T(v^<em>) \\neq 0</span> ,  <span class="math">\\mathcal{P}</span>  would become unable to select  <span class="math">f&#x27;(v^</em> \\parallel 0)</span>  so as to cause  <span class="math">T(v^<em>) = U(v^</em>) \\cdot f&#x27;(v^* \\parallel 0)</span>  to hold.</p>

    <p class="text-gray-300"><strong>Multiset check.</strong> We recall the  <span class="math">2 \\cdot \\mu</span> -ary multiset predicate  <span class="math">\\mathsf{Multiset}(\\mu)_{\\iota,\\ell} : (T_0, \\dots, T_{\\mu-1}, U_0, \\dots, U_{\\mu-1}) \\mapsto \\{(T_0(v), \\dots, T_{\\mu-1}(v)) \\mid v \\in \\mathcal{B}_\\ell\\} = \\{(U_0(v), \\dots, U_{\\mu-1}(v)) \\mid v \\in \\mathcal{B}_\\ell\\}, \\text{ where the equality is of multisets. Hyper-Plonk [CBBZ23, § 3.4] defines a protocol for &lt;math&gt;\\mathsf{Multiset}(\\mu)_{\\iota,\\ell}</span>  in two steps, first by reducing  <span class="math">\\mathsf{Multiset}(1)_{\\iota,\\ell}</span>  to  <span class="math">\\mathsf{Product}_{\\iota,\\ell}</span> , and then by reducing  <span class="math">\\mathsf{Multiset}(\\mu)_{\\iota,\\ell}</span> , for k > 1, to  <span class="math">\\mathsf{Multiset}(1)_{\\iota,\\ell}</span> . Though our treatment is similar to HyperPlonk's, we reproduce the details for self-containedness.</p>

    <p class="text-gray-300"><span id="page-26-0"></span>PROTOCOL 4.17 (1-dimensional multiset check [CBBZ23, § 3.4]).</p>

    <p class="text-gray-300">Parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span>  and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span> , and  <span class="math">\\ell</span> -variate virtual polynomials  <span class="math">[T_0]</span>  and  <span class="math">[U_0]</span>  over  <span class="math">\\mathcal{T}_{\\iota}</span> , are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{V}</span>  samples  <span class="math">r \\leftarrow \\mathcal{T}_{\\tau}</span> , and sends r to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a product check on the virtual polynomials  <span class="math">[T&#x27;] := r [T_0]</span>  and  <span class="math">[U&#x27;] := r [U_0]</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 4.18.</strong> Protocol 4.17 securely decides the predicate Multiset(1)<sub> <span class="math">\\iota,\\ell</span> </sub> on  <span class="math">[T_0]</span>  and  <span class="math">[U_0]</span> .</p>

    <p class="text-gray-300">Proof. We follow [CBBZ23, Thm. 3.4], with appropriate adaptations. Assuming Multiset(1)<sub> <span class="math">\\iota,\\ell</span> </sub>( <span class="math">T_0,U_0</span> ) = 0, we argue that  <span class="math">\\mathsf{Product}_{\\tau,\\ell}(T&#x27;,U&#x27;)=1</span>  holds with negligible probability over the verifier's random coins. Our hypothesis entails directly that the degree-2<sup> <span class="math">\\ell</span> </sup>, univariate polynomials  <span class="math">\\widehat{T}(Y) \\coloneqq \\prod_{v \\in \\mathcal{B}_{\\ell}} (Y - T_0(v))</span>  and  <span class="math">\\widehat{U}(Y) \\coloneqq \\prod_{v \\in \\mathcal{B}_{\\ell}} (Y - U_0(v))</span> , which we now view as elements of  <span class="math">\\mathcal{T}_{\\tau}[Y]</span> , are unequal. We see that the difference  <span class="math">\\widehat{T}(Y) - \\widehat{U}(Y)</span>  is not identically zero, and moreover of degree at most 2<sup> <span class="math">\\ell</span> </sup>; we write  <span class="math">R \\subset \\mathcal{T}_{\\tau}</span>  for its roots. If  <span class="math">r \\not\\in R</span> , then  <span class="math">\\prod_{v \\in \\mathcal{B}_{\\ell}} (r - T_0(v)) \\ne \\prod_{v \\in \\mathcal{B}_{\\ell}} (r - U_0(v))</span> , so that  <span class="math">\\mathsf{Product}_{\\tau,\\ell}(T&#x27;,U&#x27;)=0</span>  necessarily holds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Remark 4.19. The conjunct  <span class="math">\\bigwedge_{v \\in \\mathcal{B}_{\\ell}}(T(v) = 0 \\iff U(v) = 0)</span>  in our product predicate—which serves to make our product check Protocol 4.13 complete (see Remark 4.16)—unfortunately makes Protocol 4.17 incomplete, albeit with negligible probability. Indeed, assuming that  <span class="math">T_0</span>  and  <span class="math">U_0</span>  are such that Multiset,  <span class="math">\\ell(T_0, U_0) = 1</span> , the polynomials T' and U' produced during Protocol 4.17 fail to satisfy Product,  <span class="math">\\ell</span>  if and only if, for some  <span class="math">v^* \\in \\mathcal{B}_{\\ell}</span>  for which  <span class="math">T_0(v) \\neq U_0(v)</span> , the verifier's random scalar r satisfies  <span class="math">r = T_0(v)</span>  or  <span class="math">r = U_0(v)</span> . This event in turn can happen with probability at most  $\\frac{2^{\\ell}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , which is negligible. An identical issue affects HyperPlonk's one-dimensional multiset check [CBBZ23, § 3.4] (and, in fact, does so regardless of whether that protocol's product predicate is amended along the lines suggested by Remark 4.15).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We now present the protocol for  <span class="math">2 \\cdot \\mu</span> -ary multiset check, exactly following [CBBZ23, § 3.4].</p>

    <p class="text-gray-300"><span id="page-26-2"></span><strong>PROTOCOL 4.20</strong> ( <span class="math">\\mu</span> -dimensional multiset check [CBBZ23, § 3.4]). Parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span> , as well as  <span class="math">\\ell</span> -variate virtual polynomials  <span class="math">[T_0], \\ldots, [T_{\\mu-1}]</span>  and  <span class="math">[U_0], \\ldots, [U_{\\mu-1}]</span>  over  <span class="math">\\mathcal{T}_{\\iota}</span> , where  <span class="math">\\mu &gt; 1</span> , are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>V samples random scalars  <span class="math">r_1, \\ldots, r_{\\mu-1}</span>  from  <span class="math">\\mathcal{T}_{\\tau}</span> , and sends them to  <span class="math">\\mathcal{P}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a 1-dimensional multiset check on the virtual polynomials  <span class="math">[T&#x27;] := [T_0] + r_1 \\cdot [T_1] + \\cdots + r_{\\mu-1} \\cdot [T_{\\mu-1}]</span>  and  <span class="math">[U&#x27;] := [U_0] + r_1 \\cdot [U_1] + \\cdots + r_{\\mu-1} \\cdot [U_{\\mu-1}]</span> .</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 4.21.</strong> Protocol 4.20 securely decides the predicate  <span class="math">\\mathsf{Multiset}(\\mu)_{\\iota,\\ell}</span>  on  <span class="math">([T_i])_{i=0}^{\\mu-1}</span>  and  <span class="math">([U_i])_{i=0}^{\\mu-1}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Assuming that  <span class="math">\\mathsf{Multiset}(\\mu)_{\\iota,\\ell}(T_0,\\ldots,T_{\\mu-1},U_0,\\ldots,U_{\\mu-1})=0</span> , we show that  <span class="math">\\mathsf{Multiset}(1)_{\\iota,\\ell}(T&#x27;,U&#x27;)=1</span>  holds with negligible probability over  <span class="math">\\mathcal{V}</span> 's random coins. We follow the proof strategy of [CBBZ23, Thm. 3.5]. We write  <span class="math">T:=\\{(T_0(v),\\ldots,T_{\\mu-1}(v))\\mid v\\in\\mathcal{B}_\\ell\\}</span>  and  <span class="math">U:=\\{(U_0(v),\\ldots,U_{\\mu-1}(v))\\mid v\\in\\mathcal{B}_\\ell\\}</span>  for the multisets at</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">hand, as well as  <span class="math">\\widehat{T} \\coloneqq T \\setminus U</span>  and  <span class="math">\\widehat{U} \\coloneqq U \\setminus T</span> , which we understand as multiset differences. Since T and U are equally sized as multisets,  <span class="math">\\widehat{T}</span>  and  <span class="math">\\widehat{U}</span>  necessarily also are; moreover, our hypothesis entails precisely that  <span class="math">\\widehat{T}</span>  and  <span class="math">\\widehat{U}</span>  are nonempty. We fix an element  <span class="math">t^<em> \\in \\widehat{T}</span> . We write  <span class="math">R \\coloneqq \\{(1, r_1, \\dots, r_{\\mu-1}) \\mid (r_1, \\dots, r_{\\mu-1}) \\in \\mathcal{T}_{\\tau}^{\\mu-1}\\}</span> ; moreover, for each  <span class="math">r \\in R</span> , we write  <span class="math">\\varphi_r : \\mathcal{T}_{\\tau}^{\\mu} \\to \\mathcal{T}_{\\tau}</span>  for the map  <span class="math">\\varphi_r : (a_0, \\dots, a_{\\mu-1}) \\mapsto a_0 + r_1 \\cdot a_1 + \\dots + r_{\\mu-1} \\cdot a_{\\mu-1}</span> . Finally, for each  <span class="math">u \\in \\widehat{U}</span> , we set  <span class="math">R_u \\coloneqq \\left\\{r \\in R \\mid \\varphi_r(t^</em>) \\stackrel{?}{=} \\varphi_r(u)\\right\\}</span> . If the verifier's challenge  <span class="math">r \\notin \\bigcup_{u \\in \\widehat{U}} R_u</span> , then Multiset <span class="math">(1)_{\\iota,\\ell}(T&#x27;,U&#x27;) = 0</span>  certainly holds; indeed, in this case, the count of the element  <span class="math">\\varphi_r(t^<em>)</span>  in the multiset  <span class="math">\\{\\varphi_r(t) \\mid t \\in T\\}</span>  necessarily exceeds by at least 1 the count of this element in  <span class="math">\\{\\varphi_r(u) \\mid u \\in U\\}</span> , so that  <span class="math">\\{\\varphi_r(t) \\mid t \\in T\\} \\neq \\{\\varphi_r(u) \\mid u \\in U\\}</span> . On the other hand, each  <span class="math">R_u</span>  is precisely the intersection in  <span class="math">\\mathcal{T}_{\\tau}^{\\mu}</span>  between the affine hyperplane R and the normal hyperplane  <span class="math">\\{r \\in \\mathcal{T}_{\\tau}^{\\mu} \\mid r \\cdot (t^</em> - u) = 0\\}</span>  (which is necessarily nondegenerate, by our choice of  <span class="math">t^*</span> ). Each  <span class="math">R_u</span>  is thus a proper affine subspace of R, and so covers a proportion consisting of at most  $\\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  of R&#x27;s points. The union  </span>\\bigcup_{u \\in \\widehat{U}} R_u<span class="math">  thus covers at most  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widehat{U}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\cdot \\frac{1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\frac{2^{\\ell}}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  among R&#x27;s points (where  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\widehat{U}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  here is a multiset cardinality). This completes the proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><strong>Permutation check.</strong> We finally describe a protocol for the predicate  <span class="math">\\mathsf{Permutation}(\\sigma)_{\\iota,\\ell}: (T_0,\\ldots,T_{\\mu-1}) \\mapsto \\bigwedge_{(i,v)\\in\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_\\ell} T_{i&#x27;}(v&#x27;) = T_i(v)</span>  above; here, as before, we fix a bijection  <span class="math">\\sigma:\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_\\ell\\to\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_\\ell</span> . Though we follow HyperPlonk [CBBZ23, § 3.5], our protocol decides an extension of that work's predicate, which allows multiple inputs, as well as permutations that act across these inputs.</p>

    <p class="text-gray-300">Our protocol takes as common input a list  <span class="math">[T_0], \\ldots, [T_{\\mu-1}]</span>  of virtual polynomials. It also—unlike the protocols already given above—makes use of the indexer; specifically, the protocol takes as further common input handles  <span class="math">[s_{id}]</span>  and  <span class="math">[s_{\\sigma}]</span> , which jointly capture the permutation  <span class="math">\\sigma: \\{0, \\ldots, \\mu-1\\} \\times \\mathcal{B}_{\\ell} \\to \\{0, \\ldots, \\mu-1\\} \\times \\mathcal{B}_{\\ell}</span> . We argue first that we may freely assume that  <span class="math">\\mu = 2^{\\alpha}</span>  is a power of 2; indeed, we may always extend  <span class="math">\\sigma</span>  by the identity map, as well as pad the list  <span class="math">[T_0], \\ldots, [T_{\\mu-1}]</span>  with further virtual polynomials (set to be identically zero, say). Clearly, the padded predicate holds if and only if the unpadded one does.</p>

    <p class="text-gray-300">We fix an arbitrary injection  <span class="math">s:\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_\\ell\\hookrightarrow\\mathcal{T}_\\tau</span>  (we assume without further comment that  <span class="math">\\tau</span>  is sufficiently large). For each  <span class="math">i\\in\\{0,\\ldots,\\mu-1\\}</span> , we define mappings  <span class="math">\\mathrm{id}_i:\\mathcal{B}_\\ell\\to\\mathcal{T}_\\tau</span>  and  <span class="math">\\sigma_i:\\mathcal{B}_\\ell\\to\\mathcal{T}_\\tau</span>  by setting  <span class="math">\\mathrm{id}_i:v\\mapsto s(i,v)</span>  and  <span class="math">\\sigma_i:v\\mapsto s(\\sigma(i,v))</span> . We finally write  <span class="math">s_{\\mathrm{id}}\\coloneqq \\mathtt{merge}(\\mathrm{id}_0,\\ldots,\\mathrm{id}_{\\mu-1})</span>  and  <span class="math">s_\\sigma\\coloneqq \\mathtt{merge}(\\sigma_0,\\ldots,\\sigma_{\\mu-1})</span> , following Example 4.10. We stipulate that the indexer output  <span class="math">[s_{\\mathrm{id}}]</span>  and  <span class="math">[s_\\sigma]</span>  directly as  <span class="math">\\ell+\\alpha</span> -variate handles (though this latter measure is not necessary, it improves efficiency).</p>

    <pre><code class="language-text">PROTOCOL 4.22 (Permutation check [CBBZ23, § 3.4]).</code></pre>

    <p class="text-gray-300">Parameters  <span class="math">\\iota</span> ,  <span class="math">\\ell</span> , and  <span class="math">\\tau</span>  in  <span class="math">\\mathbb{N}</span> , the handles  <span class="math">[s_{id}]</span>  and  <span class="math">[s_{\\sigma}]</span>  constructed above, a bijection  <span class="math">\\sigma : \\{0, \\ldots, \\mu - 1\\} \\times \\mathcal{B}_{\\ell} \\to \\{0, \\ldots, \\mu - 1\\} \\times \\mathcal{B}_{\\ell}</span> , and  <span class="math">\\ell</span> -variate polynomials  <span class="math">[T_0], \\ldots, [T_{\\mu-1}]</span>  are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  construct the virtual polynomial  <span class="math">[T] := merge(T_0, \\dots, T_{\\mu-1})</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a 4-ary multiset check on the  <span class="math">\\ell + \\alpha</span> -variate pairs ( <span class="math">[s_{id}], [T]</span> ) and ( <span class="math">[s_{\\sigma}], [T]</span> ).</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 4.23.</strong> Protocol 4.22 securely decides the predicate  <span class="math">Permutation(\\sigma)_{\\iota,\\ell}</span>  on  <span class="math">[T_0], \\ldots, [T_{\\mu-1}]</span> .</p>

    <p class="text-gray-300">Proof. Assuming that  <span class="math">\\operatorname{Multiset}(2)_{\\iota,\\ell}(s_{\\operatorname{id}},T,s_{\\sigma},T)=1</span> , we show that  <span class="math">\\operatorname{Permutation}(\\sigma)_{\\iota,\\ell}(T_0,\\ldots,T_{\\mu-1})=1</span>  holds with probability 1. We write  <span class="math">\\widehat{T}_{\\operatorname{id}}\\coloneqq\\{(s_{\\operatorname{id}}(u),T(u))\\mid u\\in\\mathcal{B}_{\\ell+\\alpha}\\}</span>  and  <span class="math">\\widehat{T}_{\\sigma}\\coloneqq\\{(s_{\\sigma}(u),T(u))\\mid u\\in\\mathcal{B}_{\\ell+\\alpha}\\}</span>  (both viewed as multisubsets of  <span class="math">\\mathcal{T}_{\\tau}^2</span> ). We let  <span class="math">(i,v)\\in\\{0,\\ldots,\\mu-1\\}\\times\\mathcal{B}_{\\ell}</span>  be arbitrary, and write  <span class="math">(i&#x27;,v&#x27;)\\coloneqq\\sigma(i,v)</span> . We note that the multisets  <span class="math">\\widehat{T}_{\\operatorname{id}}</span>  and  <span class="math">\\widehat{T}_{\\sigma}</span>  each admit precisely one element whose  <span class="math">0^{\\operatorname{th}}</span>  component equals s(i',v'); indeed, these elements are exactly  <span class="math">(s(i&#x27;,v&#x27;),T_{i&#x27;}(v&#x27;))</span>  and  <span class="math">(s(i&#x27;,v&#x27;),T_{i}(v))</span> , respectively, by construction of  <span class="math">s_{\\operatorname{id}}</span> ,  <span class="math">s_{\\sigma}</span> , and T. By the assumed equality of  <span class="math">\\widehat{T}_{\\operatorname{id}}</span>  and  <span class="math">\\widehat{T}_{\\sigma}</span>  of multisets, we conclude that  <span class="math">T_{i&#x27;}(v&#x27;)=T_{i}(v)</span> .</p>

    <h4 id="sec-24" class="text-lg font-semibold mt-6">4.3 New Virtual Polynomials</h4>

    <p class="text-gray-300">We now introduce a handful of new virtual polynomial constructions. Each of these constructions, on input a handle (or a virtual polynomial), materializes a further virtual polynomial, whose relationship to its input is prescribed.</p>

    <p class="text-gray-300">The packing construction. We fix integers  <span class="math">\\iota</span> ,  <span class="math">\\kappa</span> ,  <span class="math">\\tau</span> , and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> . We recall from Subsection 2.3 the multilinear  <span class="math">\\mathcal{T}_{\\iota}</span> -basis  <span class="math">(\\beta_u)_{u \\in \\mathcal{B}_{\\kappa}}</span>  of  <span class="math">\\mathcal{T}_{\\iota + \\kappa}</span> . We finally fix a vector  <span class="math">t \\in \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span> .</p>

    <p class="text-gray-300">We define the packing operator  <span class="math">\\operatorname{pack}_{\\kappa}: \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}} \\to \\mathcal{T}_{\\iota+\\kappa}^{\\mathcal{B}_{\\ell-\\kappa}}</span>  by setting:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathrm{pack}_{\\kappa}(t)(v) \\coloneqq \\sum_{u \\in \\mathcal{B}_{\\kappa}} t(u \\parallel v) \\cdot \\beta_u</span></div>

    <p class="text-gray-300">for each  <span class="math">v \\in \\mathcal{B}_{\\ell-\\kappa}</span> .</p>

    <p class="text-gray-300">Intuitively,  <span class="math">pack_{\\kappa}</span>  iteratively processes chunks consisting of  <span class="math">2^{\\kappa}</span>  lexicographically adjacent  <span class="math">\\mathcal{T}_{\\iota}</span> -elements; it assembles the constituents of each such chunk into a single  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element.</p>

    <p class="text-gray-300">We now record a virtual polynomial materialization of  <span class="math">\\operatorname{pack}_{\\kappa}(t)</span> . For  <span class="math">t \\in \\mathcal{T}^{\\mathcal{B}_{\\ell}}_{\\iota}</span>  again as above, we write  <span class="math">\\widetilde{t} \\in \\mathcal{T}_{\\iota}[X_0, \\dots, X_{\\ell-1}]^{\\leq 1}</span>  for the MLE of t; we moreover write  <span class="math">\\mathsf{pack}_{\\kappa}(t) \\in \\mathcal{T}_{\\iota+\\kappa}[X_0, \\dots, X_{\\ell-\\kappa-1}]^{\\leq 1}</span>  for the MLE of  <span class="math">pack_{\\kappa}(t)</span> . We have the following explicit expression for  <span class="math">pack_{\\kappa}(t)</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathrm{pack}}_{\\kappa}(t)(X_0,\\ldots,X_{\\ell-\\kappa-1}) = \\sum_{u\\in\\mathcal{B}_{\\kappa}} \\widetilde{t}(u_0,\\ldots,u_{\\kappa-1},X_0,\\ldots,X_{\\ell-\\kappa-1}) \\cdot \\beta_u,</span></div>

    <p class="text-gray-300">where we destructure  <span class="math">(u_0, \\ldots, u_{\\kappa-1}) = u</span>  for each  <span class="math">u \\in \\mathcal{B}_{\\kappa}</span> . Indeed, for each  <span class="math">(v_0, \\ldots, v_{\\ell-\\kappa-1}) = v \\in \\mathcal{B}_{\\ell-\\kappa}</span>  <span class="math">\\operatorname{pack}_{\\kappa}(t)(v_0,\\ldots,v_{\\ell-\\kappa-1}) = \\operatorname{pack}_{\\kappa}(t)(v)</span> ; moreover, the polynomial above is multilinear.</p>

    <p class="text-gray-300">When  <span class="math">\\widetilde{t}</span>  is given as a handle [t], the expression  <span class="math">\\widetilde{\\mathsf{pack}}_{\\kappa}(t)(X_0,\\ldots,X_{\\ell-\\kappa-1})</span>  defines an  <span class="math">\\ell-\\kappa</span> -variate virtual polynomial, in the sense of Definition 4.6. In fact, this virtual polynomial admits an efficient evaluation protocol, as we now argue. We fix a query  <span class="math">\\operatorname{\\mathsf{Query}}(r&#x27;,s&#x27;)_{\\iota+\\kappa,\\ell-\\kappa}</span> . We note that the evaluation  <span class="math">\\operatorname{\\mathsf{pack}}_{\\kappa}(t)(r&#x27;)=</span>  <span class="math">\\sum_{u\\in\\mathcal{B}_{\\kappa}} t(u_0,\\ldots,u_{\\kappa-1},r&#x27;_0,\\ldots,r&#x27;_{\\ell-\\kappa-1})\\cdot\\beta_u</span>  is itself the sum, over  <span class="math">\\mathcal{B}_{\\kappa}</span> , of the  <span class="math">\\kappa</span> -variate polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathsf{pack}}_{\\kappa}(t,r&#x27;)(Y_0,\\ldots,Y_{\\kappa-1}) \\coloneqq \\widetilde{t}(Y_0,\\ldots,Y_{\\kappa-1},r&#x27;_0,\\ldots,r&#x27;_{\\ell-\\kappa-1}) \\cdot \\widetilde{\\beta}(Y_0,\\ldots,Y_{\\kappa-1});</span></div>

    <p class="text-gray-300">here, we write  <span class="math">\\widetilde{\\beta} \\in \\mathcal{T}_{\\iota+\\kappa}[Y_0,\\ldots,Y_{\\kappa-1}]^{\\leq 1}</span>  for the MLE of  <span class="math">(\\beta_u)_{u\\in\\mathcal{B}_{\\kappa}}</span> . It thus suffices for the verifier to decide  <span class="math">\\operatorname{\\mathsf{Sum}}(s&#x27;)_{\\tau,\\kappa}</span>  on  <span class="math">\\widetilde{\\mathsf{pack}}_{\\kappa}(t,r&#x27;)</span> . Using the sumcheck protocol, the verifier may in turn reduce that predicate to Query <span class="math">(r, s)_{\\tau, \\kappa}</span> , say, on  <span class="math">\\widetilde{\\mathsf{pack}}_{\\kappa}(t, r&#x27;)</span> . To decide this latter predicate,  <span class="math">\\mathcal{V}</span>  may simply check  <span class="math">\\widetilde{t}(r \\parallel r&#x27;) \\cdot \\widetilde{\\beta}(r) \\stackrel{?}{=} s</span> . We assume that  <span class="math">\\kappa</span>  is sufficiently small that  <span class="math">\\mathcal{V}</span>  may evaluate  <span class="math">\\widetilde{\\beta}(r)</span>  itself; on the other hand,  <span class="math">\\mathcal{V}</span>  may ascertain  <span class="math">t(r \\parallel r&#x27;)</span>  by means of one query to [t].</p>

    <p class="text-gray-300">The shifting construction. We again write  <span class="math">\\mathcal{T}_{\\ell} \\subset \\mathcal{T}_{\\tau}</span>  for a tower subfield, and fix an integer  <span class="math">\\ell \\in \\mathbb{N}</span> . We</p>

    <p class="text-gray-300">recall the identification which, for each  <span class="math">k \\in \\{0, \\dots, \\ell\\}</span> , maps  <span class="math">v \\in \\mathcal{B}_k</span>  to  <span class="math">\\{v\\} := \\sum_{i=0}^{k-1} 2^i \\cdot v_i</span> . For each block size parameter  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span>  and each shift offset  <span class="math">o \\in \\mathcal{B}_b</span> , the shift operator, on input  <span class="math">t \\in \\mathcal{T}_{b}^{\\mathcal{B}_{\\ell}}</span> , partitions t's index set  <span class="math">\\mathcal{B}_{\\ell}</span>  into b-dimensional subcubes, and then circularly rotates each resulting sub-array by o steps (where we, implicitly, flatten each sub-array lexicographically). We make this precise in the following way. For each  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span>  and  <span class="math">o \\in \\mathcal{B}_b</span>  as above, we define the shift mapping  <span class="math">s_{b,o} : \\mathcal{B}_\\ell \\to \\mathcal{B}_\\ell</span> by declaring, for each input  <span class="math">v = (v_0, \\ldots, v_{\\ell-1}) \\in \\mathcal{B}_{\\ell}</span> , that  <span class="math">s_{b,o}(v) := u</span> , where  <span class="math">u = (u_0, \\ldots, u_{\\ell-1})</span>  is such that the most-significant substrings  <span class="math">(u_b, \\ldots, u_{\\ell-1})</span>  and  <span class="math">(v_b, \\ldots, v_{\\ell-1})</span>  agree, and  <span class="math">\\{u\\} + \\{o\\} \\equiv \\{v\\} \\pmod{2^b}</span>  moreover holds. We define the <em>shift operator</em>  <span class="math">\\mathtt{shift}_{b,o}: \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}} \\to \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span>  by mapping each  <span class="math">t \\in \\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span>  to the vector  <span class="math">\\mathtt{shift}_{b,o}(t) \\coloneqq (t(s_{b,o}(v)))_{v \\in \\mathcal{B}_{\\ell}}</span> . We note that, provided we flatten t and  <span class="math">\\mathtt{shift}_{b,o}(t)</span>  using the lexicographic identification  <span class="math">v \\mapsto \\sum_{i=0}^{\\ell-1} 2^i \\cdot v_i</span> , shift<sub>b,o</sub>(t) has precisely the effect of circularly rotating each contiguous  <span class="math">2^b</span> -sized block of t downward by  <span class="math">\\{o\\}</span>  steps.</p>

    <p class="text-gray-300">We initiate an arithmetic characterization of the shift operator, which expresses each shifted vector  <span class="math">\\mathtt{shift}_{b,o}(t)</span>  as a virtual polynomial on its input t. In fact, our construction moreover admits a linear-timethat is, a  <span class="math">\\Theta(b)</span> -time—evaluation algorithm, as we explain below. Our approach is inspired by, and generalizes, the "adding 1 in binary" multilinear indicator of Setty, Thaler, and Wahby [STW23, § 5.1].</p>

    <p class="text-gray-300">We first define the length-b, o-step shift indicator function  <span class="math">s-ind_{b,o}: \\mathcal{B}_b \\times \\mathcal{B}_b \\to \\{0,1\\}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{s-ind}_{b,o}:(x,y)\\mapsto \\begin{cases} 1 &amp; \\text{if } \\{y\\}\\stackrel{?}{\\equiv} \\{x\\}+\\{o\\}\\pmod{2^b}\\\\ 0 &amp; \\text{otherwise}. \\end{cases}</span></div>

    <p class="text-gray-300">For b and  <span class="math">(o_0, \\ldots, o_{b-1}) = o \\in \\mathcal{B}_b</span>  again fixed, we realize the shift indicator function s-ind<sub>b,o</sub> inductively, by means of a sequence of functions  <span class="math">s-ind&#x27;_{k,o}</span>  and  <span class="math">s-ind&#x27;&#x27;_{k,o}</span> , each mapping  <span class="math">\\mathcal{B}_k \\times \\mathcal{B}_k \\to \\{0,1\\}</span> , for  <span class="math">k \\in \\{0,\\ldots,b\\}</span> . That is, for each  <span class="math">k \\in \\{0, \\ldots, b\\}</span> , on arguments x and y in  <span class="math">\\mathcal{B}_k</span> , we define the function  <span class="math">\\mathbf{s}\\text{-ind}&#x27;_{k,o}(x,y)</span>  so as to detect the condition  <span class="math">\\{y\\} \\stackrel{?}{=} \\{x\\} + \\{o\\}</span> , and define  <span class="math">s-ind&#x27;&#x27;_{k,o}(x,y)</span>  so as to detect the condition  <span class="math">\\{y\\} \\stackrel{?}{=}</span>  <span class="math">\\{x\\}+\\{o\\}-2^k</span> , where, in both expressions, we interpret  <span class="math">o=(o_0,\\ldots,o_{k-1})</span>  as an element of  <span class="math">\\mathcal{B}_k</span>  by truncating its bits. In words,  <span class="math">s-ind&#x27;_{k,o}</span>  detects the condition whereby the k-bit strings x and y differ exactly by the binary addition of o's least-significant k bits, and without overflow no less;  <span class="math">s-ind_{k,0}^{\\prime\\prime}</span>  detects the analogous condition, modulo an overflow into the  <span class="math">k^{\\text{th}}</span> -indexed bit position. We finally note that  <span class="math">s-\\text{ind}_{b,o} := s-\\text{ind}&#x27;_{b,o} \\vee s-\\text{ind}&#x27;&#x27;_{b,o}</span> .</p>

    <p class="text-gray-300">We now present an inductive—and arithmetically friendly—description of the functions  <span class="math">s-ind&#x27;_{k,o}</span>  and  <span class="math">s-ind_{k,a}^{\\prime\\prime}</span> , for  <span class="math">k\\in\\{0,\\ldots,b\\}</span> . For typographical convenience, we give meaning to expressions of the form  <span class="math">s-ind&#x27;_{k-1,o}(x,y)</span>  and  <span class="math">s-ind&#x27;&#x27;_{k-1,o}(x,y)</span> , for arguments x and y in  <span class="math">\\mathcal{B}_k</span> —i.e., rather than in the domain of definition  <span class="math">\\mathcal{B}_{k-1}</span> —by stipulating that the functions simply ignore their arguments' respective most-significant (that is, k-1-indexed) bits. Finally, below, we understand the expression  <span class="math">x_{k-1} \\stackrel{?}{=} o_{k-1} + y_{k-1}</span>  and its variants over the integers (i.e., as integer expressions over the arguments  <span class="math">x_{k-1}, y_{k-1}</span> , and  <span class="math">o_{k-1}</span>  in  <span class="math">\\{0,1\\} \\subset \\mathbb{Z}</span> ).</p>

    <p class="text-gray-300">case k=0.  <span class="math">\\mathtt{s-ind}_{0,o}&#x27;=1.</span>  <span class="math">s-ind_{0,o}^{&quot;}=0.</span></p>

    <div class="my-4 text-center"><span class="math-block">\\begin{split} \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k,o}&#x27;(x,y) &amp;= \\begin{cases} \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k-1,o}&#x27;(x,y) &amp; \\text{if } x_{k-1} + o_{k-1} \\stackrel{?}{=} y_{k-1} \\\\ \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k-1,o}&#x27;&#x27;(x,y) &amp; \\text{if } x_{k-1} + o_{k-1} + 1 \\stackrel{?}{=} y_{k-1} \\\\ 0 &amp; \\text{otherwise.} \\end{cases} \\\\ \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k,o}&#x27;&#x27;(x,y) &amp;= \\begin{cases} \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k-1,o}&#x27;(x,y) &amp; \\text{if } x_{k-1} + o_{k-1} \\stackrel{?}{=} y_{k-1} + 2 \\\\ \\mathbf{s}\\text{-}\\!\\operatorname{ind}_{k-1,o}&#x27;&#x27;(x,y) &amp; \\text{if } x_{k-1} + o_{k-1} + 1 \\stackrel{?}{=} y_{k-1} + 2 \\\\ 0 &amp; \\text{otherwise.} \\end{cases} \\end{split}</span></div>

    <p class="text-gray-300">The correctness of this inductive description may be explicitly checked. We note that  <span class="math">s-ind_{b,o}(x,y) =</span>  <span class="math">s-ind&#x27;_{b,o}(x,y) + s-ind&#x27;&#x27;_{b,o}(x,y)</span>  holds for each  <span class="math">(x,y) \\in \\mathcal{B}_b \\times \\mathcal{B}_b</span> .</p>

    <p class="text-gray-300">Exploiting the inductive description just given, we now arithmetically characterize the MLEs in  <span class="math">\\mathcal{T}_{\\iota}[X_0,\\ldots,X_{k-1},Y_0,\\ldots,Y_{k-1}]^{\\leq 1}</span>  of the shift-indicator functions  <span class="math">\\mathtt{s-ind}&#x27;_{k,o}</span>  and  <span class="math">\\mathtt{s-ind}&#x27;&#x27;_{k,o}</span> .</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{ccc} \\mathbf{case} \\ k = 0. \\\\ \\widehat{\\mathtt{s-ind}}_{0,o} = 1. \\\\ \\widehat{\\mathtt{s-ind}}_{0,o}&#x27;&#x27; = 0. \\end{array}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} &amp; \\operatorname{case} \\, k &gt; 0. \\\\ &amp; \\widetilde{\\operatorname{s-ind}}_{k,o}&#x27;(X,Y) = \\begin{cases} \\widetilde{\\operatorname{eq}}(X_{k-1},Y_{k-1}) \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) + (1-X_{k-1}) \\cdot Y_{k-1} \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) &amp; o_{k-1} \\stackrel{?}{=} 0. \\\\ (1-X_{k-1}) \\cdot Y_{k-1} \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) &amp; o_{k-1} \\stackrel{?}{=} 1. \\end{cases} \\\\ &amp; \\widetilde{\\operatorname{s-ind}}_{k,o}&#x27;&#x27;(X,Y) = \\begin{cases} X_{k-1} \\cdot (1-Y_{k-1}) \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) &amp; o_{k-1} \\stackrel{?}{=} 0. \\\\ X_{k-1} \\cdot (1-Y_{k-1}) \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) + \\widetilde{\\operatorname{eq}}(X_{k-1},Y_{k-1}) \\cdot \\widetilde{\\operatorname{s-ind}}_{k-1,o}&#x27;(X,Y) &amp; o_{k-1} \\stackrel{?}{=} 1. \\end{cases}</span></div>

    <p class="text-gray-300">Above, we again make use of the multilinear equality function  <span class="math">\\widetilde{eq}</span>  (see Subsection 2.1), which we apply here only to pairs of 1-bit arguments. We again stipulate that the functions  <span class="math">\\widetilde{\\mathbf{s-ind}}_{k-1,o}&#x27;</span>  and  <span class="math">\\widetilde{\\mathbf{s-ind}}_{k-1,o}&#x27;&#x27;</span> , upon being fed k-variate arguments, simply ignore these arguments' respective last variables.</p>

    <p class="text-gray-300">Finally, we define  <span class="math">\\widetilde{\\mathtt{s-ind}}_{b,o} := \\widetilde{\\mathtt{s-ind}}&#x27;_{b,o} + \\widetilde{\\mathtt{s-ind}}&#x27;&#x27;_{b,o}</span> .</p>

    <p class="text-gray-300"><strong>Theorem 4.24.</strong> The polynomial  <span class="math">\\widetilde{s\\text{-ind}}_{b,o} \\in \\mathcal{T}_{\\iota}[X_0,\\ldots,X_{b-1},Y_0,\\ldots,Y_{b-1}]</span>  just given is the MLE of  <span class="math">s\\text{-ind}_{b,o}</span> .</p>

    <p class="text-gray-300">Proof. The function  <span class="math">\\widehat{\\mathbf{s}}</span> - <span class="math">\\mathrm{ind}_{b,o}</span> 's pointwise agreement with  <span class="math">\\mathbf{s}</span> - <span class="math">\\mathrm{ind}_{b,o}</span>  over  <span class="math">\\mathcal{B}_b \\times \\mathcal{B}_b</span>  is self-evident. Its multilinearity holds by induction; indeed, for each  <span class="math">k \\in \\{1,\\ldots,b\\}</span> , we note that both  <span class="math">\\widehat{\\mathbf{s}}</span> - <span class="math">\\mathrm{ind}_{k,o}</span>  and  <span class="math">\\widehat{\\mathbf{s}}</span> - <span class="math">\\mathrm{ind}_{k,o}</span>  are sums of products between some multilinear function of  <span class="math">X_{k-1}</span>  and  <span class="math">Y_{k-1}</span>  and either  <span class="math">\\widehat{\\mathbf{s}}</span> - <span class="math">\\mathrm{ind}_{k-1,o}</span>  or  <span class="math">\\widehat{\\mathbf{s}}</span> - <span class="math">\\mathrm{ind}_{k-1,o}</span> , functions which themselves are—by induction—multilinear in the variables  <span class="math">(X_0,\\ldots,X_{k-2},Y_0,\\ldots,Y_{k-2})</span> . Each such product expression is necessarily multilinear in the variables  <span class="math">(X_0,\\ldots,X_{k-1},Y_0,\\ldots,Y_{k-1})</span> .</p>

    <p class="text-gray-300">We finally note that the polynomial  <span class="math">\\widetilde{\\mathbf{s-ind}}_{b,o}</span>  admits a  <span class="math">\\Theta(b)</span> -sized, layered arithmetic circuit; this circuit's description arises straightforwardly from the function's inductive characterization just given above.</p>

    <p class="text-gray-300">We return to the shift operator  <span class="math">\\mathtt{shift}_{b,o}:\\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}\\to\\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span>  already introduced. Leveraging the arithmetized shift-indicator functions just treated, we now present an arithmetical description of  <span class="math">\\mathtt{shift}_{b,o}</span> . Indeed, for each  <span class="math">t\\in\\mathcal{T}_{\\iota}^{\\mathcal{B}_{\\ell}}</span>  and each  <span class="math">v\\in\\mathcal{B}_{\\ell}</span> , we have the equality:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{shift}_{b,o}(t)(v) = \\sum_{u \\in \\mathcal{B}_b} t(u_0, \\dots, u_{b-1}, v_b, \\dots, v_{\\ell-1}) \\cdot \\mathtt{s-ind}_{b,o}(u_0, \\dots, u_{b-1}, v_0, \\dots, v_{b-1}).</span></div>

    <p class="text-gray-300">Finally, we write  <span class="math">\\widetilde{\\mathtt{shift}}_{b,o}(t)(X_0,\\ldots,X_{\\ell-1})\\in\\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span>  for the MLE of  <span class="math">\\mathtt{shift}_{b,o}(t)</span> . We note the explicit expression:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathtt{shift}}_{b,o}(t)(X_0,\\ldots,X_{\\ell-1}) = \\sum_{u \\in \\mathcal{B}_b} \\widetilde{t}(u_0,\\ldots,u_{b-1},X_b,\\ldots,X_{\\ell-1}) \\cdot \\widetilde{\\mathtt{s-ind}}_{b,o}(u_0,\\ldots,u_{b-1},X_0,\\ldots,X_{b-1}).</span></div>

    <p class="text-gray-300">Indeed, the polynomial above is clearly multilinear, and agrees pointwise with  <span class="math">\\mathtt{shift}_{b,o}(t)</span>  over  <span class="math">\\mathcal{B}_{\\ell}</span> .</p>

    <p class="text-gray-300">When [t] is a handle, the expression  <span class="math">\\widetilde{\\mathtt{shift}}_{b,o}(t)</span>  defines a virtual polynomial, which we again claim is efficiently evaluable. We fix a query  <span class="math">\\mathsf{Query}(r&#x27;,s&#x27;)_{\\iota,\\ell}</span> . We note that the evaluation  <span class="math">\\widetilde{\\mathtt{shift}}_{b,o}(t)(r&#x27;)</span>  is itself the sum, over the cube  <span class="math">\\mathcal{B}_b</span> , of the b-variate polynomial:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathtt{shift}}_{b,o}(t,r&#x27;)(Y_0,\\ldots,Y_{b-1}) \\coloneqq \\widetilde{t}(Y_0,\\ldots,Y_{b-1},r&#x27;_b,\\ldots,r&#x27;_{\\ell-1}) \\cdot \\widetilde{\\mathtt{s-ind}}_{b,o}\\big(Y_0,\\ldots,Y_{b-1},r&#x27;_0,\\ldots,r&#x27;_{b-1}\\big).</span></div>

    <p class="text-gray-300">It thus suffices for  <span class="math">\\mathcal{V}</span>  to decide  <span class="math">\\mathsf{Sum}(s&#x27;)_{\\tau,b}</span>  on  <span class="math">\\widetilde{\\mathsf{shift}}_{b,o}(t,r&#x27;)</span> ; using a sumcheck,  <span class="math">\\mathcal{V}</span>  may in turn reduce this predicate to  <span class="math">\\mathsf{Query}(r,s)_{\\tau,b}</span>  on  <span class="math">\\widetilde{\\mathsf{shift}}_{b,o}(t,r&#x27;)</span> , for values  <span class="math">r \\in \\mathcal{T}^b_{\\tau}</span>  and  <span class="math">s \\in \\mathcal{T}_{\\tau}</span>  derived during the sumcheck. As before,  <span class="math">\\mathcal{V}</span>  may decide this latter predicate itself, by querying  <span class="math">t(r_0,\\ldots,r_{b-1},r&#x27;_b,\\ldots,r&#x27;_{\\ell-1})</span>  and locally evaluating  <span class="math">\\widetilde{\\mathsf{s-ind}}_{b,o}(r_0,\\ldots,r_{b-1},r&#x27;_0,\\ldots,r&#x27;_{b-1})</span> .</p>

    <p class="text-gray-300">We will occasionally find reason to insist on the nonexistence or the existence of an overflow. In these cases, respectively, we may simply replace the shift-indicator function  <span class="math">\\mathtt{s-ind}_{b,o}</span>  with its simpler analogues  <span class="math">\\mathtt{s-ind}&#x27;_{b,o}</span>  and  <span class="math">\\mathtt{s-ind}&#x27;&#x27;_{b,o}</span> , in the expression for  <span class="math">\\mathtt{shift}_{b,o}</span>  above. We write  <span class="math">\\mathtt{shift}&#x27;_{b,o}</span>  and  <span class="math">\\mathtt{shift}&#x27;&#x27;_{b,o}</span>  for the resulting overflow-free and overflow-mandated shift operators.</p>

    <p class="text-gray-300"><strong>Example 4.25.</strong> We set  <span class="math">\\iota := 0</span>  and b := 5, and fix  <span class="math">\\ell \\geq 5</span>  and  <span class="math">o := (o_0, \\ldots, o_4) \\in \\mathcal{B}_5</span>  arbitrarily. For each vector  <span class="math">t \\in \\mathcal{T}_0^{\\mathcal{B}_\\ell}</span> —which we view as a length- <span class="math">2^\\ell</span>  column of bits, by means of the lexicographic flattening  <span class="math">v \\mapsto \\sum_{i=0}^{\\ell-1} 2^i \\cdot v_i</span> —the operator  <span class="math">\\mathfrak{shift}_{b,o}(t)</span>  breaks t into 32-elements chunks, and then circularly rotates each chunk downwards by  <span class="math">\\{o\\}</span>  steps (or equivalently, upward by  <span class="math">32 - \\{o\\}</span>  steps). On the other hand, the overflow-free shift operator  <span class="math">\\mathfrak{shift}_{b,o}&#x27;(t)</span>  rotates each chunk downwards by  <span class="math">\\{o\\}</span>  steps, without rotation; that is, it 0-fills the first  <span class="math">\\{o\\}</span>  components of each chunk. Finally, the operator  <span class="math">\\mathfrak{shift}_{b,o}&#x27;(t)</span>  acts by upwardly shifting t by  <span class="math">32 - \\{o\\}</span>  steps, 0-filling the bottom  <span class="math">32 - \\{o\\}</span>  elements of each chunk.</p>

    <p class="text-gray-300"><span id="page-30-0"></span>Remark 4.26. Our shift construction answers affirmatively a problem posed by HyperPlonk [CBBZ23] (see p. 52 of the full version). Indeed, the construction [CBBZ23, Lem. 3.13] (that is, Lemma 3.9 of the full version) yields a virtual polynomial which does something like a one-step circular rotation; specifically, that construction's permutation leaves the origin fixed, and rotates the rest of the vector in some—not lexicographic—order (determined by the action of a multiplicative generator). Though that construction can be iterated, the complexity of the iterated virtual polynomial grows exponentially in the number of iterations (i.e., the number of rotation steps). Our shift construction, on the other hand, performs a true circular rotation—that is, without a degenerate orbit at the origin—and moreover operates in lexicographic order. Interestingly, our shift construction's complexity is completely independent of the rotation offset. Rather, our virtual polynomial grows only linearly in the block size; moreover, it admits an evaluation protocol—which leverages the sumcheck—whose complexity grows just logarithmically in the block size.</p>

    <p class="text-gray-300">The saturation construction. We record a final, and very simple, virtual polynomial construction, which we use in our multiplication gadget below (see Subsection 5.3). For  <span class="math">\\ell \\geq 0</span>  fixed, and given block size and offset parameters  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span>  and  <span class="math">o \\in \\mathcal{B}_b</span>  as above, the saturation operator, on input  <span class="math">t \\in \\mathcal{T}^{\\mathcal{B}_\\ell}</span> , partitions t's index set  <span class="math">\\mathcal{B}_{\\ell}</span>  into b-dimensional subcubes, and "saturates" each resulting block with a single value (i.e., that which t takes at the block's  <span class="math">o^{\\text{th}}</span>  position). More precisely, we define the saturation mapping  <span class="math">r_{b,o}: \\mathcal{B}_{\\ell} \\to \\mathcal{B}_{\\ell}</span> by setting  <span class="math">r_{b,o}(v_0,\\ldots,v_{\\ell-1}):=(o_0,\\ldots,o_{b-1},v_b,\\ldots,v_{\\ell-1})</span> , for each  <span class="math">v=(v_0,\\ldots,v_{\\ell-1})\\in\\mathcal{B}_\\ell</span> ; finally, we define the saturation operator  <span class="math">\\mathtt{sat}_{b,o}:\\mathcal{T}_\\iota^{\\mathcal{B}_\\ell}\\to\\mathcal{T}_\\iota^{\\mathcal{B}_\\ell}</span>  by setting  <span class="math">\\mathtt{sat}_{b,o}(t):=(t(r_{b,o}(v)))_{v\\in\\mathcal{B}_\\ell}</span> .</p>

    <p class="text-gray-300">We record a virtual polynomial realization of the saturation operator. Indeed, for  <span class="math">b\\in\\{0,\\ldots,\\ell\\}</span>  and</p>

    <p class="text-gray-300"> <span class="math">o \\in \\mathcal{B}_b</span>  as above, and for each  <span class="math">t \\in \\mathcal{T}_t^{\\mathcal{B}_\\ell}</span>  and  <span class="math">v \\in \\mathcal{B}_\\ell</span> , we have that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathtt{sat}_{b,o}(t)(v) = t(o_0, \\dots, o_{b-1}, v_b, \\dots, v_{\\ell-1});</span></div>

    <p class="text-gray-300">writing  <span class="math">\\widetilde{\\mathtt{sat}}_{b,o}(t) \\in \\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]^{\\leq 1}</span>  for the MLE of  <span class="math">\\mathtt{sat}_{b,o}(t)</span> , we conclude that:</p>

    <div class="my-4 text-center"><span class="math-block">\\widetilde{\\mathtt{sat}}_{b,o}(t)(X_0,\\ldots,X_{\\ell-1})=\\widetilde{t}(o_0,\\ldots,o_{b-1},X_b,\\ldots,X_{\\ell-1}).</span></div>

    <p class="text-gray-300">The polynomial above is clearly multilinear, and agrees pointwise with  <span class="math">\\mathsf{sat}_{b,o}(t)</span>  over  <span class="math">\\mathcal{B}_{\\ell}</span> .</p>

    <p class="text-gray-300">When t is a virtual polynomial,  <span class="math">sat_{b,o}(t)</span>  clearly also is, and can be evaluated as efficiently as t can.</p>

    <h4 id="sec-25" class="text-lg font-semibold mt-6">Binary-Field Lasso 4.4</h4>

    <p class="text-gray-300">In this subsection, we discuss the work Lasso of Setty, Thaler and Wahby [STW24] and adapt that work to our binary tower setting.</p>

    <p class="text-gray-300">We develop a distilled, conceptually minimal approach to Lasso, by teasing apart its various components. Indeed, we contend that Lasso ultimately amounts to a combination of the following components:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A virtual polynomial abstraction, which materializes large tables. Indeed, Lasso's "SOS tables" [STW24, § 4] can be viewed as composition virtual polynomials in the sense of Example 4.9 above, which, operating over subtables, virtually materialize large tables.</li>

      <li>A small-table lookup procedure. Lasso's core contribution is, arguably, its single-table lookup procedure [STW24, Lem. 3], a virtual polynomial protocol which—using offline memory-checking in the sense of Blum et al. [Blu+91]—proves that the values taken over the cube by one virtual polynomial represent a subset of the values taken over the cube by another virtual polynomial. More precisely, Lasso's lookup procedure reduces precisely this predicate to a multiset predicate on certain further virtual polynomials.</li>

      <li>A multiset-check. Finally, Lasso employs a virtual protocol which securely decides the multiset predicate [STW24, Lem. 4], in the sense already developed in Subsections 4.1 and 4.2 above.</li>

    </ul>

    <p class="text-gray-300">Leveraging our abstractions, already developed above, for virtual polynomials and multisets, we thus record a minimal rendition of Lasso, which, in particular, isolates its memory-checking component. Importantly, we excise the table-virtualization process from the jurisdiction of the lookup itself, and subsume it into the constraint-satisfaction apparatus already furnished by our higher-level SNARK (see Section 5 below). This separation of concerns yields a conceptually simpler framework.</p>

    <p class="text-gray-300">Separately, we adapt Lasso to the setting of binary fields. We note first of all that the key technical result [STW24, Lem. 2] assumes that the field at hand of large prime characteristic (i.e., larger than the length of the looked-up column). That restriction is moreover essential, in the sense that [STW24, Fig. 2] as written becomes insecure in the small-characteristic setting. We adapt that work by introducing a multiplicative version of it; that is, we stipulate that the prover and verifier jointly increment the protocol's various timestamps not by adding 1 to them, but rather by multiplying them by a multiplicative generator of an appropriate binary field. Our multiplicative adaptation, however, introduces further complications. Indeed, unlike the incrementation operation, the multiply-by-generator operation on a field induces an action which is not transitive, but rather features a singleton orbit (at 0, of course). Since this fact too can be used to attack the protocol, we must further require that the prover submit an everywhere-nonzero vector of read counts. We achieve this guarantee in our treatment below, at the cost of requiring that the prover commit to an additional polynomial (we discuss our remedy further in Remark 4.29 below).</p>

    <p class="text-gray-300">We now record our protocol for the lookup predicate  <span class="math">\\mathsf{Lookup}_{\\iota,\\ell}: (T,U) \\mapsto \\bigwedge_{v \\in \\mathcal{B}_{\\ell}} \\exists v&#x27; \\in \\mathcal{B}_{\\ell}: U(v) = T(v&#x27;)</span> .</p>

    <h4 id="sec-26" class="text-lg font-semibold mt-6">PROTOCOL 4.27 (Lasso-based lookup [STW24]).</h4>

    <p class="text-gray-300">Parameters  <span class="math">\\iota</span>  and  <span class="math">\\ell</span>  in  <span class="math">\\mathbb{N}</span> , and  <span class="math">\\ell</span> -variate virtual polynomials [T] and [U] over  <span class="math">\\mathcal{T}_{\\iota}</span> , are fixed.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  set  <span class="math">\\zeta \\geq 0</span>  minimally so that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">T_{\\zeta}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1 > 2^{\\ell}<span class="math">  holds (equivalently, they set  </span>\\zeta \\coloneqq \\lceil \\log(\\ell + 1) \\rceil<span class="math"> );  </span>\\mathcal{P}<span class="math">  and  </span>\\mathcal{V}<span class="math">  moreover fix a generator  </span>\\alpha \\in \\mathcal{T}_{\\zeta}^<em><span class="math">  of  </span>\\mathcal{T}_{\\zeta}<span class="math"> &#x27;s multiplicative group of units  </span>\\mathcal{T}_{\\zeta}^</em>$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  defines arrays R and F in  <span class="math">\\mathcal{T}_{\\zeta}^{\\mathcal{B}_{\\ell}}</span>  as follows.  <span class="math">\\mathcal{P}</span>  initializes  <span class="math">F := (1)_{v \\in \\mathcal{B}_{\\ell}}</span> , and then executes:</li>

      <li>1: <strong>for</strong> each  <span class="math">v \\in \\mathcal{B}_{\\ell}</span> , in any order, <strong>do</strong></li>

      <li>2: pick an arbitrary  <span class="math">v&#x27; \\in \\mathcal{B}_{\\ell}</span>  for which U(v) = T(v') holds.</li>

      <li>3: assign R[v] := F[v'].</li>

      <li>4: overwrite  <span class="math">F[v&#x27;] \\times = \\alpha</span> .</li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathcal{P}</span>  sets  <span class="math">R&#x27; \\coloneqq \\left(\\frac{1}{R(v)}\\right)_{v \\in \\mathcal{B}_{\\ell}}</span>  to be the pointwise reciprocal of the vector R.  <span class="math">\\mathcal{P}</span>  submits the multilinear extensions  <span class="math">\\left(\\mathtt{submit}, \\zeta, \\ell, \\widetilde{R}\\right)</span> ,  <span class="math">\\left(\\mathtt{submit}, \\zeta, \\ell, \\widetilde{R&#x27;}\\right)</span> , and  <span class="math">\\left(\\mathtt{submit}, \\zeta, \\ell, \\widetilde{F}\\right)</span>  to the oracle.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a zerocheck on the  <span class="math">\\ell</span> -variate virtual polynomial  <span class="math">R \\cdot R&#x27; 1</span>  over  <span class="math">\\mathcal{T}_{\\zeta}</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  define further  <span class="math">\\ell</span> -variate virtual polynomials as follows. They set  <span class="math">O:(X_0,\\ldots,X_{\\ell-1})\\mapsto 1</span>  to be the identically-1 polynomial, and set  <span class="math">W:=\\alpha\\cdot R</span> .  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  finally run a 4-ary multiset check on the  <span class="math">\\ell+1</span> -variate pairs  <span class="math">(\\mathtt{merge}(T,U),\\mathtt{merge}(O,W))</span>  and  <span class="math">(\\mathtt{merge}(T,U),\\mathtt{merge}(F,R))</span> .</li>

    </ul>

    <p class="text-gray-300">Above, our F corresponds to Lasso's array of "final counts", R correspond to its array of inline read counts, and W corresponds to its array of inline write counts. We refer to [STW24, Lem. 3]. Protocol 4.27's completeness amounts to a more-or-less straightforward, albeit subtle exercise, and essentially follows from [STW24, Lem. 2]. We suggest the following inductive proof. Indeed, assuming that R is initialized to the all-zero array  <span class="math">(0)_{v \\in \\mathcal{B}_{\\ell}}</span> , we argue that the equality</p>

    <p class="text-gray-300"><span id="page-32-1"></span> <span class="math-block">\\{(T(v), 1) \\mid v \\in \\mathcal{B}_{\\ell}\\} \\cup \\{(U(v), \\alpha \\cdot R(v)) \\mid v \\in \\mathcal{B}_{\\ell}\\} = \\{(T(v), F(v)) \\mid v \\in \\mathcal{B}_{\\ell}\\} \\cup \\{(U(v), R(v)) \\mid v \\in \\mathcal{B}_{\\ell}\\}</span> (2)</p>

    <p class="text-gray-300">of multisets is an algorithmic invariant of the main loop above (that is, it holds as of the beginning of each iteration). The base case is clear (both multisets at hand equal  <span class="math">\\{(T(v),1) \\mid v \\in \\mathcal{B}_\\ell\\} \\cup \\{(U(v),0) \\mid v \\in \\mathcal{B}_\\ell\\}</span> ). We fix an iteration index  <span class="math">v \\in \\mathcal{B}_\\ell</span>  of the above loop. The assignment 3 entails removing (U(v),0) from both multisets, as well as adding  <span class="math">(U(v),\\alpha \\cdot F[v&#x27;])</span>  to the left multiset and (U(v),F[v']) to the right. On the other hand, the update 4 entails removing (T(v'),F[v']) from the right multiset and adding  <span class="math">(T(v&#x27;),\\alpha \\cdot F[v&#x27;])</span>  to the right multiset. Since T(v') = U(v), these changes balance; assuming that the equality held at the loop's beginning, we conclude that it likewise holds as of the loop's end. This completes the proof of completeness.</p>

    <p class="text-gray-300"><span id="page-32-3"></span><strong>Theorem 4.28.</strong> Protocol 4.27 securely decides the predicate Lookup<sub> <span class="math">\\iota,\\ell</span> </sub> on [T] and [U].</p>

    <p class="text-gray-300">Proof. We adapt Setty, Thaler, and Wahby [STW24, Lem. 3] to the multiplicative setting. Assuming that  <span class="math">\\mathsf{Zero}_{\\zeta,\\ell}(R\\cdot R&#x27;-1)=1</span>  and  <span class="math">\\mathsf{Multiset}(4)_{\\tau,\\ell+1}(\\mathsf{merge}(T,U),\\mathsf{merge}(O,W),\\mathsf{merge}(T,U),\\mathsf{merge}(F,R))=1</span>  both hold, we show that  <span class="math">\\mathsf{Lookup}_{\\iota,\\ell}(T,U)=1</span>  holds with probability 1. Our assumption  <span class="math">\\mathsf{Zero}_{\\zeta,\\ell}(R\\cdot R&#x27;-1)=1</span>  immediately implies that, for each  <span class="math">v\\in\\mathcal{B}_\\ell</span> ,  <span class="math">R(v)\\cdot R&#x27;(v)=1</span> , so that  <span class="math">R(v)\\neq 0</span> . Our second assumption is precisely the equality (2) of multisets. From it, we conclude a fortiori that</p>

    <p class="text-gray-300"><span id="page-32-2"></span> <span class="math-block">\\{(U(v), R(v)) \\mid v \\in \\mathcal{B}_{\\ell}\\} \\subset \\{(T(v), 1) \\mid v \\in \\mathcal{B}_{\\ell}\\} \\cup \\{(U(v), \\alpha \\cdot R(v)) \\mid v \\in \\mathcal{B}_{\\ell}\\}</span> (3)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">as multisets. We suppose, for contradiction, that  <span class="math">v_0 \\in \\mathcal{B}_\\ell</span> , say, were such that, for each  <span class="math">v&#x27; \\in \\mathcal{B}_\\ell</span> ,  <span class="math">U(v_0) \\neq T(v&#x27;)</span>  held. Our hypothesis on  <span class="math">v_0</span>  implies that  <span class="math">(U(v_0), R(v_0)) \\notin \\{(T(v), 1) \\mid v \\in \\mathcal{B}_\\ell\\}</span> ; we thus conclude from (3) that  <span class="math">(U(v_0), R(v_0)) \\in \\{(U(v), \\alpha \\cdot R(v)) \\mid v \\in \\mathcal{B}_\\ell\\}</span> , so that  <span class="math">v_1 \\in \\mathcal{B}_\\ell</span> , say, is such that  <span class="math">(U(v_0), R(v_0)) = (U(v_1), \\alpha \\cdot R(v_1))</span> . Since  <span class="math">U(v_1) = U(v_2)</span> , applying (3) again to the pair  <span class="math">(U(v_1), R(v_1))</span> , we find as before an element  <span class="math">v_2 \\in \\mathcal{B}_\\ell</span> , say, for which  <span class="math">(U(v_1), R(v_1)) = (U(v_2), \\alpha \\cdot R(v_2))</span> . Proceeding in this way, we obtain a sequence of elements  <span class="math">v_i \\in \\mathcal{B}_\\ell</span> , for  <span class="math">i \\in \\{0, \\dots, 2^\\ell\\}</span> , for which, for each  <span class="math">i \\in \\{0, \\dots, 2^\\ell - 1\\}</span> ,  <span class="math">R(v_{i+1}) \\cdot \\alpha = R(v_i)</span>  holds. Since  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{B}_\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^\\ell<span class="math"> , by the pigeonhole principle, we must have a collision  </span>v_i = v_j<span class="math"> , for unequal indices i &lt; j, say, in  </span>\\{0, \\dots, 2^\\ell\\}<span class="math"> . We conclude that  </span>R(v_i) = \\alpha^{j-i} \\cdot R(v_j) = \\alpha^{j-i} \\cdot R(v_i)<span class="math"> ; using our guarantee whereby  </span>R(v_i) \\neq 0<span class="math"> , we finally conclude that  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)<span class="math"> , and  </span>R(v_i) = (1, \\dots, 2^\\ell)$ ,</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-33-2"></span>Remark 4.29. The naïve multiplicative adaptation of Spark [STW24, Fig. 2] would neglect to include the pointwise reciprocal R' in Protocol 4.27 above. We argue that this reciprocal is necessary by exhibiting an attack on this simpler variant of Protocol 4.27 (i.e., that which omits R'). (In other words, the everywhere-nonvanishing of R—used in our proof of Theorem 4.28 above—is essential.) Indeed, to attack that protocol,  <span class="math">\\mathcal{P}</span>  may, on an arbitrarily chosen statement U, simply set R identically zero and F identically 1. Having begun in this way, and otherwise proceeding honestly (i.e., in the multiset check),  <span class="math">\\mathcal{P}</span>  will convince the verifier. Indeed, we see directly that, in this setting, W will likewise be identically zero, and that the equality (2) of multisets will hold. This attack's root cause is that the element  <span class="math">0 \\in \\mathcal{T}_{\\zeta}</span>  constitutes a degenerate orbit—of size 1—under the multiplicative  <span class="math">\\alpha</span> -action on  <span class="math">\\mathcal{T}_{\\zeta}</span> . The pairs (U(v), 0) and  <span class="math">(U(v), \\alpha \\cdot 0)</span>  thus balance the right and left multisets, respectively, regardless of U(v) (i.e., regardless of whether it equals T(v') for some  <span class="math">v&#x27; \\in \\mathcal{B}_{\\ell}</span> ).</p>

    <h2 id="sec-27" class="text-2xl font-bold">5 A SNARK over Binary Tower Fields</h2>

    <p class="text-gray-300">We now present a practical SNARK, suitable for general statements over binary tower fields. Its arithmetization scheme—that is, the method by which it algebraically captures general computations—refines the <em>PLONKish</em> scheme of Grigg, Bowe, Hopwood and Lai [GBHL22], and in particular its adaptation, due to Chen, Bünz, Boneh and Zhang's <em>HyperPlonk</em> [CBBZ23, Def. 4.1], to the multivariate setting. The PLONKish arithmetization arranges its witness data into a computational trace, called a <em>trace matrix</em>, of field elements. The scheme moreover makes use of a plurality of <em>gate constraints</em>; these are multivariate polynomials, to be evaluated over the rows of the trace matrix.</p>

    <h3 id="sec-28" class="text-xl font-semibold mt-8">5.1 The PLONK relation</h3>

    <p class="text-gray-300">We define the indexed relation  <span class="math">R_{\\mathsf{PLONK}}</span>  on tuples of the form (i, x; w). The <em>index</em> i captures the public parameters of the constraint system, the <em>statement</em> x represents the circuit's public inputs, and the <em>witness</em> x includes further inputs to the circuit.</p>

    <p class="text-gray-300">The index is defined to be a tuple of the form  <span class="math">i = (\\tau, \\ell, \\xi, n_{\\varphi}, n_{\\psi}, \\iota, a, g, \\sigma)</span> , where:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau \\in \\mathbb{N}</span>  is the height of the maximally-indexed tower step  <span class="math">\\mathcal{T}_{\\tau}</span>  in use,</li>

      <li><span class="math">\\ell \\in \\mathbb{N}</span>  is the base-2 logarithm of the number of trace rows (we require  <span class="math">\\ell \\leq 2^{\\tau}</span> ),</li>

      <li><span class="math">\\xi \\in \\{0, \\dots, \\ell\\}</span>  is the base-2 logarithm of the statement length,</li>

      <li><span class="math">n_{\\varphi} \\in \\mathbb{N}</span>  is the number of fixed columns,</li>

      <li><span class="math">n_{\\psi} \\in \\mathbb{N}</span>  is the number of witness columns,</li>

      <li><span class="math">\\iota:\\{0,\\ldots,n_{\\psi}-1\\}\\to\\{0,\\ldots,\\tau\\}</span>  is a mapping, which assigns to each witness column a tower field index,</li>

      <li><span class="math">a \\in (\\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\ell}})^{n_{\\varphi}}</span>  is the array of fixed columns,</li>

      <li><span class="math">(g_0, \\ldots, g_{\\mu-1})</span>  is a list of  <span class="math">\\ell</span> -variate virtual polynomials, each of which operates over  <span class="math">n_{\\varphi} + n_{\\psi}</span>  handles,</li>

      <li><span class="math">\\sigma: \\{0, \\dots, n_{\\varphi} + n_{\\psi}\\} \\times \\mathcal{B}_{\\ell} \\to \\{0, \\dots, n_{\\varphi} + n_{\\psi}\\} \\times \\mathcal{B}_{\\ell}</span>  defines a plurality of global copy constraints.</li>

    </ul>

    <p class="text-gray-300">The statement is  <span class="math">\\mathbf{x} \\coloneqq x \\in \\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\xi}}</span> , a vector of input values. The witness is  <span class="math">\\mathbf{w} \\coloneqq w \\in \\left(\\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\ell}}\\right)^{n_{\\psi}}</span> , an array of witness columns.</p>

    <p class="text-gray-300">We record several remarks. We assume throughout that  <span class="math">\\tau</span>  is sufficiently large that an injection s:  <span class="math">\\{0,\\ldots,n_{\\varphi}+n_{\\psi}\\}\\times\\mathcal{B}_{\\ell}\\hookrightarrow\\mathcal{T}_{\\tau}</span>  exists. Above, we slightly abuse notation by calling the objects  <span class="math">(g_0,\\ldots,g_{\\mu-1})</span>  "virtual polynomials"; more properly, these are circuits which operate over "placeholder" handles (i.e., handles which don't exist yet). Once the relevant handles become available—i.e., after the indexer and prover commit to the fixed and witness columns, respectively—the verifier may, by "plugging in" the appropriate handles, create from each of these circuits a genuine virtual polynomial. On the other hand, upon being fed real polynomials (as opposed to handles), these virtual polynomials of course become standard polynomials.</p>

    <p class="text-gray-300">For convenience, we write  <span class="math">\\operatorname{pad}_{\\ell}(x) \\in \\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\ell}}</span>  for the zero-extension of the vector  <span class="math">x \\in \\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\xi}}</span>  to the domain  <span class="math">\\mathcal{B}_{\\ell}</span> ; we moreover write  <span class="math">c \\in \\left(\\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\ell}}\\right)^{n_{\\varphi}+n_{\\psi}}</span>  for the concatenation of columns  <span class="math">c \\coloneqq a \\parallel w \\parallel \\operatorname{pad}_{\\ell}(x)</span> . The indexed relation  <span class="math">\\mathcal{R}_{\\mathsf{PLONK}}</span>  holds, by definition, if and only if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1. For each  <span class="math">i \\in \\{0, \\dots, \\mu 1\\}</span> , the polynomial  <span class="math">g_i(c_0, \\dots, c_{n_{\\varphi} + n_{\\psi} 1})</span>  is identically zero over  <span class="math">\\mathcal{B}_{\\ell}</span> .</li>

      <li>2. For each  <span class="math">(i, v) \\in \\{0, \\dots, n_{\\varphi} + n_{\\psi}\\} \\times \\mathcal{B}_{\\ell}</span> , it holds that  <span class="math">c_i(v) = c_{i&#x27;}(v&#x27;)</span> , where we write  <span class="math">(i&#x27;, v&#x27;) := \\sigma(i, v)</span> .</li>

      <li>3. For each  <span class="math">(i, v) \\in \\{0, \\dots, n_{\\psi} 1\\} \\times \\mathcal{B}_{\\ell}</span> , it holds that  <span class="math">w_i(v) \\in \\mathcal{T}_{\\iota(i)} \\subset \\mathcal{T}_{\\tau}</span> .</li>

    </ul>

    <p class="text-gray-300">These three conditions capture, respectively, the witness's satisfaction of all gate constraints, its satisfaction of all global copy constraints, and finally its satisfaction of all subfield constraints. The first two conditions are standard across PLONKish variants (see e.g. [CBBZ23, Def. 4.1]); the third condition is new, and pertains specifically to our tower setting. We note that we do not isolate so-called <em>selector columns</em>, as prior formalizations do (see e.g. [CBBZ23, Sec. 4.1] and [STW23, Sec. 2.2]); instead, we subsume these into our fixed columns a.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.2 Top-Level Protocol</h3>

    <p class="text-gray-300">We now present a tower field multilinear polynomial IOP for the indexed relation  <span class="math">R_{\\mathsf{PLONK}}</span> . On the input i, the indexer  <span class="math">\\mathcal{I}</span> , for each  <span class="math">i \\in \\{0, \\dots, n_{\\varphi} - 1\\}</span> , submits (submit,  <span class="math">\\tau, \\ell, \\widetilde{a_i}</span> ) to the oracle, where  <span class="math">\\widetilde{a_i}</span>  is the MLE of the fixed column  <span class="math">a_i \\in \\mathcal{T}_{\\tau}^{\\mathcal{B}_{\\ell}}</span> , and receives (receipt,  <span class="math">\\tau, \\ell, [a_i]</span> ). Moreover,  <span class="math">\\mathcal{I}</span>  performs the permutation check's setup procedure—already described in detail in advance of Protocol 4.22 above—with respect to the permutation  <span class="math">\\sigma: \\{0, \\dots, n_{\\varphi} + n_{\\psi}\\} \\times \\mathcal{B}_{\\ell} \\to \\{0, \\dots, n_{\\varphi} + n_{\\psi}\\} \\times \\mathcal{B}_{\\ell}</span> ; in this way,  <span class="math">\\mathcal{I}</span>  obtains further handles  <span class="math">[s_{\\mathrm{id}}]</span>  and  <span class="math">[s_{\\sigma}]</span> . Finally,  <span class="math">\\mathcal{I}</span>  outputs the list of handles  <span class="math">\\mathsf{vp} := ([a_0], \\dots, [a_{n_{\\varphi}-1}], [s_{\\mathrm{id}}], [s_{\\sigma}])</span> .</p>

    <h3 id="sec-30" class="text-xl font-semibold mt-8"><strong>PROTOCOL 5.1</strong> (main polynomial IOP for <span class="math">R_{PLONK}</span> ).</h3>

    <p class="text-gray-300">On the security parameter  <span class="math">\\lambda</span> , and common input i and x,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  proceed as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  compute the zero-extension  <span class="math">pad_{\\ell}(c_{\\iota})</span> , as well as its MLE  <span class="math">\\widetilde{pad}_{\\ell}(c_{\\iota})</span> .</li>

      <li>For each  <span class="math">i \\in \\{0, \\dots, n_{\\psi} 1\\}</span> ,  <span class="math">\\mathcal{P}</span>  sends (submit,  <span class="math">\\iota(i), \\ell, w_i</span> ) to the polynomial oracle.</li>

      <li>For each  <span class="math">i \\in \\{0, \\ldots, n_{\\psi}-1\\}</span> , upon receiving (receipt,  <span class="math">\\iota_i, \\ell, [w_i]</span> ) from the oracle,  <span class="math">\\mathcal{V}</span>  checks  <span class="math">\\iota_i \\stackrel{?}{=} \\iota(i)</span> .</li>

    </ul>

    <p class="text-gray-300">We abbreviate  <span class="math">([c_0], \\dots, [c_{n_{\\varphi}+n_{\\psi}-1}]) := ([a_0], \\dots, [a_{n_{\\varphi}-1}], [w_0], \\dots, [w_{n_{\\psi}-1}]).</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">i \\in \\{0, \\dots, \\mu 1\\}</span> ,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  zerocheck the virtual polynomial  <span class="math">g_i([c_0], \\dots, [c_{n_{\\omega} + n_{\\psi} 1}])</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a permutation check, with statement  <span class="math">\\sigma</span> , on the input  <span class="math">([c_0], \\ldots, [c_{n_{\\varphi}+n_{\\psi}}])</span> .</li>

    </ul>

    <h4 id="sec-31" class="text-lg font-semibold mt-6"><strong>Theorem 5.2.</strong> Protocol 5.1 securely computes the relation <span class="math">R_{PLONK}</span> .</h4>

    <p class="text-gray-300"><em>Proof.</em> We construct an emulator  <span class="math">\\mathcal{E}</span> . Our emulator  <span class="math">\\mathcal{E}</span>  operates as follows, given access to  <span class="math">\\mathcal{A}</span> , and to i and x:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>1.  <span class="math">\\mathcal{E}</span>  independently runs  <span class="math">\\mathsf{vp} := \\mathcal{I}(i)</span> , internally simulating the existence of the polynomial oracle.</li>

      <li>2. Using vp, and playing the role of V,  <span class="math">\\mathcal{E}</span>  runs  <span class="math">\\mathcal{A}</span>  internally, and in particular intercepts its submissions (submit,  <span class="math">\\iota_i</span> ,  <span class="math">\\ell</span> ,  <span class="math">w_i</span> ) intended for the polynomial oracle. As V would,  <span class="math">\\mathcal{E}</span>  aborts if, for any index  <span class="math">i \\in \\{0, \\ldots, n_{\\psi} 1\\}</span> , either  <span class="math">\\mathcal{A}</span>  fails to submit the expected witness  <span class="math">w_i</span>  or the tower height  <span class="math">\\iota_i \\neq \\iota(i)</span>  is wrong.</li>

      <li>3.  <span class="math">\\mathcal{E}</span>  continues to simulate the role of  <span class="math">\\mathcal{V}</span>  internally to  <span class="math">\\mathcal{A}</span> , during the course of the virtual protocols prescribed by Protocol 5.1. If, at any point, the verifier  <span class="math">\\mathcal{V}</span>  in  <span class="math">\\mathcal{E}</span> 's head aborts, then  <span class="math">\\mathcal{E}</span>  does too (i.e., it outputs  <span class="math">\\perp</span> ).</li>

      <li><span id="page-34-1"></span>4.  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">\\mathbf{w} := (w_0, \\dots, w_{n_{\\psi}-1})</span>  and terminates.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We argue that  <span class="math">\\mathcal{E}</span>  fulfills the requirements of Definition 4.3 with respect to the relation  <span class="math">R_{\\mathsf{PLONK}}</span> . We note first that  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">\\mathbb{W}</span>  in step 4 above with the same probability with which  <span class="math">\\mathcal{V}</span>  accepts. It follows that the relevant discrepancy  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Pr[\\langle \\mathcal{A}(\\mathbf{i}, \\mathbb{X}), \\mathcal{V}(\\mathsf{vp}, \\mathbb{X}) \\rangle = 1] - \\Pr[R(\\mathbf{i}, \\mathbb{X}, \\mathbb{W}) = 1]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is equal to the probability with which  </span>\\mathcal{A}<span class="math">  submits a well-formed witness  </span>\\mathbb{W}<span class="math">  for which  </span>R(\\mathbf{i}, \\mathbb{X}, \\mathbb{W}) = 0<span class="math">  holds and  </span>\\mathcal{V}<span class="math">  nonetheless accepts. This latter probability is negligible precisely in virtue of the security—in the sense of Definition 4.7—of the zerocheck and permutation check virtual protocols which  </span>\\mathcal{V}<span class="math">  runs with  </span>\\mathcal{A}$  in Protocol 5.1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-32" class="text-xl font-semibold mt-8">5.3 Gadgets</h3>

    <p class="text-gray-300">In this subsection, we record composable gadgets for various key operations, including unsigned integer addition and multiplication. In our setting, a "gadget" is a special sort of virtual polynomial protocol in which the predicate at hand may apply not just to input columns—that is, to polynomials known to both parties before the protocol begins—but moreover to further virtual polynomials which arise during the protocol. Informally, a gadget is a virtual protocol in which, if the verifier doesn't abort, the parties output a further virtual polynomial, which necessarily relates to the protocol's inputs in a prescribed way. This slight relaxation of Definition 4.7 doesn't change the spirit of that definition.</p>

    <p class="text-gray-300"><strong>Addition.</strong> We record a simple gadget for the addition of unsigned integers. Our construction, informally, captures the raw relationship at the level of bits, using a few simple  <span class="math">\\mathbb{F}_2</span> -constraints, as well as a shift (see Subsection 4.3); it then uses the packing operator to materialize the relevant bit-columns into virtual columns of blocks.</p>

    <p class="text-gray-300">We fix a column size  <span class="math">\\ell \\geq 0</span>  and a bit-width  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span> . On inputs X, Y, and Z in  <span class="math">\\mathcal{T}_0^{\\mathcal{B}_\\ell}</span> , the addition predicate sends  <span class="math">\\mathsf{Add}_{\\ell,b} : (X,Y,Z) \\mapsto \\bigwedge_{v \\in \\mathcal{B}_{\\ell-b}} \\{\\mathsf{pack}_b(X)(v)\\} + \\{\\mathsf{pack}_b(Y)(v)\\} \\equiv \\{\\mathsf{pack}_b(Z)(v)\\} \\pmod{2^{2^b}}</span> . That is, the addition predicate requires that, for each  <span class="math">v \\in \\mathcal{B}_{\\ell-b}</span> , the elements  <span class="math">\\mathsf{pack}_b(X)(v)</span> ,  <span class="math">\\mathsf{pack}_b(Y)(v)</span> , and  <span class="math">\\mathsf{pack}_b(Z)(v)</span>  of  <span class="math">\\mathcal{T}_b</span>  respectively have monomial basis representations  <span class="math">x = (x_0, \\dots, x_{2^b-1}), y = (z_0, \\dots, z_{2^b-1}),</span>  and  <span class="math">z = (z_0, \\dots, z_{2^b-1})</span>  for which  <span class="math">\\{x\\} + \\{y\\} \\equiv \\{z\\} \\pmod{2^{2^b}}</span>  holds (as usual, we write  <span class="math">\\{v\\} := \\sum_{i=0}^{2^b-1} 2^i \\cdot v_i</span> ).</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">PROTOCOL 5.3 (Addition gadget).</h4>

    <p class="text-gray-300">Parameters  <span class="math">\\ell \\in \\mathbb{N}</span>  and  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span>  and  <span class="math">\\ell</span> -variate virtual polynomials [X] and [Y] over  <span class="math">\\mathcal{T}_0</span>  are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By performing  <span class="math">2^{\\ell-b}</span>  independent  <span class="math">2^b</span> -bit ripple-carry additions,  <span class="math">\\mathcal{P}</span>  obtains the vector of carry-outs  <span class="math">c_{\\text{out}} \\in \\mathcal{T}_0^{\\mathcal{B}_{\\ell}}</span> .  <span class="math">\\mathcal{P}</span>  submits (submit,  <span class="math">0, \\ell, \\widetilde{c_{\\text{out}}}</span> ) to the oracle.</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  define  <span class="math">\\ell</span> -variate virtual polynomials  <span class="math">c_{\\text{in}} := \\mathtt{shift}&#x27;_{b,1}(c_{\\text{out}})</span>  and  <span class="math">Z := X + Y + c_{\\text{in}}</span>  over  <span class="math">\\mathcal{T}_0</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  zerocheck the  <span class="math">\\ell</span> -variate virtual polynomial  <span class="math">X \\cdot Y + X \\cdot c_{\\text{in}} + Y \\cdot c_{\\text{in}} c_{\\text{out}}</span>  over  <span class="math">\\mathcal{T}_0</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  output Z.</li>

    </ul>

    <p class="text-gray-300"><strong>Theorem 5.4.</strong> Protocol 5.3 securely decides the predicate  <span class="math">Add_{\\ell,b}</span>  on [X], [Y] and [Z].</p>

    <p class="text-gray-300">Proof. Indeed, assuming that  <span class="math">\\mathsf{Zero}_{0,\\ell}(X \\cdot Y + X \\cdot c_{\\mathsf{in}} + Y \\cdot c_{\\mathsf{in}} - c_{\\mathsf{out}}) = 1</span> , we show that  <span class="math">\\mathsf{Add}_{\\ell,b}(X,Y,Z)</span>  holds with probability 1. Protocol 5.3 captures the action of a ripple-carry adder on each  <span class="math">2^b</span> -bit chunk of the inputs X and Y. Indeed, our hypothesis entails exactly that the  <span class="math">\\mathbb{F}_2</span> -identity  <span class="math">X \\cdot Y + X \\cdot c_{\\mathsf{in}} + Y \\cdot c_{\\mathsf{in}} = c_{\\mathsf{out}}</span>  holds identically over  <span class="math">\\mathcal{B}_\\ell</span> . This shows that, logically,  <span class="math">c_{\\mathsf{out}} = X \\wedge Y \\vee X \\wedge c_{\\mathsf{in}} \\vee Y \\wedge c_{\\mathsf{in}}</span>  holds identically over  <span class="math">\\mathcal{B}_\\ell</span> , so that  <span class="math">c_{\\mathsf{out}}</span>  relates as required to X, Y and  <span class="math">c_{\\mathsf{in}}</span> . On the other hand, the relationship between  <span class="math">c_{\\mathsf{in}}</span>  and  <span class="math">c_{\\mathsf{out}}</span>  is correct, by definition of  <span class="math">\\mathsf{shift}&#x27;_{b,1}</span> . We conclude that  <span class="math">Z \\coloneqq X + Y + c_{\\mathsf{in}}</span>  has the required property.  <span class="math">\\square</span></p>

    <p class="text-gray-300"><strong>Multiplication.</strong> We now describe a gadget which captures unsigned integer multiplication. For each  <span class="math">\\ell \\geq 0</span>  and  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span> , we define the <em>multiplication predicate</em>  <span class="math">\\mathsf{Mult}_{\\ell,b}(X,Y,Z) \\mapsto \\bigwedge_{v \\in \\mathcal{B}_{\\ell-b}} \\{\\mathsf{pack}_b(X)(v)\\} \\cdot \\{\\mathsf{pack}_b(Y)(v)\\} \\equiv \\{\\mathsf{pack}_b(Z)(v)\\} \\pmod{2^{2^b}}.</span></p>

    <p class="text-gray-300">Informally, our multiplication gadget executes the schoolbook algorithm on a-bit words, where a, a tunable parameter, controls the size of a certain lookup table. We check the relevant word-by-word multiplications using lookups; the remaining work amounts to appropriately combining the results of the various word-wise multiplications.</p>

    <p class="text-gray-300">We fix a lookup table size parameter  <span class="math">a \\in \\{0, \\dots, b-1\\}</span> . We recall the multilinear  <span class="math">\\mathcal{T}_a</span> -basis  <span class="math">1, X_a, X_{a+1}, X_a \\cdot X_{a+1}</span>  of  <span class="math">\\mathcal{T}_{a+2}</span> . We define the multiplication lookup table  <span class="math">T \\in \\mathcal{T}_{a+2}^{\\mathcal{B}_{2^a} \\times \\mathcal{B}_{2^a}}</span>  as follows:</p>

    <div class="my-4 text-center"><span class="math-block">T: (x,y) \\mapsto x \\cdot 1 + y \\cdot X_a + z_0(x,y) \\cdot X_{a+1} + z_1(x,y) \\cdot X_a \\cdot X_{a+1}.</span></div>

    <p class="text-gray-300">Above, we first identify the  <span class="math">\\mathcal{B}_{2^a}</span> -elements x and y with  <span class="math">\\mathcal{T}_a</span> -elements, by means of the multilinear  <span class="math">\\mathbb{F}_2</span> -basis of  <span class="math">\\mathcal{T}_a</span> . Moreover, we write  <span class="math">z_0(x,y)</span>  and  <span class="math">z_1(x,y)</span>  for the unique  <span class="math">\\mathcal{T}_a</span> -elements for which  <span class="math">\\{z_0(x,y)\\}+2^{2^a}\\cdot\\{z_1(x,y)\\}=1</span></p>

    <p class="text-gray-300"> <span class="math">\\{x\\} \\cdot \\{y\\}</span>  holds; here, the right-hand quantity is a simple product of integers. In words,  <span class="math">z_0(x,y)</span>  and  <span class="math">z_1(x,y)</span> , on the level of bits, respectively give the lower and upper halves of the  <span class="math">2 \\cdot 2^a</span> -bit integer product  <span class="math">\\{x\\} \\cdot \\{y\\}</span> . Informally, the lookup table T takes, as its values over the  <span class="math">2^a + 2^a</span> -dimensional hypercube, precisely the concatenations  <span class="math">x \\parallel y \\parallel x \\cdot y</span>  of the "legal" multiplication triples (this concatenation takes place in  <span class="math">\\mathcal{T}_{a+2}</span> ).</p>

    <p class="text-gray-300">We how have the following virtual polynomial protocol:</p>

    <h4 id="sec-34" class="text-lg font-semibold mt-6">PROTOCOL 5.5 (Multiplication gadget).</h4>

    <p class="text-gray-300">Parameters  <span class="math">\\ell \\in \\mathbb{N}</span> ,  <span class="math">b \\in \\{0, \\dots, \\ell\\}</span> , and  <span class="math">a \\in \\{0, \\dots, b-1\\}</span> , as above, the lookup table  <span class="math">T \\in \\mathcal{T}_{a+2}^{\\mathcal{B}_{2a+1}}</span> , and finally  <span class="math">\\ell</span> -variate virtual polynomials [X] and [Y] over  <span class="math">\\mathcal{T}_0</span>  are fixed.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  initialize the identically-zero  <span class="math">\\ell</span> -variate virtual column [Z] over  <span class="math">\\mathcal{T}_0</span> .</li>

      <li>For each  <span class="math">u \\in \\mathcal{B}_{b-a}</span> ,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  proceed as follows:</li>

      <li><span class="math">\\ \\mathcal{P} \\ \\text{and} \\ \\mathcal{V} \\ \\text{abbreviate} \\ X_u \\coloneqq \\mathtt{shift}&#x27;_{b-a,u}(\\mathtt{pack}_a(X)) \\ \\text{and} \\ Y_u \\coloneqq \\mathtt{sat}_{b-a,u}(\\mathtt{pack}_a(Y)).</span></li>

      <li><span class="math">\\mathcal{P}</span>  constructs the array  <span class="math">\\mathbf{cross}_u := (z_0(X_u(v), Y_u(v)) + z_1(X_u(v), Y_u(v)) \\cdot X_a)_{v \\in \\mathcal{B}_{\\ell-a}}</span>  in  <span class="math">\\mathcal{T}_{a+1}^{\\mathcal{B}_{\\ell-a}}</span> , where  <span class="math">z_0</span>  and  <span class="math">z_1</span>  are as above, and submits (submit,  <span class="math">a+1, \\ell-a, \\widetilde{\\mathbf{cross}}_u</span> ) to the oracle.</li>

      <li><span class="math">-\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  perform a lookup on  <span class="math">U_u := X_u \\cdot 1 + Y_u \\cdot X_a + \\mathbf{cross}_u \\cdot X_{a+1}</span>  against T.</li>

      <li>For each parity bit  <span class="math">j \\in \\{0,1\\}</span> ,  <span class="math">\\mathcal{P}</span>  defines  <span class="math">\\mathbf{aux}_{u,j} \\in \\mathcal{T}_0^{\\mathcal{B}_\\ell}</span>  by concatenating the bits of the  <span class="math">2^{\\ell-a-1}</span>   <span class="math">\\mathcal{T}_{a+1}</span> -elements of the substring  <span class="math">(\\mathbf{cross}_u(j, v_1, \\dots, v_{\\ell-a-1}))_{v \\in \\mathcal{B}_{\\ell-a-1}}</span> .  <span class="math">\\mathcal{P}</span>  submits  <span class="math">(\\mathbf{submit}, 0, \\ell, \\widetilde{\\mathbf{aux}}_0)</span>  and  <span class="math">(\\mathbf{submit}, 0, \\ell, \\widetilde{\\mathbf{aux}}_1)</span>  to the oracle.  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  run a zerocheck on the  <span class="math">\\ell-a</span> -variate polynomial  <span class="math">\\mathbf{merge}(\\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,0}), \\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,1})) \\mathbf{cross}_u</span>  over  <span class="math">\\mathcal{T}_{a+1}</span> .</li>

      <li>By running the addition gadget twice, each time with block parameter b,  <span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  update  <span class="math">Z += \\mathbf{aux}_{u,0} + \\mathbf{shift}&#x27;_{b,2^a}(\\mathbf{aux}_{u,1})</span> .</li>

      <li><span class="math">\\mathcal{P}</span>  and  <span class="math">\\mathcal{V}</span>  output the virtual polynomial [Z].</li>

    </ul>

    <p class="text-gray-300">In the last line of the main loop, we slightly abuse notation by writing  <span class="math">\\mathtt{shift}&#x27;_{b,2^a}</span>  to mean  <span class="math">\\mathtt{shift}&#x27;_{b,o}</span> , where  <span class="math">o := (0,\\ldots,0,1,0,\\ldots,0)</span>  (i.e.,  <span class="math">\\{o\\} = 2^a</span> ).</p>

    <p class="text-gray-300">The completeness of Protocol 5.5 is a straightforward, though delicate, exercise. We note that, for each  <span class="math">u \\in \\mathcal{B}_{b-a}</span> , the elements  <span class="math">\\mathbf{aux}_0</span>  and  <span class="math">\\mathbf{aux}_1</span>  of  <span class="math">\\mathcal{T}_0^{\\mathcal{B}_\\ell}</span>  are defined precisely so that  <span class="math">\\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,0})</span>  and  <span class="math">\\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,1})</span>  respectively yield the even and odd substrings of  <span class="math">\\mathbf{cross}_u</span> . In other words, the equality  <span class="math">\\mathbf{merge}(\\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,0}), \\mathbf{pack}_{a+1}(\\mathbf{aux}_{u,1})) = \\mathbf{cross}_u</span>  ensured during the zerocheck holds essentially by fiat. The completeness of the lookups follows directly from the construction of  <span class="math">\\mathbf{cross}_u</span> .</p>

    <p class="text-gray-300"><strong>Theorem 5.6.</strong> Protocol 5.5 securely decides the predicate  <span class="math">Mult_{\\ell,b}</span>  on [X], [Y] and [Z].</p>

    <p class="text-gray-300">Proof. If  <span class="math">\\mathcal{V}</span>  accepts, then  <span class="math">\\mathsf{Lookup}(T, U_u) = 1</span>  holds for each  <span class="math">u \\in \\mathcal{B}_{b-a}</span> ; in particular, for each  <span class="math">u \\in \\mathcal{B}_{b-a}</span>  and each  <span class="math">v \\in \\mathcal{B}_{\\ell-a}</span> , we have the equality  <span class="math">\\{\\mathsf{cross}_u(v)\\} = \\{\\mathsf{shift}&#x27;_{b-a,u}(\\mathsf{pack}_a(X))(v)\\} \\cdot \\{\\mathsf{sat}_{b-a,u}(\\mathsf{pack}_a(Y))(v)\\}</span>  of unsigned,  <span class="math">2^{a+1}</span> -bit integers. Unwinding the definitions of  <span class="math">\\mathsf{shift}&#x27;_{b-a,u}</span>  and  <span class="math">\\mathsf{sat}_{b-a,u}</span> , we conclude further that, for each iteration  <span class="math">u \\in \\mathcal{B}_{b-a}</span>  as above and each chunk index  <span class="math">(v_{b-a},\\ldots,v_{\\ell-a-1})</span> , the vector  <span class="math">\\mathsf{cross}_u</span> , restricted to the chunk indexed by  <span class="math">(v_{b-a},\\ldots,v_{\\ell-a-1})</span> , contains exactly the  <span class="math">2^{b-a}</span>  double-width cross terms  <span class="math">\\{\\mathsf{pack}_a(X)(s_0,\\ldots,s_{b-a-1},v_{b-a},\\ldots,v_{\\ell-a-1})\\} \\cdot \\{\\mathsf{pack}_a(Y)(u_0,\\ldots,u_{b-a-1},v_{b-a},\\ldots,v_{\\ell-a-1})\\}</span> , where the strings  <span class="math">s \\coloneqq (s_0,\\ldots,s_{b-a-1})</span>  are such that  <span class="math">\\{s\\}</span>  ranges through the list  <span class="math">(0,\\ldots,0,1,2,\\ldots,2^{b-a}-1-\\{u\\})</span> . In words,  <span class="math">(\\mathsf{cross}_u(w_0,\\ldots,w_{b-a-1},v_{b-a},\\ldots,v_{\\ell-a}))_{w\\in\\mathcal{B}_{b-a}}</span>  yields precisely the  <span class="math">\\{u\\}^{\\text{th}}</span>  row of the triangular array associated with the schoolbook multiplication of  <span class="math">(\\mathsf{pack}_a(X)(w_0,\\ldots,w_{b-a-1},v_{b-a},\\ldots,v_{\\ell-a-1}))_{w\\in\\mathcal{B}_{b-a}}</span>  and  <span class="math">(\\mathsf{pack}_a(Y)(w_0,\\ldots,w_{b-a-1},v_{b-a},\\ldots,v_{\\ell-a-1}))_{w\\in\\mathcal{B}_{b-a}}</span> , which we understand  <span class="math">2^{b-a}</span> -limb integers. Each cell of this array, moreover, is double-width—that is,  <span class="math">2^{a+1}</span>  bits—and needs to be reduced.</p>

    <p class="text-gray-300">To "fold" the elements of this row, with carries, we use a trick. Working modulo  <span class="math">2^{2^b}</span> , we must add the  <span class="math">2^{b-a}</span>   <span class="math">2^{a+1}</span> -bit elements of each chunk of  <span class="math">\\mathbf{cross}_u</span> , after shifting each successive element moreover by  <span class="math">2^a</span>  further positions (and truncating the most-significant  <span class="math">2^a</span>  bits of the last-indexed element in each chunk).</p>

    <p class="text-gray-300">Upon writing each integer in its proper place, we find that the even-indexed components of the chunk—corresponding to those indices  <span class="math">(0, w_1, \\ldots, w_{b-a-1}, v_{b-a}, \\ldots, v_{\\ell-a-1})</span> , for  <span class="math">(w_1, \\ldots, w_{b-a-1}) \\in \\mathcal{B}_{b-a-1}</span> —don't overlap; the odd-indexed components  <span class="math">(1, w_1, \\ldots, w_{b-a-1}, v_{b-a}, \\ldots, v_{\\ell-a-1})</span>  similarly lack overlaps. We thus "lift" both of these respective substrings to bit-vectors, so that we can add them. The bit-vectors  <span class="math">\\mathbf{aux}_{u,0}</span>  and  <span class="math">\\mathbf{aux}_{u,1}</span> , we see, are defined to be the respective lifts to  <span class="math">\\mathcal{T}_0^{\\mathcal{B}_\\ell}</span>  of the even and odd substrings of  <span class="math">\\mathbf{cross}_u</span> ; the verifier's zerocheck ensures that they take exactly this form. It thus remains only to show that, for each block index  <span class="math">(v_{b-a}, \\ldots, v_{\\ell-a-1})</span> , we have that  <span class="math">\\sum_{w \\in \\mathcal{B}_{b-a}} 2^{\\{w\\} \\cdot a} \\cdot \\{\\mathbf{cross}_u(w_0, \\ldots, w_{b-a-1}, v_{b-a}, \\ldots, v_{\\ell-a-1})\\} \\equiv \\{\\mathbf{pack}_b(\\mathbf{aux}_{u,0})(v_{b-a}, \\ldots, v_{\\ell-a-1})\\} + \\{\\mathbf{pack}_b(\\mathbf{shift}&#x27;_{b,2^a}(\\mathbf{aux}_{u,1}))(v_{b-a}, \\ldots, v_{\\ell-a-1})\\} \\pmod{2^b}</span> . We observe finally that the two terms on this expression's right-hand side correspond precisely to its left-hand sum's even-indexed and odd-indexed subset sums. This completes the proof.</p>

    <p class="text-gray-300">We finally remark upon the efficiency of Protocol 5.5. Protocol 5.5 entails  <span class="math">O(2^{b-a})</span>  executions of the addition gadget, as well as  <span class="math">2^{b-a}</span>  lookups, each into tables T and  <span class="math">U_u</span>  sized  <span class="math">2^{2^{a+1}}</span>  and  <span class="math">2^{\\ell-a}</span> , respectively. The parameter  <span class="math">a \\in \\{0, \\ldots, b-1\\}</span> , we see, mediates a tradeoff between <em>more lookups</em> and <em>more expensive lookups</em>; those choices of a for which these costs become similar appear to be the best.</p>

    <p class="text-gray-300"><span id="page-37-1"></span>Example 5.7. In the case  <span class="math">\\ell := 20</span>  and b := 5, Protocol 5.5 yields a multiplication gadget for 32-bit integers. Setting a := 3, we obtain a <em>limb size</em> of  <span class="math">2^3 = 8</span>  bits, as well as a lookup table T—of size  <span class="math">2^{2^{3+1}} = 2^{16}</span> —which contains all possible byte-by-byte products. Finally, each looked-up column  <span class="math">U_u</span>  is of size  <span class="math">2^{20-3} = 2^{17}</span> . These sizes thus all-but balance, and seem to be optimal. In this setting, we see that Protocol 5.5 proceeds by performing the schoolbook method, chunk-wise, on pairs of 4-limb integers, using lookups to handle each individual product of bytes.</p>

    <p class="text-gray-300">Remark 5.8. Protocol 5.5 works only for those limb size parameters a strictly smaller than the block size parameter b. In words, it requires that strictly more than one limb-by-limb product be performed throughout the course of each  <span class="math">2^b</span> -bit integer product. While a variant of Protocol 5.5 adapted to the extreme case a = b—that is, to the case of "one-shot" lookup-based products—should be possible (and in fact, should be somewhat simpler than that which we give), the tables therein required would be impracticably large in most interesting parameter regimes. (Specifically, they would be of size  <span class="math">2^{2^{b+1}}</span> ; we refer to Example 5.7 above.) We have opted not to pursue this line of inquiry.</p>

    <h3 id="sec-35" class="text-xl font-semibold mt-8">5.4 Keccak-256 Arithmetization</h3>

    <p class="text-gray-300">In this subsection, we supply a PLONKish arithmetization (in the sense of Subsection 5.1 above) of the Keccak-f[1600] permutation [BDPV11, § 1.2], which resides at the heart of the Keccak family of sponge functions. The Keccak-256 hash function in particular represents a core bottleneck facing modern efforts to scale Ethereum using SNARKs. Our arithmetization captures the correct computation of Keccak-f[1600], and exploits the unique advantages of our tower-field setting.</p>

    <p class="text-gray-300">We recall the full Keccak-f[b] permutation. We follow the treatment of that algorithm given in [BDPV11, § 1.2], as well as a pseudocode description given online. The permutation state consists of a b-bit-array  <span class="math">A \\in \\mathbb{F}_2^{5 \\times 5 \\times w}</span> , where  <span class="math">w \\coloneqq 2^{\\ell}</span>  for some power  <span class="math">\\ell \\in \\{0, \\dots, 6\\}</span>  (below, we in fact fix  <span class="math">\\ell \\coloneqq 6</span> , so that b = 1600). We understand A throughout as a  <span class="math">5 \\times 5</span>  array of lanes, or w-bit words (see [BDPV11, Fig. 1.1]), and index into it accordingly. We define addition and multiplication on lanes componentwise; to avoid confusion, we denote using the symbol \\* the componentwise multiplication of lanes (i.e., the bitwise AND operation). The intermediate value B below takes the same shape as A does; the objects C and D below are one-dimensional, length-5 arrays of lanes. We understand all indices into these arrays modulo 5. We moreover make use of various constants. That is, we have a number  <span class="math">n_r</span>  of rounds (per Keccak's specification, we set  <span class="math">n_r := 12 + 2 \\cdot \\ell = 24</span> ); as well as a  <span class="math">5 \\times 5</span>  array  <span class="math">r \\in \\{0, \\dots, w-1\\}^{5 \\times 5}</span>  of rotation offsets, whose derivation is explained in [BDPV11, § 1.2]. We finally have an array RC of round constants, whose construction is again detailed in [BDPV11, § 1.2]; for each  <span class="math">i_r \\in \\{0, \\dots, n_r-1\\}</span> ,  <span class="math">RC[i_r] \\in \\mathbb{F}_2^w</span>  is a single binary word. We reproduce the Keccak-f[b] permutation in full in Algorithm 1 below.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6"><strong>Algorithm 1</strong> (Keccak-f[b] permutation [BDPV11].)</h4>

    <pre><code class="language-text">1: procedure Keccak-f[b](A)
        for i_{\\rm r} \\in \\{0, \\dots, n_{\\rm r} - 1\\} do
2:
             for x \\in \\{0, ..., 4\\} do C[x] := A[x, 0] + A[x, 1] + A[x, 2] + A[x, 3] + A[x, 4].
                                                                                                                                \\triangleright begin \\theta step
3:
             for x \\in \\{0, ..., 4\\} do D[x] := C[x-1] + rot(C[x+1], 1).
4:
             for (x,y) \\in \\{0,\\ldots,4\\} \\times \\{0,\\ldots,4\\} do A[x,y] += D[x].
5:
             for (x, y) \\in \\{0, \\dots, 4\\} \\times \\{0, \\dots, 4\\} do B[y, 2 \\cdot x + 3 \\cdot y] := rot(A[x, y], r[x, y]).
                                                                                                                              \\triangleright \\gamma and \\pi steps
6:
             for (x,y) \\in \\{0,\\ldots,4\\} \\times \\{0,\\ldots,4\\} do A[x,y] = (B[x+1,y]+1) * B[x+2,y].
7:
                                                                                                                                        \\triangleright \\chi \\text{ step}
             A[0,0] += RC[i_r].
8:
                                                                                                                                         \\triangleright \\iota \\text{ step}</code></pre>

    <p class="text-gray-300">We build our PLONK constraint system for Keccak-f[1600] over two tower fields,  <span class="math">\\mathcal{T}_0</span>  and  <span class="math">\\mathcal{T}_6</span> . We take the liberty of defining the constraint system over committed columns of different lengths, linking them by means of a packing argument (see Subsection 4.3). The constraint system has  <span class="math">2^5</span>  rows, so that it can accommodate  <span class="math">n_{\\rm T}=24</span>  rounds; it uses one row per round. It uses two fixed columns:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">q_{\\text{round}} \\in \\mathcal{T}_0[X_0, ..., X_4]^{\\leq 1}</span>  is the selector for the round computation. It takes the value 1 on those cube points lexicographically indexed  <span class="math">\\{0, ..., 23\\}</span>  and 0 on the points indexed  <span class="math">\\{24, ..., 31\\}</span> . This polynomial has a simple description as a multilinear extension over the dimension-5 cube, and so can be efficiently evaluated locally by the verifier (i.e., without the aid of a commitment or an opening proof).</li>

      <li><span class="math">\\mathbf{RC} \\in \\mathcal{T}_6[X_0,...,X_4]^{\\leq 1}</span>  is the column of 64-bit round constants.</li>

    </ul>

    <p class="text-gray-300">The permutation state is committed in the following group of columns:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{A} \\in (\\mathcal{T}_0[X_0,...,X_{10}]^{\\leq 1})^{5\\times 5}</span>  captures the 25 lanes of state, as of the beginning of each successive round.</li>

      <li><span class="math">\\mathbf{C} \\in (\\mathcal{T}_0[X_0,...,X_{10}]^{\\leq 1})^5</span>  represents C in the  <span class="math">\\theta</span>  step above.</li>

      <li><span class="math">\\mathbf{D} \\in (\\mathcal{T}_0[X_0,...,X_{10}]^{\\leq 1})^5</span>  represents D in the  <span class="math">\\theta</span>  step above.</li>

      <li><span class="math">\\mathbf{A}^{\\chi} \\in \\left(\\mathcal{T}_0[X_0,...,X_{10}]^{\\leq 1}\\right)^{5\\times 5}</span>  captures the state of A as of the conclusion of the  <span class="math">\\chi</span>  step.</li>

    </ul>

    <p class="text-gray-300">We further define a series of virtual polynomials:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathbf{A}^{\\theta} \\in (\\mathcal{T}_0[X_0,...,X_{10}]^{\\leq 1})^{5\\times 5}</span>  represents the state of A as of the conclusion of the  <span class="math">\\theta</span>  step. For each  <span class="math">x \\in \\{0,...,4\\}</span>  and  <span class="math">y \\in \\{0,...,4\\}</span> , we define  <span class="math">\\mathbf{A}^{\\theta}_{x,y} \\coloneqq \\mathbf{A}_{x,y} + \\mathbf{D}_x</span> .</li>

      <li><span class="math">\\mathbf{B} \\in (\\mathcal{T}_0[X_0, ..., X_{10}]^{\\leq 1})^{5 \\times 5}</span>  represents the state of B as of the conclusion of the  <span class="math">\\pi</span>  and  <span class="math">\\gamma</span>  steps. For each  <span class="math">x \\in \\{0, ..., 4\\}</span>  and  <span class="math">y \\in \\{0, ..., 4\\}</span> , we define  <span class="math">\\mathbf{B}_{y,2x+3y} := \\mathbf{shift}_{6,r(x,y)}(\\mathbf{A}_{x,y}^{\\theta})</span> .</li>

    </ul>

    <p class="text-gray-300">We impose the following gate constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each  <span class="math">x \\in \\{0, ..., 4\\}</span> ,  <span class="math">\\mathbf{C}_x \\sum_{y=0}^4 \\mathbf{A}_{x,y} = 0</span> .</li>

      <li>For each  <span class="math">x \\in \\{0, ..., 4\\}</span> ,  <span class="math">\\mathbf{C}_{x-1} + \\mathtt{shift}_{6,1}(\\mathbf{C}_{x+1}) \\mathbf{D}_x = 0</span> .</li>

      <li>For each  <span class="math">(x,y) \\in \\{0,...,4\\} \\times \\{0,...,4\\}, \\mathbf{A}_{x,y}^{\\chi} ((1 \\mathbf{B}_{x+1,y}) \\cdot \\mathbf{B}_{x+2,y}) = 0.</span></li>

      <li><span class="math">\\bullet \\ q_{\\mathrm{round}} \\cdot \\left( \\mathtt{pack}_6 \\big( \\mathbf{A}_{0,0}^{\\chi} \\big) + \\mathbf{RC} \\mathtt{shift}_{5,-1}&#x27;&#x27;(\\mathtt{pack}_6 (\\mathbf{A}_{0,0})) \\right) = 0.</span></li>

      <li><span class="math">\\bullet \\ \\ \\text{For each} \\ (x,y) \\in \\{0,...,4\\} \\times \\{0,...,4\\} \\setminus \\{(0,0)\\}, \\ q_{\\text{round}} \\cdot \\left( \\texttt{shift}_{5,-1}&#x27;&#x27;(\\texttt{pack}_6(\\mathbf{A}_{x,y})) \\texttt{pack}_6(\\mathbf{A}_{x,y}^\\chi) \\right) = 0.</span></li>

    </ul>

    <p class="text-gray-300">Provided that these constraints are fulfilled, the arrays  <span class="math">(\\operatorname{pack}_6(A_{x,y})(v))_{(x,y)\\in\\{0,\\dots,4\\}\\times\\{0,\\dots,4\\}}</span> , for the rowindices  <span class="math">\\{v\\}=0</span>  and  <span class="math">\\{v\\}=24</span>  respectively, are related exactly by the KECCAK-f[1600] permutation.</p>

    <h3 id="sec-37" class="text-xl font-semibold mt-8">6 Performance Evaluation</h3>

    <p class="text-gray-300">We describe this work's concrete performance, leveraging <em>Binius</em>, an open-source production-grade Rust implementation of our protocol.</p>

    <p class="text-gray-300">We begin by benchmarking our protocol's polynomial commitment and sumcheck tasks, which jointly dominate our prover's overall computation. We further benchmark our protocol's end-to-end performance on the Keccak-f task, which entails proving the validity of a plurality of independent invocations of the Keccak-f[1600] permutation (see Subsection 5.4 above). This task represents a critical subroutine in SNARKs which prove the validity of Ethereum blocks. Our protocol beats the state-of-the-art in both of these tasks, as we demonstrate in our tables below.</p>

    <p class="text-gray-300">Binius of course implements the requisite tower field arithmetic primitives. We use the Intel Galois Field New Instructions (GFNI) instruction set extension to accelerate the Wiedemann tower's fundamental multiplication and inversion operations. The GFNI extension includes the SIMD instruction GF2P8MULB, which multiplies elements of the field  <span class="math">\\mathbb{F}_{2^8} \\cong \\mathbb{F}_2[X]/(X^8+X^4+X^3+X+1)</span> . This latter instruction assumes a monomial—as opposed to a tower— <span class="math">\\mathbb{F}_2</span> -basis of  <span class="math">\\mathbb{F}_{2^8}</span> ; we convert between these representations using the further instruction GF2P8AFFINEQB. That is, by using these instructions together, we obtain a short sequence of CPU instructions which multiplies  <span class="math">\\mathbb{F}_{2^8}</span> -elements expressed in coordinates with respect to the multilinear basis. For those towers  <span class="math">\\mathcal{T}_{\\iota}</span>  for which  <span class="math">\\iota &gt; 3</span> , we use the binary, recursive Karatsuba approach discussed above (see Subsection 2.3), though we terminate its recursion at the base case  <span class="math">\\iota = 3</span> .</p>

    <p class="text-gray-300">We benchmark our polynomial commitment scheme's performance on polynomials over 1-bit, 8-bit, and 32-bit binary fields. The scheme of Subsection 3.4 works with any collision-resistant hash function; we instantiate that scheme with Grøstl, which—as has been explained above—is both performant and recursion-friendly. We use the Reed–Solomon code with rate  <span class="math">\\frac{1}{4}</span>  throughout. We present benchmarks for both singlethreaded execution (in Table 2) and multithreaded execution (in Table 3).</p>

    <p class="text-gray-300">We benchmark our protocol against two high-performance software implementations of alternative schemes. First, we benchmark against the Lasso open-source project's implementation of Wahby et al.'s Hyrax [Wah+18], using the BN254 elliptic curve. The latter library uses the well-known arkworks project [ark22], as well as certain further optimizations specific to the commitment of small-valued field elements. The Lasso project makes efficient use of multithreading during its commitment phase. We further benchmark against Plonky3, which implements FRI-PCS, itself parameterized so as to attain 100 bits of provable security (in the unique decoding regime). Though Plonky3's FRI-PCS is univariate—while the other schemes we benchmark here are multilinear—we find our comparison against it informative, in view of its highly-regarded performance. Like our construction, FRI-PCS can be used with any collision-resistant hash function, as well as with Reed-Solomon codes of arbitrary rate. We thus benchmark that scheme under both the Poseidon and Keccak-256 hash functions; we note that Poseidon, though slower, is often used in practice for its recursionfriendliness. We moreover use the rate- <span class="math">\\frac{1}{2}</span>  Reed-Solomon code, to match that used in our benchmarks of our own construction. Plonky3 also implements multithreading, but performs best on batched polynomial commitments (as opposed to on single polynomial commitments). To present a fairer comparison, we specialize that scheme to the batched case during both commitment and evaluation. Specifically, we benchmark that scheme on batches consisting of 256 polynomials. We find, as expected, that the FRI-PCS commits elements smaller than 31 bits no faster than it does 31-bit elements; we thus accordingly unify the results we present.</p>

    <p class="text-gray-300">Table 4 describes our sumcheck prover's performance. The performance profile of the sumcheck protocol's prover depends on the form of the virtual polynomial upon which that protocol is applied. We adopt the standard course whereby we benchmark only multivariate polynomials defined as products of several multilinears. Specifically, we present results corresponding to the products of 2, 3, and 4 multilinears. We first benchmark our sumcheck prover in the tower field  <span class="math">\\mathcal{T}_7 \\cong \\mathbb{F}_{2^{128}}</span> . We moreover benchmark the sumcheck prover's performance in the monomial-basis binary field  <span class="math">\\mathbb{F}_{2^{128}} \\cong \\mathbb{F}_2[X]/(X^{128} + X^{127} + X^{126} + X^{121} + 1)</span> . This field—and in particular, its irreducible polynomial—appears in Gueron, Langley and Lindell's RFC 8452 [GLL19, § 3], and figures in that document's POLYVAL polynomial authenticator. That particular field makes available a certain highly optimized multiplication algorithm, which appears, for both the  <span class="math">x86\\_64</span>  and the ARM64 instruction sets, in Thomas Pornin's BearSSL (these implementations use the PCLMULQDQ and PMULL instructions, respectively). We note that each given sumcheck prover may, in practice, elect to internally convert between the tower field  <span class="math">\\mathcal{T}_7</span>  and the isomorphic monomial-basis field  <span class="math">\\mathbb{F}_{2^{128}}</span> , for the sake computational efficiency (and without thereby necessitating that the relevant verifier change in any way).</p>

    <p class="text-gray-300">Finally, we benchmark the sumcheck prover over the  <span class="math">\\mathrm{BN}254</span>  scalar field, using Lasso's implementation of that prover.</p>

    <p class="text-gray-300">In Tables 5 and 6, we benchmark both Plonky3 and this work on the Keccak-f task, which entails proving the validity of 8,192 independent invocations of the Keccak-f[1600] permutation.</p>

    <p class="text-gray-300">We ran all benchmarks on an Google Cloud c3-standard-22 cloud instance with a 4th-generation Intel Xeon Scalable ("Sapphire Rapids 8488C") processor, 22 virtual CPUs, and 88 GiB of RAM.</p>

    <p class="text-gray-300"><span id="page-40-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prob. Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coeff. Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pf. Size (MiB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax, BN254 <span class="math">G_1</span></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{20}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1969</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01296</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02664</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4760</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03053</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02647</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">1.716</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03061</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02655</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{24}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">3.148</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2058</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08664</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">6.157</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4838</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08610</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">24.82</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4882</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08639</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{28}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">50.40</td>

            <td class="px-3 py-2 border-b border-gray-700">3.303</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2962</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">93.50</td>

            <td class="px-3 py-2 border-b border-gray-700">7.802</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2943</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">297.3</td>

            <td class="px-3 py-2 border-b border-gray-700">7.854</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2942</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{20}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.990</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1262</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01577</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06496</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baby Bear</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{24}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.500</td>

            <td class="px-3 py-2 border-b border-gray-700">2.125</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2491</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08464</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{28}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2.100</td>

            <td class="px-3 py-2 border-b border-gray-700">35.00</td>

            <td class="px-3 py-2 border-b border-gray-700">4.092</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1086</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3,</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{20}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.990</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05909</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01485</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03657</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baby Bear</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{24}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.500</td>

            <td class="px-3 py-2 border-b border-gray-700">1.033</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2381</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04277</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Keccak-256</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{28}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2.100</td>

            <td class="px-3 py-2 border-b border-gray-700">17.53</td>

            <td class="px-3 py-2 border-b border-gray-700">3.962</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05078</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our construction</td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{20}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.229</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002260</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003343</td>

            <td class="px-3 py-2 border-b border-gray-700">0.006843</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.265</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01904</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004669</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004186</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.369</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05717</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01661</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004562</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{24}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.906</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02436</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08347</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02002</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.942</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2166</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07961</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01296</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.326</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8334</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3536</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01514</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"><span class="math">2^{28}</span></td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.546</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3979</td>

            <td class="px-3 py-2 border-b border-gray-700">1.553</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07140</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4.058</td>

            <td class="px-3 py-2 border-b border-gray-700">3.345</td>

            <td class="px-3 py-2 border-b border-gray-700">1.855</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03974</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">5.081</td>

            <td class="px-3 py-2 border-b border-gray-700">20.51</td>

            <td class="px-3 py-2 border-b border-gray-700">10.63</td>

            <td class="px-3 py-2 border-b border-gray-700">0.07019</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Singlethreaded performance of commitment schemes in the  <span class="math">\\rho = \\frac{1}{2}</span>  case.</p>

    <p class="text-gray-300"><span id="page-41-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commitment Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prob. Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coeff. Size</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pf. Size (MiB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Commit (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Hyrax, BN254 G1</td>

            <td class="px-3 py-2 border-b border-gray-700">20<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01591</td>

            <td class="px-3 py-2 border-b border-gray-700">0.001760</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004896</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03882</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003191</td>

            <td class="px-3 py-2 border-b border-gray-700">0.004693</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.031</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1404</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003047</td>

            <td class="px-3 py-2 border-b border-gray-700">0.005291</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2266</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01774</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01291</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">0.4451</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04079</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01173</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.125</td>

            <td class="px-3 py-2 border-b border-gray-700">1.824</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04035</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01228</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">28<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">3.531</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2371</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04023</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">6.550</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6231</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03643</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.500</td>

            <td class="px-3 py-2 border-b border-gray-700">21.42</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6230</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03895</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.990</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01873</td>

            <td class="px-3 py-2 border-b border-gray-700">0.007697</td>

            <td class="px-3 py-2 border-b border-gray-700">0.06262</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baby Bear</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.500</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2479</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04761</td>

            <td class="px-3 py-2 border-b border-gray-700">0.08217</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2.100</td>

            <td class="px-3 py-2 border-b border-gray-700">4.142</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6652</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1062</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">0.990</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01133</td>

            <td class="px-3 py-2 border-b border-gray-700">0.007310</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03462</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Baby Bear</td>

            <td class="px-3 py-2 border-b border-gray-700">224</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">1.500</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1657</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04306</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04102</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Keccak-256</td>

            <td class="px-3 py-2 border-b border-gray-700">228</td>

            <td class="px-3 py-2 border-b border-gray-700">31</td>

            <td class="px-3 py-2 border-b border-gray-700">2.100</td>

            <td class="px-3 py-2 border-b border-gray-700">2.889</td>

            <td class="px-3 py-2 border-b border-gray-700">0.6542</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04892</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our construction</td>

            <td class="px-3 py-2 border-b border-gray-700">220</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.229</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0009150</td>

            <td class="px-3 py-2 border-b border-gray-700">0.001191</td>

            <td class="px-3 py-2 border-b border-gray-700">0.005620</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.265</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003452</td>

            <td class="px-3 py-2 border-b border-gray-700">0.001584</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003842</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">0.369</td>

            <td class="px-3 py-2 border-b border-gray-700">0.007446</td>

            <td class="px-3 py-2 border-b border-gray-700">0.002126</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003653</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">0.906</td>

            <td class="px-3 py-2 border-b border-gray-700">0.003712</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008356</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01272</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.942</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04027</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01007</td>

            <td class="px-3 py-2 border-b border-gray-700">0.008109</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">1.326</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1596</td>

            <td class="px-3 py-2 border-b border-gray-700">0.03096</td>

            <td class="px-3 py-2 border-b border-gray-700">0.009585</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">28<br>2</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">3.546</td>

            <td class="px-3 py-2 border-b border-gray-700">0.09003</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2212</td>

            <td class="px-3 py-2 border-b border-gray-700">0.04136</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">4.058</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8228</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2604</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02645</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">5.081</td>

            <td class="px-3 py-2 border-b border-gray-700">3.327</td>

            <td class="px-3 py-2 border-b border-gray-700">0.8555</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02902</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Multithreaded performance of commitment schemes in the ρ = 2 case.</p>

    <p class="text-gray-300"><span id="page-42-0"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Field</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Num. Variables ℓ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Num. Multilinears</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN254 Fr</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.09755</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00006163</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1150</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00007208</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1397</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0001127</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.428</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00007190</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.670</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00009728</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.033</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0001194</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">21.69</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0001174</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">26.07</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0001058</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">34.09</td>

            <td class="px-3 py-2 border-b border-gray-700">0.0001188</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">T7, tower basis</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.05234</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00001903</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.09794</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00002047</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1502</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00002332</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.7780</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00002181</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">1.420</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003230</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">2.247</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00004054</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">12.111</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003134</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">22.36</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00002818</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">35.63</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003636</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">F2<br>128 , monomial basis</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01288</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003492</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.01911</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00002925</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02986</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003339</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.1295</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003063</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.2285</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00004113</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.3566</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003888</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">28</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">1.877</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00003508</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">3.409</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00005481</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">4</td>

            <td class="px-3 py-2 border-b border-gray-700">5.538</td>

            <td class="px-3 py-2 border-b border-gray-700">0.00004534</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 4: Multithreaded performance of the sumcheck prover on products of multilinear polynomials.</p>

    <p class="text-gray-300"><span id="page-43-6"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash Used Internally</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (MiB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3</td>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">4.010</td>

            <td class="px-3 py-2 border-b border-gray-700">120</td>

            <td class="px-3 py-2 border-b border-gray-700">0.639</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Keccak-256</td>

            <td class="px-3 py-2 border-b border-gray-700">4.010</td>

            <td class="px-3 py-2 border-b border-gray-700">71.2</td>

            <td class="px-3 py-2 border-b border-gray-700">0.527</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our construction</td>

            <td class="px-3 py-2 border-b border-gray-700">Grøstl</td>

            <td class="px-3 py-2 border-b border-gray-700">5.574</td>

            <td class="px-3 py-2 border-b border-gray-700">65.3</td>

            <td class="px-3 py-2 border-b border-gray-700">0.156</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 5: Singlethreaded performance on proving  <span class="math">8{,}192~{\\rm Keccak}</span> -fs.</p>

    <p class="text-gray-300"><span id="page-43-7"></span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Protocol</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hash Used Internally</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof Size (MiB)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove (s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Verify (s)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Plonky3</td>

            <td class="px-3 py-2 border-b border-gray-700">Poseidon</td>

            <td class="px-3 py-2 border-b border-gray-700">4.010</td>

            <td class="px-3 py-2 border-b border-gray-700">17.4</td>

            <td class="px-3 py-2 border-b border-gray-700">0.644</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Keccak-256</td>

            <td class="px-3 py-2 border-b border-gray-700">4.010</td>

            <td class="px-3 py-2 border-b border-gray-700">13.8</td>

            <td class="px-3 py-2 border-b border-gray-700">0.525</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our construction</td>

            <td class="px-3 py-2 border-b border-gray-700">Grøstl</td>

            <td class="px-3 py-2 border-b border-gray-700">5.574</td>

            <td class="px-3 py-2 border-b border-gray-700">5.90</td>

            <td class="px-3 py-2 border-b border-gray-700">0.100</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 6: Multithreaded performance on proving 8,192 Keccak-fs.</p>

    <h2 id="sec-38" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-43-3"></span>[AHIV23] Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubramaniam. "Ligero: lightweight sublinear arguments without a trusted setup". In: <em>Designs, Codes and Cryptography</em> (2023). DOI: 10.1007/s10623-023-01222-8.</li>

      <li><span id="page-43-9"></span>[ark22] arkworks contributors. arkworks zkSNARK ecosystem. 2022. URL: https://arkworks.rs.</li>

      <li><span id="page-43-0"></span>[BBHR18a] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. "Fast Reed-Solomon Interactive Oracle Proofs of Proximity". In: International Colloquium on Automata, Languages, and Programming. Ed. by Ioannis Chatzigiannakis, Christos Kaklamanis, Dániel Marx, and Donald Sannella. Vol. 107. Leibniz International Proceedings in Informatics. Dagstuhl, Germany: Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik, 2018, 14:1–14:17. DOI: 10.4230/LIPIcs.ICALP.2018.14.</li>

      <li><span id="page-43-1"></span>[BBHR18b] Eli Ben-Sasson, Iddo Bentov, Yinon Horesh, and Michael Riabzev. Scalable, transparent, and post-quantum secure computational integrity. Cryptology ePrint Archive, Paper 2018/046. 2018. URL: https://eprint.iacr.org/2018/046.</li>

      <li><span id="page-43-8"></span>[BC14] Daniel J. Bernstein and Tung Chou. "Faster Binary-Field Multiplication and Faster Binary-Field MACs". In: ed. by Antoine Joux and Amr Youssef. Cham: Springer International Publishing, 2014. ISBN: 978-3-319-13051-4. DOI: 10.1007/978-3-319-13051-4\\_6.</li>

      <li><span id="page-43-2"></span>[BCG20] Jonathan Bootle, Alessandro Chiesa, and Jens Groth. "Linear-Time Arguments with Sublinear Verification from Tensor Codes". In: <em>Theory of Cryptography</em>. Ed. by Rafael Pass and Krzysztof Pietrzak. Cham: Springer International Publishing, 2020, pp. 19–46. ISBN: 978-3-030-64378-2. DOI: 10.1007/978-3-030-64378-2\\_2.</li>

      <li><span id="page-43-5"></span>[BCKL22] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. "Scalable and Transparent Proofs over All Large Fields, via Elliptic Curves". In: <em>Theory of Cryptography</em>. Ed. by Eike Kiltz and Vinod Vaikuntanathan. Cham: Springer Nature Switzerland, 2022, pp. 467–496. ISBN: 978-3-031-22318-1. DOI: 10.1007/978-3-031-22318-1\\_17.</li>

      <li><span id="page-43-4"></span>[BCKL23] Eli Ben-Sasson, Dan Carmon, Swastik Kopparty, and David Levit. "Elliptic Curve Fast Fourier Transform (ECFFT) Part I: Low-degree Extension in Time  <span class="math">O(n \\log n)</span>  over all Finite Fields". In: ACM-SIAM Symposium on Discrete Algorithms. Society for Industrial and Applied Mathematics, Nov. 2023, pp. 700–737. DOI: doi:10.1137/1.9781611977554.ch30.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-44-13"></span>[BCS16] Eli Ben-Sasson, Alessandro Chiesa, and Nicholas Spooner. "Interactive Oracle Proofs". In: <em>International Conference on Theory of Cryptography</em>. Vol. 9986. Berlin, Heidelberg: Springer-Verlag, 2016, pp. 31–60. ISBN: 978-3-662-53644-5. DOI: 10.1007/978-3-662-53644-5\\_2.</li>

      <li><span id="page-44-10"></span>[BCS97] Wieb Bosma, John Cannon, and Allan Steel. "Lattices of Compatibly Embedded Finite Fields". In: Journal of Symbolic Computation 24.3 (1997), pp. 351-369. DOI: https://doi.org/10.1006/jsco.1997.0138. URL: https://www.sciencedirect.com/science/article/pii/S0747717197901383.</li>

      <li><span id="page-44-12"></span>[BDPV11] Guido Bertoni, Joan Daemen, Michaël Peeters, and Gilles Van Assche. <em>The Keccak reference</em>. 2011. URL: https://keccak.team/files/Keccak-reference-3.0.pdf.</li>

      <li><span id="page-44-8"></span>[BDSW23] Carsten Baum, Samuel Dittmer, Peter Scholl, and Xiao Wang. "SoK: Vector OLE-based zero-knowledge protocols". In: <em>Designs, Codes and Cryptography</em> 91.11 (2023), pp. 3527–3561. DOI: 10.1007/s10623-023-01292-8.</li>

      <li><span id="page-44-3"></span>[Ben+23] Eli Ben-Sasson, Dan Carmon, Yuval Ishai, Swastik Kopparty, and Shubhangi Saraf. "Proximity Gaps for Reed–Solomon Codes". In: <em>Journal of the ACM</em> 70.5 (Oct. 2023). DOI: 10.1145/3614423.</li>

      <li><span id="page-44-0"></span>[BFS20] Benedikt Bünz, Ben Fisch, and Alan Szepieniec. "Transparent SNARKs from DARK Compilers". In: <em>Advances in Cryptology – EUROCRYPT 2020</em>. Ed. by Anne Canteaut and Yuval Ishai. Cham: Springer International Publishing, 2020, pp. 677–706.</li>

      <li><span id="page-44-1"></span>[BGKS19] Eli Ben-Sasson, Lior Goldberg, Swastik Kopparty, and Shubhangi Saraf. <em>DEEP-FRI: Sampling Outside the Box Improves Soundness</em>. Cryptology ePrint Archive, Paper 2019/336. 2019. URL: https://eprint.iacr.org/2019/336.</li>

      <li><span id="page-44-5"></span>[BGR23] Jeremy Bruestle, Paul Gafni, and RISC Zero Team. RISC Zero zkVM: Scalable, Transparent Arguments of RISC-V Integrity. 2023. URL: https://dev.risczero.com/proof-system-in-detail.pdf (visited on 11/12/2023).</li>

      <li><span id="page-44-9"></span>[Bla+93] Ian F. Blake, XuHong Gao, Ronald C. Mullin, Scott A. Vanstone, and Tomik Yaghoobian. Applications of Finite Fields. Ed. by Alfred J. Menezes. The Springer International Series in Engineering and Computer Science. Springer Science+Business Media, 1993.</li>

      <li><span id="page-44-11"></span>[Blu+91] Manuel Blum, Will Evans, Peter Gemmell, Sampath Kannan, and Moni Naor. "Checking the Correctness of Memories". In: <em>Proceedings of the 32nd Annual Symposium on Foundations of Computer Science</em>. IEEE Computer Society, 1991, pp. 90–99. ISBN: 0818624450. DOI: 10.1109/SFCS.1991.185352.</li>

      <li><span id="page-44-2"></span>[CBBZ23] Binyi Chen, Benedikt Bünz, Dan Boneh, and Zhenfei Zhang. "HyperPlonk: Plonk with Linear-Time Prover and High-Degree Custom Gates". In: Advances in Cryptology – EUROCRYPT 2023. Ed. by Carmit Hazay and Martijn Stam. Vol. 14005. Lecture Notes in Computer Science. Cham: Springer Nature Switzerland, 2023.</li>

      <li><span id="page-44-7"></span>[CCXY18] Ignacio Cascudo, Ronald Cramer, Chaoping Xing, and Chen Yuan. "Amortized Complexity of Information-Theoretically Secure MPC Revisited". In: <em>Advances in Cryptology – CRYPTO 2018</em>. Ed. by Hovav Shacham and Alexandra Boldyreva. Cham: Springer International Publishing, 2018, pp. 395–426. ISBN: 978-3-319-96878-0. DOI: 10.1007/978-3-319-96878-0\\_14.</li>

      <li><span id="page-44-6"></span>[CG22] Ignacio Cascudo and Emanuele Giunta. "On Interactive Oracle Proofs for Boolean R1CS Statements". In: Financial Cryptography and Data Security. Ed. by Ittay Eyal and Juan Garay. Cham: Springer International Publishing, 2022, pp. 230–247. ISBN: 978-3-031-18283-9. DOI: 10.1007/978-3-031-18283-9\\_11.</li>

      <li><span id="page-44-4"></span>[Che+18] Ming-Shing Chen, Chen-Mou Cheng, Po-Chun Kuo, Wen-Ding Li, and Bo-Yin Yang. Faster Multiplication for Long Binary Polynomials. 2018. URL: https://arxiv.org/abs/1708.09746.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-45-0"></span>[Chi+20] Alessandro Chiesa, Yuncong Hu, Mary Maller, Pratyush Mishra, Noah Vesely, and Nicholas Ward. "Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS". In: <em>Advances in Cryptology – EUROCRYPT 2020</em>. Ed. by Anne Canteaut and Yuval Ishai. Lecture Notes in Computer Science. Full version. Cham: Springer International Publishing, 2020, pp. 738–768. ISBN: 978-3-030-45721-1. DOI: 10.1007/978-3-030-45721-1\\_26.</li>

      <li><span id="page-45-14"></span>[CLRS22] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. <em>Introduction to Algorithms</em>. Fourth Edition. The MIT Press, 2022.</li>

      <li><span id="page-45-13"></span>[Coh92] Stephen D. Cohen. "The Explicit Construction of Irreducible Polynomials Over Finite Fields". In: Designs, Codes and Cryptography 2.2 (1992), pp. 169–174.</li>

      <li><span id="page-45-6"></span>[DP24] Benjamin E. Diamond and Jim Posen. "Proximity Testing with Logarithmic Randomness". In: IACR Communications in Cryptology 1.1 (2024). ISSN: 3006-5496. DOI: 10.62056/aksdkp10.</li>

      <li><span id="page-45-10"></span>[FP97] John L. Fan and Christof Paar. "On efficient inversion in tower fields of characteristic two". In: Proceedings of IEEE International Symposium on Information Theory. 1997.</li>

      <li><span id="page-45-8"></span>[Gau+11] Praveen Gauravaram, Lars R. Knudsen, Krystian Matusiewicz, Florian Mendel, Christian Rechberger, Martin Schläffer, and Søren S. Thomsen. <em>Grøstl – a SHA-3 candidate</em>. 2011. URL: https://www.groestl.info/Groestl.pdf (visited on 11/12/2023).</li>

      <li><span id="page-45-16"></span>[GBHL22] Jack Grigg, Sean Bowe, Daira Hopwood, and Ying Tong Lai. <em>The halo2 Book.</em> 2022. URL: https://zcash.github.io/halo2.</li>

      <li><span id="page-45-7"></span>[GKR15] Shafi Goldwasser, Yael Tauman Kalai, and Guy N. Rothblum. "Delegating Computation: Interactive Proofs for Muggles". In: <em>Journal of the ACM</em> 62.4 (Sept. 2015). ISSN: 0004-5411. DOI: 10.1145/2699436.</li>

      <li><span id="page-45-17"></span>[GLL19] Shay Gueron, Adam Langley, and Yehuda Lindell. <em>AES-GCM-SIV: Nonce Misuse-Resistant Authenticated Encryption</em>. RFC 8452. Apr. 2019.</li>

      <li><span id="page-45-5"></span>[Gol+23] Alexander Golovnev, Jonathan Lee, Srinath Setty, Justin Thaler, and Riad S. Wahby. "Brakedown: Linear-Time and Field-Agnostic SNARKs for R1CS". In: <em>Advances in Cryptology – CRYPTO 2023</em>. Ed. by Helena Handschuh and Anna Lysyanskaya. Cham: Springer Nature Switzerland, 2023, pp. 193–226. DOI: 10.1007/978-3-031-38545-2\\_7.</li>

      <li><span id="page-45-15"></span>[Gra] Markus Grassl. Bounds on the minimum distance of linear codes and quantum codes. http://www.codetables.de.</li>

      <li><span id="page-45-9"></span>[Gra+19] Lorenzo Grassi, Dmitry Khovratovich, Christian Rechberger, Arnab Roy, and Markus Schofnegger. <em>Poseidon: A New Hash Function for Zero-Knowledge Proof Systems</em>. Cryptology ePrint Archive, Paper 2019/458. 2019. URL: https://eprint.iacr.org/2019/458.</li>

      <li><span id="page-45-12"></span>[Gur06] Venkatesan Guruswami. Algorithmic Results in List Decoding. Vol. 2. Foundations and Trends in Theoretical Computer Science 2. now publishers, 2006. DOI: 10.1561/0400000007.</li>

      <li><span id="page-45-1"></span>[GWC19] Ariel Gabizon, Zachary J. Williamson, and Oana Ciobotaru. <em>PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge</em>. Cryptology ePrint Archive, Paper 2019/953. 2019. URL: https://eprint.iacr.org/2019/953.</li>

      <li><span id="page-45-4"></span>[Hab22] Ulrich Haböck. A summary on the FRI low degree test. Cryptology ePrint Archive, Paper 2022/1216. 2022. URL: https://eprint.iacr.org/2022/1216.</li>

      <li><span id="page-45-11"></span>[HR22] Justin Holmgren and Ron D. Rothblum. "Faster Sounder Succinct Arguments and IOPs". In: Advances in Cryptology – CRYPTO 2022. Ed. by Yevgeniy Dodis and Thomas Shrimpton. Cham: Springer Nature Switzerland, 2022, pp. 474–503. ISBN: 978-3-031-15802-5. DOI: 10.1007/978-3-031-15802-5\\_17.</li>

      <li><span id="page-45-3"></span>[Kil92] Joe Kilian. "A Note on Efficient Zero-Knowledge Proofs and Arguments (Extended Abstract)". In: <em>Proceedings of the Twenty-Fourth Annual ACM Symposium on Theory of Computing</em>. New York, NY, USA: Association for Computing Machinery, 1992, pp. 723–732.</li>

      <li><span id="page-45-2"></span>[KZG10] Aniket Kate, Gregory M. Zaverucha, and Ian Goldberg. "Constant-Size Commitments to Polynomials and Their Applications". In: <em>Advances in Cryptology – ASIACRYPT 2010</em>. Ed. by Masayuki Abe. Berlin, Heidelberg: Springer Berlin Heidelberg, 2010, pp. 177–194. ISBN: 978-3-642-17373-8. DOI: 10.1007/978-3-642-17373-8.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-46-13"></span>[LCH14] Sian-Jheng Lin, Wei-Ho Chung, and Yunghsiang S. Han. "Novel Polynomial Basis and Its Application to Reed-Solomon Erasure Codes". In: <em>IEEE 55th Annual Symposium on Foundations of Computer Science</em>. 2014, pp. 316–325. DOI: 10.1109/FOCS.2014.41.</li>

      <li><span id="page-46-6"></span>[LFKN92] Carsten Lund, Lance Fortnow, Howard Karloff, and Noam Nisan. "Algebraic Methods for Interactive Proof Systems". In: Journal of the ACM 39.4 (Oct. 1992), pp. 859–868. DOI: 10.1145/146585.146605. URL: https://doi.org/10.1145/146585.146605.</li>

      <li><span id="page-46-0"></span>[MBKM19] Mary Maller, Sean Bowe, Markulf Kohlweiss, and Sarah Meiklejohn. "Sonic: Zero-Knowledge SNARKs from Linear-Size Universal and Updatable Structured Reference Strings". In: Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security. 2019, pp. 2111–2128. ISBN: 9781450367479. DOI: 10.1145/3319535.3339817.</li>

      <li><span id="page-46-3"></span>[Pol22] Polygon Zero Team. Plonky2: Fast Recursive Arguments with PLONK and FRI. GitHub. 2022. URL: https://github.com/0xPolygonZero/plonky2/blob/main/plonky2/plonky2.pdf.</li>

      <li><span id="page-46-10"></span>[RR22] Noga Ron-Zewi and Ron D. Rothblum. "Proving as Fast as Computing: Succinct Arguments with Constant Prover Overhead". In: <em>ACM SIGACT Symposium on Theory of Computing</em>. Association for Computing Machinery, 2022, pp. 1353–1363. ISBN: 9781450392648. DOI: 10.1145/3519935.3519956.</li>

      <li><span id="page-46-4"></span>[Set20] Srinath Setty. "Spartan: Efficient and General-Purpose zkSNARKs Without Trusted Setup". In: Advances in Cryptology – CRYPTO 2020. Ed. by Daniele Micciancio and Thomas Ristenpart. Cham: Springer International Publishing, 2020, pp. 704–737. ISBN: 978-3-030-56877-1. DOI: 10.1007/978-3-030-56877-1\\_25.</li>

      <li><span id="page-46-14"></span>[SL20] Srinath Setty and Jonathan Lee. Quarks: Quadruple-efficient transparent zkSNARKs. Cryptology ePrint Archive, Paper 2020/1275. 2020. URL: https://eprint.iacr.org/2020/1275.</li>

      <li><span id="page-46-2"></span>[Sta21] StarkWare. ethSTARK Documentation. Cryptology ePrint Archive, Paper 2021/582. 2021. URL: https://eprint.iacr.org/2021/582.</li>

      <li><span id="page-46-5"></span>[STW23] Srinath Setty, Justin Thaler, and Riad Wahby. Customizable constraint systems for succinct arguments. Cryptology ePrint Archive, Paper 2023/552. 2023. URL: https://eprint.iacr.org/2023/552.</li>

      <li><span id="page-46-8"></span>[STW24] Srinath Setty, Justin Thaler, and Riad Wahby. "Unlocking the Lookup Singularity with Lasso". In: Advances in Cryptology – EUROCRYPT 2024. Ed. by Marc Joye and Gregor Leander. Cham: Springer Nature Switzerland, 2024, pp. 180–209. ISBN: 978-3-031-58751-1. DOI: 10.1007/978-3-031-58751-1\\_7.</li>

      <li><span id="page-46-12"></span>[Tha22] Justin Thaler. <em>Proofs, Arguments and Zero-Knowledge</em>. Vol. 4. Foundations and Trends in Privacy and Security 2–4. now publishers, 2022.</li>

      <li><span id="page-46-1"></span>[Val08] Paul Valiant. "Incrementally Verifiable Computation or Proofs of Knowledge Imply Time/Space Efficiency". In: <em>Proceedings of the 5th Conference on Theory of Cryptography</em>. New York, USA: Springer-Verlag, 2008, pp. 1–18. ISBN: 354078523X.</li>

      <li><span id="page-46-9"></span>[Wah+18] Riad S. Wahby, Ioanna Tzialla, abhi shelat abhi, Justin Thaler, and Michael Walfish. "Doubly-Efficient zkSNARKs Without Trusted Setup". In: <em>IEEE Symposium on Security and Privacy</em>. 2018, pp. 926–943. DOI: 10.1109/SP.2018.00060.</li>

      <li><span id="page-46-7"></span>[Wie88] Doug Wiedemann. "An Iterated Quadratic Extension of GF(2)". In: The Fibonacci Quarterly 26.4 (1988), pp. 290–295.</li>

      <li><span id="page-46-11"></span>[WYKW21] Chenkai Weng, Kang Yang, Jonathan Katz, and Xiao Wang. "Wolverine: Fast, Scalable, and Communication-Efficient Zero-Knowledge Proofs for Boolean and Arithmetic Circuits". In: <em>IEEE Symposium on Security and Privacy.</em> 2021, pp. 1074–1091. DOI: 10.1109/SP40001. 2021.00056.</li>

    </ul>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">A Deferred Proofs</h3>

    <p class="text-gray-300">Proof of Theorem 3.12. We fix an adversary  <span class="math">\\mathcal{A}</span>  who outputs a commitment c and pairs  <span class="math">(t^0, u^0)</span>  and  <span class="math">(t^1, u^1)</span> . Assuming that  <span class="math">\\Pi.\\mathsf{Open}(\\mathsf{params}, c; t^0, u^0)</span>  and  <span class="math">\\Pi.\\mathsf{Open}(\\mathsf{params}, c; t^1, u^1)</span>  both hold, we argue as follows. We write  <span class="math">M^0</span>  and  <span class="math">M^1</span>  for the subsets of  <span class="math">\\{0, \\ldots, n-1\\}</span>  respectively missing from the hints  <span class="math">u^0</span>  and  <span class="math">u^1</span> . We moreover write:</p>

    <div class="my-4 text-center"><span class="math-block">X \\coloneqq \\Delta^{m_0} \\Big( \\big(u_i^0\\big)_{i=0}^{m_0-1}, \\big(\\mathsf{Enc}(t_i^0)\\big)_{i=0}^{m_0-1} \\Big) \\cup M^0 \\cup \\Delta^{m_0} \\Big( \\big(u_i^1\\big)_{i=0}^{m_0-1}, \\big(\\mathsf{Enc}(t_i^1)\\big)_{i=0}^{m_0-1} \\Big) \\cup M^1.</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">On the one hand, our hypothesis immediately implies that</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< d. On the other hand, we claim that  <span class="math">\\Delta^{m_0}\\left(\\left(\\operatorname{Enc}(t_i^0)\\right)_{i=0}^{m_0-1},\\left(\\operatorname{Enc}(t_i^1)\\right)_{i=0}^{m_0-1}\\right) \\subset X</span> . Indeed, proceeding by contraposition, we fix an index  <span class="math">j \\notin X</span> . Since  <span class="math">j \\notin M_0 \\cup M_1</span> , we see that the hints  <span class="math">u^0</span>  and  <span class="math">u^1</span>  respectively Merkle-open the columns  <span class="math">\\left(u_{i,j}^0\\right)_{i=0}^{m_0-1}</span>  and  <span class="math">\\left(u_{i,j}^1\\right)_{i=0}^{m_0-1}</span>  against c, so that—barring an oracle collision on the part of A—these columns are necessarily identical. On the other hand, since  <span class="math">j \\notin \\Delta^{m_0}\\left(\\left(u_i^0\\right)_{i=0}^{m_0-1},\\left(\\operatorname{Enc}(t_i^0)\\right)_{i=0}^{m_0-1}\\right) \\cup \\Delta^{m_0}\\left(\\left(u_i^1\\right)_{i=0}^{m_0-1},\\left(\\operatorname{Enc}(t_i^1)\\right)_{i=0}^{m_0-1}\\right)</span> , we see that  <span class="math">\\left(\\operatorname{Enc}(t_i^0)_j\\right)_{i=0}^{m_0-1} = \\left(u_{i,j}^0\\right)_{i=0}^{m_0-1}</span>  and  <span class="math">\\left(\\operatorname{Enc}(t_i^1)_j\\right)_{i=0}^{m_0-1} = \\left(u_{i,j}^1\\right)_{i=0}^{m_0-1}</span> . Combining these facts, we see that  <span class="math">\\left(\\operatorname{Enc}(t_i^0)_j\\right)_{i=0}^{m_0-1} = \\left(\\operatorname{Enc}(t_i^1)_j\\right)_{i=0}^{m_0-1}</span> , so that  <span class="math">j \\notin \\Delta^{m_0}\\left(\\left(\\operatorname{Enc}(t_i^0)\\right)_{i=0}^{m_0-1},\\left(\\operatorname{Enc}(t_i^1)\\right)_{i=0}^{m_0-1}\\right)</span> , as desired. We conclude that  <span class="math">\\left(\\operatorname{Enc}(t_i^0)_j\\right)_{i=0}^{m_0-1} = \\left(\\operatorname{Enc}(t_i^1)_j\\right)_{i=0}^{m_0-1}</span> . Because Enc is injective, we finally conclude that  <span class="math">t_0 = t_1</span>  as packed matrices; because the natural embedding is injective (see also Theorem 3.9 above), we finally deduce the equality of  <span class="math">t_0</span>  and  <span class="math">t_1</span>  as unpacked matrices, and hence as polynomials in  <span class="math">\\mathcal{T}_{\\iota}[X_0,\\ldots,X_{\\ell-1}]</span> .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><em>Proof of Theorem 3.13.</em> We define an emulator  <span class="math">\\mathcal{E}</span> . Given access to  <span class="math">\\mathcal{A}</span> , and on inputs params, c and  <span class="math">(r_0, \\ldots, r_{\\ell-1})</span> ,  <span class="math">\\mathcal{E}</span>  operates as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-47-1"></span>1. Having observed and collected  <span class="math">\\mathcal{A}</span> 's queries up until the point of its outputting c,  <span class="math">\\mathcal{E}</span>  initializes the empty matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span> .  <span class="math">\\mathcal{E}</span>  defines the following algorithm, which is essentially a slight simplification of an algorithm, called <em>Valiant's extractor</em>, given in Ben-Sasson, Chiesa and Spooner [BCS16, § A.1].</li>

      <li>1: <strong>procedure</strong> TreeBuilder(h, i, j)</li>

      <li>2: <strong>if</strong> i = 0 <strong>and</strong>  <span class="math">h \\stackrel{?}{=} H\\left((x_i)_{i=0}^{m_0-1}\\right)</span>  arises as some oracle output <strong>then</strong></li>

      <li>3: overwrite the value of the  <span class="math">j^{\\text{th}}</span>  column  <span class="math">(u_{i,j})_{i=0}^{m_0-1} \\coloneqq (x_i)_{i=0}^{m_0-1}</span> .</li>

      <li>4: <strong>else if</strong> i > 0 <strong>and</strong>  <span class="math">h \\stackrel{?}{=} H(h_0 \\parallel h_1)</span>  arises as some oracle output <strong>then</strong></li>

      <li>5: recursively kick off TREEBUILDER <span class="math">(h_0, i-1, 2 \\cdot j)</span>  and TREEBUILDER <span class="math">(h_1, i-1, 2 \\cdot j+1)</span> .</li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathcal{E}</span>  executes TreeBuilder <span class="math">(c, \\log n, 0)</span> .  <span class="math">\\mathcal{E}</span>  writes  <span class="math">M \\subset \\{0, \\dots, n-1\\}</span>  for the set of never-assigned indices.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span id="page-47-2"></span>2.  <span class="math">\\mathcal E</span>  internally runs  <span class="math">\\mathcal A</span>  on the further input  <span class="math">(r_0,\\ldots,r_{\\ell-1})</span>  in a straight-line manner, until  <span class="math">\\mathcal A</span>  outputs s and  <span class="math">\\pi</span> . If  <span class="math">\\Pi.\\mathsf{Verify}(\\mathsf{params},c,s,(r_0,\\ldots,r_{\\ell-1}),\\pi)=0</span> , then  <span class="math">\\mathcal E</span>  outputs  <span class="math">(s,\\pi;\\bot,\\bot)</span>  and terminates.</li>

      <li><span id="page-47-3"></span>3.  <span class="math">\\mathcal{E}</span>  defines:</li>

      <li>1: <strong>procedure</strong> EXTRACTPROOF()</li>

      <li>2: while true do</li>

      <li>3: freshly sample  <span class="math">(r_0, \\ldots, r_{\\ell-1}) \\leftarrow \\mathcal{Q}(\\mathsf{params})</span> .</li>

      <li>4: run  <span class="math">\\mathcal{A}</span>  on  <span class="math">(r_0, \\ldots, r_{\\ell-1})</span> , with fresh verifier randomness, until it outputs  <span class="math">(s, \\pi)</span> .</li>

      <li>5: rewind A to its initial point (i.e., immediately after outputting c).</li>

      <li>6: if  <span class="math">\\Pi</span> . Verify(params,  <span class="math">c, s, (r_0, \\dots, r_{\\ell-1}), \\pi</span> ) then return t' and  <span class="math">(r_0, \\dots, r_{\\ell-1})</span> .</li>

    </ul>

    <p class="text-gray-300"> <span class="math">\\mathcal{E}</span>  writes  <span class="math">(r_{0,0},\\ldots,r_{0,\\ell-1})</span>  for the randomness it used in  <span class="math">\\mathcal{A}</span> 's initial proof above and  <span class="math">t_0&#x27;</span>  for the message sent by  <span class="math">\\mathcal{A}</span>  during the course of its initial proof. By running the routine EXTRACTPROOF() above  <span class="math">m_0-1</span>  further times,  <span class="math">\\mathcal{E}</span>  extends these quantities to matrices  <span class="math">(t_i&#x27;)_{i=0}^{m_0-1}</span>  and  <span class="math">(r_{i,0},\\ldots,r_{i,\\ell-1})_{i=0}^{m_0-1}</span> .</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathcal{E}</span>  checks if the  <span class="math">m_0 \\times m_0</span>  matrix  <span class="math">\\left(\\bigotimes_{j=\\ell_1}^{\\ell-1} (1-r_{i,j},r_{i,j})\\right)_{i=0}^{m_0-1}</span>  is invertible. If it's not,  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">(s,\\pi;\\perp,u)</span> .</li>

    </ol>

    <p class="text-gray-300"><span id="page-48-1"></span>5. Otherwise, using the constant  <span class="math">\\mathcal{T}_{\\tau}</span> -vector space structure on  <span class="math">A_{\\iota, \\kappa, \\tau}</span> ,  <span class="math">\\mathcal{E}</span>  performs the matrix operation:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{bmatrix} - &amp; t_0 &amp; - \\\\ &amp; \\vdots &amp; \\\\ - &amp; t_{m_0-1} &amp; - \\end{bmatrix} := \\begin{bmatrix} - &amp; \\bigotimes_{j=\\ell_1}^{\\ell-1} (1 - r_{0,j}, r_{0,j}) &amp; - \\\\ &amp; \\vdots &amp; \\\\ - &amp; \\bigotimes_{j=\\ell_1}^{\\ell-1} (1 - r_{m_0-1,j}, r_{m_0-1,j}) &amp; - \\end{bmatrix}^{-1} \\cdot \\begin{bmatrix} - &amp; t&#x27;_0 &amp; - \\\\ &amp; \\vdots &amp; \\\\ - &amp; t&#x27;_{m_0-1} &amp; - \\end{bmatrix}.</span></div>

    <p class="text-gray-300">If the entries of  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  do not reside entirely in the subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> , then  <span class="math">\\mathcal{E}</span>  outputs  <span class="math">(s,\\pi;\\perp,u)</span> . Otherwise,  <span class="math">\\mathcal{E}</span>  recovers the unpacked matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  by reversing the  <span class="math">\\mathcal{T}_{\\iota}</span> -isomorphism of Theorem 3.9, sets as  <span class="math">t(X_0, \\dots, X_{\\ell-1}) \\in \\mathcal{T}_t[X_0, \\dots, X_{\\ell-1}]</span>  the polynomial whose coefficients (in the multilinear Lagrange basis) are given by the concatenation of  <span class="math">(t_i)_{i=0}^{m_0-1}</span> 's rows, and outputs  <span class="math">(s, \\pi; t, u)</span> .</p>

    <p class="text-gray-300">In the algorithm TreeBuilder, we understand the conditions 2 and 4 as demanding that the relevant preimages be well-formed. That is, in case h does arise as the output of a prior query, whose input, however, is malformed (in that it doesn't match the format demanded), we understand the relevant condition as failing to be fulfilled. If h arises as the output of multiple, distinct, well-formed preimages, then we stipulate that  <span class="math">\\mathcal{E}</span>  select arbitrarily among these preimages (this event can only occur if  <span class="math">\\mathcal{A}</span>  finds an oracle collision).</p>

    <p class="text-gray-300">We now argue that  <span class="math">\\mathcal{E}</span>  runs in expected polynomial time in  <span class="math">\\lambda</span> . We write  <span class="math">\\varepsilon</span>  for the probability that  <span class="math">\\mathcal{A}</span>  passes, conditioned on its state as of the point at which it first outputs c (this probability is taken over the coins of both  <span class="math">\\mathcal{Q}</span>  and  <span class="math">\\mathcal{V}</span> , and over the further coins of  <span class="math">\\mathcal{A}</span> ). We note that, for each fixed  <span class="math">c, \\mathcal{E}</span>  proceeds beyond step 2 above with probability exactly  <span class="math">\\varepsilon</span> . Moreover, each execution of EXTRACTPROOF terminates in expected time exactly  <span class="math">\\frac{1}{\\varepsilon}</span> , since that algorithm's line 6 passes with probability exactly  <span class="math">\\varepsilon</span>  per iteration of that algorithm. Finally, TREEBUILDER is straight-line and polynomial time. We conclude that  <span class="math">\\mathcal{E}</span> 's total expected runtime is at most that of TreeBuilder plus  <span class="math">1 + \\varepsilon \\cdot \\frac{m_0 - 1}{\\varepsilon} = m</span>  times the time it takes to run Construction 3.11 once; this total time is thus polynomial in  <span class="math">\\lambda</span>  (and independent of c and  <span class="math">\\varepsilon</span> ).</p>

    <p class="text-gray-300">We now analyze the distribution returned by  <span class="math">\\mathcal{E}</span> . We note that the outputs  <span class="math">(c, s, \\pi)</span>  upon which  <span class="math">\\mathcal{D}</span> runs are identically distributed in the distributions  <span class="math">\\operatorname{Real}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span>  and  <span class="math">\\operatorname{Ideal}_{\\mathcal{Q},\\mathcal{A},\\mathcal{E},\\mathcal{D}}^{\\Pi,\\ell}(\\lambda)</span> . It thus suffices to show that it holds in at most a negligible proportion of executions of  <span class="math">\\mathcal{A}</span> ,  <span class="math">\\mathcal{Q}</span>  and  <span class="math">\\mathcal{E}</span>  that, simultaneously,  <span class="math">\\Pi</span> . Verify(params,  <span class="math">c, s, (r_0, \\ldots, r_{\\ell-1}), \\pi</span> ) = 1 and either  <span class="math">\\Pi</span> . Open(params, t, c, u) = 0 or  <span class="math">t(r_0, \\ldots, r_{\\ell-1}) \\neq s</span> . We write  <span class="math">Q(\\lambda)</span>  for a polynomial upper bound on the number of random oracle queries  <span class="math">\\mathcal{A}</span>  makes. We recall from [BCS16, § A.1] that it holds with probability at most  <span class="math">\\frac{Q(\\lambda)^2+1}{2^{\\lambda}}</span> , which is negligible, that  <span class="math">\\mathcal{A}</span>  outputs—during any particular among its executions—either a valid Merkle path on a missing column  <span class="math">j \\in M</span>  or, for some  <span class="math">j \\notin M</span> , a valid Merkle opening  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span>  inconsistent with the matrix extracted by  <span class="math">\\mathcal{E}</span>  in step 1 above.</p>

    <p class="text-gray-300">We recall the extension code  <span class="math">\\widehat{C} \\subset A_{\\iota,\\kappa,\\tau}</span>  of the code  <span class="math">C \\subset \\mathcal{T}^n_{\\iota+\\kappa}</span>  output by  <span class="math">\\Pi.\\mathsf{Setup}</span>  (i.e., see Subsection 3.1). The following lemma shows that we may, moreover, safely restrict our attention to the setting which the extracted matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  features correlated agreement with  <span class="math">\\widehat{C}</span> . Though the matrix  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  has, by definition, entries in the synthetic subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> , for the purposes of the below lemma, we temporarily view it as a matrix with entries in  <span class="math">A_{\\iota,\\kappa,\\tau}</span> . We write  <span class="math">\\overline{C}</span>  for the puncturing of  <span class="math">\\widehat{C}</span>  at M.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span id="page-48-0"></span><strong>Lemma A.1.</strong> If  <span class="math">\\mathcal{E}</span>  's matrix satisfies  $d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, \\overline{C}^{m_0}\\right) \\geq \\frac{d}{3} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , then  </span>\\mathcal{A}$  passes with negligible probability.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We first argue that we may freely assume that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\frac{d}{3}<span class="math"> . Indeed, if  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ge \\frac{d}{3}<span class="math"> , then  </span>J \\cap M = \\emptyset<span class="math">  holds with probability at most  </span>\\left(1 - \\frac{d}{3 \\cdot n}\\right)^{\\gamma}<span class="math"> , which is negligible, since  </span>d = \\Omega(n)<span class="math">  and  </span>\\gamma = \\Theta(\\lambda)<span class="math"> . On the other hand, A can pass in case  </span>J \\cap M \\ne \\emptyset<span class="math">  only by submitting valid a Merkle opening against a missing column. We thus assume that  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\frac{d}{3}<span class="math"> , and moreover write  </span>e := \\left\\lfloor \\frac{d-1}{3} \\right\\rfloor -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . Since the distance, say  </span>\\overline{d}<span class="math"> , of  </span>\\overline{C}$  is at least d -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, which itself satisfies  $\\left\\lfloor \\frac{\\overline{d}-1}{3} \\right\\rfloor \\ge \\left\\lfloor \\frac{d-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}{3} \\right\\rfloor \\ge \\left\\lfloor \\frac{d-1}{3} \\right\\rfloor -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= e<span class="math"> , we see that  </span>e \\in \\left\\{0, \\dots, \\left\\lfloor \\frac{\\overline{d}-1}{3} \\right\\rfloor\\right\\}<span class="math"> . On the other hand, by our hypothesis,  </span>d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, \\overline{C}^{m_0}\\right) > e<span class="math"> . We abbreviate  </span>u' := \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i)<span class="math"> .  </span>(u_i)_{i=0}^{m_0-1}<span class="math"> . Applying the contraposition of Theorem 3.10 to the code  </span>\\overline{C}<span class="math"> , we conclude that, provided that the second part  </span>(r_{\\ell_1},\\ldots,r_{\\ell-1})\\in\\mathcal{T}_{\\tau}^{\\ell_0}<span class="math">  of the verifier&#x27;s random point resides <em>outside</em> a set of mass at most  </span>2\\cdot\\ell_0\\cdot\\frac{e+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  in  </span>\\mathcal{T}_{\\tau}^{\\ell_0}<span class="math"> , we have  </span>d(u', \\overline{C}) > e<span class="math"> . In particular, for each such  </span>(r_{\\ell_1}, \\dots, r_{\\ell-1})<span class="math"> ,  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta(u', \\mathsf{Enc}(t')) \\cup M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">> e +</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= \\left\\lfloor \\frac{d-1}{3} \\right\\rfloor<span class="math">  in fact holds, since  </span>\\mathsf{Enc}(t')<span class="math">  is a codeword. We conclude that  </span>J \\cap (\\Delta(u', \\mathsf{Enc}(t')) \\cup M) = \\varnothing$  holds with</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">probability at most  <span class="math">\\left(1-\\frac{d}{3\\cdot n}\\right)^{\\gamma}</span> . On the other hand, if  <span class="math">J\\cap (\\Delta(u&#x27;,\\operatorname{Enc}(t&#x27;))\\cup M)\\neq\\varnothing</span> , then we claim that  <span class="math">\\mathcal V</span>  accepts with negligible probability. Indeed,  <span class="math">\\mathcal A</span>  can pass on an index  <span class="math">j\\in M</span>  only by Merkle-opening a new column and on an index  <span class="math">j\\in\\Delta(u&#x27;,\\operatorname{Enc}(t&#x27;))\\setminus M</span>  only by Merkle-opening a column inconsistent with  <span class="math">\\mathcal E</span> 's extracted column  <span class="math">(u_{i,j})_{i=0}^{m_0-1}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Putting the pieces together, we see that  <span class="math">\\mathcal{A}</span> 's chance of passing is at most  $\\frac{Q(\\lambda)^2+1}{2^{\\lambda}}+2\\cdot\\ell_0\\cdot\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}+\\left(1-\\frac{d}{3\\cdot n}\\right)^{\\gamma}<span class="math">  (here, we crudely upper-bound  </span>2\\cdot\\ell_0\\cdot\\frac{e+1}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\leq 2\\cdot\\ell_0\\cdot\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> ). As  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq 2^{\\omega(\\log\\lambda)}<span class="math">  holds by construction, and d and  </span>\\ell_0<span class="math">  are polynomial in  </span>\\lambda<span class="math"> ,  </span>2\\cdot\\ell_0\\cdot\\frac{d}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  is negligible. On the other hand, we again have that  </span>\\left(1-\\frac{d}{3\\cdot n}\\right)^{\\gamma}$  is negligible. This completes the proof of the lemma.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Applying Lemma A.1, we assume henceforth that  $d^{m_0}\\Big((u_i)_{i=0}^{m_0-1}, \\overline{C}^{m_0}\\Big) < \\frac{d}{3} -</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">M</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . We conclude immediately that there exists an interleaved message  </span>(t_i)_{i=0}^{m_0-1}<span class="math">  for which  </span>\\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^{m_0}\\Big((u_i)_{i=0}^{m_0-1}, (\\operatorname{Enc}(t_i))_{i=0}^{m_0-1}\\Big) \\cup M\\Big</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">< \\frac{d}{3}<span class="math"> . We note that, a fortiori,  </span>d^{m_0}\\Big((u_i)_{i=0}^{m_0-1}, (\\operatorname{Enc}(t_i))_{i=0}^{m_0-1}\\Big) < \\frac{d}{3}<span class="math">  too holds. The following lemma shows that we may further restrict our attention to the case in which  </span>\\mathcal A<span class="math">  correctly outputs  </span>t' = \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}$  during its initial proof.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span id="page-49-0"></span><strong>Lemma A.2.</strong> If its message  <span class="math">t&#x27; \\neq \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}</span> , then  <span class="math">\\mathcal{A}</span>  passes with negligible probability.</p>

    <p class="text-gray-300"><em>Proof.</em> We write  <span class="math">e := \\lfloor \\frac{d-1}{3} \\rfloor</span> , and abbreviate  <span class="math">u&#x27; := \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i,r_i) \\cdot (u_i)_{i=0}^{m_0-1}</span> ; we moreover write  <span class="math">v&#x27; := \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i,r_i) \\cdot (\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}</span> . By the argument just given, we may freely assume that  <span class="math">d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, \\hat{C}^{m_0}\\right) \\le e</span>  holds; in particular,  <span class="math">d(u&#x27;,v&#x27;) \\le e</span> . On the other hand, our hypothesis implies that  <span class="math">\\mathsf{Enc}(t&#x27;) \\ne v&#x27;</span> . By the reverse triangle inequality, we thus have:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$$d(u', \\mathsf{Enc}(t')) \\geq</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">d(\\mathsf{Enc}(t'), v') - d(u', v')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\geq d - e.$$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We see that  <span class="math">J \\cap \\Delta(u&#x27;, \\mathsf{Enc}(t&#x27;)) = \\varnothing</span>  holds with probability at most  <span class="math">\\left(1 - \\frac{d-e}{n}\\right)^{\\gamma} \\leq \\left(1 - \\frac{2 \\cdot d}{3 \\cdot n}\\right)^{\\gamma}</span> , which is negligible. On the other hand, if  <span class="math">\\mathcal V</span>  queries any position  <span class="math">j \\in \\Delta(u&#x27;, \\mathsf{Enc}(t&#x27;))</span> , then either  <span class="math">j \\in M</span>  or  <span class="math">j \\in \\Delta(u&#x27;, \\mathsf{Enc}(t&#x27;)) \\setminus M</span> ; in these cases,  <span class="math">\\mathcal A</span>  can pass only by exhibiting an oracle collision (on a missing or on an existing column, respectively). This again completes the proof, in light of the guarantees  <span class="math">d = \\Omega(n)</span>  and  <span class="math">\\gamma = \\Theta(\\lambda)</span> .</p>

    <p class="text-gray-300">The following lemma is specific to our setting, and doesn't appear in [DP24]. We continue to assume that  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  has entries in the synthetic subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> , as well as that  <span class="math">d^{m_0}\\left((u_i)_{i=0}^{m_0-1},\\widehat{C}^{m_0}\\right) &lt; \\frac{d}{3}</span> .</p>

    <p class="text-gray-300"><span id="page-49-1"></span><strong>Lemma A.3.</strong> The matrix of messages  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  also has entries in the subring  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> .</p>

    <p class="text-gray-300">Proof. We assume for contradiction that the row  <span class="math">t_{i^<em>}</span> , say, where  <span class="math">i^</em> \\in \\{0, \\dots, m_0 - 1\\}</span> , satisfies  <span class="math">t_{i^<em>,j^</em>} \\notin A_{\\iota,\\kappa,\\iota}</span>  for some component  <span class="math">j^<em> \\in \\{0, \\dots, \\frac{m_1}{2^\\kappa} - 1\\}</span> . We recall the  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -basis  <span class="math">(\\beta_v)_{v \\in \\mathcal{B}_{\\tau-\\iota}}</span>  of  <span class="math">A_{\\iota,\\kappa,\\tau}</span>  introduced above. Expressing each component of  <span class="math">t_{i^</em>}</span>  in coordinates with respect to this basis, we express  <span class="math">t_{i^<em>}</span>  as a collection of  <span class="math">2^{\\tau-\\iota}</span>  vectors  <span class="math">t_{i^</em>,v} \\in \\mathcal{T}_{\\iota+\\kappa}^{m_1/2^\\kappa}</span> , for  <span class="math">v \\in \\mathcal{B}_{\\tau-\\iota}</span> . Our hypothesis on  <span class="math">t_{i^<em>}</span>  entails precisely that at least one nonzero-indexed  <span class="math">v^</em> \\in \\mathcal{B}_{\\tau-\\iota} \\setminus \\{(0,\\dots,0)\\}</span> , say—is not identically zero (i.e., as  <span class="math">\\mathcal{T}_{\\iota+\\kappa}^{m_1/2^\\kappa}</span> -element).</p>

    <p class="text-gray-300">Again exploiting the fact that  <span class="math">\\widehat{C}</span> 's generator matrix has entries in  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> , we see that the encoding  <span class="math">\\mathsf{Enc}(t_{i^<em>}) \\in A^n_{\\iota,\\kappa,\\tau}</span>  is precisely given, slice-wise, by the respective slice-encodings  <span class="math">\\mathsf{Enc}(t_{i^</em>,v})</span> , for  <span class="math">v \\in \\mathcal{B}_{\\tau-\\iota}</span> . Since  <span class="math">t_{i^<em>,v^</em>}</span>  is not identically zero, we conclude that  <span class="math">\\mathsf{Enc}(t_{i^<em>,v^</em>}) \\in \\mathcal{T}^n_{\\iota+\\kappa}</span>  is necessarily nonzero at at least d positions.</p>

    <p class="text-gray-300">Since  <span class="math">u_{i^<em>}</span>  is defined over  <span class="math">A_{\\iota,\\kappa,\\iota}</span> , its  <span class="math">v^{</em>\\text{th}}</span>  slice  <span class="math">u_{i^<em>,v^</em>}</span>  is identically zero. We conclude that  <span class="math">d(u_{i^<em>}, \\mathsf{Enc}(t_{i^</em>})) \\geq d</span> ; this inequality contradicts our assumption  <span class="math">d^{m_0}\\left((u_i)_{i=0}^{m_0-1}, (\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}\\right) &lt; \\frac{d}{3}</span> , itself justified above.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Lemma A.3 shows that, under the hypothesis  <span class="math">d^{m_0}\\Big((u_i)_{i=0}^{m_0-1}, \\widehat{C}^{m_0}\\Big) &lt; \\frac{d}{3}</span> —and assuming, as usual, that  <span class="math">(u_i)_{i=0}^{m_0-1}</span>  is defined over  <span class="math">A_{\\iota,\\kappa,\\iota} \\subset A_{\\iota,\\kappa,\\tau}</span> —we actually obtain the stronger conclusion  <span class="math">d^{m_0}\\Big((u_i)_{i=0}^{m_0-1}, C^{m_0}\\Big) &lt; \\frac{d}{3}</span> . Indeed, for each  <span class="math">i \\in \\{0,\\ldots,m_0-1\\}</span> , since  <span class="math">t_i \\in A_{\\iota,\\kappa,\\iota}^{m_1/2^{\\kappa}}</span>  (by Lemma A.3), we conclude that  <span class="math">\\operatorname{Enc}(t_i) \\in A_{\\iota,\\kappa,\\iota}^{n}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We thus restrict our attention to the case in which  <span class="math">\\mathcal{A}</span> 's initial proof  <span class="math">\\pi</span>  passes and there exists a message  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  for which both  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^{m_0}\\left((u_i)_{i=0}^{m_0-1},(\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}\\right)\\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{d}{3}<span class="math">  and  </span>t'=\\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)\\cdot(t_i)_{i=0}^{m_0-1}$  hold. We denote:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$\\delta := \\frac{Q(\\lambda)^2 + 1}{2^{\\lambda}} + \\left(1 - \\frac{2 \\cdot d}{3 \\cdot n}\\right)^{\\gamma} + \\frac{\\ell_0}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Since  <span class="math">\\delta</span>  is negligible in  <span class="math">\\lambda</span> ,  <span class="math">\\sqrt{\\delta}</span>  also is. In this light, we may simply ignore each execution for which  <span class="math">\\mathcal{A}</span> 's probability of success  <span class="math">\\varepsilon \\leq \\sqrt{\\delta}</span> , since in that case  <span class="math">\\mathcal{E}</span>  proceeds into step 3 in the first place with negligible probability. We thus assume that  <span class="math">\\varepsilon &gt; \\sqrt{\\delta}</span>  in what follows. In the following technical lemma, we write V for the event in which  <span class="math">\\mathcal{A}</span>  submits an accepting proof, and E for a further, arbitrary event.</p>

    <p class="text-gray-300"><span id="page-50-0"></span><strong>Lemma A.4.</strong> Assuming as above that  <span class="math">\\Pr[V] &gt; \\sqrt{\\delta}</span> , if  <span class="math">\\Pr[V \\wedge E] \\leq \\delta</span>  moreover holds, then  <span class="math">\\Pr[E \\mid V] \\leq \\sqrt{\\delta}</span> .</p>

    <p class="text-gray-300"><em>Proof.</em> Assuming the hypotheses of the lemma, we see that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[E \\mid V] = \\frac{\\Pr[V \\wedge E]}{\\Pr[V]} &lt; \\frac{\\delta}{\\sqrt{\\delta}} = \\sqrt{\\delta},</span></div>

    <p class="text-gray-300">as required.  <span class="math">\\Box</span></p>

    <p class="text-gray-300"><span id="page-50-1"></span><strong>Lemma A.5.</strong> The probability that  <span class="math">t&#x27;_i \\neq \\bigotimes_{j=\\ell_1}^{\\ell-1} (1-r_{i,j}, r_{i,j}) \\cdot (t_i)_{i=0}^{m_0-1}</span>  for any  <span class="math">i \\in \\{1, \\dots, m_0-1\\}</span>  is negligible.</p>

    <p class="text-gray-300">Proof. For each  <span class="math">i^<em> \\in \\{1, \\dots, m_0 - 1\\}</span> , we write  <span class="math">E_{i^</em>}</span>  for the event in which  <span class="math">\\mathcal{A}</span> 's  <span class="math">i^{<em>th}</span>  message  <span class="math">t&#x27;_{i^</em>} \\neq \\bigotimes_{j=\\ell_1}^{\\ell-1} (1 - r_{i^<em>,j}, r_{i^</em>,j}) \\cdot (t_i)_{i=0}^{m_0-1}</span> . By the argument of Lemma A.2,  <span class="math">\\Pr[V \\mid E_{i^<em>}]</span>  is at most  <span class="math">\\frac{Q(\\lambda)^2 + 1}{2^{\\lambda}} + \\left(1 - \\frac{2 \\cdot d}{3 \\cdot n}\\right)^{\\gamma} \\leq \\delta</span> . We thus see that  <span class="math">\\Pr[V \\wedge E_{i^</em>}] = \\Pr[V \\mid E_{i^<em>}] \\cdot \\Pr[E_{i^</em>}] \\leq \\delta</span> , so that the hypothesis of Lemma A.4 is fulfilled, and  <span class="math">\\Pr[E_{i^*} \\mid V] \\leq \\sqrt{\\delta}</span>  holds. The probability that any among the events  <span class="math">E_1, \\dots, E_{m_0-1}</span>  holds is thus at most  <span class="math">1 - \\left(1 - \\sqrt{\\delta}\\right)^{m_0-1} \\leq (m_0-1) \\cdot \\sqrt{\\delta}</span> , which is negligible (here, we use a standard binomial approximation).  <span class="math">\\square</span></p>

    <p class="text-gray-300"><span id="page-50-2"></span><strong>Lemma A.6.</strong> The probability that the rows  <span class="math">\\left(\\bigotimes_{j=\\ell_1}^{\\ell-1}(1-r_{i,j},r_{i,j})\\right)_{i=0}^{m_0-1}</span>  are linearly dependent is negligible.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Proof. We first argue that for  <span class="math">A\\subset \\mathcal{T}_{\\tau}^{m_0}</span>  an arbitrary proper linear subspace, and  $S\\coloneqq \\left\\{(r_{\\ell_1},\\ldots,r_{\\ell-1})\\in\\mathcal{T}_{\\tau}^{\\ell_0}\\ \\middle</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)\\in A\\right\\}<span class="math">  its preimage under the tensor map, we have  </span>\\mu(S)\\le \\frac{\\ell_0}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math"> . It suffices to prove the result only in case A is a hyperplane. We write  </span>a=(a_0,\\ldots,a_{m_0-1})\\in\\mathcal{T}_{\\tau}^{m_0}<span class="math">  for a vector of coefficients, not all zero, for which  </span>A=\\{u\\in\\mathcal{T}_{\\tau}^{m_0}\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ u\\cdot a=0\\}<span class="math">  holds. By construction,  </span>(r_{\\ell_1},\\ldots,r_{\\ell-1})\\in S<span class="math">  if and only if  </span>\\bigotimes_{i=\\ell_1}^{\\ell-1}(1-r_i,r_i)\\cdot a=0<span class="math"> . We note that  </span>S\\subset\\mathcal{T}_{\\tau}^{\\ell_0}<span class="math">  is nothing other than the vanishing locus of that combination of the  </span>\\ell_0<span class="math"> -variate multilinear Lagrange polynomials given by the coefficient vector a. Because a is not identically zero and these polynomials are linearly independent, we conclude that the combination is itself nonzero. Applying Schwartz–Zippel, we see that the vanishing locus  </span>S\\subset\\mathcal{T}_{\\tau}^{\\ell_0}<span class="math">  is of mass at most  </span>\\mu(S)\\leq\\frac{\\ell_0}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}$ , as desired.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We note that  <span class="math">\\bigotimes_{j=\\ell_1}^{\\ell-1}(1-r_{0,j},r_{0,j})</span>  is not the zero vector, since its components necessarily sum to 1. For each  <span class="math">i^<em> \\in \\{1,\\ldots,m_0-1\\}</span> , we set as  <span class="math">A_{i^</em>} \\subset \\mathcal{T}_{\\tau}^{m_0}</span>  the span of  <span class="math">\\left(\\bigotimes_{j=\\ell_1}^{\\ell-1}(1-r_{i,j},r_{i,j})\\right)_{i=0}^{i^<em>-1}</span> , and write  <span class="math">E_{i^</em>}</span>  for the event in which  <span class="math">\\bigotimes_{j=\\ell_1}^{\\ell-1}(1-r_{i^<em>,j},r_{i^</em>,j}) \\in A_{i^<em>}</span> . The above argument implies exactly that  $\\Pr[E_{i^</em>}] \\leq \\frac{\\ell_0}{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\tau}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">} \\leq \\delta<span class="math"> ; we conclude in particular that  </span>\\Pr[V \\wedge E_{i^<em>}] = \\Pr[V \\mid E_{i^</em>}] \\cdot \\Pr[E_{i^<em>}] \\leq \\delta<span class="math"> , and the hypothesis of Lemma A.4 is again fulfilled. Applying Lemma A.4 repeatedly, we conclude again that the probability that any of the events  </span>E_{i^</em>}<span class="math">  holds, for  </span>i^* \\in \\{1,\\ldots,m_0-1\\}<span class="math"> , is at most  </span>1-\\left(1-\\sqrt{\\delta}\\right)^{m_0-1} \\leq (m_0-1) \\cdot \\sqrt{\\delta}<span class="math"> , which is negligible.  </span>\\square$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We finally argue that the values t and  <span class="math">u=(u_i)_{i=0}^{m_0-1}</span>  extracted by  <span class="math">\\mathcal E</span>  satisfy  <span class="math">\\Pi.\\mathsf{Open}(\\mathsf{params},c;t,u)</span>  and  <span class="math">t(r_0,\\ldots,r_{\\ell-1})=s</span> . Indeed, under the condition guaranteed by Lemma A.1, a matrix  <span class="math">(t_i)_{i=0}^{m_0-1}</span>  for which  $\\left</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta^{m_0}\\left((u_i)_{i=0}^{m_0-1},(\\mathsf{Enc}(t_i))_{i=0}^{m_0-1}\\right)\\cup M\\right</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><\\frac{d}{3}<span class="math">  exists. Under the conditions guaranteed by Lemmas A.5 and A.6,  </span>\\mathcal E<span class="math">  extracts precisely this matrix  </span>(t_i)_{i=0}^{m_0-1}<span class="math">  in steps 3 and 5. By Lemma A.3, this matrix is a posteriori defined over  </span>A_{\\iota,\\kappa,\\iota}<span class="math"> , and thus—up to reversing Theorem 3.9&#x27;s  </span>\\mathcal T_\\iota<span class="math"> -isomorphism—defines a polynomial  </span>t(X_0,\\ldots,X_{\\ell-1})\\in \\mathcal T_\\iota[X_0,\\ldots,X_{\\ell-1}]^{\\preceq 1}<span class="math"> , as required. Finally, Lemma A.2 guarantees that  </span>\\mathcal A$ 's first message</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">satisfies  <span class="math">t&#x27; = \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1}</span> ; on the other hand,  <span class="math">\\Pi.\\mathsf{Verify}(\\mathsf{params}, c, s, (r_0, \\dots, r_{\\ell-1}), \\pi)</span>  implies that  <span class="math">s = t&#x27; \\cdot \\bigotimes_{i=0}^{\\ell_1-1} (1-r_i, r_i)</span> . We conclude that  <span class="math">s = \\bigotimes_{i=\\ell_1}^{\\ell-1} (1-r_i, r_i) \\cdot (t_i)_{i=0}^{m_0-1} \\cdot \\bigotimes_{i=0}^{\\ell_1-1} (1-r_i, r_i) = t(r_0, \\dots, r_{\\ell-1}),</span>  as required. This completes the proof of the theorem.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Proof of Theorem 3.14. We recall first of all the guarantee  <span class="math">\\ell = O(\\log \\lambda)</span> , which holds by assumption throughout Construction 3.11; we moreover assume that, for  <span class="math">\\iota \\geq 0</span>  arbitrary, each  <span class="math">\\mathcal{T}_{\\iota}</span> -multiplication imposes a cost polynomial in the bit-length  <span class="math">2^{\\iota}</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We set  <span class="math">\\gamma \\coloneqq \\lambda</span>  and  <span class="math">\\tau \\coloneqq \\lceil \\log(\\log^2(\\lambda)) \\rceil</span> , as well as as well as  <span class="math">\\ell_1 \\coloneqq \\lceil \\frac{1}{2} \\cdot (\\ell + \\log \\gamma) \\rceil</span>  and  <span class="math">\\ell_0 \\coloneqq \\ell - \\ell_1</span> , and finally write  <span class="math">m_0 \\coloneqq 2^{\\ell_0}</span>  and  <span class="math">m_1 \\coloneqq 2^{\\ell_1}</span> . Since the statement is asymptotic and  <span class="math">\\iota</span>  is constant, we assume freely that  <span class="math">\\tau \\ge \\iota</span> . We note that  <span class="math">m_0</span>  and  <span class="math">m_1</span>  differ by at most a factor of 2 from, respectively,  <span class="math">\\frac{1}{\\sqrt{\\gamma}} \\cdot \\sqrt{2^\\ell}</span>  and  <span class="math">\\sqrt{\\gamma} \\cdot 2^\\ell</span> . We fix the rate  <span class="math">\\rho \\coloneqq \\frac{1}{2}</span> , and moreover set  <span class="math">\\kappa \\ge 0</span>  minimally so that  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathcal{T}_{\\iota+\\kappa}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^{2^{\\iota+\\kappa}} \\ge \\frac{1}{\\rho} \\cdot \\frac{m_1}{2^\\kappa}<span class="math">  holds (equivalently, so that  </span>2^{\\iota+\\kappa} + \\kappa \\ge -\\log \\rho + \\ell_1<span class="math">  holds). We note that this minimal  </span>\\kappa<span class="math">  necessarily satisfies  </span>\\kappa \\le \\ell_1<span class="math"> . Indeed, the choice  </span>\\kappa = \\ell_1<span class="math">  itself certainly satisfies  </span>2^{\\iota+\\ell_1} + \\ell_1 \\ge 1 + \\ell_1 = -\\log \\rho + \\ell_1<span class="math"> , as required. We conclude that  </span>2^\\kappa \\le m_1<span class="math"> ; we finally write  </span>k \\coloneqq \\frac{m_1}{2^\\kappa}<span class="math">  and  </span>n \\coloneqq \\frac{1}{\\rho} \\cdot k<span class="math"> , and set as  </span>C \\subset \\mathcal{T}_{\\iota+\\kappa}^n<span class="math">  the Reed–Solomon code  </span>\\mathsf{RS}_{\\mathcal{T}_{\\iota+\\kappa}}[n,k]<span class="math"> . We note that, by our choice of  </span>\\kappa<span class="math"> , this code exists. On the other hand, by the minimality of  </span>\\kappa<span class="math"> , we moreover have the upper-bound  </span>2^{\\iota+\\kappa} \\le 2 \\cdot (-\\log(\\rho) + \\ell_1 - \\kappa) = O(\\ell)<span class="math"> . We note that the values  </span>\\gamma, \\tau, \\kappa<span class="math"> , and  </span>C \\subset \\mathcal{T}_{\\iota+\\kappa}^n<span class="math">  chosen in this way fulfill the requirements of  </span>\\Pi$ . Setup.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We assume that each bit received imposes constant cost; we see immediately that the protocol's total communication-attendant cost is  <span class="math">2^{\\tau} \\cdot m_1 + 2^{\\iota + \\kappa} \\cdot m_0 \\cdot \\gamma = O\\left(\\log^2(\\lambda) \\cdot \\sqrt{\\gamma \\cdot 2^{\\ell}} + \\ell \\cdot \\sqrt{\\frac{2^{\\ell}}{\\gamma}} \\cdot \\gamma\\right) = \\widetilde{O}(\\sqrt{2^{\\ell}}).</span></p>

    <p class="text-gray-300">Again by our choice of  <span class="math">\\tau</span> , we see that each  <span class="math">\\mathcal{T}_{\\tau}</span> -operation costs polynomially in  <span class="math">2^{\\tau} = O(\\log^2 \\lambda)</span> , and so costs  <span class="math">\\widetilde{O}(1)</span> . We see that the total cost of all  <span class="math">\\mathcal{T}_{\\tau}</span> -operations is  <span class="math">\\widetilde{O}(m_0 + m_1) = \\widetilde{O}\\left(\\sqrt{\\lambda \\cdot 2^{\\ell}}\\right)</span> . We analyze the total cost of all  <span class="math">\\mathcal{T}_{\\iota}</span>  operations in the following way. Since  <span class="math">2^{\\kappa} \\leq 2^{\\iota + \\kappa} = O(\\ell)</span> , and since the cost of  <span class="math">2^{\\tau - \\iota}</span>   <span class="math">\\mathcal{T}_{\\iota}</span> -operations is certainly at most that of one  <span class="math">\\mathcal{T}_{\\tau}</span> -operation, we see that the total cost imposed by  <span class="math">2^{\\kappa} \\cdot 2^{\\tau - \\iota}</span>   <span class="math">\\mathcal{T}_{\\iota}</span> -operations is at most  <span class="math">O(\\ell) \\cdot \\widetilde{O}(1) = \\widetilde{O}(1)</span> . The total cost of all  <span class="math">\\mathcal{T}_{\\iota}</span> -operations is thus  <span class="math">\\widetilde{O}(\\gamma \\cdot m_0) = \\widetilde{O}\\left(\\sqrt{\\gamma \\cdot 2^{\\ell}}\\right) = \\widetilde{O}\\left(\\sqrt{\\lambda \\cdot 2^{\\ell}}\\right)</span> .</p>

    <p class="text-gray-300">Using the upper-bound  <span class="math">2^{\\iota+\\kappa}=O(\\ell)=O(\\log\\lambda)</span> , we see that each  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -operation costs  <span class="math">\\widetilde{O}(1)</span> . On the other hand, the result [LCH14] ensures that the cost of  <span class="math">\\mathfrak{Enc}</span>  is equal to that of  <span class="math">O(n\\cdot\\log k)=O\\left(\\frac{1}{\\rho}\\cdot\\frac{m_1}{2^\\kappa}\\cdot\\log(\\frac{m_1}{2^\\kappa})\\right)=\\widetilde{O}\\left(\\sqrt{2^\\ell}\\right)</span>   <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -operations, and so is itself  <span class="math">\\widetilde{O}\\left(\\sqrt{2^\\ell}\\right)</span> . The total cost of all  <span class="math">2^{\\tau-\\iota}</span>  encoding operations is thus  <span class="math">O(\\log^2\\lambda)\\cdot\\widetilde{O}\\left(\\sqrt{2^\\ell}\\right)=\\widetilde{O}\\left(\\sqrt{2^\\ell}\\right)</span> , as required.</p>

    <p class="text-gray-300">We assume, as Brakedown's analysis does (see [Gol+23, § 1]), that the cost  <span class="math">\\mathfrak{Hash}</span>  of hashing a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -element is comparable to that of performing a  <span class="math">\\mathcal{T}_{\\iota+\\kappa}</span> -operation. The total cost of each  <span class="math">\\mathfrak{Hash}</span>  operation is thus  <span class="math">\\widetilde{O}(1)</span> , so that the total cost of all  <span class="math">\\gamma \\cdot m_0</span>   <span class="math">\\mathfrak{Hash}</span> -operations is  <span class="math">\\widetilde{O}\\left(\\sqrt{\\gamma \\cdot 2^\\ell}\\right) = \\widetilde{O}\\left(\\sqrt{\\lambda \\cdot 2^\\ell}\\right)</span> .</p>`;
---

<BaseLayout title="Succinct Arguments over Towers of Binary Fields (2023/1784)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/1784
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
