---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/272';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Impossible differential cryptanalysis of LBlock with concrete investigation of key scheduling algorithm';
const AUTHORS_HTML = 'Jiageng Chen, Yuichi Futa, Atsuko Miyaji, Chunhua Su';

const CONTENT = `    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">Impossible differential cryptanalysis has been proved to be one of the most powerful techniques to attack block ciphers. Based on the impossible differential paths, we can usually add several rounds before or after to launch the key recovery attack. Impossible differential cryptanalysis is powerful not only because the number of rounds it can break is very competitive compared to other attacks, but also unlike differential attacks which are statistical attacks in the essential, impossible differential analysis does not require many statistical assumptions. In this paper, we investigate the key recovery attack part of the impossible differential cryptanalysis. We point out that when taking the (non-linear) key scheduling algorithm into consideration, we can further derive the redundancy among the subkeys, and thus can filter the wrong key at a rather early stage. This can help us control the time complexity and increase the number of rounds we can attack. As an application, we analyze recently proposed lightweight block cipher LBlock, and as a result, we can break 23 rounds with complexity $2^{77.4}$ encryptions without using the whole code block, which is by far the best attack against this cipher.</p>
      <p class="text-gray-300"><strong>Keywords:</strong> Impossible differential cryptanalysis &middot; key recovery attack &middot; key scheduling algorithm &middot; LBlock</p>
    </section>

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Block ciphers have been investigated for quite a long time, and a lot of powerful methods have been proposed such as differential attack [2], boomerang attack [23], linear attack [16], integral attack [13], meet in the middle attack [5], and so on. Among these techniques, impossible differential cryptanalysis is one of the most powerful attack against block ciphers, especially block cipher with Feistel and General Feistel structures are especially considered to be weak for impossible differential attack as demonstrated in [8] and [22]. Since the technique was first published in [1], a lot of ciphers have been carefully investigated by impossible differential attack, which has become a standard default routine when evaluating newly proposed ciphers. Different from differential attack which searches for the right key with the most high probability, impossible differential attack searches the right key by discarding the wrong ones, and the process makes sure that the right key will never be wrongly discarded. Thus compared with the differential attack which has to makes the wrong key randomization hypothesis [3], impossible differential attack provides much more guarantee on the cryptanalysis result we get. Thus if similar results (from the point view of data complexity, computational complexity and the number of rounds) are derived, we should prefer impossible differential cryptanalysis. Like in differential attack we need to first find good differential path holding with high probability, we need to find an impossible differential path, which from the name indicating, should not be existed with probability one. Since there is no probability involved compared with differential attack, good path here means the path that can cover long rounds. There are a lot of researches on how to find such path such as [11]. Generally speaking, finding impossible differential path is a relatively easier job than finding differential path, since at present, the gap between the theory and practice for finding the best differential path is still large. In this paper, we would like to focus on the key recovery part. Previously, this part was done trivially by directly recover the subkey involved in the beginning or the end of the impossible differential path. We show in this paper that we can further optimize this step by considering the key scheduling algorithm instead of considering the subkey as independent key bits. By investigating the key scheduling algorithm carefully, we could reveal the relationship between the subkey bits guessed in the first rounds and last rounds, then the redundancy can help us to discard the key at an early stage efficiently.</p>

    <p class="text-gray-300">Lightweight block ciphers have attracted much of the research attention due to the low computational cost in both hardware and software implementation which is suitable for resource-restricted devices such as RFID tags. The security margin they provide, although reduced compared with the traditional block ciphers, is considered to be reasonable given the cost of information being protected. Generally speaking, key size is usually chosen to be 80 bits, while the popular versions of block size are 32, 48 and 64 bits. The first famous block cipher that was widely considered to be lightweight is PRESENT [4]. After that, many lightweight block ciphers have been proposed such as KATAN/KTANTAN family [6], TWINE [21], PRINTcipher [12], LBlock [26] and so on. Compared with AES which was selected through competitions, lightweight block ciphers get started only recently, and the lack of enough cryptanalysis will prevent those ciphers from being adopted by the industrial world. In this paper, we target one of the recent proposed cipher LBlock which has not been analyzed thoroughly.</p>

    <p class="text-gray-300">In ACNS2011, LBlock [26] was proposed as a lightweight block which targets fast hardware and software implementation. It is designed using 32-round Feistel structure with 64-bit block size and 80-bit key size. In the original paper, the authors gave several attacks against LBlock, among which the impossible differential attack is the best one that can attack 20 rounds. Since, it attracted many analysises using techniques such as differential attack, boomerang attack, integral attack, zero-correlation linear attack, and so on. Among them, impossible differential attack is one of the best attack which can penetrate the largest number of rounds. We summarize the latest analysis results in the following tables along with ours.</p>

    <p class="text-gray-300">Table 1. Single key scenario attacks against LBlock</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">#</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Round</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Methods</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time Complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">1 0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Source</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[18]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Integral Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{2^{70}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[19]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Zero-Correlation Linear</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{71.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.1}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[20]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[26]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[14]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[10]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{57}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Ours</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">13</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{42.08}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">not mentioned</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[15]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">17</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{67.52}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59.75}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[7]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">18</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Boomerang Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70.84}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63.27}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[7]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[17]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Related-Key)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Impossible Differential Attack</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61.4}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[24]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(Related-Key)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">This paper is organized as follows. In Section 2, we first give short introduction on impossible differential attack, and then propose an improved version based on the key scheduling algorithm. Section 3 provides main notations and specifications of LBlock. Section 4 gives the concrete attacks against 23 rounds of LBlock and followed by the conclusion in Section 5.</p>

    </section>

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2 Impossible differential attack considering key scheduling algorithm</h2>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8">2.1 Impossible differential attack</h3>

    <p class="text-gray-300">Before the key recovery steps, we will first need a good impossible differential characteristic which covers as many rounds as possible. Usually, this kind of impossible differential characteristic can be built by miss-in-the-middle method. For a truncated input differential  <span class="math">\\alpha</span> , try to find an output differential  <span class="math">\\gamma</span>  where  <span class="math">Pr(\\alpha \\to \\gamma) = 1</span>  in the forward direction. In the same way, find a backward differential path  <span class="math">\\beta \\to \\delta</span>  with probability 1. If  <span class="math">\\gamma \\neq \\delta</span> , then  <span class="math">Pr(\\alpha \\to \\beta) = 1</span> . Now based on this impossible differential path, we add some rounds at the beginning and the end of the path to compute the truncated input and output differential  <span class="math">\\Delta P</span>  and  <span class="math">\\Delta C</span> . Suppose the subkeys used during rounds covered by paths  <span class="math">\\Delta P \\to \\alpha</span>  and  <span class="math">\\Delta C \\to \\beta</span>  are defined to be  <span class="math">k_f</span>  and  <span class="math">k_b</span> , then we try to guess the subkey bits  <span class="math">k_f, k_b</span>  (or the corresponding extended key bits) to test that given the plaintext and ciphertext pairs following input and output differentials  <span class="math">(\\Delta P, \\Delta C)</span> , whether</p>

    <p class="text-gray-300">the guessed key bits can be satisfied. If so, then it can be eliminated from the key space. By testing the key space using a large mount of message pairs, the right key is expected to be remained. The general framework is depicted in Figure 1.</p>

    <p class="text-gray-300">    <img src="_page_3_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. Impossible Differential Cryptanalysis</p>

    <p class="text-gray-300">To launch a successful impossible differential attack, we wish that both impossible differential characteristic and key recovery rounds can be long so that the total number of rounds we can attack may be increased. There are many previous researches dealing with how to build good impossible differential characteristics such as [11]. Unlike differential path, the space left to be improved seems to be little regarding the impossible differential path. Thus investigating the key recovery in detail may provide us with some further advantages which is only generally studied previously.</p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8">2.2 Our improvement by investigating key scheduling algorithm</h3>

    <p class="text-gray-300">Let's suppose before and after the impossible differential path, we add  <span class="math">r_f</span>  rounds and  <span class="math">r_b</span>  rounds. Denote the number of subkey bits involved in the  <span class="math">r_f</span>  and  <span class="math">r_b</span>  rounds to be  <span class="math">\\#SK_f</span>  and  <span class="math">\\#SK_b</span> , which are the key bits that are required when computing from difference  <span class="math">\\Delta P</span>  ( <span class="math">\\Delta C</span> ) to  <span class="math">\\alpha</span>  ( <span class="math">\\beta</span> ). The traditional way to proceed key recovery phase is to find for each of the  <span class="math">\\#SK_f + \\#SK_b</span>  subkey candidate, a set of plaintext and ciphertext pairs that can satisfy the impossible differential path. Let's suppose that for each of the  <span class="math">\\#SK_f + \\#SK_b</span>  key candidates, we have N pairs before satisfying the last x-bit condition of the impossible differential path, and denote the probability to be  <span class="math">Pr_x</span> . Then the probability for the subkey candidate to remain is  <span class="math">Pr_x = (1-2^{-x})^N</span> . Thus the number of remaining key candidate is  <span class="math">2^{\\#SK_f + \\#SK_b} \\times (1 - 2^{-x})^N</span> , which should be less than the  <span class="math">2^{\\#SK_f + \\#SK_b}</span> . Many of the previous researches on impossible differential attack assumes that  <span class="math">\\#SK_f + \\#SK_b</span>  is less than the total master key length. In that case, we can filter either  <span class="math">SK_f</span>  or  <span class="math">SK_b</span>  to a relatively small amount of number, then brute force the rest of the consecutive key bits related to  <span class="math">SK_f</span>  or  <span class="math">SK_b</span> . The problem here is that  <span class="math">SK_f</span>  and  <span class="math">SK_b</span>  are definitely not independent subkeys. Key scheduling algorithm of the block cipher will take a master key as a starting point and generate subkeys for each round from the master key bits. Usually, the subkey generation will go through nonlinear operation such S-Box or modular addition, etc. Recent lightweight block ciphers even simplify it by just reusing the master</p>

    <p class="text-gray-300">key in different rounds such as TEA(XTEA) [25] and LED [9], or only linear operation such as KATAN family [6]. If we can exploit the relation between SK<sup>f</sup> and SKb, we can reduce the number of total key candidate, and further extend the number of rounds we can attack, since we do not need 2#SKf+#SK<sup>b</sup> to be less than the total master key bits. The simple reusing or only linear key scheduling algorithm is relatively easy to analyze. Here we focus on the non-linear key scheduling algorithm which is widely deployed, and at the same time it is not as trivial to analyze as the case of linear key scheduling algorithm. We propose to proceed the key recovery phase in the following steps:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Given the plaintext and ciphertext differences and the first round conditions, make a structure of plaintext and ciphertext pairs which satisfy the input and output difference as well as the first round conditions for each of the first round subkeys that are required to be guessed.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Guess the subkey bits in either r<sup>f</sup> or r<sup>b</sup> and filter the wrong pairs after each condition checking.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>For each guessed subkey bit, propagate it forwards or backwards respectively (which depend on r<sup>f</sup> or rb) to subkeys in each of the following rounds until it faces nonlinear operation where more unknown information bits are required to keep going.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Resolve the subkey conflicting. If we find that part of input or output of the nonlinear function are known, then guess the rest of unknown bits to derive the corresponding input or output. If part of the input or output are already known due to step two, then we get a conflict and the total number of guessed key candidates can be decreased. Then go to step 2 until no more conflicts can be resolved.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Finally for each guessed subkey, filter it according to the remaining pairs. After that, we need to map the subkey which are distributed in different rounds to one round, and apply brute force search to recover the rest of the key bits that have not been guessed. Then we know all the consecutive key bits which has the same length as the master key length, and can easily recover the master key.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">The biggest difference from the previous researches is step 4. Previously, only plaintext and ciphertext pairs get filtered after each subkey guess. Here if we can also filter the key candidates at an early stage, then we gain an advantage at both computational complexity and the number of rounds we can attack. Just consider the situation where in order to check t-bit condition, we need to guess sbit subkey where s is much more larger than t. This can be the case for checking the conditions in rounds close to the input or output of the impossible differential path, where many subkeys are involved in computing the internal state. The complexity is computed as the multiplication of the number of guessed key bits and the remaining pairs. It is highly possible that the number of guessed key bits grows so quickly that the total complexity is larger than brute force searching the master key. By reducing the key candidates at the same time as filtering plaintext and ciphertext pairs, we can control and optimize the total complexity.</p>

    <h4 id="sec-misc-1" class="text-lg font-semibold mt-6">Notations and LBlock 3</h4>

    <h4 id="sec-misc-2" class="text-lg font-semibold mt-6">Notations</h4>

    <p class="text-gray-300">We summarize the notations here that will be used in the analysis.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-L_r, R_r</span> : the left and right internal state of round r starting from 0.</li>
      <li><span class="math">-L_{r,[i]}, R_{r,[i]}</span> : the i-th nibble of  <span class="math">L_r</span>  and  <span class="math">R_r</span> .  <span class="math">-\\Delta L_{i,[j]}, \\Delta R_{i,[j]}</span> : the difference of <em>i</em>-th nibble of  <span class="math">L_r</span>  and  <span class="math">R_r</span> .</li>
      <li><span class="math">-\\alpha_i</span> : differences specified in the rounds before the impossible differential path.</li>
      <li><span class="math">-\\beta_i</span> : differences specified in the rounds after the impossible differential path.</li>
      <li><span class="math">K_i</span> : The corresponding 80-bit master key used in round i.</li>
      <li><span class="math">-k_i</span> : 32-bit subkey used in round i.</li>
      <li><span class="math">-k_{i,[i\\sim j]}</span> : i-th bit to j-th bit of subkey  <span class="math">k_i</span> . i and j are denoted according to the whole 80-bit index instead of 32-bit index. Assuming  <span class="math">k_0 = [k_{0,48}, k_{0,49}, ..., k_{0,79}]</span> .</li>
    </ul>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8">3.2 LBlock</h3>

    <p class="text-gray-300">LBlock consists of a 32-round variant Feistel network with 64-bit block size and 80-bit key size. The encryption algorithm works as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">For
<span class="math">$i = 2, 3, ..., 33</span>$
, do  <span class="math">X_i = F(X_{i-1}, K_{i-1}) \\oplus (X_{i-2} &lt;&lt;&lt; 8)</span></p></li>
      <li><p class="text-gray-300">Ciphertext is  <span class="math">C = X_{32} || X_{33}</span></p></li>
    </ol>

    <p class="text-gray-300">Here round function F contains a S-Box layer and a diffusion layer which are denoted as S and P.</p>

    <p class="text-gray-300"><span class="math">$F: \\{0,1\\}^{32} \\times \\{0,1\\}^{32} \\to \\{0,1\\}^{32}, (X,K_i) \\to P(S(X \\oplus K_i))</span>$</p>

    <p class="text-gray-300">There are eight 4-bit S-Boxes for each of the nibbles. Suppose the input and output of the S-box are Y and Z. The S layer can be denoted as</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} Y &amp;= Y_7 ||Y_6||Y_5||Y_4||Y_3||Y_2||Y_1||Y_0 \\rightarrow Z = Z_7 ||Z_6||Z_5||Z_4||Z_3||Z_2||Z_1||Z_0 \\\\ Z_7 &amp;= s_7(Y_7), Z_6 = s_6(Y_6), Z_5 = s_5(Y_5), Z_4 = s_4(Y_4), Z_3 = s_3(Y_3), \\\\ Z_2 &amp;= s_2(Y_2), Z_1 = s_1(Y_1), Z_0 = s_0(Y_0) \\end{split}</span>$</p>

    <p class="text-gray-300">For diffusion layer with the input and output of the layer being Z and U, it can be denoted as:</p>

    <p class="text-gray-300"><span class="math">$U_7 = Z_6, U_6 = Z_4, U_5 = Z_7, U_4 = Z_5, U_3 = Z_2, U_2 = Z_0, U_1 = Z_3, U_0 = Z_1</span>$</p>

    <p class="text-gray-300">All the above details are concluded in Figure 2. Since take advantage of key scheduling algorithm, we also give the description here. 80-bit master K is denoted as  <span class="math">K = [k_{79}, k_{78}, ..., k_0]</span> . Set the first round key to be  <span class="math">k_0 = [k_{79}, ..., k_{48}]</span> . Then for each of the subkey used in the following round, we do the following updating process before outputting the leftmost 32 bits of K.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>K = K &lt;&lt;&lt; 29</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">[k_{79},...,k_{76}] = S_9[k_{79},...,k_{76}], [k_{75},...,k_{72}] = S_9[k_{75},...,k_{72}]</span> 3.  <span class="math">[k_{50},...,k_{46}] \\oplus [i]_2</span></li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Step 2 is the main non-linear operation we will need to consider in detail, and we do not care about step 3.</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. LBlock</p>

    </section>

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">4 Impossible differential attack on 23 rounds of LBlock</h2>

    <p class="text-gray-300">We take advantage of the 14 round impossible differential path (00000000,000*  <span class="math">(0000) \\neq (000000 * 0,00000000)</span> , which is also used in [10]. Now we add four rounds before and five rounds after to attack in total 23 rounds of LBlock. Since the differential property is rather symmetric, we could also attack in the five rounds before and four rounds after pattern. Here for the simplicity, we only demonstrate the first one. Figure 3 demonstrates the differential path for the first four and the last five rounds. Our first task is to collect the plaintext and ciphertext pairs that could be used to launch the attack. By propagating the input and output impossible differential in the backward and forward directions, we can get part of the differences of the plaintext and ciphertext pairs. Usually, we first collect pairs that satisfy the plaintext difference, and then filter the pairs according to the ciphertext difference. However, this approach is time consuming since it first needs to collect a huge amount of data to start with. Here we propose to construct plaintext and ciphertext pairs using conditional impossible differential, which will help to bypass the plaintext and ciphertext difference conditions as well as the first round conditions free of cost.</p>

    <p class="text-gray-300">First let's fix plaintext  <span class="math">L_{0,[0,3,5\\sim7]}</span>  to be some random value in  <span class="math">F_2^4</span> .  <span class="math">L_{0,[1,2,4]}</span>  take all the 16 values and we get  <span class="math">2^{12}</span>  plaintexts. Now for each  <span class="math">k_{0,[1,2,4]}</span> , compute  <span class="math">R_{0,1}=S_2(L_{0,2}\\oplus k_{0,2}),\\,R_{0,4}=S_4(L_{0,4}\\oplus k_{0,4})</span>  and  <span class="math">R_{0,6}=S_1(L_{0,1}\\oplus k_{0,1})</span> . Take all the 16 values for  <span class="math">R_{0,[0,2]}</span> , then we have  <span class="math">2^{12}\\times 2^8=2^{20}</span>  plaintexts for each of the 12-</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300"><strong>Fig. 3.</strong> Differential path for the first four rounds (left side) and last five rounds (right side).  <span class="math">\\alpha_i</span>  and  <span class="math">\\beta_i</span>  denote some non-zero 4-bit difference.</p>

    <p class="text-gray-300">bit subkey  <span class="math">k_{0,[1,2,4]}</span> . Any pair taken from them will satisfy the plaintext difference and first round conditions. Now query the corresponding ciphertexts and sort the data according to  <span class="math">L_{23,7}</span> ,  <span class="math">R_{23,[2,6,7]}</span>  where there are no output difference. Then we can directly generate  <span class="math">2^{20\\times 2-1}\\times 2^{-4\\times 4}=2^{23}</span>  pairs for each of the 12-bit subkey. Actually, we can further filter the pairs before guessing any key bits. It is based on the following observation.</p>

    <p class="text-gray-300"><strong>Theorem 1.</strong> For every S-Box, each input difference leads to average 6.06 possible output differences. And given each possible input and output pair, there are on average  <span class="math">2^{1.4}</span>  legal key candidates.</p>

    <p class="text-gray-300">So if both input and output differences to an S-box are known, we know part of them are illegal and can be filtered immediately. By investigating the first four and last five rounds, we conclude the following 12 conditions, and from them we are able to filter part of the plaintext and ciphertext pairs.</p>

    <pre><code class="language-text">\\begin{array}{l} - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{1:} \\  \\, \\alpha_0 \\to \\alpha_4, \\  \\, \\alpha_2 \\to \\alpha_3. \\\\ - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{2:} \\  \\, \\alpha_1 \\to \\alpha_2. \\\\ - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{3:} \\  \\, \\alpha_0 \\to \\alpha_1. \\\\ - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{20:} \\  \\, \\beta_0 \\to \\beta_3, \\  \\, \\beta_2 \\to \\beta_4. \\\\ - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{21:} \\  \\, \\beta_3 \\to \\beta_7, \\  \\, \\beta_4 \\to \\beta_5. \\\\ - \\  \\, \\mathbf{Round} \\  \\, \\mathbf{22:} \\  \\, \\beta_7 \\to \\beta_c, \\  \\, \\beta_5 \\to \\beta_b, \\  \\, \\beta_6 \\to \\beta_a, \\  \\, \\beta_2 \\to \\beta_7. \\end{array}
</code></pre>

    <p class="text-gray-300">Note that all the above differences  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  appear in the plaintext and ciphertext difference, and that's why we can use the above condition to further filter the legal pairs by a very quick table lookup. Each of the above condition will allow one pair to pass with probability  <span class="math">\\frac{6.06}{16} = 2^{-1.4}</span> . Thus there remains  <span class="math">2^{23-1.4\\times12} = 2^{6.2}</span>  pairs. Let's suppose these  <span class="math">2^{6.2}</span>  pairs form one structure, and we can build similar structures by taking one of the following procedures. (1). changing the fixed values of  <span class="math">L_{0,[0,3,5\\sim7]}</span> ,  <span class="math">R_{0,[3,5,7]}</span> . (2), changing the values of  <span class="math">R_{0,[1,4,6]}</span>  by xoring a constant in  <span class="math">F_2^4</span> . We can do (1) since we have not chosen those values yet. For the case of (2), we can explain in this way: in the previous construction, we actually require for example  <span class="math">R_{0,1} = S_2(L_{0,2} \\oplus k_{0,2})</span>  and  <span class="math">R&#x27;_{0,1} =</span>  <span class="math">S_2(L_{0,2}&#x27; \\oplus k_{0,2})</span> . Thus of course  <span class="math">R_{0,1} \\oplus R_{0,1}&#x27; = S_2(L_{0,2} \\oplus k_{0,2}) \\oplus S_2(L_{0,2}&#x27; \\oplus k_{0,2})</span> . However, this equation still hold if we add a constant C to both  <span class="math">R_{0,1}</span>  and  <span class="math">R&#x27;_{0,1}</span> . Remember we only need conditions on differences not the exact values. Another point here is that the plaintexts by adding the constant C for one subkey actually has been obtained by another subkey. In other words, the total data complexity will not increase, and many plaintexts can be shared among different subkeys. As a result, we can maximumly build  <span class="math">2^{12+4\\times8}=2^{44}</span>  structures for each of the subkey  <span class="math">k_{0,[1,2,4]}</span> . Suppose we take n structures, then for each of the subkey  <span class="math">k_{0,[1,2,4]}</span> , we have  <span class="math">2^{n+6.2}</span>  legal pairs, and the data complexity is  <span class="math">2^{n+20}</span> .</p>

    <h3 id="sec-misc-3" class="text-xl font-semibold mt-8">Key recovery.</h3>

    <p class="text-gray-300">The key scheduling algorithm of LBlock is designed in a stream cipher way. At each round, 8-bit subkey go through non-linear S-Box. It is easy to see that as long as the consecutive 80-bit subkey can be recovered, we can easily recover the master key. We start by guessing the subkey bits used in the first four and last five rounds. And by taking advantage of the key scheduling algorithm, we finally map the guessed key bits to the consecutive 80-bit key at round 18. Impossible differential analysis will allow us to reduce the key space, and we brute force search the rest of the space to target the correct key candidate. We investigate round by round as follows.</p>

    <h4 id="sec-misc-4" class="text-lg font-semibold mt-6">Round 22.</h4>

    <p class="text-gray-300">There are  <span class="math">4 \\times 4</span>  bit conditions to satisfy at round 22. First let's check the condition  <span class="math">\\Delta R_{22,0} = 0</span> , which involves guessing  <span class="math">k_{22,[50\\sim53]}</span> , the remaining pairs is  <span class="math">2^{n+6.2-2.6} = 2^{n+3.6}</span>  since we have already filtered  <span class="math">2^{1.4}</span>  pairs in the data collection phase. We proceed in the similar way for other 4-bit conditions and we will not explain them again. The complexity is around  <span class="math">2 \\times 2^{12+4} \\times 2^{n+6.2} \\times \\frac{1}{8 \\times 23} \\approx 2^{n+15.68}</span>  23-round encryptions. Then we do key filtering by using key schedule algorithm. Guess  <span class="math">k_{22,[54\\sim57]}</span> , then by tracing back the key scheduling algorithm, we know  <span class="math">k_{8,[52\\sim57]}</span>  after shifting operation, and  <span class="math">k_{9,[52\\sim55]}</span> . Guess  <span class="math">k_{8,[51,58]}</span>  so that the 8-bit input to the two S-Boxes are known. Thus we have a 4-bit filtering condition from  <span class="math">k_{9,[52\\sim55]}</span> , which leaves  <span class="math">2^{12+4+2} \\times 2^{-4} = 2^{14}</span>  keys. Guess  <span class="math">k_{19,[59]}</span> , then we have 2-bit filtering condition between  <span class="math">k_{19}</span>  and  <span class="math">k_{20}</span> . Thus the number of remaining keys become  <span class="math">2^{14+1-2} = 2^{13}</span> .</p>

    <p class="text-gray-300">For the second 4-bit condition ( <span class="math">\\Delta R_{22,6} = 0</span> ), we need to guess  <span class="math">k_{22,[54\\sim57]}</span> , which is already known by computing backward from the known subkey bits. The remaining pairs becomes  <span class="math">2^{n+3.6-2.6} = 2^{n+1}</span> . It takes  <span class="math">2\\times2^{13}\\times2^{n+3.6}\\times\\frac{1}{8\\times23} = 2^{n+10.10}</span>  23 round encryptions.</p>

    <p class="text-gray-300">For the third 4-bit condition ( <span class="math">\\Delta R_{22,7}=0</span> ), we need to guess  <span class="math">k_{22,[62\\sim65]}</span> . The legal number of pairs decreases to  <span class="math">2^{n+1}\\times 2^{-2.6}=2^{n-1.6}</span> . It takes  <span class="math">2\\times 2^{13+4}\\times 2^{n+1}\\times \\frac{1}{8\\times 23}=2^{n+11.48}</span>  23 round encryptions.</p>

    <p class="text-gray-300">Before the fourth condition, we perform key filtering process. Guess  <span class="math">k_{22,[66\\sim69]}</span>  and  <span class="math">k_{6,[22]}</span> , by computing backwards, we find  <span class="math">k_{5,64}</span>  and  <span class="math">k_{2,[65\\sim67]}</span>  have already been guessed, which result in a 4-bit condition. Thus there remains  <span class="math">2^{17}\\times2^{5}\\times2^{-4}=2^{18}</span>  key candidates. Then proceed the fourth condition checking ( <span class="math">\\Delta R_{22,4}=0</span> ). There remains  <span class="math">2^{n-1.6-2.6}=2^{n-4.2}</span> , and it takes  <span class="math">2\\times2^{18}\\times2^{n-1.6}\\times\\frac{1}{8\\times23}=2^{n+9.88}</span>  23 round encryptions. After processing round 23, we can further reduce the key candidates. Guess  <span class="math">k_{17,[60,61]}</span> , we can compute  <span class="math">k_{16,[62]}</span>  and  <span class="math">k_{5,[58,59]}</span> , which are already known. Then the key candidates are reduced to  <span class="math">2^{18+2-3}=2^{17}</span> .</p>

    <h4 id="sec-misc-5" class="text-lg font-semibold mt-6">Round 21.</h4>

    <p class="text-gray-300">Round 21 has  <span class="math">4\\times 3-1.4\\times 2=9.2</span>  bits conditions to satisfy. For each of the conditions, we only list the key bits that are required to be guessed, while ignore the ones which are already known. For checking condition  <span class="math">\\Delta R_{21,6}=0</span> , we need to guess  <span class="math">k_{21,[79,0\\sim2]}</span> . The remaining pairs is  <span class="math">2^{n-4.2}\\times 2^{-2.6}=2^{n-6.8}</span> . It takes  <span class="math">2\\times 2^{17+4}\\times 2^{n-4.2}\\times \\frac{2}{8\\times 23}=2^{n+11.28}</span>  23 round encryptions.</p>

    <p class="text-gray-300">To check condition  <span class="math">\\Delta R_{21,1}=0</span> , we need to guess  <span class="math">k_{22,[70\\sim73]}, k_{21,[7\\sim10]}</span> . Notice that this condition is not pre-filtered at the data collection phase, so we have a 4-bit condition here. Thus there remains  <span class="math">2^{n-6.8}\\times 2^{-4}=2^{n-10.8}</span>  legal pairs. It takes  <span class="math">2\\times 2^{21+8}\\times 2^{n-6.8}\\times \\frac{2}{8\\times 23}=2^{n+16.68}</span>  23 round encryptions.</p>

    <p class="text-gray-300">For the last condition  <span class="math">\\Delta R_{21,7} = 0</span>  in round 21, we guess  <span class="math">k_{21,[78]}</span>  and  <span class="math">k_{21,[11\\sim 14]}</span> . The number of pairs get remained is  <span class="math">2^{n-10.8} \\times 2^{-2.6} = 2^{n-13.4}</span> . It takes  <span class="math">2 \\times 2^{29+5} \\times 2^{n-10.8} \\times \\frac{2}{8\\times 23} = 2^{n+17.68}</span>  23 round encryptions.</p>

    <h4 id="sec-misc-6" class="text-lg font-semibold mt-6">Round 1.</h4>

    <p class="text-gray-300">After processing Round 21, we go back to the first five rounds to proceed round 1. There are in total two 4-bit conditions in Round 1 and both of them have been pre-filtered and thus only  <span class="math">2\\times 2.6=5.2</span>  bit conditions remained. Let's guess  <span class="math">k_{0,[48\\sim50]}</span> ,  <span class="math">k_{1,[27\\sim30]}</span>  and  <span class="math">k_{0,[47]}</span> , then according to key scheduling</p>

    <p class="text-gray-300">algorithm, we can derive  <span class="math">k_{12,[50,51]}</span> , which are known already. So we first filter the key candidates to leave  <span class="math">2^{34+8-2}=2^{40}</span>  key candidates. Then we proceed checking condition  <span class="math">\\Delta R_{1,1}=0</span> . We have  <span class="math">2^{n-13.4}\\times 2^{-2.6}=2^{n-16}</span>  pairs remaining, and it takes  <span class="math">2\\times 2^{40}\\times 2^{n-13.4}\\times \\frac{2}{8\\times 23}=2^{n+21.10}</span>  23 round encryptions.</p>

    <p class="text-gray-300">To check the other condition  <span class="math">\\Delta R_{1,4} = 0</span> , we need to guess  <span class="math">k_{1,[35\\sim38]}</span> . Thus the remaining pairs become  <span class="math">2^{n-16} \\times 2^{-2.6} = 2^{n-18.6}</span> , and it takes  <span class="math">2 \\times 2^{40+4} \\times 2^{n-16} \\times \\frac{2}{8\\times23} = 2^{n+22.48}</span>  23 round encryptions.</p>

    <h2 id="sec-misc-7" class="text-2xl font-bold">Round 20 (Condition 1).</h2>

    <p class="text-gray-300">For round 20, there are two 4-bit conditions, and we choose to proceed only one  <span class="math">\\Delta R_{20,1}=0</span>  first and check the other one after proceeding round 2. By doing so, we can control the computational complexity in a mild way by taking advantage of the key scheduling algorithm. To check  <span class="math">\\Delta R_{20,1}=0</span> , we will have to guess 12-bit key  <span class="math">k_{20,[36\\sim39]},\\ k_{21,[19\\sim22]}</span>  and  <span class="math">k_{22,[74\\sim77]}</span> . After checking 2.6-bit filtering condition, there remains  <span class="math">2^{n-18.6}\\times 2^{-2.6}=2^{n-21.2}</span>  pairs. It takes  <span class="math">2\\times 2^{44+12}\\times 2^{n-18.6}\\times \\frac{3}{8\\times23}=2^{n+32.46}</span>  23 round encryptions.</p>

    <h4 id="sec-misc-8" class="text-lg font-semibold mt-6">Round 2.</h4>

    <p class="text-gray-300">Since the computational complexity is relatively high, by proceeding round 2, we wish to obtain more key bits information than what we actually guessed. First guess  <span class="math">k_{0,[77\\sim79]}</span>  and  <span class="math">k_{10,[0]}</span> , then we can derive  <span class="math">k_{11,[0,77,79]}</span>  which leaves  <span class="math">2^{56+4-3}=2^{57}</span>  key candidates. Guess  <span class="math">k_{1,[39\\sim42]}</span>  and  <span class="math">k_{14,[40]}</span> , we can derive  <span class="math">k_{15,[38,39]}</span>  (known), which leaves  <span class="math">2^{57+5-2}=2^{60}</span>  key candidates. Guess  <span class="math">k_{2,[6\\sim9]}</span> ,  <span class="math">k_{4,[10]}</span>  and  <span class="math">k_{15,[11]}</span> , derive  <span class="math">k_{16,[9\\sim11]}</span>  (known), which result in  <span class="math">2^{60+6-3}=2^{63}</span>  key candidates. Now we know all the subkey bits in order to check  <span class="math">\\Delta R_{2,4}=0</span> . There remains  <span class="math">2^{n-21.2}\\times 2^{-2.6}=2^{n-23.8}</span>  pairs, and it takes  <span class="math">2\\times 2^{63}\\times 2^{n-21.2}\\times \\frac{3}{8\\times23}=2^{n+36.86}</span>  23 round encryptions to test.</p>

    <h3 id="sec-misc-9" class="text-xl font-semibold mt-8">Round 20 (Condition 2).</h3>

    <p class="text-gray-300">Now let's check the second condition  <span class="math">\\Delta R_{20,7}=0</span>  of round 20. First guess  <span class="math">k_{20,[41\\sim43]}</span>  and  <span class="math">k_{15,[44]}</span> , then we derive  <span class="math">k_{3,[40\\sim42]}</span>  which are known. Key candidates becomes  <span class="math">2^{63+4-3}=2^{64}</span> . Then guess  <span class="math">k_{21,[27\\sim30]}</span>  and  <span class="math">k_{10,[26]}</span> , derive  <span class="math">k_{9,[27,28]}</span>  which are also known. There remains  <span class="math">2^{64+5-2}=2^{67}</span>  key candidates. To filter 2.6-bit condition, the remaining pairs become  <span class="math">2^{n-23.8}\\times 2^{-2.6}=2^{n-26.4}</span> . It takes  <span class="math">2\\times 2^{67}\\times 2^{n-23.8}\\times \\frac{3}{8\\times23}=2^{n+38.26}</span>  23 round encryptions to test.</p>

    <h4 id="sec-misc-10" class="text-lg font-semibold mt-6">Round 3.</h4>

    <p class="text-gray-300">Check the condition  <span class="math">\\Delta R_{3,4}=0</span>  in round 3 which is the last round before the IDC path. We need to guess 8-bit of  <span class="math">k_0</span> , 8-bit of  <span class="math">k_1</span> , 4-bit of  <span class="math">k_2</span>  and 4-bit of  <span class="math">k_3</span> . However, most of the subkey bits are already known, which remains only  <span class="math">k_{2,[11\\sim13]}</span>  to guess. Guess  <span class="math">k_{2,[11\\sim13]}</span>  along with  <span class="math">k_{4,[14]}</span> , then derive the already known bit  <span class="math">k_{5,[11]}</span> . Guess  <span class="math">k_{15,[15]}</span>  and derive the known bits  <span class="math">k_{16,[12\\sim14]}</span> . Then the number of key candidates becomes  <span class="math">2^{67+4+1-1-3}=2^{68}</span> . The remaining legal pairs become  <span class="math">2^{n-26.4}\\times 2^{-2.6}=2^{n-29}</span> , and it takes  <span class="math">2\\times 2^{68}\\times 2^{n-26.4}\\times \\frac{4}{8\\times 23}=2^{n+37.08}</span>  23 round encryptions to test.</p>

    <p class="text-gray-300"><strong>Round 19.</strong> One 4-bit condition  <span class="math">\\Delta R_{19,0}=0</span>  in round 19 requires to guess only  <span class="math">k_{20,[31]}</span>  while other bits are known at present. Notice that the condition has not been pre-filtered, thus there remains  <span class="math">2^{n-29}\\times 2^{-4}=2^{n-33}</span>  pairs. The computational complexity is  <span class="math">2\\times 2^{69}\\times 2^{n-29}\\times \\frac{4}{8\\times 23}=2^{n+35.48}</span>  23 round encryptions.</p>

    <h4 id="sec-misc-11" class="text-lg font-semibold mt-6">Round 18.</h4>

    <p class="text-gray-300">If the guessed key passed the 4-bit condition in round 18, it must be a wrong key and can be discarded from the key candidate list. Guess  <span class="math">k_{21,[23\\sim26]}</span>  which are the only bits needed for checking condition  <span class="math">\\Delta R_{18,7}=0</span> . We can derive  <span class="math">k_{20,[26]}</span>  which is known. Thus up to now, we have guessed in total  <span class="math">2^{69+4-1}=2^{72}</span>  subkey bits which exists in different rounds. We want to target the 80-bit master key  <span class="math">K_{18}</span>  at round 18. However, at present we only know 63-bit of  <span class="math">K_{18}</span> , which is not yet enough. Before filtering the 72-bit subkey, let's merge the key bits first. Guess  <span class="math">K_{18,[32\\sim35]}</span> , then we can derive  <span class="math">k_{17,[37]}</span>  and  <span class="math">k_{6,[29,30,35,36]}</span> , which are known. Now the guessed number of key candidates become  <span class="math">2^{72+4-5}=2^{71}</span> . Further guess  <span class="math">K_{19,[3\\sim6]}</span> , derive  <span class="math">k_{18,[8]}</span>  and  <span class="math">k_{7,[6,7]}</span>  which are known and the guessed key candidates finally shrink down to  <span class="math">2^{71+4-3}=2^{72}</span> , and we have known 74-bit of  <span class="math">K_{18}</span> . Finally we can check the last condition to filter these  <span class="math">2^{72}</span>  key candidates. There remains  <span class="math">2^{72}\\times(1-2^{-4})^{2^{n-33}}</span>  keys. For each of the remaining keys, we brute force search the remaining 6-bit of  <span class="math">K_{18}</span> . Thus the complexity of this step can be computed as  <span class="math">2\\times2^{72}\\times(1+(1-2^{-4})+\\cdots+(1-2^{-4})^{2^{n-33}-1})\\times\\frac{6}{8\\times23}+2^{72}\\times(1-2^{-4})^{2^{n-33}}\\times2^6</span> .</p>

    <h3 id="sec-misc-12" class="text-xl font-semibold mt-8">Complexity.</h3>

    <p class="text-gray-300">Since we put the number of structures (data complexity) in the computational complexity as a variable, we can always take the balance between the data complexity and computational complexity. For example let's take n=37, then the data complexity will be  <span class="math">2^{57}</span>  which is less than the whole code block. Computational complexity is computed by adding all the cost in each of the steps. As a result, we get  <span class="math">2^{37+15.68}+2^{37+10.10}+2^{37+11.48}+2^{37+9.88}+2^{37+11.28}+2^{37+16.68}+2^{37+21.10}+2^{37+22.48}+2^{37+32.46}+2^{37+36.86}+2^{37+38.26}+2^{37+35.48}+2^{71.37}+2^{76.51}\\approx 2^{77.4}</span>  23 rounds encryptions.</p>

    </section>

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">5 Conclusion</h2>

    <p class="text-gray-300">In this paper, we investigate the impossible differential attack by considering the key scheduling algorithm. Previous works usually treat the subkey used in the first and last rounds to be independent ones. But in fact the subkey bits are not independent and are generated by key scheduling algorithm. It is rather easy to observe the relation when the key scheduling algorithm just simply reuses the master key bits such as XTEA, etc, however, we point out that even the key scheduling algorithm involves non-linear operations such as S-Box, we can still exploit the relation which can be used to reduce the time complexity to improve the number of rounds we can attack. As an application, we investigate LBlock and achieve attacking 23 rounds in single key model without using the whole code block, which is the best single key attack so far.</p>

    </section>

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Eli Biham, Alex Biryukov, and Adi Shamir. Cryptanalysis of skipjack reduced to 31 rounds using impossible differentials. In Jacques Stern, editor,  <span class="math">Advances\\ in</span></li>
    </ul>

    <ul class="space-y-2 text-gray-400 text-sm list-none">
      <li><p class="text-gray-300">Cryptology EUROCRYPT 99, volume 1592 of Lecture Notes in Computer Science, pages 12&ndash;23. Springer Berlin Heidelberg, 1999.</p></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Eli Biham and Adi Shamir. Differential cryptanalysis of des-like cryptosystems. In AlfredJ. Menezes and ScottA. Vanstone, editors, Advances in Cryptology-CRYPT0 90, volume 537 of Lecture Notes in Computer Science, pages 2&ndash;21. Springer Berlin Heidelberg, 1991.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Cline Blondeau, Benot Grard, and Kaisa Nyberg. Multiple differential cryptanalysis using llr and 2 statistics. In Ivan Visconti and Roberto Prisco, editors, Security and Cryptography for Networks, volume 7485 of Lecture Notes in Computer Science, pages 343&ndash;360. Springer Berlin Heidelberg, 2012.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>A. Bogdanov, L.R. Knudsen, G. Leander, C. Paar, A. Poschmann, M.J.B. Robshaw, Y. Seurin, and C. Vikkelsoe. Present: An ultra-lightweight block cipher. In Pascal Paillier and Ingrid Verbauwhede, editors, Cryptographic Hardware and Embedded Systems - CHES 2007, volume 4727 of Lecture Notes in Computer Science, pages 450&ndash;466. Springer Berlin Heidelberg, 2007.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Andrey Bogdanov and Christian Rechberger. A 3-subset meet-in-the-middle attack: Cryptanalysis of the lightweight block cipher ktantan. In Alex Biryukov, Guang Gong, and DouglasR. Stinson, editors, Selected Areas in Cryptography, volume 6544 of Lecture Notes in Computer Science, pages 229&ndash;240. Springer Berlin Heidelberg, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Christophe Cannire, Orr Dunkelman, and Miroslav Kneevi. Katan and ktantan a family of small and efficient hardware-oriented block ciphers. In Christophe Clavier and Kris Gaj, editors, Cryptographic Hardware and Embedded Systems - CHES 2009, volume 5747 of Lecture Notes in Computer Science, pages 272&ndash;288. Springer Berlin Heidelberg, 2009.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Jiageng Chen and Atsuko Miyaji. Differential cryptanalysis and boomerang cryptanalysis of lblock. In Alfredo Cuzzocrea, Christian Kittl, DimitrisE. Simos, Edgar Weippl, and Lida Xu, editors, Security Engineering and Intelligence Informatics, volume 8128 of Lecture Notes in Computer Science, pages 1&ndash;15. Springer Berlin Heidelberg, 2013.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Jiazhe Chen, Keting Jia, Hongbo Yu, and Xiaoyun Wang. New impossible differential attacks of reduced-round camellia-192 and camellia-256. In Udaya Parampalli and Philip Hawkes, editors, Information Security and Privacy, volume 6812 of Lecture Notes in Computer Science, pages 16&ndash;33. Springer Berlin Heidelberg, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Jian Guo, Thomas Peyrin, Axel Poschmann, and Matt Robshaw. The led block cipher. In Bart Preneel and Tsuyoshi Takagi, editors, Cryptographic Hardware and Embedded Systems CHES 2011, volume 6917 of Lecture Notes in Computer Science, pages 326&ndash;341. Springer Berlin Heidelberg, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ferhat Karako, Hseyin Demirci, and A.Emre Harmanc. Impossible differential cryptanalysis of reduced-round lblock. In Ioannis Askoxylakis, HenrichC. Phls, and Joachim Posegga, editors, Information Security Theory and Practice. Security, Privacy and Trust in Computing Systems and Ambient Intelligent Ecosystems, volume 7322 of Lecture Notes in Computer Science, pages 179&ndash;188. Springer Berlin Heidelberg, 2012.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Jongsung Kim, Seokhie Hong, Jaechul Sung, Sangjin Lee, Jongin Lim, and Soohak Sung. Impossible differential cryptanalysis for block cipher structures. In Thomas Johansson and Subhamoy Maitra, editors, Progress in Cryptology - INDOCRYPT 2003, volume 2904 of Lecture Notes in Computer Science, pages 82&ndash;96. Springer Berlin Heidelberg, 2003.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Lars Knudsen, Gregor Leander, Axel Poschmann, and MatthewJ.B. Robshaw. Printcipher: A block cipher for ic-printing. In Stefan Mangard and Franois-Xavier Standaert, editors, Cryptographic Hardware and Embedded Systems, CHES 2010, volume 6225 of Lecture Notes in Computer Science, pages 16&ndash;32. Springer Berlin Heidelberg, 2010.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Lars Knudsen and David Wagner. Integral cryptanalysis. In Joan Daemen and Vincent Rijmen, editors, Fast Software Encryption, volume 2365 of Lecture Notes in Computer Science, pages 112&ndash;127. Springer Berlin Heidelberg, 2002.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Ya Liu, Dawu Gu, Zhiqiang Liu, and Wei Li. Impossible differential attacks on reduced-round lblock. In MarkD. Ryan, Ben Smyth, and Guilin Wang, editors, Information Security Practice and Experience, volume 7232 of Lecture Notes in Computer Science, pages 97&ndash;108. Springer Berlin Heidelberg, 2012.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Minier. Marine and Maria Naya-Plasencia. Some preliminary studies on the differential behavior of te lightweight block cipher LBlock. In ECRYPT Workshop on Lightweight Cryptography, pages 35&ndash;48, 2011.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Mitsuru Matsui. Linear cryptanalysis method for des cipher. In Tor Helleseth, editor, Advances in Cryptology EUROCRYPT 93, volume 765 of Lecture Notes in Computer Science, pages 386&ndash;397. Springer Berlin Heidelberg, 1994.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Marine Minier and Maria Naya-Plasencia. A related key impossible differential attack against 22 rounds of the lightweight block cipher lblock. volume 112, pages 624&ndash;629, Amsterdam, The Netherlands, The Netherlands, August 2012. Elsevier North-Holland, Inc.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Yu Sasaki and Lei Wang. Comprehensive study of integral analysis on 22-round lblock. In Taekyoung Kwon, Mun-Kyu Lee, and Daesung Kwon, editors, Information Security and Cryptology ICISC 2012, volume 7839 of Lecture Notes in Computer Science, pages 156&ndash;169. Springer Berlin Heidelberg, 2013.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Yu Sasaki and Lei Wang. Meet-in-the-middle technique for integral attacks against feistel ciphers. In LarsR. Knudsen and Huapeng Wu, editors, Selected Areas in Cryptography, volume 7707 of Lecture Notes in Computer Science, pages 234&ndash;251. Springer Berlin Heidelberg, 2013.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Hadi Soleimany and Kaisa Nyberg. Zero-correlation linear cryptanalysis of reduced-round lblock. volume 2012, page 570, 2012.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Tomoyasu Suzaki, Kazuhiko Minematsu, Sumio Morioka, and Eita Kobayashi. twine: A lightweight block cipher for multiple platforms. In LarsR. Knudsen and Huapeng Wu, editors, Selected Areas in Cryptography, volume 7707 of Lecture Notes in Computer Science, pages 339&ndash;354. Springer Berlin Heidelberg, 2013.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Yukiyasu Tsunoo, Etsuko Tsujihara, Maki Shigeri, Teruo Saito, Tomoyasu Suzaki, and Hiroyasu Kubo. Impossible differential cryptanalysis of clefia. In Kaisa Nyberg, editor, Fast Software Encryption, volume 5086 of Lecture Notes in Computer Science, pages 398&ndash;411. Springer Berlin Heidelberg, 2008.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>David Wagner. The boomerang attack. In Lars Knudsen, editor, Fast Software Encryption, volume 1636 of Lecture Notes in Computer Science, pages 156&ndash;170. Springer Berlin Heidelberg, 1999.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Long Wen, Mei-Qin Wang, and Jing-Yuan Zhao. Related-key impossible differential attack on reduced-round lblock. Journal of Computer Science and Technology, 29(1):165&ndash;176, 2014.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>David J Wheeler and Roger M Needham. Tea, a tiny encryption algorithm. In Fast Software Encryption, pages 363&ndash;366. Springer, 1995.</li>
    </ul></li>
      <li><ul class="space-y-2 text-gray-400 text-sm list-none">
      <li>Wenling Wu and Lei Zhang. Lblock: A lightweight block cipher. In Javier Lopez and Gene Tsudik, editors, Applied Cryptography and Network Security, volume</li>
    </ul></li>
    </ul>

    <p class="text-gray-300">6715 of Lecture Notes in Computer Science, pages 327&ndash;344. Springer Berlin Heidelberg, 2011.</p>

    </section>
`;
---

<BaseLayout title="Impossible differential cryptanalysis of LBlock with concret... (2014/272)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/272
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <nav id="toc" class="mb-10 p-6 rounded-lg" style="background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li><a href="#sec-1" class="hover:text-white">Introduction</a></li>
        <li>
          <a href="#sec-2" class="hover:text-white">Impossible differential attack considering key scheduling algorithm</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li><a href="#sec-2.1" class="hover:text-white">Impossible differential attack</a></li>
            <li><a href="#sec-2.2" class="hover:text-white">Our improvement by investigating key scheduling algorithm</a></li>
            <li><a href="#sec-3.2" class="hover:text-white">LBlock</a></li>
          </ol>
        </li>
        <li><a href="#sec-4" class="hover:text-white">Impossible differential attack on 23 rounds of LBlock</a></li>
        <li><a href="#sec-5" class="hover:text-white">Conclusion</a></li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400
        list-disc list-inside">
        <li><a href="#references" class="hover:text-white">References</a></li>
      </ul>
    </nav>


    <Fragment set:html={CONTENT} />

    <PaperHistory slug="impossible-differential-cryptanalysis-of-lblock-with-2014" />
  </article>
</BaseLayout>
