---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1239';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Authenticated Dictionaries with Cross-Incremental Proof (Dis)aggregation';
const AUTHORS_HTML = 'Alin Tomescu, Yu Xia, Zachary Newman';

const CONTENT = `    <p class="text-gray-300">Alin Tomescu^{1} Yu Xia^{2} Zachary Newman^{2} ^{1}VMware Research ^{2}MIT CSAIL Wednesday, October 7th, 2020</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Authenticated dictionaries (ADs) are a key building block of many cryptographic systems, such as transparency logs, distributed file systems and cryptocurrencies. In this paper, we propose a new notion of cross-incremental proof (dis)aggregation for authenticated dictionaries, which enables aggregating multiple proofs with respect to different dictionaries into a single, succinct proof. Importantly, this aggregation can be done incrementally and can be later reversed via disaggregation. We give an efficient authenticated dictionary construction from hidden-order groups that achieves cross-incremental (dis)aggregation. Our construction also supports updating digests, updating (cross-)aggregated proofs and precomputing all proofs efficiently. This makes it ideal for stateless validation in cryptocurrencies with smart contracts. As an additional contribution, we give a second authenticated dictionary construction, which can be used in more malicious settings where dictionary digests are adversarially-generated, but features only “one-hop” proof aggregation (with respect to the same digest). We add support for append-only proofs to this construction, which gives us an append-only authenticated dictionary (AAD) that can be used for transparency logs and, unlike previous AAD constructions, supports updating and aggregating proofs.</p>

    <p class="text-gray-300">2</p>

    <p class="text-gray-300">1  Introduction  3 1.1  Related Work  3</p>

    <p class="text-gray-300">2  Preliminaries  5 2.1  Algorithms  5 2.2  Proofs of Knowledge of Co-prime Roots (PoKCR)  6 2.3  Proofs of Knowledge of Exponent (PoKE)  6 2.4  RSA Accumulators  6 2.4.1  Membership and subset witnesses  7 2.4.2  Non-membership and disjointness witnesses  7 2.5  Incrementally Aggregatable Vector Commitments from RSA  7</p>

    <p class="text-gray-300">3  Enhancements to RSA Accumulators  9 3.1  Faster Witness Extraction in PoKCR  9 3.2  Computing All Non-membership Witnesses Across Different, Related Accumulators  10 3.3  Aggregating Non-membership Witnesses Across Different, Related Accumulators  11</p>

    <p class="text-gray-300">4  Authenticated Dictionaries from Hidden-Order Groups  11 4.1  Definitions  11 4.2  Updatable Authenticated Dictionary for Stateless Validation  13 4.3  Append-only Authenticated Dictionary for Transparency Logs  15</p>

    <p class="text-gray-300">5  Future Work  17</p>

    <p class="text-gray-300">A  Updating RSA Non-membership Witnesses  20</p>

    <p class="text-gray-300">B  Security Proofs  20 B.1  Definitions and Cryptographic Assumptions  20 B.2  Warm-up: Key Binding for Individual Proofs  21 B.2.1  Case 1:  <span class="math">v \\neq \\bot</span>  and  <span class="math">v&#x27; \\neq \\bot</span>  21 B.2.2  Case 2:  <span class="math">v = \\bot</span>  or  <span class="math">v&#x27; = \\bot</span>  22 B.2.3  Weak Key Binding for Individual UAD Proofs  22 B.3  Key Binding for Aggregated Proofs  22 B.3.1  Case 1:  <span class="math">v_{z} \\neq \\bot</span>  and  <span class="math">v_{z}&#x27; \\neq \\bot</span>  22 B.3.2  Case 2:  <span class="math">v_{z} = \\bot</span>  or  <span class="math">v_{z}&#x27; = \\bot</span>  23 B.3.3  Weak Key Binding for Aggregated UAD Proofs  23 B.4  Warm-up: Append-only Security w.r.t. Individual Proofs  23 B.5  Append-only Security for Aggregated Proofs  24</p>

    <p class="text-gray-300">1 Introduction</p>

    <p class="text-gray-300">An <em>authenticated dictionary (AD)</em> scheme securely outsources storage of a set of <em>keys-value pairs</em> to an <em>untrusted prover</em>. In this setting, the prover can convince any <em>verifier</em>, who has a succinct <em>digest</em> of the dictionary, that a key has a particular value in the outsourced dictionary by sending him a <em>lookup proof</em> for that key. Authenticated dictionaries are a fundamental building block of numerous applications, including authenticated file systems <em>[15]</em>, privacy-preserving web applications <em>[9, 11]</em>, cryptocurrencies <em>[30]</em>, stateless validation in cryptocurrencies <em>[6, 14]</em> and transparency logs <em>[7, 17, 23, 29]</em>. In this paper, we enhance authenticated dictionaries in two ways.</p>

    <p class="text-gray-300">ADs for Stateless Validation. In Section 4.2, we propose a new <em>updatable authenticated dictionary (UAD)</em> which supports a new notion of <em>cross-incremental proof (dis)aggregation</em>. Specifically, our UAD supports aggregating many lookup proofs, even if those proofs are with respect to different dictionaries with different digests. Importantly, such a <em>cross-aggregated proof</em> can also be disaggregated to recover the original lookup proofs. Cross-incremental aggregation generalizes previous notions of <em>incremental aggregation</em> of proofs with respect to the same digest <em>[4]</em> and <em>one-hop, cross-commitment aggregation</em> of proofs with respect to different digests <em>[10]</em>. Furthermore, our UAD offers efficiently updatable proofs and digests as well as efficient proof pre-computation. We prove our UAD satisfies <em>weak key binding</em> (see Definition B.2), which assumes digests are honestly generated.</p>

    <p class="text-gray-300">Our UAD can be used for stateless, smart contract-based cryptocurrencies. In such systems, the memory of each smart contract is just a dictionary that maps memory locations from <span class="math">\\{0,1\\}^{256}</span> to their value, and can thus be authenticated using our UAD. Because previous work cannot authenticate dictionaries with large key space, it restricts the smart contract memory to be much smaller (<span class="math">\\{0,1\\}^{10}</span>) and authenticates it using a vector <em>[10]</em>. Our work naturally overcomes this limitation. Furthermore, using cross-incremental aggregation, miners can now <em>incrementally</em> build a block’s cross-aggregated proof as proofs for different smart contract executions arrive. This makes block proposal faster, as miners do not have to wait for all proofs before starting to aggregate. It also opens up opportunities for aggregating proofs inside the P2P network of the cryptocurrency, reducing communication in the network.</p>

    <p class="text-gray-300">Beyond Stateless Validation. In Section 4.3, we modify our UAD to have stronger security so it can be used in more malicious settings. Specifically, our new construction satisfies <em>strong key binding</em> (see Definition 4.3), which means security holds even when digests are maliciously constructed by the adversary. This is the case in many applications, such as transparency logs, authenticated file systems and privacy-preserving web applications. For the transparency log setting, we show our construction supports efficient <em>append-only proofs</em> <em>[29]</em> that one dictionary is a subset of another. Furthermore, we add support for <em>non-membership proofs</em> of keys that are <em>not</em> in the dictionary. As a result, we obtain an <em>append-only authenticated dictionary (AAD)</em> which, unlike previous schemes <em>[27, 29]</em>, supports updating proofs and <em>one-hop proof aggregation</em>.</p>

    <p class="text-gray-300">New Techniques for RSA Accumulators. As a building block for our AAD, we develop techniques for computing and aggregating <em>RSA non-membership witnesses</em> across different-but-related <em>RSA accumulators</em> <em>[2]</em>. We also develop a faster algorithm for witness extraction in Boneh et al.’s <em>proof-of-knowledge of co-prime roots (PoKCR)</em> protocol (see Section 2.2). We believe these techniques could be of independent interest.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <p class="text-gray-300">We survey recent work that builds authenticated dictionaries from group-theoretic assumptions, rather than traditional Merkle-based techniques, which are inherently expensive to aggregate.</p>

    <p class="text-gray-300">Streaming Authenticated Data Structure (SADS). Papamanthou et al. <em>[20]</em> present an elegant lattice-based construction that generalized Merkle trees using an algebraic hash function. However, their construction does not support aggregating proofs nor append-only proofs, making it ill-suited both for stateless validation and transparency logs.</p>

    <p class="text-gray-300">Authenticated Hash Tables (AHTs). Papamanthou et al. <em>[21]</em> build <em>authenticated hash tables (AHTs)</em> from both bilinear accumulators <em>[18]</em> and RSA accumulators <em>[2]</em>. Their tree-based approach uses an accumulator rather than a normal collision-resistant hash function for authentication. However, their construction assumes digests are generated honestly and is thus only secure under weak key binding. Also, they do not support proof updates, proof aggregation, nor append-only proofs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">AD scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Aggrega-table π's?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Binding</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Updatability?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Update hint-free?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Non-memb. π's?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Append-only π's?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Prove all fast?</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Merkle tree</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">Strong</td>

            <td class="px-3 py-2 border-b border-gray-700">I</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SADS [20]</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">Strong</td>

            <td class="px-3 py-2 border-b border-gray-700">DI</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AHTs [21]</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n/a</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KVC1 [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Strong</td>

            <td class="px-3 py-2 border-b border-gray-700">DI</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KVC2 [3]</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak</td>

            <td class="px-3 py-2 border-b border-gray-700">DI</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">AAD [27]</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">Strong</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">n/a</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Aardvark [14]</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak</td>

            <td class="px-3 py-2 border-b border-gray-700">DI</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KVaC [1]</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak</td>

            <td class="px-3 py-2 border-b border-gray-700">DI</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our UAD</td>

            <td class="px-3 py-2 border-b border-gray-700">Cross-incr.</td>

            <td class="px-3 py-2 border-b border-gray-700">Weak</td>

            <td class="px-3 py-2 border-b border-gray-700">ADIX</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓*</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Our AAD</td>

            <td class="px-3 py-2 border-b border-gray-700">One-hop</td>

            <td class="px-3 py-2 border-b border-gray-700">Strong</td>

            <td class="px-3 py-2 border-b border-gray-700">aDI</td>

            <td class="px-3 py-2 border-b border-gray-700">×</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">*Our UAD supports non-membership proofs, but they can only be "one-hop" aggregated.</p>

    <p class="text-gray-300">Table 1: Comparison of our AD with other ADs based on lattices, pairing-friendly or hidden-order groups. In "Updatability", we indicate updatability of: individual lookup proofs  <span class="math">(I)</span> , aggregated lookup proofs  <span class="math">(A)</span> , aggregated lookup proofs, but only after changes to existing keys  <span class="math">(a)</span> , cross-aggregated lookup proofs  <span class="math">(X)</span>  and digests  <span class="math">(D)</span> .</p>

    <p class="text-gray-300">Key-Value Commitments (KVC). Boneh et al. [3] briefly describe two AD constructions from their RSA-based vector commitment scheme. Their first construction, which we dub  <span class="math">\\mathrm{KVC}_1</span> , satisfies strong key binding (see Definition 4.3) while their second construction,  <span class="math">\\mathrm{KVC}_2</span> , relaxes security to weak key binding for efficiency gains. Unlike our UAD construction, they do not support incremental (dis)aggregation, nor cross-aggregation of proofs. Also, they cannot update aggregated proofs and do not support append-only proofs.</p>

    <p class="text-gray-300">AADs. Tomescu et al. [29] give an append-only authenticated dictionary (AAD) construction from bilinear accumulators [18]. Later on, Tomescu [27] generalizes this construction to RSA accumulators. Both constructions support append-only proofs and non-membership proofs and can be used, in theory, for transparency logs. They also use an amortization technique [19] to precompute all lookup proof and all append-only proofs in quasilinear time and support appending to the dictionary in amortized polylogarithmic time. Importantly, their AAD supports pre-computing all non-membership proofs. Unfortunately, neither construction supports proof aggregation, nor proof updates (individual or aggregated). Also, their RSA-based AAD requires  <span class="math">O(\\lambda)</span>  more exponentiations per key-value pair added to the dictionary than ours.</p>

    <p class="text-gray-300">Aardvark. Leung et al. [14] propose Aardvark, an authenticated dictionary built on top of the cross-aggregatable VC by Gorbunov et al [10]. Aardvark supports one-hop aggregation of proofs and relies on pairing-friendly groups. As a result, Aardvark is fast in practice and has aggregated proof sizes of only 48 bytes. In contrast, our UAD's aggregated proof, consisting of two hidden-order group elements, is at least 512 bytes. However, Aardvark has a few drawbacks. First, the digest's size is non-constant:  <span class="math">n / B</span>  group elements, where  <span class="math">B</span>  is a construction-specific bucket size and  <span class="math">n</span>  is the dictionary size. Second, Aardvark is only secure under weak key binding, by assuming dictionary digests are generated honestly. Third, although an Aardvark dictionary proof is built by cross-aggregating VC proofs, Aardvark does not explore further cross-aggregating their dictionary proofs themselves. Even if cross-aggregation were possible in Aardvark, it would not be incremental and it would not support proof disaggregation. Last, Aardvark does not support fast pre-computation of proofs.</p>

    <p class="text-gray-300">KVaC. Agrawal and Raghumaran also introduced an authenticated dictionary from the RSA assumption, which they dub KVaC. Their elegant construction also builds on top of [4,5,13] and has the advantage of not requiring any auxiliary information (i.e., update hints) for updating proofs and digests. Furthermore, KVaC also supports one-hop proof aggregation. This makes KVaC very useful for stateless validation. However, their construction has a few drawbacks. First, they do not support incremental (dis)aggregation nor cross-commitment aggregation, which helps with smart contract based validation [10]. Second, they do not discuss updating aggregated proofs, which helps with stateless validation in the smart contract setting. Third, they do not explore fast proof pre-computation, which is a necessary ingredient for proof-serving nodes in stateless cryptocurrencies [6, 28]. Fourth, their construction only satisfies weak key binding (see Definition B.2), which is sufficient in the stateless cryptocurrency setting, but not in other settings, such as transparency logs. Fifth, their construction does not support non-membership proofs for keys that were never inserted in the dictionary, which is also necessary for transparency logs. We believe it would</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 1: We frequently rely on these algorithms, where  <span class="math">\\pmb{x} = [x_{1},\\dots,x_{n}], n = 2^{k}, x^{*} = \\prod_{i\\in [n]}x_{i}</span>  and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= O(\\ell)$  bits.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">be interesting to see to what extent our techniques can enhance KVaCs and vice-versa.</p>

    <p class="text-gray-300">Notation. Let  <span class="math">\\lambda</span>  denote our security parameter. Let  <span class="math">\\ell</span>  denote the length (in bits) of vector elements and of dictionary values. Let  <span class="math">\\mathbb{G}_?</span>  denote a hidden-order group and  <span class="math">g</span>  be a random group element in  <span class="math">\\mathbb{G}_?</span> . Let  <span class="math">H: \\{0,1\\}^* \\to \\mathrm{Primes}_{\\ell+1}</span>  be a collision-resistant hash function that outputs  <span class="math">(\\ell+1)</span> -bit primes. We typically use bolded variables  <span class="math">\\pmb{x}</span>  to denote vectors  <span class="math">[x_1, x_2, \\ldots, x_n]</span>  of elements. We also use  <span class="math">\\pmb{x}_I = (x_i)_{i \\in I}</span>  to denote an  <span class="math">I</span> -subvector of  <span class="math">\\pmb{x}</span>  with only the values at indices in  <span class="math">I</span> .</p>

    <p class="text-gray-300">Our work makes frequent use of the following algorithms.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Extended Euclidean Algorithm (EEA). Given two integers  <span class="math">x, y</span>  such that  <span class="math">\\gcd(x, y) = 1</span> ,  <span class="math">(a, b) \\gets \\mathsf{EEA}(x, y)</span>  returns Bézout coefficients  <span class="math">(a, b)</span>  such that  <span class="math">ax + by = 1</span>  in  <span class="math">O(m \\log^2 m \\log \\log m)</span>  bit operations [25], where  $m = \\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math"> . Importantly, the returned coefficients satisfy  </span>a \\leq y<span class="math">  and  </span>b \\leq x$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Shamir's trick. For any  <span class="math">g \\in \\mathbb{G}_?</span> , given integers  <span class="math">x, y</span>  and  <span class="math">g^{\\frac{1}{x}}, g^{\\frac{1}{y}}</span> , this classic algorithm by Shamir [26] efficiently computes  <span class="math">g^{\\frac{1}{xx}}</span>  as  <span class="math">\\left(g^{1/x}\\right)^b \\left(g^{1/y}\\right)^a</span>  where  <span class="math">a, b</span>  are Bézout coefficients such that  <span class="math">ax + by = 1</span> . If  $\\ell = \\max \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">y</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> , the cost is dominated by  </span>O(\\ell)<span class="math">  group operations. Shamir&#x27;s trick can be extended to  </span>n &gt; 2<span class="math">  inputs  </span>\\{x_i, g^{1/x_i}\\}_{i \\in [n]}<span class="math">  by building a binary computation tree whose leaves are the individual  </span>(x_i, g^{1/x_i})<span class="math"> &#x27;s (see Fig. 1). Next, if a node&#x27;s left and right children store  </span>(x_L, g^{1/x_L})<span class="math">  and  </span>(x_R, g^{1/x_R})<span class="math"> , respectively, then that node computes and stores  </span>(x_L \\cdot x_R, g^{\\frac{1}{x_L x_R}})<span class="math"> . This way, the root will compute the desired  </span>\\left( \\prod_{i \\in [n]} x_i, g^{\\frac{1}{\\prod_{i \\in [n]} x_i}} \\right)<span class="math"> . Shamir&#x27;s (recursive) trick on  </span>n<span class="math">  inputs takes  </span>T(n) = 2T(n/2) + O(\\ell n) = O(\\ell n \\log n)$  group operations which, in practice, dominate the cost of EEAs and integer multiplications.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">RootFactor. Given  <span class="math">g \\in \\mathbb{G}_?</span>  and integers  <span class="math">x = [x_1, \\ldots, x_n]</span> , outputs  <span class="math">g^{x^<em> / x_i}</span>  for all  <span class="math">x_i</span> , where  <span class="math">x^</em> = \\prod_{i \\in [n]} x_i</span> . This algorithm takes  <span class="math">O(\\ell n \\log n)</span>  group operations, where  $\\ell = \\max_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_i</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , and was introduced by Sander et al [24].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MultiRootExp. Given group elements  <span class="math">\\alpha = [\\alpha_{1},\\ldots ,\\alpha_{n}]</span>  and integers  <span class="math">\\pmb {x} = [x_{1},\\dots,x_{n}]</span> , outputs  <span class="math">y = \\prod_{i\\in [n]}\\alpha_i^{x^<em> /x_i}</span>  where  <span class="math">x^{</em>} = \\prod_{i\\in [n]}x_{i}</span> . This algorithm takes in  <span class="math">O(\\ell n\\log n)</span>  group operations, where  $\\ell = \\max_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x_{i}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , and was introduced by Boneh et al. [3] (but under the name MultiExp).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The PoKCR protocol by Boneh et al. [3] proves knowledge of  <span class="math">w_{i}</span> 's such that  <span class="math">w_{i}^{x_{i}} = \\alpha_{i}</span>  to a verifier that has the  <span class="math">\\alpha_{i}</span> 's and  <span class="math">x_{i}</span> 's. In other words, the protocol proves the following relation holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {R} _ {\\mathrm {P o K C R}} = \\left\\{\\left[ \\alpha_ {1}, \\dots , \\alpha_ {n} \\right] \\in \\mathbb {G} _ {?} ^ {n}, \\left[ x _ {1}, \\dots , x _ {n} \\right] \\in \\mathbb {G} _ {?} ^ {n}: w _ {i} ^ {x _ {i}} = \\alpha_ {i}, \\forall i \\in [ n ] \\right\\} \\tag {1}</span></div>

    <p class="text-gray-300">To prove the relation holds, PoKCR.  <span class="math">\\mathsf{Prove}(\\pmb {\\alpha},\\pmb {x},\\pmb {w})</span>  simply returns  <span class="math">W = \\prod_{i\\in [n]}w_{i}</span>  . To verify, PoKCR.  <span class="math">\\mathsf{Ver}(\\pmb {\\alpha},\\pmb {x},W)</span>  first computes  <span class="math">x^{<em>} = \\prod_{i\\in [n]}x_{i}</span>  and then checks if  <span class="math">W^{x^{</em>}}\\stackrel {?}{=}\\mathsf{MultiRootExp}(\\pmb {\\alpha},\\pmb {x}) = \\prod_{i\\in [n]}\\alpha_{i}^{x^{*} / x_{i}}</span></p>

    <p class="text-gray-300">Knowledge soundness. Boneh et al. [3] argue the PoKCR protocol is a proof of knowledge by showing the verifier can extract any  <span class="math">w_{i}</span> 's given a  <span class="math">W</span> ,  <span class="math">x</span>  and  <span class="math">\\alpha</span>  as follows. Let  <span class="math">z_{i} = x^{<em>} / x_{i}</span>  and  <span class="math">z_{i,j} = x^{</em>} / (x_{i}x_{j})</span> . Since  <span class="math">W</span>  is valid,  <span class="math">W^{x<em>} = \\prod_{i\\in [n]}\\alpha_{i}^{z_{i}}</span> . This means  <span class="math">W^{x^{</em>}} = (\\prod_{j\\in [n]\\setminus \\{i\\}}\\alpha_{j}^{z_{j}})\\alpha_{i}^{z_{i}} = (\\prod_{j\\in [n]\\setminus \\{i\\}}\\alpha_{j}^{z_{i,j}})^{x_{i}}\\alpha_{i}^{z_{i}}\\stackrel {\\mathrm{def}}{=}A_{j}^{x_{i}}\\alpha_{i}^{z_{i}}</span> . Also note that  <span class="math">W^{z_i} = (W^{x^<em>)1 / x_i} = (A_j^{x_i}\\alpha_i^{z_i})^{1 / x_i} = A_j(\\alpha_i^{z_i})^{1 / x_i}</span> . Thus, we can let  <span class="math">u = W^{z_i} / A_j = (\\alpha_i^{z_i})^{1 / x_i} = (\\alpha_i^{1 / x_i})^{z_i}</span> . Next, note that a ShamirTrick(  <span class="math">u,\\alpha_i,x_i,z_i</span>  ) on  <span class="math">u = (\\alpha_i^{1 / x_i})^{z_i} = (\\alpha_i^{x^</em> / x_i})^{1 / x_i}</span>  and  <span class="math">\\alpha_{i} = (\\alpha_{i}^{x^{*} / x_{i}})^{1 / z_{i}}</span> , gives exactly  <span class="math">\\alpha_{i}^{1 / x_{i}}</span> .</p>

    <p class="text-gray-300">Time to extract. Assume each  <span class="math">x_{i}</span>  is at most  <span class="math">\\ell</span>  bits. Note that  <span class="math">A_{j} = \\prod_{j\\in [n]\\setminus \\{i\\}}\\alpha_{j}^{z_{i,j}} = \\mathsf{MultiRootExp}(\\pmb{\\alpha}_{[n]\\setminus \\{i\\}},\\pmb{x}_{[n]\\setminus \\{i\\}})</span>  can be computed in  <span class="math">O(\\ell n\\log n)</span>  group operations. This dominates the time to compute  <span class="math">W^{z_i}</span>  and to do the Shamir trick.</p>

    <p class="text-gray-300">The PoKE protocol by Boneh et al. [3] proves knowledge of an  <span class="math">x \\in \\mathbb{Z}</span>  such that  <span class="math">w = u^x</span>  to a verifier who has  <span class="math">w</span>  and  <span class="math">u</span> . In other words, it proves that the relation  <span class="math">\\mathcal{R}_{\\mathrm{PoKE}} = \\{w \\in \\mathbb{G}_?, u \\in \\mathbb{G}_?: w = u^x\\}</span>  holds. The protocol makes use</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoKE.Prove(w = u^x, u ∈ G?, x ∈ Z) → πPoKE</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">PoKE.Ver(w ∈ G?, u ∈ G?, πPoKE) → {0,1}</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">g ← HG? (u, w) and z = g^x</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse (z, Q, r) ← πPoKE</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">l ← HPrimes2λ (u, w, z) and α ← H2λ (u, w, z, l)</td>

            <td class="px-3 py-2 border-b border-gray-700">g ← HG? (u, w)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let q ∈ Z, r ∈ [0, l) s.t. x = ql + r.</td>

            <td class="px-3 py-2 border-b border-gray-700">l ← HPrimes2λ (u, w, z) and α ← H2λ (u, w, z, l)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let Q = (ug^α)^q and πPoKE = (z, Q, r).</td>

            <td class="px-3 py-2 border-b border-gray-700">return Q^l (ug^α)^r = wz^α</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 2: Non-interactive proof-of-knowledge of exponent (PoKE) protocol [3].</p>

    <p class="text-gray-300">of three different hash functions  <span class="math">H_{\\mathbb{G}_7} : \\mathbb{G}_7^2 \\to \\mathbb{G}_7</span> ,  <span class="math">H_{\\mathrm{Primes}_{2\\lambda}} : \\mathbb{G}_7^3 \\to \\mathrm{Primes}_{2\\lambda}</span>  and  <span class="math">H_{2\\lambda} : \\mathbb{G}_7^3 \\times \\{0,1\\}^{2\\lambda} \\to \\{0,1\\}^{2\\lambda}</span>  modeled as random oracles. Correctness holds because:</p>

    <div class="my-4 text-center"><span class="math-block">Q ^ {\\ell} u ^ {r} g ^ {\\alpha r} = \\left(u ^ {q} g ^ {\\alpha q}\\right) ^ {\\ell} u ^ {r} g ^ {\\alpha r} = u ^ {q \\ell} g ^ {\\alpha q \\ell} u ^ {r} g ^ {\\alpha r} = u ^ {q \\ell + r} g ^ {\\alpha q \\ell + \\alpha r} = u ^ {x} g ^ {\\alpha x} = w z ^ {\\alpha} \\tag {2}</span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Knowledge soundness holds in the generic group model (see [3, Proof of Thm. 3 in Appendix C.2]). A PoKE proof contains two elements in  <span class="math">\\mathbb{G}_?</span>  and a  <span class="math">2\\lambda</span> -bit number  <span class="math">r</span>  and can be computed in  $O(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">RSA accumulators were introduced by Benaloh and de Mare [2]. Given a set  <span class="math">T = \\{e_1, e_2, \\ldots, e_n\\}</span>  of unique,  <span class="math">\\ell</span> -bit prime elements, an RSA accumulator is a commitment  <span class="math">c = g^{\\prod_{e_i \\in T} e_i}</span>  to the set  <span class="math">T</span> . Here,  <span class="math">g</span>  is a random element of  <span class="math">\\mathbb{G}_?</span> . RSA accumulators support proving membership of any  <span class="math">e_i</span> , as well as non-membership of any  <span class="math">e \\notin T</span> . Furthermore, RSA accumulators support proving subset relations  <span class="math">S \\subseteq T</span>  as well as disjointness relations  <span class="math">X \\cap T = \\emptyset</span> .</p>

    <p class="text-gray-300">To prove that  <span class="math">e_i \\in T</span>  w.r.t. the accumulator  <span class="math">c</span> , the prover computes a membership witness  <span class="math">w_i = g^{\\prod_{e_j \\in T, e_j \\neq e_i}} = c^{1 / e_i}</span> . The verifier checks the witness as  <span class="math">w_i^{e_i} \\stackrel{?}{=} c</span> . Sander et al. [24] showed that all of  <span class="math">T</span> 's membership witnesses can be computed in  <span class="math">O(\\ell n \\log n)</span>  time as  <span class="math">(w_i)_{i \\in [n]} \\gets \\text{RootFactor}(g, [e_1, e_2, \\ldots, e_n])</span>  (see Fig. 1). Furthermore, a subset witness for several elements  <span class="math">S \\subseteq T</span>  can be computed as  <span class="math">w_S = g^{\\prod_{e_j \\in T, e_j \\notin S}} = c^{1 / \\prod_{e_j \\in S}}</span> . The verifier checks the witness as  <span class="math">w_i^{\\prod_{e_j \\in S}} \\stackrel{?}{=} c</span> . Note that such a witness can be aggregated from the individual witnesses  <span class="math">c^{1 / e_j}</span> 's as  <span class="math">w_S = \\text{ShamirTrick}((c^{1 / e_j})_{j \\in S}, (e_j)_{j \\in S})</span> .</p>

    <p class="text-gray-300">Cross-accumulator aggregation. Boneh et al. [3] show it is possible to cross-aggregate membership witnesses (and thus subset witnesses too) with respect to different accumulators, under the restriction that the elements being witnessed are pairwise co-prime. Recall that, given  <span class="math">n</span>  witnesses  <span class="math">w_{i}</span> , each for an element  <span class="math">e_{i}</span>  w.r.t. a different accumulator  <span class="math">a_{i}</span> , a cross-aggregated witness should prove that  <span class="math">w_{i}^{e_{i}} = a_{i}, \\forall i \\in [n]</span> . But, as Boneh et al. observe, this is equivalent to proving the PoKCR relation from Eq. (1) holds with  <span class="math">x_{i} = e_{i}</span>  and  <span class="math">\\alpha_{i} = a_{i}</span> . Thus, assuming all pairs of  <span class="math">e_{i}</span> 's are co-prime, a PoKCR proof can be used to aggregate all  <span class="math">w_{i}</span> 's into a single  <span class="math">w = \\prod_{i \\in [n]} w_{i}</span>  and verified using PoKCR.  <span class="math">\\text{Ver}(\\mathbf{a}, \\mathbf{x}, w)</span> . In Section 3.1, we give a faster algorithm for extracting all witnesses  <span class="math">w_{i}</span>  from such a cross-aggregated witness  <span class="math">w</span> .</p>

    <p class="text-gray-300">Li et al. [16] introduced non-membership witnesses for RSA accumulators. A non-membership witness for  <span class="math">e</span>  w.r.t. to accumulator  <span class="math">c = g^u</span>  is  <span class="math">(a, B = g^b)</span>  where  <span class="math">(a, b) = \\mathsf{EEA}(u, e)</span> , such that  <span class="math">au + be = 1</span> . The witness is verified by checking if  <span class="math">c^a B^e = g</span>  in  <span class="math">O(\\ell)</span>  group operations. Li et al. also show how to update non-membership witnesses after additions or deletions to the accumulator (see Fig. 3).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc.NonMemWitUpdAdd (c, a, B, x, x')</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc.NonMemWitUpdDel (c, c', a, B, x, x')</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let (s, t) = EEA(x, x')</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Note that c' = c1/x' is the updated accumulator without x'.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let q ∈ Z, r ∈ [0, x) s.t. at = qx + r</td>

            <td class="px-3 py-2 border-b border-gray-700">Let q ∈ Z, r ∈ [0, x) s.t. x'a = qx + r</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (a', B') = (r, cqx' + asB)</td>

            <td class="px-3 py-2 border-b border-gray-700">return (a', B') = (r, (c')^qB)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 3: Algorithms by Li et al. [16] for updating an RSA non-membership witness in  <span class="math">O(\\ell)</span>  group operations. For an intuitive explanation, see Appendix A.</p>

    <p class="text-gray-300">Boneh et al. [3] give algorithms for aggregating several non-membership witnesses  <span class="math">(a_{i},B_{i})_{i\\in [n]}</span>  for  <span class="math">e_i</span>  w.r.t. the same accumulator  <span class="math">c</span>  into a single disjointness witness for all  <span class="math">e_i</span> 's, which we describe in Fig. 4. Specifically, Acc.NonMemWitAgg* returns an  <span class="math">O(\\ell n)</span> -sized disjointness witness and Acc.NonMemWitAgg returns a constant-sized disjointness witness by using a PoKE proof.</p>

    <p class="text-gray-300">Our work builds upon Catalano and Fiore's RSA-based vector commitment (VC) scheme [5], which was later enhanced by Lai and Malavolta [12] with subvector proofs and by Campanelli et al. [4] with proof (dis)aggregation, efficient proof pre-computation and constant-sized auxiliary information for updates.</p>

    <p class="text-gray-300">Public parameters. Let  <span class="math">e_i = H(i)</span>  be distinct primes corresponding to each position  <span class="math">i \\in [n]</span>  in the vector. We often use  <span class="math">e_I = \\prod_{i \\in I} e_i</span>  for any set  <span class="math">I \\subseteq [n]</span> . Let  <span class="math">S = g^{\\prod_{j \\in [n]} e_j}</span>  and  <span class="math">S_i = S^{1/e_i} = g^{\\prod_{j \\in [n] \\setminus \\{i\\}} e_j}</span> . Note that  <span class="math">S</span>  can be regarded as an RSA accumulator [2] and  <span class="math">S_i</span>  as an RSA membership witness for  <span class="math">e_i</span> . Also note that the vector can be extended with new positions by adding more primes  <span class="math">(e_{n+1}, e_{n+2}, \\ldots)</span>  to  <span class="math">S</span>  (and thus to the  <span class="math">S_i</span> 's too). The public parameters consist of a proving key  <span class="math">\\mathsf{prk} = (g, H)</span>  and a verification key  <span class="math">\\mathsf{vrk} = (g, H)</span> . The  <span class="math">S_i</span> 's are called update keys since they serve as auxiliary information when updating digests and proofs.</p>

    <p class="text-gray-300">Commitment. A commitment to  <span class="math">\\pmb{v} = (v_{i})_{i\\in [n]}</span>  consists of  <span class="math">S = g^{e_{[n]}}</span>  and  <span class="math">c = \\prod_{i\\in [n]}S_i^{v_i}</span> . The committing time is dominated by computing all  <span class="math">S_{i}</span> 's in  <span class="math">O(\\ell n\\log n)</span>  group operations via RootFactor  <span class="math">(g,[e_1,\\dots ,e_n])</span> . The commitment</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc.NonMemWitAgg* (c, (ai, Bi, ei)i∈[n]) → (a, B)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc.NonMemWitAgg (c, (ai, Bi, ei)i∈[n]) → π</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">if n = 1, then return (a1, B1), else</td>

            <td class="px-3 py-2 border-b border-gray-700">(a, B) ← Acc.NonMemWitAgg*(c, (ai, Bi, ei)i∈[n])</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Split [n] into two halves L and R</td>

            <td class="px-3 py-2 border-b border-gray-700">return π = (ca, πaPoKE = PoKE.Prove(ca, c, a), B)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  (aL, BL) ← Acc.NonMemWitAgg* (c, (ai, bi, ei)i∈L) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">(aR, BR) ← Acc.NonMemWitAgg* (c, (ai, bi, ei)i∈R)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Acc.NonMemWitAggVer (c, π, (ei)i∈[n]) → {0, 1}</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">(s, t) ← EEA(eL, eR)</td>

            <td class="px-3 py-2 border-b border-gray-700">Parse (w, πaPoKE, B) ← π</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">a' ← t · aL · eR + s · aR · eL</td>

            <td class="px-3 py-2 border-b border-gray-700">return</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Let q ∈ Z, r ∈ [0, eLeR) s.t. a' = q · (eLeR) + r</td>

            <td class="px-3 py-2 border-b border-gray-700">1 = PoKE.Ver(w, c, πaPoKE) ∧</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">return (r, cq(BL)t(BR)*)</td>

            <td class="px-3 py-2 border-b border-gray-700">g = wBeI</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Figure 4: Algorithms by Boneh et al. [3] for aggregating RSA non-membership witnesses. (For intuition, see [3, pg. 18]).</p>

    <p class="text-gray-300">can be updated after extending the vector with a new position  <span class="math">v_{n+1}</span>  as  <span class="math">S&#x27; = S^{e_{n+1}}</span>  and  <span class="math">c&#x27; = c^{e_{n+1}}S^{v_{n+1}}</span> . Note that the vector can be extended with multiple positions by applying this update sequentially.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The commitment can also be updated after changing any set of values  <span class="math">(v_{j})_{j\\in J}</span>  by  <span class="math">\\delta_j</span> , if the individual  <span class="math">S_{j}</span> 's are given. Then, the commitment is updated as  <span class="math">S^{\\prime} = S</span>  and  <span class="math">c^{\\prime} = c\\cdot \\prod_{j\\in J}S_{j}^{\\delta_{j}}</span> . If  $b =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , this takes  </span>O(\\ell b)<span class="math">  group operations. Alternatively, if an aggregated update key  </span>S_{J} = S^{1 / e_{J}}<span class="math">  is given, each  </span>S_{j}<span class="math">  is first computed via RootFactor  </span>(S_J,(e_j)_{j\\in J})<span class="math">  in  </span>O(\\ell b\\log b)$  group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Subvector proofs. An  <span class="math">I</span> -subvector proof  <span class="math">\\pi_I</span>  for  <span class="math">\\pmb{v}_I = (v_i)_{i \\in I}, I \\subseteq [n]</span>  consists of (1)  <span class="math">S_I = S^{\\frac{1}{e_I}}</span>  and (2)  <span class="math">\\Lambda_I = \\left(\\prod_{j \\in [n] \\setminus I} S_j^{v_j}\\right)^{1 / e_I} = \\prod_{j \\in [n] \\setminus I} S_{I,j}^{v_j}</span> , where  <span class="math">S_{I,j} = S_j^{1 / e_I}</span> . Let  $b =</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The prover computes (1)  </span>S_I = g^{\\prod_{i \\in [n] \\setminus I} e_i}<span class="math">  and (2) all  </span>S_{I,j}<span class="math"> &#x27;s via RootFactor  </span>(g, (e_i)_{i \\in [n] \\setminus I})<span class="math"> . The prover time is dominated by the  </span>O(\\ell(n - b) \\log (n - b))<span class="math">  group operations from RootFactor. To verify  </span>\\pi_I<span class="math"> , one checks if  </span>(S_I)^{e_I} = S<span class="math"> , computes  </span>(S_i)_{i \\in I}<span class="math">  via RootFactor  </span>(S_I, (e_i)_{i \\in I})<span class="math">  and checks if  </span>c = \\Lambda_I^{e_I} \\prod_{i \\in I} S_i^{v_i}<span class="math"> . The verification time is dominated by the  </span>O(\\ell b \\log b)$  group operations from RootFactor.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1<span class="math"> , then an  </span>I<span class="math"> -subvector proof is referred to as an individual proof. A useful fact to notice is that  </span>\\pi_I<span class="math">  is simply the commitment to a vector &quot;without positions  </span>I<span class="math">  in it,&quot; since  </span>S_I = S^{1 / e_I}<span class="math">  and  </span>\\Lambda_I = \\left(c / \\prod_{i\\in I}S_i^{v_i}\\right)^{1 / e_I}$ . We often use this observation in Section 4.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">(Dis)aggregating proofs. Campanelli et al. introduce incremental (dis)aggregation of subvector proofs (see Fig. 5). Specifically, they show how to aggregate  <span class="math">\\pi_I, \\pi_J</span>  for  <span class="math">\\pmb{v}_I</span>  and  <span class="math">\\pmb{v}_J</span>  into a subvector proof  <span class="math">\\pi_{I \\cup J}</span>  for  <span class="math">\\pmb{v}_{I \\cup J}</span>  via CFG.Agg. They also show how to disaggregate any proof  <span class="math">\\pi_I</span>  into a proof  <span class="math">\\pi_{I \\setminus K}</span>  for a smaller subvector via CFG.Disagg. Lastly, they give a CFG.AggManyToOne algorithm that aggregates individual proofs for  <span class="math">v_i</span> 's,  <span class="math">i \\in I</span> , into a subvector proof for  <span class="math">\\pmb{v}_I</span>  Fig. 5 summarizes these algorithms as well as CFG.Agg*, a relaxed version of CFG.Agg that assumes  <span class="math">I \\cap J = \\emptyset</span> .</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let  $b = \\max \\{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\}<span class="math"> . Then, CFG.Agg<em> takes  </span>O(\\ell b \\log b)<span class="math">  group operations. CFG.AggManyToOne uses CFG.Agg</em> recursively and takes  </span>T(b) = 2T(b/2) + O(\\ell b \\log b) = O(\\ell b \\log^2 b)<span class="math">  group operations. CFG.Disagg takes  </span>O(\\ell(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">) \\log (</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">))<span class="math">  group operations. Since the worst-case time to disaggregate  </span>\\pi_I<span class="math">  and  </span>\\pi_J<span class="math">  is  </span>O(\\ell b \\log b)<span class="math">  group operations, CFG.Agg is also  </span>O(\\ell b \\log b)$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Updating  <span class="math">I</span> -subvector proofs A proof  <span class="math">\\pi_I = (S_I, \\Lambda_I)</span>  for  <span class="math">(v_i)_{i \\in I}</span>  can be updated to  <span class="math">\\pi_I&#x27; = (S_I&#x27;, \\Lambda_I&#x27;)</span>  after the vector changes. Previous work [4, 5] shows how to update proofs if (1) several  <span class="math">v_j</span> 's change or if (2) the vector is extended with extra positions  <span class="math">n + 1, n + 2, \\ldots, n + \\Delta</span> . In Section 4.2, we show how to handle the case where positions in the vector are "removed," which is necessary for dictionaries.</p>

    <p class="text-gray-300">Case 1: Extending vector with new values  <span class="math">v_{n+1}, \\ldots, v_{n+\\Delta}</span> : In this case, we have:</p>

    <div class="my-4 text-center"><span class="math-block">S _ {I} ^ {\\prime} = S _ {I} ^ {\\prod_ {j \\in [ \\Delta ]} e _ {n + j}} \\quad \\Lambda_ {I} ^ {\\prime} = \\Lambda_ {I} ^ {\\prod_ {j \\in [ \\Delta ]} e _ {n + j}} \\prod_ {j \\in [ \\Delta ]} \\left(\\left(S _ {I} ^ {\\prime}\\right) ^ {1 / e _ {n + j}}\\right) ^ {v _ {n + j}} \\tag {3}</span></div>

    <p class="text-gray-300">Note that this takes  <span class="math">O(\\ell \\Delta)</span>  group operations if done sequentially (as described in the commitment update paragraph above) rather than using RootFactor to compute all  <span class="math">S_K^{\\prime 1 / e_{n + j}}</span> 's.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CFG.Agg* (I, J, vI, vJ, πI, πJ) → πI∪J ▷ Assume proofs verify against digest d = (c, S = gΠi∈[n] e i) Parse (SI, ΛI) ← πI and (SJ, ΛJ) ← πJ ▷ where S′i=S, ΛI = Πj∈[n] ∪ S′i, Λ′i = C SI∪J ← ShamirTrick(SI, SJ, eI, eJ), s.t. S′i∪J = S (SI,j)j∈J ← RootFactor(SI∪J, (ej)j∈J), s.t. S′i,j = S′i/ej (SJ,i)i∈I ← RootFactor(SI∪J, (ei)i∈I), s.t. S′i,i = S′i/ei</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CFG.AggManyToOne (I, vI, (πi)i∈I) → πI if</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 1, then return π1, else Split I into two halves L and R πL ← CFG.AggManyToOne(L, vL, (πi)i∈L) πR ← CFG.AggManyToOne(R, vR, (πi)i∈R) πI ← CFG.Agg*(L, R, vL, vR, πL, πR) return πI endif</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Λ<em>I ← ΛI/Πj∈J S′i,j = Πj∈[n] ∪ S′i, S′i, j = Πj∈[n] j∉I∪J Λ</em>J ← ΛJ/Πi∈I S′i,j = Πi∈[n] ∪ S′i, S′i, j = Πi∈[n] i∉I∪J ΛI∪J ← ShamirTrick(Λ<em>I, Λ</em>J, eI, eJ) = Πk∈[n] k∉I∪J</td>

            <td class="px-3 py-2 border-b border-gray-700">CFG.Disagg(I, K, vI, πI = (SI, ΛI)) → πK SK ← S′i∈I∈K = S′i/ek (SK,i) ← RootFactor(SI, (ei)i∈I∈K) ΛK ← Λi∈I∈K Πi∈I∈K S′i, i return πK = (SK, ΛK) CFG.Agg (I, J, vI, vJ, πI, πJ) → πI∪J πJ∪I → CFG.Disagg(J, J ∪ I, vJ, πJ) πI∪J ← CFG.Agg*(I, J ∪ I, vI, vJ∪I, πI, πJ∪I) return πI∪J</td>

          </tr>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Figure 5: Algorithms by Campanelli et al. [4] for incrementally (dis)aggregating proofs. CFG.Agg* assumes  <span class="math">I \\cap J = \\emptyset</span> , CFG.Disagg assumes  <span class="math">K \\subset I, K \\neq \\emptyset</span> , CFG.Agg assumes  <span class="math">I \\nsubseteq J</span>  and  <span class="math">J \\nsubseteq I</span>  and CFG.AggManyToOne assumes  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">I</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 2^k$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Case 2: Changing each  <span class="math">(v_{j})_{j\\in J}</span>  by  <span class="math">\\delta_j</span> : If  <span class="math">J\\subseteq I</span> , then  <span class="math">\\pi_I&#x27; = \\pi_I</span> . Otherwise,  <span class="math">S&#x27; = S_I</span>  and  <span class="math">\\Lambda_I&#x27; = \\Lambda_I\\prod_{j\\in J\\setminus I}(S_{I,j})^{\\delta_j}</span> . In order to compute all  <span class="math">S_{I,j}</span> 's, we must be given either the aggregate update key  <span class="math">S_J</span>  or the individual  <span class="math">S_j</span> 's (from which  <span class="math">S_J</span>  can be computed). First, computes  <span class="math">S_{J\\setminus I} = S_J^{e_J / e_{J\\setminus I}} = S^{1 / e_{J\\setminus I}}</span>  in  $O(\\ell</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">J</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)<span class="math">  group operations. Second, computes  </span>S_{I\\cup J} = \\mathrm{ShamirTrick}(S_I,S_{J\\setminus I},e_I,e_{J\\setminus I})<span class="math"> . Third, computes all  </span>S_{I,j},j\\in J\\setminus I<span class="math"> &#x27;s via RootFactor  </span>(S_{I\\cup J},(e_j)_{j\\in J\\setminus I})$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Precomputing all proofs. All individual proofs can be computed fast in  <span class="math">O(\\ell n \\log^2 n)</span>  time via proof disaggregation in a recursive manner [4] by disaggregating the proof for the full vector  <span class="math">\\pmb{v}</span>  (i.e.,  <span class="math">\\pi_{[n]} = (g, 1_{\\mathbb{G}_7})</span> ) into a subvector proof for its left half  <span class="math">\\pmb{v}_L</span>  and a subvector proof for its right half  <span class="math">\\pmb{v}_R</span> . Then, this can be repeated recursively to obtain all individual proofs (see VC.DisaggOneToMany in [4, Fig. 1]).</p>

    <p class="text-gray-300">In this section, we give a new technique for performing faster witness extraction in the PoKCR protocol by Boneh et al. [3] from Section 2.2. This helps us verify cross-aggregated proofs faster in our UAD from Section 4.2. Then, we show how to compute all RSA non-membership witnesses  <span class="math">(a_{i},B_{i})_{i\\in I}</span>  for  <span class="math">e_i</span>  w.r.t. its own accumulator  <span class="math">c^{1 / e_i}</span> , which we use to precompute proofs fast in our AAD from Section 4.3. Lastly, we also show how to aggregate such witnesses across different accumulators, which we leverage to aggregate lookup proofs in our AAD. The  <span class="math">e_i</span> 's are assumed to be  <span class="math">\\ell</span> -bit primes.</p>

    <p class="text-gray-300">Suppose we have a PoKCR proof  <span class="math">W</span>  of  <span class="math">x_{i}</span> th roots of  <span class="math">\\alpha_{i}, \\forall i \\in [m]</span>  as per Section 2.2. We know that each root  <span class="math">w_{i} = \\alpha_{i}^{1 / x_{i}}</span>  can be extracted in  <span class="math">O(\\ell m\\log m)</span>  group operations, where  <span class="math">\\ell</span>  is the max length in bits of the  <span class="math">x_{i}</span> 's. This means extracting all  <span class="math">w_{i}</span> 's takes  <span class="math">O(\\ell m^2\\log m)</span>  group operations, which can be slow. Here, we give an  <span class="math">O(\\ell m\\log^2 m)</span>  time algorithm called PoKCR.Extract for computing all  <span class="math">w_{i}</span> 's. The key idea is to split up  <span class="math">[m]</span>  into halves  <span class="math">L</span>  and  <span class="math">R</span>  and show how to extract  <span class="math">W_{L} = \\prod_{i\\in L}w_{i} = \\prod_{i\\in L}\\alpha_{i}^{1 / x_{i}}</span>  and  <span class="math">W_{R} = \\prod_{i\\in L}\\alpha_{i}^{1 / x_{i}}</span> . Then, the algorithm can recurse, eventually extracting all individual  <span class="math">w_{i}</span> 's.</p>

    <p class="text-gray-300">Let <span class="math">x_{L}=\\prod_{i\\in L}x_{i}</span>, <span class="math">x_{R}=\\prod_{i\\in R}x_{i}</span> and <span class="math">x^{*}=x_{L}x_{R}</span>. Since <span class="math">W</span> verifies, we have:</p>

    <p class="text-gray-300"><span class="math">W^{x^{<em>}}</span> <span class="math">=\\prod_{i\\in[m]}\\alpha_{i}^{x^{</em>}/x_{i}}=\\left(\\prod_{i\\in L}\\alpha_{i}^{x^{<em>}/x_{i}}\\right)\\left(\\prod_{i\\in R}\\alpha_{i}^{x^{</em>}/x_{i}}\\right)\\Leftrightarrow</span> (4) <span class="math">W^{x_{L}x_{R}}</span> <span class="math">=\\left(\\prod_{i\\in L}\\alpha_{i}^{1/x_{i}}\\right)^{x_{L}x_{R}}\\left(\\prod_{i\\in R}\\alpha_{i}^{1/x_{i}}\\right)^{x_{R}x_{L}}\\Rightarrow</span> (5) <span class="math">W^{x_{R}}</span> <span class="math">=(W_{L})^{x_{R}}\\left(W_{R}\\right)^{x_{R}}\\text{ and }W^{x_{L}}=(W_{L})^{x_{L}}\\left(W_{R}\\right)^{x_{L}}</span> (6)</p>

    <p class="text-gray-300">Note that the following terms are computable in <span class="math">O(\\ell m\\log m)</span> group operations:</p>

    <p class="text-gray-300"><span class="math">(W_{L})^{x_{L}}</span> <span class="math">=\\left(\\prod_{i\\in L}\\alpha_{i}^{1/x_{i}}\\right)^{x_{L}}=\\text{MultiRootExp}(\\bm{\\alpha}_{L},\\bm{x}_{L})</span> (7) <span class="math">(W_{R})^{x_{R}}</span> <span class="math">=\\left(\\prod_{i\\in R}\\alpha_{i}^{1/x_{i}}\\right)^{x_{R}}=\\text{MultiRootExp}(\\bm{\\alpha}_{R},\\bm{x}_{R})</span> (8)</p>

    <p class="text-gray-300">Next, <span class="math">W^{x_{L}}</span> and <span class="math">W^{x_{R}}</span> can be computed in <span class="math">O(\\ell m)</span> group operations. This means <span class="math">W_{R}^{x_{L}}=W^{x_{L}}/(W_{L})^{x_{L}}</span> and <span class="math">W_{L}^{x_{R}}=W^{x_{R}}/(W_{R})^{x_{R}}</span> can be computed too! Thus, we can use Shamir’s trick to obtain <span class="math">W_{L}</span> and <span class="math">W_{R}</span> in <span class="math">O(\\ell m\\log m)</span> group operations.</p>

    <p class="text-gray-300"><span class="math">\\text{ShamirTrick}(w_{L}^{x_{L}},w_{L}^{x_{R}},x_{R},x_{L})</span> <span class="math">=\\text{ShamirTrick}(w_{L}^{x^{<em>}/x_{R}},w_{L}^{x^{</em>}/x_{L}},x_{R},x_{L})=w_{L}^{x^{<em>}/x_{L}x_{R}}=w_{L}</span> (9) <span class="math">\\text{ShamirTrick}(w_{R}^{x_{L}},w_{R}^{x_{R}},x_{R},x_{L})</span> <span class="math">=\\text{ShamirTrick}(w_{R}^{x^{</em>}/x_{R}},w_{R}^{x^{<em>}/x_{L}},x_{R},x_{L})=w_{R}^{x^{</em>}/x_{L}x_{R}}=w_{R}</span> (10)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Thus, all roots <span class="math">w_{i}=\\alpha_{i}^{1/x_{i}}</span> can be obtained via recursion. Note that our final PoKCR.Extract(<span class="math">W,\\bm{\\alpha},\\bm{x}</span>) algorithm runs in time <span class="math">T(m)=2T(m/2)+O(\\ell m\\log m)=O(\\ell m\\log^{2}m)</span> group operations, where $m=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{\\alpha}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\bm{x}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.2 Computing All Non-membership Witnesses Across Different, Related Accumulators</h3>

    <p class="text-gray-300">In this section, we give an algorithm called Acc.NonMemWitCrossProve that, on input <span class="math">g</span> and <span class="math">(e_{i})_{i\\in[n]}</span>, computes all RSA non-membership witnesses <span class="math">(a_{i},B_{i})</span>’s for each <span class="math">e_{i}</span> w.r.t. <span class="math">c_{i}=g^{e^{<em>}/e_{i}}</span> where <span class="math">e^{</em>}=\\prod_{i\\in[n]}e_{i}</span>. Later on, we use this algorithm in Section 4.3 to precompute all lookup proofs in our AD construction.</p>

    <p class="text-gray-300">First, the algorithm computes a non-membership witness <span class="math">(a,B=g^{b})</span> for <span class="math">e^{<em>}</span> w.r.t. to the empty accumulator <span class="math">g^{1}</span>, where <span class="math">a\\cdot 1+b\\cdot e^{</em>}=1</span>. Next, let <span class="math">e_{L}=\\prod_{i\\in[1,n/2]}e_{i}</span> and <span class="math">e_{R}=\\prod_{i\\in(n/2,n]}e_{i}</span> such that <span class="math">e=e_{L}e_{R}</span>. The algorithm recursively updates <span class="math">(a,B)</span> into two witnesses: <span class="math">(a_{L},B_{L})</span> for <span class="math">e_{L}</span> w.r.t <span class="math">g^{e_{R}}</span>, and <span class="math">(a_{R},B_{R})</span> for <span class="math">e_{R}</span> w.r.t. <span class="math">g^{e_{L}}</span>. As a result, at the bottom of this recursion tree, the algorithm outputs all non-membership witnesses <span class="math">(a_{i},B_{i})</span> for <span class="math">e_{i}</span> w.r.t. <span class="math">g^{e^{*}/e_{i}}</span>.</p>

    <p class="text-gray-300">We show how to compute <span class="math">(a_{L},B_{L})</span> and note <span class="math">(a_{R},B_{R})</span> follows by symmetry. The algorithm computes Bézout coefficients <span class="math">(s,t)</span> such that <span class="math">s\\cdot e_{L}+t\\cdot e_{R}=1\\Rightarrow a=as\\cdot e_{L}+at\\cdot e_{R}</span>. Then, note that:</p>

    <p class="text-gray-300"><span class="math">g</span> <span class="math">=g^{a}B^{e}=g^{as\\cdot e_{L}+at\\cdot e_{R}}(B^{e_{R}})^{e_{L}}</span> (11) <span class="math">=(g^{as})^{e_{L}}(g^{e_{R}})^{at}(B^{e_{R}})^{e_{L}}=(g^{e_{R}})^{at}(g^{as}B^{e_{R}})^{e_{L}}</span> (12)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We could now set <span class="math">a_{L}=at</span> and <span class="math">B_{L}=(g^{as}B^{e_{R}})</span> as the witness, but $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">at</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{L}e_{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is too large for efficient recursion. To fix this, we reduce </span>at<span class="math"> modulo </span>e_{L}<span class="math"> by writing it as </span>at=q\\cdot e_{L}+r<span class="math"> for some integers </span>(q,r)<span class="math">, with </span>r<e_{L}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">g</span> <span class="math">=(g^{e_{R}})^{at}(g^{as}B^{e_{R}})^{e_{L}}=(g^{e_{R}})^{r+q\\cdot e_{L}}(g^{as}B^{e_{R}})^{e_{L}}</span> (13) <span class="math">=(g^{e_{R}})^{r}(g^{e_{R}})^{q\\cdot e_{L}}(g^{as}B^{e_{R}})^{e_{L}}=(g^{e_{R}})^{r}(g^{qe_{R}}g^{as}B^{e_{R}})^{e_{L}}</span> (14)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Now, we can set <span class="math">a_{L}=at\\bmod e_{L}=r</span> and <span class="math">B_{L}=(g^{qe_{R}}g^{as}B^{e_{R}})</span>. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{L}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=O(\\ell n/2)<span class="math"> and </span>B_{L}<span class="math"> is a group element. Both </span>(a_{L},B_{L})<span class="math"> can be computed in </span>O(\\ell n)<span class="math"> group operations. Our final Acc.NonMemWitCrossProve recursive algorithm will take </span>T(n)=2T(n/2)+O(\\ell n)=O(\\ell n\\log n)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">3.3 Aggregating Non-membership Witnesses Across Different, Related Accumulators</p>

    <p class="text-gray-300">In this subsection, we give an algorithm called Acc.NonMemWitCrossAgg that aggregates <span class="math">n</span> witnesses <span class="math">(a_{i},B_{i})_{i\\in[n]}</span> for <span class="math">e_{i}</span> w.r.t. <span class="math">c^{1/e_{i}}</span> into a single non-membership witness <span class="math">(a,B)</span> for <span class="math">e^{<em>}=\\prod_{i\\in[n]}e_{i}</span> w.r.t. <span class="math">c^{\\prime}=c^{1/e^{</em>}}</span>. Later on, we use this algorithm in Section 4.3 to aggregate lookup proofs in our AD construction. We first describe how Acc.NonMemWitCrossAgg algorithm works when <span class="math">n=2</span> and then define it recursively for <span class="math">n&gt;2</span>.</p>

    <p class="text-gray-300"><em>Case <span class="math">n=2</span></em>: Suppose we are given just two witnesses <span class="math">\\pi_{0}=(a_{0},B_{0})</span> for <span class="math">e_{0}</span> w.r.t. <span class="math">c^{1/e_{0}}</span>, and <span class="math">\\pi_{1}=(a_{1},B_{1})</span> for <span class="math">e_{1}</span> w.r.t. <span class="math">c^{1/e_{1}}</span>, where:</p>

    <p class="text-gray-300"><span class="math">(c^{1/e_{0}})^{a_{0}}(B_{0})^{e_{0}}=g\\qquad\\qquad(c^{1/e_{1}})^{a_{1}}(B_{1})^{e_{1}}=g</span> (15)</p>

    <p class="text-gray-300">We want to aggregate them into a disjointness witness <span class="math">\\pi=(a,B)</span> for <span class="math">e_{0}\\cdot e_{1}</span> w.r.t. <span class="math">c^{\\prime}=c^{\\frac{1}{e_{0}\\cdot e_{1}}}</span>, such that <span class="math">(c^{\\prime})^{a}B^{e_{0}\\cdot e_{1}}=g</span>. First, we update the witness for <span class="math">e_{0}</span> w.r.t. <span class="math">c^{1/e_{0}}</span> into a witness w.r.t <span class="math">c^{\\prime}</span>, which removed <span class="math">e_{1}</span>, as <span class="math">(a^{\\prime}_{0},B^{\\prime}_{0})=\\textsf{Acc.NonMemWitUpdDel}(c^{1/e_{0}},c^{\\prime},a_{0},B_{0},e_{0},e_{1})</span>. Second, we update the witness for <span class="math">e_{1}</span> w.r.t. <span class="math">c^{1/e_{1}}</span> into a witness w.r.t <span class="math">c^{\\prime}</span>, which removed <span class="math">e_{0}</span>, as <span class="math">(a^{\\prime}_{1},B^{\\prime}_{1})=\\textsf{Acc.NonMemWitUpdDel}(c^{1/e_{1}},c^{\\prime},a_{1},B_{1},e_{1},e_{0})</span>. Now, we have two non-membership witnesses for <span class="math">e_{0}</span> and <span class="math">e_{1}</span> w.r.t. <span class="math">c^{\\prime}</span>:</p>

    <p class="text-gray-300"><span class="math">(c^{\\prime})^{a^{\\prime}_{0}}(B^{\\prime}_{0})^{e_{0}}=g\\qquad\\qquad(c^{\\prime})^{a^{\\prime}_{1}}(B^{\\prime}_{1})^{e_{1}}=g</span> (16)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Next, we can aggregate these witnesses as <span class="math">(a,B)=\\textsf{Acc.NonMemWitAgg}^{*}(c^{\\prime},a^{\\prime}_{0},B^{\\prime}_{0},\\,e_{0},a^{\\prime}_{1},B^{\\prime}_{1},e_{1})</span> such that <span class="math">(c^{\\prime})^{a}B^{e_{0}e_{1}}=g</span>. The time complexity of this is <span class="math">O(\\ell)</span> group operations. Note that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e_{0}e_{1}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, but we reduce it next.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><em>Case <span class="math">n&gt;2</span></em>: Suppose we are given an arbitrary number of witnesses <span class="math">n</span>. Then, we lay out a computation tree with the <span class="math">(a_{i},B_{i})</span>’s in the leaves such that every node runs the aggregation explained above on its two children. This results in the root computing a non-membership witness <span class="math">(a,B)</span> for <span class="math">e^{<em>}</span> w.r.t <span class="math">c^{\\prime}=c^{1/e^{</em>}}</span>. Finally, we compute a PoKE proof <span class="math">\\pi_{a}^{\\textsf{PoKE}}=\\textsf{PoKE.Prove}((c^{\\prime})^{a},c^{\\prime},a)</span> to "compress" <span class="math">a</span>, which is of size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">e^{*}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. The final aggregated disjointness witness will be </span>\\pi=((c^{\\prime})^{a},\\,\\pi_{a}^{\\textsf{PoKE}},B)<span class="math"> and verifies via Acc.NonMemWitAggVer</span>(c^{\\prime},\\,\\pi,(e_{i})_{i\\in[n]})<span class="math"> (see Fig. 4). Thus, our final Acc.NonMemWitCrossAgg algorithm will take </span>T(n)=2T(n/2)+O(\\ell n)=O(\\ell n\\log n)$ group operations.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-16" class="text-2xl font-bold">4 Authenticated Dictionaries from Hidden-Order Groups</h2>

    <p class="text-gray-300">In this section, we first formalize authenticated dictionaries. Then, we give two constructions from hidden-order groups, both built on top of the VC scheme from Section 2.5. Our first construction is an <em>updatable authenticated dictionary (UAD)</em> for stateless validation in the smart contract setting (see Section 4.2). Our UAD supports a new notion of <em>cross-incremental proof (dis)aggregation</em>, which generalizes the notion of <em>cross-commitment aggregation</em> by <em>Gorbunov et al. [10]</em>. Our second construction is an <em>append-only authenticated dictionary (AAD)</em> for applications with stronger security requirements, such as transparency logs (see Section 4.3). Our AAD additionally supports <em>non-membership proofs</em> of keys that are not in the dictionary and <em>append-only proofs</em> to prove a dictionary has only been extended with new key-value pairs. However, our AAD’s stronger security comes at the cost of downgrading from cross-incremental (dis)aggregation to "one-hop" proof aggregation <em>[3]</em>.</p>

    <p class="text-gray-300">Notation. We use <span class="math">k\\in D</span> to indicate key <span class="math">k</span> is in the dictionary with some value <span class="math">v\\neq\\bot</span>. When <span class="math">k</span> is not in the dictionary, we say it has value <span class="math">v=\\bot</span>. We also use <span class="math">(k,v)\\in D</span> to indicate key <span class="math">k</span> has value <span class="math">v\\neq\\bot</span> in the dictionary. We often denote a subset of a dictionary as a pair <span class="math">(K,V)</span> where <span class="math">V(k)</span> stores the value of each key <span class="math">k\\in K</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.1 Definitions</h3>

    <p class="text-gray-300">The following APIs capture the essential operations in an AD scheme and are useful for formalizing security.</p>

    <p class="text-gray-300"><span class="math">\\textsf{AD.Setup}(1^{\\lambda})\\rightarrow(\\textsf{prk},\\textsf{vrk}).</span> Returns the AD’s <em>proving key</em> and <em>verification key</em>.</p>

    <p class="text-gray-300"><span class="math">\\textsf{AD.Commit}(\\textsf{prk},D)\\rightarrow d.</span> Returns a digest <span class="math">d</span> of the dictionary <span class="math">d</span>.</p>

    <p class="text-gray-300"><span class="math">\\textsf{AD.ProveLookup}(\\textsf{prk},D,K)\\rightarrow\\pi.</span> Returns a <em>lookup proof</em> <span class="math">\\pi</span> that each <span class="math">k\\in K</span> has value <span class="math">D(k)</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">AD.VerLookup(vrk,  <span class="math">d,K,V,\\pi)\\to \\{0,1\\}</span>  . Verifies the proof  <span class="math">\\pi</span>  that each  <span class="math">k\\in K</span>  has value  <span class="math">V(k)</span>  in the dictionary with digest  <span class="math">d</span></p>

    <p class="text-gray-300">AD.CrossAgg((vrk,  <span class="math">d_{i},K_{i},V_{i},\\pi_{i})_{i\\in [m]})\\to \\pi</span>  . Given lookup proofs  <span class="math">\\pi_{i}</span>  for each  <span class="math">k\\in K_{i}</span>  having value  <span class="math">V_{i}(k)</span>  w.r.t. digest  <span class="math">d_{i}</span>  built using the public parameters from vrk  <span class="math">i</span>  (with all vrk  <span class="math">i\\neq \\mathrm{vrk}_j</span>  ), returns a succinct, cross-aggregated proof  <span class="math">\\pi</span></p>

    <p class="text-gray-300">AD.CrossVerLookup((vrk,  <span class="math">d_{i},K_{i},V_{i})_{i\\in [m]},\\pi)\\to \\{0,1\\}</span>  . Verifies the cross-aggregated proof  <span class="math">\\pi</span>  that each  <span class="math">k\\in K_{i}</span>  has value  <span class="math">V_{i}(k)</span>  in the dictionary with digest  <span class="math">d_{i}</span>  , for all  <span class="math">i\\in [m]</span>  . When  <span class="math">m = 1</span>  , simply returns AD.VerLookup(vrk1,  <span class="math">d_{1}</span> <span class="math">K_{1},V_{1},\\pi)</span>  . In other words, proofs cross-aggregated amongst  <span class="math">m = 1</span>  digests are just normal aggregated proofs.</p>

    <p class="text-gray-300">AD.ProveAppendOnly(prk,  <span class="math">D,D^{\\prime})\\to \\pi</span>  . Returns an append-only proof  <span class="math">\\pi</span>  that the dictionary  <span class="math">D</span>  is a subset of  <span class="math">D^{\\prime}</span></p>

    <p class="text-gray-300">AD.VerAppendOnly(vrk,  <span class="math">d,d^{\\prime},\\pi)\\to \\{0,1\\}</span>  . Verifies the proof  <span class="math">\\pi</span>  that the dictionary with digest  <span class="math">d</span>  is a subset of the dictionary with digest  <span class="math">d^{\\prime}</span></p>

    <p class="text-gray-300">Definition 4.1 (Correctness). An authenticated dictionary scheme is correct if,  <span class="math">\\forall</span>  public parameters  <span class="math">(\\mathsf{prk},\\mathsf{vrk})\\gets</span>  AD.Setup  <span class="math">(1^{\\lambda})</span> <span class="math">\\forall</span>  dictionaries  <span class="math">D</span>  with digest  <span class="math">d\\gets</span>  AD.Commit(prk,  <span class="math">D</span>  ), the following hold:</p>

    <p class="text-gray-300">LOOKUP CORRECTNESS:  <span class="math">\\forall</span>  sets of keys  <span class="math">K</span> , if  <span class="math">\\pi = \\mathsf{AD}.\\mathsf{ProveLookup}(\\mathsf{prk},D,K)</span>  and  <span class="math">V(k) = D(k),\\forall k\\in K</span> , then AD.VerLookup(vrk,  <span class="math">d,K,V,\\pi) = 1</span> .</p>

    <p class="text-gray-300">APPEND-ONLY CORRECTNESS:  <span class="math">\\forall</span>  dictionaries  <span class="math">D^{\\prime}</span>  such that  <span class="math">D\\subseteq D^{\\prime}</span>  and  <span class="math">d^{\\prime}\\gets \\mathsf{AD}.Commit(\\mathsf{prk},D)</span> , if  <span class="math">\\pi =</span>  AD.ProveAppendOnly(prk,  <span class="math">D,D^{\\prime}</span> ), then AD.VerAppendOnly(vrk,  <span class="math">d,d^{\\prime},\\pi) = 1</span> .</p>

    <p class="text-gray-300">Definition 4.2 (Cross-lookup Correctness). An authenticated dictionary scheme has cross-lookup correctness if,  <span class="math">\\forall m, \\forall \\left((\\mathsf{prk}_i, \\mathsf{vrk}_i) \\leftarrow \\mathsf{AD.Setup}(1^\\lambda)\\right)_{i \\in [m]}, \\forall</span>  dictionaries  <span class="math">(D_i)_{i \\in [m]}</span> , each with digest  <span class="math">d_i = \\mathsf{AD.Committ}(\\mathsf{prk}_i, D_i)</span> ,  <span class="math">\\forall</span>  sets of keys  <span class="math">(K_i)_{i \\in [m]}</span>  with values  <span class="math">V_i(k) = D_i(k), k \\in K_i</span> , if  <span class="math">\\pi_i \\leftarrow \\mathsf{AD.ProveLookup}(\\mathsf{prk}_i, D_i, K_i), \\forall i \\in [m]</span>  and  <span class="math">\\pi \\leftarrow \\mathsf{AD.CrossAgg}((\\mathsf{vrk}_i, d_i, K_i, V_i, \\pi_i)_{i \\in [m]})</span> , then AD.CrossVerLookup  <span class="math">((\\mathsf{vrk}_i, d_i, K_i, V_i)_{i \\in [m]}, \\pi) = 1</span> .</p>

    <p class="text-gray-300">Definition 4.3 (Strong Key Binding).  <span class="math">\\forall</span>  adversaries  <span class="math">\\mathcal{A}</span>  running in time  <span class="math">\\mathrm{poly}(\\lambda)</span> , there exists negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span> , such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {p r k}, \\mathsf {v r k}) \\leftarrow \\mathsf {A D . S e t u p} (1 ^ {\\lambda}), \\\\ (d, K, K ^ {\\prime}, V, V ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\mathsf {p r k}, \\mathsf {v r k}): \\\\ \\mathsf {A D . V e r L o o k u p} (\\mathsf {v r k}, d, K, V, \\pi) = 1 \\wedge \\\\ \\mathsf {A D . V e r L o o k u p} (\\mathsf {v r k}, d, K ^ {\\prime}, V ^ {\\prime}, \\pi^ {\\prime}) = 1 \\wedge \\\\ \\exists k \\in K \\cap K ^ {\\prime} \\text {s . t .} V (k) \\neq V ^ {\\prime} (k) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Observation: In some applications, such as stateless validation for cryptocurrencies, a weaker definition where the adversary outputs a dictionary and the digest is correctly computed from it suffices (see Definition B.2).</p>

    <p class="text-gray-300">Definition 4.4 (Strong Cross Binding).  <span class="math">\\forall M = \\mathrm{poly}(\\lambda)</span> ,  <span class="math">\\forall</span>  adversaries  <span class="math">\\mathcal{A}</span>  running in time  <span class="math">\\mathrm{poly}(\\lambda)</span> , there exists negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span> , such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} \\left(\\left(\\mathsf {p r k} _ {i}, \\mathsf {v r k} _ {i}\\right) \\leftarrow \\mathsf {A D . S e t u p} (1 ^ {\\lambda})\\right) _ {i \\in [ M ]}, \\\\ \\left((d _ {i}, K _ {i}, V _ {i}) _ {i \\in I}, (d _ {j} ^ {\\prime}, K _ {j} ^ {\\prime}, V _ {j} ^ {\\prime}) _ {j \\in J}, \\pi , \\pi^ {\\prime}\\right) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, (\\mathsf {p r k} _ {i}, \\mathsf {v r k} _ {i}) _ {i \\in [ M ]}): \\\\ \\mathsf {A D . C r o s s V e r L o o k u p} ((\\mathsf {v r k} _ {i}, d _ {i}, K _ {i}, V _ {i}) _ {i \\in I}, \\pi) = 1 \\wedge \\\\ \\mathsf {A D . C r o s s V e r L o o k u p} ((\\mathsf {v r k} _ {j}, d _ {j} ^ {\\prime}, K _ {j} ^ {\\prime}, V _ {j} ^ {\\prime}) _ {j \\in J}, \\pi^ {\\prime}) = 1 \\wedge \\\\ \\exists i \\in I, j \\in J, k \\in K _ {i} \\cap K _ {j} ^ {\\prime} \\text {s u c h t h a t} \\\\ \\mathsf {v r k} _ {i} = \\mathsf {v r k} _ {j} \\wedge d _ {i} = d _ {j} ^ {\\prime} \\wedge V _ {i} (k) \\neq V _ {j} ^ {\\prime} (k) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">Observation: Note that  <span class="math">I, J</span>  are subsets of  <span class="math">[M]</span> . Also note that this definition requires the public parameters of the dictionaries whose proofs are being cross-aggregated to be different. An ideal cross-aggregation scheme should also work for dictionaries built using the same public parameters.</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Definition 4.5 (Append-only Security).</h6>

    <p class="text-gray-300"><span class="math">\\forall</span> adversaries <span class="math">\\mathcal{A}</span> running in time <span class="math">\\mathsf{poly}(\\lambda)</span>, there exists negligible function <span class="math">\\mathsf{negl}(\\cdot)</span>, such that:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}(\\mathsf{prk},\\mathsf{vrk})\\leftarrow\\mathsf{AD}.Setup(1^{\\lambda}),\\\\ (d,d^{\\prime},K,K^{\\prime},V,V^{\\prime},\\pi,\\pi^{\\prime},\\pi_{\\subseteq})\\leftarrow\\mathcal{A}(1^{\\lambda},\\mathsf{prk},\\mathsf{vrk}):\\\\ \\mathsf{AD}.VerAppendOnly(\\mathsf{vrk},d,d^{\\prime},\\pi_{\\subseteq})=1\\wedge\\\\ \\mathsf{AD}.VerLookup(\\mathsf{vrk},d,K,V,\\pi)=1\\wedge\\\\ \\mathsf{AD}.VerLookup(\\mathsf{vrk},d^{\\prime},K^{\\prime},V^{\\prime},\\pi^{\\prime})=1\\wedge\\\\ \\exists k\\in K\\cap K^{\\prime}\\text{ s.t. }V(k)\\neq\\bot\\wedge V(k)\\neq V^{\\prime}(k)\\end{array}\\right]\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Observation: This definition can be generalized to work with cross-aggregated proofs too.</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">4.2 Updatable Authenticated Dictionary for Stateless Validation</h3>

    <p class="text-gray-300">At a high level, we obtain an <em>updatable authenticated dictionary (UAD)</em> by mapping keys <span class="math">k</span> to primes <span class="math">e_{k}=H(k)</span> in the VC from Section 2.5 (instead of mapping vector indices <span class="math">i</span> to primes <span class="math">e_{i}</span>). This idea was developed concurrently in <em>[1]</em>, however, our work extends it in a different direction. First, we add <em>cross-incremental (dis)aggregation of proofs</em>, which allows <em>incrementally</em> cross-aggregating multiple lookup proofs across different digests as well as disaggregating such cross-aggregated proofs. This is useful for stateless validation in the smart contract setting <em>[10]</em>. Second, our construction supports updating aggregated proofs and proof pre-computation. One important caveat is that our cross-aggregation requires that the digests were built using different public parameters. Although this is different than previous work <em>[10]</em>, which allows the public parameters to be the same, it can still be used in the smart contract setting, since each contract can easily use its own (constant-sized) public parameters.</p>

    <p class="text-gray-300">We prove our UAD has <em>weak key binding</em> (see Definition B.2) in Appendix B.3 under the Strong RSA assumption (see Definition B.1). Similar to previous work <em>[3, 4]</em>, our UAD can update proofs and digests, but requires <em>auxiliary information</em> related to the keys <span class="math">k\\in K</span> that changed. Although eliminating the need for such auxiliary information is important <em>[1]</em>, we believe it is worth the cost given that it enables our UAD to support cross-incremental proof (dis)aggregation with the ability to update even cross-aggregated proofs! Furthermore, in the stateless validation setting, this auxiliary information is not too problematic, since it can be easily included in the transaction or served by <em>proof-serving nodes</em> <em>[28]</em>.</p>

    <p class="text-gray-300">Public parameters. The public parameters remain <span class="math">\\mathsf{prk}=\\mathsf{vrk}=(g,H)</span>, where <span class="math">g</span> is a generator for the hidden-order group <span class="math">\\mathbb{G}_{?}</span> and <span class="math">H</span> is a CRHF that maps keys (not vector indices) to <span class="math">\\ell+1</span> bit primes. Values in the dictionary must be <span class="math">\\ell</span>-bit numbers.</p>

    <p class="text-gray-300">Digest. Let <span class="math">D</span> be a dictionary and <span class="math">K</span> be the set of keys with a value <span class="math">D(k)\\neq\\bot</span> in the dictionary. We often use <span class="math">e_{K}=\\prod_{k\\in K}e_{k}</span> to denote the product of the prime representatives of all keys in <span class="math">K</span>. Let <span class="math">S=g^{e_{K}}</span> and <span class="math">S_{k}=S^{\\frac{1}{e_{k}}}</span>. The digest <span class="math">d=(c,S)</span> of our UAD resembles the VC from Section 2.5, where <span class="math">c=\\prod_{(k,v)\\in D}\\left(S_{k}\\right)^{v}</span>.</p>

    <p class="text-gray-300">Lookup proofs. Similar to Section 2.5, a proof <span class="math">\\pi_{k}</span> for <span class="math">k</span> having value <span class="math">v\\neq\\bot</span> in the dictionary <span class="math">D</span> with digest <span class="math">d=(c,S)</span> consists of two parts. The first part is a commitment <span class="math">\\Lambda_{k}</span> to <span class="math">D</span> without <span class="math">(k,v)</span> in it, where <span class="math">\\Lambda_{k}=\\prod_{(k^{\\prime},v)\\in D,k^{\\prime}\\neq k}\\left(\\left(S_{k^{\\prime}}\\right)^{v}\\right)^{\\frac{1}{e_{k}}}</span>. The second part, is an RSA membership witness <span class="math">S_{k}</span> for <span class="math">k</span> w.r.t. the RSA accumulator <span class="math">S</span> in the digest, where <span class="math">S_{k}=S^{\\frac{1}{e_{k}}}</span>. As before, to verify the proof, one checks if <span class="math">S=\\left(S_{k}\\right)^{e_{k}}</span> and if <span class="math">c=\\left(S_{k}\\right)^{v}(\\Lambda_{k})^{e_{k}}</span>.</p>

    <p class="text-gray-300">(Dis)aggregating lookup proofs. The incremental proof (dis)aggregation from Fig. 5 carries over to our construction. This because the CFG.Agg, CFG.Disagg and CFG.AggManyToOne algorithms by Campanelli et al. <em>[4]</em> are agnostic to whether <span class="math">e_{i}=H(i)</span> is obtained from the hash of a vector index <span class="math">i</span> or a dictionary key <span class="math">i</span>. Thus, our aggregated lookup proofs resemble the <span class="math">I</span>-subvector proofs from Section 2.5. Specifically, given lookup proofs <span class="math">(\\pi_{k})_{k\\in K}</span>, for each key <span class="math">k</span> having value <span class="math">v_{k}\\neq\\bot</span>, we can aggregate them as <span class="math">(S_{K},\\Lambda_{K})\\leftarrow\\mathsf{CFG.AggManyToOne}(K,(v_{k})_{k\\in K}</span>, <span class="math">(\\pi_{k})_{k\\in K})</span>, such that they verify as <span class="math">S=(S_{K})^{e_{K}}</span> and <span class="math">c=(\\Lambda_{K})^{e_{K}}\\prod_{k\\in K}(S_{k})^{v_{k}}</span>.</p>

    <p class="text-gray-300">Updating the digest. The digest <span class="math">d=(c,S)</span> can be easily updated given additions of new key-value pairs or changes to existing keys in the dictionary, similar to how the VC is updated in Section 2.5. Additionally, we also show how to update the digest after <em>removing</em> keys from the dictionary. This might be useful in the stateless cryptocurrency setting, for example, to delete users whose balance is zero. Specifically, we observe that, given the proof <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k})</span> for the removed key <span class="math">k</span> w.r.t. the old digest <span class="math">d=(c,S)</span>, we simply set the new digest to be <span class="math">d^{\\prime}=(c^{\\prime},S^{\\prime})</span> with <span class="math">c^{\\prime}=\\Lambda_{k}</span> and</p>

    <p class="text-gray-300"><span class="math">S^{\\prime}=S_{k}</span>. This is because the proof for the removed key <span class="math">k</span> is exactly the digest of the dictionary without key <span class="math">k</span> in it (see Section 2.5)! Lastly, to update the digest after multiple keys <span class="math">k\\in K</span> were removed, we first aggregate the proofs into a <span class="math">(\\Lambda_{K},S_{K})</span> via CFG.Agg or CFG.AggManyToOne and let the new digest <span class="math">d^{\\prime}=(\\Lambda_{K},S_{K})</span>.</p>

    <p class="text-gray-300">Updating proofs. Let <span class="math">\\pi_{K}=(S_{K},\\Lambda_{K})</span> be either an individual or an aggregated lookup proof for all <span class="math">k\\in K</span> having value <span class="math">v_{k}</span> w.r.t. digest <span class="math">d=(c,S)</span>. Updating <span class="math">\\pi_{K}</span> after adding new key-value pairs or after changing existing keys’ values works the same as in the VC from Section 2.5. As in the VC, updating after changing existing keys <span class="math">\\hat{k}\\in\\hat{K}</span> requires at least the aggregate update key <span class="math">S_{\\hat{K}}</span> (or the individual <span class="math">S_{\\hat{k}}</span>’s).</p>

    <p class="text-gray-300">We show how to update <span class="math">\\pi_{K}</span> to <span class="math">\\pi^{\\prime}_{K\\setminus\\hat{K}}</span> after removing several keys <span class="math">\\hat{k}\\in\\hat{K}</span>. We stress that the updated proof <span class="math">\\pi^{\\prime}_{K\\setminus\\hat{K}}</span> has to be for keys <span class="math">K\\setminus\\hat{K}</span> since that is the subset of <span class="math">K</span> left in the dictionary after removing all keys in <span class="math">\\hat{K}</span>. One consequence of this is that, when <span class="math">K=\\hat{K}</span>, the updated proof <span class="math">\\pi^{\\prime}_{K\\setminus\\hat{K}}</span> would need to be a non-membership proof for all <span class="math">k\\in K</span>. While our UAD does not support this, our AAD in Section 4.3 does. Thus, we only care about the case when <span class="math">K\\neq\\hat{K}</span>.</p>

    <p class="text-gray-300">In this case, assume we are given an aggregated proof <span class="math">\\pi_{\\hat{K}^{\\prime}}</span> for each <span class="math">\\hat{k}</span> having value <span class="math">v_{\\hat{k}}</span> (or individual proofs <span class="math">\\pi_{\\hat{k}}</span> which can be aggregated into <span class="math">\\pi_{\\hat{K}}</span>). Note that we can aggregate <span class="math">\\pi_{K\\cup\\hat{K}}=(S_{K\\cup\\hat{K}},\\Lambda_{K\\cup\\hat{K}})</span> via CFG.Agg<span class="math">(K,\\hat{K},(v_{k})_{k\\in K},(v_{\\hat{k}})_{\\hat{k}\\in\\hat{K}},\\pi_{K}</span>, <span class="math">\\pi_{\\hat{K}})</span>, obtaining a valid proof for all keys <span class="math">K\\cup\\hat{K}</span> w.r.t. the old digest <span class="math">d</span>. Interestingly, we observe that <span class="math">\\pi_{K\\cup\\hat{K}}</span> is also a valid proof for all keys <span class="math">K\\setminus\\hat{K}</span> w.r.t. the new digest <span class="math">d^{\\prime}=(c^{\\prime},S^{\\prime})=(\\Lambda_{\\hat{K}},S_{\\hat{K}})</span>. (Recall from above that the new digest <span class="math">d^{\\prime}</span> is just the aggregated proof <span class="math">\\pi_{\\hat{K}}</span> for the removed keys.) We explain how this works next.</p>

    <p class="text-gray-300">First, partition <span class="math">K\\cup\\hat{K}</span> into <span class="math">K\\setminus\\hat{K}</span> and <span class="math">\\hat{K}</span> so that <span class="math">e_{K\\cup\\hat{K}}=e_{K\\setminus\\hat{K}}e_{\\hat{K}}</span>. Second, to see how <span class="math">S_{K\\cup\\hat{K}}</span> verifies against <span class="math">S^{\\prime}</span>, note that, since <span class="math">S_{K\\cup\\hat{K}}</span> verifies against <span class="math">S</span> and <span class="math">K\\cup\\hat{K}</span>, we have <span class="math">S=(S_{K\\cup\\hat{K}})^{e_{K\\setminus\\hat{K}}e_{\\hat{K}}}\\Leftrightarrow S^{1/e_{\\hat{K}}}=(S_{K\\cup\\hat{K}})^{e_{K\\setminus\\hat{K}}}\\Leftrightarrow S^{\\prime}=(S_{K\\cup\\hat{K}})^{e_{K\\setminus\\hat{K}}}</span> Third, to see how <span class="math">\\Lambda_{K\\cup\\hat{K}}</span> verifies against <span class="math">c^{\\prime}</span> and <span class="math">K\\setminus\\hat{K}</span>, note that, since <span class="math">\\Lambda_{K\\cup\\hat{K}}</span> verifies against <span class="math">c</span> and and <span class="math">K\\cup\\hat{K}</span>, we have:</p>

    <p class="text-gray-300"><span class="math">c</span> <span class="math">=(\\Lambda_{K\\cup\\hat{K}})^{e_{K\\setminus K}e_{\\hat{K}}}\\prod_{k\\in K\\setminus\\hat{K}}(S_{k})^{v_{k}}\\prod_{k\\in\\hat{K}}(S_{k})^{v_{k}}\\Leftrightarrow</span> (17) <span class="math">c\\big{/}\\prod_{k\\in\\hat{K}}(S_{k})^{v_{k}}</span> <span class="math">=(\\Lambda_{K\\cup\\hat{K}})^{e_{K\\setminus K}e_{\\hat{K}}}\\prod_{k\\in K\\setminus\\hat{K}}(S_{k})^{v_{k}}\\Leftrightarrow</span> (18) <span class="math">\\left(c\\big{/}\\prod_{k\\in\\hat{K}}(S_{k})^{v_{k}}\\right)^{1/e_{\\hat{K}}}</span> <span class="math">=(\\Lambda_{K\\cup\\hat{K}})^{e_{K\\setminus K}}\\left(\\prod_{k\\in K\\setminus\\hat{K}}(S^{1/e_{k}})^{v_{k}}\\right)^{1/e_{\\hat{K}}}\\Leftrightarrow</span> (19) <span class="math">\\Lambda_{\\hat{K}}</span> <span class="math">=(\\Lambda_{K\\cup\\hat{K}})^{e_{K\\setminus K}}\\prod_{k\\in K\\setminus\\hat{K}}\\left((S^{1/e_{\\hat{K}}})^{v_{k}}\\right)^{1/e_{k}}\\Leftrightarrow</span> (20) <span class="math">c^{\\prime}</span> <span class="math">=(\\Lambda_{K\\cup\\hat{K}})^{e_{K\\setminus\\hat{K}}}\\prod_{k\\in K\\setminus\\hat{K}}((S^{\\prime})^{1/e_{k}})^{v_{k}}</span> (21)</p>

    <p class="text-gray-300">Thus, we can set <span class="math">\\pi^{\\prime}_{K\\setminus\\hat{K}}=\\pi_{K\\cup\\hat{K}}</span> as the new updated proof for all keys in <span class="math">K\\setminus\\hat{K}</span>.</p>

    <p class="text-gray-300">Cross-incremental (dis)aggregation. Suppose we are given <span class="math">m</span> aggregated proofs <span class="math">\\pi_{i}</span> for keys <span class="math">k\\in K_{i}</span> with values <span class="math">v=V_{i}(k)</span>, where each <span class="math">\\pi_{i}</span> is w.r.t. its own digest <span class="math">d_{i}</span>. We would like to cross-aggregate <em>[10]</em> these proofs into a single, constant-sized proof <span class="math">\\pi</span> that verifies against these <span class="math">m</span> digests and the <span class="math">(K_{i},V_{i})</span>’s. Let <span class="math">d_{i}=(c_{i},A_{i})</span> and <span class="math">\\pi_{i}=(W_{i},\\Lambda_{i})</span> where <span class="math">W_{i}=A_{i}^{1/e_{K_{i}}}</span>.</p>

    <p class="text-gray-300">Our first difficulty is that we must cross-aggregate all of the RSA subset witnesses <span class="math">W_{i}</span> into a single witness that verifies w.r.t. to the <span class="math">m</span> different <span class="math">A_{i}</span> accumulators. This seems possible using a PoKCR proof (see Section 2.2), similar to how RSA accumulator witnesses were cross-aggregated in Section 2.4.1. Unfortunately, these techniques require that <span class="math">\\gcd(e_{K_{i}},e_{K_{j}})=1,\\forall i,j</span>, which is not necessarily the case when the <span class="math">K_{i}</span>’s share common keys. Our key observation is that we can ensure this GCD property holds by requiring that all keys in <span class="math">K_{i}</span>’s be hashed with a <span class="math">K_{i}</span>-specific hash function <span class="math">H_{i}</span>. This ensures that the same <span class="math">k\\in K_{i}\\cap K_{j}</span> gets mapped to two different prime representatives, which in turn ensures <span class="math">\\gcd(e_{K_{i}},e_{K_{j}})=1,\\forall i,j</span>. Put differently, the public parameters for the <span class="math">i</span>th AD with digest <span class="math">d_{i}</span> must have its own, unique hash function <span class="math">H_{i}</span></p>

    <p class="text-gray-300">We are now left with cross-aggregating the <span class="math">\\Lambda_{i}</span>’s. Recall that each <span class="math">\\Lambda_{i}</span> would verify as <span class="math">c_{i}=\\Lambda_{i}^{e_{K_{i}}}\\prod_{k\\in K_{i}}(A_{i,k})^{V_{i}(k)}\\Leftrightarrow c_{i}/\\prod_{k\\in K_{i}}(A_{i,k})^{V_{i}(k)}=\\Lambda_{i}^{e_{K_{i}}}</span>. Thus, checking all the <span class="math">\\Lambda_{i}</span>’s is equivalent to checking a PoKCR relation holds (i.e., set <span class="math">w_{i}=\\Lambda_{i},x_{i}=e_{K_{i}}</span> and <span class="math">\\alpha_{i}=c_{i}/\\prod_{k\\in K_{i}}(A_{i,k})^{V_{i}(k)}</span> in Eq. (1)). As a result, we can aggregate the <span class="math">\\Lambda_{i}</span>’s using a PoKCR, just like the <span class="math">W_{i}</span>’s. Finally, the cross-aggregated proof <span class="math">\\pi=(W,\\Lambda)</span> can be computed in <span class="math">O(m)</span> group operations as <span class="math">W=\\prod_{i\\in[m]}W_{i}</span> and <span class="math">\\Lambda=\\prod_{i\\in[m]}\\Lambda_{i}</span>. <em>Verifying cross-aggregated proofs.</em> Let <span class="math">e^{<em>}=\\prod_{i\\in[m]}e_{K_{i}}</span> where <span class="math">e_{K_{i}}=\\prod_{k\\in K_{i}}H_{i}(k)</span>. One first verifies the cross-aggregated RSA subset witness <span class="math">W</span> via <span class="math">W^{e^{</em>}}\\stackrel{{\\scriptstyle<em>}}{{=}}\\prod_{i\\in[m]}A_{i}^{e^{</em>}/e_{K_{i}}}=\\mathsf{MultiRootExp}((A_{i})_{i\\in[m]}</span>, <span class="math">(e_{K_{i}})_{i\\in[m]})</span> (similar to Section 2.4.1). Second, the verifier extracts all <span class="math">W_{i}</span>’s from <span class="math">W</span> such that <span class="math">W_{i}^{e_{K_{i}}}=A_{i}</span> via <span class="math">\\mathsf{PoKCR.Extract}(W,(A_{i})_{i\\in[m]}</span>, <span class="math">(e_{K_{i}})_{i\\in[m]})</span> from Section 3.1. Importantly, this takes <span class="math">O(\\ell bm\\log^{2}(bm))</span> group operations (rather than <span class="math">O(\\ell bm^{2})</span>, if done naively). Third, the verifier computes, for all <span class="math">i\\in[m]</span>, <span class="math">(A_{i,k})_{k\\in K_{i}}\\leftarrow\\mathsf{RootFactor}(W_{i},(H_{i}(k))_{k\\in K_{i}})</span>, where <span class="math">A_{i,k}=W_{i}^{e_{K_{i}}/H_{i}(k)}=A_{i}^{1/H_{i}(k)}</span>. Last, the verifier checks if <span class="math">\\Lambda^{e^{<em>}}=\\prod_{i\\in[m]}(\\alpha_{i})^{e^{</em>}/e_{K_{i}}}=\\mathsf{MultiRootExp}(\\bm{\\alpha}</span>, <span class="math">(e_{K_{i}})_{i\\in[m]})</span>, where <span class="math">\\alpha_{i}=c_{i}/\\prod_{k\\in K_{i}}(A_{i,k})^{V_{i}(k)}</span>. The total verification time is dominated by the <span class="math">O(\\ell bm\\log^{2}\\ell bm)</span> group operations from <span class="math">\\mathsf{PoKCR.Extract}</span>.</p>

    <p class="text-gray-300"><em>Soundness of cross-aggregation.</em> Recall that all the aggregated lookup proofs <span class="math">\\pi_{i}=(W_{i},\\Lambda_{i})</span>’s can be extracted from a cross-aggregated proof <span class="math">(W,\\Lambda)</span> via <span class="math">\\mathsf{PoKCR.Extract}</span>. This means that, two cross-aggregated proofs <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> that are inconsistent for some <span class="math">k\\in K_{i}\\cap K_{j}^{\\prime}</span> can be used to obtain two inconsistent aggregated lookup proofs <span class="math">\\pi_{i}</span> and <span class="math">\\pi_{j}^{\\prime}</span> for <span class="math">K_{i}</span> and <span class="math">K_{j}^{\\prime}</span>, respectively, w.r.t. the same digest <span class="math">d_{i}=d_{j}^{\\prime}</span>. As a result, the security reduction from Appendix B.3 can be used to break the Strong RSA assumption.</p>

    <p class="text-gray-300"><em>Incremental (dis)aggregation.</em> Since the <span class="math">W_{i}</span>’s and <span class="math">\\Lambda_{i}</span>’s can be recovered from the cross-aggregated proof <span class="math">(W,\\Lambda)</span> via <span class="math">\\mathsf{PoKCR.Extract}</span>, our construction also supports <em>disaggregation</em> of cross-aggregated lookup proofs. Furthermore, cross-aggregation can be done <em>incrementally</em> as follows. Assume we are given two cross-aggregated proofs <span class="math">\\pi,\\pi^{\\prime}</span> that verify against <span class="math">(\\mathsf{vrk}_{i},d_{i},K_{i},V_{i})_{i\\in[m]}</span> and <span class="math">(\\mathsf{vrk}_{i}^{\\prime},d_{i}^{\\prime},K_{i}^{\\prime},V_{i}^{\\prime})_{i\\in[m^{\\prime}]}</span>, we can combine them as follows. If <span class="math">\\mathsf{vrk}_{i}\\neq\\mathsf{vrk}_{j}^{\\prime},\\forall i\\in[m],j\\in[m^{\\prime}]</span>, then we can simply multiply the two proofs together. Otherwise, for each <span class="math">i,j</span> where <span class="math">\\mathsf{vrk}_{i}=\\mathsf{vrk}_{j}^{\\prime}</span> and <span class="math">d_{i}=d_{j}^{\\prime}</span>, we extract <span class="math">\\pi_{i}</span> from <span class="math">\\pi</span> and <span class="math">\\pi_{j}^{\\prime}</span> from <span class="math">\\pi^{\\prime}</span> via <span class="math">\\mathsf{PoKCR.Extract}</span> and remove them from <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span>. (Since we cannot cross-aggregate across different digests with the same <span class="math">\\mathsf{vrk}</span>, we require that <span class="math">d_{i}=d_{j}^{\\prime}</span>.) Then, we aggregate <span class="math">\\pi_{i}</span> and <span class="math">\\pi_{j}^{\\prime}</span> together via <span class="math">\\mathsf{CFG.Agg}</span> into a <span class="math">\\pi_{i,j}</span>. Finally, we add <span class="math">\\pi_{i,j}</span> back into either <span class="math">\\pi</span> or <span class="math">\\pi^{\\prime}</span> (but not both). After repeating this for all <span class="math">i,j</span> where <span class="math">\\mathsf{vrk}_{i}=\\mathsf{vrk}_{j}^{\\prime}</span>, <span class="math">\\pi</span> and <span class="math">\\pi^{\\prime}</span> will not share any verification keys and can be aggregated by multiplying them as before.</p>

    <p class="text-gray-300"><em>Updatability.</em> As a consequence of disaggregation, our cross-aggregated proofs can be updated by disaggregating them, updating the aggregated proof and re-aggregating them.</p>

    <h3 id="sec-20" class="text-xl font-semibold mt-8">4.3 Append-only Authenticated Dictionary for Transparency Logs</h3>

    <p class="text-gray-300">In this subsection, we extend our updatable authenticated dictionary (UAD) from Section 4.2 with strong key binding, <em>non-membership proofs</em>, and append-only proofs. An <em>append-only proof</em> <em>[29]</em> can convince any verifier that a dictionary <span class="math">D</span> is a subset of <span class="math">D^{\\prime}</span>, meaning all key-value pairs in <span class="math">D</span> are also in <span class="math">D^{\\prime}</span>. This gives us an <em>append-only authenticated dictionary (AAD)</em>, which can be used for transparency logging <em>[23, 29, 17, 7]</em> as well as any other application with stronger security requirements, where our UAD’s weak binding does not suffice.</p>

    <p class="text-gray-300">However, adding strong key binding comes at a cost. First, our AAD no longer supports incremental (dis)aggregation of proofs nor cross-aggregation. Instead, it only supports <em>“one-hop” proof aggregation</em> <em>[3]</em>, or aggregating <span class="math">b</span> individual lookup proofs into a constant-sized, aggregated proof. Second, while such aggregated proofs can still be updated after changes to existing keys’ values, they can no longer be updated after adding keys to or removing keys from the dictionary. Nonetheless, our AAD maintains full updatability of individual proofs, updatability of digests and efficient pre-computation of all proofs.</p>

    <p class="text-gray-300">Strong binding. To prove security against adversaries that output arbitrary digests, we need to augment our lookup proofs. Specifically, in addition to <span class="math">(S_{k},\\Lambda_{k})</span>, we include an additional RSA non-membership witness <span class="math">(a_{k},B_{k})</span> for <span class="math">k</span> w.r.t. to <span class="math">S_{k}</span> (since <span class="math">S_{k}</span> can also be seen as an RSA accumulator too). To verify the proof <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k},a_{k},B_{k})</span> for <span class="math">(k,v_{k})</span> against the digest <span class="math">d=(c,S)</span>, the verifier checks <span class="math">S_{k}</span> and <span class="math">\\Lambda_{k}</span> as explained in Section 4.2 and additionally checks that <span class="math">(S_{k})^{a_{k}}\\left(B_{k}\\right)^{e_{k}}=g</span>.</p>

    <p class="text-gray-300">Non-membership proofs. A non-membership proof <span class="math">\\pi_{k}</span> for key <span class="math">k</span> is a non-membership of <span class="math">e_{k}</span> in the RSA accumulator <span class="math">S</span> (see Section 2.4.2). Specifically, <span class="math">\\pi_{k}=(\\bot,\\bot,a_{k},B_{k})</span> where <span class="math">S^{a_{k}}\\left(B_{k}\\right)^{e_{k}}=g</span>. The verifier can easily check the proof satisfies the equation above in <span class="math">O(\\ell)</span> group operations.</p>

    <p class="text-gray-300">Aggregating lookup proofs. Aggregation works as before, except we must now account for the additional RSA non-membership witnesses <span class="math">(a_{k},B_{k})</span> used for key binding or for non-membership. Given lookup proofs <span class="math">(\\pi_{k})_{k\\in K}</span>, we partition the set of keys <span class="math">K</span> into two sets: (1) <span class="math">K_{1}</span>, the set of keys <span class="math">k</span> with values <span class="math">v_{k}\\neq\\bot</span> in the dictionary, and (2) <span class="math">K_{0}</span>, the set of keys that are not in the dictionary (i.e., <span class="math">v_{k}=\\bot</span>). Recall that <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k},a_{k},B_{k})</span>, with <span class="math">S_{k}</span> and <span class="math">\\Lambda_{k}</span> set to <span class="math">\\bot</span>, when proving non-membership.</p>

    <p class="text-gray-300">For <span class="math">k\\in K_{0}</span>: In this case, recall that <span class="math">(a_{k},B_{k})</span> is just an RSA non-membership witness for <span class="math">e_{k}</span> w.r.t. the accumulator <span class="math">S</span>, which we can aggregate as <span class="math">\\pi_{K_{0}}=\\textsf{Acc.NonMemWitAgg}(S,(a_{k},B_{k},e_{k})_{k\\in K_{0}})</span> (see Fig. 4). This does come at the cost of using a PoKE proof (see Section 2.3), which impedes both incremental (dis)aggregation and updating aggregated proofs when keys are removed or added to the dictionary (which changes <span class="math">S</span> and thus <span class="math">(a_{k},B_{k})</span>).</p>

    <p class="text-gray-300">For <span class="math">k\\in K_{1}</span>: First, the <span class="math">(S_{k},\\Lambda_{k})</span>’s can be aggregated into <span class="math">(S_{K_{1}},\\Lambda_{K_{1}})</span> as explained in Section 4.2. Next, recall that <span class="math">(a_{k},B_{k})</span> is an RSA non-membership witness for <span class="math">e_{k}</span> w.r.t. to <span class="math">S_{k}</span> (not w.r.t. <span class="math">S</span>, as was the case for <span class="math">k\\in K_{0}</span>). We combine all <span class="math">(a_{k},B_{k})</span>’s into a disjointness witness for <span class="math">e_{K_{1}}</span> w.r.t. <span class="math">S_{K_{1}}</span> as <span class="math">\\pi_{K_{1}}\\leftarrow\\textsf{Acc.NonMemWitCrossAgg}((a_{k},B_{k},e_{k},S_{k})_{k\\in K_{1}})</span> (see Section 3.3). In Appendix B.3, we show this is enough for strong key binding. Note that this aggregation also comes at the cost of using a PoKE proof.</p>

    <p class="text-gray-300">The final aggregated proof is <span class="math">\\pi_{K}=(S_{K_{1}},\\Lambda_{K_{1}},\\pi_{K_{1}},\\pi_{K_{0}})</span>, and verifies as:</p>

    <p class="text-gray-300"><span class="math">S</span> <span class="math">=(S_{K_{1}})^{e_{K_{1}}}</span> (22) <span class="math">S_{k}</span> <span class="math">=S^{1/e_{k}},\\forall k\\in K_{1},\\text{ computed via RootFactor}(S_{K_{1}},(e_{k})_{k\\in K_{1}})</span> (23) <span class="math">c</span> <span class="math">=\\prod_{k\\in K_{1}}(S_{k})^{v_{k}}(\\Lambda_{K_{1}})^{e_{K_{1}}}</span> (24) <span class="math">1</span> <span class="math">=\\textsf{Acc.NonMemWitAggVer}(S_{K_{1}},\\pi_{K_{1}},(e_{k})_{k\\in K_{1}})\\text{ (see Fig. 4)}</span> (25) <span class="math">1</span> <span class="math">=\\textsf{Acc.NonMemWitAggVer}(S,\\pi_{K_{0}},(e_{k})_{k\\in K_{0}})</span> (26)</p>

    <p class="text-gray-300">Updating individual proofs. Let <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k},a_{k},B_{k})</span> be an individual lookup proof for a single key-value pair <span class="math">(k,v)</span> w.r.t. digest <span class="math">d=(c,S)</span>. The updated proof will be <span class="math">\\pi^{\\prime}_{k}=(S^{\\prime}_{k},\\Lambda^{\\prime}_{k},a^{\\prime}_{k},B^{\\prime}_{k})</span>, computed as follows, based on two cases.</p>

    <p class="text-gray-300">Case 1: Adding a new key-value pair <span class="math">(\\hat{k},\\hat{v})</span>. If <span class="math">v\\neq\\bot</span>, then <span class="math">(S^{\\prime}_{k},\\Lambda^{\\prime}_{k})</span> are computed as before in Section 4.2, while <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})=\\textsf{Acc.NonMemWitUpdAdd}(S_{k},a_{k},B_{k},e_{k},e_{\\hat{k}})</span>. If <span class="math">v=\\bot</span>, then <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})=\\textsf{Acc.NonMemWitUpdAdd}(S,a_{k},B_{k},e_{k},e_{\\hat{k}})</span>.</p>

    <p class="text-gray-300">Case 2: Changing existing key <span class="math">\\hat{k}</span>’s value by <span class="math">\\hat{\\delta}</span>. If <span class="math">v\\neq\\bot</span>, the proof update is done as explained in Section 4.2. Otherwise, if <span class="math">v=\\bot</span>, then the non-membership proof <span class="math">\\pi_{k}</span> remains the same (since only <span class="math">c</span>, not <span class="math">S</span>, changed in the digest). Note that, in this case, our AAD also supports updating aggregated lookup proofs <span class="math">\\pi_{K}=(S_{K},\\Lambda_{K},a_{K},B_{K})</span>, since a change to one or more keys <span class="math">\\hat{k}</span> does not affect the <span class="math">(a_{K},B_{K})</span> part of the proof (which cannot be updated due to its use of PoKE proofs).</p>

    <p class="text-gray-300">Case 3: Removing a key <span class="math">\\hat{k}</span> with value <span class="math">\\hat{v}</span>. If <span class="math">k=\\hat{k}</span>, then, we must update the lookup proof for <span class="math">(k,v)</span> to a non-membership proof for <span class="math">k</span>. Recall that <span class="math">\\pi_{k}</span> contains a non-membership witness <span class="math">(a_{k},B_{k})</span> w.r.t. the RSA accumulator <span class="math">S_{k}</span>. Importantly, observe that the new digest <span class="math">d^{\\prime}=(c^{\\prime},S^{\\prime})</span>, after removing <span class="math">k</span>, has exactly <span class="math">S^{\\prime}=S_{k}</span>. Thus, we simply set <span class="math">\\pi^{\\prime}_{k}=(\\bot,\\bot,a_{k},B_{k})</span>. Otherwise, if <span class="math">k\\neq\\hat{k}</span>, we have two cases based on whether <span class="math">\\pi_{k}</span> is a non-membership proof.</p>

    <p class="text-gray-300">Subcase <span class="math">k\\neq\\hat{k}</span> and <span class="math">v=\\bot</span>. In this subcase, we have to update the <span class="math">(a_{k},B_{k})</span> non-membership witness for <span class="math">e_{k}</span> w.r.t. <span class="math">S</span> to be a witness w.r.t. <span class="math">S^{\\prime}=S_{\\hat{k}}</span> as <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})=\\textsf{Acc.NonMemWitUpdDel}(S,S^{\\prime},a_{k},B_{k},e_{k},e_{\\hat{k}})</span>. If multiple keys <span class="math">\\hat{k}\\in R</span> are removed, then recall from Section 4.2 that the new digest has <span class="math">S^{\\prime}=S^{1/e_{R}}</span>. Thus, we can update the proof as <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})=\\textsf{Acc.NonMemWitUpdDel}(S,S^{\\prime},a_{k},B_{k},e_{k},e_{R})</span>. (Note that an aggregated proof <span class="math">\\pi_{R}</span> for all <span class="math">\\hat{k}\\in R</span> would suffice in this case, since it contains <span class="math">S_{R}=S^{1/e_{R}}=S^{\\prime}</span>.)</p>

    <p class="text-gray-300">Subcase <span class="math">k\\neq\\hat{k}</span> and <span class="math">v\\neq\\bot</span>. In this subcase, <span class="math">S^{\\prime}_{k}</span> and <span class="math">\\Lambda^{\\prime}_{k}</span> are updated as explained in Section 4.2. Then, the <span class="math">(a_{k},B_{k})</span> non-membership witness for <span class="math">e_{k}</span> w.r.t. <span class="math">S_{k}</span> is updated into a witness w.r.t. <span class="math">S_{k,\\hat{k}}=\\textsf{ShamirTrick}(S_{k},S_{\\hat{k}},e_{k},e_{\\hat{k}})</span>. This can be done as <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})=\\textsf{Acc.NonMemWitUpdDel}(S_{k},S_{k,\\hat{k}},a_{k},B_{k},e_{k},e_{\\hat{k}})</span>. If multiple keys <span class="math">\\hat{k}\\in R</span> are being</p>

    <p class="text-gray-300">removed, this is handled as in the previous subcase by computing <span class="math">S_{R,k}=(S_{R})^{1/e_{k}}=\\mathsf{ShamirTrick}(S_{R},S_{k},e_{R},e_{k})</span> and then setting <span class="math">(a_{k}^{\\prime},B_{k}^{\\prime})=\\mathsf{Acc.NonMemWitUpdDel}(S_{k},S_{R,k},a_{k},B_{k},e_{k},e_{R})</span>. As in the previous subcase, an aggregate proof <span class="math">\\pi_{R}</span> for all <span class="math">\\hat{k}\\in R</span> suffices.</p>

    <p class="text-gray-300">Append-only proofs. Suppose new key-value pairs <span class="math">(k,v_{k})_{k\\in K}</span> were added to the dictionary with digest <span class="math">d=(c,S)</span>, obtaining a new digest <span class="math">d^{\\prime}=(c^{\\prime},S^{\\prime})</span>. Then, note that <span class="math">S^{\\prime}=S^{e_{K}}</span> and <span class="math">c^{\\prime}=c^{e_{K}}\\prod_{k\\in K}(S^{\\prime})^{\\frac{e_{k}}{e_{k}}}=c^{e_{K}}\\prod_{k\\in K}(S^{e_{K}})^{\\frac{e_{k}}{e_{k}}}=c^{e_{K}}S^{\\sum_{k\\in K}v_{i}\\cdot\\frac{e_{K}}{e_{k}}}</span> Let <span class="math">z=\\sum_{k\\in K}v_{i}\\cdot e_{K\\setminus\\{k\\}}</span>. The append-only proof <span class="math">\\pi</span> between <span class="math">d=(c,S)</span> and <span class="math">d=(c^{\\prime},S^{\\prime})</span> consists of three PoKE proofs. Specifically, <span class="math">\\pi_{\\subseteq}^{\\mathsf{PoKE}}=\\mathsf{PoKE.Prove}(S^{\\prime},S,u)</span>, <span class="math">\\pi_{u}^{\\mathsf{PoKE}}=\\mathsf{PoKE.Prove}(c^{u},c,u)</span> and <span class="math">\\pi_{z}^{\\mathsf{PoKE}}=\\mathsf{PoKE.Prove}(S^{z},S,z)</span>. Note that these PoKE proofs can be further compressed via the PoKCR protocol <em>[3]</em>. The final append-only proof is <span class="math">\\pi=(\\pi_{\\subseteq}^{\\mathsf{PoKE}},U,\\pi_{u}^{\\mathsf{PoKE}},Z,\\pi_{z}^{\\mathsf{PoKE}})</span>, where <span class="math">U=c^{u}</span>, <span class="math">Z=S^{z}</span>.</p>

    <p class="text-gray-300">To verify <span class="math">\\pi</span>, one checks if <span class="math">c^{\\prime}=UZ,\\mathsf{PoKE.Ver}(S^{\\prime},S,\\pi_{\\subseteq}^{\\mathsf{PoKE}})\\stackrel{{\\scriptstyle?}}{{=}}1</span>, <span class="math">\\mathsf{PoKE.Ver}(U,c,\\pi_{u}^{\\mathsf{PoKE}})\\stackrel{{\\scriptstyle?}}{{=}}1</span> and <span class="math">\\mathsf{PoKE.Ver}(Z,S,\\pi_{z}^{\\mathsf{PoKE}})\\stackrel{{\\scriptstyle?}}{{=}}1</span>. We stress that our UAD from Section 4.2 also supports this type of append-only proof, as highlighted in Table 1.</p>

    <p class="text-gray-300">Computing all lookup proofs fast. To compute all <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k},a_{k}</span>, <span class="math">B_{k})</span> efficiently, first, the <span class="math">S_{k}</span>’s and <span class="math">\\Lambda_{k}</span>’s can be computed as before in Section 4.2. Second, each <span class="math">(a_{k},B_{k})</span> is an RSA non-membership witness for <span class="math">e_{k}</span> w.r.t. <span class="math">S_{k}=S^{1/e_{k}}</span> and, as we have shown in Section 3.2, we can compute all of them in <span class="math">O(\\ell n\\log n)</span> group operations via <span class="math">\\mathsf{Acc.NonMemWitCrossAgg}(g,(e_{k})_{k\\in D})</span>.</p>

    <h2 id="sec-21" class="text-2xl font-bold">5 Future Work</h2>

    <p class="text-gray-300">Our work leaves several interesting open questions. First, can we build an AD with strong key binding and cross-incremental (dis)aggregation of proofs? Second, can we eliminate the need for auxiliary information during updates in such an AD? Third, can we de-amortize <em>[19]</em> and efficiently pre-compute all non-membership proofs? Lastly, we did not formalize nor prove append-only security with cross-aggregated proofs but, since cross-aggregated proofs can be disaggregated, security follows naturally as argued in Section 4.3.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">References</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] S. Agrawal and S. Raghuraman. KVaC: Key-Value Commitments for Blockchains and Beyond. Cryptology ePrint Archive, Report 2020/1161, 2020. https://eprint.iacr.org/2020/1161.</li>

      <li>[2] J. Benaloh and M. de Mare. One-Way Accumulators: A Decentralized Alternative to Digital Signatures. In T. Helleseth, editor, EUROCRYPT ’93, pages 274–285, Berlin, Heidelberg, 1994. Springer Berlin Heidelberg.</li>

      <li>[3] D. Boneh, B. Bünz, and B. Fisch. Batching Techniques for Accumulators with Applications to IOPs and Stateless Blockchains. Cryptology ePrint Archive, Report 2018/1188, 2018. https://eprint.iacr.org/2018/1188.</li>

      <li>[4] M. Campanelli, D. Fiore, N. Greco, D. Kolonelos, and L. Nizzardo. Vector Commitment Techniques and Applications to Verifiable Decentralized Storage. Cryptology ePrint Archive, Report 2020/149, 2020. https://eprint.iacr.org/2020/149.</li>

      <li>[5] D. Catalano and D. Fiore. Vector Commitments and Their Applications. In K. Kurosawa and G. Hanaoka, editors, Public-Key Cryptography – PKC 2013, pages 55–72, Berlin, Heidelberg, 2013. Springer Berlin Heidelberg.</li>

      <li>[6] A. Chepurnoy, C. Papamanthou, and Y. Zhang. Edrax: A Cryptocurrency with Stateless Transaction Validation, 2018. https://eprint.iacr.org/2018/968.</li>

      <li>[7] S. A. Crosby and D. S. Wallach. Efficient Data Structures for Tamper-Evident Logging. In Proceedings of the 18th Conference on USENIX Security Symposium, SSYM’09, page 317–334, USA, 2009. USENIX Association.</li>

      <li>[8] I. Damgård and M. Koprowski. Generic Lower Bounds for Root Extraction and Signature Schemes in General Groups. In L. R. Knudsen, editor, Advances in Cryptology — EUROCRYPT 2002, pages 256–271, Berlin, Heidelberg, 2002. Springer Berlin Heidelberg.</li>

      <li>[9] A. J. Feldman, A. Blankstein, M. J. Freedman, and E. W. Felten. Social Networking with Frientegrity: Privacy and Integrity with an Untrusted Provider. In Proceedings of the 21st USENIX Conference on Security Symposium, Security’12, page 31, USA, 2012. USENIX Association.</li>

      <li>[10] S. Gorbunov, L. Reyzin, H. Wee, and Z. Zhang. Pointproofs: Aggregating Proofs for Multiple Vector Commitments, 2020. https://eprint.iacr.org/2020/419.</li>

      <li>[11] N. Karapanos, A. Filios, R. A. Popa, and S. Capkun. Verena: End-to-End Integrity Protection for Web Applications. In 2016 IEEE Symposium on Security and Privacy (SP), pages 895–913, May 2016.</li>

      <li>[12] R. W. Lai and G. Malavolta. Subvector Commitments with Application to Succinct Arguments. Cryptology ePrint Archive, Report 2018/705, 2018. https://eprint.iacr.org/2018/705.</li>

      <li>[13] R. W. F. Lai and G. Malavolta. Subvector Commitments with Application to Succinct Arguments. In A. Boldyreva and D. Micciancio, editors, Advances in Cryptology – CRYPTO 2019, pages 530–560, Cham, 2019. Springer International Publishing.</li>

      <li>[14] D. Leung, Y. Gilad, S. Gorbunov, L. Reyzin, and N. Zeldovich. Aardvark: A Concurrent Authenticated Dictionary with Short Proofs. Cryptology ePrint Archive, Report 2020/975, 2020. https://eprint.iacr.org/2020/975.</li>

      <li>[15] J. Li, M. Krohn, D. Mazières, D. Shasha, and D. Shasha. Secure Untrusted Data Repository (SUNDR). In Proceedings of the 6th Conference on Symposium on Operating Systems Design & Implementation - Volume 6, OSDI’04, pages 9–9, Berkeley, CA, USA, 2004. USENIX Association.</li>

      <li>[16] J. Li, N. Li, and R. Xue. Universal Accumulators with Efficient Nonmembership Proofs. In J. Katz and M. Yung, editors, Applied Cryptography and Network Security, pages 253–269, Berlin, Heidelberg, 2007. Springer Berlin Heidelberg.</li>

    </ul>

    <p class="text-gray-300">[17] M. S. Melara, A. Blankstein, J. Bonneau, E. W. Felten, and M. J. Freedman. CONIKS: Bringing Key Transparency to End Users. In 24th USENIX Security Symposium (USENIX Security 15), pages 383–398, Washington, D.C., August 2015. USENIX Association.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[18] L. Nguyen. Accumulators from Bilinear Pairings and Applications. In A. Menezes, editor, CT-RSA ’05, pages 275–292, Berlin, Heidelberg, 2005. Springer Berlin Heidelberg.</li>

      <li>[19] M. H. Overmars and J. van Leeuwen. Worst-case optimal insertion and deletion methods for decomposable searching problems. Information Processing Letters, 12(4):168 – 173, 1981.</li>

      <li>[20] C. Papamanthou, E. Shi, R. Tamassia, and K. Yi. Streaming Authenticated Data Structures. In T. Johansson and P. Q. Nguyen, editors, Advances in Cryptology – EUROCRYPT 2013, pages 353–370, Berlin, Heidelberg, 2013. Springer Berlin Heidelberg.</li>

      <li>[21] C. Papamanthou, R. Tamassia, and N. Triandopoulos. Authenticated Hash Tables Based on Cryptographic Accumulators. Algorithmica, 74(2):664–712, 2016.</li>

      <li>[22] R. L. Rivest, A. Shamir, and L. Adleman. A method for obtaining digital signatures and public-key cryptosystems. Communications of the ACM, 21(2):120–126, feb 1978.</li>

      <li>[23] M. D. Ryan. Enhanced certificate transparency and end-to-end encrypted mail. In NDSS’14, February 2014.</li>

      <li>[24] T. Sander, A. Ta-Shma, and M. Yung. Blind, Auditable Membership Proofs. In Y. Frankel, editor, Financial Cryptography, pages 53–71, Berlin, Heidelberg, 2001. Springer Berlin Heidelberg.</li>

      <li>[25] A. Schönhage. Schnelle Berechnung Von Kettenbruchentwicklungen. Acta Inf., 1(2):139–144, June 1971.</li>

      <li>[26] A. Shamir. On the generation of cryptographically strong pseudo-random sequences. In S. Even and O. Kariv, editors, Automata, Languages and Programming, pages 544–550, Berlin, Heidelberg, 1981. Springer Berlin Heidelberg.</li>

      <li>[27] A. Tomescu. How to Keep a Secret and Share a Public Key (Using Polynomial Commitments). PhD thesis, Massachusetts Institute of Technology, Cambridge, MA, USA, 2020.</li>

      <li>[28] A. Tomescu, I. Abraham, V. Buterin, J. Drake, D. Feist, and D. Khovratovich. Aggregatable Subvector Commitments for Stateless Cryptocurrencies. In C. Galdi and V. Kolesnikov, editors, Security and Cryptography for Networks, pages 45–64, Cham, 2020. Springer International Publishing.</li>

      <li>[29] A. Tomescu, V. Bhupatiraju, D. Papadopoulos, C. Papamanthou, N. Triandopoulos, and S. Devadas. Transparency Logs via Append-Only Authenticated Dictionaries. In ACM CCS’19, CCS ’19, page 1299–1316, New York, NY, USA, 2019. Association for Computing Machinery.</li>

      <li>[30] G. Wood. Ethereum: A secure decentralised generalised transaction ledger. https://gavwood.com/paper.pdf, 2014.</li>

    </ul>

    <p class="text-gray-300">A Updating RSA Non-membership Witnesses</p>

    <p class="text-gray-300">In this section, we explain why the algorithms for updating RSA non-membership witnesses from Fig. 3 work. Suppose we have an RSA accumulator <span class="math">c=g^{\\prod_{e\\in T}e}=g^{u}</span> over a set <span class="math">T</span> (of prime representatives). Suppose <span class="math">x\\nmid u</span>, so <span class="math">x</span> is not in the RSA accumulator <span class="math">c</span>. Then, a non-membership witness for <span class="math">x</span> consists of (commitments to) Bézout coefficients <span class="math">(a,b)</span> such that <span class="math">au+bx=1</span>. Specifically, the witness is <span class="math">\\pi_{x}=(a,B=g^{b})</span> and verifies as:</p>

    <p class="text-gray-300"><span class="math">c^{a}B^{x}=g\\Rightarrow g^{ua}g^{bx}=1\\Rightarrow au+bx=1</span> (27)</p>

    <p class="text-gray-300">Updates after adding an element <span class="math">\\bm{x^{\\prime}}</span>. Next, suppose we added a new element <span class="math">x^{\\prime}</span> to the set, obtaining a new accumulator <span class="math">c^{\\prime}=c^{x^{\\prime}}=g^{ux^{\\prime}}</span>. We would like to update the Bézout coefficients <span class="math">(a,b)</span> from <span class="math">\\pi_{x}</span> to <span class="math">(a^{\\prime},B^{\\prime}=g^{b^{\\prime}})</span> such that <span class="math">(c^{\\prime})^{a^{\\prime}}\\left(B^{\\prime}\\right)^{x}=g</span>. Since <span class="math">x</span> and <span class="math">x^{\\prime}</span> are both primes, we have <span class="math">\\gcd(x,x^{\\prime})=1</span>. Thus, <span class="math">\\exists s,t</span> such that <span class="math">sx+tx^{\\prime}=1</span>, which implies <span class="math">a=asx+atx^{\\prime}</span>. Replacing in Eq. (27), we get:</p>

    <p class="text-gray-300"><span class="math">c^{asx+atx^{\\prime}}B^{x}=g\\Leftrightarrow(c^{as})^{x}(c^{x^{\\prime}})^{at}B^{x}=g\\Leftrightarrow(c^{\\prime})^{at}(c^{as}B)^{x}=g</span> (28)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">However, note that if we let <span class="math">a^{\\prime}=at</span>, then <span class="math">a^{\\prime}</span> would be of size $2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and would keep getting larger after subsequent witness updates. Therefore, we would like to reduce its size back to </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">x</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">. We can do this easily, by reducing it modulo </span>x<span class="math">! Specifically, </span>\\exists q,r<span class="math"> with </span>r<x<span class="math"> such that </span>at=qx+r$. Thus, we get:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(c^{\\prime})^{qx+r}(c^{as}B)^{x}=g</span> (29) <span class="math">(c^{\\prime})^{r}(c^{x^{\\prime}})^{qx}(c^{as}B)^{x}=g</span> (30) <span class="math">(c^{\\prime})^{r}((c^{\\prime})^{q}c^{as}B)^{x}=g</span> (31) <span class="math">(c^{\\prime})^{r}(c^{qx^{\\prime}+as}B)^{x}=g</span> (32)</p>

    <p class="text-gray-300">As a result, to update the witness for <span class="math">x</span> after adding <span class="math">x^{\\prime}</span> co-prime with <span class="math">x</span> such that <span class="math">\\exists s,t,sx+tx^{\\prime}=1</span>, we let <span class="math">a^{\\prime}=r</span> and <span class="math">B^{\\prime}=c^{qx^{\\prime}+as}B</span> as in Fig. 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Updates after deleting an element <span class="math">\\bm{x^{\\prime}}</span>. Next, suppose we deleted an element <span class="math">x^{\\prime}</span> from the set, obtaining a new accumulator <span class="math">c^{\\prime}=c^{1/x^{\\prime}}=g^{u/x^{\\prime}}</span>. We would like to update the Bézout coefficients <span class="math">(a,b)</span> from <span class="math">\\pi_{x}</span> to <span class="math">(a^{\\prime},B^{\\prime})</span> such that <span class="math">(c^{\\prime})^{a^{\\prime}}\\left(g^{\\beta}\\right)^{x}=g</span>. Note that we can rewrite Eq. (27) as <span class="math">c^{a}B^{x}=g\\Leftrightarrow(c^{\\prime})^{x^{\\prime}a}B^{x}=g</span>. We could let <span class="math">B^{\\prime}=B</span> and <span class="math">a^{\\prime}=x^{\\prime}a</span>, but $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">a^{\\prime}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> would be too large, so we would like to reduce </span>x^{\\prime}a<span class="math"> modulo </span>x<span class="math">! Since </span>\\exists q,r<span class="math"> such that </span>x^{\\prime}a=qx+r$, we can rewrite:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">(c^{\\prime})^{x^{\\prime}a}B^{x}=g\\Leftrightarrow(c^{\\prime})^{qx+r}B^{x}=g\\Leftrightarrow(c^{\\prime})^{r}\\left((c^{\\prime})^{q}B\\right)^{x}=g</span> (33)</p>

    <p class="text-gray-300">As a result, the updated witness is <span class="math">B^{\\prime}=(c^{\\prime})^{q}B</span> and <span class="math">a^{\\prime}=r</span> as in Fig. 3.</p>

    <h2 id="sec-22" class="text-2xl font-bold">Appendix B Security Proofs</h2>

    <h3 id="sec-23" class="text-xl font-semibold mt-8">B.1 Definitions and Cryptographic Assumptions</h3>

    <p class="text-gray-300">Our work often relies on the Strong RSA assumption, which we define below.</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Definition B.1 (Strong RSA Assumption).</h6>

    <p class="text-gray-300"><span class="math">\\mathsf{GenHidOrdGr}</span> satisfies this assumption if, <span class="math">\\forall</span> adversaries <span class="math">\\mathcal{A}</span> running in time <span class="math">\\mathsf{poly}(\\lambda)</span>:</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{c}\\mathbb{G}_{?}\\leftarrow\\mathsf{GenHidOrdGr}(1^{\\lambda}),g\\in_{R}\\mathbb{G}_{?,}\\\\ (u,e)\\leftarrow\\mathcal{A}(1^{\\lambda},\\mathbb{G}_{?,}g):\\\\ u^{e}=g\\ \\mathbf{and}\\ e\\ \\text{is prime}\\end{array}\\right]\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <p class="text-gray-300">Informally, this assumption says that no probabilistic polynomial-time (PPT) adversary can compute <em>any</em> <span class="math">e</span>th prime root of a random element <span class="math">g</span>. This is a generalization of the RSA assumption <em>[22]</em>, which says that, for a <em>fixed</em> <span class="math">e</span>, no PPT adversary can compute an <span class="math">e</span>th root of a random <span class="math">g</span></p>

    <p class="text-gray-300">Weak Key Binding. Some authenticated dictionary schemes are only secure if the digest  <span class="math">d</span>  is produced correctly, rather than adversarially. This security notion is called weak key binding and is modeled by having the adversary return a dictionary  <span class="math">D</span> , whose commitment  <span class="math">d</span>  is correctly computed. In contrast, in the strong key binding definition (see Definition 4.3), the adversary is allowed to output a digest  <span class="math">d</span>  directly, which means he could maliciously generate it.</p>

    <p class="text-gray-300">Definition B.2 (Weak Key Binding).  <span class="math">\\forall</span>  adversaries  <span class="math">\\mathcal{A}</span>  running in time poly  <span class="math">(\\lambda)</span> , there exists negligible function  <span class="math">\\mathrm{negl}(\\cdot)</span> , such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c} (\\mathsf {p r k}, \\mathsf {v r k}) \\leftarrow \\mathsf {A D . S e t u p} (1 ^ {\\lambda}), \\\\ (D, K, K ^ {\\prime}, V, V ^ {\\prime}, \\pi , \\pi^ {\\prime}) \\leftarrow \\mathcal {A} (1 ^ {\\lambda}, \\mathsf {p r k}, \\mathsf {v r k}): \\\\ d \\leftarrow \\mathsf {A D . C o m m i t} (\\mathsf {p r k}, D) \\wedge \\\\ \\mathsf {A D . V e r L o o k u p} (\\mathsf {v r k}, d, K, V, \\pi) = 1 \\wedge \\\\ \\mathsf {A D . V e r L o o k u p} (\\mathsf {v r k}, d, K ^ {\\prime}, V ^ {\\prime}, \\pi^ {\\prime}) = 1 \\wedge \\\\ \\exists k \\in K \\cap K ^ {\\prime} \\text {s . t .} V (k) \\neq V ^ {\\prime} (k) \\end{array} \\right] \\leq \\mathsf {n e g l} (\\lambda)</span></div>

    <h2 id="sec-25" class="text-2xl font-bold">B.2 Warm-up: Key Binding for Individual Proofs</h2>

    <p class="text-gray-300">First, we prove our AAD construction from Section 4.3 satisfies strong key binding (see Definition 4.3) under the Strong RSA assumption (see Definition B.1), when proofs are not aggregated: i.e., adversary outputs two inconsistent proofs for an individual key  <span class="math">k</span> . (This proof does not use the generic group model [8].)</p>

    <p class="text-gray-300">Proof. Assume an adversary  <span class="math">\\mathcal{A}</span>  breaks strong key binding and outputs a digest  <span class="math">d = (c, S)</span>  and two inconsistent proofs  <span class="math">\\pi = (S_k, \\Lambda_k, a_k, B_k), \\pi&#x27; = (S_k&#x27;, \\Lambda_k&#x27;, a_k&#x27;, B_k&#x27;)</span>  for a key  <span class="math">k</span>  having two different values  <span class="math">v</span>  and  <span class="math">v&#x27;</span> . Then, we show how to build another adversary  <span class="math">\\mathcal{B}</span>  that breaks a random Strong RSA problem instance  <span class="math">g</span>  by outputting  <span class="math">g^{1 / e_k}</span>  for some prime  <span class="math">e_k</span> . Our adversary  <span class="math">\\mathcal{B}</span>  sets up the AD scheme with prk and vrk set to  <span class="math">g</span>  and the hash function  <span class="math">H</span> . Depending on  <span class="math">v</span>  and  <span class="math">v&#x27;</span> , we have two cases.</p>

    <h2 id="sec-26" class="text-2xl font-bold">B.2.1 Case 1:  <span class="math">v \\neq \\bot</span>  and  <span class="math">v&#x27; \\neq \\bot</span></h2>

    <p class="text-gray-300">Let  <span class="math">e_k = H(k)</span>  be the prime representative of the key  <span class="math">k</span> . If both proofs pass verification, the following relations must hold:</p>

    <div class="my-4 text-center"><span class="math-block">S = S _ {k} ^ {e _ {k}} = \\left(S _ {k} ^ {\\prime}\\right) ^ {e _ {k}} \\tag {34}</span></div>

    <div class="my-4 text-center"><span class="math-block">c = \\Lambda_ {k} ^ {e _ {k}} S _ {k} ^ {v} = \\left(\\Lambda_ {k} ^ {\\prime}\\right) ^ {e _ {k}} \\left(S _ {k} ^ {\\prime}\\right) ^ {v ^ {\\prime}} \\tag {35}</span></div>

    <p class="text-gray-300">Since  <span class="math">S_{k}^{e_{k}} = (S_{k}^{\\prime})^{e_{k}}</span> , it follows that  <span class="math">S_{k} = S_{k}^{\\prime}</span> . Thus, we can rewrite Eq. (35) as:</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda_ {k} ^ {e _ {k}} S _ {k} ^ {v} = \\left(\\Lambda_ {k} ^ {\\prime}\\right) ^ {e _ {k}} S _ {k} ^ {v ^ {\\prime}} \\Leftrightarrow \\left(\\Lambda_ {k} / \\Lambda_ {k} ^ {\\prime}\\right) ^ {e _ {k}} = \\left(S _ {k}\\right) ^ {v ^ {\\prime} - v} \\Leftrightarrow \\tag {36}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\Lambda^ {e _ {k}} = \\left(S _ {k}\\right) ^ {v ^ {\\prime} - v}, \\text { where } \\Lambda = \\Lambda_ {k} / \\Lambda_ {k} ^ {\\prime} \\tag {37}</span></div>

    <p class="text-gray-300">Recall  <span class="math">\\pi</span>  contains  <span class="math">(a_{k},B_{k})</span>  such that  <span class="math">(S_{k})^{a_{k}}(B_{k})^{e_{k}} = g</span> .  <span class="math">\\mathcal{B}</span>  calls  <span class="math">(x_{k},Y_{k}) = \\mathrm{Acc.NonMemWitUpdAdd}(S_{k},a_{k},B_{k},e_{k},v^{\\prime} - v)^{1}</span>  (see Section 2.4.2). In other words,  <span class="math">\\mathcal{B}</span>  updates the non-membership witness  <span class="math">(a_{k},B_{k})</span>  for  <span class="math">e_k</span>  w.r.t. the RSA accumulator  <span class="math">S_{k}</span>  into a non-membership witness  <span class="math">(x_{k},Y_{k})</span>  for  <span class="math">e_k</span>  w.r.t. the RSA accumulator  <span class="math">(S_{k})^{v^{\\prime} - v}</span> . Thus, we have  <span class="math">(S_{k})^{(v^{\\prime} - v)x_{k}}(Y_{k})^{e_{k}} = g\\Leftrightarrow (S_{k})^{v^{\\prime} - v} = ((Y_{k})^{-e_{k}}g)^{1 / x_{k}}</span>  Next, rewrite  <span class="math">\\Lambda^{e_k} = (S_k)^{v&#x27; - v}</span>  from Eq. (37) as:</p>

    <div class="my-4 text-center"><span class="math-block">\\Lambda^ {e _ {k}} = \\left(\\left(Y _ {k}\\right) ^ {- e _ {k}} g\\right) ^ {1 / x _ {k}} \\Leftrightarrow \\Lambda^ {x _ {k} e _ {k}} = \\left(Y _ {k}\\right) ^ {- e _ {k}} g \\Leftrightarrow \\Lambda^ {x _ {k}} = Y _ {k} ^ {- 1} g ^ {1 / e _ {k}} \\tag {38}</span></div>

    <p class="text-gray-300">Thus,  <span class="math">\\mathcal{B}</span>  breaks Strong RSA by outputting  <span class="math">(e_k,\\Lambda^{x_k}Y_k = g^{1 / e_k})</span></p>

    <h4 id="sec-27" class="text-lg font-semibold mt-6">B.2.2 Case 2: <span class="math">v=\\perp</span> or <span class="math">v^{\\prime}=\\perp</span></h4>

    <p class="text-gray-300">Assume without loss of generality, that <span class="math">v\\neq\\perp</span> and <span class="math">v^{\\prime}=\\perp</span>. Recall that <span class="math">S_{k}</span> is an RSA membership witness for <span class="math">e_{k}</span> w.r.t. to the RSA accumulator <span class="math">S</span>. Also, recall that <span class="math">(a^{\\prime}_{k},B^{\\prime}_{k})</span> is an RSA non-membership witness for <span class="math">e_{k}</span> w.r.t. to that same RSA accumulator <span class="math">S</span>. This clearly breaks the RSA accumulator’s security <em>[3, Def. 6, pg. 13]</em>. Since there exists an adversary <span class="math">\\mathcal{C}</span> that, on input the accumulator <span class="math">S</span> and the two inconsistent witnesses for <span class="math">e_{k}</span>, breaks the Strong RSA assumption, <span class="math">\\mathcal{B}</span> can use <span class="math">\\mathcal{C}</span> to break Strong RSA. ∎</p>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">B.2.3 Weak Key Binding for Individual UAD Proofs</h4>

    <p class="text-gray-300">The <em>weak key binding</em> security proof for our UAD construction from Section 4.2 follows in the same fashion, except that at Eq. (37), the security reduction knows that <span class="math">S_{k}=g^{e_{K\\setminus\\{k\\}}}</span> where <span class="math">K</span> is the set of all keys in the dictionary <span class="math">D</span>, which the adversary <span class="math">\\mathcal{A}</span> now outputs. Then, Eq. (37) becomes:</p>

    <p class="text-gray-300"><span class="math">\\Lambda^{e_{k}}=(S_{k})^{v^{\\prime}-v}\\Leftrightarrow\\Lambda^{e_{k}}=(g^{e_{K\\setminus\\{k\\}}})^{v^{\\prime}-v}=g^{e_{K\\setminus\\{k\\}}(v^{\\prime}-v)}</span> (39)</p>

    <p class="text-gray-300">Thus, <span class="math">\\mathcal{B}</span> can compute <span class="math">e_{K\\setminus\\{k\\}}</span> and find Bézout coefficients <span class="math">(x_{k},y_{k})</span> such that <span class="math">x_{k}e_{K\\setminus\\{k\\}}(v^{\\prime}-v)+y_{k}e_{k}=1</span>. As a result, we have:</p>

    <p class="text-gray-300"><span class="math">\\Lambda^{e_{k}}=g^{\\frac{1-y_{k}e_{k}}{x_{k}}}\\Leftrightarrow\\Lambda^{x_{k}e_{k}}=g/g^{y_{k}e_{k}}\\Leftrightarrow\\Lambda^{x_{k}e_{k}}g^{y_{k}e_{k}}=g\\Leftrightarrow\\Lambda^{x_{k}}g^{y_{k}}\\hskip 56.9055pt=g^{1/e_{k}}</span> (40)</p>

    <p class="text-gray-300">Thus, <span class="math">\\mathcal{B}</span> can break Strong RSA by outputting <span class="math">(e_{k},\\Lambda^{x_{k}}g^{y_{k}}=g^{1/e_{k}})</span>.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">B.3 Key Binding for Aggregated Proofs</h3>

    <p class="text-gray-300">We are now ready to prove <em>key binding</em> (see Definition 4.3) holds for our AAD from Section 4.3, even with aggregated lookup proofs, under the Strong RSA assumption (see Definition B.1) in the generic group model <em>[8]</em>. Our proof strategy is very simple: we disaggregate the inconsistent aggregated proofs into inconsistent individual proofs and re-use our security reduction from Appendix B.2.</p>

    <h6 id="sec-30" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Assume an adversary <span class="math">\\mathcal{A}</span> breaks key binding and outputs a digest <span class="math">d=(c,S)</span>, and two inconsistent proofs <span class="math">\\pi=(S_{I_{1}},\\Lambda_{I_{1}},\\pi_{I_{1}},\\pi_{I_{0}}),\\pi^{\\prime}=(S_{J_{1}},\\Lambda_{J_{1}},\\pi_{J_{1}},\\pi_{J_{0}})</span> for <span class="math">I,V</span> and <span class="math">J,V^{\\prime}</span>. Recall from Section 4.3 that <span class="math">I=I_{1}\\cup I_{0}</span> and <span class="math">k\\in I_{1}</span> always has value <span class="math">V(k)\\neq\\perp</span> while <span class="math">k\\in I_{0}</span> has value <span class="math">\\perp</span>. (<span class="math">J_{1}</span> and <span class="math">J_{0}</span> are defined similarly.) Let <span class="math">v_{k}=V(k),\\forall k\\in I</span> and <span class="math">v^{\\prime}_{k}=V^{\\prime}(k),\\forall k\\in J</span>. Since <span class="math">\\mathcal{A}</span> broke key binding, <span class="math">\\exists</span> a key <span class="math">z\\in I\\cap J</span> with <span class="math">v_{z}\\neq v^{\\prime}_{z}</span>. We show how to build another adversary <span class="math">\\mathcal{B}</span> that breaks a random Strong RSA problem instance <span class="math">g</span> by outputting <span class="math">g^{1/e}</span> for some prime <span class="math">e</span>. Our adversary <span class="math">\\mathcal{B}</span> sets up the AD scheme with <span class="math">\\mathsf{prk}</span> and <span class="math">\\mathsf{vrk}</span> set to <span class="math">g</span> and the hash function <span class="math">H</span>. Recall that, for any set <span class="math">T</span> of keys, <span class="math">e_{T}=\\prod_{k\\in T}e_{k}</span>.</p>

    <h4 id="sec-31" class="text-lg font-semibold mt-6">B.3.1 Case 1: <span class="math">v_{z}\\neq\\perp</span> and <span class="math">v^{\\prime}_{z}\\neq\\perp</span></h4>

    <p class="text-gray-300">First, <span class="math">\\mathcal{B}</span> can obtain <span class="math">(S_{z},\\Lambda_{z})\\leftarrow\\mathsf{CFG.Disagg}(I_{1},\\{z\\},(v_{k})_{k\\in I_{1}},\\pi)</span> (see Fig. 5) where <span class="math">S_{z}=S^{1/e_{z}}</span>. Second, <span class="math">\\mathcal{B}</span> must extract <span class="math">(a_{z},B_{z})</span> from <span class="math">\\pi_{I_{1}}</span> such that <span class="math">(S_{z})^{a_{z}}(B_{z})^{e_{z}}=g</span>. Recall that <span class="math">\\pi_{I_{1}}=(A_{I_{1}},\\pi_{I_{1}}^{\\mathsf{PoKE}},B_{I_{1}})</span> is a disjointness proof for all keys in <span class="math">I_{1}</span> (including <span class="math">z</span>) such that <span class="math">\\mathsf{PoKE.Ver}(A_{I_{1}},S_{I_{1}},\\pi_{I_{1}}^{\\mathsf{PoKE}})=1</span> and <span class="math">A_{I_{1}}B_{I_{1}}^{e_{I_{1}}}=g</span>. Since the PoKE proof verifies, <span class="math">\\mathcal{B}</span> extracts <span class="math">a_{I_{1}}</span> from the PoKE proof such that <span class="math">A_{I_{1}}=S_{I_{1}}^{a_{I_{1}}}</span> with non-negligible probability. Thus, <span class="math">\\mathcal{B}</span> now has <span class="math">S_{I_{1}}^{a_{I_{1}}}B_{I_{1}}^{e_{I_{1}}}=g</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{B}</span> can disaggregate the RSA disjointness witness <span class="math">(a_{I_{1}},B_{I_{1}})</span> for <span class="math">e_{I_{1}}</span> not being in the accumulator <span class="math">S_{I_{1}}</span> into individual non-membership witnesses <span class="math">(a_{k},B_{k})_{k\\in I_{1}}</span> for <span class="math">e_{k}</span> not being in accumulator <span class="math">S_{k}=S^{1/e_{k}}</span> as follows. <span class="math">\\mathcal{B}</span> gets non-membership witness <span class="math">(\\hat{a}_{k},\\hat{B}_{k})_{k\\in I_{1}}</span> for each <span class="math">e_{k}</span> w.r.t. <span class="math">S_{I_{1}}</span> via <span class="math">\\mathsf{BreakUpNonMemWit}(S_{I_{1}},a_{I_{1}},B_{I_{1}},(e_{k})_{k\\in I_{1}})</span> from <em>[3, Fig. 3, pg. 16]</em>. Then, <span class="math">\\mathcal{B}</span> uses <span class="math">\\mathsf{Acc.NonMemWitUpdAdd}(S_{I_{1}},\\hat{a}_{z},\\hat{B}_{z},e_{z},e_{I_{1}}/e_{z})</span> to update <span class="math">(\\hat{a}_{z},\\hat{B}_{z})</span> into a non-membership witness <span class="math">(a_{z},B_{z})</span> for <span class="math">e_{z}</span> w.r.t. to <span class="math">S_{z}</span>.</p>

    <p class="text-gray-300">Thus, <span class="math">\\pi_{z}=(S_{z},\\Lambda_{z},a_{z},B_{z})</span> is an individual lookup proof for <span class="math">z</span> having value <span class="math">v_{z}</span> that verifies against <span class="math">d=(c,S)</span>. In exactly the same fashion, <span class="math">\\mathcal{B}</span> disaggregates <span class="math">\\pi^{\\prime}</span> into an individual lookup proof <span class="math">\\pi^{\\prime}_{z}=(S^{\\prime}_{z},\\Lambda^{\\prime}_{z},a^{\\prime}_{z},B^{\\prime}_{z})</span> for <span class="math">z</span> having value <span class="math">v^{\\prime}_{z}\\neq v_{z}</span> that verifies against <span class="math">d=(c,S)</span>. Finally, <span class="math">\\mathcal{B}</span> can call the adversary from Appendix B.2 with <span class="math">d=(c,S)</span> and these two inconsistent proofs as input and break Strong RSA.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">B.3.2 Case 2: <span class="math">v_{z}=\\bot</span> or <span class="math">v_{z}^{\\prime}=\\bot</span></h4>

    <p class="text-gray-300">Without loss of generality, assume that <span class="math">v_{z}\\neq\\bot</span> and <span class="math">v_{z}^{\\prime}=\\bot</span>. As in the previous case, <span class="math">\\mathcal{B}</span> can disaggregate <span class="math">\\pi</span> and obtain <span class="math">S_{z}</span>, which is an RSA membership witness for <span class="math">e_{z}</span> w.r.t. the accumulator <span class="math">S</span>: i.e., <span class="math">S_{z}=(S_{I_{1}})^{e_{I_{1}\\setminus\\{z\\}}}</span>.</p>

    <p class="text-gray-300">Next, recall that the proof <span class="math">\\pi^{\\prime}</span> contains an RSA disjointness witness <span class="math">\\pi_{J_{0}}=(A_{J_{0}},\\pi_{J_{0}}^{\\mathsf{PoKE}},B_{J_{0}})</span> for all keys <span class="math">k\\in J_{0}</span> that have value <span class="math">\\bot</span> w.r.t. the accumulator <span class="math">S</span>, such that <span class="math">A_{J_{0}}(B_{J_{0}})^{e_{J_{0}}}=g</span> and <span class="math">\\mathsf{PoKE.Ver}(A_{J_{0}},S,\\pi_{J_{0}}^{\\mathsf{PoKE}})=1</span>. Thus, since the PoKE proof verifies, <span class="math">\\mathcal{B}</span> can extract <span class="math">a_{J_{0}}</span> such that <span class="math">A_{J_{0}}=S^{a_{J_{0}}}</span> with non-negligible probability. Thus, <span class="math">\\mathcal{B}</span> now has <span class="math">S^{a_{J_{0}}}(B_{J_{0}})^{e_{J_{0}}}=g</span>.</p>

    <p class="text-gray-300">Next, <span class="math">\\mathcal{B}</span> can disaggregate this <span class="math">(a_{J_{0}},B_{J_{0}})</span> RSA disjointness witness for <span class="math">e_{J_{0}}</span> w.r.t. <span class="math">S</span>, into RSA non-membership witnesses <span class="math">(a_{k},B_{k})_{k\\in J_{0}}</span> for each <span class="math">e_{k}</span> w.r.t. <span class="math">S</span> via <span class="math">\\mathsf{BreakUpNonMemWit}(S,a_{J_{0}},B_{J_{0}},(e_{k})_{k\\in J_{0}})</span>. Therefore, <span class="math">\\mathcal{B}</span> can obtain a non-membership witness <span class="math">(a_{z},B_{z})</span> for <span class="math">e_{z}</span> w.r.t. <span class="math">S</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathcal{B}</span> now has both a membership and a non-membership witness for <span class="math">e_{z}</span> w.r.t. <span class="math">S</span>. This clearly breaks the RSA accumulator’s security <em>[3, Def. 6, pg. 13]</em>. Since there exists an adversary <span class="math">\\mathcal{C}</span> that, on input <span class="math">S</span> and the two inconsistent witnesses for <span class="math">e_{z}</span>, breaks the Strong RSA assumption, <span class="math">\\mathcal{B}</span> can use <span class="math">\\mathcal{C}</span> to break Strong RSA. ∎</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">B.3.3 Weak Key Binding for Aggregated UAD Proofs</h4>

    <p class="text-gray-300">We can use the same disaggregation-based approach as above to prove weak key binding for our UAD construction from Section 4.2. Importantly, there is no need for the generic group model <em>[8]</em> when disaggregating UAD proofs, since our UAD does not use PoKE proofs. Once the inconsistent UAD aggregated proofs are disaggregated into inconsistent UAD individual proofs, the security reduction from Appendix B.2.3 can be invoked with the individual proofs, which will break the Strong RSA problem.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">B.4 Warm-up: Append-only Security w.r.t. Individual Proofs</h3>

    <p class="text-gray-300">Suppose an adversary <span class="math">\\mathcal{A}</span> breaks append-only security (see Definition 4.5) of our AAD from Section 4.3 and outputs a lookup proof <span class="math">\\pi_{k}=(S_{k},\\Lambda_{k},a_{k},B_{k})</span> for key <span class="math">k</span> having value <span class="math">v\\neq\\bot</span> w.r.t. digest <span class="math">d=(c,S)</span>, a lookup proof <span class="math">\\pi_{k}^{\\prime}=(S_{k},^{\\prime}\\Lambda_{k}^{\\prime},a_{k}^{\\prime},B_{k}^{\\prime})</span> for <span class="math">k</span> having value <span class="math">v^{\\prime}\\neq v</span> w.r.t. digest <span class="math">d^{\\prime}=(c^{\\prime},S^{\\prime})</span>, with <span class="math">v^{\\prime}</span> possibly equal to <span class="math">\\bot</span>, and an append-only proof <span class="math">\\pi_{\\subseteq}</span> between <span class="math">d</span> and <span class="math">d^{\\prime}</span>. Then, we show how to build another adversary <span class="math">\\mathcal{B}</span> that, in the generic group model <em>[8]</em>, breaks the Strong RSA problem (see Definition B.1).</p>

    <p class="text-gray-300">Recall from Section 4.3 that <span class="math">\\pi_{\\subseteq}=(\\pi_{\\subseteq}^{\\mathsf{PoKE}},U,\\pi_{u}^{\\mathsf{PoKE}},Z,\\pi_{z}^{\\mathsf{PoKE}})</span> where <span class="math">c^{\\prime}=UZ</span>, <span class="math">\\mathsf{PoKE.Ver}(S^{\\prime},S,\\pi_{\\subseteq}^{\\mathsf{PoKE}})=1</span>, <span class="math">\\mathsf{PoKE.Ver}(U,c,\\pi_{u}^{\\mathsf{PoKE}})=1</span> and <span class="math">\\mathsf{PoKE.Ver}(Z,S,\\pi_{z}^{\\mathsf{PoKE}})=1</span>. Since the PoKE proofs verify, <span class="math">\\mathcal{B}</span> can extract with non-negligible probability <span class="math">(u,z)</span> such that <span class="math">S^{\\prime}=S^{u}</span> and <span class="math">c^{\\prime}=c^{u}S^{z}</span>. Next, we split into cases.</p>

    <p class="text-gray-300">Case 1: <span class="math">v^{\\prime}\\neq\\bot</span>. Since <span class="math">\\pi_{k}^{\\prime}</span> verifies against <span class="math">d^{\\prime}</span>, we know that <span class="math">S^{\\prime}=(S_{k}^{\\prime})^{e_{k}}</span>, which implies that <span class="math">(S_{k}^{\\prime})^{e_{k}}=S^{u}</span>. But since <span class="math">\\pi_{k}</span> verifies against <span class="math">d</span>, we have <span class="math">S=(S_{k})^{e_{k}}</span>. Thus, <span class="math">(S_{k}^{\\prime})^{e_{k}}=(S_{k}^{e_{k}})^{u}\\Rightarrow S_{k}^{\\prime}=S_{k}^{u}</span>. From the validity of <span class="math">\\pi_{k}^{\\prime}</span>, we also know that <span class="math">(S_{k}^{\\prime})^{v^{\\prime}}(\\Lambda_{k}^{\\prime})^{e_{k}}=c^{\\prime}=c^{u}S^{u}</span>. Similarly, from <span class="math">\\pi_{k}</span>, we know that <span class="math">(S_{k})^{v}(\\Lambda_{k})^{e_{k}}=c</span>. Thus:</p>

    <p class="text-gray-300"><span class="math">(S_{k}^{\\prime})^{v^{\\prime}}(\\Lambda_{k}^{\\prime})^{e_{k}}</span> <span class="math">=((S_{k})^{v}(\\Lambda_{k})^{e_{k}})^{u}\\left((S_{k})^{e_{k}}\\right)^{z}=(S_{k}^{\\prime})^{v}(\\Lambda_{k})^{ue_{k}}(S_{k})^{ze_{k}}\\Leftrightarrow</span> (41) <span class="math">(S_{k}^{\\prime})^{v^{\\prime}-v}</span> <span class="math">=\\frac{(\\Lambda_{k})^{ue_{k}}}{(\\Lambda_{k}^{\\prime})^{e_{k}}}(S_{k})^{ze_{k}}\\Rightarrow(S_{k}^{\\prime})^{v^{\\prime}-v}=\\Lambda^{e_{k}},\\text{ with }\\Lambda=\\frac{(\\Lambda_{k})^{u}}{\\Lambda_{k}^{\\prime}}(S_{k})^{z}</span> (42)</p>

    <p class="text-gray-300">Next, we know from <span class="math">\\pi_{k}^{\\prime}</span> that <span class="math">(a_{k}^{\\prime},B_{k}^{\\prime})</span> is a non-membership witness for <span class="math">e_{k}</span> w.r.t. the RSA accumulator <span class="math">S_{k}^{\\prime}</span>. Since <span class="math">\\gcd(e_{k},v^{\\prime}-v)=1</span> (because <span class="math">e_{k}</span> is a <span class="math">(\\ell+1)</span>-bit prime and values <span class="math">v</span> and <span class="math">v^{\\prime}</span> are <span class="math">\\ell</span> bits), we can update this to a non-membership witness for the RSA accumulator <span class="math">(S_{k}^{\\prime})^{v^{\\prime}-v}</span> as <span class="math">(x_{k},Y_{k})=\\mathsf{Acc.NonMemWitUpdAdd}(S_{k}^{\\prime},a_{k}^{\\prime},B_{k}^{\\prime},e_{k},v^{\\prime}-v)</span> such that <span class="math">\\left((S_{k}^{\\prime})^{v^{\\prime}-v}\\right)^{x_{k}}(Y_{k})^{e_{k}}=g\\Leftrightarrow(S_{k}^{\\prime})^{v^{\\prime}-v}=\\left((Y_{k})^{-e_{k}}g\\right)^{1/x_{k}}</span>. Finally, replace <span class="math">(S_{k}^{\\prime})^{v^{\\prime}-v}</span> in Eq. (42) to get <span class="math">\\left((Y_{k})^{-e_{k}}g\\right)^{1/x_{k}}=\\Lambda^{e_{k}}\\Leftrightarrow(Y_{k})^{-e_{k}}g=\\Lambda^{x_{k}e_{k}}\\Leftrightarrow Y_{k}^{-1}g^{1/e_{k}}=\\Lambda^{x_{k}}</span>. Thus, <span class="math">g^{1/e_{k}}=\\Lambda^{x_{k}}Y_{K}</span>, and <span class="math">\\mathcal{B}</span> breaks Strong RSA on <span class="math">g</span> by outputting <span class="math">(e_{k},\\Lambda^{x_{k}}Y_{K})</span>.</p>

    <p class="text-gray-300">Case 2: <span class="math">v^{\\prime}=\\bot</span>. In this case, <span class="math">\\pi_{k}</span> contains a membership witness <span class="math">S_{k}</span> for <span class="math">e_{k}</span> in <span class="math">S</span> such that <span class="math">(S_{k})^{e_{k}}=S</span>. Recall that <span class="math">\\mathcal{B}</span> extracted <span class="math">u</span> from the append-only proof <span class="math">\\pi_{\\subseteq}</span> such that <span class="math">S^{\\prime}=S^{u}</span>. Since <span class="math">((S_{k})^{u})^{e_{k}}=((S^{k})^{e_{k}})^{u}=S^{u}=S^{\\prime}</span>, this implies <span class="math">(S_{k})^{u}</span> is a membership witness for <span class="math">e_{k}</span> w.r.t. <span class="math">S^{\\prime}</span> as well. However, since <span class="math">\\pi_{k}^{\\prime}</span> says key <span class="math">k</span> is not in the new dictionary, it includes a (contradicting) non-membership witness <span class="math">(a_{k}^{\\prime},B_{k}^{\\prime})</span> for <span class="math">e_{k}</span> w.r.t. the accumulator <span class="math">S^{\\prime}</span>. This clearly breaks the RSA accumulator’s security <em>[3, Def. 6, pg. 13]</em>. Since there exists an adversary <span class="math">\\mathcal{C}</span> that, on input the accumulator <span class="math">S^{\\prime}</span> and the two inconsistent witnesses for <span class="math">e_{k}</span>, breaks the Strong RSA assumption, <span class="math">\\mathcal{B}</span> can use <span class="math">\\mathcal{C}</span> to break Strong RSA.</p>

    <h2 id="sec-35" class="text-2xl font-bold">Appendix</h2>

    <p class="text-gray-300">B.5 Append-only Security for Aggregated Proofs</p>

    <h6 id="sec-36" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">Suppose an adversary <span class="math">\\mathcal{A}</span> breaks append-only security as defined in Definition 4.5 and outputs a lookup proof <span class="math">\\pi</span> for keys <span class="math">k\\in K</span> having value <span class="math">v_{k}=V(k)</span> w.r.t. digest <span class="math">(c,S)</span>, a lookup proof <span class="math">\\pi^{\\prime}</span> for keys <span class="math">k\\in K^{\\prime}</span> having value <span class="math">v_{k}^{\\prime}=V^{\\prime}(k)</span> w.r.t. digest <span class="math">(c^{\\prime},S^{\\prime})</span>, such that <span class="math">\\exists z\\in K\\cap K^{\\prime}</span> with <span class="math">v_{z}\\neq\\bot</span> and <span class="math">v_{z}\\neq v_{z}^{\\prime}</span>, and an append-only proof <span class="math">\\pi_{\\subseteq}</span> between <span class="math">d</span> and <span class="math">d^{\\prime}</span>. Then, we show how to build another adversary <span class="math">\\mathcal{B}</span> that, in the generic group model <em>[8]</em>, breaks the Strong RSA problem (see Definition B.1) As with our proof for strong key binding of aggregated proofs (see Appendix B.3), we take advantage of the fact that our construction supports disaggregating proofs. Note that <span class="math">K=K_{1}\\cup K_{0}</span> and <span class="math">k\\in K_{1}</span> always has value <span class="math">v_{k}\\neq\\bot</span> while <span class="math">k\\in K_{0}</span> has value <span class="math">\\bot</span>. Similarly, <span class="math">K^{\\prime}</span> is also partitioned into <span class="math">K_{1}^{\\prime}</span> and <span class="math">K_{0}^{\\prime}</span>. As before, we need to consider two separate cases.</p>

    <p class="text-gray-300">Case 1: <span class="math">\\bm{v_{z}}\\neq\\bot</span> and <span class="math">\\bm{v_{z}^{\\prime}}\\neq\\bot</span>. In this case, <span class="math">\\mathcal{B}</span> proceeds similar to Appendix B.3.1. Specifically, given the aggregated lookup proof <span class="math">\\pi</span>, <span class="math">\\mathcal{B}</span> disaggregates a proof <span class="math">\\pi_{z}</span> for <span class="math">z</span> having value <span class="math">v_{z}</span> w.r.t. digest <span class="math">(c,S)</span>. Similarly, given <span class="math">\\pi^{\\prime}</span>, <span class="math">\\mathcal{B}</span> disaggregates <span class="math">\\pi_{z}^{\\prime}</span> for <span class="math">z</span> having value <span class="math">v_{z}^{\\prime}\\neq v_{z}</span> w.r.t. digest <span class="math">(c^{\\prime},S^{\\prime})</span>. Now, <span class="math">\\mathcal{B}</span> calls the security reduction from Appendix B.4 with <span class="math">(d,d^{\\prime},\\pi_{z},\\pi_{z}^{\\prime},z,v_{z},v_{z}^{\\prime},\\pi_{\\subseteq})</span> as input, which breaks the Strong RSA problem.</p>

    <p class="text-gray-300">Case 2: <span class="math">\\bm{v_{z}}\\neq\\bot</span> and <span class="math">\\bm{v_{z}^{\\prime}}=\\bot</span>. In this case <span class="math">z\\in K_{1}</span> and <span class="math">z\\in K_{0}^{\\prime}</span>. Recall that <span class="math">\\pi=(S_{K_{1}},\\Lambda_{K_{1}},\\pi_{K_{1}},\\pi_{K_{0}})</span> and <span class="math">\\pi^{\\prime}=(S_{K_{1}^{\\prime}},\\Lambda_{K_{1}^{\\prime}},\\pi_{K_{1}^{\\prime}},\\pi_{K_{0}^{\\prime}})</span>. <span class="math">\\mathcal{B}</span> proceeds as follows. <span class="math">\\mathcal{B}</span> computes an RSA membership witness <span class="math">S_{z}</span> for <span class="math">e_{z}</span> w.r.t. the accumulator <span class="math">S</span> as <span class="math">S_{z}=(S_{K_{1}})^{e_{K_{1}\\setminus\\{z\\}}}</span>. As explained in Appendix B.4, <span class="math">\\mathcal{B}</span> extracts <span class="math">u</span> from <span class="math">\\pi_{\\subseteq}</span> such that <span class="math">S^{\\prime}=S^{u}</span>. Then, <span class="math">\\mathcal{B}</span> updates <span class="math">S_{z}</span> to a membership witness <span class="math">(S_{z})^{u}</span> for <span class="math">e_{z}</span> w.r.t. <span class="math">S^{\\prime}</span>. Similar to Appendix B.3.2, <span class="math">\\mathcal{B}</span> extracts with non-negligible probability <span class="math">(a_{K_{0}^{\\prime}},B_{K_{0}^{\\prime}})</span> from <span class="math">\\pi_{K_{0}^{\\prime}}=(A_{K_{0}^{\\prime}},\\pi_{K_{0}^{\\prime}}^{p_{\\text{spKE}}},B_{K_{0}^{\\prime}})</span> where <span class="math">A_{K_{0}^{\\prime}}=(S^{\\prime})^{a_{K_{0}^{\\prime}}}</span> and <span class="math">(S^{\\prime})^{a_{K_{0}^{\\prime}}}B_{K_{0}^{\\prime}}^{e_{K_{0}^{\\prime}}}=g</span>. In other words, <span class="math">\\mathcal{B}</span> extracts an RSA disjointness witness <span class="math">(a_{K_{0}^{\\prime}},B_{K_{0}^{\\prime}})</span> for <span class="math">e_{K_{0}^{\\prime}}</span> w.r.t. <span class="math">S^{\\prime}</span>. Next, <span class="math">\\mathcal{B}</span> can disaggregate this disjointness witness into individual non-membership witnesses <span class="math">(a_{k},B_{k})_{k\\in K_{0}^{\\prime}}</span> for each <span class="math">e_{k}</span> w.r.t. <span class="math">S^{\\prime}</span> via <span class="math">\\mathsf{BreakUpNonMemWit}(S^{\\prime},a_{K_{0}^{\\prime}},B_{K_{0}^{\\prime}},(e_{k})_{k\\in K_{0}^{\\prime}})</span> from <em>[3, Fig. 3, pg. 16]</em>. Thus, <span class="math">\\mathcal{B}</span> obtains a non-membership witness <span class="math">(a_{z},B_{z})</span> for <span class="math">e_{z}</span> w.r.t <span class="math">S^{\\prime}</span> (since <span class="math">z\\in K_{0}^{\\prime}</span>). Since <span class="math">\\mathcal{B}</span> now has both a membership and a non-membership witness for <span class="math">e_{z}</span> w.r.t. <span class="math">S^{\\prime}</span>, this clearly breaks the RSA accumulator’s security <em>[3, Def. 6, pg. 13]</em>. Since there exists an adversary <span class="math">\\mathcal{C}</span> that, on input the accumulator <span class="math">S^{\\prime}</span> and the two inconsistent witnesses for <span class="math">e_{z}</span>, breaks the Strong RSA assumption, <span class="math">\\mathcal{B}</span> can use <span class="math">\\mathcal{C}</span> to break Strong RSA. ∎</p>

    <h2 id="sec-37" class="text-2xl font-bold">Appendix</h2>`;
---

<BaseLayout title="Authenticated Dictionaries with Cross-Incremental Proof (Dis... (2020/1239)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1239
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
