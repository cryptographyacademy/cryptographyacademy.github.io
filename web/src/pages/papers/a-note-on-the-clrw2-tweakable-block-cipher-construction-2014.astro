---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/111';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'A Note on the CLRW2 Tweakable Block Cipher Construction';
const AUTHORS_HTML = 'Unknown authors';

const CONTENT = `    <h4 id="sec-1" class="text-lg font-semibold mt-6">Gordon Procter</h4>

    <p class="text-gray-300">Information Security Group, Royal Holloway, University of London gordon.procter.2011@rhul.ac.uk</p>

    <p class="text-gray-300"><strong>Abstract.</strong> In this note, we describe an error in the proof for CLRW2 given by Landecker et al. in their paper at CRYPTO 2012 on the beyond-birthday-bound security for tweakable block ciphers. We are able to resolve the issue, give a new bound for the security of CLRW2, and identify a potential limitation of this proof technique when looking to extend the scheme to provide asymptotic security.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">1 Introduction</h4>

    <p class="text-gray-300">Tweakable block ciphers were formalised by Liskov, Rivest, and Wagner at CRYPTO 2002 [18]. A tweakable block cipher is a block cipher that admits an additional input (the tweak) to introduce extra variability at the message-block level, in the same way that a nonce or IV introduces variability at the message level. The Hasty Pudding Cipher [23] and Mercy [7] are early examples of ciphers that natively support a tweak; in the case of the Hasty Pudding Cipher, this was called Spice. The tweak may be public and, informally, the security aim is that, for a single key, the permutations indexed by the tweaks are independent; appropriate security notions are defined more formally in Section 2.2.</p>

    <p class="text-gray-300">Liskov et al. [18] describe the syntax and security requirements for tweakable block ciphers and describe two methods for building a tweakable block cipher from a standard block cipher. They also give a method to construct a strong tweakable block cipher&lt;sup&gt;1&lt;/sup&gt; from a standard block cipher.</p>

    <p class="text-gray-300">Several tweakable block ciphers have been proposed including Goldenberg et al.'s work on tweaking Luby-Rackoff ciphers [9]; Rogaway's XE and XEX modes [22], which are closely related to the OCB mode of operation [14]; and Threefish [8], which forms part of the hash function Skein [8].</p>

    <p class="text-gray-300">Many block-cipher-based encryption and authentication schemes are secure up to the birthday bound, i.e. provided that fewer than  <span class="math">2^{\\frac{n}{2}}</span>  queries are made, where n is the width of the block cipher (in bits). Beyond this point, one would expect a collision in the input to the block cipher to occur and for this to perhaps leak some information or simplify forgery attempts (as described in, for example, [1,3,4,20]). Several works have studied the security of schemes beyond the birthday bound (for examples, see [10,12]); one related question is how to acheive beyond-birthday-bound security for tweakable block ciphers.</p>

    <p class="text-gray-300">At FSE 2009, Minematsu [21] suggested a method to build a 2n-bit tweakable block cipher that provides  <span class="math">\\mathcal{O}(2^{\\frac{n+m}{2}})</span>  security from an n-bit block cipher (where m is the size of the tweak). This scheme has a Luby-Rackoff or Feistel structure, but has the disadvantage of only supporting short tweaks and requiring per-invocation block-cipher rekeying which makes changing the tweak computationally expensive.</p>

    <p class="text-gray-300">At CRYPTO 2012 Landecker, Shrimpton, and Terashima [16] continued the study of tweakable block ciphers. Their paper has two main contributions: specifying CLRW2, a tweakable block cipher construction that remains secure beyond the birthday bound (up to approximately</p>

    <p class="text-gray-300">&lt;span id=&quot;page-0-0&quot;&gt;&lt;/span&gt;&lt;sup&gt;&amp;&lt;/sup&gt;lt;sup&gt;1&lt;/sup&gt; Informally, a strong tweakable block cipher is one that remains secure when the adversary is given also access to a decryption oracle.</p>

    <p class="text-gray-300">2 2n &lt;sup&gt;3&lt;/sup&gt; queries); and giving a proof that TBC-MAC (the analogue of CBC-MAC defined in terms of tweakable block ciphers) is both a PRF and unforgeable. CLRW2 allows arbitrarily long tweaks and does not require excessive rekeying of the block cipher.</p>

    <p class="text-gray-300">The CLRW2 construction was extended by Lampe and Seurin at FSE 2013 <a href="#page-11-12">[15]</a> who consider longer chains of the LRW2 construction and are able to show (asymptotically in the number of rounds, using a coupling argument) that this provides greater security further beyond the birthday bound than the CLRW2 construction. Their bounds agree with Landecker et al.'s bound in the case of non-adaptive CPA adversaries and they prove a weaker bound for CCA adversaries; they conjecture that the bound proved for non-adaptive CPA adversaries also holds for CCA adversaries.</p>

    <h4 id="sec-3" class="text-lg font-semibold mt-6">Contributions</h4>

    <p class="text-gray-300">This is an early draft in which we identify a flaw in the proof given by Landecker et al. for CLRW2 <a href="#page-11-11">[16,</a><a href="#page-11-13">17]</a> and are able to resolve it. We describe modifications that correct the proof and give new bounds for the security of CLRW2. We also identify a potential issue which may prevent this proof technique being used to extend these results asymptotically, although this issue does not appear to affect Lampe and Seurin's results.</p>

    <p class="text-gray-300">Landecker et al. have independently identified and corrected the error in their proof <a href="#page-11-14">[24]</a>; they correct the proof using a neat coupling argument which results in a tighter bound.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Structure</h3>

    <p class="text-gray-300">This note is structured as follows: In Section <a href="#page-1-1">2,</a> we introduce the notation, syntax, and security models used in this note; in Section <a href="#page-2-0">3,</a> we give a brief summary of Landecker et al.'s scheme and corresponding proof; in Section <a href="#page-5-0">4,</a> we describe and demonstrate the error that we have identified in the proof; in Section <a href="#page-7-0">5,</a> we give one possible method to fix this error and derive new bounds for the security of CLRW2; and Section <a href="#page-9-0">6</a> contains a description of some issues that may prevent this proof technique being extended asymptotically.</p>

    <h2 id="sec-5" class="text-2xl font-bold">&lt;span id=&quot;page-1-1&quot;&gt;&lt;/span&gt;2 Preliminaries</h2>

    <h2 id="sec-6" class="text-2xl font-bold">2.1 Notation</h2>

    <p class="text-gray-300">For a set X , we write x $← X to represent an element x being uniformly sampled from X . For a bitstring x ∈ {0, 1} &lt;sup&gt;∗&lt;/sup&gt; we use |x| to denote its length. We use ξ(p) to represent a Bernoulli random variable that is 1 with probability p and 0 with probability 1 − p. For a set S ⊆ {0, 1} &lt;sup&gt;n&lt;/sup&gt; and an element x ∈ {0, 1} &lt;sup&gt;n&lt;/sup&gt; we define S ⊕ x = {s ⊕ x : s ∈ S}.</p>

    <p class="text-gray-300">We follow the code-based game paradigm of Bellare and Rogaway <a href="#page-10-3">[5]</a>. We will use X&lt;sup&gt;i&lt;/sup&gt; to denote plaintext input to a tweakable block cipher and Y&lt;sup&gt;i&lt;/sup&gt; for ciphertext output. Queries made by an adversary and the value of random variables related to those queries are be indexed by a counter i. In games, all boolean flags are initialised to false and arrays are initially undefined at every point.</p>

    <h2 id="sec-7" class="text-2xl font-bold">&lt;span id=&quot;page-1-0&quot;&gt;&lt;/span&gt;2.2 Block Cipher Syntax and Security</h2>

    <p class="text-gray-300">A block cipher is a family of functions: E : K × {0, 1} &lt;sup&gt;n&lt;/sup&gt; → {0, 1} n , where K is the keyspace. We require that E(k, ·) is a permutation on {0, 1} n for every choice of key k. We will often denote E(k, ·) by Ek(·) and the inverse of this permutation by E −1 k (·).</p>

    <p class="text-gray-300">We follow Bellare, Kilian, and Rogaway <a href="#page-10-4">[2]</a> and say that a block cipher is secure if it is a pseudo-random permutation family (PRP). A pseudo-random permutation family is a set of permutations  <span class="math">\\{E_k|k\\in\\mathcal{K}\\}</span>  that is indistinguishable from a random permutation family  <span class="math">\\Pi</span>  also indexed by elements of  <span class="math">\\mathcal{K}</span> . A strong pseudo-random permutation family (SPRP) is a pseudo-random permutation family that remains indistinguishable from a random permutation family when an adversary is also given access to either a decryption oracle, or to the random permutation's inverse.</p>

    <p class="text-gray-300">Consider an adversary A and define their SPRP advantage against E as</p>

    <p class="text-gray-300"><span class="math">$\\mathrm{Adv}_E^{\\mathrm{sprp}}(\\mathcal{A}) = \\left| \\Pr[1 \\leftarrow \\mathcal{A}^{(E_k, E_k^{-1})}] - \\Pr[1 \\leftarrow \\mathcal{A}^{(\\pi, \\pi^{-1})}] \\right|</span>$</p>

    <p class="text-gray-300">where  <span class="math">k \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K}$  and  <span class="math">\\pi \\stackrel{\\</span>}{\\leftarrow} \\Pi$ . Define  <span class="math">\\mathrm{Adv}_E^{\\mathrm{sprp}}(q,t)</span>  to be the maximum advantage that can be realised by an adversary asking no more than q queries and running in time at most t. We say that E is a strong pseudo-random permutation if  <span class="math">\\mathrm{Adv}_E^{\\mathrm{sprp}}(q,t)</span>  is sufficiently small.</p>

    <p class="text-gray-300">A tweakable block cipher is a family of functions:  <span class="math">\\widetilde{E}: \\mathcal{K} \\times \\mathcal{T} \\times \\{0,1\\}^n \\to \\{0,1\\}^n</span> , where  <span class="math">\\mathcal{K}</span>  is the keyspace and  <span class="math">\\mathcal{T}</span>  is the tweakspace. We require that, for every  <span class="math">k \\in \\mathcal{K}</span>  and  <span class="math">T_i \\in \\mathcal{T}</span> ,  <span class="math">\\widetilde{E}_k(T_i, \\cdot)</span>  is a permutation on  <span class="math">\\{0,1\\}^n</span>  and we denote the inverse of this permutation by  <span class="math">\\widetilde{E}_k^{-1}(T_i, \\cdot)</span> . We remark that in the case of CLRW2, a tweakable block cipher key includes two keys for the underlying block cipher and two keys for the universal hash function family, i.e.  <span class="math">k = (k_1, H_1, k_2, H_2)</span> .</p>

    <p class="text-gray-300">We use the definition of tweakable block cipher security given by Liskov et al. [18,19]. A secure tweakable block cipher is one that is indistinguishable from a tweaked random permutation family  <span class="math">\\widetilde{H}</span> , where  <span class="math">\\widetilde{H}</span>  is a set of random permutations on  <span class="math">\\{0,1\\}^n</span>  indexed by elements of  <span class="math">\\mathcal{K} \\times \\mathcal{T}</span> . A strong tweakable block cipher is one that is indistinguishable from a tweaked random permutation family when an adversary is given either access to encryption and decryption oracles for the tweakable block cipher or access to a family of tweaked random permutations and their inverses. In the definition of both tweakable block ciphers and strong tweakable block ciphers, the adversary is able to choose both the input and the tweak for each query.</p>

    <p class="text-gray-300">Consider an adversary A and define their tweakable-SPRP advantage against  <span class="math">\\widetilde{E}</span>  as</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Adv}_{\\widetilde{E}}^{\\widetilde{\\operatorname{sprp}}}(\\mathcal{A}) = \\left| \\Pr[1 \\leftarrow \\mathcal{A}^{(\\widetilde{E}_k, \\widetilde{E}_k^{-1})}] - \\Pr[1 \\leftarrow \\mathcal{A}^{(\\widetilde{\\pi}, \\widetilde{\\pi}^{-1})}] \\right|</span>$</p>

    <p class="text-gray-300">where  <span class="math">k \\stackrel{\\</span>}{\\leftarrow} \\mathcal{K}$  and  <span class="math">\\widetilde{\\pi} = \\{\\pi(k, T_i, \\cdot) \\in \\widetilde{\\Pi} : T_i \\in \\mathcal{T}\\}</span> . Define  <span class="math">\\operatorname{Adv}_{\\widetilde{E}}^{\\widetilde{\\operatorname{sprp}}}(q, t)</span>  to be the maximum advantage that can be realised by an adversary making no more than q queries and running in time at most t. We say that  <span class="math">\\widetilde{E}</span>  is a strong tweakable block cipher if  <span class="math">\\operatorname{Adv}_{\\widetilde{E}}^{\\widetilde{\\operatorname{sprp}}}(q, t)</span>  is sufficiently small.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">2.3 Universal Hash Functions</h4>

    <p class="text-gray-300">A family of hash functions will be denoted  <span class="math">\\mathcal{H} = \\{h_H : \\{0,1\\}^* \\to \\{0,1\\}^n \\mid H \\in \\mathcal{K}_{\\mathcal{H}}\\}</span>  with each hash function  <span class="math">h_H</span>  indexed by a key  <span class="math">H \\in \\mathcal{K}_{\\mathcal{H}}</span> . For simplicity and clarity, we will abbreviate  <span class="math">h_{H_j}</span>  to  <span class="math">h_j</span> .</p>

    <p class="text-gray-300">A family of hash functions is said to be  <span class="math">\\epsilon</span> -almost XOR universal [13] if for every  <span class="math">M, M&#x27; \\in \\{0,1\\}^*</span>  with  <span class="math">M \\neq M&#x27;</span>  and for every  <span class="math">c \\in \\{0,1\\}^n</span> ,  <span class="math">\\Pr_{H \\in \\mathcal{K}_{\\mathcal{H}}}[h_H(M) \\oplus h_H(M&#x27;) = c] &lt; \\epsilon</span> . Throughout this paper  <span class="math">\\epsilon</span> -almost XOR universal will be abbreviated to  <span class="math">\\epsilon</span> -AXU.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">&lt;span id=&quot;page-2-0&quot;&gt;&lt;/span&gt;3 Description of the CLRW2 Tweakable Block Cipher Construction</h3>

    <p class="text-gray-300">The scheme proposed by Landecker et al. [16] combines an  <span class="math">\\epsilon</span> -AXU hash function and a block cipher. The ciphertext  <span class="math">Y_i</span>  is computed from plaintext  <span class="math">X_i</span>  using key  <span class="math">k = (k_1, H_1, k_2, H_2)</span>  and tweak  <span class="math">T_i</span>  as follows:</p>

    <p class="text-gray-300"><span class="math">$Y_i = E_{k_2} (E_{k_1}(X_i \\oplus h_1(T_i)) \\oplus h_1(T_i) \\oplus h_2(T_i)) \\oplus h_2(T_i)</span>$</p>

    <p class="text-gray-300">    <img src="_page_3_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-3-0&quot;&gt;&lt;/span&gt;Fig. 1. The CLRW2 tweakable block cipher construction.</p>

    <p class="text-gray-300">This construction is illustrated in Figure <a href="#page-3-0">1.</a> The intuition behind the security of CLRW2 is that an adversary can only obtain a 'birthday-bound-style' advantage by causing a collision at both inputs to the block cipher The reduction given by Landecker et al. (which relies on the SPRP security of the block cipher to show the strong tweakable block cipher security of CLRW2) proceeds via a series of games. The aim of these games is to show that the output of CLRW2 is close to that of an ideal tweakable block cipher, in the absence of a query that causes a collision at both block cipher inputs and that the likelihood of such a query is sufficiently low.</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">3.1 Additional Notation</h4>

    <p class="text-gray-300">We largely follow the notation used by Landecker et al. <a href="#page-11-11">[16,</a><a href="#page-11-13">17]</a> to avoid introducing confusion.</p>

    <p class="text-gray-300">Throughout this paper, we will lazy-sample random permutations instead of defining the permutation up front. When referring to the domain and range of a permutation π : {0, 1} &lt;sup&gt;n&lt;/sup&gt; → {0, 1} n , we will use Domfull(π) and Rngfull(π) to denote the set {0, 1} n in order to make clear the context that this set relates to. When lazy-sampling a permutation π : {0, 1} &lt;sup&gt;n&lt;/sup&gt; → {0, 1} n we will use the sets Domlazy(π) ⊆ Domfull(π) = {0, 1} &lt;sup&gt;n&lt;/sup&gt; and Rnglazy(π) ⊆ Rngfull(π) = {0, 1} n to keep track of which values have been defined in the domain and range (respectively) of π. We will often drop the subscript for the sets Domlazy(π) and Rnglazy(π) provided that the meaning is clear. The 'lazy' sets have an implicit query index because they are only defined relative to the previous queries and random choices within them.</p>

    <p class="text-gray-300">We use Y&lt;sup&gt;i&lt;/sup&gt; = {0, 1} &lt;sup&gt;n&lt;/sup&gt; \\ {Y&lt;sup&gt;j&lt;/sup&gt; : j &lt; i and T&lt;sup&gt;j&lt;/sup&gt; = Ti} and Y&lt;sup&gt;i&lt;/sup&gt; = {0, 1} &lt;sup&gt;n&lt;/sup&gt; \\ Y&lt;sup&gt;i&lt;/sup&gt; . That is, if Y&lt;sup&gt;i&lt;/sup&gt; ∈ Y&lt;sup&gt;i&lt;/sup&gt; then Yi is not a possible output from an ideal tweakable block cipher given the output from previous queries (recalling that &lt;sup&gt;E&lt;/sup&gt;&lt;sup&gt;e&lt;/sup&gt; (k, T&lt;sup&gt;i&lt;/sup&gt; , ·) is a permutation). Hence, Y&lt;sup&gt;i&lt;/sup&gt; is the set of possible output values from an ideal tweakable block cipher.</p>

    <p class="text-gray-300">We define the sets S&lt;sup&gt;j&lt;/sup&gt; as they are defined in Landecker et al.'s paper and present them graphically in Figure <a href="#page-4-0">2.</a> These sets partition {0, 1} n for a particular input (X&lt;sup&gt;i&lt;/sup&gt; , Ti) according to the whether the corresponding inputs and outputs of each permutation have already been defined. As above, these sets have an implicit query index.</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} S_1 &amp;= \\{Y_i \\in \\mathcal{Y}_i : Y_i \\oplus h_2(T_i) \\notin \\mathsf{Rng}(\\pi_2)\\} \\\\ S_2 &amp;= \\{Y_i \\in \\mathcal{Y}_i : Y_i \\oplus h_2(T_i) \\in \\mathsf{Rng}(\\pi_2) \\land \\pi_2^{-1}(Y_i \\oplus h_2(T_i)) \\oplus h_1(T_i) \\oplus h_2(T_i) \\notin \\mathsf{Rng}(\\pi_1)\\} \\\\ S_3 &amp;= \\{Y_i \\in \\mathcal{Y}_i : Y_i \\oplus h_2(T_i) \\in \\mathsf{Rng}(\\pi_2) \\land \\pi_2^{-1}(Y_i \\oplus h_2(T_i)) \\oplus h_1(T_i) \\oplus h_2(T_i) \\in \\mathsf{Rng}(\\pi_1)\\} \\\\ S_4 &amp;= \\{Y_i \\in \\overline{\\mathcal{Y}_i}\\} \\end{split}</span>$</p>

    <p class="text-gray-300">That is, S&lt;sup&gt;1&lt;/sup&gt; is the set of output values that correspond to undefined outputs from π&lt;sup&gt;2&lt;/sup&gt; and S&lt;sup&gt;2&lt;/sup&gt; is the set of output values corresponding to defined outputs from π2, but for which the output of π&lt;sup&gt;1&lt;/sup&gt; is undefined. The set S&lt;sup&gt;3&lt;/sup&gt; contains output values for which the all inputs and outputs to the block cipher are defined. Because we only consider these sets when L&lt;sup&gt;i&lt;/sup&gt; ∈/ Rng(π1), these</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. An illustration of the definition for sets Si. The domain and range of each permutation are divided into two sets: the input/output pairs that are 'Old' (in Dom(π&lt;sup&gt;j&lt;/sup&gt; ) and Rng(π&lt;sup&gt;j&lt;/sup&gt; )), shown above the dashed line; and the points that are 'New' (in Dom(π&lt;sup&gt;j&lt;/sup&gt; ) and Rng(π&lt;sup&gt;j&lt;/sup&gt; )), shown below the dashed line. In the case that L&lt;sup&gt;i&lt;/sup&gt; ∈/ Dom(π1), any value corresponding to a black box in the above diagram is impossible.</p>

    <p class="text-gray-300">&lt;span id=&quot;page-4-0&quot;&gt;&lt;/span&gt;output values are inconsistent with the responses to previous queries. Finally, S&lt;sup&gt;4&lt;/sup&gt; = Y&lt;sup&gt;i&lt;/sup&gt; is the set of values that are not possible for either an ideal tweakable block cipher or the CLRW2 construction; responding to a query with an element of this set would violate the requirement for each &lt;sup&gt;E&lt;/sup&gt;&lt;sup&gt;e&lt;/sup&gt; (k, T&lt;sup&gt;i&lt;/sup&gt; , ·) to be a permutation.</p>

    <p class="text-gray-300">At a first glance, S&lt;sup&gt;3&lt;/sup&gt; is appears to be the difference between CLRW2 and an ideal tweakable block cipher: elements in S&lt;sup&gt;4&lt;/sup&gt; are not possible in either case; elements in S&lt;sup&gt;1&lt;/sup&gt; and S&lt;sup&gt;2&lt;/sup&gt; are possible in both cases; while elements in S&lt;sup&gt;3&lt;/sup&gt; are not excluded from the output of an ideal tweakable block cipher but are impossible if CLRW2 is used. This informal summary does not give the full detail – if the situation were this simple, the original proof would be correct.</p>

    <p class="text-gray-300">We use pT BC(Yi) to denote the probability that Y&lt;sup&gt;i&lt;/sup&gt; is the output of the ideal tweakable block cipher and pG3(Yi) for the probability that Y&lt;sup&gt;i&lt;/sup&gt; is the output of the intermediate cipher defined in Game 3 of the proof; these probabilities are both conditioned on all previous queries and responses.</p>

    <h2 id="sec-11" class="text-2xl font-bold">3.2 Overview of Proof</h2>

    <p class="text-gray-300">We give a brief overview of Landecker et al.'s proof below but refer to the original papers <a href="#page-11-11">[16</a><a href="#page-11-13">,17]</a> for the full details.</p>

    <p class="text-gray-300">Game 0 defines the scheme when it is instantiated with a particular block cipher and is given in Figure <a href="#page-4-1">3,</a> to introduce the random variables corresponding to inputs and outputs to the random permutations in later games.</p>

    <pre><code class="language-text">Game 0
1: procedure Ee (T, X)
2: i ← i + 1; Xi ← X; Ti ← T
3: Li ← Xi ⊕ h1(Ti)
4: Zi ← Ek1
              (Li)
5: Mi ← Zi ⊕ h1(Ti) ⊕ h2(Ti)
6: Yi ← Ek2
              (Mi) ⊕ h2(Ti)
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-4-1&quot;&gt;&lt;/span&gt;return Y&lt;sup&gt;i&lt;/sup&gt;</p>

    <p class="text-gray-300">Fig. 3. Game 0 defines the scheme when it is instantiated with a specific block cipher. It is included here to introduce the random variables corresponding to inputs and outputs to the random permutations in later games.</p>

    <p class="text-gray-300">Games 1 to 3 consider the case in which there is a collision at the input to the first block cipher. The conclusion of this analysis is that in the absence of a collision at both block ciphers</p>

    <p class="text-gray-300">on the same query, the output of CLRW2 is indistinguishable from an ideal tweakable block cipher and that the probability of two block cipher collisions being caused by the same query is sufficiently small that the scheme remains secure up to approximately  <span class="math">2^{\\frac{2n}{3}}</span>  queries.</p>

    <p class="text-gray-300">In Game 1, the block cipher is replaced with a random permutation, which is lazy-sampled. The security of this scheme relies on the assumption that the block cipher used to instantiate the scheme is a strong pseudorandom permutation and the distinguishing advantage between Game 0 and Game 1 is bounded above by  <span class="math">2\\text{Adv}_E^{\\text{sprp}}(\\mathcal{A})</span> .</p>

    <p class="text-gray-300">Between Games 1 and 3, the only changes to the definition of these games are in section of code that is executed when the image of  <span class="math">L_i</span>  under  <span class="math">\\pi_1</span>  has already been defined. The differences between these games are as follows. In Game 1, the existing definition of  <span class="math">\\pi_2(M_i)</span>  is used. In Game 2,  <span class="math">Y_i</span>  is sampled from  <span class="math">\\mathcal{Y}_i</span>  (the set of possible values) and this definition is checked to ensure that it does not contradict any existing definition of  <span class="math">\\pi_2(M_i)</span>  or  <span class="math">\\pi_2^{-1}(Y_i \\oplus h_2(T_i))</span> . If the sampling of  <span class="math">Y_i</span>  from  <span class="math">\\mathcal{Y}_i</span>  does cause a contradiction, one of  <span class="math">\\mathsf{bad}_1</span>  and  <span class="math">\\mathsf{bad}_2</span>  is set to true and  <span class="math">Y_i</span>  is redefined. Game 3 is identical to Game 2, except that in  <span class="math">Y_i</span>  is never redefined in Game 4, even if a  <span class="math">\\mathsf{bad}</span>  flag is set to true. The difference between Game 1 and Game 2 is purely syntactic; the distribution of all random variables in the two games are identical. The distributions of all random variables in Games 2 and 3 are identical unless either  <span class="math">\\mathsf{bad}_1</span>  or  <span class="math">\\mathsf{bad}_2</span>  is set to true.</p>

    <p class="text-gray-300">Games 4 to 6 address the case in which there is no first round collision; it is in this case that we have identified the problem with the proof. In these games, no changes are made to the code that is executed when  <span class="math">\\pi_1(L_i)</span>  is already defined.</p>

    <p class="text-gray-300">Between Game 3 and Game 4, the order in which  <span class="math">Z_i</span>  and  <span class="math">Y_i</span>  are sampled is changed, however the joint distribution is not changed. Between Games 4 and 5, the method used to sample  <span class="math">Z_i</span> and  <span class="math">Y_i</span>  is changed, with the aim that the final joint distribution is unchanged. We will see that this aim is not achieved and that this is where the error in the proof occurs.</p>

    <p class="text-gray-300">Game 5 and Game 6 are identical unless it is necessary to redefine  <span class="math">Y_i</span> . If it is necessary to redefine  <span class="math">Y_i</span>  in Game 5, then  <span class="math">\\mathsf{bad}_3</span>  is set to true and so these two games are identical until  <span class="math">\\mathsf{bad}</span> , in a similar way to Game 2 and Game 3. Game 6 and Game 7 are functionally identical and Game 7 realises an ideal tweakable block cipher.</p>

    <p class="text-gray-300">Game 8 is essentially identical to Game 7, but gives the adversary control over the  <span class="math">Y_i</span>  values. The motivation for this step is that this makes it no harder for an adversary to trigger any of the bad events, but makes it easier to reason about the probability of a bad event occurring.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-5-0&quot;&gt;&lt;/span&gt;4 The Error in the Proof</h4>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">4.1 Games 4 and 5 are not Identical</h4>

    <p class="text-gray-300">In the proof of security given for CLRW2 [16,17], Landecker et al. assert that the output distributions of Games 4 and 5 are identical. However, this is only the case if  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i)</span>  is non-negative for  <span class="math">Y_i \\in S_1 \\cup S_2</span> . This is because the resampling step in Game 5 (at Lines 618-9) only produces an identical distribution to that of Game 4 if  <span class="math">p_{G3}(Y_i) \\ge p_{TBC}(Y_i)</span>  for  <span class="math">Y_i \\in S_1 \\cup S_2</span> .</p>

    <p class="text-gray-300">It is possible for a series of queries to result in  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i)</span>  being negative for all  <span class="math">Y_i \\in S_1</span> . This results in a contradiction to the claim that the output distributions of Games 4 and 5 are always identical.</p>

    <p class="text-gray-300">In Section 5 we describe one method of modifying Games 5-8 to fix this issue with the proof. We redefine  <span class="math">\\Delta_i = \\sum_{Y_i \\in S_i} p_{G3}(Y_i) - p_{TBC}(Y_i)</span>  (without the modulus signs from Landecker et al.'s definition) and note that  <span class="math">|\\Delta_i| = \\sum_{Y_i \\in S_i} |p_{G3}(Y_i) - p_{TBC}(Y_i)|</span>  because for a given set  <span class="math">S_j</span>  either  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) \\ge 0</span>  for every  <span class="math">Y_i</span>  in  <span class="math">S_j</span>  or  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) &lt; 0</span>  for every  <span class="math">Y_i</span>  in  <span class="math">S_j</span> . Using our definition,  <span class="math">|\\Delta_j|</span>  corresponds precisely with Landecker et al.'s definition of  <span class="math">\\Delta_j</span> .</p>

    <p class="text-gray-300">We briefly describe the differences between the sampling methods employed when  <span class="math">L_i</span>  is new in the relevant games. The resulting probability distributions are illustrated in Figures 7 to 9.</p>

    <p class="text-gray-300">In Game 3,  <span class="math">Z_i</span>  is chosen uniformly at random from  <span class="math">\\overline{\\mathsf{Dom}(\\pi_1)}</span>  and  <span class="math">Y_i</span>  is defined to be consistent with this choice of  <span class="math">Z_i</span> . In Game 4, an appropriately weighted coin is tossed and  <span class="math">Y_i</span>  is chosen from either  <span class="math">S_1</span>  or  <span class="math">S_2</span>  so that the distributions of  <span class="math">Z_i</span>  and  <span class="math">Y_i</span>  are identical to the distribution in Game 3. In Game 5,  <span class="math">Y_i</span>  is chosen uniformly from  <span class="math">\\mathcal{Y}_i</span>  and if  <span class="math">Y_i</span>  is in  <span class="math">S_3</span>  then it is resampled, from either  <span class="math">S_1</span>  or  <span class="math">S_2</span> .</p>

    <p class="text-gray-300">When  <span class="math">Y_i</span>  is resampled in Game 5, the probability that it is chosen in  <span class="math">S_2</span>  is  <span class="math">\\frac{|\\Delta_2|}{|\\Delta_1|+|\\Delta_2|}</span> . This probability is used because if  <span class="math">|\\Delta_1|+|\\Delta_2|=|\\Delta_3|</span>  then the distribution of  <span class="math">Y_i</span>  does not change between Games 4 and 5 [17, p. 9]. However, if  <span class="math">p_{G3}(Y_i)-p_{TBC}(Y_i)&lt;0</span>  then  <span class="math">|\\Delta_2|=|\\Delta_1|+|\\Delta_3|</span> , so  <span class="math">|\\Delta_1|+|\\Delta_2|&gt;|\\Delta_3|</span>  and the distribution of  <span class="math">Y_i</span>  does change.</p>

    <p class="text-gray-300">In fact, the difference between the distributions in Games 4 and 5 is exaggerated by the method used by Landecker et al. to resample from  <span class="math">S_1 \\cup S_2</span>  if  <span class="math">Y_i \\in S_3</span> , as illustrated in Figure 11. In the case that  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) &lt; 0</span>  for  <span class="math">Y_i \\in S_1</span> , the desired difference between the distributions in Game 4 and Game 5 for  <span class="math">Y_i \\in S_1</span>  is  <span class="math">-|\\Delta_1|</span> , i.e.</p>

    <p class="text-gray-300"><span class="math">$\\sum_{Y_i \\in S_1} p_{G3}(Y_i) = \\sum_{Y_i \\in S_1} p_{TBC}(Y_i) - |\\Delta_1|</span>$</p>

    <p class="text-gray-300">but using the sampling method described, this increases this to  <span class="math">|\\Delta_1| \\cdot \\frac{|\\Delta_3|}{|\\Delta_1| + |\\Delta_2|}</span> , so that</p>

    <p class="text-gray-300"><span class="math">$\\sum_{Y_i \\in S_1} p_{G3}(Y_i) = \\sum_{Y_i \\in S_1} p_{TBC}(Y_i) + |\\Delta_1| \\cdot \\frac{|\\Delta_3|}{|\\Delta_1| + |\\Delta_2|}.</span>$</p>

    <p class="text-gray-300">Similarly, the difference for  <span class="math">Y_i \\in S_2</span>  is decreased from  <span class="math">|\\Delta_2|</span>  to  <span class="math">|\\Delta_2| \\cdot \\frac{|\\Delta_3|}{|\\Delta_1| + |\\Delta_2|}</span></p>

    <h2 id="sec-14" class="text-2xl font-bold">4.2 How to make <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) &lt; 0</span></h2>

    <p class="text-gray-300">The proof given by Landecker et al. [16,17] is correct provided that  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) \\ge 0</span>  when  <span class="math">Y_i \\in S_1 \\cup S_2</span> . We will call the situation in which  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) &lt; 0</span>  for some  <span class="math">Y_i \\in S_i \\cup S_2</span>  an <em>inversion</em>. To demonstrate an inversion, first recall that:</p>

    <p class="text-gray-300"><span class="math">$p_{TBC}(Y_i) = \\frac{1}{2^n - |S_4|} \\text{ for } Y_i \\notin S_4,</span>$</p>

    <p class="text-gray-300"><span class="math">$p_{G3}(Y_i) = \\frac{N - |S_2|}{N|S_1|} \\text{ for } Y_i \\in S_1, \\text{ and}</span>$</p>

    <p class="text-gray-300"><span class="math">$p_{G3}(Y_i) = \\frac{1}{N} \\text{ for } Y_i \\in S_2,</span>$</p>

    <p class="text-gray-300">where  <span class="math">N = |\\overline{\\mathsf{Dom}(\\pi_1)}|</span> .</p>

    <p class="text-gray-300"><span class="math">Y_i \\in S_1</span>  We consider the possibility of an inversion occurring for  <span class="math">Y_i \\in S_1</span>  and show that an adversary can force an inversion to happen for  <span class="math">Y_i</span>  in  <span class="math">S_1</span>  with high probability. In this case, an inversion occurs when</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2^n - |S_4|} = p_{TBC}(Y_i) &gt; p_{G3}(Y_i) = \\frac{N - |S_2|}{N|S_1|}</span>$</p>

    <p class="text-gray-300">Suppose that the adversary asks a number of queries so that  <span class="math">|\\mathsf{Dom}(\\pi_1)| = a</span>  and  <span class="math">|\\mathsf{Dom}(\\pi_2)| = b</span> , with no restrictions on how  <span class="math">X_i</span>  and  <span class="math">T_i</span>  are chosen. Then, one way that an inversion can occur with high probability is if: the adversary uses a new tweak for the next query;  <span class="math">L_i</span>  is new; and for every  <span class="math">Z_i \\in \\mathsf{Rng}(\\pi_1)</span> ,  <span class="math">Z_i \\oplus h_1(T_i) \\oplus h_2(T_i) \\in \\overline{\\mathsf{Dom}(\\pi_2)}</span> .</p>

    <p class="text-gray-300">In this case:</p>

    <p class="text-gray-300"><span class="math">$N = 2^n - a</span>$
,  <span class="math">|S_1| = 2^n - b</span> ,  <span class="math">|S_2| = b</span> , and  <span class="math">|S_3| = |S_4| = 0</span> .</p>

    <p class="text-gray-300">Starting with the observation that ab &gt; 0, the following statements are equivalent:</p>

    <p class="text-gray-300"><span class="math">$ab &gt; 0</span>$</p>

    <p class="text-gray-300"><span class="math">$2^{2n} - (a+b)2^n + ab &gt; 2^{2n} - (a+b)2^n</span>$</p>

    <p class="text-gray-300"><span class="math">$(2^n - a)(2^n - b) &gt; 2^n(2^n - a - b)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2^n} &gt; \\frac{2^n - a - b}{(2^n - a)(2^n - b)}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2^n - |S_4|} &gt; \\frac{N - |S_2|}{N|S_1|}</span>$</p>

    <p class="text-gray-300"><span class="math">$p_{TBC}(Y_i) &gt; p_{G3}(Y_i)</span>$</p>

    <p class="text-gray-300">which is the condition for an inversion.</p>

    <p class="text-gray-300">This situation can occur and indeed it is easy for an adversary to force this event to happen. If  <span class="math">T_1 \\neq T_2</span>  then an inversion occurs on the second query (where a = b = 1) with probability  <span class="math">1 - \\epsilon \\approx \\frac{2^n - 1}{2^n}</span> , which is the probability that  <span class="math">h_j(T_1) \\neq h_j(T_2)</span>  when  <span class="math">T_1 \\neq T_2</span>  (this probability is conditioned on the event  <span class="math">L_i \\in \\overline{\\mathsf{Dom}(\\pi_1)}</span>  having occurred).</p>

    <p class="text-gray-300"><span class="math">Y_i \\in S_2</span>  We also consider the possibility of an inversion occurring for  <span class="math">Y_i \\in S_2</span> . For an inversion to occur we need</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2^n - |S_4|} = p_{TBC}(Y_i) &gt; p_{G3}(Y_i) = \\frac{1}{N}</span>$</p>

    <p class="text-gray-300">Now note that</p>

    <p class="text-gray-300"><span class="math">$2^n - |S_4| \\ge |S_1| + |S_2| \\ge N</span>$</p>

    <p class="text-gray-300">and so</p>

    <p class="text-gray-300"><span class="math">$\\frac{1}{2^n - |S_4|} \\le \\frac{1}{|S_1| + |S_2|} \\le \\frac{1}{N}</span>$</p>

    <p class="text-gray-300">Therefore, for  <span class="math">Y_i \\in S_2</span> , there is no situation in which  <span class="math">p_{TBC}(Y_i) \\geq p_{G3}(Y_i)</span> .</p>

    <p class="text-gray-300">A Minor Issue with Landecker et al.'s Graph We also make the minor remark that the graph given by Landecker et al. [16, Fig.3] shows  <span class="math">p_{G3}(Y_1) \\ge p_{G3}(Y_2)</span> , where  <span class="math">Y_1 \\in S_1</span>  and  <span class="math">Y_2 \\in S_2</span> , when in fact this situation can never occur as  <span class="math">N - |S_2|</span>  is never any larger than  <span class="math">|S_1|</span>  and</p>

    <p class="text-gray-300"><span class="math">$|N - |S_2| \\le |S_1| \\Leftrightarrow \\frac{N - |S_2|}{|S_1|} \\le 1 \\Leftrightarrow \\frac{N - |S_2|}{N|S_1|} \\le \\frac{1}{N} \\Leftrightarrow p_{G3}(Y_1) \\le p_{G3}(Y_2).</span>$</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-7-0&quot;&gt;&lt;/span&gt;5 How to Fix Landecker et al.'s Proof</h4>

    <p class="text-gray-300">The proof given by Landecker et al. can be fixed by modifying Games 5 to 8. The strategy we have adopted is to not change the distribution of  <span class="math">Y_i</span>  between Games 4 and 5, then to bound the distance between the distributions that result from an ideal tweakable block cipher and from Game 5. This is the same strategy followed by Landecker et al. but we are careful to ensure that the distribution of  <span class="math">Y_i</span>  does not change between Games 4 and 5 when  <span class="math">p_{G3}(Y_i) - p_{TBC}(Y_i) &lt; 0</span> . This requires us to reduce the probability of  <span class="math">Y_i</span>  being sampled from  <span class="math">S_1</span>  when  <span class="math">\\Delta_1 &lt; 0</span>  in Game 5; we do this naïvely by tossing an appropriately weighted coin to decide whether to resample</p>

    <p class="text-gray-300"><span class="math">Y_i</span>  from  <span class="math">S_2</span> . We add conditional branches to differentiate between the cases  <span class="math">\\Delta_1 \\geq 0</span>  and  <span class="math">\\Delta_1 &lt; 0</span> ; this is a simple approach, but appears to work well and we lose only a small factor in the bound.</p>

    <p class="text-gray-300">In Appendix A, we give the revised games (Figures 4, 5, and 6) and graphically represent the probability distributions realised by each of these games (Figures 7, 8, 9, 10, 11, and 12). We have only specified the encryption algorithm for each of game; it is straightforward to derive the corresponding decryption algorithms.</p>

    <p class="text-gray-300">The distributions of all random variables in Games 4 and 5' are identical. Games 5' and 6' are identical unless either bad&lt;sub&gt;3&lt;/sub&gt; or bad&lt;sub&gt;4&lt;/sub&gt; gets set to true. The distributions of random varibles in Games 6' and 7' are identical, with Game 7' simplifying some of the program flow. Game 8' gives the adversary control over  <span class="math">Y_i</span>  values, so the bad flags can be set at least as easily as they can in Game 7'. We note that Game 8 and Game 8' are identical except for the addition of lines 14 to 17, so a large majority of the original analysis still applies.</p>

    <p class="text-gray-300">Landecker et al. have independently identified an alternative method to correct the error in their proof [24], using a coupling argument which results in a tighter bound.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-8-0&quot;&gt;&lt;/span&gt;5.1 A Bound on <span class="math">\\Delta_1</span></h4>

    <p class="text-gray-300">To bound the advantage an adversary gains when we change from Game 5' to Game 6', we need to bound  <span class="math">|\\Delta_1| \\frac{(2^n - |S_4|)}{|S_1|}</span>  in the case that  <span class="math">\\Delta_1 &lt; 0</span> . By noting that</p>

    <p class="text-gray-300"><span class="math">$N \\ge 2^n - q</span>$
,  <span class="math">|S_1| \\ge 2^n - q</span> ,  <span class="math">|S_2| \\le q</span> ,  <span class="math">|S_3| \\ge 0</span> , and  <span class="math">|S_4| \\ge 0</span></p>

    <p class="text-gray-300">we can bound  <span class="math">|\\Delta_1|</span>  and  <span class="math">|\\Delta_1| \\cdot \\frac{(2^n - |S_4|)}{|S_1|}</span> :</p>

    <p class="text-gray-300"><span class="math">$|\\Delta_1| \\le \\frac{q^2}{2^n(2^n - q)}</span>$
and  <span class="math">|\\Delta_1| \\cdot \\frac{(2^n - |S_4|)}{|S_1|} \\le \\frac{q^2}{(2^n - q)^2}</span></p>

    <p class="text-gray-300">More details are given in Appendix B. This bound is tight, in the sense that it is possible for an adversary to ask a series of q queries and for  <span class="math">|\\Delta_1| \\cdot \\frac{(2^n - |S_4|)}{|S_1|}</span>  to be as large as described by this bound. For this to occur we require that  <span class="math">|S_4| = |S_3| = 0</span> ,  <span class="math">|S_2| = q</span> , and  <span class="math">N = 2^n - q</span> .</p>

    <p class="text-gray-300">We also need to compare this to  <span class="math">\\beta_1 + \\Pr[Q]</span>  as calculated by Landecker et al., who show that  <span class="math">\\beta_1 + \\Pr[Q] \\le \\frac{2q^3\\hat{\\epsilon}^2}{1-q^3\\hat{\\epsilon}^2}.</span> Now, note that  <span class="math">\\frac{1}{2^n-q} \\le \\frac{1}{2^n-2q} \\le \\hat{\\epsilon}</span>  and that  <span class="math">1-q^3\\hat{\\epsilon}^2 \\le 1</span> . So</p>

    <p class="text-gray-300"><span class="math">$\\frac{q^2}{(2^n - q)^2} \\le q^2 \\hat{\\epsilon}^2 \\le \\frac{q^3 \\hat{\\epsilon}^2}{1 - q^3 \\hat{\\epsilon}^2}</span>$</p>

    <p class="text-gray-300">and we can see that</p>

    <p class="text-gray-300"><span class="math">$\\Pr\\left[\\mathcal{A}^{G8&#x27;}:\\mathsf{bad}_4\\right] \\leq \\frac{q^2}{(2^n-q)^2} \\leq q^3 \\hat{\\epsilon}^2 \\leq \\frac{q^3 \\hat{\\epsilon}^2}{1-q^3 \\hat{\\epsilon}^2}.</span>$</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Game Hopping Probabilities</h4>

    <p class="text-gray-300">Recalling Landecker et al.'s observation [16,17] that</p>

    <p class="text-gray-300"><span class="math">$2\\Pr\\left[\\mathcal{A}^{G8&#x27;}:\\mathsf{bad}_3\\right]+\\Pr\\left[\\mathcal{A}^{G8&#x27;}:\\mathsf{bad}_1\\vee\\mathsf{bad}_2\\right]\\leq \\frac{6q^3\\hat{\\epsilon}^2}{1-q^3\\hat{\\epsilon}^2},</span>$</p>

    <p class="text-gray-300">we are able to compute the adversary's advantage, using the Fundamental Lemma of Game Playing [5]:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\Pr\\left[\\mathcal{A}^{G1} \\to 1\\right] &amp;\\leq \\Pr\\left[\\mathcal{A}^{G4} \\to 1\\right] + \\Pr\\left[\\mathcal{A}^{G4} : \\mathsf{bad}_1 \\lor \\mathsf{bad}_2\\right] \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{G5&#x27;} \\to 1\\right] + \\Pr\\left[\\mathcal{A}^{G5&#x27;} : \\mathsf{bad}_1 \\lor \\mathsf{bad}_2\\right] \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{G6&#x27;} \\to 1 \\land \\neg(\\mathsf{bad}_3 \\lor \\mathsf{bad}_4)\\right] + \\Pr\\left[\\mathcal{A}^{G6&#x27;} \\to 1 \\land (\\mathsf{bad}_3 \\lor \\mathsf{bad}_4)\\right] \\\\ &amp;\\quad + \\Pr\\left[\\mathcal{A}^{G6&#x27;} : (\\mathsf{bad}_1 \\lor \\mathsf{bad}_2) \\land (\\mathsf{bad}_3 \\lor \\mathsf{bad}_4)\\right] \\\\ &amp;\\quad + \\Pr\\left[\\mathcal{A}^{G6&#x27;} : (\\mathsf{bad}_1 \\lor \\mathsf{bad}_2) \\land \\neg(\\mathsf{bad}_3 \\lor \\mathsf{bad}_4)\\right] \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{G6&#x27;} \\to 1\\right] + 2\\Pr\\left[\\mathcal{A}^{G6&#x27;} : \\mathsf{bad}_3 \\lor \\mathsf{bad}_4\\right] + \\Pr\\left[\\mathcal{A}^{G6&#x27;} : \\mathsf{bad}_1 \\lor \\mathsf{bad}_2\\right] \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{(\\widetilde{n},\\widetilde{n}^{-1})} \\to 1\\right] + 2\\Pr\\left[\\mathcal{A}^{G8&#x27;} : \\mathsf{bad}_3\\right] + 2\\Pr\\left[\\mathcal{A}^{G8&#x27;} : \\mathsf{bad}_4\\right] \\\\ &amp;\\quad + \\Pr\\left[\\mathcal{A}^{G8&#x27;} : \\mathsf{bad}_1 \\lor \\mathsf{bad}_2\\right] \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{(\\widetilde{n},\\widetilde{n}^{-1})} \\to 1\\right] + \\frac{6q^3\\hat{\\epsilon}^2}{1-q^3\\hat{\\epsilon}^2} + 2\\frac{q^2}{(2^n-q)^2} \\\\ &amp;\\leq \\Pr\\left[\\mathcal{A}^{(\\widetilde{n},\\widetilde{n}^{-1})} \\to 1\\right] + \\frac{8q^3\\hat{\\epsilon}^2}{1-q^3\\hat{\\epsilon}^2} \\end{split}</span>$</p>

    <p class="text-gray-300">So, there is an adversary  <span class="math">\\mathcal{B}</span>  against the SPRP security of E, such that:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Adv}_{\\widetilde{E}}^{\\widetilde{\\operatorname{sprp}}}(\\mathcal{A}) \\leq \\operatorname{Adv}_{E}^{\\operatorname{sprp}}(\\mathcal{B}) + \\frac{8q^3\\hat{\\epsilon}^2}{1 - q^3\\hat{\\epsilon}^2}.</span>$</p>

    <p class="text-gray-300">This is in contrast to the original result, which concludes that there is an adversary  <span class="math">\\mathcal{B}</span>  against the SPRP security of E, such that:</p>

    <p class="text-gray-300"><span class="math">$\\operatorname{Adv}_{\\widetilde{E}}^{\\widetilde{\\operatorname{sprp}}}(\\mathcal{A}) \\leq \\operatorname{Adv}_{E}^{\\operatorname{sprp}}(\\mathcal{B}) + \\frac{6q^3\\hat{\\epsilon}^2}{1 - q^3\\hat{\\epsilon}^2}.</span>$</p>

    <h4 id="sec-18" class="text-lg font-semibold mt-6">&lt;span id=&quot;page-9-0&quot;&gt;&lt;/span&gt;6 A Limitation of this Proof Technique</h4>

    <p class="text-gray-300">A natural extension of the work of Landecker et al. [16] is to consider longer chains of the LRW2 construction, as Lampe and Seurin have done at FSE 2013 [15]. The naïve approach to proving results in this case, which we emphasise is not the approach taken by Lampe and Seurin, would be to mimic Landecker et al.'s proof but to increase the number of sets  <span class="math">S_i</span>  to describe where the last non-colliding input to a permutation occurs. This technique does not seem to succeed in the presence of the errors described in this note. A second remark about this approach is that it fundamentally depends on the ability to sample from a set  <span class="math">\\overline{\\text{Rng}}_{\\text{lazy}}(\\pi_i) \\cap (\\overline{\\text{Dom}}_{\\text{lazy}}(\\pi_{i+1}) \\oplus h_i(T_i) \\oplus h_{i+1}(T_i))</span> . If this set is ever empty, it will be possible for an adversary to make a query that cannot be answered using the method described and a different proof method will be required. If this set is ever empty, it will be possible for an adversary to make a query that cannot be answered using the method described and a different proof method will be required.</p>

    <p class="text-gray-300">We bound the number of queries that may be asked before the sampling method described above fails by  <span class="math">q &lt; 2^{n-1}</span> . We emphasise that this does not constitute an error in Landecker et al.'s proof and does not appear to be an issue in Lampe and Seurin's work [15], it simply prevents Landecker et al.'s technique being naïvely extended asymptotically.</p>

    <p class="text-gray-300">This bound is obtained as follows: Note that for every j,  <span class="math">|\\mathsf{Dom}_{\\mathsf{lazy}}(\\pi_j)| = |\\mathsf{Rng}_{\\mathsf{lazy}}(\\pi_j)|</span>  after every query and, for every tweak,  <span class="math">h_j(T_i) \\oplus h_{j+1}(T_i)</span>  defines a perfect matching  <span class="math">\\{0,1\\}^n \\to \\{0,1\\}^n</span></p>

    <p class="text-gray-300">(representing Rngfull(π&lt;sup&gt;j&lt;/sup&gt; ) and Domfull(πj+1)). Suppose that we remove (up to) two edges from every matching when answering each query: one edges that matches the output of π&lt;sup&gt;j&lt;/sup&gt; and one edge matching the input to πj+1. Then it is possible to respond to any later query, as long as every matching has at least one edge remaining. If there is a matching with no remaining edges, then there is a tweak for which Rnglazy(π&lt;sup&gt;j&lt;/sup&gt; ) ∩ (Domlazy(πj+1) ⊕ h&lt;sup&gt;j&lt;/sup&gt; (Ti) ⊕ hj+1(Ti)) is empty and an input value X&lt;sup&gt;i&lt;/sup&gt; such that X&lt;sup&gt;i&lt;/sup&gt; ⊕h1(Ti) ∈/ Domlazy(π1). If there is a matching with no remaining edges, then there is a tweak for which Rnglazy(π&lt;sup&gt;j&lt;/sup&gt; )∩(Domlazy(πj+1)⊕h&lt;sup&gt;j&lt;/sup&gt; (Ti)⊕hj+1(Ti)) is empty and an input value X&lt;sup&gt;i&lt;/sup&gt; such that X&lt;sup&gt;i&lt;/sup&gt; ⊕ h1(Ti) ∈/ Domlazy(π1).</p>

    <p class="text-gray-300">We can guarantee that Rnglazy(π&lt;sup&gt;j&lt;/sup&gt; ) ∩ (Domlazy(πj+1) ⊕ h&lt;sup&gt;j&lt;/sup&gt; (Ti) ⊕ hj+1(Ti)) is not empty for every i and j, provided that q &lt; 2 n−1 . While it may remain possible to sample from this set beyond this bound, it is not guaranteed and depends on both the adversary's queries and the random choices in the lazy sampling of the functions.</p>

    <p class="text-gray-300">This does not cause a problem until n − 1 block ciphers are chained together because up to that point security is only provided for q &lt; 2 n−1 . However if n − 1 block ciphers are chained together using the CLRW2 construction, then this issue can occur and it may not be possible to respond to queries using this method.</p>

    <h2 id="sec-19" class="text-2xl font-bold">7 Discussion and Conclusions</h2>

    <p class="text-gray-300">We have shown that a minor error exists in the proof given for the tweakable block cipher CLRW2 <a href="#page-11-11">[16,</a><a href="#page-11-13">17]</a>. Fortunately it is possible for this error to be corrected and the scheme still provides a similar level of security.</p>

    <p class="text-gray-300">We also identify a potential limitation to extending this result asymptotically, by bounding the number of queries that can be made before it may be impossible to use Landecker et al.'s sampling method. We emphasise that this does not constitute an error in Landecker et al.'s proof and does not appear to be an issue in Lampe and Seurin's work; it simply prevents Landecker et al.'s technique being na¨ıvely extended asymptotically.</p>

    <p class="text-gray-300">Recently, flaws have been found in the proofs for two high-profile ciphers: GCM <a href="#page-11-17">[11]</a> and XCB <a href="#page-10-5">[6]</a>. In order for the community to have faith in the proofs given for schemes, it is important that security proofs are correct and any errors are removed. The factor lost by correcting the bound in this case is significantly smaller than for these errors, however it remains important that any errors in a security reduction are removed.</p>

    <h2 id="sec-20" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-0&quot;&gt;&lt;/span&gt;1. M. Bellare, A. Desai, E. Jokipii, and P. Rogaway. A concrete security treatment of symmetric encryption. In Foundations of Computer Science, 1997. Proceedings., 38th Annual Symposium on, pages 394–403, Oct 1997.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-4&quot;&gt;&lt;/span&gt;2. Mihir Bellare, Joe Kilian, and Phillip Rogaway. The security of cipher block chaining. In Yvo G. Desmedt, editor, Advances in Cryptology CRYPTO 94, volume 839 of Lecture Notes in Computer Science, pages 341–358. Springer Berlin Heidelberg, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-1&quot;&gt;&lt;/span&gt;3. Mihir Bellare, Ted Krovetz, and Phillip Rogaway. Luby-Rackoff backwards: Increasing security by making block ciphers non-invertible. In Kaisa Nyberg, editor, Advances in Cryptology EUROCRYPT'98, volume 1403 of Lecture Notes in Computer Science, pages 266–280. Springer Berlin Heidelberg, 1998.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-2&quot;&gt;&lt;/span&gt;4. Mihir Bellare, Krzysztof Pietrzak, and Phillip Rogaway. Improved Security Analyses for CBC MACs. In Victor Shoup, editor, Advances in Cryptology CRYPTO 2005, volume 3621 of Lecture Notes in Computer Science, pages 527–545. Springer Berlin Heidelberg, 2005.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-3&quot;&gt;&lt;/span&gt;5. Mihir Bellare and Phillip Rogaway. The Security of Triple Encryption and a Framework for Code-Based Game-Playing Proofs. In Serge Vaudenay, editor, Advances in Cryptology - EUROCRYPT 2006, volume 4004 of Lecture Notes in Computer Science, pages 409–426. Springer Berlin Heidelberg, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-10-5&quot;&gt;&lt;/span&gt;6. Debrup Chakraborty, Vicente Hernandez-Jimenez, and Palash Sarkar. Another Look at XCB. Cryptology ePrint Archive, Report 2013/823, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-2&quot;&gt;&lt;/span&gt;7. Paul Crowley. Mercy: A Fast Large Block Cipher for Disk Sector Encryption. In Gerhard Goos, Juris Hartmanis, Jan Leeuwen, and Bruce Schneier, editors, Fast Software Encryption, volume 1978 of Lecture Notes in Computer Science, pages 49–63. Springer Berlin Heidelberg, 2001.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-6&quot;&gt;&lt;/span&gt;8. Niels Ferguson, Stefan Lucks, Bruce Schneier, Doug Whiting, Mihir Bellare, Tadayoshi Kohno, Jon Callas, and Jesse Walker. The Skein Hash Function Family. <a href="http://www.skein-hash.info/sites/default/files/skein1.3.pdf">http://www.skein-hash.info/sites/default/</a> <a href="http://www.skein-hash.info/sites/default/files/skein1.3.pdf">files/skein1.3.pdf</a>, 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-3&quot;&gt;&lt;/span&gt;9. David Goldenberg, Susan Hohenberger, Moses Liskov, Elizabeth Crump Schwartz, and Hakan Seyalioglu. On Tweaking Luby-Rackoff Blockciphers. In Kaoru Kurosawa, editor, Advances in Cryptology ASIACRYPT 2007, volume 4833 of Lecture Notes in Computer Science, pages 342–356. Springer Berlin Heidelberg, 2007.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-8&quot;&gt;&lt;/span&gt;10. Tetsu Iwata. New Blockcipher Modes of Operation with Beyond the Birthday Bound Security. In Matthew Robshaw, editor, Fast Software Encryption, volume 4047 of Lecture Notes in Computer Science, pages 310– 327. Springer Berlin Heidelberg, 2006.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-17&quot;&gt;&lt;/span&gt;11. Tetsu Iwata, Keisuke Ohashi, and Kazuhiko Minematsu. Breaking and Repairing GCM Security Proofs. In Reihaneh Safavi-Naini and Ran Canetti, editors, Advances in Cryptology CRYPTO 2012, volume 7417 of Lecture Notes in Computer Science, pages 31–49. Springer Berlin Heidelberg, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-9&quot;&gt;&lt;/span&gt;12. A. Joux. On the security of blockwise secure modes of operation beyond the birthday bound. Information Theory, IEEE Transactions on, 56(3):1239–1246, March 2010.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-16&quot;&gt;&lt;/span&gt;13. Hugo Krawczyk. LFSR-based Hashing and Authentication. In Yvo G. Desmedt, editor, Advances in Cryptology CRYPTO 4, volume 839 of Lecture Notes in Computer Science, pages 129–139. Springer Berlin Heidelberg, 1994.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-5&quot;&gt;&lt;/span&gt;14. Ted Krovetz and Phillip Rogaway. The Software Performance of Authenticated-Encryption Modes. In Antoine Joux, editor, Fast Software Encryption, volume 6733 of Lecture Notes in Computer Science, pages 306–327. Springer Berlin Heidelberg, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-12&quot;&gt;&lt;/span&gt;15. Rodolphe Lampe and Yannick Seurin. Tweakable Blockciphers with Asymptotically Optimal Security. Fast Software Encryption 2013 (to appear).</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-11&quot;&gt;&lt;/span&gt;16. Will Landecker, Thomas Shrimpton, and R. Seth Terashima. Tweakable Blockciphers with Beyond Birthday-Bound Security. In Reihaneh Safavi-Naini and Ran Canetti, editors, Advances in Cryptology, CRYPTO 2012, volume 7417 of Lecture Notes in Computer Science, pages 14–30. Springer Berlin Heidelberg, 2012.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-13&quot;&gt;&lt;/span&gt;17. Will Landecker, Thomas Shrimpton, and R. Seth Terashima. Tweakable Blockciphers with Beyond Birthday-Bound Security. Cryptology ePrint Archive, Report 2012/450, 2012. Version 20120808:065419.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-0&quot;&gt;&lt;/span&gt;18. Moses Liskov, Ronald L. Rivest, and David Wagner. Tweakable Block Ciphers. In Moti Yung, editor, Advances in Cryptology, CRYPTO 2002, volume 2442 of Lecture Notes in Computer Science, pages 31–46. Springer Berlin Heidelberg, 2002.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-15&quot;&gt;&lt;/span&gt;19. Moses Liskov, Ronald L. Rivest, and David Wagner. Tweakable Block Ciphers. Journal of Cryptology, 24(3):588–613, 2011.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-7&quot;&gt;&lt;/span&gt;20. David McGrew. Impossible plaintext cryptanalysis and probable-plaintext collision attacks of 64-bit block cipher modes. Cryptology ePrint Archive, Report 2013/623, 2013.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-10&quot;&gt;&lt;/span&gt;21. Kazuhiko Minematsu. Beyond-Birthday-Bound Security Based on Tweakable Block Cipher. In Orr Dunkelman, editor, Fast Software Encryption, volume 5665 of Lecture Notes in Computer Science, pages 308–326. Springer Berlin Heidelberg, 2009.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-4&quot;&gt;&lt;/span&gt;22. Phillip Rogaway. Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC. In Pil Joong Lee, editor, Advances in Cryptology - ASIACRYPT 2004, volume 3329 of Lecture Notes in Computer Science, pages 16–31. Springer Berlin Heidelberg, 2004.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-1&quot;&gt;&lt;/span&gt;23. Rich Schroeppel. Hasty Pudding Cipher Specification. <a href="http://web.archive.org/web/20070206162154/http://www.cs.arizona.edu/people/rcs/hpc/hpc-spec">http://web.archive.org/web/</a> <a href="http://web.archive.org/web/20070206162154/http://www.cs.arizona.edu/people/rcs/hpc/hpc-spec">20070206162154/http://www.cs.arizona.edu/people/rcs/hpc/hpc-spec</a>, 1999.</p></li>
      <li><p class="text-gray-300">&lt;span id=&quot;page-11-14&quot;&gt;&lt;/span&gt;24. Thomas Shrimpton and R. Seth Terashima. personal communication, Jan 2014.</p></li>
    </ul>

    <h2 id="sec-21" class="text-2xl font-bold">&lt;span id=&quot;page-12-0&quot;&gt;&lt;/span&gt;Appendix A More Details on the Fix for the Proof</h2>

    <pre><code class="language-text">Game 50
       , 60
1: procedure Ee (T, X)
2: i ← i + 1; Xi ← X; Ti ← T
3: Li ← Xi ⊕ h1(Ti)
4: if Li ∈ Dom(π1) then
5: Mi ← π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)
6: Yi
         $← Yi
7: if Mi ∈ Dom(π2) then
8: bad1 ← true
9: else if Yi ⊕ h2(Ti) ∈ Rng(π2) then
10: bad2 ← true
11: π2(Mi) ← Yi ⊕ h2(Ti)
12: else
13: Yi
         $← Yi
14: if ∆1 ≥ 0 then
15: if Yi ∈ S1 then
16: Vi ← 0
17: else if Yi ∈ S2 then
18: Vi ← 1
19: else if Yi ∈ S3 then
20: bad3 ← true
21: Vi
               $
               ← ξ(
                    |∆2|
                  |∆1|+|∆2|
                        )
22: Zi ← π
                 −1
                 2
                   (Yi ⊕ h2(Ti)) ⊕ h1(Ti) ⊕ h2(Ti)
23: if Vi = 1 then
24: Yi
                 $
                ← S2
25: else if Vi = 0 then
26: Yi
                 $
                ← S1
27: else if ∆1 &lt; 0 then
28: if Yi ∈ S3 then
29: bad3 ← true
30: Yi
               $
              ← S2
31: if Yi ∈ S1 then
32: Vi ← 0
33: Ui
               $
              ← ξ(
                  |∆1|(2n−|S4|)
                     |S1|
                          )
34: if Ui = 1 then
35: bad4 ← true
36: Yi
                 $
                 ← S2
37: if Yi ∈ S2 then
38: Vi ← 1
39: if Yi ∈ S2 then
40: Zi ← π
               −1
               2
                (Yi ⊕ h2(Ti)) ⊕ h2(Ti) ⊕ h1(Ti)
41: else if Yi ∈ S1 then
42: Zi
            $
            ← Rng(π1) \\ (Dom(π2) ⊕ h2(Ti) ⊕ h1(Ti)
43: π2(Zi ⊕ h1(Ti) ⊕ h2(Ti)) ← Yi ⊕ h2(Ti)
44: π1(Li) ← Zi
45: Mi ← π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)
     return Yi
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-12-1&quot;&gt;&lt;/span&gt;Fig. 4. Between Game 4 and Game 5&lt;sup&gt;0&lt;/sup&gt; , the order in which V&lt;sup&gt;i&lt;/sup&gt; and Y&lt;sup&gt;i&lt;/sup&gt; are sampled is reversed. Game 5&lt;sup&gt;0&lt;/sup&gt; is identical to Game 5 and Game 6&lt;sup&gt;0&lt;/sup&gt; is identical to Game 6, except for the addition of lines <a href="#page-12-0">27</a> to <a href="#page-12-0">38.</a> Game 6&lt;sup&gt;0&lt;/sup&gt; is identical to Game 5&lt;sup&gt;0&lt;/sup&gt; until one of bad&lt;sup&gt;3&lt;/sup&gt; or bad&lt;sup&gt;4&lt;/sup&gt; is set to true.</p>

    <pre><code class="language-text">Game 70
1: procedure Ee (T, X)
2: i ← i + 1; Xi ← X; Ti ← T
3: Yi
       $← Yi
4: Li ← Xi ⊕ h1(Ti)
5: if Li ∈ Dom(π1) then
6: Mi ← π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)
7: if Mi ∈ Dom(π2) then
8: bad1 ← true
9: else if Yi ⊕ h2(Ti) ∈ Rng(π2) then
10: bad2 ← true
11: π2(Mi) ← Yi ⊕ h2(Ti)
12: else
13: if Yi ∈ S1 then
14: Vi ← 0
15: if ∆1 &lt; 0 then
16: Ui
                $
               ← ξ(
                   |∆1|(2n−|S4|)
                       |S1|
                             )
17: if Ui = 1 then
18: bad4 ← true
19: else if Yi ∈ S2 then
20: Vi ← 1
21: else if Yi ∈ S3 then
22: bad3 ← true
23: Zi ← π
                −1
                2
                  (Yi ⊕ h2(Ti)) ⊕ h1(Ti) ⊕ h2(Ti)
24: if Vi = 1 then
25: Zi ← π
                −1
                2
                  (Yi ⊕ h2(Ti)) ⊕ h2(Ti) ⊕ h1(Ti)
26: else if Vi = 0 then
27: Zi
             $
             ← Rng(π1) \\ (Dom(π2) ⊕ h2(Ti) ⊕ h1(Ti))
28: π2(Zi ⊕ h1(Ti) ⊕ h2(Ti)) ← Yi ⊕ h2(Ti)
29: π1(Li) ← Zi
30: Mi ← π1(Li) ⊕ h1(Ti) ⊕ h2(Ti)
     return Yi
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-13-0&quot;&gt;&lt;/span&gt;Fig. 5. The distributions of random variables in Games 6&lt;sup&gt;0&lt;/sup&gt; and 7&lt;sup&gt;0&lt;/sup&gt; are identical, with Game 7&lt;sup&gt;0&lt;/sup&gt; simplifying some of the program flow. Game 7&lt;sup&gt;0&lt;/sup&gt; is identical to Game 7, except for the addition of lines <a href="#page-12-1">15</a> to <a href="#page-12-1">18.</a></p>

    <pre><code class="language-text">\\mathrm{Game}\\ 8&#x27;
  1: procedure \\widetilde{E}(T, X, Y)
              i \\leftarrow i+1; X_i \\leftarrow X; T_i \\leftarrow T
 2:
              Y_i \\leftarrow Y
 3:
 4:
              L_i \\leftarrow X_i \\oplus h_1(T_i)
 5:
              if L_i \\in \\mathsf{Dom}(\\pi_1) then
                    M_i \\leftarrow \\pi_1(L_i) \\oplus h_1(T_i) \\oplus h_2(T_i)
  6:
 7:
                    if M_i \\in \\mathsf{Dom}(\\pi_2) then
 8:
                           \\mathsf{bad}_1 \\leftarrow \\mathsf{true}
 9:
                    else if Y_i \\oplus h_2(T_i) \\in \\mathsf{Rng}(\\pi_2) then
10:
                            \\mathsf{bad}_2 \\leftarrow \\mathsf{true}
                            \\pi_2(M_i) \\leftarrow Y_i \\oplus h_2(T_i)
11:
12:
              else
13:
                     if Y_i \\in S_1 then
                           if \\Delta_1 &lt; 0 then
U_i \\overset{\\$}{\\leftarrow} \\xi(\\frac{|\\Delta_1|(2^n - |S_4|)}{|S_1|})\\nif U_i = 1 then
14:
15:
16:
17:
                                        \\mathsf{bad}_4 \\leftarrow \\mathsf{true}
                            Z_i \\stackrel{\\$}{\\leftarrow} \\overline{\\mathsf{Rng}(\\pi_1)} \\setminus (\\mathsf{Dom}(\\pi_2) \\oplus h_2(T_i) \\oplus h_1(T_i)
18:
19:
                            \\pi_2(Z_i \\oplus h_1(T_i) \\oplus h_2(T_i)) \\leftarrow Y_i \\oplus h_2(T_i)
20:
                     else if Y_i \\in S_2 then
                            Z_i \\leftarrow \\pi_2^{-1}(Y_i \\oplus h_2(T_i)) \\oplus h_1(T_i) \\oplus h_2(T_i)
21:
22:
                     else if Y_i \\in S_3 then
23:
                            \\mathsf{bad}_3 \\leftarrow \\mathsf{true}
                            Z_i \\leftarrow \\pi_2^{-1}(Y_i \\oplus h_2(T_i)) \\oplus h_1(T_i) \\oplus h_2(T_i)
24:
25:
                     \\pi_1(L_i) \\leftarrow Z_i
             M_i \\leftarrow \\pi_1(L_i) \\oplus h_1(T_i) \\oplus h_2(T_i) return Y_i
26:
</code></pre>

    <p class="text-gray-300">&lt;span id=&quot;page-14-0&quot;&gt;&lt;/span&gt;<strong>Fig. 6.</strong> Game 8' gives the adversary control over  <span class="math">Y_i</span>  values, so the 'bad flags' can be set at least as easily as they can in Game 7'. Game 8' is identical to Game 8, except for the addition of lines 14 to 17.</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-0&quot;&gt;&lt;/span&gt;Fig. 7. Game 4, when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0. The output of CLRW2 is denoted by solid, black lines. The dashed line indicates the behaviour of an ideal tweakable block cipher. The shaded areas correspond to the ∆is We do not need to redefine Game 4 when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0.</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-2&quot;&gt;&lt;/span&gt;Fig. 8. Game 5, when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0. The solid, grey line denotes the distribution from which the output is initially sampled; this is the output distribution according to an ideal tweakable block cipher. The output is resampled according to the bold arrows. The solid, black lines represents the final distribution, which is identical to that of Game 4. Game 5 is identical to Game 5&lt;sup&gt;0&lt;/sup&gt; when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0.</p>

    <p class="text-gray-300">    <img src="_page_15_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-15-1&quot;&gt;&lt;/span&gt;Fig. 9. Game 6, when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0. The solid, black line denotes the distribution of CLRW2 in Game 6, which coincides with the distribution of outputs from an ideal tweakable block cipher. bad&lt;sup&gt;3&lt;/sup&gt; is set to true if the output is sampled from the labelled region. The dashed line indicates the behaviour of an CLRW2 in previous games; Game 6 is identical to Game 5 unless bad&lt;sup&gt;3&lt;/sup&gt; is set to true. Game 6 is identical to Game 6&lt;sup&gt;0&lt;/sup&gt; when ∆&lt;sup&gt;1&lt;/sup&gt; ≥ 0.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-1&quot;&gt;&lt;/span&gt;Fig. 10. Game 4, when ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0. The output of CLRW2 is denoted by solid, black lines. The dashed line indicates the behaviour of an ideal tweakable block cipher. We do not need to redefine Game 4 when ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-0&quot;&gt;&lt;/span&gt;Fig. 11. Game 5&lt;sup&gt;0&lt;/sup&gt; , when ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0. The solid, grey line denotes the distribution from which the output is initially sampled; this is the output distribution according to an ideal tweakable block cipher. The output is resampled according to the bold arrows. The solid, black lines represents the final distribution, which is identical to that of Game 4. The dashed lines labelled by ? indicate the incorrect probabilities realised in Game 5 from Landecker et al.'s paper if ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0.</p>

    <p class="text-gray-300">    <img src="_page_16_Figure_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">&lt;span id=&quot;page-16-2&quot;&gt;&lt;/span&gt;Fig. 12. Game 6&lt;sup&gt;0&lt;/sup&gt; , when ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0. The solid, black line denotes the distribution of CLRW2 in Game 6, which coincides with the distribution of outputs from an ideal tweakable block cipher. bad&lt;sup&gt;3&lt;/sup&gt; and bad&lt;sup&gt;4&lt;/sup&gt; are set to true if the output is sampled from the respectively labelled regions. The dashed line indicates the behaviour of an CLRW2 in previous games; Game 6&lt;sup&gt;0&lt;/sup&gt; is identical to Game 5&lt;sup&gt;0&lt;/sup&gt; unless bad&lt;sup&gt;3&lt;/sup&gt; or bad&lt;sup&gt;4&lt;/sup&gt; is set to true.</p>

    <p class="text-gray-300">As described in Section <a href="#page-8-0">5.1,</a> we can bound |∆1| in the case that ∆&lt;sup&gt;1&lt;/sup&gt; &lt; 0 as follows:</p>

    <p class="text-gray-300"><span class="math">$|\\Delta_{1}| = \\frac{|S_{1}|}{2^{n} - |S_{4}|} - \\frac{N - |S_{2}|}{N}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{|S_{1}|}{2^{n} - |S_{4}|} - 1 + \\frac{|S_{2}|}{N}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{|S_{1}| - (2^{n} - |S_{4}|)}{2^{n} - |S_{4}|} + \\frac{|S_{2}|}{N}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{-|S_{2}| - |S_{3}|}{2^{n} - |S_{4}|} + \\frac{|S_{2}|}{N}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq -\\frac{|S_{2}| + |S_{3}|}{2^{n}} + \\frac{|S_{2}|}{N}</span>$</p>

    <p class="text-gray-300"><span class="math">$= |S_{2}| \\left(\\frac{1}{N} - \\frac{1}{2^{n}}\\right) - \\frac{|S_{3}|}{2^{n}}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq |S_{2}| \\left(\\frac{1}{N} - \\frac{1}{2^{n}}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq q \\left(\\frac{1}{N} - \\frac{1}{2^{n}}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$\\leq q \\left(\\frac{1}{2^{n} - q} - \\frac{1}{2^{n}}\\right)</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{q^{2}}{2^{n}(2^{n} - q)}</span>$</p>

    <p class="text-gray-300">So:</p>

    <p class="text-gray-300"><span class="math">$|\\Delta_1| \\cdot \\frac{(2^n - |S_4|)}{|S_1|} \\le \\frac{q^2}{2^n (2^n - q)} \\cdot \\frac{(2^n - |S_4|)}{|S_1|}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\le \\frac{q^2}{2^n (2^n - q)} \\cdot \\frac{2^n}{(2^n - q)}</span>$</p>

    <p class="text-gray-300"><span class="math">$= \\frac{q^2}{(2^n - q)^2}</span>$</p>

`;
---

<BaseLayout title="A Note on the CLRW2 Tweakable Block Cipher Construction (2014/111)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/111
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="a-note-on-the-clrw2-tweakable-block-cipher-construction-2014" />
  </article>
</BaseLayout>
