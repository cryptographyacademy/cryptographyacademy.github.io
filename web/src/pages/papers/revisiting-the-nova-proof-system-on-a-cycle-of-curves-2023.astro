---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2023/969';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Revisiting the Nova Proof System on a Cycle of Curves';
const AUTHORS_HTML = 'Wilson Nguyen, Dan Boneh, Srinath Setty';

const CONTENT = `    <p class="text-gray-300">Wilson Nguyen Dan Boneh Stanford University {wdnguyen,dabo}@cs.stanford.edu Srinath Setty Microsoft Research srinath@microsoft.com</p>

    <p class="text-gray-300">Abstract. Nova is an efficient recursive proof system built from an elegant folding scheme for (relaxed) R1CS statements. The original Nova paper (CRYPTO'22) presented Nova using a single elliptic curve group of order <span class="math">p</span>. However, for improved efficiency, the implementation of Nova alters the scheme to use a 2-cycle of elliptic curves. This altered scheme is only described in the code and has not been proven secure. In this work, we point out a soundness vulnerability in the original implementation of the 2-cycle Nova system. To demonstrate this vulnerability, we construct a convincing Nova proof for the correct evaluation of <span class="math">2^{75}</span> rounds of the Minroot VDF in only 1.46 seconds. We then present a modification of the 2-cycle Nova system and formally prove its security. The modified system also happens to be more efficient than the original implementation. In particular, the modification eliminates an R1CS instance-witness pair from the recursive proof. The implementation of Nova has now been updated to use our optimized and secure system. We also show that Nova's IVC proofs are malleable and discuss several mitigations.</p>

    <p class="text-gray-300">In a recent work, Kothapalli, Setty, and Tzialla introduced an elegant folding scheme for relaxed R1CS statements [11]. The scheme leads to the Nova proof system: an efficient succinct proof system for incrementally verifiable computation, or IVC [18]. The description and analysis of Nova in [11] restricts itself to a single chain of incremental computation, namely a series of identical computation steps that produce an output which is fed directly into the next step. At every step, a single application of some function <span class="math">\\mathsf{F}</span> is applied, and a statement about the validity of the prior step is folded into an ongoing statement of validity. We refer to this as a single IVC chain.</p>

    <p class="text-gray-300">To improve efficiency, the implementation of Nova [13] uses a 2-cycle of elliptic curves. This leads to a proof system that uses two parallel IVC chains that must be linked together. Until this work, the 2-cycle Nova system was only described in the implementation code and there was no public proof of security.</p>

    <p class="text-gray-300">In this short note, we begin by formally describing the two IVC chains approach used in the Nova implementation. Instead of describing the original scheme, we present in Sections 4 and 5 a modified version of Nova that results in shorter IVC proofs. As detailed later, the modification eliminates an R1CS instance-witness pair from IVC proofs. In Section 6 we prove knowledge soundness of this modified system. The Nova implementation has now been updated [17] to use this optimized system. In Section 8 we show that Nova's IVC proofs are malleable, which can lead to a security vulnerability in some applications. We discuss strategies to mitigate this concern in Section 8.2. Sections 2 and 3 establish the terminology needed to describe Nova on a cycle of elliptic curves.</p>

    <p class="text-gray-300">In Appendix B we describe an attack on the original implementation. The attack is able to produce proofs for false statements. For example, we compute a convincing proof for an evaluation of <span class="math">2^{75}</span> rounds of the Minroot VDF [9] in only 1.46 seconds on a single laptop. The core issue that this attack exploits is that the original 2-cycle Nova system produces an IVC proof that contains an additional R1CS instance-witness pair that is not sufficiently constrained by the verifier.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2.1 Incrementally Verifiable Computation (IVC)</h2>

    <p class="text-gray-300">Incrementally verifiable computation, or IVC, was introduced by Valiant [18]. For a function <span class="math">\\mathsf{F}:\\{0,1\\}^a\\times \\{0,1\\}^b\\to \\{0,1\\}^a</span>, and some public values <span class="math">z_0,z_i\\in \\{0,1\\}^a</span>, an IVC scheme lets a prover generate a succinct</p>

    <p class="text-gray-300">proof that it knows auxiliary values  <span class="math">\\mathsf{aux}_0, \\ldots, \\mathsf{aux}_{i-1} \\in \\{0, 1\\}^b</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{c c c c} &amp;amp; \\mathsf {a u x} _ {0} &amp;amp; \\mathsf {a u x} _ {1} &amp;amp; \\mathsf {a u x} _ {i - 1} \\\\ z _ {0} \\to \\boxed {\\downarrow} &amp;amp; \\to \\boxed {\\downarrow} &amp;amp; \\to \\dots \\to &amp;amp; \\boxed {\\downarrow} \\\\ z _ {0} \\to \\boxed {\\mathsf {F}} &amp;amp; \\to \\boxed {\\mathsf {F}} &amp;amp; \\to \\dots \\to &amp;amp; \\boxed {\\mathsf {F}} \\end{array} \\to z _ {i}</span></div>

    <p class="text-gray-300">The following definition gives the syntax and security properties for an IVC scheme. The prover  <span class="math">\\mathcal{P}</span>  in this definition computes a proof for one step in the IVC chain. Iterating the prover will produce a proof  <span class="math">\\pi_i</span>  for the entire chain of length  <span class="math">i</span> .</p>

    <p class="text-gray-300"><strong>Definition 1 (IVC [18]).</strong> An IVC Scheme is a tuple of efficient algorithms  <span class="math">(\\mathsf{Setup},\\mathcal{P},\\mathcal{V})</span>  with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}(1^{\\lambda}, n) \\to \\mathsf{pp}</span> : Given a security parameter  <span class="math">1^{\\lambda}</span> , a poly-size bound  <span class="math">n \\in \\mathbb{N}</span> , outputs public parameters  <span class="math">\\mathsf{pp}</span> .</li>

      <li><span class="math">\\mathcal{P}(\\mathsf{pp},\\mathsf{F},(i,z_0,z_i),\\mathsf{aux}_i,\\pi_i)\\to \\pi_{i + 1}</span> : Given public parameters  <span class="math">\\mathsf{pp}</span> , a function  <span class="math">\\mathsf{F}:\\{0,1\\}^a\\times \\{0,1\\}^b\\to \\{0,1\\}^a</span>  computable by a circuit of size at most  <span class="math">n</span> , an index  <span class="math">i\\in \\mathbb{N}</span> , an initial input  <span class="math">z_0\\in \\{0,1\\}^a</span> , a claimed output  <span class="math">z_i\\in \\{0,1\\}^a</span> , advice  <span class="math">\\mathsf{aux}_i\\in \\{0,1\\}^b</span> , and an IVC proof  <span class="math">\\pi_i</span> , outputs a new IVC proof  <span class="math">\\pi_{i + 1}</span> .</li>

      <li><span class="math">\\mathcal{V}(\\mathsf{pp},\\mathsf{F},(i,z_0,z_i),\\pi_i)\\to 0 / 1</span> : Given public parameters  <span class="math">\\mathsf{pp}</span> , a function  <span class="math">\\mathsf{F}</span> , an index  <span class="math">i</span> , an initial input  <span class="math">z_0</span> , a claimed output  <span class="math">z_{i}</span> , and an IVC proof  <span class="math">\\pi_{i}</span> , outputs 0 (accept) or 1 (reject).</li>

    </ul>

    <p class="text-gray-300">An IVC Scheme satisfies the following properties:</p>

    <p class="text-gray-300"><strong>Completeness:</strong> For every poly-size bound  <span class="math">n \\in \\mathbb{N}</span> , for every pp in the output space of  <span class="math">\\mathsf{Setup}(1^{\\lambda}, n)</span> , for every function  <span class="math">\\mathsf{F}: \\{0, 1\\}^{a} \\times \\{0, 1\\}^{b} \\to \\{0, 1\\}^{a}</span>  computable by a circuit within the poly-size bound  <span class="math">n</span> , for every collection of elements  <span class="math">(i \\in \\mathbb{N}, z_{0}, z_{i} \\in \\{0, 1\\}^{a})</span> ,  <span class="math">\\mathsf{aux}_{i} \\in \\{0, 1\\}^{b}</span> , and IVC proof  <span class="math">\\pi_{i}</span> ,</p>

    <div class="my-4 text-center"><span class="math-block">\\operatorname * {P r} \\left[ \\begin{array}{c c} \\mathcal {V} (\\mathsf {p p}, \\mathsf {F}, (i, z _ {0}, z _ {i}), \\pi_ {i}) = 1 &amp;amp; \\pi_ {i + 1} \\leftarrow \\mathcal {P} (\\mathsf {p p}, \\mathsf {F}, (i, z _ {0}, z _ {i}), \\mathsf {a u x} _ {i}, \\pi_ {i}), \\\\ \\Downarrow &amp;amp; z _ {i + 1} \\leftarrow F (z _ {i}, \\mathsf {a u x} _ {i}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">Knowledge Soundness: Let  <span class="math">n \\in \\mathbb{N}</span>  be a poly-size bound and  <span class="math">\\ell(\\lambda)</span>  be a polynomial in the security parameter. Let  <span class="math">\\mathcal{F}</span>  be an efficient function sampling adversary that outputs a function  <span class="math">\\mathsf{F}: \\{0,1\\}^a \\times \\{0,1\\}^b \\to \\{0,1\\}^a</span>  computable by a circuit within the poly-size bound  <span class="math">n</span> . Then for every efficient IVC prover  <span class="math">P^*</span> , there exists an efficient extractor  <span class="math">\\mathcal{E}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{r} \\mathrm {P r} \\left[ \\begin{array}{c c} \\mathcal {V} (\\mathsf {p p}, \\mathsf {F}, (i, z _ {0}, z _ {i}), \\pi_ {i}) = 1 &amp;amp; \\quad \\mathsf {p p} \\leftarrow \\mathsf {S e t u p} (1 ^ {\\lambda}, n), \\\\ \\Big \\downarrow &amp;amp; \\quad \\rho \\leftarrow \\{0, 1 \\} ^ {\\ell (\\lambda)}, \\\\ z _ {i} = \\mathsf {F} (\\mathbf {z} _ {i - 1}, \\mathsf {a u x} _ {i - 1}) \\wedge &amp;amp; \\quad \\mathsf {F} \\leftarrow \\mathcal {F} (\\mathsf {p p}; \\rho), \\\\ (i = 1 \\Rightarrow \\mathbf {z} _ {i - 1} = z _ {0}) \\wedge &amp;amp; \\quad (i, z _ {0}, z _ {i}, \\pi_ {i}) \\leftarrow P ^ {*} (\\mathsf {p p}; \\rho), \\\\ (i &amp;gt; 1 \\Rightarrow \\mathcal {V} (\\mathsf {p p}, \\mathsf {F}, (i - 1, z _ {0}, \\mathbf {z} _ {i - 1}), \\pi_ {i - 1}) = 1) &amp;amp; \\quad (\\mathbf {z} _ {i - 1}, \\mathsf {a u x} _ {i - 1}), \\pi_ {i - 1} \\leftarrow \\mathcal {E} (\\mathsf {p p}; \\rho) \\end{array} \\right] \\geq 1 - \\mathsf {n e g l} (\\lambda) \\end{array}</span></div>

    <p class="text-gray-300">Remark 1 (Full Extraction). Our definition of knowledge soundness implies other notions of IVC knowledge soundness, which require the extraction of all the auxiliary values in the execution chain [1, 2, 10, 11]. Informally, consider some  <span class="math">\\rho</span>  and  <span class="math">\\mathsf{pp}</span>  sampled at random, and an adversary  <span class="math">P^{<em>}(\\mathsf{pp};\\rho)</span>  that outputs a proof for  <span class="math">i</span>  iterations of the IVC. Then the knowledge extractor  <span class="math">\\mathcal{E}</span>  can be used to construct an IVC prover for a proof of  <span class="math">i - 1</span>  iterations. Applying the definition again to the prover derived from  <span class="math">\\mathcal{E}</span>  implies that there is a knowledge extractor  <span class="math">\\mathcal{E}&#x27;</span>  that outputs a valid  <span class="math">(z_{i - 2},\\mathsf{aux}_{i - 2})</span> ,  <span class="math">\\pi_{i - 2}</span>  with all but negligible probability. We can repeat this argument inductively to extract a vector of auxiliary values  <span class="math">(\\mathsf{aux}_{i - 1},\\ldots ,\\mathsf{aux}_0)</span>  that shows that the  <span class="math">z_{i}</span>  output by  <span class="math">P^{</em>}</span>  is computed correctly from  <span class="math">z_0</span> . Note that if  <span class="math">\\mathrm{time}(\\mathcal{E}) &amp;gt; c\\cdot \\mathrm{time}(P^{*})</span>  for some constant  <span class="math">c &amp;gt; 1</span> , then this argument only works for  <span class="math">O(\\log \\lambda)</span>  steps before the running time of the extractor becomes super-polynomial in  <span class="math">\\lambda</span> . We use this sequential IVC model for consistency with the original Nova [11, 13]. In certain applications, a tree-like IVC proof system might be preferable.</p>

    <h6 id="sec-5" class="text-base font-medium mt-4">Remark 2 (Succinct Verifier).</h6>

    <p class="text-gray-300">The verifier in Definition 1 takes as input the description of the function <span class="math">\\mathsf{F}</span> which implies that its running time must be at least linear in the size of <span class="math">\\mathsf{F}</span>. One can include an additional Keygen algorithm that outputs a prover-verifier key pair <span class="math">(\\mathsf{pk},\\mathsf{vk})</span> specialized to a function <span class="math">\\mathsf{F}</span>, where the size of <span class="math">\\mathsf{vk}</span> is sub-linear in the size of <span class="math">\\mathsf{F}</span>. This shifts the work of processing the description of <span class="math">\\mathsf{F}</span> to a preprocessing phase. The verifier then takes <span class="math">\\mathsf{vk}</span> as input, instead of <span class="math">\\mathsf{F}</span>, which may lead to a faster online verifier. In fact, Nova <em>[11]</em> includes a Keygen algorithm that enables a succinct verifier.</p>

    <h6 id="sec-6" class="text-base font-medium mt-4">Remark 3 (Zero Knowledge).</h6>

    <p class="text-gray-300">In some settings one also wants the IVC scheme to be zero knowledge, but in this writeup we focus on knowledge soundness of the scheme.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.2 Committed Relaxed R1CS over a Ring</h3>

    <p class="text-gray-300">The Nova Proof system over a cycle of curves makes use of two finite fields <span class="math">\\mathbb{F}_{1}</span> and <span class="math">\\mathbb{F}_{2}</span> simultaneously. As such, it is convenient to treat the primitives used in Nova as operating on the finite commutative ring <span class="math">\\mathrm{R}:=\\mathbb{F}_{1}\\times\\mathbb{F}_{2}</span>, where addition and multiplication are defined component wise. That is, for <span class="math">a=(a_{1},a_{2})</span> and <span class="math">b=(b_{1},b_{2})</span> in <span class="math">\\mathrm{R}</span>, we define <span class="math">a+b=(a_{1}+a_{2},b_{1}+b_{2})</span> and <span class="math">a\\cdot b=(a_{1}b_{1},a_{2}b_{2})</span>.</p>

    <h6 id="sec-8" class="text-base font-medium mt-4">Definition 2.</h6>

    <p class="text-gray-300"><em>(Commitment Scheme)</em> Let <span class="math">\\mathrm{R}</span> be a finite commutative ring. A commitment scheme for vectors over <span class="math">\\mathrm{R}</span> is a pair of efficient algorithms <span class="math">(\\mathsf{Setup}_{\\mathsf{com}},\\mathsf{Commit})</span> with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{com}}(1^{\\lambda},\\mathrm{R},n)\\to\\mathsf{pp}_{\\mathsf{com}}</span>: Given a security parameter <span class="math">1^{\\lambda}\\in 1^{\\mathbb{N}}</span>, a description of a ring <span class="math">\\mathrm{R}</span>, and a poly-size bound <span class="math">n\\in\\mathbb{N}</span>, outputs public parameters <span class="math">\\mathsf{pp}_{\\mathsf{com}}</span>.</li>

      <li><span class="math">\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x)\\to c</span>: Given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{com}}</span> and input <span class="math">x\\in\\mathrm{R}^{n}</span>, outputs a commitment <span class="math">c</span>.</li>

    </ul>

    <p class="text-gray-300">These algorithms need to satisfy the following properties,</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Binding: Let <span class="math">n\\in\\mathbb{N}</span> be a poly-size bound. For every efficient adversary <span class="math">\\mathcal{A}</span> and for every finite commutative ring <span class="math">\\mathrm{R}</span> whose size is at most exponential in <span class="math">\\lambda</span>,</li>

    </ul>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{ccl}\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x_{0})=\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x_{1})\\wedge\\\\ x_{0}\\neq x_{1}\\end{array}\\right.\\quad:\\quad\\begin{array}[]{ccl}\\mathsf{pp}_{\\mathsf{com}}\\leftarrow\\mathsf{Setup}_{\\mathsf{com}}(1^{\\lambda},\\mathrm{R},n)\\\\ (x_{0},x_{1})\\leftarrow\\mathcal{A}(\\mathsf{pp}_{\\mathsf{com}})\\end{array}\\Big{\\rvert}\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Additively Homomorphic: Given two commitments <span class="math">c\\leftarrow\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x)</span>, <span class="math">c^{\\prime}\\leftarrow\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x^{\\prime})</span> to vectors <span class="math">x,\\ x^{\\prime}\\in\\mathrm{R}^{n}</span> (not necessarily distinct), there is an efficient homomorphism <span class="math">\\oplus</span> on commitments such that <span class="math">c\\oplus c^{\\prime}=\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x+x^{\\prime})</span>.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Succinct: For any <span class="math">x\\in\\mathrm{R}^{n}</span>, the commitment <span class="math">c\\leftarrow\\mathsf{Commit}(\\mathsf{pp}_{\\mathsf{com}},x)</span> must have size $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">c</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\leq\\mathsf{poly}(\\lambda,\\log(n))$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h6 id="sec-9" class="text-base font-medium mt-4">Definition 3.</h6>

    <p class="text-gray-300"><em>(Committed Relaxed R1CS over a Ring)</em> Consider <span class="math">m,n,\\ell\\in\\mathbb{N}</span> where <span class="math">m&gt;\\ell</span> and a finite commutative ring <span class="math">\\mathrm{R}</span>. Further, consider a commitment scheme <span class="math">\\mathsf{Commit}</span> for vectors over <span class="math">\\mathrm{R}</span>, where <span class="math">\\mathsf{pp}_{W}</span> and <span class="math">\\mathsf{pp}_{E}</span> are commitment parameters for vectors of size <span class="math">m-\\ell-1</span> and <span class="math">n</span> respectively.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A committed relaxed R1CS instance is a tuple <span class="math">\\mathbb{U}:=(\\bar{E},s,\\bar{W},x)</span>, where <span class="math">\\bar{E}</span> and <span class="math">\\bar{W}</span> are commitments, <span class="math">s\\in\\mathrm{R}</span>, and <span class="math">x\\in\\mathrm{R}^{\\ell}</span>.</li>

      <li>A committed relaxed R1CS instance <span class="math">\\mathbb{U}=(\\bar{E},s,\\bar{W},x)</span> is satisfiable with respect to an R1CS constraint system <span class="math">\\mathsf{R1CS}:=(A,B,C\\in\\mathrm{R}^{n\\times m})</span> if there exist a relaxed witness <span class="math">\\mathbb{W}:=(E\\in\\mathrm{R}^{n},\\ W\\in\\mathrm{R}^{m-\\ell-1})</span> such that</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\bar{E}=\\mathsf{Commit}(\\mathsf{pp}_{E},E),\\quad\\bar{W}=\\mathsf{Commit}(\\mathsf{pp}_{W},W),\\quad\\text{and}\\quad(A\\cdot Z)\\circ(B\\cdot Z)=s\\cdot(C\\cdot Z)+E</span></p>

    <p class="text-gray-300">where <span class="math">Z=(W,x,s)</span>. We refer to <span class="math">E</span> as the error vector and <span class="math">W</span> as the extended witness.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An instance-witness pair <span class="math">(\\mathbb{U},\\mathbb{W})</span> satisfies a constraint system <span class="math">\\mathsf{R1CS}</span> if <span class="math">\\mathbb{W}</span> is a satisfying relaxed witness for <span class="math">\\mathbb{U}</span>. An instance-witness pair <span class="math">(\\mathfrak{w},\\mathfrak{w})</span> pair strictly satisfies an R1CS constraint system <span class="math">\\mathsf{R1CS}</span> if <span class="math">(1)</span> the pair satisfies <span class="math">\\mathsf{R1CS}</span> and <span class="math">(2)</span> <span class="math">\\mathfrak{w}.\\bar{E}=\\hat{0}</span> is the commitment to the zero vector and <span class="math">s=1</span>.</li>

    </ul>

    <h6 id="sec-10" class="text-base font-medium mt-4">Remark 4 (Trivially Satisfiable Instance-Witness Pairs).</h6>

    <p class="text-gray-300">A committed instance-witness pair <span class="math">(\\mathbb{U}_{\\perp},\\mathbb{W}_{\\perp})</span> will denote a trivially satisfying pair for an R1CS constraint system <span class="math">\\mathsf{R1CS}</span> over <span class="math">\\mathrm{R}</span>. In Nova <em>[11]</em>, this pair is constructed by setting <span class="math">E,W,</span> and <span class="math">x</span> to appropriately sized zero vectors, <span class="math">\\bar{E},\\bar{W}</span> to be commitments to the zero vectors, and <span class="math">s</span> equal to <span class="math">0</span></p>

    <p class="text-gray-300">Folding schemes give an efficient approach to IVC. In recent years, several works [1, 2, 10-12, 15] constructed efficient folding schemes for different problems. Nova [11] introduces an elegant folding scheme, for folding two committed relaxed R1CS instances and their witnesses. Nova's folding scheme is a public-coin, one-round interactive protocol that is made non-interactive in the random oracle model using the Fiat-Shamir transform. Additionally, Nova heuristically instantiates the random oracle with a concrete hash function and assumes that this heuristic produces a protocol that is knowledge sound. A similar assumption is used in other recursive proof systems [1, 2, 10].</p>

    <p class="text-gray-300">Definition 4. A Non-Interactive Folding Scheme for Committed Relaxed R1CS consists of an underlying commitment scheme  <span class="math">(\\mathsf{Setup}_{\\mathsf{com}}, \\mathsf{Commit})</span>  (Definition 2) for committed relaxed instances (Definition 3) and a tuple of efficient algorithms  <span class="math">(\\mathsf{Fold}_{\\mathsf{Setup}}, \\mathsf{Fold}_{\\mathcal{K}}, \\mathsf{Fold}_{\\mathcal{P}}, \\mathsf{Fold}_{\\mathcal{V}})</span>  with the following interface:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Fold}_{\\mathsf{Setup}}(1^{\\lambda}, n) \\to \\mathsf{pp}</span> : Given a security parameter  <span class="math">1^{\\lambda} \\in 1^{\\mathbb{N}}</span> , a poly-size bound  <span class="math">n \\in \\mathbb{N}</span> , outputs public parameters  <span class="math">\\mathsf{pp}</span>  which contain the description of a finite commutative ring  <span class="math">\\mathbf{R}</span>  and commitment parameters  <span class="math">\\mathsf{pp}_{\\mathsf{com}}</span>  for vectors over  <span class="math">\\mathbf{R}</span>  within the size bound  <span class="math">n</span> .</li>

      <li><span class="math">\\mathsf{Fold}_{\\mathcal{K}}(\\mathsf{pp},\\mathsf{R1CS})\\to (\\mathsf{pk},\\mathsf{vk})</span>  Given public parameters  <span class="math">\\mathsf{pp}</span> , an R1CS constraint system R1CS over R within the poly-size bound  <span class="math">n</span> , outputs proving key  <span class="math">\\mathsf{pk}</span>  and verifier key  <span class="math">\\mathsf{vk}</span> .</li>

      <li><span class="math">\\mathsf{Fold}_{\\mathcal{P}}(\\mathsf{pk},(\\mathfrak{u},\\mathfrak{w}),(\\mathbb{U},\\mathbb{W}))\\to (\\bar{\\mathsf{T}},(\\mathbb{U}&#x27;,\\mathbb{W}&#x27;)):</span>  Given a proving key  <span class="math">\\mathsf{pk}</span> , two committed relaxed R1CS instance-witness pairs  <span class="math">(\\mathfrak{u},\\mathfrak{w}),(\\mathbb{U},\\mathbb{W})</span> , outputs a folding proof  <span class="math">\\bar{\\mathsf{T}}</span>  in the commitment space, and a new committed relaxed R1CS instance-witness pair  <span class="math">(\\mathbb{U}&#x27;,\\mathbb{W}&#x27;)</span> .</li>

      <li><span class="math">\\mathsf{Fold}_{\\mathcal{V}}\\left(\\mathsf{vk},\\mathfrak{u},\\mathbb{U},\\bar{\\mathsf{T}}\\right)\\to \\mathbb{U}^{\\prime}</span> : Given a verification key  <span class="math">\\mathsf{vk}</span> , two committed relaxed R1CS instances  <span class="math">\\mathfrak{u},\\mathbb{U}</span> , and a folding proof  <span class="math">\\bar{\\mathsf{T}}</span> , outputs a new committed relaxed R1CS instance  <span class="math">\\mathbb{U}^{\\prime}</span> .</li>

    </ul>

    <p class="text-gray-300">These algorithms need to satisfy the following properties:</p>

    <p class="text-gray-300">Completeness: For every poly-size bound  <span class="math">n&#x27; \\in \\mathbb{N}</span> , for every pp in the output space of  <span class="math">\\mathsf{Fold}_{\\mathsf{Setup}}(1^{\\lambda}, n&#x27;)</span> , for every poly-size  <span class="math">m, n, \\ell \\in \\mathbb{N}</span>  where  <span class="math">m &amp;gt; \\ell</span> ,  <span class="math">n&#x27; &amp;gt; m - \\ell - 1</span> ,  <span class="math">n&#x27; &amp;gt; n</span> , for every R1CS constraint system  <span class="math">\\mathsf{R1CS} := (A, B, C \\in \\mathbb{R}^{n \\times m})</span> , for every committed relaxed instance-witness pair  <span class="math">(\\mathfrak{u}, \\mathfrak{w}), (\\mathbb{U}, \\mathbb{W})</span>  for R1CS,</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathbb {U} ^ {\\prime} = \\mathbb {U} ^ {\\prime \\prime} &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {F o l d} _ {\\mathcal {K}} (\\mathsf {p p}, \\mathsf {R 1 C S}), \\\\ \\wedge &amp;amp; (\\mathfrak {T}, (\\mathbb {U} ^ {\\prime}, \\mathbb {W} ^ {\\prime})) \\leftarrow \\mathsf {F o l d} _ {\\mathcal {P}} (\\mathsf {p k}, (\\mathfrak {u}, \\mathfrak {w}), (\\mathbb {U}, \\mathbb {W})), \\\\ (\\mathfrak {u}, \\mathfrak {w}), (\\mathbb {U}, \\mathbb {W}) \\text {s a t i s f y R 1 C S} &amp;amp; \\mathbb {U} ^ {\\prime \\prime} \\leftarrow \\mathsf {F o l d} _ {\\mathcal {V}} (\\mathsf {v k}, \\mathfrak {u}, \\mathbb {U}, \\bar {\\mathsf {T}}) \\end{array} \\right] = 1</span></div>

    <p class="text-gray-300">Knowledge Soundness: Let  <span class="math">n \\in \\mathbb{N}</span>  be a poly-size bound and  <span class="math">\\ell(\\lambda)</span>  be a polynomial in the security parameter. For every efficient adversary  <span class="math">\\mathcal{P}^*</span> , there exist an efficient extractor  <span class="math">\\mathcal{E}</span>  such that</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\begin{array}{c c} \\mathbb {U} ^ {\\prime} = \\mathsf {F o l d} _ {\\mathcal {V}} (\\mathsf {v k}, \\mathfrak {u}, \\mathbb {U}, \\bar {\\mathsf {T}}) \\wedge &amp;amp; \\mathsf {p p} \\leftarrow \\mathsf {F o l d} _ {\\mathsf {S e t u p}} (1 ^ {\\lambda}, n), \\\\ (\\mathbb {U} ^ {\\prime}, \\mathbb {W} ^ {\\prime}) \\text {s a t i s f i e s R 1 C S} &amp;amp; \\rho \\leftarrow \\{0, 1 \\} ^ {\\ell (\\lambda)}, \\\\ \\Downarrow &amp;amp; (\\mathsf {R 1 C S}, (\\mathfrak {u}, \\mathbb {U}, \\bar {\\mathsf {T}}), (\\mathbb {U} ^ {\\prime}, \\mathbb {W} ^ {\\prime})) \\leftarrow \\mathcal {P} ^ {*} (\\mathsf {p p}; \\rho), \\\\ (\\mathfrak {u}, \\mathfrak {w}), (\\mathbb {U}, \\mathbb {W}) \\text {s a t i s f y R 1 C S} &amp;amp; (\\mathsf {p k}, \\mathsf {v k}) \\leftarrow \\mathsf {F o l d} _ {\\mathcal {K}} (\\mathsf {p p}, \\mathsf {R 1 C S}), \\\\ &amp;amp; (\\mathfrak {w}, \\mathbb {W}) \\leftarrow \\mathcal {E} (\\mathsf {p p}; \\rho) \\end{array} \\right] \\geq 1 - \\mathsf {n e g l} (\\lambda)</span></div>

    <p class="text-gray-300">In words, the definition of knowledge soundness states that if an adversary  <span class="math">\\mathcal{P}^<em></span>  can create a folded statement  <span class="math">\\mathbb{U}&#x27;</span>  of two statements  <span class="math">\\mathfrak{u}</span>  and  <span class="math">\\mathbb{U}</span>  and a satisfying witness  <span class="math">\\mathbb{W}&#x27;</span>  for  <span class="math">\\mathbb{U}&#x27;</span> , then an extractor  <span class="math">\\mathcal{E}</span>  for  <span class="math">\\mathcal{P}^</em></span>  can produce satisfying witnesses  <span class="math">\\mathfrak{w}</span>  for  <span class="math">\\mathfrak{u}</span>  and  <span class="math">\\mathbb{W}</span>  for  <span class="math">\\mathbb{U}</span> .</p>

    <p class="text-gray-300">Collision resistance. The Nova construction also uses collision resistant hash functions. To be comprehensive, we define these next.</p>

    <h6 id="sec-12" class="text-base font-medium mt-4">Definition 5 (Collision Resistant Hash Functions).</h6>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Let <span class="math">\\mathrm{R}</span> be a finite commutative ring such that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathrm{R}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\approx 2^{\\lambda}<span class="math">. A hash function for </span>\\mathrm{R}<span class="math"> is a pair of efficient algorithms </span>(\\mathsf{Setup}_{\\mathsf{H}},\\mathsf{H})$ with the following interface:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{Setup}_{\\mathsf{H}}(1^{\\lambda},\\mathrm{R})\\to\\mathsf{pp}_{\\mathsf{H}}</span>: Given a security parameter <span class="math">1^{\\lambda}\\in 1^{\\mathbb{N}}</span> and a description of <span class="math">\\mathrm{R}</span>, outputs public parameters <span class="math">\\mathsf{pp}_{\\mathsf{H}}</span>.</li>

      <li><span class="math">\\mathsf{H}(\\mathsf{pp}_{\\mathsf{H}},x)\\to h</span>: Given public parameters <span class="math">\\mathsf{pp}_{\\mathsf{H}}</span> and input <span class="math">x\\in\\mathrm{R}^{*}</span>, outputs a hash <span class="math">h\\in\\mathrm{R}</span>.</li>

    </ul>

    <p class="text-gray-300">A hash function is collision resistant if for every efficient adversary <span class="math">\\mathcal{A}</span>,</p>

    <p class="text-gray-300">\\[ \\Pr\\left[\\begin{array}[]{cc}\\mathsf{H}(\\mathsf{pp}_{\\mathsf{H}},m_{0})=\\mathsf{H}(\\mathsf{pp}_{\\mathsf{H}},m_{1})\\ \\wedge\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ :\\ \\ \\ \\mathsf{pp}_{\\mathsf{H}}\\leftarrow\\mathsf{Setup}_{\\mathsf{H}}(1^{\\lambda},\\mathrm{R})\\\\ m_{0}\\neq m_{1}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\end{array}\\right]\\leq\\mathsf{negl}(\\lambda) \\]</p>

    <h2 id="sec-13" class="text-2xl font-bold">3 The Nova Proof System over a Cycle of Curves: Preliminary Details</h2>

    <p class="text-gray-300">In this section and the next, we describe details about the underlying primitives in the Nova Proof System <em>[13]</em>. Section 5 describes the explicit operation of the modified IVC verifier and modified IVC prover.</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Cycle of Elliptic Curves</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">To reduce the number of constraints related to group operations, the implementation of Nova uses a cycle of elliptic curves for which the discrete log problem is hard. Specifically, the Nova implementation is generic over any cycle of elliptic curves that implements certain Rust traits (Nova implements those traits for the pasta cycle of two curves <em>[14]</em>). We denote the elliptic curve groups as <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span>. We refer to the <em>scalar field</em> of an elliptic curve group <span class="math">\\mathbb{G}</span> as the field <span class="math">\\mathbb{F}</span> whose order is $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{G}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">, and the <em>base field</em> of </span>\\mathbb{G}<span class="math"> as the field </span>\\mathbb{F}^{\\prime}<span class="math"> over which the elliptic curve is defined (i.e. the points have the form </span>(x,y)\\in\\mathbb{F}^{\\prime}\\times\\mathbb{F}^{\\prime}$).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The group <span class="math">\\mathbb{G}_{1}</span> has scalar field <span class="math">\\mathbb{F}_{1}</span> and base field <span class="math">\\mathbb{F}_{2}</span>, while <span class="math">\\mathbb{G}_{2}</span> has scalar field <span class="math">\\mathbb{F}_{2}</span> and base field <span class="math">\\mathbb{F}_{1}</span>. Group operations for <span class="math">\\mathbb{G}_{1}</span> can be efficiently expressed as constraints over the base field <span class="math">\\mathbb{F}_{2}</span>. Symmetrically, group operations for <span class="math">\\mathbb{G}_{2}</span> can be efficiently expressed as constraints over the base field <span class="math">\\mathbb{F}_{1}</span>. The groups <span class="math">\\mathbb{G}_{1}</span> and <span class="math">\\mathbb{G}_{2}</span> will be the commitment spaces for Pedersen vector commitments for vectors over <span class="math">\\mathbb{F}_{1}</span> and <span class="math">\\mathbb{F}_{2}</span> respectively.</p>

    <h4 id="sec-15" class="text-lg font-semibold mt-6">Groups and Rings</h4>

    <p class="text-gray-300">We define the ring <span class="math">\\mathrm{R}:=\\mathbb{F}_{1}\\times\\mathbb{F}_{2}</span> as the set of tuples with one element in <span class="math">\\mathbb{F}_{1}</span> and another in <span class="math">\\mathbb{F}_{2}</span>. We can naturally define the ring operations as the component-wise field operations. Similarly, define the group <span class="math">\\mathbb{G}:=\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span> and it’s group operation as the component-wise group operation.</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Commitments</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In Nova, the folding procedure requires additively homomorphic commitments to vectors over a field <span class="math">\\mathbb{F}</span>. Their specific construction <em>[11]</em> uses Pedersen vector commitments belonging to a group <span class="math">\\mathbb{G}</span> of order $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\mathbb{F}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$, for which the discrete log problem is hard. Nova’s implementation <em>[13]</em> is generic over the commitment scheme and one can supply a different commitment scheme for vectors, but we restrict our attention to Pedersen vector commitments in this paper.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We generalize the Pedersen vector commitment to the ring <span class="math">\\mathrm{R}:=\\mathbb{F}_{1}\\times\\mathbb{F}_{2}</span> by composing a Pedersen vector commitment over <span class="math">\\mathbb{F}_{1}</span> with commitment space <span class="math">\\mathbb{G}_{1}</span> and a Pedersen vector commitment over <span class="math">\\mathbb{F}_{2}</span> with commitment space <span class="math">\\mathbb{G}_{2}</span>. We write <span class="math">x^{(1)}\\in\\mathbb{F}_{1}^{n}</span> and <span class="math">x^{(2)}\\in\\mathbb{F}_{2}^{n}</span> for the left and right projections of a vector <span class="math">x\\in\\mathrm{R}^{n}</span>. Then, the commitment to <span class="math">x</span> is a pair of commitments: a commitment to <span class="math">x^{(1)}\\in\\mathbb{F}_{1}^{n}</span> and a commitment to <span class="math">x^{(2)}\\in\\mathbb{F}_{2}^{n}</span>. Concretely, this commitment to the vector <span class="math">x\\in\\mathrm{R}^{n}</span> will be an element in <span class="math">\\mathbb{G}:=\\mathbb{G}_{1}\\times\\mathbb{G}_{2}</span>.</p>

    <h4 id="sec-17" class="text-lg font-semibold mt-6">Committed relaxed instances</h4>

    <p class="text-gray-300">Consider two R1CS constraint systems</p>

    <p class="text-gray-300"><span class="math">\\mathsf{R1CS}^{(1)}:=(A_{1},B_{1},C_{1}\\in\\mathbb{F}_{1}^{n_{1}\\times m_{1}})\\quad\\text{and}\\quad\\mathsf{R1CS}^{(2)}:=(A_{2},B_{2},C_{2}\\in\\mathbb{F}_{1}^{n_{2}\\times m_{2}})</span></p>

    <p class="text-gray-300">defined over <span class="math">\\mathbb{F}_{1}</span> and <span class="math">\\mathbb{F}_{2}</span>, respectively. A committed relaxed instance for <span class="math">\\mathsf{R1CS}^{(1)}</span> is a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathbb{U}^{(1)}:=\\big{(}\\bar{\\mathbb{E}}^{(1)},\\ s^{(1)},\\ \\bar{\\mathbb{W}}^{(1)},\\ x^{(1)}\\big{)}\\qquad\\text{where}\\qquad\\bar{\\mathbb{E}}^{(1)},\\bar{\\mathbb{W}}^{(1)}\\in\\mathbb{G}_{1},\\quad s^{(1)}\\in\\mathbb{F}_{1},\\quad x^{(1)}\\in\\mathbb{F}_{1}^{\\ell_{1}}.</span></p>

    <p class="text-gray-300">The corresponding relaxed witness <span class="math">\\mathbb{W}^{(1)}=(E^{(1)},W^{(1)})</span> has an error vector <span class="math">E^{(1)}\\in\\mathbb{F}_{1}^{n_{1}}</span> and extended witness <span class="math">W^{(1)}\\in\\mathbb{F}_{1}^{m_{1}-\\ell_{1}-1}</span>. Symmetrically, a committed relaxed instance for <span class="math">\\mathsf{R1CS}^{(2)}</span> is a tuple</p>

    <p class="text-gray-300"><span class="math">\\mathbb{U}^{(2)}:=\\big{(}\\bar{\\mathbb{E}}^{(2)},\\ s^{(2)},\\ \\bar{\\mathbb{W}}^{(2)},\\ x^{(2)}\\big{)}\\qquad\\text{where}\\qquad\\bar{\\mathbb{E}}^{(2)},\\bar{\\mathbb{W}}^{(2)}\\in\\mathbb{G}_{2},\\quad s^{(2)}\\in\\mathbb{F}_{2},\\quad x^{(2)}\\in\\mathbb{F}_{2}^{\\ell_{2}}.</span></p>

    <p class="text-gray-300">The corresponding relaxed witness <span class="math">\\mathbb{W}^{(2)} = (E^{(2)}, W^{(2)})</span> has error vector <span class="math">E^{(2)} \\in \\mathbb{F}_2^{n_2}</span> and <span class="math">W^{(2)} \\in \\mathbb{F}_2^{m_2 - \\ell_2 - 1}</span>.</p>

    <p class="text-gray-300">The two constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> over <span class="math">\\mathbb{F}_1</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> over <span class="math">\\mathbb{F}_2</span> can be treated as a single constraint system <span class="math">\\mathsf{R1CS} := (A, B, C \\in \\mathbb{R}^{n \\times m})</span> over <span class="math">\\mathbb{R} := \\mathbb{F}_1 \\times \\mathbb{F}_2</span>. The constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> are simply the left and right projections of <span class="math">\\mathsf{R1CS}</span>. A strict projection of <span class="math">\\mathsf{R1CS}</span> would require the dimensions of <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> to be identical to the dimensions of <span class="math">\\mathsf{R1CS}</span>. In practice, <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> can have different dimensions. When abstractly combining the constraint systems to obtain <span class="math">\\mathsf{R1CS}</span>, we can pad the systems with dummy rows and columns so that <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> have the same dimension. In particular, <span class="math">m = \\max(m_1, m_2)</span>, <span class="math">n = \\max(n_1, n_2)</span>, and <span class="math">l = \\max(l_1, l_2)</span>. Similarly, we can treat instance-witness pairs <span class="math">(\\mathbb{U}^{(1)}, \\mathbb{W}^{(1)})</span>, <span class="math">(\\mathbb{U}^{(2)}, \\mathbb{W}^{(2)})</span> as the left and right projection of an instance-witness pair <span class="math">(\\mathbb{U}, \\mathbb{W})</span> for <span class="math">\\mathsf{R1CS}</span>.</p>

    <p class="text-gray-300"><strong>Hash Functions</strong> Hash functions <span class="math">\\mathsf{H}_1: \\mathbb{F}_1^<em> \\to \\mathbb{F}_1</span> and <span class="math">\\mathsf{H}_2: \\mathbb{F}_2^</em> \\to \\mathbb{F}_2</span> are collision resistant hash functions that take as input an arbitrary number of field elements and output a single field element which encodes the hash. In Nova, this single field element can be represented as a scalar whose bit representation is at most 250 bits long. Thus, the output hash has a unique representation in both fields, whose elements are 256 bits.¹</p>

    <p class="text-gray-300">Concretely, define <span class="math">h_1 \\coloneqq \\mathsf{H}_1(\\ldots)</span> as the output of <span class="math">\\mathsf{H}_1</span> for some arbitrary input elements <span class="math">(\\ldots) \\in \\mathbb{F}_1^*</span>. The hash can be expressed as <span class="math">h_1 = \\sum_{i \\leq 250} b_i^{(1)} \\cdot (2^{(1)})^i</span> where <span class="math">2^{(1)} \\in \\mathbb{F}_1</span> and for all <span class="math">i \\leq 250</span>, <span class="math">b_i^{(1)} \\in \\mathbb{F}_1</span> are bits in <span class="math">\\{0,1\\}</span>. The hash output <span class="math">h_1 \\coloneqq \\sum_{i \\leq 250} b_i^{(1)} \\cdot (2^{(1)})^i</span> in <span class="math">\\mathbb{F}_1</span> can be represented as an element <span class="math">h_1&#x27;</span> in <span class="math">\\mathbb{F}_2</span>. To do so, define <span class="math">h_1&#x27; := \\sum_{i \\leq 250} b_i^{(2)} \\cdot (2^{(2)})^i</span> where for all <span class="math">i</span>, the bit <span class="math">b_i^{(2)} \\in \\mathbb{F}_2</span> is the same the bit <span class="math">b_i^{(1)} \\in \\mathbb{F}_1</span> (i.e. if <span class="math">b_i^{(1)} = 1^{(1)}</span> we define <span class="math">b_i^{(2)} = 1^{(2)}</span> otherwise <span class="math">b_i^{(2)} = 0^{(2)}</span>). Symmetrically, a hash output <span class="math">h_2 := \\sum_{i \\leq 250} b_i^{(2)} \\cdot (2^{(2)})^i</span> in <span class="math">\\mathbb{F}_2</span> can be represented as an element <span class="math">h_2&#x27;</span> in <span class="math">\\mathbb{F}_1</span> in the same way.</p>

    <p class="text-gray-300">Similarly, the hash function <span class="math">\\mathsf{H} : \\{0,1\\}^* \\to \\{0,1\\}^\\lambda</span> is a collision resistant hash function whose outputs can be represented uniquely in both fields. We omit the hash parameters for <span class="math">\\mathsf{H}</span> for ease of presentation. The Nova implementation [13] uses the Poseidon hash function [7] for <span class="math">\\mathsf{H}_1</span> and <span class="math">\\mathsf{H}_2</span> and SHA-3 [5] for <span class="math">\\mathsf{H}</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">3.1 Folding over a Cycle of Curves</h2>

    <p class="text-gray-300">In Nova [11], a non-interactive folding scheme in the random oracle model is constructed by applying the Fiat-Shamir transform [6] to an interactive folding scheme. By instantiating the random oracle with an appropriate cryptographic hash function, they heuristically obtain a non-interactive folding scheme in the plain model. The construction described in [11] is limited to an R1CS constraint system R1CS defined over a field <span class="math">\\mathbb{F}</span> with commitments belonging to a group <span class="math">\\mathbb{G}</span> (with scalar field <span class="math">\\mathbb{F}</span>).</p>

    <p class="text-gray-300">We extend the construction to R1CS constraint systems R1CS defined over a ring <span class="math">\\mathbb{R} := \\mathbb{F}_1 \\times \\mathbb{F}_2</span> by composing a folding scheme for R1CS constraint systems defined over <span class="math">\\mathbb{F}_1</span> and a folding scheme for R1CS constraint systems defined over <span class="math">\\mathbb{F}_2</span>. When we fold committed relaxed instances for <span class="math">\\mathsf{R1CS}^{(1)}</span>, we implicitly mean run the folding scheme for systems over <span class="math">\\mathbb{F}_1</span>. Symmetrically, when we fold committed relaxed instances for <span class="math">\\mathsf{R1CS}^{(2)}</span>, we implicitly mean run the folding scheme for systems over <span class="math">\\mathbb{F}_2</span>. However, the random oracle calls used in both folding schemes will need to take in an argument <span class="math">\\mathsf{vk}</span>, which is derived from both systems. We describe this in more detail in the description of <span class="math">\\mathsf{Fold}_{\\mathcal{K}}</span>.</p>

    <p class="text-gray-300"><strong>Folding Setup</strong> <span class="math">\\mathsf{Fold}_{\\mathsf{Setup}}</span> takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A security parameter <span class="math">1^{\\lambda}</span>.</li>

      <li>A poly-size bound <span class="math">n \\in \\mathbb{N}</span>.</li>

    </ul>

    <p class="text-gray-300">The algorithm performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Sample a cycle of elliptic curves <span class="math">(\\mathbb{G}_1, \\mathbb{F}_1, \\mathbb{G}_2, \\mathbb{F}_2) \\gets \\mathsf{SampleCycle}(1^\\lambda)</span>.</li>

      <li>Sample collision resistant hash parameters <span class="math">\\mathsf{pp}_{\\mathsf{H}_1} \\gets \\mathsf{Setup}_{\\mathsf{H}}(1^\\lambda, \\mathbb{F}_1)</span>, <span class="math">\\mathsf{pp}_{\\mathsf{H}_2} \\gets \\mathsf{Setup}_{\\mathsf{H}}(1^\\lambda, \\mathbb{F}_2)</span>.</li>

      <li>Sample commitment parameters <span class="math">\\mathsf{pp}_{\\mathsf{com}_1} \\gets \\mathsf{Setup}_{\\mathsf{com}}(1^\\lambda, \\mathbb{F}_1, n)</span> and <span class="math">\\mathsf{pp}_{\\mathsf{com}_2} \\gets \\mathsf{Setup}_{\\mathsf{com}}(1^\\lambda, \\mathbb{F}_2, n)</span>.</li>

      <li>Output <span class="math">\\mathsf{pp} := \\big((\\mathbb{G}_1, \\mathbb{F}_1, \\mathbb{G}_2, \\mathbb{F}_2), \\quad \\mathsf{pp}_{\\mathsf{H}_1}, \\mathsf{pp}_{\\mathsf{H}_2}, \\mathsf{pp}_{\\mathsf{H}}, \\quad \\mathsf{pp}_{\\mathsf{com}_1}, \\mathsf{pp}_{\\mathsf{com}_2}\\big)</span>.</li>

    </ol>

    <p class="text-gray-300">¹The size of a digest is configurable, but a digest length of 250 bits was chosen to support a variety of popular curve cycles e.g., secp/secq, pallas/vesta (pasta curves), BN254/Grumpkin.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">²The commitment parameters <span class="math">\\mathsf{pp}_E</span>, <span class="math">\\mathsf{pp}_W</span> will be prefixes of <span class="math">\\mathsf{pp}_{\\mathsf{com}}</span> where the length is $\\max(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">E</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">6</p>

    <p class="text-gray-300">.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Folding Keygen <span class="math">\\mathsf{Fold}_{\\mathcal{K}}</span> takes in as input:</h5>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public parameters <span class="math">\\mathsf{pp}</span></li>

      <li>An R1CS constraint system <span class="math">\\mathsf{R1CS}</span> over R within the poly-size bound <span class="math">n</span>.</li>

    </ul>

    <p class="text-gray-300">The algorithm performs the following steps:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assign the verification key <span class="math">\\mathsf{vk}</span> to a hash digest of the public parameters and constraint systems</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}\\leftarrow\\mathsf{H}\\big{(}\\mathsf{pp},\\ \\mathsf{R1CS}:=(\\mathsf{R1CS}^{(1)},\\mathsf{R1CS}^{(2)})\\big{)}</span> (1)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Assign the proving key <span class="math">\\mathsf{pk}\\leftarrow(\\mathsf{pp},\\ \\mathsf{R1CS})</span> to be the public parameters and constraint systems.</li>

      <li>Output <span class="math">(\\mathsf{pk},\\mathsf{vk})</span>.</li>

    </ol>

    <h5 id="sec-20" class="text-base font-semibold mt-4">The Verification Key</h5>

    <p class="text-gray-300">The Nova folding scheme is derived from an interactive protocol via the Fiat-Shamir transform <em>[6]</em>. As such, queries to the random oracle must include a description of the entire environment. Concretely, let <span class="math">\\mathsf{H}</span> be an appropriate cryptographic hash function that heuristically instantiates a random oracle and whose outputs can be represented uniquely in both fields. The <span class="math">\\mathsf{vk}</span> element (assigned in (1)) denotes a hash digest of the environment. <span class="math">\\mathsf{Fold}_{V}</span> incorporates the elements <span class="math">\\mathsf{vk},\\ \\mathfrak{u},\\mathbb{U},\\tilde{\\mathsf{T}}</span> as arguments to its random oracle. We stress that this is needed to preserve the soundness of the Fiat-Shamir transform <em>[3]</em>, as these digest elements represent inputs to the folding verifier when viewed as an interactive protocol.</p>

    <h2 id="sec-21" class="text-2xl font-bold">4 The Augmented Constraint Systems Used in Nova</h2>

    <p class="text-gray-300">The Nova IVC Scheme operates on a pair of functions <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span>, one for each field. Abstractly, one can treat Nova as an IVC scheme for the combined function <span class="math">\\mathsf{F}:(\\mathbb{F}_{1}^{a_{1}}\\times\\mathbb{F}_{2}^{a_{2}})\\times(\\mathbb{F}_{1}^{b_{1}}\\times\\mathbb{F}_{2}^{b_{2}})\\to(\\mathbb{F}_{1}^{a_{1}}\\times\\mathbb{F}_{2}^{a_{2}})</span> of the form</p>

    <p class="text-gray-300"><span class="math">\\big{(}(z^{(1)},\\ z^{(2)}),\\ (\\mathsf{aux}^{(1)},\\ \\mathsf{aux}^{(2)})\\big{)}\\ \\ \\ \\stackrel{{\\scriptstyle\\mathsf{F}}}{{\\longmapsto}}\\ \\ \\ \\big{(}\\mathsf{F}_{1}(z^{(1)},\\ \\mathsf{aux}^{(1)}),\\ \\mathsf{F}_{2}(z^{(2)},\\ \\mathsf{aux}^{(2)})\\big{)}</span></p>

    <p class="text-gray-300">where <span class="math">\\mathsf{F}_{1}:\\mathbb{F}_{1}^{a_{1}}\\times\\mathbb{F}_{1}^{b_{1}}\\to\\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">\\mathsf{F}_{2}:\\mathbb{F}_{2}^{a_{2}}\\times\\mathbb{F}_{2}^{b_{2}}\\to\\mathbb{F}_{2}^{a_{2}}</span> are poly-size arithmetic circuits over <span class="math">\\mathbb{F}_{1}</span> and <span class="math">\\mathbb{F}_{2}</span> respectively.</p>

    <p class="text-gray-300">The Nova IVC scheme aims to prove that <span class="math">(z^{(1)}_{i},z^{(2)}_{i})</span> is the result of iterating the function <span class="math">\\mathsf{F}=(\\mathsf{F}_{1},\\mathsf{F}_{2})</span> a total of <span class="math">i</span> times starting from the input <span class="math">(z^{(1)}_{0},z^{(2)}_{0})</span> and using some auxiliary inputs. Every iteration of the IVC uses two R1CS constraint systems, one over <span class="math">\\mathbb{F}_{1}</span> and one over <span class="math">\\mathbb{F}_{2}</span>, to verify that the functions <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span> were evaluated correctly in that iteration. However, Nova augments these core constraint systems with additional constraints to verify that folding is done correctly at every iteration, and that the outputs of the previous iteration are properly forward to the current iteration. In this section we describe the two augmented constraint systems in detail.</p>

    <h5 id="sec-22" class="text-base font-semibold mt-4">The augmented constraint systems</h5>

    <p class="text-gray-300">Nova defines two augmented R1CS constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> over <span class="math">\\mathbb{F}_{1}</span> and <span class="math">\\mathbb{F}_{2}</span>. As noted in Section 3, a group operation for <span class="math">\\mathsf{G}_{1}</span> can be efficiently expressed as constraints in the base field <span class="math">\\mathbb{F}_{2}</span>. Since the folding operation requires group operations in <span class="math">\\mathsf{G}_{1}</span>, the Nova implementation does the folding of the committed instances <span class="math">\\mathfrak{u}^{(1)}</span> and <span class="math">\\mathbb{U}^{(1)}</span> for <span class="math">\\mathsf{R1CS}^{(1)}</span> in the constraints of <span class="math">\\mathsf{R1CS}^{(2)}</span>. Symmetrically, the Nova implementation does the folding of the committed instances <span class="math">\\mathfrak{u}^{(2)}</span> and <span class="math">\\mathbb{U}^{(2)}</span> for <span class="math">\\mathsf{R1CS}^{(2)}</span> in the constraints of <span class="math">\\mathsf{R1CS}^{(1)}</span>.</p>

    <p class="text-gray-300">The constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> are defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>let <span class="math">\\mathsf{R1CS}^{(1)}</span> be the R1CS constraint system for the relation <span class="math">\\mathcal{R}_{1}</span> defined in Figure 1(a).</li>

      <li>let <span class="math">\\mathsf{R1CS}^{(2)}</span> be the <span class="math">\\mathsf{R1CS}</span> constraint system for the relation <span class="math">\\mathcal{R}_{2}</span> defined in Figure 1(b).</li>

    </ul>

    <p class="text-gray-300">Intuitively, each constraint system applies one step of its function <span class="math">z_{i+1}:=\\mathsf{F}(z_{i},\\ \\mathsf{aux}_{i})</span>, folds a prior committed instance <span class="math">\\mathfrak{u}</span> into a running committed instance <span class="math">\\mathbb{U}</span> for the opposite constraint system, maintains the original inputs <span class="math">z_{0}</span>, and updates the iteration index <span class="math">i</span>. We will explain these constraint systems in more detail when we describe the operation of the prover in Section 5.3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R1 :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w(1)i+1.x := (x0, x1 ∈ F1);</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  w(1)i := (vk ∈ F1, i(1) ∈ F1, z0(1), zi(1) ∈ F1a1, auxi(1) ∈ F1b1, U(i(2), u(i(2) ∈ U(2), T(i(2) ∈ G2))  |</p>

    <p class="text-gray-300">|   |  where U(2) := G2 × F2 × G2 × F22  |</p>

    <p class="text-gray-300">|   |  If i(1) = 0(1):  |</p>

    <p class="text-gray-300">|   |  Then set U(2)i := U(2)i  |</p>

    <p class="text-gray-300">|   |  Else set U(2)i := FoldV(vk, u(i(2), U(i(2), T(i(2))  |</p>

    <p class="text-gray-300">|   |  Accept if:  |</p>

    <p class="text-gray-300">|   |  If i(1) = 0(1) then zi(1) = z0(1)  |</p>

    <p class="text-gray-300">|   |  u(2)i. E = 0(2)  |</p>

    <p class="text-gray-300">|   |  u(2)i.s = 1(2)  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R2 :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">w(2)i+1.x := (x0, x1 ∈ F2);</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  w(2)i := (vk ∈ F2, i(2) ∈ F2, z0(2), zi(2) ∈ F2a2, auxi(2) ∈ F2b2, U(i(1), u(i(1) ∈ U(1), T(i(1) ∈ G1))  |</p>

    <p class="text-gray-300">|   |  where U(1) := G1 × F1 × G1 × F12  |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R2 :=</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">If i(2) = 0(2):</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Then set U(1)i := u(1)i  |</p>

    <p class="text-gray-300">|   |  Else set U(1)i := FoldV(vk, u(i(1), U(i(1), T(i(1))  |</p>

    <p class="text-gray-300">|   |  Accept if:  |</p>

    <p class="text-gray-300">|   |  If i(2) = 0(2) then zi(2) = z0(2)  |</p>

    <p class="text-gray-300">|   |  u(1)i. E = 0(1)  |</p>

    <p class="text-gray-300">|   |  u(1)i.s = 1(1)  |</p>

    <p class="text-gray-300">|   |  u(1)i.x0 = H2(vk, i(2), z0(2), zi(2), U(i(1))  |</p>

    <p class="text-gray-300">|   |  x0 = u(1)i. x1  |</p>

    <p class="text-gray-300">|   |  x1 = H2(vk, (i+1)(2), z0(2), zi(2) := F2(zi(2), auxi(2)), U(i+1))  |</p>

    <p class="text-gray-300">(b) The relation  <span class="math">\\mathcal{R}_2</span>  defining the R1CS constraint system  <span class="math">\\mathsf{R1CS}^{(2)}</span>  on instance-witness pairs  <span class="math">(\\mathfrak{u}_{i + 1}^{(2)}.x;\\hat{w}_{i + 1}^{(1)})</span></p>

    <p class="text-gray-300">Representation of Non-native Field elements and Arithmetic</p>

    <p class="text-gray-300">Folding two committed instances <span class="math">\\mathfrak{u}^{(1)}</span> and <span class="math">\\mathbb{U}^{(1)}</span> requires not only group operations over <span class="math">\\mathsf{G}_{1}</span>, but also field operations over <span class="math">\\mathbb{F}_{1}</span>. However, the R1CS constraint system <span class="math">\\mathsf{R1CS}^{(2)}</span> over <span class="math">\\mathbb{F}_{2}</span> has to encode the folding operation as constraints over <span class="math">\\mathbb{F}_{2}</span>. To account for this, <span class="math">\\mathbb{F}_{1}</span> elements are encoded appropriately as <span class="math">\\mathbb{F}_{2}</span> elements such that non-native arithmetic can be expressed as <span class="math">\\mathbb{F}_{2}</span> constraints. The same strategy is symmetrically applied for folding constraints in <span class="math">\\mathsf{R1CS}^{(1)}</span>.</p>

    <h5 id="sec-23" class="text-base font-semibold mt-4">Hash parameters</h5>

    <p class="text-gray-300">The hash parameters <span class="math">\\mathsf{pp}_{\\mathsf{H}_{1}}</span> and <span class="math">\\mathsf{pp}_{\\mathsf{H}_{2}}</span> for <span class="math">\\mathsf{H}_{1}</span> and <span class="math">\\mathsf{H}_{2}</span> are hard-coded in the respective constraint systems. We omit the hash parameters in our paper for ease of notation, but implicitly call the hash function with their respective parameters generated in the IVC Setup.</p>

    <h5 id="sec-24" class="text-base font-semibold mt-4">Symmetry</h5>

    <p class="text-gray-300">If we omit the base case constraints, <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> are essentially symmetric constraint systems. The difference in indexing, <span class="math">\\mathfrak{u}^{(2)}_{i}</span> versus <span class="math">\\mathfrak{u}^{(1)}_{i+1}</span>, is a notional choice that does not affect the symmetry. Additionally, we want to highlight that the only constraint on <span class="math">\\mathfrak{u}^{(1)}_{i+1}.x_{0}</span> and <span class="math">\\mathfrak{u}^{(2)}_{i+1}.x_{0}</span> are that they equal <span class="math">\\mathfrak{u}^{(2)}_{i}.x_{1}</span> and <span class="math">\\mathfrak{u}^{(1)}_{i+1}.x_{1}</span> respectively. As described in Section 3, hash values can be represented in both fields uniquely; thus, this equality is well-defined. Essentially, these <em>copy</em> constraints <em>pass</em> along the hashes meant for the public IO of the opposite instance. We will describe this strategy in more detail in Section 5.3.</p>

    <h2 id="sec-25" class="text-2xl font-bold">5 The Modified Nova IVC Scheme</h2>

    <p class="text-gray-300">This section describes a modification to the prior (vulnerable) Nova proof system on a two-cycle of curves. In Section 5.2, our modifications are highlighted in red text. In Section 6, we prove that this modified Nova System is knowledge sound (Definition 1). In Section 7 we describe two approaches to further shrink the Nova proof.</p>

    <h3 id="sec-26" class="text-xl font-semibold mt-8">5.1 Setup</h3>

    <p class="text-gray-300">The Nova Setup algorithm Setup takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A security parameter <span class="math">1^{\\lambda}</span>.</li>

      <li>A poly-size bound <span class="math">n\\in\\mathbb{N}</span>.</li>

    </ul>

    <p class="text-gray-300">The algorithm outputs <span class="math">\\mathsf{pp}\\leftarrow\\mathsf{Fold}_{\\mathsf{Setup}}(1^{\\lambda},n)</span>.</p>

    <h3 id="sec-27" class="text-xl font-semibold mt-8">5.2 The Modified Nova Verifier</h3>

    <p class="text-gray-300">The Nova Verifier <span class="math">\\mathcal{V}</span> takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IVC public parameters <span class="math">\\mathsf{pp}</span>,</li>

      <li>a description of functions <span class="math">\\mathsf{F}_{1}:\\mathbb{F}_{1}^{a_{1}}\\times\\mathbb{F}_{1}^{b_{1}}\\rightarrow\\mathbb{F}_{1}^{a_{1}}\\ \\ \\ \\text{and}\\ \\ \\mathsf{F}_{2}:\\mathbb{F}_{2}^{a_{2}}\\times\\mathbb{F}_{2}^{b_{2}}\\rightarrow\\mathbb{F}_{2}^{a_{2}}</span>,</li>

      <li>an index <span class="math">i\\in\\mathbb{N}</span>,</li>

      <li>starting values <span class="math">z_{0}^{(1)}\\in\\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">z_{0}^{(2)}\\in\\mathbb{F}_{2}^{a_{2}}</span>,</li>

      <li>claimed evaluations <span class="math">z_{i}^{(1)}\\in\\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">z_{i}^{(2)}\\in\\mathbb{F}_{2}^{a_{2}}</span>, and</li>

      <li>an IVC Proof for iteration <span class="math">i</span>, namely <span class="math">\\pi_{i}\\coloneqq\\big{(}(\\mathfrak{u}^{(2)}_{i},\\mathsf{w}^{(2)}_{i}),\\ \\ (\\mathbb{U}^{(1)}_{i},\\mathbb{W}^{(1)}_{i}),\\ \\ (\\mathbb{U}^{(2)}_{i},\\mathbb{W}^{(2)}_{i})\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">The verifier first runs the following initial procedure, which can be treated as a preprocessing phase (as discussed in Remark 2):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given functions <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span>, deterministically generate augmented R1CS constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> which implement relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> from Figures 1(a) and 1(b)</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute the folding verification key</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\ \\cdot\\ ,\\mathsf{vk})\\leftarrow\\mathsf{Fold}_{\\mathcal{K}}\\big{(}\\mathsf{pp},\\ \\mathsf{R1CS}:=(\\mathsf{R1CS}^{(1)},\\mathsf{R1CS}^{(2)})\\big{)}</span></p>

    <p class="text-gray-300">Then, the verifier accepts if the following six conditions are met:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The index <span class="math">i</span> must be greater than 0.</li>

      <li><span class="math">\\mathfrak{u}^{(2)}_{i}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z^{(1)}_{0},z^{(1)}_{i},\\mathbb{U}^{(2)}_{i}\\big{)}</span></li>

      <li><span class="math">\\mathfrak{u}^{(2)}_{i}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},i^{(2)},z^{(2)}_{0},z^{(2)}_{i},\\mathbb{U}^{(1)}_{i}\\big{)}</span></li>

      <li>The pair <span class="math">(\\mathbb{U}^{(1)}_{i},\\mathbb{W}^{(1)}_{i})</span> satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>The pair <span class="math">(\\mathbb{U}^{(2)}_{i},\\mathbb{W}^{(2)}_{i})</span> satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>The pair <span class="math">(\\mathfrak{u}^{(2)}_{i},\\mathsf{w}^{(2)}_{i})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

    </ol>

    <h4 id="sec-28" class="text-lg font-semibold mt-6">Vulnerability in Nova</h4>

    <p class="text-gray-300">The old IVC proof <span class="math">\\pi_{i}</span> contained an additional instance-witness pair <span class="math">(\\mathfrak{u}^{(1)}_{i},\\mathsf{w}^{(1)}_{i})</span>.</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}:=\\big{(}(\\mathfrak{u}^{(1)}_{i},\\mathsf{w}^{(1)}_{i}),\\ \\ (\\mathbb{U}^{(1)}_{i},\\mathbb{W}^{(1)}_{i}),\\ \\ (\\mathfrak{u}^{(2)}_{i},\\mathsf{w}^{(2)}_{i}),\\ \\ (\\mathbb{U}^{(2)}_{i},\\mathbb{W}^{(2)}_{i})\\big{)}</span></p>

    <p class="text-gray-300">Here we denote modifications to the verifier in red font. The old verifier checked that <span class="math">(\\mathfrak{u}^{(1)}_{i},\\mathsf{w}^{(1)}_{i})</span> strictly satisfied <span class="math">\\mathsf{R1CS}^{(1)}</span>, and that <span class="math">\\mathfrak{u}^{(1)}_{i}.x_{1}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z^{(1)}_{0},z^{(1)}_{i},\\mathbb{U}^{(2)}_{i}\\big{)}</span> instead of <span class="math">\\mathfrak{u}^{(2)}_{i}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z^{(1)}_{0},z^{(1)}_{i},\\mathbb{U}^{(2)}_{i}\\big{)}</span>. An assumption made in the implementation was that the instance <span class="math">\\mathfrak{u}^{(1)}_{i}</span> was folded into <span class="math">\\mathbb{U}^{(1)}_{i}</span>. However, there were no checks that guaranteed this to be true. With the additional symmetry of the relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span>, an attacker could generate adversarial instances <span class="math">\\mathfrak{u}^{(1)}_{i},\\ \\mathfrak{u}^{(2)}_{i}</span> that were trivially satisfiable for any choice of <span class="math">i&gt;2</span>. The attack required only two iterations of the IVC prover. To demonstrate the attack, we generated a convincing IVC proof of <span class="math">2^{75}</span> iterations of the Minroot VDF <em>[9]</em> in 1.46 seconds on a laptop, which should be impossible for a secure IVC scheme.</p>

    <p class="text-gray-300">To remediate this issue, we removed the pair <span class="math">(\\mathfrak{u}^{(1)}_{i},\\mathsf{w}^{(1)}_{i})</span> from the IVC proof. Additionally, we shifted the hash check to <span class="math">\\mathfrak{u}^{(2)}_{i}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z^{(1)}_{0},z^{(1)}_{i},\\mathbb{U}^{(2)}_{i}\\big{)}</span>. This change also pleasantly reduces the IVC proof size. For a complete description of the old Nova verifier see Appendix A. Additionally, a complete description of the vulnerability can be found in Appendix B, along with a proof of concept attack on Nova’s implementation of the Minroot VDF.</p>

    <h3 id="sec-29" class="text-xl font-semibold mt-8">5.3 The Modified Nova Prover</h3>

    <p class="text-gray-300">In this section, we describe a modified Nova prover. The algorithm is similar to the old Nova prover, but the generated IVC proof <span class="math">\\pi_{i+1}</span> omits the pair <span class="math">(\\mathfrak{u}^{(1)}_{i+1},\\mathsf{w}^{(1)}_{i+1})</span>, which caused the original vulnerability (Appendix B). We first describe an initial procedure, then the base case step of the Nova prover, and then the recursive step as illustrated in Figure 2.</p>

    <h4 id="sec-30" class="text-lg font-semibold mt-6">Initial Procedure</h4>

    <p class="text-gray-300">The prover performs an initial procedure identical to the initial procedure of the verifier:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given functions <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span>, deterministically generate augmented R1CS constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> which implement relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span>.</li>

      <li>Compute the folding prover and verifier key</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\mathsf{pk},\\mathsf{vk})\\leftarrow\\mathsf{Fold}_{\\mathcal{K}}\\big{(}\\mathsf{pp},\\ \\mathsf{R1CS}:=(\\mathsf{R1CS}^{(1)},\\mathsf{R1CS}^{(2)})\\big{)}</span></p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 2: An illustration of the key parts of the prover's operation in the non-base case.</p>

    <p class="text-gray-300">The Base Case The Nova Prover  <span class="math">\\mathcal{P}</span>  takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IVC public parameters  <span class="math">\\mathfrak{pp}</span> .</li>

      <li>A description of functions  <span class="math">\\mathsf{F}_1: \\mathbb{F}_1^{a_1} \\times \\mathbb{F}_1^{b_1} \\to \\mathbb{F}_1^{a_1}</span>  and  <span class="math">\\mathsf{F}_2: \\mathbb{F}_2^{a_2} \\times \\mathbb{F}_2^{b_2} \\to \\mathbb{F}_2^{a_2}</span> .</li>

      <li>Starting values  <span class="math">z_0^{(1)} \\in \\mathbb{F}_1^{a_1}</span>  and  <span class="math">z_0^{(2)} \\in \\mathbb{F}_2^{a_2}</span> .</li>

      <li>Auxiliary inputs  <span class="math">\\mathsf{aux}_0^{(1)}\\in \\mathbb{F}_1^{b_1}</span>  and  <span class="math">\\mathsf{aux}_0^{(2)}\\in \\mathbb{F}_2^{b_2}</span> .</li>

    </ul>

    <p class="text-gray-300">The prover proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute New Pair for  <span class="math">\\mathsf{R1CS}^{(1)}</span> : Compute the new committed pair  <span class="math">(\\mathfrak{u}_1^{(1)},\\mathfrak{w}_1^{(1)})</span>  for  <span class="math">\\mathsf{R1CS}^{(1)}</span>  as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define an initial dummy instance as  <span class="math">\\mathfrak{u}_0^{(2)}\\coloneqq \\left(\\bar{\\mathbf{0}}^{(2)},1^{(2)},\\bar{\\mathbf{0}}^{(2)},x\\coloneqq (x_0,x_1)\\right)</span>  where</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">x _ {0} := \\mathsf {H} _ {1} \\big (\\mathsf {v k}, 0 ^ {(1)}, z _ {0} ^ {(1)}, z _ {0} ^ {(1)}, \\mathbb {U} _ {\\perp} ^ {(2)} \\big) \\qquad \\text {a n d} \\qquad x _ {1} := \\mathsf {H} _ {2} \\big (\\mathsf {v k}, 0 ^ {(2)}, z _ {0} ^ {(2)}, z _ {0} ^ {(2)}, \\mathbb {U} _ {\\perp} ^ {(1)} \\big)</span></div>

    <p class="text-gray-300">This instance will not be folded into any running instance.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define  <span class="math">\\hat{w}_1^{(1)}\\coloneqq (\\mathsf{vk},0^{(1)},z_0^{(1)},z_0^{(1)},\\mathsf{aux}_0^{(1)},\\mathbb{U}_{\\perp}^{(2)},\\mathfrak{u}_0^{(2)},\\bar{\\mathbf{0}}^{(2)})</span>  as the relation witness for  <span class="math">\\mathcal{R}_1</span> . Then, compute the extended witness  <span class="math">w_{1}^{(1)}</span>  by performing the computation on  <span class="math">\\hat{w}_1^{(1)}</span>  required to satisfy the constraints expressed in R1CS <span class="math">^{(1)}</span> .</li>

      <li>Commit to the extended witness  <span class="math">\\bar{\\mathsf{w}}_1^{(1)}\\gets \\mathsf{Commit}\\big(\\mathsf{pp}_W^{(1)},w_1^{(1)}\\big)</span></li>

      <li>Define  <span class="math">\\mathbb{U}_1^{(2)}\\coloneqq \\mathbb{U}_{\\perp}^{(2)}</span>  and  <span class="math">\\mathbb{W}_1^{(2)}\\coloneqq \\mathbb{W}_{\\perp}^{(2)}</span></li>

      <li>Define  <span class="math">x_0 \\coloneqq \\mathfrak{u}_0^{(2)} \\cdot x_1</span>  and compute  <span class="math">x_1 \\coloneqq \\mathsf{H}_1(\\mathsf{vk}, 1^{(1)}, z_0^{(1)}, z_1^{(1)} \\coloneqq \\mathsf{F}_1(z_0^{(1)}, \\mathsf{aux}_0^{(1)}), \\mathbb{U}_1^{(2)})</span> .</li>

      <li>Assign  <span class="math">\\mathfrak{u}_1^{(1)}\\coloneqq \\left(\\bar{\\mathbf{0}}^{(1)},1^{(1)},\\bar{\\mathbf{w}}_1^{(1)},(x_0,x_1)\\right)</span>  and  <span class="math">\\mathsf{w}_1^{(1)}\\coloneqq \\left(\\bar{\\mathbf{0}}^{(1)},w_1^{(1)}\\right)</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute New Pair for  <span class="math">\\mathsf{R1CS}^{(2)}</span> : Compute the new committed pair  <span class="math">(\\mathfrak{u}_1^{(2)},\\mathfrak{w}_1^{(2)})</span>  for  <span class="math">\\mathsf{R1CS}^{(2)}</span>  as follows:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{w}_1^{(2)} \\coloneqq (\\mathsf{vk}, 0^{(2)}, z_0^{(2)}, z_0^{(2)}, \\mathsf{aux}_0^{(2)}, \\mathbb{U}_{\\perp}^{(1)}, \\mathfrak{u}_1^{(1)}, \\bar{0}^{(2)})</span> as the relation witness for <span class="math">\\mathcal{R}_2</span>. Then, compute the extended witness <span class="math">w_1^{(2)}</span> by performing the computation on <span class="math">\\hat{w}_1^{(2)}</span> required to satisfy the constraints expressed in <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_1^{(2)} \\gets \\mathsf{Commit}(\\mathrm{pp}_W^{(2)}, w_1^{(2)})</span>.</li>

      <li>Define <span class="math">\\mathbb{U}_1^{(1)} \\coloneqq \\mathfrak{u}_1^{(1)}</span> and <span class="math">\\mathbb{W}_1^{(1)} \\coloneqq \\mathbf{w}_1^{(1)}</span>.</li>

      <li>Define <span class="math">x_0 \\coloneqq \\mathfrak{u}_1^{(1)} \\cdot x_1</span> and compute <span class="math">x_1 \\coloneqq \\mathsf{H}_2\\big(\\mathsf{vk}, 1^{(2)}, z_0^{(2)}, z_1^{(2)} \\coloneqq \\mathsf{F}_2(z_0^{(2)}, \\mathsf{aux}_0^{(2)}), \\mathbb{U}_1^{(1)}\\big)</span>.</li>

      <li>Assign <span class="math">\\mathfrak{u}_1^{(2)} \\coloneqq \\left(\\bar{0}^{(2)}, 1^{(2)}, \\bar{\\mathsf{w}}_1^{(2)}, (x_0, x_1)\\right)</span> and <span class="math">\\mathbf{w}_1^{(2)} \\coloneqq \\left(\\vec{0}^{(2)}, w_1^{(2)}\\right)</span>.</li>

      <li>Output Prover State: Output IVC Proof for step 1</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\pi_ {1} := \\left(\\left(\\mathfrak {u} _ {1} ^ {(2)}, \\mathbf {w} _ {1} ^ {(2)}\\right), \\left(\\mathbb {U} _ {1} ^ {(1)}, \\mathbb {W} _ {1} ^ {(1)}\\right), \\left(\\mathbb {U} _ {1} ^ {(2)}, \\mathbb {W} _ {1} ^ {(2)}\\right)\\right)</span></div>

    <p class="text-gray-300">along with new evaluations <span class="math">z_1^{(1)} \\coloneqq \\mathsf{F}_1(z_0^{(1)}, \\mathsf{aux}_0^{(1)})</span> and <span class="math">z_1^{(2)} \\coloneqq \\mathsf{F}_2(z_0^{(2)}, \\mathsf{aux}_0^{(2)})</span>. These outputs are sufficient to execute another step of the Nova prover for iteration 1.</p>

    <p class="text-gray-300">The Non-Base Case The Nova Prover <span class="math">\\mathcal{P}</span> takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IVC public parameters <span class="math">\\mathsf{pp}</span>.</li>

      <li>Constraint Systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>An index <span class="math">i \\in \\mathbb{N}</span>, where <span class="math">i \\geq 1</span>.</li>

      <li>Starting values <span class="math">z_0^{(1)} \\in \\mathbb{F}_1^{a_1}</span> and <span class="math">z_0^{(2)} \\in \\mathbb{F}_2^{a_2}</span>.</li>

      <li>Evaluations <span class="math">z_{i}^{(1)}\\in \\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">z_{i}^{(2)}\\in \\mathbb{F}_{2}^{a_{2}}</span>.</li>

      <li>Auxiliary inputs <span class="math">\\mathsf{aux}_i^{(1)}\\in \\mathbb{F}_1^{b_1}</span> and <span class="math">\\mathsf{aux}_i^{(2)}\\in \\mathbb{F}_2^{b_2}</span>.</li>

      <li>An IVC Proof for Iteration <span class="math">i</span> <span class="math">\\pi_{i} := \\big((\\mathfrak{u}_{i}^{(2)}, \\mathbf{w}_{i}^{(2)}), (\\mathbb{U}_{i}^{(1)}, \\mathbb{W}_{i}^{(1)}), (\\mathbb{U}_{i}^{(2)}, \\mathbb{W}_{i}^{(2)})\\big)</span>.</li>

    </ul>

    <p class="text-gray-300">The prover proceeds as follows (see also Figure 2):</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold Prior Pairs for <span class="math">\\mathsf{R1CS}^{(2)}</span>: Fold the committed pairs <span class="math">(\\mathfrak{u}_i^{(2)},\\mathbf{w}_i^{(2)})</span> and <span class="math">(\\mathbb{U}_i^{(2)},\\mathbb{W}_i^{(2)})</span> for <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} _ {\\mathcal {P}} \\left(\\mathrm {p k}, \\left(\\mathfrak {u} _ {i} ^ {(2)}, \\mathbf {w} _ {i} ^ {(2)}\\right), \\left(\\mathbb {U} _ {i} ^ {(2)}, \\mathbb {W} _ {i} ^ {(2)}\\right)\\right)\\rightarrow \\left(\\bar {\\Upsilon} _ {i} ^ {(2)}, \\left(\\mathbb {U} _ {i + 1} ^ {(2)}, \\mathbb {W} _ {i + 1} ^ {(2)}\\right)\\right)</span></div>

    <p class="text-gray-300">Obtain a folding proof <span class="math">\\bar{\\Upsilon}_i^{(2)}</span> and new committed relaxed instance-witness pair <span class="math">(\\mathbb{U}_{i + 1}^{(2)},\\mathbb{W}_{i + 1}^{(2)})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute New Pair for <span class="math">\\mathsf{R1CS}^{(1)}</span>: Compute the new committed pair <span class="math">(\\mathfrak{u}_{i + 1}^{(1)},\\mathbf{w}_{i + 1}^{(1)})</span> for <span class="math">\\mathsf{R1CS}^{(1)}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{w}_{i+1}^{(1)} := (\\mathsf{vk}, i^{(1)}, z_0^{(1)}, z_i^{(1)}, \\mathsf{aux}_i^{(1)}, \\mathbb{U}_i^{(2)}, \\mathfrak{u}_i^{(2)}, \\bar{\\Upsilon}_i^{(2)})</span> as the relation witness for <span class="math">\\mathcal{R}_1</span>. Then, compute the extended witness <span class="math">w_{i+1}^{(1)}</span> by performing the computation on <span class="math">\\hat{w}_{i+1}^{(1)}</span> required to satisfy the constraints expressed in <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_{i + 1}^{(1)}\\gets \\mathsf{Commit}(\\mathrm{pp}_W^{(1)},w_{i + 1}^{(1)})</span></li>

      <li>Define <span class="math">x_0 \\coloneqq \\mathfrak{u}_i^{(2)} \\cdot x_1</span> and compute <span class="math">x_1 \\coloneqq \\mathsf{H}_1\\big(\\mathsf{vk}, (i + 1)^{(1)}, z_0^{(1)}, z_{i + 1}^{(1)} \\coloneqq \\mathsf{F}_1(z_i^{(1)}, \\mathsf{aux}_i^{(1)}), \\mathbb{U}_{i + 1}^{(2)})</span></li>

      <li>Assign <span class="math">\\mathfrak{u}_{i + 1}^{(1)} \\coloneqq \\left(\\bar{0}^{(1)}, 1^{(1)}, \\bar{\\mathsf{w}}_{i + 1}^{(1)}, (x_0, x_1)\\right)</span> and <span class="math">\\mathbf{w}_{i + 1}^{(1)} \\coloneqq \\left(\\vec{0}^{(1)}, w_{i + 1}^{(1)}\\right)</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold Pairs for <span class="math">\\mathsf{R1CS}^{(1)}</span>: Fold the newly computed pair <span class="math">(\\mathfrak{u}_{i + 1}^{(1)},\\mathbf{w}_{i + 1}^{(1)})</span> with the committed pair <span class="math">(\\mathbb{U}_i^{(1)},\\mathbb{W}_i^{(1)})</span> for <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} _ {\\mathcal {P}} \\left(\\mathrm {p k}, \\left(\\mathfrak {u} _ {i + 1} ^ {(1)}, \\mathbf {w} _ {i + 1} ^ {(1)}\\right), \\left(\\mathbb {U} _ {i} ^ {(1)}, \\mathbb {W} _ {i} ^ {(1)}\\right)\\right)\\rightarrow \\left(\\bar {\\Upsilon} _ {i} ^ {(1)}, \\left(\\mathbb {U} _ {i + 1} ^ {(1)}, \\mathbb {W} _ {i + 1} ^ {(1)}\\right)\\right)</span></div>

    <p class="text-gray-300">Obtain a folding proof <span class="math">\\bar{\\Upsilon}_i^{(1)}</span> and new committed relaxed instance-witness pair <span class="math">(\\mathbb{U}_{i + 1}^{(1)},\\mathbb{W}_{i + 1}^{(1)})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute New Pair for <span class="math">\\mathsf{R1CS}^{(2)}</span>: Compute the new committed pair <span class="math">(\\mathfrak{u}_{i+1}^{(2)},\\mathfrak{w}_{i+1}^{(2)})</span> for <span class="math">\\mathsf{R1CS}^{(2)}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\bar{w}_{i+1}^{(2)} := (\\mathsf{vk}, i^{(2)}, z_0^{(2)}, z_i^{(2)}, \\mathsf{aux}_i^{(2)}, \\mathbb{U}_i^{(1)}, \\mathfrak{u}_{i+1}^{(1)}, \\bar{\\mathsf{T}}_i^{(1)})</span> as the relation witness for <span class="math">\\mathcal{R}_2</span>. Then, compute the extended witness <span class="math">w_{i+1}^{(2)}</span> by performing the computation on <span class="math">\\bar{w}_{i+1}^{(2)}</span> required to satisfy the constraints expressed in <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_{i+1}^{(2)} \\gets \\mathsf{Commit}(\\mathsf{pp}_W^{(2)}, w_{i+1}^{(2)})</span>.</li>

      <li>Define <span class="math">x_0 := \\mathfrak{u}_{i+1}^{(1)} \\cdot x_1</span> and compute <span class="math">x_1 := \\mathsf{H}_2\\big(\\mathsf{vk}, (i+1)^{(2)}, z_0^{(2)}, z_{i+1}^{(2)} := \\mathsf{F}_2(z_i^{(2)}, \\mathsf{aux}_i^{(2)}), \\mathbb{U}_{i+1}^{(1)}\\big)</span>.</li>

      <li>Assign <span class="math">\\mathfrak{u}_{i+1}^{(2)} := (\\bar{0}^{(2)}, 1^{(2)}, \\bar{\\mathfrak{w}}_{i+1}^{(2)}, (x_0, x_1))</span> and <span class="math">\\mathfrak{w}_{i+1}^{(2)} := (\\bar{0}^{(2)}, w_{i+1}^{(2)})</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output Prover State: Output IVC Proof for step <span class="math">i + 1</span></li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\pi_{i+1} := \\left((\\mathfrak{u}_{i+1}^{(2)}, \\mathfrak{w}_{i+1}^{(2)}), \\quad (\\mathbb{U}_{i+1}^{(1)}, \\mathbb{W}_{i+1}^{(1)}), \\quad (\\mathbb{U}_{i+1}^{(2)}, \\mathbb{W}_{i+1}^{(2)})\\right)</span></div>

    <p class="text-gray-300">along with new evaluations <span class="math">z_{i+1}^{(1)} \\coloneqq \\mathsf{F}_1(z_i^{(1)}, \\mathsf{aux}_i^{(1)})</span> and <span class="math">z_{i+1}^{(2)} \\coloneqq \\mathsf{F}_2(z_i^{(2)}, \\mathsf{aux}_i^{(2)})</span>. These outputs are sufficient to execute another step of the Nova prover for iteration <span class="math">i + 1</span>.</p>

    <p class="text-gray-300">This completes our description of the prover.</p>

    <h2 id="sec-31" class="text-2xl font-bold">6 Proof of security</h2>

    <p class="text-gray-300"><strong>Theorem 1.</strong> If the non-interactive folding scheme is knowledge sound (Definition 4) and the hash function is collision resistant (Definition 5), then our modified Nova IVC scheme is knowledge sound (Definition 1).</p>

    <p class="text-gray-300"><strong>Proof</strong> Let <span class="math">n \\in \\mathbb{N}</span> be a poly-size bound and <span class="math">\\ell(\\lambda)</span> be a polynomial in the security parameter. Let <span class="math">\\mathsf{pp}</span> and <span class="math">\\rho</span> be public parameters and randomness sampled as <span class="math">\\mathsf{pp} \\gets \\mathsf{Setup}(1^{\\lambda})</span> and <span class="math">\\rho \\gets \\{0,1\\}^{\\ell(\\lambda)}</span>. Consider an adversary <span class="math">\\mathcal{F}(\\mathsf{pp}; \\rho)</span> that outputs functions <span class="math">(\\mathsf{F}_1, \\mathsf{F}_2)</span>, and a malicious prover <span class="math">P^*(\\mathsf{pp}; \\rho)</span> that outputs a tuple <span class="math">(i, (z_0^{(1)}, z_0^{(2)}), (z_i^{(1)}, z_i^{(2)}), \\pi_i)</span> with</p>

    <div class="my-4 text-center"><span class="math-block">\\pi_i := \\left((\\mathfrak{u}_i^{(2)}, \\mathfrak{w}_i^{(2)}), \\quad (\\mathbb{U}_i^{(1)}, \\mathbb{W}_i^{(1)}), \\quad (\\mathbb{U}_i^{(2)}, \\mathbb{W}_i^{(2)})\\right). \\tag{2}</span></div>

    <p class="text-gray-300">We assume that <span class="math">\\mathcal{V}(\\mathsf{pp}, (\\mathsf{F}_1, \\mathsf{F}_2), (i, (z_0^{(1)}, z_0^{(2)}), (z_i^{(1)}, z_i^{(2)})), \\pi_i) = 1</span>. We need to construct an efficient extractor <span class="math">\\mathcal{E}(\\mathsf{pp}; \\rho)</span> that outputs valid <span class="math">(z_{i-1}^{(1)}, \\mathsf{aux}_{i-1}^{(1)})</span>, <span class="math">(z_{i-1}^{(2)}, \\mathsf{aux}_{i-1}^{(2)})</span>, and <span class="math">\\pi_{i-1}</span> with high probability.</p>

    <p class="text-gray-300">Since the verifier accepts the proof <span class="math">\\pi_i</span> in equation (2) the following conditions must hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Condition 1. The index <span class="math">i</span> must be greater than 0.</li>

      <li>Condition 2. <span class="math">\\mathfrak{u}_i^{(2)} \\cdot x_0 = \\mathsf{H}_1\\big(\\mathsf{vk}, i^{(1)}, z_0^{(1)}, z_i^{(1)}, \\mathbb{U}_i^{(2)}\\big)</span></li>

      <li>Condition 3. <span class="math">\\mathfrak{u}_i^{(2)} \\cdot x_1 = \\mathsf{H}_2\\big(\\mathsf{vk}, i^{(2)}, z_0^{(2)}, z_i^{(2)}, \\mathbb{U}_i^{(1)}\\big)</span></li>

      <li>Condition 4. The pair <span class="math">(\\mathbb{U}_i^{(1)}, \\mathbb{W}_i^{(1)})</span> satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>Condition 5. The pair <span class="math">(\\mathbb{U}_i^{(2)}, \\mathbb{W}_i^{(2)})</span> satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>Condition 6. The pair <span class="math">(\\mathfrak{u}_i^{(2)}, \\mathfrak{w}_i^{(2)})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

    </ul>

    <h2 id="sec-32" class="text-2xl font-bold">6.1 The case <span class="math">i = 1</span></h2>

    <p class="text-gray-300">Here we consider the case when <span class="math">\\mathbf{i}</span> is equal to 1.</p>

    <p class="text-gray-300">By (Condition 6), the pair <span class="math">(\\mathfrak{u}_1^{(2)}, \\mathfrak{w}_1^{(2)})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span> which implements relation <span class="math">\\mathcal{R}_2</span>. This implies that the extended witness <span class="math">\\mathfrak{w}_1^{(2)} \\cdot w^{(2)}</span> contains an <span class="math">\\mathcal{R}_2</span> witness <span class="math">\\hat{w}_1^{(2)}</span> of the form</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{w}_1^{(2)} := \\left(\\mathsf{vk}&#x27; \\in \\mathbb{F}_2, \\quad j \\in \\mathbb{F}_2, \\quad z, z&#x27; \\in \\mathbb{F}_2^{p_2}, \\quad \\mathsf{aux}_0^{(2)} \\in \\mathbb{F}_2^{b_2}, \\quad \\mathbb{U}_0^{(1)}, \\mathfrak{u}_1^{(1)} \\in \\mathcal{U}^{(1)}, \\quad \\bar{\\mathsf{T}}_0^{(1)} \\in \\mathbb{G}_1\\right).</span></div>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{1}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(2)},\\ z,\\ \\mathsf{F}_{2}(z^{\\prime},\\mathsf{aux}^{(2)}_{0}),\\ \\mathbb{U}\\big{)}</span> (3)</p>

    <p class="text-gray-300">for some instance <span class="math">\\mathbb{U}\\in\\mathcal{U}^{(1)}</span> (dependent on <span class="math">j</span>). By (Condition 3), we know that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{1}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},1^{(2)},z^{(2)}_{0},z^{(2)}_{1},\\mathbb{U}^{(1)}_{1}\\big{)}.</span> (4)</p>

    <p class="text-gray-300">Therefore, by equations (3) and (4) and the collision resistance of <span class="math">\\mathsf{H}_{2}</span>, we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(2)},\\ z,\\ \\mathsf{F}_{2}(z^{\\prime},\\mathsf{aux}^{(2)}_{0}),\\ \\mathbb{U}\\big{)}=\\big{(}\\mathsf{vk},1^{(2)},z^{(2)}_{0},z^{(2)}_{1},\\mathbb{U}^{(1)}_{1}\\big{)},</span> (5)</p>

    <p class="text-gray-300">otherwise there is an explicit collision finder on the hash function <span class="math">\\mathsf{H}_{2}</span>. By equation (5), we can conclude that</p>

    <p class="text-gray-300"><span class="math">j=0^{(2)},\\quad z=z^{(2)}_{0},\\quad\\mathsf{F}_{2}(z^{\\prime},\\mathsf{aux}^{(2)}_{0})=z^{(2)}_{1},\\quad\\mathbb{U}=\\mathbb{U}^{(1)}_{1}</span> (6)</p>

    <p class="text-gray-300">Since <span class="math">j=0^{(2)}</span>, the relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">z=z^{\\prime}\\quad\\text{and}\\quad\\mathbb{U}=\\mathfrak{u}^{(1)}_{1}</span> (7)</p>

    <p class="text-gray-300">By equation (6) and (7), we can conclude</p>

    <p class="text-gray-300"><span class="math">z^{(2)}_{1}</span> <span class="math">=\\mathsf{F}_{2}(z^{(2)}_{0},\\mathsf{aux}^{(2)}_{0})</span> (8) <span class="math">\\mathbb{U}^{(1)}_{1}</span> <span class="math">=\\mathfrak{u}^{(1)}_{1}</span> (9)</p>

    <p class="text-gray-300">Furthermore, <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(1)}_{1}.\\bar{E}=\\bar{0}^{(1)}\\quad\\text{and}\\quad\\mathfrak{u}^{(1)}_{1}.s=1^{(1)}</span> (10)</p>

    <p class="text-gray-300">By (Condition 4) and equations (9) and (10), the pair <span class="math">(\\mathfrak{u}^{(1)}_{1},\\mathbb{W}^{(1)}_{1})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span> which implements the relation <span class="math">\\mathcal{R}_{1}</span>. This implies that the extended witness <span class="math">\\mathbb{W}^{(1)}_{1}.w^{(1)}</span> contains an <span class="math">\\mathcal{R}_{1}</span> witness <span class="math">\\hat{w}^{(1)}_{1}</span> of the form</p>

    <p class="text-gray-300"><span class="math">\\hat{w}^{(1)}_{1}:=\\big{(}\\mathsf{vk}^{\\prime}\\in\\mathbb{F}_{1},\\ \\ j\\in\\mathbb{F}_{1},\\ \\ z,z^{\\prime}\\in\\mathbb{F}_{1}^{n_{1}},\\ \\ \\mathsf{aux}^{(1)}_{0}\\in\\mathbb{F}_{1}^{b_{1}},\\ \\ \\mathbb{U}^{(2)}_{0},\\mathfrak{u}^{(2)}_{0}\\in\\mathcal{U}^{(2)},\\ \\ \\bar{\\mathsf{T}}^{(2)}_{0}\\in\\mathbb{G}_{2}\\big{)}.</span> (11)</p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(1)}_{1}.x_{1}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(1)},\\ z,\\ \\mathsf{F}_{1}(z^{\\prime},\\mathsf{aux}^{(1)}_{0}),\\ \\mathbb{U}\\big{)}</span> (12)</p>

    <p class="text-gray-300">for some instance <span class="math">\\mathbb{U}\\in\\mathcal{U}^{(2)}</span> (dependent on <span class="math">j</span>). By (Condition 2), we know</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{1}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},1^{(1)},z^{(1)}_{0},z^{(1)}_{1},\\mathbb{U}^{(2)}_{1}\\big{)}.</span> (13)</p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{1}.x_{0}=\\mathfrak{u}^{(1)}_{1}.x_{1}</span> (14)</p>

    <p class="text-gray-300">By equations (13) and (14), we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(1)}_{1}.x_{1}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},1^{(1)},z^{(1)}_{0},z^{(1)}_{1},\\mathbb{U}^{(2)}_{1}\\big{)}.</span> (15)</p>

    <p class="text-gray-300">Therefore, by equations (12) and (15) and the collision resistance of <span class="math">\\mathsf{H}_{1}</span>, we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(1)},\\ z,\\ \\mathsf{F}_{1}(z^{\\prime},\\mathsf{aux}^{(1)}_{0}),\\ \\mathbb{U}\\big{)}=\\big{(}\\mathsf{vk},1^{(1)},z^{(1)}_{0},z^{(1)}_{1},\\mathbb{U}^{(2)}_{1}\\big{)},</span> (16)</p>

    <p class="text-gray-300">otherwise there is an explicit collision finder on the hash function <span class="math">\\mathsf{H}_{1}</span>. By (16), we can conclude that</p>

    <p class="text-gray-300"><span class="math">j=0^{(1)},\\quad z=z^{(1)}_{0},\\quad\\mathsf{F}_{1}(z^{\\prime},\\mathsf{aux}^{(1)}_{0})=z^{(1)}_{1}.</span> (17)</p>

    <p class="text-gray-300">Since <span class="math">j=0^{(1)}</span>, the relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">z=z^{\\prime}</span> (18)</p>

    <p class="text-gray-300">By equations (17) and (18), we can conclude that</p>

    <p class="text-gray-300"><span class="math">z_{1}^{(1)}=\\mathsf{F}_{1}(z_{0}^{(1)},\\mathsf{aux}_{0}^{(1)}).</span> (19)</p>

    <p class="text-gray-300">In summary, the extractor <span class="math">\\mathcal{E}</span> outputs the elements <span class="math">(z_{0}^{(1)},\\mathsf{aux}_{0}^{(1)}),\\;\\;(z_{0}^{(2)},\\mathsf{aux}_{0}^{(2)})</span>, and any IVC proof <span class="math">\\pi_{0}</span>. We argued that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By (8) we have <span class="math">z_{1}^{(2)}=\\mathsf{F}_{2}(z_{0}^{(2)},\\mathsf{aux}_{0}^{(2)})</span>.</li>

      <li>By (19) we have <span class="math">z_{1}^{(1)}=\\mathsf{F}_{1}(z_{0}^{(1)},\\mathsf{aux}_{0}^{(1)})</span>.</li>

    </ul>

    <p class="text-gray-300">Therefore, these output elements satisfy the requirements for the IVC extractor.</p>

    <h3 id="sec-33" class="text-xl font-semibold mt-8">6.2 The case <span class="math">i&gt;1</span></h3>

    <p class="text-gray-300">Here we consider the case when <span class="math">\\mathbf{i}</span> is greater than <span class="math">\\mathbf{1}</span>.</p>

    <p class="text-gray-300">By (Condition 6), the pair <span class="math">(\\mathfrak{u}_{i}^{(2)},\\mathsf{w}_{i}^{(2)})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span> which implements relation <span class="math">\\mathcal{R}_{2}</span>. This implies that the extended witness <span class="math">\\mathsf{w}_{i}^{(2)}.w^{(2)}</span> contains an <span class="math">\\mathcal{R}_{2}</span> witness <span class="math">\\hat{w}_{i}^{(2)}</span> of the form</p>

    <p class="text-gray-300"><span class="math">\\hat{w}_{i}^{(2)}:=\\big{(}\\mathsf{vk}^{\\prime}\\in\\mathbb{F}_{2},\\;\\;j\\in\\mathbb{F}_{2},\\;\\;z,z_{i-1}^{(2)}\\in\\mathbb{F}_{2}^{a_{2}},\\;\\;\\mathsf{aux}_{i-1}^{(2)}\\in\\mathbb{F}_{2}^{b_{2}},\\;\\;\\mathbb{U}_{i-1}^{(1)},\\mathfrak{u}_{i}^{(1)}\\in\\mathcal{U}^{(1)},\\;\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\in\\mathbb{G}_{1}\\big{)}</span></p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk}^{\\prime},\\;j+1^{(2)},\\;z,\\;\\mathsf{F}_{2}(z_{i-1}^{(2)},\\mathsf{aux}_{i-1}^{(2)}),\\;\\mathbb{U}\\big{)}</span> (20)</p>

    <p class="text-gray-300">for some instance <span class="math">\\mathbb{U}\\in\\mathcal{U}^{(1)}</span> (dependent on <span class="math">j</span>). By (Condition 3), we also know</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},i^{(2)},z_{0}^{(2)},z_{i}^{(2)},\\mathbb{U}_{i}^{(1)}\\big{)}.</span> (21)</p>

    <p class="text-gray-300">Therefore, by equations (20) and (21) and the collision resistance of <span class="math">\\mathsf{H}_{2}</span>, we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\mathsf{vk}^{\\prime},\\;j+1^{(2)},\\;z,\\;\\mathsf{F}_{2}(z_{i-1}^{(2)},\\mathsf{aux}_{i-1}^{(2)}),\\;\\mathbb{U}\\Big{)}=\\Big{(}\\mathsf{vk},i^{(2)},z_{0}^{(2)},z_{i}^{(2)},\\mathbb{U}_{i}^{(1)}\\Big{)},</span> (22)</p>

    <p class="text-gray-300">otherwise there is an explicit collision finder on the hash function <span class="math">\\mathsf{H}_{2}</span>. By equation (22), we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}^{\\prime}=\\mathsf{vk},\\quad j=(i-1)^{(2)},\\quad z=z_{0}^{(2)},\\quad\\mathsf{F}_{2}(z_{i-1}^{(2)},\\mathsf{aux}_{i-1}^{(2)})=z_{i}^{(2)},\\quad\\mathbb{U}=\\mathbb{U}_{i}^{(1)}</span> (23)</p>

    <p class="text-gray-300">Since <span class="math">i&gt;1</span> and <span class="math">j=(i-1)</span>, we must have <span class="math">j\\neq 0^{(2)}</span>. Thus, the relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathbb{U}=\\mathsf{Fold}_{V}\\big{(}\\mathsf{vk},\\;\\mathbb{U}_{i-1}^{(1)},\\;\\mathfrak{u}_{i}^{(1)},\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\big{)}.</span> (24)</p>

    <p class="text-gray-300">Now, by equations (23) and (24), we must have</p>

    <p class="text-gray-300"><span class="math">\\hat{w}_{i}^{(2)}=\\big{(}\\mathsf{vk},\\;(i-1)^{(2)},\\;z_{0}^{(2)},z_{i-1}^{(2)},\\;\\mathsf{aux}_{i-1}^{(2)},\\;\\mathbb{U}_{i-1}^{(1)},\\mathfrak{u}_{i}^{(1)},\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\big{)}</span> (25)</p>

    <p class="text-gray-300">for which we know</p>

    <p class="text-gray-300"><span class="math">z_{i}^{(2)}</span> <span class="math">=\\mathsf{F}_{2}\\big{(}z_{i-1}^{(2)},\\mathsf{aux}_{i-1}^{(2)}\\big{)}</span> (26) <span class="math">\\mathbb{U}_{i}^{(1)}</span> <span class="math">=\\mathsf{Fold}_{V}\\big{(}\\mathsf{vk},\\;\\mathbb{U}_{i-1}^{(1)},\\;\\mathfrak{u}_{i}^{(1)},\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\big{)}</span> (27)</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">By (Condition 4), equation (27), and knowledge soundness of the folding scheme, we can extract satisfying witnesses</p>

    <p class="text-gray-300"><span class="math">\\mathsf{w}_{i}^{(1)}\\text{ for }\\mathfrak{u}_{i}^{(1)}\\quad\\text{ and }\\quad\\mathds{W}_{i-1}^{(1)}\\text{ for }\\mathds{U}_{i-1}^{(1)}</span> (28)</p>

    <p class="text-gray-300">with respect to <span class="math">\\mathsf{R1CS}^{(1)}</span>. Otherwise, we could use the prover <span class="math">P^{*}</span> to construct an adversary that breaks the knowledge soundness of the folding scheme. The relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(1)}.\\bar{E}=\\bar{0}^{(1)}\\quad\\text{and}\\quad\\mathfrak{u}_{i}^{(1)}.s=1^{(1)}</span> (29)</p>

    <p class="text-gray-300">Thus, by (28) and (29), the extracted pair <span class="math">(\\mathfrak{u}_{i}^{(1)},\\mathsf{w}_{i}^{(1)})</span> must strictly satisfy <span class="math">\\mathsf{R1CS}^{(1)}</span> which implements the relation <span class="math">\\mathcal{R}_{1}</span>. This implies that the extended witness <span class="math">\\mathsf{w}_{i}^{(1)}.w^{(1)}</span> contains an <span class="math">\\mathcal{R}_{1}</span> witness <span class="math">\\hat{w}_{i}^{(1)}</span> of the form</p>

    <p class="text-gray-300"><span class="math">\\hat{w}_{i}^{(1)}:=\\big{(}\\mathsf{vk}^{\\prime}\\in\\mathsf{F}_{1},\\ \\ j\\in\\mathsf{F}_{1},\\ \\ z,z_{i-1}^{(1)}\\in\\mathsf{F}_{1}^{a_{1}},\\ \\ \\mathsf{aux}_{i-1}^{(1)}\\in\\mathsf{F}_{1}^{b_{1}},\\ \\ \\ \\mathds{U}_{i-1}^{(2)},\\mathfrak{u}_{i-1}^{(2)}\\in\\mathcal{U}^{(2)},\\ \\ \\bar{\\mathsf{T}}_{i-1}^{(2)}\\in\\mathsf{G}_{2}\\big{)}.</span></p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(1)}.x_{1}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(1)},\\ z,\\ \\mathsf{F}_{1}(z_{i-1}^{(1)},\\mathsf{aux}_{i-1}^{(1)}),\\ \\mathds{U}\\big{)}</span> (30)</p>

    <p class="text-gray-300">for some instance <span class="math">\\mathds{U}\\in\\mathcal{U}^{(2)}</span> (dependent on <span class="math">j</span>). By (Condition 2), we know</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathds{U}_{i}^{(2)}\\big{)}.</span> (31)</p>

    <p class="text-gray-300">The relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{0}=\\mathfrak{u}_{i}^{(1)}.x_{1}</span> (32)</p>

    <p class="text-gray-300">By equations (31) and (32), we can conclude</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}_{i}^{(1)}.x_{1}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathds{U}_{i}^{(2)}\\big{)}.</span> (33)</p>

    <p class="text-gray-300">Therefore, by equations (30) and (33) and the collision resistance of <span class="math">\\mathsf{H}_{1}</span>, we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\Big{(}\\mathsf{vk}^{\\prime},\\ j+1^{(1)},\\ z,\\ \\mathsf{F}_{1}(z_{i-1}^{(1)},\\mathsf{aux}_{i-1}^{(1)}),\\ \\mathds{U}\\Big{)}=\\Big{(}\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathds{U}_{i}^{(2)}\\Big{)},</span> (34)</p>

    <p class="text-gray-300">otherwise there is an explicit collision finder on the hash function <span class="math">\\mathsf{H}_{1}</span>. By equation (34), we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathsf{vk}^{\\prime}=\\mathsf{vk},\\quad j=(i-1)^{(1)},\\quad z=z_{0}^{(1)},\\quad\\mathsf{F}_{1}(z_{i-1}^{(1)},\\mathsf{aux}_{i-1}^{(1)})=z_{i}^{(1)},\\quad\\mathds{U}=\\mathds{U}_{i}^{(2)}</span> (35)</p>

    <p class="text-gray-300">Since <span class="math">i&gt;1</span> and <span class="math">j=(i-1)</span>, we must have <span class="math">j\\neq 0^{(1)}</span>. Thus, the relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathds{U}=\\mathsf{Fold}_{\\mathcal{V}}\\big{(}\\mathsf{vk},\\ \\mathds{U}_{i-1}^{(2)},\\ \\mathfrak{u}_{i-1}^{(2)},\\ \\bar{\\mathsf{T}}_{i-1}^{(2)}\\big{)}</span> (36)</p>

    <p class="text-gray-300">Thus, by equations (35) and (36), we must have</p>

    <p class="text-gray-300"><span class="math">\\hat{w}_{i}^{(1)}=\\big{(}\\mathsf{vk},\\ (i-1)^{(1)},\\ z_{0}^{(1)},z_{i-1}^{(1)},\\ \\mathsf{aux}_{i-1}^{(1)},\\ \\mathds{U}_{i-1}^{(2)},\\mathfrak{u}_{i-1}^{(2)},\\ \\bar{\\mathsf{T}}_{i-1}^{(2)}\\big{)}</span> (37)</p>

    <p class="text-gray-300">for which we know</p>

    <p class="text-gray-300"><span class="math">z_{i}^{(1)}</span> <span class="math">=\\mathsf{F}_{1}\\big{(}z_{i-1}^{(1)},\\mathsf{aux}_{i-1}^{(1)}\\big{)}</span> (38) <span class="math">\\mathds{U}_{i}^{(2)}</span> <span class="math">=\\mathsf{Fold}_{\\mathcal{V}}\\big{(}\\mathsf{vk},\\ \\mathds{U}_{i-1}^{(2)},\\ \\mathfrak{u}_{i-1}^{(2)},\\ \\bar{\\mathsf{T}}_{i-1}^{(2)}\\big{)}</span> (39)</p>

    <p class="text-gray-300">By (Condition 5), equation (39), and knowledge soundness of the folding scheme, we can extract satisfying witnesses</p>

    <p class="text-gray-300"><span class="math">\\mathsf{w}_{i-1}^{(2)}\\text{ for }\\mathfrak{u}_{i-1}^{(2)}\\quad\\text{and}\\quad\\mathds{W}_{i-1}^{(2)}\\text{ for }\\mathds{U}_{i-1}^{(2)}</span> (40)</p>

    <p class="text-gray-300">with respect to <span class="math">\\mathsf{R1CS}^{(2)}</span>. Otherwise, we could use the prover <span class="math">P^{*}</span> to construct an adversary that breaks the knowledge soundness of the folding scheme. The relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{i-1}.\\bar{E}=\\bar{0}^{(2)}\\quad\\text{and}\\quad\\mathfrak{u}^{(2)}_{i-1}.s=1^{(2)}</span> (41)</p>

    <p class="text-gray-300">Thus, by (40) and (41), the extracted pair <span class="math">(\\mathfrak{u}^{(2)}_{i-1},\\mathfrak{w}^{(2)}_{i-1})</span> must strictly satisfy <span class="math">\\mathsf{R1CS}^{(2)}</span> which implements relation <span class="math">\\mathcal{R}_{2}</span>. By equation (37), the relation <span class="math">\\mathcal{R}_{1}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{i-1}.x_{0}</span> <span class="math">=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},\\ (i-1)^{(1)},\\ z^{(1)}_{0},z^{(1)}_{i-1},\\ \\mathbb{U}^{(2)}_{i-1}\\big{)}</span> (42) <span class="math">\\mathfrak{u}^{(1)}_{i}.x_{0}</span> <span class="math">=\\mathfrak{u}^{(2)}_{i-1}.x_{1}</span> (43)</p>

    <p class="text-gray-300">By equation (25), the relation <span class="math">\\mathcal{R}_{2}</span> enforces that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(1)}_{i}.x_{0}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},\\ (i-1)^{(2)},\\ z^{(2)}_{0},z^{(2)}_{i-1},\\ \\mathbb{U}^{(1)}_{i-1}\\big{)}.</span> (44)</p>

    <p class="text-gray-300">Thus, by equations (43) and (44), we can conclude that</p>

    <p class="text-gray-300"><span class="math">\\mathfrak{u}^{(2)}_{i-1}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},\\ (i-1)^{(2)},\\ z^{(2)}_{0},z^{(2)}_{i-1},\\ \\mathbb{U}^{(1)}_{i-1}\\big{)}.</span> (45)</p>

    <p class="text-gray-300">In summary, the extractor <span class="math">\\mathcal{E}</span> works as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>It parses witness <span class="math">\\mathsf{w}^{(2)}_{i}</span> to obtain the <span class="math">\\mathcal{R}_{2}</span> witness in (25).</li>

      <li>It runs the folding extractor on a folding prover derived from <span class="math">P^{*}</span> to obtain the relaxed witnesses in (28).</li>

      <li>It parses witness <span class="math">\\mathsf{w}^{(1)}_{i}</span> to obtain the <span class="math">\\mathcal{R}_{1}</span> witness in (37).</li>

      <li>It runs the folding extractor on a folding prover derived from <span class="math">P^{*}</span> to obtain the relaxed witnesses in (40).</li>

      <li>It then outputs the elements <span class="math">(z^{(1)}_{i-1},\\mathsf{aux}^{(1)}_{i-1}),\\ \\ (z^{(2)}_{i-1},\\mathsf{aux}^{(2)}_{i-1})</span>, and <span class="math">\\pi_{i-1}</span> where</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\pi_{i-1}:=\\big{(}(\\mathfrak{u}^{(2)}_{i-1},\\mathsf{w}^{(2)}_{i-1}),\\ \\ (\\mathbb{U}^{(1)}_{i-1},\\mathbb{W}^{(1)}_{i-1}),\\ \\ (\\mathbb{U}^{(2)}_{i-1},\\mathbb{W}^{(2)}_{i-1})\\big{)}.</span></p>

    <p class="text-gray-300">We argued that</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>By (38) we have <span class="math">z^{(1)}_{i}=\\mathsf{F}_{1}\\big{(}z^{(1)}_{i-1},\\mathsf{aux}^{(1)}_{i-1}\\big{)}</span>.</li>

      <li>By (26) we have <span class="math">z^{(2)}_{i}=\\mathsf{F}_{2}\\big{(}z^{(2)}_{i-1},\\mathsf{aux}^{(2)}_{i-1}\\big{)}</span>.</li>

      <li>By assumption, the index <span class="math">i-1</span> is greater than <span class="math">0</span>.</li>

      <li>By (42) we have <span class="math">\\mathfrak{u}^{(2)}_{i-1}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},\\ (i-1)^{(1)},\\ z^{(1)}_{0},z^{(1)}_{i-1},\\ \\mathbb{U}^{(2)}_{i-1}\\big{)}</span>.</li>

      <li>By (45) we have <span class="math">\\mathfrak{u}^{(2)}_{i-1}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},\\ (i-1)^{(2)},\\ z^{(2)}_{0},z^{(2)}_{i-1},\\ \\mathbb{U}^{(1)}_{i-1}\\big{)}</span>.</li>

      <li>By (28), the pair <span class="math">(\\mathbb{U}^{(1)}_{i-1},\\mathbb{W}^{(1)}_{i-1})</span> satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>By (40), the pair <span class="math">(\\mathbb{U}^{(2)}_{i-1},\\mathbb{W}^{(2)}_{i-1})</span> satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>By (40) and (41), the pair <span class="math">(\\mathfrak{u}^{(2)}_{i-1},\\mathsf{w}^{(2)}_{i-1})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

    </ul>

    <p class="text-gray-300">Therefore, we must have <span class="math">\\mathcal{V}\\Big{(}\\mathsf{pp},(\\mathsf{F}_{1},\\mathsf{F}_{2}),(i-1,(z^{(1)}_{0},z^{(2)}_{0}),(z^{(1)}_{i-1},z^{(2)}_{i-1})),\\pi_{i-1}\\Big{)}=1</span>. This shows that the elements output by the extractor <span class="math">\\mathcal{E}</span> satisfy the requirements for the IVC extractor. <span class="math">\\Box</span></p>

    <h2 id="sec-34" class="text-2xl font-bold">7 Further IVC Proof Compression</h2>

    <p class="text-gray-300">In this section, we informally describe two additional strategies to compress IVC proofs. The combination of both strategies is used in the original Nova paper and its implementation to produce a compressed IVC proof <span class="math">\\pi_{i}^{\\prime\\prime}</span> (49). We highlight that even without a SNARK (Section 7.2) an IVC proof <span class="math">\\pi_{i}</span> (46) can be compressed and still maintain an incremental property.</p>

    <p class="text-gray-300">7.1 Compression without SNARKs</p>

    <h5 id="sec-35" class="text-base font-semibold mt-4">Prover</h5>

    <p class="text-gray-300">The prover given a convincing proof</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}:=\\big{(}(\\mathfrak{u}_{i}^{(2)},\\mathsf{w}_{i}^{(2)}),\\;\\;(\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)}),\\;\\;(\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})\\big{)}.</span> (46)</p>

    <p class="text-gray-300">can perform the following procedure to produced a compressed proof <span class="math">\\pi^{\\prime}_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold Pairs for R1CS^{(2)}: Fold the committed pairs <span class="math">(\\mathfrak{u}_{i}^{(2)},\\mathsf{w}_{i}^{(2)})</span> and <span class="math">(\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})</span> for R1CS^{(2)}.</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathsf{Fold}_{P}\\big{(}\\mathsf{pk},(\\mathfrak{u}_{i}^{(2)},\\mathsf{w}_{i}^{(2)}),(\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})\\big{)}\\to\\big{(}\\bar{\\mathsf{T}}_{i}^{(2)},\\;(\\;\\cdot\\;,\\;\\mathbb{W}_{i+1}^{(2)})\\big{)}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output New Compressed Proof: Output the following compressed proof</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi^{\\prime}_{i}:=\\big{(}\\mathfrak{u}_{i}^{(2)},\\;\\;\\mathbb{U}_{i}^{(2)},\\;\\;(\\bar{\\mathsf{T}}_{i}^{(2)},\\mathbb{W}_{i+1}^{(2)}),\\;\\;(\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)})\\big{)}</span> (47)</p>

    <h5 id="sec-36" class="text-base font-semibold mt-4">Verifier</h5>

    <p class="text-gray-300">Then, the verifier given a compressed proof <span class="math">\\pi^{\\prime}_{i}</span> (47) performs an initial folding procedure</p>

    <p class="text-gray-300"><span class="math">\\mathbb{U}_{i+1}^{(2)}:=\\mathsf{Fold}_{V}\\big{(}\\mathsf{vk},\\mathfrak{u}_{i}^{(2)},\\mathbb{U}_{i}^{(2)},\\bar{\\mathsf{T}}_{i}^{(2)}\\big{)}</span></p>

    <p class="text-gray-300">and accepts if the following six conditions are met:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The index <span class="math">i</span> must be greater than 0.</li>

      <li><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathbb{U}_{i}^{(2)}\\big{)}</span></li>

      <li><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},i^{(2)},z_{0}^{(2)},z_{i}^{(2)},\\mathbb{U}_{i}^{(1)}\\big{)}</span></li>

      <li>The pair <span class="math">(\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)})</span> satisfies R1CS^{(1)}.</li>

      <li>The pair <span class="math">(\\mathbb{U}_{i+1}^{(2)},\\mathbb{W}_{i+1}^{(2)})</span> satisfies R1CS^{(2)}.</li>

      <li><span class="math">\\mathfrak{u}_{i}^{(2)}.\\bar{E}=\\bar{0}^{(2)}</span> and <span class="math">\\mathfrak{u}_{i}^{(2)}.s=\\bar{1}^{(2)}</span></li>

    </ol>

    <h5 id="sec-37" class="text-base font-semibold mt-4">Knowledge Soundness</h5>

    <p class="text-gray-300">We omit the proof of knowledge soundness as the proof in Section 6 can be trivially extended to cover this additional folding step.</p>

    <h5 id="sec-38" class="text-base font-semibold mt-4">Incremental Operation with Compressed Proofs</h5>

    <p class="text-gray-300">The compressed proof <span class="math">\\pi^{\\prime}_{i}</span> (47) along with evaluations <span class="math">z_{i+1}^{(1)}:=\\mathsf{F}_{1}(z_{i}^{(1)},\\mathsf{aux}_{i}^{(1)})</span> and <span class="math">z_{i+1}^{(2)}:=\\mathsf{F}_{2}(z_{i}^{(2)},\\mathsf{aux}_{i}^{(2)})</span> are sufficient to execute another step of the Nova prover for iteration <span class="math">i+1</span>. In our paper, we describe the IVC scheme using the non-compressed proof <span class="math">\\pi_{i}</span> (46) instead of the compressed proof <span class="math">\\pi^{\\prime}_{i}</span>. However, we could also describe the IVC scheme with <span class="math">\\pi^{\\prime}_{i}</span> being the IVC proof instead. We decided to describe the IVC scheme with <span class="math">\\pi_{i}</span> because our construction is easier to understand without the additional compression step.</p>

    <p class="text-gray-300">In Nova (Construction 4 in Section 5.2 of <em>[11]</em>), this approach is used in tandem with a SNARK to produced a compressed proof <span class="math">\\pi^{\\prime\\prime}_{i}</span>. However, we highlight that this final folding step without a SNARK also produces a valid IVC proof that is compressed and readily incremental.</p>

    <h3 id="sec-39" class="text-xl font-semibold mt-8">7.2 Compression with SNARKs</h3>

    <p class="text-gray-300">A generic SNARK for the relation <span class="math">\\mathcal{R}_{\\mathsf{sat}}</span> (48) can be used to compress the IVC proof further. Nova uses the Spartan SNARK <em>[16]</em> in the original paper <em>[11]</em> and implementation <em>[13]</em>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">Prover</p>

    <p class="text-gray-300">The prover given a compressed IVC proof <span class="math">\\pi^{\\prime}_{i}</span> (47) as produced in Section 7.1</p>

    <p class="text-gray-300"><span class="math">\\pi^{\\prime}_{i}:=\\left(\\mathfrak{u}^{(2)}_{i},\\ \\ \\mathbb{U}^{(2)}_{i},\\ \\ (\\bar{\\mathsf{T}}^{(2)}_{i},\\mathbb{W}^{(2)}_{i+1}),\\ \\ (\\mathbb{U}^{(1)}_{i},\\mathbb{W}^{(1)}_{i})\\right)</span></p>

    <p class="text-gray-300">can perform the following procedure to produce a new compressed proof <span class="math">\\pi^{\\prime\\prime}_{i}</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compress Witnesses with SNARK proof: Produce a SNARK proof <span class="math">\\pi_{\\mathsf{sat}}</span> for the following relation</li>

    </ol>

    <p class="text-gray-300">\\[ \\mathcal{R}_{\\mathsf{sat}}:=\\left\\{\\left(\\mathbb{U}^{(2)}_{i+1},\\ \\mathbb{U}^{(1)}_{i}\\ ;\\ \\ \\mathbb{W}^{(2)}_{i+1},\\ \\mathbb{W}^{(1)}_{i}\\right)\\ \\ \\ :\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\right. \\] (48)</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output New Compressed Proof: Output the following new compressed proof</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\pi^{\\prime\\prime}_{i}:=\\left(\\mathfrak{u}^{(2)}_{i},\\ \\ \\mathbb{U}^{(2)}_{i},\\ \\ \\mathbb{U}^{(1)}_{i},\\ \\ \\bar{\\mathsf{T}}^{(2)}_{i},\\ \\ \\pi_{\\mathsf{sat}}\\right)</span> (49)</p>

    <p class="text-gray-300">Verifier Then, the verifier given compressed proof <span class="math">\\pi^{\\prime\\prime}_{i}</span> (49) performs an initial folding procedure</p>

    <p class="text-gray-300"><span class="math">\\mathbb{U}^{(2)}_{i+1}:=\\mathsf{Fold}_{V}\\big{(}\\mathsf{vk},\\mathfrak{u}^{(2)}_{i},\\mathbb{U}^{(2)}_{i},\\bar{\\mathsf{T}}^{(2)}_{i}\\big{)}</span></p>

    <p class="text-gray-300">and accepts if the following five conditions are met:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The index <span class="math">i</span> must be greater than 0.</li>

      <li><span class="math">\\mathfrak{u}^{(2)}_{i}.x_{0}=\\mathsf{H}_{1}\\big{(}\\mathsf{vk},i^{(1)},z^{(1)}_{0},z^{(1)}_{i},\\mathbb{U}^{(2)}_{i}\\big{)}</span></li>

      <li><span class="math">\\mathfrak{u}^{(2)}_{i}.x_{1}=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},i^{(2)},z^{(2)}_{0},z^{(2)}_{i},\\mathbb{U}^{(1)}_{i}\\big{)}</span></li>

      <li><span class="math">\\pi_{\\mathsf{sat}}</span> is a convincing SNARK proof for the relation <span class="math">\\mathcal{R}_{\\mathsf{sat}}</span> (48) with instance <span class="math">\\big{(}\\mathbb{U}^{(2)}_{i+1},\\ \\mathbb{U}^{(1)}_{i}\\big{)}</span>.</li>

      <li><span class="math">\\mathfrak{u}^{(2)}_{i}.\\bar{E}=\\bar{0}^{(2)}</span> and <span class="math">\\mathfrak{u}^{(2)}_{i}.s=\\bar{1}^{(2)}</span></li>

    </ol>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">Knowledge Soundness</h4>

    <p class="text-gray-300">We defer to Nova <em>[11]</em> for the construction of a SNARK for relation <span class="math">\\mathcal{R}_{\\mathsf{sat}}</span> (48).</p>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">Compression in Nova’s Implementation</h4>

    <p class="text-gray-300">Nova’s implementation <em>[13]</em> performs the compression step described in Section 7.2 using Spartan <em>[16]</em>. They refer to the composition of the IVC Scheme and both compression steps (Section 7.1 and Section 7.2) as the CompressedSNARK.</p>

    <h2 id="sec-42" class="text-2xl font-bold">8 Malleability of Nova’s IVC proofs</h2>

    <p class="text-gray-300">In this section, we show that the Nova’s IVC proofs, described in Section 5 are malleable. This readily applies to the original Nova construction as well <em>[11]</em>. We first explain the issue and then present several mitigations.</p>

    <p class="text-gray-300">Suppose an adversary is given a valid Nova IVC proof <span class="math">\\pi_{i}</span> with respect to the following parameters</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>IVC public parameters <span class="math">\\mathsf{pp}</span>,</li>

      <li>a description of functions <span class="math">\\mathsf{F}_{1}:\\mathbb{F}_{1}^{a_{1}}\\times\\mathbb{F}_{1}^{b_{1}}\\to\\mathbb{F}_{1}^{a_{1}}\\ \\ \\ \\text{and}\\ \\ \\mathsf{F}_{2}:\\mathbb{F}_{2}^{a_{2}}\\times\\mathbb{F}_{2}^{b_{2}}\\to\\mathbb{F}_{2}^{a_{2}}</span>,</li>

      <li>an index <span class="math">i\\in\\mathbb{N}</span>,</li>

      <li>starting values <span class="math">z^{(1)}_{0}\\in\\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">z^{(2)}_{0}\\in\\mathbb{F}_{2}^{a_{2}}</span>, and</li>

      <li>claimed evaluations <span class="math">z^{(1)}_{i}\\in\\mathbb{F}_{1}^{a_{1}}</span> and <span class="math">z^{(2)}_{i}\\in\\mathbb{F}_{2}^{a_{2}}</span>.</li>

    </ul>

    <p class="text-gray-300">We show in Section 8.1 that the adversary can construct a proof <span class="math">\\pi_{\\mathsf{prime}}</span> for the same iteration <span class="math">i</span>, but for some <span class="math">z^{(2)}_{\\mathsf{prime}}</span> different from <span class="math">z^{(2)}_{i}</span>. In particular, running the IVC verifier with arguments</p>

    <p class="text-gray-300"><span class="math">\\big{(}\\mathsf{pp},\\ (\\mathsf{F}_{1},\\mathsf{F}_{2}),\\ i,\\ (z^{(1)}_{0},z^{(2)}_{0}),\\ (z^{(1)}_{i},z^{(2)}_{\\mathsf{prime}}),\\ \\pi_{\\mathsf{prime}}\\ \\big{)}</span></p>

    <p class="text-gray-300">causes the verifier to accept. We stress that our adversary does not need to know the auxiliary values <span class="math">(\\mathsf{aux}^{(2)}_{0},\\mathsf{aux}^{(2)}_{1},\\ldots,\\mathsf{aux}^{(2)}_{i-1})</span> used to compute <span class="math">z^{(2)}_{i}</span>. By choosing an alternate final auxiliary value <span class="math">\\mathsf{aux}^{(2)}_{\\mathsf{prime}}\\neq\\mathsf{aux}^{(2)}_{i-1}</span>, our adversary can construct a proof <span class="math">\\pi_{\\mathsf{prime}}</span> for an alternate value <span class="math">z^{(2)}_{\\mathsf{prime}}</span> for <span class="math">i</span> iterations, without knowledge of the first <span class="math">i-1</span> auxiliary values.</p>

    <p class="text-gray-300">Discussion. Why does malleability matter? A malleable proof system <em>[4]</em> can lead to a real world security vulnerability. Suppose Alice uses her secret auxiliary values to compute <span class="math">z_{i}^{(2)}</span> and this <span class="math">z_{i}^{(2)}</span> encodes her payment address. She sends the <span class="math">z_{i}^{(2)}</span> and the proof to a payment contract. An attacker could intercept her message and maul <span class="math">z_{i}^{(2)}</span> to a <span class="math">z_{\\textsf{prime}}^{(2)}</span> which encodes the attackers payment address instead, along with a valid proof <span class="math">\\pi_{\\textsf{prime}}</span>. The payment contract will then send the funds to the attacker instead of Alice. Concretely, if Tornado Cash had used a proof system that were malleable on statements, it would have been possible to steal funds.</p>

    <h6 id="sec-43" class="text-base font-medium mt-4">Remark 5 (Non-malleability does not apply to deterministic functions).</h6>

    <p class="text-gray-300">Our malleabilty attack in Section 8.1 does not apply when the function <span class="math">\\mathsf{F}</span> is deterministic, namely it does not take an auxiliary argument as input. The reason is that in this case the value <span class="math">z_{i}</span> at the <span class="math">i</span>-th iteration of <span class="math">\\mathsf{F}</span> is determined by the starting value <span class="math">z_{0}</span>, and the adversary is committed to <span class="math">z_{0}</span>. Hence, the adversary cannot cause a different <span class="math">z_{i}</span> to be accepted at iteration <span class="math">i</span> when starting at <span class="math">z_{0}</span>. There are several widely used examples where IVC is applied to a deterministic function. One example, is the MinRoot construction <em>[9]</em> for a Verifiable Delay Function. Another example is when repeatedly applying a simple state machine to an initial state <span class="math">z_{0}</span>.</p>

    <h4 id="sec-44" class="text-lg font-semibold mt-6">Mitigations.</h4>

    <p class="text-gray-300">Applications that use Nova IVC with auxiliary inputs often require non-malleability. In Section 8.2 we present three mitigation strategies to ensure that Nova IVC is non-malleable:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><em>Compression:</em> The prover in Section 5 outputs the final folded instance along with a satisfying witness. Instead, the prover could output a final folded instance along with a zkSNARK proof that it has a valid witness for this folded instance. If the zkSNARK is simulation extractable <em>[8]</em> then the final proof is non-malleable. In fact, the current Nova implementation uses this approach, which has the additional benefit of compressing the final proof. However, this is not compatible with the notion of IVC: with post compression, it is no longer possible for another party to further extend the IVC chain efficiently via folding. Consequently, the entire computation of the IVC chain has to be done by a single party.</li>

      <li><em>Context:</em> A different mitifation is to expand the verification key <span class="math">\\mathsf{vk}</span> to include an additional context element <span class="math">\\mathsf{ctx}</span>, as defined in Section 8.2. This ensures non-malleability, but this approach is again incompatible with IVC. The additional context element contains the very last step of the computation, and this prevents another party from further extending the IVC chain using folding.</li>

      <li><em>Incremental context:</em> To ensure non-malleability while supporting the incremental aspect of IVC we describe a third strategy that extends the context method in the previous bullet. Our approach is to update the verification key <span class="math">\\mathsf{vk}</span> on every hand-off from one party to the next as they extend the IVC chain.</li>

    </ul>

    <p class="text-gray-300">We discuss these in more detail in Section 8.2. First, let us see the details of the malleability attack.</p>

    <h3 id="sec-45" class="text-xl font-semibold mt-8">8.1 The Malleability Attack</h3>

    <p class="text-gray-300">We present a malleability attack on the last step of the IVC chain. Recall that the Nova IVC proof <span class="math">\\pi_{i}</span> contains the following elements</p>

    <p class="text-gray-300"><span class="math">\\pi_{i}:=\\big{(}(\\mathfrak{u}_{i}^{(2)},\\mathfrak{w}_{i}^{(2)}),\\;\\;(\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)}),\\;\\;(\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})\\big{)}.</span></p>

    <p class="text-gray-300">The malleability attack proceeds as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parse witness: In Section 6, we argued that we can parse the witness <span class="math">\\mathfrak{w}_{i}^{(2)}</span> to obtain relational witness</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\hat{w}_{i}^{(2)}=\\big{(}\\mathsf{vk},\\;(i-1)^{(2)},\\;z_{0}^{(2)},z_{i-1}^{(2)},\\;\\mathsf{aux}_{i-1}^{(2)},\\;\\mathbb{U}_{i-1}^{(1)},\\mathfrak{u}_{i}^{(1)},\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\big{)}</span></p>

    <p class="text-gray-300">for which we know</p>

    <p class="text-gray-300"><span class="math">z_{i}^{(2)}</span> <span class="math">=\\mathsf{F}_{2}\\big{(}z_{i-1}^{(2)},\\mathsf{aux}_{i-1}^{(2)}\\big{)}</span> <span class="math">\\mathbb{U}_{i}^{(1)}</span> <span class="math">=\\mathsf{Fold}_{V}\\big{(}\\mathsf{vk},\\;\\mathbb{U}_{i-1}^{(1)},\\;\\mathfrak{u}_{i}^{(1)},\\;\\bar{\\mathsf{T}}_{i-1}^{(1)}\\big{)}</span></p>

    <p class="text-gray-300">Thus, we parse <span class="math">\\mathfrak{w}_{i}^{(2)}</span> to obtain <span class="math">\\hat{w}_{i}^{(2)}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Find a different auxiliary value: Using <span class="math">z_{i-1}^{(2)}</span>, choose some <span class="math">\\mathsf{aux}_{\\mathsf{prime}}^{(2)}</span> such that</li>

    </ol>

    <p class="text-gray-300"><span class="math">z^{(2)}_{\\mathsf{prime}}:=\\mathsf{F}_{2}\\big{(}z_{i-1}^{(2)},\\ \\mathsf{aux}_{\\mathsf{prime}}^{(2)}\\big{)}\\quad\\neq\\quad\\mathsf{F}_{2}\\big{(}z_{i-1}^{(2)},\\ \\mathsf{aux}_{i-1}^{(2)}\\big{)}=z_{i}^{(2)}</span></p>

    <p class="text-gray-300">We assume that finding such an <span class="math">\\mathsf{aux}_{\\mathsf{prime}}^{(2)}</span> is efficient for <span class="math">\\mathsf{F}_{2}</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute a new pair for <span class="math">\\mathsf{R1CS}^{(2)}</span>: Compute the pair <span class="math">(\\mathfrak{u}^{(2)}_{\\mathsf{prime}},\\mathfrak{w}^{(2)}_{\\mathsf{prime}})</span> for <span class="math">\\mathsf{R1CS}^{(2)}</span> as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{w}^{(2)}_{\\mathsf{prime}}:=(\\mathsf{vk},(i-1)^{(2)},z_{0}^{(2)},z_{i-1}^{(2)},\\mathsf{aux}_{\\mathsf{prime}}^{(2)},\\mathbb{U}_{i-1}^{(1)},\\mathfrak{u}^{(1)}_{i},\\bar{\\mathsf{T}}^{(1)}_{i-i})</span> as the relation witness for <span class="math">\\mathcal{R}_{2}</span>. Then, compute the extended witness <span class="math">w^{(2)}_{\\mathsf{prime}}</span> by performing the computation on <span class="math">\\hat{w}^{(2)}_{\\mathsf{prime}}</span> required to satisfy the constraints expressed in <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}^{(2)}_{\\mathsf{prime}}\\leftarrow\\mathsf{Commit}(\\mathrm{pp}_{W}^{(2)},w^{(2)}_{\\mathsf{prime}})</span>.</li>

      <li>Define <span class="math">x_{0}:=\\mathfrak{u}^{(1)}_{i}.x_{1}</span> and compute <span class="math">x_{1}:=\\mathsf{H}_{2}\\big{(}\\mathsf{vk},i^{(2)},z_{0}^{(2)},z^{(2)}_{\\mathsf{prime}}:=\\mathsf{F}_{2}(z_{i-1}^{(2)},\\mathsf{aux}_{\\mathsf{prime}}^{(2)}),\\mathbb{U}_{i}^{(1)}\\big{)}</span>.</li>

      <li>Assign <span class="math">\\mathfrak{u}^{(2)}_{\\mathsf{prime}}:=\\big{(}\\bar{0}^{(2)},1^{(2)},\\bar{\\mathsf{w}}^{(2)}_{\\mathsf{prime}},(x_{0},x_{1})\\big{)}</span> and <span class="math">\\mathsf{w}^{(2)}_{\\mathsf{prime}}:=\\big{(}\\bar{0}^{(2)},w^{(2)}_{\\mathsf{prime}}\\big{)}</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Output the mauled new proof: Output <span class="math">\\pi_{\\mathsf{prime}}:=\\big{(}(\\mathfrak{u}^{(2)}_{\\mathsf{prime}},\\mathsf{w}^{(2)}_{\\mathsf{prime}}),\\ (\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)}),\\ (\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})\\big{)}</span>.</li>

    </ol>

    <p class="text-gray-300">By construction, the proof <span class="math">\\pi_{\\mathsf{prime}}</span> is convincing.</p>

    <h6 id="sec-46" class="text-base font-medium mt-4">Remark 6 (Generalizing the Malleability Attack).</h6>

    <p class="text-gray-300">Consider an IVC proof system where the final proof for validity of <span class="math">z_{i}</span> contains enough information to reconstruct a valid pre-image <span class="math">z_{i-1}</span> to <span class="math">z_{i}</span> along with a proof of validity for <span class="math">z_{i-1}</span>. Then an attacker can re-execute the last step of the IVC prover with a different choice of the final auxiliary value <span class="math">\\mathsf{aux}_{i-1}</span> and obtain a <span class="math">z^{\\prime}_{i}</span> that is likely different from <span class="math">z_{i}</span>, along with a validity proof for <span class="math">z^{\\prime}_{i}</span>. The attacker thus obtains a validity proof for <span class="math">z^{\\prime}_{i}\\neq z_{i}</span> despite having no knowledge of the first <span class="math">i-1</span> auxiliary values. Using this generalized view we can readily show that IVC proofs in the original Nova construction <em>[11]</em> are also malleable.</p>

    <h3 id="sec-47" class="text-xl font-semibold mt-8">8.2 Preventing This Malleability Attack</h3>

    <p class="text-gray-300">In this section we present three strategies to defend Nova IVC against the malleability attack from Section 8.1. First, recall that an important property of IVC is that it is <em>incremental</em>, hence the ‘I’ in IVC. This means that one party can start at <span class="math">z_{0}</span> and compute <span class="math">z_{i}</span>, the <span class="math">i</span>-th iteration of a function <span class="math">\\mathsf{F}</span>, along with a proof <span class="math">\\pi_{i}</span> that <span class="math">z_{i}</span> is valid. Another party can then continue the computation and produce <span class="math">z_{j}</span> which is the <span class="math">j</span>-th iteration of <span class="math">\\mathsf{F}</span>, for some <span class="math">j&gt;i</span>, along with a proof <span class="math">\\pi_{j}</span> that <span class="math">z_{j}</span> is valid. A third party can then take over, and so on. We refer to the points along the IVC chain, where one party hands off the computation to another party, as the hand-off point. With this incremental property in mind, let us consider three strategies to make the Nova folding scheme non-malleable.</p>

    <p class="text-gray-300">(1) <em>Compression</em> The most direct mitigation strategy is to use the compressed IVC proof <span class="math">\\pi^{\\prime\\prime}_{i}</span> defined in (49), namely</p>

    <p class="text-gray-300"><span class="math">\\pi^{\\prime\\prime}_{i}:=\\big{(}\\mathfrak{u}^{(2)}_{i},\\ \\mathbb{U}_{i}^{(2)},\\ \\mathbb{U}_{i}^{(1)},\\ \\bar{\\mathsf{T}}^{(2)}_{i},\\ \\pi_{\\mathsf{sat}}\\big{)}</span></p>

    <p class="text-gray-300">Here the SNARK must be zero knowledge so that <span class="math">\\pi_{\\mathsf{sat}}</span> contains no information about the underlying witnesses. Similarly, the witness commitment <span class="math">\\bar{\\mathsf{w}}^{(2)}_{i}</span> in <span class="math">\\mathfrak{u}^{(2)}_{i}</span> must be a hiding commitment. Furthermore, the SNARK should also be simulation extractable <em>[8]</em>.</p>

    <p class="text-gray-300">While this approach prevents our non-malleability attack, it also ruins the ability of the first prover (Fiona) to hand off the computation to a second prover (Sam) to continue the folding process. Sam does not see the witness for the final folding instance computed by Fiona, and consequently Sam cannot fold further iterations of <span class="math">\\mathsf{F}</span> into this instance. Note that Fiona must apply compression to her proof, otherwise Sam could use the malleability attack before doing his part of the computation. As a result, when applying this strategy to Nova folding, the entire IVC chain must be computed by a single party. Hence, again, this approach is incompatible with efficiently incremental IVC.</p>

    <p class="text-gray-300">(2) Incorporating Context Elements in the Verification Key A very different mitigation strategy is to expand the verification key vk to include a context string ctx defined as follows:</p>

    <p class="text-gray-300"><span class="math">(\\ \\cdot\\ ,\\textsf{vk})\\leftarrow\\textsf{Fold}_{\\mathcal{K}}\\big{(}\\textsf{pp},\\ (\\textsf{R1CS}^{(1)},\\textsf{R1CS}^{(2)}),\\ \\textsf{ctx}\\big{)}\\quad\\text{where}\\quad\\textsf{ctx}\\leftarrow(i,z^{(1)}_{i},z^{(2)}_{i}).</span></p>

    <p class="text-gray-300">This inductively binds the proof to a particular choice of <span class="math">(i,z^{(1)}_{i},z^{(2)}_{i})</span>. However, this again breaks the incremental property because the prover cannot hand off this proof to another prover to continue folding to some iteration <span class="math">j&gt;i</span>. Note also that the first (and only) IVC prover must compute the final <span class="math">(z^{(1)}_{i},z^{(2)}_{i})</span> before starting to construct the IVC proof.</p>

    <p class="text-gray-300">(3) Incremental context Our third mitigation strategy prevents the malleability attack while preserving the incremental property of Nova folding. We do so by updating the verification key at every hand off point in the IVC chain.</p>

    <p class="text-gray-300">Consider two provers: <span class="math">\\mathcal{P}_{\\textsf{prior}}</span> and <span class="math">\\mathcal{P}_{\\textsf{curr}}</span>. The prover <span class="math">\\mathcal{P}_{\\textsf{prior}}</span> was given a proof at position <span class="math">a</span> in the IVC chain and continued the computation to position <span class="math">b&gt;a</span>. The prover <span class="math">\\mathcal{P}_{\\textsf{curr}}</span> is given the proof produced by <span class="math">\\mathcal{P}_{\\textsf{prior}}</span> and continues the computation to position <span class="math">c&gt;b</span> in the IVC chain. Both provers incorporate private auxiliary data into their respective portions of the computation. Prover <span class="math">\\mathcal{P}_{\\textsf{curr}}</span> wants to produce an IVC proof <span class="math">\\pi_{c}</span> for <span class="math">c</span> executions of F with the same auxiliary values that the previous provers used in the first <span class="math">b</span> iterations while using its own auxiliary values for the remaining <span class="math">c-b</span> iterations.</p>

    <p class="text-gray-300">Briefly, to enable this while preventing a malleability attack, we introduce the notion of a range parameter range which is incorporated into the verification key. This range parameter enables <span class="math">\\mathcal{P}_{\\textsf{curr}}</span> to specify when a verification key should be swapped for a new one. In more detail, we define a new digest parameter dig which is identical to the old verification key vk:</p>

    <p class="text-gray-300"><span class="math">\\textsf{dig}:=\\textsf{H}\\big{(}\\textsf{pp},\\ (\\textsf{R1CS}^{(1)},\\textsf{R1CS}^{(2)})\\big{)}.</span></p>

    <p class="text-gray-300">Furthermore, for a given <span class="math">a&lt;b&lt;c</span> define</p>

    <p class="text-gray-300"><span class="math">\\textsf{range}_{\\textsf{prior}}:=\\big{(}(a,z^{(1)}_{a},z^{(2)}_{a}),\\ (b,z^{(1)}_{b},z^{(2)}_{b})\\big{)},\\qquad\\qquad\\qquad\\textsf{vk}_{\\textsf{prior}}:=\\textsf{H}\\big{(}\\textsf{dig},\\ \\textsf{range}_{\\textsf{prior}}\\big{)},</span> (50)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">\\textsf{range}_{\\textsf{curr}}:=\\big{(}(b,z^{(1)}_{b},z^{(2)}_{b}),\\ (c,z^{(1)}_{c},z^{(2)}_{c})\\big{)},\\qquad\\qquad\\qquad\\textsf{vk}_{\\textsf{curr}}:=\\textsf{H}\\big{(}\\textsf{dig},\\ \\textsf{range}_{\\textsf{curr}}\\big{)},</span> (51)</p>

    <p class="text-gray-300">where <span class="math">(a,z^{(1)}_{a},z^{(2)}_{a})</span> is the claimed evaluation after <span class="math">a</span> iterations of F, and similarly for <span class="math">b</span> and <span class="math">c</span>.</p>

    <p class="text-gray-300">To verify the computation after <span class="math">c</span> iterations, the IVC verifier is explicitly given the evaluations <span class="math">(b,z^{(1)}_{b},z^{(2)}_{b})</span> and <span class="math">(c,z^{(1)}_{c},z^{(2)}_{c})</span>. It verifies that <span class="math">b&lt;c</span> and computes parameters dig and vk_{curr}. In addition, the relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> from Figures 1(a) and 1(b) will take in additional witness inputs dig, <span class="math">(a,z^{(1)}_{a},z^{(2)}_{a})</span>, and <span class="math">(b,z^{(1)}_{b},z^{(2)}_{b})</span> and incorporate these additional constraints:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The indices respect <span class="math">a&lt;b&lt;i</span>, where <span class="math">i</span> is the input iteration index.</li>

      <li>If input iteration index <span class="math">i\\neq b</span>, proceed as usual. The verification key included in the input committed instance <span class="math">\\mathfrak{u}_{i}</span> is identical to the one included in <span class="math">\\mathfrak{u}_{i+1}</span>.</li>

      <li>If input iteration index <span class="math">i=b</span>, then the relation swaps the verification keys. Check that the input instance <span class="math">\\mathfrak{u}_{b}</span> contains the verification key <span class="math">\\textsf{vk}_{\\textsf{prior}}</span> as computed in (50). Additionally, compute the verification key <span class="math">\\textsf{vk}_{\\textsf{curr}}</span> as computed in (51). Use <span class="math">\\textsf{vk}_{\\textsf{curr}}</span> in the fold operation and include <span class="math">\\textsf{vk}_{\\textsf{curr}}</span> in the output hash contained in the instance <span class="math">\\mathfrak{u}_{b+1}</span>.</li>

    </ul>

    <p class="text-gray-300">As explained above, this approach prevents the malleability attack while preserving the incremental property using Nova folding. The cost is a slightly larger IVC proof which includes, as usual, the final evaluation values <span class="math">(c,z^{(1)}_{c},z^{(2)}_{c})</span>, but now also needs to include the second-to-last handoff values, namely <span class="math">(b,z^{(1)}_{b},z^{(2)}_{b})</span>. Of course, the very last prover in the IVC chain can still apply a zkSNARK to compress the final proof.</p>

    <p class="text-gray-300">Acknowledgments. This work was partially funded by NSF, DARPA, the Simons Foundation, and NTT Research. Opinions, findings, and conclusions or recommendations expressed in this material are those of the authors and do not necessarily reflect the views of DARPA.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">Bibliography</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] B. Bünz and B. Chen. ProtoStar: Generic efficient accumulation/folding for special sound protocols, 2023. https://eprint.iacr.org/2023/620.</li>

      <li>[2] B. Bünz, A. Chiesa, W. Lin, P. Mishra, and N. Spooner. Proof-carrying data without succinct arguments. Advances in Cryptology – CRYPTO 2021, Part I, 2021.</li>

      <li>[3] Q. Dao, J. Miller, O. Wright, and P. Grubbs. Weak Fiat-Shamir attacks on modern proof systems, 2023. https://eprint.iacr.org/2023/691.</li>

      <li>[4] A. De Santis, G. Di Crescenzo, R. Ostrovsky, G. Persiano, and A. Sahai. Robust non-interactive zero knowledge. Advances in Cryptology – CRYPTO 2001, 2001.</li>

      <li>[5] M. Dworkin. SHA-3 standard: Permutation-based hash and extendable-output functions, 2015.</li>

      <li>[6] A. Fiat and A. Shamir. How to prove yourself: Practical solutions to identification and signature problems. Advances in Cryptology – CRYPTO’86, 1987.</li>

      <li>[7] L. Grassi, D. Khovratovich, C. Rechberger, A. Roy, and M. Schofnegger. Poseidon: A new hash function for zero-knowledge proof systems. USENIX Security 2021: 30th USENIX Security Symposium, 2021.</li>

      <li>[8] J. Groth. Simulation-sound NIZK proofs for a practical language and constant size group signatures. Advances in Cryptology – ASIACRYPT 2006, 2006.</li>

      <li>[9] D. Khovratovich, M. Maller, and P. R. Tiwari. MinRoot: Candidate sequential function for Ethereum VDF, 2022. https://eprint.iacr.org/2022/1626.</li>

      <li>[10] A. Kothapalli and S. Setty. HyperNova: Recursive arguments for customizable constraint systems, 2023. https://eprint.iacr.org/2023/573.</li>

      <li>[11] A. Kothapalli, S. Setty, and I. Tzialla. Nova: Recursive zero-knowledge arguments from folding schemes. Advances in Cryptology – CRYPTO 2022, Part IV, 2022.</li>

      <li>[12] N. Mohnblatt. Sangria: A folding scheme for PLONK, 2023. link.</li>

      <li>[13] Nova Contributors. Nova implementation, 2022. https://github.com/Microsoft/Nova.</li>

      <li>[14] Pasta Contributors. Pasta curves, 2020. https://github.com/zcash/pasta_curves.</li>

      <li>[15] C. Ràfols and A. Zacharakis. Folding schemes with selective verification, 2022. https://eprint.iacr.org/2022/1576.</li>

      <li>[16] S. Setty. Spartan: Efficient and general-purpose zkSNARKs without trusted setup. Advances in Cryptology – CRYPTO 2020, Part III, 2020.</li>

      <li>[17] S. Setty. Nova pull request 167, 2023. https://github.com/Microsoft/Nova/pull/167.</li>

      <li>[18] P. Valiant. Incrementally verifiable computation or proofs of knowledge imply time/space efficiency. TCC 2008: 5th Theory of Cryptography Conference, 2008.</li>

    </ul>

    <p class="text-gray-300">Appendix</p>

    <p class="text-gray-300">In this Appendix, we describe the prior implementation of the Nova Verifier and the vulnerability in detail. At the end, we provide a proof of concept attack against the Minroot VDF <em>[9]</em> Nova verifier.</p>

    <h2 id="sec-48" class="text-2xl font-bold">Appendix A The Old Nova Verifier</h2>

    <p class="text-gray-300">The old Nova Verifier <span class="math">\\mathcal{V}</span> takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint Systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>An index <span class="math">i\\in\\mathbb{N}</span>.</li>

      <li>Starting values <span class="math">z_{0}^{(1)}\\in\\mathbb{F}_{1},\\ z_{0}^{(2)}\\in\\mathbb{F}_{2}</span>.</li>

      <li>Claimed evaluations <span class="math">z_{i}^{(1)}\\in\\mathbb{F}_{1},\\ z_{i}^{(2)}\\in\\mathbb{F}_{2}</span></li>

      <li>An IVC Proof for iteration <span class="math">i</span> is <span class="math">\\pi_{i}:=\\big{(}(\\mathfrak{u}_{i}^{(1)},\\mathbf{w}_{i}^{(1)}),\\ (\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)}),\\ (\\mathfrak{u}_{i}^{(2)},\\mathbf{w}_{i}^{(2)}),\\ (\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})\\big{)}</span>.</li>

    </ul>

    <p class="text-gray-300">The verifier performs an initial procedure:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Given functions <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span>, deterministically generate augmented R1CS constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> which implement relations <span class="math">\\mathcal{R}_{1}</span> and <span class="math">\\mathcal{R}_{2}</span> from Figures 1(a) and 1(b)</li>

      <li>Compute the folding verification key</li>

    </ol>

    <p class="text-gray-300"><span class="math">(\\ \\cdot\\ ,\\mathsf{vk})\\leftarrow\\mathsf{Fold}_{\\mathcal{K}}\\big{(}\\mathsf{pp},\\ \\mathsf{R1CS}:=(\\mathsf{R1CS}^{(1)},\\mathsf{R1CS}^{(2)})\\big{)}</span></p>

    <p class="text-gray-300">The verifier accepts if the following conditions are met:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The index <span class="math">i</span> must be greater than 0.</li>

      <li><span class="math">\\mathfrak{u}_{i}^{(1)}.x_{1}=\\mathsf{H}_{1}\\left(\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathbb{U}_{i}^{(2)}\\right)</span></li>

      <li><span class="math">\\mathfrak{u}_{i}^{(2)}.x_{1}=\\mathsf{H}_{2}\\left(\\mathsf{vk},i^{(2)},z_{0}^{(2)},z_{i}^{(2)},\\mathbb{U}_{i}^{(1)}\\right)</span></li>

      <li>Pair <span class="math">(\\mathbb{U}_{i}^{(1)},\\mathbb{W}_{i}^{(1)})</span> satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>Pairs <span class="math">(\\mathbb{U}_{i}^{(2)},\\mathbb{W}_{i}^{(2)})</span> satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

      <li>Pair <span class="math">(\\mathfrak{u}_{i}^{(1)},\\mathbf{w}_{i}^{(1)})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span>.</li>

      <li>Pair <span class="math">(\\mathfrak{u}_{i}^{(2)},\\mathbf{w}_{i}^{(2)})</span> strictly satisfies <span class="math">\\mathsf{R1CS}^{(2)}</span>.</li>

    </ol>

    <h2 id="sec-49" class="text-2xl font-bold">Appendix B The Vulnerability</h2>

    <p class="text-gray-300">In this section we first break down the implications of the verifier checks. Then, we explore a vulnerability with the approach. Finally, we describe a process to forge convincing IVC proofs in two stages.</p>

    <p class="text-gray-300">Informally, for <span class="math">i&gt;2</span>, the security argument for Nova IVC proceeds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that <span class="math">\\mathfrak{u}_{i}^{(1)}.x_{1}=\\mathsf{H}_{1}\\left(\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)},\\mathbb{U}_{i}^{(2)}\\right)</span>. This ensures that <span class="math">\\mathfrak{u}_{i}^{(1)}.x_{1}</span> is derived from the inputs <span class="math">z_{i}^{(1)}</span> and <span class="math">\\mathbb{U}_{i}^{(2)}</span> that are provided to the verifier.</li>

      <li>The verifier checks that the pair <span class="math">(\\mathfrak{u}_{i}^{(1)},\\mathbf{w}_{i}^{(1)})</span> satisfies <span class="math">\\mathsf{R1CS}^{(1)}</span> which implements the relation <span class="math">\\mathcal{R}_{1}</span>. This implies two things:</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First, <span class="math">\\mathbb{U}_{i}^{(2)}</span> is the result of folding the instances <span class="math">\\mathfrak{u}_{i-1}^{(2)}</span> and <span class="math">\\mathbb{U}_{i-1}^{(2)}</span> specified in <span class="math">\\mathbf{w}_{i}^{(1)}</span>,</li>

      <li>Second, <span class="math">\\mathfrak{u}_{i-1}^{(2)}.x_{0}=\\mathsf{H}_{1}\\left(\\mathsf{vk},\\ (i-1)^{(1)},\\ z_{0}^{(1)},\\ z_{i-1}^{(1)},\\ \\mathbb{U}_{i-1}^{(2)}\\right)</span> where <span class="math">z_{i}^{(1)}=\\mathsf{F}_{1}(z_{i-1}^{(1)},\\ \\mathsf{aux}_{i-1}^{(1)})</span> for some element <span class="math">\\mathsf{aux}_{i-1}^{(1)}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The verifier checks that <span class="math">(\\mathfrak{U}_i^{(2)},\\mathbb{W}_i^{(2)})</span> satisfies R1CS<span class="math">^{(2)}</span>, which implements the relation <span class="math">\\mathcal{R}_2</span>. Then by knowledge soundness of the folding scheme, one can extract valid witnesses <span class="math">\\mathsf{w}_{i - 1}^{(2)}</span> for <span class="math">\\mathfrak{u}_{i - 1}^{(2)}</span> and <span class="math">\\mathbb{W}_{i - 1}^{(2)}</span> for <span class="math">\\mathfrak{U}_{i - 1}^{(2)}</span> with respect to R1CS<span class="math">^{(2)}</span>.</li>

      <li>Now, since <span class="math">\\mathsf{w}_{i - 1}^{(2)}</span> is a valid witness for <span class="math">\\mathfrak{u}_{i - 1}^{(2)}</span>, there are instances <span class="math">\\mathfrak{u}_{i - 1}^{(1)}</span> and <span class="math">\\mathfrak{U}_{i - 2}^{(1)}</span> specified in <span class="math">\\mathsf{w}_{i - 1}^{(2)}</span>. By definition of <span class="math">\\mathcal{R}_2</span>, the instance <span class="math">\\mathfrak{u}_{i - 1}^{(1)}</span> must satisfy <span class="math">\\mathfrak{u}_{i - 1}^{(1)}.x_1 = \\mathfrak{u}_{i - 1}^{(2)}.x_0 = \\mathsf{H}_1\\left(\\mathsf{vk},(i - 1)^{(1)},z_0^{(1)},z_{i - 1}^{(1)},\\mathfrak{U}_{i - 1}^{(2)}\\right)</span>.</li>

    </ul>

    <p class="text-gray-300">We would now like to conclude that both <span class="math">\\mathfrak{u}_{i-1}^{(1)}</span> and <span class="math">\\mathfrak{U}_{i-2}^{(1)}</span> are satisfiable for R1CS<span class="math">^{(1)}</span>. However, none of the verifier checks or invariants induced by the relations imply that either <span class="math">\\mathfrak{u}_{i-1}^{(1)}</span> or <span class="math">\\mathfrak{U}_{i-2}^{(1)}</span> are satisfiable with respect to R1CS<span class="math">^{(1)}</span>. To see why, observe that <span class="math">\\mathcal{R}_2</span> verifies that <span class="math">\\mathfrak{u}_{i-1}^{(1)}</span> and <span class="math">\\mathfrak{U}_{i-2}^{(1)}</span> fold into some <span class="math">\\mathfrak{U}_{i-1}^{(1)}</span>. Then this <span class="math">\\mathfrak{U}_{i-1}^{(1)}</span> is hashed into <span class="math">\\mathfrak{u}_{i-1}^{(2)}.x_1</span>, which gets copied to <span class="math">\\mathfrak{u}_i^{(1)}.x_0</span>. The verifier is given an instance <span class="math">\\mathfrak{U}_i^{(1)}</span> that it expects to be the result of folding <span class="math">\\mathfrak{u}_i^{(1)}</span> and <span class="math">\\mathfrak{U}_{i-1}^{(1)}</span>, but this need not be the case. In fact, <span class="math">\\mathfrak{U}_i^{(1)}</span> can be the result of folding entirely different <span class="math">\\mathfrak{u}^{(1)}</span> and <span class="math">\\mathfrak{U}^{(1)}</span>.</p>

    <p class="text-gray-300">Our attack exploits this by running the honest Nova prover for two stages. The first stage generates a satisfiable instance <span class="math">\\mathfrak{u}_{i-1}^{(2)}</span> with <span class="math">x_0</span> containing our own adversarially chosen values of <span class="math">(i-1)^{(1)}</span> and <span class="math">z_{i-1}^{(1)}</span>. Then, the second stage generates pairs <span class="math">(\\mathfrak{u}_i^{(1)},\\mathfrak{w}_i^{(1)})</span>, <span class="math">(\\mathfrak{U}_i^{(2)},\\mathfrak{W}_i^{(2)})</span> by running the honest prover again with <span class="math">\\mathfrak{U}_{\\perp}^{(2)}</span>, <span class="math">\\mathfrak{u}_{i-1}^{(2)}</span> as relational witness inputs. The attack proceeds symmetrically to generate pairs <span class="math">(\\mathfrak{u}_i^{(2)},\\mathfrak{w}_i^{(2)})</span>, <span class="math">(\\mathfrak{U}_i^{(1)},\\mathfrak{W}_i^{(1)})</span>.</p>

    <h2 id="sec-50" class="text-2xl font-bold">B.1 Attack Procedure</h2>

    <p class="text-gray-300">Our adversary <span class="math">\\mathcal{A}</span> takes in as input:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Constraint Systems R1CS<span class="math">^{(1)}</span> and R1CS<span class="math">^{(2)}</span>.</li>

      <li>An attack index <span class="math">i &amp;gt; 2 \\in \\mathbb{N}</span>.</li>

      <li>Arbitrary starting values <span class="math">z_0^{(1)} \\in \\mathbb{F}_1</span> and <span class="math">z_0^{(2)} \\in \\mathbb{F}_2</span>.</li>

      <li>Arbitrary claimed evaluations <span class="math">z_{i}^{(1)}\\in \\mathbb{F}_{1}</span> and <span class="math">z_{i}^{(2)}\\in \\mathbb{F}_{2}</span>.</li>

      <li>Preimages <span class="math">(z_{i - 1}^{(1)},\\mathsf{aux}_{i - 1}^{(1)})\\in \\mathbb{F}_1</span> and <span class="math">(z_{i - 1}^{(2)},\\mathsf{aux}_{i - 1}^{(2)})\\in \\mathbb{F}_2</span> such that <span class="math">z_{i}^{(1)} = \\mathsf{F}_{1}(z_{i - 1}^{(1)},\\mathsf{aux}_{i - 1}^{(1)})</span> and <span class="math">z_{i}^{(2)} = \\mathsf{F}_{2}(z_{i - 1}^{(2)},\\mathsf{aux}_{i - 1}^{(2)})</span>.</li>

    </ul>

    <p class="text-gray-300"><span class="math">\\mathcal{A}</span> will produce a false but convincing IVC proof <span class="math">\\pi_{i}</span> that the elements <span class="math">z_{i}^{(1)} = \\mathsf{F}_{1}^{(i)}(z_{0}^{(1)},\\cdot)</span> and <span class="math">z_{i}^{(2)} = \\mathsf{F}_{2}^{(i)}(z_{0}^{(2)},\\cdot)</span> are produced by iteratively applying the non-deterministic functions <span class="math">\\mathsf{F}_1</span>, <span class="math">\\mathsf{F}_2</span> <span class="math">i</span>-times on <span class="math">z_0^{(1)}</span>, <span class="math">z_0^{(2)}</span> for some collection of auxiliary values <span class="math">\\{\\mathsf{aux}_j^{(1)},\\mathsf{aux}_j^{(2)}\\}_{0\\leq j &amp;lt; i}</span>.</p>

    <p class="text-gray-300">Stage One <span class="math">\\mathcal{A}</span> will imitate an honest Nova Prover to produce a satisfying pair <span class="math">(\\mathfrak{u}_{i-1}^{(2)}, \\mathfrak{w}_{i-1}^{(2)})</span> for R1CS<span class="math">^{(2)}</span>, but with adversarial inputs.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Produce Adversarial Instance: We will produce an adversarial <span class="math">\\mathfrak{u}_{i-1}^{(1)}</span> by performing the following steps:</li>

    </ol>

    <p class="text-gray-300">(a) Compute <span class="math">x_0 \\coloneqq \\mathsf{H}_2\\left(\\mathsf{vk}, (i - 2)^{(2)}, z_0^{(2)}, z_{i - 2}^{(2)}, \\mathfrak{U}_{\\perp}^{(1)}\\right)</span>, where <span class="math">z_{i - 2}^{(2)}</span> can be set to anything, such as <span class="math">\\vec{0}^{(2)}</span>.</p>

    <p class="text-gray-300">(b) Compute <span class="math">x_{1} \\coloneqq \\mathsf{H}_{1}\\left(\\mathsf{vk}, (i - 1)^{(1)}, z_{0}^{(1)}, z_{i - 1}^{(1)}, \\mathfrak{U}_{\\perp}^{(2)}\\right)</span>.</p>

    <p class="text-gray-300">(c) Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_{i-1}^{(1)} \\gets \\mathsf{Commit}(\\mathrm{pp}_W^{(1)}, w_{i-1}^{(1)})</span>, where the extended witness <span class="math">w_{i-1}^{(1)}</span> can be set to anything, such as <span class="math">\\vec{0}^{(2)}</span>.</p>

    <p class="text-gray-300">(d) Assign <span class="math">\\mathfrak{u}_{i-1}^{(1)} := \\left(\\bar{0}^{(1)}, 1^{(1)}, \\bar{w}_{i-1}^{(1)}, (x_0, x_1)\\right)</span> and <span class="math">\\mathsf{w}_{i-1}^{(1)} := \\left(\\vec{0}^{(1)}, w_{i-1}^{(1)}\\right)</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Fold Pair for R1CS<span class="math">^{(1)}</span>: Fold the newly computed pair <span class="math">(\\mathfrak{u}_{i-2}^{(1)}, \\mathfrak{w}_{i-2}^{(1)})</span> with the trivially satisfiable pair <span class="math">(\\mathfrak{U}_{\\perp}^{(1)}, \\mathfrak{W}_{\\perp}^{(1)})</span> for R1CS<span class="math">^{(1)}</span>.</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Fold}_{\\mathcal{P}}\\left(\\mathsf{pk}, (\\mathfrak{u}_{i-1}^{(1)}, \\mathsf{w}_{i-1}^{(1)}), (\\mathfrak{U}_{\\perp}^{(1)}, \\mathfrak{W}_{\\perp}^{(1)})\\right) \\to \\left(\\bar{\\mathsf{T}}_{i-2}^{(1)}, (\\mathfrak{U}_{i-1}^{(1)}, \\mathfrak{W}_{i-1}^{(1)})\\right)</span></div>

    <p class="text-gray-300">Obtain a folding proof <span class="math">\\bar{\\mathsf{T}}_{i-2}^{(1)}</span> and new committed relaxed instance-witness pair <span class="math">(\\mathfrak{U}_{i-1}^{(1)}, \\mathfrak{W}_{i-1}^{(1)})</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Compute New Pair for R1CS(2): Compute the new committed pair <span class="math">(\\mathfrak{u}_{i-1}^{(2)}, \\mathfrak{w}_{i-1}^{(2)})</span> for R1CS(2) as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{w}_{i-1}^{(2)} := (\\mathsf{vk}, (i-2)^{(2)}, z_0^{(2)}, z_{i-2}^{(2)}, \\mathsf{aux}_{i-2}^{(2)}, \\mathbb{U}_{\\perp}^{(1)}, \\mathfrak{u}_{i-1}^{(1)}, \\bar{\\mathsf{T}}_{i-2}^{(1)})</span> as the relation witness for <span class="math">\\mathcal{R}_2</span>, where <span class="math">\\mathsf{aux}_{i-2}^{(2)}</span> can be set to anything, such as <span class="math">\\vec{0}^{(2)}</span>. Then, compute the extended witness <span class="math">w_{i-1}^{(2)}</span> by performing the computation on <span class="math">\\hat{w}_{i-1}^{(2)}</span> required to satisfy the constraints expressed in R1CS(2).</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_{i-1}^{(2)} \\gets \\mathsf{Commit}(\\mathsf{pp}_W^{(2)}, w_{i-1}^{(2)})</span>.</li>

      <li>Define <span class="math">x_0 = \\mathfrak{u}_{i-1}^{(1)} \\cdot x_1</span> and compute <span class="math">x_1 = \\mathsf{H}_2\\left(\\mathsf{vk}, (i-1)^{(2)}, z_0^{(2)}, \\mathsf{F}_2^{(2)}(z_{i-2}^{(2)}, \\mathsf{aux}_{i-2}^{(2)}), \\mathbb{U}_{i-1}^{(1)}\\right)</span>.</li>

      <li>Assign <span class="math">\\mathfrak{u}_{i-1}^{(2)} := \\left(\\bar{0}^{(2)}, 1^{(2)}, \\bar{\\mathsf{w}}_{i-1}^{(2)}, (x_0, x_1)\\right)</span> and <span class="math">\\mathfrak{w}_{i-1}^{(2)} := \\left(\\vec{0}^{(2)}, w_{i-1}^{(2)}\\right)</span>.</li>

    </ul>

    <p class="text-gray-300">This new committed instance-witness pair <span class="math">(\\mathfrak{u}_{i-1}^{(2)}, \\mathfrak{w}_{i-1}^{(2)})</span> is valid, because the computation performed above explicitly satisfies the constraints of R1CS(2). Furthermore, <span class="math">\\mathfrak{u}_{i-1}^{(2)} \\cdot x_0 = \\mathfrak{u}_{i-1}^{(1)} \\cdot x_1</span>, which is maliciously set to <span class="math">\\mathsf{H}_1\\left(\\mathsf{vk}, (i-1)^{(1)}, z_0^{(1)}, z_{i-1}^{(1)}, \\mathbb{U}_{\\perp}^{(2)}\\right)</span>.</p>

    <p class="text-gray-300">Stage Two <span class="math">\\mathcal{A}</span> will imitate an honest Nova Prover for R1CS(1), but with witness input derived in stage one.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Fold Pair for R1CS(2):</strong> Fold the newly computed pair <span class="math">(\\mathfrak{u}_{i-1}^{(2)}, \\mathfrak{w}_{i-1}^{(2)})</span> with the trivially satisfiable pair <span class="math">(\\mathbb{U}_{\\perp}^{(2)}, \\mathbb{W}_{\\perp}^{(2)})</span> for R1CS(2).</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\operatorname {F o l d} _ {\\mathcal {P}} \\left(\\mathrm {p k}, \\left(\\mathrm {u} _ {i - 1} ^ {(2)}, \\mathrm {w} _ {i - 1} ^ {(2)}\\right), \\left(\\mathbb {U} _ {\\perp} ^ {(2)}, \\mathbb {W} _ {\\perp} ^ {(2)}\\right)\\right)\\rightarrow \\left(\\bar {\\mathrm {T}} _ {i - 1} ^ {(2)}, \\left(\\mathbb {U} _ {i} ^ {(2)}, \\mathbb {W} _ {i} ^ {(2)}\\right)\\right)</span></div>

    <p class="text-gray-300">Obtain a folding proof <span class="math">\\bar{\\mathsf{T}}_{i-1}^{(2)}</span> and new committed relaxed instance-witness pair <span class="math">(\\mathbb{U}_i^{(2)},\\mathbb{W}_i^{(2)})</span>. Note that since both pairs are satisfiable, this new pair <span class="math">(\\mathbb{U}_i^{(2)},\\mathbb{W}_i^{(2)})</span> is also satisfiable.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Compute New Pair for R1CS(1):</strong> Compute the new committed pair <span class="math">(\\mathfrak{u}_i^{(1)}, \\mathfrak{w}_i^{(1)})</span> for R1CS(1) as follows:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Define <span class="math">\\hat{w}_i^{(1)} \\coloneqq (\\mathsf{vk}, (i - 1)^{(1)}, z_0^{(1)}, z_{i - 1}^{(1)}, \\mathsf{aux}_{i - 1}^{(1)}, \\mathbb{U}_{\\perp}^{(2)}, \\mathfrak{u}_{i - 1}^{(2)}, \\bar{\\mathsf{T}}_{i - 1}^{(2)})</span> as the relation witness for <span class="math">\\mathcal{R}_1</span>. Then, compute the extended witness <span class="math">w_i^{(1)}</span> by performing the computation on <span class="math">\\hat{w}_i^{(1)}</span> required to satisfy the constraints expressed in R1CS(1).</li>

      <li>Commit to the extended witness <span class="math">\\bar{\\mathsf{w}}_i^{(1)}\\gets \\mathsf{Commit}(\\mathsf{pp}_W^{(1)},w_i^{(1)})</span></li>

      <li>Define <span class="math">x_0 = \\mathfrak{u}_{i - 1}^{(2)}.x_1</span> and compute <span class="math">x_{1} = \\mathsf{H}_{1}\\left(\\mathsf{vk},i^{(1)},z_{0}^{(1)},z_{i}^{(1)}:=\\mathsf{F}_{1}(z_{i - 1}^{(1)},\\mathsf{aux}_{i - 1}^{(1)}),\\mathbb{U}_{i}^{(2)}\\right)</span></li>

      <li>Assign <span class="math">\\mathfrak{u}_i^{(1)}\\coloneqq \\left(\\bar{0}^{(1)},1^{(1)},\\bar{\\mathsf{w}}_i^{(1)},(x_0,x_1)\\right)</span> and <span class="math">\\mathfrak{w}_i^{(1)}\\coloneqq \\left(\\vec{0}^{(1)},w_i^{(1)}\\right)</span>.</li>

    </ul>

    <p class="text-gray-300">This new committed instance-witness pair <span class="math">(\\mathfrak{u}_i^{(1)}, \\mathfrak{w}_i^{(1)})</span> is satisfiable, because the computation performed above explicitly satisfies the constraints of R1CS(1). Furthermore, <span class="math">\\mathfrak{u}_i^{(1)}.x_1 = \\mathsf{H}_1\\left(\\mathsf{vk},i^{(1)},z_0^{(1)},z_i^{(1)},\\mathbb{U}_i^{(2)}\\right)</span>. To recap, after these two stages we obtained pairs <span class="math">(\\mathfrak{u}_i^{(1)}, \\mathfrak{w}_i^{(1)})</span> and <span class="math">(\\mathbb{U}_i^{(2)}, \\mathbb{W}_i^{(2)})</span> such that the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{u}_i^{(1)}.x_1 = \\mathsf{H}_1\\left(\\mathsf{vk},i^{(1)},z_0^{(1)},z_i^{(1)},\\mathbb{U}_i^{(2)}\\right)</span></li>

      <li><span class="math">(\\mathfrak{u}_i^{(1)}, \\mathfrak{w}_i^{(1)})</span> strictly satisfies R1CS(1).</li>

      <li><span class="math">(\\mathbb{U}_i^{(2)}, \\mathbb{W}_i^{(2)})</span> satisfies R1CS(2).</li>

    </ul>

    <p class="text-gray-300"><strong>Symmetry</strong> Since the relations expressed by the augmented constraint systems <span class="math">\\mathsf{R1CS}^{(1)}</span> and <span class="math">\\mathsf{R1CS}^{(2)}</span> are symmetric (Section 4) when <span class="math">i &amp;gt; 2</span>. We can repeat both stages above symmetrically to produce pairs <span class="math">(\\mathfrak{u}_i^{(2)}, \\mathfrak{w}_i^{(2)})</span> and <span class="math">(\\mathbb{U}_i^{(1)}, \\mathbb{W}_i^{(1)})</span> such that the following hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathfrak{u}_i^{(2)}.x_1 = \\mathsf{H}_2\\left(\\mathsf{vk},i^{(2)},z_0^{(2)},z_i^{(2)},\\mathbb{U}_i^{(1)}\\right)</span></li>

      <li><span class="math">(\\mathfrak{u}_i^{(2)}, \\mathfrak{w}_i^{(2)})</span> strictly satisfies R1CS(2).</li>

      <li><span class="math">(\\mathbb{U}_i^{(1)}, \\mathbb{W}_i^{(1)})</span> satisfies R1CS(1).</li>

    </ul>

    <p class="text-gray-300">Finally, adversary <span class="math">\\mathcal{A}</span> outputs an IVC proof <span class="math">\\pi_i := \\big((\\mathfrak{u}_i^{(1)}, \\mathfrak{w}_i^{(1)}), (\\mathbb{U}_i^{(1)}, \\mathbb{W}_i^{(1)}), (\\mathfrak{u}_i^{(2)}, \\mathfrak{w}_i^{(2)}), (\\mathbb{U}_i^{(2)}, \\mathbb{W}_i^{(2)})\\big)</span>. By construction, <span class="math">\\pi_i</span> is a convincing IVC proof (i.e. all the verifier checks pass).</p>

    <p class="text-gray-300">26</p>

    <p class="text-gray-300">B.2 Proof of Concept Attack Against the Minroot Verifier</p>

    <p class="text-gray-300">We implement our attack against the Nova Proof System generically for any choice of <span class="math">\\mathsf{F}_{1}</span> and <span class="math">\\mathsf{F}_{2}</span> and parameters specified in Section B.1. Our implementation can be found in our repo MercysJest/NovaBreakingTheCycleAttack, which is a direct fork of the original microsoft/Nova repo. To demonstrate the attack, we can compute a convincing Nova proof for the correct evaluation of <span class="math">2^{75}</span> rounds of the Minroot VDF in only 1.46 seconds on a Macbook. The demonstration code can be found in examples/vuln.rs.</p>

    <p class="text-gray-300">================================================================================ Demonstrating exploit against Nova-based VDF with MinRoot delay function ================================================================================ Producing public parameters... PublicParams::setup, took 49.787099416s ... Each IVC Step Performs 4096 iterations of Minroot. Generating fake proof of 9223372036854775808 IVC Steps. In total, faking 37778931862957161709568 Minroot iterations. Generating fake proof took 1.462871375s Verifying a RecursiveSNARK... RecursiveSNARK::verify: true, took 110.942375ms Generating a CompressedSNARK using Spartan with IPA-PC... CompressedSNARK::prove: true, took 24.981085s CompressedSNARK::len 9713 bytes Verifying a CompressedSNARK... CompressedSNARK::verify: true, took 194.277833ms</p>`;
---

<BaseLayout title="Revisiting the Nova Proof System on a Cycle of Curves (2023/969)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2023 &middot; eprint 2023/969
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
