---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/315';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-14';
---

<BaseLayout title="plookup: Polynomial Protocol for Lookup Tables (2020/315)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        plookup: A simplified polynomial protocol for lookup tables
      </h1>
      <p class="text-gray-400 mb-2">
        Ariel Gabizon, Zachary J. Williamson
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; Full Version &middot; eprint 2020/315
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">Converted with: {CRAWLER} &middot; {CONVERTED_DATE}</p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">Preliminaries</a>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">The Main Scheme</a>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Generalizing to Vector Lookups and Multiple Tables</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-4.1"
                class="hover:text-white">
                Multiple Tables</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            An Optimized Solution for Continuous Ranges</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We present a protocol for checking the values of a committed
        polynomial
        <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; n&#125;[X]</span>
        over a multiplicative subgroup
        <span class="math">H \subset \mathbb&#123;F&#125;</span>
        of size <span class="math">n</span>, are contained in the
        values of a table
        <span class="math">t \in \mathbb&#123;F&#125;^d</span>.
        Our protocol can be viewed as a simplification of one from
        Bootle et al. [BCG+] for a similar problem, with
        potential efficiency improvements when
        <span class="math">d \leq n</span>.
        In particular, [BCG+]&rsquo;s protocol requires
        committing to several auxiliary polynomials of degree
        <span class="math">d \cdot \log n</span>, whereas ours
        requires three commitments to auxiliary polynomials of degree
        <span class="math">n</span>, which can be much smaller in
        the case
        <span class="math">d \sim n</span>.
      </p>
      <p class="text-gray-300">
        One common use case of this primitive in the zk-SNARK setting
        is a &ldquo;batched range proof&rdquo;, where one wishes to
        check all of
        <span class="math">f</span>&rsquo;s values on
        <span class="math">H</span> are in a range
        <span class="math">[0, \ldots, M]</span>.
        We present a slightly optimized protocol for this special
        case, and pose improving it as an open problem.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        When wanting to use zk-SNARKs to prove statements involving
        standard primitives like AES-128 or SHA-256, one runs into the
        problem that the operations involved in these primitives are
        &ldquo;SNARK unfriendly&rdquo;, in the sense of having large
        representations in the native SNARK language, which typically
        corresponds to low degree equations over a large prime field.
        Examples of operations with large overhead are ones involving
        bit decomposition like bitwise XOR or AND. This has led to
        growing research into STARK and SNARK friendly hash functions
        and symmetric primitives that are based solely on native field
        operations [GKK+19, AAB+19,
        AGR+16, ACG+19].
      </p>

      <p class="text-gray-300">
        We investigate an alternative approach, where for commonly
        used operations we precompute a lookup table of the legitimate
        (input, output) combinations; and the prover argues the
        witness values exist in this table.
      </p>

      <p class="text-gray-300">
        Using randomness, we can reduce to the case of looking up
        single field elements instead of tuples. Then, in polynomial
        language, this ultimately boils down to proving polynomials
        are the same &ldquo;up to multiplicities&rdquo;. That is,
        suppose that the values in the lookup table are
        <span class="math">\&#123;t_i\&#125;_&#123;i \in [d]&#125;</span>
        and the values in the witness are
        <span class="math">\&#123;f_i\&#125;_&#123;i \in [n]&#125;</span>.
        We want to show that the polynomials
      </p>

      <div class="math-block">
        F(X) := \prod_&#123;i \in [n]&#125; (X - f_i), \quad
        G(X) := \prod_&#123;i \in [d]&#125; (X - t_i)
      </div>

      <p class="text-gray-300">
        have the same roots, ignoring multiplicities; i.e. that for
        some non-negative integers
        <span class="math">\&#123;e_i\&#125;_&#123;i \in [d]&#125;</span>
        we have
        <span class="math">F(X) = \prod_&#123;i \in [d]&#125; (X - t_i)^&#123;e_i&#125;</span>.
        Bootle et al. [BCG+] gave an algorithm for this
        exact problem, also in the context of efficient SNARK
        arithmetization of a common operation (in their case,
        repeatedly checking that field elements correspond to certain
        convenient sparse representations of boolean strings).
      </p>

      <p class="text-gray-300">
        Their algorithm requires committing to a vector of length
        <span class="math">d \log n</span> that contains for each
        <span class="math">i \in [d]</span>,
        <span class="math">j \in [\log n]</span> the value
        <span class="math">(x - t_i)^&#123;2^j&#125;</span> for a
        random verifier challenge
        <span class="math">x \in \mathbb&#123;F&#125;</span>.
        They also commit to the binary decomposition of the
        <span class="math">\&#123;e_i\&#125;</span>, and using the
        two, prove that
        <span class="math">F</span> is of the desired form.
      </p>

      <p class="text-gray-300">
        We present here an arguably simpler protocol for the same
        problem, that doesn&rsquo;t require explicitly representing
        the multiplicities. Let us use the notation
        <span class="math">f \subset t</span> as shorthand for
        <span class="math">\&#123;f_i\&#125;_&#123;i \in [n]&#125; \subset \&#123;t_i\&#125;_&#123;i \in [d]&#125;</span>.
      </p>

      <p class="text-gray-300">
        The idea is to look at a sorted version
        <span class="math">\&#123;s_i\&#125;</span> of the values
        <span class="math">\&#123;f_i\&#125;</span>, and compare the
        set of non-zero differences in
        <span class="math">\&#123;s_i\&#125;</span> and
        <span class="math">\&#123;t_i\&#125;</span>.
        Note that if
        <span class="math">f \subset t</span>, and every element of
        <span class="math">t</span> appears at least once in
        <span class="math">f</span>, we indeed have that these sets
        of differences are the same. However, the converse is not
        true: We can create a sequence of values
        <span class="math">\&#123;s_i\&#125;</span> having the same
        difference set as
        <span class="math">\&#123;t_i\&#125;</span>, but with the
        differences appearing in different order; and in this case
        we won&rsquo;t have
        <span class="math">s \subset t</span>.
        As an illustrating example, take
      </p>

      <div class="math-block">
        t = \&#123;1, 4, 8\&#125;, \quad
        s = \&#123;1, 1, 4, 8, 8, 8\&#125;, \quad
        s' = \&#123;1, 5, 5, 5, 8, 8\&#125;
      </div>

      <p class="text-gray-300">
        All three sets have the same difference set
        <span class="math">\&#123;3, 4\&#125;</span>; but since
        those differences appear in different order in
        <span class="math">s'</span> and
        <span class="math">t</span>, we don&rsquo;t have
        <span class="math">s' \subset t</span>.
        Though not an issue in the above examples, we also
        didn&rsquo;t address checking the starting point is the same
        in <span class="math">s</span> and
        <span class="math">t</span>. Both issues can be solved by
        comparing randomized difference sets: We choose random
        <span class="math">\beta \in \mathbb&#123;F&#125;</span>,
        and compare the elements in the sequences
        <span class="math">\&#123;t_i + \beta t_&#123;i+1&#125;\&#125;_&#123;i \in [d-1]&#125;</span>,
        <span class="math">\&#123;s_i + \beta s_&#123;i+1&#125;\&#125;_&#123;i \in [n-1]&#125;</span>.
      </p>

      <p class="text-gray-300">
        Seemingly, we have taken &ldquo;one step forward and one
        back&rdquo; by adding the random
        <span class="math">\beta</span>, as now pairs
        <span class="math">(s_i, s_&#123;i+1&#125;)</span> with
        <span class="math">s_i = s_&#123;i+1&#125;</span> will give
        a non-zero contribution
        <span class="math">s_i + \beta \cdot s_&#123;i+1&#125; = (1 + \beta) \cdot s_i</span>.
        However, all elements corresponding to a repetition are now
        multiples of
        <span class="math">(1 + \beta)</span> and we are able to use
        this to &ldquo;identify&rdquo; them and not use them in the
        comparison with the table. Specifically, we show that this
        check can be done correctly and efficiently using a
        &ldquo;grand product argument&rdquo; similar to the one used
        in [GWC19]&rsquo;s permutation argument.
      </p>

      <p class="text-gray-300">
        A technicality is that as mentioned this approach assumes all
        of <span class="math">t</span>&rsquo;s values appear at
        least once in <span class="math">f</span>; which is one
        reason we in fact take <span class="math">s</span> to be the
        sorted version of the concatenation of
        <span class="math">f</span> and
        <span class="math">t</span>. This ends up also helping to
        batch both checks into one product: The check that
        <span class="math">f \subset s</span>, and the check that
        <span class="math">s \subset t</span>.
      </p>

      <p class="text-gray-300">
        Precise details of the scheme are given in Section
        <a href="#sec-3" class="text-blue-400 hover:text-blue-300">
          3</a>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. PRELIMINARIES                                             -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">2. Preliminaries</h2>

      <p class="text-gray-300">
        <strong>Terminology.</strong> For integer
        <span class="math">d</span>, we denote by
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>
        the set of univariate polynomials over
        <span class="math">\mathbb&#123;F&#125;</span> of degree
        smaller than <span class="math">d</span>.
      </p>

      <p class="text-gray-300">
        <strong>Polynomial Protocols.</strong> We use the ranged
        polynomial protocol terminology from [GWC19] to describe our
        protocols. We repeat the definition for reference.
      </p>

      <p class="text-gray-300">
        In such a protocol a prover
        <span class="math">\mathbf&#123;P&#125;</span> sends
        polynomials of a certain degree bound
        <span class="math">d</span> to an ideal party
        <span class="math">\mathcal&#123;I&#125;</span>, and at the
        end of protocol, the verifier can ask whether certain
        identities hold between the polynomials sent during the
        protocol, the input polynomials, and the preprocessed
        polynomials, on a predefined set
        <span class="math">H</span>.
      </p>

      <p class="text-gray-300">
        More precisely,
      </p>

      <div class="formal-block formal-block-definition">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-blue-400">
            Definition 2.1
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-3">
          Fix positive integers
          <span class="math">d, D, t, \ell</span> and
          <span class="math">H \subset \mathbb&#123;F&#125;</span>.
          An <span class="math">H</span>-ranged
          <span class="math">(d, D, t, \ell)</span>-polynomial
          protocol is a multiround protocol between a prover
          <span class="math">\mathbf&#123;P&#125;</span>, verifier
          <span class="math">\mathbf&#123;V&#125;</span> and trusted
          party
          <span class="math">\mathcal&#123;I&#125;</span> that
          proceeds as follows.
        </p>
        <ol class="list-decimal list-inside text-sm text-gray-300
          ml-4 space-y-2">
          <li>
            The protocol definition includes a set of preprocessed
            and input polynomials
            <span class="math">g_1, \ldots, g_\ell \in \mathbb&#123;F&#125;_&#123;\leq d&#125;[X]</span>.
          </li>
          <li>
            The messages of
            <span class="math">\mathbf&#123;P&#125;</span> are sent
            to
            <span class="math">\mathcal&#123;I&#125;</span> and are
            of the form <span class="math">f</span> for
            <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>.
            If
            <span class="math">\mathbf&#123;P&#125;</span> sends a
            message not of this form, the protocol is aborted.
          </li>
          <li>
            The messages of
            <span class="math">\mathbf&#123;V&#125;</span> to
            <span class="math">\mathbf&#123;P&#125;</span> are
            arbitrary (but we will concentrate on public coin
            protocols where the messages are simply random coins).
          </li>
          <li>
            At the end of the protocol, suppose
            <span class="math">f_1, \ldots, f_t</span> are the
            polynomials that were sent from
            <span class="math">\mathbf&#123;P&#125;</span> to
            <span class="math">\mathcal&#123;I&#125;</span>.
            <span class="math">\mathbf&#123;V&#125;</span> may ask
            <span class="math">\mathcal&#123;I&#125;</span> if
            certain polynomial identities hold on
            <span class="math">H</span> between
            <span class="math">\&#123;f_1, \ldots, f_t, g_1, \ldots, g_\ell\&#125;</span>.
            Where each identity is of the form
            <div class="math-block">
              F(X) := G(X, h_1(v_1(X)), \dots, h_M(v_M(X)))
              \equiv 0,
            </div>
            for some
            <span class="math">h_i \in \&#123;f_1, \ldots, f_t, g_1, \ldots, g_\ell\&#125;</span>,
            <span class="math">G \in \mathbb&#123;F&#125;[X, X_1, \ldots, X_M]</span>,
            <span class="math">v_1, \ldots, v_M \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>
            such that
            <span class="math">F \in \mathbb&#123;F&#125;_&#123;&lt; D&#125;[X]</span>
            for every choice of
            <span class="math">f_1, \ldots, f_t</span> made by
            <span class="math">\mathbf&#123;P&#125;</span> when
            following the protocol correctly.
          </li>
          <li>
            After receiving the answers from
            <span class="math">\mathcal&#123;I&#125;</span>
            regarding the identities,
            <span class="math">\mathbf&#123;V&#125;</span> outputs
            <em>acc</em> if all identities hold, and outputs
            <em>rej</em> otherwise.
          </li>
        </ol>
      </div>

      <p class="text-gray-300">
        It is shown in Section 4 of [GWC19] how such a protocol can
        be compiled into one in the algebraic group model using the
        polynomial commitment scheme of [KZG10].
      </p>

      <p class="text-gray-300">
        For such a protocol
        <span class="math">\mathscr&#123;P&#125;</span>, let
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;)</span>
        be the maximum over
        <span class="math">f_1, \ldots, f_t</span> sent by an
        honest prover during protocol execution of
        <span class="math">\left(\sum_&#123;i \in [t]&#125; \deg(f_i) + 1\right) + D - |H|</span>.
      </p>

      <p class="text-gray-300">
        The prover complexity ends up being closely tied to
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;)</span>
        as this corresponds to the number of group operations to
        commit to all polynomials (including the quotient polynomial
        that comes up in translating a ranged polynomial protocol to
        a polynomial protocol) using [KZG10]. We will thus attempt
        to minimize
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;)</span>
        in our protocols.
      </p>

      <p class="text-gray-300">
        <strong>Lagrange bases and multiplicative subgroups.</strong>
        In our protocols, we take <span class="math">H</span> to be
        a multiplicative subgroup of some order
        <span class="math">N</span> with generator
        <span class="math">\mathbf&#123;g&#125;</span>. For
        <span class="math">i \in [N]</span>, we denote by
        <span class="math">L_i \in \mathbb&#123;F&#125;_&#123;&lt; N&#125;[X]</span>
        the <span class="math">i</span>&rsquo;th Lagrange polynomial
        for <span class="math">H</span>, that satisfies
        <span class="math">L_i(\mathbf&#123;g&#125;^i) = 1</span>
        and
        <span class="math">L_i(\mathbf&#123;g&#125;^j) = 0</span>
        for <span class="math">j \neq i</span>. These polynomials
        are convenient when specifying a point check in an
        <span class="math">H</span>-ranged protocol. For example,
        requiring
        <span class="math">L_i(\mathbf&#123;x&#125;)f(\mathbf&#123;x&#125;) = 0</span>
        for all
        <span class="math">\mathbf&#123;x&#125; \in H</span> is
        equivalent to
        <span class="math">f(\mathbf&#123;g&#125;^i) = 0</span>.
      </p>

      <p class="text-gray-300">
        The generator
        <span class="math">\mathbf&#123;g&#125;</span> is convenient
        for specifying constraints on &ldquo;neighboring
        values&rdquo;. For example, the constraint
        <span class="math">f(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;) - f(\mathbf&#123;x&#125;) = 1</span>
        means that <span class="math">f</span>&rsquo;s value grows
        by one when going to the &ldquo;next&rdquo; point.
      </p>

      <p class="text-gray-300">
        We refer the reader to Section 4 of [GWC19] for more details.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 3. THE MAIN SCHEME                                           -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">3. The Main Scheme</h2>

      <p class="text-gray-300">
        <strong>Notation:</strong> Fix integers
        <span class="math">n, d</span> and vectors
        <span class="math">f \in \mathbb&#123;F&#125;^n</span>,
        <span class="math">t \in \mathbb&#123;F&#125;^d</span>.
        We use the notation
        <span class="math">f \subset t</span> to mean
        <span class="math">\&#123;f_i\&#125;_&#123;i \in [n]&#125; \subset \&#123;t_i\&#125;_&#123;i \in [d]&#125;</span>.
        Let
        <span class="math">H = \&#123;\mathbf&#123;g&#125;, \dots, \mathbf&#123;g&#125;^&#123;n+1&#125; = 1\&#125;</span>
        be a multiplicative subgroup of order
        <span class="math">n+1</span> in
        <span class="math">\mathbb&#123;F&#125;</span>.
        For a polynomial
        <span class="math">f \in \mathbb&#123;F&#125;[X]</span> and
        <span class="math">i \in [n+1]</span> we sometimes denote
        <span class="math">f_i := f(\mathbf&#123;g&#125;^i)</span>.
        For a vector
        <span class="math">f \in \mathbb&#123;F&#125;^n</span>, we
        also denote by <span class="math">f</span> the polynomial
        in
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt; n&#125;[X]</span>
        with
        <span class="math">f(\mathbf&#123;g&#125;^i) = f_i</span>.
      </p>

      <p class="text-gray-300">
        When <span class="math">f \subset t</span>, we say that
        <span class="math">f</span> is <em>sorted by
        <span class="math">t</span></em> when values appear in the
        same order in <span class="math">f</span> as they do in
        <span class="math">t</span>. Formally, for any
        <span class="math">i &lt; i' \in [n]</span> such that
        <span class="math">f_i \neq f_&#123;i'&#125;</span>, if
        <span class="math">j, j' \in [d]</span> are such that
        <span class="math">t_j = f_i</span>,
        <span class="math">t_&#123;j'&#125; = f_&#123;i'&#125;</span>
        then <span class="math">j &lt; j'</span>.
      </p>

      <p class="text-gray-300">
        Now, given
        <span class="math">t \in \mathbb&#123;F&#125;^d</span>,
        <span class="math">f \in \mathbb&#123;F&#125;^n</span>,
        <span class="math">s \in \mathbb&#123;F&#125;^&#123;n+d&#125;</span>,
        define bi-variate polynomials
        <span class="math">F, G</span> as
      </p>

      <div class="math-block">
        F(\beta, \gamma) := (1 + \beta)^n \cdot
        \prod_&#123;i \in [n]&#125; (\gamma + f_i)
        \prod_&#123;i \in [d-1]&#125;
        (\gamma(1 + \beta) + t_i + \beta t_&#123;i+1&#125;)
      </div>

      <div class="math-block">
        G(\beta, \gamma) := \prod_&#123;i \in [n+d-1]&#125;
        (\gamma(1+\beta) + s_i + \beta s_&#123;i+1&#125;)
      </div>

      <p class="text-gray-300">
        we have
      </p>

      <!-- Claim 3.1 -->

      <div class="formal-block formal-block-claim">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-cyan-400">
            Claim 3.1
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-3">
          <span class="math">F \equiv G</span> if and only if
        </p>
        <ol class="list-decimal list-inside text-sm text-gray-300
          ml-4 space-y-1">
          <li>
            <span class="math">f \subset t</span>, and
          </li>
          <li>
            <span class="math">s</span> is
            <span class="math">(f, t)</span> sorted by
            <span class="math">t</span>.
          </li>
        </ol>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> We write
        <span class="math">F, G</span> as elements of
        <span class="math">\mathbb&#123;F&#125;(\beta)[\gamma]</span>
        while taking out a
        <span class="math">(1 + \beta)</span> factor as follows.
      </p>

      <div class="math-block">
        F(\beta, \gamma) = (1 + \beta)^&#123;n+d-1&#125; \cdot
        \prod_&#123;i \in [n]&#125; (\gamma + f_i)
        \prod_&#123;i \in [d-1]&#125;
        \left(\gamma + \frac&#123;t_i + \beta t_&#123;i+1&#125;&#125;
        &#123;1 + \beta&#125;\right)
      </div>

      <div class="math-block">
        G(\beta, \gamma) = (1 + \beta)^&#123;n+d-1&#125;
        \prod_&#123;i \in [n+d-1]&#125;
        \left(\gamma + \frac&#123;s_i + \beta s_&#123;i+1&#125;&#125;
        &#123;1 + \beta&#125;\right)
      </div>

      <p class="text-gray-300">
        Suppose first that
        <span class="math">f \subset t</span> and
        <span class="math">s \in \mathbb&#123;F&#125;^&#123;n+d&#125;</span>
        is <span class="math">(f, t)</span> sorted by
        <span class="math">t</span>.
      </p>

      <p class="text-gray-300">
        Then for each
        <span class="math">j \in [d-1]</span>, there is a distinct
        index <span class="math">i \in [n+d-1]</span> such that
        <span class="math">(t_j, t_&#123;j+1&#125;) = (s_i, s_&#123;i+1&#125;)</span>.
        The corresponding factors in
        <span class="math">F, G</span> are equal. That is,
      </p>

      <div class="math-block">
        \left(\gamma + \frac&#123;t_i + \beta t_&#123;i+1&#125;&#125;
        &#123;1+\beta&#125;\right) \equiv
        \left(\gamma + \frac&#123;s_i + \beta s_&#123;i+1&#125;&#125;
        &#123;1+\beta&#125;\right)
      </div>

      <p class="text-gray-300">
        Let <span class="math">P' \subset [n+d-1]</span> the set of
        these <span class="math">d-1</span> indices
        <span class="math">i</span>, and let
        <span class="math">P := [n+d-1] \setminus P'</span>. The
        <span class="math">n</span> indices
        <span class="math">i \in P</span> are such that
        <span class="math">s_i = s_&#123;i+1&#125;</span>, and
        <span class="math">\&#123;s_i\&#125;_&#123;i \in P&#125;</span>
        equals
        <span class="math">\&#123;f_i\&#125;_&#123;i \in [n]&#125;</span>
        as multisets. That is, we have a one-to-one map
        <span class="math">j: P \to [n]</span> such that for each
        <span class="math">i \in P</span>,
        <span class="math">s_i = f_&#123;j(i)&#125;</span>.
        For each <span class="math">i \in P</span>, the
        corresponding factor of <span class="math">G</span> will be
      </p>

      <div class="math-block">
        \gamma + \frac&#123;s_i + \beta s_&#123;i+1&#125;&#125;
        &#123;1+\beta&#125; = \gamma + s_i,
      </div>

      <p class="text-gray-300">
        which equals the factor
        <span class="math">\gamma + f_&#123;j(i)&#125;</span> in
        <span class="math">F</span>.
      </p>

      <p class="text-gray-300">
        For the other direction, assume
        <span class="math">F \equiv G</span> as polynomials in
        <span class="math">\mathbb&#123;F&#125;[\beta, \gamma]</span>.
        Then <span class="math">F \equiv G</span> also as elements
        of
        <span class="math">\mathbb&#123;F&#125;(\beta)[\gamma]</span>.
        Since
        <span class="math">\mathbb&#123;F&#125;(\beta)[\gamma]</span>
        is a unique factorization domain, we know that the linear
        factors of <span class="math">F, G</span>, as written above
        must be equal. Thus, for each
        <span class="math">i \in [d-1]</span>,
        <span class="math">G</span> must have a factor equal to
        <span class="math">\left(\gamma + \frac&#123;t_i + \beta t_&#123;i+1&#125;&#125;&#123;1+\beta&#125;\right)</span>.
        In other words, for some
        <span class="math">j \in [n+d-1]</span>,
      </p>

      <div class="math-block">
        \gamma + \frac&#123;t_i + \beta t_&#123;i+1&#125;&#125;
        &#123;1+\beta&#125; =
        \gamma + \frac&#123;s_j + \beta s_&#123;j+1&#125;&#125;
        &#123;1+\beta&#125;,
      </div>

      <p class="text-gray-300">
        which implies
        <span class="math">t_i + \beta t_&#123;i+1&#125; = s_j + \beta s_&#123;j+1&#125;</span>,
        and therefore
        <span class="math">t_i = s_j</span>,
        <span class="math">t_&#123;i+1&#125; = s_&#123;j+1&#125;</span>.
        Call <span class="math">P' \subset [n+d-1]</span> the set of
        these <span class="math">d-1</span> indices
        <span class="math">j</span>. For any index
        <span class="math">j \in [n+d-1] \setminus P'</span>, there
        must be a factor &ldquo;coming from
        <span class="math">f</span>&rdquo; in
        <span class="math">F</span> that equals the corresponding
        factor in <span class="math">G</span>. More precisely, for
        such <span class="math">j</span> there exists
        <span class="math">i \in [n]</span> such that
      </p>

      <div class="math-block">
        \gamma + f_i =
        \gamma + \frac&#123;s_j + \beta s_&#123;j+1&#125;&#125;
        &#123;1+\beta&#125;,
      </div>

      <p class="text-gray-300">
        or equivalently
      </p>

      <div class="math-block">
        f_i + \beta f_i = s_j + \beta s_&#123;j+1&#125;
      </div>

      <p class="text-gray-300">
        which implies
        <span class="math">f_i = s_j = s_&#123;j+1&#125;</span>.
      </p>

      <p class="text-gray-300">
        Thus, we know that whenever consecutive values in
        <span class="math">s</span> are different, they are exactly
        equal to two consecutive values in
        <span class="math">t</span>, and all values of
        <span class="math">f</span> are values of
        <span class="math">t</span>.
        <span class="math">\square</span>
      </p>

      <p class="text-gray-300">
        Claim 3.1 motivates the following protocol. It will be
        convenient to assume
        <span class="math">d = n+1</span>. (If
        <span class="math">d \leq n</span> pad
        <span class="math">t</span> with
        <span class="math">n-d+1</span> repetitions of the last
        element.)
      </p>

      <p class="text-gray-300">
        <strong>Preprocessed polynomials:</strong> The polynomial
        <span class="math">t \in \mathbb&#123;F&#125;_&#123;\leq n+1&#125;[X]</span>
        describing the lookup values.
      </p>

      <p class="text-gray-300">
        <strong>Inputs:</strong>
        <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; n&#125;[X]</span>
      </p>

      <h3 class="text-xl font-semibold">Protocol</h3>

      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-3">
        <li>
          Let
          <span class="math">s \in \mathbb&#123;F&#125;^&#123;2n+1&#125;</span>
          be the vector that is
          <span class="math">(f,t)</span> sorted by
          <span class="math">t</span>. We represent
          <span class="math">s</span> by
          <span class="math">h_1, h_2 \in \mathbb&#123;F&#125;_&#123;&lt; n+1&#125;[X]</span>
          as follows.
          <span class="math">h_1(\mathbf&#123;g&#125;^i) = s_i</span>
          for <span class="math">i \in [n+1]</span>; and
          <span class="math">h_2(\mathbf&#123;g&#125;^i) = s_&#123;n+i&#125;</span>
          for each <span class="math">i \in [n+1]</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> computes
          the polynomials
          <span class="math">h_1, h_2</span> and sends them to the
          ideal party
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span> chooses
          random
          <span class="math">\beta, \gamma \in \mathbb&#123;F&#125;</span>
          and sends them to
          <span class="math">\mathbf&#123;P&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> computes a
          polynomial
          <span class="math">Z \in \mathbb&#123;F&#125;_&#123;\leq n+1&#125;[X]</span>
          that aggregates the value
          <span class="math">F(\beta, \gamma) / G(\beta, \gamma)</span>
          where <span class="math">F, G</span> are as described
          above. Specifically, we let

          <ol class="list-[lower-alpha] list-inside ml-6 mt-2
            space-y-2">
            <li>
              <span class="math">Z(\mathbf&#123;g&#125;) = 1</span>,
            </li>
            <li>
              For
              <span class="math">2 \leq i \leq n</span>:
              <div class="math-block">
                Z(\mathbf&#123;g&#125;^&#123;i&#125;) =
                \frac&#123;
                  (1+\beta)^&#123;i-1&#125;
                  \prod_&#123;j &lt; i&#125; (\gamma + f_&#123;j&#125;)
                  \cdot
                  \prod_&#123;1 \le j &lt; i&#125;
                  (\gamma(1+\beta) + t_&#123;j&#125;
                  + \beta t_&#123;j+1&#125;)
                &#125;&#123;
                  \prod_&#123;1 \le j &lt; i&#125;
                  (\gamma(1+\beta) + s_&#123;j&#125;
                  + \beta s_&#123;j+1&#125;)
                  (\gamma(1+\beta) + s_&#123;n+j&#125;
                  + \beta s_&#123;n+j+1&#125;)
                &#125;
              </div>
            </li>
            <li>
              <span class="math">Z(\mathbf&#123;g&#125;^&#123;n+1&#125;) = 1</span>.
            </li>
          </ol>
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> sends
          <span class="math">Z</span> to
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span> checks that
          <span class="math">Z</span> is indeed of the form
          described above, and that
          <span class="math">Z(\mathbf&#123;g&#125;^&#123;n+1&#125;) = 1</span>.
          More precisely,
          <span class="math">\mathbf&#123;V&#125;</span> checks the
          following identities for all
          <span class="math">\mathbf&#123;x&#125; \in H</span>.

          <ol class="list-[lower-alpha] list-inside ml-6 mt-2
            space-y-3">
            <li>
              <div class="math-block">
                L_1(\mathbf&#123;x&#125;)(Z(\mathbf&#123;x&#125;) - 1) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                (\mathbf&#123;x&#125; - \mathbf&#123;g&#125;^&#123;n+1&#125;)
                \, Z(\mathbf&#123;x&#125;) \, (1+\beta) \cdot
                (\gamma + f(\mathbf&#123;x&#125;))
                (\gamma (1+\beta) + t(\mathbf&#123;x&#125;)
                + \beta \, t(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;))
              </div>
              <div class="math-block">
                = (\mathbf&#123;x&#125; - \mathbf&#123;g&#125;^&#123;n+1&#125;)
                \, Z(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;)
                (\gamma (1+\beta) + h_1(\mathbf&#123;x&#125;)
                + \beta \, h_1(\mathbf&#123;g&#125; \cdot
                \mathbf&#123;x&#125;))
                (\gamma (1+\beta) + h_2(\mathbf&#123;x&#125;)
                + \beta \, h_2(\mathbf&#123;g&#125; \cdot
                \mathbf&#123;x&#125;))
              </div>
            </li>
            <li>
              <div class="math-block">
                L_&#123;n+1&#125;(\mathbf&#123;x&#125;)
                (h_1(\mathbf&#123;x&#125;) -
                h_2(\mathbf&#123;g&#125; \cdot
                \mathbf&#123;x&#125;)) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                L_&#123;n+1&#125;(\mathbf&#123;x&#125;)
                (Z(\mathbf&#123;x&#125;) - 1) = 0
              </div>
            </li>
          </ol>

          <p class="text-gray-300 mt-2">
            and outputs <em>acc</em> iff all checks hold.
          </p>
        </li>
      </ol>

      <!-- Lemma 3.2 -->

      <div class="formal-block formal-block-lemma">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-amber-400">
            Lemma 3.2
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-3">
          Suppose that
          <span class="math">\&#123;f(\mathbf&#123;g&#125;^i)\&#125;_&#123;i \in [n]&#125;</span>
          is not contained in
          <span class="math">\&#123;t(\mathbf&#123;g&#125;^i)\&#125;_&#123;i \in [n+1]&#125;</span>.
          Then for any strategy of
          <span class="math">\mathcal&#123;A&#125;</span> playing
          the role of
          <span class="math">\mathbf&#123;P&#125;</span> in the
          above protocol
          <span class="math">\mathscr&#123;P&#125;</span>, the
          probability that
          <span class="math">\mathbf&#123;V&#125;</span> accepts is
          <span class="math">\operatorname&#123;negl&#125;(\lambda)</span>.
          Furthermore, we have
          <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;) = 5n+4</span>.
        </p>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> We start by computing
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;)</span>.
        The prover sends
        <span class="math">h_1, h_2, Z \in \mathbb&#123;F&#125;_&#123;&lt; n+1&#125;[X]</span>,
        which aggregates to
        <span class="math">3n+3</span>. The second identity checked
        by the verifier is of the highest degree, containing a
        product of these three and the linear term
        <span class="math">X - \mathbf&#123;g&#125;^&#123;n+1&#125;</span>,
        which gives us another
        <span class="math">3n+2</span> from which we subtract
        <span class="math">|H| = n+1</span>. In total we get
        <span class="math">5n+4</span>.
      </p>

      <p class="text-gray-300">
        We proceed to prove correctness. The check in step 6c shows
        that
        <span class="math">h_1(\mathbf&#123;g&#125;^&#123;n+1&#125;) = h_2(\mathbf&#123;g&#125;)</span>,
        and thus <span class="math">h_1, h_2</span> indeed
        consistently describe a single vector
        <span class="math">s \in \mathbb&#123;F&#125;^&#123;2n+1&#125;</span>.
        Using Claim 3.1 we know that when
        <span class="math">f</span>&rsquo;s range is not contained
        in <span class="math">t</span>&rsquo;s for any choice of
        <span class="math">s</span> sent by
        <span class="math">\mathbf&#123;P&#125;</span> the
        polynomials
        <span class="math">F(X,Y), G(X,Y)</span> are different.
        From the Schwartz&ndash;Zippel lemma, except with
        probability
        <span class="math">\operatorname&#123;negl&#125;(\lambda)</span>,
        <span class="math">\mathbf&#123;V&#125;</span> chooses
        <span class="math">\beta, \gamma</span> such that
        <span class="math">F(\beta, \gamma) \neq G(\beta, \gamma)</span>.
        In this case we have
        <span class="math">Z(\mathbf&#123;g&#125;^&#123;n+1&#125;) \neq 1</span>
        which means
        <span class="math">\mathbf&#123;V&#125;</span> rejects.
        <span class="math">\square</span>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. GENERALIZING TO VECTOR LOOKUPS                            -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Generalizing to Vector Lookups and Multiple Tables
      </h2>

      <p class="text-gray-300">
        Suppose we have several witness polynomials
        <span class="math">f_1, \ldots, f_w \in \mathbb&#123;F&#125;_&#123;&lt; n&#125;[X]</span>,
        and a table of values
        <span class="math">t^* \in (\mathbb&#123;F&#125;^w)^d</span>.
        We wish to check that for each
        <span class="math">j \in [n]</span>,
        <span class="math">(f_1(\mathbf&#123;g&#125;^j), \ldots, f_w(\mathbf&#123;g&#125;^j)) \in t^*</span>.
        We can use randomization to efficiently reduce to the case
        of Section
        <a href="#sec-3" class="text-blue-400 hover:text-blue-300">
          3</a>.
      </p>

      <p class="text-gray-300">
        For each <span class="math">i \in [w]</span> we will include
        in the set of preprocessed polynomials
        <span class="math">t_i \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>
        with
        <span class="math">t_i(\mathbf&#123;g&#125;^j) = t_&#123;i,j&#125;^*</span>
        for each <span class="math">j \in [d]</span>.
      </p>

      <p class="text-gray-300">
        The verifier will choose random
        <span class="math">\alpha \in \mathbb&#123;F&#125;</span>.
      </p>

      <p class="text-gray-300">
        Then we will define
        <span class="math">t := \sum_&#123;i \in [w]&#125; \alpha^i t_i</span>,
        <span class="math">f := \sum_&#123;i \in [w]&#125; \alpha^i f_i</span>.
      </p>

      <p class="text-gray-300">
        Assume that for some
        <span class="math">j \in [n]</span>,
        <span class="math">(f_1(\mathbf&#123;g&#125;^j), \dots, f_w(\mathbf&#123;g&#125;^j)) \notin t^*</span>.
        Then except with probability
        <span class="math">d \cdot w / |\mathbb&#123;F&#125;|</span>,
        <span class="math">f(\mathbf&#123;g&#125;^j) \notin t</span>.
        Thus, after the selection of
        <span class="math">\alpha</span>, we can run the protocol of
        the previous section on
        <span class="math">f, t</span>.
      </p>

      <p class="text-gray-300">
        As alluded to in the introduction, a natural use case for
        this vector lookup primitive is a key-value setting, where we
        have a function <span class="math">f</span> with
        <span class="math">w-1</span> inputs, and wish to verify a
        vector is of the form
        <span class="math">(x_1, \ldots, x_&#123;w-1&#125;, f(x_1, \ldots, x_&#123;w-1&#125;))</span>
        for some input
        <span class="math">(x_1, \ldots, x_&#123;w-1&#125;)</span>.
      </p>

      <!-- 4.1 Multiple tables -->

      <h3 id="sec-4.1" class="text-xl font-semibold">
        4.1 Multiple Tables
      </h3>

      <p class="text-gray-300">
        Suppose further that we have in fact multiple tables
        <span class="math">t_1^*, \ldots, t_\ell^*</span> and for
        each <span class="math">i \in [n]</span> wish to check that
        for some predefined
        <span class="math">j = j(i) \in [\ell]</span>,
        <span class="math">(f_1(\mathbf&#123;g&#125;^i), \ldots, f_w(\mathbf&#123;g&#125;^i)) \in t_j^*</span>.
        We can reduce to the previous setting as follows. We create a
        preprocessed table containing
        <span class="math">t_1^*, \ldots, t_\ell^*</span> as
        sub-tables, by adding a column specifying the table index.
      </p>

      <p class="text-gray-300">
        That is, suppose for simplicity that for each
        <span class="math">j \in [\ell]</span>,
        <span class="math">t_j^* \in (\mathbb&#123;F&#125;^w)^&#123;d/\ell&#125;</span>.
        We construct
        <span class="math">t^* \in (\mathbb&#123;F&#125;^&#123;w+1&#125;)^d</span>,
        containing for each
        <span class="math">j \in [\ell]</span>,
        <span class="math">i \in [d/\ell]</span> the element
        <span class="math">(j, (t_j^*)_i)</span>.
        We preprocess a polynomial
        <span class="math">q \in \mathbb&#123;F&#125;_&#123;\leq n&#125;[X]</span>
        such that
        <span class="math">q_i = j(i)</span>, where again
        <span class="math">j(i)</span> is the subtable we wish the
        <span class="math">i</span>&rsquo;th value to be in. Now
        apply the method above to check that for each
        <span class="math">i \in [n]</span>,
        <span class="math">(q(\mathbf&#123;g&#125;^i), f_1(\mathbf&#123;g&#125;^i), \dots, f_w(\mathbf&#123;g&#125;^i)) \in t^*</span>.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. OPTIMIZED SOLUTION FOR CONTINUOUS RANGES                  -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. An Optimized Solution for Continuous Ranges
      </h2>

      <p class="text-gray-300">
        Suppose we wish to check that
        <span class="math">f \subset \&#123;0, \ldots, d-1\&#125;</span>
        for some integer
        <span class="math">d &lt; n</span>. We could use our above
        protocol while setting
        <span class="math">t_i = i - 1</span> for
        <span class="math">i \in [d]</span>. By using
        <span class="math">d = n+1</span>, the above protocol allows
        us to check
        <span class="math">f \subset \&#123;0, \ldots, n\&#125;</span>
        with complexity
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;) = 5n+4</span>
        as stated in Lemma 3.2. We present an alternative protocol
        with the same complexity that will allow us to check
        <span class="math">f \subset \&#123;0, \ldots, 2n-2\&#125;</span>.
        In fact, the protocol naturally generalizes for ranges
        <span class="math">\&#123;0, \ldots, c(n-1)\&#125;</span>
        while only increasing the degree of verifier constraints.
        Thus, one may choose a larger
        <span class="math">c</span> in protocols where the range
        proof is a subroutine, according to the maximal constraint
        degree in other parts of the protocol.
      </p>

      <p class="text-gray-300">
        The idea is the following. (We emphasize we are assuming the
        range is in fact contained in
        <span class="math">\mathbb&#123;F&#125;</span>, i.e.
        <span class="math">cn &lt; |\mathbb&#123;F&#125;|</span>.)
        Suppose that we enforce that the sorted witness
        <span class="math">s</span> starts from zero and ends at
        <span class="math">c \cdot (n-1)</span>, i.e.
        <span class="math">s_1 = 0</span>,
        <span class="math">s_&#123;2n+1&#125; = c \cdot (n-1)</span>,
        and that for each
        <span class="math">i \in [2n]</span>,
        <span class="math">s_&#123;i+1&#125; - s_i \leq c</span>.
        This suffices to deduce that
        <span class="math">s_i \in \&#123;0, \ldots, c(n-1)\&#125;</span>
        for each
        <span class="math">i \in [2n+1]</span>.
      </p>

      <p class="text-gray-300">
        The condition
        <span class="math">s_&#123;i+1&#125; - s_i \leq c</span>
        can be enforced by a constraint that plugs in this difference
        into the degree
        <span class="math">c+1</span> polynomial that vanishes on
        <span class="math">\&#123;0, \ldots, c\&#125;</span>.
        Enforcing the increments this way obviates the need to look
        at a permutation between differences, and instead we can
        directly check a permutation between the values of
        <span class="math">(f, t)</span> and
        <span class="math">s</span>; where
        <span class="math">t</span> is the table of
        <span class="math">c</span>&rsquo;th multiples, i.e.
        <span class="math">t_i = c \cdot (i-1)</span> for
        <span class="math">i \in [n]</span>.
      </p>

      <p class="text-gray-300">
        We proceed to describe the protocol in detail. As in the
        first protocol, we assume <span class="math">H</span> is a
        multiplicative subgroup of order
        <span class="math">n+1</span> with generator
        <span class="math">\mathbf&#123;g&#125;</span>.
      </p>

      <p class="text-gray-300">
        The protocol is parameterized by a positive integer parameter
        <span class="math">c</span>. And we denote by
        <span class="math">P</span> the polynomial
        <span class="math">P(X) := \prod_&#123;i=0&#125;^&#123;c&#125; (X - i)</span>.
      </p>

      <p class="text-gray-300">
        <strong>Preprocessed polynomials:</strong> The polynomial
        <span class="math">t \in \mathbb&#123;F&#125;_&#123;\leq n&#125;[X]</span>
        with
        <span class="math">t_i = c \cdot (i-1)</span> for
        <span class="math">i \in [n]</span>.
      </p>

      <p class="text-gray-300">
        <strong>Inputs:</strong>
        <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; n&#125;[X]</span>
      </p>

      <h3 class="text-xl font-semibold">Protocol</h3>

      <ol class="list-decimal list-inside text-gray-300 ml-4
        space-y-3">
        <li>
          Let
          <span class="math">s \in \mathbb&#123;F&#125;^&#123;2n+1&#125;</span>
          be the vector that is
          <span class="math">(f,t)</span> sorted by
          <span class="math">t</span>. We represent
          <span class="math">s</span> by
          <span class="math">h_1, h_2 \in \mathbb&#123;F&#125;_&#123;&lt; n+1&#125;[X]</span>
          as follows.
          <span class="math">h_1(\mathbf&#123;g&#125;^i) = s_i</span>
          for <span class="math">i \in [n+1]</span>; and
          <span class="math">h_2(\mathbf&#123;g&#125;^i) = s_&#123;n+i&#125;</span>
          for each <span class="math">i \in [n]</span> and
          <span class="math">h_2(\mathbf&#123;g&#125;^&#123;n+1&#125;) = c(n-1)</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> computes
          the polynomials
          <span class="math">h_1, h_2</span> and sends them to the
          ideal party
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span> chooses
          random
          <span class="math">\gamma \in \mathbb&#123;F&#125;</span>
          and sends it to
          <span class="math">\mathbf&#123;P&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> computes a
          polynomial
          <span class="math">Z \in \mathbb&#123;F&#125;_&#123;&lt; n+1&#125;[X]</span>
          that aggregates the value
          <span class="math">F(\beta, \gamma) / G(\beta, \gamma)</span>
          where <span class="math">F, G</span> are as described
          above. Specifically, we let

          <ol class="list-[lower-alpha] list-inside ml-6 mt-2
            space-y-2">
            <li>
              <span class="math">Z(\mathbf&#123;g&#125;) = 1</span>,
            </li>
            <li>
              For
              <span class="math">2 &lt; i &lt; n</span>:
              <div class="math-block">
                Z(\mathbf&#123;g&#125;^i) =
                \frac&#123;
                  \prod_&#123;j &lt; i&#125; (\gamma + f_&#123;j&#125;)
                  \cdot
                  \prod_&#123;1 \le j &lt; i&#125;
                  (\gamma + t_&#123;j&#125;)
                &#125;&#123;
                  \prod_&#123;1 \le j &lt; i&#125;
                  (\gamma + s_&#123;j&#125;)
                  (\gamma + s_&#123;n+j&#125;)
                &#125;
              </div>
            </li>
            <li>
              <span class="math">Z(\mathbf&#123;g&#125;^&#123;n+1&#125;) = 1</span>.
            </li>
          </ol>
        </li>
        <li>
          <span class="math">\mathbf&#123;P&#125;</span> sends
          <span class="math">Z</span> to
          <span class="math">\mathcal&#123;I&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbf&#123;V&#125;</span> checks the
          following identities for all
          <span class="math">\mathbf&#123;x&#125; \in H</span>.

          <ol class="list-[lower-alpha] list-inside ml-6 mt-2
            space-y-3">
            <li>
              <div class="math-block">
                L_1(\mathbf&#123;x&#125;)(h_1(\mathbf&#123;x&#125;)) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                P(h_1(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;)
                - h_1(\mathbf&#123;x&#125;)) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                P(h_2(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;)
                - h_2(\mathbf&#123;x&#125;)) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                L_&#123;n+1&#125;(\mathbf&#123;x&#125;)
                (h_1(\mathbf&#123;x&#125;) -
                h_2(\mathbf&#123;g&#125; \cdot
                \mathbf&#123;x&#125;)) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                L_&#123;n+1&#125;(\mathbf&#123;x&#125;)
                (h_2(\mathbf&#123;x&#125;)) = c \cdot (n - 1)
              </div>
            </li>
            <li>
              <div class="math-block">
                L_1(\mathbf&#123;x&#125;)
                (Z(\mathbf&#123;x&#125;) - 1) = 0
              </div>
            </li>
            <li>
              <div class="math-block">
                (\mathbf&#123;x&#125; - \mathbf&#123;g&#125;^&#123;n+1&#125;)
                (Z(\mathbf&#123;x&#125;)
                (\gamma + f(\mathbf&#123;x&#125;))
                (\gamma + t(\mathbf&#123;x&#125;))
                = (\mathbf&#123;x&#125; -
                \mathbf&#123;g&#125;^&#123;n+1&#125;) \cdot
                Z(\mathbf&#123;g&#125; \cdot \mathbf&#123;x&#125;)
                (\gamma + h_1(\mathbf&#123;x&#125;))
                (\gamma + h_2(\mathbf&#123;x&#125;)))
              </div>
            </li>
            <li>
              <div class="math-block">
                L_&#123;n+1&#125;(\mathbf&#123;x&#125;)
                (Z(\mathbf&#123;x&#125;) - 1) \equiv 0
              </div>
            </li>
          </ol>

          <p class="text-gray-300 mt-2">
            and outputs <em>acc</em> iff all checks hold.
          </p>
        </li>
      </ol>

      <div class="formal-block formal-block-claim">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-cyan-400">
            Remark 5.1
          </span>
        </div>
        <p class="text-sm text-gray-300">
          Note that if we are in a situation where the sorted values
          of <span class="math">f</span> alone already have a
          consecutive gap of at most
          <span class="math">c</span>, we can use a simpler protocol
          showing a permutation between
          <span class="math">f</span> and
          <span class="math">s</span> without needing to use
          <span class="math">t</span>.
        </p>
      </div>

      <!-- Lemma 5.2 -->

      <div class="formal-block formal-block-lemma">
        <div class="flex items-start justify-between mb-2">
          <span class="text-sm font-bold text-amber-400">
            Lemma 5.2
          </span>
        </div>
        <p class="text-sm text-gray-300 mb-3">
          Fix positive integer <span class="math">c</span>. Suppose
          that
          <span class="math">\&#123;f(\mathbf&#123;g&#125;^i)\&#125;_&#123;i \in [n]&#125;</span>
          is not contained in
          <span class="math">\&#123;0, \ldots, c(n-1)\&#125;</span>.
          Then for any strategy of
          <span class="math">\mathcal&#123;A&#125;</span> playing
          the role of
          <span class="math">\mathbf&#123;P&#125;</span> in the
          above protocol
          <span class="math">\mathscr&#123;P&#125;</span>, the
          probability that
          <span class="math">\mathbf&#123;V&#125;</span> accepts is
          <span class="math">\operatorname&#123;negl&#125;(\lambda)</span>.
          Furthermore, for
          <span class="math">c \geq 2</span> we have
          <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;) = (3+c)n + 2</span>.
        </p>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> We compute
        <span class="math">\mathfrak&#123;d&#125;(\mathscr&#123;P&#125;)</span>:
        As in the previous protocol
        <span class="math">\mathbf&#123;P&#125;</span> sends
        <span class="math">Z, h_1, h_2 \in \mathbb&#123;F&#125;_&#123;&lt; n+1&#125;[X]</span>,
        which aggregates to
        <span class="math">3n+3</span>. Now, for
        <span class="math">c \geq 2</span> the highest degree
        constraints are the check
        <span class="math">P(h_1(\mathbf&#123;g&#125; \cdot X) - h_1(X)) \equiv 0</span>
        (and the same check for
        <span class="math">h_2</span>). Which gives degree
        <span class="math">(c+1) \cdot n</span> to which we add one
        and subtract
        <span class="math">|H| = n+1</span>; totalling in
        <span class="math">3n + 3 + (c+1) \cdot n - (n+1) = (3+c)n + 2</span>.
      </p>

      <p class="text-gray-300">
        Now for the main claim, assume that for some
        <span class="math">i \in [n]</span>,
        <span class="math">f_i \notin \&#123;0, \ldots, c(n-1)\&#125;</span>.
        The checks in steps 6a&ndash;6e imply that the values
        <span class="math">\&#123;h_1(\mathbf&#123;g&#125;^i), h_2(\mathbf&#123;g&#125;^i)\&#125;_&#123;i \in [n]&#125;</span>
        are all in the range
        <span class="math">\&#123;0, \ldots, c(n-1)\&#125;</span>.
        Define polynomials
      </p>

      <div class="math-block">
        F(X) := \prod_&#123;i \in [n]&#125;
        (X - f(\mathbf&#123;g&#125;^i))
        (X - t(\mathbf&#123;g&#125;^i)), \quad
        G(X) := \prod_&#123;i \in [n]&#125;
        (X - h_1(\mathbf&#123;g&#125;^i))
        (X - h_2(\mathbf&#123;g&#125;^i))
      </div>

      <p class="text-gray-300">
        Under the assumption that for some
        <span class="math">i \in [n]</span>,
        <span class="math">f_i \notin \&#123;0, \ldots, cn\&#125;</span>,
        we have that <span class="math">F</span> and
        <span class="math">G</span> are distinct polynomials.
      </p>

      <p class="text-gray-300">
        The checks in steps 6f&ndash;6h imply that
        <span class="math">F(\gamma) = G(\gamma)</span>.
      </p>

      <p class="text-gray-300">
        Since
        <span class="math">\gamma \in \mathbb&#123;F&#125;</span> is
        chosen uniformly it follows that
        <span class="math">\mathbf&#123;V&#125;</span> accepts with
        probability
        <span class="math">\operatorname&#123;negl&#125;(\lambda)</span>.
        <span class="math">\square</span>
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        We thank Jens Groth for introducing us to the lookup protocol
        of [BCG+]. We thank Kevaundray Wedderburn for
        comments and corrections and the name plookup.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-none space-y-3 text-sm text-gray-400">
        <li id="ref-AAB19">
          <span class="text-gray-500">[AAB+19]</span>
          A. Aly, T. Ashur, E. Ben-Sasson, S. Dhooghe, and
          A. Szepieniec.
          <em>Efficient symmetric primitives for advanced
          cryptographic protocols (A marvellous contribution).</em>
          IACR Cryptology ePrint Archive, 2019:426, 2019.
        </li>
        <li id="ref-ACG19">
          <span class="text-gray-500">[ACG+19]</span>
          M. R. Albrecht, C. Cid, L. Grassi, D. Khovratovich,
          R. L&uuml;ftenegger, C. Rechberger, and M. Schofnegger.
          <em>Algebraic cryptanalysis of STARK-friendly designs:
          Application to MARVELlous and MiMC.</em>
          In Advances in Cryptology &ndash; ASIACRYPT 2019, pages
          371&ndash;397, 2019.
        </li>
        <li id="ref-AGR16">
          <span class="text-gray-500">[AGR+16]</span>
          M. R. Albrecht, L. Grassi, C. Rechberger, A. Roy, and
          T. Tiessen.
          <em>MiMC: Efficient encryption and cryptographic hashing
          with minimal multiplicative complexity.</em>
          In Advances in Cryptology &ndash; ASIACRYPT 2016, pages
          191&ndash;219, 2016.
        </li>
        <li id="ref-BCG">
          <span class="text-gray-500">[BCG+]</span>
          J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen, and
          M. Maller.
          <em>Arya: Nearly linear-time zero-knowledge proofs for
          correct program execution.</em>
          In Advances in Cryptology &ndash; ASIACRYPT 2018,
          volume 11272 of Lecture Notes in Computer Science, pages
          595&ndash;626.
        </li>
        <li id="ref-BG12">
          <span class="text-gray-500">[BG12]</span>
          S. Bayer and J. Groth.
          <em>Efficient zero-knowledge argument for correctness of
          a shuffle.</em>
          In Advances in Cryptology &ndash; EUROCRYPT 2012, pages
          263&ndash;280, 2012.
        </li>
        <li id="ref-GKK19">
          <span class="text-gray-500">[GKK+19]</span>
          L. Grassi, D. Kales, D. Khovratovich, A. Roy,
          C. Rechberger, and M. Schofnegger.
          <em>Starkad and Poseidon: New hash functions for zero
          knowledge proof systems.</em>
          IACR Cryptology ePrint Archive, 2019:458, 2019.
          <a href="/papers/poseidon-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-GWC19">
          <span class="text-gray-500">[GWC19]</span>
          A. Gabizon, Z. J. Williamson, and O. Ciobotaru.
          <em>PLONK: Permutations over Lagrange-bases for
          oecumenical noninteractive arguments of knowledge.</em>
          IACR Cryptology ePrint Archive, 2019:953, 2019.
          <a href="/papers/plonk-2019" class="text-blue-400 hover:text-blue-300">[page on this site]</a>
        </li>
        <li id="ref-KZG10">
          <span class="text-gray-500">[KZG10]</span>
          A. Kate, G. M. Zaverucha, and I. Goldberg.
          <em>Constant-size commitments to polynomials and their
          applications.</em>
          Pages 177&ndash;194, 2010.
        </li>
      </ol>
    </section>
    <PaperHistory slug="plookup-2020" />
  </article>
</BaseLayout>
