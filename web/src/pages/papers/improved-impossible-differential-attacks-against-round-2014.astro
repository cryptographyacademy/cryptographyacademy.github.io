---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/279';
const CRAWLER = 'marker';
const CONVERTED_DATE = '2026-02-18';
const TITLE_HTML = 'Improved Impossible Differential Attacks against Round-Reduced LBlock';
const AUTHORS_HTML = 'Christina Boura&lt;sup&gt;1&lt;/sup&gt; , Marine Minier&lt;sup&gt;2&lt;/sup&gt; , Mar´ıa Naya-Plasencia&lt;sup&gt;3&lt;/sup&gt; , and Valentin Suder&lt;sup&gt;3&lt;/sup&gt;';

const CONTENT = `    <p class="text-gray-300">Christina Boura&lt;sup&gt;1&lt;/sup&gt; , Marine Minier&lt;sup&gt;2&lt;/sup&gt; , Mar´ıa Naya-Plasencia&lt;sup&gt;3&lt;/sup&gt; , and Valentin Suder&lt;sup&gt;3&lt;/sup&gt;</p>

    <blockquote class="border-l-4 border-gray-600 pl-4 my-4 text-gray-400 italic">
    <p class="text-gray-300">&lt;sup&gt;1&lt;/sup&gt; University of Versailles, France 2 INSA Lyon, France 3 Inria, France</p>

    </blockquote>

    <p class="text-gray-300">Abstract. Impossible differential attacks are among the most powerful forms of cryptanalysis against block ciphers. We present in this paper an in-depth complexity analysis of these attacks. We show an unified way to mount such attacks and provide generic formulas for estimating their time and data complexities. LBlock is a well studied lightweight block cipher with respect to impossible differential attacks. While previous single-key cryptanalysis reached up to 22 rounds, by applying our method we are able to break 23 rounds with time complexity 2 &lt;sup&gt;75&lt;/sup&gt;.&lt;sup&gt;36&lt;/sup&gt; and data complexity 2&lt;sup&gt;59&lt;/sup&gt;. Other time/data trade-offs are equally possible. This is to our knowledge the best (non-exhaustive search like) cryptanalysis of this function in the single-key model.</p>

    <p class="text-gray-300">Keywords. block ciphers, impossible differential attacks, LBlock.</p>

    <p class="text-gray-300">The differential attack introduced in [5] has shown to be one of the most powerful attacks against symmetric cryptosystems. Its main idea relies on exploiting differential paths that have a higher probability to occur than a differential path chosen at random. A variant of differential cryptanalysis is the impossible differential cryptanalysis, introduced independently by Knudsen [11] and by Biham et. al [4] and where one searches for differential paths that have probability zero to occur. In the concept of this attack, some rounds are added at the beginning and at the end of the impossible path, and if a trial key partially decrypts a given pair to the impossible differential, then this key certainly cannot be the right one and is thus rejected. The goal is to repeat this procedure in order to remove as many keys as possible and to reduce consequently the candidate key space.</p>

    <p class="text-gray-300">Impossible differential attacks have been extensively applied against many block ciphers and hash functions. Some examples are the 31-round attack against Skipjack [4], an application on the SHA-3 finalist Skein [3], attacks on reduced round Camellia [22, 13] and many more. These attacks seem to work particularly well for the case of Feistel ciphers, as the relatively slow diffusion of these schemes, permits the construction of long impossible differential paths. Due to the high technicality, the analysis of the time complexity and the necessary data is a point that is very often not treated in an optimal way, as for example in [9, 12, 2, 1].</p>

    <p class="text-gray-300">LBlock [21] is a lightweight block cipher designed by Wu and Zhang in 2011. It is an iterated construction that can be seen as a variant of a Feistel network. LBlock has received the attention of many researchers and has been the target of numerous analyses. The best known attack achieves 22 rounds using impossible differential cryptanalysis. In this paper we show how to reach 23 rounds by equally applying impossible differential attacks.</p>

    <p class="text-gray-300">The rest of the paper is organized as follows. Section 2 describes a general framework for impossible differential attacks and an analysis of their complexity. Section 3 describes LBlock and the detailed analysis of one of the attacks, while providing other possible trade-offs.</p>

    <p class="text-gray-300">In this section we provide a generic and optimized framework for mounting impossible differential attacks.</p>

    <p class="text-gray-300">The basic principle behind an impossible differential attack consists of two main steps. The first one relies on the discovery of an impossible differential path, while the second consists in adding</p>

    <p class="text-gray-300">input and output rounds that will be used for discarding some key candidates. We start our analysis by presenting the notations that will be used to describe our method.</p>

    <p class="text-gray-300">    <img src="_page_1_Figure_1.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">\\Delta_X</span> ,  <span class="math">\\Delta_Y</span> : input (resp. output) differences of the impossible differential path.</li>
      <li><span class="math">r_{\\Delta}</span> : number of rounds of the impossible differential path.</li>
      <li><span class="math">\\Delta_{in}</span> ,  <span class="math">\\Delta_{out}</span> : input (resp. output) truncated differences of the cipher.</li>
      <li><span class="math">r_{in}</span> : number of rounds of the differential path <span class="math">(\\Delta_X, \\Delta_{in})</span> .</li>
      <li><span class="math">r_{out}</span> : number of rounds of the differential path <span class="math">(\\Delta_Y, \\Delta_{out})</span> .</li>
    </ul>

    <p class="text-gray-300">The differential  <span class="math">(\\Delta_X \\to \\Delta_{in})</span>  (resp.  <span class="math">(\\Delta_Y \\to \\Delta_{out})</span> ) occurs with probability 1 while the differential  <span class="math">(\\Delta_{in} \\to \\Delta_X)</span>  (resp.  <span class="math">(\\Delta_{out} \\to \\Delta_Y)</span> ) is verified with probability  <span class="math">\\frac{1}{2^{c_{in}}}</span>  (resp.  <span class="math">\\frac{1}{2^{c_{out}}}</span> ), where  <span class="math">c_{in}</span>  (resp.  <span class="math">c_{out}</span> ) is the number of bit-conditions that have to be verified in order to obtain  <span class="math">\\Delta_X</span>  from  <span class="math">\\Delta_{in}</span>  (resp.  <span class="math">\\Delta_Y</span>  from  <span class="math">\\Delta_{out}</span> ).</p>

    <p class="text-gray-300">Before describing the scenario of the attack, we start by introducing the following definition.</p>

    <p class="text-gray-300">Information key bits. We will call information key bits of a set  <span class="math">k_j</span>  and denote by  <span class="math">|k_j|</span> , the minimal number of subkey bits (coming possibly from different subkeys of the cipher) that have to be determined in order to completely recover the set  <span class="math">k_j</span>  of all the subkey bits involved in an attack.</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">2.1 Scenario</h4>

    <p class="text-gray-300">Suppose that we deal with a permutation of size n parametrized by a key K of size |K|. The impossible differential attack on  <span class="math">(r_{in} + r_{\\Delta} + r_{out})</span>  rounds of this parametrized permutation can then be divided into three parts:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>First consider that the impossible differential path is placed between the rounds  <span class="math">(r_{in} + 1)</span>  and  <span class="math">(r_{in} + r_{\\Delta})</span> . This impossible differential path implies that it is not possible, from an input difference  <span class="math">\\Delta_X</span>  at round  <span class="math">(r_{in} + 1)</span> , to get to an output difference  <span class="math">\\Delta_Y</span>  at the end of round  <span class="math">(r_{in} + r_{\\Delta})</span> . The objective is then, for each given pair of inputs (or outputs), to discard the keys that would generate a difference  <span class="math">\\Delta_X</span>  at the beginning of round  <span class="math">(r_{in} + 1)</span>  and at the same time, a difference  <span class="math">\\Delta_Y</span>  at the output of round  <span class="math">(r_{in} + r_{\\Delta})</span> . We want to have enough pairs so that the number of non-discarded keys is significantly lower than the a priori total number of candidates.</li>
      <li>The first  <span class="math">r_{in}</span>  rounds have a truncated input difference in  <span class="math">\\Delta_{in}</span>  and an output difference  <span class="math">\\Delta_X</span> , which is the input of the impossible differential path. There are  <span class="math">c_{in}</span>  bit-conditions that need to be verified so that from  <span class="math">\\Delta_{in}</span>  we generate  <span class="math">\\Delta_X</span> , and  <span class="math">|k_{in}|</span>  information key bits intervening.</li>
      <li>The last  <span class="math">r_{out}</span>  rounds have a truncated output difference in  <span class="math">\\Delta_{out}</span>  and an input difference  <span class="math">\\Delta_Y</span> , which is the output of the impossible differential path. There are  <span class="math">c_{out}</span>  bit-conditions that need to be verified so that from  <span class="math">\\Delta_{out}</span>  we generate  <span class="math">\\Delta_Y</span>  in the backward direction, and  <span class="math">|k_{out}|</span>  information key bits intervening.</li>
    </ul>

    <p class="text-gray-300">The probability that, for a given key, a pair of inputs with differences  <span class="math">(\\Delta_{in}, \\Delta_{out})</span>  verifies all the bit-conditions is  <span class="math">2^{-(c_{in}+c_{out})}</span> . In other words, this is the probability that for a pair of inputs having a difference  <span class="math">\\Delta_{in}</span>  and an output difference  <span class="math">\\Delta_{out}</span> , a key from the possible key set is discarded. Then, we need an amount of input (or output) pairs N such that the probability for a trial key to be kept in the possible key set is as small as possible. This probability is equal to  <span class="math">P = (1 - 2^{-(c_{in}+c_{out})})^N</span> . If our goal is to be left at the end with only the correct key, then as we will try in total  <span class="math">2^{|k_{in}\\cup k_{out}|}</span>  keys, we should choose N such that</p>

    <p class="text-gray-300"><span class="math">$P = (1 - 2^{-(c_{in} + c_{out})})^N &lt; \\frac{1}{2^{|k_{in} \\cup k_{out}|}}.</span>$</p>

    <p class="text-gray-300">This approach for choosing N is the one generally used by default. In this work we propose a different approach, that can help reducing the number of pairs used in the attack and establishing better trade-offs between the data and the time complexity. More precisely, we permit smaller values of N. By proceeding like this, we will be probably left with more that one key in our candidate key set and we will need to proceed to an exhaustive search among the remaining candidates, but the total time complexity of the attack will be very probably lower. In practice, we will start with values of N such that  <span class="math">P &lt; \\frac{1}{2}</span>  so to reduce the exhaustive search by at least one bit. The smaller value of N verifying</p>

    <p class="text-gray-300"><span class="math">P = (1 - 2^{-(c_{in} + c_{out})})^N &lt; \\frac{1}{2}</span></p>

    <p class="text-gray-300">is approximately  <span class="math">N = 2^{c_{in} + c_{out}}</span> .</p>

    <p class="text-gray-300">The N pairs that we consider, following our definition, are pairs that verify the input and output truncated differentials. However, in most of the attacks, once one such pair has been obtained, we can also check, without the need to guess any key bits, if some conditions can be verified, or if there exists an impossibility. An example of such a situation is when the input and output differences to an active Sbox have already been fixed (case of LBlock), or when the key bits do not intervene in the first or last round conditions. We have not included in this generic analysis any of these additional sievings that could help reducing the number of needed pairs, while increasing the number of keys passing the conditions, as this is an issue difficult to treat in a generic way. However, as generalizing such attacks rests our main aim, we will show that it is actually easy to include this improvement in the cost of what we will call  <span class="math">C_{Key}</span> , which is the average cost, for a given pair among the N pairs, to test the candidate keys.</p>

    <p class="text-gray-300">We provide now a generic solution for determining the cost of obtaining such N pairs. To the best of our knowledge, this is the first known generic solution to this problem.</p>

    <h4 id="sec-2" class="text-lg font-semibold mt-6">2.2 Finding N pairs verifying a given truncated differential</h4>

    <p class="text-gray-300">From the limited birthday problem [7] (and slightly corrected here), we know that the cost of finding one pair verifying the input and output differences costs:</p>

    <p class="text-gray-300"><span class="math">$C_1 = \\max \\left\\{ \\min_{\\Delta \\in \\{\\Delta_{in}, \\Delta_{out}\\}} \\left\\{ \\sqrt{2^{n+1-|\\Delta|}} \\right\\}, 2^{n+1-(|\\Delta_{in}|+|\\Delta_{out}|)} \\right\\}.</span>$</p>

    <p class="text-gray-300">A direct way to treat the problem of determining the cost of finding N solutions would be to compute it as  <span class="math">N \\times C_1</span> . However, by computing the cost in this way we might be wasting some structures and therefore this solution is not optimal. We propose here for the first time, an optimal generic expression for the cost of obtaining N pairs verifying an input truncated difference in  <span class="math">\\Delta_{in}</span> and a truncated output difference in  <span class="math">\\Delta_{out}</span> . In practice, we are searching to determine the number of inputs, say  <span class="math">2^x</span> , that will be necessary to construct the N pairs.</p>

    <p class="text-gray-300">We distinguish two cases depending on the dimension of the input space,  <span class="math">|\\Delta_{in}|</span>  and of the output space,  <span class="math">|\\Delta_{out}|</span>  compared to the number of pairs N we need to construct:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>If  <span class="math">N \\leq \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{9^{n-|\\Delta_{out}|}}</span> , this means that  <span class="math">|\\Delta_{in}|</span>  is large enough to allow us to build  <span class="math">2^x</span>  inputs belonging to the same structure  <span class="math">(2^x \\leq 2^{|\\Delta_{in}|})</span> . Therefore  <span class="math">N = \\frac{2^x 2^{x-1}}{2^{n-|\\Delta_{out}|}}</span> , which means that we</li>
    </ul>

    <p class="text-gray-300">need  <span class="math">2^x = \\sqrt{N2^{n-|\\Delta_{out}|+1}}</span>  inputs. - Otherwise, if  <span class="math">N &gt; \\frac{2^{|\\Delta_{in}|}2^{|\\Delta_{in}|-1}}{2^{n-|\\Delta_{out}|}}</span>  which means that  <span class="math">|\\Delta_{in}|</span>  is not large enough, we will need to</p>

    <p class="text-gray-300">consider  <span class="math">2^y</span>  structures of size  <span class="math">2^{|\\Delta_{in}|}</span>  in a way that  <span class="math">N = 2^y \\frac{2^{|\\Delta_{in}|} 2^{|\\Delta_{in}|} - 1}{2^{n-|\\Delta_{out}|}}</span> . The number of inputs is in this case given by:</p>

    <p class="text-gray-300"><span class="math">2^{x} - 2^{y} 2^{|\\Delta_{in}|} - N 2^{n-|\\Delta_{out}|-|\\Delta_{in}|+1}</span></p>

    <p class="text-gray-300">By taking all of this into account together with the fact that we are dealing with a permutation (having thus a symmetry in both directions) and by considering the attacker to be able to chose the ciphertexts as well as the plaintexts, we can conclude that the cost of obtaining the N pairs will be:</p>

    <p class="text-gray-300"><span class="math">$C_N = \\max \\left\\{ \\min_{\\Delta \\in \\{\\Delta_{in}, \\Delta_{out}\\}} \\left\\{ \\sqrt{N2^{n+1-|\\Delta|}} \\right\\}, N2^{n+1-|\\Delta_{in}|-|\\Delta_{out}|} \\right\\}.</span>$
(1)</p>

    <p class="text-gray-300">This cost represents the amount of data needed for the attack. Obviously, as the size of the state is equal to n, we need that:</p>

    <p class="text-gray-300"><span class="math">$C_N \\leq 2^n</span>$
.</p>

    <p class="text-gray-300">These conditions are not verified in several cases from [2], which invalidates the corresponding attacks.</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.3 Time and memory complexity</h3>

    <p class="text-gray-300">We are going to detail now the computation of the time complexity of the attack. For this, we will need to briefly recall the attack procedure.</p>

    <p class="text-gray-300">By following the early abort technique [14], the attack consists in storing the N pairs and testing out step by step the key candidates, by reducing at each time the size of the remaining possible pairs.</p>

    <p class="text-gray-300">The complexity is then determined by 1) the cost of obtaining N pairs, 2) the number of pairs to test multiplied by the average cost of testing the candidate keys per pair and 3) the cost of testing the remaining key candidates and recovering the whole key. From this and by taking into account the cost of one encryption (CE) as well as the relative cost of partial encryption for the key guessing phase (CE&lt;sup&gt;0&lt;/sup&gt; ) we conclude that the time complexity of the attack is</p>

    <p class="text-gray-300"><span class="math">$T_{comp} = \\left(C_N + N(C_{Key}C_{E&#x27;} + 1) + 2^{|K|}P\\right)C_E,\\tag{2}</span>$</p>

    <p class="text-gray-300">where the last term is a simplification of 2&lt;sup&gt;|&lt;/sup&gt;K|−|kin∪kout&lt;sup&gt;|&lt;/sup&gt;P2 |kin∪kout| . Obviously, as we want the attack complexity to be smaller than the exhaustive search complexity, the above quantity should be smaller than 2&lt;sup&gt;|&lt;/sup&gt;K&lt;sup&gt;|&lt;/sup&gt;CE.</p>

    <p class="text-gray-300">It must be noted here that the value of Ckey depends on the cipher structure and its computation is a delicate task that closely depends on the attack parameters. For this reason it can only be computed once all parameters are known. Therefore, in order to be able to compute the time complexity of the attack in an automated way, we will provide a tight approximation of Ckey by |kin∪kout| 2 cin+cout . In most of the cases, as in the examples of the applications that we will detail in the following sections, this expression is a very tight upper bound of Ckey. In the same way, the precise computation of CE&lt;sup&gt;0&lt;/sup&gt; (that is always smaller than 1) can only be done once the attack parameters are known. So for automating the procedure, we can approximate the time complexity of the attack by</p>

    <p class="text-gray-300"><span class="math">$T&#x27;_{comp} = \\left(C_N + N\\left(\\frac{2^{|k_{in} \\cup k_{out}|}}{2^{c_{in} + c_{out}}}C_{E&#x27;} + 1\\right) + 2^{|K|}P\\right)C_E.</span>$
(3)</p>

    <p class="text-gray-300">Due to the additional free sieving of the first and last rounds pointed out at the end of Section 2.1, we note that Formula (3) is a very tight upper bound of Formula (2).</p>

    <p class="text-gray-300">By using the early abort technique [14], the only elements that need to be stored are the N pairs. Therefore, the memory complexity of the attack is determined by storing N &lt;sup&gt;4&lt;/sup&gt; .</p>

    <p class="text-gray-300">LBlock is a lightweight block cipher designed by Wu and Zhang in 2011 [21]. It is an iterated construction that can be seen as a variant of a Feistel network. The total number of iterations is equal to 32. The cipher operates on a 64-bit state and encrypts messages by using a 80-bit key.</p>

    <p class="text-gray-300">We start by providing a short description of the algorithm specifications. For a more complete description one can refer to [21].</p>

    <p class="text-gray-300">&lt;sup&gt;4&lt;/sup&gt; If N &gt; 2 &lt;sup&gt;|&lt;/sup&gt;kin∪kout&lt;sup&gt;|&lt;/sup&gt; we could store the discarded key candidates instead, but in practice this is rarely the case. We can though consider a memory complexity of min{N, 2 |kin∪kout| }.</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">3.1 Description of LBlock</h4>

    <p class="text-gray-300">Encryption algorithm. Denote by  <span class="math">P = L_0|R_0</span>  a 64-bit plaintext, where  <span class="math">L_0</span>  and  <span class="math">R_0</span>  are 32-bit vectors. The encryption procedure is as follows.</p>

    <pre><code class="language-text">- For i = 1, 2, ..., 31 do

• R_i = L_{i-1}

• L_i = F(L_{i-1}, K_i) \\oplus (R_{i-1} \\ll 8).

- L_{32} = L_{31}

- R_{32} = F(L_{31}, K_{32}) \\oplus (R_{31} \\ll 8).

- Output the ciphertext C = L_{32}|R_{32}.
</code></pre>

    <p class="text-gray-300">Round function F. A round of LBlock is depicted in Figure 1. The round function F can be divided into three steps. First, the 32-bit subkey  <span class="math">K_i</span>  is added to  <span class="math">L_{i-1}</span>  by a simple XOR. Then, a nonlinear layer applies to the result. This nonlinear layer consists of the application nibble by nibble of eight different 4-bit Sboxes  <span class="math">S_0, \\ldots, S_7</span> . The description of these Sboxes can be found in [21]. Finally, the resulting nibbles are permuted as seen in Figure 1.</p>

    <p class="text-gray-300">    <img src="_page_4_Picture_4.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 1. A round of LBlock</p>

    <p class="text-gray-300">The key schedule of LBlock can be found in Appendix A. Equally, a description of previous cryptanalysis results for this cipher is given in Appendix B.</p>

    <p class="text-gray-300">We are going to describe now an attack against 23 rounds of LBlock. To our knowledge, this is so far the best known attack against this cipher. We will equally present improved attacks of the ones published so far on 22 rounds.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">3.2 Impossible Differential Attack on 23 rounds of LBlock</h4>

    <p class="text-gray-300">We start by providing the parameters of the attack that we obtained by applying Algorithm 1 to LBlock. It has to be noted that these parameters are not the only ones that lead to a valid attack on 23-round LBlock. Several different configurations lead to attacks having a similar time complexity.</p>

    <p class="text-gray-300">The 14-round impossible differential path used for this attack is</p>

    <pre><code class="language-text">(00000000,0000\\alpha000) \\xrightarrow{14r} (00000\\beta00,00000000).
</code></pre>

    <p class="text-gray-300">This path is placed between the rounds 5 and 19 of the cipher. It is different from both paths used to attack 21 and 22 rounds of LBlock in [9] and can be visualized in Appendix C.</p>

    <p class="text-gray-300">We were able then to extend this impossible differential path adding  <span class="math">r_{in} = 5</span>  rounds to the input and  <span class="math">r_{out} = 4</span>  rounds to the output and attack the first 23 rounds of the cipher. As can be seen in Figure 2, the number of input bit-conditions is  <span class="math">c_{in} = 4 \\times 11 = 44</span>  and the number of output bit-conditions  <span class="math">c_{out} = 4 \\times 7 = 28</span> . In the same way,  <span class="math">\\Delta_{in} = (*0 * 0 * * * 0, * * * * * * * * * 0)</span>  with  <span class="math">|\\Delta_{in}| = 12 \\times 4 = 48</span>  and  <span class="math">\\Delta_{out} = (* * 0 * * * 0, 0 * * 0000*)</span>  with  <span class="math">|\\Delta_{out}| = 8 \\times 4 = 32</span> .</p>

    <p class="text-gray-300">In the general case, estimating the size of  <span class="math">|k_{in} \\cup k_{out}|</span>  is a delicate task and different approaches can be used. A straightforward one is to express the key-bits involved with regard to a subkey of the cipher. However, this approach for LBlock results in a non-optimal approximation of the number of information key-bits. For this reason, we describe next an alternative method for evaluating  <span class="math">|k_{in} \\cup k_{out}|</span>  for our attack.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">Algorithm 1</h4>

    <pre><code class="language-text">Require: An impossible differential path (\\Delta_X \\nrightarrow \\Delta_Y).
Ensure: A set of solutions \\mathcal{L}_{sol} formed by the parameters (r_{in}, r_{out}, c_{in}, c_{out}, \\Delta_{in}, \\Delta_{out}, c_{out}, \\Delta_{in}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out}, c_{out},
                    |k_{in} \\cup k_{out}|, N, C_N, T&#x27;_{comp}) corresponding to a valid attack.
    1: for all possible r_{in} do
    2:
                               for all possible r_{out} do
    3:
                                            Determine |k_{in} \\cup k_{out}|, c_{in}, c_{out}, C_{E&#x27;}, \\Delta_{in} \\text{ and } \\Delta_{out}.
                                            N \\leftarrow 2^{c_{in} + \\dot{c}_{out}}.
    4:
                                            while C_N \\leq 2^n do
    5:
                                                        T_{comp}&#x27; \\leftarrow C_N + N(2^{|k_{in} \\cup k_{out}| - (c_{in} + c_{out})} C_{E&#x27;} + 1) + 2^{|K|} P.
    6:
                                                         if T_{comp}^{&#x27;} &lt; 2^{|K|}, then
    7:
    8:
                                                                     Add parameters to \\mathcal{L}_{sol}.
    9:
                                                         end if
10:
                                                         Increase N.
                                            end while
11:
                                end for
12.
13: end for
14: return L
</code></pre>

    <p class="text-gray-300">    <img src="_page_5_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 2. The initial rounds (on the left) and the final rounds (on the right). Different colors stand for the round that these key-bits intervene.</p>

    <p class="text-gray-300"><strong>Determining</strong>  <span class="math">|k_{in} \\cup k_{out}|</span>  We describe here a method to determine the information key-bits with respect to the key schedule of LBlock. This method helps at minimizing, for the case of LBlock, the total number of key-bits to guess, compared to just expressing  <span class="math">k_{in} \\cup k_{out}</span>  with respect to a subkey of the cipher. However, this technique, even if only applied to LBlock here, could be possibly adapted to ciphers having a similar key schedule, as it is for example the case of the block ciphers PRESENT [6] and MIBS [8].</p>

    <p class="text-gray-300">First, remark that due to LBlock's key schedule structure, the bits of the extended subkeys  <span class="math">K^i</span>  and  <span class="math">K^{i+1}</span>  are related by a rotation of 29 bits to the left. Indeed, if we know the value of a key-bit in</p>

    <p class="text-gray-300">a given position of  <span class="math">K^i</span> , then we equally know the value of the key-bit in this position rotated by 29 to the right of  <span class="math">K^{i+1}</span>  as long as this bit is not involved in an Sbox operation during the computation of  <span class="math">K^{i+1}</span>  from  <span class="math">K^i</span> .</p>

    <p class="text-gray-300">We visualize the key schedule of LBlock in the way depicted in Figure 3. In this figure, each</p>

    <p class="text-gray-300">    <img src="_page_6_Figure_2.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 3. Representation of LBlock's key schedule. Each line represents one different subkey with respect to the 80-bit master key.</p>

    <p class="text-gray-300">symbol of a row (square, triangle, diamond and cross) is a bit of  <span class="math">K^i</span> , i = 1, ..., 32. The least significant bit is represented by the rightmost symbol of each row. The 32 bits of each subkey  <span class="math">K_i</span>  are denoted by either a triangle, a square or a diamond. Squares and triangles determine the position of Sboxes  <span class="math">S_9</span>  (resp.  <span class="math">S_8</span> ) through the key schedule. The bold symbols stand for the subkey nibbles involved in our attack. In this representation, two bits in a given column are the same (up to a known constant addition) if there is no Sbox involved between them. We assume that if we want to know the value of the key bits at the output of an Sbox, we have to know all the input key bits to this Sbox.</p>

    <p class="text-gray-300">In order to correctly estimate the information key-bits of  <span class="math">k_{in} \\cup k_{out}</span>  and determine a good evaluation of  <span class="math">|k_{in} \\cup k_{out}|</span> , we will proceed as follows. The first step is to find the information key-bits of the key-bits involved in the first and the last rounds separately. This step can be done easily, as when considering only the first or the last rounds, nearly no Sbox is involved, and the key-bits at the same positions with respect to the master key have a one-to-one correspondence.</p>

    <p class="text-gray-300">We can express the information key-bits of both first rounds and last rounds with the help of one subkey in the first rounds and one subkey in the last rounds respectively that minimizes the number of bits involved. There are various possible equivalent choices for these subkeys. We will call block of information key-bits a set of consecutive bits of the subkey used for expressing the information key-bits of the first rounds (resp. the last rounds). As seen in Figure 3, with the parameters of our attack, there exist 3 such blocks in the first rounds (the yellow ones) and 5 blocks in the last rounds (the blue ones). For each block of the first rounds (resp. last rounds), we look for the number of information key-bits in the last rounds (resp. first rounds) that can be recovered. Then, we choose the configuration of blocks that lead to the smallest number of involved bits. However, some decisions have to be taken. More precisely, each time we meet an Sbox without knowing all the input bits, we can either guess the missing bits or drop the involved known bits. This choice depends on the key-bits involved that we want to recover.</p>

    <p class="text-gray-300">We will now apply this procedure to our attack. For instance, we can see in Figure 3 that from the first yellow block on the left (of size 57 bits), by guessing one more bit of  <span class="math">K^{11}</span>  and one more bit of  <span class="math">K^{12}</span> , we can express all but 2 key nibbles involved in the last rounds. We repeat the same approach for each combination of blocks in the forward and the backward direction. Finally, for the key nibbles involved, the configuration of blocks minimizing the number of bits to guess is depicted</p>

    <p class="text-gray-300">in Figure 3. A red path denotes the key-bits we can recover from a block of information key-bits in the first rounds (yellow blocks). Remark that sometimes it is not worth matching the information key-bits in the first and the last rounds, as it is the case for the nibbles on the right, i.e. it is less expensive to just guess both nibbles independently than to try to obtain a connection. Then the number of information key-bits we will need in our attack is evaluated block by block as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>57 bits from  <span class="math">K^1</span> , 1 bit from  <span class="math">K^{11}</span>  (at position 72) and 1 bit from  <span class="math">K^{12}</span>  (at position 79)</li>
      <li>1 nibble from  <span class="math">K^1</span> , 1 bit from  <span class="math">K^{14}</span>  (at position 75) and 1 bit from  <span class="math">K^{22}</span>  (at position 13)</li>
      <li>-1 nibble from  <span class="math">K^1</span></li>
      <li>-1 nibble from  <span class="math">K^{22}</span> .</li>
    </ul>

    <p class="text-gray-300">In this way, the number of information key-bits we obtain is 73.</p>

    <p class="text-gray-300"><strong>Determining</strong>  <span class="math">C_{Key}</span> . The issue now is to determine how much will it cost us to retrieve, for each one of the N pairs, the keys that must not be discarded. The average cost of this step is the parameter  <span class="math">C_{key}</span> .</p>

    <p class="text-gray-300">In [9], a gradual algorithm is proposed where the possibilities for the subkey bits are tested and discarded in order. Still, this method is quite expensive, having a cost of about  <span class="math">C_{key} = 2^{27}</span>  operations. Here, we propose a method for finding the key candidates that will have  <span class="math">C_{key} \\approx 2</span> . Figure 4 will be used in our explanation to determine which key-bits we are referring to at each step.</p>

    <p class="text-gray-300">    <img src="_page_7_Figure_8.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 4. Representation of the subkeys as used for determining  <span class="math">C_{key}</span> . Each line represents one different subkey with respect to the 80-bit master key. Different colors stand for the round that these key-bits intervene. Subkey-bits are denoted with letters to ease the explanation.</p>

    <p class="text-gray-300">Average probability of a differential transition. Our first action was to have a look at LBlock Sboxes difference tables. For the matter that occupies us, they are all equivalent. We counted the number of possible difference transitions, including the possibility of having zero difference. We have to do this as, amongst the N pairs recovered, we have forced the truncated difference, but we have not assured yet that all the nibbles in the truncated difference are actually active. There are 96 out of 256 possible transitions. That means that if we fix a difference in the input and a difference in the output of an Sbox, we have a probability of  <span class="math">96/256 \\approx 2^{-1.41}</span>  that this one is a valid transition through the Sbox. For each valid differential transition, we have on average  <span class="math">\\frac{15 \\cdot 16}{96} \\approx 2^{1.32}</span>  values that verify it.</p>

    <p class="text-gray-300">Preliminary sieving of pairs. A similar idea was exploited in [18], however we provide here a method with an optimized complexity. When obtaining one out of the N pairs with the wanted truncated differential, we can easily verify that the input and output differences of several active Sboxes from the first and the last round paths are already completely determined. This is the case for the 4 active Sboxes of round 1, the 2 out of the 3 active Sboxes in round 2, the 2 Sboxes of round 3, and the 3, 2, 1 and 1 active Sboxes of rounds 23, 22, 21 and 10 respectively. This means that all the pairs that have incompatible difference transitions in this 15 already determined ones, will never produce the impossible differential path, and it is not worth trying them.</p>

    <p class="text-gray-300">Therefore, we will only have  <span class="math">N \\cdot 2^{-1.41 \\cdot 15} = N \\cdot 2^{-21.22}</span>  remaining pairs to treat. For each of the already fixed valid transitions, we know that there exist, on average,  <span class="math">2^{1.32}</span>  values that make the transition possible.</p>

    <p class="text-gray-300">We show now how to perform, for each one of these remaining pairs, a step by step determination of the associated partial subkeys to discard or to retain.</p>

    <p class="text-gray-300">Step by step determination of remaining possible subkeys.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">For each one of the  <span class="math">N2^{-21.22}</span>  pairs, we guess the bits from Figure 4 denoted by a, b and c, that is  <span class="math">N2^{-21.22}2^{5.28}2^42^5 = N2^{-6.94}</span>  remaining sets of pairs and partial subkeys with some bits already determined. The bits with an a correspond to the 4 nibbles of the subkey that will directly intervene in the 4 active Sboxes of the first round. This is why we only have  <span class="math">2^{1.32 \\cdot 4} = 2^{5.28}</span>  possibilities for the 16 a-bits, while we have to completely guess the b- and the c-bits. With this, all the A-bits are determined.</p></li>
      <li><p class="text-gray-300">Each one of the two nibbles from the A-part in yellow have  <span class="math">2^{1.32}</span>  possible values, as they are directly involved in the active Sboxes of the 23rd round. But we have a probability of  <span class="math">2^{-7}</span>  of this values being correct, as the A-bits have already been determined in the previous step. Therefore, we have  <span class="math">N2^{-6.94}2^{1.32 \\cdot 2}2^{-7} = N2^{-11.3}</span>  remaining sets.</p></li>
      <li><p class="text-gray-300">We try next all the possibilities for the e-bits: we have  <span class="math">N2^{-11.3}2^3 = N2^{-8.3}</span>  remaining ones.</p></li>
      <li><p class="text-gray-300">We guess the possible values for the f-bits. As all the b-, c- and e-bits are already determined, we know the values and differences at the input of the three active Sboxes of round 2 but for the values of the subkey of round 2. Out of these three active Sboxes, we could already check for two of them, during the preliminary sieving, if their differences could be a valid transition. But this is not the case for the third one. For the two Sboxes with already correct differences, we have  <span class="math">2^{1.32}</span>  possible values per involved nibble in f. For the other Sbox there is a probability of  <span class="math">2^{-1.41}</span>  of having a valid transition, and when this is the case, we have  <span class="math">2^{1.32}</span>  possible values. This means that on average we will have  <span class="math">2^{-0.09}</span>  possible values for this nibble. We obtain  <span class="math">N2^{-8.3+1.32\\cdot 2-0.09} = N2^{-5.75}</span> . We also guess the g-bit, and obtain  <span class="math">N2^{-4.75}</span>  remaining sets. With this, all the B-bits are determined.</p></li>
      <li><p class="text-gray-300">From the <em>B</em>-bits, the yellow nibble that affects directly the third active Sbox of round 23 has been determined, but there only existed  <span class="math">2^{1.32}</span>  possible values for it, so we will only keep  <span class="math">N2^{-4.75+1.32-4} = N2^{-7.43}</span>  sets.</p></li>
      <li><p class="text-gray-300">We consider the  <span class="math">2^{1.32}</span>  possible values for the p-nibble and for the r-nibble. Next, we guess the h-bits. With them, all the subkey nibbles involved in the active Sbox of round 21 except of the o-bits, have been determined. As we had already checked that the difference transition was a correct one during the preliminary sieving, we have also determined the  <span class="math">2^{1.32}</span>  possible values for the nibble formed by the B- and o-bits, and they already have 3 bits determined by the upper part, so we will keep:  <span class="math">N2^{-7.43}2^{2\\cdot 1.32}2^42^{1.32}2^{-3} = N2^{-2.47}</span> . Note that the o-bit has also been determined.</p></li>
      <li><p class="text-gray-300">In a similar way, we only have  <span class="math">2^{1.32}</span>  possible values for the nibble with the <em>i</em>-bits:  <span class="math">N2^{-2.47+1.32} = N2^{-1.15}</span> .</p></li>
      <li><p class="text-gray-300">We guess the bit at position j, and with this we are able to determine both C-nibbles. Both these C-nibbles affect the same active Sbox at round 5, which is not one of the Sboxes used in the preliminary sieving. As everything involving this Sbox has been determined, we have a probability of  <span class="math">2^{-4}</span>  of verifying the 4-bit condition of the Sbox:  <span class="math">N2^{-4.15}</span> .</p></li>
      <li><p class="text-gray-300">Next, we guess the k-bits, for which we have  <span class="math">2^{1.32}</span>  possibilities. We also guess the 2 l-bits, and for which of them we have a condition on one bit at position m of being verified:  <span class="math">N2^{-4.15+1.32+2-1} = N2^{-1.83}</span> .</p></li>
      <li><p class="text-gray-300">We guess the four bits from n, and we verify the 1-bit conditions at o and at the left most h-bit. We have again  <span class="math">2^{-0.09}</span>  possibilities for q. We guess the bit t (2), which imposes conditions on 3 bits of q:  <span class="math">N2^{-1.83}2^{4-2}2^{-0.09}2^{1-3} = N2^{-1.92}</span> .</p></li>
      <li><p class="text-gray-300">We consider the  <span class="math">2^{1.32}</span>  possibilities for the s-nibble, obtaining finally  <span class="math">N2^{-0.6}</span>  combinations of (pair, partial subkey) as possible candidates.</p></li>
    </ul>

    <p class="text-gray-300">The complexity of the previous procedure, determines now  <span class="math">C_{key}</span> :</p>

    <p class="text-gray-300"><span class="math">$C_{key} = 2^{-6.94} + 2^{-11.3} + 2^{-8.3} + 2^{-5.75} + 2^{-7.43} + 2^{-2.47} + 2^{-1.15} + 2^{-4.15} + 2^{-1.83} + 2^{-1.92} + 2^{-0.6} = 1.92</span>$</p>

    <p class="text-gray-300">Complexity of the Attack We briefly recall in Figure 5 the parameters of our attack on 23 rounds.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(*0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">* 0 *</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">* * *</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0,*</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">* * *</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">* * *0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_X</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">(00000000,0000\\alpha000)</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_{out}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">(*</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* 0 *</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">* *</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">00,0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0**0</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">0000*)</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_Y</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">(00000\\beta00,00000000)</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Delta_{in} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Delta_{out} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r_{in}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r_{out}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">r_{\\Delta}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">c_{in}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">c_{out}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">C_{key}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ k_{in} \\cup k_{out} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">48</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">5</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">44</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1.92</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">73</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 5. Parameters of our impossible differential cryptanalysis of 23-round LBlock.</p>

    <p class="text-gray-300">Notice that in this attack, we approximate the relative cost of partial encryption for the key guessing phase as the ratio between the active Sboxes during the differentials and the total number of Sboxes during an encryption. Therefore,  <span class="math">C_{E&#x27;} = \\frac{36}{8 \\cdot 23} = 2^{0.65}</span> . The trade-offs between data, memory and time complexity for this attack can now be seen in the rightmost table of Figure 6.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">N</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">N</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Memory</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78.56}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{57}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{56}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78.58}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{57}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{57}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77.12}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{57}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{73}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77.22}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{73}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74.32}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">rounds</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75.36} \\mathrm{C_E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{71.53} \\mathrm{C_E}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{59}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75.49}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72.35}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{60}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{76}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{76.48}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{76}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{73.35}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77.48}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{77}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{74.35}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78.48}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78}</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{75.35}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{79}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{79.48}C_E</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{64}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{79}</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 6. Data-memory-time trade-offs for the attacks on 22 and 23 rounds of LBlock.</p>

    <h4 id="sec-7" class="text-lg font-semibold mt-6">3.3 Improvement of the Impossible Differential Cryptanalysis of 22-round LBlock</h4>

    <p class="text-gray-300">We give in this section the data, memory and time complexities that we obtained for an impossible differential attack on 22 rounds of LBlock. The parameters of our attack are depicted in Figure 7, while the obtained data, memory and time complexities can be found in the table on the left of Figure 6. It can be seen that our method can efficiently improve the complexities of the previous attack on 22-round LBlock, provided in [9] (see Table 1).</p>

    <p class="text-gray-300">Notice that, similarly to the previous section, we approximate the relative cost of partial encryption for the key guessing phase as the ratio between the active Sboxes during the differentials and the total number of active Sboxes during an encryption. Therefore,  <span class="math">C_{E&#x27;} = \\frac{36}{8 \\cdot 22} = \\frac{36}{176}</span> .</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Z</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_{in}</span></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">(***000</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">000,</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><em>0</em></th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">0 * &gt;</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">* * 0</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">) [.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">\\Delta_X</span> (</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">000000</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"><span class="math">00,0000\\alpha000</span></th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_{out}   (**0***00,0**0000*)  </span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">) [.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\Delta_Y</span> (</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">00000£</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">800,00000000</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Delta_{in} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ \\Delta_{out} $</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">$ k_{in} \\cup k_{out} $</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">32</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">4</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">14</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">28</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{28}{176}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\frac{2^{71}}{2^{56}}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">71</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Fig. 7. Parameters of our impossible differential cryptanalysis of 22-round LBlock.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">4 Conclusion</h4>

    <p class="text-gray-300">We have applied the generalized impossible differential attack to the lightweight block cipher LBlock. We have improved the complexity of the previously best known attack on 22 rounds, and we have provided for the first time, an attack on 23 out of the 32 total rounds of the cipher.</p>

    <h2 id="sec-9" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Abed, E. List, S. Lucks, and J. Wenzel. Differential and Linear Cryptanalysis of Reduced-Round Simon. Cryptology ePrint Archive, Report 2013/526, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. A. Alkhzaimi and M. M. Lauridsen. Cryptanalysis of the SIMON Family of Block Ciphers. Cryptology ePrint Archive, Report 2013/543, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J-P. Aumasson, Ç. Çalik, W. Meier, O. Özen, R. C.-W. Phan, and K. Varici. Improved Cryptanalysis of Skein. In <em>ASIACRYPT 2009</em>, volume 5912 of <em>LNCS</em>, pages 542–559. Springer, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E. Biham, A. Biryukov, and A. Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In <em>EUROCRYPT 1999</em>, volume 1592 of <em>LNCS</em>, pages 12–23. Springer, 1999.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>E. Biham and A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In <em>CRYPTO 1990</em>, volume 537 of <em>LNCS</em>, pages 2–21. Springer, 1990.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>A. Bogdanov, L. R. Knudsen, G. Leander, C. Paar, A. Poschmann, M. J. B. Robshaw, Y. Seurin, and C. Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. In <em>CHES 2007</em>, volume 4727 of <em>LNCS</em>, pages 450–466. Springer, 2007.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. Gilbert and T. Peyrin. Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In FSE 2010, volume 6147 of LNCS, pages 365–383. Springer, 2010.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Izadi, B. Sadeghiyan, S. S. Sadeghian, and H. Arabnezhad Khanooki. MIBS: A New Lightweight Block Cipher. In <em>CANS 2009</em>, volume 5888 of <em>LNCS</em>, pages 334–348. Springer, 2009.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Karakoç, H. Demirci, and A. E. Harmanci. Impossible Differential Cryptanalysis of Reduced-Round LBlock. In WISTP 2012, volume 7322 of LNCS, pages 179–188. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>F. Karakoç, H. Demirci, and A. E. Harmanci. Biclique cryptanalysis of LBlock and TWINE. <em>Inf. Process. Lett.</em>, 113(12):423–429, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>L. R. Knudsen. DEAL A 128-bit cipher. Technical Report, Department of Informatics, University of Bergen, Norway, 1998.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Liu, D. Gu, Z. Liu, and W. Li. Impossible Differential Attacks on Reduced-Round LBlock. In ISPEC 2012, volume 7232 of LNCS, pages 97–108. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Liu, L. Li, D. Gu, X. Wang, Z. Liu, J. Chen, and W. Li. New Observations on Impossible Differential Cryptanalysis of Reduced-Round Camellia. In <em>FSE 2012</em>, volume 7549 of <em>LNCS</em>, pages 90–109. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>J. Lu, J. Kim, N. Keller, and O. Dunkelman. Improving the Efficiency of Impossible Differential Cryptanalysis of Reduced Camellia and MISTY1. In <em>CT-RSA</em>, volume 4964 of <em>LNCS</em>, pages 370–386. Springer, 2008.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>M. Minier and M. Naya-Plasencia. A Related Key Impossible Differential Attack Against 22 Rounds of the Lightweight Block Cipher LBlock. <em>Inf. Process. Lett.</em>, 112(16):624–629, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Sasaki and L. Wang. Comprehensive Study of Integral Analysis on 22-Round LBlock. In <em>ICISC</em> 2012, volume 7839 of <em>LNCS</em>, pages 156–169. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>H. Soleimany and K. Nyberg. Zero-Correlation Linear Cryptanalysis of Reduced-Round LBlock. In <em>International Workshop on Coding and Cryptography-WCC 2013</em>, 2013.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>T. Suzaki, K. Minematsu, S. Morioka, and E. Kobayashi. TWINE: A Lightweight Block Cipher for Multiple Platforms. In <em>Selected Areas in Cryptography-SAC 2012</em>, volume 7707 of <em>LNCS</em>, pages 339–354. Springer, 2012.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Y. Wang, W. Wu, X. Yu, and L. Zhang. Security on LBlock against Biclique Cryptanalysis. In WISA 2012, volume 7690 of LNCS, pages 1–14. Springer, 2012.</li>
    </ol></li>
      <li><p class="text-gray-300">L. Wen, M. Wang, and J. Zhao. Related-Key Impossible Differential Attack on Reduced-Round LBlock. J. Comput. Sci. Technol., 29(1):165–176, 2014.</p></li>
      <li><p class="text-gray-300">W. Wu and L. Zhang. LBlock: A Lightweight Block Cipher. In ACNS 2011, volume 6715 of LNCS, pages 327–344. Springer, 2011.</p></li>
      <li><p class="text-gray-300">W. Wu, L. Zhang, and W. Zhang. Improved Impossible Differential Cryptanalysis of Reduced-Round Camellia. In Selected Areas in Cryptography-SAC 2009, volume 5381 of LNCS, pages 442–456. Springer, 2008.</p></li>
    </ul>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">A Key schedule of LBlock</h4>

    <p class="text-gray-300">Denote by K the master key of the encryption. We will call the generated vectors  <span class="math">K^i</span> , i = 1, ..., 32, extended subkeys. Then, the 32 subkeys  <span class="math">K_i</span> ,  <span class="math">1 \\le i \\le 32</span>  are derived from K as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">-K^{1} = K</span>   <span class="math">-K_{1} = K[79, ..., 48]</span>  For i = 2, ..., 32 do  <span class="math">\\bullet K^{i} = K^{i-1} \\ll 29</span>    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><span class="math">K^{i}[79, \\dots, 76] = S_{9}[K^{i}[79, \\dots, 76]]</span></li>
      <li><span class="math">K^{i}[75,...,70] = S_{9}[K^{i}[75,...,70]]</span></li>
      <li><span class="math">K^{i}[50,\\ldots,46]=K^{i}[50,\\ldots,46]\\oplus[i-1]_2</span> , where  <span class="math">[i-1]_2</span>  is the binary representation of i-1.</li>
      <li><span class="math">K_i = K^i[79, \\dots, 48]</span></li>
    </ul></li>
    </ul>

    <p class="text-gray-300">LBlock has received the attention of many researchers and it has been the target of numerous analyses. Different techniques, such as differential cryptanalysis, impossible differential cryptanalysis (in the single and related key models), integral and zero-correlation cryptanalysis have been applied to break reduced-round versions of the cipher [21, 12, 9, 15, 16, 19, 10, 17, 20]. The maximum number of rounds achieved by all these attacks in the single key is 22. The previous results concerning impossible differential crypanalysis of LBlock can be found in Table 1.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Model</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left"># rounds</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Time complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Data complexity</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Reference</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Single-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">20</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{72.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[21]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Single-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{73.7}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{62.5} CP</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[12]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Single-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">21</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{69.5}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{63} \\text{ CP}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[9]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Single-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{79.28}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{58}</span> CP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[9]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Related-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">22</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{70}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{47}</span> RKCP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[15]</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Related-key</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">23</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{78.3}</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2^{61.4}</span> RKCP</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">[20]</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1. Previous impossible differential cryptanalysis results on LBlock</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">C Impossible differential path for the 23-round of LBlock</h4>

    <p class="text-gray-300">We give here the impossible differential path that has been used to attack 23 rounds of LBlock. The green color stands for nibbles that have a truncated difference with probability 1 (active nibbles), while white symbolizes nibbles that do not have a difference (passive nibbles). Finally, we represent by grey the nibbles for which we do not know whether they are active or passive. This 14-round impossible differential path combines two paths of probability 1 for which an impossibility occurs after 7 rounds. The nibble for which the impossibility occurs is the fourth nibble from the left of  <span class="math">L_{12}</span> .</p>

    <p class="text-gray-300">    <img src="_page_12_Figure_0.jpeg" alt="" class="my-4 max-w-full" />
</p>

    <p class="text-gray-300">Fig. 8. 14-round impossible differential path used in the 23-round attack against LBlock.</p>

`;
---

<BaseLayout title="Improved Impossible Differential Attacks against Round-Reduc... (2014/279)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/279
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="improved-impossible-differential-attacks-against-round-2014" />
  </article>
</BaseLayout>
