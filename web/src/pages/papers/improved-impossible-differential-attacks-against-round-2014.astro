---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2014/279';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Improved Impossible Differential Attacks against Round-Reduced LBlock';
const AUTHORS_HTML = 'Christina Boura, Marine Minier, María Naya-Plasencia, Valentin Suder';

const CONTENT = `    <p class="text-gray-300">Christina Boura [11] Marine Minier [22] María Naya-Plasencia [32] Valentin Suder [32]</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Impossible differential attacks are among the most powerful forms of cryptanalysis against block ciphers. We present in this paper an in-depth complexity analysis of these attacks. We show an unified way to mount such attacks and provide generic formulas for estimating their time and data complexities. LBlock is a well studied lightweight block cipher with respect to impossible differential attacks. While previous single-key cryptanalysis reached up to 22 rounds, by applying our method we are able to break 23 rounds with time complexity <span class="math">2^{75.36}</span> and data complexity <span class="math">2^{59}</span>. Other time/data trade-offs are equally possible. This is to our knowledge the best (non-exhaustive search like) cryptanalysis of this function in the single-key model.</p>

    <p class="text-gray-300">Keywords block ciphers, impossible differential attacks, LBlock.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">The differential attack introduced in <em>[5]</em> has shown to be one of the most powerful attacks against symmetric cryptosystems. Its main idea relies on exploiting differential paths that have a higher probability to occur than a differential path chosen at random. A variant of differential cryptanalysis is the impossible differential cryptanalysis, introduced independently by Knudsen <em>[11]</em> and by Biham et. al <em>[4]</em> and where one searches for differential paths that have probability zero to occur. In the concept of this attack, some rounds are added at the beginning and at the end of the impossible path, and if a trial key partially decrypts a given pair to the impossible differential, then this key certainly cannot be the right one and is thus rejected. The goal is to repeat this procedure in order to remove as many keys as possible and to reduce consequently the candidate key space.</p>

    <p class="text-gray-300">Impossible differential attacks have been extensively applied against many block ciphers and hash functions. Some examples are the 31-round attack against Skipjack <em>[4]</em>, an application on the SHA-3 finalist Skein <em>[3]</em>, attacks on reduced round Camellia <em>[22, 13]</em> and many more. These attacks seem to work particularly well for the case of Feistel ciphers, as the relatively slow diffusion of these schemes, permits the construction of long impossible differential paths. Due to the high technicality, the analysis of the time complexity and the necessary data is a point that is very often not treated in an optimal way, as for example in <em>[9, 12, 2, 1]</em>.</p>

    <p class="text-gray-300">LBlock <em>[21]</em> is a lightweight block cipher designed by Wu and Zhang in 2011. It is an iterated construction that can be seen as a variant of a Feistel network. LBlock has received the attention of many researchers and has been the target of numerous analyses. The best known attack achieves 22 rounds using impossible differential cryptanalysis. In this paper we show how to reach 23 rounds by equally applying impossible differential attacks.</p>

    <p class="text-gray-300">The rest of the paper is organized as follows. Section 2 describes a general framework for impossible differential attacks and an analysis of their complexity. Section 3 describes LBlock and the detailed analysis of one of the attacks, while providing other possible trade-offs.</p>

    <h2 id="sec-4" class="text-2xl font-bold">2 Impossible Differential Attacks and Complexity analysis</h2>

    <p class="text-gray-300">In this section we provide a generic and optimized framework for mounting impossible differential attacks.</p>

    <p class="text-gray-300">The basic principle behind an impossible differential attack consists of two main steps. The first one relies on the discovery of an impossible differential path, while the second consists in adding</p>

    <p class="text-gray-300">input and output rounds that will be used for discarding some key candidates. We start our analysis by presenting the notations that will be used to describe our method.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\Delta_{X}</span> ,  <span class="math">\\Delta_{Y}</span> : input (resp. output) differences of the impossible differential path.</li>

      <li><span class="math">r_{\\Delta}</span> : number of rounds of the impossible differential path.</li>

      <li><span class="math">\\Delta_{in}</span> ,  <span class="math">\\Delta_{out}</span> : input (resp. output) truncated differences of the cipher.</li>

      <li><span class="math">r_{in}</span> : number of rounds of the differential path  <span class="math">(\\Delta_X, \\Delta_{in})</span> .</li>

      <li><span class="math">r_{out}</span> : number of rounds of the differential path  <span class="math">(\\Delta_Y, \\Delta_{out})</span> .</li>

    </ul>

    <p class="text-gray-300">The differential  <span class="math">(\\varDelta_X\\rightarrow\\varDelta_{in})</span>  (resp.  <span class="math">(\\varDelta_Y\\rightarrow\\varDelta_{out})</span> ) occurs with probability 1 while the differential  <span class="math">(\\varDelta_{in}\\rightarrow\\varDelta_X)</span>  (resp.  <span class="math">(\\varDelta_{out}\\rightarrow\\varDelta_Y)</span> ) is verified with probability  <span class="math">\\frac{1}{2^{c_{in}}}</span>  (resp.  <span class="math">\\frac{1}{2^{c_{out}}}</span> ), where  <span class="math">c_{in}</span>  (resp.  <span class="math">c_{out}</span> ) is the number of bit-conditions that have to be verified in order to obtain  <span class="math">\\varDelta_X</span>  from  <span class="math">\\varDelta_{in}</span>  (resp.  <span class="math">\\varDelta_Y</span>  from  <span class="math">\\varDelta_{out}</span> ).</p>

    <p class="text-gray-300">Before describing the scenario of the attack, we start by introducing the following definition.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Information key bits. We will call information key bits of a set  <span class="math">k_{j}</span>  and denote by  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{j}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> , the minimal number of subkey bits (coming possibly from different subkeys of the cipher) that have to be determined in order to completely recover the set  </span>k_{j}$  of all the subkey bits involved in an attack.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Suppose that we deal with a permutation of size  <span class="math">n</span>  parametrized by a key  <span class="math">K</span>  of size  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> . The impossible differential attack on  </span>(r_{in} + r_{\\Delta} + r_{out})$  rounds of this parametrized permutation can then be divided into three parts:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First consider that the impossible differential path is placed between the rounds  <span class="math">(r_{in} + 1)</span>  and  <span class="math">(r_{in} + r_{\\Delta})</span> . This impossible differential path implies that it is not possible, from an input difference  <span class="math">\\Delta_X</span>  at round  <span class="math">(r_{in} + 1)</span> , to get to an output difference  <span class="math">\\Delta_Y</span>  at the end of round  <span class="math">(r_{in} + r_{\\Delta})</span> . The objective is then, for each given pair of inputs (or outputs), to discard the keys that would generate a difference  <span class="math">\\Delta_X</span>  at the beginning of round  <span class="math">(r_{in} + 1)</span>  and at the same time, a difference  <span class="math">\\Delta_Y</span>  at the output of round  <span class="math">(r_{in} + r_{\\Delta})</span> . We want to have enough pairs so that the number of non-discarded keys is significantly lower than the a priori total number of candidates.</li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- The first  <span class="math">r_{in}</span>  rounds have a truncated input difference in  <span class="math">\\Delta_{in}</span>  and an output difference  <span class="math">\\Delta_X</span> , which is the input of the impossible differential path. There are  <span class="math">c_{in}</span>  bit-conditions that need to be verified so that from  <span class="math">\\Delta_{in}</span>  we generate  <span class="math">\\Delta_X</span> , and  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  information key bits intervening.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">The probability that, for a given key, a pair of inputs with differences  <span class="math">(\\Delta_{in}, \\Delta_{out})</span>  verifies all the bit-conditions is  <span class="math">2^{-(c_{in} + c_{out})}</span> . In other words, this is the probability that for a pair of inputs having a difference  <span class="math">\\Delta_{in}</span>  and an output difference  <span class="math">\\Delta_{out}</span> , a key from the possible key set is discarded. Then, we need an amount of input (or output) pairs  <span class="math">N</span>  such that the probability for a trial key to be kept in the possible key set is as small as possible. This probability is equal to  <span class="math">P = (1 - 2^{-(c_{in} + c_{out})})^N</span> . If our goal is to be left at the end with only the correct key, then as we will try in total  $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">  keys, we should choose  </span>N$  such that</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P = (1 - 2 ^ {- (c _ {i n} + c _ {o u t})}) ^ {N} &lt;   \\frac {1}{2 ^ {</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k _ {i n} \\cup k _ {o u t}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="my-4 text-center"><span class="math-block"></span></div>

    <p class="text-gray-300">This approach for choosing <span class="math">N</span> is the one generally used by default. In this work we propose a different approach, that can help reducing the number of pairs used in the attack and establishing better trade-offs between the data and the time complexity. More precisely, we permit smaller values of <span class="math">N</span>. By proceeding like this, we will be probably left with more that one key in our candidate key set and we will need to proceed to an exhaustive search among the remaining candidates, but the total time complexity of the attack will be very probably lower. In practice, we will start with values of <span class="math">N</span> such that <span class="math">P&lt;\\frac{1}{2}</span> so to reduce the exhaustive search by at least one bit. The smaller value of <span class="math">N</span> verifying</p>

    <p class="text-gray-300"><span class="math">P=(1-2^{-(c_{in}+c_{out})})^{N}&lt;\\frac{1}{2}</span></p>

    <p class="text-gray-300">is approximately <span class="math">N=2^{c_{in}+c_{out}}</span>.</p>

    <p class="text-gray-300">The <span class="math">N</span> pairs that we consider, following our definition, are pairs that verify the input and output truncated differentials. However, in most of the attacks, once one such pair has been obtained, we can also check, without the need to guess any key bits, if some conditions can be verified, or if there exists an impossibility. An example of such a situation is when the input and output differences to an active Sbox have already been fixed (case of LBlock), or when the key bits do not intervene in the first or last round conditions.We have not included in this generic analysis any of these additional sievings that could help reducing the number of needed pairs, while increasing the number of keys passing the conditions,as this is an issue difficult to treat in a generic way. However, as generalizing such attacks rests our main aim, we will show that it is actually easy to include this improvement in the cost of what we will call <span class="math">C_{Key}</span>, which is the average cost, for a given pair among the <span class="math">N</span> pairs, to test the candidate keys.</p>

    <p class="text-gray-300">We provide now a generic solution for determining the cost of obtaining such <span class="math">N</span> pairs. To the best of our knowledge, this is the first known generic solution to this problem.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Finding <span class="math">N</span> pairs verifying a given truncated differential</h3>

    <p class="text-gray-300">From the limited birthday problem <em>[7]</em> (and slightly corrected here), we know that the cost of finding one pair verifying the input and output differences costs:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_{1}=\\max\\left\\{\\min_{\\Delta\\in\\{\\Delta_{in},\\Delta_{out}\\}}\\left\\{\\sqrt{2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right\\},2^{n+1-(</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">)}\\right\\}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">A direct way to treat the problem of determining the cost of finding <span class="math">N</span> solutions would be to compute it as <span class="math">N\\times C_{1}</span>. However, by computing the cost in this way we might be wasting some structures and therefore this solution is not optimal. We propose here for the first time, an optimal generic expression for the cost of obtaining <span class="math">N</span> pairs verifying an input truncated difference in <span class="math">\\Delta_{in}</span> and a truncated output difference in <span class="math">\\Delta_{out}</span>. In practice, we are searching to determine the number of inputs, say <span class="math">2^{x}</span>, that will be necessary to construct the <span class="math">N</span> pairs.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We distinguish two cases depending on the dimension of the input space, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> and of the output space, </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> compared to the number of pairs </span>N$ we need to construct:</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- If $N\\leq\\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-1}}{2^{n-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">, this means that </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math"> is large enough to allow us to build </span>2^{x}<span class="math"> inputs belonging to the same structure (</span>2^{x}\\leq 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">). Therefore </span>N=\\frac{2^{x}2^{x-1}}{2^{n-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}<span class="math">, which means that we need </span>2^{x}=\\sqrt{N2^{n-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}}$ inputs.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$2^{x}=2^{y}2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}=N2^{n-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">+1}.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">By taking all of this into account together with the fact that we are dealing with a permutation (having thus a symmetry in both directions) and by considering the attacker to be able to chose the ciphertexts as well as the plaintexts, we can conclude that the cost of obtaining the <span class="math">N</span> pairs will be:</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$C_{N}=\\max\\left\\{\\min_{\\Delta\\in\\{\\Delta_{in},\\Delta_{out}\\}}\\left\\{\\sqrt{N2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}\\right\\},N2^{n+1-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}\\right\\}.$ (1)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This cost represents the amount of data needed for the attack. Obviously, as the size of the state is equal to <span class="math">n</span>, we need that:</p>

    <p class="text-gray-300"><span class="math">C_{N}\\leq 2^{n}.</span></p>

    <p class="text-gray-300">These conditions are not verified in several cases from <em>[2]</em>, which invalidates the corresponding attacks.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">2.3 Time and memory complexity</h3>

    <p class="text-gray-300">We are going to detail now the computation of the time complexity of the attack. For this, we will need to briefly recall the attack procedure.</p>

    <p class="text-gray-300">By following the early abort technique <em>[14]</em>, the attack consists in storing the <span class="math">N</span> pairs and testing out step by step the key candidates, by reducing at each time the size of the remaining possible pairs.</p>

    <p class="text-gray-300">The complexity is then determined by 1) the cost of obtaining <span class="math">N</span> pairs, 2) the number of pairs to test multiplied by the average cost of testing the candidate keys per pair and 3) the cost of testing the remaining key candidates and recovering the whole key. From this and by taking into account the cost of one encryption (<span class="math">C_{E}</span>) as well as the relative cost of partial encryption for the key guessing phase (<span class="math">C_{E^{\\prime}}</span>) we conclude that the time complexity of the attack is</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T_{comp}=\\left(C_{N}+N(C_{Key}C_{E^{\\prime}}+1)+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P\\right)C_{E},$ (2)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where the last term is a simplification of $2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">-</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}<span class="math">. Obviously, as we want the attack complexity to be smaller than the exhaustive search complexity, the above quantity should be smaller than </span>2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}C_{E}$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">It must be noted here that the value of <span class="math">C_{key}</span> depends on the cipher structure and its computation is a delicate task that closely depends on the attack parameters. For this reason it can only be computed once all parameters are known. Therefore, in order to be able to compute the time complexity of the attack in an automated way, we will provide a tight approximation of <span class="math">C_{key}</span> by $\\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{2^{c_{in}+c_{out}}}<span class="math">. In most of the cases, as in the examples of the applications that we will detail in the following sections, this expression is a very tight upper bound of </span>C_{key}<span class="math">. In the same way, the precise computation of </span>C_{E^{\\prime}}$ (that is always smaller than 1) can only be done once the attack parameters are known. So for automating the procedure, we can approximate the time complexity of the attack by</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$T^{\\prime}_{comp}=\\left(C_{N}+N(\\frac{2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}}{2^{c_{in}+c_{out}}}C_{E^{\\prime}}+1)+2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P\\right)C_{E}.$ (3)</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Due to the additional free sieving of the first and last rounds pointed out at the end of Section 2.1, we note that Formula (3) is a very tight upper bound of Formula (2).</p>

    <p class="text-gray-300">By using the early abort technique <em>[14]</em>, the only elements that need to be stored are the <span class="math">N</span> pairs. Therefore, the memory complexity of the attack is determined by storing <span class="math">N</span> .</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Application to LBlock</h2>

    <p class="text-gray-300">LBlock is a lightweight block cipher designed by Wu and Zhang in 2011 <em>[21]</em>. It is an iterated construction that can be seen as a variant of a Feistel network. The total number of iterations is equal to 32. The cipher operates on a 64-bit state and encrypts messages by using a 80-bit key.</p>

    <p class="text-gray-300">We start by providing a short description of the algorithm specifications. For a more complete description one can refer to *[21]</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Encryption algorithm. Denote by  $P = L_0</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_0<span class="math">  a 64-bit plaintext, where  </span>L_0<span class="math">  and  </span>R_0$  are 32-bit vectors. The encryption procedure is as follows.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For  <span class="math">i = 1,2,\\ldots ,31</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">R_{i} = L_{i - 1}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">L_{i} = F(L_{i - 1},K_{i})\\oplus (R_{i - 1}\\ll 8).</span></li>

      <li><span class="math">L_{32} = L_{31}</span></li>

      <li><span class="math">R_{32} = F(L_{31},K_{32})\\oplus (R_{31}\\ll 8).</span></li>

    </ul>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- Output the ciphertext  $C = L_{32}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">R_{32}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Round function  <span class="math">F</span> . A round of LBlock is depicted in Figure 1. The round function  <span class="math">F</span>  can be divided into three steps. First, the 32-bit subkey  <span class="math">K_{i}</span>  is added to  <span class="math">L_{i-1}</span>  by a simple XOR. Then, a nonlinear layer applies to the result. This nonlinear layer consists of the application nibble by nibble of eight different 4-bit Sboxes  <span class="math">S_{0}, \\ldots, S_{7}</span> . The description of these Sboxes can be found in [21]. Finally, the resulting nibbles are permuted as seen in Figure 1.</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig.1. A round of LBlock</p>

    <p class="text-gray-300">The key schedule of LBlock can be found in Appendix A. Equally, a description of previous cryptanalysis results for this cipher is given in Appendix B.</p>

    <p class="text-gray-300">We are going to describe now an attack against 23 rounds of LBlock. To our knowledge, this is so far the best known attack against this cipher. We will equally present improved attacks of the ones published so far on 22 rounds.</p>

    <p class="text-gray-300">We start by providing the parameters of the attack that we obtained by applying Algorithm 1 to LBlock. It has to be noted that these parameters are not the only ones that lead to a valid attack on 23-round LBlock. Several different configurations lead to attacks having a similar time complexity.</p>

    <p class="text-gray-300">The 14-round impossible differential path used for this attack is</p>

    <div class="my-4 text-center"><span class="math-block">(0 0 0 0 0 0 0 0, 0 0 0 0 \\alpha 0 0 0) \\stackrel {1 4 r} {\\rightarrow} (0 0 0 0 0 \\beta 0 0, 0 0 0 0 0 0 0 0).</span></div>

    <p class="text-gray-300">This path is placed between the rounds 5 and 19 of the cipher. It is different from both paths used to attack 21 and 22 rounds of LBlock in [9] and can be visualized in Appendix C.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We were able then to extend this impossible differential path adding  <span class="math">r_{in} = 5</span>  rounds to the input and  <span class="math">r_{out} = 4</span>  rounds to the output and attack the first 23 rounds of the cipher. As can be seen in Figure 2, the number of input bit-conditions is  <span class="math">c_{in} = 4 \\times 11 = 44</span>  and the number of output bit-conditions  <span class="math">c_{out} = 4 \\times 7 = 28</span> . In the same way,  <span class="math">\\Delta_{in} = (<em>0 </em> 0 <em> </em> <em> 0, </em> <em> </em> <em> </em> 0)</span>  with  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{in}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 12 \\times 4 = 48<span class="math">  and  </span>\\Delta_{out} = (<em> </em> 0 <em> </em> <em> 00, 0 </em> <em> 0000</em>)<span class="math">  with  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\Delta_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">= 8 \\times 4 = 32$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In the general case, estimating the size of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  is a delicate task and different approaches can be used. A straightforward one is to express the key-bits involved with regard to a subkey of the cipher. However, this approach for LBlock results in a non-optimal approximation of the number of information key-bits. For this reason, we describe next an alternative method for evaluating  </span></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$  for our attack.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Require: An impossible differential path  <span class="math">(\\varDelta_{X}\\nrightarrow\\varDelta_{Y})</span></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ensure: A set of solutions  <span class="math">\\mathcal{L}_{sol}</span>  formed by the parameters  $(r_{in}, r_{out}, c_{in}, c_{out}, \\Delta_{in}, \\Delta_{out},</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, N, C_N, T_{comp}')$  corresponding to a valid attack.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">1: for all possible  <span class="math">r_{in}</span>  do 2: for all possible  <span class="math">r_{out}</span>  do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: Determine  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">, c_{in}, c_{out}, C_{E'}, \\Delta_{in}<span class="math">  and  </span>\\Delta_{out}$ .</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">4:  <span class="math">N\\gets 2^{c_{in} + c_{out}}</span> 5: while  <span class="math">C_N \\leq 2^n</span>  do</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6:  $T_{comp}^{\\prime}\\gets C_N + N(2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in}\\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">- (c_{in} + c_{out})}C_{E^{\\prime}} + 1) + 2^{</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">K</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}P.$</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">8: Add parameters to  <span class="math">\\mathcal{L}_{sol}</span> . 9: end if 10: Increase  <span class="math">N</span> 11: end while 12: end for 13: end for 14: return  <span class="math">\\mathcal{L}_{sol}</span> .</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 2. The initial rounds (on the left) and the final rounds (on the right). Different colors stand for the round that these key-bits intervene.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a></p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Determining  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">  We describe here a method to determine the information key-bits with respect to the key schedule of LBlock. This method helps at minimizing, for the case of LBlock, the total number of key-bits to guess, compared to just expressing  </span>k_{in} \\cup k_{out}$  with respect to a subkey of the cipher. However, this technique, even if only applied to LBlock here, could be possibly adapted to ciphers having a similar key schedule, as it is for example the case of the block ciphers PRESENT [6] and MIBS [8].</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">First, remark that due to LBlock's key schedule structure, the bits of the extended subkeys  <span class="math">K^i</span>  and  <span class="math">K^{i + 1}</span>  are related by a rotation of 29 bits to the left. Indeed, if we know the value of a key-bit in</p>

    <p class="text-gray-300">a given position of  <span class="math">K^i</span> , then we equally know the value of the key-bit in this position rotated by 29 to the right of  <span class="math">K^{i + 1}</span>  as long as this bit is not involved in an Sbox operation during the computation of  <span class="math">K^{i + 1}</span>  from  <span class="math">K^i</span> .</p>

    <p class="text-gray-300">We visualize the key schedule of LBlock in the way depicted in Figure 3. In this figure, each</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> Fig. 3. Representation of LBlock's key schedule. Each line represents one different subkey with respect to the 80-bit master key.</p>

    <p class="text-gray-300">symbol of a row (square, triangle, diamond and cross) is a bit of  <span class="math">K^i</span> ,  <span class="math">i = 1, \\ldots, 32</span> . The least significant bit is represented by the rightmost symbol of each row. The 32 bits of each subkey  <span class="math">K_i</span>  are denoted by either a triangle, a square or a diamond. Squares and triangles determine the position of Sboxes  <span class="math">S_9</span>  (resp.  <span class="math">S_8</span> ) through the key schedule. The bold symbols stand for the subkey nibbles involved in our attack. In this representation, two bits in a given column are the same (up to a known constant addition) if there is no Sbox involved between them. We assume that if we want to know the value of the key bits at the output of an Sbox, we have to know all the input key bits to this Sbox.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">In order to correctly estimate the information key-bits of  <span class="math">k_{in} \\cup k_{out}</span>  and determine a good evaluation of  $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k_{in} \\cup k_{out}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$ , we will proceed as follows. The first step is to find the information key-bits of the key-bits involved in the first and the last rounds separately. This step can be done easily, as when considering only the first or the last rounds, nearly no Sbox is involved, and the key-bits at the same positions with respect to the master key have a one-to-one correspondence.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We can express the information key-bits of both first rounds and last rounds with the help of one subkey in the first rounds and one subkey in the last rounds respectively that minimizes the number of bits involved. There are various possible equivalent choices for these subkeys. We will call block of information key-bits a set of consecutive bits of the subkey used for expressing the information key-bits of the first rounds (resp. the last rounds). As seen in Figure 3, with the parameters of our attack, there exist 3 such blocks in the first rounds (the yellow ones) and 5 blocks in the last rounds (the blue ones). For each block of the first rounds (resp. last rounds), we look for the number of information key-bits in the last rounds (resp. first rounds) that can be recovered. Then, we choose the configuration of blocks that lead to the smallest number of involved bits. However, some decisions have to be taken. More precisely, each time we meet an Sbox without knowing all the input bits, we can either guess the missing bits or drop the involved known bits. This choice depends on the key-bits involved that we want to recover.</p>

    <p class="text-gray-300">We will now apply this procedure to our attack. For instance, we can see in Figure 3 that from the first yellow block on the left (of size 57 bits), by guessing one more bit of  <span class="math">K^{11}</span>  and one more bit of  <span class="math">K^{12}</span> , we can express all but 2 key nibbles involved in the last rounds. We repeat the same approach for each combination of blocks in the forward and the backward direction. Finally, for the key nibbles involved, the configuration of blocks minimizing the number of bits to guess is depicted</p>

    <p class="text-gray-300">in Figure 3. A red path denotes the key-bits we can recover from a block of information key-bits in the first rounds (yellow blocks). Remark that sometimes it is not worth matching the information key-bits in the first and the last rounds, as it is the case for the nibbles on the right, i.e. it is less expensive to just guess both nibbles independently than to try to obtain a connection. Then the number of information key-bits we will need in our attack is evaluated block by block as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>57 bits from  <span class="math">K^1</span> , 1 bit from  <span class="math">K^{11}</span>  (at position 72) and 1 bit from  <span class="math">K^{12}</span>  (at position 79)</li>

      <li>1 nibble from  <span class="math">K^1</span> , 1 bit from  <span class="math">K^{14}</span>  (at position 75) and 1 bit from  <span class="math">K^{22}</span>  (at position 13)</li>

      <li>1 nibble from  <span class="math">K^1</span></li>

      <li>1 nibble from  <span class="math">K^{22}</span> .</li>

    </ul>

    <p class="text-gray-300">In this way, the number of information key-bits we obtain is 73.</p>

    <p class="text-gray-300">Determining  <span class="math">C_{Key}</span> . The issue now is to determine how much will it cost us to retrieve, for each one of the  <span class="math">N</span>  pairs, the keys that must not be discarded. The average cost of this step is the parameter  <span class="math">C_{key}</span> .</p>

    <p class="text-gray-300">In [9], a gradual algorithm is proposed where the possibilities for the subkey bits are tested and discarded in order. Still, this method is quite expensive, having a cost of about  <span class="math">C_{key} = 2^{27}</span>  operations. Here, we propose a method for finding the key candidates that will have  <span class="math">C_{key} \\approx 2</span> . Figure 4 will be used in our explanation to determine which key-bits we are referring to at each step.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> Fig. 4. Representation of the subkeys as used for determining  <span class="math">C_{key}</span> . Each line represents one different subkey with respect to the 80-bit master key. Different colors stand for the round that these key-bits intervene. Subkey-bits are denoted with letters to ease the explanation.</p>

    <p class="text-gray-300">Average probability of a differential transition. Our first action was to have a look at LBlock Sboxes difference tables. For the matter that occupies us, they are all equivalent. We counted the number of possible difference transitions, including the possibility of having zero difference. We have to do this as, amongst the  <span class="math">N</span>  pairs recovered, we have forced the truncated difference, but we have not assured yet that all the nibbles in the truncated difference are actually active. There are 96 out of 256 possible transitions. That means that if we fix a difference in the input and a difference in the output of an Sbox, we have a probability of  <span class="math">96 / 256 \\approx 2^{-1.41}</span>  that this one is a valid transition through the Sbox. For each valid differential transition, we have on average  <span class="math">\\frac{15 \\cdot 16}{96} \\approx 2^{1.32}</span>  values that verify it.</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Preliminary sieving of pairs.</h4>

    <p class="text-gray-300">A similar idea was exploited in <em>[18]</em>, however we provide here a method with an optimized complexity. When obtaining one out of the <span class="math">N</span> pairs with the wanted truncated differential, we can easily verify that the input and output differences of several active Sboxes from the first and the last round paths are already completely determined. This is the case for the 4 active Sboxes of round 1, the 2 out of the 3 active Sboxes in round 2, the 2 Sboxes of round 3, and the 3, 2, 1 and 1 active Sboxes of rounds 23, 22, 21 and 10 respectively. This means that all the pairs that have incompatible difference transitions in this 15 already determined ones, will never produce the impossible differential path, and it is not worth trying them.</p>

    <p class="text-gray-300">Therefore, we will only have <span class="math">N\\cdot 2^{-1.41\\cdot 15}=N\\cdot 2^{-21.22}</span> remaining pairs to treat. For each of the already fixed valid transitions, we know that there exist, on average, <span class="math">2^{1.32}</span> values that make the transition possible.</p>

    <p class="text-gray-300">We show now how to perform, for each one of these remaining pairs, a step by step determination of the associated partial subkeys to discard or to retain.</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Step by step determination of remaining possible subkeys.</h4>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For each one of the <span class="math">N2^{-21.22}</span> pairs, we guess the bits from Figure 4 denoted by <span class="math">a,b</span> and <span class="math">c</span>, that is <span class="math">N2^{-21.22}2^{5.28}2^{4}2^{5}=N2^{-6.94}</span> remaining sets of pairs and partial subkeys with some bits already determined. The bits with an <span class="math">a</span> correspond to the 4 nibbles of the subkey that will directly intervene in the 4 active Sboxes of the first round. This is why we only have <span class="math">2^{1.32\\cdot 4}=2^{5.28}</span> possibilities for the 16 <span class="math">a</span>-bits, while we have to completely guess the <span class="math">b</span>- and the <span class="math">c</span>-bits. With this, all the <span class="math">A</span>-bits are determined.</li>

      <li>Each one of the two nibbles from the <span class="math">A</span>-part in yellow have <span class="math">2^{1.32}</span> possible values, as they are directly involved in the active Sboxes of the 23rd round. But we have a probability of <span class="math">2^{-7}</span> of this values being correct, as the <span class="math">A</span>-bits have already been determined in the previous step. Therefore, we have <span class="math">N2^{-6.94}2^{1.32\\cdot 2}2^{-7}=N2^{-11.3}</span> remaining sets.</li>

      <li>We try next all the possibilities for the <span class="math">e</span>-bits: we have <span class="math">N2^{-11.3}2^{3}=N2^{-8.3}</span> remaining ones.</li>

      <li>We guess the possible values for the <span class="math">f</span>-bits. As all the <span class="math">b</span>-, <span class="math">c</span>- and <span class="math">e</span>-bits are already determined, we know the values and differences at the input of the three active Sboxes of round 2 but for the values of the subkey of round 2. Out of these three active Sboxes, we could already check for two of them, during the preliminary sieving, if their differences could be a valid transition. But this is not the case for the third one. For the two Sboxes with already correct differences, we have <span class="math">2^{1.32}</span> possible values per involved nibble in <span class="math">f</span>. For the other Sbox there is a probability of <span class="math">2^{-1.41}</span> of having a valid transition, and when this is the case, we have <span class="math">2^{1.32}</span> possible values. This means that on average we will have <span class="math">2^{-0.09}</span> possible values for this nibble. We obtain <span class="math">N2^{-8.3+1.32\\cdot 2-0.09}=N2^{-5.75}</span>. We also guess the <span class="math">g</span>-bit, and obtain <span class="math">N2^{-4.75}</span> remaining sets. With this, all the <span class="math">B</span>-bits are determined.</li>

      <li>From the <span class="math">B</span>-bits, the yellow nibble that affects directly the third active Sbox of round 23 has been determined, but there only existed <span class="math">2^{1.32}</span> possible values for it, so we will only keep <span class="math">N2^{-4.75+1.32-4}=N2^{-7.43}</span> sets.</li>

      <li>We consider the <span class="math">2^{1.32}</span> possible values for the <span class="math">p</span>-nibble and for the <span class="math">r</span>-nibble. Next, we guess the <span class="math">h</span>-bits. With them, all the subkey nibbles involved in the active Sbox of round 21 except of the <span class="math">o</span>-bits, have been determined. As we had already checked that the difference transition was a correct one during the preliminary sieving, we have also determined the <span class="math">2^{1.32}</span> possible values for the nibble formed by the <span class="math">B</span>- and <span class="math">o</span>-bits, and they already have 3 bits determined by the upper part, so we will keep: <span class="math">N2^{-7.43}2^{2\\cdot 1.32}2^{4}2^{1.32}2^{-3}=N2^{-2.47}</span>. Note that the <span class="math">o</span>-bit has also been determined.</li>

      <li>In a similar way, we only have <span class="math">2^{1.32}</span> possible values for the nibble with the <span class="math">i</span>-bits: <span class="math">N2^{-2.47+1.32}=N2^{-1.15}</span>.</li>

      <li>We guess the bit at position <span class="math">j</span>, and with this we are able to determine both <span class="math">C</span>-nibbles. Both these <span class="math">C</span>-nibbles affect the same active Sbox at round 5, which is not one of the Sboxes used in the preliminary sieving. As everything involving this Sbox has been determined, we have a probability of <span class="math">2^{-4}</span> of verifying the 4-bit condition of the Sbox: <span class="math">N2^{-4.15}</span>.</li>

      <li>Next, we guess the <span class="math">k</span>-bits, for which we have <span class="math">2^{1.32}</span> possibilities. We also guess the 2 <span class="math">l</span>-bits, and for which of them we have a condition on one bit at position <span class="math">m</span> of being verified: <span class="math">N2^{-4.15+1.32+2-1}=N2^{-1.83}</span>.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We guess the four bits from  <span class="math">n</span> , and we verify the 1-bit conditions at  <span class="math">o</span>  and at the left most  <span class="math">h</span> -bit. We have again  <span class="math">2^{-0.09}</span>  possibilities for  <span class="math">q</span> . We guess the bit  <span class="math">t</span>  (2), which imposes conditions on 3 bits of  <span class="math">q</span> :  <span class="math">N2^{-1.83}2^{4 - 2}2^{-0.09}2^{1 - 3} = N2^{-1.92}</span> .</li>

      <li>We consider the  <span class="math">2^{1.32}</span>  possibilities for the  <span class="math">s</span> -nibble, obtaining finally  <span class="math">N2^{-0.6}</span>  combinations of (pair, partial subkey) as possible candidates.</li>

    </ul>

    <p class="text-gray-300">The complexity of the previous procedure, determines now  <span class="math">C_{key}</span> :</p>

    <div class="my-4 text-center"><span class="math-block">C _ {k e y} = 2 ^ {- 6. 9 4} + 2 ^ {- 1 1. 3} + 2 ^ {- 8. 3} + 2 ^ {- 5. 7 5} + 2 ^ {- 7. 4 3} + 2 ^ {- 2. 4 7} + 2 ^ {- 1. 1 5} + 2 ^ {- 4. 1 5} + 2 ^ {- 1. 8 3} + 2 ^ {- 1. 9 2} + 2 ^ {- 0. 6} = 1. 9 2</span></div>

    <p class="text-gray-300">Complexity of the Attack We briefly recall in Figure 5 the parameters of our attack on 23 rounds.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> Fig. 5. Parameters of our impossible differential cryptanalysis of 23-round LBlock.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a></p>

    <p class="text-gray-300">Notice that in this attack, we approximate the relative cost of partial encryption for the key guessing phase as the ratio between the active Sboxes during the differentials and the total number of Sboxes during an encryption. Therefore,  <span class="math">C_{E&#x27;} = \\frac{36}{8 \\cdot 23} = 2^{0.65}</span> . The trade-offs between data, memory and time complexity for this attack can now be seen in the rightmost table of Figure 6.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> Fig. 6. Data-memory-time trade-offs for the attacks on 22 and 23 rounds of LBlock.</p>

    <p class="text-gray-300">!<a href="img-9.jpeg">img-9.jpeg</a></p>

    <p class="text-gray-300">We give in this section the data, memory and time complexities that we obtained for an impossible differential attack on 22 rounds of LBlock. The parameters of our attack are depicted in Figure 7, while the obtained data, memory and time complexities can be found in the table on the left of Figure 6. It can be seen that our method can efficiently improve the complexities of the previous attack on 22-round LBlock, provided in [9] (see Table 1).</p>

    <p class="text-gray-300">Notice that, similarly to the previous section, we approximate the relative cost of partial encryption for the key guessing phase as the ratio between the active Sboxes during the differentials and the total number of active Sboxes during an encryption. Therefore,  <span class="math">C_{E&#x27;} = \\frac{36}{8 \\cdot 22} = \\frac{36}{176}</span> .</p>

    <p class="text-gray-300">!<a href="img-10.jpeg">img-10.jpeg</a> Fig. 7. Parameters of our impossible differential cryptanalysis of 22-round LBlock.</p>

    <p class="text-gray-300">We have applied the generalized impossible differential attack to the lightweight block cipher LBlock. We have improved the complexity of the previously best known attack on 22 rounds, and we have provided for the first time, an attack on 23 out of the 32 total rounds of the cipher.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>F. Abed, E. List, S. Lucks, and J. Wenzel. Differential and Linear Cryptanalysis of Reduced-Round Simon. Cryptology ePrint Archive, Report 2013/526, 2013.</li>

      <li>H. A. Alkhzaimi and M. M. Lauridsen. Cryptanalysis of the SIMON Family of Block Ciphers. Cryptology ePrint Archive, Report 2013/543, 2013.</li>

      <li>J-P. Aumasson, C. Çalik, W. Meier, O. Özen, R. C.-W. Phan, and K. Varici. Improved Cryptanalysis of Skein. In ASIACRyPT 2009, volume 5912 of LNCS, pages 542-559. Springer, 2009.</li>

      <li>E. Biham, A. Biryukov, and A. Shamir. Cryptanalysis of Skipjack Reduced to 31 Rounds Using Impossible Differentials. In EUROCRYPT 1999, volume 1592 of LNCS, pages 12-23. Springer, 1999.</li>

      <li>E. Biham and A. Shamir. Differential Cryptanalysis of DES-like Cryptosystems. In CRYPTO 1990, volume 537 of LNCS, pages 2-21. Springer, 1990.</li>

      <li>A. Bogdanov, L. R. Knudsen, G. Leander, C. Paar, A. Poschmann, M. J. B. Robshaw, Y. Seurin, and C. Vikkelsoe. PRESENT: An Ultra-Lightweight Block Cipher. In CHES 2007, volume 4727 of LNCS, pages 450-466. Springer, 2007.</li>

      <li>H. Gilbert and T. Peyrin. Super-Sbox Cryptanalysis: Improved Attacks for AES-Like Permutations. In FSE 2010, volume 6147 of LNCS, pages 365-383. Springer, 2010.</li>

      <li>M. Izadi, B. Sadeghiyan, S. S. Sadeghian, and H. Arabnezhad Khanooki. MIBS: A New Lightweight Block Cipher. In CANS 2009, volume 5888 of LNCS, pages 334-348. Springer, 2009.</li>

      <li>F. Karakoc, H. Demirci, and A. E. Harmanci. Impossible Differential Cryptanalysis of Reduced-Round LBlock. In WISTP 2012, volume 7322 of LNCS, pages 179-188. Springer, 2012.</li>

      <li>F. Karakoc, H. Demirci, and A. E. Harmanci. Biclique cryptanalysis of LBlock and TWINE. Inf. Process. Lett., 113(12):423-429, 2013.</li>

      <li>L. R. Knudsen. DEAL - A 128-bit cipher. Technical Report, Department of Informatics, University of Bergen, Norway, 1998.</li>

      <li>Y. Liu, D. Gu, Z. Liu, and W. Li. Impossible Differential Attacks on Reduced-Round LBlock. In ISPEC 2012, volume 7232 of LNCS, pages 97-108. Springer, 2012.</li>

      <li>Y. Liu, L. Li, D. Gu, X. Wang, Z. Liu, J. Chen, and W. Li. New Observations on Impossible Differential Cryptanalysis of Reduced-Round Camellia. In FSE 2012, volume 7549 of LNCS, pages 90-109. Springer, 2012.</li>

      <li>J. Lu, J. Kim, N. Keller, and O. Dunkelman. Improving the Efficiency of Impossible Differential Cryptanalysis of Reduced Camellia and MISTY1. In CT-RSA, volume 4964 of LNCS, pages 370-386. Springer, 2008.</li>

      <li>M. Minier and M. Naya-Plasencia. A Related Key Impossible Differential Attack Against 22 Rounds of the Lightweight Block Cipher LBlock. Inf. Process. Lett., 112(16):624-629, 2012.</li>

      <li>Y. Sasaki and L. Wang. Comprehensive Study of Integral Analysis on 22-Round LBlock. In ICISC 2012, volume 7839 of LNCS, pages 156-169. Springer, 2012.</li>

      <li>H. Soleimany and K. Nyberg. Zero-Correlation Linear Cryptanalysis of Reduced-Round LBlock. In International Workshop on Coding and Cryptography-WCC 2013, 2013.</li>

      <li>T. Suzuki, K. Minematsu, S. Morioka, and E. Kobayashi. TWINE: A Lightweight Block Cipher for Multiple Platforms. In Selected Areas in Cryptography-SAC 2012, volume 7707 of LNCS, pages 339-354. Springer, 2012.</li>

      <li>Y. Wang, W. Wu, X. Yu, and L. Zhang. Security on LBlock against Biclique Cryptanalysis. In WISA 2012, volume 7690 of LNCS, pages 1-14. Springer, 2012.</li>

      <li>L. Wen, M. Wang, and J. Zhao. Related-Key Impossible Differential Attack on Reduced-Round LBlock. J. Comput. Sci. Technol., 29(1):165-176, 2014.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>W. Wu and L. Zhang. LBlock: A Lightweight Block Cipher. In ACNS 2011, volume 6715 of LNCS, pages 327-344. Springer, 2011.</li>

      <li>W. Wu, L. Zhang, and W. Zhang. Improved Impossible Differential Cryptanalysis of Reduced-Round Camellia. In Selected Areas in Cryptography-SAC 2009, volume 5381 of LNCS, pages 442-456. Springer, 2008.</li>

    </ol>

    <p class="text-gray-300">Denote by  <span class="math">K</span>  the master key of the encryption. We will call the generated vectors  <span class="math">K^i</span> ,  <span class="math">i = 1, \\ldots, 32</span> , extended subkeys. Then, the 32 subkeys  <span class="math">K_i</span> ,  <span class="math">1 \\leq i \\leq 32</span>  are derived from  <span class="math">K</span>  as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">K^1 = K</span></li>

      <li><span class="math">K_{1} = K[79,\\dots ,48]</span></li>

      <li>For  <span class="math">i = 2, \\ldots, 32</span>  do</li>

    </ul>

    <p class="text-gray-300"><span class="math">K^i = K^{i - 1}\\ll 29</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">K^i [79,\\dots ,76] = S_9[K^i [79,\\dots ,76]]</span></li>

      <li><span class="math">K^i [75,\\dots ,72] = S_8[K^i [75,\\dots ,72]]</span></li>

      <li><span class="math">K^i [50, \\ldots, 46] = K^i [50, \\ldots, 46] \\oplus [i - 1]_2</span> , where  <span class="math">[i - 1]_2</span>  is the binary representation of  <span class="math">i - 1</span> .</li>

      <li><span class="math">K_{i} = K^{i}[79,\\dots ,48]</span></li>

    </ul>

    <p class="text-gray-300">LBlock has received the attention of many researchers and it has been the target of numerous analyses. Different techniques, such as differential cryptanalysis, impossible differential cryptanalysis (in the single and related key models), integral and zero-correlation cryptanalysis have been applied to break reduced-round versions of the cipher [21, 12, 9, 15, 16, 19, 10, 17, 20]. The maximum number of rounds achieved by all these attacks in the single key is 22. The previous results concerning impossible differential cryptanalysis of LBlock can be found in Table 1.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"># rounds</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Time complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Data complexity</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Reference</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Single-key</td>

            <td class="px-3 py-2 border-b border-gray-700">20</td>

            <td class="px-3 py-2 border-b border-gray-700">272.7</td>

            <td class="px-3 py-2 border-b border-gray-700">263 CP</td>

            <td class="px-3 py-2 border-b border-gray-700">[21]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Single-key</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">273.7</td>

            <td class="px-3 py-2 border-b border-gray-700">262.5 CP</td>

            <td class="px-3 py-2 border-b border-gray-700">[12]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Single-key</td>

            <td class="px-3 py-2 border-b border-gray-700">21</td>

            <td class="px-3 py-2 border-b border-gray-700">269.5</td>

            <td class="px-3 py-2 border-b border-gray-700">263 CP</td>

            <td class="px-3 py-2 border-b border-gray-700">[9]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Single-key</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">279.28</td>

            <td class="px-3 py-2 border-b border-gray-700">258 CP</td>

            <td class="px-3 py-2 border-b border-gray-700">[9]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Related-key</td>

            <td class="px-3 py-2 border-b border-gray-700">22</td>

            <td class="px-3 py-2 border-b border-gray-700">270</td>

            <td class="px-3 py-2 border-b border-gray-700">247 RKCP</td>

            <td class="px-3 py-2 border-b border-gray-700">[15]</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Related-key</td>

            <td class="px-3 py-2 border-b border-gray-700">23</td>

            <td class="px-3 py-2 border-b border-gray-700">278.3</td>

            <td class="px-3 py-2 border-b border-gray-700">261.4 RKCP</td>

            <td class="px-3 py-2 border-b border-gray-700">[20]</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1. Previous impossible differential cryptanalysis results on LBlock</p>

    <p class="text-gray-300">We give here the impossible differential path that has been used to attack 23 rounds of LBlock. The green color stands for nibbles that have a truncated difference with probability 1 (active nibbles), while white symbolizes nibbles that do not have a difference (passive nibbles). Finally, we represent by grey the nibbles for which we do not know whether they are active or passive. This 14-round impossible differential path combines two paths of probability 1 for which an impossibility occurs after 7 rounds. The nibble for which the impossibility occurs is the fourth nibble from the left of  <span class="math">L_{12}</span> .</p>

    <p class="text-gray-300">!<a href="img-11.jpeg">img-11.jpeg</a> Fig. 8. 14-round impossible differential path used in the 23-round attack against LBlock.</p>

    <p class="text-gray-300">!<a href="img-12.jpeg">img-12.jpeg</a></p>`;
---

<BaseLayout title="Improved Impossible Differential Attacks against Round-Reduc... (2014/279)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2014 &middot; eprint 2014/279
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
