---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2020/1558';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Double-Odd Elliptic Curves';
const AUTHORS_HTML = 'Thomas Pornin';

const CONTENT = `    <p class="text-gray-300">Thomas Pornin</p>

    <p class="text-gray-300">NCC Group, thomas.pornin@nccgroup.com</p>

    <p class="text-gray-300">13 December, 2020</p>

    <p class="text-gray-300">Abstract. This article explores the use of elliptic curves with order <span class="math">2r = 2 \\mod 4</span>, which we call double-odd elliptic curves. This is a very large class, comprising about <span class="math">1/4</span>th of all curves over a given field. On such curves, we manage to define a prime order group with appropriate characteristics for building cryptographic protocols:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Element encoding is canonical, and verified upon decoding. For a <span class="math">2n</span>-bit group (with <span class="math">n</span>-bit security), encoding size is <span class="math">2n + 1</span> bits, i.e. as good as compressed points on classic prime order curves.</li>

      <li>Unified and complete formulas allow secure and efficient computations in the group.</li>

      <li>Efficiency is on par with twisted Edwards curves, and in some respects slightly better; e.g. half of double-odd curves have formulas for computing point doublings with only six multiplications (down to <span class="math">1\\mathrm{M} + 5\\mathrm{S}</span> per doubling on some curves).</li>

    </ul>

    <p class="text-gray-300">We describe here various formulas and discuss implementations. We also define two specific parameter choices for curves with 128-bit security, called do255e and do255s. Our own implementations on 64-bit x86 (Coffee Lake) and low-end ARM Cortex M0+ achieve generic point multiplication in 76696 and 2.19 million cycles, respectively, with curve do255e.</p>

    <p class="text-gray-300">Note. A summary of the results presented here, and links to all implementations in various languages, can be found on the double-odd curves site:</p>

    <p class="text-gray-300">https://doubleodd.group/</p>

    <h2 id="sec-3" class="text-2xl font-bold">1.1 Motivation</h2>

    <p class="text-gray-300">A number of cryptographic functionalities, such as key exchange (Diffie-Hellman[13]) and signatures (ECDSA[1,21], Schnorr[35]), can be built on top of a suitable group. Informally, proper security can be achieved if:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>the group order is a large enough prime number;</li>

      <li>computations over the group can be performed efficiently (encoding and decoding of elements, applying the group law);</li>

      <li>but discrete logarithm in the group is computationally infeasible.</li>

    </ul>

    <p class="text-gray-300">It is unknown whether such a group can exist, in absolute terms, because there is no proof that discrete logarithm can ever be "infeasible". However, we know of some candidates which</p>

    <p class="text-gray-300">fulfill the first two properties, and for which no efficient enough method to solve discrete logarithm is known. Among such candidates, elliptic curves offer good performance, in particular in terms of encoding size: a curve may offer "  <span class="math">n</span> -bit security", i.e. a discrete logarithm cost of at least  <span class="math">2^n</span>  simple operations, with only  <span class="math">2^{2n}</span>  elements, which can be represented over about  <span class="math">2n</span>  bits. This is the best that can be hoped for, since there are known algorithms for computing discrete logarithm over any group, with cost proportional to the square root of the group size.</p>

    <p class="text-gray-300">Several kinds of elliptic curves have been explored, with various characteristics and drawbacks. The two main classes in wide usage are dubbed Weierstraβ curves and twisted Edwards curves.</p>

    <p class="text-gray-300">Weierstraβ curves. Given a base finite field  <span class="math">\\mathbb{F}_q</span> , the curve is the set of points  <span class="math">(x,y) \\in \\mathbb{F}_q \\times \\mathbb{F}_q</span>  that fulfill the short Weierstraβ equation  <span class="math">y^2 = x^3 + Ax + B</span>  for two given constants  <span class="math">A</span>  and  <span class="math">B</span>  in  <span class="math">\\mathbb{F}_q</span>  such that  <span class="math">4A^3 + 27B^2 \\neq 0</span> ; an extra formal point with no defined coordinates, called the point-at-infinity (denoted  <span class="math">\\mathbb{O}</span> ), is adjoined to the curve and is used as the neutral element in the group law <span class="math">^1</span> .</p>

    <p class="text-gray-300">The group law (traditionally called "addition") is defined geometrically, as illustrated on figure 1. For two points  <span class="math">P</span>  and  <span class="math">Q</span>  on the curve, the line  <span class="math">(PQ)</span>  is drawn; it intersects the curve at a third point, which is  <span class="math">-(P + Q)</span> . The sum  <span class="math">P + Q</span>  is the opposite of this point, which is defined to be its image by the symmetry relative to the horizontal axis.</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> Fig. 1: Point addition on a Weierstraβ curve.</p>

    <p class="text-gray-300">This law can be expressed with a few arithmetic operations on the  <span class="math">x</span>  and  <span class="math">y</span>  coordinates. Since these operations include divisions, which are in practice much more expensive to compute than additions or multiplications, it is customary to use some sort of fractional repre</p>

    <p class="text-gray-300">sentation (often Jacobian or projective coordinates)². This yields practical formulas, whose main problem is that they have exceptional cases which must be handled differently:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The point-at-infinity does not have defined coordinates, and requires a specific representation and formulas.</li>

      <li>When adding a point <span class="math">P</span> to its opposite <span class="math">-P</span>, both points have the same <span class="math">x</span> coordinate, so the line from <span class="math">P</span> to <span class="math">-P</span> is vertical and cannot be expressed as an equation <span class="math">y = Cx + D</span>. Moreover, in that case, the third point of intersection with the curve is the point-at-infinity, again with no well-defined coordinates.</li>

      <li>When adding a point <span class="math">P</span> to itself, the line <span class="math">(PP)</span> is not defined; different formulas must be used to obtain the tangent to the curve on <span class="math">P</span>.</li>

    </ul>

    <p class="text-gray-300">Exceptional cases are a source of implementation issues if not properly handled; ad hoc tests can be added, but they usually lead to vulnerabilities through side channels leaks (non constant-time implementation), or to inefficiency (if all possible code paths are executed and the correct one selected with constant-time selection routines). There are known formulas working over projective coordinates that are complete, i.e. with no exceptional case[34]; these, however, are more expensive than the traditional incomplete formulas.</p>

    <p class="text-gray-300">It is customary to express formula cost in terms of the number of multiplications and squarings involved in point addition and point doubling. The traditional Jacobian coordinates (with incomplete formulas) lead to a cost of <span class="math">12\\mathrm{M} + 4\\mathrm{S}</span> for general point addition, and <span class="math">4\\mathrm{M} + 4\\mathrm{S}</span> for point doubling³. With complete formulas in projective coordinates, general point addition cost is lowered to <span class="math">12\\mathrm{M}</span>, but doubling cost raises to <span class="math">8\\mathrm{M} + 3\\mathrm{S}</span>; since multiplication of a point by a scalar uses way more point doublings than general additions, this makes these formulas less efficient.</p>

    <p class="text-gray-300">Weierstraß curves can have a prime order, and <span class="math">n</span>-bit security is obtained with a curve order of size <span class="math">2n</span> bits, and whose elements can be encoded to, and decoded from, a compact representation in <span class="math">2n + 1</span> bits (<span class="math">2n</span> bits for the <span class="math">x</span> coordinate of the point, and one extra bit to allow unambiguous reconstruction of the <span class="math">y</span> coordinate).</p>

    <p class="text-gray-300"><strong>Twisted Edwards curves.</strong> Twisted Edwards curves[5] use a degree-4 equation <span class="math">Cx^2 + y^2 = 1 + Dx^2y^2</span>, for two constants <span class="math">C</span> and <span class="math">D</span>. They are, in fact, birationally equivalent to some Weierstraß curves, specifically Montgomery curves (with equation <span class="math">By^2 = x^3 + Ax^2 + x</span>). Twisted Edwards curves have the advantage of leading to a representation and formulas which are both complete and efficient: there is no exceptional case; general point addition is computed with cost 8M, and doubling with cost 4M+4S (using "extended coordinates"[20]). With some alternate coordinate representations, doublings can be made faster (3M+4S) but it makes general point addition slower (9M).</p>

    <p class="text-gray-300">While the complete formulas for twisted Edwards curves are roughly 1.5 times faster than complete formulas for Weierstraß curves, they have a drawback known as the <em>cofactor</em>: the number of elements in such a curve is necessarily a multiple of 4, and therefore cannot be</p>

    <p class="text-gray-300">²In some specific fields defined as extensions of smaller fields, it is possible to compute inversions efficiently enough to use affine coordinates, but this depends on the implementation architecture and tends to have suboptimal performance on CPUs with large registers[30].</p>

    <p class="text-gray-300">³Subject to the additional condition that <span class="math">A = -3</span>, which can be achieved on most curves through the use of an isomorphic or at worst isogenous representation of the curve.</p>

    <p class="text-gray-300">a large prime. At best, such curves can have order <span class="math">4r</span>, with <span class="math">r</span> being the prime order of the (sub)group on which cryptographic functionality can be expressed; the cofactor is the ratio between the total curve order and the prime order of the target subgroup. An immediate consequence is that <span class="math">n</span>-bit security needs <span class="math">r</span> to be a <span class="math">2n</span>-bit integer, thus a total curve order of at least <span class="math">2n + 2</span> bits, with elements encoded over <span class="math">2n + 3</span> bits. This slight inefficiency (2 extra bits) is rarely significant in practice, although it can be burdensome in some cases, e.g. when trying to encode meaningful data into curve points.</p>

    <p class="text-gray-300">Less anecdotally, the non-trivial cofactor can lead to difficulties, and even security vulnerabilities, depending on the situation. The main cause is that there is no known efficient way to verify that a given point is part of a specific subgroup⁴. For instance, the Ed25519 signature algorithm, built over a twisted Edwards curve with cofactor 8, has two different verification equations; in the words of RFC 8032[23]:</p>

    <p class="text-gray-300">Check the group equation <span class="math">8sB = 8R + 8kA&#x27;</span>. It's sufficient, but not required, to instead check <span class="math">sB = R + kA&#x27;</span>.</p>

    <p class="text-gray-300">With valid signatures, the two equations will both be fulfilled; moreover, building a case where the first equation matches but the second does not require knowledge of the private key. Therefore, this feature does not contradict the assertion that Ed25519 is a secure signature algorithm. However, the possibility to craft malicious values such that different verifier implementations disagree on the signature validity is enough to induce serious issues in some applications, in particular consensus-based distributed systems[40]. More serious breaches exploiting the non-trivial cofactor have been reported[27]. Generally speaking, the cofactor may cause issues that must be mitigated in the protocol that uses the curve as base group; the solution is usually a generous application of extra multiplications by the cofactor in some places, along with some filtering of low-order points. Such extra operations are not expensive, but complicate the design and security analysis of cryptographic protocols. It can be said that the overall simplicity of use of complete point addition formulas has been obtained not by removing complexity, but by foisting it into upper design layers. When available, prime order groups with no cofactor issue are preferable[12].</p>

    <p class="text-gray-300">Decaf and Ristretto. Decaf[19] and its successor Ristretto[3] are encoding and decoding maps that aim at solving the cofactor issues of twisted Edwards curves with cofactor 4 (for Decaf) or 8 (for Ristretto). A given curve point <span class="math">P</span> can be encoded into a base field element; when decoding, this yields a point <span class="math">P&#x27;</span> which will not necessarily be the point <span class="math">P</span>, but which will be such that <span class="math">P&#x27; - P</span> is a low-order point. All points that differ with each other by a low-order point encode into the same sequence of bits. This process allows using the curve of order <span class="math">4r</span> or <span class="math">8r</span> as if it were a group of order <span class="math">r</span>.</p>

    <p class="text-gray-300">Decaf and Ristretto remove security issues related to the cofactor, without introducing any new security hypothesis, since they work over an existing twisted Edwards curve and are provably as secure as that curve. However, they have some remaining (but smaller) drawbacks:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The encoding size is not fully optimal, in that <span class="math">n</span>-bit security will need a curve defined over a field of at least <span class="math">2n + 2</span> bits (<span class="math">2n + 3</span> bits with Ristretto), and use as many bits for encoding. This is close, but not equal to the <span class="math">2n + 1</span> bits achievable with Weierstraß curves.</li>

    </ul>

    <p class="text-gray-300">⁴By “efficient” we mean here having cost negligible with regard to that of a generic point multiplication by a scalar.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Both the decoding and encoding process require the computation of an inverse square root in the field, which needs an exponentiation with an exponent of about the same size as the field. “Normal” twisted Edwards curves require a similar operation for decoding from compressed coordinates, but encoding only needs an inversion. Constant-time inversion is traditionally performed with Fermat’s little theorem, at a cost similar to that of a square root, but faster solutions are known<em>[32]</em>, especially on embedded systems, where the cost of inversion can be as low as 1/5th of the cost of a square root or an inverse square root, for a typical 255-bit field<em>[33]</em>.</li>

    </ul>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">Goal.</h3>

    <p class="text-gray-300">We want to find curve equations and formulas that improve on the currently known solutions. Specifically, we would like to obtain the following desirable properties:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A group of order <span class="math">r</span> prime, backed by an elliptic curve of order <span class="math">r</span> (or possibly a multiple of <span class="math">r</span>, as long as the extra cofactor is tamed through an appropriate encoding, as in Ristretto).</li>

      <li>Group elements should have a canonical encoding into at most <span class="math">2n+1</span> bits, for a security level of <span class="math">n</span> bits (i.e. <span class="math">r</span> having a size of <span class="math">2n</span> bits).</li>

      <li>The decoding process should be efficiently verifiable: it should be easy to check (with negligible overhead) that the sequence of bits that was used as input is indeed exactly what would be obtained as output if the decoded element were to be encoded again.</li>

      <li>The group law should be computable with efficient complete formulas, amenable to fast and secure implementations (notably, constant-time implementations). The efficiency of point doublings is critical, since most of the cost in usual cryptographic operations (multiplication of a curve point by a scalar) is spent in computing sequences of successive doublings.</li>

      <li>The underlying elliptic curve should be from a large class, so that the usual well-studied assumptions of resistance to discrete logarithm may be leveraged without introducing any new cryptographic hypothesis.</li>

    </ul>

    <p class="text-gray-300">In this document, we explore such a class of elliptic curves, and show how they fulfill all these goals (and some more).</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">1.2 Core Ideas</h3>

    <p class="text-gray-300">Let <span class="math">\\mathbb{F}_{q}</span> be a given finite field where operations are efficient. It can be any field of characteristic different from 2 and 3, but, for the purposes of this introduction, let’s imagine that we use integers modulo a prime which is close to a power of 2, such <span class="math">q=2^{255}-19</span>, as used in Curve25519<em>[4]</em>. All elliptic curves can be described as Weierstraß curves with a short Weierstraß equation, and, as we explained, we can choose curves with a prime order. This is how most standard elliptic curves have historically been defined. Relevant classic standards (e.g. ANSI X9.62<em>[1]</em>) support arbitrary curves with both trivial and non-trivial cofactors, but if we are to use the generic short Weierstraß equation, then it makes little sense not to choose a curve with prime order, to at least remove cofactor issues. A contrario, when using a twisted Edwards curve (or its Montgomery counterpart), the cofactor is at least 4. This raises the following question: what of the “intermediate” curves with a cofactor of 2, i.e. with a total order which is not prime, but still a cofactor lower than 4?</p>

    <p class="text-gray-300">This document explores the class of elliptic curves with order  <span class="math">2r</span> , with  <span class="math">r</span>  being an odd integer (in practical situations, we will choose curves such that  <span class="math">r</span>  is prime). For want of a better name, we call them double-odd elliptic curves.</p>

    <p class="text-gray-300">On a short Weierstraβ curve, points of order 2 are points that have  <span class="math">y = 0</span> . A double-odd elliptic curve has, by construction, a single point of order 2; let's call it  <span class="math">N</span> . We first apply a simple change of variable to make it so that the  <span class="math">x</span>  coordinate of  <span class="math">N</span>  is also zero. This is illustrated on figure 2. This change of variable transforms the curve equation into a similar but not identical form:  <span class="math">y^2 = x(x^2 + ax + b)</span> , for two constants  <span class="math">a</span>  and  <span class="math">b</span> .</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> Fig. 2: Change of variable on a double-odd elliptic curve.</p>

    <p class="text-gray-300">Let's call  <span class="math">E[r]</span>  the subgroup of points of  <span class="math">r</span> -torsion on the curve (i.e. the points that, multiplied by  <span class="math">r</span> , yield  <span class="math">\\mathbb{O}</span> ). It is a group of order  <span class="math">r</span> , thus a good candidate for a foundation for the prime order group we are looking for. All curve points can be separated into two disjoint sets:  <span class="math">E[r]</span> , and points  <span class="math">P + N</span>  where  <span class="math">P \\in E[r]</span> . In other words, if a point  <span class="math">P</span>  is in  <span class="math">E[r]</span> , then  <span class="math">P + N</span>  is not, and vice versa.</p>

    <p class="text-gray-300">For a point  <span class="math">P = (x, y)</span>  on the curve, distinct from  <span class="math">N</span>  and  <span class="math">\\mathbb{O}</span> , let's consider the addition  <span class="math">P + N</span>  from a geometric point of view. The line  <span class="math">(PN)</span>  has a well-defined slope  <span class="math">w = y / x</span>  and intersects the curve on a third point, which is, by definition, the point  <span class="math">-(P + N)</span> . The important remark here is that if  <span class="math">P \\in E[r]</span> , then  <span class="math">-(P + N) \\notin E[r]</span> , and vice versa. This is illustrated on figure 3.</p>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Fig. 3: Adding the point  <span class="math">N</span>  (of order 2) to a point  <span class="math">P</span> .</p>

    <p class="text-gray-300">The consequence of that addition is that for a given slope value  <span class="math">w</span> , there is a unique line with that slope that goes through  <span class="math">N</span> . That line might not intersect the curve at any other point; but if it does, then it will intersect the curve in two points, exactly one of which is part of  <span class="math">E[r]</span> . This implies that any point  <span class="math">(x,y) \\in E[r]</span>  can be encoded into a field element  <span class="math">w = y / x</span> , which is the slope of the line from  <span class="math">N</span>  to that point, and this encoding is injective <span class="math">^6</span> .</p>

    <p class="text-gray-300">For decoding, we use  <span class="math">w</span>  to define the line  <span class="math">(PN)</span>  and resolve the equation that yields the coordinates of both  <span class="math">P</span>  and  <span class="math">-(P + N)</span> ; this is a degree-2 equation, so it is solvable, in all generality, with a square root computation. To finalize decoding, we need a way to distinguish between  <span class="math">P</span>  and  <span class="math">-(P + N)</span> , i.e. find out which of the two solutions is the point which is part of  <span class="math">E[r]</span> . It turns out (this is not obvious geometrically) that for all points  <span class="math">P = (x,y)</span>  (distinct from  <span class="math">\\bigcirc</span>  and  <span class="math">N</span> ) on a double-odd elliptic curve,  <span class="math">P</span>  is in  <span class="math">E[r]</span>  if and only if  <span class="math">x</span>  is a quadratic residue in the field. Thus, we can find the correct  <span class="math">P</span>  by way of testing the quadratic residue, which can be done with relative ease with a Legendre symbol computation.</p>

    <p class="text-gray-300">At that point, we have the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For a  <span class="math">2n</span> -bit odd prime integer  <span class="math">r</span> , we use a curve with order  <span class="math">2r</span> , based on a field  <span class="math">\\mathbb{F}_q</span>  of size  <span class="math">2n + 1</span>  bits.</li>

      <li><span class="math">E[r]</span>  is a prime order group suitable for cryptographic functionalities. Each element  <span class="math">(x, y) \\in E[r]</span>  can be encoded into the value  <span class="math">w = y / x</span> . This encoding requires a division, which we can hope to be implicit in the use of fractional coordinates; this is similar to what is done for other curves (short Weierstraß and twisted Edwards), and more efficient than Decaf/Ristretto.</li>

      <li>Decoding is intrinsically verified and involves a square root and a Legendre symbol computation. Depending on target architectures, the Legendre symbol may have minor overhead; on ARM Cortex M0+ CPUs, we find for instance that the cost of a Legendre symbol is less than 1/6th of that of a square root[33].</li>

    </ul>

    <p class="text-gray-300">This is a promising debut. Now, we want at least unified formulas, i.e. formulas for which addition of a point to itself is not an exceptional case. This could be done generically by using a change of variable after decoding (the reverse of the one illustrated on figure 2) and then using the known complete formulas for short Weierstraß curves[34]. However, we can do better, leveraging again the point  <span class="math">N</span> .</p>

    <p class="text-gray-300">Consider the situation of adding a point  <span class="math">P</span>  to itself, shown on figure 4. On the left side, the classical solution involves detecting that case and then using the tangent to the curve. This leads to incomplete formulas and thus implementation safety issues. However, on a double-odd elliptic curve, we can use the point  <span class="math">N</span>  to instead add point  <span class="math">P</span>  with point  <span class="math">P + N</span> , as shown on the right side of figure 4 (blue lines);  <span class="math">P</span>  and  <span class="math">P + N</span>  are distinct and have distinct  <span class="math">x</span>  coordinates, therefore the normal addition method works. More generally, when adding points  <span class="math">P</span>  and  <span class="math">Q</span>  together, and  <span class="math">P</span>  and  <span class="math">Q</span>  are both on  <span class="math">E[r]</span> , then we compute  <span class="math">P + Q = (P + (Q + N)) + N</span> . Points  <span class="math">P</span>  and  <span class="math">Q + N</span>  necessarily have distinct  <span class="math">x</span>  coordinates, since  <span class="math">P</span>  is in  <span class="math">E[r]</span>  but  <span class="math">Q + N</span>  is not. This avoids the exceptional cases related to adding a point to itself, and naturally leads to at least unified formulas.</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> Fig. 4: Point doubling, without and with the help of the point  <span class="math">N</span> .</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a></p>

    <p class="text-gray-300">A further trick will help: instead of working with points in  <span class="math">E[r]</span> , we will work with points which are not in  <span class="math">E[r]</span> ; we will define our group law as  <span class="math">(P + N) * (Q + N) = (P + Q) + N</span> . This is equivalent to saying that we represent point  <span class="math">P \\in E[r]</span>  by point  <span class="math">P + N</span> ; we are still conceptually working with points on the prime order group  <span class="math">E[r]</span> , but through their dual points. This small transform has the nice side-effect of making  <span class="math">N</span>  the neutral point in the group, i.e. a point with well-defined  <span class="math">x</span>  and  <span class="math">y</span>  coordinates. This will help in making complete formulas, that handle the neutral just like any other point.</p>

    <p class="text-gray-300">It remains to be seen whether all this leads to efficient formulas. As will be described in the rest of this document, it does.</p>

    <p class="text-gray-300">9</p>

    <p class="text-gray-300">We summarize here the results which will be explained at length in the remaining pages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Double-odd elliptic curves are exactly (up to isomorphism) curves of equation:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">y ^ {2} = x \\left(x ^ {2} + a x + b\\right)</span></div>

    <p class="text-gray-300">where <span class="math">a</span> and <span class="math">b</span> are two field elements such that neither <span class="math">b</span> nor <span class="math">a^2 - 4b</span> is a quadratic residue. This is a large class; about <span class="math">1/4</span>th of all curves are double-odd curves (this is similar to, for instance, Montgomery curves).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A group of order <span class="math">r</span> is defined as <span class="math">\\mathbb{G} = \\{P + N \\mid P \\in E[r]\\}</span>. The group is homomorphic to the curve subgroup of points of <span class="math">r</span>-torsion; its neutral element is <span class="math">N = (0, 0)</span>. Addition in <span class="math">\\mathbb{G}</span> of <span class="math">P + N</span> and <span class="math">Q + N</span> is performed as:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(P + N) * (Q + N) = P + (Q + N)</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group element <span class="math">(x, y)</span> is canonically encoded as the value <span class="math">w = y/x</span> (value zero for the neutral <span class="math">N</span>). A group with <span class="math">n</span>-bit security is encoded over <span class="math">2n + 1</span> bits, which is about the best that can be hoped for with elliptic curves, and matches what can be achieved with prime order short Weierstraß curves. Decoding is intrinsically verified; invalid encodings can be reliably detected and rejected. When decoded, the obtained element is necessarily in the right prime order group.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Several coordinate systems can be used. We define <span class="math">(x, w)</span> and <span class="math">(x, u)</span> systems (with <span class="math">w = y/x</span> and <span class="math">u = x/y</span>). With <span class="math">(x, w)</span>, we get unified formulas (that can be implemented in complete routines); in <span class="math">(x, u)</span> coordinates, we achieve complete formulas.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>With Jacobian <span class="math">(x, w)</span> coordinates, we represent points in <span class="math">\\mathbb{G}</span> as triplets <span class="math">(X: W: Z)</span> such that <span class="math">x = X / Z^2</span> and <span class="math">w = W / Z</span>. These coordinates lead to unified addition formulas with cost <span class="math">8\\mathrm{M} + 6\\mathrm{S}</span>, and complete doubling formulas with cost <span class="math">2\\mathrm{M} + 5\\mathrm{S}</span> (generically on all curves) that can be reduced to <span class="math">1\\mathrm{M} + 6\\mathrm{S}</span> or even <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span> on some curves. Moreover, in sequences of successive doublings, marginal cost per doubling is <span class="math">4\\mathrm{M} + 2\\mathrm{S}</span> for half of double-odd elliptic curves, and as low as <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span> or even <span class="math">1\\mathrm{M} + 5\\mathrm{S}</span> for some curves (a sequence of <span class="math">n</span> doublings on these last curves can be done in cost <span class="math">1\\mathrm{S} + n(1\\mathrm{M} + 5\\mathrm{S})</span>). This doubling cost is lower than the fastest known doublings on twisted Edwards curves.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>With fractional <span class="math">(x, u)</span> coordinates, we represent points in <span class="math">\\mathbb{G}</span> as quadruplets <span class="math">(X: Z: U: T)</span> such that <span class="math">x = X / Z</span> and <span class="math">u = U / T</span>. With this representation, generic point addition cost is 10M, with complete formulas (for mixed addition, with one operand in affine <span class="math">(x, u)</span> coordinates, cost is 8M). Doubling cost is <span class="math">3\\mathrm{M} + 6\\mathrm{S}</span>. Just like in Jacobian <span class="math">(x, w)</span> coordinates, sequences of successive doublings can be done with a low per-doubling marginal cost (on some curves, cost of <span class="math">n</span> doublings is <span class="math">3\\mathrm{M} + n(1\\mathrm{M} + 5\\mathrm{S})</span>).</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Last but not least, the family of double-odd curves includes the GLV curves <span class="math">y^{2} = x^{3} + bx</span> (in a field <span class="math">\\mathbb{F}_q</span> with <span class="math">q = 1 \\mod 4</span>), which have been described in 2001[16]. Such curves are precisely those for which we achieve the lowest per-doubling cost (1M+5S), and they also feature an efficient endomorphism that can be used to further speed up point multiplication by a scalar<span class="math">^{7}</span>.</li>

    </ul>

    <p class="text-gray-300">Following these results, we define and implement two curves (called do255e and do255s) that operate over 255-bit fields (integers modulo <span class="math">2^{255} - 18651</span> and <span class="math">2^{255} - 3957</span>, respectively) and offer the usual "128-bit" security level. Curve do255e is a GLV curve; curve do255s is an ordinary curve with no fast endomorphism. On 64-bit x86 systems (Coffee Lake core), with curve do255e, we get generic point multiplication in less than 77k cycles (fully constant-time). This translates to the following performance for high-level operations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key pair generation: 49122 cycles (including public key encoding into 32 bytes).</li>

      <li>Key exchange: 105340 cycles (this is a multiplication of the point from the peer by our private key; this cost includes the 18220 cycles for the decoding of the peer's point from its compact 32-byte representation, and the key derivation process with SHAKE256).</li>

      <li>Signature generation: 53584 cycles.</li>

      <li>Signature verification: 111900 cycles on average (including the 18220 cycles for decoding the public key from its compact 32-byte encoding).</li>

    </ul>

    <p class="text-gray-300">We also implement our curves in ARMv6-M assembly (for the Cortex M0+), and obtain the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Key pair generation: 1.42m cycles⁹.</li>

      <li>Key exchange: 2.62m cycles.</li>

      <li>Signature generation: 1.50m cycles.</li>

      <li>Signature verification: 3.26m cycles (average).</li>

    </ul>

    <p class="text-gray-300">These performance figures compare favourably to other existing fast curves. For instance, with Curve25519 on ARM Cortex M0+, the fastest reported key exchange has cost 3.23m cycles[33].</p>

    <p class="text-gray-300">We also support a constant-time hash-to-curve process, by using a mapping function, applied twice (two 32-byte chunks are derived from the input with a suitable hash function, each chunk is mapped to a curve point, and the two points are added together). Most double-odd elliptic curves can use Elligator2[7], which is efficient. For GLV curves with <span class="math">a = 0</span>, Elligator2 is not applicable; we instead describe a novel map function applicable to such curves.</p>

    <h2 id="sec-7" class="text-2xl font-bold">1.4 Article Outline</h2>

    <p class="text-gray-300">In the next section (section 2), we study the structure of double-odd elliptic curves; in particular, we establish their equation and formally define the prime order group <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">In section 3, we establish several formulas for computing the group law in various affine coordinate systems that apply to double-odd elliptic curve. We also show that double-odd elliptic curves can be viewed as a subgroup of a twisted Edwards curve in a degree-2 field extension, and we describe some isogenies which are useful in deriving fast formulas for computing point doublings. We finally describe two maps from arbitrary field elements to curve points (one is Elligator2, the other is a new map applicable to GLV curves with equation <span class="math">y^{2} = x(x^{2} + b)</span>).</p>

    <p class="text-gray-300">⁸Technically, they have only 127-bit security level, but that’s still more than the 126 bits from Curve25519.</p>

    <p class="text-gray-300">⁹We are using “m” to denote one million.</p>

    <p class="text-gray-300">Section 4 details the application of these formulas in several fractional coordinate systems, which allow computations to proceed with only multiplications but no division (except a single one, at the end, when encoding a point into bytes). These algorithms represent the template for practical implementations.</p>

    <p class="text-gray-300">Specific parameter sets for curves do255e and do255s are defined in section 5. The criteria which led to these specific choices are explained. We also provide in this section a succinct specification of key exchange and signature algorithms using these curves.</p>

    <p class="text-gray-300">Implementation details and issues are covered in section 6. There we describe our implementation techniques for both 64-bit x86 (C code with intrinsics and some inline assembly) and ARM Cortex M0+ (mostly assembly code).</p>

    <h2 id="sec-8" class="text-2xl font-bold">2 Structure of Double-Odd Elliptic Curves</h2>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">2.1 Notations</h3>

    <p class="text-gray-300">In all the subsequent analysis, we will work in the finite field <span class="math">\\mathbb{F}_{q}</span> of cardinal <span class="math">q=p^{m}</span> for a prime <span class="math">p\\geq 5</span> (the field characteristic) and integer <span class="math">m\\geq 1</span>. Integer constants such as 4 or 27 are to be understood as elements of <span class="math">\\mathbb{F}_{q}</span> when appropriate (all such constants will be products of powers of 2 and 3 only, therefore non-zero in <span class="math">\\mathbb{F}_{q}</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">QR(K)</span> is the set of quadratic residues in field <span class="math">K</span>: $QR(K)=\\{x^{2}\\,</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\,x\\in K\\}<span class="math">. Note that </span>0\\in QR(K)<span class="math">. Most of the time, we will work with the field </span>\\mathbb{F}_{q}<span class="math"> and will use the shorthand </span>QR<span class="math"> to designate </span>QR(\\mathbb{F}_{q})$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">x</span>, <span class="math">y</span>, <span class="math">u</span>, <span class="math">w</span>… designate point coordinates, i.e. elements of <span class="math">\\mathbb{F}_{q}</span>. In this section, <span class="math">X</span> is the symbolic identifier for the generator of the ring of polynomials <span class="math">\\mathbb{F}_{q}[X]</span>, which is used for some of the demonstrations (in some other later sections, <span class="math">X</span> will be used to denote some point coordinates in various projective representations; the context should make it clear).</p>

    <h3 id="sec-10" class="text-xl font-semibold mt-8">2.2 Curve Characterization</h3>

    <p class="text-gray-300">In this section, we characterize the set of curves over <span class="math">\\mathbb{F}_{q}</span>, with order <span class="math">2r</span> for an odd integer <span class="math">r</span>.</p>

    <p class="text-gray-300">All elliptic curves on <span class="math">\\mathbb{F}_{q}</span> can be transformed through changes of variables into a <em>short Weierstraß</em>’ curve, i.e. the set of points <span class="math">(x,y)\\in\\mathbb{F}_{q}\\times\\mathbb{F}_{q}</span> such that:</p>

    <p class="text-gray-300"><span class="math">y^{2}=x^{3}+Ax+B</span></p>

    <p class="text-gray-300">for two given constants <span class="math">A</span> and <span class="math">B</span> in <span class="math">\\mathbb{F}_{q}</span>. The curve also includes an extra “point-at-infinity” which we will denote <span class="math">\\mathbb{O}</span>; that point does not have <span class="math">x</span> and <span class="math">y</span> coordinates. The curve is an Abelian group with the following addition law:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The neutral element is <span class="math">\\mathbb{O}</span>.</li>

      <li>The opposite of <span class="math">P=(x,y)</span> is <span class="math">-P=(x,-y)</span>.</li>

      <li>For any two points <span class="math">P_{1}</span> and <span class="math">P_{2}</span> such that <span class="math">P_{1}\\neq\\mathbb{O}</span>, <span class="math">P_{2}\\neq\\mathbb{O}</span> and <span class="math">P_{1}\\neq-P_{2}</span>, the line going through <span class="math">P_{1}</span> and <span class="math">P_{2}</span> will intersect the curve on a third point, which is <span class="math">-(P_{1}+P_{2})</span>. When <span class="math">P_{1}=P_{2}</span>, the line to consider is the tangent to the curve on <span class="math">P_{1}</span>.</li>

    </ul>

    <p class="text-gray-300">When adding point <span class="math">P_{1}=(x_{1},y_{1})</span> to <span class="math">P_{2}=(x_{2},y_{2})</span>, the slope of the line from <span class="math">P_{1}</span> to <span class="math">P_{2}</span> can be computed as <span class="math">\\lambda=(y_{2}-y_{1})/(x_{2}-x_{1})</span>. If <span class="math">P_{1}=P_{2}</span>, this expression is not usable; instead, we use the tangent, whose slope is <span class="math">\\lambda=(3x^{2}+A)/2y</span>.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">The three following properties are equivalent to each other:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>There is no point <span class="math">(x,y)</span> on the curve such that both <span class="math">3x^{2}+A=0</span> and <span class="math">2y=0</span>.</li>

      <li><span class="math">4A^{3}+27B^{2}\\neq 0</span>.</li>

      <li>The polynomial <span class="math">X^{3}+AX+B\\in\\mathbb{F}_{q}[X]</span> does not have a multiple root (i.e. it is relatively prime to its derivative <span class="math">3X^{2}+A</span>).</li>

    </ul>

    <p class="text-gray-300">If these properties are met, then the law is well-defined and imbues the curve with an Abelian group structure.</p>

    <p class="text-gray-300">We now want to study double-odd curves, i.e. curves whose order is equal to <span class="math">2r</span> for an odd integer <span class="math">r</span>. The fundamental theorem of finitely generated Abelian groups states that any finite Abelian group is homomorphic to:</p>

    <p class="text-gray-300"><span class="math">\\mathbb{Z}_{n_{1}}\\times\\mathbb{Z}_{n_{2}}\\times...\\times\\mathbb{Z}_{n_{k}}</span></p>

    <p class="text-gray-300">for some integers <span class="math">n_{i}</span> such that <span class="math">n_{i}</span> divides <span class="math">n_{i+1}</span> for all <span class="math">i</span> in <span class="math">1</span> to <span class="math">k-1</span>. This implies that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any Abelian group with an even order must have at least one element of order <span class="math">2</span> (if the product of all <span class="math">n_{i}</span> is even, then at least one of them is even).</li>

      <li>Any Abelian group whose order is a multiple of <span class="math">4</span> must include at least one element of order <span class="math">4</span>, or at least three elements of order <span class="math">2</span> (if the product of all <span class="math">n_{i}</span> is a multiple of <span class="math">4</span>, and <span class="math">n_{k}=2</span> mod <span class="math">4</span>, then <span class="math">n_{k-1}</span> must be even as well).</li>

    </ul>

    <p class="text-gray-300">Therefore, curves with order <span class="math">2r=2</span> mod <span class="math">4</span> are the curves which contain a single element of order <span class="math">2</span>, and no element of order <span class="math">4</span>. Elements of order <span class="math">2</span> are points <span class="math">(u,0)</span> for some integer <span class="math">u</span> which is a root of <span class="math">X^{3}+AX+B</span>. We can then write:</p>

    <p class="text-gray-300"><span class="math">X^{3}+AX+B=(X-u)(X^{2}+uX+(A+u^{2}))</span></p>

    <p class="text-gray-300">We will now apply the change of variable <span class="math">x\\mapsto x+u</span>; this is an isomorphism between curves, since it preserves lines (straight lines are mapped to straight lines) and therefore also preserves the structure induced by the group law. This turns the curve equation into:</p>

    <p class="text-gray-300"><span class="math">y^{2}=x(x^{2}+ax+b)</span></p>

    <p class="text-gray-300">for constants <span class="math">a</span> and <span class="math">b</span> such that:</p>

    <p class="text-gray-300"><span class="math">a=3u</span> <span class="math">b=A+3u^{2}</span></p>

    <p class="text-gray-300">From now on, we will consider curves using this alternate equation. Conversely, any curve using that equation can be turned back into a short Weierstraß equation by applying the <span class="math">x\\mapsto x-a/3</span> change of variable, yielding:</p>

    <p class="text-gray-300"><span class="math">A=(3b-a^{2})/3</span> <span class="math">B=a(2a^{2}-9b)/27</span></p>

    <p class="text-gray-300">The curve is well-defined if and only if there is no double root to the polynomial <span class="math">X^{3}+aX^{2}+bX</span>, i.e. if and only if the two following properties hold:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b \\neq 0</span> (otherwise, 0 would be a double root).</li>

      <li><span class="math">a^2 - 4b \\neq 0</span> (otherwise, <span class="math">X^2 + aX + B</span> would have a double root).</li>

    </ul>

    <p class="text-gray-300">The point <span class="math">N = (0, 0)</span> is part of the curve, and has order 2. This is, by construction, the only point with <span class="math">x = 0</span>. As will be detailed below (section 2.3), for any point <span class="math">P = (x, y)</span> with <span class="math">x, y \\neq 0</span>, the point <span class="math">P + N</span> has coordinates <span class="math">(b / x, -by / x^2)</span>.</p>

    <p class="text-gray-300">For the curve to have order <span class="math">2r = 2 \\mod 4</span>, <span class="math">N</span> must be the only point of order 2, i.e. there should be no other root to <span class="math">X^3 + aX^2 + bX</span>. This implies that <span class="math">a^2 - 4b \\notin QR</span>. Moreover, if <span class="math">b \\in QR</span>, then let <span class="math">c</span> be a square root of <span class="math">b</span>; in that case:</p>

    <div class="my-4 text-center"><span class="math-block">a^2 - 4b = (a + 2c)(a - 2c)</span></div>

    <p class="text-gray-300">Since <span class="math">a^2 - 4b \\notin QR</span>, then one of <span class="math">a + 2c</span> and <span class="math">a - 2c</span> must be a quadratic residue. Without loss of generality, suppose that <span class="math">a + 2c \\in QR</span>. Then, points <span class="math">(\\pm c, \\pm c\\sqrt{a + 2c})</span> are on the curve, and have order 4: each such point <span class="math">P</span> is such that <span class="math">P + N = -P</span>. Therefore, a curve of order <span class="math">2r = 2 \\mod 4</span> must have <span class="math">b \\notin QR</span>.</p>

    <p class="text-gray-300">Conversely, consider a curve with equation <span class="math">y^2 = x(x^2 + ax + b)</span> for any <span class="math">a, b \\in \\mathbb{F}_q</span> such that <span class="math">b \\neq 0</span> and <span class="math">a^2 - 4b \\neq 0</span>. Such a curve contains the point <span class="math">N = (0, 0)</span>, and thus its order is even. If its order is a multiple of 4, then either:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>there is at least another point of order 2, which implies that <span class="math">X^2 + aX + b</span> has roots in <span class="math">\\mathbb{F}_q</span>, and therefore <span class="math">a^2 - 4b \\in QR</span>; or</li>

      <li>the curve contains a point <span class="math">Q = (x_4, y_4)</span> of order 4 such that <span class="math">2Q = N</span>, which means that <span class="math">Q + N = -Q</span>, which implies that <span class="math">x_4 = b / x_4</span>, and thus <span class="math">b \\in QR</span>.</li>

    </ul>

    <p class="text-gray-300">All these facts can be summarized into the following:</p>

    <p class="text-gray-300"><strong>Characterization of double-odd elliptic curves:</strong></p>

    <p class="text-gray-300">Elliptic curves <span class="math">E</span>, over a finite field <span class="math">\\mathbb{F}_q</span> of characteristic <span class="math">p \\geq 5</span>, and whose order is equal to 2 modulo 4, are exactly, up to isomorphisms, the curves with equation:</p>

    <div class="my-4 text-center"><span class="math-block">y^2 = x(x^2 + ax + b)</span></div>

    <p class="text-gray-300">for two constants <span class="math">a, b \\in \\mathbb{F}_q</span> such that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">a^2 - 4b</span> is not a quadratic residue;</li>

      <li><span class="math">b</span> is not a quadratic residue.</li>

    </ul>

    <h2 id="sec-11" class="text-2xl font-bold">2.3 Core Addition Formulas</h2>

    <p class="text-gray-300">Let <span class="math">P_1 = (x_1, y_1)</span> and <span class="math">P_2 = (x_2, y_2)</span> two points on a curve <span class="math">E</span> of equation <span class="math">y^2 = x(x^2 + ax + b)</span>; neither point is the special point-at-infinity (O) since that point does not have coordinates. Let <span class="math">P_3 = P_1 + P_2</span>. The coordinates <span class="math">(x_3, y_3)</span> of <span class="math">P_3</span> can be obtained as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x_1 = x_2</span> and <span class="math">y_1 = -y_2</span>, then <span class="math">P_3 = \\mathbb{O}</span> (with no defined coordinates).</li>

      <li>Otherwise, if <span class="math">x_1 = x_2</span>, then <span class="math">y_1 = y_2</span> and <span class="math">P_1 = P_2</span>; define the slope of the tangent to the curve on <span class="math">P_1</span> as:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\lambda = \\frac{3x_1^2 + 2ax_1 + b}{2y_1}</span></div>

    <p class="text-gray-300">and the coordinates of <span class="math">P_3</span> are:</p>

    <div class="my-4 text-center"><span class="math-block">x_3 = \\lambda^2 - a - 2x_1</span></div>

    <div class="my-4 text-center"><span class="math-block">y_3 = \\lambda(x_1 - x_3) - y_1</span></div>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, <span class="math">x_1 \\neq x_2</span>, and we can compute the slope <span class="math">\\lambda</span> of the line from <span class="math">P_1</span> to <span class="math">P_2</span> as:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\lambda = \\frac{y_2 - y_1}{x_2 - x_1}</span></div>

    <p class="text-gray-300">and the coordinates of <span class="math">P_3</span> are:</p>

    <div class="my-4 text-center"><span class="math-block">x_3 = \\lambda^2 - a - x_1 - x_2</span></div>

    <div class="my-4 text-center"><span class="math-block">y_3 = \\lambda(x_1 - x_3) - y_1</span></div>

    <p class="text-gray-300">From these formulas, we now consider two important sub-cases. The first one is when adding a point <span class="math">P = (x, y)</span> to <span class="math">N = (0, 0)</span> (the point of order 2). If <span class="math">P \\neq N</span>, then <span class="math">x \\neq 0</span> and the slope of the line <span class="math">(PN)</span> is:</p>

    <div class="my-4 text-center"><span class="math-block">\\lambda = \\frac{y}{x}</span></div>

    <p class="text-gray-300">yielding the coordinates <span class="math">(x&#x27;, y&#x27;)</span> of <span class="math">P&#x27; = P + N</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} x&#x27; &amp;amp;= \\frac{y^2}{x^2} - a - x \\\\ &amp;amp;= \\frac{x^3 + ax^2 + bx - ax^2 - x^3}{x^2} \\\\ &amp;amp;= \\frac{b}{x} \\end{aligned}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} y&#x27; &amp;amp;= \\frac{y}{x} \\left(x - \\frac{b}{x}\\right) - y \\\\ &amp;amp;= -\\frac{by}{x^2} \\end{aligned}</span></div>

    <p class="text-gray-300">The second sub-case is that of point doubling, i.e. adding a point to itself. Let <span class="math">P = (x, y) \\neq N</span>, and <span class="math">P_2 = 2P</span>. The coordinate <span class="math">x</span> of <span class="math">P_2</span> is computed as:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} x_2 &amp;amp;= \\left(\\frac{3x^2 + 2ax + b}{2y}\\right)^2 - a - 2x \\\\ &amp;amp;= \\frac{9x^4 + 12ax^3 + (4a^2 + 6b)x^2 + 4abx + b^2}{(2y)^2} \\\\ &amp;amp;\\quad - \\frac{4ax^3 - 4a^2x^2 - 4abx}{(2y)^2} - \\frac{8x^4 - 8ax^3 - 8bx^2}{(2y)^2} \\\\ &amp;amp;= \\frac{x^4 - 2bx^2 + b^2}{(2y)^2} \\\\ &amp;amp;= \\left(\\frac{x^2 - b}{2y}\\right)^2 \\end{aligned}</span></div>

    <p class="text-gray-300">Therefore, the <span class="math">x</span> coordinate of <span class="math">2P</span>, for any point <span class="math">P \\neq \\mathbb{O}, N</span>, is a quadratic residue.</p>

    <p class="text-gray-300">14</p>

    <p class="text-gray-300">2.4 A Prime Order Group</p>

    <p class="text-gray-300">Let <span class="math">E</span> be a curve of order <span class="math">2r=2</span> mod <span class="math">4</span>; <span class="math">r</span> is an odd integer. We will now define a group of order <span class="math">r</span>, homomorphic to a subgroup of size <span class="math">r</span> in <span class="math">E</span>, with a canonical encoding as field elements. All the analysis here works for any odd integer <span class="math">r</span>, but most cryptographic applications (e.g. signatures) will require <span class="math">r</span> to be prime; we then assume that the curve parameters (<span class="math">\\mathbb{P}_{q}</span>, <span class="math">a</span> and <span class="math">b</span>) are chosen so that <span class="math">r</span> is a prime of appropriate length.</p>

    <p class="text-gray-300">Let <span class="math">E[r]</span> be the set of points of <span class="math">r</span>-torsion in <span class="math">E</span>, i.e. the points which, multiplied by <span class="math">r</span>, yield <span class="math">\\mathbb{O}</span>. This is a subgroup of <span class="math">E</span>. In fact, any point on <span class="math">E</span> can be decomposed into a sum of two points <span class="math">P_{r}+P_{t}</span>, where <span class="math">P_{r}\\in E[r]</span> and <span class="math">P_{t}\\in\\{\\mathbb{O},N\\}</span>; points <span class="math">P_{r}</span> and <span class="math">P_{t}</span> can be computed as:</p>

    <p class="text-gray-300"><span class="math">P_{r}=(r+1)P</span> <span class="math">P_{t}=rP</span></p>

    <p class="text-gray-300">This decomposition is unique. Note that <span class="math">N\\notin E[r]</span>.</p>

    <p class="text-gray-300">Suppose that <span class="math">P=(x,y)\\in E[r]</span> and <span class="math">P\\neq\\mathbb{O}</span>; consider the line that goes from <span class="math">N</span> to <span class="math">P</span>. Since <span class="math">N</span> is the only point on the curve with <span class="math">x=0</span>, and also the only point on the curve with <span class="math">y=0</span>, the line <span class="math">(PN)</span> has a defined non-zero slope <span class="math">w=y/x</span>. This line, by construction, intersects the curve at a third point which is <span class="math">-P+N</span>. In particular, <span class="math">-P+N\\notin E[r]</span>. Similarly, if we had started from <span class="math">P^{\\prime}\\notin E[r]</span> and <span class="math">P^{\\prime}\\neq N</span>, then the line <span class="math">(P^{\\prime}N)</span> has slope <span class="math">w^{\\prime}=y^{\\prime}/x^{\\prime}</span> and intersects the curve on a third point, which is <span class="math">-P^{\\prime}+N</span>, and which is part of <span class="math">E[r]</span>. Thus, any given slope <span class="math">w\\neq 0</span> may correspond to only two points on the curve, exactly one of which is in <span class="math">E[r]</span>.</p>

    <p class="text-gray-300">If <span class="math">P\\in E[r]</span>, then <span class="math">P=P_{r}=(r+1)P=2((r+1)/2)P</span>: every point in <span class="math">E[r]</span> is the double of some other point. As we saw in section 2.3, this implies that the <span class="math">x</span> coordinate of any point <span class="math">P\\in E[r]</span> (<span class="math">P\\neq\\mathbb{O}</span>) is a quadratic residue. Conversely, for any point <span class="math">P^{\\prime}=(x^{\\prime},y^{\\prime})\\notin E[r]</span> (and <span class="math">P^{\\prime}\\neq N</span>), we saw that <span class="math">P^{\\prime}=P+N</span> with <span class="math">x^{\\prime}=b/x</span>, for some point <span class="math">P</span> which will then be a point of <span class="math">r</span>-torsion. Thus, <span class="math">x\\in QR</span>. Since <span class="math">b\\notin QR</span>, it follows that <span class="math">x^{\\prime}\\notin QR</span>. These properties lead to the following important fact:</p>

    <p class="text-gray-300">Characterization of <span class="math">r</span>-torsion points</p>

    <p class="text-gray-300">For any point <span class="math">P=(x,y)\\in E</span> such that <span class="math">P\\neq\\mathbb{O},N</span>, <span class="math">P\\in E[r]</span> if and only if <span class="math">x\\in QR</span>.</p>

    <p class="text-gray-300">We will now define a group of order <span class="math">r</span> whose elements can be uniquely encoded to, and decoded from, field elements. The group will be homomorphic to <span class="math">E[r]</span>, but we choose to represent elements by points which are not in <span class="math">E[r]</span> for reasons which will be explained below. Here is the group definition:</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Elements of <span class="math">\\mathbb{G}</span> are the curve points which are not in <span class="math">E[r]</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbb{G} = \\{P + N \\mid P \\in E[r]\\}</span></div>

    <p class="text-gray-300">These are exactly the points of <span class="math">E</span> whose <span class="math">x</span> coordinate is either 0 (for point <span class="math">N</span>) or not a quadratic residue in <span class="math">\\mathbb{F}_q</span>.</p>

    <p class="text-gray-300">For <span class="math">P_1 + N</span> and <span class="math">P_2 + N</span> in <span class="math">\\mathbb{G}</span>, the group law yields:</p>

    <div class="my-4 text-center"><span class="math-block">(P_1 + N) * (P_2 + N) = (P_1 + P_2) + N</span></div>

    <p class="text-gray-300">The neutral point is <span class="math">N</span>. The opposite of <span class="math">P_1 + N</span> is <span class="math">-P_1 + N = -(P_1 + N)</span>.</p>

    <p class="text-gray-300">Elements of <span class="math">\\mathbb{G}</span> can be encoded into field elements with the following map:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\phi: \\quad \\mathbb{G} \\longrightarrow \\mathbb{F}_q \\\\ (P_1 + N) \\longmapsto 0 \\quad \\text{if } (P_1 + N) = N \\\\ y/x \\quad \\text{if } (P_1 + N) = (x, y) \\neq N \\\\ \\end{array}</span></div>

    <p class="text-gray-300">As we saw above, this map is injective: any value <span class="math">w = y/x \\neq 0</span> corresponds to only two points on the curve, only one of which being in <span class="math">\\mathbb{G}</span>. The decoding process, from a given <span class="math">w \\in \\mathbb{F}_q</span>, is as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">w = 0</span>, then the point is <span class="math">N</span>.</li>

      <li>Otherwise, consider the equation <span class="math">x^2 - (w^2 - a)x + b = 0</span> (this is a rewriting of the curve equation, replacing <span class="math">y</span> with <span class="math">wx</span>, and dividing by <span class="math">x</span>). This is a quadratic equation in <span class="math">x</span>, whose discriminant is <span class="math">\\Delta = (w^2 - a)^2 - 4b</span>; note that <span class="math">\\Delta \\neq 0</span> (otherwise, it would imply that <span class="math">b \\in QR</span>). If <span class="math">\\Delta \\notin QR</span>, then there is no solution (the provided <span class="math">w</span> is not the image of a group element by <span class="math">\\phi</span>); otherwise, there are two distinct solutions:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">x = \\frac{w^2 - a \\pm \\sqrt{\\Delta}}{2}</span></div>

    <p class="text-gray-300">The two solutions are such that their product is <span class="math">b</span>, which is not a quadratic residue; thus, exactly one of the solutions is not a quadratic residue: this is the <span class="math">x</span> coordinate of the point <span class="math">P + N</span> such that <span class="math">\\phi(P + N) = w</span>. The <span class="math">y</span> coordinate of <span class="math">P + N</span> is obtained as: <span class="math">y = xw</span>.</p>

    <p class="text-gray-300">We could have defined <span class="math">\\mathbb{G}</span> to be <span class="math">E[r]</span>, using point addition as group law, and with the same mapping to field elements (decoding would then have chosen the solution <span class="math">x</span> which is a quadratic residue). However, we prefer the formulation above for the following reasons:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Every element of <span class="math">\\mathbb{G}</span> has defined <span class="math">(x, y)</span> coordinates. The neutral element is <span class="math">N = (0, 0)</span>; the curve point-at-infinity <span class="math">\\mathbb{O}</span> is not in <span class="math">\\mathbb{G}</span>.</li>

      <li>The group law can be computed as:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">(P_1 + N) * (P_2 + N) = (P_1 + P_2) + N = P_1 + (P_2 + N)</span></div>

    <p class="text-gray-300">Notice that <span class="math">P_1 \\in E[r]</span> but <span class="math">P_2 + N \\notin E[r]</span>. Therefore, it cannot happen that <span class="math">P_1 = P_2 + N</span>. This means that addition formulas can be applied without encountering the special case of adding a point to itself. This will help in establishing unified and complete formulas, as will be detailed in section 3.</p>

    <p class="text-gray-300">2.5 Curve Isomorphisms</p>

    <p class="text-gray-300">For any non-zero value <span class="math">\\varepsilon</span> in <span class="math">\\mathbb{F}_{q}</span>, the mapping <span class="math">(x,y)\\mapsto(x^{\\prime},y^{\\prime})=(x\\varepsilon^{2},y\\varepsilon^{3})</span> is an isomorphism from curve <span class="math">y^{2}=x(x^{2}+ax+b)</span> to curve <span class="math">y^{\\prime 2}=x^{\\prime}(x^{\\prime 2}+(a\\varepsilon^{2})x^{\\prime}+(b\\varepsilon^{4}))</span> (this is the usual isomorphism on Weierstraß curves, applied to our curve equation).</p>

    <p class="text-gray-300">The <span class="math">j</span>-invariant of an elliptic curve is a quantity which is conserved by such isomorphisms. For a short Weierstraß curve <span class="math">y^{2}=x^{3}+Ax+B</span>, the <span class="math">j</span>-invariant is defined as:</p>

    <p class="text-gray-300"><span class="math">j=1728\\frac{4A^{3}}{4A^{3}+27B^{2}}</span></p>

    <p class="text-gray-300">In our case, for curves <span class="math">y^{2}=x(x^{2}+ax+b)</span>, we obtain:</p>

    <p class="text-gray-300"><span class="math">j=\\frac{256(3b-a^{2})^{3}}{b^{2}(4b-a^{2})}</span></p>

    <p class="text-gray-300">When <span class="math">j\\neq 0</span> and <span class="math">j\\neq 1728</span>, there are exactly two curves (up to isomorphism) that have this <span class="math">j</span>-invariant, and they are quadratic twists of each other (i.e. they become the same curve when lifted into the extension field <span class="math">\\mathbb{F}_{q^{2}}</span>). For curve <span class="math">y^{2}=x(x^{2}+ax+b)</span>, the quadratic twist has equation <span class="math">y^{2}=x(x^{2}-ax+b)</span>. If a curve has order <span class="math">2r</span>, then its twist has order <span class="math">2q+2-2r</span>, which is then also equal to <span class="math">2</span> modulo <span class="math">4</span>.</p>

    <p class="text-gray-300">The case <span class="math">j=0</span> is not very interesting to us. Indeed, such a curve is isomorphic to the short Weierstraß curve <span class="math">y^{2}=x^{3}+B</span> for some <span class="math">B\\neq 0</span>. If <span class="math">q=1</span> mod <span class="math">3</span>, then such a curve has either no point of order <span class="math">2</span>, or three distinct points of order <span class="math">2</span>; in both cases, the curve order cannot be equal to <span class="math">2</span> modulo <span class="math">4</span>. If <span class="math">q=2</span> mod <span class="math">3</span>, the curve is supersingular with order exactly <span class="math">q+1</span>; this can be equal to <span class="math">2</span> modulo <span class="math">4</span> if <span class="math">q=1</span> mod <span class="math">4</span> (which, combined with <span class="math">q=2</span> mod <span class="math">3</span>, implies <span class="math">q=5</span> mod <span class="math">12</span>). However, such a supersingular curve has embedding degree <span class="math">2</span>: the Weil pairing maps discrete logarithm on the curve into the discrete logarithm problem on the multiplicative subgroup of <span class="math">\\mathbb{F}_{q^{2}}</span>, for which sub-exponential algorithms are known<em>[28]</em>. In order to obtain a decent level of security, one would have to make <span class="math">q</span> quite large (at least <span class="math">1024</span> bits), implying poor computing performance and large values.</p>

    <p class="text-gray-300">Curves with <span class="math">j=1728</span> are more useful: this situation is obtained with <span class="math">a=0</span>. Note that the condition <span class="math">a^{2}-4b\\notin QR</span> then implies that <span class="math">-b\\notin QR</span>. Since we also need <span class="math">b\\notin QR</span>, a curve of order <span class="math">2</span> modulo <span class="math">4</span> can have <span class="math">j=1728</span> only if <span class="math">q=1</span> mod <span class="math">4</span> (indeed, if <span class="math">q=3</span> mod <span class="math">4</span>, then the curve would be supersingular and its order would be a multiple of <span class="math">4</span>). A non-supersingular curve with <span class="math">j=1728</span> admits one quadratic twist and two quartic twists that share the same <span class="math">j</span>-invariant; if <span class="math">\\zeta</span> is a non-quadratic residue in <span class="math">\\mathbb{F}_{q}</span>, then the twists of curve <span class="math">y^{2}=x(x^{2}+b)</span> can be obtained as:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>quadratic twist: <span class="math">y^{2}=x(x^{2}+b_{s}^{\\sigma 2})</span></li>

      <li>quartic twists: <span class="math">y^{2}=x(x^{2}+b_{\\epsilon}^{\\sigma})</span> and <span class="math">y^{2}=x(x^{2}+b_{\\epsilon}^{\\sigma 3})</span></li>

    </ul>

    <p class="text-gray-300">This works from any <span class="math">\\zeta\\notin QR</span>, in particular <span class="math">\\zeta=b</span>. Note that if <span class="math">b\\notin QR</span>, then <span class="math">b_{\\epsilon}^{\\sigma}</span> and <span class="math">b_{\\epsilon}^{\\sigma 3}</span> are quadratic residues, which means that the quartic twists are not curves with order <span class="math">2</span> modulo <span class="math">4</span>.</p>

    <p class="text-gray-300">Curves with <span class="math">j=1728</span> are a type of GLV curve<em>[16]</em>: the map <span class="math">(x,y)\\mapsto(-x,\\eta y)</span>, for <span class="math">\\eta</span> a primitive <span class="math">4</span>-th root of unity in <span class="math">\\mathbb{F}_{q}</span>, can be very efficiently computed, and it is an endomorphism of the curve, corresponding to multiplication of the point by a certain constant <span class="math">\\mu</span>. This endomorphism can be used to speed up point multiplication; this will be explained in more details in section 6.2.</p>

    <p class="text-gray-300">3 Formulas</p>

    <p class="text-gray-300">In this section, we derive several addition formulas for our group <span class="math">\\mathbb{G}</span>, defined in section 2.4, using various representations of coordinates. We still stick to “affine” coordinates; practical implementations would rather use one of the fractional systems which will be detailed in section 4. Thus, this section is still concerned with laying out mathematical foundations.</p>

    <p class="text-gray-300">We use the following conventions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Group element <span class="math">P_{1}+N</span> has coordinates <span class="math">(x_{1},y_{1})</span>. Take care that <span class="math">(x_{1},y_{1})</span> are the coordinates of <span class="math">P_{1}+N</span>, not of <span class="math">P_{1}</span>.</li>

      <li>We seek formulas to compute the coordinates <span class="math">(x_{3},y_{3})</span> of point <span class="math">P_{3}+N</span>, which is equal to <span class="math">(P_{1}+N)*(P_{2}+N)</span>.</li>

      <li>When explicitly considering element doubling (applying the law on a point and itself), the point <span class="math">P+N</span> has coordinates <span class="math">(x,y)</span>, and its double <span class="math">2P+N</span> has coordinates <span class="math">(x^{\\prime},y^{\\prime})</span>.</li>

    </ul>

    <p class="text-gray-300">The group law in <span class="math">\\mathbb{G}</span> is denoted with the “<span class="math">*</span>” operator; in the rest of the article, we will call it “addition in <span class="math">\\mathbb{G}</span>”. Conversely, in the few instances where we refer to the traditional addition of curve points, we will use the expression “addition on the curve”.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">3.1 On Formula Completeness</h3>

    <p class="text-gray-300">In all generality, formulas that work for most input points may have exceptional cases, for which they do not return the right result. Following the terminology in <em>[8]</em>, we will say that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Formulas with no exceptional case are <em>complete</em>.</li>

      <li>Formulas whose only exceptional cases are such that one of the input points, or the output point, is the group neutral element (<span class="math">N</span>), are <em>unified</em>.</li>

    </ul>

    <p class="text-gray-300">On standard Weierstraß curves, with affine <span class="math">(x,y)</span> coordinates, the formulas for adding two points together are neither complete nor unified, since they must make a special case for adding a point to itself. Thanks to our definition of the group <span class="math">\\mathbb{G}</span> and its law, we will naturally avoid such issues, since we compute the addition of <span class="math">P_{1}+N</span> and <span class="math">P_{2}+N</span> in <span class="math">\\mathbb{G}</span> as the addition on the curve of points <span class="math">P_{1}</span> and <span class="math">P_{2}+N</span>; these two points are always distinct since <span class="math">P_{1}\\in E[r]</span> but <span class="math">P_{2}+N\\notin E[r]</span>. All our formulas are thus always unified, and we will see that some of them are complete.</p>

    <p class="text-gray-300">Non-unified formulas can be a problem for secure implementation: correct handling of exceptional cases will imply either side channels (some of the code will be executed conditionally, depending on the input points) or substantial execution overhead (the general and the exceptional cases being both executed systematically). In some cases, it can be shown that operations cannot be exceptional. For instance, suppose that a routine multiplies a given curve point by a scalar, the point being part of a curve of prime order and different from the point-at-infinity, and the scalar being non-zero and lower than the curve order (this is the classic situation of a Diffie-Hellman key exchange). In that situation, a classic double-and-add algorithm will involve explicit doublings, and extra additions; it can be shown that none of the extra additions can be a doubling, and therefore a routine that cannot handle that exceptional case is usable. However, most implementations of point multiplications will improve the double-and-add algorithm with window optimizations, and will furthermore apply Booth recoding on the scalar<em>[9]</em> to reduce the size of the individual digits; in that case, it is no longer true that</p>

    <p class="text-gray-300">all point additions are exception-less. More generally, this kind of analysis depends on how the point addition is used, and cannot necessarily be extended to all protocols.</p>

    <p class="text-gray-300">Unified formulas avoid most of these issues. A complete routine can be made out of unified formulas, by handling the remaining exceptional cases with a pair of constant-time conditional copy operations (adding an element with the neutral element should yield back the first element). Using complete formulas can avoid even such conditional copies. Generally speaking, complete routines are sufficient for most secure implementations; complete formulas are helpful in some specific contexts, such as the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Some hardware platforms may provide efficient accelerators for arithmetic operations on field elements, but not for making efficient constant-time comparisons and conditional copies.</li>

      <li>In some homomorphic encryption or zero-knowledge proof systems, coordinates are not directly accessible, but manipulated through a blinding layer that allows arithmetic operations on field elements, but not constant-time conditional copies.</li>

    </ul>

    <p class="text-gray-300">Additionally, in some cases, formulas which are only unified with affine coordinates become complete when used with some fractional coordinate systems, leading to complete algorithms (and implementations). Some such examples will be seen in section 4.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">3.2 Affine (x, y) Coordinates</h3>

    <p class="text-gray-300">Let <span class="math">P_{1}+N=(x_{1},y_{1})</span>, <span class="math">P_{2}+N=(x_{2},y_{2})</span>, and their sum (in <span class="math">\\mathbb{G}</span>) <span class="math">P_{3}+N=(x_{3},y_{3})</span>. We first suppose that neither <span class="math">P_{1}+N</span> nor <span class="math">P_{2}+N</span> is the neutral element <span class="math">N</span>; thus, <span class="math">x_{1},y_{1},x_{2}</span> and <span class="math">y_{2}</span> are non-zero. The curve point <span class="math">P_{2}</span> has coordinates <span class="math">(b/x_{2},-by_{2}/x_{2}^{2})</span>. The slope of the line from <span class="math">P_{1}+N</span> to <span class="math">P_{2}</span> is:</p>

    <p class="text-gray-300"><span class="math">\\lambda</span> <span class="math">=\\frac{\\frac{-by_{2}}{x_{2}^{2}}-y_{1}}{\\frac{b}{x_{2}}-x_{1}}</span> <span class="math">=\\frac{x_{1}x_{2}^{2}y_{1}+bx_{1}y_{2}}{x_{1}x_{2}(x_{1}x_{2}-b)}</span></p>

    <p class="text-gray-300">The coordinates of <span class="math">P_{3}+N</span> are then:</p>

    <p class="text-gray-300"><span class="math">x_{3}</span> <span class="math">=\\lambda^{2}-a-x_{1}-\\frac{b}{x_{2}}</span> <span class="math">y_{3}</span> <span class="math">=\\lambda(x_{1}-x_{3})-y_{1}</span></p>

    <p class="text-gray-300">Applying the expression of <span class="math">\\lambda</span> above, and simplifying (replacing <span class="math">y_{1}^{2}=x_{1}^{3}+ax_{1}^{2}+bx_{1}</span>, and similarly for <span class="math">y_{2}^{2}</span>, and taking into account that <span class="math">x_{1}x_{2}\\neq 0</span>), yields the following formulas:</p>

    <p class="text-gray-300">Addition in <span class="math">\\mathbb{G}\\left((x,y)\\text{ coordinates, complete}\\right)</span></p>

    <p class="text-gray-300"><span class="math">x_{3}</span> <span class="math">=\\frac{b((x_{1}+x_{2})(x_{1}x_{2}+b)+2ax_{1}x_{2}+2y_{1}y_{2})}{(x_{1}x_{2}-b)^{2}}</span> <span class="math">y_{3}</span> <span class="math">=\\frac{b(2a(x_{1}y_{2}+x_{2}y_{1})(x_{1}x_{2}+b)+(x_{1}^{2}y_{2}+x_{2}^{2}y_{1})(x_{1}x_{2}+3b)+(y_{1}+y_{2})(3bx_{1}x_{2}+b^{2}))}{-(x_{1}x_{2}-b)^{3}}</span></p>

    <p class="text-gray-300">These formulas are complete: they are unified by construction, and it is easily seen that if <span class="math">(x_{1},y_{1})=(0,0)</span> or <span class="math">(x_{2},y_{2})=(0,0)</span>, the correct result is obtained.</p>

    <p class="text-gray-300">Noticing that:</p>

    <p class="text-gray-300"><span class="math">\\frac{(y_{1}x_{2}+y_{2}x_{1})^{2}}{x_{1}x_{2}}=(x_{1}+x_{2})(x_{1}x_{2}+b)+2ax_{1}x_{2}+2y_{1}y_{2}</span></p>

    <p class="text-gray-300">and that:</p>

    <p class="text-gray-300"><span class="math">(y_{1}x_{2}+y_{2}x_{1})((y_{1}y_{2}+ax_{1}x_{2})(x_{1}x_{2}+b)+2bx_{1}x_{2}(x_{1}+x2))=</span> <span class="math">x_{1}x_{2}(2a(x_{1}y_{2}+x_{2}y_{1})(x_{1}x_{2}+b)+(x_{1}^{2}y_{2}+x_{2}^{2}y_{1})(x_{1}x_{2}+3b)+(y_{1}+y_{2})(3bx_{1}x_{2}+b^{2}))</span></p>

    <p class="text-gray-300">we can simplify the formulas into:</p>

    <p class="text-gray-300"><span class="math">x_{3}=\\frac{b(y_{1}x_{2}+y_{2}x_{1})^{2}}{x_{1}x_{2}(x_{1}x_{2}-b)^{2}}</span> <span class="math">y_{3}=\\frac{-b(y_{1}x_{2}+y_{2}x_{1})((y_{1}y_{2}+ax_{1}x_{2})(x_{1}x_{2}+b)+2bx_{1}x_{2}(x_{1}+x2))}{x_{1}x_{2}(x_{1}x_{2}-b)^{3}}</span></p>

    <p class="text-gray-300">However, these alternate formulas are only unified, not complete, since setting <span class="math">x_{1}=0</span> or <span class="math">x_{2}=0</span> implies an undefined division by zero.</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">3.3 Affine (x, w) Coordinates</h3>

    <p class="text-gray-300">Since group elements are encoded as the ratio <span class="math">w=y/x</span>, we may try to use <span class="math">w</span> itself as a coordinate. In (x, w) coordinates, the curve equation is:</p>

    <p class="text-gray-300"><span class="math">w^{2}x=x^{2}+ax+b</span></p>

    <p class="text-gray-300">The neutral point <span class="math">N</span> cannot be represented in (x, w) coordinates: that point does not have a defined <span class="math">w</span> coordinate. Therefore, we will not obtain complete formulas as long as we keep to affine representation (we may still get complete formulas when switching to fractional representations, e.g. Jacobian coordinates; this will be investigated in section 4.1).</p>

    <p class="text-gray-300">(x, w) coordinates have a number of properties which are useful for deriving formulas:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>No point with defined (x, w) coordinates has <span class="math">x=0</span> or <span class="math">w=0</span>.</li>

      <li>If point <span class="math">P\\neq\\mathbb{O}</span>, <span class="math">N</span> has coordinates (x, w), then:</li>

    </ul>

    <p class="text-gray-300"><span class="math">-P=(x,-w)</span> <span class="math">P+N=(b/x,-w)</span> <span class="math">-P+N=(b/x,w)</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x\\neq 0</span>, then <span class="math">x+b/x=w^{2}-a</span> and <span class="math">x-b/x=2x+a-w^{2}</span>.</li>

    </ul>

    <p class="text-gray-300">We now derive formulas in (x, w) coordinates. We consider two group elements <span class="math">P_{1}+N=(x_{1},w_{1})</span> and <span class="math">P_{2}+N=(x_{2},w_{2})</span>, and their sum <span class="math">P_{3}+N=(x_{3},w_{3})</span> in the group <span class="math">\\mathbb{O}</span>. For now, we assume that <span class="math">P_{1}+N\\neq N</span>, <span class="math">P_{2}+N\\neq N</span>, and <span class="math">P_{3}+N\\neq N</span>. This implies that <span class="math">x_{1},x_{2},w_{1},w_{2}</span></p>

    <p class="text-gray-300">and <span class="math">w_{1} + w_{2}</span> are non-zero. Using the alternate formulas from the previous section, replacing each <span class="math">y</span> with <span class="math">xw</span> and simplifying fractions by removing common non-zero factors, we obtain the following unified formulas (they are not complete since <span class="math">N</span> does not have a well-defined <span class="math">w</span> coordinate).</p>

    <p class="text-gray-300"><strong>Addition in</strong> <span class="math">\\mathbb{G}\\left((x,w)\\text{ coordinates, unified}\\right)</span></p>

    <div class="my-4 text-center"><span class="math-block">x _ {3} = \\frac {b x _ {1} x _ {2} (w _ {1} + w _ {2}) ^ {2}}{(x _ {1} x _ {2} - b) ^ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">w _ {3} = - \\frac {(w _ {1} w _ {2} + a) (x _ {1} x _ {2} + b) + 2 b (x _ {1} + x _ {2})}{(w _ {1} + w _ {2}) (x _ {1} x _ {2} - b)}</span></div>

    <p class="text-gray-300">When adding a point to itself, the generic formulas above can be simplified. Suppose that we want to compute <span class="math">2P + N = (x&#x27;, w&#x27;)</span> from <span class="math">P + N = (x, w)</span>; the generic formulas become:</p>

    <div class="my-4 text-center"><span class="math-block">x ^ {\\prime} = \\frac {4 b x ^ {2} w ^ {2}}{(x ^ {2} - b) ^ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {\\prime} = - \\frac {(w ^ {2} + a) (x ^ {2} + b) + 4 b x}{2 w (x ^ {2} - b)}</span></div>

    <p class="text-gray-300">Dividing numerator and denominator in both fractions by <span class="math">x</span>, and replacing <span class="math">(x^2 + b) / x</span> and <span class="math">(x^2 - b) / x</span> with <span class="math">w^2 - a</span> and <span class="math">2x + a - w^2</span>, respectively, yields the following doubling formulas:</p>

    <p class="text-gray-300"><strong>Doubling in</strong> <span class="math">\\mathbb{G}\\left((x,w)\\text{ coordinates, unified}\\right)</span></p>

    <div class="my-4 text-center"><span class="math-block">x ^ {\\prime} = \\frac {4 b w ^ {2}}{(2 x + a - w ^ {2}) ^ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">w ^ {\\prime} = - \\frac {w ^ {4} + (4 b - a ^ {2})}{2 w (2 x + a - w ^ {2})}</span></div>

    <p class="text-gray-300">Note that if <span class="math">P + N \\neq N</span>, then <span class="math">2P + N \\neq N</span>, since we work in a group <span class="math">\\mathbb{G}</span> of odd order. Therefore, the only exceptional case to worry about for doublings is when the input point is already the neutral point <span class="math">N</span>.</p>

    <h2 id="sec-16" class="text-2xl font-bold">3.4 Mapping to a Twisted Edwards Curve Subgroup</h2>

    <p class="text-gray-300">Double-odd curves are not equivalent to twisted Edwards curves over the same field, since the order of a twisted Edwards curve is always a multiple of 4. However, a double-odd curve can be mapped into a subgroup of a twisted Edwards curve in a field extension of degree 2, using the formulas described in this section.</p>

    <p class="text-gray-300">Let <span class="math">i</span> such that <span class="math">i^2 = b</span>. Since <span class="math">b \\notin QR</span>, <span class="math">i</span> cannot exist in <span class="math">\\mathbb{F}_{q^i}</span> therefore, <span class="math">i</span> defines a field extension <span class="math">\\mathbb{F}_{q^2}</span>. An element <span class="math">v \\in \\mathbb{F}_{q^2}</span> can be uniquely written as:</p>

    <div class="my-4 text-center"><span class="math-block">v = \\Re (v) + i \\Im (v)</span></div>

    <p class="text-gray-300">for two values <span class="math">\\Re(v)</span> and <span class="math">\\Im(v)</span> in <span class="math">\\mathbb{F}_q</span>, which we will call, by analogy with complex numbers, the "real part" and "imaginary part" of the value <span class="math">v</span>.</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">For a point <span class="math">P = (x, y) \\in E</span>, we define the two coordinates <span class="math">u</span> and <span class="math">v</span> as follows:</p>

    <div class="my-4 text-center"><span class="math-block">u = \\frac{x}{y}</span></div>

    <div class="my-4 text-center"><span class="math-block">v = \\frac{x - i}{x + i}</span></div>

    <p class="text-gray-300">If <span class="math">P = \\mathcal{N}</span>, the fraction <span class="math">x / y</span> is undefined, and we set <span class="math">u = 0</span>. In that case, <span class="math">v = -1</span>. If <span class="math">P = \\mathbb{O}</span>, we set <span class="math">u = 0</span> and <span class="math">v = 1</span>. Note that:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">u \\in \\mathbb{F}_q</span> for all points <span class="math">P \\in \\mathbb{G}</span>; moreover, <span class="math">u \\neq 0</span> when <span class="math">P \\neq \\mathcal{N}, \\mathbb{O}</span>.</li>

      <li><span class="math">v \\notin \\mathbb{F}_q</span> except when <span class="math">P = \\mathcal{N}</span> or <span class="math">\\mathbb{O}</span>, in which case <span class="math">v = \\pm 1</span>.</li>

    </ul>

    <p class="text-gray-300">This transformation is reversible; the original <span class="math">x</span> and <span class="math">y</span> can be recomputed with:</p>

    <div class="my-4 text-center"><span class="math-block">x = i \\frac{1 + v}{1 - v}</span></div>

    <div class="my-4 text-center"><span class="math-block">y = \\frac{x}{u}</span></div>

    <p class="text-gray-300">(and the mapping to <span class="math">\\mathcal{N}</span> or <span class="math">\\mathbb{O}</span> when <span class="math">v \\in \\mathbb{F}_q</span>.)</p>

    <p class="text-gray-300">Note that if <span class="math">P \\in E</span> is mapped to <span class="math">(u, v)</span>, then <span class="math">P + \\mathcal{N}</span> is mapped to <span class="math">(-u, -v)</span>. This is true for all points of <span class="math">E</span>, including <span class="math">\\mathcal{N}</span> and <span class="math">\\mathbb{O}</span>.</p>

    <p class="text-gray-300">Replacing <span class="math">x</span> and <span class="math">y</span> with their expressions in <span class="math">u</span> and <span class="math">v</span> into the curve equation <span class="math">y^{2} = x(x^{2} + ax + b)</span> leads to the following:</p>

    <div class="my-4 text-center"><span class="math-block">(a + 2i)u^{2} + v^{2} = 1 + (a - 2i)u^{2}v^{2}</span></div>

    <p class="text-gray-300">which is the equation of a twisted Edwards curve.</p>

    <p class="text-gray-300">Twisted Edwards curves are defined and analyzed in [5]. If points <span class="math">P_{1}</span> and <span class="math">P_{2}</span> have coordinates <span class="math">(u_{1}, v_{1})</span> and <span class="math">(u_{2}, v_{2})</span>, respectively, and <span class="math">P_{1} + P_{2}</span> has coordinates <span class="math">(\\hat{u}, \\hat{v})</span>, then:</p>

    <div class="my-4 text-center"><span class="math-block">\\hat{u} = \\frac{u_{1}v_{2} + u_{2}v_{1}}{1 + (a - 2i)u_{1}u_{2}v_{1}v_{2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\hat{v} = \\frac{v_{1}v_{2} - (a + 2i)u_{1}u_{2}}{1 - (a - 2i)u_{1}u_{2}v_{1}v_{2}}</span></div>

    <p class="text-gray-300">Take care that we are here talking about point addition, i.e. not the composition law in our group <span class="math">\\mathbb{G}</span>. We will investigate the formulas for <span class="math">\\mathbb{G}</span> later on.</p>

    <p class="text-gray-300">[5] shows that these formulas are complete provided that the first curve equation constant (here <span class="math">a - 2i</span>) is a quadratic residue, and the second constant (here <span class="math">a + 2i</span>) is not. However, this is not the case here; indeed, none of the four values <span class="math">\\pm a \\pm 2i</span> can be a quadratic residue in <span class="math">\\mathbb{F}_{q^2}</span>, because that would imply that <span class="math">a^2 - 4b \\in QR(\\mathbb{F}_q)</span>, which would be incompatible with our initial curve construction.</p>

    <p class="text-gray-300">We can still show that the formulas, while not necessarily complete in general, are still complete for the subset of points which are the mapping of points from our original curve <span class="math">E</span>. As explained in [5], the twisted Edwards curve is isomorphic to a non-twisted curve by the mapping <span class="math">u \\mapsto u / \\sqrt{a - 2i}</span>; since <span class="math">a - 2i \\notin QR(\\mathbb{F}_{q^2})</span>, such a mapping requires lifting the curve into another field extension, this time into <span class="math">\\mathbb{F}_{q^4}</span>. Then, the demonstration in [8] (section</p>

    <p class="text-gray-300">22</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>applies and shows that the formulas are correct for all inputs such that the denominators <span class="math">(1 \\pm (a - 2i)u_1u_2v_1v_2</span> in our case) are non-zero. Thus, we only need to prove that there are no points <span class="math">(x_1, y_1)</span> and <span class="math">(x_2, y_2)</span> in <span class="math">E</span>, such that their mappings into coordinates <span class="math">(u_1, v_1)</span> and <span class="math">(u_2, v_2)</span> would lead to <span class="math">1 \\pm (a - 2i)u_1u_2v_1v_2 = 0</span>.</li>

    </ol>

    <p class="text-gray-300">First, notice that if <span class="math">P_{1} = N</span> or <span class="math">\\mathbb{O}</span>, then <span class="math">u_{1} = 0</span> and <span class="math">1 \\pm (a - 2i)u_{1}u_{2}v_{1}v_{2} = 1 \\neq 0</span>. This is also the case if <span class="math">P_{2} = N</span> or <span class="math">\\mathbb{O}</span>. We can thus restrict ourselves to the case where <span class="math">P_{1} \\neq N, \\mathbb{O}</span> and <span class="math">P_{2} \\neq N, \\mathbb{O}</span>, i.e. <span class="math">x_{1}, x_{2}, u_{1}</span> and <span class="math">u_{2}</span> are non-zero. Replacing <span class="math">v</span> with <span class="math">(x - i) / (x + i)</span>, we obtain that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathcal {D} ((a - 2 i) u _ {1} u _ {2} v _ {1} v _ {2}) = \\frac {- 2 u _ {1} u _ {2} x _ {1} x _ {2}}{(x _ {1} ^ {2} - b) (x _ {2} ^ {2} - b)} \\left(\\frac {1}{u _ {1} ^ {2} u _ {2} ^ {2}} - (a ^ {2} - 4 b)\\right)</span></div>

    <p class="text-gray-300">which is non-zero, since <span class="math">a^2 - 4b \\notin QR(\\mathbb{F}_q)</span>. Therefore, the denominators can never be zero for the points mapped from <span class="math">E</span>, and the formulas are complete for these points.</p>

    <h2 id="sec-17" class="text-2xl font-bold">3.5 Affine <span class="math">(x, u)</span> Coordinates</h2>

    <p class="text-gray-300">We now use the twisted Edwards curve formulas to derive additional formulas for <span class="math">\\mathbb{G}</span>. As previously, we consider two points <span class="math">P_{1} + N</span> and <span class="math">P_{2} + N</span> in <span class="math">\\mathbb{G}</span>, and their sum (in <span class="math">\\mathbb{G}</span>) <span class="math">P_{3} + N = (P_{1} + N) * (P_{2} + N)</span>. Since this means that <span class="math">P_{3} = (P_{1} + P_{2}) + N</span>, we can use the formulas above, then apply the <span class="math">+N</span> operation, which, in <span class="math">(u, v)</span> coordinates, is just negation of the values:</p>

    <div class="my-4 text-center"><span class="math-block">u _ {3} = - \\frac {u _ {1} v _ {2} + u _ {2} v _ {1}}{1 + (a - 2 i) u _ {1} u _ {2} v _ {1} v _ {2}}</span></div>

    <div class="my-4 text-center"><span class="math-block">v _ {3} = - \\frac {v _ {1} v _ {2} - (a + 2 i) u _ {1} u _ {2}}{1 - (a - 2 i) u _ {1} u _ {2} v _ {1} v _ {2}}</span></div>

    <p class="text-gray-300">For better performance, we want to work only in <span class="math">\\mathbb{F}_q</span>, and thus we need to use <span class="math">x</span> instead of <span class="math">v</span> as input, and revert to <span class="math">x</span> on output. Applying the map <span class="math">v \\mapsto x</span> into the equation for <span class="math">v_3</span> yields the following (after multiplying numerator and denominator by <span class="math">(x_1 - i)(x_2 - i)</span>, which is always non-zero since <span class="math">x_1, x_2 \\in \\mathbb{F}_q</span>):</p>

    <div class="my-4 text-center"><span class="math-block">v _ {3} = - \\frac {(x _ {1} - i) (x _ {2} - i) - (a + 2 i) u _ {1} u _ {2} (x _ {1} + i) (x _ {2} + i)}{(x _ {1} + i) (x _ {2} + i) - (a - 2 i) u _ {1} u _ {2} (x _ {1} - i) (x _ {2} - i)}</span></div>

    <p class="text-gray-300">Developing this expression, then multiplying numerator and denominator by <span class="math">i</span> and inserting the minus sign in the numerator leads us to:</p>

    <div class="my-4 text-center"><span class="math-block">v _ {3} = \\frac {C - i D}{C + i D}</span></div>

    <p class="text-gray-300">with:</p>

    <div class="my-4 text-center"><span class="math-block">C = b \\left(\\left(x _ {1} + x _ {2}\\right) \\left(1 + a u _ {1} u _ {2}\\right) + 2 u _ {1} u _ {2} \\left(x _ {1} x _ {2} + b\\right)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">D = \\left(x _ {1} x _ {2} + b\\right) \\left(1 - a u _ {1} u _ {2}\\right) - 2 b u _ {1} u _ {2} \\left(x _ {1} + x _ {2}\\right)</span></div>

    <p class="text-gray-300">Since we know that <span class="math">v_{3} = (x_{3} - i) / (x_{3} + i)</span> for some <span class="math">x_{3} \\in \\mathbb{F}_{q}</span>, it follows that <span class="math">x_{3} = C / D</span>.</p>

    <p class="text-gray-300">23</p>

    <p class="text-gray-300">A similar treatment to the expression of <span class="math">u_{3}</span> yields:</p>

    <p class="text-gray-300"><span class="math">u_{3}=-\\frac{F+iG}{H+iJ}</span></p>

    <p class="text-gray-300">with:</p>

    <p class="text-gray-300"><span class="math">F</span> <span class="math">=(u_{1}+u_{2})(x_{1}x_{2}-b)</span> <span class="math">G</span> <span class="math">=(u_{1}-u_{2})(x_{2}-x_{1})</span> <span class="math">H</span> <span class="math">=(x_{1}x_{2}+b)(1+au_{1}u_{2})+2bu_{1}u_{2}(x_{1}+x_{2})</span> <span class="math">J</span> <span class="math">=(x_{1}+x_{2})(1-au_{1}u_{2})-2u_{1}u_{2}(x_{1}x_{2}+b)</span></p>

    <p class="text-gray-300">We always have <span class="math">x_{1}x_{2}\\neq b</span>, since <span class="math">x_{1}x_{2}\\in QR(\\mathbb{P}_{q})</span> and <span class="math">b\\notin QR(\\mathbb{P}_{q})</span>. If <span class="math">u_{1}+u_{2}\\neq 0</span>, then the real part of the numerator (<span class="math">F</span>) is non-zero. Since the expression of <span class="math">u_{3}</span> is known to be well-defined and to yield an element of <span class="math">\\mathbb{P}_{q}</span>, it follows that the real part of the denominator (<span class="math">H</span>) is also non-zero, and <span class="math">u_{3}=-F/H</span>.</p>

    <p class="text-gray-300">In case <span class="math">u_{1}+u_{2}=0</span>, then <span class="math">P_{1}+N=-P_{2}+N</span>, which means that <span class="math">x_{1}=x_{2}</span> and <span class="math">P_{3}+N=N</span>; we then have <span class="math">F=0</span>, and we should get <span class="math">u_{3}=0</span>. If <span class="math">x_{1}=0</span>, then <span class="math">H=b\\neq 0</span>. If <span class="math">x_{1}\\neq 0</span>, then:</p>

    <p class="text-gray-300"><span class="math">H</span> <span class="math">=(x_{1}^{2}+b)(1-au_{1}^{2})-4bu_{1}^{2}x_{1}</span> <span class="math">=u_{1}^{2}x_{1}((x_{1}+b/x_{1})(1/u_{1}^{2}-a)-4b)</span> <span class="math">=u_{1}^{2}x_{1}((x_{1}+b/x_{1})^{2}-4b)</span> <span class="math">=u_{1}^{2}x_{1}(x_{1}-b/x_{1})^{2}</span> <span class="math">=u_{1}^{2}(x_{1}^{2}-b)^{2}/x_{1}</span></p>

    <p class="text-gray-300">which is a non-zero value, since <span class="math">b\\notin QR(\\mathbb{P}_{q})</span>. Thus, even when <span class="math">u_{1}+u_{2}=0</span>, we always have <span class="math">H\\neq 0</span>; the fraction <span class="math">-F/H</span> is well-defined and has the correct value (<span class="math">0</span>).</p>

    <p class="text-gray-300">We therefore have obtained complete formulas for addition in <span class="math">\\mathbb{G}</span>:</p>

    <p class="text-gray-300">Addition in <span class="math">\\mathbb{G}</span> (<span class="math">(x,u)</span> coordinates, complete)</p>

    <p class="text-gray-300"><span class="math">x_{3}</span> <span class="math">=\\frac{b((x_{1}+x_{2})(1+au_{1}u_{2})+2u_{1}u_{2}(x_{1}x_{2}+b))}{(x_{1}x_{2}+b)(1-au_{1}u_{2})-2bu_{1}u_{2}(x_{1}+x_{2})}</span> <span class="math">u_{3}</span> <span class="math">=\\frac{-(u_{1}+u_{2})(x_{1}x_{2}-b)}{(x_{1}x_{2}+b)(1+au_{1}u_{2})+2bu_{1}u_{2}(x_{1}+x_{2})}</span></p>

    <p class="text-gray-300">We may note that the expression for <span class="math">u_{3}</span> could have been obtained by simply replacing <span class="math">w</span> with <span class="math">1/u</span> in the expression for <span class="math">w_{3}</span> shown in section 3.3; however, the proof above also shows that the formula is complete.</p>

    <p class="text-gray-300">Another, different formula for <span class="math">u_{3}</span> can be obtained. Split <span class="math">v</span> into its real and imaginary parts:</p>

    <p class="text-gray-300"><span class="math">v</span> <span class="math">=\\frac{x-i}{x+i}</span> <span class="math">=\\frac{(x-i)^{2}}{x^{2}-b}</span> <span class="math">=\\frac{x^{2}+b}{x^{2}-b}+i\\,\\frac{-2x}{x^{2}-b}</span></p>

    <p class="text-gray-300">We write <span class="math">m = \\Re(v)</span> and <span class="math">n = \\Im(v)</span>, respectively. Replacing <span class="math">v</span> inside the expression of <span class="math">u_3</span>, and multiplying numerator and denominator by <span class="math">(x_1^2 - b)(x_2^2 - b)</span> (which is always non-zero, since <span class="math">b \\notin QR(\\mathbb{F}_q)</span>) yields:</p>

    <div class="my-4 text-center"><span class="math-block">u_3 = - \\frac{(u_1 m_2 + u_2 m_1) + i (u_1 n_2 + u_2 n_1)}{L + i M}</span></div>

    <p class="text-gray-300">with:</p>

    <div class="my-4 text-center"><span class="math-block">L = 1 + u_1 u_2 \\left( a (m_1 m_2 + b n_1 n_2) - 2 b (m_1 n_2 + m_2 n_1) \\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">M = u_1 u_2 \\left( a (m_1 n_2 + m_2 n_1) - 2 (m_1 m_2 + b n_1 n_2) \\right)</span></div>

    <p class="text-gray-300">Note that <span class="math">M = (x_1^2 - b)(x_2^2 - b)\\Im((a - 2i)u_1u_2v_1v_2)</span>, which we proved (in section 3.4) to be non-zero when <span class="math">u_1</span> and <span class="math">u_2</span> are non-zero. We will now assume that <span class="math">u_1 \\neq 0</span> and <span class="math">u_2 \\neq 0</span>, i.e. that <span class="math">P_1 + N \\neq N</span> and <span class="math">P_2 + N \\neq N</span>; this also implies that <span class="math">x_1 \\neq 0</span> and <span class="math">x_2 \\neq 0</span>.</p>

    <p class="text-gray-300">We can multiply numerator and denominator by <span class="math">L - iM</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} u_3 = - \\frac{(u_1 m_2 + u_2 m_1) L - b (u_1 n_2 + u_2 n_1) M}{L^2 - b M^2} \\\\ \\quad - i \\frac{(u_1 n_2 + u_2 n_1) L - (u_1 m_2 + u_2 m_1) M}{L^2 - b M^2} \\end{array}</span></div>

    <p class="text-gray-300">Since <span class="math">u_3 \\in \\mathbb{F}_q</span>, its imaginary part is zero, which implies that:</p>

    <div class="my-4 text-center"><span class="math-block">u_1 m_2 + u_2 m_1 = \\frac{(u_1 n_2 + u_2 n_1) L}{M}</span></div>

    <p class="text-gray-300">Replacing this value in the expression of <span class="math">u_3</span> leads to:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} u_3 = - \\frac{(u_1 n_2 + u_2 n_1) (L^2 - b M^2)}{M (L^2 - b M^2)} \\\\ \\quad = \\frac{u_1 n_2 + u_2 n_1}{M} \\end{array}</span></div>

    <p class="text-gray-300">Replacing <span class="math">m_1, m_2, n_1</span> and <span class="math">n_2</span> with their expressions in <span class="math">x_1</span> and <span class="math">x_2</span>, and using the fact that <span class="math">x + b/x = 1/u^2 - a</span> (by the curve equation), we can then obtain the following:</p>

    <div class="my-4 text-center"><span class="math-block">u_3 = - \\frac{u_1 (x_1 - \\frac{b}{x_1}) + u_2 (x_2 - \\frac{b}{x_2})}{u_1 u_2 \\left( \\frac{1}{u_1^2 u_2^2} + 4 b - a^2 \\right)}</span></div>

    <p class="text-gray-300">Then, replacing <span class="math">x - b/x = 2x - x - b/x = 2x - 1/u^2 + a</span>, we get to:</p>

    <div class="my-4 text-center"><span class="math-block">u_3 = - \\frac{u_1 ((2 x_2 + a) u_2^2 - 1) + u_2 ((2 x_1 + a) u_1^2 - 1)}{1 + (4 b - a^2) u_1^2 u_2^2}</span></div>

    <p class="text-gray-300">We derived this formula under the assumption that <span class="math">P_1 + N \\neq N</span> and <span class="math">P_2 + N \\neq N</span>, but it can be easily verified that if <span class="math">P_1 + N = N</span>, then it yields <span class="math">u_3 = u_2</span>, which is correct; similarly, if <span class="math">P_2 + N = N</span>, then it yields <span class="math">u_3 = u_1</span>, which is again correct. Therefore, this formula is complete.</p>

    <p class="text-gray-300">25</p>

    <p class="text-gray-300">3.6 Some Isogenies</p>

    <p class="text-gray-300">We present here a family of isogenies that apply to double-odd elliptic curves, and are helpful for building efficient implementations. For the presentation in this section, we work in <span class="math">(x,w)</span> coordinates.</p>

    <p class="text-gray-300">Warning: in this section, we are considering point addition on the curve, not in the group <span class="math">\\mathbb{G}</span>. We will denote points <span class="math">P_{1}=(x_{1},w_{1})</span> and <span class="math">P_{2}=(x_{2},w_{2})</span>, and consider their sum on the curve <span class="math">P_{3}=(x_{3},w_{3})</span>.</p>

    <p class="text-gray-300">We denote <span class="math">E(a,b)</span> the double-odd elliptic curve with equation <span class="math">w^{2}x=x^{2}+ax+b</span>. Our odd-order group <span class="math">\\mathbb{G}</span>, when defined as the non-<span class="math">r</span>-torsion points of <span class="math">E(a,b)</span>, will be referred to as <span class="math">\\mathbb{G}(a,b)</span>.</p>

    <p class="text-gray-300">For any <span class="math">\\pi\\in\\mathbb{F}_{q}</span> such that <span class="math">\\pi\\neq 0</span>, we define the following function:</p>

    <p class="text-gray-300"><span class="math">\\psi_{\\pi}:E(a,b)</span> <span class="math">\\longrightarrow E(-2a\\pi^{2},\\pi^{4}(a^{2}-4b))</span> <span class="math">P</span> <span class="math">\\longmapsto</span> <span class="math">\\mathbb{O}\\text{ if }P=\\mathbb{O}\\text{ or }N</span> <span class="math">\\left(\\pi^{2}w^{2},-\\frac{\\pi(x-b/x)}{w}\\right)\\text{ otherwise}</span></p>

    <p class="text-gray-300">This function is well-defined, because the output is indeed on the expected curve:</p>

    <p class="text-gray-300"><span class="math">\\left(-\\frac{\\pi(x-b/x)}{w}\\right)^{2}</span> <span class="math">=\\frac{\\pi^{2}((w^{2}-a)^{2}-4b)}{w^{2}}</span> <span class="math">=\\frac{\\pi^{2}(w^{4}-2aw^{2}+a^{2}-4b)}{w^{2}}</span> <span class="math">=\\pi^{2}w^{2}-2a\\pi^{2}+\\frac{\\pi^{4}(a^{2}-4b)}{\\pi^{2}w^{2}}</span></p>

    <p class="text-gray-300">The <span class="math">\\psi_{\\pi}</span> function is an <em>isogeny</em> between curves <span class="math">E(a,b)</span> and <span class="math">E(-2a\\pi^{2},\\pi^{4}(a^{2}-4b))</span>. To prove it, we need to show that for points <span class="math">P_{1}=(x_{1},w_{1})</span>, <span class="math">P_{2}=(x_{2},w_{2})</span>, and <span class="math">P_{3}=(x_{3},w_{3})=P_{1}+P_{2}</span>, then <span class="math">\\psi_{\\pi}(P_{1}+P_{2})=\\psi_{\\pi}(P_{1})+\\psi_{\\pi}(P_{2})</span>. Reusing the formulas described in sections 3.3 and the alternate formula obtained at the end of section 3.5, and taking into account that we are here using addition on the curve, not addition in <span class="math">\\mathbb{G}</span>, we can derive the following formulas:</p>

    <p class="text-gray-300"><span class="math">x_{3}</span> <span class="math">=\\frac{(x_{1}x_{2}-b)^{2}}{x_{1}x_{2}(w_{1}+w_{2})^{2}}</span> <span class="math">w_{3}</span> <span class="math">=\\frac{w_{1}^{2}w_{2}^{2}-(a^{2}-4b)}{w_{1}(x_{2}-b/x_{2})+w_{2}(x_{1}-b/x_{1})}</span></p>

    <p class="text-gray-300">Such formulas are valid on the curve <span class="math">E(a,b)</span> as long as <span class="math">P_{1},P_{2}</span> and <span class="math">P_{1}+P_{2}</span> are distinct from both <span class="math">\\mathbb{O}</span> and <span class="math">N</span>. Using these formulas, it is straightforward (but tedious) to show that <span class="math">\\psi_{\\pi}(P_{1}+P_{2})</span> and <span class="math">\\psi_{\\pi}(P_{1})+\\psi_{\\pi}(P_{2})</span> have the same <span class="math">w</span> coordinate. Note that the <span class="math">x</span> coordinate of <span class="math">\\psi_{\\pi}(P)</span> is a quadratic residue for all points <span class="math">P</span>; this implies that <span class="math">\\psi_{\\pi}(P)</span> is an <span class="math">r</span>-torsion point. As we saw in section 2.4, a value <span class="math">w</span> may correspond to at most one point of <span class="math">r</span>-torsion; therefore, a match on <span class="math">w</span> coordinates is sufficient to prove the equality of the points, which completes the proof.</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">In general, <span class="math">E(-2a\\pi^2, \\pi^4(a^2 - 4b))</span> is not isomorphic to <span class="math">E(a, b)</span>. As explained in section 2.5, these two curves are isomorphic if and only if there exists <span class="math">\\varepsilon \\in \\mathbb{F}_q</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">-2a\\pi^2 = a\\varepsilon^2</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi^4(a^2 - 4b) = b^4</span></div>

    <p class="text-gray-300">This may happen only in the following situations:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>if <span class="math">a = 0</span>, in which case the <span class="math">j</span>-invariant of the curve <span class="math">E(a, b)</span> is <span class="math">j = 1728</span>;</li>

      <li>if <span class="math">a \\neq 0</span> and <span class="math">a^2 = 8b</span>, in which case the <span class="math">j</span>-invariant of the curve <span class="math">E(a, b)</span> is <span class="math">j = 8000</span>.</li>

    </ul>

    <p class="text-gray-300">In such situations, <span class="math">\\psi_{-1/2}</span> is an endomorphism over the curve, which can be used to speed up some curve operations, in particular multiplication of a point by a scalar, with the GLV method[16]. For curves with <span class="math">j = 1728</span>, this is not very interesting in practice, since faster endomorphisms exist.</p>

    <p class="text-gray-300">While <span class="math">E(a, b)</span> and <span class="math">E(-2a\\pi^2, \\pi^4(a^2 - 4b))</span> are not, in general, isomorphic to each other, applying <span class="math">\\psi_{\\pi}</span> twice will bring us back to a curve isomorphic to <span class="math">E(a, b)</span>, even if using distinct constants <span class="math">\\pi</span> and <span class="math">\\pi&#x27;</span>. Indeed:</p>

    <div class="my-4 text-center"><span class="math-block">-2(-2a\\pi^2)\\pi&#x27;^2 = (2\\pi\\pi&#x27;)^2a</span></div>

    <div class="my-4 text-center"><span class="math-block">\\pi&#x27;^4((-2a\\pi^2)^2 - 4\\pi^4(a^2 - 4b)) = (2\\pi\\pi&#x27;)^4b</span></div>

    <p class="text-gray-300">If <span class="math">2\\pi\\pi&#x27; = 1</span>, then we will be back to the original curve <span class="math">E(a, b)</span> itself.</p>

    <p class="text-gray-300">Using these properties, we define the following functions:</p>

    <div class="my-4 text-center"><span class="math-block">\\psi_1: E(a, b) \\longrightarrow E(-2a, a^2 - 4b)</span></div>

    <div class="my-4 text-center"><span class="math-block">(x, w) \\longmapsto \\left(w^2, -\\frac{(x - b/x)}{w}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\psi_{1/2}&#x27;: E(-2a, a^2 - 4b) \\longrightarrow E(a, b)</span></div>

    <div class="my-4 text-center"><span class="math-block">(x, w) \\longmapsto \\left(w^2/4, -\\frac{(x - (a^2 - 4b)/x)}{2w}\\right)</span></div>

    <p class="text-gray-300">with <span class="math">\\psi_1(\\mathbb{O}) = \\psi_1(N) = \\mathbb{O}</span>, and similarly for <span class="math">\\psi_{1/2}&#x27;</span>.</p>

    <p class="text-gray-300">Since all these functions output points in <span class="math">E[r]</span> and we prefer to work with our group <span class="math">\\mathbb{G}</span> which consists in, precisely, the points which are not in <span class="math">E[r]</span>, we also define dual functions:</p>

    <div class="my-4 text-center"><span class="math-block">\\vartheta_1: E(a, b) \\longrightarrow \\mathbb{G}(-2a, a^2 - 4b)</span></div>

    <div class="my-4 text-center"><span class="math-block">(x, w) \\longmapsto \\left(\\frac{a^2 - 4b}{w^2}, \\frac{(x - b/x)}{w}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\vartheta_{1/2}&#x27;: E(-2a, a^2 - 4b) \\longrightarrow \\mathbb{G}(a, b)</span></div>

    <div class="my-4 text-center"><span class="math-block">(x, w) \\longmapsto \\left(\\frac{4b}{w^2}, \\frac{(x - (a^2 - 4b)/x)}{2w}\\right)</span></div>

    <p class="text-gray-300">with <span class="math">\\vartheta_1(\\mathbb{O}) = \\vartheta_1(N) = N&#x27;</span> (neutral of the destination group <span class="math">\\mathbb{G}(-2a, a^2 - 4b)</span>), and similarly for <span class="math">\\vartheta_{1/2}&#x27;</span>. The <span class="math">\\vartheta_\\pi</span> functions are the composition of <span class="math">\\psi_\\pi</span> with an addition (on the curve) of <span class="math">N</span>;</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300"><span class="math">\\mathcal{G}(a,b)</span> is an homomorphism from <span class="math">\\mathbb{G}(a,b)</span> to <span class="math">\\mathbb{G}(-2a,a^{2}-4b)</span>, and <span class="math">\\mathcal{\\delta}^{\\prime}_{1/2}</span> is an homomorphism from <span class="math">\\mathbb{G}(-2a,a^{2}-4b)</span> to <span class="math">\\mathbb{G}(a,b)</span>.</p>

    <p class="text-gray-300">By using the formulas above, we straightforwardly obtain the following results for any <span class="math">P\\in E(a,b)</span>:</p>

    <p class="text-gray-300"><span class="math">\\psi^{\\prime}_{1/2}(\\psi_{1}(P))</span> <span class="math">=\\psi^{\\prime}_{1/2}(\\mathcal{\\delta}_{1}(P))=2P</span> <span class="math">\\mathcal{\\delta}^{\\prime}_{1/2}(\\psi_{1}(P))</span> <span class="math">=\\mathcal{\\delta}^{\\prime}_{1/2}(\\mathcal{\\delta}_{1}(P))=2P+N</span></p>

    <p class="text-gray-300">This leads to possible variants for computing point doublings in <span class="math">\\mathbb{G}</span>, and, in particular, to optimize sequences of successive doublings in <span class="math">\\mathbb{G}</span>, depending on whether <span class="math">\\psi_{1}</span> or <span class="math">\\mathcal{\\delta}_{1}</span> happens to be more efficient to compute in any particular system of coordinates for a specific curve.</p>

    <h3 id="sec-18" class="text-xl font-semibold mt-8">3.7 Mappings Into Double-Odd Curves</h3>

    <p class="text-gray-300">We consider here deterministic functions that map from arbitrary field elements into points on a double-odd elliptic curve. Such mappings are not bijective (if only because the field <span class="math">\\mathbb{F}_{q}</span> and the curve do not have the same number of elements). The main use of a mapping is the implementation of a hash-to-curve process, in which an arbitrary binary input is mapped into a curve point which is indifferentiable from a point chosen at random and uniformly on the curve; in order to obtain indifferentiability, the following algorithm is used:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Hash the input into two distinct field elements with an appropriate collision-resistant hash function. Practically, if the target field size is <span class="math">n</span> bits, we can produce two sequences of <span class="math">n+128</span> bits from the input, with an extensible output function such as SHAKE<em>[22]</em>, then interpret each sequence as a big integer, which we reduce modulo the field order <span class="math">q</span>.</li>

      <li>Map each obtained field element into a curve point with the deterministic mapping.</li>

      <li>Add the two points together.</li>

    </ol>

    <p class="text-gray-300">A generic method for defining such a mapping over any short Weierstraß curve has been published by Shallue and van de Woestijne<em>[36]</em>, and a simplified version thereof by Ulas<em>[38]</em>. The original method is, by definition, applicable to double-odd elliptic curves, since we can always use the changes of variable defined in section 2.2 to convert between equation <span class="math">y^{2}=x(x^{2}+ax+b)</span> and the short Weierstraß equation <span class="math">y^{2}=x^{3}+Ax+B</span>. The simplified method is applicable (and faster) to <em>most</em> curves, provided that they lead to <span class="math">AB\\neq 0</span>. In particular, it does not work for GLV curves with <span class="math">j=1728</span>, which lead to <span class="math">A=b\\neq 0</span> and <span class="math">B=0</span>.</p>

    <p class="text-gray-300">A different mapping function is Elligator2<em>[7]</em>, which is applicable to all curves with even order, including double-odd curves, except, again, GLV curves with <span class="math">j=1728</span>. Since Elligator2 is somewhat simpler and faster than the SW and SWU mappings, we use it for double-odd curves with <span class="math">j\\neq 1728</span>. We recall it below. For GLV curves with <span class="math">j=1728</span>, we define a custom mapping, which builds on the same ideas as the original Shallue-van de Woestijne mapping, but tailored to the specificities of the curve.</p>

    <h5 id="sec-19" class="text-base font-semibold mt-4">Elligator2.</h5>

    <p class="text-gray-300">This mapping is applicable to double-odd curves as long as <span class="math">a\\neq 0</span>. Let <span class="math">d</span> be a conventional fixed value in <span class="math">\\mathbb{F}_{q}</span> such that <span class="math">d\\notin QR</span> (e.g. we can use <span class="math">d=-1</span> when <span class="math">q=3\\ \\mathrm{mod}\\ 4</span>). For an input <span class="math">e\\in\\mathbb{F}_{q}</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">1+de^{2}=0</span>, then return the point-at-infinity <span class="math">\\mathbb{O}</span></li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, set <span class="math">v = a / (1 + de^2)</span> and <span class="math">z = v(v^2 + av + b)</span>, and compute the Legendre symbol of <span class="math">z</span> (the Legendre symbol of a value <span class="math">t</span> is 0 if <span class="math">t = 0</span>, 1 if <span class="math">t \\neq 0</span> and <span class="math">t \\in QR</span>, or -1 if <span class="math">t \\notin QR</span>). Note that <span class="math">v \\neq 0</span>, and therefore <span class="math">z \\neq 0</span> (otherwise, the curve would not be double-odd). Then:</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">\\chi(z) = 1</span>, then set <span class="math">x = v</span>.</li>

      <li>Otherwise, set <span class="math">x = -v - a</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>At that point it is guaranteed that <span class="math">x(x^2 + ax + b)</span> is a square, and a square root is extracted from it. A fixed convention is used to select one of the two square roots. In the original Elligator2, that square root is then multiplied by <span class="math">\\chi(z)</span> to obtain the coordinate <span class="math">y</span>.</li>

    </ol>

    <p class="text-gray-300">GLV curves with <span class="math">j = 1728</span>. When <span class="math">a = 0</span>, Elligator2 cannot be applied (and neither can the simplified SWU mapping). We define here a custom mapping. Let <span class="math">d \\in \\mathbb{F}_q</span> such that <span class="math">d^2 = -1</span> (<span class="math">d</span> must exist since, in that case, <span class="math">q = 1 \\mod 4</span>). For an input <span class="math">e \\in \\mathbb{F}_q</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">e = 0</span> then return the point-at-infinity <span class="math">\\mathbb{O}</span>.</li>

      <li>Otherwise, define:</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x_1 = e + (1 - b) / (4e) \\\\ x_2 = d(e - (1 - b) / (4e)) \\end{array}</span></div>

    <p class="text-gray-300">With such definitions, then it is easy to show that:</p>

    <div class="my-4 text-center"><span class="math-block">(x_1^3 + bx_1)(x_2^3 + bx_2) = (x_1x_2)^3 + bx_1x_2</span></div>

    <p class="text-gray-300">Therefore, at least one of <span class="math">x_1, x_2</span> and <span class="math">x_1x_2</span> is the <span class="math">x</span> coordinate for a point on the curve:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">x_1 \\in QR</span>, then set <span class="math">x = x_1</span>.</li>

      <li>Otherwise, if <span class="math">x_2 \\in QR</span>, then set <span class="math">x = x_2</span>.</li>

      <li>Otherwise, set <span class="math">x = x_1x_2</span>.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Once <span class="math">x</span> is chosen, use a square root extraction to compute <span class="math">y</span>. A fixed convention is used to deterministically select one of the two square roots.</li>

    </ol>

    <p class="text-gray-300">An alternate method (proposed in [39]) to the one exposed just above would be to find an isogeny between the target double-odd elliptic curve and an alternate curve for which <span class="math">a \\neq 0</span> and Elligator2 can be applied. Depending on the curve parameters and the target architecture, that alternate method may or may not be more efficient. Elligator2 involves one Legendre symbol and one square root computation; our custom map needs two Legendre symbols and one square root computation. Thus, using an isogeny from an alternate curve with <span class="math">j \\neq 1728</span> may provide a faster process if the isogeny itself is faster than a Legendre symbol computation. As described in [33], on ARM Cortex M0+ processors with the field of integers modulo <span class="math">2^{255} - 19</span>, the cost of a constant-time Legendre symbol computation is lower than that of 30 multiplications in the base field; for many curves, there is no suitable isogeny that can be computed with that few multiplications. On the other hand, on larger architectures (e.g. 64-bit x86), cost of Legendre computation rises to more than 100M.</p>

    <p class="text-gray-300">Mapping to <span class="math">\\mathbb{G}</span>. Since we will want, in general, to map to the prime order group <span class="math">\\mathbb{G}</span> and not the complete curve, we need to "clear the cofactor". The simplest way is to apply the mapping not to the curve <span class="math">E(a, b)</span>, but to the dual curve <span class="math">E(-2a, a^2 - 4b)</span>. Once a point on that curve is obtained, the isogeny <span class="math">\\theta_{1/2}&#x27;</span> (defined in section 3.6) can be applied, to obtain a point in <span class="math">\\mathbb{G}(a, b)</span>.</p>

    <p class="text-gray-300">Inversions.</p>

    <p class="text-gray-300">The mappings described above involve divisions in <span class="math">\\mathbb{F}_q</span>, in the computation of the value <span class="math">v</span> (for Elligator2) or <span class="math">(1 - b) / (4e)</span> (for the mapping for GLV curves). It is possible to combine that inversion with a square root computation in order to perform both at the cost of a single modular exponentiation; this is leveraged in, for instance, Ristretto[3]. However, this is not especially useful in our case, because even if the affine coordinates of the curve point on <span class="math">E</span> are obtained, the application of <span class="math">\\theta_{1/2}^{\\prime}</span> introduces further inversions. Moreover, in general, such mappings are used as part of a hash-to-curve process, where the mapping is applied twice, and the two points added together, which will again involve some inversions. It is thus more efficient to make each mapping produce a point in fractional coordinates, and convert back to affine only after the final point addition; or, even, not to convert to affine coordinates at all, if the obtained point is to be used in further computations on <span class="math">\\mathbb{G}</span>.</p>

    <p class="text-gray-300">In section 3, we saw various formulas for computing operations in <span class="math">\\mathbb{G}</span>. These formulas involve arithmetic operations on field elements, notably inversions. In general, inversion is much more expensive than multiplication, and implementations strive to reduce the number of required inversions, even if that implies making more multiplications<span class="math">^{11}</span>. The usual trick is to represent coordinates as fractions, and then apply arithmetic operations on numerators and denominators. Using fractions makes operations more expensive (e.g. an addition on fractions requires, in general, three multiplications in the field) but removes all inversions from the computation, except a single one at the end of the algorithm, when the fractional result must be reduced to an affine value (usually for encoding purposes). Various coordinate systems using fractions have been defined, e.g. projective and Jacobian coordinates.</p>

    <p class="text-gray-300">In this section, we describe algorithms for generic point addition and specialized point doubling in several systems of coordinates. All the algorithms presented here are complete; some achieve completeness by using complete formulas, while others rely on some inexpensive conditional copy operations to handle exceptional cases. We use CONDCOPY <span class="math">(m, n, c)</span> to denote the action of overwriting the contents of <span class="math">m</span> with the value of <span class="math">n</span> is <span class="math">c</span> is true, or leaving <span class="math">m</span> untouched if <span class="math">c</span> is false. This operation can be implemented with constant-time selection in an efficient manner, with a cost roughly similar to that of an addition in the field when operands <span class="math">m</span> and <span class="math">n</span> are field elements.</p>

    <p class="text-gray-300">All algorithm costs are expressed with the notation <span class="math">e\\mathrm{M} + f\\mathrm{S}</span>, with <span class="math">e</span> and <span class="math">f</span> being integers; "M" represents a multiplication in the field, and "S" is a squaring. Depending on the used field, used software and hardware architecture, and implementation strategy, a squaring may have the same cost as a multiplication, or it may be somewhat faster; in typical software implementations, squaring cost will typically be between 65 and <span class="math">85\\%</span> of that of a multiplication. A squaring can always be computed as a multiplication; thus, the cost of a squaring cannot exceed that of a multiplication. Conversely, any multiplication can be computed with two squarings and some additions and subtractions, using <span class="math">4mn = (m + n)^2 - (m - n)^2</span>; thus, squaring cost cannot really be less than half that of a multiplication.</p>

    <p class="text-gray-300">Thus, algorithms described below strive primarily to reduce the total number of multiplications and squarings, and, for a given total number, favour squarings over multiplications. It</p>

    <p class="text-gray-300"><span class="math">^{11}</span>As shown in [30], this is not always true; in some field extensions, inversions are efficient enough, relatively to multiplications, that sticking to affine coordinates is a reasonable implementation strategy.</p>

    <p class="text-gray-300">must be noted that all these costs are estimates, which, in particular, do not take into account the costs of additions, subtractions, and conditional copies. These operations are less expensive than multiplications and squarings, but not necessarily negligible, especially on “fast” systems (e.g. 64-bit x86 CPUs). Therefore, on any given target system, an algorithm that (for instance) has cost 1M+6S may turn out to be less efficient than another with cost 2M+5S, if the latter uses fewer of these cheap operations, or has a lower computing depth and more easily maps to the computing resources of a superscalar CPU.</p>

    <p class="text-gray-300">An additional effect is that modern “large” CPUs use heavily pipelined and out-of-order evaluation, to the point that interdependencies between values become more important than raw operation counts. As a rule of thumb, counts of multiplications and squarings yield reasonably accurate estimates of actual performance on small embedded CPUs (say, within 10% of the actual value), but less so on large superscalar CPUs, where two algorithms with seemingly equivalent costs may differ in performance by 20% or more. Only real implementations and benchmarks can provide better accuracy.</p>

    <p class="text-gray-300">In all cost estimates, we systematically consider that the curve constants <span class="math">a</span> and <span class="math">b</span> are chosen such that multiplication by either, or by any constant value derived from <span class="math">a</span> and <span class="math">b</span>, is inexpensive.</p>

    <h3 id="sec-21" class="text-xl font-semibold mt-8">4.1 Jacobian (x, w) Coordinates</h3>

    <p class="text-gray-300">Jacobian coordinates are a fractional representation of <span class="math">x</span> and <span class="math">w</span> that is analogous to curve isomorphisms: a point <span class="math">P+N\\in\\mathbb{G}</span> will be represented by a triplet of field elements <span class="math">(X:W:Z)</span> such that:</p>

    <p class="text-gray-300"><span class="math">x</span> <span class="math">=\\frac{X}{Z^{2}}</span> <span class="math">w</span> <span class="math">=\\frac{W}{Z}</span></p>

    <p class="text-gray-300">It can be verified that these coordinates are analogous to the usual Jacobian coordinates in <span class="math">(x,y)</span> representation, and that they can be interpreted as an application of the isomorphism presented in section 2.5 (with <span class="math">\\varepsilon=1/Z</span>).</p>

    <p class="text-gray-300">Jacobian coordinates can represent the neutral point <span class="math">N</span> by setting <span class="math">Z=0</span>; for any point in <span class="math">\\mathbb{G}</span> distinct from <span class="math">N</span>, <span class="math">Z</span> will be a non-zero field element. However, we can be a bit more restrictive, which will be helpful in some cases: we define that valid representations of <span class="math">N</span> are triplets <span class="math">(0:W{:}0)</span>, where <span class="math">W\\neq 0</span>. This implies that <span class="math">W</span> is never equal to 0 for any element of <span class="math">\\mathbb{G}</span>. These Jacobian coordinates will be extended later to cover all curve points, not just <span class="math">\\mathbb{G}</span>; in that case, we will represent the point-at-infinity <span class="math">\\mathbb{O}</span> as <span class="math">(W^{2}:W{:}0)</span> for any <span class="math">W\\neq 0</span>.</p>

    <h4 id="sec-22" class="text-lg font-semibold mt-6">4.1.1 Addition in Jacobian (x, w) Coordinates</h4>

    <p class="text-gray-300">Using the formulas from section 3.3, we can express the sum in Jacobian coordinates of group elements <span class="math">P_{1}+N=(X_{1}:W_{1}:Z_{1})</span> and <span class="math">P_{2}+N=(X_{2}:W_{2}:Z_{2})</span> as point <span class="math">P_{3}+N=(X_{3}:W_{3}:Z_{3})</span></p>

    <p class="text-gray-300">with:</p>

    <div class="my-4 text-center"><span class="math-block">X _ {3} = b X _ {1} X _ {2} \\left(W _ {1} Z _ {2} + W _ {2} Z _ {1}\\right) ^ {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">W _ {3} = - \\left(\\left(W _ {1} W _ {2} + a Z _ {1} Z _ {2}\\right) \\left(X _ {1} X _ {2} + b Z _ {1} ^ {2} Z _ {2} ^ {2}\\right) + 2 b Z _ {1} Z _ {2} \\left(X _ {1} Z _ {2} ^ {2} + X _ {2} Z _ {1} ^ {2}\\right)\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">Z _ {3} = \\left(X _ {1} X _ {2} - b Z _ {1} ^ {2} Z _ {2} ^ {2}\\right) \\left(W _ {1} Z _ {2} + W _ {2} Z _ {1}\\right)</span></div>

    <p class="text-gray-300">These values can be computed in cost 8M+6S (eight multiplications and six squarings in  <span class="math">\\mathbb{F}_q</span> ) as shown in algorithm 1.</p>

    <p class="text-gray-300">Algorithm 1 Addition (Jacobian  <span class="math">(x, w)</span> ) (cost: 8M+6S) Require:  <span class="math">P_{1} + N = (X_{1}:W_{1}:Z_{1})</span>  and  <span class="math">P_{2} + N = (X_{2}:W_{2}:Z_{2})</span> Ensure:  <span class="math">(P_{1} + P_{2}) + N = (X_{3}:W_{3}:Z_{3})</span> 1:  <span class="math">t_1\\gets Z_1^2</span> 2:  <span class="math">t_2\\gets Z_2^2</span> 3:  <span class="math">t_3\\gets ((Z_1 + Z_2)^2 -t_1 - t_2) / 2</span> <span class="math">\\triangleright t_3 = Z_1Z_2</span> 4:  <span class="math">t_4\\gets t_3^2</span> <span class="math">\\triangleright t_4 = Z_1^2Z_2^2</span> 5:  <span class="math">t_5\\gets W_1W_2</span> 6:  <span class="math">t_6\\gets X_1X_2</span> 7:  <span class="math">t_7\\gets (W_1 + Z_1)(W_2 + Z_2) - t_3 - t_5</span> <span class="math">\\triangleright t_7 = W_1Z_2 + W_2Z_1</span> 8:  <span class="math">t_8\\gets (X_1 + t_1)(X_2 + t_2) - t_4 - t_6</span> <span class="math">\\triangleright t_8 = X_1Z_2^2 +X_2Z_1^2</span> 9:  <span class="math">Z_{3}\\gets (t_{6} - bt_{4})t_{7}</span> 10:  <span class="math">t_9\\gets t_7^3</span> <span class="math">\\triangleright t_9 = (W_1Z_2 + W_2Z_1)^4</span> 11:  <span class="math">X_{3}\\gets bt_{6}t_{9}</span> 12:  <span class="math">t_{10}\\gets (t_5 + at_3)(t_6 + bt_4)</span> <span class="math">\\triangleright t_{10} = (W_1W_2 + aZ_1Z_2)(X_1X_2 + bZ_1^2Z_2^2)</span> 13:  <span class="math">W_{3}\\gets -t_{10} - 2bt_{3}t_{8}</span> 14: CONDCOPY((X3:W3:Z3), (X1:W1:Z1), Z2=0) 15: CONDCOPY((X3:W3:Z3), (X2:W2:Z2), Z1=0)</p>

    <p class="text-gray-300">If either (or both)  <span class="math">P_{1} + N</span>  or  <span class="math">P_{2} + N</span>  is  <span class="math">N</span> , then the CONDCOPY calls set the output to one of the inputs, therefore valid by definition. If neither  <span class="math">P_{1} + N</span>  nor  <span class="math">P_{2} + N</span>  is  <span class="math">N</span> , but their sum in  <span class="math">\\mathbb{G}</span>  is  <span class="math">N</span> , then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Coordinates are such that  <span class="math">w_{1} + w_{2} = 0</span> , therefore  <span class="math">W_{1}Z_{2} + W_{2}Z_{1} = 0</span> , which implies that  <span class="math">X_{3}</span>  and  <span class="math">Z_{3}</span>  are set to 0.</li>

      <li>Similarly,  <span class="math">x_{1} = x_{2}</span> , thus  <span class="math">W_{3}</span>  is set to:</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} W _ {3} = - Z _ {1} ^ {3} Z _ {2} ^ {3} \\left(\\left(- w _ {1} ^ {2} + a\\right) \\left(x _ {1} ^ {2} + b\\right) + 4 b x _ {1}\\right) \\\\ = - Z _ {1} ^ {3} Z _ {2} ^ {3} \\left(- \\left(w _ {1} ^ {2} - a\\right) \\left(w _ {1} ^ {2} x _ {1} - a x _ {1}\\right) + 4 b x _ {1}\\right) \\\\ = - x _ {1} Z _ {1} ^ {2} Z _ {2} ^ {3} \\left(4 b - \\left(w _ {1} ^ {2} - a\\right) ^ {2}\\right) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">Since, in that situation,  <span class="math">x_{1}, Z_{1}</span>  and  <span class="math">Z_{2}</span>  are non-zero, and  <span class="math">4b \\notin QR</span> , it follows that  <span class="math">W_{3}</span>  is set to a non-zero value.</p>

    <p class="text-gray-300">Thus, if the output is  <span class="math">N</span> , then what is returned is a valid representation of  <span class="math">N</span>  ( <span class="math">X_{3}</span>  and  <span class="math">Z_{3}</span>  are zero,  <span class="math">W_{3}</span>  is not). We conclude that algorithm 1 is complete.</p>

    <p class="text-gray-300">The cost of algorithm 1 is 8M+6S. If point <span class="math">P_{2}</span> is really in affine coordinates (<span class="math">Z_{2}</span> statically known to be equal to 1), then <span class="math">t_{2}=1</span>, <span class="math">t_{3}=Z_{1}</span> and <span class="math">t_{4}=t_{1}</span>, thereby saving three squarings; in that case (often called “mixed addition”), the cost is 8M+3S. If both input points are in affine coordinates, then <span class="math">t_{1}=t_{2}=t_{3}=t_{4}=1</span>, <span class="math">t_{7}=W_{1}+W_{2}</span>, <span class="math">t_{8}=X_{1}+X_{2}</span>, and the multiplication <span class="math">t_{3}t_{8}</span> in the computation of <span class="math">W_{3}</span> is trivial, leading to a total cost of 5M+2S.</p>

    <p class="text-gray-300">Note that the first two operations are squarings of <span class="math">Z_{1}</span> and <span class="math">Z_{2}</span>, respectively; each depends on the coordinates of only one operand, not the other. We may therefore cache these values, with an alternate representation which is reminiscent of Chudnovsky coordinates<em>[10]</em>: a point <span class="math">(X:W:Z)</span> can be represented and stored as a quadruplet <span class="math">(X:W:Z:Z^{2})</span>. If Chudnovsky coordinates are used in algorithm 1, then the first two steps (computations of <span class="math">t_{1}</span> and <span class="math">t_{2}</span>) are free, since these values are directly provided as inputs; on the other hand, an extra squaring must be performed at the end, to compute <span class="math">Z_{3}^{2}</span>, so that the returned point is also in Chudnovsky coordinates. Overall, this decreases the cost of addition in <span class="math">\\mathbb{G}</span> to 8M+5S. We do not use this representation in our implementation because it increases RAM usage (which can be a problem on RAM-constrained embedded systems), and also because these savings are subsumed under the use of window normalization and mixed addition.</p>

    <h4 id="sec-23" class="text-lg font-semibold mt-6">4.1.2 Doubling in Jacobian (x, w) Coordinates</h4>

    <p class="text-gray-300">While the generic point addition, with cost 8M+6S, is not especially fast for an addition routine, point doublings can be made much faster. Using formulas from section 3.3, we find that if <span class="math">P+N=(X:W:Z)</span> and <span class="math">2P+N=(X^{\\prime}:W^{\\prime}:Z^{\\prime}:)</span>, then:</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}</span> <span class="math">=16bW^{4}Z^{4}</span> <span class="math">W^{\\prime}</span> <span class="math">=-(W^{4}+(4b-a^{2})Z^{4})</span> <span class="math">Z^{\\prime}</span> <span class="math">=2WZ(2X+aZ^{2}-W^{2})</span></p>

    <p class="text-gray-300">Even though the corresponding affine formulas are only unified, we find that these formulas are complete: if <span class="math">P+N\\neq N</span>, then <span class="math">2P+N\\neq N</span> (since the order of <span class="math">\\mathbb{G}</span> is odd); if <span class="math">P+N=N</span>, then <span class="math">X=Z=0</span> but <span class="math">W\\neq 0</span>, which leads to <span class="math">X^{\\prime}=Z^{\\prime}=0</span> and <span class="math">W^{\\prime}=-W^{4}\\neq 0</span>, i.e. a valid representation of the neutral point <span class="math">N</span>. Therefore, any algorithm leveraging these formulas will be complete, without needing any invocation of CONDCOPY.</p>

    <p class="text-gray-300">Point doublings in <span class="math">\\mathbb{G}</span> can be computed with these formulas in cost 2M+5S, as shown in algorithm 2.</p>

    <p class="text-gray-300">|  Algorithm 2 Doubling (Jacobian (x, w)) (cost: 2M+5S)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P+N=(X:W:Z)  |   |</p>

    <p class="text-gray-300">|  Ensure: 2P+N=(X':W':Z')  |   |</p>

    <p class="text-gray-300">|  1: t1←Z2  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: t2←t12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷t2=Z4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: t3←W2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: t4←t52</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷t4=W4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: X'←16bt2t4 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: W'←-(t4+(4b-a2)t2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷This step does not require any expensive operation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  8: Z'←t5(2X+at1-t3) |   |</p>

    <p class="text-gray-300">Doubling can be further optimized if there exists  <span class="math">e \\in \\mathbb{F}_q</span>  such that  <span class="math">4b - a^2 = e^2</span> . Note that since (by construction of the curve)  <span class="math">a^2 - 4b \\notin QR</span> , a square root of  <span class="math">4b - a^2</span>  exists if and only if  <span class="math">q = 3 \\mod 4</span> . Using the value  <span class="math">e</span> , cost can be turned into  <span class="math">1\\mathrm{M} + 6\\mathrm{S}</span>  as shown on algorithm 3.</p>

    <p class="text-gray-300">Algorithm 3 Doubling (Jacobian  <span class="math">(x, w)</span> ) with  <span class="math">q = 3 \\mod 4</span>  (cost: 1M+6S) Require:  <span class="math">P + N = (X:W:Z)</span> Ensure:  <span class="math">2P + N = (X&#x27;:W&#x27;:Z&#x27;)</span> 1:  <span class="math">t_1 \\gets Z^2</span> 2:  <span class="math">t_2 \\gets W^2</span> 3:  <span class="math">t_3 \\gets (W + Z)^2 - t_1 - t_2</span> 4:  <span class="math">X&#x27; \\gets bt_3^4</span> 5:  <span class="math">W&#x27; \\gets (e/2)t_3 - (t_1 + et_2)^2</span> 6:  <span class="math">Z&#x27; \\gets t_3(2X + at_1 - t_2)</span></p>

    <p class="text-gray-300">Algorithm 3 is complete since it computes exactly the same output values as algorithm 2, which is complete.</p>

    <p class="text-gray-300">As previously explained, cost  <span class="math">1\\mathrm{M} + 6\\mathrm{S}</span>  can be lower than  <span class="math">2\\mathrm{M} + 5\\mathrm{S}</span> , depending on implementation target and strategy. Note that even if  <span class="math">a</span>  and  <span class="math">b</span>  are small integers, the value  <span class="math">e</span>  (a square root of  <span class="math">4b - a^2</span>  in field  <span class="math">\\mathbb{F}_q</span> ) may be a "non-simple" value, and multiplications by  <span class="math">e</span>  and  <span class="math">e/2</span>  may be considerably more expensive, nullifying the savings induced by this algorithm. To use algorithm 3 efficiently, the curve parameters  <span class="math">a</span>  and  <span class="math">b</span>  must be chosen so that the constant  <span class="math">e</span>  leads to fast multiplications by  <span class="math">e</span>  and  <span class="math">e/2</span> .</p>

    <p class="text-gray-300">Another possible optimization is in the specific case of  <span class="math">2b = a^2</span> . This implies that  <span class="math">4b - a^2 \\in QR</span> , hence  <span class="math">q = 3 \\mod 4</span> ; moreover, this case requires that  <span class="math">2 \\notin QR</span> . These conditions can be met if and only if  <span class="math">q = 3 \\mod 8</span> . Note that if  <span class="math">2b = a^2</span> , then the  <span class="math">j</span> -invariant of the curve is:</p>

    <div class="my-4 text-center"><span class="math-block">j = \\frac {2 5 6 (3 b - 2 b) ^ {3}}{b ^ {2} (4 b - 2 b)} = 1 2 8</span></div>

    <p class="text-gray-300">Therefore, there are only two curves (up to isomorphisms) in a given field that match these conditions. We can thus enforce the curve equation to be either  <span class="math">y^{2} = x(x^{2} + x + 1 / 2)</span>  or</p>

    <p class="text-gray-300"><span class="math">y^{2} = x(x^{2} - x + 1 / 2)</span> ; we furthermore assume that the latter equation is used. On such a curve, we can compute point doubling with cost  <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span> , as described in algorithm 4.</p>

    <p class="text-gray-300">|  Algorithm 4 Doubling (Jacobian (x, w)), curve y2 = x(x2 - x + 1/2) (cost: 2M+4S)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P + N = (X:W:Z)  |   |</p>

    <p class="text-gray-300">|  Ensure: 2P + N = (X':W':Z')  |   |</p>

    <p class="text-gray-300">|  1: t1← WZ  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">2: t2← t12</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ t2= W2Z2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  3: X' ← 8t32 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4: t3← (W+Z)2-2t1</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ t3= W2+Z2= W2-aZ2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: W' ← 2t2-t32 |   |</p>

    <p class="text-gray-300">|  6: Z' ← 2t1(2X-t3) |   |</p>

    <p class="text-gray-300">Algorithm 4 again computes the same output values as algorithm 2, and is thus complete; it simply leverages the specific choice of curve parameters to compute the values more efficiently.</p>

    <p class="text-gray-300">While the generic addition routine, with cost  <span class="math">8\\mathrm{M} + 6\\mathrm{S}</span> , is relatively slow by modern standards (e.g. there are generic complete formulas, on any subgroup of odd order of a Weierstraß curve, that can compute point addition in projective coordinates in 12M[34]), the computation of doublings in  <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span>  is very fast; it is, in fact, faster than the best known doubling formulas in twisted Edwards curves ( <span class="math">3\\mathrm{M} + 4\\mathrm{S}</span>  in inverted coordinates[5]). When computing a multiplication of a group element by a scalar, a generic double-and-add algorithm with window optimizations will consist mostly of doublings; e.g., with a 5-bit window, there will be only one extra addition for every five doublings, making any saving in the doubling procedure much more important than the overhead of the point addition.</p>

    <p class="text-gray-300">When computing a sequence of successive doublings, we can obtain additional savings (depending on the curve) by leveraging the isogenies described in section 3.6. The morphism  <span class="math">\\psi_{1}</span> , that maps  <span class="math">(X:W:Z)</span>  (arbitrary curve point) to  <span class="math">(X&#x27;:W&#x27;:Z&#x27;)</span>  (on  <span class="math">E(-2a, a^2 - 4b)[r]</span> ) can be computed with the following formulas:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime} = W ^ {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">W ^ {\\prime} = - (2 X + a Z ^ {2} - W ^ {2})</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime} = W Z</span></div>

    <p class="text-gray-300">while  <span class="math">\\psi_{1/2}&#x27;(X&#x27;:W&#x27;:Z&#x27;) = (X&#x27;&#x27;:W&#x27;&#x27;:Z&#x27;&#x27;)</span>  is computed with:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime \\prime} = W ^ {\\prime 4}</span></div>

    <div class="my-4 text-center"><span class="math-block">W ^ {\\prime \\prime} = - (2 X ^ {\\prime} - 2 a Z ^ {\\prime 2} - W ^ {\\prime 2})</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime \\prime} = 2 W ^ {\\prime} Z ^ {\\prime}</span></div>

    <p class="text-gray-300">and  <span class="math">\\theta_{1/2}&#x27;(X&#x27;: W&#x27;: Z&#x27;) = (X&#x27;&#x27;: W&#x27;&#x27;: Z&#x27;&#x27;)</span>  uses:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime \\prime} = 1 6 b Z ^ {\\prime 4}</span></div>

    <div class="my-4 text-center"><span class="math-block">W ^ {\\prime \\prime} = 2 X ^ {\\prime} - 2 a Z ^ {\\prime 2} - W ^ {\\prime 2}</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime \\prime} = 2 W ^ {\\prime} Z ^ {\\prime}</span></div>

    <p class="text-gray-300">To discuss completeness of these formulas, we must define what is a valid representation of the point-at-infinity. Indeed, we only specified that  <span class="math">(0:W:0)</span>  (for any  <span class="math">W\\neq 0</span> ) represents the point  <span class="math">N</span>  (the point of order 2 on the curve, with coordinates  <span class="math">(x,y) = (0,0)</span> ). We formally define that the point-at-infinity is  <span class="math">\\mathbb{O} = (W^2:W:0)</span>  for any  <span class="math">W\\neq 0</span> . It is easily verified that when applied on either  <span class="math">N</span>  or  <span class="math">\\mathbb{O}</span> , then  <span class="math">\\psi_{1}</span>  and  <span class="math">\\psi_{1 / 2}^{\\prime}</span>  yield a valid representation of  <span class="math">\\mathbb{O}</span> , while  <span class="math">\\theta_{1 / 2}^{\\prime}</span>  yields a valid representation of  <span class="math">N</span> . Therefore, all these formulas are complete.</p>

    <p class="text-gray-300">By using  <span class="math">2WZ = (W + Z)^{2} - W^{2} - Z^{2}</span> , all three functions can be computed with cost 4S. Since  <span class="math">2P + N = \\theta_{1/2}&#x27;(\\psi_1(P))</span> , this naturally leads to an algorithm with cost 8S. This is rarely competitive with the 2M+5S cost of algorithm 2; however, on some specific curves, additional savings can be obtained.</p>

    <p class="text-gray-300">In particular, if  <span class="math">a = 0</span>  (i.e. curves with  <span class="math">j = 1728</span> ), then  <span class="math">\\psi_{1}</span>  and  <span class="math">\\psi_{1/2}&#x27;</span>  can both be computed in cost  <span class="math">1\\mathrm{M} + 2\\mathrm{S}</span>  each. In the context of computing  <span class="math">n \\geq 1</span>  successive doublings, we can use  <span class="math">\\psi_{1}</span>  and  <span class="math">\\psi_{1/2}&#x27;</span>  alternately, with only one final  <span class="math">\\theta_{1/2}&#x27;</span>  at the end to get back to  <span class="math">\\mathbb{G}</span> . Moreover, the computation of  <span class="math">Z&#x27;</span>  (in  <span class="math">\\psi_{1}</span> ) then  <span class="math">Z&#x27;&#x27;</span>  (in  <span class="math">\\psi_{1/2}&#x27;</span> ) can be slightly optimized, replacing one multiplication with one squaring. This leads to algorithm 5:</p>

    <p class="text-gray-300">Algorithm 5  <span class="math">n</span>  doublings (Jacobian  <span class="math">(x, w)</span> ), curve  <span class="math">y^2 = x(x^2 + b)</span>  (cost:  <span class="math">n(1\\mathrm{M} + 5\\mathrm{S}) + 1\\mathrm{S}</span> ) Require:  <span class="math">P + N = (X:W:Z)</span>  , integer  <span class="math">n\\geq 1</span> Ensure:  <span class="math">2^{n}P + N = (X^{\\prime}:W^{\\prime}:Z^{\\prime})</span> 1:  <span class="math">(X_{t}:W_{t}:Z_{t})\\gets (X:W:Z)</span> 2: for  <span class="math">1\\leq i\\leq n - 1</span>  do 3:  <span class="math">t_1\\gets W_t^2</span> 4:  <span class="math">t_2\\gets t_1 - 2X_t</span> <span class="math">\\triangleright t_2 = W_t^2 -2X_t = W_t&#x27;</span> 5:  <span class="math">t_3\\gets t_2^2</span> <span class="math">\\triangleright t_3 = W_t&#x27;^2</span> 6:  <span class="math">Z_{t}\\leftarrow ((W_{t} + t_{2})^{2} - t_{1} - t_{3})Z_{t}</span> <span class="math">\\triangleright Z_{t}^{\\prime \\prime} = 2W_{t}W_{t}^{\\prime}Z_{t}</span> 7:  <span class="math">W_{t}\\gets t_{3} - 2t_{1}^{2}</span> <span class="math">\\triangleright</span>  Note that  <span class="math">t_1^2 = X_t&#x27;^2</span> 8:  <span class="math">X_{t}\\gets t_{3}^{2}</span> 9:  <span class="math">t_1\\gets W_t^2</span> <span class="math">\\triangleright</span>  Final computation of  <span class="math">\\psi_{1}</span> 10:  <span class="math">Z_{t}\\gets W_{t}Z_{t}</span> 11:  <span class="math">W_{t}\\gets t_{1} - 2X</span> 12:  <span class="math">X_{t}\\gets t_{1}^{2}</span> 13:  <span class="math">X^{\\prime}\\gets 16bZ_{t}^{4}</span> <span class="math">\\triangleright</span>  Final computation of  <span class="math">\\theta_{1 / 2}^{\\prime}</span> 14:  <span class="math">W^{\\prime}\\gets 2X_{t} - W_{t}^{2}</span> 15:  <span class="math">Z^{\\prime}\\gets 2W_{t}Z_{t}</span> 16: return  <span class="math">(X^{\\prime}:W^{\\prime}:Z^{\\prime})</span></p>

    <p class="text-gray-300">With algorithm 5, a sequence of <span class="math">n</span> doublings on a GLV curve <span class="math">y^{2} = x^{3} + bx</span> can be computed with cost 1M+5S per doubling, and only 1S of overhead for the whole sequence. For a single doubling (<span class="math">n = 1</span> in algorithm 5), we get a cost of 1M+6S, which is marginally better than 2M+5S and similar to that of algorithm 3 (which we cannot use on such GLV curves, since they require <span class="math">q = 1 \\mod 4</span>).</p>

    <p class="text-gray-300">A per-doubling cost of <span class="math">4\\mathrm{M} + 2\\mathrm{S}</span> can also be obtained on a large class of double-odd elliptic curves, provided that the curve equation constants are chosen appropriately. This relies on the observation that application of <span class="math">\\theta_{1}</span> or <span class="math">\\theta_{1/2}&#x27;</span> yields a value of <span class="math">X</span> which is the square of a known value, multiplied by a small constant. Suppose now that we work in a field <span class="math">\\mathbb{F}_q</span> such that <span class="math">2 \\notin QR</span>; this is equivalent to saying that <span class="math">q = 3</span> or <span class="math">5 \\mod 8</span>. In that case, for a point <span class="math">(x, w) \\in \\mathbb{G}</span>, there exists values <span class="math">F, W</span> and <span class="math">Z</span> such that <span class="math">x = 2(F^2 / Z^2)</span> and <span class="math">w = W / Z</span>. The <span class="math">X</span> coordinate (in Jacobian coordinates) is then <span class="math">X = 2F^2</span>. The application of <span class="math">\\theta_{1}</span> on the point can then be computed as:</p>

    <div class="my-4 text-center"><span class="math-block">F&#x27; = \\left(\\sqrt{(a^2 - 4b)/2}\\right) Z^2</span></div>

    <div class="my-4 text-center"><span class="math-block">W&#x27; = (2F + W)(2F - W) + aZ^2</span></div>

    <div class="my-4 text-center"><span class="math-block">Z&#x27; = WZ</span></div>

    <p class="text-gray-300">Similarly, application of <span class="math">\\theta_{1/2}&#x27;</span> on the result will use:</p>

    <div class="my-4 text-center"><span class="math-block">F&#x27;&#x27; = \\left(\\sqrt{2b}\\right) Z&#x27;^2</span></div>

    <div class="my-4 text-center"><span class="math-block">W&#x27;&#x27; = (2F&#x27; + W&#x27;)(2F&#x27; - W&#x27;) - 2aZ&#x27;^2</span></div>

    <div class="my-4 text-center"><span class="math-block">Z&#x27;&#x27; = 2W&#x27;Z&#x27;</span></div>

    <p class="text-gray-300">These formulas hinge on the fact that if <span class="math">2 \\notin QR</span>, then <span class="math">(a^2 - 4b)/2 \\in QR</span> and <span class="math">2b \\in QR</span>. Both <span class="math">\\theta_1</span> and <span class="math">\\theta_{1/2}&#x27;</span> can be computed in cost 2M+1S, leading to a per-doubling cost of 4M+2S, i.e. "six multiplications". Note though that on small architectures, the relative costs of multiplications and squarings is likely to make it so that an algorithm in 1M+6S per doubling is preferable. Moreover, the requirement that <span class="math">\\sqrt{(a^2 - 4b)/2}</span> and <span class="math">\\sqrt{2b}</span> are "small" (so that multiplication by these constants has low cost) may be restrictive in curve choice.</p>

    <p class="text-gray-300">37</p>

    <p class="text-gray-300">Algorithm 6  <span class="math">n</span>  doublings (Jacobian  <span class="math">(x, w)</span> ) with  <span class="math">q = 3</span>  or 5 mod 8 (cost:  <span class="math">n(4\\mathrm{M} + 2\\mathrm{S}) + 1\\mathrm{M}</span> ) Require:  <span class="math">P + N = (X:W:Z)</span>  , integer  <span class="math">n\\geq 1</span> Ensure:  <span class="math">2^{n}P + N = (X^{\\prime}:W^{\\prime}:Z^{\\prime})</span> 1:  <span class="math">t_1\\gets W^2</span>  ▷ Application of  <span class="math">\\vartheta_{1}</span> 2:  <span class="math">t_2\\gets Z^2</span> 3:  <span class="math">t_3\\gets (W + Z)^2 -t_1 - t_2</span>  ▷  <span class="math">t_3 = 2WZ</span> 4:  <span class="math">F_{t}\\gets (\\sqrt{(a^{2} - 4b) / 2})t_{1}</span> 5:  <span class="math">W_{t}\\gets 2X + at_{2} - t_{1}</span> 6:  <span class="math">Z_{t}\\gets t_{3} / 2</span> 7: for  <span class="math">1\\leq i\\leq n - 1</span>  do 8:  <span class="math">t_1\\gets (2F_t + W_t)(2F_t - W_t)</span>  ▷ Application of  <span class="math">\\vartheta_{1 / 2}^{\\prime}</span> 9:  <span class="math">t_2\\gets Z_t^2</span> 10:  <span class="math">Z_{t}\\gets 2W_{t}Z_{t}</span> 11:  <span class="math">F_{t}\\gets (\\sqrt{2b})t_{2}</span> 12:  <span class="math">W_{t}\\gets t_{1} - 2at_{2}</span> 13:  <span class="math">t_1\\gets (2F_t + W_t)(2F_t - W_t)</span>  ▷ Application of  <span class="math">\\vartheta_{1 / 2}</span> 14:  <span class="math">t_2\\gets Z_t^2</span> 15:  <span class="math">Z_{t}\\gets W_{t}Z_{t}</span> 16:  <span class="math">F_{t}\\gets (\\sqrt{(a^{2} - 4b) / 2})t_{2}</span> 17:  <span class="math">W_{t}\\gets t_{1} + at_{2}</span> 18:  <span class="math">t_1\\gets (2F_t + W_t)(2F_t - W_t)</span>  ▷ Final application of  <span class="math">\\vartheta_{1 / 2}^{\\prime}</span> 19:  <span class="math">t_2\\gets Z_t^2</span> 20:  <span class="math">Z^{\\prime}\\gets 2W_{t}Z_{t}</span> 21:  <span class="math">X^{\\prime}\\gets 4bt_{2}^{2}</span> 22:  <span class="math">W^{\\prime}\\gets t_{1} - 2at_{2}</span> 23: return  <span class="math">(X^{\\prime}:W^{\\prime}:Z^{\\prime})</span></p>

    <p class="text-gray-300">In order to apply the formulas in  <span class="math">(x, u)</span>  coordinates without having to compute a division in  <span class="math">\\mathbb{F}_q</span>  for each point addition, we will use fractional coordinates: point  <span class="math">(x, u)</span>  is represented by a quadruplet  <span class="math">(X:Z:U:T)</span>  which is such that:</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a></p>

    <p class="text-gray-300">With the fractional  <span class="math">(x, u)</span>  representation, using the formulas from section 3.5, the sum of group elements  <span class="math">P_{1} + N = (X_{1}:Z_{1}:U_{1}:T_{1})</span>  and  <span class="math">P_{2} + N = (X_{2}:Z_{2}:U_{2}:T_{2})</span>  is  <span class="math">P_{3} + N =</span></p>

    <p class="text-gray-300"><span class="math">(X_{3}:Z_{3}:U_{3}:T_{3})</span>  such that:</p>

    <p class="text-gray-300"><span class="math">X_{3} = b((X_{1}Z_{2} + X_{2}Z_{1})(T_{1}T_{2} + aU_{1}U_{2}) + 2U_{1}U_{2}(X_{1}X_{2} + bZ_{1}Z_{2}))</span></p>

    <p class="text-gray-300"><span class="math">Z_{3} = (X_{1}X_{2} + bZ_{1}Z_{2})(T_{1}T_{2} - aU_{1}U_{2}) - 2bU_{1}U_{2}(X_{1}Z_{2} + X_{2}Z_{1})</span></p>

    <p class="text-gray-300"><span class="math">U_{3} = -(U_{1}T_{2} + U_{2}T_{1})(X_{1}X_{2} - bZ_{1}Z_{2})</span></p>

    <p class="text-gray-300"><span class="math">T_{3} = (X_{1}X_{2} + bZ_{1}Z_{2})(T_{1}T_{2} + aU_{1}U_{2}) + 2bU_{1}U_{2}(X_{1}Z_{2} + X_{2}Z_{1})</span></p>

    <p class="text-gray-300">Since the original affine formulas are complete, these fractional formulas are equally complete, and guarantee that  <span class="math">Z_{3}</span>  and  <span class="math">T_{3}</span>  are non-zero. These formulas are evaluated by algorithm 7:</p>

    <p class="text-gray-300">Algorithm 7 Addition (fractional  <span class="math">(x,u)</span> ) (cost: 10M) Require:  <span class="math">P_{1} + N = (X_{1}:Z_{1}:U_{1}:T_{1})</span>  and  <span class="math">P_{2} + N = (X_{2}:Z_{2}:U_{2}:T_{2})</span> Ensure:  <span class="math">(P_{1} + P_{2}) + N = (X_{3}:Z_{3}:U_{3}:T_{3})</span> 1:  <span class="math">t_1\\gets X_1X_2</span> 2:  <span class="math">t_2\\gets Z_1Z_2</span> 3:  <span class="math">t_3\\gets U_1U_2</span> 4:  <span class="math">t_4\\gets T_1T_2</span> 5:  <span class="math">t_5\\gets (X_1 + Z_1)(X_2 + Z_2) - t_1 - t_2</span> <span class="math">\\triangleright t_5 = X_1Z_2 + X_2Z_1</span> 6:  <span class="math">t_6\\gets (U_1 + T_1)(U_2 + T_2) - t_3 - t_4</span> <span class="math">\\triangleright t_6 = U_1T_2 + U_2T_1</span> 7:  <span class="math">t_7\\gets t_1 + bt_2</span> <span class="math">\\triangleright t_7 = X_1X_2 + bZ_1Z_2</span> 8:  <span class="math">t_8\\gets t_4t_7</span> 9:  <span class="math">t_9\\gets t_3(2bt_5 + at_7)</span> 10:  <span class="math">t_{10}\\gets (t_4 + at_3)(t_5 + t_7)</span> <span class="math">\\triangleright</span>  Using constant  <span class="math">\\alpha = (4b - a^2) / (2b - a)</span> 11:  <span class="math">X_{3}\\gets b(t_{10} - t_{8} + \\beta t_{9})</span> <span class="math">\\triangleright</span>  Using constant  <span class="math">\\beta = (a - 2) / (2b - a)</span> 12:  <span class="math">Z_{3}\\gets t_{8} - t_{9}</span> 13:  <span class="math">U_{3}\\gets -t_{6}(t_{1} - bt_{2})</span> 14:  <span class="math">T_{3}\\gets t_{8} + t_{9}</span></p>

    <p class="text-gray-300">Algorithm 7 has cost 10M. This assumes that multiplications by the constants  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  are inexpensive, i.e. that the curve parameters  <span class="math">a</span>  and  <span class="math">b</span>  are chosen such that  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  are small integers or fractions. For instance, if  <span class="math">a = -1</span>  and  <span class="math">b = 1/2</span> , then  <span class="math">\\alpha = 1/2</span>  and  <span class="math">\\beta = -3/2</span> . When working with a given curve, it is possible to use an isomorphic curve, by applying the isomorphism described in section 2.5 when input data is converted into or out of fractional coordinates. For instance, still with  <span class="math">a = -1</span>  and  <span class="math">b = 1/2</span> , we can use  <span class="math">s = \\sqrt{-2}</span>  (square root in the field  <span class="math">\\mathbb{F}_q</span> ), which turns the curve equation into  <span class="math">y^2 = x(x^2 + 2x + 2)</span>  and leads, in algorithm 7, to  <span class="math">\\alpha = 2</span>  and  <span class="math">\\beta = 0</span> , making operations involving  <span class="math">\\beta</span>  even simpler.</p>

    <p class="text-gray-300">Similarly, if the curve parameters are such that  <span class="math">2b = a</span> , then  <span class="math">\\alpha</span>  and  <span class="math">\\beta</span>  are not defined, and algorithm 7 cannot be applied as is. In that case, the curve can be converted to an isomorphic curve by applying a change of variable, as we just described. More simply, we will avoid that case when selecting our curve parameters.</p>

    <p class="text-gray-300">If the second input  <span class="math">P_{2} + N</span>  is in affine coordinates, i.e.  <span class="math">Z_{2} = T_{2} = 1</span>  (mixed addition), then computations of  <span class="math">t_{2}</span>  and  <span class="math">t_{4}</span>  become trivial and the total cost drops to 8M. If both inputs are in affine coordinates, then  <span class="math">t_{2}, t_{4}, t_{5}</span>  and  <span class="math">t_{6}</span>  are inexpensive and the total cost is 6M.</p>

    <p class="text-gray-300">If applying algorithm 7 on a point and itself, to compute a doubling, then computations of  <span class="math">t_1</span>  to  <span class="math">t_6</span>  are actually squarings, making the cost  <span class="math">4\\mathrm{M} + 6\\mathrm{S}</span> , which can be lower than  <span class="math">10\\mathrm{M}</span>  if squarings are faster than multiplication on a specific architecture. However, one can do better by temporarily switching to Jacobian coordinates, and converting back to fractional  <span class="math">(x, u)</span>  coordinates on output. Specifically, given a point  <span class="math">P + N = (X:Z:U:T)</span>  on the group  <span class="math">\\mathbb{G}</span>  on curve  <span class="math">E(a, b)</span> , we can apply the isogeny  <span class="math">\\psi_1</span>  (described in section 3.6) to obtain a point  <span class="math">(X&#x27;:W&#x27;:Z&#x27;)</span>  in Jacobian coordinates on curve  <span class="math">E(-2a, a^2 - 4b)[r]</span> , with the following formulas:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime} = Z ^ {2} T ^ {4}</span></div>

    <div class="my-4 text-center"><span class="math-block">W ^ {\\prime} = Z T ^ {2} - (2 X + a Z) U ^ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime} = Z U T</span></div>

    <p class="text-gray-300">These formulas are obtained straightforwardly, by applying the expression of  <span class="math">\\psi_{1}</span> . They are moreover complete: if  <span class="math">P + N = N</span> , then  <span class="math">X = U = 0</span>  and  <span class="math">ZT \\neq 0</span> , hence  <span class="math">W&#x27; = ZT^2 \\neq 0</span> ,  <span class="math">X&#x27; = W&#x27;^2</span> , and  <span class="math">Z&#x27; = 0</span> , which is a valid representation of the point-at-infinity  <span class="math">\\mathbb{O}</span>  in Jacobian coordinates, as we defined it in section 4.1.3.</p>

    <p class="text-gray-300">On such a point, we can then apply  <span class="math">\\delta_{1/2}&#x27;</span>  with an output back in  <span class="math">\\mathbb{G}</span>  (on curve  <span class="math">E(a, b)</span> ) and expressed in fractional  <span class="math">(x, u)</span>  coordinates  <span class="math">(X&#x27;&#x27;: Z&#x27;&#x27;: U&#x27;&#x27;: T&#x27;&#x27;)</span> , with these formulas:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime \\prime} = 4 b Z ^ {\\prime 2}</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime \\prime} = W ^ {\\prime 2}</span></div>

    <div class="my-4 text-center"><span class="math-block">U ^ {\\prime \\prime} = 2 W ^ {\\prime} Z ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">T ^ {\\prime \\prime} = 2 X ^ {\\prime} - 2 a Z ^ {\\prime 2} - W ^ {\\prime 2}</span></div>

    <p class="text-gray-300">We can again verify that these formulas are complete: if  <span class="math">(X&#x27;:W&#x27;:Z&#x27;)</span>  is either  <span class="math">N</span>  or  <span class="math">\\mathbb{O}</span> , then a valid representation of  <span class="math">N</span>  is obtained (with  <span class="math">X&#x27;&#x27; = U&#x27;&#x27; = 0</span>  and  <span class="math">Z&#x27;&#x27;T&#x27;&#x27; \\neq 0</span> ).</p>

    <p class="text-gray-300">Since  <span class="math">\\delta_{1/2}&#x27;(\\psi_1(P + N)) = 2P + N</span> , the composition of these two isogenies computes the double in  <span class="math">\\mathbb{G}</span>  of the source point  <span class="math">P + N</span> . This is expressed by algorithm 8:</p>

    <p class="text-gray-300">|  Algorithm 8 Doubling (fractional (x, u)) (cost: 4M+5S)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P+N=(X:Z:U:T)  |   |</p>

    <p class="text-gray-300">|  Ensure: 2P+N=(X'':Z'':U'':T'')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: t1←ZT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Start of ψ1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: t2←t1T |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: X'←t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X' = Z2T4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: t3←U2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: W'←t2-(2X+aZ)t3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ W' = ZT2-(2X+aZ)U2</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">8: X''←4bt4</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ X'' = 4bZ'2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  9: Z''←W'2 |   |</p>

    <p class="text-gray-300">|  10: t5←W2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">11: U''←(W'+Z')2-t4-t5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ U'' = 2W'Z'</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">As explained above, algorithm 8 is complete; it has cost  <span class="math">4\\mathrm{M} + 5\\mathrm{S}</span> , which is better than the  <span class="math">4\\mathrm{M} + 6\\mathrm{S}</span>  cost resulting from the application of algorithm 7 on two identical operands.</p>

    <p class="text-gray-300">We can do better by using a different way to compute the  <span class="math">x</span>  coordinate of isogenies. Consider that when applying  <span class="math">\\theta_{1}</span>  on a point  <span class="math">(x, w)</span>  to obtain  <span class="math">(x&#x27;, w&#x27;)</span> , then  <span class="math">x&#x27; = (a^{2} - 4b) / w^{2}</span> . We can use the curve equation to replace  <span class="math">w^{2}</span>  with  <span class="math">x + a + b / x</span> , yielding the following formulas:</p>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime} = (a ^ {2} - 4 b) X Z</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime} = X ^ {2} + a X Z + b Z ^ {2}</span></div>

    <div class="my-4 text-center"><span class="math-block">X ^ {\\prime \\prime} = 4 b X ^ {\\prime} Z ^ {\\prime}</span></div>

    <div class="my-4 text-center"><span class="math-block">Z ^ {\\prime \\prime} = X ^ {\\prime 2} - 2 a X ^ {\\prime} Z ^ {\\prime} + (a ^ {2} - 4 b) Z ^ {\\prime 2}</span></div>

    <div class="my-4 text-center"><span class="math-block">U ^ {\\prime \\prime} = 2 (a ^ {2} - 4 b) (X ^ {2} - b Z ^ {2}) Z ^ {\\prime} U</span></div>

    <div class="my-4 text-center"><span class="math-block">T ^ {\\prime \\prime} = \\left(X ^ {\\prime 2} - \\left(a ^ {2} - 4 b\\right) Z ^ {\\prime 2}\\right) T</span></div>

    <p class="text-gray-300">It can be easily verified that these formulas are complete (because  <span class="math">X^2 + aXZ + bZ^2</span>  cannot be zero if  <span class="math">Z \\neq 0</span> ). These formulas lead to a point doubling algorithm with cost  <span class="math">3\\mathrm{M} + 6\\mathrm{S}</span> :</p>

    <p class="text-gray-300">Algorithm 9 Doubling (fractional  <span class="math">(x, u)</span> ) (cost:  <span class="math">3\\mathrm{M} + 6\\mathrm{S}</span> ) Require:  <span class="math">P + N = (X:Z:U:T)</span> Ensure:  <span class="math">2P + N = (X&#x27;&#x27;:Z&#x27;&#x27;:U&#x27;&#x27;:T&#x27;&#x27;)</span> 1:  <span class="math">t_1 \\gets X^2</span> 2:  <span class="math">t_2 \\gets Z^2</span> 3:  <span class="math">t_3 \\gets (X + Z)^2 - t_1 - t_2</span> 4:  <span class="math">X&#x27; \\gets ((a^2 - 4b)/2)t_3</span> 5:  <span class="math">Z&#x27; \\gets t_1 + bt_2 + (a/2)t_3</span> 6:  <span class="math">t_4 \\gets X&#x27;^2</span> 7:  <span class="math">t_5 \\gets Z&#x27;^2</span> 8:  <span class="math">t_6 \\gets (X&#x27; + Z&#x27;)^2 - t_4 - t_5</span> 9:  <span class="math">X&#x27;&#x27; \\gets 2bt_6</span> 10:  <span class="math">Z&#x27;&#x27; \\gets t_4 + (a^2 - 4b)t_5 - at_6</span> 11:  <span class="math">U&#x27;&#x27; \\gets 2(a^2 - 4b)(t_1 - bt_2)Z&#x27;U</span> 12:  <span class="math">T&#x27;&#x27; \\gets (t_4 - (a^2 - 4b)t_5)T</span></p>

    <p class="text-gray-300">Algorithm 8 naturally extends to the case of computing  <span class="math">n</span>  successive doublings by noticing that extra doublings on  <span class="math">E(-2a, a^2 - 4b)[r]</span>  can be inserted between the initial  <span class="math">\\psi_1</span>  and the final  <span class="math">\\theta_{1/2}&#x27;</span> . Each such doubling can be computed as  <span class="math">\\psi_1(\\psi_{1/2}&#x27;)(P)</span> , which is generically computable in 8S (since both  <span class="math">\\psi_1</span>  and  <span class="math">\\psi_{1/2}&#x27;</span>  can be computed in 4S each). On some curves, better performance can be obtained. In particular, for GLV curves (with  <span class="math">a = 0</span> ), the inner doublings can be done in only 1M+5S. This leads to the following algorithm:</p>

    <p class="text-gray-300">|  Algorithm 10 n doublings (fractional (x, u)), curve y2 = x(x2 + b) (cost: n(1M+5S)+3M)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P + N = (X:Z:U:T), integer n ≥ 1  |   |</p>

    <p class="text-gray-300">|  Ensure: 2nP + N = (X'':Z'':U'':T'')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: t1← ZT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Start of y1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: t2← t1T |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: X'← t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X' = Z2T4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: t3← U2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: W'← t2 - 2Xt3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ W' = ZT2 - (2X + aZ)U2, with a = 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  7: for 1 ≤ i ≤ n-1 do |   |</p>

    <p class="text-gray-300">|  8: t1← W'2 |   |</p>

    <p class="text-gray-300">|  9: t2← t1 - 2Xt |   |</p>

    <p class="text-gray-300">|  10: t3← t2 |   |</p>

    <p class="text-gray-300">|  11: Z'← ((W' + t2)2 - t1 - t3)Z' |   |</p>

    <p class="text-gray-300">|  12: W'← t3 - 2t12 |   |</p>

    <p class="text-gray-300">|  13: X'← t3 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">14: t4← Z'2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Start of θ'1/2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  15: t5← W'2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16: X''← 4bt4</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X'' = 4bZ'2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  18: Z''← t5 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19: T''← 2X' - t5</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ T'' = 2X' - 2aZ'2 - W'2, with a = 0.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">We note that algorithm 10 has only moderate overhead compared to algorithm 5 (+3M but -1S). Since addition in fractional  <span class="math">(x, u)</span>  coordinates is faster than addition in Jacobian  <span class="math">(x, w)</span>  coordinates (10M instead of  <span class="math">8\\mathrm{M} + 6\\mathrm{S}</span> ), this makes fractional  <span class="math">(x, u)</span>  coordinates nominally competitive with Jacobian  <span class="math">(x, w)</span>  coordinates for point multiplication by a scalar. This also holds when multiplying a base point in affine coordinates (or using a window optimization with window points normalized to affine coordinates).</p>

    <p class="text-gray-300">For other curves, we can use the following generic technique:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>First doubling is performed is  <span class="math">\\psi_{1}</span>  followed by  <span class="math">\\theta_{1/2}^{\\prime}</span>  with result in Jacobian  <span class="math">(x, w)</span>  coordinates.</li>

      <li>Next  <span class="math">n - 2</span>  doublings are done in Jacobian  <span class="math">(x, w)</span>  coordinates.</li>

      <li>Last doubling includes the conversion back into fractional  <span class="math">(x, u)</span>  coordinates.</li>

    </ul>

    <p class="text-gray-300">In the first doubling,  <span class="math">\\psi_{1}</span>  is computed in cost  <span class="math">4\\mathrm{M} + 2\\mathrm{S}</span> , then  <span class="math">\\theta_{1/2}&#x27;</span>  in cost  <span class="math">4\\mathrm{S}</span> . The next  <span class="math">n - 2</span>  doublings can use any of the algorithms from section 4.1.2 with cost  <span class="math">2\\mathrm{M} + 5\\mathrm{S}</span>  (algorithm 2, for all curves),  <span class="math">1\\mathrm{M} + 6\\mathrm{S}</span>  (algorithm 3, when  <span class="math">q = 3 \\mod 4</span> ) or  <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span>  (algorithm 4, for curve  <span class="math">y^{2} = x(x^{2} - x + 1/2)</span> ). The last doubling must include the conversion back to fractional  <span class="math">(x, u)</span>  coordinates; this can be done in cost  <span class="math">2\\mathrm{M} + 5\\mathrm{S}</span>  for all curves, and  <span class="math">2\\mathrm{M} + 4\\mathrm{S}</span>  for curve  <span class="math">y^{2} = x(x^{2} - x + 1/2)</span> .</p>

    <p class="text-gray-300">We show below the generic case (valid for all double-odd curves) in algorithm 11, and the specialized case for curve  <span class="math">y^{2} = x(x^{2} - x + 1 / 2)</span>  in algorithm 12.</p>

    <p class="text-gray-300">|  Algorithm 11 n doublings (fractional (x, u)) (cost: n(2M+5S)+2M+1S)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P+N=(X:Z:U:T), integer n≥2  |   |</p>

    <p class="text-gray-300">|  Ensure: 2nP+N=(X'':Z'':U'':T'')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: t1←ZT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Start of φ1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: t2←t1T |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: X'←t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X' = Z2T4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: t3←U2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: W'←t2-(2X+aZ)t3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ W' = ZT2-(2X+aZ)U2</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  8: t5←Z'2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: X←16bt52</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X = 16bZ'4</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11: Z←(W' + Z')2 - t4 - t5</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Z = 2W'Z'</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  12: for 1≤i≤n-2 do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13: t1←Z2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Simple doubling with algorithm 2.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  15: t3←W2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">16: t4←t32</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ t4 = W4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  18: X'←16bt2t4 |   |</p>

    <p class="text-gray-300">|  19: W'←-(t4+(4b-a2)t2) |   |</p>

    <p class="text-gray-300">|  20: Z'←t5(2X+at1-t3) |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">21: t1←W2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Final doubling with result in fractional (x, u).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  22: t2←Z2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">23: t3←(W+Z)2 - t1 - t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ t3 = 2WZ</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25: X''←bt32</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ X'' = 4bW2Z2</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  26: Z''←W'2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">27: U''←t3W'</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ U'' = 2WW'Z</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Algorithm 12 n doublings (fractional (x, u)), curve y2 = x(x2 - x + 1/2) (cost: n(2M+4S)+2M+2S)  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">---</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Require: P + N = (X:Z:U:T), integer n ≥ 2  |   |</p>

    <p class="text-gray-300">|  Ensure: 2nP + N = (X'':Z'':U'':T'')  |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">1: t1← ZT</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Start of ψ1</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  2: t2← t1T |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">3: X'← t2</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X' = Z2T4</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  5: t3← U2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">6: W'← t2 - (2X - Z)t3</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ W' = ZT2 - (2X + aZ)U2, with a = -1.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  8: t5← Z'2 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">9: X← 8t52</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ X = 16bZ'4, with b = 1/2.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">11: Z← (W' + Z')2 - t4 - t5</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Z = 2W'Z'</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  12: for 1 ≤ i ≤ n-2 do |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">13: t1← WZ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Simple doubling with algorithm 4.</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">15: t3← (W + Z)2 - 2t1</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ t3 = W2 + Z2 = W2 - aZ2, with a = -1.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  16: W← 2t2 - t32 |   |</p>

    <p class="text-gray-300">|  17: Z← 2t1(2X - t3) |   |</p>

    <p class="text-gray-300">|  18: X← 8t22 |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">19: t1← WZ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">▷ Final doubling with result in fractional (x, u).</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">21: t3← (W + Z)2 - 2t1</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ t3 = W2 - aZ2, with a = -1.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">22: X''← 4t2</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ X'' = 4bW2Z2</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">23: Z''← (2X - t3)2</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ Z'' = (2X + aZ2 - W2)2, with a = -1.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">24: U''← 2t1(2X - t3)</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ U'' = 2WZ(2X + aZ2 - W2), with a = -1.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">25: T''← 2t2 - t32</td>

            <td class="px-3 py-2 border-b border-gray-700">▷ T'' = -(W4 - (a2 - 4b)Z4), with a = -1 and b = 1/2.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Algorithms 10, 11 and 12 are complete, since they only use complete formulas.</p>

    <p class="text-gray-300">In the case of using a base field such that  <span class="math">q = 3 \\mod 4</span>  and computing  <span class="math">n</span>  doublings with algorithm 11, the  <span class="math">n - 2</span>  inner doublings can use algorithm 3 (with cost  <span class="math">1\\mathrm{M} + 6\\mathrm{S}</span>  each) instead of algorithm 2 (with cost  <span class="math">2\\mathrm{M} + 5\\mathrm{S}</span>  each), which can yield a slight speed-up on architectures where squarings are faster than generic multiplications. Similarly, when  <span class="math">q = 3</span>  or 5 mod 8, the formulas used in algorithm 6 can also be applied here, leading to an overall cost of  <span class="math">n(4\\mathrm{M} + 2\\mathrm{S}) + 2\\mathrm{M} + 2\\mathrm{S}</span> .</p>

    <p class="text-gray-300">Ladder algorithms are a type of point multiplication algorithm in which scalar bits are processed one by one, in a succession of steps which are identical to each other save for a conditional exchange of some state values, controlled by the current scalar bit. The main example is that of Montgomery curves, such as the well-known Curve25519[4]. A comprehensive sur</p>

    <p class="text-gray-300">vey of formulas pertaining to Montgomery curves and some other curves is presented in <em>[11]</em>. The gist of the ladder on Montgomery curves is the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The successive steps are a double-and-add algorithm, starting with a base point <span class="math">P_{0}</span>. Each step modifies the current point <span class="math">P</span>, replacing it with either <span class="math">2P</span> or <span class="math">2P+P_{0}</span>.</li>

      <li>The current point is not stored as a pair of coordinates, but represented by the <span class="math">x</span> coordinates of two points <span class="math">P_{1}</span> and <span class="math">P_{2}</span>, which are such that <span class="math">P_{1}=P</span> and <span class="math">P_{2}=P_{1}+P_{0}</span>.</li>

      <li>The <span class="math">x</span> coordinate of either <span class="math">2P_{1}</span> (respectively <span class="math">2P_{2}</span>) can be computed from the <span class="math">x</span> coordinate of <span class="math">P_{1}</span> (respectively <span class="math">P_{2}</span>) directly. The <span class="math">x</span> coordinate of <span class="math">P_{3}=P_{1}+P_{2}</span> can be computed with relatively simple formulas from the <span class="math">x</span> coordinates of <span class="math">P_{1}</span>, <span class="math">P_{2}</span> and <span class="math">P_{0}</span>.</li>

    </ul>

    <p class="text-gray-300">An important feature of this algorithm is that only <span class="math">x</span> coordinates are used. The formulas typically use a fractional representation (each <span class="math">x</span> coordinate is provided as a fraction). On Montgomery curves, the overall cost is 5M+4S per scalar bit, assuming that curve equation constants are small integers, and that the <span class="math">x</span> coordinate of the base point <span class="math">P_{0}</span> is provided as a single non-fractional value <span class="math">x_{0}</span>.</p>

    <p class="text-gray-300">In <em>[11]</em>, the general case of short Weierstraß curves, and the more specific case of curves of even order (a class of curves that includes both double-odd curves and Montgomery curves), are briefly studied. In there, it is asserted that for curves with equation <span class="math">y^{2}=x(x^{2}+ax+b)</span>, the corresponding ladder has a cost of 7M+6S (2M+4S for computing <span class="math">2P_{1}</span>, and 5M+2S for <span class="math">P_{1}+P_{2}</span>, assuming a non-fractional <span class="math">x_{0}</span>). We can, however, do better on double-odd curves. First, consider a source point <span class="math">P=(x,\\,w)</span> in <span class="math">\\mathbb{G}</span>. The <span class="math">\\theta_{1}</span> isogeny (defined in section 3.6) maps <span class="math">P_{1}</span> to <span class="math">(x^{\\prime},\\,w^{\\prime})</span>, with:</p>

    <p class="text-gray-300"><span class="math">x^{\\prime}</span> <span class="math">=\\frac{a^{2}-4b}{w^{2}}</span> <span class="math">=\\frac{(a^{2}-4b)x}{x^{2}+ax+b}</span></p>

    <p class="text-gray-300">If <span class="math">x</span> is expressed as the fraction <span class="math">X/Z</span>, and similarly <span class="math">x^{\\prime}=X^{\\prime}/Z^{\\prime}</span>, then we get:</p>

    <p class="text-gray-300"><span class="math">X^{\\prime}</span> <span class="math">=(a^{2}-4b)XZ</span> <span class="math">Z^{\\prime}</span> <span class="math">=X^{2}+aXZ+bZ^{2}</span></p>

    <p class="text-gray-300">Note that these expressions are complete, since, on a double-odd curve, <span class="math">X^{2}+aXZ+bZ^{2}</span> cannot be zero as long as <span class="math">Z\\neq 0</span>. We can rewrite <span class="math">Z^{\\prime}</span> as:</p>

    <p class="text-gray-300"><span class="math">Z^{\\prime}=(X+Z)(X+bZ)+(a-1-b)XZ</span></p>

    <p class="text-gray-300">which implies that, in that representation, <span class="math">\\theta_{1}</span> can be computed in cost 2M. The same applies to <span class="math">\\theta^{\\prime}_{1/2}</span>. Since the composition of <span class="math">\\theta_{1}</span> and <span class="math">\\theta^{\\prime}_{1/2}</span> is equivalent to a point doubling, this implies that we can compute the <span class="math">x</span> coordinate of <span class="math">2P_{1}</span>, from the <span class="math">x</span> coordinate of <span class="math">P_{1}</span>, in cost 4M (take care that we are considering here doubling in <span class="math">\\mathbb{G}</span>).</p>

    <p class="text-gray-300">For the addition <span class="math">P_{3}=P_{1}+P_{2}</span>, we can use the formulas from section 3.3:</p>

    <p class="text-gray-300"><span class="math">x_{3}=\\frac{bx_{1}x_{2}(w_{1}+w_{2})^{2}}{(x_{1}x_{2}-b)^{2}}</span></p>

    <p class="text-gray-300">and, similarly, for <span class="math">P_0 = P_2 - P_1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">x_0 = \\frac{b x_1 x_2 (w_2 - w_1)^2}{(x_1 x_2 - b)^2}</span></div>

    <p class="text-gray-300">Multiplying the two values together, and simplifying with <span class="math">xw^2 = x^2 + ax + b</span>, we obtain that:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} x_3 x_0 &amp;amp;= \\frac{b (x_1 x_2 (w_2^2 - w_1^2))^2}{(x_1 x_2 - b)^4} \\\\ &amp;amp;= \\frac{b ((x_1 x_2 - b)(x_1 - x_2))^2}{(x_1 x_2 - b)^4} \\\\ &amp;amp;= \\frac{b (x_1 - x_2)^2}{(x_1 x_2 - b)^2} \\end{aligned}</span></div>

    <p class="text-gray-300">Applying a fractional representation of <span class="math">x_1, x_2</span> and <span class="math">x_3</span> (but assuming that <span class="math">x_0</span> is non-fractional), we obtain the following:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{aligned} X_3 &amp;amp;= b (X_1 Z_2 - X_2 Z_1)^2 \\\\ Z_3 &amp;amp;= x_0 (X_1 X_2 - b Z_2 Z_1)^2 \\end{aligned}</span></div>

    <p class="text-gray-300">We derived these expressions assuming that none of the points <span class="math">P_0, P_1, P_2</span> or <span class="math">P_3</span> was the neutral <span class="math">\\mathcal{N}</span>, but it can easily be seen that the formulas are still correct if <span class="math">P_1, P_2</span> and/or <span class="math">P_3</span> is <span class="math">\\mathcal{N}</span>, as long as <span class="math">P_0 \\neq \\mathcal{N}</span>, i.e. <span class="math">x_0 \\neq 0</span>.</p>

    <p class="text-gray-300">These formulas can be computed in cost 4M+2S by noticing that:</p>

    <div class="my-4 text-center"><span class="math-block">X_1 Z_2 - X_2 Z_1 = (X_1 - Z_1)(X_2 + Z_2) - X_1 X_2 + Z_1 Z_2</span></div>

    <p class="text-gray-300">In total, these formulas lead to a ladder algorithm with cost 8M+2S per scalar bit. This is slower than the 5M+4S achievable with Montgomery ladders, but quite faster than the previously reported 7M+6S.</p>

    <p class="text-gray-300"><strong>Using only w.</strong> We saw in section 2.4 that elements of <span class="math">\\mathbb{G}</span> are encoded as their <span class="math">w</span> coordinate. While it is possible to recover the <span class="math">x</span> coordinate from <span class="math">w</span>, this has a non-negligible cost (a square root and a Legendre symbol) which we would prefer to avoid when using a ladder implementation. In Montgomery curves, no point decompression is needed as long as the <span class="math">x</span> coordinate of <span class="math">P_0</span> is provided, and the required final result is not the complete point <span class="math">kP_0</span> (for scalar <span class="math">k</span>) but only the <span class="math">x</span> coordinate thereof; this is sufficient for key exchange with Diffie-Hellman, which is traditionally defined to only use the <span class="math">x</span> coordinate of the resulting point as shared key.</p>

    <p class="text-gray-300">We can obtain similar characteristics if we define that a key exchange over a double-odd curve should use, as final shared secret, the value <span class="math">w^2</span>, for the <span class="math">w</span> coordinate of <span class="math">kP_0</span>. Indeed:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For any point <span class="math">P = (x, w)</span> in <span class="math">\\mathbb{G}(a, b)</span>, the <span class="math">x</span> coordinate of <span class="math">\\mathcal{S}_1(P)</span> is <span class="math">(a^2 - 4b)/w^2</span>. We can thus apply the ladder not in <span class="math">\\mathbb{G}(a, b)</span>, but in the dual curve <span class="math">\\mathbb{G}(-2a, a^2 - 4b)</span>.</li>

      <li>The value <span class="math">x_0</span> is obtained as <span class="math">x_0 = (a^2 - 4b)/w_0^2</span>, which seems fractional, but does not induce any additional overhead in practice: in the computation of <span class="math">X_3</span> and <span class="math">Z_3</span>, this merely implies that the multiplication by <span class="math">x_0</span> on the denominator is replaced with a multiplication by <span class="math">w_0^2/(a^2 - 4b)</span> on the numerator.</li>

      <li>The final value is obtained as a fraction. Since it contains <span class="math">(a^2 - 4b)/w^2</span>, where <span class="math">w^2</span> is the sought value, it suffices to reduce the inverse of the fraction instead of the fraction, with no extra overhead.</li>

    </ul>

    <p class="text-gray-300">46</p>

    <p class="text-gray-300">Input validation and "twist security". Curve25519[4] avoids any validation on the input by selecting the curve such that it has order  <span class="math">8r</span>  for some prime  <span class="math">r</span> , but its quadratic twist also has order  <span class="math">4r&#x27;</span>  for some other prime  <span class="math">r&#x27;</span> . It can be shown that when a value  <span class="math">x</span>  is received and it is not the  <span class="math">x</span>  coordinate of a point on the curve in the base field, then it is the  <span class="math">x</span>  coordinate of a point on the same curve but in a quadratic field extension  <span class="math">\\mathbb{F}_{q^2}</span> . The  <span class="math">x</span> -only ladder algorithm can thus proceed, but it really computes in a subgroup of the curve over  <span class="math">\\mathbb{F}_{q^2}</span> , and that specific subgroup happens to be homomorphic to a subgroup of the quadratic twist of the curve on the base field  <span class="math">\\mathbb{F}_q</span> . Since the algorithm takes care to always use a scalar (private key) which is a multiple of 8, this usage is safe within the context of a Diffie-Hellman key exchange: even if an attacker sends an invalid point which is not on the curve, the computation proceeds in another group of large prime order, which is sufficient to avoid leaking information about the private key.</p>

    <p class="text-gray-300">This trick has been called "twist security", and presented as an extra security feature of the curve. It could have equally been described as a constraint on curve selection, made necessary by the absence of input validation in the scalar multiplication algorithm. It must be noted, also, that  <span class="math">x</span> -only algorithms are the only situation where that constraint is useful: the "twist security" is not a general protection against invalid curve attacks. For instance, on short Weierstraß curves but also on twisted Edwards curves, accepting an invalid input does not imply that subsequent operations will run over a curve subgroup homomorphic to a subgroup of the quadratic twist.</p>

    <p class="text-gray-300">In the case of double-odd elliptic curves, our goal is to provide a verifiable prime order group, free of extra issues that may complicate design and analysis of protocols built upon it. In the case of a Diffie-Hellman key exchange, this stance would call for proper input validation, instead of implicitly using the quadratic twist, because the latter would require extra analysis to show that it is safe in the context of the protocol that uses this key exchange. Therefore, we prefer to verify that the input value  <span class="math">w</span>  is correct. This can be done relatively efficiently by noticing that point decoding involves computing the discriminant  <span class="math">\\Delta = (w^2 - a)^2 - 4b</span>  of a quadratic equation (see section 2.4); the value  <span class="math">w</span>  is decodable, i.e. correct, if and only if  <span class="math">\\Delta</span>  is a quadratic residue. This can be tested with a Legendre symbol computation; there is no need for a square root computation. As previously described, on some architectures (especially small embedded systems), Legendre symbol computations are much cheaper than square roots. This input validation would cost less than  <span class="math">2\\%</span>  of the overall point multiplication on an ARM Cortex M0+ with a 256-bit field.</p>

    <p class="text-gray-300">As long as we perform input validation, there is no need to select a curve with "twist security". This is not a bad property that should be avoided, but it has a definitely lower priority in the curve selection process than, for instance, choosing the curve parameters  <span class="math">a</span>  and  <span class="math">b</span>  so that the multiplications by the constants involved in the various formulas are efficient.</p>

    <p class="text-gray-300">Table 1 shows a summary of the costs of the formulas presented in the previous sections. For half of possible field choices (specifically, fields  <span class="math">\\mathbb{F}_q</span>  where  <span class="math">q = 3</span>  or 5 mod 8), we can compute sequences of successive doublings with a cost of six multiplications per doubling (4M+2S generally, but down to 1M+5S for GLV curves with  <span class="math">j = 1728</span> ). The overhead for such a sequence is higher when working in fractional  <span class="math">(x,u)</span>  coordinates than in Jacobian  <span class="math">(x,w)</span>  co</p>

    <p class="text-gray-300">ordinates; a contrario, fractional  <span class="math">(x,u)</span>  coordinates have better performance for generic point addition and mixed point addition.</p>

    <p class="text-gray-300">Point additions (but not doublings) in Jacobian coordinates use unified formulas and can be implemented into complete routines by way of using a few inexpensive CONDCOPY calls to properly handle situations when one of the inputs is the neutral  <span class="math">N</span> . All other formulas, including doublings in Jacobian coordinates, are complete, and their implementation is straightforward from the arithmetic formulation.</p>

    <p class="text-gray-300">The  <span class="math">x</span> -only addition (called "X-add" in table 1) relies on the specific relationship between the operands maintained in the ladder algorithm (namely, that the  <span class="math">x</span>  coordinate of the difference of the two points is known and a non-fractional value).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Coordinates</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Addition</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Mixed add</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Doubling</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">n doublings</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Jacobian (x, w)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+3S</td>

            <td class="px-3 py-2 border-b border-gray-700">2M+5S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(2M+5S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q = 3 mod 4</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+3S</td>

            <td class="px-3 py-2 border-b border-gray-700">1M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(1M+6S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q = 3 or 5 mod 8</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+3S</td>

            <td class="px-3 py-2 border-b border-gray-700">2M+5S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(4M+2S)+1M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">a = 0 (GLV)</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+3S</td>

            <td class="px-3 py-2 border-b border-gray-700">1M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(1M+5S)+1S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y2 = x(x2 - x + 1/2)</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+3S</td>

            <td class="px-3 py-2 border-b border-gray-700">2M+4S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(2M+4S)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractional (x, u)</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(2M+5S)+2M+1S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q = 3 mod 4</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(1M+6S)+4M-1S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">q = 3 or 5 mod 8</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(4M+2S)+2M+2S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">a = 0 (GLV)</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(1M+5S)+3M</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">y2 = x(x2 - x + 1/2)</td>

            <td class="px-3 py-2 border-b border-gray-700">10M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M</td>

            <td class="px-3 py-2 border-b border-gray-700">3M+6S</td>

            <td class="px-3 py-2 border-b border-gray-700">n(2M+4S)+2M+2S</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Coordinates</td>

            <td class="px-3 py-2 border-b border-gray-700">Curve</td>

            <td class="px-3 py-2 border-b border-gray-700">X-add</td>

            <td class="px-3 py-2 border-b border-gray-700">X-double</td>

            <td class="px-3 py-2 border-b border-gray-700">Ladder (per scalar bit)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Fractional x</td>

            <td class="px-3 py-2 border-b border-gray-700">any</td>

            <td class="px-3 py-2 border-b border-gray-700">4M+2S</td>

            <td class="px-3 py-2 border-b border-gray-700">4M</td>

            <td class="px-3 py-2 border-b border-gray-700">8M+2S</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Summary of formula costs.</p>

    <p class="text-gray-300">In this section, we select and describe two specific curves that leverage the algorithms explained in section 4.</p>

    <p class="text-gray-300">Curve parameters should be chosen so as to maximize performance for a given security level. "Performance" is a polysemic term; it covers consumption of many resource types such as computation time, RAM, power, and ROM/Flash size, and these values greatly vary depending on the target architecture. Here, we focus on software architectures, with the three following classes of hardware platforms:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Small embedded systems, whose internal multiplier cannot handle operands larger than 16 bits without truncation. This category includes the ARM Cortex M0+ CPU, whose muls opcode accepts 32-bit operands, but returns only the low 32 bits of the result.</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Larger embedded systems that can compute <span class="math">32 \\times 32 \\rightarrow 64</span> multiplications with relative ease. In this category, one will find the ARM Cortex M4, many microcontrollers based on MIPS or RISC-V cores, and others 32-bit platforms.</li>

      <li>Big desktop and server systems with 64-bit registers and efficient <span class="math">64 \\times 64 \\rightarrow 128</span> multipliers. Such systems offer what can practically be viewed as infinite RAM, but with heavy access penalties when reaching values which are not in L1 cache. These architectures also often have extensive SIMD instruction sets that can help with parallel implementations. This category also includes powerful mobile devices such as laptop computers and smartphones.</li>

    </ul>

    <p class="text-gray-300">We are aiming for the "128-bit" security level, which, in practice, means that the prime order group <span class="math">\\mathbb{G}</span> should have order <span class="math">r \\geq 2^{250}</span> or so<span class="math">^{12}</span>. Typical existing curves in that category include NIST P-256 (order about <span class="math">2^{256}</span>), secp256k1 (order about <span class="math">2^{256}</span>) and Curve25519 (order about <span class="math">2^{252}</span>). We favour fields of integers modulo a prime <span class="math">q = 2^{255} - m</span> for a very small integer <span class="math">m</span>; this format has some advantages:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Reduction of a large integer modulo <span class="math">q</span> is inexpensive, thanks to the choice of <span class="math">m</span>. The best choice of <span class="math">m</span> would be 1, but this is not possible since <span class="math">2^{255} - 1</span> is not prime. The next best choice is a small <span class="math">m &amp;lt; 2^{15}</span>; on small systems with the ARM Cortex M0+ CPU, all multipliers <span class="math">m</span> up to 15 bits yield basically equivalent performance.</li>

      <li>Use of the exponent 255 instead of 256 makes the curves more directly comparable to Curve25519 (which uses <span class="math">q = 2^{255} - 19</span>) and can enable some alternate representations, e.g. using 51-bit limbs (since <span class="math">255 = 5 \\times 51</span>). Even when representing values over 32-bit or 64-bit limbs, the use of a 255-bit modulus <span class="math">q</span> means that an extra bit is available to spill carries, which is convenient in some corner cases.</li>

    </ul>

    <p class="text-gray-300">In all our algorithms, we made cost estimates under the assumption that multiplication by the curve constants <span class="math">a</span> and <span class="math">b</span>, and derived constants such as <span class="math">\\alpha = (4b - a^2) / (2b - a)</span> and <span class="math">\\beta = (a - 2) / (2b - a)</span>, are inexpensive. Best constant values are then, in increasing order of cost: <span class="math">0, \\pm 1, 1/2, \\pm 2, 2^r</span> for <span class="math">t &amp;lt; 16</span>, other small integers. Keeping to these "optimal" constants means that our primary selection variable is the field order, rather than the constants themselves.</p>

    <p class="text-gray-300">We do not aim specifically for "twist security", i.e. choosing a curve of order <span class="math">2r</span> (with <span class="math">r</span> prime) such that the quadratic twist has order <span class="math">2r&#x27;</span> with <span class="math">r&#x27;</span> being also prime; see section 4.3 for a discussion about this feature and its usefulness in our case.</p>

    <h2 id="sec-33" class="text-2xl font-bold">5.2 do255e</h2>

    <p class="text-gray-300">Our first choice is a GLV curve, with <span class="math">j = 1728</span>. We saw that such curves allow for some of our most efficient algorithms, especially for repeated doublings; moreover, such curves come with efficiently computable endomorphisms that yield substantial performance improvements for</p>

    <p class="text-gray-300"><span class="math">^{12}</span>The “128-bit” level means that attacks should require at least <span class="math">2^{128}</span> simple operations. Generic algorithms for computing discrete logarithm in a group with <span class="math">2^{2n}</span> elements require <span class="math">2^n</span> operations, where each operation is an application of the group law. However, application of the group law implies quite a few “simple operations”; e.g. on double-odd curves, it requires at least 6 multiplications or squarings in the field, and each such multiplication or squaring itself needs a substantial amount of work, and close to 40 cycles on modern large 64-bit CPUs. This is why we can normally claim to reach the traditional level of “128 bits” with fewer than <span class="math">2^{256}</span> group elements.</p>

    <p class="text-gray-300">49</p>

    <p class="text-gray-300">some operations (see section 6.2). We explore moduli  <span class="math">q = 2^{255} - m</span>  with increasing values of  <span class="math">m</span> , aiming for curve  <span class="math">y^2 = x(x^2 + b)</span>  with order  <span class="math">2r</span> , with  <span class="math">r</span>  prime. The following shall be noted:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>As was noted in section 2.5, we need  <span class="math">q = 1</span>  mod 4, since otherwise the curve would be supersingular, and weak. We further require that  <span class="math">q = 5</span>  mod 8 because it helps with the implementation of square roots, compared with  <span class="math">q = 1</span>  mod 8.</li>

      <li>We want  <span class="math">b = \\pm 2</span> , in order to minimize the cost of multiplying by  <span class="math">b</span> . We cannot have  <span class="math">b = 0, 1</span>  or  <span class="math">-1</span> , since all of these are quadratic residues in  <span class="math">\\mathbb{F}_q</span>  when  <span class="math">q = 1 \\mod 4</span> , so the next best choice is  <span class="math">\\pm 2</span> . This is not, in fact, a restrictive condition: for a given  <span class="math">q</span> , there are only four possible curves with  <span class="math">j = 1728</span>  (up to isomorphism) and only two of them will have  <span class="math">b \\notin QR</span> ; using  <span class="math">b = \\pm 2</span>  exhausts all possibilities for double-odd curves.</li>

    </ul>

    <p class="text-gray-300">With such criteria, we find that the first match is for  <span class="math">m = 18651</span> . This gives us our first curve, which we call do255e ("do" stands for "double-odd", "255" is the field width, and "e" is for "endomorphism", i.e. the defining characteristic of a GLV curve):</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Field  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q = 2^{255} - 18651</span></li>

      <li>Curve equation:  <span class="math">y^{2} = x(x^{2} - 2)</span></li>

      <li>Curve order:  <span class="math">2r</span> , with  <span class="math">r = 2^{254} - 131528281291764213006042413802501683931</span></li>

      <li>Conventional generator  <span class="math">G</span> :</li>

    </ul>

    <div class="my-4 text-center"><span class="math-block">G _ {x} = 2</span></div>

    <div class="my-4 text-center"><span class="math-block">G _ {y} = 2</span></div>

    <p class="text-gray-300">The conventional generator  <span class="math">G</span>  was chosen by selecting the group element with the lowest non-zero  <span class="math">u</span>  coordinate (when interpreted as an integer in the 0 to  <span class="math">q - 1</span>  range); in this case,  <span class="math">u = 1</span>  corresponds to a valid element on  <span class="math">\\mathbb{G}</span>  with  <span class="math">x = 2</span>  and  <span class="math">y = 2</span> .</p>

    <p class="text-gray-300">The embedding degree is the minimal field extension degree required for definition of Weil pairings (and similar constructions). For a random curve, this is expected to be very high, close to the group order itself. This is the case here: embedding degree is  <span class="math">(r - 1) / 12 \\approx 2^{250.42}</span> . Thus, the MOV attack[28] is not applicable to do255e.</p>

    <p class="text-gray-300">It so happens that the prime order  <span class="math">r</span>  which we obtain is slightly below  <span class="math">2^{254}</span> , which is convenient for scalar decomposition, as will be explained in section 6.2.</p>

    <p class="text-gray-300">GLV curves have some internal structure which is not found in randomly selected curves, namely the small complex multiplication (CM) discriminant. For any curve defined over field  <span class="math">\\mathbb{F}_q</span>  and with cardinal  <span class="math">n</span> , the quantity  <span class="math">(q + 1 - n)^2 - 4q</span>  is a negative integer. If we factorize that integer and remove all squares of prime factors, then what remains is the CM discriminant; i.e. we write the integer as  <span class="math">DV^2</span>  where  <span class="math">D</span>  is square-free. For randomly selected curves,  <span class="math">D</span>  is normally very large, close to  <span class="math">q</span>  itself in size. However, for curves with  <span class="math">j = 1728</span> ,  <span class="math">D</span>  is minimal: the discriminant is  <span class="math">D = -1</span> . This small discriminant is the reason why there are efficiently computable endomorphisms on the curve (roughly speaking, the smallest degree of any endomorphism on a curve, as a rational function, rises with  <span class="math">D</span> ).</p>

    <p class="text-gray-300">This small discriminant has historically generated some unease about GLV curves. Most of the reluctance was in fact related to the patents which cover the acceleration technique with endomorphisms; however, the relevant patents seem to have expired worldwide in 2019, and in the US in September 2020[17] <span class="math">^{13}</span> . Another well-known GLV curve (with  <span class="math">j = 0</span> ) is secp256k1, which has been extensively used in Bitcoin, and no weakness has been detected in it so far, despite its visibility. Nevertheless, there might still be some lingering resistance to such curves, which is why we propose another double-odd curve which has a large CM discriminant.</p>

    <p class="text-gray-300">We saw (e.g. algorithm 4) that there are some advantages to aim for a curve such that  <span class="math">a^2 = 2b</span> . As was pointed out in section 4.1.2, such curves require  <span class="math">q = 3 \\mod 8</span>  and have  <span class="math">j = 128</span> ; therefore, for any  <span class="math">q</span> , there are only two potential curves to test, with equation  <span class="math">y^2 = x(x^2 \\pm x + 1/2)</span> . Moreover, we prefer to have  <span class="math">a = -1</span>  (so that  <span class="math">-a</span>  is a square), so we end up with only a single equation to test, which is  <span class="math">y^2 = x(x^2 - x + 1/2)</span> .</p>

    <p class="text-gray-300">We thus explore fields of integers modulo  <span class="math">q = 2^{255} - m</span>  for increasing values of  <span class="math">m</span> , such that  <span class="math">q</span>  is prime and  <span class="math">q = 3 \\mod 8</span> , until we find a field such that curve  <span class="math">y^2 = x(x^2 - x + 1/2)</span>  has order  <span class="math">2r</span>  over that field, for a prime integer  <span class="math">r</span> . The first match is for  <span class="math">m = 3957</span> , yielding the curve do255s:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Field  <span class="math">\\mathbb{F}_q</span>  with  <span class="math">q = 2^{255} - 3957</span></li>

      <li>Curve equation:  <span class="math">y^{2} = x(x^{2} - x + 1 / 2)</span></li>

      <li>Curve order:  <span class="math">2r</span> , with  <span class="math">r = 2^{254} + 56904135270672826811114353017034461895</span></li>

      <li>Conventional generator  <span class="math">G</span> :</li>

    </ul>

    <p class="text-gray-300"><span class="math">G_{x} = 26116555989003923291153849381583511726</span></p>

    <p class="text-gray-300">884321626891190016751861153053671511729</p>

    <p class="text-gray-300"><span class="math">G_{y} = 28004200202554007000979780628642488551</span></p>

    <p class="text-gray-300">173104653237157345493551052336745442580</p>

    <p class="text-gray-300">As with do255e, the conventional generator  <span class="math">G</span>  has been chosen as the element of  <span class="math">\\mathbb{G}</span>  with the lowest non-zero  <span class="math">u</span>  coordinate; in this case, the first match is for  <span class="math">u = 3</span> .</p>

    <p class="text-gray-300">It can be noticed that the curve order  <span class="math">n = 2r</span>  induces:</p>

    <p class="text-gray-300"><span class="math">(q + 1 - n)^{2} - 4q = -2^{3}\\times 4733\\times 21559\\times 4008140143618905971</span></p>

    <p class="text-gray-300"><span class="math">\\times 66821379857449408346450655102995637941435764209893</span></p>

    <p class="text-gray-300">leading to the CM discriminant  <span class="math">D = ((q + 1 - n)^2 - 4q) / 4 \\approx -2^{254.917}</span> , which is very large, as is expected of any "non-special" curve.</p>

    <p class="text-gray-300">The embedding degree of do255s is  <span class="math">r - 1 \\approx 2^{254.00}</span> : just like do255e, do255s is not vulnerable to pairing-based attacks.</p>

    <p class="text-gray-300">52</p>

    <p class="text-gray-300">In this section we discuss implementation issues. In particular:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A succinct specification for high-level cryptographic operations (key exchange, signatures) over do255e and do255s is given in section 6.1.</li>

      <li>Section 6.2 shows how the GLV endomorphism applies to curve do255e to speed up multiplications of points by scalars.</li>

      <li>Our implementation on 64-bit x86 (Coffee Lake) is described in section 6.3. The implementation on the much smaller ARM Cortex M0+ is described in section 6.4.</li>

    </ul>

    <h2 id="sec-38" class="text-2xl font-bold">6.1 High-Level Cryptographic Operations</h2>

    <p class="text-gray-300">While do255e and do255s are, by nature, generic groups usable in arbitrarily many high-level protocol designs, it is beneficial to specify the core functionalities of key pair generation, public and private key encoding, key exchange (Diffie-Hellman) and signatures. In the case of Curve25519 and Ed25519, this was historically not done in the initial publications, and it led to a large variety of behaviours of implementations when faced with edge cases such as keys with value zero, low-order points, ignored bits and malleability[40]. We would prefer to avoid such a situation for do255e and do255s, hence this section.</p>

    <h2 id="sec-39" class="text-2xl font-bold">6.1.1 Bytes and Encoding Formats</h2>

    <p class="text-gray-300">We use 8-bit bytes (formally, octets) and every encoding format is an ordered sequence of bytes with a fixed length. Two types of primitive elements are encoded: elements of the base field <span class="math">\\mathbb{F}_q</span> (integers modulo <span class="math">q</span>), and scalars (integers modulo the prime <span class="math">r</span>). The following rules apply:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The value is encoded as an integer on the 0 to <span class="math">q - 1</span> (for base field elements) or 0 to <span class="math">r - 1</span> (for scalars) range. Encoding convention is unsigned little-endian over exactly 32 bytes (size does not depend on the numerical value); the least significant byte comes first, the last significant comes last.</li>

      <li>When decoding, the value MUST be verified to be in the proper range. Any value which is not strictly lower than the modulus MUST be rejected.</li>

      <li>It so happens that <span class="math">q</span> and <span class="math">r</span> are lower than <span class="math">2^{255}</span> for both curves. Therefore, the most significant bit of the last encoding byte is always zero. However, this bit MUST NOT be ignored when decoding; the encoding has length exactly 32 bytes and all bits of all bytes are taken into account<span class="math">^{14}</span>.</li>

    </ul>

    <p class="text-gray-300">In the specifications below, we use literal strings in various places as domain separation tags. The strings are listed with double-quote characters, e.g. "do255e-ecdh:"; this must be understood as a sequence of bytes, one per string character, without the double quotes. There is no length prefix, and no terminating null bytes; thus, this example string has length 12 bytes, the first byte is 0x64, and the last byte is 0x3A.</p>

    <p class="text-gray-300"><span class="math">^{14}</span>It is of course feasible for any application to apply further encoding layers and to leverage the fact that the top bit is always zero to, for instance, encode some other data in that bit. However, in that case, the top bit MUST be cleared before considering the value as an encoded base field element or scalar.</p>

    <p class="text-gray-300">6.1.2 Group Elements, Private and Public Keys</p>

    <p class="text-gray-300">An element of the group <span class="math">\\mathbb{G}</span> is a point with coordinates <span class="math">(x, w)</span>, or the neutral <span class="math">N</span>. The encoding of a group element is the encoding of its <span class="math">w</span> coordinate, which is a base field element (for point <span class="math">N</span>, the value is zero). The decoding process is described in section 2.4 and involves computing a square root, then a Legendre symbol. The square root computation may fail, in which case the input sequence of bytes is not a valid point encoding. All point decoding activities MUST reject invalid encodings. Note that all rules for field element encoding apply as well; thus, a sequence of bytes may be successfully decoded into a group element only if that element would be encoded back into that exact sequence of bytes, and none other. In other words, encoding is always <em>canonical</em>.</p>

    <p class="text-gray-300">Public keys are group elements which are distinct from the neutral <span class="math">N</span>. If the decoding process specified above succeeds but the obtained group element is <span class="math">N</span>, then it MUST be explicitly rejected.</p>

    <p class="text-gray-300">Private keys are scalars, and encoded as scalars (over 32 bytes). A private key of value zero is NOT valid, and it MUST be rejected if encountered.</p>

    <p class="text-gray-300">The public key corresponding to a private key <span class="math">d</span> is the point <span class="math">dG</span>, where <span class="math">G</span> is the conventional generator for the group. Since <span class="math">d</span> is a non-zero scalar, the public key is a non-neutral group element, and every non-neutral group element corresponds to a single private key. Applications may find it convenient, for performance reasons, to store key pairs <span class="math">(d, dG)</span>, instead of just private keys: the public key corresponding to a given private key can always be recomputed from the private key, but retrieval from storage is usually faster. If an application uses key pair storage, then it is up to it to ensure that stored public keys match the corresponding stored private keys.</p>

    <h4 id="sec-40" class="text-lg font-semibold mt-6">6.1.3 Private Key Generation</h4>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">A properly generated private key is chosen uniformly at random among non-zero integers modulo the prime group order <span class="math">r</span>. The source of randomness must be cryptographically strong and have sufficient entropy for the target security level (128 bits). In the case of do255e and do255s, <span class="math">r</span> is very close to a power of two (in both cases, $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">r-2^{254}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><2^{127}<span class="math">); this implies that it is acceptable to obtain only 256 bits (32 bytes) from a source of uniformly random bytes, interpret that value as an integer in the 0 to </span>2^{256}-1<span class="math"> range, then reduce it modulo </span>r$ (which can be done with only two conditional subtractions).</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h4 id="sec-41" class="text-lg font-semibold mt-6">6.1.4 Key Exchange</h4>

    <p class="text-gray-300">Key exchange happens between two parties. Each party has generated its own key pair, denoted <span class="math">(d_{1},d_{1}G)</span> and <span class="math">(d_{2},d_{2}G)</span> for parties 1 and 2, respectively. The parties send their public keys to each other. Party 1 computes <span class="math">P_{1}=d_{1}(d_{2}G)</span>, while party 2 computes <span class="math">P_{2}=d_{2}(d_{1}G)</span>; if no communication error or alteration happened, then <span class="math">P_{1}=P_{2}</span>. This is a Diffie-Hellman process<em>[13]</em>. The resulting shared secret is the field element <span class="math">w^{2}</span>, for the coordinate <span class="math">w</span> of the shared element <span class="math">P_{1}=P_{2}</span>.</p>

    <p class="text-gray-300">The following rules apply:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Elements are private and public keys; thus, the relevant rules apply. In particular, private keys are non-zero, and public keys are not the neutral. Parties MUST reject public keys with invalid encodings, notably public keys that are the valid encoding of the neutral <span class="math">N</span></li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If the process succeeds, then the key rules imply that the resulting point is not the neutral <span class="math">N</span>. Therefore, its <span class="math">w</span> coordinate is well-defined. We use <span class="math">w^2</span>, not <span class="math">w</span>, as the shared secret, in order to allow use of <span class="math">w</span>-only ladders as described in section 4.3 (these ladder algorithms are not as efficient as “normal” point multiplication, but they lead to simpler implementations with very low RAM requirements, and thus may be preferable in some situations).</li>

      <li>The shared secret is not used as is; it must be derived into shared key material. For key derivation, we use the SHAKE256[22] function. The input to SHAKE256 is the concatenation of the following elements:</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The ASCII-encoded string “do255e-ecdh:” or “do255s-ecdh:”, depending on whether the used curve is do255e or do255s.</li>

      <li>If the key exchange process succeeded (local private key was properly encoded and non-zero; peer public key was properly encoded and non-neutral), then:</li>

    </ol>

    <p class="text-gray-300">(a) A single byte of value 0x00.</p>

    <p class="text-gray-300">(b) The encoding of the field element <span class="math">w^2</span> (shared secret).</p>

    <p class="text-gray-300">Otherwise:</p>

    <p class="text-gray-300">(a) A single byte of value 0xFF.</p>

    <p class="text-gray-300">(b) The encoding of the local private key (<span class="math">d_1</span> for party 1, <span class="math">d_2</span> for party 2).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The two public keys involved in the exchange, each as a 32-byte sequence. For this step, the two public keys are interpreted as integers (with unsigned little endian convention), and the numerically lower of the two is injected first.</li>

    </ol>

    <p class="text-gray-300">The SHAKE256 output is then the shared key material resulting from the exchange. Since SHAKE256 output length is unbounded, an arbitrary amount of key material can thus be obtained, depending on the requirements of the protocol that leverages this key exchange.</p>

    <p class="text-gray-300">The key derivation mechanism specified above was designed so that it is possible to hide from outsiders whether the key exchange succeeded or not. This can be useful in some protocols where the sent public keys are not visible to attackers, and it more closely matches the behaviour of Curve25519, albeit with the important difference that the two parties are here perfectly aware of whether the exchange actually worked or not. The use of the local private key in lieu of the shared secret makes the resulting key material unpredictable by attackers, but still reproducible for a given input public key. Since public and private keys are both encoded over exactly 32 bytes, the implementation can make it so that the success status cannot be detected through timing-based side channels.</p>

    <p class="text-gray-300">SHAKE256 processes data by chunks of 136 bytes; the key derivation process above injects only 109 bytes, and thus requires only a single invocation of the internal Keccak permutation.</p>

    <h2 id="sec-42" class="text-2xl font-bold">6.1.5 Signatures</h2>

    <p class="text-gray-300">We define an application of Schnorr signatures. Such a signature is the concatenation of a group element <span class="math">R</span> and a scalar <span class="math">s</span>; its length is 64 bytes. Take care that the group element <span class="math">R</span> is not a public key, i.e. it can be the neutral <span class="math">N</span>; similarly, the scalar <span class="math">s</span> can be zero. For an input data <span class="math">m</span> which is to be signed, we define the hashed message <span class="math">(h)</span> as the concatenation of:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>An identifier for the used hash function. This is the ASCII encoding of the decimal-dotted format of the object identifier (OID) that designates the hash function, followed</li>

    </ol>

    <p class="text-gray-300">54</p>

    <p class="text-gray-300">by a colon (":"). For instance, if using SHA3-256 (as specified in [22]), then the identifier is the string "2.16.840.1.101.3.4.2.8:".</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The binary output of the identified hash function, when applied to the message <span class="math">m</span>. The length is uniquely determined by the hash function; for instance, a SHA3-256 output always has length exactly 32 bytes.</li>

    </ol>

    <p class="text-gray-300">It is possible the use the "raw" data without prehashing. In that case, the value of <span class="math">b</span> is the concatenation of a single byte of value 0x3A (this is the ASCII encoding of a colon character) and the message <span class="math">m</span> itself. Using raw unhashed data can help in making the signature process resilient to weaknesses in hash functions with regard to collisions; however, it also makes signature processing harder for RAM-constrained systems (either generation or verification, or both, will require buffering of the whole message). We therefore recommend that input data be hashed with a collision-resistant hash function<span class="math">^{15}</span>.</p>

    <p class="text-gray-300">The signature process goes as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The private key is the scalar <span class="math">d</span>; the public key is <span class="math">Q = dG</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A per-signature scalar <span class="math">k</span> is generated. This can nominally be obtained with any method that ensures that <span class="math">k</span> is chosen uniformly at random in the 0 to <span class="math">r - 1</span> range and kept fully secret from outsiders, and that a new scalar <span class="math">k</span> is generated for each signature in a way unrelated to previously produced values <span class="math">k</span>. These rules can be hard to guarantee, especially in embedded systems. The following process can be used. Apply SHAKE256 on the concatenation of the following elements:</li>

    </ol>

    <p class="text-gray-300">(a) The ASCII encoding of the string "do255e-sign-k:" or "do255s-sign-k:" (depending on the used curve).</p>

    <p class="text-gray-300">(b) The encoding of the private key <span class="math">d</span> (32 bytes).</p>

    <p class="text-gray-300">(c) Some optional extra seed with a length prefix. A non-constant seed value can be injected here; it will make signatures non-deterministic and may help in providing additional protection against some physical attacks such as fault attacks. The extra seed needs not be secret or unpredictable. Signatures are still secure if the seed is absent. The seed encoding format is the concatenation of:</p>

    <p class="text-gray-300">i. The seed length (expressed in bytes), encoded over 64 bits (8 bytes) in unsigned little-endian format.</p>

    <p class="text-gray-300">ii. The seed value.</p>

    <p class="text-gray-300">If no optional seed is provided, then this is considered equivalent to a zero-length seed: the length prefix is still injected into SHAKE256 and then consists of eight bytes of value 0x00.</p>

    <p class="text-gray-300">(d) The hashed message <span class="math">b</span>, as specified above.</p>

    <p class="text-gray-300">A SHAKE256 output of length 32 bytes is then extracted, and interpreted as an integer (unsigned little-endian convention) in the 0 to <span class="math">2^{256} - 1</span> range, which is then reduced modulo <span class="math">r</span>, which requires at most two conditional subtractions (of <span class="math">2r</span>, then <span class="math">r</span>)<span class="math">^{16}</span>.</p>

    <p class="text-gray-300">The use of this process to obtain <span class="math">k</span> is not mandatory, but following it exactly has the additional benefit of making the implementation testable against precomputed test vectors.</p>

    <p class="text-gray-300"><span class="math">^{15}</span>I.e.: don't use MD5 or SHA-1! SHA-256, SHA-512, or all SHA3 variants should be fine.</p>

    <p class="text-gray-300"><span class="math">^{16}</span>As in the case of private key generation, we leverage here the fact that <span class="math">r</span> is very close to a power of two; thus, the modular reduction will not induce any statistically significant bias. In full generality, for arbitrary double-odd curves, one would need to generate more data with SHAKE256, e.g. an excess of at least 128 bits over the size of <span class="math">r</span>, and then perform full modular reduction.</p>

    <p class="text-gray-300">55</p>

    <p class="text-gray-300">It also ensures signature safety even if the local hardware source for randomness is biased or unavailable at signature time.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Once <span class="math">k</span> is obtained, the group element <span class="math">R=kG</span> is computed.</li>

      <li>The challenge value (denoted <span class="math">e</span>) is computed. This process again uses SHAKE256 over a concatenation of elements:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The ASCII string “do255e-sign-e:” or “do255s-sign-e:” (depending on the used curve).</li>

      <li>The 32-byte encoding of <span class="math">R</span>.</li>

      <li>The 32-byte encoding of the signer’s public key <span class="math">Q</span>.</li>

      <li>The hashed message <span class="math">h</span> (as specified above).</li>

    </ol>

    <p class="text-gray-300">A 32-byte output is then obtained from SHAKE256; it is interpreted as an integer (unsigned little-endian convention) in the 0 to <span class="math">2^{256}-1</span> range, which is reduced modulo <span class="math">r</span>. This yields the scalar value <span class="math">e</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The scalar <span class="math">s=k+de\\mod r</span> is computed.</li>

    </ol>

    <p class="text-gray-300">As stated above, the signature is the concatenation of the encodings of <span class="math">R</span> and <span class="math">s</span>, in that order. A signature always has length 64 bytes.</p>

    <p class="text-gray-300">The verification process is the following:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The signer’s public key is <span class="math">Q=dG</span>. This is an input to the process. We assume here that some assurance has been obtained that the public key is indeed owned by the expected signer, and that the public key has been validly decoded and is thus not the neutral point <span class="math">N</span>.</li>

      <li>The signature is parsed into its two elements <span class="math">R</span> and <span class="math">s</span>, which are both decoded. All rules on canonical encodings apply. Note that it is allowed (though very improbable in practice) that <span class="math">R=N</span> and/or that <span class="math">s=0</span>.</li>

      <li>The challenge value <span class="math">e</span> is computed using the same process as in the signature generation (see above).</li>

      <li>The signature is valid if and only if the following equation is fulfilled:</li>

    </ol>

    <p class="text-gray-300"><span class="math">sG-eQ=R</span></p>

    <p class="text-gray-300">Note that we are using here addition in the group <span class="math">\\mathbb{G}</span>, not classic addition of points on the curve.</p>

    <p class="text-gray-300">There are several ways in which that equation can be verified, but they do not impact the definition of what is a valid signature.</p>

    <p class="text-gray-300">These signatures are not malleable: without knowledge of the private key, it is not computationally feasible to modify an existing signature over a given message into another valid signature over the same message and verifiable against the public key. However, since each signature involves a signer-generated value <span class="math">k</span>, the private key owner can produce many different signature values over the same message <span class="math">m</span>, all verifiable against the public key. This is a known feature of all Schnorr and similar signatures (e.g. ECDSA).</p>

    <h4 id="sec-43" class="text-lg font-semibold mt-6">6.1.6 Hash-to-curve</h4>

    <p class="text-gray-300">To support hash-to-curve operations, we use the mappings defined in section 3.7. For both curves, the process is as follows, for an input message <span class="math">m</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Use SHAKE256 over the concatenation of the following elements:</li>

    </ol>

    <p class="text-gray-300">(a) The string "do255e-hash-to-curve:" or "do255s-hash-to-curve:" (again depending on which curve is used). (b) The hashed message  <span class="math">b</span> . This value contains either the input data  <span class="math">m</span> , or a hash thereof, with a prefix identifying the used hash function. Refer to the specification of signatures above for the value of  <span class="math">b</span> .</p>

    <p class="text-gray-300">Then 64 bytes of output are obtained from SHAKE256.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first 32 bytes of output of SHAKE256 are mapped into a group element  <span class="math">P_{1}</span>  with the mappings defined below. The remaining 32 bytes of output are also mapped into a group element  <span class="math">P_{2}</span> .</li>

      <li>The hash output is the group element  <span class="math">P_{1} + P_{2}</span>  (this is addition in the group  <span class="math">\\mathbb{G}</span> , not on the curve).</li>

    </ol>

    <p class="text-gray-300">Square root normalization. The mappings below use square roots. Since any non-zero quadratic residue has two distinct square roots, a rule must be chosen to select which root to keep. In this specification, we define that the primary square root of a field element is the unique square root which, as an integer in the 0 to  <span class="math">q - 1</span>  range, is even (i.e. its least significant bit is 0).</p>

    <p class="text-gray-300">Mapping for do255e. Let  <span class="math">d</span>  be the square root of  <span class="math">-1</span>  in the field; with the normalization rule, the value of  <span class="math">d</span>  is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} d = 7 6 5 6 0 6 3 7 4 2 4 6 3 0 2 6 5 6 8 6 7 9 8 2 3 5 7 2 3 9 5 3 2 5 7 9 9 0 \\\\ 2 7 6 0 1 8 3 8 5 5 8 3 4 5 2 5 8 4 2 6 5 3 5 8 1 6 5 0 4 3 7 2 5 9 5 4 3 8 \\\\ \\end{array}</span></div>

    <p class="text-gray-300">We apply the mapping into the dual curve  <span class="math">y&#x27;^2 = x&#x27;^3 + b&#x27;x&#x27;</span> , with  <span class="math">b&#x27; = -4b = 8</span> . The input bytes are interpreted as an integer in unsigned little-endian convention; this integer is then reduced modulo  <span class="math">q</span> , yielding the field element  <span class="math">e</span> . If  <span class="math">e = 0</span> , then the mapping output is  <span class="math">N</span>  and all subsequent steps may be skipped <span class="math">^{17}</span> . Otherwise, define the following values:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E _ {1} = 4 e ^ {2} - 7 \\\\ E _ {2} = d (4 e ^ {2} + 7) \\\\ F = 4 e \\\\ G _ {1} = 6 4 e ^ {7} + 1 7 6 e ^ {5} - 3 0 8 e ^ {3} - 3 4 3 e \\\\ G _ {2} = - d (6 4 e ^ {7} - 1 7 6 e ^ {5} - 3 0 8 e ^ {3} + 3 4 3 e) \\\\ H = 8 e ^ {2} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">It can be shown that none of these values may be zero at this point.</p>

    <p class="text-gray-300">We compute Legendre symbols on  <span class="math">G_{1}</span>  and  <span class="math">G_{2}</span> ; each symbol will be either 1 (value is a quadratic residue) or -1 (value is not a quadratic residue). Then:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If  <span class="math">G_{1} \\in QR</span> , then set  <span class="math">x&#x27; = E_{1} / F</span>  and  <span class="math">y&#x27; = (\\sqrt{G_{1}}) / H</span> .</li>

    </ul>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Otherwise, if <span class="math">G_2 \\in QR</span>, then set <span class="math">x&#x27; = E_2 / F</span> and <span class="math">y&#x27; = (\\sqrt{G_2}) / H</span>.</li>

      <li>Otherwise, set <span class="math">x&#x27; = (E_1E_2) / F^2</span> and <span class="math">y&#x27; = (\\sqrt{G_1G_2}) / H^2</span>.</li>

    </ul>

    <p class="text-gray-300">The square root computation MUST be normalized as explained above.</p>

    <p class="text-gray-300">The obtained <span class="math">(x&#x27;, y&#x27;)</span> is a point on the dual curve. We apply the <span class="math">\\theta_{1/2}&#x27;</span> isogeny to obtain <span class="math">(x, w)</span> on <span class="math">\\mathbb{G}</span> on curve do255e:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x = -8x&#x27;^2 / y&#x27;^2 \\\\ w = x&#x27;(x&#x27;^2 - 8) / (2x&#x27;y&#x27;) \\end{array}</span></div>

    <p class="text-gray-300"><strong>Mapping for do255s.</strong> We apply the mapping into the dual curve <span class="math">y&#x27;^2 = x&#x27;(x&#x27;^2 + a&#x27;x + b&#x27;)</span>, with <span class="math">a&#x27; = -2a = 2</span> and <span class="math">b&#x27; = a^2 - 4b = -1</span>. The input bytes are interpreted as an integer in unsigned little-endian convention; this integer is then reduced modulo <span class="math">q</span>, yielding the field element <span class="math">e</span>. If <span class="math">e = \\pm 1</span>, then the mapping output is <span class="math">N</span> and all subsequent steps may be skipped<span class="math">^{18}</span>. Otherwise, define the following values:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} E_1 = -2 \\\\ E_2 = 2e^2 \\\\ F = 1 - e^2 \\\\ G_1 = -2e^6 + 14e^4 - 14e^2 + 2 \\\\ G_2 = 2e^8 - 14e^6 + 14e^4 - 2e^2 \\\\ H = (1 - e^2)^2 \\end{array}</span></div>

    <p class="text-gray-300">None of <span class="math">G_1</span>, <span class="math">F</span> and <span class="math">H</span> can be zero; however, <span class="math">G_2</span> can be zero (but only if <span class="math">e = 0</span>). We compute a Legendre symbol on <span class="math">G_1</span>:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>If <span class="math">G_1 \\in QR</span>, then set <span class="math">x&#x27; = E_1 / F</span> and <span class="math">y&#x27; = (\\sqrt{G_1}) / H</span>.</li>

      <li>Otherwise, set <span class="math">x&#x27; = E_2 / F</span> and <span class="math">y&#x27; = (\\sqrt{G_2}) / H</span>.</li>

    </ul>

    <p class="text-gray-300">The obtained <span class="math">(x&#x27;, y&#x27;)</span> is a point on the dual curve. We apply the <span class="math">\\theta_{1/2}&#x27;</span> isogeny to obtain <span class="math">(x, w)</span> on <span class="math">\\mathbb{G}</span> on curve do255s:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} x = 2x&#x27;^2 / y&#x27;^2 \\\\ w = x&#x27;(x&#x27;^2 + 1) / (2x&#x27;y&#x27;) \\end{array}</span></div>

    <p class="text-gray-300">Take care that if <span class="math">e = 0</span> then we get the neutral <span class="math">N</span>, with no defined <span class="math">w</span> coordinate.</p>

    <h2 id="sec-44" class="text-2xl font-bold">6.2 The GLV Method</h2>

    <p class="text-gray-300">The GLV method[16] leverages an easily computed endomorphism on the curve to speed up point multiplication by a scalar. This is applicable to curve do255e, as described here.</p>

    <p class="text-gray-300"><span class="math">^{18}</span>As in the case of the do255e mapping, all other steps SHOULD still be performed, to achieve a constant-time implementation.</p>

    <p class="text-gray-300">Let <span class="math">\\eta</span> be a square root of <span class="math">-1</span> in <span class="math">\\mathbb{F}_{q}</span>. There are two such square roots; we use the one whose least significant bit is 0:</p>

    <p class="text-gray-300"><span class="math">\\eta=76560637424630265686798235723953257990</span> <span class="math">27601838558345258426535816504372595438</span></p>

    <p class="text-gray-300">We use it to define the function <span class="math">\\hat{\\delta}</span> such that <span class="math">\\hat{\\delta}(N)=N</span> and <span class="math">\\hat{\\delta}(x,w)=(-x,-\\eta w)</span> (in <span class="math">(x,u)</span> coordinates, this yields <span class="math">\\hat{\\delta}(x,u)=(-x,\\eta u)</span>). <span class="math">\\hat{\\delta}</span> is an endomorphism on the group <span class="math">\\mathbb{G}</span>; therefore, <span class="math">\\hat{\\delta}(P)=\\mu P</span> for a constant <span class="math">\\mu</span> which is a square root of <span class="math">-1</span> modulo <span class="math">r</span>. With our choice of <span class="math">\\eta</span>, we have:</p>

    <p class="text-gray-300"><span class="math">\\mu=23076176648693837106500022901799924463</span> <span class="math">072024427516564762134831823525232195341</span></p>

    <p class="text-gray-300">Suppose that we have a scalar <span class="math">k</span>; we can decompose it into two smaller scalars <span class="math">k_{0}</span> and <span class="math">k_{1}</span> such that <span class="math">k=k_{0}+\\mu k_{1}\\bmod r</span>. To do that, we consider the lattice of dimension two with basis vectors <span class="math">(\\mu,1)</span> and <span class="math">(r,0)</span>. The original GLV article<em>[16]</em> describes a method that heuristically finds a short basis, but we can also apply Lagrange’s algorithm to obtain a shortest basis<em>[31]</em>. It may additionally be noted that since <span class="math">r=1\\bmod 4</span>, it can be written as a sum of two squares <span class="math">r=s^{2}+t^{2}</span>, which means that <span class="math">\\mu=s/t</span> or <span class="math">t/s</span>. Therefore, the vectors <span class="math">(t,s)</span> and <span class="math">(-s,t)</span> are a short and orthogonal basis for the lattice; this is thus a shortest basis, and Lagrange’s algorithm will reveal it. For do255e, we have:</p>

    <p class="text-gray-300"><span class="math">s=34978546233976132960203755786038370577</span> <span class="math">t=166506827525740345966246169588540045182</span></p>

    <p class="text-gray-300">Given <span class="math">k</span>, we can compute integers <span class="math">c</span> and <span class="math">d</span> as:</p>

    <p class="text-gray-300"><span class="math">c=\\lfloor kt/r\\rceil</span> <span class="math">d=\\lfloor ks/r\\rceil</span></p>

    <p class="text-gray-300">Integers <span class="math">c</span> and <span class="math">d</span> are nonnegative, and less than <span class="math">2^{127}</span>.</p>

    <p class="text-gray-300">We can then compute <span class="math">k_{0}</span> and <span class="math">k_{1}</span>:</p>

    <p class="text-gray-300"><span class="math">k_{0}=k-ds-ct</span> <span class="math">k_{1}=dt-cs</span></p>

    <p class="text-gray-300">Note that <span class="math">k_{0}</span> and <span class="math">k_{1}</span> are signed integers; they may be negative. As shown in <em>[16]</em>, we always have <span class="math">k_{0}^{2}+k_{1}^{2}\\leq s^{2}+t^{2}</span>. Since the latter sum is equal to <span class="math">r</span> which is slightly below <span class="math">2^{254}</span> in the case of do255e, this guarantees that <span class="math">k_{0}</span> and <span class="math">k_{1}</span> will fit over 128 bits each (including the sign bit). This allows us to compute the products and subtractions over 128 bits only, ignoring upper bits.</p>

    <p class="text-gray-300">Computing <span class="math">c</span> and <span class="math">d</span> involves rounded divisions. A generic method due to Grandlund and Montgomery<em>[18]</em> allows computing these rounded divisions with only multiplications and shifts. In the case of do255e, we can leverage the fact that <span class="math">r</span> is close to <span class="math">2^{254}</span> to specialize that method into the following process. Let <span class="math">x</span> be an integer such that <span class="math">x\\leq(r-1)\\max(s,t)</span>, and we want to compute <span class="math">\\lfloor x/r\\rceil</span></p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Set: <span class="math">z \\gets x + (r - 1)2</span></li>

      <li>Set: <span class="math">y \\gets \\lfloor z / 2^{254} \\rfloor + 1</span></li>

      <li>If <span class="math">yr &amp;gt; z</span>, then set: <span class="math">y \\gets y - 1</span></li>

      <li>Return <span class="math">y</span></li>

    </ol>

    <p class="text-gray-300">This process relies on the fact that <span class="math">\\lfloor z / 2^{254} \\rfloor</span> (which is a simple right shift) is a good approximation of <span class="math">z / r</span>. Indeed, if we write <span class="math">z = z_0 + 2^{254} z_1</span>, with <span class="math">0 \\leq z_0 &amp;lt; 2^{254}</span>, then it can be shown that <span class="math">z_1 r &amp;lt; z &amp;lt; (z_1 + 3/2) r</span>; therefore, the rounded division result is either <span class="math">z_1</span> or <span class="math">z_1 + 1</span>.</p>

    <p class="text-gray-300">The most expensive operation above is the computation of the product <span class="math">yr</span>, but this can be again optimized by noticing that we don't actually need that product; we just need to know whether it is greater than <span class="math">z</span>. Moreover, if we write <span class="math">r = 2^{254} - r_0</span> (with <span class="math">r_0 &amp;lt; 2^{127}</span>), then we can write:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} z - y r = 2 ^ {2 5 4} (y - 1) + z _ {0} - 2 ^ {2 5 4} y + y r _ {0} \\\\ = z _ {0} + y r _ {0} - 2 ^ {2 5 4} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">This reduces the cost of the product <span class="math">yr</span> to that of <span class="math">yr_0</span>, with both <span class="math">y</span> and <span class="math">r_0</span> fitting on 127 bits each.</p>

    <p class="text-gray-300">Once we have decomposed <span class="math">k</span> into <span class="math">k_0 + \\mu k_1</span>, we can compute <span class="math">kP</span> for a point <span class="math">P</span> as:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} k P = k _ {0} P + k _ {1} (\\mu P) \\\\ = k _ {0} P + k _ {1} \\delta (P) \\\\ \\end{array}</span></div>

    <p class="text-gray-300">The point <span class="math">\\delta(P)</span> is inexpensively computed with a single multiplication by a constant <span class="math">(\\eta)</span>. In a classic double-and-add algorithm, these two scalar multiplications can share the doublings, using the method often called "Shamir's trick" but first described by Straus[37]; namely, after one doubling, <span class="math">P</span> and/or <span class="math">\\delta(P)</span> is added to the current accumulator. This is compatible with window optimizations. Since <span class="math">k_{0}</span> and <span class="math">k_{1}</span> are half the size of <span class="math">k</span>, the total number of extra point additions is unchanged, but the number of point doublings is halved, thus making the whole point multiplication process substantially faster.</p>

    <p class="text-gray-300">In general, such speed-ups can be achieved when multiplying a fixed, conventional point for which appropriate windows may be precomputed (e.g. when doing key pair generation, or signature generation). The GLV method also handles the case of a dynamically obtained point <span class="math">P</span>, in particular during a Diffie-Hellman key exchange.</p>

    <h2 id="sec-45" class="text-2xl font-bold">6.3 64-bit x86 Implementation</h2>

    <p class="text-gray-300">Our x86 implementations are written mostly in C; one variant includes a few assembly routines to leverage the mulx and adcx/adox opcodes on x86 CPUs that support them. Base field elements are represented as 256-bit integers over four 64-bit limbs; all routines accept integer inputs in the complete range 0 to <span class="math">2^{256} - 1</span>, but they don't enforce full reduction of the result on output. Reduction of an intermediate 512-bit integer (e.g. the result of multiplication or squaring) modulo <span class="math">2^{255} - m</span> is performed as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The value to reduce is split into a low half <span class="math">a_0</span> (four limbs) and a high half <span class="math">a_1</span> (also four limbs).</li>

    </ul>

    <p class="text-gray-300">Using <span class="math">2^{256}=2m</span> mod <span class="math">q</span>, the value <span class="math">2ma_{1}</span> is added to <span class="math">a_{0}</span>. This results in a value that fits in five limbs; moreover, the highest limb value cannot exceed <span class="math">2m</span>. Let’s write this value as <span class="math">b+2^{256}b</span>, with <span class="math">b&lt;2^{256}</span> and <span class="math">b</span> being the high limb.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">b</span> is truncated to 255 bits, while its former top bit is injected into <span class="math">b</span>; i.e.:</li>

    </ul>

    <p class="text-gray-300"><span class="math">b\\leftarrow 2b+\\lfloor b/2^{255}\\rfloor</span> <span class="math">b\\leftarrow b\\ \\mathrm{mod}\\ 2^{255}</span></p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The value <span class="math">b+bm</span> is computed and returned. At that point, the value of <span class="math">bm</span> is at most <span class="math">m(4m+1)</span>, and therefore fits on a single limb, since we work in fields such that <span class="math">m&lt;2^{15}</span>. Since <span class="math">b&lt;2^{255}</span>, the addition result will necessarily fit in 256 bits.</li>

    </ul>

    <p class="text-gray-300">Our implementation of operations on fields, especially multiplications and squaring, is very similar to that of Nath and Sarkar<em>[29]</em> for the field of integers modulo <span class="math">2^{255}-19</span>, and offers similar performance. For inversion in the field, we use a constant-time optimized binary GCD, as described in <em>[32]</em>; a variant of that algorithm is used to compute Legendre symbols, still in constant-time, and with similar performance: we perform an inversion or a Legendre symbol with a cost of approximately 2/3rd of that of a square root, which uses a modular exponentiation. For square roots, optimized addition chains are used on the exponent, so that the exponentiation uses 251 squarings and 13 multiplications (for do255e), or 252 squarings and 12 multiplications (for do255s).</p>

    <p class="text-gray-300">For key pair generation and signature generation, when multiplying the conventional generator, a double-and-add algorithm with 5-bit windows is used; four windows are precomputed, corresponding to <span class="math">G</span>, <span class="math">2^{65}G</span>, <span class="math">2^{130}G</span> and <span class="math">2^{195}G</span>, so that only 60 doublings are needed, along with 51 point additions. The doublings are performed as 12 sequences of 5 successive doublings, for which we have described optimized formulas. Window points use affine coordinates, so that mixed addition formulas are used, and each point uses only 64 bytes of storage for two coordinates. Since Booth recoding<em>[9]</em> is used, each window contains 16 points, so the total size of these precomputed tables is about 4 kilobytes. Some marginal speed-ups could be obtained by using larger tables and/or more of them; the current 4-way split seems to be a good compromise that avoids putting too much pressure on the L1 cache. Of course, all lookups in the tables are done in a fully constant-time way.</p>

    <p class="text-gray-300">For multiplying a random point by a scalar, we use dynamically generated windows, again with 5-bit windows and Booth recoding. For do255e, the GLV method (described in section 6.2) is applied to reduce the number of doublings. Windows are also normalized to affine coordinates; we can invert all <span class="math">Z</span> coordinates with a single shared inversion, using a trick due to Montgomery: for all non-zero <span class="math">x</span> and <span class="math">y</span>, we have <span class="math">1/x=y/(xy)</span> and <span class="math">1/y=x/(xy)</span>, so it suffices to invert <span class="math">xy</span>. This trick can be applied recursively. Once the windows are normalized to affine coordinates, mixed addition formulas can be used. Moreover, using affine coordinates makes points smaller in RAM, and thus lowers the cost of constant-time lookups.</p>

    <p class="text-gray-300">For signature verification, we use a combined 4-way scalar multiplication with half-size scalars, again with 5-bit windows and Booth recoding. For do255e, the GLV scalar splitting method is used; for do255s, we use the Antipa et al method<em>[2]</em>, along with the implementation of Lagrange’s lattice basis reduction in dimension two described in <em>[31]</em>. Signature verification nominally operates on public data (public key and signature value) and thus does not require a constant-time implementation; this helps in making window lookups.</p>

    <p class="text-gray-300">For all operations, we have the choice between the Jacobian  <span class="math">(x, w)</span>  coordinates and the fractional  <span class="math">(x, u)</span>  coordinates. It is not easy to predict in advance which representation is best. Raw multiplication and squaring counts only provide an approximate estimate of performance. Modern x86 CPUs have deep pipelines with out-of-order execution, and will freely and dynamically mix opcodes from several arithmetic operations, on top of the optimizations already performed by the compiler; this implies that dependencies between operations are also an important aspect. In our code, after some benchmarks, we settled on the following:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>For do255e, we use  <span class="math">(x,u)</span>  coordinates for multiplying  <span class="math">G</span>  (key pair generation, signature generation) and for verifying signatures; we use  <span class="math">(x,w)</span>  coordinates for multiplying a dynamically received point by a scalar.</li>

      <li>For do255s, we use  <span class="math">(x, w)</span>  coordinates for all operations.</li>

    </ul>

    <p class="text-gray-300">For signature verification on do255s, we furthermore use wNAF to reduce the average number of point additions. We do not apply the wNAF techniques to signature verification on do255e, because they would imply shorter sequences of doublings and thus a greater overhead with our optimized formulas in  <span class="math">(x,u)</span>  coordinates.</p>

    <p class="text-gray-300">Our test machine is an Intel Core i5-8295U clocked at 2.3 GHz ("Coffee Lake"), running Linux (Ubuntu 20.04). TurboBoost was disabled. Performance was measured by first running 1000 "blank" runs, then 1000 other runs, and using the median cycle count from the latter. For signature verification, the algorithms and implementations are not constant-time, so we use random signatures, leading to some extra variance; the reported value is thus less precise. Obtained performance measurements are shown on table 2 (code compiled with Clang 10.0, flags -02 and -march=skylake).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do255e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do255s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key pair generation (with public key encoding)</td>

            <td class="px-3 py-2 border-b border-gray-700">49122</td>

            <td class="px-3 py-2 border-b border-gray-700">52146</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key exchange (with decoding and key derivation)</td>

            <td class="px-3 py-2 border-b border-gray-700">105340</td>

            <td class="px-3 py-2 border-b border-gray-700">141688</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Signature generation</td>

            <td class="px-3 py-2 border-b border-gray-700">53584</td>

            <td class="px-3 py-2 border-b border-gray-700">56872</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Signature verification (with public key decoding)</td>

            <td class="px-3 py-2 border-b border-gray-700">111894</td>

            <td class="px-3 py-2 border-b border-gray-700">158602</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Measured performance on 64-bit x86 (clock cycles). Note: point encoding (about 7000 cycles) and decoding (about 18000 cycles) costs are included.</p>

    <p class="text-gray-300">Compared with large 64-bit x86 CPUs, the ARM Cortex M0+ is at the other end of the spectrum, and one of the smallest and least-powered on which implementing elliptic curve cryptography still makes sense. Our implementation is written mostly in assembly. Values are represented over 8 limbs of 32 bits. Multiplication and squaring in the field use a three-level signed Karatsuba decomposition, using techniques very similar to those described in [14]; we indeed obtain very similar performance as well (1464 cycles for multiplication, 997 cycles for squaring).</p>

    <p class="text-gray-300">Our implementation is fully constant-time (except for signature verification, which is assumed to use only public data). In particular, we do not assume that RAM accesses don't</p>

    <p class="text-gray-300">leak information about the target address. Indeed, while the Cortex M0+ core does not by itself include a cache, it is integrated into a microcontroller circuit which may provide a cache; that circuit will also route all memory accesses from the core into an interconnection matrix which arbitrates between accesses from the core and from peripherals, in ways which are rarely documented. Therefore, we cannot in general guarantee that even on a specific target microcontroller model, all RAM accesses are free of such side channels. It is safer to use a fully constant-time strategy. The overhead is not great: about 40k cycles for a complete point multiplication, i.e. less than  <span class="math">2\\%</span>  of the overall cost.</p>

    <p class="text-gray-300">All our external functions comply with the standard ABI for ARMv6-M. Notably, none of our assembly-written functions touches the r9 register, which, depending on the target system, may be reserved for all purposes. On some systems (e.g. iOS up to and including version 2), r9 may even be reserved at all times, and cannot be used by any function even if the original value is restored on exit. For maximum portability, we thus shun that register completely.</p>

    <p class="text-gray-300">Algorithms are mostly the same as in the x86 code, with some notable differences:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We use 4-bit windows instead of 5-bit windows. This is made so in order to lower RAM usage; RAM is typically a scarce resource on small microcontrollers. With Booth recoding, a 4-bit window contains 8 points, hence 512 bytes with affine coordinates, but extra room is needed for temporaries in order to fill the window and invert the  <span class="math">Z</span>  coordinates. Our target RAM usage is  <span class="math">1.5\\mathrm{kB}</span>  of stack space.</li>

      <li>All operations on do255e use  <span class="math">(x, u)</span>  coordinates, including generic point multiplication. The window is computed in  <span class="math">(x, w)</span>  coordinates, but converted to  <span class="math">(x, u)</span>  during normalization to affine coordinates. On the other hand, all operations on do255s use  <span class="math">(x, w)</span>  coordinates.</li>

      <li>On the ARM Cortex M0+, inversions (with the binary GCD) and Legendre symbol computations are much faster than square roots; their costs are similar to, respectively, 37 and 30 multiplications in the field.</li>

    </ul>

    <p class="text-gray-300">We verified correctness of the implementation and performed benchmarks on an Atmel (now Microchip) SAMD20 Xplained Pro board, using an ATSAMD20J18 microcontroller[26]. The board was clocked at 8 MHz; Flash access did not incur any wait state, and all measures are reproducible with 1-cycle accuracy (signature verification is still intrinsically variable-time, and the reported value is an average). Measured performance is shown in table 3.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Operation</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do255e</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">do255s</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key pair generation (with public key encoding)</td>

            <td class="px-3 py-2 border-b border-gray-700">1422257</td>

            <td class="px-3 py-2 border-b border-gray-700">1572978</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Key exchange (with decoding and key derivation)</td>

            <td class="px-3 py-2 border-b border-gray-700">2616600</td>

            <td class="px-3 py-2 border-b border-gray-700">3591395</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Signature generation</td>

            <td class="px-3 py-2 border-b border-gray-700">1502127</td>

            <td class="px-3 py-2 border-b border-gray-700">1653043</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Signature verification (with public key decoding)</td>

            <td class="px-3 py-2 border-b border-gray-700">3255000</td>

            <td class="px-3 py-2 border-b border-gray-700">3747000</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 3: Measured performance on ARM Cortex M0+ (clock cycles). Note: point encoding (about 57000 cycles) and decoding (about 325000 cycles) costs are included.</p>

    <p class="text-gray-300">7 Conclusion</p>

    <p class="text-gray-300">In this document, we studied double-odd elliptic curves, an hitherto neglected class of elliptic curves. This class is large, since it includes about 1/4th of all curves; algorithms using these curves do not rely on any new security hypothesis about elliptic curves (in that respect, double-odd elliptic curves are very similar to Montgomery curves when they were first introduced). We showed that double-odd elliptic curves can offer the comfortable abstraction of a prime order group, which simplifies usage and analysis in various cryptographic protocols. This property is similar to what Decaf and Ristretto provide over twisted Edwards curves; however, double-odd elliptic curves are slightly more economical in space (<span class="math">2n+1</span> bits for <span class="math">n</span>-bit security, instead of <span class="math">2n+2</span> or <span class="math">2n+3</span> for Decaf / Ristretto).</p>

    <p class="text-gray-300">At the same time, safe (complete) formulas for operations on that prime order group are described, and we show that they can achieve performance levels which are on par with what can be obtained from twisted Edwards curves. This makes double-odd elliptic curves attractive.</p>

    <p class="text-gray-300">Many subjects related to double-odd elliptic curves remain to be explored; for instance:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Parallel implementations, leveraging SIMD opcodes such as AVX2 or AVX512, have not been studied.</li>

      <li>There may be other coordinate systems with better formulas. Intuitively, the four unconstrained values in fractional <span class="math">(x,u)</span> coordinates seem wasteful; there may exist a more constrained system (similar to extended coordinates for twisted Edwards curves<em>[20]</em>) with lower cost.</li>

      <li>Proper use of the formulas, and benchmarks, for batch signature verification should be studied.</li>

      <li>Some of the ideas developed here might be applicable to other kinds of curves. In particular, using the <span class="math">(0,0)</span> point as pivot to make unified formulas might be usable, under some conditions, on Montgomery curves. General binary curves (curves over fields of characteristic 2) may also benefit from similar techniques.</li>

      <li>Nothing prevents definition of double-odd elliptic curves on field extensions, and potentially use of combinations of GLV and GLS endomorphisms<em>[15]</em> for even better performance.</li>

    </ul>

    <h2 id="sec-47" class="text-2xl font-bold">Acknowledgements</h2>

    <p class="text-gray-300">Paul Bottinelli, Gérald Doussot and Eric Schorn provided reviews of this text and are working on extra implementations. Samuel Neves sent me the links to the (presumed expired) GLV patents. Filippo Valsorda helped with the design of the Go implementation API.</p>

    <p class="text-gray-300">My employer, NCC Group, provided the most important resource for research: free time (although many week-ends were also used, because science happens when it happens).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Accredited Standard Committee X9, Inc., ANSI X9.62: Public Key Cryptography for the Financial Services Industry: the Elliptic Curve Digital Signature Algorithm (ECDSA), 2005.</li>

      <li>A. Antipa, D. Brown, R. Gallant, R. Lambert, R. Struik and S. Vanstone, <em>Accelerated Verification of ECDSA signatures</em>, Selected Areas in Cryptography - SAC 2005, Lecture Notes in Computer Science, vol 3897, pp. 307-318, 2005.</li>

      <li>T. Arcieri, I. Lovecraft and H. de Valence, <em>The Ristretto Group</em>, https://ristretto.group/</li>

      <li>D. Bernstein, Curve25519: new Diffie-Hellman speed records, PKC 2006, Lecture Notes in Computer Science, vol. 3958, pp. 207-228, 2006.</li>

      <li>D. Bernstein, P. Birkner, M. Joye, T. Lange and C. Peters, Twisted Edwards Curves, https://eprint.iacr.org/2008/013</li>

      <li>D. Bernstein, N. Duif, T. Lange, P. Schwabe and B.-Y. Yang, High-speed high-security signatures, Journal of Cryptographic Engineering, vol. 2, issue 2, pp. 77-89, 2012.</li>

      <li>D. Bernstein, M. Hamburg, A. Krasnova and T. Lange, <em>Elligator: elliptic-curve points indistinguishable from uniform random strings</em>, Proceedings of the 2013 ACM SIGSAC Conference on Computer and Communications Security, 2013, https://doi.org/10.1145/2508859.2516734</li>

      <li>D. Bernstein and T. Lange, Faster addition and doubling on elliptic curves, Advances in Cryptology - ASIACRYPT 2007, Lecture Notes in Computer Science, vol. 4833, pp. 29-50, 2007. https://eprint.iacr.org/2007/286</li>

      <li>A. Booth, A Signed Binary Multiplication Technique, The Quarterly Journal of Mechanics and Applied Mathematics, vol. 4, issue 2, pp. 236-240, 1951.</li>

      <li>D. Chudnovsky and G. Chudnovsky, Sequences of numbers generated by addition in formal groups and new primality and factorization tests, Advances in Applied Mathematics, vol. 7, issue 4, pp. 385-434, 1986.</li>

      <li>C. Costello and B. Smith, Montgomery curves and their arithmetic, Journal of Cryptographic Engineering, vol. 8, issue 3, pp. 227-240, 2018.</li>

      <li>C. Cremers and D. Jackson, Prime, Order Please! Revisiting Small Subgroup and Invalid Curve Attacks on Protocols using Diffie-Hellman, IEEE 32nd Computer Security Foundations Symposium (CSF), 2019.</li>

      <li>W. Diffie and M. Hellman, New Directions in Cryptography, IEEE Transactions on Information Theory, vol. 22, issue 6, pp. 644-654, 1976.</li>

      <li>M. Düll, B. Haase, G. Hinterwälder, M. Hutter, C. Paar, A. Sánchez and P. Schwabe, High-speed Curve25519 on 8-bit, 16-bit, and 32-bit microcontrollers, Designs, Codes and Cryptography, vol. 77, issue 2-3, pp.493-514, 2015.</li>

      <li>S. Galbraith, X. Lin and M. Scott, Endomorphisms for faster elliptic curve cryptography on a large class of curves Journal of Cryptology, vol. 24, issue 3, pp. 446-469, 2011.</li>

      <li>R. Gallant, J. Lambert and S. Vanstone, <em>Faster Point Multiplication on Elliptic Curves with Efficient Endomorphisms</em>, Advances in Cryptology - CRYPTO 2001, Lecture Notes in Computer Science, vol. 2139, pp. 190-200, 2001.</li>

      <li>R. Gallant, R. Lambert and S. Vanstone; R. Lambert and A. Vadekar, Method for accelerating cryptographic operations on elliptic curves, https://patents.google.com/patent/US7110538B2/en https://patents.google.com/patent/US7995752B2/en</li>

      <li>T. Grandlund and P. Montgomery, Division by Invariant Integers using Multiplication, ACM SIGPLAN Notices, vol. 29, issue 6, pp. 61-72, 1994.</li>

      <li>M. Hamburg, Decaf: Eliminating cofactors through point compression, Advances in Cryptology - CRYPTO 2015, Lecture Notes in Computer Science, vol. 9215, pp. 705-723, 2015.</li>

    </ol>

    <p class="text-gray-300">65</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>H. Hisil, K. Wong, G. Carter and E. Dawson, Twisted Edwards Curves Revisited, Advances in Cryptology - ASIACRPT 2008, Lecture Notes in Computer Science, vol 5350, pp. 326-343, 2008.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Information Technology Laboratory, Digital Signature Standard (DSS), National Institute of Standard and Technology, FIPS 186-4, 2013.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Information Technology Laboratory, SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions, National Institute of Standard and Technology, FIPS 202, 2015.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>S. Josefsson and I. Liusvaara, Edwards-Curve Digital Signature Algorithm (EdDSA), https://tools.ietf.org/html/rfc8032</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>L. Kronecker, Auseinandersetzung einiger Eigenschaften der Klassenzahl idealer komplexen Zahlen, 1870.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>I. Lovecraft and H. de Valence, Dalek cryptography, https://dalek.rs/</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Microchip, SAM D20 Family (microcontroller datasheet), http://ww1.microchip.com/downloads/en/DeviceDoc/SAM_D20_%20Family_Datasheet_DS60001504C.pdf</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>luigi1111 and R. Spagni, Disclosure of a Major Bug in CryptoNote Based Currencies, https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Menezes, T. Okamoto and S. Vanstone, Reducing elliptic curve logarithms to a finite field, IEEE Transactions on Information Theory, vol. 39, issue 5, pp. 1639-1646, 1993.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>K. Nath and P. Sarkar, Efficient Arithmetic In (Pseudo-)Mersenne Prime Order Fields, https://eprint.iacr.org/2018/985</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. Pornin, Efficient Elliptic Curve Operations On Microcontrollers With Finite Field Extensions, https://eprint.iacr.org/2020/009</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. Pornin, Optimized Lattice Basis Reduction In Dimension 2, and Fast Schnorr and EdDSA Signature Verification, https://eprint.iacr.org/2020/454</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. Pornin, Optimized Binary GCD for Modular Inversion, https://eprint.iacr.org/2020/972</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>T. Pornin, Faster Modular Inversion and Legendre Symbol, and an X25519 Speed Record, https://research.nccgroup.com/2020/09/28/faster-modular-inversion-and-legendre-symbol-and-an-x25519-speed-record/</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>J. Renes, C. Costello and L. Batina, Complete addition formulas for prime order elliptic curves, Advances in Cryptology - Eurocrypt 2016, Lecture Notes in Computer Science, vol. 9665, pp. 403-428, 2016.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>C.-P. Schnorr, Efficient Identification and Signatures for Smart Cards, Advances in Cryptology - CRYPTO '89, Lecture Notes in Computer Science, vol. 435, pp. 239-252, 1989.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>A. Shallue and C. van de Woestijne, Construction of rational points on elliptic curves over finite fields, Algorithm Number Theory Symposium - ANTS 2006, Lecture Notes in Computer Science, vol. 4076, pp. 510-524, 2006.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>E. Straus, Addition chains of vectors (problem 5125), American Mathematical Monthly, vol. 70, pp. 806-808, 1964.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>M. Ulas, Rational Points on Certain Hyperelliptic Curves over Finite Fields, Bulletin of the Polish Academy of Sciences - Mathematics, vol. 55, issue 2, pp. 97-104, 2007.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>R. Wahby and D. Boneh, Fast and simple constant-time hashing to the BLS12-381 elliptic curve, IACR Transactions on Cryptographic Hardware and Embedded Systems, vol. 2019, issue 4, pp. 154-179, 2019.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>H. de Valence, ZIP 215: Explicitly Defining and Modifying Ed25519 Validation Rules, https://zips.z.cash/zip-0215</li>

    </ol>

    <p class="text-gray-300">66</p>`;
---

<BaseLayout title="Double-Odd Elliptic Curves (2020/1558)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2020 &middot; eprint 2020/1558
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
