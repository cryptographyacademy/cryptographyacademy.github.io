---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2011/334';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'On the Efficient Implementation of Pairing-Based Protocols';
const AUTHORS_HTML = 'Michael Scott';

const CONTENT = `    <p class="text-gray-300">Michael Scott</p>

    <p class="text-gray-300">School of Computing Dublin City University Ballymun, Dublin 9, Ireland. mike@computing.dcu.ie</p>

    <p class="text-gray-300">Abstract. The advent of Pairing-based protocols has had a major impact on the applicability of cryptography to the solution of more complex real-world problems. However there has always been a question mark over the performance of such protocols. In response much work has been done to optimize pairing implementation, and now it is generally accepted that being pairing-based does not preclude a protocol from consideration as a practical proposition. However although a lot of effort has gone into the optimization of the stand-alone pairing, in many protocols the pairing calculation appears in a particular context within which further optimizations may be possible. It is the purpose of this paper to bridge the gap between theory and practise, and to show that even complex protocols may have a surprisingly efficient implementation. We also point out that in some cases the usually recommended pairing friendly curves may not in fact be optimal. We claim a new record with our implementation of a pairing at the AES-256 bit level.</p>

    <p class="text-gray-300">Keywords: Pairing implementation.</p>

    <p class="text-gray-300">Pairings, with their richer structure, allow solution to problems for which traditional public key methods could offer no solution. The classic example would be Identity-based Encryption, long known as a concept, stubbornly resistant to realisation using standard methods, yet easy to construct using pairings.</p>

    <p class="text-gray-300">Other problems of interest, like short signature schemes [13], non-interactive key exchange [33], attribute-based cryptography [38] (which has particular significance for security in the context of cloud computing [2]), and public key encryption with key-word search [12], also succumbed. These protocols, although often proven secure under reasonable assumptions, were becoming ever more complex, outstripping the ability of implementers to keep up. Indeed in parallel with these developments optimal methods for calculating bilinear pairings and ancillary operations were also being developed. To give an idea of the current</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Research supported by the Claude Shannon Institute, Science Foundation Ireland Grant 06/MI/006</li>

    </ul>

    <p class="text-gray-300">state-of-the-art, see <em>[9]</em> where a pairing at the equivalent of AES-128 bit security is calculated on the standard contemporary computing platform in less than a millisecond. See also <em>[3]</em>.</p>

    <p class="text-gray-300">However depending on the context in which the pairing is needed within a particular protocol further optimizations may also be possible, and it is the purpose of this paper to highlight these possibilities and measure their impact. We also give some performance statistics for practical implementation of some protocols.</p>

    <h2 id="sec-3" class="text-2xl font-bold">2 Pairings</h2>

    <p class="text-gray-300">There are, it is generally accepted, 4 varieties of pairing, of which the Type-1 and Type-3 are the most common, and the most practical for implementation purposes <em>[18]</em>. Here we restrict ourselves to Type-1 and Type-3 pairings implemented on elliptic curves. Note that while pairing-based protocols are commonly described in the context of a Type-1 pairing, most can be ported to the Type-3 setting. This will of course impact on the security assumptions, but that is not a concern here.</p>

    <p class="text-gray-300">The notation for the pairing is <span class="math">e(P,Q)</span>. We will refer to <span class="math">P</span> as the left-hand argument and <span class="math">Q</span> as the right-hand argument. The pairing itself evaluates as an element in the <span class="math">k</span>-th extension of the underlying finite field <span class="math">\\mathbb{F}_{q}</span>, where <span class="math">k</span> is called the embedding degree, which is a fixed parameter associated with the chosen curve. Note that only elliptic curves <span class="math">E(\\mathbb{F}_{q})</span> with reasonably small values of embedding degrees are of interest here – such curves are called pairing-friendly.</p>

    <p class="text-gray-300">For sensible choices, at least one of <span class="math">P</span> or <span class="math">Q</span> is a point in <span class="math">E(\\mathbb{F}_{q})</span>, and the other may be represented as a point in <span class="math">E(\\mathbb{F}_{q^{d}})</span>, where <span class="math">d</span> is an exact divisor of <span class="math">k</span>. For security it is important the discrete logarithm problems in both the elliptic curve fields (ECDLP) and the <span class="math">k</span>-th extension of the finite field (DLP) should be of equal complexity. Indeed as pointed out some years ago by Menezes, Okamoto and Vanstone <em>[26]</em> (see also <em>[17]</em>), the former problem can be easily converted to the latter on pairing-friendly curves. Unfortunately index calculus methods apply in the finite field setting, so parameter sizes must be adjusted upwards to take this into account. We must also be wary of a direct Pollard-rho attack on the ECDLP problem. For a survey of the discrete logarithm problem in all of its settings, see <em>[29]</em>.</p>

    <p class="text-gray-300">Therefore in an ideal world, for AES-128 security, one would like the elliptic curve group size to be 256-bits embedded in a field of the same size (to defend against Pollard-rho), and an extension degree of 12 to raise the size of the finite field DLP problem to 3072 bits (to defend against index calculus). In fact using a member of the well known Barreto-Naehrig family of pairing friendly curves <em>[7]</em>, we can achieve exactly that.</p>

    <p class="text-gray-300">Type-1 pairings, denoted <span class="math">G_{1}\\times G_{1}\\rightarrow G_{T}</span>, are implemented on supersingular elliptic curves over <span class="math">\\mathbb{F}_{p}</span>, <span class="math">\\mathbb{F}_{2^{m}}</span> and <span class="math">\\mathbb{F}_{3^{m}}</span>, with maximum embedding degrees of 2, 4 and 6 respectively. In a Type-1 pairing both <span class="math">P</span> and <span class="math">Q</span> are points over the base field <span class="math">G_{1}</span>, and the pairing supports the property of symmetry, that is <span class="math">e(P,Q)=e(P,Q_{1})\\times e(P,Q_{2})</span></p>

    <p class="text-gray-300"><span class="math">e(Q,P)</span>, so left and right hand arguments can be swapped at will. A problem with Type-1 pairings is that none are known which are as efficient at the AES-192 and AES-256 levels of security as the Type-3 equivalent, primarily as none support embedding degrees greater than 6 (on elliptic curves).</p>

    <p class="text-gray-300">Type-3 pairings, here denoted <span class="math">G_{2}\\times G_{1}\\to G_{T}</span>, are much more numerous and support any embedding degree. They are only known on elliptic curves over fields of large prime characteristic <span class="math">E(\\mathbb{F}_{p})</span>. Usually we prefer those that support the maximal twist (minimizing <span class="math">d</span> above), and those which support the required size of group (for the chosen level of security) in the smallest possible field. This feature is captured in the <span class="math">\\rho</span> parameter of the pairing-friendly curve – see the Freeman-Scott-Teske taxonomy of pairing-friendly curves for more details <em>[16]</em>. There such curves are referred to as curves which support “efficient arithmetic”. For a Type-3 pairing one of <span class="math">P</span> or <span class="math">Q</span> is in the larger field <span class="math">G_{2}</span>, a point on <span class="math">E(\\mathbb{F}_{q^{d}})</span>, and the symmetry property does not hold.</p>

    <p class="text-gray-300">Another matter of choice is that of which pairing function to implement. The Tate pairing was initially preferred, until the discovery of truncated loop variants like the <span class="math">\\eta_{T}</span> pairing <em>[6]</em>, which was more efficient over fields of small characteristic. In the Type-3 setting the situation is a little more complex. In the Miller algorithm the left-hand argument, in the course of the calculation, undergoes a point multiplication by a fixed system parameter. The best truncated loop variants of the Tate pairing in the Type-3 setting are the ate pairing <em>[20]</em>, or the R-ate pairing <em>[23]</em>. These can achieve the maximum loop reduction, by a factor of <span class="math">\\phi(k)</span>, where <span class="math">\\phi(.)</span> is the Euler totient function <em>[37]</em>. In both cases the left-hand parameter must, unfortunately, be the element in the larger field <span class="math">E(\\mathbb{F}_{p^{d}})</span>. However this only partially offsets the advantage of optimal loop reduction.</p>

    <p class="text-gray-300">Algorithm 1 Computation of basic ate pairing <span class="math">e(P,Q)</span> using Miller’s algorithm 0: <span class="math">P\\in E(\\mathbb{F}_{p^{d}}),Q\\in E(\\mathbb{F}_{p})</span>, trace <span class="math">t</span>, even <span class="math">k</span>, where <span class="math">P</span> has order <span class="math">r</span> 0: <span class="math">e(P,Q)</span> 1: <span class="math">T\\leftarrow P</span>, <span class="math">m\\leftarrow 1</span> 2: <span class="math">n\\leftarrow t-1</span> 3: for <span class="math">i\\leftarrow\\lfloor\\lg(n)\\rfloor-1</span> downto <span class="math">0</span> do 4: <span class="math">m\\leftarrow m^{2}.l_{T,T}(Q)</span> 5: <span class="math">T\\leftarrow 2T</span> 6: if <span class="math">n_{i}=1</span> then 7: <span class="math">m\\leftarrow m.l_{T,P}(Q)</span> 8: <span class="math">T\\leftarrow T+P</span> 9: end if 10: end for 11: <span class="math">m\\leftarrow m^{(p^{k}-1)/r}</span> 12: return <span class="math">m</span></p>

    <p class="text-gray-300">In the Miller algorithm the line function <span class="math">l_{A,B}(Q)</span> is a distance calculated between the fixed point <span class="math">Q</span> and the lines that arise when adding <span class="math">B</span> to <span class="math">A</span> on the elliptic curve in the standard way.</p>

    <p class="text-gray-300">A final choice is projective or affine coordinates for the representation of elliptic curve points. Recall that the latter representation requires a single base field modular inversion for each point addition or doubling. However over <span class="math">\\mathbb{F}_{p^{d}}</span>, for larger <span class="math">d</span>, this becomes less significant than multiplications over the full extension field. Also the line functions required for Miller’s algorithm are simpler to calculate using affine coordinates. Recent work indicates that for embedding degrees less than 12 projective coordinates may be optimal, but that above that affine may be preferred <em>[22]</em>. However this decision depends to an extent on the chosen platform <em>[1]</em>. For BN curves we certainly lean towards projective coordinates <em>[3]</em>.</p>

    <h2 id="sec-4" class="text-2xl font-bold">3 Optimizations</h2>

    <p class="text-gray-300">The pairing itself is open to some interesting optimisations, depending on its context. These often involve precomputation, and so in some contexts storage availability may become an issue. As we will see these optimizations can interact in interesting ways.</p>

    <p class="text-gray-300">If both left-hand and right-hand arguments are fixed, then clearly the pairing itself can be precalculated and stored. If the left-hand parameter is fixed, then its multiples that arise in its multiplication by the fixed loop variable can be precalculated offline and stored in affine coordinates. We will call this the “fixed argument” optimization, first pointed out by Scott <em>[34]</em> and recently analysed in more detail by Costello and Stebila <em>[15]</em>. No advantage can be taken of a fixed right-hand parameter, but for a Type-1 pairing only, symmetry can be exploited to move it to the left-hand side and precalculate its multiples as before. For a protocol on a Type-3 pairing it might well be worthwhile to consider reversing the roles of the left-hand and right-hand parameters in the protocol, in order to get the precomputable variable (if there is one) on the left side of the pairing.</p>

    <p class="text-gray-300">Note that if storage is not an issue, and the left-hand parameter is fixed, then the size of <span class="math">d</span> in <span class="math">E(\\mathbb{F}_{q^{d}})</span> doesn’t really matter, and so it is no longer important to use a pairing-friendly curve with the maximal twist. However it will be advantageous to use the pairing which gives us the maximal loop reduction, and the extra storage required for precomputation is often offset by the degree of loop reduction that can be achieved <em>[15]</em>. Therefore the possibility of precomputation may impact our choice of pairing-friendly curve. We will return to this point later.</p>

    <p class="text-gray-300">A second raft of optimisations is associated with the calculation of products of pairings, as arise in many protocols. As first pointed out by Solinas <em>[36]</em> and Scott <em>[34]</em> and expanded upon by Granger and Smart <em>[19]</em> three major optimisations are possible in this setting. All of the pairings can share the same Miller variable <span class="math">m</span>, and all can share the final exponentiation. Also Montgomery’s trick can be used to carry out all of the point additions/doublings for all of the pairings simultaneously in affine coordinates, while sharing just one modular inversion. If products of pairings play a major part in a protocol this may be a further incentive to use affine coordinates through-out. However if most or all of the left-hand parameters can be precomputed on, this optimization becomes less interesting.</p>

    <p class="text-gray-300">In this case the inclusion of one more pairing to a product of pairings typically carries only the extra cost of <span class="math">n</span> sparse <span class="math">k</span>-th extension field multiplications, if there are <span class="math">n</span> iterations required in the main Miller loop.</p>

    <p class="text-gray-300">Well-known precomputation optimizations apply to powering fixed elements in finite fields, and multiplying fixed points on elliptic curves. These may be applicable in some steps of a pairing-based protocol, and should not be overlooked.</p>

    <p class="text-gray-300">It is interesting to observe however that precomputation optimizations do not really apply to Type-1 pairings over fields of small characteristic. This is related to the fact on a supersingular curve <span class="math">E(\\mathbb{F}_{2^{m}})</span> (for example) point doublings require only field squarings, and these are very fast (asymptotically and in practise) compared to field multiplications. Therefore cheap multiples of a point may be calculated efficiently on-the-fly rather than needing to be precalculated. Also in our experience such Type-1 pairings tend to result in smaller implementations, and so they may be considered a better choice for the space-constrained environment where precomputation would not be an option anyway <em>[30]</em>. In the sequel we will concentrate on the Type-3 pairing scenario.</p>

    <h2 id="sec-5" class="text-2xl font-bold">4 Pairing friendly curves</h2>

    <p class="text-gray-300">We will use a variety of pairing-friendly curves to cover all common security levels, corresponding to common AES-like security levels of 80, 128, 192 and 256 bits. All are associated with an even embedding degree <span class="math">k</span>, as the denominator-elimination optimization is important <em>[5]</em>. The curves used are given in Table 1. These curves have been obtained from a number of sources. For a review of the available pairing friendly curves see the Freeman-Scott-Teske taxonomy <em>[16]</em>. The curve CP-80 is a Cocks-Pinch curve <em>[10]</em>, MNT-80 is a Miyaji-Nakabayashi-Takano curve <em>[27]</em>, BN-128 is a Barreto-Naehrig curve <em>[7]</em>, KSS-192 is a Kachisa-Schaefer-Scott curve <em>[21]</em>, and finally BLS-256 is a Barreto-Lynn-Scott curve <em>[4]</em>. These have been chosen to conservatively satisfy the above levels of security in terms of the difficulty of the various discrete logarithm problems which defend pairing-based cryptography from attack. In all cases the size of <span class="math">k.\\lg p</span> is within the limits given in <em>[16]</em>, Table 1. Note that the choice of curve for AES-192 security is not straightforward as there is not an obvious best choice amongst the available pairing-friendly curves. A KSS curve with <span class="math">k=16</span> would be a contender, as would a BN curve with a group size of 640-bits <em>[32]</em>. Some tests indicate that our choice is slightly better than the BN alternative, and requires a smaller <span class="math">G_{1}</span>. Our choice also supports a sextic twist on <span class="math">G_{2}</span>. For an alternative point of view, see <em>[28]</em>.</p>

    <p class="text-gray-300">Extension fields of degree <span class="math">k</span>, in which the bulk of the pairing computation takes place, are built using a tower of extensions - see <em>[8]</em> for details.</p>

    <h2 id="sec-6" class="text-2xl font-bold">5 A simple example - Boneh-Boyen IBE</h2>

    <p class="text-gray-300">To illustrate these points let us first look at a relatively simple protocol and see which optimizations apply. Note that in a pairing based protocol we should first</p>

    <p class="text-gray-300">Table 1. Pairing-friendly curves</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G2 type</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">k</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Modulus (bits)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">ρ</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Towering</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Pairing</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">CP-80</td>

            <td class="px-3 py-2 border-b border-gray-700">Fp (projective)</td>

            <td class="px-3 py-2 border-b border-gray-700">2</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">3.2</td>

            <td class="px-3 py-2 border-b border-gray-700">1-2</td>

            <td class="px-3 py-2 border-b border-gray-700">Tate</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MNT-80</td>

            <td class="px-3 py-2 border-b border-gray-700">Fp3 (affine)</td>

            <td class="px-3 py-2 border-b border-gray-700">6</td>

            <td class="px-3 py-2 border-b border-gray-700">160</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1-2-6/1-3-6</td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BN-128</td>

            <td class="px-3 py-2 border-b border-gray-700">Fp2 (projective)</td>

            <td class="px-3 py-2 border-b border-gray-700">12</td>

            <td class="px-3 py-2 border-b border-gray-700">256</td>

            <td class="px-3 py-2 border-b border-gray-700">1</td>

            <td class="px-3 py-2 border-b border-gray-700">1-2-4-12</td>

            <td class="px-3 py-2 border-b border-gray-700">R-ate</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">KSS-192</td>

            <td class="px-3 py-2 border-b border-gray-700">Fp3 (affine)</td>

            <td class="px-3 py-2 border-b border-gray-700">18</td>

            <td class="px-3 py-2 border-b border-gray-700">512</td>

            <td class="px-3 py-2 border-b border-gray-700">1.33</td>

            <td class="px-3 py-2 border-b border-gray-700">1-3-6-18</td>

            <td class="px-3 py-2 border-b border-gray-700">R-ate</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">BLS-256</td>

            <td class="px-3 py-2 border-b border-gray-700">Fp4 (affine)</td>

            <td class="px-3 py-2 border-b border-gray-700">24</td>

            <td class="px-3 py-2 border-b border-gray-700">640</td>

            <td class="px-3 py-2 border-b border-gray-700">1.25</td>

            <td class="px-3 py-2 border-b border-gray-700">1-2-4-8-24</td>

            <td class="px-3 py-2 border-b border-gray-700">ate</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">look at fixed system parameters, that are often introduced in the Setup part of the protocol. These are obvious candidates for precomputation. A second good place to look is at the private keys of the users, created often in the Keygen or Extract step of the protocol. Clearly a particular individual is free to precompute on their own fixed private key.</p>

    <p class="text-gray-300">Our first example is the  <span class="math">BB_{1}</span>  Identity Based Encryption scheme from Boneh and Boyen, as described in section 4.3 of [11] (the full version).</p>

    <p class="text-gray-300">Setup Select random points  <span class="math">P \\in G_2</span>  and  <span class="math">Q \\in G_1</span> . If the pairing friendly group is of size  <span class="math">r</span> , then pick random group elements  <span class="math">\\alpha, \\beta</span>  and  <span class="math">\\delta \\in \\mathbb{Z}_r</span> . Set  <span class="math">Q_a = \\alpha Q</span>  and  <span class="math">Q_d = \\delta Q</span> . Compute  <span class="math">v = e(P, Q)^{\\alpha \\beta}</span> . Finally choose a hash function  <span class="math">H_1(.)</span>  which hashes an element in  <span class="math">G_T</span>  to a string of length  <span class="math">m</span>  bits, and a second hash function  <span class="math">H_2(.)</span>  which hashes an identity string to a group element. The public parameters are  <span class="math">\\{Q, Q_a, Q_d, v\\}</span> , and the master key is  <span class="math">\\{P, \\alpha, \\beta, \\delta\\}</span> .</p>

    <p class="text-gray-300">Extract Given the master key and an identity  <span class="math">ID</span> , generate a random  <span class="math">w</span>  and extract the private key as  <span class="math">D_0 = (\\alpha \\beta + w(\\alpha H_2(ID) + \\delta))P</span>  and  <span class="math">D_1 = wP</span> .</p>

    <p class="text-gray-300">Encrypt Given  <span class="math">ID</span>  and a message  <span class="math">M</span>  of length  <span class="math">m</span> , pick a random  <span class="math">s</span>  and output  <span class="math">C = \\{M \\oplus H_1(v^s), sQ, sQ_d + sH_2(ID)Q_a\\}</span></p>

    <p class="text-gray-300">Decrypt To decrypt the ciphertext  <span class="math">C = \\{C_0, C_1, C_2\\}</span>  using the private key  <span class="math">\\{D_0, D_1\\}</span> , output  <span class="math">M = C_0 \\oplus H_1(e(D_0, C_1) / e(D_1, C_2))</span></p>

    <p class="text-gray-300">As pointed out by the authors, this protocol is remarkable to the extent that it can benefit from multiple precomputation optimizations. However the fixed-argument optimization was overlooked. To benefit from this on a Type-3 pairing, the precomputable variable (in this case the private key) must appear on the left side of the pairing. Indeed the applicability of this optimization helps fix the optimal role assignment in many pairing-based protocols on Type-3 curves. Costello and Stebila did consider this optimization for this protocol (Table 5 [15]), but not in conjunction with the multi-pairing optimization which also applies in the decryption step. Granger and Smart [19] estimated the gain from using a multipairing, but not in the context where the fixed-argument optimization applied. Finally Lauter, Montgomery and Naehrig [22] did consider both optimizations in combination (see also [1]), but not in the context of a particular protocol.</p>

    <p class="text-gray-300">To summarise for this protocol, all point multiplications and extension field exponentiations in the Extract and Encrypt steps can benefit from "fixed-point"</p>

    <p class="text-gray-300">optimizations. In the Decrypt step the quotient of pairings can be trivially replaced with a product, and so both the multi-pairing and fixed-argument optimizations apply.</p>

    <p class="text-gray-300">To measure performance we present timings for an actual implementation [35], for each step of this protocol. See table 2. All of the code and implementations described here can be found in [35], along with details of the pairing-friendly curves used. Our hardware is a 64-bit Intel i5 520M, clocked at  <span class="math">2.4\\mathrm{GHz}</span> . Our implementation runs on a single core, and uses a mixture of  <span class="math">\\mathrm{C + + }</span> , C and some automatically generated assembly language. We acknowledge that hand-crafted assembly will always do better, sometimes a lot better [3], especially at lower levels of security.</p>

    <p class="text-gray-300">We use an 8-bit window size for fixed-point optimizations. For the fixed-argument optimization we do not exploit the merging optimization as described in [15]. However exploiting this idea (at the cost of doubling the storage requirement) would give a further small but useful speed-up.</p>

    <p class="text-gray-300">Table 2.  <span class="math">{BB}_{1}</span>  protocol - timings in milliseconds</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MNT-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN-128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS-192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLS-256</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">with/without precomp</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">w/o</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">w/o</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">w/o</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">w/o</td>

            <td class="px-3 py-2 border-b border-gray-700">w</td>

            <td class="px-3 py-2 border-b border-gray-700">w/o</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Extract</td>

            <td class="px-3 py-2 border-b border-gray-700">0.207</td>

            <td class="px-3 py-2 border-b border-gray-700">1.020</td>

            <td class="px-3 py-2 border-b border-gray-700">0.663</td>

            <td class="px-3 py-2 border-b border-gray-700">2.239</td>

            <td class="px-3 py-2 border-b border-gray-700">0.363</td>

            <td class="px-3 py-2 border-b border-gray-700">0.854</td>

            <td class="px-3 py-2 border-b border-gray-700">5.265</td>

            <td class="px-3 py-2 border-b border-gray-700">10.237</td>

            <td class="px-3 py-2 border-b border-gray-700">10.360</td>

            <td class="px-3 py-2 border-b border-gray-700">30.598</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Encrypt</td>

            <td class="px-3 py-2 border-b border-gray-700">0.366</td>

            <td class="px-3 py-2 border-b border-gray-700">1.695</td>

            <td class="px-3 py-2 border-b border-gray-700">0.194</td>

            <td class="px-3 py-2 border-b border-gray-700">0.767</td>

            <td class="px-3 py-2 border-b border-gray-700">0.653</td>

            <td class="px-3 py-2 border-b border-gray-700">1.646</td>

            <td class="px-3 py-2 border-b border-gray-700">3.625</td>

            <td class="px-3 py-2 border-b border-gray-700">8.596</td>

            <td class="px-3 py-2 border-b border-gray-700">8.110</td>

            <td class="px-3 py-2 border-b border-gray-700">29.460</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Decrypt (2 pairings)</td>

            <td class="px-3 py-2 border-b border-gray-700">1.213</td>

            <td class="px-3 py-2 border-b border-gray-700">2.360</td>

            <td class="px-3 py-2 border-b border-gray-700">1.392</td>

            <td class="px-3 py-2 border-b border-gray-700">3.788</td>

            <td class="px-3 py-2 border-b border-gray-700">4.097</td>

            <td class="px-3 py-2 border-b border-gray-700">4.680</td>

            <td class="px-3 py-2 border-b border-gray-700">36.438</td>

            <td class="px-3 py-2 border-b border-gray-700">41.090</td>

            <td class="px-3 py-2 border-b border-gray-700">65.846</td>

            <td class="px-3 py-2 border-b border-gray-700">73.469</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Decrypt (multi-pairing)</td>

            <td class="px-3 py-2 border-b border-gray-700">0.834</td>

            <td class="px-3 py-2 border-b border-gray-700">1.991</td>

            <td class="px-3 py-2 border-b border-gray-700">1.043</td>

            <td class="px-3 py-2 border-b border-gray-700">3.383</td>

            <td class="px-3 py-2 border-b border-gray-700">2.533</td>

            <td class="px-3 py-2 border-b border-gray-700">3.106</td>

            <td class="px-3 py-2 border-b border-gray-700">20.614</td>

            <td class="px-3 py-2 border-b border-gray-700">25.221</td>

            <td class="px-3 py-2 border-b border-gray-700">36.900</td>

            <td class="px-3 py-2 border-b border-gray-700">44.035</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The most striking conclusion to be drawn from this table is that by exploiting both the fixed-argument and multi-pairing precomputation optimizations, for this protocol we basically get the two pairings for the price of one (or less). In the case of the MNT curve, the gain is even more striking. For these curves only a quadratic twist is possible for  <span class="math">G_{2}</span> , where point multiplication is therefore particularly expensive.</p>

    <p class="text-gray-300">Note that the latency of both the encryption and extract stages can be further optimized by exploiting the fact that a lot of the calculation can be carried out offline, prior to the presentation of the inputs. For example the encrypting entity can compute and maintain offline a pool of tuplets  <span class="math">\\{s, v^s, sQ, sQ_d\\}</span>  prior to receiving the message and ID. In this way the online part of the calculation reduces to a single fixed-point multiplication. The same applies to the extract phase by precomputing tuplets  <span class="math">\\{w, wP\\}</span> .</p>

    <p class="text-gray-300">6 Attribute based cryptography</p>

    <p class="text-gray-300">Next we consider a much more elaborate protocol, a ciphertext-policy attribute-based encryption scheme due to Waters <em>[38]</em>. Our first problem is that the protocol (<em>[38]</em> section 3) is described in the context of a Type-1 pairing. However this protocol has already been implemented on an MNT curve by Akinyele et al., <em>[2]</em> so we follow the example of their conversion to a Type-3 setting.</p>

    <p class="text-gray-300">Each participant in this scheme is equipped with a set of attributes. When a message is encrypted, it is encrypted in such a way that it is only acessible to recipients who possess a particular combination of attributes. This combination of attributes is described in a logical fashion, which can be put into the form of a tree-like structure. The attributes form the leaf-nodes of the tree. Each attribute might appear at several leaf nodes. Each node evaluates as true or false, and these results eventually arrive at the root of the tree, which itself evaluates as true or false. If a recipient’s attributes satisfy this access structure, then they can decrypt the ciphertext.</p>

    <p class="text-gray-300">This tree structure can in turn be converted into an LSSS matrix, which is required by the protocol. For this we use the method of Liu and Cao <em>[25]</em>. The number of rows in the matrix is the number of leaf nodes of the access tree. Each row of the matrix is associated with an (not necessarily distinct) attribute by a function <span class="math">f(.)</span>. If attribute <span class="math">j</span> is associated with row <span class="math">i</span> of the LSSS matrix, then <span class="math">j=f(i)</span>. A secret value <span class="math">s</span> will be hidden using a secret sharing operation using the LSSS matrix, and can only be recovered by a valid recipient. The satisfiability of the access structure is reflected in the ability to find the inverse of the subset of the LSSS matrix associated with the attributes available to a recipient, who can then regenerate <span class="math">s</span>. The protocol as described here includes an optimized Decrypt step found in the implementation associated with <em>[2]</em>.</p>

    <p class="text-gray-300">Select random points <span class="math">P\\in G_{2}</span> and <span class="math">Q\\in G_{1}</span>. If the pairing friendly group is of size <span class="math">r</span>, then pick random group elements <span class="math">\\alpha</span> and <span class="math">\\delta\\in\\mathbb{Z}_{r}</span>. Set <span class="math">P_{d}=\\delta P</span>, <span class="math">Q_{d}=\\delta Q</span>, <span class="math">Q_{\\alpha}=\\alpha Q</span> and <span class="math">v=e(P,Q)^{\\alpha}</span>. For each of the <span class="math">U</span> attributes in the system, generate a random <span class="math">H_{i}\\in G_{2}</span>. The public parameters are <span class="math">\\{P,Q,v,P_{d},Q_{d},H_{1}\\ldots H_{U}\\}</span>. The master key is <span class="math">Q_{\\alpha}</span>. The inputs are a message <span class="math">M</span>, and an <span class="math">m\\times n</span> LSSS matrix <span class="math">S</span>. Generate a random vector <span class="math">\\bar{u}=(s,y_{2},\\ldots y_{n})\\in\\mathbb{Z}_{r}</span>. Then calculate the <span class="math">m</span> vector <span class="math">\\bar{\\lambda}=S.\\bar{u}</span> and generate another random <span class="math">m</span> vector <span class="math">\\bar{x}\\in\\mathbb{Z}_{r}</span>. Calculate the ciphertext as <span class="math">C_{t}=Mv^{s}</span>, <span class="math">C_{d}=sP</span>, and for <span class="math">i</span> equal 1 to <span class="math">m</span> calculate <span class="math">C_{i}=\\lambda_{i}P_{d}-x_{i}H_{f(i)}</span> and <span class="math">D_{i}=x_{i}Q</span>. Note that the same attribute may be associated with different indices <span class="math">i</span>. The inputs are the master key and a set of <span class="math">\\ell</span> attributes <span class="math">A</span> assigned to an individual. Pick a random group element <span class="math">t\\in\\mathbb{Z}_{r}</span> and create a private key as <span class="math">K=Q_{\\alpha}+tQ_{d}</span>, <span class="math">L=tQ</span> and <span class="math">K_{i}=tH_{i}</span> for each possessed attribute <span class="math">i\\in A</span>. First reduce the matrix <span class="math">S</span> by removing rows associated with attributes that are not in <span class="math">A</span> and remove redundant all-zero columns from the matrix. Next calculate the vector <span class="math">\\bar{\\omega}</span> which in the first row of <span class="math">S^{-1}</span>. For a reasonable</p>

    <p class="text-gray-300">number of attributes, the <span class="math">\\omega_{i}</span> will be very small integers. (The shared secret <span class="math">s=\\bar{\\omega}.\\bar{\\lambda}</span>.) Set all <span class="math">C_{j}\\leftarrow\\omega_{j}C_{j}</span> and <span class="math">D_{j}\\leftarrow\\omega_{j}D_{j}</span>. Where the same attribute is associated with more than one row of the <span class="math">S</span> matrix, combine the associated <span class="math">C_{j}</span> and <span class="math">D_{j}</span> values by simply adding them. (We exploit bilinearity as <span class="math">e(K_{i},D_{j}).e(K_{i},D_{k})=e(K_{i},D_{j}+D_{k})</span>, and rewrite <span class="math">D_{i}=D_{j}+D_{k}</span>). Finally recover the message as</p>

    <p class="text-gray-300"><span class="math">M=C_{t}.e(C_{d},-K)e(\\sum_{i\\in A}C_{i},L)\\prod_{i\\in A}e(K_{i},D_{i})</span></p>

    <p class="text-gray-300">Casting an implementer’s eye over the above we observe that</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>All point multiplications and extension field exponentiations in the Encrypt and Extract steps benefit from the fixed-point optimization.</li>

      <li>The latency of both Encrypt and Keygen steps can benefit from the off-line maintainance of precomputed pools of data, in the former case tuples of <span class="math">\\{s,sP,v^{s},x_{1},x_{1}Q,x_{1}H_{1},\\ldots x_{1}H_{U},x_{2},\\ldots x_{U}H_{U}\\}</span> and in the latter tuples of <span class="math">\\{t,tQ,tQ_{d},tH_{1}\\ldots tH_{U}\\}</span>. Now Keygen requires essentially no work at all other than plucking values from the pool and a single point addition, and encryption requires an on-line calculation of just <span class="math">m</span> fixed-point multiplications, if there are <span class="math">m</span> leaf nodes in the access tree.</li>

      <li>We have assigned roles to <span class="math">G_{1}</span> and <span class="math">G_{2}</span> to facilitate the fixed-argument precomputation for the potentially expensive Decrypt step. As can be seen decryption boils down primarily to a multi-pairing of <span class="math">\\ell+2</span> pairings. For the first two of these the precomputable parameter (<span class="math">K</span> and <span class="math">L</span>) unfortunately falls on the “wrong side” of the pairing. Interestingly on a Type-1 pairing over a field of prime characteristic, symmetry could be expoited to move these over to the other side. However the <span class="math">\\ell</span> pairings associated with the potentially large number of attributes can all profit from precomputation.</li>

    </ol>

    <p class="text-gray-300">We provide timings for an implementation in the context of a fairly elaborate but arbitrarily chosen access structure with a total of <span class="math">U=12</span> attributes. The LSSS matrix has <span class="math">m=14</span> rows (two of the attributes appear twice), and the recipient has <span class="math">\\ell=6</span> attributes, which are sufficient to satisfy the access tree. We also show decryption times where an extra attribute is required, increasing the number of pairings in the multi-pairing by 1. Note the Encryption and Keygen timings are for the complete operation, without exploiting the possibility of off-line maintainance of precomputed pools. One surprising observation is that the Encrypt step for this implementation of this protocol is actually more time-consuming than the pairing-heavy Decrypt step. This goes counter to the received wisdom.</p>

    <p class="text-gray-300">For a contrived system with 20 attributes, all of which are required for decryption, for the BN-128 curve it takes 9.93ms for encryption and 13.05ms for decryption. This is more than 30 times faster (and at a higher level of security) than the timings reported in <em>[2]</em> on the same processor, and significantly faster than the results reported recently by Acar et al. (<em>[1]</em>, Table 3).</p>

    <p class="text-gray-300">Table 3. Waters CP-ABE protocol - timings in milliseconds</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MNT-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN-128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS-192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLS-256</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Encrypt</td>

            <td class="px-3 py-2 border-b border-gray-700">4.57</td>

            <td class="px-3 py-2 border-b border-gray-700">10.61</td>

            <td class="px-3 py-2 border-b border-gray-700">6.96</td>

            <td class="px-3 py-2 border-b border-gray-700">84.16</td>

            <td class="px-3 py-2 border-b border-gray-700">164.88</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Keygen</td>

            <td class="px-3 py-2 border-b border-gray-700">1.25</td>

            <td class="px-3 py-2 border-b border-gray-700">2.24</td>

            <td class="px-3 py-2 border-b border-gray-700">1.42</td>

            <td class="px-3 py-2 border-b border-gray-700">17.06</td>

            <td class="px-3 py-2 border-b border-gray-700">33.03</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Decrypt (6 attributes)</td>

            <td class="px-3 py-2 border-b border-gray-700">3.26</td>

            <td class="px-3 py-2 border-b border-gray-700">5.63</td>

            <td class="px-3 py-2 border-b border-gray-700">6.18</td>

            <td class="px-3 py-2 border-b border-gray-700">39.28</td>

            <td class="px-3 py-2 border-b border-gray-700">66.91</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Decrypt (7 attributes)</td>

            <td class="px-3 py-2 border-b border-gray-700">3.41</td>

            <td class="px-3 py-2 border-b border-gray-700">6.03</td>

            <td class="px-3 py-2 border-b border-gray-700">6.68</td>

            <td class="px-3 py-2 border-b border-gray-700">41.54</td>

            <td class="px-3 py-2 border-b border-gray-700">71.04</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Finally we consider a complex Inner-Product Predicate Encryption scheme based on bilinear maps with prime-order groups, recently proposed by Park [31]. We omit the details of the protocol (see page 251 of [31]), which although described in the setting of a Type-1 pairing can easily be converted to use a Type-3 pairing. Our implementation exploits all of the precomputation possibilities. Fixed point optimizations apply to all stages of the Encrypt step, and the fixed-argument optimization applies to the Decrypt step. The Encrypt step calculations take place in  <span class="math">G_{1}</span>  (and are therefore unaffected by the size of  <span class="math">G_{2}</span> ). At first glance this protocol appears to be potentially quite impractical. For an implementation supporting 10 attributes the decryption step requires the computation of the product of 42 pairings. However as can be seen from table 4 the timings achieved are surprisingly reasonable.</p>

    <p class="text-gray-300">Table 4. Park's IPE protocol (10 attributes) - timings in milliseconds</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Curve</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CP-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">MNT-80</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BN-128</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">KSS-192</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">BLS-256</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Encrypt</td>

            <td class="px-3 py-2 border-b border-gray-700">13.02</td>

            <td class="px-3 py-2 border-b border-gray-700">4.72</td>

            <td class="px-3 py-2 border-b border-gray-700">9.05</td>

            <td class="px-3 py-2 border-b border-gray-700">32.37</td>

            <td class="px-3 py-2 border-b border-gray-700">61.84</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Decrypt</td>

            <td class="px-3 py-2 border-b border-gray-700">9.49</td>

            <td class="px-3 py-2 border-b border-gray-700">16.23</td>

            <td class="px-3 py-2 border-b border-gray-700">22.22</td>

            <td class="px-3 py-2 border-b border-gray-700">112.76</td>

            <td class="px-3 py-2 border-b border-gray-700">188.47</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">The applicability of these optimizations potentially has an impact on the optimal choice of pairing. In particular if the fixed-argument optimization applies to the pairing, then all required multiples of points on  <span class="math">E(\\mathbb{F}_{q^d})</span>  can be precalculated, and thus there is no longer any major benefit in  <span class="math">d</span>  being minimal. However while this is true in the context of a protocol step involving pairings, if  <span class="math">G_{2}</span>  becomes larger this may have a negative impact on the performance of other phases of a particular protocol.</p>

    <p class="text-gray-300">As a concrete example compare a Brezing and Weng curve [14] with  <span class="math">k = 8</span> ,  <span class="math">\\rho = 1.25</span>  and  <span class="math">d = 4</span> , with the alternative efficient-arithmetic curve recommended</p>

    <p class="text-gray-300">in FST <em>[16]</em>, for which <span class="math">k=8</span>, <span class="math">\\rho=1.5</span> and <span class="math">d=2</span>. If the fixed argument optimization applies then the smaller <span class="math">d</span> value for the latter is largely irrelevant to the pairing calculation, and with a superior <span class="math">\\rho</span> value the Brezing and Weng curve may well make a better choice at an AES-112 level of security.</p>

    <p class="text-gray-300">In the context of a multi-pairing in conjunction with fixed arguments, then the impact of “one more” pairing will be minimized if we choose a curve which supports the minimum Miller loop length for a given level of security.</p>

    <p class="text-gray-300">In the paper <em>[28]</em> the authors consider curves with <span class="math">k=15</span>. Despite the loss of full denominator elimination the authors contend that this might be a contender with BN curves at the AES-128 bit level. One of the problems with the <span class="math">k=15</span> curve is that only a cubic twist is possible, and arithmetic on <span class="math">E(\\mathbb{F}_{p^{5}})</span> is expensive compared with arithmetic on <span class="math">E(\\mathbb{F}_{p^{2}})</span> as required for the BN curve which supports a sextic twist. However if the fixed argument optimization applies, this advantage for BN curves disappears as all these values required by the pairing can be precomputed. And a <span class="math">k=15</span> curve will have an optimal pairing with a half-sized Miller loop compared with the BN equivalent (<span class="math">\\phi(15)=8</span>, <span class="math">\\phi(12)=4</span>). In <em>[24]</em> the authors make a similar case for a <span class="math">k=9</span> curve. At the AES-256 level the KSS <span class="math">k=32</span> curve <em>[16]</em> might turn out to be a better choice than our BLS <span class="math">k=24</span> curve. The latter has a better twist (6 vs 4), but the former has twice the loop-reduction and a better <span class="math">\\rho</span> value of 1.125.</p>

    <p class="text-gray-300">So in the scenario of a protocol where a multi-pairing is required, and where the great majority of the left-hand parameters are fixed – a scenario which a quick glance through the literature would seem to indicate is quite common – efficient implementation might benefit from a reappraisal of which pairing-friendly curve is optimal to use for the standard levels of security.</p>

    <h2 id="sec-9" class="text-2xl font-bold">9 Conclusion</h2>

    <p class="text-gray-300">We have pointed out that in pairing-based protocols many precomputation optimizations are possible. By combining these the performance can be improved significantly. In particular we show that relatively complex protocols are completely practical on standard hardware at all levels of security. We give for the first time realistic timings for pairings at the AES-256 bit level. Whereas one pairing at the AES-256 level takes 37 milliseconds on a contemporary PC, we observe that “one-more” pairing in the context of a multi-pairing can take less than 5 milliseconds. For future work we ask whether the currently accepted pairing-friendly curves are actually the optimal choice when deployed in real-world protocols.</p>

    <h2 id="sec-10" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] T. Acar, K. Lauter, M. Naehrig, and D. Shumow. Affine pairings on ARM. Cryptology ePrint Archive, Report 2011/243, 2011. http://eprint.iacr.org/2011/243.</li>

      <li>[2] Joseph A. Akinyele, Christoph U. Lehmann, Matthew D. Green, Matthew W. Pagano, Zachary N. J. Peterson, and Aviel D. Rubin. Self-protecting electronic</li>

    </ul>

    <p class="text-gray-300">medical records using attribute-based encryption. Cryptology ePrint Archive, Report 2010/565, 2010. http://eprint.iacr.org/2010/565.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[3] D. F. Aranha, K. Karabina, P. Longa, C. H. Gebotys, and J. López. Faster explicit formulas for computing pairings over ordinary curves. In Eurocrypt 2011, volume 6632 of Lecture Notes in Computer Science, pages 48–68. Springer-Verlag, 2011.</li>

      <li>[4] P. S. L. M. Barreto, B. Lynn, and M. Scott. Constructing elliptic curves with prescribed embedding degrees. In Security in Communication Networks – SCN’2002, volume 2576 of Lecture Notes in Computer Science, pages 263–273. Springer-Verlag, 2002.</li>

      <li>[5] P. S. L. M. Barreto, B. Lynn, and M. Scott. Efficient implementation of pairing-based cryptosystems. Journal of Cryptography, 17:321–334, 2004.</li>

      <li>[6] P.S.L.M. Barreto, S. Galbraith, C. OhEigeartaigh, and M. Scott. Efficient pairing computation on supersingular abelian varieties. Designs, Codes and Cryptography, 42:239–271, 2007. http://eprint.iacr.org/2004/375.</li>

      <li>[7] P.S.L.M. Barreto and M. Naehrig. Pairing-friendly elliptic curves of prime order. In Selected Areas in Cryptography – SAC’2005, volume 3897 of Lecture Notes in Computer Science, pages 319–331. Springer-Verlag, 2006.</li>

      <li>[8] N. Benger and M. Scott. Constructing tower extensions for the implementation of pairing-based cryptography. In WAIFI 2010, volume 6087 of Lecture Notes in Computer Science, pages 180–195. Springer-Verlag, 2010.</li>

      <li>[9] J-L. Beuchat, J. E. González-Díaz, S. Mitsunari, E. Okamoto, F. Rodríguez-Henríquez, and T. Teruya. High-speed software implementation of the optimal ate pairing over barretto-naehrig curves. In Pairing 2010, volume 6487 of Lecture Notes in Computer Science, pages 21–39. Springer-Verlag, 2010.</li>

      <li>[10] I. F. Blake, G. Seroussi, and N. P. Smart, editors. Advances in Elliptic Curve Cryptography, Volume 2. Cambridge University Press, 2005.</li>

      <li>[11] D. Boneh and X. Boyen. Efficient selective-ID secure identity based encryption without random oracles. In Advances in Cryptology—EUROCRYPT 2004, volume 3027 of Lecture Notes in Computer Science, pages 223–238. Berlin: Springer-Verlag, 2004. Full version available at http://www.cs.stanford.edu/~xb/eurocrypt04b/.</li>

      <li>[12] D. Boneh, G. Di Crescenzo, R. Ostrovsky, and G. Persiano. Public key encryption with keyword search. In Advances in Cryptology - EUROCRYPT 2004, volume 3027 of Lecture Notes in Computer Science, pages 506–522. Springer Berlin / Heidelberg, 2004.</li>

      <li>[13] D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing. In Advances in Cryptology – Asiacrypt’2001, volume 2248 of Lecture Notes in Computer Science, pages 514–532. Springer-Verlag, 2002.</li>

      <li>[14] F. Brezing and A. Weng. Elliptic curves suitable for pairing based cryptography. Designs, Codes and Cryptology, 37:133–141, 2005.</li>

      <li>[15] C. Costello and D. Stebila. Fixed argument pairings. Cryptology ePrint Archive, Report 2010/342, 2010. http://eprint.iacr.org/2010/342.</li>

      <li>[16] D. Freeman, M. Scott, and E. Teske. A taxonomy of pairing friendly elliptic curves. Journal of Cryptography, 23:224–280, 2010.</li>

      <li>[17] G. Frey, M. Müller, and H. Rück. The Tate pairing and the discrete logarithm applied to elliptic curve cryptosystems. IEEE Transactions on Information Theory, 45(5):1717–1719, 1999.</li>

      <li>[18] S. Galbraith, K. Paterson, and N. Smart. Pairings for cryptographers. Discrete Applied Mathematics, 156:3113–3121, 2008.</li>

      <li>[19] R. Granger and N. P. Smart. On computing products of pairings. Cryptology ePrint Archive, Report 2006/172, 2006. http://eprint.iacr.org/2006/172.</li>

    </ul>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>F. Hess, N. Smart, and F. Vercauteren. The eta pairing revisited. IEEE Trans. Information Theory, 52:4595–4602, 2006.</li>

    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>21. E. Kachisa, E. Schaefer, and M. Scott. Constructing Brezing-Weng pairing-friendly elliptic curves using elements in the cyclotomic field. In Pairing 2008, volume 5209 of Lecture Notes in Computer Science, pages 126–135. Springer-Verlag, 2008.</li>

      <li>22. K. Lauter, P. Montgomery, and M. Naehrig. An analysis of affine coordinates for pairing computation. In Pairing 2010, volume 6487 of Lecture Notes in Computer Science, pages 1–20. Springer-Verlag, 2010.</li>

      <li>23. E. Lee, H-S. Lee, and C-M. Park. Efficient and generalized pairing computation on abelian varieties. IEEE Transactions on Information Theory, 55:1793–1803, 2009.</li>

      <li>24. X. Lin, C. Zhao, F. Zhang, and Y. Wang. Computing the ate pairing on elliptic curves with embedding degree <span class="math">k=9</span>. IEICE Transactions, 91-A(9):2387–2393, 2008.</li>

      <li>25. Zhen Liu and Zhenfu Cao. On efficiently transferring the linear secret-sharing scheme matrix in ciphertext-policy attribute-based encryption. Cryptology ePrint Archive, Report 2010/374, 2010. http://eprint.iacr.org/2010/374.</li>

      <li>26. A.J. Menezes, T. Okamoto, and S.A. Vanstone. Reducing elliptic curve logarithms to logarithms in a finite field. Information Theory, IEEE Transactions on, 39(5):1639 –1646, sep 1993.</li>

      <li>27. A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic curve traces for FR-reduction. IEICE Transactions on Fundamentals, E84-A(5):1234–1243, 2001.</li>

      <li>28. N. El Mrabet, N. Guillermin, and S. Ionica. A study of pairing computation for elliptic curves with embedding degree 15. Cryptology ePrint Archive, Report 2009/370, 2009. http://eprint.iacr.org/2009/370.</li>

      <li>29. A. M. Odlyzko. Discrete logarithms: the past and the future. Design, Codes and Cryptography, 19:129–145, 2000.</li>

      <li>30. L. Oliveira, D. Aranha, C. Gouvêa, M. Scott, D. Câmara, J. López, and R. Dahab. TinyPBC: Pairings for authenticated identity-based non-interactive key distribution in sensor networks. Computer Communications, 34:485–493, 2011.</li>

      <li>31. J. H. Park. Inner-product encryption under standard assumptions. Designs, Codes and Cryptography, 58:235–257, 2011.</li>

      <li>32. G. Pereira, M. Simplício Jr., M. Naehrig, and P. Barreto. A family of implementation-friendly BN elliptic curves. Journal of Systems and Software, 84:1319–1326, 2011.</li>

      <li>33. R. Sakai, K. Ohgishi, and M. Kasahara. Cryptosystems based on pairing. The 2000 Symposium on Cryptography and Information Security, Okinawa, Japan, 2000.</li>

      <li>34. M. Scott. Computing the Tate pairing. In CT-RSA, volume 3376 of Lecture Notes in Computer Science, pages 293–304. Springer-Verlag, 2005.</li>

      <li>35. M. Scott. Miracl library, 2011. http://www.shamus.ie.</li>

      <li>36. J. Solinas. ID-based digital signature algorithms, 2003. http://www.cacr.math.uwaterloo.ca/conferences/2003/ecc2003/solinas.pdf.</li>

      <li>37. F. Vercauteren. Optimal pairings. Information Theory, IEEE Transactions on, 56(1):455–461, Jan. 2010.</li>

      <li>38. B. Waters. Ciphertext-policy attribute-based encryption: An expressive, efficient, and provably secure realization. In Public Key Cryptography PKC 2011, volume 6571 of Lecture Notes in Computer Science, pages 53–70. Springer Berlin / Heidelberg, 2011.</li>

    </ul>`;
---

<BaseLayout title="On the Efficient Implementation of Pairing-Based Protocols (2011/334)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2011 &middot; eprint 2011/334
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
