---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2021/818';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'CTng: Secure Certificate and Revocation Transparency';
const AUTHORS_HTML = 'Jie Kong, Damon James, Hemi Leibowitz, Ewa Syta, Amir Herzberg';

const CONTENT = `    <p class="text-gray-300">In God we Trust; Others we Monitor</p>

    <p class="text-gray-300">This paper was accepted to NDSS’26. This is a draft of the full version of the paper.</p>

    <p class="text-gray-300">Jie Kong<em>, Damon James</em>, Hemi Leibowitz†§, Ewa Syta‡, Amir Herzberg*</p>

    <p class="text-gray-300">*University of Connecticut, Storrs, CT</p>

    <p class="text-gray-300">†The College of Management Academic Studies, Rishon LeZion, Israel</p>

    <p class="text-gray-300">‡Trinity College, Hartford, CT</p>

    <p class="text-gray-300">Abstract—We present CTng, an evolutionary and practical PKI design that efficiently addresses multiple key challenges faced by deployed PKI systems. CTng ensures strong security properties, including guaranteed transparency of certificates and guaranteed, unequivocal revocation, achieved under NTTP-security, i.e., without requiring trust in any single CA, logger, or relying party. These guarantees hold even in the presence of arbitrary corruptions of these entities, assuming only a known bound <span class="math">(f)</span> of corrupt monitors (e.g., <span class="math">f = 8</span>), with minimal performance impact. CTng also enables efficient certificate validation and preserves relying-party privacy, while providing scalable and efficient distribution of revocation updates.</p>

    <p class="text-gray-300">These properties significantly improve upon current PKI designs. In particular, while Certificate Transparency (CT) [39], [40], [41] aims to eliminate single points of trust, the existing specification [40] still assumes benign loggers. Addressing this through log redundancy is possible, but rather inefficient, limiting deployed configurations to <span class="math">f \\leq 2</span>.</p>

    <p class="text-gray-300">We present a security analysis and an evaluation of our open-source CTng prototype, showing that it is efficient and scalable under realistic deployment conditions.</p>

    <p class="text-gray-300">The Public Key Infrastructure (PKI) facilitates the secure use of public keys. PKI is critical for the security of open, distributed systems such as the Internet. Typically, a relying party obtains a public key and validates it using a certificate signed by a trusted Certificate Authority (CA). The PKI defines how certificates are issued and revoked (by the CAs) and validated (by relying parties).</p>

    <p class="text-gray-300">Most deployed PKIs follow the X.509 standard [10], [29]. X.509 certificates are used in protocols such as TLS, SSH, S/MIME, IPsec, and others. The most common application of PKI is to secure web and other forms of communication over the Internet using the TLS protocol. In particular, web communication is typically protected using HTTPS, which runs HTTP over TLS, with the browser acting as the relying party and validating the server's certificate. We refer to the PKI used to secure web communication as Web-PKI. In Web-PKI,</p>

    <p class="text-gray-300">relying parties (browsers) inherently trust a broad set of root CAs. Each root CA can issue certificates for any domain or CA, effectively acting as a Trusted Third Party (TTP), either directly or indirectly, by certifying another CA and facilitating a certificate chain.</p>

    <p class="text-gray-300">There have been multiple PKI failures [55], [52], [12], [4]. Typically, an attacker obtains a rogue certificate, i.e., a certificate that appears valid to relying parties, contains a public key corresponding to a private key known to the attacker, and includes the identifier (e.g., a domain) of a benign victim entity. The attacker then exploits the rogue certificate to impersonate the victim, typically as a trusted website.</p>

    <p class="text-gray-300">These failures and attacks motivated numerous proposals and efforts to improve the security of PKI schemes, including [53], [21], [46], [34], [61], [5], [69], [59], [60], [45], [24], [63], [35], [42], [41], [23], [43], [32], [18]. Among these, Certificate Transparency (CT) [39], [40], [41] stands out as the only 'post-X.509' PKI scheme that has been deployed and used in practice. The main goal of CT is to make the set of issued certificates publicly visible (transparent), enabling detection of rogue certificates, e.g., allowing a domain owners to discover unauthorized certificates issued for their domain. In principle, this could be achieved by requiring CAs to publish every certificate they issue. However, a rogue CA could simply choose not to publish certain certificates.</p>

    <p class="text-gray-300">CT addresses this by introducing public logs operated by entities known as loggers. In CT, a certificate is considered valid only if it comes with a Signed Certificate Timestamp (SCT), a signed commitment from a logger to include the certificate in its public log. This approach ensures transparency even in the presence of misbehaving CAs. The broader objective of CT was to eliminate reliance on any single trusted party, a principle termed the No Trusted Third Party (NTTP) goal [41]. However, CT, as standardized by the IETF in CTv1 [39] and CTv2 [40], ensures transparency only under the assumption that all certificates are logged by an honest logger [65]. In other words, neither version satisfies the NTTP goal. If a CA can be compromised or act maliciously, so can a logger.</p>

    <p class="text-gray-300">§ The work was partially completed during the author's PhD studies at the Dept. of Computer Science, Bar-Ilan University, Israel.</p>

    <p class="text-gray-300">CT has been adopted by major browsers, including Chrome, Safari, and Brave, all of which require that valid certificates include SCTs. Currently, there are six deployed CT loggers operated by organizations such as Google, Cloudflare, and Let’s Encrypt. In addition, 13 organizations run monitors that help detect maliciously or mistakenly issued certificates. Most CAs now issue CT-compliant certificates.</p>

    <p class="text-gray-300">In practice, browsers do attempt to ensure security against rogue loggers, but in a constrained and inefficient way, requiring each certificate to be logged with multiple loggers, as recommended in CTv2 <em>[40]</em>. Typically, due to overhead, only two loggers are required. While they are chosen from a set approved by browser vendors, the selection is made by the (potentially corrupt) CAs, who decide whether to log certificates with a specific log, limiting the security benefits. Furthermore, although CT logs are append-only and verifiable by CT monitors, malicious loggers can still maintain and present separate logs (i.e., Merkle trees), making CT vulnerable to <em>split-world attacks</em>. Currently, CT does not employ any mechanism to verify that a logger does not equivocate <em>[40]</em>.</p>

    <p class="text-gray-300">Another concern is that, while CT has significantly improved transparency of certificates, CT does not address the critical area of <em>certificate revocation</em>. Standardized revocation mechanisms, such as CRLs and OCSP, have been largely abandoned by browsers due to performance and privacy concerns. Today, browsers rely primarily on proprietary mechanisms, such as Google Chrome’s CRLSets, which typically cover only a small subset of certificates (see §VII).</p>

    <p class="text-gray-300">Changing the status quo is never easy, particularly when it involves the Web-PKI, a large-scale system under the control of various stakeholders. Some might argue that the current state of Web-PKI is “good enough”, while others might quickly point out the significant practical challenges involved in implementing even minor changes. Both criticisms have validity; however, settling for “good enough” is not a viable option when it comes to the security of such a crucial component of our online infrastructure, especially since it is plausible to transition to a secure, yet performance-oriented PKI. Recent regulatory developments, such as the EU’s eIDAS 2 <em>[15]</em>, which requires browsers to trust government-approved CAs and limits their ability to remove unsafe or malicious ones, underscore that the need for a stronger PKI is not merely a theoretical concern, but a practical necessity.</p>

    <p class="text-gray-300">In response, we present CTng, a Web-PKI design and prototype system. CTng improves <em>security</em> by achieving NTTP-secure transparency and revocation, while also supporting <em>efficient certificate validation</em> and ensuring <em>privacy</em> for relying parties. It allows relying parties to prefetch certificate validation data, removing reliance on real-time checks. CTng also improves <em>efficiency</em> and <em>scalability</em>; in particular, clients can validate certificates and their revocation status efficiently as part of their connection to a server, with minimal bandwidth overhead and without needing to communicate with any other entities. Furthermore, CTng is designed to maintain efficiency even when using <em>post-quantum signatures</em>. Finally, the CTng design is <em>evolutionary</em>, preserving most aspects of the existing PKI, including CT.</p>

    <p class="text-gray-300">CTng expands the role of CT monitors, empowering them to monitor the logs and efficiently provide the information required for relying parties to validate certificates. CTng achieves NTTP-security <em>efficiently</em>: a CA needs only to log certificates with a single logger, and a relying party needs only one low-bandwidth interaction with a single monitor to receive the periodic transparency and revocation updates. This approach is efficiently implemented using well-established and widely available <em>threshold signatures</em>, which have open-source implementations, as essential for successful deployment.</p>

    <p class="text-gray-300">CTng benefits are especially evident in the context of revocation, where CTng ensures <em>NTTP-secure guaranteed and unequivocal revocation</em>, allowing monitors to provide timely updates (e.g., daily or even hourly) to relying parties. By prefetching this information, relying parties can validate certificates without depending on additional real-time checks, avoiding the costly over-provisioning required to handle traffic spikes. In contrast, current revocation approaches require CAs or browser vendors to serve requests from arbitrary clients and CT leaves loggers similarly exposed to peak load conditions. To further improve efficiency, CTng incorporates the compact CRV design from <em>[57]</em> to minimize the size of revocation information distributed to clients.</p>

    <p class="text-gray-300">We present an open-source implementation <em>[30]</em> of two versions of CTng: a base version (§IV) and an optimized version with two optional design enhancements that reduce bandwidth (§IV-D1 and §IV-D2), allowing CTng to support more monitors and to be resilient to a larger number of faulty monitors.</p>

    <p class="text-gray-300">A third enhancement to the CTng design, described in §A but not yet implemented, reduces the overhead associated with the transmission, verification, and computation of signatures. This reduction in overhead can be quite significant when using post-quantum signatures. A similar goal - and design - were presented in the <em>Merkle tree certificates</em> proposal <em>[6]</em>, a recently-proposed alternative design for issuing certificates based on the use of a Merkle tree by the issuing CA.</p>

    <p class="text-gray-300">Our evaluations (§VI) confirm the practicality and efficiency of CTng across all entities. On modest hardware, the base version of CTng with just the broadcast optimization (§IV-D1) exceeds current global-scale precertificate throughput and supports 32 monitors while tolerating up to 8 faulty monitors (<span class="math">f=8</span>). With the additional erasure encoding optimization (§IV-D2), performance further improves for higher number of faulty monitors (<span class="math">f</span>) . Increasing the number of monitors has negligible impact on system throughput.</p>

    <p class="text-gray-300">Contributions:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>We present CTng, an evolutionary extension of the current Web-PKI based on PKIX <em>[7]</em> and CT, utilizing well-established cryptographic primitives and approaches.</li>

      <li>CTng efficiently achieves NTTP-secure transparency and revocation. In particular, it prevents <em>logger omission</em></li>

    </ul>

    <p class="text-gray-300">attacks<em>, where a logger fails to include a certificate in the log within the promised timeframe, and provides a defense against </em>split-world attacks<em>, where a logger might present different log views to different clients. Further, CTng ensures guaranteed and unequivocal revocation and consequently prevents the </em>Zombie certificate attack*, where a certificate may appear as non-revoked to some relying parties after its revocation.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CTng offers benefits such as efficient certificate validation and privacy for relying parties. In particular, relying parties do not need to perform real-time signature validations. CTng is efficient even when using high-overhead signature schemes, such as post-quantum signature schemes.</li>

      <li>CTng achieves its security goals. We present a security analysis that demonstrates its NTTP-security guarantees for both transparency and revocation.</li>

      <li>CTng is efficient and scalable. We present a performance evaluation of our open-source implementation, showing its practicality for realistic deployments.</li>

    </ul>

    <h2 id="sec-3" class="text-2xl font-bold">II From CT to CTng</h2>

    <p class="text-gray-300">We now provide an overview of the current Web-PKI, highlighting how CT addresses some of the limitations of the trusted CA model. We then examine the attacks that remain possible despite CT and discuss how they are mitigated by CTng. Table I summarizes these attacks and the corresponding defenses in CT and CTng, while Figure 1 offers a high-level comparison of the two systems.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">II-A Current Web-PKI</h3>

    <p class="text-gray-300">CT was introduced to mitigate the risk of misbehavior by CAs by introducing two new entities: loggers, responsible for ensuring the transparency of certificates, and monitors, responsible for auditing these logs to ensure correctness, detect problematic certificates and help identify rogue or negligent CAs. Adding these entities has changed the way certificates are issued and used.</p>

    <p class="text-gray-300">To establish a secure communication channel between a relying party (i.e., a browser) and a subject (i.e., a server) <span class="math">s</span>, the subject provides a PKIX certificate to the relying party, which certifies the public key <span class="math">pk_{s}</span> of <span class="math">s</span>. To obtain the certificate, the subject contacts a CA, which first verifies that the subject controls <span class="math">s</span>, and then generates a <em>precertificate</em>, essentially a PKIX-compliant certificate that includes a dedicated ‘poison’ extension, which prevents it from being treated as a valid certificate by relying parties, as specified by CTv2 <em>[40]</em>.</p>

    <p class="text-gray-300">The CA then submits the precertificate to multiple loggers. Each logger verifies that the precertificate is PKIX-compliant and has not been previously logged. If so, it issues a Signed Certificate Timestamp (SCT), a promise to include the precertificate in its log, implemented using a Merkle tree to ensure auditability, within the <em>Maximum Merge Delay (MMD)</em>.</p>

    <p class="text-gray-300">The CA aggregates the SCTs and, using the X.509v3 extensions mechanism <em>[29]</em>, embeds them into the final certificate, which is then sent back to the subject. Relying parties accept a certificate only if it includes a sufficient number of valid SCTs issued by loggers they trust. The certificate issuance process is illustrated in Figure 1(a), steps I.1–I.4.</p>

    <p class="text-gray-300">Periodically, monitors retrieve the newly logged certificates and the current <em>Signed Tree Head</em> (STH) from loggers and ensure that: (1) the log is append-only, i.e., all past certificates are still in the log; and (2) the log is transparent, i.e., all newly logged certificates <em>that were reported</em> by the logger were added to the log, and <em>only</em> them. Monitors also analyze the newly added certificates to detect any possible mis-issuance, impersonation, or phishing attempts, and may notify affected subjects. The monitoring process is depicted in steps P.1–P.2.</p>

    <p class="text-gray-300">To revoke a certificate, the subject requests revocation from the issuing CA. Once revoked, the CA can publish the revocation status via Certificate Revocation Lists (CRLs) or provide it via the Online Certificate Status Protocol (OCSP). Browser vendors periodically retrieve CRLs from trusted CAs and propagate (select) revocation information to browsers. This allows relying parties to reject revoked certificates, provided the relevant revocation data has been supplied to them. CT does not play a role in the revocation process. The revocation process is illustrated in Figure 1(a), step R.1, and the vendor-assisted propagation of revocation is shown in steps U.1–U.3.</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">II-B Remaining Web-PKI Attacks and CTng Defenses</h3>

    <p class="text-gray-300">We now discuss several attacks that adversaries can carry out in the current Web-PKI, focusing on threats posed by different entities within the ecosystem, and compare how these attacks are addressed by deployed and proposed defense mechanisms in CT with the defenses of CTng (Table I).</p>

    <p class="text-gray-300"><em>Misbehaving Subjects (Websites)</em>: A rogue website can launch a <em>stealthy corrupt certificate</em> attack by obtaining a valid but fraudulent certificate, either by deceiving a benign CA or colluding with a malicious CA. Without CT, this attack could remain undetected indefinitely. With CT, the attack window is limited, as the certificate must be publicly logged within the MMD period and then can be reported by monitors. However, the effectiveness of CT relies on active monitoring and timely response by domain owners. CTng strengthens this defense via its <em>efficient validation</em> process (§IV-E), which enables monitors to distribute <em>verified</em> information to relying parties ahead of time. This removes the need for real-time checks and allows relying parties to independently validate certificates.</p>

    <p class="text-gray-300"><em>Misbehaving CAs</em>: Although CT provides transparency for certificate issuance, it does not extend it to certificate revocation. This enables two distinct split-world attacks. In a <em>stealthy revocation DoS</em> attack, a malicious CA can falsely but selectively indicate that a valid, non-revoked certificate has <em>been revoked</em>, causing denial-of-service for the targeted website since the certificate would be rejected. In a <em>Zombie certificate</em> attack, a malicious CA can falsely indicate that a revoked certificate has <em>not been revoked</em>, enabling attackers who control the corresponding private key (e.g., from a past</p>

    <p class="text-gray-300">compromise) to impersonate legitimate domains. CT offers no built-in defense against either of these attacks, and existing revocation mechanisms (CRLs, OCSP) are insufficient due to CA control over the information these mechanisms rely on, and the lack of transparency in how proprietary versions of CRLs are implemented across different browsers. CTng mitigates both attacks through its Periodic Consistent Broadcast protocol (§IV-D), which ensures that revocation information is distributed transparently and consistently to relying parties.</p>

    <p class="text-gray-300">Misbehaving Loggers: Loggers in CT are assumed to act honestly, but this assumption can be violated in two main ways. In a logger omission attack, the logger can issue an SCT but never include the corresponding certificate into the log within the MMD. This prevents the monitors from discovering the certificate. CT attempts to address this through SCT auditing mechanisms <em>[58, 31]</em>, which are optional and raise privacy concerns - although Google Chrome audits a small proportion of SCTs using k-anonymous queries <em>[20]</em>. In contrast, CTng’s efficient validation allows clients to detect missing certificates without relying on SCT audits or any other real-time queries and without sacrificing privacy. In a logger split-world attack, a rogue logger can present inconsistent Merkle tree views of its log to different clients (or at different times), enabling selective suppression of certificates. Although gossip protocols <em>[51, 48]</em> have been proposed for CT, they have not been standardized or deployed. CTng directly addresses this through its Periodic Consistent Broadcast, ensuring all monitors receive and verify consistent views of all logs.</p>

    <p class="text-gray-300">Misbehaving Monitors: In CT as deployed, monitors operate independently, checking logs for suspicious certificates but playing no active role in verifying logger behavior, particularly for split-world attacks. A misbehaving monitor may fail to report suspicious certificates or collude with attackers to ignore them, an issue that CT does not address. In contrast, CTng assigns monitors an active, collaborative role: they collectively ensure log integrity and distribute verified certificate information to relying parties. CTng assumes that some monitors may be arbitrarily malicious and adopts a quorum-based model (§III-A) that tolerates up to <span class="math">f</span> faulty monitors. A relying party needs to contact only one monitor to obtain information; a misbehaving monitor cannot provide incorrect information, it can at most fail to respond. In that case, the relying party can try another monitor (see §IV-E) and is guaranteed to succeed after at most <span class="math">f</span> attempts.</p>

    <h2 id="sec-6" class="text-2xl font-bold">III CTng: Model and Goals</h2>

    <p class="text-gray-300">We now describe the CTng system and adversary models, and present CTng’s security, privacy, and system goals.</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">III-A System and Adversary Models</h3>

    <p class="text-gray-300">In CTng, we assume the same five types of entities as in CT: CAs, loggers, monitors, subjects (websites), and relying parties (browsers). Each relying party has a set of root (anchor) CAs and a set of trusted loggers, along with their known public keys (or certificates). In practice, browser vendors define these trusted entities.</p>

    <p class="text-gray-300">We assume a computationally-bounded adversary that controls any number of subjects, CAs, loggers, and relying parties, but only up to <span class="math">f</span> monitors. The adversary gains full control of these entities, including their private keys. This attack model allows the adversary to perform any of the attacks listed in Table I. We assume a majority of benign monitors; that is, there must be at least <span class="math">2f+1</span> monitors and their connections should be <span class="math">(f+1)</span>-connected; in particular, each benign monitor should be connected to at least one other benign monitor.</p>

    <p class="text-gray-300">CTng’s monitors use threshold signatures; for simplicity, we assume that the distributed generation of the threshold key is completed before CTng begins running and that the relying parties know the corresponding threshold verification key.</p>

    <p class="text-gray-300">We assume loosely-synchronized clocks where the drift between any two clocks is bounded by <span class="math">\\Delta_{clk}</span> at any time. We also assume that communication between pairs of benign entities is bounded by <span class="math">\\Delta_{com}</span>. Together, these assumptions ensure that a benign relying party can reliably contact at least one benign monitor within the expected time bounds. For simplicity, we assume that each logger and CA is monitored by all monitors.</p>

    <h3 id="sec-8" class="text-xl font-semibold mt-8">III-B Security and Privacy Goals</h3>

    <p class="text-gray-300">In <em>[65]</em>, Wrótniak et al. formally defined four PKI security requirements, and analyzed whether these requirements are satisfied by PKIX and CT under specific assumptions. We set these four requirements as security goals for CTng, and include intuitive definitions of these requirements below. For the formal definitions, see <em>[65]</em>.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G1: Existential unforgeability, i.e., every valid certificate <span class="math">\\psi</span> was either issued by the entity designated as the issuer of the certificate (<span class="math">\\psi.issuer</span>), or was issued by a (rogue) entity that managed to obtain a valid (but fraudulent) certificate <span class="math">\\hat{\\psi}</span> to a key it controls where <span class="math">\\hat{\\psi}.subject=\\psi.issuer</span>.</li>

      <li>G2: Accountability, i.e., every valid certificate has a root CA that is accountable for it (identified unequivocally as responsible for that certificate).</li>

      <li>G3: Guaranteed transparency, i.e., every certificate <span class="math">\\psi</span> that was logged at a logger <span class="math">\\ell</span> at time <span class="math">t</span>, every benign monitor that monitors <span class="math">\\ell</span> (prior to <span class="math">t</span>) is aware of <span class="math">\\psi</span> no later than <span class="math">t+\\Delta</span>, where <span class="math">\\Delta</span> reflects the maximum delay allowed.</li>

      <li>G4: Guaranteed revocation, i.e., every certificate <span class="math">\\psi</span> that was revoked at time <span class="math">t</span> by its benign issuer, will not be considered valid at any time after <span class="math">t+\\Delta</span>, where <span class="math">\\Delta</span> reflects the maximum delay allowed for the revocation to be known.</li>

    </ul>

    <p class="text-gray-300">That said, CTng not only aims to satisfy goals G1-G4, it also aims to do so under strict model assumptions. For example, as shown in Table II, both CTv1 and CTv2 satisfy the guaranteed transparency goal, but only under a weaker model assumption that loggers are benign (addressed through logger redundancy). In contrast, CTng assumes a stronger adversary model in which the adversary can control any number of loggers and up to <span class="math">f</span> monitors.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attack model</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Attack (§II-B)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CT defense</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Current defenses</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Subject, CA</td>

            <td class="px-3 py-2 border-b border-gray-700">Stealthy corrupt certificate</td>

            <td class="px-3 py-2 border-b border-gray-700">SCT validation</td>

            <td class="px-3 py-2 border-b border-gray-700">Efficient certificate validation (§IV-E)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Stealthy revocation DoS</td>

            <td class="px-3 py-2 border-b border-gray-700">Short-lived certificates</td>

            <td class="px-3 py-2 border-b border-gray-700">Periodic Consistent Broadcast (§IV-D)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|   |  Zombie certificate  |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Subject, logger(s)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Logger omission</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">SCT auditing [58], [31] (privacy concerns)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Efficient certificate validation (§IV-E)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">Logger split-world or Log-ger omission</td>

            <td class="px-3 py-2 border-b border-gray-700">SCTs from multiple loggers (overhead: log and cert size, validation)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Subject, monitor(s)</td>

            <td class="px-3 py-2 border-b border-gray-700">Monitor omission</td>

            <td class="px-3 py-2 border-b border-gray-700">Use multiple monitors (overhead)</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE I: Comparison of CT and CTng defenses against different attacker models and relevant attacks, including: stealthy corrupt certificate (attacker uses a fake identity to deceive victims), stealthy revocation DoS (non-revoked certificate 'appears' revoked to victims), Zombie certificate (revoked certificate 'appears' non-revoked to victims), logger omission (a certificate with an SCT is expected to be in the log, but is not added), logger split-world (the logger presents different views of the log to different log clients), and monitor omission (monitor does not report a certificate to client). Detailed discussion in §II-B.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X.509 w/CRL</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">X.509 w/OCSP</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CTv1, CTv2 [37],[38]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CT-VendorRev e.g., Chrome, Safari</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CT-VendorRev-wAudit Chrome w/Audit[30]</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CTng</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Security & Privacy Goals  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G1: Existential unforgeability</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G3: Guaranteed transparency</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗1</td>

            <td class="px-3 py-2 border-b border-gray-700">✗1</td>

            <td class="px-3 py-2 border-b border-gray-700">✗1</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G4: Guaranteed revocation</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G5: Unequivocal revocation</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">G6: Relying-party privacy</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✗</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

            <td class="px-3 py-2 border-b border-gray-700">✗2</td>

            <td class="px-3 py-2 border-b border-gray-700">✓</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">|  Systems Goals  |   |   |   |   |   |   |</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">G7: Evolutionary design</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">✓</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE II: Comparison of relevant (evolutionary) PKI schemes with respect to goals described and discussed in §III. See §VII for other schemes. Additional comments:  <span class="math">{}^{1}</span>  Both CTv1 and CTv2 assume loggers are benign; however,CTv1 wrongfully states that loggers are not assumed to be trusted; this statement was remediated in CTv2, which explicitly states the benign loggers assumption, but suggests logger redundancy. For more information, see [65].  <span class="math">{}^{2}</span>  SCTs by default,are audited using k-anonymous lookup. Privacy exposure only if SCT not known to Google (but should be),or if using Enhanced safe browsing.</p>

    <p class="text-gray-300">Because CTng targets a stronger adversary model, we identified an additional important property not defined in [65], and we define this property as an explicit goal for CTng:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G5: Unequivocal revocation, i.e., an attacker cannot cause some relying parties to consider the certificate as valid, while other relying parties consider the certificate revoked.</li>

    </ul>

    <p class="text-gray-300">To understand why unequivocal revocation (G5) is necessary in addition to guaranteed revocation (G4), it is important to clarify that G4 assumes that the issuing CA is benign. However, as discussed in §II-B, a misbehaving CA can launch attacks such as the stealthy revocation DoS attack, selectively making a non-revoked certificate appear revoked. Since CTng assumes a stronger adversary model in which the adversary may control any number of CAs, it is important to also define the unequivocal revocation goal (G5), which ensures that even misbehaving CAs cannot carry out such attacks.</p>

    <p class="text-gray-300">An additional concern in PKI design is the risk of compromising the privacy of relying parties. For example, both CTv1 and CTv2 describe an auditing process in which relying parties can query loggers for an STH and proofs of inclusion (PoI) for previously received certificates, in order to verify that the SCT promises made by loggers have been fulfilled. However, this process can reveal the browsing history of relying parties, since it exposes the certificates of the websites they visit. As a result, some relying parties avoid auditing altogether (e.g., Safari), while others (e.g., Chrome) support auditing select SCTs using k-anonymous lookup queries. Unfortunately, auditing all SCTs for all relying parties through this mechanism is not feasible from performance point of view. A similar concern exists with the OCSP revocation mechanism [54], which also requires relying parties to send a request that exposes the certificate they are validating. Thus, we set the following privacy goal:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G6: Relying party privacy, i.e., certificates validated by</li>

    </ul>

    <p class="text-gray-300">the relying parties are never disclosed to any third party.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">III-C Systems Goals</h3>

    <p class="text-gray-300">One of the key factors that contributed to the widespread adoption of CT was the fact that CT was carefully designed to limit changes within the Web-PKI ecosystem. In general, proposals are more likely to be adopted if they extend existing mechanisms rather than replace them, especially when those mechanisms are already deployed. Moreover, augmenting an existing system allows for targeted improvements while preserving components that function well. For example, the classical PKI mechanisms based on X.509 and PKIX are highly efficient: certificates are compact, certification requires only a single signature operation, and basic certificate validation involves just a few signature verifications with no additional communication. Therefore, we set the following goal:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G7: <em>Evolutionary design</em>, i.e., do not introduce new entities and instead propose reasonable modifications to the processes of existing entities that support deployment and facilitate transition from the current system.</li>

    </ul>

    <p class="text-gray-300">That said, some of the currently deployed mechanisms, e.g., revocation, transparency etc., can be improved. Such improvements can help mitigate many challenges; for example, the challenges of scalability and flash crowds, where entities must provide services to an unpredictable yet large number of relying parties. This could affect the certificate validation process, which normally requires real-time operations against such entities. Thus, we set the following goal:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>G8: <em>Efficient certificate validation</em>, i.e., each certificate can be validated by relying parties using locally available data, without requiring any (real-time) requests to other entities.</li>

    </ul>

    <h2 id="sec-10" class="text-2xl font-bold">IV CTng Design</h2>

    <p class="text-gray-300">In this section, we first provide a high-level overview of how CTng addresses the shortcomings of Web-PKI and the changes it requires. We then detail the design of CTng, focusing on its core functions: certificate issuance (§IV-B), certificate revocation (§IV-C), monitoring and broadcasting (§IV-D), and certificate validation (§IV-E). A designed extension optimized for efficient support of post-quantum signatures is discussed in (§A).</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">IV-A High Level Overview</h3>

    <p class="text-gray-300">CTng introduces changes to the current Web-PKI design that apply to all existing entities: CAs, loggers, monitors, and relying parties. That said, aside from the changes introduced for monitors, all other modifications are relatively simple to implement. Most importantly, they can be deployed alongside the existing infrastructure, allowing for a manageable transition to CTng. In fact, some of the changes are not mandatory for the deployment of CTng, and CTng can be initially deployed without them. However, these changes can significantly improve the efficiency of the system and, therefore, we believe that they should be considered for deployment, possibly gradually.</p>

    <p class="text-gray-300">The decision to introduce more substantial changes to the monitors is deliberate. Among all entities, monitors are the easiest to modify, given their current deployment status, without disrupting the operation of the existing Web-PKI.</p>

    <p class="text-gray-300">We now describe CTng’s design by explaining the changes to each type of entity. The design is illustrated in Figure 1(b), where the changes with respect to the current Web-PKI are highlighted in red.</p>

    <p class="text-gray-300"><em>Certificate Authorities (CAs).</em> The process of issuing a new certificate (I.1–I.4) in CTng remains unchanged from the process in CT <em>[39, 40]</em>, except for one difference. Specifically, in CT, the CA receives from the logger, and includes in an extension in the certificate, a <em>Signed Certificate Timestamp (SCT)</em>, which is an attestation by the logger that the new certificate will be included in the log. In CTng, the SCTs are replaced by the CTng extension, which contains four values. Three of these values are used by relying parties to confirm that the certificate is indeed logged in log <span class="math">\\ell</span> (see §IV-E): a log identifier <span class="math">\\ell</span>, a period number <span class="math">p</span>, and a Proof of Inclusion (PoI).</p>

    <p class="text-gray-300">The fourth value in the CTng extension is called the Revocation Number (RN). The RN is used to implement CTng’s improved revocation mechanism. The CTng design is based on the efficient design of <em>[57]</em>, in which each CA maintains a bit vector, called the <em>Certificate Revocation Vector (CRV)</em>, where each bit represents the revocation status of a single certificate issued by that CA; the RN of a certificate is the index of the bit in the CRV corresponding to that certificate. In the original CRV design <em>[57]</em>, the RN is added by the CA; and, like in other currently-deployed revocation mechanisms, correct provision of the revocation information depends on a single entity (the CA for CRV and ‘classical’ revocation mechanisms such as CRLs and OCSP, and the vendor for the widely-used OneCRL and CRLSet).</p>

    <p class="text-gray-300">The revocation process (R.1, R.2 and P.2) in CTng differs: there is no single party which is responsible for distributing revocation information. Instead, in CTng, the revocation information, produced and signed by the CA, is also monitored, authenticated, and distributed by the CTng monitors. This avoids delays and failures associated with revocation queries against the CA, a major problem for CRLs and OCSP, and prevents revocation equivocation by a faulty CA/vendor; see §IV-D.</p>

    <p class="text-gray-300"><em>Loggers.</em> Apart from their changed interaction with the CAs (SCTs are no longer issued), another key difference between CT and CTng is that loggers no longer maintain a single large Merkle tree for certificates. Instead, loggers create multiple smaller Merkle trees, each corresponding to certificates issued within a specific period. This approach keeps each tree relatively small, reducing the overhead of PoI verification, which is important since the PoI is part of the CTng extension and must be verified whenever a certificate is validated. Note that in CTng, we could have easily integrated the logging functions with the monitoring functions; the reasons to maintain separate loggers is mostly for backwards compatibility. Loggers also reduce the load on the monitor, allowing each monitor to receive the certificate from a small set of loggers rather than</p>

    <p class="text-gray-300">!<a href="img-0.jpeg">img-0.jpeg</a> (a) Current Web-PKI: X.509 with CT and vendor-assisted revocation information</p>

    <p class="text-gray-300">!<a href="img-1.jpeg">img-1.jpeg</a> (b) CTng Fig. 1: High-level comparison of CT and CTng. I - Issuance, R - Revocation, P - Periodic Consistent Broadcast (Monitoring and Broadcasting), U - Update. In the CTng design, illustrated in Figure 1b, we marked in red the changes from the CT design. This graph only presents one possible deployment scenario where the relying party fetches all updates directly from the monitors.</p>

    <p class="text-gray-300">from many CAs; further savings in communication can be obtained using the erasure encoding optimization, see §IV-D2.</p>

    <p class="text-gray-300">Monitors. In CTng, monitors no longer merely passively monitor logs (P.1 and P.2); instead, they actively participate in overseeing the behavior of loggers by broadcasting the certificates and STHs they receive from loggers to other monitors using the Periodic Consistent Broadcast (PCB) protocol (P.5 and P.6), introduced in §IV-D. The PCB protocol ensures that all monitors maintain a consistent view of the logs, which enables them to provide verified periodic updates to the relying parties. PCB also allows benign monitors to generate a Proof of Misbehavior (PoM) against any logger that either fails to provide updates in a timely manner or sends conflicting information (i.e., equivocates), and to ensure correct operation in spite of possible faulty monitors. In addition to retrieving the certificates and transparency information (STHs) from the logs, monitors also retrieve revocation information directly from the CAs (P.2), allowing the monitors to efficiently and securely provide relying parties with up to date revocation information.</p>

    <p class="text-gray-300">Relying parties. In CTng, a relying party periodically retrieves the transparency and revocation updates that were threshold-signed by the monitors (U.1 and U.2). These can be obtained directly from the monitors and can also be cached and served by ISPs or vendors, as they are third-party verifiable. The updates, alongside a CTng-compliant certificate that the client receives during a TLS handshake, allow the client to immediately validate the certificate, in particular, validate</p>

    <p class="text-gray-300">that the certificate was logged and was not revoked, without requiring any real-time interactions with the CA, the logger, or the monitors (see §IV-E).</p>

    <p class="text-gray-300">We now provide more details on each of the CTng mechanisms.</p>

    <p class="text-gray-300">For an issuing CA  <span class="math">I</span>  to generate a certificate for a subject,  <span class="math">I</span>  first generates and sends a precertificate with a Revocation Number (RN) to a logger  <span class="math">\\ell^4</span> . The RN is a unique sequential identifier that maps a certificate to a revocation status bit in the CRV maintained by  <span class="math">I</span> .</p>

    <p class="text-gray-300">Let  <span class="math">t_\\ell</span>  denote the time on  <span class="math">\\ell</span> 's clock when  <span class="math">\\ell</span>  receives the precertificate. The logger ensures that the precertificate is valid and not already in the log, then adds it to a list of pending precertificates to be logged. Periodically, when the time on  <span class="math">\\ell</span> 's clock is  <span class="math">t_\\ell^{STH}(p) \\equiv p \\cdot MMD + 2 \\cdot \\Delta_{clk}</span> , logger  <span class="math">\\ell</span>  computes the head (digest) of the Merkle tree whose leaves are the pending precertificates [40], each augmented with the RN. Since the clock bias is at most  <span class="math">\\Delta_{clk}</span> , this occurs before real time  <span class="math">p \\cdot MMD + 3 \\cdot \\Delta_{clk}</span> . By substituting  <span class="math">p</span>  in the expression with the bound  <span class="math">p \\leq 1 + \\frac{\\tau_I - \\Delta_{clk} + \\Delta_{com}}{MMD}</span>  (see Claim 1), we have that a</p>

    <p class="text-gray-300">4In CTng, it normally suffices for the CA to use a single logger; the CA can quickly detect if the logger fails to add the precertificate to its publicly available log and, in this rare event, switch to a different logger. 5Certificate serial numbers, while also unique, are generated randomly and therefore cannot serve as efficient indices for revocation lookups. 6We add  <span class="math">2\\cdot \\Delta_{clk}</span>  because that ensures that the time the monitor will receive the STH - as measured on the monitor's clock - will be at least  <span class="math">p\\cdot MMD</span></p>

    <p class="text-gray-300">precertificate which the CA sent to the logger at time <span class="math">\\tau_{I}</span> will be included by the logger in the <span class="math">head</span> by <span class="math">\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+\\Delta_{com}</span> (see Figure 3a and Claim 1).</p>

    <p class="text-gray-300">At this time, the logger <span class="math">\\ell</span> computes the Signed Tree Head (STH), denoted, for perid <span class="math">p</span>, as <span class="math">STH_{\\ell}^{p}</span>, as follows:</p>

    <p class="text-gray-300"><span class="math">STH_{\\ell}^{p}=(p,\\ell,head,size,\\sigma)</span> (1)</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">size</span> is the number of precertificates and <span class="math">\\sigma</span> is <span class="math">\\ell</span>’s signature over the encoding of the other fields: $p\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ \\ell\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ head\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ size<span class="math">. The logger </span>\\ell<span class="math"> then sends </span>STH_{\\ell}^{p}<span class="math"> to </span>I<span class="math">; it also sends to </span>I<span class="math"> a PoI for each of the precertificates sent by </span>I<span class="math">, as a proof of logging, to be included in the final certificate. This allows CAs to generate a CTng-compliant certificate, i.e., a certificate which includes the PoI of the certificates after validating the PoI against </span>STH_{\\ell}^{p}<span class="math"> . Logger </span>\\ell<span class="math"> will also send </span>STH_{\\ell}^{p}<span class="math"> and all the precertificates included in </span>STH_{\\ell}^{p}$ to the monitors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Periodically, the CA receives the <span class="math">STH_{\\ell,M}^{p}</span> (and PoM if any) from the monitors, the CA then checks if the logger it uses is in the PoM list or if <span class="math">STH_{\\ell,M}^{p}</span> does not match the <span class="math">STH_{\\ell}^{p}</span> it has received previously from the logger. In either case, the CA should immediately relog its issued certificates and in the mismatch case, it should send the <span class="math">STH_{\\ell}^{p}</span> to at least <span class="math">f+1</span> monitors to report logger equivocation. This prevents rogue loggers from delaying the issuing process indefinitely.</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">III-C Revoking Certificates</h3>

    <p class="text-gray-300">The CTng revocation process is initiated by the issuing CA <span class="math">I</span>, usually upon request to revoke the certificate by its subject (the domain owner), and is based on the CRV design of <em>[57]</em>. The CA marks the revocation of certificate <span class="math">\\psi</span> by setting <span class="math">CRV_{I}^{p}[\\psi.CTng.RN]</span> to 1 (revoked), where <span class="math">\\psi.CTng.RN</span> is the revocation number identifier of <span class="math">\\psi</span>, included in the CTng extension of <span class="math">\\psi</span>. The CRV is the Certificate Revocation Vector, a vector with one bit per each certificate issued by <span class="math">I</span>; its bits are initially 0 (not revoked).</p>

    <p class="text-gray-300">Similarly to how the logger informs the monitors periodically, the CA also informs the monitors about revocations periodically; that is, the CA sends these updates whenever its clock shows <span class="math">p\\cdot MMD+2\\cdot\\Delta_{clk}</span> for an integer <span class="math">p&amp;gt;0</span>. Let <span class="math">CRV_{I}^{p}</span> denote the value of the CRV of issuer <span class="math">I</span> when its clock shows <span class="math">p\\cdot MMD+2\\cdot\\Delta_{clk}</span>; <span class="math">I</span> first computes its <span class="math">\\Delta</span>CRV for period <span class="math">p</span>, denoted <span class="math">\\Delta CRV_{I}^{p}</span>, as:</p>

    <p class="text-gray-300"><span class="math">\\Delta CRV_{I}^{p}=CRV_{I}^{p}\\oplus CRV_{I}^{p-1}</span> (2)</p>

    <p class="text-gray-300">Then, <span class="math">I</span> generates a Signed Revocation Hash (SRH), which contains <span class="math">I</span>’s signature over the revocation status of the certificates issued by <span class="math">I</span>. Let <span class="math">h</span> denote a Collision Resistant Hash Function (CRHF)<em>[7]</em>; the SRH of CA <span class="math">I</span> for MMD period <span class="math">p</span>, denoted as <span class="math">SRH_{I}^{p}</span>, is defined as:</p>

    <p class="text-gray-300"><span class="math">SRH_{I}^{p}=(p,I,h(CRV_{I}^{p}),h(\\Delta CRV_{I}^{p}),\\sigma)</span> (3)</p>

    <p class="text-gray-300"><em>[7]</em>For simplicity, we show the design using a keyless CRHF, as done by the CT specifications, including in its Merkle tree. Of course, this is secure only under the random oracle model. It is easy to adjust the design for security in the real model, by using a keyed CRHF (also referred to as Any Collision Resistant (ACR) hash function).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">where <span class="math">h(CRV_{I}^{p})</span> and <span class="math">h(\\Delta CRV_{I}^{p})</span> are the CRHF outputs on <span class="math">CRV_{I}^{p}</span> and <span class="math">\\Delta CRV_{I}^{p}</span> respectively, and <span class="math">\\sigma</span> is <span class="math">I</span>’s signature over: $p\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ I\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ h(CRV_{I}^{p})\\</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"></th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\ h(\\Delta CRV_{I}^{p})<span class="math">. Finally, </span>I<span class="math"> will send both the </span>SRH_{I}^{p}<span class="math"> and the </span>\\Delta CRV_{I}^{p}<span class="math"> to all the monitors, or at least to </span>2\\cdot f+1$ monitors.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">!<a href="img-2.jpeg">img-2.jpeg</a> Figure 2: State diagram of a monitor running the PCB protocol to process transparency updates from a logger. Green represents the processing of timely and valid STH, which must come with the corresponding set of certificates. Orange represents misbehavior accusations. Red represents the response when misbehavior is proven. Dashed transition represents one that may not occur within the same period. Revocation updates from CAs are handled basically in the same way, simply referring to CRVs and corresponding SRHs instead of to STHs.</p>

    <h3 id="sec-14" class="text-xl font-semibold mt-8">III-D Monitoring and Periodic Consistent Broadcast (PCB)</h3>

    <p class="text-gray-300">Each monitor <span class="math">m</span>, wakes up periodically<em>[8]</em>, whenever its clock value is <span class="math">t_{m}^{Init}(p)\\equiv p\\cdot MMD</span> for integer <span class="math">p\\geq 0</span>. At this time, the monitor begins to process the STHs and precertificates sent to it during this period by the loggers, as well as the SRHs and <span class="math">\\Delta CRV</span>s sent to it by the CAs. We refer to this process as the Periodic Consistent Broadcast (PCB) protocol.</p>

    <p class="text-gray-300"><em>[8]</em>We could instead use different periods for different pairs of monitor and logger/CA to reduce peak load. The modifications are simple but result in some ‘writing clutter’ (and a bit additional delay), so we simplify by using the same periods for all.</p>

    <p class="text-gray-300">The goals of the PCB protocol are: (1) to validate receipt of a valid <span class="math">STH^{p}_{\\ell}</span> and corresponding precertificates from each logger <span class="math">\\ell</span>, and to produce a threshold-signed version of the <span class="math">STH^{p}_{\\ell}</span> , denoted as <span class="math">STH^{p}_{\\ell,M}</span>, which is identical in every field except that its signature field <span class="math">STH^{p}_{\\ell,M}</span>.<span class="math">\\sigma</span> contains a joint signature by at least <span class="math">f+1</span> monitors, allowing validation by relying parties; (2) similarly, to validate receipt of a valid <span class="math">SRH^{p}_{\\ell}</span> and the corresponding <span class="math">\\Delta CRV^{p}_{\\ell}</span> from each CA <span class="math">I</span>, and to generate <span class="math">SRH^{p}_{\\ell,M}</span>, signed jointly by <span class="math">f+1</span> monitors; and (3) to identify any loggers or CAs that send invalid or no periodic updates, and to generate a corresponding Proof of Misbehavior (PoM).</p>

    <p class="text-gray-300">The operation of the PCB protocol in each monitor is defined by a distinct state machine for every origin (logger or CA); see Figure 2. Since the PCB protocol handles both transparency and revocation information similarly, we focus on the process for handling the STHs and precertificates from a single logger, denoted <span class="math">\\ell</span>, during a single MMD period <span class="math">p</span>. The processing of the SRHs and CRVs is similar.</p>

    <p class="text-gray-300">The monitor wakes up for period <span class="math">p</span>, and enters the Init state, when its local clock value is <span class="math">p\\cdot MMD</span>. Since the clock drift is at most <span class="math">\\Delta_{clk}</span>, monitor <span class="math">m</span> wakes up during the real-time interval <span class="math">[p\\cdot MMD-\\Delta_{clk},p\\cdot MMD+\\Delta_{clk}]</span>, which is before the logger would send the STH and precertificates of period <span class="math">p</span> (which is after <span class="math">p\\cdot MMD+\\Delta_{clk}</span>). A benign logger would send the (same) valid STH and the set of corresponding precertificates to all monitors. This ensures that the monitor will already be waiting for the STH and precertificates when they arrive (from a benign logger).</p>

    <p class="text-gray-300">Upon receiving the (first) valid STH, either from the logger or from another monitor, <span class="math">m</span> sends that STH to the other monitors and transitions from the Init state to the Precommit state. By forwarding the STH, <span class="math">m</span> helps mitigate potential attacks in which it receives the STH, but some other benign monitor does not.</p>

    <p class="text-gray-300">The Init state also handles the case where the benign monitors, and in particular benign monitor <span class="math">m</span>, do not receive the STH in a timely manner. When the PCB state machine starts, a dedicated timer for <span class="math">t_{u}</span> seconds is begun, where:</p>

    <p class="text-gray-300"><span class="math">t_{u}\\equiv\\Delta_{com}+4\\cdot\\Delta_{clk}</span> (4)</p>

    <p class="text-gray-300">If the <span class="math">t_{u}</span> timer times out, i.e., when <span class="math">m</span>’s clock reaches <span class="math">p\\cdot MMD+t_{u}</span>, then <span class="math">m</span> signs a partial accusation Proof of Misbehavior (aPoM) against logger <span class="math">\\ell</span> and sends it to the other monitors as part of event <span class="math">a_{1}</span>. If there are <span class="math">f+1</span> or more benign monitors that generate such partial aPoM against <span class="math">\\ell</span>, i.e., that did not receive the STH from <span class="math">\\ell</span> before <span class="math">t_{u}</span> expired, then each benign monitor will receive at least <span class="math">f+1</span> partial aPoMs against <span class="math">\\ell</span>. Each time a new partial aPoM against <span class="math">\\ell</span> is received, event <span class="math">a_{3}</span> increments a counter. When the counter reaches <span class="math">f+1</span>, event <span class="math">a_{4}</span> is invoked, namely, monitor <span class="math">m</span> computes an aPoM, denoted <span class="math">aPoM_{M}</span>, jointly signed by at least <span class="math">f+1</span> monitors, all stating that logger <span class="math">\\ell</span> is faulty. Then, <span class="math">m</span> transitions to the PoM state, as there is no need to continue processing updates from a logger (<span class="math">\\ell</span>) who was proven to be faulty.</p>

    <p class="text-gray-300">A rogue logger can also send different (conflicting) STHs to different monitors. This case is handled by the Precommit state. Let <span class="math">t^{Pre}_{m}</span> denote the time on <span class="math">m</span>’s clock when it enters the Precommit state. The Precommit state has two main goals: to collect the set of precertificates corresponding to the STH and to detect an attack in which a rogue logger sends two conflicting STHs. A conflicting STH pair constitutes a collision Proof of Misbehavior (cPoM); if such a collision occurs, <span class="math">m</span> immediately transitions to the PoM (error) state (as part of event <span class="math">c_{1}</span>).</p>

    <p class="text-gray-300">To make sure that <span class="math">m</span> will not sign one STH while another benign monitor signs a different STH, <span class="math">m</span> transitions from the Precommit state to the next valid state, Postcommit, only after receiving the set of precertificates corresponding to the STH (see §IV-D1) and after its clock shows <span class="math">t^{Pre}_{m}+t_{v}</span>. The value of <span class="math">t_{v}</span> depends on the connectivity among the monitors; if all monitors are directly connected, use <span class="math">t_{v}=2\\cdot\\Delta_{com}</span>, and in general, use <span class="math">t_{v}=2\\cdot\\Delta_{com}\\cdot d_{M}</span>, where <span class="math">d_{M}</span> is the diameter of the <span class="math">(f+1)</span>-connected monitor network. This ensures that when <span class="math">m</span> transitions to Postcommit, all other monitors have received the same STH, preventing the case that two benign monitors move to Postcommit with different STHs. The PCB protocol allows some benign monitors to move to Postcommit and others to terminate with a PoM, as long as all benign monitors that reach Postcommit agree on the same STH. This behavior does not introduce a vulnerability in CTng; the rogue logger would be known to all benign monitors before the next period, and therefore also to all relying parties.</p>

    <p class="text-gray-300">A rogue logger could also fail to send the set of precertificates corresponding to the STH. Monitor <span class="math">m</span> detects this if it does not receive all precertificates by <span class="math">t^{Pre}_{m}+t_{c}</span>, where the timer <span class="math">t_{c}</span> is set to <span class="math">t_{c}=\\Delta_{com}</span>. Benign loggers send the precertificates together with the STH, so they should arrive no more than <span class="math">\\Delta_{com}</span> after the STH. Upon such detection, <span class="math">m</span> signs and sends a partial aPoM to the other monitors, since it has determined that <span class="math">\\ell</span> is rogue (event <span class="math">a_{3}</span>). Monitor <span class="math">m</span> transitions to the PoM (error) state if it collects <span class="math">f+1</span> validly signed partial aPoMs from different monitors against <span class="math">\\ell</span> (event <span class="math">a_{4}</span>).</p>

    <p class="text-gray-300">When <span class="math">m</span> transitions to Postcommit, it signs the STH using its share of the threshold signing key distributed among the monitors; we refer to this as a partial signature (sig). Monitor <span class="math">m</span> gathers the partial signatures it receives in event <span class="math">e_{4}</span>, and the PCB completes successfully (transitions to Done) once <span class="math">m</span> is in the Postcommit state and has collected <span class="math">f+1</span> partial</p>

    <p class="text-gray-300">signatures and therefore has a complete threshold signature (event <span class="math">e_{5}</span>).</p>

    <p class="text-gray-300">Monitor <span class="math">m</span> could transition to the PoM error state either from the Postcommit state or even from the Done state. This transition is done once <span class="math">m</span> detects a conflicting STH, or collects <span class="math">f+1</span> valid aPoM messages signed by different monitors. In any case where <span class="math">m</span> does not reach Done, it will transition to the PoM error state with a valid Proof of Misbehavior (either an aPoM or a cPoM) against the rogue logger <span class="math">\\ell</span>. If <span class="math">m</span> does reach the accepting Done state, it will hold the threshold-signed STH, denoted <span class="math">STH^{p}_{\\ell,M}</span>, along with the corresponding precertificates.</p>

    <p class="text-gray-300">Monitor <span class="math">m</span> follows a similar process to obtain the valid threshold-signed revocation information (<span class="math">\\Delta CRV^{p}_{I}</span>) and <span class="math">SRH^{p}_{I,M}</span>, or a PoM against a rogue CA.</p>

    <p class="text-gray-300">Monitor <span class="math">m</span> provides the <span class="math">STH^{p}_{\\ell,M}</span>, <span class="math">\\Delta CRV^{p}_{I}</span>, and <span class="math">SRH^{p}_{I,M}</span> to relying parties via either periodic prefetching (§IV-E) . It also informs any subscribing entity <span class="math">x</span> (e.g., a domain owner) of any logged certificate that matches the profile to which <span class="math">x</span> subscribed (e.g., domain names identical or similar to those owned by <span class="math">x</span>).</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">We next describe two (optional) optimizations to the PCB protocol. The first is a simple broadcast optimization, that reduces the bandwidth usage between monitors, and is used by our implementation by default (§IV-D1). The second optimization, described in §IV-D2, uses erasure encoding to further reduce the amount of data sent from a logger to each monitor to $\\frac{2\\cdot</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">certs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">}{n}<span class="math"> bytes (where </span>n$ is the total number of monitors). Our evaluation shows mixed results for this optimization, therefore we did not make it the default in the implementation.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <h2 id="sec-15" class="text-2xl font-bold">1) The Broadcast Optimization</h2>

    <p class="text-gray-300">In the PCB protocol as described so far, monitors immediately share the (validated) precertificates they received with other monitors. This would result in sending many precertificates unnecessarily between monitors, consuming bandwidth unnecessarily. To mitigate this, our implementation deploys, by default, the following simple optimization.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>After a monitor receives from the logger the complete, valid set of precertificates for the current period, it notifies its neighbors.</li>

      <li>A monitor receiving the first such notification, sends back a request for precertificates and begins a timer (for <span class="math">2\\cdot\\Delta_{com}</span> or less).</li>

      <li>If the timer expires and the monitor still did not receive a complete, valid set of precertificates corresponding to the STH, then the monitor sends requests to any monitor that informs it of the availability of a complete, valid set of precertificates. Until then, the monitor does not send such requests to other monitors (except the first one), but does keep a record of the monitors from whom it received notification of available precertificates.</li>

      <li>A monitor that receives a request for precertificates, responds with the (complete, valid) set of precertificates it had received.</li>

      <li>Once the timer expires, the monitor will change its operation and immediately ask for the precertificates whenever it receives notice of their availability at a peer monitor.</li>

    </ul>

    <p class="text-gray-300">This approach eliminates redundant fetches and sending of precertificates while still ensuring prompt delivery.</p>

    <h2 id="sec-16" class="text-2xl font-bold">2) The Erasure Encoding Algorithm (EEA) Optimization</h2>

    <p class="text-gray-300">In the EEA optimization of the PCB protocol, loggers and CAs break down the precertificates or compressed CRV file into <span class="math">k=floor(\\frac{n}{2})</span> data shards and generate <span class="math">n-k</span> parity shards, where <span class="math">n</span> is the number of monitors. Since our model requires <span class="math">n\\geq 2\\cdot f+1</span> (see §III-A), this ensures that the system can always tolerate <span class="math">f</span> losses.</p>

    <p class="text-gray-300">To ensure the authenticity of these file shares, the logger/CA will construct another Merkle tree where the file shares becomes the leaves. Each file share will be assigned a <span class="math">Pol_{m_{i}}</span> with respect to the same root <span class="math">head_{fs}</span>, both of which will be sent as part of the update alongside the fileshare and <span class="math">STH^{p}_{\\ell}</span> (see Equation 1), where <span class="math">STH^{p}_{\\ell}.\\sigma</span> is signed over <span class="math">STH^{p}_{\\ell}.p\\parallel STH^{p}_{\\ell}.\\ell\\parallel h(head_{fs}\\parallel STH^{p}_{\\ell}.head)\\parallel STH^{p}_{\\ell}.size</span>.</p>

    <p class="text-gray-300">The EEA optimization requires a small change to the PCB protocol as illustrated in Figure 2. Namely, in event <span class="math">e_{2}</span>, the monitor should reconstruct the precertificate file from <span class="math">k</span> EEA-encoded shares before validation.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">2.1 Efficient Certificate Validation by Relying Parties</h3>

    <p class="text-gray-300">The ultimate goal of PKI is certificate validation by relying parties. In this subsection, we present the default CTng process, allowing efficient certificate validation by typical relying parties, such as browsers. In §A, we show how CTng can incorporate the design of <em>[6]</em> to reduce overhead for both CAs and relying parties following migration to a post-quantum PKI.</p>

    <p class="text-gray-300">Relying parties with reasonable resources and connectivity would obtain, every MMD, the STHs of that period (from each logger) and the SRH and <span class="math">\\Delta</span>CRV values of that period (from each CA). The relying party would then validate the threshold-signature on these values, proving that the values were validated by (at least) <span class="math">f+1</span> monitors, i.e., by at least one benign monitor.</p>

    <p class="text-gray-300">Specifically, for all transparency updates, the relying party confirms the validity of the threshold signature <span class="math">STH^{p}_{\\ell,M}.\\sigma</span> over the encoding of the other fields: <span class="math">p\\parallel\\ell\\parallel head\\parallel size</span> using the group public key of the monitors <span class="math">PK_{M}</span> (see Equation 1). Similarly, for all revocation updates, the relying party confirms that <span class="math">SRH^{p}_{I,M}.\\sigma</span> is a valid threshold signature over the other fields: <span class="math">p\\parallel I\\parallel h(CRV^{p}_{I})\\parallel h(\\Delta CRV^{p}_{I})</span> (see Equation 3).</p>

    <p class="text-gray-300">The relying party also obtains and validates Proofs of Misbehavior (PoMs): both conflict PoMs (cPoMs) and accusation PoMs (aPoMs). The relying party would validate that each aPoM is threshold-signed by at least <span class="math">f+1</span> monitors, like the validation of the STH, SRH and <span class="math">\\Delta</span>CRV values. The relying party would also validate the cPoMs, but the process is a bit</p>

    <p class="text-gray-300">different: each cPoM should consist of two different updates for the same period and both signed by the same (faulty) logger or CA.</p>

    <p class="text-gray-300">The relying party can obtain the periodical updates either directly from one of the monitors, or from another source; since updates are threshold-signed and timestamped, their authenticity and freshness are ensured even if obtained from a source which is not trustworthy. For example, the information can be downloaded from a monitor, validated and then cached and provided by a browser vendor or the client’s ISP, or distributed as DNS records; the resource requirements on the monitors would be minimal.</p>

    <p class="text-gray-300">Finally, the relying party verifies that a valid STH was received from each non-faulty logger, and that a valid SRH and <span class="math">\\Delta</span>CRV were received from each non-faulty CA.</p>

    <p class="text-gray-300">If any verification fails, the relying party considers the monitor or other source from which it received the update as faulty, and restarts the process with a different monitor (or other source).</p>

    <p class="text-gray-300">After successful verification, the relying party updates its local storage based on the newly received information. Specifically, for each transparency update <span class="math">STH^{p}_{\\ell,M}</span>, the relying party stores the logger ID <span class="math">STH^{p}_{\\ell,M}.\\ell</span>, the period number <span class="math">STH^{p}_{\\ell,M}.p</span>, and the Merkle digest <span class="math">STH^{p}_{\\ell,M}.head</span>; for each revocation update <span class="math">SRH^{p}_{I,M}</span>, along with its <span class="math">\\Delta CRV^{p}_{I}</span>, the relying party updates the CRV for <span class="math">SRH^{p}_{I,M}.I</span> in its local storage.</p>

    <p class="text-gray-300">The prefetched information allows the relying party to perform offline validation as follows. Upon establishing a TLS connection with a subject (website) that uses a CTng-compliant certificate <span class="math">\\psi</span>, the relying party first confirms that <span class="math">\\psi</span> is PKIX-valid, as per <em>[13]</em>, e.g., correctly signed, trust-anchored, not expired, etc. The relying party then searches its local storage for the head <span class="math">Localheads[\\ell,p]</span> corresponding to logger <span class="math">\\psi.CTng.\\ell</span> in period <span class="math">\\psi.CTng.p</span>. It then extracts the precertificate portion <span class="math">\\Phi</span> from <span class="math">\\psi</span>, computes <span class="math">h(\\Phi)</span>, and confirms via MT.VerifyPoI that <span class="math">Localheads[\\ell,p]</span> can be reconstructed from <span class="math">h(\\Phi)</span> and <span class="math">\\psi.CTng.PoI</span> <em>[40]</em>. Finally, the relying party confirms that <span class="math">\\psi</span> is not revoked by checking the revocation status using the issuing CA <span class="math">\\psi.I</span> and the RN field <span class="math">\\psi.CTng.RN</span>; specifically, that <span class="math">LocalCRV[\\psi.I][\\psi.CTng.RN]=0</span>.</p>

    <h2 id="sec-18" class="text-2xl font-bold">V Analysis</h2>

    <p class="text-gray-300">In this section, we analyze how CTng, with the periodic prefetch mechanism (§IV-E), achieves the goals listed in (§III) against an attacker who controls an arbitrary set of loggers and CAs, as well as up to <span class="math">f</span> monitors.</p>

    <p class="text-gray-300">We state and prove two theorems; The first theorem establishes the ‘timeline’ for issuing and validating certificates in CTng, demonstrating that CTng ensures correctness; intuitively, a certificate issued properly using a benign CA, logger, and monitor will be considered valid as expected. The second theorem shows that CTng satisfies the security and privacy goals (G1 to G6). Finally, we explain how CTng achieves the system goals (G7 to G8).</p>

    <h3 id="sec-19" class="text-xl font-semibold mt-8">V-A Timing and Correctness Analysis</h3>

    <p class="text-gray-300">We now analyze the timeline of events in CTng, showing that CTng ensures correctness: issued certificates become valid (until revoked or expired) within bounded time, and revoked certificates become invalid within bounded time (See Figure 3). The analysis provides time bounds, which we also use in the design of CTng. The analysis is mostly done in terms of real-time intervals; we denote different real-time values by adding subscripts and superscripts, as needed, to the symbol <span class="math">\\tau</span>. The bound of <span class="math">\\Delta_{clk}</span> on the clock bias allows us to bound the real time when the local clock of an entity shows any given value, e.g., <span class="math">C</span>, as:</p>

    <p class="text-gray-300"><span class="math">\\tau_{C}\\in[C-\\Delta_{clk},C+\\Delta_{clk}]</span> (5)</p>

    <p class="text-gray-300">In particular, let <span class="math">C_{p}\\equiv p\\cdot MMD+2\\cdot\\Delta_{clk}</span> for an integer <span class="math">p\\geq 0</span>, and <span class="math">\\tau^{\\ell}_{p}</span> denote the time when <span class="math">\\ell</span>’s local clock shows <span class="math">C_{p}</span>. From Equation 5, we have:</p>

    <p class="text-gray-300">\\[ \\begin{split}\\tau^{\\ell}_{p}&\\in[C_{p}-\\Delta_{clk},C_{p}+\\Delta_{clk}]\\\\ &=[p\\cdot MMD+\\Delta_{clk},p\\cdot MMD+3\\cdot\\Delta_{clk}]\\end{split} \\] (6)</p>

    <p class="text-gray-300">For simplicity, the timing analysis, whose results are summarized by Theorem 1, assumes that the execution of all entities begins at real time zero.</p>

    <h6 id="sec-20" class="text-base font-medium mt-4">Theorem 1.</h6>

    <p class="text-gray-300">Let <span class="math">I</span> be a benign CA, <span class="math">\\ell</span> be a benign logger used by <span class="math">I</span>, <span class="math">m</span> be a benign monitor, <span class="math">RP</span> be a benign relying party using <span class="math">m</span>, and <span class="math">d_{M}</span> be the diameter of the <span class="math">f+1</span>-connected monitor network. For every integer <span class="math">p&gt;0</span>, let <span class="math">\\tau^{Init}_{p,m}</span> denote the time when the local clock of monitor <span class="math">m</span> shows <span class="math">p\\cdot MMD</span>. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Let <span class="math">\\Phi</span> be a precertificate issued by <span class="math">I</span> at time <span class="math">\\tau_{I}</span>, and suppose <span class="math">RP</span> validates the corresponding certificate <span class="math">\\psi</span> at time <span class="math">\\tau_{RP}&gt;\\tau_{I}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(4+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. Then <span class="math">RP</span> will determine <span class="math">\\psi</span> to be valid, provided that <span class="math">\\psi</span> has not expired (i.e. <span class="math">\\psi.to\\geq\\tau_{RP}+\\Delta_{clk}</span>) and that <span class="math">\\psi</span> was not revoked by <span class="math">I</span> until <span class="math">\\tau_{RP}</span>.</li>

      <li>Let <span class="math">\\psi</span> be a certificate that <span class="math">I</span> issued (at <span class="math">\\tau_{I}</span>) and revoked at time <span class="math">\\tau_{R}</span> (<span class="math">\\tau_{R}&gt;\\tau_{I}</span>). Suppose <span class="math">RP</span> validates <span class="math">\\psi</span> at time <span class="math">\\tau_{RP}&gt;\\tau_{R}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(3+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. Then <span class="math">RP</span> will determine <span class="math">\\psi</span> to be invalid.</li>

    </ol>

    <h6 id="sec-21" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">We only present the detailed argument for the first statement; the second statement follows similarly as shown in Claim 5.</p>

    <p class="text-gray-300">The proof is by a series of claims, following the events in the handling of <span class="math">\\Phi</span> (and <span class="math">\\psi</span>) and the timeline as illustrated in Figure 3. In Claim 1, we analyze the period when <span class="math">\\ell</span> handles and forwards <span class="math">\\Phi</span> (and the corresponding STH) issued at . In Claim 2, we derive the bound for the update timer <span class="math">t_{u}</span> and show that the <span class="math">t_{u}</span> timeout event will never happen if the logger is benign. Claim 3 shows that all benign monitors move to Done state, with a complete threshold signature over the STH, before <span class="math">\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+3\\cdot d_{M})\\cdot\\Delta_{com}</span>.</p>

    <p class="text-gray-300">Finally, let <span class="math">\\psi</span> be the full certificate corresponding to the precertificate <span class="math">\\Phi</span>, and, in particular, containing the PoI generated by the benign logger <span class="math">\\ell</span>. Claim 4 completes the proof, by</p>

    <p class="text-gray-300">!<a href="img-3.jpeg">img-3.jpeg</a> (a) Certificate issuance timeline.</p>

    <p class="text-gray-300">!<a href="img-4.jpeg">img-4.jpeg</a> (b) Certificate revocation timeline. Fig. 3: Timeline visualizations used in the proof of correctness (Theorem 1).</p>

    <p class="text-gray-300">showing that the benign relying party  <span class="math">RP</span>  will consider  <span class="math">\\psi</span>  as valid at time  <span class="math">\\tau_{RP} &amp;gt; \\tau_I + 2\\cdot MMD + 4\\cdot \\Delta_{clk} + (4 + 3\\cdot d_M)\\cdot \\Delta_{com}</span> , provided that  <span class="math">\\psi .to\\geq \\tau_{RP} + \\Delta_{clk}</span>  and that  <span class="math">\\psi</span>  was not revoked by  <span class="math">I</span>  until  <span class="math">\\tau_{RP}</span> .</p>

    <p class="text-gray-300">Claim 1. Let  <span class="math">\\tau_{I}</span>  denote the time when the CA sent  <span class="math">\\Phi</span>  to logger  <span class="math">\\ell</span>  and let  <span class="math">p</span>  denote the period number included in the first STH which  <span class="math">\\ell</span>  sends after receiving  <span class="math">\\Phi</span> . Then  <span class="math">\\tau_{p}^{\\ell} \\in [\\max \\{\\tau_{I}, C_{p} - \\Delta_{clk}\\}, C_{p} + \\Delta_{clk}]</span>  and  <span class="math">p \\in [p_0, p_1]</span> , where:</p>

    <div class="my-4 text-center"><span class="math-block">p _ {0} \\equiv \\left[ \\frac {\\tau_ {I} - 3 \\cdot \\Delta_ {c l k}}{M M D} \\right], p _ {1} \\equiv 1 + \\left\\lfloor \\frac {\\tau_ {I} - \\Delta_ {c l k} + \\Delta_ {c o m}}{M M D} \\right\\rfloor \\tag {7}</span></div>

    <p class="text-gray-300">Argument: Immediately from the bound  <span class="math">\\Delta_{com}</span>  on the delay, we know that logger  <span class="math">\\ell</span>  receives  <span class="math">\\Phi</span>  during  <span class="math">[\\tau_I,\\tau_I + \\Delta_{com}]</span> ; let  <span class="math">\\tau_L</span>  denote the time when  <span class="math">\\ell</span>  received  <span class="math">\\Phi</span> . From the design, we know that  <span class="math">\\ell</span>  sends the next STH when its clock shows  <span class="math">C_p</span> , with the STH containing the period number  <span class="math">p</span> . From Equation 6 and the fact that this is the STH sent after  <span class="math">\\tau_L</span> , we obtained  <span class="math">\\tau_p^\\ell \\in [\\max \\{\\tau_L,C_p - \\Delta_{clk}\\},C_p + \\Delta_{clk}]</span> .</p>

    <p class="text-gray-300">We next show that  <span class="math">p \\in [p_0, p_1]</span>  where  <span class="math">p_0, p_1</span>  are as in Equation 7.</p>

    <p class="text-gray-300">Since  <span class="math">\\tau_{I} \\leq \\tau_{L} \\leq \\tau_{I} + \\Delta_{com}</span> , it follows from Eq. 5 that:</p>

    <div class="my-4 text-center"><span class="math-block">\\tau_ {I} \\leq C _ {p} + \\Delta_ {c l k} = p \\cdot M M D + 3 \\cdot \\Delta_ {c l k} \\tag {8}</span></div>

    <p class="text-gray-300">Since  <span class="math">\\Phi</span>  must be received after the previous STH:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\tau_ {I} \\geq \\tau_ {p - 1} ^ {\\ell} - \\Delta_ {c o m} \\geq C _ {p - 1} - \\Delta_ {c o m} - \\Delta_ {c l k} \\tag {9} \\\\ = (p - 1) \\cdot M M D + \\Delta_ {c l k} - \\Delta_ {c o m} \\\\ \\end{array}</span></div>

    <p class="text-gray-300">From Equation 8 and Equation 9 we can derive bounds for  <span class="math">p</span> :</p>

    <div class="my-4 text-center"><span class="math-block">\\frac {\\tau_ {I} - 3 \\cdot \\Delta_ {c l k}}{M M D} \\leq p \\leq 1 + \\frac {\\tau_ {I} - \\Delta_ {c l k} + \\Delta_ {c o m}}{M M D} \\tag {10}</span></div>

    <p class="text-gray-300">Since  <span class="math">p</span>  is an integer, we have:</p>

    <div class="my-4 text-center"><span class="math-block">p _ {0} \\leq p \\leq p _ {1}, \\text {defined in Equation 7} \\tag {11}</span></div>

    <p class="text-gray-300">We next show that monitor  <span class="math">m</span>  will receive  <span class="math">STH_{p}^{\\ell}</span>  and  <span class="math">\\Phi</span>  before the  <span class="math">t_{u}</span>  timer times-out, where  <span class="math">t_{u} \\equiv \\Delta_{com} + 4 \\cdot \\Delta_{clk}</span> .</p>

    <p class="text-gray-300">Claim 2. Let  <span class="math">\\tau_{p,m}^{Init}</span>  denote the time of the  <span class="math">p^{th}</span>  INIT and PRECOMMIT events in  <span class="math">m</span> . Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\tau_{p,m}^{Init} \\in [p \\cdot MMD - \\Delta_{clk}, p \\cdot MMD + \\Delta_{clk}]</span> .</li>

      <li>For every period  <span class="math">p &amp;gt; 0</span>  and benign logger  <span class="math">\\ell</span> , monitor  <span class="math">m</span>  receives a valid  <span class="math">STH_{p}^{\\ell}</span>  during  <span class="math">[\\tau_{p,m}^{Init}, \\tau_{p,m}^{Init} + t_{u}]</span> , that is, the  <span class="math">t_{u}</span>  timeout event (action  <span class="math">a_{1}</span>  of the INIT state) is never invoked for the benign logger  <span class="math">\\ell</span> .</li>

    </ol>

    <p class="text-gray-300">Argument: Monitor  <span class="math">m</span>  begins period  <span class="math">p</span>  when its local clock shows  <span class="math">p \\cdot MMD</span> , i.e., following Eq. 5, at  <span class="math">\\tau_{p,m}^{Init} \\in [p \\cdot MMD - \\Delta_{clk}, p \\cdot MMD + \\Delta_{clk}]</span> , which is the first part of the claim. Equivalently:</p>

    <div class="my-4 text-center"><span class="math-block">p \\cdot M M D - \\Delta_ {c l k} \\leq \\tau_ {p, m} ^ {\\text {I n i t}} \\leq p \\cdot M M D + \\Delta_ {c l k} \\tag {12}</span></div>

    <p class="text-gray-300">To prove the second item, we first note that a benign logger  <span class="math">\\ell</span>  sends the STH for the  <span class="math">p^{th}</span>  period, i.e.,  <span class="math">STH_{p}^{\\ell}</span> , when its clock shows  <span class="math">p\\cdot MMD + 2\\cdot \\Delta_{clk}</span> , i.e., after real time  <span class="math">p\\cdot MMD + \\Delta_{clk}</span> . From the RHS of Equation 12, this cannot happen before  <span class="math">\\tau_{p,m}^{Init}</span> .</p>

    <p class="text-gray-300">To prove the second item, it remains to show that the STH is not received after  <span class="math">\\tau_{p,m}^{Init} + t_u</span> , where  <span class="math">t_u \\equiv \\Delta_{com} + 4 \\cdot \\Delta_{clk}</span> . The latest real time at which  <span class="math">\\ell</span>  will send the STH would be  <span class="math">p \\cdot MMD + 3 \\cdot \\Delta_{clk}</span> , therefore,  <span class="math">m</span>  receives the STH at or before real time  <span class="math">p \\cdot MMD + 3 \\cdot \\Delta_{clk} + \\Delta_{com}</span> . By substituting  <span class="math">p \\cdot MMD \\leq \\tau_{p,m}^{Init} + \\Delta_{clk}</span>  (LHS of Equation 12) we see that  <span class="math">m</span>  receives the STH before  <span class="math">\\tau_{p,m}^{Init} + 4 \\cdot \\Delta_{clk} + \\Delta_{com}</span> , as required.</p>

    <p class="text-gray-300">We now bound the times for the different steps of the PCB protocol in benign monitors, providing us with the desired bound on the time until the monitors have a valid STH for certificates issued by benign CAs, using a benign logger.</p>

    <h6 id="sec-22" class="text-base font-medium mt-4">Claim 3.</h6>

    <p class="text-gray-300">Let <span class="math">\\tau_{p,m}^{Precommit}</span>, <span class="math">\\tau_{p,m}^{Postcommit}</span> and <span class="math">\\tau_{p,m}^{Done}</span> denote the time when benign monitor <span class="math">m</span> enters its <span class="math">p^{th}</span> Precommit, Postcommit and Done State. Let <span class="math">d_{M}</span> denote the diameter of the <span class="math">(f+1)</span>-connected monitor topology. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Any precertificate sent to a benign logger <span class="math">\\ell</span> at time <span class="math">\\tau_{I}</span>, and the corresponding STH, are received by <span class="math">m</span> at time <span class="math">\\tau_{p,m}^{Precommit}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+2\\cdot\\Delta_{com}</span>.</li>

      <li>All benign monitors generate their partial signature over <span class="math">STH_{p}^{\\ell}</span> and move to Postcommit at time <span class="math">\\tau_{p,m}^{Postcommit}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+2\\cdot d_{M})\\cdot\\Delta_{com}</span>.</li>

      <li>All benign monitors move to Done state, with a complete threshold signature over the STH, at time <span class="math">\\tau_{p,m}^{Done}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+3\\cdot d_{M})\\cdot\\Delta_{com}</span>.</li>

    </ol>

    <p class="text-gray-300"><em>Argument:</em> Recall that, by Equation 6, <span class="math">\\ell</span> sends the STH at or before</p>

    <p class="text-gray-300"><span class="math">p\\cdot MMD+3\\cdot\\Delta_{clk}</span></p>

    <p class="text-gray-300">From Claim 1, we have <span class="math">p\\leq p_{1}</span>, where (by Equation 7)</p>

    <p class="text-gray-300"><span class="math">p_{1}\\equiv 1+\\left\\lfloor\\frac{\\tau_{I}-\\Delta_{clk}+\\Delta_{com}}{MMD}\\right\\rfloor.</span></p>

    <p class="text-gray-300">The time <span class="math">\\tau_{p}^{\\ell}</span> at which <span class="math">\\ell</span> sends <span class="math">\\Phi</span> and the corresponding STH is therefore not later than</p>

    <p class="text-gray-300"><span class="math">\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+\\Delta_{com}.</span></p>

    <p class="text-gray-300">Hence, we have an upper bound on the time at which monitor <span class="math">m</span> receives the STH and certificates, denoted <span class="math">\\tau_{p,m}^{Precommit}</span>:</p>

    <p class="text-gray-300"><span class="math">\\tau_{p,m}^{Precommit}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+2\\cdot\\Delta_{com}.</span></p>

    <p class="text-gray-300">This proves part 1 of the claim.</p>

    <p class="text-gray-300">In the Precommit state, the benign monitors wait for <span class="math">t_{v}=2\\cdot d_{M}\\cdot\\Delta_{com}</span> time for a potential conflicting STH. Such a conflicting STH will not be received, since <span class="math">\\ell</span> is benign and will not send a conflicting STH (and the attacker cannot send a fake yet valid conflicting STH). Therefore, the time <span class="math">\\tau_{p,m}^{Postcommit}</span> at which a benign monitor <span class="math">m</span> moves to Postcommit is at most: <span class="math">\\tau_{p,m}^{Postcommit}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+2\\cdot d_{M})\\cdot\\Delta_{com}</span>, proving part 2 of the claim.</p>

    <p class="text-gray-300">At this point, each benign monitor will generate its partial signature of the STH, and send it to all the other monitors. Let <span class="math">\\tau_{p,m}^{Done}</span> denote the time at which benign monitor <span class="math">m</span> will have the necessary <span class="math">f+1</span> partial signatures, and move to Done; this would occur within only one more <span class="math">d_{M}\\cdot\\Delta_{com}</span>, i.e., <span class="math">\\tau_{p,m}^{Done}\\leq\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. ∎</p>

    <h6 id="sec-23" class="text-base font-medium mt-4">Claim 4.</h6>

    <p class="text-gray-300">Let <span class="math">\\psi</span> be the certificate corresponding to the precertificate <span class="math">\\Phi</span>, both issued by benign CA <span class="math">I</span> using the benign logger <span class="math">\\ell</span>. Suppose that a benign relying party <span class="math">RP</span>, which uses a benign monitor <span class="math">m</span>, validates <span class="math">\\psi</span> at time <span class="math">\\tau_{RP}&gt;\\tau_{I}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(4+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. Then <span class="math">RP</span> will determine <span class="math">\\psi</span> to be valid, provided that <span class="math">\\psi.to\\geq\\tau_{RP}+\\Delta_{clk}</span> and that <span class="math">\\psi</span> was not revoked by <span class="math">I</span> until <span class="math">\\tau_{RP}</span>.</p>

    <p class="text-gray-300"><em>Argument:</em> Since <span class="math">\\ell</span> and the CA <span class="math">I</span> are both benign, we know that <span class="math">\\psi</span> will contain a valid PoI for <span class="math">STH_{p}^{\\ell}</span>.</p>

    <p class="text-gray-300">A benign <span class="math">RP</span> asks for a new STH once every MMD. Therefore, when it validates <span class="math">\\psi</span> at <span class="math">\\tau_{RP}</span>, the <span class="math">RP</span> should already have requested and received from <span class="math">m</span> all the STHs signed by the monitors until <span class="math">\\tau_{RP}-MMD-2\\cdot\\Delta_{com}-2\\cdot\\Delta_{clk}</span>; notice that we allow here for the (extremely unlikely) case where the <span class="math">RP</span>’s clock was behind by <span class="math">\\Delta_{clk}</span> when it requested the previous update (including STH) from <span class="math">m</span>, and that it was ahead by <span class="math">\\Delta_{clk}</span> at <span class="math">\\tau_{RP}</span>.</p>

    <p class="text-gray-300">From Claim 3, all benign monitors, including <span class="math">m</span>, have a complete threshold signature of the STH which covers <span class="math">\\Phi</span>, allowing successful validation of <span class="math">\\psi</span>, by <span class="math">\\tau_{I}+MMD+2\\cdot\\Delta_{clk}+(2+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. Since <span class="math">\\tau_{RP}&gt;\\tau_{I}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(4+3\\cdot d_{M})\\cdot\\Delta_{com}</span>, then, at <span class="math">\\tau_{RP}</span>, the <span class="math">RP</span> should already have this (signed) STH, and would determine <span class="math">\\psi</span> to be valid. ∎</p>

    <h6 id="sec-24" class="text-base font-medium mt-4">Claim 5.</h6>

    <p class="text-gray-300">Let <span class="math">\\tau_{R}</span> denote the time when certificate <span class="math">\\psi</span> is revoked by CA <span class="math">I</span> and let <span class="math">p</span> denote the period number included in the first SRH which <span class="math">I</span> sends after revoking <span class="math">\\psi</span>. Let <span class="math">\\tau_{p}^{I}</span> denote the time at which the <span class="math">I</span> sends the SRH and <span class="math">\\Delta</span>CRV.Let <span class="math">\\tau_{p,m}^{Precommit}</span>, <span class="math">\\tau_{p,m}^{Postcommit}</span> and <span class="math">\\tau_{p,m}^{Done}</span> denote the time when benign monitor <span class="math">m</span> enters its <span class="math">p^{th}</span> Precommit, Postcommit and Done State. Then:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The first <span class="math">SRH</span> and <span class="math">\\Delta CRV</span> generated after <span class="math">\\psi</span> was revoked at time <span class="math">\\tau_{R}</span> are received by <span class="math">m</span> at <span class="math">\\tau_{p,m}^{Precommit}</span> before <span class="math">\\tau_{R}</span> + <span class="math">MMD</span> + <span class="math">2\\cdot\\Delta_{clk}+\\Delta_{com}</span>.</li>

      <li>All benign monitors move to Done state, with a complete threshold signature over the SRH at <span class="math">\\tau_{p,m}^{Done}</span> before <span class="math">\\tau_{R}</span> + <span class="math">MMD</span> + <span class="math">2\\cdot\\Delta_{clk}+(1+3\\cdot d_{M})\\cdot\\Delta_{com}</span></li>

      <li>Let <span class="math">RP</span> be a benign relying party that uses a benign monitor <span class="math">m</span>. If it validates <span class="math">\\psi</span> at any time</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\tau_{RP}&gt;\\tau_{R}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(3\\cdot d_{M})\\cdot\\Delta_{com},</span></p>

    <p class="text-gray-300">then <span class="math">RP</span> determines <span class="math">\\psi</span> to be invalid.</p>

    <p class="text-gray-300"><em>Argument:</em> Since <span class="math">\\psi</span> must be revoked before the current SRH but after the previous SRH:</p>

    <p class="text-gray-300"><span class="math">\\tau_{R}\\leq C_{p}+\\Delta_{clk}=p\\cdot MMD+3\\cdot\\Delta_{clk}</span> (13) <span class="math">\\tau_{R}\\geq C_{p-1}-\\Delta_{clk}=(p-1)\\cdot MMD+\\Delta_{clk}</span> (14)</p>

    <p class="text-gray-300">From Equation 13 and Equation 14 we can derive the bound for <span class="math">p</span>: <span class="math">p\\in[p_{0},p_{1}]</span>, where:</p>

    <p class="text-gray-300"><span class="math">p_{0}\\equiv\\left\\lceil\\frac{\\tau_{R}-3\\cdot\\Delta_{clk}}{MMD}\\right\\rceil,\\ p_{1}\\equiv 1+\\left\\lfloor\\frac{\\tau_{R}-\\Delta_{clk}}{MMD}\\right\\rfloor</span> (15)</p>

    <p class="text-gray-300">Benign CA <span class="math">I</span> sends the (valid) <span class="math">SRH</span> and the corresponding <span class="math">\\Delta CRV</span> for period <span class="math">p</span> at</p>

    <p class="text-gray-300"><span class="math">\\tau_{p}^{I}\\leq p\\cdot MMD+3\\cdot\\Delta_{clk},</span></p>

    <p class="text-gray-300">so monitor <span class="math">m</span> receives them no later than</p>

    <p class="text-gray-300"><span class="math">p\\cdot MMD+3\\cdot\\Delta_{clk}+\\Delta_{com}.</span></p>

    <p class="text-gray-300">Substituting</p>

    <p class="text-gray-300"><span class="math">p&lt;p_{1}\\equiv 1+\\left\\lfloor\\frac{\\tau_{R}-\\Delta_{clk}}{MMD}\\right\\rfloor,</span></p>

    <p class="text-gray-300">it follows that the first <span class="math">SRH</span> and <span class="math">\\Delta CRV</span> generated after certificate <span class="math">\\psi</span> was revoked at time <span class="math">\\tau_{R}</span> are received by <span class="math">m</span> at</p>

    <p class="text-gray-300"><span class="math">\\tau_{p,m}^{Precommit}&lt;\\tau_{R}+MMD+2\\cdot\\Delta_{clk}+\\Delta_{com}.</span></p>

    <p class="text-gray-300">This completes the proof for the first half of the claim.</p>

    <p class="text-gray-300">After entering the Precommit State, the operation afterwards mirrors the transparency information processing from Claim 3 to Claim 4, since the same PCB protocol is used. Therefore, it takes <span class="math">m</span> at most <span class="math">3\\cdot d_{M}\\cdot\\Delta_{com}</span> to reach the Done state, before <span class="math">\\tau_{R}</span> + MMD + <span class="math">2\\cdot\\Delta_{clk}+(1+3\\cdot d_{M})\\cdot\\Delta_{com}</span>.</p>

    <p class="text-gray-300">When the relying party validates <span class="math">\\psi</span> at <span class="math">\\tau_{RP}</span>, the <span class="math">RP</span> should already have requested and received from <span class="math">m</span> all the SRHs signed by the monitors with the corresponding <span class="math">\\Delta</span>CRVs to update its local CRV until <span class="math">\\tau_{RP}-MMD-2\\cdot\\Delta_{com}-2\\cdot\\Delta_{clk}</span>, since all benign monitors have reached the done state before <span class="math">\\tau_{R}</span> + <span class="math">MMD</span> + <span class="math">2\\cdot\\Delta_{clk}+(1+3\\cdot d_{M})\\cdot\\Delta_{com}</span> and the time at which the RP validates <span class="math">\\psi</span> is greater than <span class="math">\\tau_{R}+2\\cdot MMD+4\\cdot\\Delta_{clk}+(3+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. The RP should have already updated its local CRV and will therefore determine <span class="math">\\psi</span> to be invalid. ∎</p>

    <h3 id="sec-25" class="text-xl font-semibold mt-8">VI-B Security and Privacy Goals</h3>

    <h6 id="sec-26" class="text-base font-medium mt-4">Theorem 2.</h6>

    <p class="text-gray-300">CTng ensures the security and privacy Goals (G1–G6).</p>

    <h6 id="sec-27" class="text-base font-medium mt-4">Proof.</h6>

    <p class="text-gray-300">In <em>[65]</em>, Wrótniak et al. showed that both PKIX and CT satisfy existential unforgeability (G1) and accountability (G2) by assuming less restrictive assumptions than in §III-A. Since CTng augments CT and builds upon the core functionality of PKIX/CT used in <em>[65]</em>, Claim 6 uses reduction from CTng to <em>[65]</em>, to prove that G1 and G2 are also satisfied by CTng.</p>

    <p class="text-gray-300">Claim 7 shows that CTng achieves <span class="math">\\Delta-</span>guaranteed transparency (G3) for <span class="math">\\Delta=0</span>, since a benign relying party considers <span class="math">\\psi</span> as valid only if <span class="math">\\psi</span> has a valid PoI in the corresponding STH, which must be validly signed by the threshold monitors key, i.e., all benign monitors must have already received the corresponding precertificate as well.</p>

    <p class="text-gray-300">Claim 8 shows that CTng achieves <span class="math">\\Delta-</span>guaranteed revocation (G4) for <span class="math">\\Delta=2\\cdot MMD+6\\cdot\\Delta_{clk}+(4+3\\cdot d_{M})\\cdot\\Delta_{com}</span>, following the bounds calculated in Theorem 1 that shows that the revocation will be known to the relying party within such <span class="math">\\Delta</span>.</p>

    <p class="text-gray-300">Claim 9 shows that CTng ensures unequivocal revocation (G5), by showing that any adversary that breaks G5 in CTng is either using an insecure threshold signature scheme or does not guarantee the models assumptions described in §III-A.</p>

    <p class="text-gray-300">Finally, Claim 10 shows that CTng preserves relying-party privacy (G6), because the certificate validation process in CTng does not disclose any information to any third party. ∎</p>

    <p class="text-gray-300">Claim 6. CTng satisfies G1: existential unforgeability and G2: accountability under the model assumptions described in §III-A.</p>

    <p class="text-gray-300"><em>Argument.</em> The proof is by reduction. In <em>[65]</em>, Wrótniak et al. showed that both PKIX and CT satisfy these requirements by assuming less restrictive assumptions than in §III-A. Intuitively, since CTng augments CT and builds upon the core functionality of PKIX/CT that was used in <em>[65]</em>, it also does not provide an adversary any advantage that will allow it to break existential unforgeability or accountability. Specifically, CTng does not change the signing operation w.r.t CT. Therefore, if there exists an adversary <span class="math">\\mathcal{A}</span> that prevents CTng from satisfying the existential unforgeability or accountability requirements, we can construct an adversary <span class="math">\\mathcal{A}</span>’ that runs adversary <span class="math">\\mathcal{A}</span> internally and breaks existential unforgeability / accountability in PKIX or CT as well.</p>

    <p class="text-gray-300">Similarly, the new functionality introduced by CTng does not provide the adversary access to the benign entities’ private keys nor the ability to forge attestations on their behalf. Specifically, the relevant changes introduced by CTng include:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CAs sign CRVs instead of CRLs/OCSP.</li>

      <li>Loggers sign smaller trees.</li>

      <li>Monitors broadcast transparent data and use threshold signatures.</li>

    </ol>

    <p class="text-gray-300">The data signed in these changes is decided solely by the signing entity and only after the entity verified its validity, e.g., a logger ensures a new certificate is valid. The existence of at least one benign monitor in change three ensures that the threshold-signed data is indeed valid. Thus, the new signed attestations in CTng were either signed by a benign entity or were issued by a rogue entity that managed to hijack the information’s chain of trust. In both cases, this means that CTng satisfies both existential unforgeability and accountability. ∎</p>

    <p class="text-gray-300">Claim 7. CTng achieves G3: <span class="math">\\Delta-</span>guaranteed transparency for <span class="math">\\Delta=0</span>. Namely, if certificate <span class="math">\\psi</span> is considered valid by a benign relying party at time <span class="math">\\tau</span>, then the corresponding precertificate <span class="math">\\Phi</span> was received by all benign monitors before <span class="math">\\tau</span>.</p>

    <p class="text-gray-300"><em>Argument.</em> Benign relying party considers <span class="math">\\psi</span> as valid only if <span class="math">\\psi</span> has a valid PoI in the corresponding STH, which must be validly signed by the threshold monitors key. Namely, the STH must have been signed using at least <span class="math">f+1</span> of the partial keys of different monitors, i.e., by at least one benign monitor <span class="math">m</span>. However, a benign monitor signs an STH only from Postcommit state, i.e., after receiving all the corresponding precertificates and sending them to all other monitors; the integrity of the Merkle tree ensures these precertificates received by <span class="math">m</span> include <span class="math">\\Phi</span>, the precertificate corresponding to <span class="math">\\psi</span>. Thus, all benign monitors must have already received <span class="math">\\Phi</span> as well (at least when sent to them by <span class="math">m</span>). ∎</p>

    <p class="text-gray-300">Claim 8. CTng achieves G4: <span class="math">\\Delta-</span>guaranteed revocation for <span class="math">\\Delta=2\\cdot MMD+6\\cdot\\Delta_{clk}+(4+3\\cdot d_{M})\\cdot\\Delta_{com}</span>. Namely, let <span class="math">\\psi</span> be a certificate revoked by the benign issuing CA at time <span class="math">\\tau_{R}</span>, and let <span class="math">RP</span> be a benign relying party which uses a benign monitor <span class="math">m</span>. Then <span class="math">RP</span> will not consider <span class="math">\\psi</span> as valid at any time <span class="math">\\tau&gt;\\tau_{R}+\\Delta</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Asymptotic Overhead</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">System</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">CAs</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Loggers</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Monitors</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Computation per MMD</td>

            <td class="px-3 py-2 border-b border-gray-700">CT + CRLset</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm + Nrpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Ncpm · log(Nc))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Ncpm · log(Nc))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CTng</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm + Nrpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm · log(Ncpm))</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Communication per MMD</td>

            <td class="px-3 py-2 border-b border-gray-700">CT + CRLset</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Ncpm + Nrpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Nm · Ncpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Nm · Ncpm)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CTng</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm + Nm · Nrpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nm · Ncpm)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nm · (Ncpm + Nrpm))</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Storage</td>

            <td class="px-3 py-2 border-b border-gray-700">CT + CRLset</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nr)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(f · Nc)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700"></td>

            <td class="px-3 py-2 border-b border-gray-700">CTng</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nr)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Nc)</td>

            <td class="px-3 py-2 border-b border-gray-700">O(Ncpm + Nr)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE III: Asymptotic overhead per MMD for CT (as defined in [40]) with CRLset and CTng. Each entry shows the complexity in terms of key system parameters:  <span class="math">N_{\\mathrm{cpm}}</span>  (number of all new precertificates issued per MMD),  <span class="math">N_{\\mathrm{c}}</span>  (total number of certificates in all logs),  <span class="math">N_{\\mathrm{rpm}}</span>  (number of all new revocations per MMD),  <span class="math">N_{\\mathrm{r}}</span>  (total number of revoked certificates)  <span class="math">N_{\\mathrm{ca}}</span>  (number of CAs),  <span class="math">N_{\\mathrm{m}}</span>  (number of monitors), and  <span class="math">f</span>  (security parameter).</p>

    <p class="text-gray-300">Argument. Let  <span class="math">CRV</span>  be the CRV kept by  <span class="math">RP</span>  at time  <span class="math">\\tau</span> . For  <span class="math">RP</span>  to consider  <span class="math">\\psi</span>  as valid, we must have  <span class="math">CRV[\\psi .CTng.RN] = \\bot</span> . However, since  <span class="math">RP</span>  uses the benign monitor  <span class="math">m</span> , then  <span class="math">RP</span>  would have an updated value for its  <span class="math">CRV</span> ; in particular, the CRV would reflect any  <span class="math">\\Delta CRV</span>  issued by a benign CA, including  <span class="math">\\psi .issuer</span> , before  <span class="math">\\tau - \\Delta</span> . Since the CA is benign, this includes the  <span class="math">\\Delta CRV</span>  indicating that  <span class="math">\\psi</span>  was revoked.</p>

    <p class="text-gray-300">Claim 9. CTng ensures G5: Unequivocal revocation: for every valid certificate  <span class="math">\\psi</span> , no PPT adversary can convince some benign relying party  <span class="math">x</span>  that a certificate  <span class="math">\\psi</span>  is valid while convincing a different benign relying party  <span class="math">y</span>  that  <span class="math">\\psi</span>  was revoked, with a non-negligible probability.</p>

    <p class="text-gray-300">Argument. Assume to the contrary that there exists an adversary  <span class="math">\\mathcal{A}</span>  that can convince a benign relying party  <span class="math">x</span>  that a certificate  <span class="math">\\psi</span>  is valid while convincing a different benign relying party  <span class="math">y</span>  that  <span class="math">\\psi</span>  was revoked, with a non-negligible probability. In CTng, the revocation status information is threshold-signed by  <span class="math">f + 1</span>  monitors, ensuring that at least one benign monitor has signed it. This foils the zombie certificate attack (§II-B) because an attacker cannot silently show a certificate as revoked. Furthermore, the honest monitor will broadcast to the rest of the monitors, ensuring that they will learn about the revocation; this ensures that no future CRV could claim that it was not revoked.</p>

    <p class="text-gray-300">Therefore, since  <span class="math">x</span>  considers  <span class="math">\\psi</span>  as valid non-revoked certificate while  <span class="math">y</span>  considers  <span class="math">\\psi</span>  as revoked, then</p>

    <p class="text-gray-300"><span class="math">x.CRV_{\\psi .issuer}^{p}[\\psi .RN] = 0\\neq 1 = y.CRV_{\\psi .issuer}^{p^{\\prime}}[\\psi .RN]</span></p>

    <p class="text-gray-300">for some  <span class="math">p \\geq p&#x27;</span> . However, for that to happen, the adversary either:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Provided  <span class="math">x</span>  and  <span class="math">y</span>  conflicting CRV data by forging the monitors' threshold signature, or</li>

      <li>Prevented  <span class="math">x</span>  from obtaining an updated CRV with the revocation update.</li>

    </ol>

    <p class="text-gray-300">Option 1 means the threshold signature scheme is not secure and option 2 negates the assumption that relying parties have access to at least one benign monitor, contrary to the assumption that CTng does not achieve unequivocal revocation.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Claim 10. CTng preserves G6: Relying-party privacy.</p>

    <p class="text-gray-300">Argument. The certificate validation process in CTng is offline and does not require any additional real-time communication except for the usual interactions (e.g., with a web or other TLS server). As a result, certificates used by relying parties are never disclosed to any third party.  <span class="math">\\square</span></p>

    <p class="text-gray-300">G7: Evolutionary design. CTng does not require any additional entities compared to CT and introduces only modest changes to the roles and processes of existing CT entities. In particular, CT only expands the roles of monitors and requires CA/browser support for the new CTng extension.</p>

    <p class="text-gray-300">G8: Efficient certificate validation. In CTng, the decision to accept or reject a certificate is made entirely by the relying party, based solely on information provided with the certificate or stored locally as shown in §IV-E. As a result, relying parties are not required to initiate any network communication with any entities during the validation process, beyond receiving the certificate itself.</p>

    <p class="text-gray-300">We begin with a description of our evaluation setup of the experiments (§VI-A). Then, we evaluate the performance impact on each entity individually (§VI-B), followed by experimentally evaluating the performance and scalability of our CTng prototype implementation as a complete system (§VI-C).</p>

    <p class="text-gray-300">We implemented a prototype of the PCB protocol [30] in Go 1.23, with and without the erasure-encoding algorithm described in §IV-D2. We evaluated our prototype using the DeterLab testbed [47], where the test environment consisted of virtual machines running Ubuntu 22.04, each equipped with 8 cores and 16 GB of RAM. The baseline settings for all experiments are in Table IV (with justifications for these choices).</p>

    <p class="text-gray-300">We analyzed and compared the asymptotic overhead of each type of entity in CTng with respect to the overheads in CT, and summarized the results in Table III. The overhead of different CAs, loggers and monitors may differ widely depending on their usage; to deal with that, we present the overall overhead</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Parameter</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Value</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Justification</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of loggers</td>

            <td class="px-3 py-2 border-b border-gray-700">8</td>

            <td class="px-3 py-2 border-b border-gray-700">As of January 2025, all publicly usable CT logs are operated by six organizations, with each organization running 1-3 logs at any given time [1].</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Precertificate simulation</td>

            <td class="px-3 py-2 border-b border-gray-700">Random string of size 2000 Bytes</td>

            <td class="px-3 py-2 border-b border-gray-700">Based on [64], where the average size of precertificate is estimated to be 1570 Bytes.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Precertificate workload</td>

            <td class="px-3 py-2 border-b border-gray-700">400K certs/hr (uniformly distributed among the loggers)</td>

            <td class="px-3 py-2 border-b border-gray-700">Cloudflare observed [11] global precertificate throughput of 380K - 390K unique precertificates per hour in December 2024.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of CAs</td>

            <td class="px-3 py-2 border-b border-gray-700">100</td>

            <td class="px-3 py-2 border-b border-gray-700">Number of CAs does not have a noticeable impact [57].</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total number of certificates</td>

            <td class="px-3 py-2 border-b border-gray-700">100 million</td>

            <td class="px-3 py-2 border-b border-gray-700">Based on [57]. The daily revocation rate was not explicitly stated in [57], so we confirmed it with the authors.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Daily revocation rate</td>

            <td class="px-3 py-2 border-b border-gray-700">0.02%</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Total revocation rate</td>

            <td class="px-3 py-2 border-b border-gray-700">1%</td>

            <td class="px-3 py-2 border-b border-gray-700"></td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">MMD interval</td>

            <td class="px-3 py-2 border-b border-gray-700">10 minutes</td>

            <td class="px-3 py-2 border-b border-gray-700">This is the value data-mined from our own experiments, which leaves enough safety margin across our test suite.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of monitors</td>

            <td class="px-3 py-2 border-b border-gray-700">32</td>

            <td class="px-3 py-2 border-b border-gray-700">A reasonable upper bound on the number of monitors [2].</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Number of monitor faults allowed (f)</td>

            <td class="px-3 py-2 border-b border-gray-700">3</td>

            <td class="px-3 py-2 border-b border-gray-700">Slightly larger than CT's minimum fault tolerance (2SCTs [27] → f = 1).</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Access link capacity</td>

            <td class="px-3 py-2 border-b border-gray-700">1000 Mbps</td>

            <td class="px-3 py-2 border-b border-gray-700">Standard link capacity.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">Topology</td>

            <td class="px-3 py-2 border-b border-gray-700">Star topology</td>

            <td class="px-3 py-2 border-b border-gray-700">Simulates the internet back bone.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">TABLE IV: Baseline experiment setup.</p>

    <p class="text-gray-300">for all CAs, all loggers and all monitors. The overheads will also depend on the distribution of certificates and revocations between the different CAs and loggers; for simplicity, our computations assume the worst case where all certificates are by a single CA, which is using a fixed set of loggers.</p>

    <p class="text-gray-300">As we detail below, CTng does not introduce undue overhead for system entities, especially when weighted against the added security benefits and their existing responsibilities. Each role remains feasible in terms of performance and operational complexity. Note also that since CT and CTng rely on the same types of entities, the incentives to operate a CTng entity would be similar to the incentives to operate the corresponding CT entity. Further, we expect additional participants to join the ecosystem, such as browser vendors and large ISPs acting as monitors, driven in part by the value of providing stronger security benefits and (as done today) revocation services to their users.</p>

    <p class="text-gray-300">CAs: In both CT and CTng, the computation overhead per MMD is  <span class="math">O(N_{\\mathrm{cpm}} + N_{\\mathrm{rpm}})</span> , where  <span class="math">N_{\\mathrm{cpm}}</span>  is the number of all new precertificates issued per MMD, and  <span class="math">N_{\\mathrm{rpm}}</span>  is the number of all new revocations per MMD. However, since CT uses log redundancy, its communication overhead per MMD is  <span class="math">O(f \\cdot N_{\\mathrm{cpm}} + N_{\\mathrm{rpm}})</span> , as certificates need to be logged over multiple loggers, and the CRLsets mechanism needs to learn about all newly revoked certificates. In comparison, CTng's communication overhead is  <span class="math">O(N_{\\mathrm{cpm}} + N_{\\mathrm{m}} \\cdot N_{\\mathrm{rpm}})</span> , where  <span class="math">N_{\\mathrm{m}}</span>  is the number of monitors, since certificates are logged with only a single logger, which then sends the SRH and  <span class="math">\\Delta \\mathrm{CRV}</span>  to all monitors.</p>

    <p class="text-gray-300">The storage requirements in both CT and CTng are  <span class="math">O(N_{\\mathrm{r}})</span> , where  <span class="math">N_{\\mathrm{r}}</span>  is the total number of revoked certificates. This is because CAs do not need to store the certificates they have issued, but must retain those they have revoked. Although the storage overhead is asymptotically the same, the CRV approach used in CTng is significantly more space-efficient, requiring approximately 1.8 bits per revocation compared to CRLite's 6.6 bits, CRLset's 110 bits, and OneCRL's 1928 bits</p>

    <p class="text-gray-300">per revocation [38], [57].</p>

    <p class="text-gray-300">Loggers: The computational overhead for CT loggers is dominated by the need to update the Merkle tree by adding, in each MMD,  <span class="math">f \\cdot N_{cpm}</span>  new precertificates, where the factor of  <span class="math">O(f)</span>  comes from the logger redundancy required. The computational cost for each precertificate is proportional to the height of the tree, i.e.,  <span class="math">\\log (N_c)</span> . The  <span class="math">O(f)</span>  factor similarly impacts the communication and storage complexities of CT. In contrast, in CTng, we avoid the  <span class="math">O(f)</span>  factor; the computational cost is mainly due to the need to generate the PoI for each precertificate. Also, the height of the tree is only  <span class="math">O(\\log (N_{cpm}))</span> , since CTng uses separate trees for each MMD period.</p>

    <p class="text-gray-300">Monitors: The computational and communication costs for CT monitors (if implemented as the RFC [39], [40] prescribe) are similar to these of CT loggers. In case of CT, these are dominated by the need to receive  <span class="math">f</span>  copies of each precertificate and to add  <span class="math">f \\cdot N_{cpm}</span>  new precertificates to the Merkle tree of certificates <span class="math">^{13}</span> . For CTng, the costs are significantly reduced since we avoid the need to receive and handle  <span class="math">f</span>  redundant copies of each precertificate, and since the Merkle trees are much smaller (per MMD). CTng has an additional overhead of also handling revocations; in practice, the overhead due to revocations is negligible compared to the overhead of certificates.</p>

    <p class="text-gray-300">The storage requirements of CT and CTng monitors are the same for issued certificates <span class="math">^{14}</span> . CTng also stores the  <span class="math">\\Delta</span> CRV identifying newly revoked certificates. Note that Table III does not explicitly reflect the additional overhead of the activities that CTng monitors do and CT monitors do not: the PCB protocol and client prefetching. The reason is that the additional PCB protocol overhead is dominated by the aforementioned asymptotic overhead of handling the certificates. Also, clients</p>

    <p class="text-gray-300">can fetch the (signed) data from intermediaries such as CDNs, ISPs and browser vendors; they do not have to obtain it directly from monitors.</p>

    <h4 id="sec-32" class="text-lg font-semibold mt-6">Subjects (Websites)</h4>

    <p class="text-gray-300">The changes CTng introduce with respect to subjects are insignificant in terms of overhead. Notice, however, that issuing certificates in CTng takes more time than in CT (see Theorem 1).</p>

    <h4 id="sec-33" class="text-lg font-semibold mt-6">Relying Parties</h4>

    <p class="text-gray-300">We measured the prefetching method (§IV-E) for an MMD of 1 day and a standard revocation rate of 1%, and found that, for CTng, the daily communication overhead is 249 KB and the storage overhead is 2.33 MB; this is for the entire set of revocations. In comparison, Chrome’s implementation of CT with CRLsets incurs a daily bandwidth cost of 250 KB <em>[38]</em>, but this is for only 2% of the certificates (compared to full coverage provided by CTng).</p>

    <p class="text-gray-300">Next, we measured the per connection communication and computation overheads. The communication overhead is similar; a CT extension with the minimum 2 SCTs is 222 B when using ECSDA and 594 B when using RSA-2048, while a CTng extension is 780 B .However, CT requires significantly more computations to validate a certificate: approximately 25 ms using RSA 2048 and 50 ms using ECDSA, compared to only about 0.28 <span class="math">\\mu\\text{\\,}\\mathrm{\\SIUnitSymbolMicro}</span> in CTng. The reason for this significant difference is the fact that CTng requires only hash computations and no (real-time) signature verification, unlike CT, which uses log redundancy, and each SCT requires a public key signature verification.</p>

    <h3 id="sec-34" class="text-xl font-semibold mt-8">V-C Performance and Scalability of the System as a Whole</h3>

    <p class="text-gray-300">To evaluate the performance of our prototype, we measured the impact of several key system parameters on the maximum convergence time, defined as the duration required for the last benign monitor in the network to reach the “done” state described in Figure 2. This state indicates that all transparency information is fully prepared to be served to a relying party. The maximum convergence time effectively represents the smallest MMD that our system can support. In each experiment, we use the base settings from Table IV, except for the specific parameter being evaluated to assess its impact.</p>

    <h4 id="sec-35" class="text-lg font-semibold mt-6">The effect of increasing the number of monitors</h4>

    <p class="text-gray-300">In Figure 4a, we plot the impact of increasing the number of monitors from <span class="math">8</span> to <span class="math">32</span>. Our results show that CTng can easily support even a large number of monitors, as the maximum convergence time for <span class="math">32</span> monitors is only 32.77 seconds. Furthermore, we observe that CTng scales efficiently in the number of monitors: quadrupling the number of monitors from <span class="math">8</span> to <span class="math">32</span> does not result in any noticeable increase in convergence time; the results are all within our (quite tight) error margins.</p>

    <h4 id="sec-36" class="text-lg font-semibold mt-6">The effect of increasing number of monitor faults allowed (Figure 4b)</h4>

    <p class="text-gray-300">Using the baseline setting of 32 monitors, we experimented with increasing the monitor fault tolerance (<span class="math">f</span>) from 1 to 8, both with and without the erasure encoding algorithm. As shown in Figure 4b, CTng performs well under both configurations, with a convergence time increasing up to 67.11 seconds without erasure encoding, and increasing very slightly, from 32.51 to 34.51 seconds, with erasure encoding. We observe that when the number of faulty monitors is small, the overhead introduced by erasure encoding is not justified; in fact, the version without erasure encoding outperforms the encoded version. However, when the number of faulty monitors exceeds 4, erasure encoding becomes more effective.</p>

    <h4 id="sec-37" class="text-lg font-semibold mt-6">The impact of increased workload on loggers (Figure 4c)</h4>

    <p class="text-gray-300">Our workload baseline setting uniformly distributes a workload of 400 K precertificates per hour across 8 loggers. To evaluate the impact of increased workload per logger, we performed experiments in which the same total workload was distributed among fewer loggers. As shown in Figure 4c, our findings indicate that although fewer loggers introduce a bottleneck, CTng still converges within 75.62 seconds with only two loggers each handling a workload of 200 K precertificates per hour.</p>

    <h4 id="sec-38" class="text-lg font-semibold mt-6">The impact of increased workload on the system (Figure 4d)</h4>

    <p class="text-gray-300">While the previous experiments demonstrate that CTng can efficiently handle a workload of 400 K precertificates per hour, which is the current rate observed in the wild <em>[11]</em>, it is important to assess how CTng performs under higher volumes, as this number is expected to only increase in the foreseeable future. In Figure 4d, we plot the measured convergence time of our prototype under workloads ranging from 200 K to 1,200 K precertificates per hour. Our results show that the convergence time of CTng scales linearly with the overall workload processed by the monitor network. Under the baseline workload of 400 K precertificates per hour, the system converges within 32.77 seconds. Even at a workload of 1,200 K precertificates per hour, CTng converges within 77.04 seconds. In other words, CTng maintains a reasonable convergence time even with a safety factor of three, which is important not only for accommodating future growth but also for handling additional overheads that may not be reflected in our experimental setup.</p>

    <p class="text-gray-300">In summary, we have demonstrated that: (1) CTng scales linearly with the input workload; (2) CTng can support MMDs on the order of minutes, with a good safety margin; and (3) the convergence time of CTng does not significantly increase due to an increase in the number of monitors. Most importantly, with erasure encoding, convergence time increases only mildly even as the number of tolerated faulty monitors grows. In contrast, CT incurs substantial overhead when tolerating additional faulty loggers.</p>

    <p class="text-gray-300">!<a href="img-5.jpeg">img-5.jpeg</a> (a) Varying number of monitors.</p>

    <p class="text-gray-300">!<a href="img-6.jpeg">img-6.jpeg</a> (b) Different number of monitor faults allowed.</p>

    <p class="text-gray-300">!<a href="img-7.jpeg">img-7.jpeg</a> (c) Different number of loggers.</p>

    <p class="text-gray-300">!<a href="img-8.jpeg">img-8.jpeg</a> (d) Different total precertificate workload. Fig. 4: System convergence time measured under four distinct experimental conditions.: (a) as the number of monitors varies, (b) as the number of monitor faults allowed changes, (c) for same total precertificate workload distributed among different number of loggers, and (d) for varying overall precertificate workloads. See Table IV for other values used.</p>

    <p class="text-gray-300">Several works focus on extending CT with an auditing mechanism; some of these also address the privacy risks associated with auditing. Examples include CT gossip [51], [48] and CTor [18], which enhance CT by integrating SCT auditing, STH gossiping, and conflict reporting to detect logger misbehavior in a timely manner. However, these mechanisms face scalability challenges as the number of participating entities grows. Other designs, such as [53], [23], [58], [31], emphasize privacy-preserving solutions for SCT auditing that account for the risk of a client's activity being revealed through either querying or reporting during the audit process.</p>

    <p class="text-gray-300">Vendor-assisted revocation mechanisms such as CRLsets [26] and OneCRL [25] improve upon traditional revocation methods by offering more scalable and reliable solutions. However, because these mechanisms cover only a small subset of revocations, they necessitate a fail-open model that allows the browser to accept a certificate when its revocation status is unknown [38]. In contrast, CRLite [38] further improves the efficiency by leveraging advanced data structures, specifically cascading Bloom filters, which enable browsers to cover the entire revocation space with acceptable overhead and support a fail-close model for revocation checks. Let's Revoke [57] enhances further the efficiency of revocation by encoding each certificate's revocation status</p>

    <p class="text-gray-300">using only a single bit, at the cost of requiring an additional Revocation Number (RN) extension in the certificate itself.</p>

    <p class="text-gray-300">Other works focus on ensuring security with robustness to up to  <span class="math">f</span>  rogue entities. In COCA [70], certificates must be co-signed by multiple CAs. ARPKI [5] extends this model by requiring additional synchronization across servers. A consensus model for CT logs, presented in [64], prevents log split-world attacks but introduces significant overhead. Furthermore, works such as [33], [3] leverage blockchain technology to achieve certificate and/or revocation transparency by completely decoupling these processes from traditional PKI entities like CAs. However, this approach requires a complete overhaul of the existing PKI system. Later work, such as [66], [22], takes a more incremental approach by introducing the concept of hybrid X.509 certificates, which can be validated using the classic CA chain of trust while embedding an X.509 extension containing fields necessary for blockchain-related operations. However, these works' approach still inherits several blockchain-related drawbacks, including the size of the blockchain and the fluctuating cost of maintaining it, both of which are closely tied to cryptocurrency market dynamics.</p>

    <p class="text-gray-300">Our PCB protocol builds on a large body of work in reliable broadcast, agreement, and consensus protocols (e.g., [36], [9], [37], [28]), as well as more recent efficient designs (e.g., [67], [68], [19]). PCB adopts several efficiency-driven ideas from</p>

    <p class="text-gray-300">these protocols, but it differs in key aspects due to the specific requirements of our setting. In particular, to the best of our knowledge, no existing protocol directly provides properties to satisfy CTng goals.</p>

    <p class="text-gray-300">In particular, consider the <em>guaranteed transparency</em> (G3) requirement, which dictates that each precertificate must be known to all benign monitors within a bounded delay. Meeting this requirement requires explicit bounds on both clock drift and communication delay, thereby ruling out fully asynchronous protocols. Even partially synchronous protocols such as <em>[68, 69, 70]</em> typically do not model or account for clock bias. Moreover, PCB incorporates a built-in mechanism for misbehavior detection and accusation (e.g., equivocation or omission), which is critical for achieving CTng’s NTTP-security goals.</p>

    <p class="text-gray-300">PCB shares structural similarities with leader-based consensus protocols like HotStuff <em>[68]</em>, in that only the originator proposes a value. However, unlike traditional leader-based protocols, the originator in PCB does not participate in the consensus phase.</p>

    <p class="text-gray-300">In contrast to Byzantine Fault Tolerant (BFT) consensus protocols, CTng requires only <em>weak consistency</em>, similar to the Crusader’s agreement <em>[36]</em>, so using a BFT protocol in place of PCB would incur unnecessary overhead. Specifically, let <span class="math">y</span> be the value output by an honest monitor. If any honest monitor outputs <span class="math">y^{\\prime}</span>, then <span class="math">y^{\\prime}=y</span> or <span class="math">y^{\\prime}=\\bot</span> (Proof of Misbehavior, PoM). If an honest monitor outputs <span class="math">\\bot</span> in round <span class="math">r</span>, then all honest monitors output <span class="math">\\bot</span> by the end of round <span class="math">r+1</span>. This relaxed agreement ensures that all benign monitors output timely updates when the originator is benign (within one MMD), and that they hold the originator accountable via PoM within two MMDs if it is faulty (due to equivocation or unresponsiveness).</p>

    <h2 id="sec-42" class="text-2xl font-bold">VIII Conclusions</h2>

    <p class="text-gray-300">We presented CTng, an evolutionary extension of CT and the current Web-PKI. CTng is a secure and efficient system that supports certificate transparency and ensures guaranteed, unequivocal revocation. It achieves the NTTP goal that originally motivated CT but has yet to be fully realized. We experimentally validated that a prototype of CTng has low overhead and modest requirements for all participating entities. We analyzed CTng and showed that CTng meets its NTTP-security and systems goals. We hope this work contributes to the much-needed improvements in the Web-PKI ecosystem, which forms the foundation for applied cryptographic protocols such as TLS, and that it encourages further research in this area. In particular, a provably secure and practically deployable version of CTng offers an exciting direction for future work.</p>

    <h3 id="sec-43" class="text-xl font-semibold mt-8">Acknowledgements</h3>

    <p class="text-gray-300">The authors are very grateful to Haitham Ghalwash, who contributed to the early work on CTng. We thank Federico Cedolini, Abhinna Adhikari, Eli Shattuck, Son Mana, Yonatan Cohen, Finn Navin, Isaac Teles, Marcus Barone, Millenia Polanco, Addison Cox, and Arvind Kasiliya for their work on the implementation of CTng, and DeterLab (Sphere Research Infrastructure) for providing testbed resources. This work is partially supported by the National Science Foundation under Grants No. 2149765 and 2247810, by the Research Authority Fund of the College of Management Academic Studies, Rishon LeZion, Israel, and by the endowment to Prof. Herzberg from the Comcast Corporation. The opinions expressed are those of the authors and do not necessarily reflect those of their universities or funding sources.</p>

    <h2 id="sec-44" class="text-2xl font-bold">References</h2>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[1] Certificate transparency logs. https://certificate.transparency.dev/logs/, 2025. Accessed: 20 March 2025.</li>

      <li>[2] Monitors – certificate transparency. https://certificate.transparency.dev/monitors/, 2025. Accessed: March 29, 2025.</li>

      <li>[3] Mustafa Al-Bassam. Scpki: A smart contract-based pki and identity system. In Proceedings of the ACM Workshop on Blockchain, Cryptocurrencies and Contracts, BCC ’17, page 35–40, New York, NY, USA, 2017. Association for Computing Machinery.</li>

      <li>[4] Andrew Ayer. Timeline of Certificate Authority Failures. https://sslmate.com/resources/certificate_authority_failures, 2018.</li>

      <li>[5] David Basin, Cas Cremers, Tiffany Hyun-Jin Kim, Adrian Perrig, Ralf Sasse, and Pawel Szalachowski. ARPKI: Attack Resilient Public-Key Infrastructure. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 382–393. ACM, 2014.</li>

      <li>[6] David Benjamin, Devon O’Brien, Bas Westerbaan, Luke Valenta, and Filippo Valsorda. Merkle Tree Certificates. Internet-Draft draft-davidben-tls-merkle-tree-certs-06, Internet Engineering Task Force, July 2025. Work in Progress.</li>

      <li>[7] Sharon Boeyen, Stefan Santesson, Tim Polk, Russ Housley, Stephen Farrell, and Dave Cooper. Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. RFC 5280, May 2008.</li>

      <li>[8] Luis Brandao and Rene Peralta. NIST first call for multi-party threshold schemes, March 2025. NIST internal report NISTIR 8214C 2pd, second public draft.</li>

      <li>[9] Miguel Castro and Barbara Liskov. Practical byzantine fault tolerance. In 3rd Symposium on Operating Systems Design and Implementation (OSDI 99), New Orleans, LA, February 1999. USENIX Association.</li>

      <li>[10] BLUE BOOK CCITT. Recommendations X. 509 and ISO 9594-8. Information Processing Systems-OSI-The Directory Authentication Framework (Geneva: CCITT), 1988.</li>

      <li>[11] Cloudflare. Merkle town — certificate transparency logs. https://ct.cloudflare.com/logs, 2024. Accessed: 2025-01-16.</li>

      <li>[12] Comodo™. Incident Report. Published online, http://www.comodo.com/Comodo-Fraud-Incident-2011-03-23.html, 3 2011.</li>

      <li>[13] D. Cooper, S. Santesson, S. Farrell, S. Boeyen, R. Housley, and W. Polk. Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile. RFC 5280 (Proposed Standard), May 2008. Updated by RFCs 6818, 8398, 8399.</li>

      <li>[14] David A Cooper, Daniel C Apon, Quynh H Dang, Michael S Davidson, Morris J Dworkin, Carl A Miller, et al. Recommendation for stateful hash-based signature schemes. NIST Special Publication, 800(208):800–208, 2020.</li>

      <li>[15] Council of European Union. Com/2021/281, Revision of the eIDAS Regulation - European Digital Identity (EUid), 2021.</li>

      <li>[16] Daniele Cozzo and Nigel P. smart. Sharing the luov: Threshold post-quantum signatures. Cryptology ePrint Archive, Paper 2019/1060, 2019. https://eprint.iacr.org/2019/1060.</li>

      <li>[17] Daniele Cozzo and Nigel P Smart. Sharing the luov: threshold post-quantum signatures. In IMA International Conference on Cryptography and Coding, pages 128–153. Springer, 2019.</li>

      <li>[18] Rasmus Dahlberg, Tobias Pulls, Tom Ritter, and Paul Syverson. Privacy-preserving & incrementally-deployable support for certificate transparency in tor. Proceedings on Privacy Enhancing Technologies, 2021(2):194–213, 2021.</li>

    </ul>

    <p class="text-gray-300">-</p>

    <p class="text-gray-300">[19] George Danezis, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegelman. Narwhal and tusk: a dag-based mempool and efficient bft consensus. In Proceedings of the Seventeenth European Conference on Computer Systems, EuroSys ’22, page 34–50, New York, NY, USA, 2022. Association for Computing Machinery.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[20] Joe DeBlasio. How does the certificate transparency check in chrome work?, Oct 2023.</li>

      <li>[21] Peter Eckersley. Sovereign Key Cryptography for Internet Domains. https://git.eff.org/?p=sovereign-keys.git;a=blob;f=sovereign-key-design.txt;hb=HEAD, 2012.</li>

      <li>[22] Yves Christian Elloh Adja, Badis Hammi, Ahmed Serhrouchni, and Sherali Zeadally. A blockchain-based certificate revocation management and status verification system. Computers & Security, 104:102209, 2021.</li>

      <li>[23] Saba Eskandarian, Eran Messeri, Joseph Bonneau, and Dan Boneh. Certificate transparency with privacy. Proceedings on Privacy Enhancing Technologies, 4:232–247, 2017.</li>

      <li>[24] Conner Fromknecht, Dragos Velicanu, and Sophia Yakoubov. A Decentralized Public Key Infrastructure with Identity Retention. IACR Cryptology ePrint Archive, 2014:803, 2014.</li>

      <li>[25] Mark Goodwin. Revoking intermediate certificates: Introducing OneCRL. Mozilla Security Blog, https://blog.mozilla.org/security/2015/03/03/revoking-intermediate-certificates-introducing-onecrl/, 3 2015.</li>

      <li>[26] Inc Google. Crlsets. https://www.chromium.org/Home/chromium-security/crlsets/.</li>

      <li>[27] Google Chrome. Certificate transparency policy. https://googlechrome. github.io/CertificateTransparency/ct_policy.html. Accessed: 20 March 2025.</li>

      <li>[28] Yue Guo, Rafael Pass, and Elaine Shi. Synchronous, with a chance of partition tolerance. In Advances in Cryptology – CRYPTO 2019: 39th Annual International Cryptology Conference, Santa Barbara, CA, USA, August 18–22, 2019, Proceedings, Part I, page 499–529, Berlin, Heidelberg, 2019. Springer-Verlag.</li>

      <li>[29] International Telecommunication Union. Recommendation ITU-T X.509, OSI – The Directory: Public-Key and Attribute Certificate Frameworks, 2016.</li>

      <li>[30] Jie Kong. CTngV3. https://github.com/jik18001/CTngV3, 2025.</li>

      <li>[31] Google LLC Joe DeBlasio. Opt-out SCT Auditing in Chrome. Other. https://docs.google.com/document/d/16G-Q7iN3kB46GSW5b-sfH5MO3nKSYyEb77YsM7TMZGE/.</li>

      <li>[32] Daniel Kales, Olamide Omolola, and Sebastian Ramacher. Revisiting user privacy for certificate transparency. In EuroS&P, pages 432–447. IEEE, 2019.</li>

      <li>[33] Brian Khieu and Melody Moh. Chpki: Cloud blockchain-based public key infrastructure. In Proceedings of the 2019 ACM Southeast Conference, ACMSE ’19, page 58–63, New York, NY, USA, 2019. Association for Computing Machinery.</li>

      <li>[34] Tiffany Hyun-Jin Kim, Lin-Shung Huang, Adrian Perrig, Collin Jackson, and Virgil Gligor. Accountable Key Infrastructure (AKI): A Proposal for a Public-Key Validation Infrastructure. In Proceedings of the 22nd international conference on World Wide Web, pages 679–690. ACM, 2013.</li>

      <li>[35] Murat Yasin Kubilay, Mehmet Sabir Kiraz, and Haci Ali Mantar. CertLedger: A new PKI model with Certificate Transparency based on blockchain. arXiv preprint arXiv:1806.03914, 2018.</li>

      <li>[36] L. Lamport. The weak byzantine generals problem. J. ACM, 30(3):668–676, July 1983.</li>

      <li>[37] Leslie Lamport. The part-time parliament. ACM Trans. Comput. Syst., 16(2):133–169, May 1998.</li>

      <li>[38] James Larisch, David R. Choffnes, Dave Levin, Bruce M. Maggs, Alan Mislove, and Christo Wilson. Crlite: A scalable system for pushing all tls revocations to all browsers. In IEEE Symposium on Security and Privacy, pages 539–556. IEEE Computer Society, 2017.</li>

      <li>[39] B. Laurie, A. Langley, and E. Kasper. Certificate Transparency. RFC 6962 (Experimental), June 2013. Obsoleted by RFC 9162.</li>

      <li>[40] B. Laurie, E. Messeri, and R. Stradling. Certificate Transparency Version 2.0. RFC 9162 (Experimental), December 2021.</li>

      <li>[41] Ben Laurie. Certificate transparency. Communications of the ACM, 57(10):40–46, 2014.</li>

      <li>[42] Ben Laurie and Emilia Kasper. Revocation Transparency. Google Research, September, 2012.</li>

      <li>[43] Wouter Lueks and Ian Goldberg. Sublinear scaling for multi-client private information retrieval. In Rainer Böhme and Tatsuaki Okamoto, editors, Financial Cryptography and Data Security - 19th International Conference, FC 2015, San Juan, Puerto Rico, January 26-30, 2015, Revised Selected Papers, volume 8975 of Lecture Notes in Computer Science, pages 168–186. Springer, 2015.</li>

      <li>[44] Laurane Marco, Abdullah Talayhan, and Serge Vaudenay. Making classical (threshold) signatures post-quantum for single use on a public ledger. In International Workshop on Security, pages 173–192. Springer, 2023.</li>

      <li>[45] Stephanos Matsumoto and Raphael M Reischuk. IKP: Turning a PKI Around with Decentralized Automated Incentives. In Security and Privacy (SP), 2017 IEEE Symposium on, pages 410–426. IEEE, 2017.</li>

      <li>[46] Marcela S Melara, Aaron Blankstein, Joseph Bonneau, Edward W Felten, and Michael J Freedman. CONIKS: Bringing Key Transparency to End Users. In USENIX Security Symposium, pages 383–398, 2015.</li>

      <li>[47] J. Mirkovic, T.V. Benzel, T. Faber, R. Braden, J.T. Wroclawski, and S. Schwab. The deter project: Advancing the science of cyber security experimentation and test. In Technologies for Homeland Security (HST), 2010 IEEE International Conference on, pages 1 –7, nov. 2010.</li>

      <li>[48] Linus Nordberg, Daniel Kahn Gillmor, and Tom Ritter. Gossiping in CT. Internet-Draft draft-ietf-trans-gossip-05, Internet Engineering Task Force, January 2018. Work in Progress.</li>

      <li>[49] National Institute of Standards and Technology (NIST). Module-lattice-based digital signature standard (draft), aug 2023.</li>

      <li>[50] National Institute of Standards and Technology (NIST). Stateless hash-based digital signature standard (fips 205), aug 2023. Based on the SPHINCS+ proposal.</li>

      <li>[51] Michael Oxford, David Parker, and Mark Ryan. Quantitative verification of certificate transparency gossip protocols. In 2020 IEEE Conference on Communications and Network Security (CNS), pages 1–9. IEEE, 2020.</li>

      <li>[52] JR Prins. DigiNotar Certificate Authority breach “Operation Black Tulip”, 2011.</li>

      <li>[53] Mark Dermot Ryan. Enhanced certificate transparency and end-to-end encrypted mail. In NDSS, 2014.</li>

      <li>[54] S. Santesson, M. Myers, R. Ankney, A. Malpani, S. Galperin, and C. Adams. X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP. RFC 6960 (Proposed Standard), June 2013. Updated by RFC 8954.</li>

      <li>[55] Nicolas Serrano, Hilda Hadan, and Jean L. Camp. A complete study of P.K.I. (PKI’s Known Incidents), 7 2019. Available at SSRN, https://ssrn.com/abstract=3425554.</li>

      <li>[56] Victor Shoup. Practical threshold signatures. In Bart Preneel, editor, EUROCRYPT, volume 1807 of Lecture Notes in Computer Science, pages 207–220. Springer, 2000.</li>

      <li>[57] Trevor Smith, Luke Dickenson, and Kent E. Seamons. Let’s revoke: Scalable global certificate revocation. In NDSS. The Internet Society, 2020.</li>

      <li>[58] Emily Stark and Chris Thompson. Opt-in sct auditing (public), 9 2020.</li>

      <li>[59] Ewa Syta, Iulia Tamas, Dylan Visher, David Isaac Wolinsky, and Bryan Ford. Certificate Cothority: Towards Trustworthy Collective CAs. Hot Topics in Privacy Enhancing Technologies (HotPETs), 7, 2015.</li>

      <li>[60] Ewa Syta, Iulia Tamas, Dylan Visher, David Isaac Wolinsky, Philipp Jovanovic, Linus Gasser, Nicolas Gailly, Ismail Khoffi, and Bryan Ford. Keeping Authorities “Honest or Bust” with Decentralized Witness Cosigning. In Security and Privacy (SP), 2016 IEEE Symposium on, pages 526–545. Ieee, 2016.</li>

      <li>[61] Pawel Szalachowski, Stephanos Matsumoto, and Adrian Perrig. PoliCert: Secure and Flexible TLS Certificate Management. In Proceedings of the 2014 ACM SIGSAC Conference on Computer and Communications Security, pages 406–417. ACM, 2014.</li>

      <li>[62] George Tasopoulos, Jinhui Li, Apostolos P. Fournaris, Raymond K. Zhao, Amin Sakzad, and Ron Steinfeld. Performance evaluation of&nbsp;post-quantum tls 1.3 on&nbsp;resource-constrained embedded systems. In Information Security Practice and Experience: 17th International Conference, ISPEC 2022, Taipei, Taiwan, November 23–25, 2022, Proceedings, page 432–451, Berlin, Heidelberg, 2022. Springer-Verlag.</li>

      <li>[63] Alin Tomescu and Srinivas Devadas. Catena: Efficient Non-equivocation via Bitcoin. In 2017 38th IEEE Symposium on Security and Privacy (SP), pages 393–409. IEEE, 2017.</li>

      <li>[64] Joel Wanner, Laurent Chuat, and Adrian Perrig. A formally verified protocol for log replication with byzantine fault tolerance. In 2020 International Symposium on Reliable Distributed Systems (SRDS), pages 101–112, 2020.</li>

      <li>[65] Sara Wrótniak, Hemi Leibowitz, Ewa Syta, and Amir Herzberg. Provable security for pki schemes. In Proceedings of the 2024 on ACM SIGSAC Conference on Computer and Communications Security, CCS</li>

    </ul>

    <p class="text-gray-300">’24, page 1552–1566, New York, NY, USA, 2024. Association for Computing Machinery.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[66] Alexander YAKUBOV, Wazen SHBAIR, Anders Wallbom, David Sanda, and Radu STATE. A blockchain-based pki management framework. In The First IEEE/IFIP International Workshop on Managing and Managed by Blockchain (Man2Block) colocated with IEEE/IFIP NOMS 2018, Tapei, Tawain 23-27 April 2018, 2018.</li>

      <li>[67] Lei Yang, Seo Jin Park, Mohammad Alizadeh, Sreeram Kannan, and David Tse. DispersedLedger: High-Throughput byzantine consensus on variable bandwidth networks. In 19th USENIX Symposium on Networked Systems Design and Implementation (NSDI 22), pages 493–512, Renton, WA, April 2022. USENIX Association.</li>

      <li>[68] Maofan Yin, Dahlia Malkhi, Michael K. Reiter, Guy Golan Gueta, and Ittai Abraham. Hotstuff: Bft consensus with linearity and responsiveness. In Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing, PODC ’19, page 347–356, New York, NY, USA, 2019. Association for Computing Machinery.</li>

      <li>[69] Jiangshan Yu, Vincent Cheval, and Mark Ryan. DTKI: A New Formalized PKI with Verifiable Trusted Parties. The Computer Journal, 59(11):1695–1713, 2016.</li>

      <li>[70] Lidong Zhou, Fred B. Schneider, and Robbert Van Renesse. Coca: A secure distributed online certification authority. ACM Trans. Comput. Syst., 20(4):329–368, nov 2002.</li>

    </ul>

    <h2 id="sec-45" class="text-2xl font-bold">Appendix A Post-Quantum Crypto-Ready CTng</h2>

    <p class="text-gray-300">Advances in quantum computing motivate the development of cryptographic protocols that remain secure even in the presence of quantum adversaries. Specifically, PKI, and CTng in particular, rely on the security of signatures, and the classical, widely deployed signature schemes, are vulnerable to a quantum adversary.</p>

    <p class="text-gray-300">A PQS scheme is a signature scheme which is believed to be secure even against a quantum adversary. Several PQS scheme were proposed, and some were standardized by NIST <em>[49, 50, 14, 44, 16]</em>). A naive way to make CTng secure against a quantum adversary, is to use it with a PQS scheme, instead of using a classical signature scheme (vulnerable to quantum attackers).</p>

    <p class="text-gray-300">However, most PQS proposals entail much higher resource demands compared to classical signature schemes: keys are significantly longer, signatures are significantly longer, and/or operations (signing and/or verifying) are significantly slower <em>[62]</em>. This motivates design of protocols which reduce the overhead of public key signatures and verification operations (which can be significantly slower, using PQS schemes, then their operation using quantum-vulnerable schemes), and, also, reduce the number of public keys distributed (since PQS schemes can have significantly longer keys). Furthermore, no post-quantum threshold signature scheme was standardized yet, although some papers proposed such schemes (e.g., <em>[17]</em>) and NIST is working on a standard <em>[8]</em>.</p>

    <p class="text-gray-300">The Merkle tree certificates proposal <em>[6]</em> is a recently-proposed alternative design for issuing certificates, which uses Merkle trees to reduce the overheads due to the use of signatures, mainly for efficient post-quantum certificate issuing and validation. The basic idea is that instead of signing each certificate separately, the CA will add new certificates to a Merkle tree, and periodically sign the root of the tree. The ‘signature’ on the certificate becomes the Proof-of-Inclusion (PoI) of it in the tree, plus the signature over the tree head. Relying parties can validate this single signature for all of the certificates in the tree, and then only need to validate the (hash-based) PoI for each specific certificate. The efficiency of this design is due to the fact that hash functions, including hash functions considered secure even against a quantum adversary, are much more efficient than signatures, especially compared to PQS schemes.</p>

    <p class="text-gray-300">In the rest of this subsection we explain how a similar design, allowing efficient use of PQS schemes, can be adopted in CTng. We explain the changes in the operations of each of the entities involved.</p>

    <p class="text-gray-300">CAs: A CA batches all certificates it issues during each MMD period into a Merkle tree whose leaves are the certificates. Near the end of the period, the CA signs the tree root (<span class="math">STH_{CA}</span>) and submits it to the logger. Each certificate’s signature field is then replaced by the signed root and its corresponding PoI, while all other CA functions remain unchanged. Note that the CA can also submit ‘regular’ certificates (not using Merkle tree), allowing co-existence.</p>

    <p class="text-gray-300">Logger: After validating the certificates against the <span class="math">STH_{CA}s</span> submitted by the CAs, each logger constructs its own Merkle tree, with the <span class="math">STH_{CA}s</span> as the leaves, and returns a PoI to each CA by the end of the MMD period. This reduces logger computation, as it generates only one PoI per <span class="math">STH_{CA}</span>, rather than one for every submitted certificate. Again, we note that the logger can continue to support ‘regular’ certificates in addition to the Merkle tree certificates; for efficiency, it may be better to place the <span class="math">STH_{CA}s</span> in a high level of the tree, ensuring shorter PoIs.</p>

    <p class="text-gray-300">Monitors and Relying Parties: While there are proposals for PQS threshold schemes <em>[17]</em> and an ongoing standardization effort <em>[8]</em>, it is possible that monitors will have to sign using a multiple-signature scheme. Considering that PQS schemes can have high overhead, this can cause significant overhead to the relying parties (for validation and communication). Notice, however, that the overhead is mostly due to the fact that in the CTng design, a separate threshold signature is used for the periodical update from every originator (logger and CA) separately. This overhead can be dramatically reduced, by modifying the design so that the monitors will sign only one message per period, containing the updates from all the loggers and the monitors. To do this, the monitors need to first reach a consensus—via an additional voting round—on the list of updates to be signed. This list includes valid updates (STHs and SRHs) and any Proofs of Misbehavior (PoMs) generated in each PCB round. This introduces reasonable additional overhead for the monitors, but allow the relying parties to validate only one threshold signature (or <span class="math">f+1</span> signatures of a non-threshold PQS scheme) per MMD period. This single threshold signature-validation per MMD allows the relying party to validate all of the required objects from all loggers and CAs. This should not be computationally challenging - even if using the least-efficient PQS scheme.</p>`;
---

<BaseLayout title="CTng: Secure Certificate and Revocation Transparency (2021/818)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2021 &middot; eprint 2021/818
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
