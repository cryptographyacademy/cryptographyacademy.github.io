---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2003/193';
const CRAWLER = 'mistral';
const CONVERTED_DATE = '2026-02-16';
const TITLE_HTML = 'Efficient Extension of Standard Schnorr/RSA signatures into Universal Designated-Verifier Signatures';
const AUTHORS_HTML = 'Ron Steinfeld, Huaxiong Wang, Josef Pieprzyk';

const CONTENT = `    <p class="text-gray-300">Ron Steinfeld, Huaxiong Wang, Josef Pieprzyk Dept. of Computing, Macquarie University, Australia {rons,hwang,josef}@ics.mq.edu.au</p>

    <h6 id="sec-2" class="text-base font-medium mt-4">Abstract</h6>

    <p class="text-gray-300">Universal Designated-Verifier Signature (UDVS) schemes are digital signature schemes with additional functionality which allows <em>any</em> holder of a signature to <em>designate</em> the signature to any desired <em>designated-verifier</em> such that the designated-verifier can verify that the message was signed by the signer, but is unable to convince anyone else of this fact.</p>

    <p class="text-gray-300">Since UDVS schemes reduce to standard signatures when no verifier designation is performed, it is natural to ask how to extend the classical Schnorr or RSA signature schemes into UDVS schemes, so that the existing key generation and signing implementation infrastructure for these schemes can be used without modification. We show how this can be efficiently achieved, and provide proofs of security for our schemes in the random oracle model.</p>

    <h2 id="sec-3" class="text-2xl font-bold">1 Introduction</h2>

    <p class="text-gray-300">Universal Designated-Verifier Signature (UDVS) schemes introduced by Steinfeld et al <em>[26]</em> are digital signature schemes with additional functionality which allows <em>any</em> holder of a signature to <em>designate</em> the signature to any desired <em>designated-verifier</em> such that the designated-verifier can verify that the message was signed by the signer, but is unable to convince anyone else of this fact, because the verifier’s secret key allows him to forge the designated-verifier signatures without the signer’s cooperation. Such signature schemes protect the privacy of signature holders from dissemination of signatures by verifiers, and have applications in certification systems <em>[26]</em>.</p>

    <p class="text-gray-300">The previous work <em>[26]</em> has shown how to construct efficient deterministic UDVS schemes from Bilinear group-pairs. However, since UDVS schemes reduce to standard signatures when no verifier designation is performed, it is natural to ask how to extend the classical Schnorr <em>[24]</em> or RSA <em>[22]</em> signature schemes into UDVS schemes, so that the existing key generation and signing implementation infrastructure for these schemes can be used without modification — the UDVS functionality can be added to such implementations as an optional feature. In this paper we show how this can be efficiently achieved, and provide concrete proofs of security for our schemes in the random oracle model <em>[2]</em>.</p>

    <p class="text-gray-300">As shown in <em>[26]</em>, any secure efficient construction of an unconditionally-private UDVS scheme with <em>unique signatures</em> (e.g. fully deterministic UDVS schemes with unique secret keys) gives rise to a secure efficient ID-Based Encryption (IBE) scheme. Constructing secure and efficient IBE schemes from classical Diffie-Hellman or RSA problems is a long-standing open problem <em>[3]</em>, and until this</p>

    <p class="text-gray-300">*This is the full version of a paper to appear in PKC 2004.</p>

    <p class="text-gray-300">problem is solved we also cannot hope to construct unconditionally-private UDVS schemes with unique signatures based on classical problems. However, the results in this paper show that by giving up the unique signature requirement and allowing randomization in either the signing (in the case of Schnorr signatures) or designation (in the case of RSA) algorithms, one can construct efficient UDVS schemes from classical problems. Although the UDVS schemes presented in this paper do not have unique signatures, they still achieve perfect unconditional privacy in the sense of <em>[26]</em>.</p>

    <p class="text-gray-300">The proofs of all theorems in the paper are included in the Appendix.</p>

    <h3 id="sec-4" class="text-xl font-semibold mt-8">1.1 Related Work</h3>

    <p class="text-gray-300">As pointed out in <em>[26]</em>, the concept of UDVS schemes can be viewed as an application of the general idea of <em>designated-verifier proofs</em>, introduced by Jakobsson, Sako and Impagliazzo <em>[15]</em>, where a prover non-interactively designates a proof of a statement to a verifier, in such a way that the verifier can simulate the proof by himself with his secret key and thus cannot transfer the proof to convince anyone else about the truth of the statement, yet the verifier himself is convinced by the proof. The distinctive feature of UDVS schemes is <em>universal</em> designation: <em>anyone</em> who obtains a signature can designate it.</p>

    <p class="text-gray-300">Two of our proposed UDVS schemes (namely <span class="math">\\mathsf{SchUDVS}_{2}</span> and <span class="math">\\mathsf{RSAUDVS}</span>) make use of the paradigm in <em>[15]</em> of using a trapdoor commitment in a non-interactive proof of knowledge to achieve verifier designation. Since the underlying construction techniques used in these schemes is known, we view our main contribution here is in providing a concrete security analysis which bounds the insecurity of these schemes in terms of the underlying primitives. Our third proposed scheme <span class="math">\\mathsf{SchUDVS}_{1}</span> shows an alternative and more efficient approach than the paradigm of <em>[15]</em>, for extending the Schnorr signature scheme into a UDVS scheme, using the Diffie-Hellman function. It is an analogoue of the the bilinear-based approach for constructing UDVS schemes proposed in <em>[26]</em>.</p>

    <p class="text-gray-300">Besides providing UDVS schemes based on classical problems, another contribution of this paper is in defining a stronger unforgeability notion for UDVS schemes, which allows the forger access to the attacked designated verifier’s verification oracle, as well as to the signer’s signing oracle (whereas the model in <em>[26]</em> only allows access to the signing oracle). We analyse our schemes in this stronger model.</p>

    <p class="text-gray-300">There have been other approaches proposed to address the privacy threat associated with dissemination of verifiable signed documents. Chaum and van Antwerpen <em>[9, 7]</em> introduced undeniable signatures for this purpose, which require a signer or confirmer’s <em>[8, 18, 17, 6, 12]</em> interactive cooperation to verify a signature, but this approach places significant inconvenience and workload on verifiers and confirmers, compared to an off-line non-interactive verification. The work of Brands on <em>digital credentials</em> <em>[5, 4]</em> suggests further approaches to enhance user privacy, such as <em>selective disclosure</em> of attributes (see also <em>[27]</em>) and <em>unlinkability</em> of user transactions. Chameleon signatures <em>[16]</em> allow designation of signatures to verifiers by the <em>signer</em>, and in addition allow a signer to prove a forgery by a designated verifier. Ring signatures <em>[21]</em>, when restricted to two users, can also be viewed as designated-verifier signatures, where one user is the actual signer and the other user is the designated-verifier who can also forge the two-user ring signature, thus providing the privacy property, called <em>signer anonymity</em> in the context of ring signatures. However, signer designation is still performed by the <em>signer</em> in these schemes.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">2 Preliminaries</p>

    <h3 id="sec-5" class="text-xl font-semibold mt-8">2.1 Algorithms and Probability Notation</h3>

    <p class="text-gray-300">We say that a function <span class="math">f:\\mathds{N}\\to\\mathds{R}</span> is a <em>negligible</em> function if, for any <span class="math">c&gt;0</span>, there exists <span class="math">k_{0}\\in\\mathds{N}</span> such that <span class="math">f(k)&lt;1/k^{c}</span> for all <span class="math">k&gt;k_{0}</span>. We say that a probability function <span class="math">p:\\mathds{N}\\to\\mathds{R}</span> is <em>overwhelming</em> if the function <span class="math">q:\\mathds{N}\\to\\mathds{R}</span> defined by <span class="math">q(k)=1-p(k)</span> is a negligible function. For various algorithms discussed, we will define a sequence of integers to measure the <em>resources</em> of these algorithms (e.g. running-time plus program length, number of oracle queries to various oracles). All these resource parameters can in general be functions of a <em>security parameter</em> <span class="math">k</span> of the scheme. We say that an algorithm A with resource parameters <span class="math">RP=(r_{1},\\ldots,r_{n})</span> is <em>efficient</em> if each resource parameter <span class="math">r_{i}(k)</span> of A is bounded by a polynomial function of the security parameter <span class="math">k</span>, i.e. there exists a <span class="math">k_{0}&gt;0</span> and <span class="math">c&gt;0</span> such that <span class="math">r_{i}(k)&lt;k^{c}</span> for all <span class="math">k&gt;k_{0}</span>.</p>

    <h3 id="sec-6" class="text-xl font-semibold mt-8">2.2 Discrete-Log and Diffie-Hellman Problems</h3>

    <p class="text-gray-300">Our schemes use the following known hard problems for their security. For all these problems GC denotes an algorithm that on input a security parameter <span class="math">k</span>, returns an instance <span class="math">(D_{G},g)</span> of a multiplicative group <span class="math">G</span> of prime order <span class="math">q</span> with generator <span class="math">g</span> (the description string <span class="math">D_{G}</span> determines the group and contains the group order <span class="math">q</span>).</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Discrete-Log Problem (DL) <em>[10]</em>: Given <span class="math">(D_{G},g)=\\mathsf{GC}(k)</span> and <span class="math">y_{1}=g^{x_{1}}</span> for uniformly random <span class="math">x_{1}\\in\\mathds{Z}_{q}</span>, compute <span class="math">x_{1}</span>. We say that DL is <em>hard</em> if the success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A,DL}}(k)</span> of any efficient DL algorithm A with run-time <span class="math">t(k)</span> is upper-bounded by a negligible function <span class="math">\\mathbf{InSec}_{\\mathsf{DL}}(t)</span> of <span class="math">k</span>.</li>

      <li>Computational Diffie-Hellman Problem (CDH) <em>[10]</em>: Given <span class="math">(D_{G},g)=\\mathsf{GC}(k)</span>, <span class="math">y_{1}=g^{x_{1}}</span> and <span class="math">y_{2}=g^{x_{2}}</span> for uniformly random <span class="math">x_{1},x_{2}\\in\\mathds{Z}_{q}</span>, compute <span class="math">\\mathsf{CDH}_{g}(g^{x_{1}},g^{x_{2}})\\stackrel{{\\scriptstyle\\rm def}}{{=}}g^{x_{1}x_{2}}</span>. We say that CDH is <em>hard</em> if the success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A,CDH}}(k)</span> of any efficient CDH algorithm A with run-time <span class="math">t(k)</span> is upper-bounded by a negligible function <span class="math">\\mathbf{InSec}_{\\mathsf{CDH}}(t)</span> in <span class="math">k</span>.</li>

      <li>Strong Diffie-Hellman Problem (SDH) <em>[1, 19]</em>: Given <span class="math">(D_{G},g)=\\mathsf{GC}(k)</span>, <span class="math">y_{1}=g^{x_{1}}</span> and <span class="math">y_{2}=g^{x_{2}}</span> for uniformly random <span class="math">x_{1},x_{2}\\in\\mathds{Z}_{q}</span>, compute <span class="math">g^{x_{1}x_{2}}</span> given access to a restricted Decision Diffie-Hellman (DDH) oracle <span class="math">\\mathsf{DDH}_{x_{1}}(.,.)</span>, which on input <span class="math">(w,K)\\in G\\times G</span>, returns <span class="math">1</span> if <span class="math">K=w^{x_{1}}</span> and <span class="math">0</span> else. We say that SDH is <em>hard</em> if the success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A,SDH}}(k)</span> of any efficient SDH algorithm A with run-time <span class="math">t(k)</span> and which makes up to <span class="math">q(k)</span> queries to <span class="math">\\mathsf{DDH}_{x_{1}}(.,.)</span>, is upper-bounded by a negligible function <span class="math">\\mathbf{InSec}_{\\mathsf{SDH}}(t,q)</span> in <span class="math">k</span>.</li>

    </ol>

    <p class="text-gray-300">We remark that the Strong Diffie-Hellman problem (SDH) as defined above and in <em>[1]</em> is a potentially harder variant of the Gap Diffie-Hellman (GDH) problem as defined in <em>[19]</em>. The difference between the two problems is in the DDH oracle: In the GDH problem the DDH oracle accepts <em>four</em> inputs <span class="math">(h,z_{1},z_{2},K)</span> from the attacker and decides whether <span class="math">K=\\mathsf{CDH}_{h}(z_{1},z_{2})</span>, whereas in the SDH problem the attacker can only control the <span class="math">(z_{2},K)</span> inputs to the DDH oracle and the other two are fixed to the values <span class="math">h=g</span> and <span class="math">z_{1}=y_{1}</span> (we call this weaker oracle a <em>restricted</em> DDH oracle).</p>

    <p class="text-gray-300">###</p>

    <p class="text-gray-300">2.3 Trapdoor Hash Functions</p>

    <p class="text-gray-300">Some of our proposed UDVS schemes make use of a general cryptographic scheme called a <em>trapdoor hash function</em>. We recall the definition and security notions for such schemes <em>[25]</em>. A trapdoor hash function scheme consists of three efficient algorithms: a <em>key generation</em> algorithm GKF, a <em>hash function evaluation</em> algorithm <span class="math">F</span>, and a <em>collision solver</em> algorithm CSF. On input a security parameter <span class="math">k</span>, the (randomized) key-gen. algorithm GKF<span class="math">(k)</span> outputs a secret/public-key pair <span class="math">(sk,pk)</span>. On input a public-key <span class="math">pk</span>, message <span class="math">m\\in M</span> and random <span class="math">r\\in R</span> (Here <span class="math">M</span> and <span class="math">R</span> are the message and randomness spaces, respectively), the hash function evaluation algorithm outputs a hash string <span class="math">h=F_{pk}(m;r)\\in H</span> (here <span class="math">H</span> is the hash string space). On input a key-pair <span class="math">(sk,pk)</span>, a message/randomizer pair <span class="math">(m_{1},r_{1})\\in M\\times R</span> and a second message <span class="math">m_{2}\\in M</span>, the collision solver algorithm outputs a second randomizer <span class="math">r_{2}=\\mathsf{CSF}((sk,pk),(m_{1},r_{1}),m_{2})\\in R</span> such that <span class="math">(m_{1},r_{1})</span> and <span class="math">(m_{2},r_{2})</span> constitute a collision for <span class="math">F_{pk}</span>, i.e. <span class="math">F_{pk}(m_{1};r_{1})=F_{pk}(m_{2};r_{2})</span>.</p>

    <p class="text-gray-300">There are two desirable security properties for a trapdoor hash function scheme <span class="math">\\mathsf{TH}=(\\mathsf{GKF},F,\\mathsf{CSF})</span>. The scheme TH is called <em>collision-resistant</em> if the success probability <span class="math">\\mathbf{Succ}^{\\mathsf{CR}}_{\\mathsf{A},\\mathsf{TH}}</span> of any efficient attacker A in the following game is negligible. A key-pair <span class="math">(sk,pk)=\\mathsf{GKF}(k)</span> is generated, and A is given <span class="math">k</span> and the public-key <span class="math">pk</span>. A can run for time <span class="math">t</span> and succeeds if it outputs a collision <span class="math">(m_{1},r_{1})</span> and <span class="math">(m_{2},r_{2})</span> for <span class="math">F_{pk}</span> satisfying <span class="math">F_{pk}(m_{1},r_{1})=F_{pk}(m_{2},r_{2})</span> and <span class="math">m_{1}\\neq m_{2}</span>. We denote by <span class="math">\\mathbf{InSec}^{\\mathsf{CR}}_{\\mathsf{TH}}(t)</span> the maximal success probability in above game over all attackers A with run-time plus program length at most <span class="math">t</span>. The scheme TH is called <em>perfectly-trapdoor</em> if it has the following property: for each key-pair <span class="math">(sk,pk)=\\mathsf{GKF}(k)</span> and message pair <span class="math">(m_{1},m_{2})\\in M\\times M</span>, if <span class="math">r_{1}</span> is chosen uniformly at random from <span class="math">R</span>, then <span class="math">r_{2}\\overset{\\text{def}}{=}\\mathsf{CSF}((sk,pk),(m_{1},r_{1}),m_{2})\\in R</span> has a uniform probability distribution on <span class="math">R</span>.</p>

    <h6 id="sec-7" class="text-base font-medium mt-4">Remark 1.</h6>

    <p class="text-gray-300">Several examples of trapdoor hash function schemes are given in <em>[25]</em>. To make the UDVS scheme <span class="math">\\mathsf{SchUDVS}_{2}</span> provably secure based on the discrete-log assumption, one can use the following simple trapdoor hash function scheme <span class="math">\\mathsf{TH}_{\\mathsf{DL}}</span>, similar to that given in <em>[25]</em>. Let <span class="math">h:\\{0,1\\}^{<em>}\\to\\mathsf{Z}_{q}</span> be any collision-resistant hash function. The key gen. algorithm GKF chooses a group <span class="math">G</span> of prime order <span class="math">q</span> and outputs key-pair <span class="math">sk=(D_{G},g,x)</span> and <span class="math">pk=(D_{G},g,y)</span> where <span class="math">x</span> is random in <span class="math">\\mathsf{Z}_{q}^{</em>}</span> and <span class="math">y=g^{x}\\in G</span> (here <span class="math">D_{G}</span> is description string for group <span class="math">G</span>, including the prime group order <span class="math">q</span>). On input the public key <span class="math">pk</span>, and message/randomizer pair <span class="math">(m,r)\\in\\{0,1\\}^{*}\\times\\mathsf{Z}_{q}</span>, the evaluation algorithm computes the hash <span class="math">h_{s}=F_{pk}(m;r)=g^{h(m)}\\cdot y^{r}\\in G</span>. On input <span class="math">(sk,pk)</span> and <span class="math">(m_{1},r_{1},m_{2})</span>, the collision solver outputs <span class="math">r_{2}=r_{1}+(h(m_{1})-h(m_{2}))\\cdot x^{-1}\\bmod q</span>. The scheme <span class="math">\\mathsf{TH}_{\\mathsf{DL}}</span> is collision-resistant as long as <span class="math">h</span> is collision-resistant and the discrete-log is hard in <span class="math">G</span>. <span class="math">\\mathsf{TH}_{\\mathsf{DL}}</span> is also perfectly-trapdoor.</p>

    <h2 id="sec-8" class="text-2xl font-bold">3 Universal Designated-Verifier Signature (UDVS) Schemes</h2>

    <p class="text-gray-300">We review the definition of UDVS schemes and their security notions <em>[26]</em>. For unforgeability we also introduce a stronger notion of security than used in <em>[26]</em>.</p>

    <p class="text-gray-300">A Universal Designated Verifier Signature (UDVS) scheme DVS consists of seven algorithms and a ‘Verifier Key-Registration Protocol’ <span class="math">\\mathsf{P}_{\\mathsf{KR}}</span>. All these algorithms may be randomized.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Parameter Generation GC — on input a security parameter <span class="math">k</span>, outputs a string consisting of common scheme parameters <span class="math">cp</span> (publicly shared by all users).</li>

      <li>Signer Key Generation GKS — on input a common parameter string <span class="math">cp</span>, outputs a secret/public key-pair <span class="math">(sk_{1},pk_{1})</span> for <em>signer</em>.</li>

      <li>Verifier Key Generation GKV — on input a common parameter string <span class="math">cp</span>, outputs a secret/public key-pair <span class="math">(sk_{3},pk_{3})</span> for <em>verifier</em>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing S — on input signing secret key <span class="math">sk_{1}</span>, message <span class="math">m</span>, outputs <em>signer</em>’s publicly-verifiable (PV) signature <span class="math">\\sigma</span>.</li>

      <li>Public Verification V — on input <em>signer</em>’s public key <span class="math">pk_{1}</span> and message/PV-signature pair <span class="math">(m,\\sigma)</span>, outputs verification decision <span class="math">d\\in\\{Acc,Rej\\}</span>.</li>

      <li>Designation CDV — on input a <em>signer</em>’s public key <span class="math">pk_{1}</span>, a <em>verifier</em>’s public key <span class="math">pk_{3}</span> and a message/PV-signature pair <span class="math">(m,\\sigma)</span>, outputs a designated-verifier (DV) signature <span class="math">\\widehat{\\sigma}</span>.</li>

      <li>Designated Verification VDV — on input a <em>signer</em>’s public key <span class="math">pk_{1}</span>, <em>verifier</em>’s secret key <span class="math">sk_{3}</span>, and message/DV-signature pair <span class="math">(m,\\widehat{\\sigma})</span>, outputs verification decision <span class="math">d\\in\\{Acc,Rej\\}</span>.</li>

      <li>Verifier Key-Registration P_{KR} = (KRA,VER) — a protocol between a ‘Key Registration Authority’ (KRA) and a ‘Verifier’ (VER) who wishes to register a verifier’s public key. On common input <span class="math">cp</span>, the algorithms KRA and VER interact by sending messages alternately from one to another. At the end of the protocol, KRA outputs a pair <span class="math">(pk_{3},Auth)</span>, where <span class="math">pk_{3}</span> is a verifier’s public-key, and <span class="math">Auth\\in\\{Acc,Rej\\}</span> is a key-registration authorization decision. We write <span class="math">P_{KR}(\\textsf{KRA},\\textsf{VER})=(pk_{3},Auth)</span> to denote this protocol’s output.</li>

    </ol>

    <p class="text-gray-300"><em>Verifier Key-Reg. Protocol.</em> The purpose of the ‘Verifier Key-Registration’ protocol is to force the verifier to ‘know’ the secret-key corresponding to his public-key, in order to enforce the non-transferability privacy property. In this paper we assume, following <em>[26]</em>, the <em>direct</em> key reg. protocol, in which the verifier simply reveals his secret key to the KRA.</p>

    <p class="text-gray-300"><em>Consistent UDVS Schemes.</em> The ‘PV-Consistency’ property requires that the PV-signatures produced by the <em>signer</em> are accepted as valid by the PV-verification algorithm V. The ‘DV-Consistency’ property requires that the DV-signatures produced by the <em>designator</em> using the designation algorithm CDV are accepted as valid by the DV-verification algorithm VDV. A UDVS scheme is <em>consistent</em> if it has both of the above consistency properties.</p>

    <h3 id="sec-9" class="text-xl font-semibold mt-8">3.1 Unforgeability</h3>

    <p class="text-gray-300">In the case of a UDVS scheme there are actually two types of unforgeability properties to consider. The first property, called called ‘PV-Unforgeability’, is just the usual existential unforgeability notion under chosen-message attack <em>[13]</em> for the standard PV signature scheme <span class="math">D=(\\textsf{GC},\\textsf{GKS},\\textsf{S},\\textsf{V})</span> induced by the UDVS scheme (this prevents attacks to fool the <em>designator</em>). The second property, called ‘DV-Unforgeability’, requires that it is difficult for an attacker to forge a DV-signature <span class="math">\\widehat{\\sigma}^{<em>}</span> by the signer on a ‘new’ message <span class="math">m^{</em>}</span>, such that the pair <span class="math">(m^{<em>},\\widehat{\\sigma}^{</em>})</span> passes the DV-verification test with respect to a given designated-verifier’s public key <span class="math">pk_{3}</span> (this prevents attacks to fool the designated verifier, possibly mounted by a dishonest designator). As pointed out in <em>[26]</em>, it is sufficient to prove the DV unforgeability of a UDVS scheme, since the ‘DV-unforgeability’ property implies the ‘PV-unforgeability’ property.</p>

    <p class="text-gray-300">In this paper we introduce a stronger version of DV-unforgeability than used in <em>[26]</em>, which we call ST-DV-UF. This model allows the forger also access to the verification oracle of the designated-verifier (this oracle may help the forger because it uses the designated-verifier’s secret key, which in turn can be used to forge DV signatures, as required by the privacy property). Note that the model in <em>[26]</em> does not provide this oracle. We believe it is desirable for UDVS schemes to be secure even under such attacks, and place no restrictions on the attacker in accessing the verifier’s oracle — in particular the attacker can control both the message/DV sig. pair as well as the signer’s public key in accessing this oracle. We remark (proof omitted) that the <em>strong</em> DV-unforgeability of the UDVS scheme in <em>[26]</em> follows (in the random-oracle model) from the hardness of a <em>gap</em> version of the Bilinear Diffie-Hellman</p>

    <p class="text-gray-300">(BDH) problem, in which the attacker has access to a BDH decision oracle (whereas just hardness of BDH suffices for this scheme to achieve the weaker DV-unforgeability notion in <em>[26]</em>).</p>

    <h6 id="sec-10" class="text-base font-medium mt-4">Definition 3.1 (Strong DV-Unforgeability).</h6>

    <p class="text-gray-300">Let <span class="math">\\mathsf{DVS}=(\\mathsf{GC},\\mathsf{GKS},\\mathsf{GKV},\\mathsf{S},\\mathsf{V},\\mathsf{CDV},\\mathsf{VDV},\\mathsf{P}_{\\mathsf{KR}})</span> be a UDVS scheme. Let <span class="math">\\mathsf{A}</span> denote a forger attacking the unforgeability of <span class="math">\\mathsf{DVS}</span>. The Strong DV-Unforgeability notion ST-UF-DV for this scheme is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Attacker Input: Signer and Verifier’s public-keys <span class="math">(pk_{1},pk_{3})</span> (where <span class="math">(sk_{1},pk_{1})=\\mathsf{GKS}(cp)</span>, <span class="math">(sk_{3},pk_{3})=\\mathsf{GKV}(cp)</span> and <span class="math">cp=\\mathsf{GC}(k)</span>).</li>

      <li>Attacker Resources: Run-time plus program-length at most <span class="math">t</span>, Oracle access to signer’s signing oracle <span class="math">\\mathsf{S}(sk_{1},.)</span> (<span class="math">q_{s}</span> queries), oracle access to designated-verifier’s verification oracle <span class="math">\\mathsf{VDV}(.,sk_{3},.,.)</span> (<span class="math">q_{v}</span> queries) and, if scheme <span class="math">\\mathsf{DVS}</span> makes use of <span class="math">n</span> random oracles <span class="math">RO_{1},\\ldots,RO_{n}</span>, allow <span class="math">q_{RO_{i}}</span> queries to the <span class="math">i</span>th oracle <span class="math">RO_{i}</span> for <span class="math">i=1,\\ldots,n</span>. We write attacker’s Resource Parameters (RPs) as <span class="math">RP=(t,q_{s},q_{v},q_{RO_{1}},\\ldots,q_{RO_{n}})</span>.</li>

      <li>Attacker Goal: Output a forgery message/DV-signature pair <span class="math">(m^{<em>},\\widehat{\\sigma}^{</em>})</span> such that:</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>The forgery is valid, i.e. <span class="math">\\mathsf{VDV}(pk_{1},sk_{3},m^{<em>},\\widehat{\\sigma}^{</em>})=Acc</span>.</li>

      <li>Message <span class="math">m^{*}</span> is ‘new’, i.e. has not been queried by attacker to <span class="math">\\mathsf{S}</span>.</li>

      <li>Security Notion Definition: Scheme is said to be <em>unforgeable</em> in the sense of ST-UF-DV if, for any efficient attacker <span class="math">\\mathsf{A}</span>, the probability <span class="math">\\mathbf{Succ}_{\\mathsf{A},\\mathsf{DVS}}^{\\mathrm{ST-UF-DV}}(k)</span> that <span class="math">\\mathsf{A}</span> succeeds in achieving above goal is a negligible function of <span class="math">k</span>. We quantify the insecurity of <span class="math">\\mathsf{DVS}</span> in the sense of ST-UF-DV against arbitrary attackers with resource parameters <span class="math">RP=(t,q_{s},q_{v},q_{RO_{1}},\\ldots,q_{RO_{n}})</span> by the probability</li>

    </ol>

    <p class="text-gray-300"><span class="math">\\mathbf{InSec}_{\\mathsf{DVS}}^{\\mathrm{ST-UF-DV}}(t,q_{s},q_{v},q_{RO_{1}},\\ldots,q_{RO_{n}})\\overset{\\mathrm{def}}{=}\\max_{\\mathsf{A}\\in AS_{RP}}\\mathbf{Succ}_{\\mathsf{A},\\mathsf{DVS}}^{\\mathrm{ST-UF-DV}}(k),</span></p>

    <p class="text-gray-300">where the set <span class="math">AS_{RP}</span> contains all attackers with resource parameters <span class="math">RP</span>.</p>

    <h3 id="sec-11" class="text-xl font-semibold mt-8">3.2 Non-Transferability Privacy</h3>

    <p class="text-gray-300">Informally, the purpose of the privacy property for a UDVS scheme is to prevent a designated-verifier from using the DV signature <span class="math">\\sigma_{dv}</span> on a message <span class="math">m</span> to produce evidence which convinces a third-party that the message <span class="math">m</span> was signed by the signer. The privacy is achieved because the designated-verifier can forge DV signatures using his secret-key, so even if the designated-verifier reveals his secret key to the third-party, the third-party cannot distinguish whether a DV signature was produced by the designator or forged by the designated-verifier.</p>

    <p class="text-gray-300">We review the privacy model from <em>[26]</em>. The attacker is modelled as a pair of interacting algorithms <span class="math">(\\mathsf{A_{1}},\\mathsf{A_{2}})</span> representing the designated-verifier (DV) and Third-Party (TP), respectively. Let <span class="math">\\widehat{\\mathsf{A_{1}}}</span> denote a forgery strategy. The goal of <span class="math">\\mathsf{A_{2}}</span> is to distinguish whether it is interacting with <span class="math">\\mathsf{A_{1}}</span> who has access to designated signatures (game yes) or with <span class="math">\\widehat{\\mathsf{A_{1}}}</span>, who doesn’t have access to designated signatures (game no). More precisely, the game yes runs in two stages as follows.</p>

    <p class="text-gray-300"><em>Stage 1.</em> <span class="math">(\\mathsf{A_{1}},\\mathsf{A_{2}})</span> are run on input <span class="math">pk_{1}</span>, where <span class="math">(sk_{1},pk_{1})=\\mathsf{GKS}(cp)</span> and <span class="math">cp=\\mathsf{GC}(k)</span>. In this stage, <span class="math">\\mathsf{A_{1}}</span> has access to: (1) signing oracle <span class="math">\\mathsf{S}(sk_{1},.)</span>, (2) <span class="math">\\mathsf{KRA}</span> key-reg. oracle to register verifier public keys <span class="math">pk</span> via <span class="math">P_{KR}</span> interactions, (3) <span class="math">\\mathsf{A_{2}}</span> oracle for querying a message to <span class="math">\\mathsf{A_{2}}</span> and receiving a response. At end of stage 1, <span class="math">\\mathsf{A_{1}}</span> outputs a message <span class="math">m^{<em>}</span> not queried to <span class="math">\\mathsf{S}</span> during the game (<span class="math">m^{</em>}</span> is given to <span class="math">\\mathsf{A_{2}}</span>). Let <span class="math">\\sigma^{<em>}=\\mathsf{S}(sk_{1},m^{</em>})</span>.</p>

    <p class="text-gray-300"><em>Stage 2.</em> <span class="math">\\mathsf{A_{1}}</span> continues to make <span class="math">\\mathsf{S},\\mathsf{KRA}</span> and <span class="math">\\mathsf{A_{2}}</span> queries as in stage 1, but also has access to a designation oracle <span class="math">\\mathsf{CDV}(pk_{1},.,m^{<em>},\\sigma^{</em>})</span> which it can query with any verifier public-key <span class="math">pk</span> which was answered <span class="math">Acc</span> by a previous <span class="math">\\mathsf{KRA}</span> key-reg. query. At end of stage 2, <span class="math">\\mathsf{A_{2}}</span> outputs a decision <span class="math">d\\in\\{\\mathsf{yes},\\mathsf{no}\\}</span>.</p>

    <p class="text-gray-300">##</p>

    <p class="text-gray-300">The game no is defined in the same way except that (1) <span class="math">\\mathsf{A}_1</span> is replaced by <span class="math">\\widehat{\\mathsf{A}_1}</span>, (2) <span class="math">\\widehat{\\mathsf{A}_1}</span> receives as input <span class="math">pk_1</span> and the program for <span class="math">\\mathsf{A}_1</span>, (3) <span class="math">\\widehat{\\mathsf{A}_1}</span> cannot make any designation queries.</p>

    <p class="text-gray-300"><strong>Definition 3.2 (PR-Privacy[26]).</strong> Let <span class="math">\\mathsf{DVS} = (\\mathsf{GC},\\mathsf{GKS},\\mathsf{GKV},\\mathsf{S},\\mathsf{V},\\mathsf{CDV},\\mathsf{VDV},\\mathsf{P}_{\\mathsf{KR}})</span> be a UDVS scheme. Let <span class="math">(\\mathsf{A}_1,\\mathsf{A}_2)</span> denote an attack pair against the privacy of DVS. Let <span class="math">\\widehat{\\mathsf{A}_1}</span> denote a forgery strategy. The privacy notion PR for this scheme is defined as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Attacker Input:</strong> Signer public-key <span class="math">pk_1</span> (where <span class="math">(sk_1, pk_1) = \\mathsf{GKS}(cp)</span>, and <span class="math">cp = \\mathsf{GC}(k)</span>). Note that <span class="math">\\widehat{\\mathsf{A}_1}</span> also accepts the program for <span class="math">\\mathsf{A}_1</span> as input.</li>

      <li><strong>Resources for <span class="math">(\\mathsf{A}_1, \\widehat{\\mathsf{A}_1})</span>:</strong> Run-time <span class="math">(t_1, \\widehat{t_1})</span>, access to signing oracle <span class="math">\\mathsf{S}(sk_1, .)</span> (up to <span class="math">(q_s, \\widehat{q}_s)</span> queried messages different from <span class="math">m^<em></span>), access to key-reg. protocol interactions with the KRA (up to <span class="math">(q_k, \\widehat{q}_k)</span> interactions), access to <span class="math">\\mathsf{A}_2</span> oracle (up to <span class="math">(q_c, \\widehat{q}_c)</span> messages). In stage 2, <span class="math">\\mathsf{A}_1</span> also has access to designation oracle <span class="math">\\mathsf{CDV}(pk_1, ., m^</em>, \\sigma^<em>)</span> (up to <span class="math">q_d</span> queried keys successfully registered with KRA), where <span class="math">\\sigma^</em> = \\mathsf{S}(sk_1, m^<em>)</span> is a signer's signature on the challenge message <span class="math">m^</em></span> output by <span class="math">\\mathsf{A}_1</span> at end of Stage 1. Note that <span class="math">\\widehat{\\mathsf{A}_1}</span> cannot make any designation queries.</li>

      <li><strong>Resources for <span class="math">\\mathsf{A}_2</span>:</strong> Run-time <span class="math">t_2</span>.</li>

    </ol>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">4. <strong>Attacker Goal:</strong> Let <span class="math">P(\\mathsf{A}_1, \\mathsf{A}_2)</span> and <span class="math">P(\\widehat{\\mathsf{A}_1}, \\mathsf{A}_2)</span> denote the probabilities that <span class="math">\\mathsf{A}_2</span> outputs yes when interacting with <span class="math">\\mathsf{A}_1</span> (game yes) and <span class="math">\\widehat{\\mathsf{A}_1}</span> (game no), respectively. The goal of <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> is to achieve a non-negligible convincing measure $C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1, \\mathsf{A}_2) \\stackrel{\\mathrm{def}}{=}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">P(\\mathsf{A}_1, \\mathsf{A}_2) - P(\\widehat{\\mathsf{A}_1}, \\mathsf{A}_2)</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><strong>Security Notion Definition:</strong> Scheme is said to achieve privacy in the sense of PR if there exists an efficient forgery strategy <span class="math">\\widehat{\\mathsf{A}_1}</span> such that the convincing measure <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1, \\mathsf{A}_2)</span> achieved by any efficient attacker pair <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> is negligible in the security parameter <span class="math">k</span>. We quantify the insecurity of DVS in the sense of PR against arbitrary attacker pairs <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> with resources <span class="math">(RP_1, RP_2)</span> (attacker set <span class="math">AS_{RP_1, RP_2}</span>), with respect to arbitrary forgery strategies <span class="math">\\widehat{\\mathsf{A}_1}</span> with resources <span class="math">\\widehat{RP_1}</span> (attacker set <span class="math">AS_{\\widehat{RP_1}}</span>) by the probability</li>

    </ol>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{InSec}_{\\mathsf{DVS}}^{\\mathsf{PR}}(RP_1, \\widehat{RP_1}, RP_2) \\stackrel{\\mathrm{def}}{=} \\min_{\\widehat{\\mathsf{A}_1} \\in AS_{\\widehat{RP_1}}} \\max_{(\\mathsf{A}_1, \\mathsf{A}_2) \\in AS_{RP_1}, RP_2} C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1, \\mathsf{A}_2).</span></div>

    <p class="text-gray-300">If <span class="math">\\mathbf{InSec}_{\\mathsf{DVS}}^{\\mathsf{PR}}(RP_1, \\widehat{RP_1}, RP_2) = 0</span> holds for any computationally unbounded <span class="math">\\mathsf{A}_2</span>, it is said to be perfect unconditional privacy. If privacy holds when <span class="math">\\widehat{q_{s1}} = q_{s1}</span> it is said to be complete privacy.</p>

    <p class="text-gray-300">We will present two UDVS schemes which are both extensions of the Schnorr [24] signature scheme (that is, the signer key-generation, signing and public-verification algorithms in both schemes are identical to those of the Schnorr signature). The first UDVS scheme <span class="math">\\mathsf{SchUDVS}_1</span> has an efficient and deterministic designation algorithm and its unforgeability relies on the Strong Diffie-Hellman (SDH) assumption. The second UDVS scheme <span class="math">\\mathsf{SchUDVS}_2</span> has a less efficient randomized designation algorithm, but its unforgeability follows from the weaker Discrete-Logarithm (DL) assumption (in the random-oracle model).</p>

    <h3 id="sec-13" class="text-xl font-semibold mt-8">4.1 First Scheme: <span class="math">\\mathsf{SchUDVS}_{1}</span></h3>

    <p class="text-gray-300">Our first UDVS scheme <span class="math">\\mathsf{SchUDVS}_{1}</span> is defined as follows. Let <span class="math">\\{0,1\\}^{\\leq\\ell}</span> denote the message space of all bit strings of length at most <span class="math">\\ell</span> bits. The scheme makes use of a cryptographic hash function <span class="math">H:\\{0,1\\}^{\\leq\\ell}\\times\\{0,1\\}^{l_{G}}\\to\\{0,1\\}^{l_{H}}</span>, modelled as a random-oracle <em>[2]</em> in our security analysis. We assume that elements of the group <span class="math">G</span> output by algorithm GC are represented by bit strings of length <span class="math">l_{G}\\geq l_{q}</span> bits, where <span class="math">l_{q}\\stackrel{{\\scriptstyle\\text{def}}}{{=}}\\lfloor\\log_{2}q\\rfloor+1</span> is the bit length of <span class="math">q</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Parameter Generation GC. (Identical to Schnorr). Choose a group <span class="math">G</span> of prime order <span class="math">q&gt;2^{l_{H}}</span> with description string <span class="math">D_{G}</span> (e.g. if <span class="math">G</span> is a subgroup of <span class="math">\\mathbb{Z}_{p}^{*}</span>, the string <span class="math">D_{G}</span> would contain <span class="math">(p,q)</span>), and let <span class="math">g\\in G</span> denote a generator for <span class="math">G</span>. The common parameters are <span class="math">cp=(D_{G},g)</span>.</li>

      <li>Signer Key Generation GKS. (Identical to Schnorr). Given the common parameters <span class="math">cp</span>, pick random <span class="math">x_{1}\\in\\mathbb{Z}_{q}^{*}</span> and compute <span class="math">y_{1}=g^{x_{1}}</span>. The public key is <span class="math">pk_{1}=(cp,y_{1})</span>. The secret key is <span class="math">sk_{1}=(cp,x_{1})</span>.</li>

      <li>Verifier Key Generation GKV. Given the common parameters <span class="math">cp</span>, pick random <span class="math">x_{3}\\in\\mathbb{Z}_{q}^{*}</span> and compute <span class="math">y_{3}=g^{x_{3}}</span>. The public key is <span class="math">pk_{3}=(cp,y_{3})</span>. The secret key is <span class="math">sk_{3}=(cp,x_{3})</span>.</li>

      <li>Signing S. (Identical to Schnorr). Given the signer’s secret key <span class="math">(cp,x_{1})</span>, and message <span class="math">m</span>, choose a random <span class="math">k\\in\\mathbb{Z}_{q}</span> and compute <span class="math">u=g^{k}</span>, <span class="math">r=H(m,u)</span> and <span class="math">s=k+r\\cdot x_{1}\\pmod{q}</span>. The PV signature is <span class="math">\\sigma=(r,s)</span>.</li>

      <li>Public Verification V. (Identical to Schnorr). Given the signer’s public key <span class="math">y_{1}</span> and a message/PV sig. pair <span class="math">(m,(r,s))</span>, accept if and only if <span class="math">H(m,u)=r</span>, where <span class="math">u=g^{s}\\cdot y_{1}^{-r}</span>.</li>

      <li>Designation CDV. Given the signer’s public key <span class="math">y_{1}</span>, a verifier’s public key <span class="math">y_{3}</span> and a message/PV-signature pair <span class="math">(m,(r,s))</span>, compute <span class="math">u=g^{s}\\cdot y_{1}^{-r}</span> and <span class="math">K=y_{3}^{s}</span>. The DV signature is <span class="math">\\widetilde{\\sigma}=(u,K)</span>.</li>

      <li>Designated Verification VDV. Given a signer’s public key <span class="math">y_{1}</span>, a verifier’s secret key <span class="math">x_{3}</span>, and message/DV-sig. pair <span class="math">(m,(u,K))</span>, accept if and only if <span class="math">K=(u\\cdot y_{1}^{r})^{x_{3}}</span>, where <span class="math">r=H(m,u)</span>.</li>

    </ol>

    <h5 id="sec-14" class="text-base font-semibold mt-4">Unforgeability</h5>

    <p class="text-gray-300">The PV-Unforgeability of <span class="math">\\mathsf{SchUDVS}_{1}</span> is equivalent to the unforgeability of the Schnorr signature, which in turn is equivalent to the Discrete-Logarithm (DL) assumption in <span class="math">G</span>, assuming the random-oracle model for <span class="math">H(.)</span> <em>[20]</em>. However, for the DV-Unforgeability of <span class="math">\\mathsf{SchUDVS}_{1}</span>, it is clear that the stronger ‘Computational Diffie-Hellman’ (CDH) assumption in <span class="math">G</span> is certainly <em>necessary</em> — an attacker can forge a DV signature <span class="math">(u,K)</span> on a message <span class="math">m</span> by choosing a random <span class="math">u\\in G</span>, computing <span class="math">r=H(m,u)</span> and then <span class="math">K=\\mathsf{CDH}_{g}(u\\cdot y_{1}^{r},y_{3})</span> (indeed this is the idea behind the proof of the privacy of <span class="math">\\mathsf{SchUDVS}_{1}</span> — see below). Moreover, in the strong DV-unforgeability attack setting, the even stronger ‘Strong Diffie-Hellman’ (SDH) assumption in <span class="math">G</span> is necessary. This is because the forger’s access to the verifier’s VDV oracle allows him to simulate the fixed-input DDH oracle <span class="math">\\mathsf{DDH}_{x_{3}}(w,K)</span> which decides whether <span class="math">K=w^{x_{3}}</span> or not (see Sec. 2.2), namely we have <span class="math">\\mathsf{DDH}_{x_{3}}(w,K)=\\mathsf{VDV}(y_{1}^{\\prime},x_{3},m,(u,K))</span> with <span class="math">y_{1}^{\\prime}=(w\\cdot u^{-1})^{r^{-1}\\bmod q}</span> and <span class="math">r=H(m,u)</span>. Note that this does not rule out the possibility that there may be another attack which even bypasses the need to break SDH. Fortunately, the following theorem shows that this is not the case and SDH is also a <em>sufficient</em> condition for Strong DV-Unforgeability of <span class="math">\\mathsf{SchUDVS}_{1}</span>, assuming the random-oracle model for <span class="math">H(.)</span>. The proof uses the forking technique, as used in the proof in <em>[20]</em> of PV-Unforgeability of the Schnorr signature.</p>

    <h6 id="sec-15" class="text-base font-medium mt-4">Theorem 4.1 (Strong DV-Unforg. of <span class="math">\\mathsf{SchUDVS}_{1}</span>).</h6>

    <p class="text-gray-300">If the Strong Diffie-Hellman problem (SDH) is hard in groups generated by the common-parameter algorithm GC, then the scheme <span class="math">\\mathsf{SchUDVS}_{1}</span> achieves</p>

    <p class="text-gray-300">Strong DV-unforgeability (ST-UF-DV notion) in the random-oracle model for <span class="math">H(.)</span>. Concretely, the following insecurity bound holds:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{InSec}_{\\mathsf{SchUDVS}_{1}}^{\\text{ST-UF-DV}}(t,q_{s},q_{v},q_{H})\\leq 2\\left[(q_{H}+q_{v})\\mathbf{InSec}_{\\mathsf{SDH}}(t[S],q[S])\\right]^{1/2}+\\frac{q_{s}(q_{H}+q_{s}+q_{v})+2(q_{H}+q_{v})+1}{2^{l_{H}}},</span></p>

    <p class="text-gray-300">where <span class="math">t[S]=2t+2(q_{H}+q_{s}+q_{v}+1)(T_{S}+O(l_{H}))+(q_{s}+1)O(l_{q}T_{g})+O(l_{q}^{2})</span>, where <span class="math">T_{S}=O(\\log_{2}(q_{H}+q_{s}+q_{v})\\cdot(\\ell+l_{G}))</span> and <span class="math">q[S]=2q_{v}</span>. Here we denote by <span class="math">T_{g}</span> the time needed to perform a group operation in <span class="math">G</span>.</p>

    <p class="text-gray-300">Privacy. The privacy of <span class="math">\\mathsf{SchUDVS}_{1}</span> follows from the existence of an algorithm for forging DV signatures (with identical probability distribution as that of real DV signatures) using the verifier’s secret key, which is a trapdoor for solving the <span class="math">\\mathsf{CDH}</span> problem on which the DV-Unforgeability relies.</p>

    <h6 id="sec-16" class="text-base font-medium mt-4">Theorem 4.2 (Privacy of <span class="math">\\mathsf{SchUDVS}_{1}</span>).</h6>

    <p class="text-gray-300">The scheme <span class="math">\\mathsf{SchUDVS}_{1}</span> achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{InSec}_{\\mathsf{SchUDVS}_{1}}^{\\text{PR}}(RP_{1},\\widehat{RP}_{1},\\infty)=0,</span> (1)</p>

    <p class="text-gray-300">where <span class="math">RP_{1}=(t_{1},q_{s1},q_{c1},q_{k1},q_{d1})</span> denotes <span class="math">\\mathsf{A}_{1}</span>’s resource parameters and <span class="math">\\widehat{RP}_{1}=(\\widehat{t}_{1},\\widehat{q}_{s1},\\widehat{q}_{c1},\\widehat{q}_{k1})</span> denotes the forgery strategy <span class="math">\\widehat{\\mathsf{A}_{1}}</span>’s resources, which are given by: <span class="math">\\widehat{t}_{1}=t_{1}+q_{d1}O(l_{q}T_{g}+q_{d1}l_{G})+q_{k1}O(l_{q}T_{g})</span>, <span class="math">\\widehat{q}_{s1}=q_{s1}</span> (complete privacy), <span class="math">\\widehat{q}_{c1}=q_{c1}</span>, <span class="math">\\widehat{q}_{k1}=0</span>.</p>

    <h3 id="sec-17" class="text-xl font-semibold mt-8">4.2 Second Scheme: <span class="math">\\mathsf{SchUDVS}_{2}</span></h3>

    <p class="text-gray-300">Our second UDVS scheme <span class="math">\\mathsf{SchUDVS}_{2}</span> trades off efficiency for a better provable unforgeability security guarantee. Rather than using the Diffie-Hellman trapdoor function to achieve privacy, we instead get the designator to produce a Schnorr proof of knowledge of the PV signature <span class="math">(r,s)</span>. This proof of knowledge is made non-interactive in the random-oracle model using the Fiat-Shamir heuristic <em>[11]</em>, but using a trapdoor hash function <em>[16, 25]</em> <span class="math">F_{y_{3}}(.;.)</span> composed with a random oracle <span class="math">J(.)</span> in producing the ‘verifier random challenge’ <span class="math">\\widehat{r}</span> for this proof of knowledge. The designated-verifier’s secret key consists of the trapdoor for the hash function <span class="math">F_{y_{3}}</span>, which suffices for forging the DV signatures, thus providing the privacy property. We remark that a similar technique was used by Jakobsson Sako and Impagliazzo <em>[15]</em>, who used a trapdoor commitment scheme in constructing a designated-verifier undeniable signature scheme. Our scheme can use any secure trapdoor hash function.</p>

    <p class="text-gray-300">The resulting scheme is defined as follows. Let <span class="math">\\{0,1\\}^{\\leq\\ell}</span> denote the message space of all bit strings of length at most <span class="math">\\ell</span> bits. The scheme makes use of two cryptographic hash functions <span class="math">H:\\{0,1\\}^{\\leq\\ell}\\times\\{0,1\\}^{l_{G}}\\rightarrow\\{0,1\\}^{l_{H}}</span> and <span class="math">J:\\{0,1\\}^{\\leq\\ell}\\times\\mathsf{Z}_{2^{l_{H}}}\\times\\{0,1\\}^{l_{G}}\\times\\{0,1\\}^{l_{F}}\\rightarrow\\{0,1\\}^{l_{J}}</span>, both modelled as random-oracles <em>[2]</em> in our security analysis. We also use a trapdoor hash function scheme <span class="math">\\mathsf{TH}=(\\mathsf{GKF},F,\\mathsf{CSF})</span> with <span class="math">F_{y_{3}}:\\{0,1\\}^{l_{G}}\\times R_{F}\\rightarrow\\{0,1\\}^{l_{F}}</span> (we refer the reader to Section 2 for a definition of trapdoor hash function schemes). We assume that elements of the group <span class="math">G</span> output by algorithm <span class="math">\\mathsf{GC}</span> are represented by bit strings of length <span class="math">l_{G}\\geq l_{q}</span> bits, where <span class="math">l_{q}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\lfloor\\log_{2}q\\rfloor+1</span> is the bit length of <span class="math">q</span>.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Parameter Generation <span class="math">\\mathsf{GC}</span>. (Identical to Schnorr). Choose a group <span class="math">G</span> of prime order <span class="math">q</span> with description string <span class="math">D_{G}</span> (e.g. if <span class="math">G</span> is a subgroup of <span class="math">\\mathsf{Z}_{p}^{*}</span>, the string <span class="math">D_{G}</span> would contain <span class="math">(p,q)</span>), and let <span class="math">g\\in G</span> denote a generator for <span class="math">G</span>. The common parameters are <span class="math">cp=(k,D_{G},g)</span> (<span class="math">k</span> is the security parameter).</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signer Key Generation GKS. (Identical to Schnorr). Given the common parameters <span class="math">cp</span>, pick random <span class="math">x_1 \\in \\mathbb{Z}_q</span> and compute <span class="math">y_1 = g^{x_1}</span>. The public key is <span class="math">pk_1 = (cp, y_1)</span>. The secret key is <span class="math">sk_1 = (cp, x_1)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Verifier Key Generation GKV. Given the common parameters <span class="math">cp = k</span>, run TH's key-gen. algorithm to compute <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span>. The public key is <span class="math">pk_3 = (cp, pk)</span>. The secret key is <span class="math">sk_3 = (cp, sk, pk)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing S. (Identical to Schnorr). Given the signer's secret key <span class="math">(cp, x_1)</span>, and message <span class="math">m</span>, choose a random <span class="math">k \\in \\mathbb{Z}_q</span> and compute <span class="math">u = g^k</span>, <span class="math">r = H(m, u)</span> and <span class="math">s = k + r \\cdot x_1 \\pmod{q}</span>. The PV signature is <span class="math">\\sigma = (r, s)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Verification V. (Identical to Schnorr). Given the signer's public key <span class="math">y_1</span> and a message/PV sig. pair <span class="math">(m, (r, s))</span>, accept if and only if <span class="math">H(m, u) = r</span>, where <span class="math">u = g^s \\cdot y_1^{-r}</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designation CDV. Given the signer's public key <span class="math">y_1</span>, a verifier's public key <span class="math">pk_3 = (cp, pk)</span> and a message/PV-signature pair <span class="math">(m, (r, s))</span>, compute <span class="math">u = g^s \\cdot y_1^{-r}</span>, <span class="math">\\widehat{u} = g^{\\widehat{k}}</span> for a random <span class="math">\\widehat{k} \\in \\mathbb{Z}_q</span>, <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span> for a random <span class="math">\\widehat{r}_F \\in R_F</span>, <span class="math">\\widehat{r} = J(m, r, u, \\widehat{h})</span> and <span class="math">\\widehat{s} = \\widehat{k} + \\widehat{r} \\cdot s \\mod q</span>. The DV signature is <span class="math">\\widehat{\\sigma} = (u, \\widehat{r}_F, \\widehat{r}, \\widehat{s})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designated Verification VDV. Given a signer's public key <span class="math">y_1</span>, a verifier's secret key <span class="math">sk_3 = (cp, sk, pk)</span>, and message/DV-sig. pair <span class="math">(m, (u, \\widehat{r}_F, \\widehat{r}, \\widehat{s}))</span>, accept if and only if <span class="math">J(m, r, u, \\widehat{h}) = \\widehat{r}</span>, where <span class="math">r = H(m, u)</span>, <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span> and <span class="math">\\widehat{u} = g^{\\widehat{s}} \\cdot (u \\cdot y_1^r)^{-\\widehat{r}}</span>.</li>

    </ol>

    <p class="text-gray-300">Unforgeability. The idea behind the DV-Unforgeability of <span class="math">\\mathsf{SchUDVS}_2</span>, is that the DV signature is effectively a proof of knowledge of the <span class="math">s</span> portion of the PV Schnorr signature <span class="math">(r, s)</span> by the signer on <span class="math">m</span>. Namely, using the forking technique we can use a forger for <span class="math">\\mathsf{SchUDVS}_2</span> to extract <span class="math">s</span> and hence forge a Schnorr PV signature for some unsigned message <span class="math">m</span>, or alternately to break the collision-resistance of the trapdoor hash scheme TH. We have the following concrete result. Note that we need only assume that <span class="math">J(.)</span> is a random-oracle in proving this result, but we provide a count of <span class="math">H(.)</span> queries to allow the use of our reduction bound in conjunction with known results on the unforgeability of the Schnorr signature which assume the random-oracle model for <span class="math">H(.)</span>.</p>

    <p class="text-gray-300">Theorem 4.3 (Strong DV-Unforg. of <span class="math">\\mathsf{SchUDVS}_2</span>). If <span class="math">\\mathsf{SchUDVS}_2</span> is PV-unforgeable (UF-PV notion) and TH is collision-resistant (CR notion) then <span class="math">\\mathsf{SchUDVS}_2</span> achieves Strong DV-unforgeability (ST-UF-DV notion) in the random-oracle model for <span class="math">J(.)</span>. Concretely, the following insecurity bound holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{InSec}_{\\mathsf{SchUDVS}_2}^{\\mathrm{ST-UF-DV}}(t, q_s, q_v, q_J, q_H) \\leq \\\\ 2 \\left[ (q_J + q_v) q_s \\right]^{1/2} \\left[ \\mathbf{InSec}_{\\mathsf{SchUDVS}_2}^{\\mathrm{UF-PV}}(t[S], q_s[S], q_H[S]) + \\mathbf{InSec}_{\\mathsf{TH}}^{\\mathrm{CR}}(t[T]) \\right]^{1/2} + \\frac{2(q_J + q_v) q_s + 1}{2^{l_J}}, \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">t[S] = t[T] = 2t + O((q_J + q_v)(\\ell + l_F + l_G) + l_q T_g + l_q^2)</span>, <span class="math">q_s[S] = 2q_s</span> and <span class="math">q_H[S] = 2q_H</span>. Here we denote by <span class="math">T_g</span> the time needed to perform a group operation in <span class="math">G</span>.</p>

    <p class="text-gray-300">Privacy. The privacy of <span class="math">\\mathsf{SchUDVS}_2</span> follows from the existence of an algorithm for forging DV signatures (with identical probability distribution as that of real DV signatures) using the verifier's secret key, which is a trapdoor for solving collisions in TH. In particular we need here the perfectly-trapdoor property of TH. This result holds in the standard model (no random-oracle assumptions).</p>

    <p class="text-gray-300">10</p>

    <h6 id="sec-18" class="text-base font-medium mt-4">Theorem 4.4 (Privacy of <span class="math">\\mathsf{SchUDVS}_{2}</span>).</h6>

    <p class="text-gray-300">If the scheme <span class="math">\\mathsf{TH}</span> is perfectly-trapdoor then <span class="math">\\mathsf{SchUDVS}_{2}</span> achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{InSec}^{\\mathsf{PR}}_{\\mathsf{SchUDVS}_{2}}(RP_{1},\\widetilde{RP}_{1},\\infty)=0,</span> (2)</p>

    <p class="text-gray-300">where <span class="math">RP_{1}=(t_{1},q_{s1},q_{c1},q_{k1},q_{d1})</span> denotes <span class="math">\\mathsf{A}_{1}</span>’s resource parameters and <span class="math">\\widetilde{RP}_{1}=(\\widetilde{t}_{1},\\widetilde{q}_{s1},\\widetilde{q}_{c1},\\widetilde{q}_{k1})</span> denotes the forgery strategy <span class="math">\\widetilde{\\mathsf{A}_{1}}</span>’s RPs, which are given by: <span class="math">\\widetilde{t}_{1}=t_{1}+q_{d1}O(l_{q}T_{g}+T_{F}+T_{CSF}+T_{J}+T_{H}+q_{d1}l_{pk})+q_{k1}T_{GKF}</span>, <span class="math">\\widetilde{q}_{s1}=q_{s1}</span> (complete privacy), <span class="math">\\widetilde{q}_{c1}=q_{c1}</span>, <span class="math">\\widetilde{q}_{k1}=0</span>. Here we let <span class="math">T_{g},T_{F},T_{GKF},T_{CSF},T_{J},T_{H}</span> denote the time to compute a group operation, and evaluate <span class="math">F</span>, <span class="math">\\mathsf{GKF},\\mathsf{CSF}</span>, <span class="math">J</span> and <span class="math">H</span> respectively, and <span class="math">l_{pk}</span> denotes an upper-bound on the length of public keys for scheme <span class="math">\\mathsf{TH}</span>.</p>

    <h2 id="sec-19" class="text-2xl font-bold">5 RSA-Based Scheme: RSAUDVS</h2>

    <p class="text-gray-300">The idea for the construction of an RSA-based UDVS scheme is analogous to the second Schnorr-based scheme <span class="math">\\mathsf{SchUDVS}_{2}</span>, and is described as follows. The PV RSA signature known to the designator is the <span class="math">e</span>th root <span class="math">\\sigma=h^{1/e}\\bmod N</span> of the message hash <span class="math">h</span>, where <span class="math">(N,e)</span> is the signer’s RSA public key. To produce a DV signature on <span class="math">m</span>, the designator computes a zero-knowledge proof of knowledge of the PV signature <span class="math">\\sigma</span> (made non-interactive using Fiat-Shamir method <em>[11]</em>), which is forgeable by the verifier. The Guilliou-Quisquater ID-based signature <em>[14]</em> is based on such a proof and is applied here for this purpose. To make the proof forgeable by the verifier, we use a trapdoor hash function in the computation of the challenge, as done in the <span class="math">\\mathsf{SchUDVS}_{2}</span> scheme. We note that a restriction of the GQ proof that we use is that the random challenge <span class="math">r</span> must be smaller than the public exponent <span class="math">e</span>. To allow for small public exponents and achieve high security level, we apply <span class="math">\\alpha</span> proofs in ‘parallel’, where <span class="math">\\alpha</span> is chosen to achieve a sufficient security level — see security bound in our security analysis (a similar technique is used in the Fiat-Shamir signature scheme <em>[11]</em>).</p>

    <p class="text-gray-300">The resulting scheme is defined as follows. Let <span class="math">\\{0,1\\}^{\\leq\\ell}</span> denote the message space of all bit strings of length at most <span class="math">\\ell</span> bits. The scheme makes use of two cryptographic hash functions <span class="math">H:\\{0,1\\}^{\\leq\\ell}\\times R_{S}\\rightarrow\\{0,1\\}^{l_{H}}</span> and <span class="math">J:\\{0,1\\}^{\\leq\\ell}\\times\\mathbb{Z}_{l_{N}}^{\\alpha}\\times\\{0,1\\}^{l_{F}}\\rightarrow\\mathbb{Z}_{2^{l_{J}/\\alpha}}^{\\alpha}</span>. Note that we only need to assume that <span class="math">J(.)</span> is a random-oracle model in our security analysis, and that we allow randomized RSA signatures with hash generation <span class="math">h=H(m;s)</span> for random <span class="math">s</span>. The corresponding verification is to check if <span class="math">R(h,m)=Acc</span> or not, where <span class="math">R(.)</span> is a binary relation function that outputs <span class="math">Acc</span> if <span class="math">h</span> is a valid hash of message <span class="math">m</span> and outputs <span class="math">Rej</span> else. Thus by a suitable choice of <span class="math">H(.,.)</span> and <span class="math">R(.,.)</span> our scheme can instantiated with any of the standardised variants of RSA signatures such as RSASSA-PSS or RSASSA-PKCS1-v15, as specified in the PKCS1 standard <em>[23]</em>. We also use a trapdoor hash function scheme <span class="math">\\mathsf{TH}=(\\mathsf{GKF},F,\\mathsf{CSF})</span> with <span class="math">F_{y_{3}}:\\{0,1\\}^{l_{G}}\\times R_{F}\\rightarrow\\{0,1\\}^{l_{F}}</span> (we refer the reader to Section 2 for a definition of trapdoor hash function schemes). Here <span class="math">l_{N}</span> denotes the length of RSA modulus <span class="math">N</span> of the signer’s public key.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Common Parameter Generation GC. (Identical to RSA). The comm. pars. are <span class="math">cp=k</span> (<span class="math">k</span> is the security parameter).</li>

      <li>Signer Key Generation GKS. (Identical to RSA). Given the common parameters <span class="math">cp</span>, choose a prime <span class="math">e&gt;2^{l_{J}/\\alpha}</span>. Pick random primes <span class="math">p</span> and <span class="math">q</span> such that <span class="math">N=pq</span> has bit-length <span class="math">l_{N}</span> and <span class="math">\\gcd(e,\\phi(N))=1</span>, where <span class="math">\\phi(N)=(p-1)(q-1)</span>. Compute <span class="math">d=e^{-1}\\bmod\\phi(N)</span>. The public key is <span class="math">pk_{1}=(cp,N,e)</span>. The secret key is <span class="math">sk_{1}=(cp,N,e,d)</span>.</li>

      <li>Verifier Key Generation GKV. Given the comm. pars. <span class="math">cp=k</span>, run <span class="math">\\mathsf{TH}</span>’s key-gen. algorithm to compute <span class="math">(sk,pk)=\\mathsf{GKF}(k)</span>. The public key is <span class="math">pk_{3}=(cp,pk)</span>. The secret key is <span class="math">sk_{3}=(cp,sk,pk)</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Signing S. (Identical to RSA). Given the signer's secret key <span class="math">(cp, N, e, d)</span>, and message <span class="math">m</span>, choose a random <span class="math">s \\in R_S</span> and compute <span class="math">h = H(m, s)</span> and <span class="math">\\sigma = h^d \\mod N</span>. The PV signature is <span class="math">\\sigma</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Public Verification V. (Identical to RSA). Given the signer's public key <span class="math">(cp, N, e)</span> and a message/PV sig. pair <span class="math">(m, \\sigma)</span>, accept if and only if <span class="math">R(m, h) = Acc</span>, where <span class="math">h = \\sigma^e \\mod N</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designation CDV. Given the signer's public key <span class="math">(cp, N, e)</span>, a verifier's public key <span class="math">pk_3 = (cp, pk)</span> and a message/PV-signature pair <span class="math">(m, \\sigma)</span>, choose <span class="math">\\alpha</span> random elements <span class="math">k_i \\in \\mathbb{Z}_N^s</span> and compute <span class="math">\\widehat{u} = (\\widehat{u}_1, \\ldots, \\widehat{u}_\\alpha)</span>, where <span class="math">\\widehat{u}_i = k_i^e \\bmod N</span> for <span class="math">i = 1, \\ldots, \\alpha</span>. Compute <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span> for random <span class="math">\\widehat{r}_F \\in R_F</span>. Compute <span class="math">\\widehat{r} = (\\widehat{r}_1, \\ldots, \\widehat{r}_\\alpha) = J(m, h, \\widehat{h})</span>, where <span class="math">h = \\sigma^e \\bmod N</span> and <span class="math">\\widehat{r}_i \\in \\mathbb{Z}_{2^{l_J / \\alpha}}</span> for <span class="math">i = 1, \\ldots, \\alpha</span>. Compute <span class="math">\\widehat{s} = (\\widehat{s}_1, \\ldots, \\widehat{s}_\\alpha)</span>, where <span class="math">\\widehat{s}_i = k_i \\cdot \\sigma^{\\widehat{r}_i} \\bmod N</span> for all <span class="math">i = 1, \\ldots, \\alpha</span>. The DV signature is <span class="math">\\widehat{\\sigma} = (h, \\widehat{r}_F, \\widehat{r}, \\widehat{s})</span>.</li>

    </ol>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Designated Verification VDV. Given a signer's public key <span class="math">(cp, N, e)</span>, a verifier's secret key <span class="math">sk_3 = (cp, sk, pk)</span>, and message/DV-sig. pair <span class="math">(m, (h, \\widehat{r}_F, \\widehat{r}, \\widehat{s}))</span>, accept if and only if <span class="math">J(m, h, \\widehat{h}) = \\widehat{r}</span> and <span class="math">R(m, h) = Acc</span>, where <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span> with <span class="math">\\widehat{u} = (\\widehat{u}_1, \\ldots, \\widehat{u}_\\alpha)</span> and <span class="math">\\widehat{u}_i = \\widehat{s}_i^e \\cdot h^{-\\widehat{r}_i} \\bmod N</span> for <span class="math">i = 1, \\ldots, \\alpha</span>.</li>

    </ol>

    <p class="text-gray-300">Unforgeability. Similar to the scheme SchUDVS₂, thanks to the soundness of the GQ proof of knowledge of RSA inverses, we can prove the DV unforgeability of RSAUDVS assuming the PV-unforgeability of RSAUDVS (i.e. the existential unforgeability under chosen-message attack of the underlying standard RSA signature <span class="math">(\\mathsf{GKS}, \\mathsf{S}, \\mathsf{V})</span>) and the collision-resistance of the trapdoor hash TH. The concrete result is the following.</p>

    <p class="text-gray-300">Theorem 5.1 (Strong DV-Unforg. of RSAUDVS). If RSAUDVS is PV-unforgeable (UF-PV notion) and TH is collision-resistant (CR notion) then RSAUDVS achieves Strong DV-unforgeability (ST-UF-DV notion) in the random-oracle model for <span class="math">J(.)</span>. Concretely, the following insecurity bound holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{InSec}_{\\text{RSAUDVS}}^{\\text{ST-UF-DV}}(t, q_s, q_v, q_J, q_H) \\leq \\\\ 2 \\left[ (q_J + q_v) q_s \\right]^{1/2} \\left[ \\mathbf{InSec}_{\\text{RSAUDVS}}^{\\text{UF-PV}}(t[S], q_s[S], q_H[S]) + \\mathbf{InSec}_{\\text{TH}}^{\\text{CR}}(t[T]) \\right]^{1/2} + \\frac{2(q_J + q_v) q_s + 1}{2^{l_J}}, \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">t[S] = t[T] = 2t + O((q_J + q_v)(l_F + l_N) + l_e^2 + l_e T_N)</span>, <span class="math">q_s[S] = 2q_s</span> and <span class="math">q_H[S] = 2q_H</span>. Here we denote by <span class="math">T_N</span> the time needed to perform a multiplication in <span class="math">\\mathbb{Z}_N^s</span> and <span class="math">l_e = \\log_2(e)</span>.</p>

    <p class="text-gray-300">Privacy. The privacy of RSAUDVS is unconditional and complete, assuming the perfectly-trapdoor property of the trapdoor hash scheme TH.</p>

    <p class="text-gray-300">Theorem 5.2 (Privacy of RSAUDVS). If the scheme TH is perfectly-trapdoor then RSAUDVS achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{InSec}_{\\text{RSAUDVS}}^{\\text{PR}}(RP_1, \\widehat{RP}_1, \\infty) = 0, \\tag{3}</span></div>

    <p class="text-gray-300">where <span class="math">RP_1 = (t_1, q_{s1}, q_{c1}, q_{k1}, q_{d1})</span> denotes <span class="math">\\mathsf{A}_1</span>'s resource parameters and <span class="math">\\widehat{RP}_1 = (\\widehat{t}_1, \\widehat{q}_{s1}, \\widehat{q}_{c1}, \\widehat{q}_{k1})</span> denotes the forgery strategy <span class="math">\\widehat{\\mathsf{A}}_1</span>'s RPs, which are given by: <span class="math">\\widehat{t}_1 = t_1 + q_{d1}O(l_JT_N + T_F + T_{CSF} + T_J + T_H + q_{d1}l_{pk}) + q_{k1}T_{GKF}</span>, <span class="math">\\widehat{q}_{s1} = q_{s1}</span> (complete privacy), <span class="math">\\widehat{q}_{c1} = q_{c1}</span>, <span class="math">\\widehat{q}_{k1} = 0</span>. Here we let <span class="math">T_N, T_F, T_{GKF}, T_{CSF}, T_J, T_H</span> denote the time to compute a multiplication modulo <span class="math">N</span>, and evaluate <span class="math">F</span>, GKF, CSF, <span class="math">J</span> and <span class="math">H</span> respectively, and <span class="math">l_{pk}</span> denotes an upper-bound on the length of public keys for scheme TH.</p>

    <p class="text-gray-300">12</p>

    <p class="text-gray-300">The following tables compare the security and performance features of the proposed schemes (also shown for comparison is an entry for the bilinear-based UDVS scheme DVSBM [26]. It is evident that  <span class="math">\\mathsf{SchUDVS}_1</span>  is more computationally efficient than  <span class="math">\\mathsf{SchUDVS}_2</span>  but its security relies on a stronger assumption and it also produces slightly longer DV signatures. The RSA-based scheme RSAUDVS has a disadvantage of long DV signature length (typically about 10 times the length of a standard RSA signature) assuming a low public exponent  <span class="math">e = 2^{16} + 1</span> . However, the computation is about the same as in the Schnorr-based schemes. This is because the  <span class="math">O(l_J / \\log_2(e))</span>  exponentiations for RSAUDVS shown in Table 2 use a low exponent  <span class="math">e</span> , so the total computation is only  <span class="math">O(l_J)</span>  modular multiplications.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Extended Sig.</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Hard Problem</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Det. Desig?</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">DV Sig. Length (typ)</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SchUDVS1</td>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr</td>

            <td class="px-3 py-2 border-b border-gray-700">SDH</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">2lG(2.0 kb)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SchUDVS2</td>

            <td class="px-3 py-2 border-b border-gray-700">Schnorr</td>

            <td class="px-3 py-2 border-b border-gray-700">DL</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">lG+lF+2lq(1.5 kb)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSAUDVS</td>

            <td class="px-3 py-2 border-b border-gray-700">RSA</td>

            <td class="px-3 py-2 border-b border-gray-700">RSA</td>

            <td class="px-3 py-2 border-b border-gray-700">No</td>

            <td class="px-3 py-2 border-b border-gray-700">lN+lF+lJ+[lJ/log2(e)]lN(11.6 kb)</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DVSBM</td>

            <td class="px-3 py-2 border-b border-gray-700">BLS</td>

            <td class="px-3 py-2 border-b border-gray-700">BDH</td>

            <td class="px-3 py-2 border-b border-gray-700">Yes</td>

            <td class="px-3 py-2 border-b border-gray-700">lGT(1.0 kb)</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 1: Comparison of UDVS Schemes Features. See Secs. 4 and 5 for symbol definitions. The column 'Det Desig?' indicates if the schemes designation algorithm is deterministic or not. The 'DV Sig. Length (typ)' column entries give DV signature lengths for the following typical scheme parameter values. For SchUDVS <span class="math">_1</span>  and SchUDVS <span class="math">_2</span> , we assume a subgroup  <span class="math">G</span>  of order  <span class="math">q</span>  in  <span class="math">\\mathbf{Z}_p^*</span>  for  <span class="math">p</span>  prime, with  <span class="math">l_G = 1.024</span>  kb,  <span class="math">l_q = l_J = 0.16</span>  kb. For RSAUDVS, we assume  <span class="math">l_N = 1.024</span> ,  <span class="math">l_J = 0.16</span>  kb and  <span class="math">e = 2^{16} + 1</span> . For DVSBM we assume image group of length  <span class="math">l_{G_T} = 1.024</span>  kb.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Scheme</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Desig. Time</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">Ver. Time</th>

          </tr>

        </thead>

        <tbody>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SchUDVS1</td>

            <td class="px-3 py-2 border-b border-gray-700">2 exp.</td>

            <td class="px-3 py-2 border-b border-gray-700">1 exp.</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">SchUDVS2</td>

            <td class="px-3 py-2 border-b border-gray-700">2 exp. + TH</td>

            <td class="px-3 py-2 border-b border-gray-700">1 exp. + TH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">RSAUDVS</td>

            <td class="px-3 py-2 border-b border-gray-700">2([lJ/log2(e)] + 1) exp. + TH</td>

            <td class="px-3 py-2 border-b border-gray-700">[lJ/log2(e)] + 1 exp. + TH</td>

          </tr>

          <tr>

            <td class="px-3 py-2 border-b border-gray-700">DVSBM</td>

            <td class="px-3 py-2 border-b border-gray-700">1 pairing</td>

            <td class="px-3 py-2 border-b border-gray-700">1 pairing + 1 exp.</td>

          </tr>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">Table 2: Comparison of UDVS Schemes Approximate Computation Time. Here we count the cost of computing a product  <span class="math">a^x b^y c^z</span>  as equivalent to a single exponentiation (exp.) in the underlying group. For RSAUDVS exponent lengths are all  <span class="math">\\log_2(e)</span> . TH denotes the cost of evaluating the trapdoor hash function  <span class="math">F_{pk}</span>  (typ. 1 exp.).</p>

    <p class="text-gray-300">We have shown how to efficiently extend the standard Schnorr and RSA signature schemes into Universal Designated-Verifier Signature schemes, and provided a concrete security analysis of the resulting schemes. One problem of our RSA scheme is that the length of designated signatures is larger than standard RSA signatures by a factor roughly proportional to  <span class="math">k / \\log_2(e)</span> , where  <span class="math">k</span>  is the security parameter and  <span class="math">e</span>  is the public exponent. An interesting open problem is to find an RSA based UDVS scheme with designated signatures only a constant factor longer than standard RSA signatures, independent of  <span class="math">e</span> .</p>

    <p class="text-gray-300">[1] M. Abdalla, M. Bellare, and P. Rogaway. The Oracle Diffie-Hellman Assumptions and an Analysis of DHIES. In Topics in Cryptology - CT-RSA 2001, volume 2020 of LNCS, pages 143-158, Berlin, 2001. Springer-Verlag. See full paper available at www-cse.ucsd.edu/users/mihir.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>[2] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proc. 1-st ACM Conf. on Comp. and Comm. Security, pages 62–73, New York, November 1993. ACM.</li>

      <li>[3] D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. In CRYPTO 2001, volume 2139 of LNCS, pages 213–229, Berlin, 2001. Springer-Verlag.</li>

      <li>[4] S. Brands. A technical overview of digital credentials, 1999. Available at http://www.xs4all.nl/<span class="math">\\sim</span>brands/.</li>

      <li>[5] S. Brands. Rethinking Public Key Infrastructures and Digital Certificates. MIT Press, 2000.</li>

      <li>[6] J. Camenisch and M. Michels. Confirmer Signature Schemes Secure against Adaptive Adversaries. In Eurocrypt 2000, volume 1807 of LNCS, pages 243–258, Berlin, 2000. Springer-Verlag.</li>

      <li>[7] D. Chaum. Zero-Knowledge Undeniable Signatures. In Eurocrypt ’90, volume 473 of LNCS, pages 458–464, Berlin, 1991. Springer-Verlag.</li>

      <li>[8] D. Chaum. Designated Confirmer Signatures. In Eurocrypt ’94, volume 950 of LNCS, pages 86–91, Berlin, 1994. Springer-Verlag.</li>

      <li>[9] D. Chaum and H. van Antwerpen. Undeniable Signatures. In Crypto ’89, volume 435 of LNCS, pages 212–216, Berlin, 1990. Springer-Verlag.</li>

      <li>[10] W. Diffie and M. Hellman. New Directions in Cryptography. IEEE Trans. on Information Theory, 22:644–654, 1976.</li>

      <li>[11] A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions of Identification and Signature Problems. In CRYPTO’86, volume 263 of LNCS, pages 186–194, Berlin, 1987. Springer-Verlag.</li>

      <li>[12] R. Gennaro and T. Rabin. RSA-Based Undeniable Signatures. J. of Cryptology, 13:397–416, 2000.</li>

      <li>[13] S. Goldwasser, S. Micali, and R. Rivest. A Digital Signature Scheme Secure against Adaptively Chosen Message Attacks. SIAM Journal on Computing, 17(2):281–308, 1988.</li>

      <li>[14] L.C. Guillou and J.J. Quisquater. A “Paradoxical” Identity-Based Signature Scheme Resulting from Zero-Knowledge. In CRYPTO ’88, volume 403 of LNCS, pages 216–231, Berlin, 1990. Springer-Verlag.</li>

      <li>[15] M. Jakobsson, K. Sako, and R. Impagliazzo. Designated Verifier Proofs and Their Applications. In Eurocrypt ’96, volume 1070 of LNCS, pages 143–154, Berlin, 1996. Springer-Verlag.</li>

      <li>[16] H. Krawczyk and T. Rabin. Chameleon Signatures. In NDSS 2000, 2000. Available at http://www.isoc.org/isoc/conferences/ndss/2000/proceedings/.</li>

      <li>[17] M. Michels and M. Stadler. Generic Constructions for Secure and Efficient Confirmer Signature Schemes. In Eurocrypt ’98, volume 1403 of LNCS, pages 406–421, Berlin, 1998. Springer-Verlag.</li>

      <li>[18] T. Okamoto. Designated Confirmer Signatures and Public-Key Encryption are Equivalent. In Crypto ’94, volume 839 of LNCS, pages 61–74, Berlin, 1994. Springer-Verlag.</li>

      <li>[19] T. Okamoto and D. Pointcheval. The Gap-Problems: A New Class of Problems for the Security of Cryptographic Schemes. In PKC2001, volume 1992 of LNCS, pages 104–118, Berlin, 2000. Springer-Verlag.</li>

    </ul>

    <p class="text-gray-300">[20] D. Pointcheval and J. Stern. Security Arguments for Digital Signatures and Blind Signatures. <em>J. of Cryptology</em>, 13(3):361–396, 2000.</p>

    <p class="text-gray-300">[21] R. Rivest, A. Shamir, and Y. Tauman. How to Leak a Secret. In <em>Asiacrypt 2001</em>, volume 2248 of <em>LNCS</em>, pages 552–565, Berlin, 2001. Springer-Verlag.</p>

    <p class="text-gray-300">[22] R. L. Rivest, A. Shamir, and L. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. <em>Communications of the ACM</em>, 21(2):120–128, 1978.</p>

    <p class="text-gray-300">[23] RSA Laboratories. <em>PKCS21 v. 2.1: RSA Cryptography Standard</em>, 2002.</p>

    <p class="text-gray-300">[24] C. P. Schnorr. Efficient Identification and Signatures for Smart Cards. In <em>CRYPTO’89</em>, volume 435 of <em>LNCS</em>, pages 239–251, Berlin, 1990. Springer-Verlag.</p>

    <p class="text-gray-300">[25] A. Shamir and Y. Tauman. Improved Online/Offline Signature Schemes. In <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 355–367, Berlin, 2001. Springer-Verlag.</p>

    <p class="text-gray-300">[26] R. Steinfeld, L. Bull, H. Wang, and J. Pieprzyk. Universal Designated-Verifier Signatures. In <em>Asiacrypt 2003</em>, volume 2894 of <em>LNCS</em>, pages 523–542, Berlin, 2003. Springer-Verlag. Full version available at http://www.comp.mq.edu.au/~rons.</p>

    <p class="text-gray-300">[27] R. Steinfeld, L. Bull, and Y. Zheng. Content Extraction Signatures. In <em>International Conference on Information Security and Cryptology ICISC 2001</em>, volume 2288 of <em>LNCS</em>, pages 285–304, Berlin, 2001. Springer-Verlag.</p>

    <h2 id="sec-23" class="text-2xl font-bold">Appendix A Proof of Theorem 4.1</h2>

    <p class="text-gray-300">We show how to use any efficient forging attacker <span class="math">\\mathsf{A}</span> for breaking scheme <span class="math">\\mathsf{SchUDVS}_{1}</span> in the sense of ST-UF-DV with non-negligible probability to construct an efficient attacker <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> for breaking the Strong Diffie-Hellman problem (SDH) with non-negligible probability, thus contradicting the assumed hardness of SDH. More precisely, we show that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{S u c c}_{\\mathsf{A}_{\\mathsf{S}}, \\mathsf{S D H}}(k) \\geq \\left(1 / 4(q_{H} + q_{v})\\right) \\cdot \\left[ \\mathbf{S u c c}_{\\mathsf{A}, \\mathsf{S c h U D V S}_{1}}^{\\mathrm{ST - U F - D V}}(k) - \\frac{q_{s}(q_{H} + q_{s} + q_{v}) + 2(q_{H} + q_{v}) + 1}{2^{l_{H}}} \\right]^{2}, \\tag{4}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> has the run-time <span class="math">t[S]</span> and makes <span class="math">q[S]</span> DDH queries, as defined in the theorem statement. The theorem then follows immediately from (4), by taking maximums over all attackers <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> with the given running time. It remains to construct the attacker <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and show that it satisfies (4).</p>

    <p class="text-gray-300"><strong>Overview.</strong> We convert <span class="math">\\mathsf{A}</span> into <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> in two stages. In the first stage, we modify the <span class="math">\\mathsf{S}</span> oracle simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> so that it does not use <span class="math">x_{1}</span> (by outputting a random pair <span class="math">(r,s)</span> as the signature for message <span class="math">m</span> and modifying the <span class="math">\\mathsf{H}</span> oracle to answer consistently <span class="math">r</span> whenever <span class="math">(m,g^{s}\\cdot y_{1}^{-r})</span> is later queried to <span class="math">\\mathsf{H}</span>). We also modify the VDV oracle simulator <span class="math">\\mathsf{F}^{\\mathsf{VDV}}</span> such that it does not use <span class="math">x_{3}</span> directly but only indirectly via queries to a <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span> oracle. At the end of the first stage we obtain an efficient algorithm for the following primitive problem <span class="math">P[q_o,q_d]</span>:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>Problem <span class="math">P[q_{o}, q_{d}]</span>: Given <span class="math">(D_{G}, g) = \\mathsf{GC}(k)</span>, <span class="math">y_{1} = g^{x_{1}}</span> and <span class="math">y_{3} = g^{x_{3}}</span> for uniformly random <span class="math">x_{1}, x_{3} \\in \\mathbb{Z}_{q}</span>, <span class="math">q_{o}</span> distinct queries <span class="math">(u[1], \\ldots, u[q_{o}])</span> to oracle <span class="math">O(.)</span> (where <span class="math">r[i] = O(u[i])</span> is a uniformly random integer in <span class="math">\\mathbb{Z}_{2^{l_{H}}}</span>), and <span class="math">q_{d}</span> queries to restricted DDH oracle <span class="math">\\mathsf{DDH}_{x_{3}}(.,.)</span>, (where <span class="math">\\mathsf{DDH}_{x_{1}}(w, K)</span>,</li>

    </ol>

    <p class="text-gray-300">returns 1 if <span class="math">K = w^{x_1}</span> and 0 else), compute <span class="math">i^<em> \\in \\{1, \\ldots, q_o\\}</span> and <span class="math">K^</em> \\in G</span> such that <span class="math">K^<em> = (u[i^</em>] \\cdot y_1^{r[i^*]})^{x_3}</span>.</p>

    <p class="text-gray-300">In the second stage we show how to convert any efficient algorithm for primitive problem <span class="math">P[q_o, q_d]</span> into an efficient algorithm for SDH. This reduction is an application of the forking technique [11, 20], which involves running the attacker for <span class="math">P[q_o, q_d]</span> twice, answering its <span class="math">i^<em></span> th <span class="math">O(.)</span> query differently in the two runs to obtain two distinct solutions <span class="math">(i^</em>, K_1^<em>)</span> (with <span class="math">K_1^</em> = (u[i^<em>] \\cdot y_1^{r_1[i^</em>]})^{x_3}</span>) and <span class="math">(i^<em>, K_2^</em>)</span> (with <span class="math">K_2^<em> = (u[i^</em>] \\cdot y_1^{r_2[i^*]})^{x_3}</span>) for the <span class="math">P[q_o, q_d]</span> instance, from which the solution <span class="math">g^{x_1 x_3}</span> to the SDH instance can be recovered.</p>

    <p class="text-gray-300">We begin with the details of the 'Stage 1' reduction.</p>

    <p class="text-gray-300"><strong>Lemma A.1 (Stage 1).</strong> Any ST-UF-DV attacker A on scheme <span class="math">\\mathsf{SchUDVS}_1</span> with resources <span class="math">(t, q_s, q_v, q_H)</span> and success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A}, \\mathsf{SchUDVS}_1}^{\\mathsf{ST-UF-DV}}(k)</span> can be converted into an algorithm <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> for problem <span class="math">P[q_o, q_d]</span> with run-time <span class="math">t[P] = t + (q_s + q_v + q_H + 1)(T_S + O(l_H)) + O(q_s l_q T_g)</span> (where <span class="math">T_S = O(log_2(q_s + q_v + q_H)(\\ell + l_G))</span>), <span class="math">q_o = q_H + q_v</span> O oracle queries, <span class="math">q_d = q_v</span> DDH oracle queries, and success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_o, q_d]}(k) \\geq \\mathbf{Succ}_{\\mathsf{A}, \\mathsf{SchUDVS}_1}^{\\mathsf{ST-UF-DV}}(k) - [q_s(q_s + q_v + q_H) + 1] / 2^{l_H}</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Modified Attacker <span class="math">\\widehat{\\mathsf{A}}</span>. We first define a modified attacker <span class="math">\\widehat{\\mathsf{A}}</span> which is obtained from the original attacker <span class="math">\\mathsf{A}</span> in order to satisfy two properties (which may not be satisfied by <span class="math">\\mathsf{A}</span>): (1) Each <span class="math">H</span>-query <span class="math">(m_i, u_i)</span> of <span class="math">\\widehat{\\mathsf{A}}</span> is 'new' (i.e. unequal any earlier query <span class="math">(m_j, u_j)</span> to <span class="math">H(.)</span>), made either directly by <span class="math">\\widehat{\\mathsf{A}}</span> or indirectly by <span class="math">\\mathsf{S}</span>), and (2) For each VDV-query <span class="math">(y_{1,i}, m_i, u_i, K_i)</span> of <span class="math">\\widehat{\\mathsf{A}}</span>, the pair <span class="math">(m_i, u_i)</span> is not new (i.e. it is equal to an earlier query <span class="math">(m_j, u_j)</span> to <span class="math">H(.)</span> by either <span class="math">\\widehat{\\mathsf{A}}</span> or <span class="math">\\mathsf{S}</span> oracle). We obtain <span class="math">\\widehat{\\mathsf{A}}</span> as follows: <span class="math">\\widehat{\\mathsf{A}}</span> runs <span class="math">\\mathsf{A}</span> and stores in a sorted table <span class="math">T</span> the queries <span class="math">(m_i, u_i)</span> and corresponding responses <span class="math">r_i = H(m_i, u_i)</span> to <span class="math">\\mathsf{A}</span>'s and <span class="math">\\mathsf{S}</span> oracle's <span class="math">H</span>-queries. When <span class="math">\\mathsf{A}</span> makes an <span class="math">\\mathsf{S}</span>-query, <span class="math">\\mathsf{A}</span> forwards it to the <span class="math">\\mathsf{S}</span>-oracle and returns the signature <span class="math">(r_i, s_i)</span> to <span class="math">\\mathsf{A}</span>, adding query <span class="math">(m_i, u_i)</span> and response <span class="math">r_i</span> to table <span class="math">T</span>, where <span class="math">u_i = g^{s_i} \\cdot y_1^{-r_i}</span>. When <span class="math">\\mathsf{A}</span> makes a <span class="math">H</span> query <span class="math">(m_i, u_i)</span>, <span class="math">\\widehat{\\mathsf{A}}</span> first searches table <span class="math">T</span> for a matching earlier query <span class="math">(m_j, u_j)</span> and if found, answers <span class="math">r_i = r_j</span> from the table without querying <span class="math">H(.)</span> (if not found, <span class="math">\\widehat{\\mathsf{A}}</span> queries <span class="math">(m_i, u_i)</span> to <span class="math">H</span> answers response <span class="math">r_i</span> to <span class="math">\\mathsf{A}</span>, adding <span class="math">(m_i, u_i)</span> and response <span class="math">r_i</span> to <span class="math">T</span>). This modification implies property (1). Similarly, when <span class="math">\\mathsf{A}</span> makes a VDV oracle query <span class="math">(y_{1,i}, m_i, u_i, K_i)</span>, <span class="math">\\widehat{\\mathsf{A}}</span> searches <span class="math">T</span> for matching earlier query <span class="math">(m_j, u_j) = (m_i, u_i)</span> and if not found, it queries <span class="math">(m_i, u_i)</span> to <span class="math">H(.)</span> and updates <span class="math">T</span>. Then <span class="math">\\widehat{\\mathsf{A}}</span> forwards <span class="math">(y_{1,i}, m_i, u_i, K_i)</span> to VDV oracle and returns response to <span class="math">\\mathsf{A}</span>. This modification implies property (2). It is clear that <span class="math">\\widehat{\\mathsf{A}}</span> has the same success probability as <span class="math">\\mathsf{A}</span> (<span class="math">\\mathbf{Succ}_{\\widehat{\\mathsf{A}}, \\mathsf{SchUDVS}_1}^{\\mathsf{ST-UF-DV}} = \\mathbf{Succ}_{\\widehat{\\mathsf{A}}, \\mathsf{Sch}_{\\mathsf{II}}\\mathsf{DVS}_1}^{\\mathsf{ST-UF-DV}}</span>) and also the same number of S- and VDV- queries <span class="math">(q_s[\\widehat{\\mathsf{A}}] = q_s</span> and <span class="math">q_v[\\widehat{\\mathsf{A}}] = q_v</span>). However, the <span class="math">H</span>-query bound of <span class="math">\\widehat{\\mathsf{A}}</span> is larger due to modification (2) <span class="math">(q_H[\\widehat{\\mathsf{A}}] = q_H + q_v)</span>, and the running-time of <span class="math">\\widehat{\\mathsf{A}}</span> is also larger due to modifications (1) and (2) <span class="math">(t[\\widehat{\\mathsf{A}}] = t + O((q_v + q_H) \\log_2(q_s + q_v + q_H) \\cdot (\\ell + l_G)) + O(l_q T_g q_s))</span>, assuming a binary search by <span class="math">\\widehat{\\mathsf{A}}</span> through the sorted list of past <span class="math">H</span>-queries.</p>

    <p class="text-gray-300">We now consider several attack games, starting at the original attack <span class="math">\\mathsf{Game}_0</span> and modifying <span class="math">\\widehat{\\mathsf{A}}</span>'s view simulators to obtain the game <span class="math">\\mathsf{Game}_3</span> where <span class="math">\\widehat{\\mathsf{A}}</span> and its view simulators constitute the desired algorithm <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> against <span class="math">P[q_o, q_d]</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Game_0}</span>. This is the original forgery attack game UF-DV, where the view simulator <span class="math">\\mathsf{F} = (\\mathsf{F}^{\\mathsf{S}}, \\mathsf{F}^{\\mathsf{H}})</span> for <span class="math">\\widehat{\\mathsf{A}}</span> consists of the actual scheme's <span class="math">\\mathsf{S}</span> and <span class="math">H</span> oracles respectively. The game <span class="math">\\mathsf{Game_0}</span> runs as follows on outcome <span class="math">I</span> (we use bold letters to denote random variables which constitute the view of <span class="math">\\widehat{\\mathsf{A}}</span>, i.e. the inputs, oracle queries and responses of <span class="math">\\widehat{\\mathsf{A}}</span>, and output of <span class="math">\\widehat{\\mathsf{A}}</span>).</p>

    <p class="text-gray-300"><strong>Setup.</strong> We run <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">\\mathbf{I}_A = (\\mathbf{D_G}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span>, where <span class="math">(\\mathbf{D_G}, \\mathbf{g}) = \\mathsf{GC}(k), \\mathbf{y}_1 = \\mathbf{g}^{x_1}</span> for uniformly random <span class="math">x_1 \\in \\mathbb{Z}_q</span> and <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span> for uniformly random <span class="math">x_3 \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">16</p>

    <p class="text-gray-300">Oracle Queries. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th oracle query <span class="math">\\mathbf{Q}_i</span>, <span class="math">\\mathsf{F}</span> responds as follows:</p>

    <p class="text-gray-300">(1) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. If <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span> is an S-Query, <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> responds with <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span> computed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {r} _ {i} = H \\left(\\mathbf {m} _ {i}, \\mathbf {u} _ {i}\\right)</span></div>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {s} _ {i} = k _ {i} + \\mathbf {r} _ {i} \\cdot x _ {1}</span></div>

    <p class="text-gray-300">where <span class="math">u_{i} = \\mathbf{g}^{k_{i}}</span> for uniformly random <span class="math">k_{i}\\in \\mathbb{Z}_{q}</span></p>

    <p class="text-gray-300">(2) <span class="math">H</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{H}}</span>. If <span class="math">\\mathbf{Q}_i = (\\mathbf{m}_i, \\mathbf{u}_i)</span> is a <span class="math">H</span>-Query, <span class="math">\\mathsf{F}^{\\mathsf{H}}</span> responds with <span class="math">\\mathbf{R}_i = \\mathbf{r}_i</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {r} _ {i} = H \\left(\\mathbf {m} _ {i}, \\mathbf {u} _ {i}\\right)</span></div>

    <p class="text-gray-300">(3) VDV-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>. If <span class="math">\\mathbf{Q}_i = (\\mathbf{y}_{1,i}, \\mathbf{m}_i, (\\mathbf{u}_i, \\mathbf{K}_i))</span> is a VDV-Query, <span class="math">\\mathsf{F}^{\\mathsf{V}}</span> responds with <span class="math">\\mathbf{R}_i = \\mathbf{d}_i \\in \\{\\text{Acc}, \\text{Rej}\\}</span> defined as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {d} _ {i} = \\text{Acc if and only if } \\mathbf {K} _ {i} = \\left(\\mathbf {u} _ {i} \\cdot \\mathbf {y} _ {1} ^ {r _ {i}}\\right) ^ {x _ {3}}</span></div>

    <p class="text-gray-300">where <span class="math">r_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span></p>

    <p class="text-gray-300">Output. Eventually <span class="math">\\widehat{\\mathsf{A}}</span> outputs a forgery message/DV-sig. pair <span class="math">(\\mathbf{m}^{<em>},(\\mathbf{u}^{</em>},\\mathbf{K}^{*}))</span>.</p>

    <p class="text-gray-300">This completes the description of Game0.</p>

    <p class="text-gray-300">Let <span class="math">S_0</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\widehat{\\mathsf{A}}</span> breaks <span class="math">\\mathsf{SchUDVS}_1</span> in the sense of ST-UF-DV. By definition, this means:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf {S} _ {0} \\Rightarrow (\\mathrm {a}) \\mathbf {K} ^ {*} = \\left(\\mathbf {u} ^ {*} \\cdot \\mathbf {y} _ {1} ^ {r ^ {*}}\\right) ^ {x _ {3}} \\text{ (where } r ^ {*} = H \\left(\\mathbf {m} ^ {*}, \\mathbf {u} ^ {*}\\right) \\text{)} \\\\ \\text{(b) } \\mathbf {m} ^ {*} \\neq \\mathbf {m} _ {i} \\text{ for all } i \\in \\mathbf {W} ^ {S}, \\tag{5} \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{W}^S</span> denotes the set of S-query indices.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Bad}_0</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\widehat{\\mathsf{A}}</span> did not make a <span class="math">H</span>-query <span class="math">(\\mathbf{m}^<em>, \\mathbf{u}^</em>)</span> during the attack.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {B a d} _ {0} \\Rightarrow (\\mathbf {m} _ {i}, \\mathbf {u} _ {i}) \\neq (\\mathbf {m} ^ {*}, \\mathbf {u} ^ {*}) \\text{ for all } i \\in \\mathbf {W} ^ {H}, \\tag{6}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathbf{W}^H</span> denotes the set of H-query indices.</p>

    <p class="text-gray-300">Thanks to the randomness of <span class="math">H(.)</span>, we get:</p>

    <p class="text-gray-300"><strong>Claim A.1.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf {S} _ {0} \\wedge \\mathsf {B a d} _ {0} \\right] \\leq 1 / 2 ^ {l _ {H}}.</span></div>

    <p class="text-gray-300">Proof of Claim. If <span class="math">\\mathsf{Bad}_0</span> occurs, we know <span class="math">(\\mathbf{m}^<em>, \\mathbf{u}^</em>)</span> is not queried to <span class="math">H</span> by <span class="math">\\mathsf{A}</span> and also (by property (2) of <span class="math">\\widehat{\\mathsf{A}}</span> - see definition of <span class="math">\\widehat{\\mathsf{A}}</span>) not queried to <span class="math">H</span> by <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>. If <span class="math">\\mathsf{S}_0</span> also occurs, we know from (5)(b) that <span class="math">(\\mathbf{m}^<em>, \\mathbf{u}^</em>)</span> is not queried to <span class="math">H</span> by <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> either. Hence if <span class="math">\\mathsf{S}_0 \\wedge \\mathsf{Bad}_0</span> occurs, then <span class="math">(\\mathbf{m}^<em>, \\mathbf{u}^</em>)</span> is not queried to <span class="math">H</span> during the game, and therefore <span class="math">\\widehat{\\mathsf{A}}</span>'s view (and hence its output <span class="math">(\\mathbf{K}^<em>, \\mathbf{u}^</em>)</span>) is independent of <span class="math">r^<em> = H(\\mathbf{m}^</em>, \\mathbf{u}^<em>)</span>, which is in turn uniformly distributed in <span class="math">\\mathbb{Z}_{2^{l_H}}</span>. Since the mapping <span class="math">r^</em> \\mapsto (\\mathbf{u}^<em> \\mathbf{y}_1^{r^</em>})^{x_3}</span> is one-to-one over <span class="math">\\mathbb{Z}_{2^{l_H}}</span> (because <span class="math">2^{l_H} &amp;lt; q</span> and <span class="math">x_1</span> and <span class="math">x_3</span> are non-zero elements of <span class="math">\\mathbb{Z}_q</span>), there is only one outcome for <span class="math">r^<em></span> (out of <span class="math">2^{l_H}</span> equiprobable outcomes) such that <span class="math">(\\mathbf{u}^</em> \\mathbf{y}_1^{r^<em>})^{x_3} = \\mathbf{K}^</em></span> is satisfied. The claim follows.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Bad}_0^1</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that a <span class="math">\\mathbf{u}_i = g^{k_i}</span> used by S-oracle in answering an S-query matches a previous <span class="math">\\mathbf{u}_j</span> appearing in an earlier query to <span class="math">H</span> by either <span class="math">\\widehat{\\mathsf{A}}</span> or S-oracle:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf {B a d} _ {0} ^ {1} \\Rightarrow \\text{There exists } i \\in \\mathbf {W} ^ {S} \\text{ such that } \\mathbf {u} _ {i} = \\mathbf {u} _ {j} \\text{ for some } j &amp;lt; i. \\tag{7}</span></div>

    <p class="text-gray-300">Thanks to the randomness of the <span class="math">k_{i}</span>'s we get:</p>

    <p class="text-gray-300"><strong>Claim A.2.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathsf {B a d} _ {0} ^ {1} \\right] \\leq q _ {s} \\left(q _ {s} + q _ {v} + q _ {H}\\right) / 2 ^ {l _ {H}}.</span></div>

    <p class="text-gray-300">Proof of Claim. For each <span class="math">i</span>th <span class="math">\\mathsf{S}</span>-query, there are at most <span class="math">q_{s}[\\widehat{\\mathsf{A}}] + q_{H}[\\widehat{\\mathsf{A}}] = q_{s} + q_{v} + q_{H}</span> previous <span class="math">\\mathbf{u}_j</span>'s that <span class="math">\\mathbf{u}_i</span> can collide with. Since <span class="math">\\mathbf{u}_i = g^{k_i}</span> is uniformly distributed in <span class="math">G</span> which has order <span class="math">q</span>, <span class="math">\\mathbf{u}_i</span> has probability at most <span class="math">(q_s + q_v + q_H) / q &amp;lt; (q_s + q_v + q_H) / 2^{l_H}</span> to collide with a previous <span class="math">\\mathbf{u}_j</span>. Since there are <span class="math">q_{s}[\\widehat{\\mathsf{A}}] = q_{s}</span> <span class="math">\\mathsf{S}</span>-queries overall, the claim follows.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{S}_0^2</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\mathsf{S}_0</span> occurs but neither <span class="math">\\mathsf{Bad}_0</span> nor <span class="math">\\mathsf{Bad}_0^1</span> occur. That is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{S}_0^2 \\Rightarrow \\quad (\\mathrm{a}) \\text{ There exists } \\mathbf{i}^* \\in \\mathbf{W}^H \\text{ such that } \\mathbf{K}^* = (\\mathbf{u}_{\\mathbf{i}^*} \\cdot \\mathbf{y}_1^{\\mathbf{r}_{\\mathbf{i}^*}})^{x_3} \\\\ \\quad \\text{ and } (\\mathbf{m}_{\\mathbf{i}^*}, \\mathbf{u}_{\\mathbf{i}^*}) = (\\mathbf{m}^*, \\mathbf{u}^*) \\\\ \\quad (\\mathrm{b}) \\mathbf{m}^* \\neq \\mathbf{m}_i \\text{ for all } i \\in \\mathbf{W}^S \\\\ \\quad (\\mathrm{c}) \\mathbf{u}_i \\neq \\mathbf{u}_j \\text{ for all } j &amp;lt; i \\text{ and } i \\in \\mathbf{W}^S. \\end{array} \\tag{8}</span></div>

    <p class="text-gray-300">The above results immediately give:</p>

    <p class="text-gray-300"><strong>Claim A.3.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathsf{S}_0^2] \\geq \\Pr[\\mathsf{S}_0] - \\frac{q_s (q_s + q_v + q_H) + 1}{2^{l_H}}.</span></div>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> We have <span class="math">\\operatorname<em>{Pr}[\\mathsf{S}_0^2] = \\operatorname</em>{Pr}[\\mathsf{S}_0 \\land \\neg \\mathsf{Bad}_0 \\land \\neg \\mathsf{Bad}_0^1] \\geq \\operatorname<em>{Pr}[\\mathsf{S}_0 \\land \\neg \\mathsf{Bad}_0] - \\operatorname</em>{Pr}[\\mathsf{Bad}_0^1] \\geq \\operatorname<em>{Pr}[\\mathsf{S}_0] - \\operatorname</em>{Pr}[\\mathsf{Bad}_0] - \\operatorname*{Pr}[\\mathsf{Bad}_0^1]</span>. The claim now follows from Claims A.1 and A.2.</p>

    <p class="text-gray-300"><strong><span class="math">\\mathsf{Game}_1</span></strong>. In this game we modify the S-oracle simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> for <span class="math">\\widehat{\\mathsf{A}}</span>. The new simulator returns signatures <span class="math">(r_i, s_i)</span> where <span class="math">r_i</span> is just a uniformly random string <span class="math">\\rho_i</span> in <span class="math">\\mathbb{Z}_{2^{l_H}}</span>, without querying <span class="math">(m_i, u_i)</span> to <span class="math">\\mathsf{H}</span>. The game <span class="math">\\mathsf{Game}_1</span> runs as follows.</p>

    <p class="text-gray-300"><strong>Setup.</strong> We run <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">\\mathbf{I}_A = (\\mathbf{D_G}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span>, where <span class="math">(\\mathbf{D_G}, \\mathbf{g}) = \\mathsf{GC}(k)</span> and <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span> for uniformly random <span class="math">x_1 \\in \\mathbb{Z}_q</span> and <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span> for uniformly random <span class="math">x_3 \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300"><strong>Oracle Queries.</strong> When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th oracle query <span class="math">\\mathbf{Q}_i</span>, <span class="math">\\mathsf{F}</span> responds as follows:</p>

    <p class="text-gray-300">(1) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. If <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span> is an S-Query, <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> responds with <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span> computed as follows:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathbf{r}_i = \\rho_i \\text{ for uniformly random } \\rho_i \\in \\mathbb{Z}_{2^{l_H}} \\\\ \\mathbf{s}_i = k_i + \\mathbf{r}_i \\cdot x_1 \\\\ \\text{where } u_i = \\mathbf{g}^{k_i} \\text{ for uniformly random } k_i \\in \\mathbb{Z}_q \\end{array}</span></div>

    <p class="text-gray-300">(2) <span class="math">H</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{H}}</span>. As in <span class="math">\\mathsf{Game}_0</span>.</p>

    <p class="text-gray-300">(3) VDV-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>. As in <span class="math">\\mathsf{Game}_0</span>.</p>

    <p class="text-gray-300"><strong>Output.</strong> Eventually <span class="math">\\widehat{\\mathsf{A}}</span> outputs a forgery message/DV-sig. pair <span class="math">(\\mathbf{m}^<em>, (\\mathbf{u}^</em>, \\mathbf{K}^*))</span>.</p>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{Game}_1</span>. Let <span class="math">\\mathsf{S}_1^2</span> denote the event in <span class="math">\\mathsf{Game}_1</span> corresponding to <span class="math">\\mathsf{S}_0^2</span> in <span class="math">\\mathsf{Game}_0</span> (i.e. <span class="math">\\mathsf{S}_1^2</span> is also defined by (8) over the view of <span class="math">\\widehat{\\mathsf{A}}</span>).</p>

    <p class="text-gray-300"><strong>Claim A.4.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathsf{S}_1^2] \\geq \\Pr[\\mathsf{S}_0^2].</span></div>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> For outcomes in <span class="math">\\mathsf{S}_0^2</span> in <span class="math">\\mathsf{Game}_0</span>, the <span class="math">\\mathbf{u}_i</span> for each <span class="math">i</span>th S-query is 'new' and hence by randomness of <span class="math">H(.)</span> the responses <span class="math">\\mathbf{r}_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span> are uniform and independent in <span class="math">\\mathbb{Z}_{2^{l_H}}</span>. Furthermore, <span class="math">H(.)</span> is never queried again at <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span> during the game. Thus for each outcome in <span class="math">\\mathsf{S}_0^2</span> in <span class="math">\\mathsf{Game}_0</span> there is a corresponding outcome in <span class="math">\\mathsf{S}_1^2</span> in <span class="math">\\mathsf{Game}_1</span>, where the outcomes for <span class="math">\\rho_i</span> in <span class="math">\\mathsf{Game}_1</span> coincide with outcomes for <span class="math">H(\\mathbf{m}_i, \\mathbf{u}_i)</span> in <span class="math">\\mathsf{Game}_0</span> for all <span class="math">i \\in \\mathbf{W}^S</span>, maintaining the view of <span class="math">\\mathsf{A}</span> unchanged. Since the <span class="math">\\rho_i</span>'s are uniform and independent in <span class="math">\\mathbb{Z}_{2^{l_H}}</span> this outcome has the same probability in <span class="math">\\mathsf{Game}_1</span> as the original outcome in <span class="math">\\mathsf{Game}_0</span>. The claim follows.</p>

    <p class="text-gray-300"><span class="math">\\mathbf{Game_2}</span>. In this game we further modify the S-oracle simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> for <span class="math">\\widehat{\\mathsf{A}}</span>. The new simulator returns signatures <span class="math">(r_i, s_i)</span> where <span class="math">s_i</span> set equal to a uniformly random element <span class="math">\\zeta_i</span> in <span class="math">\\mathbb{Z}_q</span>, thus eliminating the use of <span class="math">x_1</span> by <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>.</p>

    <p class="text-gray-300">Setup. We run <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">\\mathbf{I}_A = (\\mathbf{D_G}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span>, where <span class="math">(\\mathbf{D_G}, \\mathbf{g}) = \\mathsf{GC}(k)</span> and <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span> for uniformly random <span class="math">x_1 \\in \\mathbb{Z}_q</span> and <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span> for uniformly random <span class="math">x_3 \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">Oracle Queries. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th oracle query <span class="math">\\mathbf{Q}_i</span>, <span class="math">\\mathsf{F}</span> responds as follows:</p>

    <p class="text-gray-300">(1) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. If <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span> is an S-Query, <span class="math">\\mathsf{F}^{\\mathsf{S}}</span> responds with <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span> computed as follows: <span class="math">\\mathbf{r}_i = \\rho_i</span> for uniformly random <span class="math">\\rho_i \\in \\mathbb{Z}_{2^l H}</span> <span class="math">\\mathbf{s}_i = \\zeta_i</span> for uniformly random <span class="math">\\zeta_i \\in \\mathbb{Z}_q</span></p>

    <p class="text-gray-300">(2) <span class="math">H</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{H}}</span>. As in <span class="math">\\mathsf{Game}_0</span>.</p>

    <p class="text-gray-300">(3) VDV-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>. As in <span class="math">\\mathsf{Game}_0</span>.</p>

    <p class="text-gray-300">Output. Eventually <span class="math">\\widehat{\\mathsf{A}}</span> outputs a forgery message/DV-sig. pair <span class="math">(\\mathbf{m}^{<em>}, (\\mathbf{u}^{</em>}, \\mathbf{K}^{*}))</span>.</p>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{Game}_2</span>. Let <span class="math">\\mathsf{S}_2^2</span> denote the event in <span class="math">\\mathsf{Game}_2</span> corresponding to <span class="math">\\mathsf{S}_1^2</span> in <span class="math">\\mathsf{Game}_1</span> (i.e. <span class="math">\\mathsf{S}_2^2</span> is also defined by (8) over the view of <span class="math">\\widehat{\\mathsf{A}}</span>).</p>

    <p class="text-gray-300">Claim A.5.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ S _ {2} ^ {2} \\right] \\geq \\Pr \\left[ S _ {1} ^ {2} \\right].</span></div>

    <p class="text-gray-300">Proof of Claim. In <span class="math">\\mathsf{Game}_1</span>, the <span class="math">\\mathbf{s}_i = k_i + \\mathbf{r}_i \\cdot x_1 \\bmod q</span> signature portions are uniformly random in <span class="math">\\mathbb{Z}_q</span> and independent of <span class="math">\\mathbf{r}_i</span>, thanks to the uniformly random and independent choice of <span class="math">k_i \\in \\mathbb{Z}_q</span> and the fact that mapping <span class="math">k_i \\mapsto k_i + \\mathbf{r}_i \\cdot x_1 \\bmod q</span> is a permutation of <span class="math">\\mathbb{Z}_q</span>. Hence, in <span class="math">\\mathsf{Game}_2</span>, setting <span class="math">\\mathbf{s}_i = \\zeta_i</span> for uniformly random and independent <span class="math">\\zeta_i \\in \\mathbb{Z}_q</span> leaves the view of <span class="math">\\widehat{\\mathsf{A}}</span> unchanged and immediately gives the claimed result.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_3</span>. In this game we modify the VDV-oracle simulator <span class="math">\\mathsf{F}^{\\mathsf{V}}</span> for <span class="math">\\widehat{\\mathsf{A}}</span> to use <span class="math">x_3</span> only indirectly via calls to a <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span> oracle. We also eliminate calls to <span class="math">H(.)</span> by <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>, using the fact that <span class="math">\\widehat{\\mathsf{A}}</span> never makes 'new' <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span> queries to VDV.</p>

    <p class="text-gray-300">Setup. We run <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">\\mathbf{I}_A = (\\mathbf{D_G}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span>, where <span class="math">(\\mathbf{D_G}, \\mathbf{g}) = \\mathsf{GC}(k)</span> and <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span> for uniformly random <span class="math">x_1 \\in \\mathbb{Z}_q</span> and <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span> for uniformly random <span class="math">x_3 \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">Oracle Queries. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th oracle query <span class="math">\\mathbf{Q}_i</span>, <span class="math">\\mathsf{F}</span> responds as follows:</p>

    <p class="text-gray-300">(1) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. As in <span class="math">\\mathsf{Game}_2</span>.</p>

    <p class="text-gray-300">(2) <span class="math">H</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{H}}</span>. As in <span class="math">\\mathsf{Game}_0</span>.</p>

    <p class="text-gray-300">(3) VDV-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>. If <span class="math">\\mathbf{Q}_i = (\\mathbf{y}_{1,i}, \\mathbf{m}_i, (\\mathbf{u}_i, \\mathbf{K}_i))</span> is a VDV-Query, <span class="math">\\mathsf{F}^{\\mathsf{V}}</span> responds with <span class="math">\\mathbf{R}_i = \\mathbf{d}_i \\in \\{\\mathsf{Acc}, \\mathsf{Rej}\\}</span> defined as follows:</p>

    <p class="text-gray-300"><span class="math">\\mathbf{d}_i = \\text{Acc}</span> if and only if <span class="math">\\mathsf{DDH}_{x_3}(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i}, \\mathbf{K}_i) = 1</span></p>

    <p class="text-gray-300">where <span class="math">r_i = \\mathbf{r}_j</span> and <span class="math">j \\in \\mathbf{W}^S \\vee \\mathbf{W}^H</span> is the index</p>

    <p class="text-gray-300">of a previous matching query <span class="math">(\\mathbf{m}_j, \\mathbf{u}_j) = (\\mathbf{m}_i, \\mathbf{u}_i)</span></p>

    <p class="text-gray-300">Output. Eventually <span class="math">\\widehat{\\mathsf{A}}</span> outputs a forgery message/DV-sig. pair <span class="math">(\\mathbf{m}^{<em>}, (\\mathbf{u}^{</em>}, \\mathbf{K}^{*}))</span>.</p>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{Game}_3</span>. Let <span class="math">\\mathsf{S}_3^2</span> denote the event in <span class="math">\\mathsf{Game}_3</span> corresponding to <span class="math">\\mathsf{S}_2^2</span> in <span class="math">\\mathsf{Game}_2</span> (i.e. <span class="math">\\mathsf{S}_3^2</span> is also defined by (8) over the view of <span class="math">\\widehat{\\mathsf{A}}</span>).</p>

    <p class="text-gray-300">Claim A.6.</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ S _ {3} ^ {2} \\right] \\geq \\Pr \\left[ S _ {2} ^ {2} \\right].</span></div>

    <p class="text-gray-300">Proof of Claim. In <span class="math">\\mathsf{Game}_2</span>, the test by <span class="math">\\mathsf{F}^{\\mathsf{V}}</span> if <span class="math">(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i})^{x_3} = \\mathbf{K}_i</span> or not, is equivalent to testing if <span class="math">\\mathsf{DDH}_{x_3}(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i}, \\mathbf{K}_i) = 1</span>, as used in <span class="math">\\mathsf{Game}_3</span>. The method of computing <span class="math">\\mathbf{r}_i</span> in <span class="math">\\mathsf{Game}_3</span> is equivalent to querying <span class="math">(\\mathbf{m_i}, \\mathbf{u}_i)</span> to <span class="math">H(.)</span> because by construction of <span class="math">\\widehat{\\mathsf{A}}</span>, <span class="math">(\\mathbf{m_i}, \\mathbf{u}_i)</span> must have previously appeared in a <span class="math">H</span>- or S- query.</p>

    <p class="text-gray-300">So in <span class="math">\\mathsf{Game}_3</span>, <span class="math">\\widehat{\\mathsf{A}}</span> with its view simulators constitutes an algorithm <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> for problem <span class="math">P[q_o, q_d]</span>, which on input <span class="math">(D_G, g, y_1 = g^{x_1}, y_3 = g^{x_3})</span>, makes <span class="math">q_o \\stackrel{\\mathrm{def}}{=} q_H[\\widehat{\\mathsf{A}}] = q_H + q_v</span> distinct queries <span class="math">\\mathbf{u}_i</span> to a random oracle <span class="math">O(.)</span> (the <span class="math">H(.)</span>-queries of <span class="math">\\mathsf{F}^{\\mathsf{H}}</span>) receiving answers <span class="math">\\mathbf{r}_i</span> uniform in <span class="math">\\mathbb{Z}_{2^{l_H}}</span>, and <span class="math">q_d \\stackrel{\\mathrm{def}}{=} q_v[\\widehat{\\mathsf{A}}] = q_v</span> queries to the <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span> oracle (the DDH queries of <span class="math">\\mathsf{F}^{\\mathsf{V}}</span>), and outputs <span class="math">(\\mathbf{i}^<em>, \\mathbf{K}^</em>)</span> such that <span class="math">\\mathbf{K}^<em> = (\\mathbf{u}_{\\mathbf{i}^</em>} \\cdot \\mathbf{y}_1^{\\mathbf{r}_{\\mathbf{i}^<em>}})^{x_3}</span> with probability at least <span class="math">\\operatorname</em>{Pr}[\\mathsf{S}_3^2] \\geq \\mathsf{Succ}_{\\mathsf{A}, \\mathsf{SchUDVS}_1}^{\\mathrm{ST-UF-DV}}(k) - [q_s(q_s + q_v + q_H) + 1] / 2^{l_H}</span>, using claims A.1 to A.6. The run-time of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> is the sum of the run-time <span class="math">t[\\widehat{\\mathsf{A}}] = t + O((q_v + q_H) \\log_2(q_s + q_v + q_H) \\cdot (\\ell + l_G)) + O(l_q T_g q_s)</span> of <span class="math">\\widehat{\\mathsf{A}}</span>, the run-time <span class="math">t[\\mathsf{F}^{\\mathsf{V}}] = O((q_v + q_H) \\log_2(q_s + q_v + q_H) \\cdot (\\ell + l_G)) + O(l_q T_g q_s)</span> of <span class="math">\\mathsf{F}^{\\mathsf{V}}</span> (assuming a binary search is used as for obtaining <span class="math">\\widehat{\\mathsf{A}}</span> from <span class="math">\\mathsf{A}</span>), and the time <span class="math">O(\\log_2(q_s + q_v + q_H) \\cdot (\\ell + l_G))</span> for <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> to search for <span class="math">\\mathbf{i}^<em></span> such that <span class="math">(\\mathbf{m}^</em>, \\mathbf{u}^<em>) = (\\mathbf{m}_{\\mathbf{i}^</em>}, \\mathbf{u}_{\\mathbf{i}^*})</span> . This establishes the lemma.</p>

    <p class="text-gray-300">We will need the following lemma [20] in the analysis of the forking technique for the 'Stage 2' reduction. A proof can be found in [20] but we provide one here also for completeness.</p>

    <p class="text-gray-300">Lemma A.2 (Splitting Lemma[20]). Let <span class="math">a</span> and <span class="math">b</span> denote independent random variables over finite sets <span class="math">A</span> and <span class="math">B</span>, respectively, with probability mass functions <span class="math">P_A(.)</span> and <span class="math">P_B(.)</span>, respectively. Let <span class="math">S \\subseteq A \\times B</span> be a set with <span class="math">\\operatorname*{Pr}[S] \\geq \\epsilon</span>. For each <span class="math">a \\in A</span>, let <span class="math">S(a) \\subseteq B</span> denote the set of <span class="math">b \\in B</span> such that <span class="math">(a, b) \\in S</span>. Then there exists a 'good' subset <span class="math">G</span> of <span class="math">S</span> such that:</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ G ] \\geq \\epsilon / 2</span></div>

    <p class="text-gray-300">and, for all <span class="math">(a,b)\\in G</span></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr [ S (a) ] \\geq \\epsilon / 2.</span></div>

    <p class="text-gray-300">Proof. Let us define the good set <span class="math">G</span> to be the set of all <span class="math">(a, b) \\in S</span> such that <span class="math">\\operatorname{Pr}[S(a)] \\geq \\epsilon / 2</span>. Then it is enough to show that <span class="math">\\operatorname{Pr}[G] \\geq \\epsilon / 2</span>.</p>

    <p class="text-gray-300">Suppose, towards a contradiction, that <span class="math">\\operatorname<em>{Pr}[G] &amp;lt; \\epsilon / 2</span>. Then <span class="math">\\operatorname</em>{Pr}[S] = \\operatorname<em>{Pr}[G] + \\operatorname</em>{Pr}[S \\wedge \\neg G] &amp;lt; \\epsilon / 2 + \\operatorname<em>{Pr}[S \\wedge \\neg G]</span>. But <span class="math">(a, b) \\in S \\wedge \\neg G</span> means that <span class="math">a \\in W_A</span>, where <span class="math">W_A \\subseteq A</span> is the set of <span class="math">a \\in A</span> such that <span class="math">\\operatorname</em>{Pr}[S(a)] &amp;lt; \\epsilon / 2</span>. So <span class="math">\\operatorname<em>{Pr}[S \\wedge \\neg G] = \\sum_{a \\in W_A} \\sum_{b \\in S(a)} P_A(a) P_B(b) = \\sum_{a \\in W_A} P_A(a) \\cdot \\operatorname</em>{Pr}[S(a)] &amp;lt; \\epsilon / 2</span> since <span class="math">\\sum_{b \\in S(a)} P_B(b) = \\operatorname<em>{Pr}[S(a)] &amp;lt; \\epsilon / 2</span> for all <span class="math">a \\in W_A</span>. It follows that <span class="math">\\operatorname</em>{Pr}[S] &amp;lt; \\epsilon / 2 + \\epsilon / 2 = \\epsilon</span>, a contradiction. This shows that <span class="math">\\operatorname*{Pr}[G] \\geq \\epsilon / 2</span>, which completes the proof.</p>

    <p class="text-gray-300">We will also use the following inequality.</p>

    <p class="text-gray-300">Lemma A.3. Let <span class="math">p = \\sum_{j=1}^{q} p_j</span> for some <span class="math">q</span> real numbers <span class="math">p_1, \\ldots, p_q</span> and let <span class="math">\\delta &amp;gt; 0</span> be given. If <span class="math">p \\geq q \\cdot \\delta</span> then the following inequality holds:</p>

    <div class="my-4 text-center"><span class="math-block">\\sum_ {j = 1} ^ {q} p _ {j} \\cdot (p _ {j} - \\delta) \\geq (1 / q) \\cdot (p - q \\cdot \\delta) ^ {2}.</span></div>

    <p class="text-gray-300">Proof. We have <span class="math">\\sum_{j=1}^{q} p_j \\cdot (p_j - \\delta) = \\sum_{j=1}^{q} p_j^2 - p \\cdot \\delta</span>. Using the Cauchy-Schwartz inequality we have <span class="math">\\sum_{j=1}^{q} p_j^2 \\geq (1/q) \\cdot (\\sum_{j=1}^{q} p_j)^2 = (1/q) \\cdot p^2</span>, so <span class="math">\\sum_{j=1}^{q} p_j \\cdot (p_j - \\delta) \\geq (1/q)(p^2 - q \\cdot \\delta \\cdot p)</span>. But from the</p>

    <p class="text-gray-300">assumption that <span class="math">p \\geq q \\cdot \\delta</span>, we have <span class="math">(q \\cdot \\delta)p \\geq (q \\cdot \\delta)^2</span> and hence <span class="math">p^2 - q \\cdot \\delta \\cdot p \\geq p^2 - 2(q \\cdot \\delta)p + (q \\cdot \\delta)^2 = (p - q \\cdot \\delta)^2</span>, which gives the claimed inequality.</p>

    <p class="text-gray-300"><strong>Lemma A.4 (Stage 2).</strong> Any algorithm <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> for problem <span class="math">P[q_{o}, q_{d}]</span> with run-time <span class="math">t[P]</span> and success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_{o}, q_{d}]}(k) \\geq 2q_{o} / 2^{l_{H}}</span> can be converted into an algorithm <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> for SDH with run-time <span class="math">t[S] = 2t[P] + O(l_{q}^{2} + l_{q}T_{g})</span> which makes <span class="math">q[S] = 2q_{d}</span> DDH queries, and has success probability <span class="math">\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{S}}, \\mathsf{SDH}}(k) \\geq (1 / q_{o}) \\cdot [\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_{o}, q_{d}]}(k) / 2 - q_{o} / 2^{l_{H}}]^{2}</span>. Here <span class="math">T_{g}</span> denotes the time to perform a group operation in <span class="math">G</span>.</p>

    <p class="text-gray-300"><strong>Proof.</strong> Given SDH input instance <span class="math">(D_G, g, y_1 = g^{x_1}, y_2 = g^{x_2})</span>, our SDH algorithm <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> works as follows (we assume without loss of generality that <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s DDH oracle is <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span>).</p>

    <p class="text-gray-300"><strong>Setup.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> first sets up two random vectors <span class="math">\\overrightarrow{r} = (r[1], \\ldots, r[q_o])</span> and <span class="math">\\overrightarrow{\\overline{r}} = (\\widehat{r}[1], \\ldots, \\widehat{r}[q_o])</span> with <span class="math">r[i]</span>'s and <span class="math">\\widehat{r}[i]</span>'s chosen uniformly and independently at random from <span class="math">\\mathbb{Z}_{2^{l_H}}</span> (these vectors will be used to answer <span class="math">\\mathsf{A}_{\\mathsf{P}}</span>'s <span class="math">O(.)</span> queries).</p>

    <p class="text-gray-300"><strong>First Run.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> on input <span class="math">(D_g, g, y_1, y_2; \\omega)</span>, where <span class="math">\\omega</span> is a random bit string used as the randomness input of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> (if <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> is randomized), and answers its oracle queries as follows:</p>

    <p class="text-gray-300">(1) <span class="math">O(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{O}}</span>. When <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> makes its <span class="math">i</span>th <span class="math">O(\\cdot)</span> query <span class="math">u[i]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">r[i]</span>. (2) <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{D}}</span>. When <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> makes its <span class="math">i</span>th <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span> query <span class="math">(w[i], K[i])</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> simply forwards the query to its <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span> oracle and forwards the oracle's response <span class="math">d[i]</span> to <span class="math">\\mathsf{A}_{\\mathsf{P}}</span>.</p>

    <p class="text-gray-300"><strong>First Run Output.</strong> At the end of first run, <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> outputs <span class="math">(i^{<em>},K^{</em>})</span> (note that if this run is successful then <span class="math">K^{<em>} = (u[i^{</em>}]\\cdot y_{1}^{r[i^{*}]})^{x_{2}}</span>).</p>

    <p class="text-gray-300"><strong>Second Run.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> again on the same input <span class="math">(D_g, g, y_1, y_2; \\omega)</span> as used in first run, but answers its oracle queries differently as follows:</p>

    <p class="text-gray-300">(1) <span class="math">O(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{O}}</span>. When <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> makes its <span class="math">i</span>th <span class="math">O(\\cdot)</span> query <span class="math">u[i]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">r[i]</span> for <span class="math">i &amp;lt; i^{<em>}</span> and with <span class="math">\\widehat{r}[i]</span> for <span class="math">i \\geq i^{</em>}</span>. (2) <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span>-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{D}}</span>. Answered as in first run.</p>

    <p class="text-gray-300"><strong>Second Run Output.</strong> At the end of second run, <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> outputs <span class="math">(\\widehat{i^{<em>}},\\widehat{K^{</em>}})</span> (note that if this run is successful and <span class="math">\\widehat{i^{<em>}} = i^{</em>}</span> then <span class="math">\\widehat{K^{<em>}} = (u[i^{</em>}]\\cdot y_{1}^{\\widehat{r}[i^{*}]})^{x_{2}}</span>).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s output. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> computes and returns an estimate <span class="math">K \\stackrel{\\mathrm{def}}{=} (\\widehat{K^{<em>}} / K^{</em>})^{(\\widehat{r}[i^{<em>}] - r[i^{</em>}])^{-1} \\bmod q}</span> for the SDH instance solution <span class="math">g^{x_1 x_2}</span> (if <span class="math">\\widehat{r}[i^<em>] = r[i^</em>]</span> then <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> fails).</p>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>. The running-time of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is twice the run-time of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> plus the time to compute <span class="math">K</span> at the end, which can be done in time <span class="math">O(l_q^2 + l_q \\cdot T_g)</span>. The number of <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span> queries made by <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is up to twice the number of queries made by <span class="math">\\mathsf{A}_{\\mathsf{P}}</span>. This establishes the claimed resources of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>.</p>

    <p class="text-gray-300">We now lower bound the success probability of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>. For <span class="math">i \\in \\{1, \\ldots, q_{o}\\}</span>, we call a run of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> <span class="math">i</span>-successful if <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> succeeds and <span class="math">i^{<em>} = i</span>. Note that if both first and second runs of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> are <span class="math">i</span>-successful for some <span class="math">i</span>, then we have <span class="math">i^{</em>} = \\widehat{i^{<em>}} = i</span>, <span class="math">K^{</em>} = (u[i] \\cdot y_{1}^{r[i]})^{x_{2}}</span> and <span class="math">\\widehat{K^{*}} = (u[i] \\cdot y_{1}^{\\widehat{r[i]})^{x_{2}}}</span> (note that <span class="math">u[1], \\ldots, u[i]</span> are the same in both runs because the view of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> is the same up to <span class="math">i</span>th <span class="math">O(.)</span> query response) and consequently <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s estimate <span class="math">K</span> is correct (whenever <span class="math">r[i] \\neq \\widehat{r}[i]</span> so <span class="math">(\\widehat{r}[i] - r[i])^{-1} \\bmod q</span> exists) because <span class="math">K = [(u[i] \\cdot y_{1}^{r[i]})^{x_{2}} / (u[i] \\cdot y_{1}^{\\widehat{r}[i]})^{x_{2}}]^{(\\widehat{r}[i] - r[i])^{-1} \\bmod q} = y_{1}^{x_{2}} = g^{x_{1}x_{2}}</span>).</p>

    <p class="text-gray-300">So it remains to lower bound the probability of the event <span class="math">S^<em></span> that both runs of <span class="math">A_P</span> are <span class="math">i</span>-successful for some <span class="math">i \\in \\{1, \\ldots, q_o\\}</span> and <span class="math">\\widehat{r}[i] \\neq r[i]</span>. To do this, we split <span class="math">S^</em></span> into <span class="math">q_o</span> disjoint subevents <span class="math">S_i^*</span> according to</p>

    <p class="text-gray-300">21</p>

    <p class="text-gray-300">value of <span class="math">i</span> and bound each one. For each <span class="math">i</span>, let <span class="math">A_i</span> denote the outcome space for the random variable <span class="math">a_i = (D_g, g, y_1, y_2, \\omega, r[1], \\ldots, r[i-1])</span> consisting of the view of <span class="math">\\mathsf{A}^{\\mathsf{P}}</span> up to the <span class="math">i</span>th query to <span class="math">O(.)</span>, and let <span class="math">B_i</span> denote the outcome space for the independent random variable <span class="math">b_i = (r[i], \\ldots, r[q_o])</span> consisting of the view of <span class="math">\\mathsf{A}^{\\mathsf{P}}</span> after the <span class="math">i</span>th query to <span class="math">O(.)</span> (including the response <span class="math">r[i]</span> to the <span class="math">i</span>th query). Note that the event <span class="math">\\mathsf{S}_i</span> that a run of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> is <span class="math">i</span>-successful is a subset of <span class="math">A_i \\times B_i</span> with probability <span class="math">p_i \\stackrel{\\text{def}}{=} \\operatorname<em>{Pr}[(a_i, b_i) \\in \\mathsf{S}_i]</span>. Applying the Splitting Lemma A.2, we know that there exists a subevent <span class="math">\\mathsf{G}_i</span> of <span class="math">\\mathsf{S}_i</span> such that <span class="math">\\operatorname</em>{Pr}[(a_i, b_i) \\in \\mathsf{G}_i] \\geq p_i / 2</span>, and for each <span class="math">(a, b) \\in \\mathsf{G}_i</span>, the probability that <span class="math">(a, \\widehat{b}) \\in \\mathsf{S}_i</span> over a random choice of <span class="math">\\widehat{b}</span> in <span class="math">B_i</span> is also at least <span class="math">p_i / 2</span>. Hence, the probability that the outcome <span class="math">(a, b)</span> of the first run of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> in our algorithm is in <span class="math">\\mathsf{G}_i</span> is at least <span class="math">p_i / 2</span>, and then for each of those outcomes, the probability over the random choice of <span class="math">\\widehat{b} = (\\widehat{r}[i], \\ldots, \\widehat{r}[q_o])</span> that the second run outcome <span class="math">(a, \\widehat{b})</span> is in <span class="math">\\mathsf{S}_i</span> is at least <span class="math">p_i / 2</span>. Since <span class="math">\\widehat{r}[i]</span> is uniformly chosen in <span class="math">\\mathbb{Z}_{2^{l_H}}</span>, the chance that it collides with <span class="math">r[i]</span> is <span class="math">1 / 2^{l_H}</span>, so with probability at least <span class="math">p_i / 2 - 1 / 2^{l_H}</span> over <span class="math">\\widehat{b}</span> we know that <span class="math">(a, \\widehat{b}) \\in \\mathsf{S}_i</span> and also <span class="math">\\widehat{r}[i] \\neq r[i]</span>. Summarizing, we have that the probability that (1) <span class="math">(a, b) \\in \\mathsf{G}_i</span> and (2) <span class="math">(a, \\widehat{b}) \\in \\mathsf{S}_i</span> and (3) <span class="math">\\widehat{r}[i] \\neq r[i]</span> all occur is at least <span class="math">p_i / 2(p_i / 2 - 1 / 2^{l_H})</span>. This latter event implies that both runs are <span class="math">i</span>-successful and <span class="math">\\widehat{r}[i] \\neq r[i]</span>, i.e. that event <span class="math">\\mathsf{S}_i^*</span> occurs. Hence</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathrm {S} _ {\\mathrm {i}} ^ {*} \\right] \\geq p _ {i} / 2 \\left(p _ {i} / 2 - 1 / 2 ^ {l _ {H}}\\right) \\text { for all } i \\in \\{1, \\dots , q _ {o} \\}, \\tag {9}</span></div>

    <p class="text-gray-300">and since <span class="math">p_i</span> is the probability that a run of <span class="math">\\mathsf{A}_{\\mathsf{P}}</span> is <span class="math">i</span>-successful, we know that <span class="math">\\sum_{i=1}^{q_o} p_i = \\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_o, q_d]}(k)</span>. Assuming that <span class="math">\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_o, q_d]}(k) \\geq 2q_o / 2^{l_H}</span>, we apply Lemma A.3 to (9) to get</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathrm {S} ^ {*} \\right] = \\sum_ {i = 1} ^ {q _ {o}} \\Pr \\left[ \\mathrm {S} _ {\\mathrm {i}} ^ {*} \\right] \\geq \\left(1 / q _ {o}\\right) \\cdot \\left(\\mathbf {S u c c} _ {\\mathrm {A} _ {\\mathrm {P}}, P \\left[ q _ {o}, q _ {d} \\right]} (k) / 2 - q _ {o} / 2 ^ {l _ {H}}\\right) ^ {2}, \\tag {10}</span></div>

    <p class="text-gray-300">which is the desired lower-bound on <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s success probability.</p>

    <p class="text-gray-300">To complete the proof of the theorem, we apply to A the Stage 1 reduction (Lemma A.1) followed by the Stage 2 reduction (Lemma A.4) and obtain an algorithm <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> for SDH with the claimed success probability bound (4) and resources <span class="math">t[S]</span> and <span class="math">q[S]</span>, as claimed.</p>

    <h2 id="sec-24" class="text-2xl font-bold">B Proof of Theorem 4.2</h2>

    <p class="text-gray-300">The proof is straightforward but we give the details for completeness. To show the perfect unconditional privacy, assuming the direct verifier key-reg. protocol is used, we show how to use construct the forgery strategy <span class="math">\\widehat{\\mathsf{A}_1}</span> which, for any given privacy attacker pair <span class="math">(\\mathsf{A}_1,\\mathsf{A}_2)</span>, will perfectly simulate the DV signature answers to <span class="math">\\mathsf{A}_1</span>'s designation queries <span class="math">y_{3,i}</span> without the message <span class="math">m^*</span> being signed by the signer, using the corresponding secret key <span class="math">x_{3,i}</span> that <span class="math">\\mathsf{A}_1</span> registered with <span class="math">y_{3,i}</span> during a previous key-reg. query. This shows that the convincing measure <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1,\\mathsf{A}_2)</span> is zero for any <span class="math">(\\mathsf{A}_1,\\mathsf{A}_2)</span>, as required.</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which <span class="math">\\mathsf{A}_1</span> and <span class="math">\\mathsf{A}_2</span> interact.</p>

    <p class="text-gray-300">Stage 1. The pair <span class="math">(\\mathsf{A}_1,\\mathsf{A}_2)</span> is run on input <span class="math">(D_G,g,y_1 = g^{x_1})</span>. <span class="math">\\mathsf{A}_1</span>'s oracle queries are answered as follows.</p>

    <p class="text-gray-300">(1) <span class="math">\\mathsf{S}(x_1,.)</span> Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th <span class="math">\\mathsf{S}</span>-query <span class="math">m_i</span>, it is answered with <span class="math">\\sigma_i = \\mathsf{S}(x_1, m_i)</span>.</p>

    <p class="text-gray-300">(2) KRA Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th key-reg. query <span class="math">(x_{3,i},y_{3,i})</span> it is answered <span class="math">Acc</span> if <span class="math">g^{x_{3,i}} = y_{3,i}</span> and <span class="math">Rej</span> else.</p>

    <p class="text-gray-300">(3) <span class="math">\\mathsf{A}_2</span> Queries. When <span class="math">\\mathsf{A}_1</span> sends message <span class="math">m_i</span> to <span class="math">\\mathsf{A}_2</span>, <span class="math">\\mathsf{A}_2</span> responds with an answer <span class="math">a_i</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">\\mathsf{A}_1</span> outputs a challenge message <span class="math">m^<em></span> which is given to <span class="math">\\mathsf{A}_2</span>. A PV signature <span class="math">\\sigma_i = (r^</em>, s^<em>) = \\mathsf{S}(x_1, m^</em>)</span> is generated, where <span class="math">r^<em> = H(m^</em>, u^<em>)</span> for <span class="math">u^</em> = g^{k^<em>}</span> for uniformly random <span class="math">k^</em> \\in \\mathbb{Z}_q</span>, and <span class="math">s^<em> = k^</em> + r^* \\cdot x_1 \\mod q</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">\\mathsf{A}_1</span> continues to make S,KRA and <span class="math">\\mathsf{A}_2</span> queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th CDV-query <span class="math">y_{3,i}</span>, it is answered with DV signature <span class="math">\\widehat{\\sigma}_i = \\mathrm{CDV}(y_1, y_{3,i}, m^<em>, \\sigma^</em>) = (\\widehat{u}_i, \\widehat{K}_i)</span>, where <span class="math">\\widehat{u}_i = g^{s^<em>} \\cdot y_1^{-r^</em>}</span> and <span class="math">\\widehat{K}_i = y_{3,i}^{s^*}</span>.</p>

    <p class="text-gray-300">End of Stage 2. <span class="math">\\mathsf{A}_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">Game no. We now describe the other game where <span class="math">\\widehat{\\mathsf{A}_1}</span> interacts with <span class="math">\\mathsf{A}_2</span>.</p>

    <p class="text-gray-300">Stage 1. The pair <span class="math">(\\widehat{\\mathsf{A}_1}, \\mathsf{A}_2)</span> is run on input <span class="math">(D_G, g, y_1 = g^{x_1})</span>, where <span class="math">\\widehat{\\mathsf{A}_1}</span> is also given the program for <span class="math">\\mathsf{A}_1</span> as input. <span class="math">\\widehat{\\mathsf{A}_1}</span> now runs <span class="math">\\mathsf{A}_1</span> on same input and answers <span class="math">\\mathsf{A}_1</span>'s oracle queries as follows.</p>

    <p class="text-gray-300">(1) <span class="math">\\mathsf{S}(x_1,.)</span> Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th S-query <span class="math">m_i</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> forwards it to S oracle and forwards response <span class="math">\\sigma_i = \\mathsf{S}(x_1, m_i)</span> back to <span class="math">\\mathsf{A}_1</span>.</p>

    <p class="text-gray-300">(2) KRA Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th key-reg. query <span class="math">(x_{3,i},y_{3,i})</span> <span class="math">\\widehat{\\mathsf{A}_1}</span> answers <span class="math">Acc</span> if <span class="math">g^{x_{3,i}} = y_{3,i}</span> and stores <span class="math">(x_{3,i},y_{3,i},Acc)</span> in a table <span class="math">T</span>, else it answers <span class="math">Rej</span>.</p>

    <p class="text-gray-300">(3) <span class="math">\\mathsf{A}_2</span> Queries. When <span class="math">\\mathsf{A}_1</span> outputs a message <span class="math">m_i</span> for <span class="math">\\mathsf{A}_2</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> forwards it to <span class="math">\\mathsf{A}_2</span> and forwards the answer <span class="math">a_i</span> back to <span class="math">\\mathsf{A}_1</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">\\mathsf{A}_1</span> outputs a challenge message <span class="math">m^<em></span>, which is also output by <span class="math">\\widehat{\\mathsf{A}_1}</span> and given to <span class="math">\\mathsf{A}_2</span>. <span class="math">\\widehat{\\mathsf{A}_1}</span> computes <span class="math">u^</em> = g^{k^<em>}</span> and <span class="math">r^</em> = H(m^<em>, u^</em>)</span>, for a uniformly random <span class="math">k^* \\in \\mathbb{Z}_q</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">\\mathsf{A}_1</span> continues to make S,KRA and <span class="math">\\mathsf{A}_2</span> queries, answered by <span class="math">\\widehat{\\mathsf{A}_1}</span> as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th CDV-query <span class="math">y_{3,i}</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> searches table <span class="math">T</span> for an entry <span class="math">(x_{3,j}, y_{3,j}, Acc)</span> with <span class="math">y_{3,j} = y_{3,i}</span> (note that this entry is guaranteed to exist in <span class="math">T</span> due to the restriction on <span class="math">\\mathsf{A}_1</span> to only query CDV with public keys which have been answered with <span class="math">Acc</span> by a previous KRA query) and answers with <span class="math">\\widehat{\\sigma}_i = (\\widehat{u}_i, \\widehat{K}_i)</span>, where <span class="math">\\widehat{u}_i = u^<em></span> and <span class="math">\\widehat{K}_i = (u^</em> \\cdot y^{-r^*})^{x_{3,j}}</span>.</p>

    <p class="text-gray-300">End of Stage 2. <span class="math">\\mathsf{A}_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">Note that <span class="math">\\mathsf{A}_1</span>'s (and hence also <span class="math">\\mathsf{A}_2</span>) view is perfectly simulated in Game no as in Game yes. This is because in both games <span class="math">u^<em></span> and <span class="math">r^</em></span> are computed identically and the DV signatures <span class="math">(u_i, K_i)</span> are also identical in both games because <span class="math">\\widehat{u}_i = g^{s^<em>} \\cdot y_1^{-r^</em>} = u^<em></span> in Game yes and <span class="math">u_i = u^</em></span> in Game no for all <span class="math">i</span>, and <span class="math">\\widehat{K}_i = y_{3,i}^{s^<em>} = g^{x_{3,i}s^</em>} = (u^<em>y^{-r^</em>})^{x_{3,i}}</span> in Game yes and <span class="math">\\widehat{K}_i = (u^<em> \\cdot y^{-r^</em>})^{x_{3,j}} = (u^<em> \\cdot y^{-r^</em>})^{x_{3,i}}</span> in Game no. All other oracles are simulated identically in both games. So <span class="math">\\mathsf{A}_2</span> outputs yes with same probability in both games and hence <span class="math">C_{\\widehat{\\mathsf{A}}_1}(\\mathsf{A}_1, \\mathsf{A}_2) = 0</span>, as claimed. The run-time of <span class="math">\\widehat{\\mathsf{A}}_1</span> is the run-time of <span class="math">\\mathsf{A}_1</span> plus the time <span class="math">q_{d1}O(l_qT_g + q_{d1}l_G) + q_{k1}O(l_qT_g)</span> to answer <span class="math">\\mathsf{A}_1</span>'s CDV and KRA queries. Note that <span class="math">\\widehat{q_{s1}} = q_{s1}</span>, <span class="math">\\widehat{q_{c1}} = q_{c1}</span>, and <span class="math">\\widehat{q_{k1}} = 0</span>, as claimed.</p>

    <h2 id="sec-25" class="text-2xl font-bold">C Proof of Theorem 4.3</h2>

    <p class="text-gray-300">We show how to use any efficient forging attacker <span class="math">\\mathsf{A}</span> for breaking scheme <span class="math">\\mathsf{SchUDVS}_2</span> in the sense of ST-UF-DV with non-negligible probability to construct (1) an efficient attacker <span class="math">\\mathsf{A}_S</span> for breaking the PV unforgeability of scheme <span class="math">\\mathsf{SchUDVS}_2</span> (i.e. the unforgeability of the Schnorr signature scheme), and (2) an efficient attacker <span class="math">\\mathsf{A}_T</span> for breaking the collision-resistance of the trapdoor hash scheme <span class="math">\\mathsf{TH}</span>, such that at least one of <span class="math">\\mathsf{A}_S</span> or <span class="math">\\mathsf{A}_T</span> succeed with non-negligible probability. More precisely, we show that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf{S u c c}_{\\mathsf{A}_S, \\mathsf{S c h U D V S}_2}^{\\mathrm{U F - P V}}(k) + \\mathbf{S u c c}_{\\mathsf{A}_T, \\mathsf{T H}}^{\\mathrm{C R}}(k) \\geq \\frac{1}{4(q_J + q_v)q_s} \\cdot \\left[ \\mathbf{S u c c}_{\\mathsf{A}, \\mathsf{S c h U D V S}_2}^{\\mathrm{S T - U F - D V}}(k) - \\frac{2(q_J + q_v)q_s + 1}{2^{l_J}} \\right]^2, \\tag{11}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> have resources <span class="math">(t[S], q_s[S], q_H[S])</span> and <span class="math">(t[T])</span> respectively, as defined in the theorem statement. The theorem then follows immediately from (11), by taking maximums over all attackers <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> with the given running time. It remains to construct <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> and show (11).</p>

    <p class="text-gray-300"><strong>Modified Attacker <span class="math">\\widehat{\\mathsf{A}}</span>.</strong> Similar to the proof of Theorem 4.1, we first define a <em>modified</em> attacker <span class="math">\\widehat{\\mathsf{A}}</span> which is obtained from the original attacker <span class="math">\\mathsf{A}</span> in order to satisfy two properties (which may not be satisfied by <span class="math">\\mathsf{A}</span>): (1) Each <span class="math">J</span>-query <span class="math">(m_i, r_i, u_i, \\widehat{h}_i)</span> of <span class="math">\\widehat{\\mathsf{A}}</span> is 'new' (i.e. unequal any earlier query to <span class="math">J(.)</span> made by <span class="math">\\widehat{\\mathsf{A}}</span>), and (2) <span class="math">\\widehat{\\mathsf{A}}</span> does not make any VDV queries. Since the VDV oracle of <span class="math">\\mathsf{A}</span> can be simulated knowing only the verifier's public key <span class="math">pk_3</span>, and using one query to <span class="math">H(.)</span> and <span class="math">J(.)</span> per VDV query, we can easily transform <span class="math">\\mathsf{A}</span> into <span class="math">\\widehat{\\mathsf{A}}</span> such that <span class="math">\\widehat{\\mathsf{A}}</span>'s resources (denoted with hats) are related to <span class="math">\\mathsf{A}</span>'s resources as follows: <span class="math">\\widehat{q}_s = q_s</span>, <span class="math">\\widehat{q}_v = 0</span>, <span class="math">\\widehat{q}_H = q_H + q_v</span>, <span class="math">\\widehat{q}_J = q_J + q_v</span>, and <span class="math">\\widehat{t} = t + O((q_J + q_v)\\log_2(q_J + q_v)\\cdot (\\ell + l_G + l_F)) + O(l_qT_gq_v)</span>.</p>

    <p class="text-gray-300"><strong>Game₀.</strong> Let <span class="math">\\mathsf{Game}_0</span> denote the original forgery attack game. In this game, let <span class="math">(m_i, r_i, u_i, \\widehat{h}_i)</span> denote the <span class="math">i</span>th <span class="math">J(.)</span> query of <span class="math">\\widehat{\\mathsf{A}}</span> and <span class="math">\\widehat{r}_i</span> the corresponding answer, let <span class="math">(m^<em>, u^</em>, \\widehat{r}_F^<em>, \\widehat{r}^</em>, \\widehat{s}^*)</span> denote the output forgery of <span class="math">\\widehat{\\mathsf{A}}</span>, and let <span class="math">m_i&#x27;</span> denote the <span class="math">i</span>th S-query of <span class="math">\\widehat{\\mathsf{A}}</span>. Let <span class="math">\\mathsf{S}_0</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\widehat{\\mathsf{A}}</span> breaks <span class="math">\\mathsf{SchUDVS}_2</span> in the sense of ST-UF-DV. By definition, this means:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{S}_0 \\Rightarrow \\quad (\\mathrm{a}) \\, J(m^*, r^*, u^*, \\widehat{h}^*) = \\widehat{r}^*, \\text{ where } r^* = H(m^*, u^*), \\, \\widehat{h}^* = F_{pk}(\\widehat{u}^*; \\widehat{r}_F^*), \\, \\widehat{u}^* = g^{\\widehat{s}^*}(u^* y_1^{r^*})^{-\\widehat{r}^*} \\\\ \\quad \\quad (\\mathrm{b}) \\, m^* \\neq m_i&#x27; \\text{ for all } i \\in W^S, \\tag{12} \\end{array}</span></div>

    <p class="text-gray-300">where <span class="math">W^S</span> denotes the set <span class="math">\\{1, \\ldots, q_s\\}</span> of S-query indices.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{Bad}_0</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\widehat{\\mathsf{A}}</span> did not make a <span class="math">J</span>-query <span class="math">(m^<em>, r^</em>, u^<em>, \\widehat{h}^</em>)</span> during the attack.</p>

    <div class="my-4 text-center"><span class="math-block">\\mathsf{Bad}_0 \\Rightarrow (m_i, r_i, u_i, \\widehat{h}_i) \\neq (m^*, r^*, u^*, \\widehat{h}^*) \\text{ for all } i \\in W^J, \\tag{13}</span></div>

    <p class="text-gray-300">where <span class="math">W^J</span> denotes the set <span class="math">\\{1, \\ldots, q_J\\}</span> of <span class="math">J</span>-query indices.</p>

    <p class="text-gray-300">Thanks to the randomness of <span class="math">J(.)</span>, we get:</p>

    <p class="text-gray-300"><strong>Claim C.1.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathsf{S}_0 \\wedge \\mathsf{Bad}_0] \\leq 1/2^{l_J}.</span></div>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> If <span class="math">\\mathsf{Bad}_0</span> occurs, we know <span class="math">(m^<em>, r^</em>, u^<em>, \\widehat{h}^</em>)</span> is not queried to <span class="math">J(.)</span> during the game, and therefore <span class="math">\\widehat{\\mathsf{A}}</span>'s view (and hence its output <span class="math">(m^<em>, u^</em>, \\widehat{r}_F^<em>, \\widehat{r}^</em>, \\widehat{s}^<em>)</span>) is independent of <span class="math">J(m^</em>, r^<em>, u^</em>, \\widehat{h}^<em>)</span>, which is in turn uniformly distributed in <span class="math">\\mathbb{Z}_{2^{l_J}}</span>. Hence if <span class="math">\\mathsf{Bad}_0</span> occurs the chance that <span class="math">\\widehat{r}^</em> = J(m^<em>, r^</em>, u^<em>, \\widehat{h}^</em>)</span> (so <span class="math">\\mathsf{S}_0</span> also occurs) is <span class="math">1/2^{l_J}</span>. The claim follows.</p>

    <p class="text-gray-300">Let <span class="math">\\mathsf{S}_0^1</span> denote the event in <span class="math">\\mathsf{Game}_0</span> that <span class="math">\\mathsf{S}_0</span> occurs but <span class="math">\\mathsf{Bad}_0</span> does not. That is:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf{S}_0^1 \\Rightarrow \\quad (\\mathrm{a}) \\, \\text{There exists } i^* \\in W^J \\text{ such that } (m^*, r^*, u^*) = (m_{i^*}, r_{i^*}, u_{i^*}) \\\\ \\quad \\quad \\text{and} \\, F_{pk}(g^{\\widehat{s}^*} \\cdot (u_{i^*} y_1^{r_{i^*}})^{-\\widehat{r}_{i^*}}; \\widehat{r}_F^*) = \\widehat{h}_{i^*} \\text{ and } r_{i^*} = H(m_{i^*}, u_{i^*}) \\\\ \\quad \\quad (\\mathrm{b}) \\, m^* \\neq m_i&#x27; \\text{ for all } i \\in W^S \\tag{14} \\end{array}</span></div>

    <p class="text-gray-300">The above results immediately give:</p>

    <p class="text-gray-300"><strong>Claim C.2.</strong></p>

    <div class="my-4 text-center"><span class="math-block">\\Pr[\\mathsf{S}_0^1] \\geq \\Pr[\\mathsf{S}_0] - \\frac{1}{2^{l_J}}.</span></div>

    <p class="text-gray-300"><strong>Proof of Claim.</strong> We have <span class="math">\\Pr[\\mathsf{S}_0^1] = \\Pr[\\mathsf{S}_0 \\wedge \\neg \\mathsf{Bad}_0] \\geq \\Pr[\\mathsf{S}_0] - \\Pr[\\mathsf{Bad}_0] \\geq \\Pr[\\mathsf{S}_0] - 1/2^{l_J}</span> using Claim C.1.</p>

    <p class="text-gray-300">□</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_{1}</span>. In <span class="math">\\mathsf{Game}_{1}</span>, we construct the algorithm <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> against the PV-unforgeability of <span class="math">\\mathsf{SchUDVS}_{2}</span>. On input <span class="math">(k, D_{G}, g, y_{1})</span> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs as follows.</p>

    <p class="text-gray-300">Setup. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> first sets up two random vectors <span class="math">\\overrightarrow{\\widehat{r}}[1] = (\\widehat{r}_1[1], \\ldots, \\widehat{r}_{\\widehat{q}_J}[1])</span> and <span class="math">\\overrightarrow{\\widehat{r}}[2] = (\\widehat{r}_1[2], \\ldots, \\widehat{r}_{\\widehat{q}_J}[2])</span> with <span class="math">\\widehat{r}_i[1]</span>'s and <span class="math">\\widehat{r}_i[2]</span>'s chosen uniformly and independently at random from <span class="math">\\mathsf{Z}_{2^{l_J}}</span> (these vectors will be used to answer <span class="math">\\mathsf{A}_{\\mathsf{P}}</span>'s <span class="math">J(.)</span> queries). <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> also generates a <span class="math">\\mathsf{TH}</span> key-pair <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span>.</p>

    <p class="text-gray-300">First Run. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">(D_G, g, y_1, pk; \\omega)</span>, where <span class="math">\\omega</span> is a random bit string used as the randomness input of <span class="math">\\widehat{\\mathsf{A}}</span>, and answers <span class="math">\\widehat{\\mathsf{A}}</span>'s oracle queries as follows:</p>

    <p class="text-gray-300">(1) <span class="math">J(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^J</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th <span class="math">J(\\cdot)</span> query <span class="math">(m_i[1], r_i[1], u_i[1], \\widehat{h}_i[1])</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\widehat{r}_i[1]</span>. (2) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">j</span>th S query <span class="math">m_j^\\prime [1]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> simply forwards the query to its S oracle and forwards the oracle's response <span class="math">\\sigma_{j}[1]</span> back to <span class="math">\\widehat{\\mathsf{A}}</span>. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> stores the query-answer pair <span class="math">(m_j^\\prime [1],\\sigma_j[1])</span> in a table <span class="math">T</span>.</p>

    <p class="text-gray-300">First Run Output. At the end of first run, <span class="math">\\widehat{\\mathsf{A}}</span> outputs the forgery <span class="math">(m^{<em>}[1], u^{</em>}[1], \\widehat{r}_{F}^{<em>}[1], \\widehat{r}^{</em>}[1], \\widehat{s}^{<em>}[1])</span>. Note that if this run is successful then there exists <span class="math">i^{</em>} \\in W^{J}</span> such that <span class="math">\\widehat{\\mathsf{A}}</span>'s forgery satisfies (14). We also define <span class="math">j^{<em>} \\in W^{S}</span> as the number of S-queries made by <span class="math">\\widehat{\\mathsf{A}}</span> before issuing its <span class="math">i^{</em>}</span>th <span class="math">J</span>-query. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> finds <span class="math">(i^{<em>}, j^{</em>})</span> from a table of <span class="math">\\widehat{\\mathsf{A}}</span>'s queries in time <span class="math">O(\\widehat{q}_J(\\ell + l_F + l_G) + l_q T_g)</span> (if <span class="math">i^{*}</span> doesn't exist, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> fails).</p>

    <p class="text-gray-300">Second Run. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs <span class="math">\\widehat{\\mathsf{A}}</span> again on the same input <span class="math">(D_g, g, y_1, pk; \\omega)</span> as used in first run, but answers its oracle queries differently as follows:</p>

    <p class="text-gray-300">(1) <span class="math">J(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^J</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th <span class="math">J(\\cdot)</span> query <span class="math">(m_i[2], r_i[2], u_i[2], \\widehat{h}_i[2])</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\widehat{r}_i[1]</span> for <span class="math">i &amp;lt; i^<em></span> and with <span class="math">\\widehat{r}_i[2]</span> for <span class="math">i \\geq i^</em></span>. (2) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">j</span>th S query <span class="math">m_j^\\prime [2]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\sigma_{j}[1]</span> for <span class="math">j\\leq j^{<em>}</span>. For <span class="math">j &amp;gt; j^{</em>}</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> forwards the query to its S oracle and forwards the oracle's response <span class="math">\\sigma_{j}[2]</span> back to <span class="math">\\widehat{\\mathsf{A}}</span>.</p>

    <p class="text-gray-300">Second Run Output. At the end of second run, <span class="math">\\widehat{\\mathsf{A}}</span> outputs the forgery <span class="math">(m^{<em>}[2], u^{</em>}[2], \\widehat{r}_{F}^{<em>}[2], \\widehat{r}^{</em>}[2], \\widehat{s}^{*}[2])</span>.</p>

    <p class="text-gray-300"><span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s output. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> computes and returns an estimate <span class="math">(\\widehat{m}^{<em>}, (\\widehat{r}^{</em>}, \\widehat{s}^{<em>}))</span> for a message/PV sig. for every for <span class="math">\\mathsf{SchUDVS}_2</span>, where <span class="math">\\widehat{m}^{</em>} = m^{<em>}[1]</span>, <span class="math">\\widehat{r}^{</em>} = H(m^{<em>}[1], u^{</em>}[1])</span> and <span class="math">\\widehat{s}^{<em>} = (\\widehat{s}^{</em>}[1] - \\widehat{s}^{<em>}[2]) \\cdot (\\widehat{r}_{i^{</em>}}[2] - \\widehat{r}_{i^{<em>}}[1])^{-1} \\mod q</span> (if <span class="math">\\widehat{r}_{i^{</em>}}[1] = \\widehat{r}_{i^{*}}[2]</span> then <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> fails).</p>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>. The running-time of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is twice the run-time of <span class="math">\\widehat{\\mathsf{A}}</span> plus the time to compute <span class="math">(i^{<em>}, j^{</em>})</span> and <span class="math">\\widehat{s}^{*}</span> at the end, which takes total time <span class="math">O(\\widehat{q}_J(\\ell + l_F + l_G) + l_q T_g + l_q^2)</span>. The number of <span class="math">H</span>- and <span class="math">\\mathsf{S}</span>-queries made by <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is up to twice the number of queries made by <span class="math">\\widehat{\\mathsf{A}}</span>. This establishes the claimed resources of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>.</p>

    <p class="text-gray-300">The collision-finder attacker <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> runs <span class="math">\\widehat{\\mathsf{A}}</span> twice in the same way as <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>, and at the end computes the following collision estimate <span class="math">(\\alpha[1], \\beta[1])</span>, <span class="math">(\\alpha[2], \\beta[2])</span>, where <span class="math">\\alpha[\\rho] = (u_{i^<em>}[1] \\cdot y_1^{r_{i^</em>}[1]})^{-\\widehat{r}_{i^*}[\\rho]}</span> and <span class="math">\\beta[\\rho] = \\widehat{r}_F[\\rho]</span> for <span class="math">\\rho \\in \\{1, 2\\}</span>.</p>

    <p class="text-gray-300">We now lower bound the sum of success probabilities of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span>. For each <span class="math">(i,j) \\in W^{J} \\times W^{S}</span>, we call a run of <span class="math">\\widehat{\\mathsf{A}}</span> <span class="math">(i,j)</span>-successful if <span class="math">\\widehat{\\mathsf{A}}</span>'s output satisfies (14) and <span class="math">(i^{<em>}, j^{</em>}) = (i,j)</span>. Let <span class="math">\\mathsf{S}^{<em>}</span> denote the event that both runs of <span class="math">\\widehat{\\mathsf{A}}</span> above are <span class="math">(i,j)</span>-successful for some <span class="math">(i,j)</span> and <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span>. Note that if <span class="math">\\mathsf{S}^{</em>}</span> occurs then, defining <span class="math">s^{*}</span> as the discrete-log <span class="math">u_i[1] \\cdot y_1^{r_i[1]}</span> to base <span class="math">g</span> in <span class="math">G</span>, we have from (14) that</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {m} ^ {*} = m ^ {*} [ 1 ] = m _ {i} [ 1 ] = m ^ {*} [ 2 ] = m _ {i} [ 2 ] \\text{ has not been queried to S during either run of} \\widehat {\\mathsf {A}} \\tag {15}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">F _ {p k} \\left(g ^ {\\widehat {s} _ {i} [ 1 ]} \\cdot \\left(g ^ {s ^ {*}}\\right) ^ {- \\widehat {r} _ {i} [ 1 ]}; \\widehat {r} _ {F} ^ {*} [ 1 ]\\right) = F _ {p k} \\left(g ^ {\\widehat {s} _ {i} [ 1 ]} \\cdot \\left(g ^ {s ^ {*}}\\right) ^ {- \\widehat {r} _ {i} [ 2 ]}; \\widehat {r} _ {F} ^ {*} [ 2 ]\\right) \\tag {16}</span></div>

    <p class="text-gray-300"><span class="math">m_{i}[1],r_{i}[1],u_{i}[1])=(m_{i}[2],r_{i}[2],u_{i}[2])</span> because the view of <span class="math">\\widehat{\\mathsf{A}}</span> is the same in both runs up to <span class="math">i</span>th <span class="math">J(.)</span> query response). We now split event <span class="math">\\mathsf{S}^{<em>}</span> into two disjoint subevents <span class="math">\\mathsf{S}_{\\mathsf{S}}^{</em>}</span> and <span class="math">\\mathsf{S}_{\\mathsf{T}}^{*}</span>, depending on whether</p>

    <p class="text-gray-300"><span class="math">g^{\\widehat{s}_{i}[1]}\\cdot(g^{s^{<em>}})^{-\\widehat{r}_{i}[1]}=g^{\\widehat{s}_{i}[1]}\\cdot(g^{s^{</em>}})^{-\\widehat{r}_{i}[2]}</span> (17)</p>

    <p class="text-gray-300">holds or not, respectively. If the subevent <span class="math">\\mathsf{S}_{\\mathsf{S}}^{<em>}</span> occurs, then (17) holds and hence <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>’s estimate <span class="math">\\widehat{s}^{</em>}</span> is equal to the discrete-log <span class="math">s^{<em>}=(\\widehat{s}^{</em>}[1]-\\widehat{s}^{<em>}[2])\\cdot(\\widehat{r}_{i^{</em>}}[2]-\\widehat{r}_{i^{<em>}}[1])^{-1}</span> mod <span class="math">q</span> of <span class="math">u_{i}[1]y_{1}^{r_{i}[1]}</span> and <span class="math">r_{i}[1]=H(m_{i}[1],u_{i}[1])</span>. Thus <span class="math">\\mathsf{S}_{\\mathsf{S}}^{</em>}</span> implies that <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>’s forgery is valid and coupled with (15) means that <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> succeeds to break the PV unforgeability of <span class="math">\\mathsf{SchUDVS}_{2}</span> in this case. In the other case that subevent <span class="math">\\mathsf{S}_{\\mathsf{T}}^{*}</span> occurs, (17) does not hold but (16) holds, meaning that <span class="math">\\mathsf{A}_{\\mathsf{T}}</span>’s output is a valid collision for the trapdoor hash so <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> succeeds.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">So we have shown that the sum of success probabilities of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> is equal to the probability of the event <span class="math">\\mathsf{S}^{<em>}</span> that both runs of <span class="math">\\widehat{\\mathsf{A}}</span> are <span class="math">(i,j)</span>-successful for some <span class="math">(i,j)\\in W^{J}\\times W^{S}</span> and <span class="math">\\widehat{r}_{i}[1]\\neq\\widehat{r}_{i}[2]</span>, and it remains to lower bound <span class="math">\\Pr[\\mathsf{S}^{</em>}]</span>. To do this, we split <span class="math">\\mathsf{S}^{*}</span> into $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">W_{J}\\times W^{S}</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">=\\widehat{q}_{J}q_{s}<span class="math"> disjoint subevents </span>\\mathsf{S}^{*}_{i,j}<span class="math"> according the value of </span>(i,j)<span class="math"> and bound each one. For each </span>(i,j)<span class="math">, let </span>A_{i,j}<span class="math"> denote the outcome space for the random variable </span>a_{i,j}=(D_{g},g,y_{1},pk,\\omega,(r_{1},\\ldots,r_{i-1}),(k_{1},\\ldots,k_{j}))<span class="math"> consisting of the view of </span>\\widehat{\\mathsf{A}}<span class="math"> up to the </span>i<span class="math">th query to </span>O(.)<span class="math"> and the random elements </span>k_{i}<span class="math"> used by </span>\\mathsf{S}<span class="math"> oracle to answer first </span>j<span class="math"> signature queries, and let </span>B_{i,j}<span class="math"> denote the outcome space for the independent random variable </span>b_{i,j}=((r_{i},\\ldots,r_{\\widehat{q}_{J}}),(k_{j+1},\\ldots,k_{q_{s}}))<span class="math"> consisting of the view of </span>\\mathsf{A}^{\\mathsf{P}}<span class="math"> after the </span>i<span class="math">th query to </span>O(.)<span class="math"> (including the response </span>r[i]<span class="math"> to the </span>i<span class="math">th query) and </span>k_{i}<span class="math">’s used to answer all remaining signature queries . Note that the event </span>\\mathsf{S}_{i,j}<span class="math"> that a run of </span>\\widehat{\\mathsf{A}}<span class="math"> is </span>(i,j)<span class="math">-successful is a subset of </span>A_{i,j}\\times B_{i,j}<span class="math"> with probability </span>p_{i,j}\\stackrel{{\\scriptstyle\\rm def}}{{=}}\\Pr[(a_{i,j},b_{i,j})\\in\\mathsf{S}_{i,j}]$. Proceeding from this point analgously to the calculation in Lemma A.4, we apply the Splitting Lemma A.2 and obtain</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{S}^{*}_{i,j}]\\geq p_{i,j}/2(p_{i,j}/2-1/2^{l_{J}})\\text{ for all }(i,j)\\in W^{J}\\times W^{S},</span> (18)</p>

    <p class="text-gray-300">and hence applying Lemma A.3 to (18) noting that <span class="math">\\sum_{i,j}p_{i,j}=\\Pr[\\mathsf{S}_{\\mathsf{0}}^{1}]</span> we get</p>

    <p class="text-gray-300"><span class="math">\\Pr[\\mathsf{S}^{<em>}]=\\sum_{(i,j)\\in W^{J}\\times W^{S}}\\Pr[\\mathsf{S}^{</em>}_{i,j}]\\geq\\frac{1}{\\widehat{q}_{J}q_{s}}\\cdot\\left(\\Pr[\\mathsf{S}_{\\mathsf{0}}^{1}]/2-\\widehat{q}_{J}q_{s}/2^{l_{J}}\\right)^{2},</span> (19)</p>

    <p class="text-gray-300">which using Claim C.2 gives the desired lower-bound (11) on <span class="math">\\Pr[\\mathsf{S}^{*}]</span>. This completes the proof. <span class="math">\\Box</span></p>

    <h2 id="sec-26" class="text-2xl font-bold">Appendix D Proof of Theorem 4.4</h2>

    <p class="text-gray-300">To show the perfect unconditional privacy, assuming the <em>direct</em> verifier key-reg. protocol is used, we show how to construct the forgery strategy <span class="math">\\widehat{\\mathsf{A}_{1}}</span> which, for any given privacy attacker pair <span class="math">(\\mathsf{A}_{1},\\mathsf{A}_{2})</span>, will perfectly simulate the DV signature answers to <span class="math">\\mathsf{A}_{1}</span>’s designation queries <span class="math">pk_{i}</span> without the message <span class="math">m^{*}</span> being signed by the signer, using the corresponding secret key <span class="math">sk_{i}</span> that <span class="math">\\mathsf{A}_{1}</span> registered with <span class="math">pk_{i}</span> during a previous key-reg. query. This shows that the convincing measure <span class="math">C_{\\widehat{\\mathsf{A}_{1}}}(\\mathsf{A}_{1},\\mathsf{A}_{2})</span> is zero for any <span class="math">(\\mathsf{A}_{1},\\mathsf{A}_{2})</span>, as required.</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which <span class="math">\\mathsf{A}_{1}</span> and <span class="math">\\mathsf{A}_{2}</span> interact.</p>

    <p class="text-gray-300"><em>Stage 1.</em> The pair <span class="math">(\\mathsf{A}_{1},\\mathsf{A}_{2})</span> is run on input <span class="math">(D_{G},g,y_{1}=g^{x_{1}})</span>. <span class="math">\\mathsf{A}_{1}</span>’s oracle queries are answered as follows.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li><span class="math">\\mathsf{S}(x_{1},.)</span> Queries. When <span class="math">\\mathsf{A}_{1}</span> makes <span class="math">i</span>th <span class="math">\\mathsf{S}</span>-query <span class="math">m_{i}</span>, it is answered with <span class="math">\\sigma_{i}=\\mathsf{S}(x_{1},m_{i})</span>.</li>

      <li>KRA Queries. When <span class="math">\\mathsf{A}_{1}</span> makes <span class="math">i</span>th key-reg. query <span class="math">(r_{i},sk_{i},pk_{i})</span> it is answered <span class="math">Acc</span> if <span class="math">(sk_{i},pk_{i})=\\mathsf{GKF}(k;r_{i})</span> and <span class="math">Rej</span> else.</li>

    </ol>

    <p class="text-gray-300">(3) <span class="math">\\mathsf{A}_2</span> Queries. When <span class="math">\\mathsf{A}_1</span> sends message <span class="math">m_i</span> to <span class="math">\\mathsf{A}_2</span>, <span class="math">\\mathsf{A}_2</span> responds with an answer <span class="math">a_i</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">\\mathsf{A}_1</span> outputs a challenge message <span class="math">m^<em></span> which is also given to <span class="math">\\mathsf{A}_2</span>. A PV signature <span class="math">\\sigma_i = (r^</em>, s^<em>) = \\mathsf{S}(x_1, m^</em>)</span> is generated, where <span class="math">r^<em> = H(m^</em>, u^<em>)</span> for <span class="math">u^</em> = g^{k^<em>}</span> for uniformly random <span class="math">k^</em> \\in \\mathbb{Z}_q</span>, and <span class="math">s^<em> = k^</em> + r^* \\cdot x_1 \\mod q</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">\\mathsf{A}_1</span> continues to make S,KRA and <span class="math">\\mathsf{A}_2</span> queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th CDV-query <span class="math">pk_i</span>, it is answered with DV signature <span class="math">\\widehat{\\sigma}_i = \\mathsf{CDV}(y_1, pk_i, m^<em>, \\sigma^</em>) = (u_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span>, where <span class="math">\\widehat{u}_i = g^{s^<em>} \\cdot y_1^{-r^</em>}</span>, <span class="math">\\widehat{r}_i = J(m^<em>, r^</em>, u^<em>, \\widehat{h}_i)</span> and <span class="math">\\widehat{s}_i = \\widehat{k}_i + \\widehat{r}_i \\cdot s^</em> \\mod q</span>, where <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i})</span> and <span class="math">\\widehat{u}_i = g^{\\widehat{k}_i}</span> for uniformly random <span class="math">\\widehat{k}_i \\in \\mathbb{Z}_q</span>.</p>

    <p class="text-gray-300">End of Stage 2. <span class="math">\\mathsf{A}_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">Game no. We now describe the other game where <span class="math">\\widehat{\\mathsf{A}_1}</span> interacts with <span class="math">\\mathsf{A}_2</span>.</p>

    <p class="text-gray-300">Stage 1. The pair <span class="math">(\\widehat{\\mathsf{A}_1}, \\mathsf{A}_2)</span> is run on input <span class="math">(D_G, g, y_1 = g^{x_1})</span>, where <span class="math">\\widehat{\\mathsf{A}_1}</span> is also given the program for <span class="math">\\mathsf{A}_1</span> as input. <span class="math">\\widehat{\\mathsf{A}_1}</span> runs <span class="math">\\mathsf{A}_1</span> on the same input and answers <span class="math">\\mathsf{A}_1</span>'s oracle queries as follows.</p>

    <p class="text-gray-300">(1) <span class="math">\\mathsf{S}(x_1,.)</span> Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th S-query <span class="math">m_i</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> forwards it to S oracle and forwards response <span class="math">\\sigma_i = \\mathsf{S}(x_1, m_i)</span> back to <span class="math">\\mathsf{A}_1</span>.</p>

    <p class="text-gray-300">(2) KRA Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th key-reg. query <span class="math">(r_i, sk_i, pk_i)</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> answers <span class="math">Acc</span> if <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span> and stores <span class="math">(sk_i, pk_i, Acc)</span> in a table <span class="math">T</span>, else it answers <span class="math">Rej</span>.</p>

    <p class="text-gray-300">(3) <span class="math">\\mathsf{A}_2</span> Queries. When <span class="math">\\mathsf{A}_1</span> outputs a message <span class="math">m_i</span> for <span class="math">\\mathsf{A}_2</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> forwards it to <span class="math">\\mathsf{A}_2</span> and forwards the answer <span class="math">a_i</span> back to <span class="math">\\mathsf{A}_1</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">\\mathsf{A}_1</span> outputs a challenge message <span class="math">m^<em></span>, which is also output by <span class="math">\\widehat{\\mathsf{A}_1}</span> and given to <span class="math">\\mathsf{A}_2</span>. <span class="math">\\widehat{\\mathsf{A}_1}</span> computes <span class="math">u^</em> = g^{k^<em>}</span> and <span class="math">r^</em> = H(m^<em>, u^</em>)</span>, for a uniformly random independent <span class="math">k^* \\in \\mathbb{Z}_q</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">\\mathsf{A}_1</span> continues to make S,KRA and <span class="math">\\mathsf{A}_2</span> queries, answered by <span class="math">\\widehat{\\mathsf{A}_1}</span> as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th CDV-query <span class="math">pk_i</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> searches table <span class="math">T</span> for an entry <span class="math">(sk_j, pk_j, Acc)</span> with <span class="math">pk_j = pk_i</span> (note that this entry is guaranteed to exist in <span class="math">T</span> due to the restriction on <span class="math">\\mathsf{A}_1</span> to only query CDV with public keys which have been answered with <span class="math">Acc</span> by a previous KRA query) and answers with <span class="math">\\widehat{\\sigma}_i = (u_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span>, where <span class="math">\\widehat{u}_i = u^<em></span>, <span class="math">\\widehat{r}_i = J(m^</em>, r^<em>, u^</em>, \\widehat{h}_i)</span>, <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}&#x27;; \\widehat{r}_{F,i}&#x27;)</span> for some fixed <span class="math">\\widehat{u}&#x27; \\in G</span> and uniformly random and independent <span class="math">\\widehat{r}_{F,i}&#x27; \\in R_F</span>, <span class="math">\\widehat{s}_i</span> is uniformly random and independent in <span class="math">\\mathbb{Z}_q</span>, and <span class="math">\\widehat{r}_{F,i} = \\mathsf{CSF}((sk_j, pk_j), (\\widehat{u}&#x27;, \\widehat{r}_{F,i}&#x27;), \\widehat{u}_i)</span>, with <span class="math">\\widehat{u}_i = g^{\\widehat{s}_i}(u^<em> y_1^{r^</em>})^{-\\widehat{r}_i}</span>.</p>

    <p class="text-gray-300">End of Stage 2. <span class="math">\\mathsf{A}_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">We show that <span class="math">\\mathsf{A}_1</span>'s (and hence also <span class="math">\\mathsf{A}_2</span>) view is perfectly simulated in Game no as in Game yes. In particular, the DV signatures <span class="math">(\\widehat{\\sigma}_i = (u_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span> are distributed identically in both games, for the following reasons. First, note that <span class="math">u^<em></span> and <span class="math">r^</em></span> are computed identically in both games. Second, observe that for each DV signature, <span class="math">\\widehat{r}_i</span> and <span class="math">\\widehat{s}_i</span> are determined uniquely by <span class="math">(m^<em>, r^</em>, u^*, \\widehat{u}_i, \\widehat{r}_{F,i})</span> in the same way in both games, namely</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{r}_i = J(m^*, r^*, u^*, F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i}))</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{s}_i \\text{ is the discrete-log in } G \\text{ of } \\widehat{u}_i (u^* y_1^{r^*})^{\\widehat{r}_i} \\text{ to base } g</span></div>

    <p class="text-gray-300">in both games. So it remains to show that (for each DV signature) the pair <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span> is identically distributed in both games. In Game yes, <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span> is uniform on <span class="math">G \\times R_F</span> by definition. In Game no, we</p>

    <p class="text-gray-300">27</p>

    <p class="text-gray-300">have that <span class="math">(\\widehat{u}_i,\\widehat{r}_{F,i}) = G(\\widehat{s}_i,\\widehat{r}_{F,i}^{\\prime})</span> for a function <span class="math">G:\\mathbb{Z}_q\\times R_F\\to G\\times R_F</span> defined by:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {u} _ {i} = g ^ {\\widehat {s} _ {i}} \\left(u ^ {*} y _ {1} ^ {* *}\\right) ^ {- J \\left(m ^ {*}, r ^ {*}, u ^ {*}, F _ {p k} \\left(\\widehat {u} ^ {\\prime}; \\widehat {r} _ {F, i} ^ {\\prime}\\right)\\right)} \\tag {20}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat {r} _ {F, i} = \\operatorname {C S F} ((s k, p k), (\\widehat {u} ^ {\\prime}, \\widehat {r} _ {F, i} ^ {\\prime}), \\widehat {u} _ {i}). \\tag {21}</span></div>

    <p class="text-gray-300">From the perfectly-trapdoor property of TH we have that mapping <span class="math">\\widehat{r}_{F,i}^{\\prime}\\mapsto \\mathsf{CSF}((sk,pk),(\\widehat{u}^{\\prime},\\widehat{r}_{F,i}^{\\prime}),\\widehat{u}_{i})</span> is a permutation on <span class="math">R_{F}</span>. This and the fact that <span class="math">g</span> has order <span class="math">q</span> immediately implies that function <span class="math">G:\\mathbb{Z}_q\\times R_F\\to G\\times R_F</span> is one-to-one. So since <span class="math">(\\widehat{s}_i,\\widehat{r}_{F,i}^{\\prime})</span> is uniform on <span class="math">\\mathbb{Z}_q\\times R_F</span> by definition, it follows that the image pair <span class="math">(\\widehat{u}_i,\\widehat{r}_{F,i})</span> is uniform on <span class="math">G\\times R_{F}</span> in Game no, as required. We conclude that <span class="math">\\mathsf{A}_2</span> outputs yes with same probability in both games and hence <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1,\\mathsf{A}_2) = 0</span>, as claimed. The run-time of <span class="math">\\widehat{\\mathsf{A}_1}</span> is the run-time of <span class="math">\\mathsf{A}_1</span> plus the time <span class="math">q_{d1}O(l_qT_g + T_F + T_{CSF} + T_J + T_H + q_{d1}l_{pk}) + q_{k1}T_{GKF}</span> to answer <span class="math">\\mathsf{A}_1</span>'s CDV and KRA queries. Note that <span class="math">\\widehat{q_{s1}} = q_{s1}</span>, <span class="math">\\widehat{q_{c1}} = q_{c1}</span>, and <span class="math">\\widehat{q_{k1}} = 0</span>, as claimed.</p>

    <h2 id="sec-27" class="text-2xl font-bold">E Proof of Theorem 5.1</h2>

    <p class="text-gray-300">The proof is analogous to the proof of Theorem 4.1 so we don't provide all details. We show how to use any efficient forging attacker A for breaking scheme RSAUDVS in the sense of ST-UF-DV with non-negligible probability to construct (1) an efficient attacker <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> for breaking the PV unforgeability of scheme RSAUDVS (i.e. the unforgeability of the standard RSA signature scheme), and (2) an efficient attacker <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> for breaking the collision-resistance of the trapdoor hash scheme TH, such that at least one of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> or <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> succeed with non-negligible probability. More precisely, we show that:</p>

    <div class="my-4 text-center"><span class="math-block">\\mathbf {S u c c} _ {\\mathrm {A} _ {5}, \\mathrm {R S A U D V S}} ^ {\\mathrm {U F - P V}} (k) + \\mathbf {S u c c} _ {\\mathrm {A} _ {T}, \\mathrm {T H}} ^ {\\mathrm {C R}} (k) \\geq \\frac {1}{4 \\left(q _ {J} + q _ {v}\\right) q _ {s}} \\cdot \\left[ \\mathbf {S u c c} _ {\\mathrm {A}, \\mathrm {R S A U D V S}} ^ {\\mathrm {S T - U F - D V}} (k) - \\frac {2 \\left(q _ {J} + q _ {v}\\right) q _ {s} + 1}{2 ^ {l _ {J}}} \\right] ^ {2}, \\tag {22}</span></div>

    <p class="text-gray-300">where <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> have resources <span class="math">(t[S], q_s[S], q_H[S])</span> and <span class="math">(t[T])</span> respectively, as defined in the theorem statement. The theorem then follows immediately from (22), by taking maximums over all attackers <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> with the given running time. It remains to construct <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> and show (22).</p>

    <p class="text-gray-300"><strong>Modified Attacker <span class="math">\\widehat{\\mathsf{A}}</span></strong>. As in Theorem 4.3, we first define a <strong>modified</strong> attacker <span class="math">\\widehat{\\mathsf{A}}</span> which is obtained from the original attacker <span class="math">\\mathsf{A}</span> in order to satisfy two properties (which may not be satisfied by <span class="math">\\mathsf{A}</span>): (1) Each <span class="math">J</span>-query of <span class="math">\\widehat{\\mathsf{A}}</span> is 'new' (i.e. unequal any earlier query to <span class="math">J(.)</span> made by <span class="math">\\widehat{\\mathsf{A}}</span>), and (2) <span class="math">\\widehat{\\mathsf{A}}</span> does not make any VDV queries. The <span class="math">\\widehat{\\mathsf{A}}</span>'s resources (denoted with hats) are related to <span class="math">\\mathsf{A}</span>'s resources as follows: <span class="math">\\widehat{q}_s = q_s</span>, <span class="math">\\widehat{q}_v = 0</span>, <span class="math">\\widehat{q}_H = q_H + q_v</span>, <span class="math">\\widehat{q}_J = q_J + q_v</span>, and <span class="math">\\widehat{t} = t + O((q_J + q_v)\\log_2(q_J + q_v)\\cdot (\\ell +l_G + l_F)) + O(l_qT_gq_v)</span>.</p>

    <p class="text-gray-300"><strong>Game0</strong>. Let <span class="math">\\mathsf{Game}_0</span> denote the original forgery attack game. In this game, let <span class="math">(m_i, h_i, \\widehat{h}_i)</span> denote <span class="math">\\widehat{\\mathsf{A}}</span>'s <span class="math">i</span>th <span class="math">J</span>-query, and <span class="math">\\widehat{r}_i = (\\widehat{r}_{i,1}, \\ldots, \\widehat{r}_{i,\\alpha})</span> the response to this query. Let <span class="math">(m^<em>, h^</em>, \\widehat{r}_F^<em>, \\widehat{r}^</em>, \\widehat{s}^<em>)</span> denote <span class="math">\\widehat{\\mathsf{A}}</span>'s output forgery, with <span class="math">\\widehat{r}^</em> = (\\widehat{r}_1^<em>, \\ldots, \\widehat{r}_\\alpha^</em>)</span>, <span class="math">\\widehat{s}^<em> = (\\widehat{s}_1^</em>, \\ldots, \\widehat{s}_\\alpha^<em>)</span>, <span class="math">\\widehat{h}^</em> = F_{pk}(\\widehat{u}^<em>, \\alpha; \\widehat{r}_F^</em>)</span>, <span class="math">\\widehat{u}^<em> = (\\widehat{u}_1^</em>, \\ldots, \\widehat{u}_\\alpha^<em>)</span> and <span class="math">\\widehat{u}_i^</em> = (\\widehat{s}_i^<em>)^e \\cdot (h^</em>)^{-\\widehat{r}_i^*}</span> for <span class="math">i = 1, \\ldots, \\alpha</span>. Let <span class="math">W_J = \\{1, \\ldots, \\widehat{q}_J\\}</span> and <span class="math">W_S = \\{1, \\ldots, \\widehat{q}_s\\}</span>, and let <span class="math">m_i&#x27;</span> denote the <span class="math">i</span>th S query of <span class="math">\\widehat{\\mathsf{A}}</span>. Analogously to Theorem 4.3, we define the event <span class="math">\\mathsf{S}_0</span> that A succeeds and the event <span class="math">\\mathsf{S}_0^1</span>:</p>

    <div class="my-4 text-center"><span class="math-block">\\begin{array}{l} \\mathsf {S} _ {0} ^ {1} \\Rightarrow (\\mathrm {a}) \\text { There exists } i ^ {*} \\in W ^ {J} \\text { such that } (m ^ {*}, h ^ {*}, \\widehat {h} ^ {*}) = (m _ {i}, h _ {i ^ {*}}, \\widehat {h} _ {i ^ {*}}) \\\\ \\text { and } F _ {p k} \\left(\\widehat {u} _ {i ^ {*}, 1}, \\dots , \\widehat {u} _ {i ^ {*}, \\alpha}; \\widehat {r} _ {F} ^ {*}\\right) = \\widehat {h} _ {i ^ {*}} \\text { with } \\widehat {u} _ {i ^ {*}, l} = \\left(\\widehat {s} _ {l} ^ {*}\\right) ^ {e} \\cdot h _ {i ^ {*}} ^ {- \\widehat {r} _ {i ^ {*}, l}} \\bmod N \\\\ \\text {(b)} m ^ {*} \\neq m _ {i} ^ {\\prime} \\text { for all } i \\in W ^ {S} \\text { and } R \\left(m ^ {*}, h ^ {*}\\right) = A c c \\tag {23} \\end{array}</span></div>

    <p class="text-gray-300">and due to the randomness of <span class="math">J(.)</span> we get</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ \\mathrm {S} _ {0} ^ {1} \\right] \\geq \\Pr \\left[ \\mathrm {S} _ {0} \\right] - \\frac {1}{2 ^ {l _ {J}}}. \\tag {24}</span></div>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_1</span>. In <span class="math">\\mathsf{Game}_1</span>, we construct the algorithm <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> against the PV-unforgeability of <span class="math">\\mathsf{RSAUDVS}_2</span>. On input <span class="math">(k,N,e)</span> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs as follows.</p>

    <p class="text-gray-300"><strong>Setup.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> first sets up two random vectors <span class="math">\\overrightarrow{\\hat{r}}[1] = (\\widehat{r}_1[1], \\ldots, \\widehat{r}_{\\widehat{q}_J}[1])</span> and <span class="math">\\overrightarrow{\\hat{r}}[2] = (\\widehat{r}_1[2], \\ldots, \\widehat{r}_{\\widehat{q}_J}[2])</span> with <span class="math">\\widehat{r}_i[k] = (\\widehat{r}_{i,1}[k], \\ldots, \\widehat{r}_{i,\\alpha}[k])</span> chosen uniformly and independently at random from <span class="math">\\mathbb{Z}_{2^{l_J / \\alpha}}^{\\alpha}</span> for <span class="math">k \\in \\{1, 2\\}</span>.</p>

    <p class="text-gray-300"><strong>First Run.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> generates a TH key-pair <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span> and runs <span class="math">\\widehat{\\mathsf{A}}</span> on input <span class="math">(N, e, pk; \\omega)</span>, where <span class="math">\\omega</span> is a random bit string used as the randomness input of <span class="math">\\widehat{\\mathsf{A}}</span>, and answers <span class="math">\\widehat{\\mathsf{A}}</span>'s oracle queries as follows:</p>

    <p class="text-gray-300">(1) <span class="math">J(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^J</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th <span class="math">J(\\cdot)</span> query <span class="math">(m_i[1], h_i[1], \\widehat{h}_i[1])</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\widehat{r}_i[1]</span>. (2) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">j</span>th S query <span class="math">m_j&#x27;[1]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> simply forwards the query to its S oracle and forwards the oracle's response <span class="math">\\sigma_j[1]</span> back to <span class="math">\\widehat{\\mathsf{A}}</span>. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> stores the query-answer pair <span class="math">(m_j&#x27;[1], \\sigma_j[1])</span> in a table <span class="math">T</span>.</p>

    <p class="text-gray-300"><strong>First Run Output.</strong> At the end of first run, <span class="math">\\widehat{\\mathsf{A}}</span> outputs the forgery <span class="math">(m^{<em>}[1], h^{</em>}[1], \\widehat{r}_{F}^{<em>}[1], \\widehat{r}^{</em>}[1], \\widehat{s}^{<em>}[1])</span>. Note that if this run is successful then there exists <span class="math">i^{</em>} \\in W^{J}</span> such that <span class="math">\\widehat{\\mathsf{A}}</span>'s forgery satisfies (23). We also define <span class="math">j^{<em>} \\in W^{S}</span> as the number of S-queries made by <span class="math">\\widehat{\\mathsf{A}}</span> before issuing its <span class="math">i^{</em>}</span>th <span class="math">J</span>-query. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> finds <span class="math">(i^{<em>}, j^{</em>})</span> from a table of <span class="math">\\widehat{\\mathsf{A}}</span>'s queries in time <span class="math">O(\\widehat{q}_{J}(l_{F} + l_{N}))</span> (if <span class="math">i^{*}</span> doesn't exist, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> fails).</p>

    <p class="text-gray-300"><strong>Second Run.</strong> <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> runs <span class="math">\\widehat{\\mathsf{A}}</span> again on the same input <span class="math">(N, e, pk; \\omega)</span> as used in first run, but answers its oracle queries differently as follows:</p>

    <p class="text-gray-300">(1) <span class="math">J(\\cdot)</span>-Query simulator <span class="math">\\mathsf{F}^J</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">i</span>th <span class="math">J(\\cdot)</span> query <span class="math">(m_i[2], h_i[2], \\widehat{h}_i[2])</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\widehat{r}_i[1]</span> for <span class="math">i &amp;lt; i^<em></span> and with <span class="math">\\widehat{r}_i[2]</span> for <span class="math">i \\geq i^</em></span>. (2) S-Query simulator <span class="math">\\mathsf{F}^{\\mathsf{S}}</span>. When <span class="math">\\widehat{\\mathsf{A}}</span> makes its <span class="math">j</span>th S query <span class="math">m_j&#x27;[2]</span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> responds with <span class="math">\\sigma_j[1]</span> for <span class="math">j \\leq j^<em></span>. For <span class="math">j &amp;gt; j^</em></span>, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> forwards the query to its S oracle and forwards the oracle's response <span class="math">\\sigma_j[2]</span> back to <span class="math">\\widehat{\\mathsf{A}}</span>.</p>

    <p class="text-gray-300"><strong>Second Run Output.</strong> At the end of second run, <span class="math">\\widehat{\\mathsf{A}}</span> outputs the forgery <span class="math">(m^{<em>}[2], h^{</em>}[2], \\widehat{r}_{F}^{<em>}[2], \\widehat{r}^{</em>}[2], \\widehat{s}^{*}[2])</span>.</p>

    <div class="overflow-x-auto my-4">

      <table class="min-w-full text-sm text-gray-300">

        <thead>

          <tr>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600"><span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s output. <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> computes and returns an estimate <span class="math">(\\widehat{m}^{<em>}, \\widehat{\\sigma}^{</em>})</span> for a message/PV sig. forgery for RSAUDVS as follows. First, <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> tries to find <span class="math">l^{<em>} \\in \\{1, \\ldots, \\alpha\\}</span> such that the integer <span class="math">\\delta_r = \\widehat{r}_{i^{</em>},l^{<em>}}[1] - \\widehat{r}_{i^{</em>},l^{<em>}}[2]</span> is non-zero (otherwise, if <span class="math">\\widehat{r}_{i^{</em>}}[1] = \\widehat{r}_{i^{<em>}}[2]</span>, then <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> fails). Because <span class="math">\\widehat{r}_{i,l^{</em>}}^{<em>}[1]</span> and <span class="math">\\widehat{r}_{i,l^{</em>}}^{*}[2]</span> are in <span class="math">\\mathbb{Z}_{2^{l_J / \\alpha}}</span> we know that $</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">\\delta_r</th>

            <th class="px-3 py-2 text-left font-semibold border-b border-gray-600">&lt; 2^{l_J / \\alpha} &lt; e<span class="math"> and hence </span>\\gcd(\\delta_r, e) = 1<span class="math">, since </span>e<span class="math"> is prime. So there exist integers </span>c_r &lt; e<span class="math"> and </span>c_e &lt; e<span class="math"> such that </span>c_r \\cdot \\delta_r + c_e \\cdot e = 1<span class="math"> and </span>\\mathsf{A}_{\\mathsf{S}}<span class="math"> can compute them in time </span>O(l_e^2)<span class="math">. Then </span>\\mathsf{A}_{\\mathsf{S}}<span class="math"> computes the PV sig. estimate </span>\\widehat{\\sigma}^{<em>} = (\\widehat{s}_{l^{</em>}}^{<em>}[1] / \\widehat{s}_{l^{</em>}}^{<em>}[2])^{c_r} \\cdot (h^{</em>}[1])^{c_e} \\mod N<span class="math"> on message </span>\\widehat{m}^{<em>} = m^{</em>}[1]$.</th>

          </tr>

        </thead>

        <tbody>

        </tbody>

      </table>

    </div>

    <p class="text-gray-300">This completes the description of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>. The running-time of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is twice the run-time of <span class="math">\\widehat{\\mathsf{A}}</span> plus the time to compute <span class="math">(i^{<em>},j^{</em>})</span> and <span class="math">\\widehat{\\sigma}^{*}</span> at the end, which takes total time <span class="math">O(\\widehat{q}_J(l_F + l_N) + l_e^2 +l_eT_N)</span>. The number of <span class="math">H</span>- and <span class="math">\\mathsf{S}</span>-queries made by <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> is up to twice the number of queries made by <span class="math">\\widehat{\\mathsf{A}}</span>. This establishes the claimed resources of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>.</p>

    <p class="text-gray-300">The collision-finder attacker <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> runs <span class="math">\\widehat{\\mathsf{A}}</span> twice in the same way as <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> (except that it receives the hash function public key <span class="math">pk</span> as input, and generates a signature key pair <span class="math">(N,e,d) = \\mathsf{GKS}(k)</span> by itself, with which it answers <span class="math">\\widehat{\\mathsf{A}}</span>'s signing queries - note that the hash function secret key <span class="math">sk</span> is not needed by <span class="math">\\mathsf{A}_{\\mathsf{T}}</span>), and at the end computes the following collision estimate <span class="math">(\\beta[1], \\gamma[1]), (\\beta[2], \\gamma[2])</span>, where <span class="math">\\beta[\\rho] = (\\widehat{u}_1^<em>[\\rho], \\ldots, \\widehat{u}_\\alpha^</em>[\\rho])</span> and <span class="math">\\gamma[\\rho] = \\widehat{r}_F[\\rho]</span> for <span class="math">\\rho \\in \\{1,2\\}</span> with <span class="math">\\widehat{u}_l^<em>[\\rho] = \\widehat{s}_l^</em>[\\rho]^e \\cdot (h_{i^<em>})^{-\\widehat{r}_{i^</em>,l}[\\rho]}</span> for <span class="math">l \\in \\{1, \\ldots, \\alpha\\}</span>.</p>

    <p class="text-gray-300">We now lower bound the sum of success probabilities of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span>. For each <span class="math">(i,j) \\in W^{J} \\times W^{S}</span>, we call a run of <span class="math">\\widehat{\\mathsf{A}} (i,j)</span>-successful if <span class="math">\\widehat{\\mathsf{A}}</span>'s output satisfies (23) and <span class="math">(i^{<em>},j^{</em>}) = (i,j)</span>. Let <span class="math">\\mathsf{S}^*</span> denote the event</p>

    <p class="text-gray-300">29</p>

    <p class="text-gray-300">that both runs of <span class="math">\\widehat{\\mathsf{A}}</span> above are <span class="math">(i,j)</span>-successful for some <span class="math">(i,j)</span> and <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span>. Note that if <span class="math">S^<em></span> occurs then, defining <span class="math">\\sigma^</em> = (h_i[1])^{1/e} \\bmod N</span>, we have from (23) that</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {m} ^ {*} = m _ {i} [ 1 ] = m _ {i} [ 2 ] \\text{ has not been queried to S during either run of} \\widehat {\\mathsf {A}} \\text{ and } R (m _ {i} [ 1 ], h _ {i} [ 1 ]) = A c c \\tag{25}</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">F _ {p k} (\\widehat {u} _ {i, 1} [ 1 ], \\dots , \\widehat {u} _ {i, \\alpha} [ 1 ]; \\widehat {r} _ {F} ^ {*} [ 1 ]) = F _ {p k} (\\widehat {u} _ {i, 1} [ 2 ], \\dots , \\widehat {u} _ {i, \\alpha} [ 2 ]; \\widehat {r} _ {F} ^ {*} [ 2 ])</span></div>

    <div class="my-4 text-center"><span class="math-block">\\text{with} \\widehat {u} _ {i, l} [ \\rho ] = \\left(\\widehat {s} _ {l} ^ {*} [ \\rho ]\\right) ^ {e} \\cdot h _ {i} [ \\rho ] ^ {- \\widehat {r} _ {i, l} [ \\rho ]} \\bmod N \\text{ for } \\rho \\in \\{1, 2 \\} \\text{ and } l \\in \\{1, \\dots , \\alpha \\} \\tag{26}</span></div>

    <p class="text-gray-300">(note that <span class="math">(m_i[1], h_i[1], \\widehat{h}_i[1]) = (m_i[2], h_i[2], \\widehat{h}_i[2])</span> because the view of <span class="math">\\widehat{\\mathsf{A}}</span> is the same in both runs up to <span class="math">i</span>th <span class="math">J(.)</span> query response). We now split event <span class="math">\\mathsf{S}^<em></span> into two disjoint subevents <span class="math">\\mathsf{S}_{\\mathsf{S}}^{</em>}</span> and <span class="math">\\mathsf{S}_{\\mathsf{T}}^{*}</span>, depending on whether</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat {u} _ {i, l} [ 1 ] = \\widehat {u} _ {i, l} [ 2 ] \\text{ for all } l \\in \\{1, \\dots , \\alpha \\} \\tag{27}</span></div>

    <p class="text-gray-300">holds or not, respectively. If the subevent <span class="math">\\mathsf{S}_{\\mathsf{S}}^{<em>}</span> occurs, then (27) holds. This means in particular that there exists <span class="math">l^{</em>}</span> such that <span class="math">\\widehat{u}_{i,l^{<em>}}[1] = \\widehat{u}_{i,l^{</em>}}[2]</span> but <span class="math">\\widehat{r}_{i,l^{<em>}}[1] \\neq \\widehat{r}_{i,l^{</em>}}[2]</span>, which leads to <span class="math">(\\widehat{s}_{l^{<em>}}^{</em>}[1] / \\widehat{s}_{l^{<em>}}^{</em>}[2]) \\equiv (\\sigma^{<em>})^{\\delta_{r}} \\bmod N</span> and hence <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>'s estimate <span class="math">\\widehat{\\sigma}^{</em>} = (\\sigma^{<em>})^{c_{r}\\delta_{r}} \\cdot (\\sigma^{</em>})^{c_{e}e} \\bmod N = \\sigma^{<em>} = h_{i}[1]^{1/e} \\bmod N</span>, which coupled with (25) means that <span class="math">R(m_{i}[1], h_{i}[1]) = Acc</span> and <span class="math">m_{i}[1]</span> has not been queried to <span class="math">\\mathsf{S}</span>, so <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> succeeds to break the PV unforgeability of RSAUDVS when <span class="math">\\mathsf{S}_{\\mathsf{S}}^{</em>}</span> occurs. In the other case that subevent <span class="math">\\mathsf{S}_{\\mathsf{T}}^{*}</span> occurs, (27) does not hold but (26) holds, meaning that <span class="math">\\mathsf{A}_{\\mathsf{T}}</span>'s output is a valid collision for the trapdoor hash so <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> succeeds.</p>

    <p class="text-gray-300">So we have shown that the sum of success probabilities of <span class="math">\\mathsf{A}_{\\mathsf{S}}</span> and <span class="math">\\mathsf{A}_{\\mathsf{T}}</span> is equal to the probability of the event <span class="math">\\mathsf{S}^<em></span> that both runs of <span class="math">\\widehat{\\mathsf{A}}</span> are <span class="math">(i,j)</span>-successful for some <span class="math">(i,j) \\in W^{J} \\times W^{S}</span> and <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span>, and it remains to lower bound <span class="math">\\operatorname{Pr}[\\mathsf{S}^</em>]</span>. Using the same calculation used to bound <span class="math">\\operatorname{Pr}[\\mathsf{S}^*]</span> in the proof of Theorem 4.3, we get</p>

    <div class="my-4 text-center"><span class="math-block">\\Pr \\left[ S ^ {*} \\right] \\geq \\frac {1}{\\widehat {q} _ {J} q _ {s}} \\cdot \\left(\\Pr \\left[ S _ {0} ^ {1} \\right] / 2 - \\widehat {q} _ {J} q _ {s} / 2 ^ {l _ {J}}\\right) ^ {2}, \\tag{28}</span></div>

    <p class="text-gray-300">which using (24) gives the desired lower-bound (22) on <span class="math">\\operatorname{Pr}[\\mathsf{S}^*]</span>. This completes the proof.</p>

    <h2 id="sec-28" class="text-2xl font-bold">F Proof of Theorem 5.2</h2>

    <p class="text-gray-300">Analogously to the proof of Theorem 4.4, we assume the direct verifier key-reg. protocol is used and we show how to construct the forgery strategy <span class="math">\\widehat{\\mathsf{A}_1}</span>.</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which <span class="math">\\mathsf{A}_1</span> and <span class="math">\\mathsf{A}_2</span> interact.</p>

    <p class="text-gray-300">Stage 1. The pair <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> is run on input <span class="math">(N, e)</span>. <span class="math">\\mathsf{A}_1</span>'s oracle queries are answered as follows.</p>

    <p class="text-gray-300">(1) <span class="math">\\mathsf{S}(x_1,.)</span> Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th <span class="math">\\mathsf{S}</span>-query <span class="math">m_i</span>, it is answered with <span class="math">\\sigma_i = \\mathsf{S}(x_1, m_i)</span>.</p>

    <p class="text-gray-300">(2) KRA Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th key-reg. query <span class="math">(r_i, sk_i, pk_i)</span> it is answered <span class="math">Acc</span> if <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span> and <span class="math">Rej</span> else.</p>

    <p class="text-gray-300">(3) <span class="math">\\mathsf{A}_2</span> Queries. When <span class="math">\\mathsf{A}_1</span> sends message <span class="math">m_i</span> to <span class="math">\\mathsf{A}_2</span>, <span class="math">\\mathsf{A}_2</span> responds with an answer <span class="math">a_i</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">\\mathsf{A}_1</span> outputs a challenge message <span class="math">m^<em></span>, which is given to <span class="math">\\mathsf{A}_2</span>. A PV signature <span class="math">\\sigma^</em> = \\mathsf{S}(x_1, m^<em>)</span> is generated, where <span class="math">\\sigma^</em> = (h^<em>)^{1/e} \\bmod N</span> and <span class="math">h^</em> = H(m^<em>, s^</em>)</span> for uniformly random <span class="math">s^* \\in R_S</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">\\mathsf{A}_1</span> continues to make S,KRA and <span class="math">\\mathsf{A}_2</span> queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">

      <li>CDV Queries. When <span class="math">A_1</span> makes <span class="math">i</span>th CDV-query <span class="math">pk_i</span>, it is answered with DV signature <span class="math">\\widehat{\\sigma}_i = (h_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span>, where <span class="math">h_i = h^<em></span>, <span class="math">\\widehat{r}_{F,i}</span> is uniformly random in <span class="math">R_F</span>, <span class="math">\\widehat{r}_i = (\\widehat{r}_{i,1}, \\ldots, \\widehat{r}_{i,\\alpha}) = J(m^</em>, h^<em>, \\widehat{h}_i)</span>, <span class="math">\\widehat{s}_i = (\\widehat{s}_{i,1}, \\ldots, \\widehat{s}_{i,\\alpha})</span> with <span class="math">\\widehat{s}_{i,l} = k_{i,l} \\cdot (\\sigma^</em>)^{\\widehat{r}_{i,l}}</span> mod <span class="math">N</span>, <span class="math">\\alpha</span> random elements <span class="math">k_i \\in \\mathbb{Z}_N^*</span>, and <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i})</span> with <span class="math">\\widehat{u}_i = (\\widehat{u}_{i,1}, \\ldots, \\widehat{u}_{i,\\alpha})</span>, <span class="math">\\widehat{u}_{i,l} = k_{i,l}^e</span> mod <span class="math">N</span> for <span class="math">l = 1, \\ldots, \\alpha</span>.</li>

    </ol>

    <p class="text-gray-300">End of Stage 2. <span class="math">A_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">Game no. We now describe the other game where <span class="math">\\widehat{A_1}</span> interacts with <span class="math">A_2</span>.</p>

    <p class="text-gray-300">Stage 1. The pair <span class="math">(\\widehat{\\mathsf{A}_1}, \\mathsf{A}_2)</span> is run on input <span class="math">(N, e)</span>, where <span class="math">\\widehat{\\mathsf{A}_1}</span> is also given the program for <span class="math">\\mathsf{A}_1</span> as input. <span class="math">\\widehat{\\mathsf{A}_1}</span> runs <span class="math">\\mathsf{A}_1</span> on the same input and answers <span class="math">\\mathsf{A}_1</span>'s oracle queries as follows.</p>

    <p class="text-gray-300">(1) <span class="math">\\mathsf{S}(x_1,.)</span> Queries. When <span class="math">\\mathsf{A}_1</span> makes <span class="math">i</span>th <span class="math">\\mathsf{S}</span>-query <span class="math">m_i</span>, <span class="math">\\widehat{\\mathsf{A}_1}</span> forwards it to <span class="math">\\mathsf{S}</span> oracle and forwards response <span class="math">\\sigma_i = \\mathsf{S}(x_1, m_i)</span> back to <span class="math">\\mathsf{A}_1</span>.</p>

    <p class="text-gray-300">(2) KRA Queries. When <span class="math">A_1</span> makes <span class="math">i</span>th key-reg. query <span class="math">(r_i, sk_i, pk_i)</span>, <span class="math">\\widehat{A_1}</span> answers <span class="math">Acc</span> if <span class="math">(sk_i, pk_i) = GKF(k; r_i)</span> and stores <span class="math">(sk_i, pk_i, Acc)</span> in a table <span class="math">T</span>, else it answers <span class="math">Rej</span>.</p>

    <p class="text-gray-300">(3) <span class="math">A_2</span> Queries. When <span class="math">A_1</span> outputs a message <span class="math">m_i</span> for <span class="math">A_2</span>, <span class="math">\\widehat{A_1}</span> forwards it to <span class="math">A_2</span> and forwards the answer <span class="math">a_i</span> back to <span class="math">A_1</span>.</p>

    <p class="text-gray-300">End of Stage 1. <span class="math">A_1</span> outputs a challenge message <span class="math">m^<em></span>, which is also output by <span class="math">\\widehat{A_1}</span> and given to <span class="math">A_2</span>. <span class="math">\\widehat{A_1}</span> computes <span class="math">h^</em> = H(m^<em>, s^</em>)</span>, for a uniformly random independent <span class="math">s^* \\in R_S</span>. Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2. <span class="math">A_1</span> continues to make S, KRA and <span class="math">A_2</span> queries, answered by <span class="math">\\widehat{A_1}</span> as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When <span class="math">A_1</span> makes <span class="math">i</span>th CDV-query <span class="math">pk_i</span>, <span class="math">\\widehat{A_1}</span> searches table <span class="math">T</span> for an entry <span class="math">(sk_j, pk_j, Acc)</span> with <span class="math">pk_j = pk_i</span> (note that this entry is guaranteed to exist in <span class="math">T</span> due to the restriction on <span class="math">A_1</span> to only query CDV with public keys which have been answered with <span class="math">Acc</span> by a previous KRA query) and answers with <span class="math">\\widehat{\\sigma}_i = (h_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span>, where <span class="math">h_i = h^<em></span>, <span class="math">\\widehat{r}_i = J(m^</em>, h^<em>, \\widehat{h}_i) = (\\widehat{r}_{i,1}, \\ldots, \\widehat{r}_{i,\\alpha})</span>, <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}&#x27;; \\widehat{r}_{F,i}&#x27;)</span> for some fixed <span class="math">\\widehat{u}&#x27; = (\\widehat{u}_1&#x27;, \\ldots, \\widehat{u}_\\alpha&#x27;) \\in (\\mathbb{Z}_N^</em>)^\\alpha</span> and uniformly random and independent <span class="math">\\widehat{r}_{F,i}&#x27; \\in R_F</span>, <span class="math">\\widehat{s}_i = (\\widehat{s}_{i,1}, \\ldots, \\widehat{s}_{i,\\alpha})</span> uniformly random and independent in <span class="math">(\\mathbb{Z}_N^<em>)^\\alpha</span>, and <span class="math">\\widehat{r}_{F,i} = \\mathsf{CSF}((sk_j, pk_j), (\\widehat{u}&#x27;, \\widehat{r}_{F,i}&#x27;, \\widehat{u}_i))</span>, with <span class="math">\\widehat{u}_i = (\\widehat{u}_{i,1}, \\ldots, \\widehat{u}_{i,\\alpha})</span>, where <span class="math">\\widehat{u}_{i,l} = \\widehat{s}_{i,l}^e \\cdot (h^</em>)^{-\\widehat{r}_{i,l}}</span> mod <span class="math">N</span>.</p>

    <p class="text-gray-300">End of Stage 2. <span class="math">A_2</span> outputs a decision <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span>.</p>

    <p class="text-gray-300">We show that <span class="math">A_1</span>'s (and hence also <span class="math">A_2</span>'s) view is perfectly simulated in Game no as in Game yes. In particular, the DV signatures <span class="math">(\\widehat{\\sigma}_i = (h_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span> are distributed identically in both games, for the following reasons. First, note that <span class="math">h^<em></span> is computed identically in both games. Second, observe that for each DV signature, <span class="math">\\widehat{r}_i</span> and <span class="math">\\widehat{s}_i</span> are determined uniquely by <span class="math">(m^</em>, h^*, \\widehat{u}_i, \\widehat{r}_{F,i})</span> in the same way in both games, namely</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{r}_i = J(h^*, F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i}))</span></div>

    <p class="text-gray-300">and</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{s}_{i,l} \\text{ are the } e\\text{th roots of } \\widehat{u}_i(h^*)^{\\widehat{r}_{i,l}} \\bmod N</span></div>

    <p class="text-gray-300">in both games. So it remains to show that (for each DV signature) the pair <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span> is identically distributed in both games. In Game yes, <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span> is uniform on <span class="math">G \\times R_F</span> by definition. In Game no, we have that <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i}) = G(\\widehat{s}_i, \\widehat{r}_{F,i}&#x27;)</span> for a function <span class="math">G: (\\mathbb{Z}_N^<em>)^\\alpha \\times R_F \\to (\\mathbb{Z}_N^</em>)^\\alpha \\times R_F</span> defined by:</p>

    <div class="my-4 text-center"><span class="math-block">\\widehat{u}_{i,l} = \\widehat{s}_{i,l}^e \\cdot (h^*)^{-J(h^*, F_{pk}(\\widehat{u}&#x27;; \\widehat{r}_{F,i}&#x27;))} \\bmod N \\tag{29}</span></div>

    <div class="my-4 text-center"><span class="math-block">\\widehat{r}_{F,i} = \\mathsf{CSF}((sk, pk), (\\widehat{u}&#x27;, \\widehat{r}_{F,i}&#x27;, \\widehat{u}_i). \\tag{30}</span></div>

    <p class="text-gray-300">From the perfectly-trapdoor property of <span class="math">\\mathsf{TH}</span> we have that mapping <span class="math">\\widehat{r}_{F,i}&#x27; \\mapsto \\mathsf{CSF}((sk, pk), (\\widehat{u}&#x27;, \\widehat{r}_{F,i}&#x27;)</span>, <span class="math">\\widehat{u}_i)</span> is a permutation on <span class="math">R_F</span>. This and the fact that <span class="math">\\widehat{s}_{i,l} \\mapsto \\widehat{s}_{i,l}^e \\bmod N</span> is a permutation of <span class="math">\\mathbb{Z}_N^<em></span> implies that <span class="math">G</span> is permutation on <span class="math">(\\mathbb{Z}_N^</em>)^\\alpha \\times R_F</span>. So since <span class="math">(\\widehat{s}_i, \\widehat{r}_{F,i}&#x27;)</span> is uniform on <span class="math">(\\mathbb{Z}_N^*)^\\alpha \\times R_F</span> by definition, it follows</p>

    <p class="text-gray-300">31</p>

    <p class="text-gray-300">that so is the image pair  <span class="math">(\\widehat{u}_i,\\widehat{r}_{F,i})</span> , as required. We conclude that  <span class="math">\\mathsf{A}_2</span>  outputs yes with same probability in both games and hence  <span class="math">C_{\\widehat{\\mathsf{A}}_1}(\\mathsf{A}_1,\\mathsf{A}_2) = 0</span> , as claimed. The run-time of  <span class="math">\\widehat{\\mathsf{A}_1}</span>  is the run-time of  <span class="math">\\mathsf{A}_1</span>  plus the time  <span class="math">q_{d1}O(l_JT_N + T_F + T_{CSF} + T_J + T_H + q_{d1}l_{pk} + q_{k1}T_{GKF})</span>  to answer  <span class="math">\\mathsf{A}_1</span> 's CDV and KRA queries. Note that  <span class="math">\\widehat{q_{s1}} = q_{s1}</span> ,  <span class="math">\\widehat{q_{c1}} = q_{c1}</span> , and  <span class="math">\\widehat{q_{k1}} = 0</span> , as claimed.</p>`;
---

<BaseLayout title="Efficient Extension of Standard Schnorr/RSA signatures into ... (2003/193)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2003 &middot; eprint 2003/193
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

  </article>
</BaseLayout>
