---
import BaseLayout from '../../layouts/BaseLayout.astro';
import PaperDisclaimer from '../../components/PaperDisclaimer.astro';
import PaperHistory from '../../components/PaperHistory.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2003/193';
const CRAWLER = 'modal-marker';
const CONVERTED_DATE = '2026-02-17';
const TITLE_HTML = 'Efficient Extension of Standard Schnorr/RSA signatures into Universal Designated-Verifier Signatures∗';
const AUTHORS_HTML = 'Ron Steinfeld, Huaxiong Wang, Josef Pieprzyk Dept. of Computing, Macquarie University, Australia {rons, hwang, josef}@ics.mq.edu.au';

const CONTENT = `    <p class="text-gray-300">Ron Steinfeld, Huaxiong Wang, Josef Pieprzyk Dept. of Computing, Macquarie University, Australia {rons, hwang, josef}@ics.mq.edu.au</p>

    <p class="text-gray-300">December 15, 2003</p>

    <h4 id="sec-1" class="text-lg font-semibold mt-6">Abstract</h4>

    <p class="text-gray-300">Universal Designated-Verifier Signature (UDVS) schemes are digital signature schemes with additional functionality which allows any holder of a signature to designate the signature to any desired designated-verifier such that the designated-verifier can verify that the message was signed by the signer, but is unable to convince anyone else of this fact.</p>

    <p class="text-gray-300">Since UDVS schemes reduce to standard signatures when no verifier designation is performed, it is natural to ask how to extend the classical Schnorr or RSA signature schemes into UDVS schemes, so that the existing key generation and signing implementation infrastructure for these schemes can be used without modification. We show how this can be efficiently achieved, and provide proofs of security for our schemes in the random oracle model.</p>

    <p class="text-gray-300">Universal Designated-Verifier Signature (UDVS) schemes introduced by Steinfeld et al [26] are digital signature schemes with additional functionality which allows any holder of a signature to designate the signature to any desired designated-verifier such that the designated-verifier can verify that the message was signed by the signer, but is unable to convince anyone else of this fact, because the verifier's secret key allows him to forge the designated-verifier signatures without the signer's cooperation. Such signature schemes protect the privacy of signature holders from dissemination of signatures by verifiers, and have applications in certification systems [26].</p>

    <p class="text-gray-300">The previous work [26] has shown how to construct efficient deterministic UDVS schemes from Bilinear group-pairs. However, since UDVS schemes reduce to standard signatures when no verifier designation is performed, it is natural to ask how to extend the classical Schnorr [24] or RSA [22] signature schemes into UDVS schemes, so that the existing key generation and signing implementation infrastructure for these schemes can be used without modification — the UDVS functionality can be added to such implementations as an optional feature. In this paper we show how this can be efficiently achieved, and provide concrete proofs of security for our schemes in the random oracle model [2].</p>

    <p class="text-gray-300">As shown in [26], any secure efficient construction of an unconditionally-private UDVS scheme with unique signatures (e.g. fully deterministic UDVS schemes with unique secret keys) gives rise to a secure efficient ID-Based Encryption (IBE) scheme. Constructing secure and efficient IBE schemes from classical Diffie-Hellman or RSA problems is a long-standing open problem [3], and until this</p>

    <p class="text-gray-300">&lt;sup&gt;∗&lt;/sup&gt;This is the full version of a paper to appear in PKC 2004.</p>

    <p class="text-gray-300">problem is solved we also cannot hope to construct unconditionally-private UDVS schemes with unique signatures based on classical problems. However, the results in this paper show that by giving up the unique signature requirement and allowing randomization in either the signing (in the case of Schnorr signatures) or designation (in the case of RSA) algorithms, one can construct efficient UDVS schemes from classical problems. Although the UDVS schemes presented in this paper do not have unique signatures, they still achieve perfect unconditional privacy in the sense of [26].</p>

    <p class="text-gray-300">The proofs of all theorems in the paper are included in the Appendix.</p>

    <p class="text-gray-300">As pointed out in [26], the concept of UDVS schemes can be viewed as an application of the general idea of designated-verifier proofs, introduced by Jakobsson, Sako and Impagliazzo [15], where a prover non-interactively designates a proof of a statement to a verifier, in such a way that the verifier can simulate the proof by himself with his secret key and thus cannot transfer the proof to convince anyone else about the truth of the statement, yet the verifier himself is convinced by the proof. The distinctive feature of UDVS schemes is universal designation: anyone who obtains a signature can designate it.</p>

    <p class="text-gray-300">Two of our proposed UDVS schemes (namely SchUDVS2 and RSAUDVS) make use of the paradigm in [15] of using a trapdoor commitment in a non-interactive proof of knowledge to achieve verifier designation. Since the underlying construction techniques used in these schemes is known, we view our main contribution here is in providing a concrete security analysis which bounds the insecurity of these schemes in terms of the underlying primitives. Our third proposed scheme SchUDVS1 shows an alternative and more efficient approach than the paradigm of [15], for extending the Schnorr signature scheme into a UDVS scheme, using the Diffie-Hellman function. It is an analogoue of the the bilinearbased approach for constructing UDVS schemes proposed in [26].</p>

    <p class="text-gray-300">Besides providing UDVS schemes based on classical problems, another contribution of this paper is in defining a stronger unforgeability notion for UDVS schemes, which allows the forger access to the attacked designated verifier's verification oracle, as well as to the signer's signing oracle (whereas the model in [26] only allows access to the signing oracle). We analyse our schemes in this stronger model.</p>

    <p class="text-gray-300">There have been other approaches proposed to address the privacy threat associated with dissemination of verifiable signed documents. Chaum and van Antwerpen [9, 7] introduced undeniable signatures for this purpose, which require a signer or confirmer's [8, 18, 17, 6, 12] interactive cooperation to verify a signature, but this approach places significant inconvenience and workload on verifiers and confirmers, compared to an off-line non-interactive verification. The work of Brands on digital credentials [5, 4] suggests further approaches to enhance user privacy, such as selective disclosure of attributes (see also [27]) and unlinkability of user transactions. Chameleon signatures [16] allow designation of signatures to verifiers by the signer, and in addition allow a signer to prove a forgery by a designated verifier. Ring signatures [21], when restricted to two users, can also be viewed as designated-verifier signatures, where one user is the actual signer and the other user is the designated-verifier who can also forge the two-user ring signature, thus providing the privacy property, called signer anonymity in the context of ring signatures. However, signer designation is still performed by the signer in these schemes.</p>

    <h3 id="sec-2" class="text-xl font-semibold mt-8">2.1 Algorithms and Probability Notation</h3>

    <p class="text-gray-300">We say that a function  <span class="math">f: \\mathbb{N} \\to \\mathbb{R}</span>  is a negligible function if, for any c &gt; 0, there exists  <span class="math">k_0 \\in \\mathbb{N}</span>  such that  <span class="math">f(k) &lt; 1/k^c</span>  for all  <span class="math">k &gt; k_0</span> . We say that a probability function  <span class="math">p: \\mathbb{N} \\to \\mathbb{R}</span>  is overwhelming if the function  <span class="math">q: \\mathbb{N} \\to \\mathbb{R}</span>  defined by q(k) = 1 - p(k) is a negligible function. For various algorithms discussed, we will define a sequence of integers to measure the resources of these algorithms (e.g. running-time plus program length, number of oracle queries to various oracles). All these resource parameters can in general be functions of a security parameter k of the scheme. We say that an algorithm A with resource parameters  <span class="math">RP = (r_1, \\ldots, r_n)</span>  is efficient if each resource parameter  <span class="math">r_i(k)</span>  of A is bounded by a polynomial function of the security parameter k, i.e. there exists a  <span class="math">k_0 &gt; 0</span>  and c &gt; 0 such that  <span class="math">r_i(k) &lt; k^c</span>  for all  <span class="math">k &gt; k_0</span> .</p>

    <h3 id="sec-3" class="text-xl font-semibold mt-8">2.2 Discrete-Log and Diffie-Hellman Problems</h3>

    <p class="text-gray-300">Our schemes use the following known hard problems for their security. For all these problems GC denotes an algorithm that on input a security parameter k, returns an instance  <span class="math">(D_G, g)</span>  of a multiplicative group G of prime order q with generator g (the description string  <span class="math">D_G</span>  determines the group and contains the group order q).</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>1 Discrete-Log Problem (DL) [10]: Given  <span class="math">(D_G, g) = \\mathsf{GC}(k)</span>  and  <span class="math">y_1 = g^{x_1}</span>  for uniformly random  <span class="math">x_1 \\in \\mathbb{Z}_q</span> , compute  <span class="math">x_1</span> . We say that DL is <em>hard</em> if the success probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A},\\mathsf{DL}}(k)</span>  of any efficient DL algorithm A with run-time t(k) is upper-bounded by a negligible function  <span class="math">\\mathbf{InSec}_{\\mathsf{DL}}(t)</span>  of k.</li>
      <li>2 Computational Diffie-Hellman Problem (CDH) [10]: Given  <span class="math">(D_G, g) = \\mathsf{GC}(k)</span> ,  <span class="math">y_1 = g^{x_1}</span>  and  <span class="math">y_2 = g^{x_2}</span>  for uniformly random  <span class="math">x_1, x_2 \\in \\mathbb{Z}_q</span> , compute  <span class="math">\\mathsf{CDH}_g(g^{x_1}, g^{x_2}) \\stackrel{\\text{def}}{=} g^{x_1 x_2}</span> . We say that CDH is hard if the success probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A},\\mathsf{CDH}}(k)</span>  of any efficient CDH algorithm A with run-time t(k) is upper-bounded by a negligible function  <span class="math">\\mathbf{InSec}_{\\mathsf{CDH}}(t)</span>  in k.</li>
      <li>3 Strong Diffie-Hellman Problem (SDH) [1, 19]: Given  <span class="math">(D_G, g) = \\mathsf{GC}(k)</span> ,  <span class="math">y_1 = g^{x_1}</span>  and  <span class="math">y_2 = g^{x_2}</span>  for uniformly random  <span class="math">x_1, x_2 \\in \\mathbb{Z}_q</span> , compute  <span class="math">g^{x_1x_2}</span>  given access to a restricted Decision Diffie-Hellman (DDH) oracle  <span class="math">\\mathsf{DDH}_{x_1}(.,.)</span> , which on input  <span class="math">(w,K) \\in G \\times G</span> , returns 1 if  <span class="math">K = w^{x_1}</span>  and 0 else. We say that SDH is hard if the success probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A},\\mathsf{SDH}}(k)</span>  of any efficient SDH algorithm A with run-time t(k) and which makes up to q(k) queries to  <span class="math">\\mathsf{DDH}_{x_1}(.,.)</span> , is upper-bounded by a negligible function  <span class="math">\\mathbf{InSec}_{\\mathsf{SDH}}(t,q)</span>  in k.</li>
    </ul>

    <p class="text-gray-300">We remark that the Strong Diffie-Hellman problem (SDH) as defined above and in [1] is a potentially harder variant of the Gap Diffie-Hellman (GDH) problem as defined in [19]. The difference between the two problems is in the DDH oracle: In the GDH problem the DDH oracle accepts four inputs  <span class="math">(h, z_1, z_2, K)</span>  from the attacker and decides whether  <span class="math">K = \\text{CDH}_h(z_1, z_2)</span> , whereas in the SDH problem the attacker can only control the  <span class="math">(z_2, K)</span>  inputs to the DDH oracle and the other two are fixed to the values h = g and  <span class="math">z_1 = y_1</span>  (we call this weaker oracle a restricted DDH oracle).</p>

    <h4 id="sec-4" class="text-lg font-semibold mt-6">2.3 Trapdoor Hash Functions</h4>

    <p class="text-gray-300">Some of our proposed UDVS schemes make use of a general cryptographic scheme called a trapdoor hash function. We recall the definition and security notions for such schemes [25]. A trapdoor hash function scheme consists of three efficient algorithms: a key generation algorithm GKF, a hash function evaluation algorithm F, and a collision solver algorithm CSF. On input a security parameter k, the (randomized) key-gen. algorithm GKF(k) outputs a secret/public-key pair (sk, pk). On input a public-key pk, message  <span class="math">m \\in M</span>  and random  <span class="math">r \\in R</span>  (Here M and R are the message and randomness spaces, respectively), the hash function evaluation algorithm outputs a hash string  <span class="math">h = F_{pk}(m;r) \\in H</span>  (here H is the hash string space). On input a key-pair (sk, pk), a message/randomizer pair  <span class="math">(m_1, r_1) \\in M \\times R</span>  and a second message  <span class="math">m_2 \\in M</span> , the collision solver algorithm outputs a second randomizer  <span class="math">r_2 = \\mathsf{CSF}((sk, pk), (m_1, r_1), m_2) \\in R</span>  such that  <span class="math">(m_1, r_1)</span>  and  <span class="math">(m_2, r_2)</span>  constitute a collision for  <span class="math">F_{pk}</span> , i.e.  <span class="math">F_{pk}(m_1; r_1) = F_{pk}(m_2; r_2)</span> .</p>

    <p class="text-gray-300">There are two desirable security properties for a trapdoor hash function scheme TH = (GKF, F, CSF). The scheme TH is called <em>collision-resistant</em> if the success probability  <span class="math">\\mathbf{Succ}_{A,\\mathsf{TH}}^{\\mathsf{CR}}</span>  of any efficient attacker A in the following game is negligible. A key-pair  <span class="math">(sk,pk) = \\mathsf{GKF}(k)</span>  is generated, and A is given k and the public-key pk. A can run for time t and succeeds if it outputs a collision  <span class="math">(m_1,r_1)</span>  and  <span class="math">(m_2,r_2)</span>  for  <span class="math">F_{pk}</span>  satisfying  <span class="math">F_{pk}(m_1,r_1) = F_{pk}(m_2,r_2)</span>  and  <span class="math">m_1 \\neq m_2</span> . We denote by  <span class="math">\\mathbf{InSec}_{\\mathsf{TH}}^{\\mathsf{CR}}(t)</span>  the maximal success probability in above game over all attackers A with run-time plus program length at most t. The scheme TH is called <em>perfectly-trapdoor</em> if it has the following property: for each key-pair  <span class="math">(sk,pk) = \\mathsf{GKF}(k)</span>  and message pair  <span class="math">(m_1,m_2) \\in M \\times M</span> , if  <span class="math">r_1</span>  is chosen uniformly at random from R, then  <span class="math">r_2 \\stackrel{\\mathsf{def}}{=} \\mathsf{CSF}((sk,pk),(m_1,r_1),m_2) \\in R</span>  has a uniform probability distribution on R.</p>

    <p class="text-gray-300">Remark 1. Several examples of trapdoor hash function schemes are given in [25]. To make the UDVS scheme SchUDVS&lt;sub&gt;2&lt;/sub&gt; provably secure based on the discrete-log assumption, one can use the following simple trapdoor hash function scheme TH&lt;sub&gt;DL&lt;/sub&gt;, similar to that given in [25]. Let  <span class="math">h: \\{0,1\\}^* \\to \\mathbb{Z}_q</span>  be any collision-resistant hash function. The key gen. algorithm GKF chooses a group G of prime order q and outputs key-pair  <span class="math">sk = (D_G, g, x)</span>  and  <span class="math">pk = (D_G, g, y)</span>  where x is random in  <span class="math">\\mathbb{Z}_q^*</span>  and  <span class="math">y = g^x \\in G</span>  (here  <span class="math">D_G</span>  is description string for group G, including the prime group order q). On input the public key pk, and message/randomizer pair  <span class="math">(m, r) \\in \\{0, 1\\}^* \\times \\mathbb{Z}_q</span> , the evaluation algorithm computes the hash  <span class="math">h_s = F_{pk}(m; r) = g^{h(m)} \\cdot y^r \\in G</span> . On input (sk, pk) and  <span class="math">(m_1, r_1, m_2)</span> , the collision solver outputs  <span class="math">r_2 = r_1 + (h(m_1) - h(m_2)) \\cdot x^{-1} \\mod q</span> . The scheme TH&lt;sub&gt;DL&lt;/sub&gt; is collision-resistant as long as h is collision-resistant and the discrete-log is hard in G. TH&lt;sub&gt;DL&lt;/sub&gt; is also perfectly-trapdoor.</p>

    <p class="text-gray-300">We review the definition of UDVS schemes and their security notions [26]. For unforgeability we also introduce a stronger notion of security than used in [26].</p>

    <p class="text-gray-300">A Universal Designated Verifier Signature (UDVS) scheme DVS consists of seven algorithms and a 'Verifier Key-Registration Protocol' P&lt;sub&gt;KR&lt;/sub&gt;. All these algorithms may be randomized.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Parameter Generation GC on input a security parameter k, outputs a string consisting of common scheme parameters cp (publicly shared by all users).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signer Key Generation GKS</strong> on input a common parameter string cp, outputs a secret/public key-pair  <span class="math">(sk_1, pk_1)</span>  for signer.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifier Key Generation GKV on input a common parameter string cp, outputs a secret/public key-pair  <span class="math">(sk_3, pk_3)</span>  for <em>verifier</em>.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signing</strong> S on input signing secret key  <span class="math">sk_1</span> , message m, outputs signer's publicly-verifiable (PV) signature  <span class="math">\\sigma</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Public Verification</strong> V on input <em>signer</em>'s public key  <span class="math">pk_1</span>  and message/PV-signature pair  <span class="math">(m, \\sigma)</span> , outputs verification decision  <span class="math">d \\in \\{Acc, Rej\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designation</strong> CDV on input a <em>signer</em>'s public key  <span class="math">pk_1</span> , a <em>verifier</em>'s public key  <span class="math">pk_3</span>  and a message/PV-signature pair  <span class="math">(m, \\sigma)</span> , outputs a designated-verifier (DV) signature  <span class="math">\\hat{\\sigma}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designated Verification VDV</strong> on input a <em>signer</em>'s public key  <span class="math">pk_1</span> , <em>verifier</em>'s secret key  <span class="math">sk_3</span> , and message/DV-signature pair  <span class="math">(m, \\hat{\\sigma})</span> , outputs verification decision  <span class="math">d \\in \\{Acc, Rej\\}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifier Key-Registration  <span class="math">P_{KR} = (KRA, VER)</span>  a protocol between a 'Key Registration Authority' (KRA) and a 'Verifier' (VER) who wishes to register a verifier's public key. On common input cp, the algorithms KRA and VER interact by sending messages alternately from one to another. At the end of the protocol, KRA outputs a pair  <span class="math">(pk_3, Auth)</span> , where  <span class="math">pk_3</span>  is a verifier's public-key, and  <span class="math">Auth \\in \\{Acc, Rej\\}</span>  is a key-registration authorization decision. We write  <span class="math">P_{KR}(KRA, VER) = (pk_3, Auth)</span>  to denote this protocol's output.</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Verifier Key-Reg. Protocol. The purpose of the 'Verifier Key-Registration' protocol is to force the verifier to 'know' the secret-key corresponding to his public-key, in order to enforce the non-transferability privacy property. In this paper we assume, following [26], the <em>direct</em> key reg. protocol, in which the verifier simply reveals his secret key to the KRA.</p>

    <p class="text-gray-300">Consistent UDVS Schemes. The 'PV-Consistency' property requires that the PV-signatures produced by the signer are accepted as valid by the PV-verification algorithm V. The 'DV-Consistency' property requires that the DV-signatures produced by the designator using the designation algorithm CDV are accepted as valid by the DV-verification algorithm VDV. A UDVS scheme is consistent if it has both of the above consistency properties.</p>

    <h4 id="sec-5" class="text-lg font-semibold mt-6">3.1 Unforgeability</h4>

    <p class="text-gray-300">In the case of a UDVS scheme there are actually two types of unforgeability properties to consider. The first property, called called 'PV-Unforgeability', is just the usual existential unforgeability notion under chosen-message attack [13] for the standard PV signature scheme D = (GC, GKS, S, V) induced by the UDVS scheme (this prevents attacks to fool the designator). The second property, called 'DV-Unforgeability', requires that it is difficult for an attacker to forge a DV-signature  <span class="math">\\hat{\\sigma}^*</span>  by the signer on a 'new' message  <span class="math">m^*</span> , such that the pair  <span class="math">(m^*, \\hat{\\sigma}^*)</span>  passes the DV-verification test with respect to a given designated-verifier's public key  <span class="math">pk_3</span>  (this prevents attacks to fool the designated verifier, possibly mounted by a dishonest designator). As pointed out in [26], it is sufficient to prove the DV unforgeability of a UDVS scheme, since the 'DV-unforgeability' property implies the 'PV-unforgeability' property.</p>

    <p class="text-gray-300">In this paper we introduce a stronger version of DV-unforgeability than used in [26], which we call ST-DV-UF. This model allows the forger also access to the verification oracle of the designated-verifier (this oracle may help the forger because it uses the designated-verifier's secret key, which in turn can be used to forge DV signatures, as required by the privacy property). Note that the model in [26] does not provide this oracle. We believe it is desirable for UDVS schemes to be secure even under such attacks, and place no restrictions on the attacker in accessing the verifier's oracle — in particular the attacker can control both the message/DV sig. pair as well as the signer's public key in accessing this oracle. We remark (proof omitted) that the strong DV-unforgeability of the UDVS scheme in [26] follows (in the random-oracle model) from the hardness of a gap version of the Bilinear Diffie-Hellman</p>

    <p class="text-gray-300">(BDH) problem, in which the attacker has access to a BDH decision oracle (whereas just hardness of BDH suffices for this scheme to achieve the weaker DV-unforgeability notion in [26]).</p>

    <p class="text-gray-300"><strong>Definition 3.1 (Strong DV-Unforgeability).</strong> Let DVS = (GC, GKS, GKV, S, V, CDV, VDV,  <span class="math">P_{KR}</span> ) be a UDVS scheme. Let A denote a forger attacking the unforgeability of DVS. The Strong DV-Unforgeability notion ST-UF-DV for this scheme is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Attacker Input: Signer and Verifier's public-keys  <span class="math">(pk_1, pk_3)</span>  (where  <span class="math">(sk_1, pk_1) = \\mathsf{GKS}(cp)</span> ,  <span class="math">(sk_3, pk_3) = \\mathsf{GKV}(cp)</span>  and  <span class="math">cp = \\mathsf{GC}(k)</span> ).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Attacker Resources: Run-time plus program-length at most t, Oracle access to signer's signing oracle  <span class="math">S(sk_1,.)</span>  ( <span class="math">q_s</span>  queries), oracle access to designated-verifier's verification oracle  <span class="math">VDV(.,sk_3,.,.)</span>  ( <span class="math">q_v</span>  queries) and, if scheme DVS makes use of n random oracles  <span class="math">RO_1,...,RO_n</span> , allow  <span class="math">q_{RO_i}</span>  queries to the ith oracle  <span class="math">RO_i</span>  for i=1,...,n. We write attacker's Resource Parameters (RPs) as  <span class="math">RP=(t,q_s,q_v,q_{RO_1},...,q_{RO_n})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Attacker Goal: Output a forgery message/DV-signature pair  <span class="math">(m^*, \\hat{\\sigma}^*)</span>  such that:</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) The forgery is valid, i.e.  <span class="math">VDV(pk_1, sk_3, m^*, \\widehat{\\sigma}^*) = Acc.</span></li>
      <li>(2) Message m* is 'new', i.e. has not been queried by attacker to S.</li>
    </ul></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Security Notion Definition: Scheme is said to be unforgeable in the sense of ST-UF-DV if, for any efficient attacker A, the probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A},\\mathsf{DVS}}^{\\mathsf{ST-UF-DV}}(k)</span>  that A succeeds in achieving above goal is a negligible function of k. We quantify the insecurity of DVS in the sense of ST-UF-DV against arbitrary attackers with resource parameters  <span class="math">RP = (t, q_s, q_v, q_{RO_1}, \\ldots, q_{RO_n})</span>  by the probability</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}_{\\mathsf{DVS}}^{\\mathsf{ST-UF-DV}}(t,q_s,q_v,q_{RO_1},\\ldots,q_{RO_n}) \\stackrel{\\mathrm{def}}{=} \\max_{\\mathsf{A} \\in AS_{RP}} \\mathbf{Succ}_{\\mathsf{A},\\mathsf{DVS}}^{\\mathsf{ST-UF-DV}}(k),</span>$</p>

    <p class="text-gray-300">where the set  <span class="math">AS_{RP}</span>  contains all attackers with resource parameters RP.</p>

    <h4 id="sec-6" class="text-lg font-semibold mt-6">3.2 Non-Transferability Privacy</h4>

    <p class="text-gray-300">Informally, the purpose of the privacy property for a UDVS scheme is to prevent a designated-verifier from using the DV signature  <span class="math">\\sigma_{dv}</span>  on a message m to produce evidence which convinces a third-party that the message m was signed by the signer. The privacy is achieved because the designated-verifier can forge DV signatures using his secret-key, so even if the designated-verifier reveals his secret key to the third-party, the third-party cannot distinguish whether a DV signature was produced by the designator or forged by the designated-verifier.</p>

    <p class="text-gray-300">We review the privacy model from [26]. The attacker is modelled as a pair of interacting algorithms  <span class="math">(A_1, A_2)</span>  representing the designated-verifier (DV) and Third-Party (TP), respectively. Let  <span class="math">\\widehat{A_1}</span>  denote a forgery strategy. The goal of  <span class="math">A_2</span>  is to distinguish whether it is interacting with  <span class="math">A_1</span>  who has access to designated signatures (game yes) or with  <span class="math">\\widehat{A_1}</span> , who doesn't have access to designated signatures (game no). More precisely, the game yes runs in two stages as follows.</p>

    <p class="text-gray-300">Stage 1.  <span class="math">(A_1, A_2)</span>  are run on input  <span class="math">pk_1</span> , where  <span class="math">(sk_1, pk_1) = \\mathsf{GKS}(cp)</span>  and  <span class="math">cp = \\mathsf{GC}(k)</span> . In this stage,  <span class="math">\\mathsf{A}_1</span>  has access to: (1) signing oracle  <span class="math">\\mathsf{S}(sk_1, .)</span> , (2) KRA key-reg. oracle to register verifier public keys pk via  <span class="math">P_{KR}</span>  interactions, (3)  <span class="math">\\mathsf{A}_2</span>  oracle for querying a message to  <span class="math">\\mathsf{A}_2</span>  and receiving a response. At end of stage 1,  <span class="math">\\mathsf{A}_1</span>  outputs a message  <span class="math">m^*</span>  not queried to  <span class="math">\\mathsf{S}</span>  during the game  <span class="math">(m^*</span>  is given to  <span class="math">\\mathsf{A}_2</span> ). Let  <span class="math">\\sigma^* = \\mathsf{S}(sk_1, m^*)</span> .</p>

    <p class="text-gray-300">Stage 2. A&lt;sub&gt;1&lt;/sub&gt; continues to make S,KRA and A&lt;sub&gt;2&lt;/sub&gt; queries as in stage 1, but also has access to a designation oracle CDV( <span class="math">pk_1,..,m^*,\\sigma^*</span> ) which it can query with any verifier public-key pk which was answered Acc by a previous KRA key-reg. query. At end of stage 2, A&lt;sub&gt;2&lt;/sub&gt; outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">The game no is defined in the same way except that (1)  <span class="math">A_1</span>  is replaced by  <span class="math">\\widehat{A_1}</span> , (2)  <span class="math">\\widehat{A_1}</span>  receives as input  <span class="math">pk_1</span>  and the program for  <span class="math">A_1</span> , (3)  <span class="math">\\widehat{A_1}</span>  cannot make any designation queries.</p>

    <p class="text-gray-300"><strong>Definition 3.2 (PR-Privacy[26]).</strong> Let DVS = (GC, GKS, GKV, S, V, CDV, VDV,  <span class="math">P_{KR}</span> ) be a UDVS scheme. Let  <span class="math">(A_1, A_2)</span>  denote an attack pair against the privacy of DVS. Let  <span class="math">\\widehat{A_1}</span>  denote a forgery strategy. The privacy notion PR for this scheme is defined as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Attacker Input: Signer public-key  <span class="math">pk_1</span>  (where  <span class="math">(sk_1, pk_1) = \\mathsf{GKS}(cp)</span> , and  <span class="math">cp = \\mathsf{GC}(k)</span> ). Note that  <span class="math">\\widehat{\\mathsf{A}_1}</span>  also accepts the program for  <span class="math">\\mathsf{A}_1</span>  as input.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Resources for  <span class="math">(A_1,\\widehat{A_1})</span> : Run-time  <span class="math">(t_1,\\widehat{t_1})</span> , access to signing oracle  <span class="math">S(sk_1,.)</span>  (up to  <span class="math">(q_s,\\widehat{q_s})</span>  queried messages different from  <span class="math">m^*</span> ), access to key-reg. protocol interactions with the KRA (up to  <span class="math">(q_k,\\widehat{q_k})</span>  interactions), access to  <span class="math">A_2</span>  oracle (up to  <span class="math">(q_c,\\widehat{q_c})</span>  messages). In stage 2,  <span class="math">A_1</span>  also has access to designation oracle CDV( <span class="math">pk_1,...,m^*,\\sigma^*</span> ) (up to  <span class="math">q_d</span>  queried keys successfully registered with KRA), where  <span class="math">\\sigma^* = S(sk_1,m^*)</span>  is a signer's signature on the challenge message  <span class="math">m^*</span>  output by  <span class="math">A_1</span>  at end of Stage 1. Note that  <span class="math">\\widehat{A_1}</span>  cannot make any designation queries.</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Resources for</strong>  <span class="math">A_2</span> : Run-time  <span class="math">t_2</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Attacker Goal: Let  <span class="math">P(A_1, A_2)</span>  and  <span class="math">P(\\widehat{A_1}, A_2)</span>  denote the probabilities that  <span class="math">A_2</span>  outputs yes when interacting with  <span class="math">A_1</span>  (game yes) and  <span class="math">\\widehat{A_1}</span>  (game no), respectively. The goal of  <span class="math">(A_1, A_2)</span>  is to achieve a non-negligible convincing measure  <span class="math">C_{\\widehat{A_1}}(A_1, A_2) \\stackrel{\\text{def}}{=} |P(A_1, A_2) P(\\widehat{A_1}, A_2)|</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Security Notion Definition: Scheme is said to achieve privacy in the sense of PR if there exists an efficient forgery strategy  <span class="math">\\widehat{A}_1</span>  such that the convincing measure  <span class="math">C_{\\widehat{A}_1}(A_1, A_2)</span>  achieved by any efficient attacker pair  <span class="math">(A_1, A_2)</span>  is negligible in the security parameter k. We quantify the insecurity of DVS in the sense of PR against arbitrary attacker pairs  <span class="math">(A_1, A_2)</span>  with resources  <span class="math">(RP_1, RP_2)</span>  (attacker set  <span class="math">AS_{RP_1, RP_2}</span> ), with respect to arbitrary forgery strategies  <span class="math">\\widehat{A}_1</span>  with resources  <span class="math">\\widehat{RP}_1</span>  (attacker set  <span class="math">AS_{\\widehat{RP}_1}</span> ) by the probability</li>
    </ol></li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}^{\\mathrm{PR}}_{\\mathsf{DVS}}(RP_1,\\widehat{RP}_1,RP_2) \\stackrel{\\mathrm{def}}{=} \\min_{\\widehat{\\mathsf{A}_1} \\in AS_{\\widehat{RP}_1}} \\max_{(\\mathsf{A}_1,\\mathsf{A}_2) \\in AS_{RP_1,RP_2}} C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1,\\mathsf{A}_2).</span>$</p>

    <p class="text-gray-300">If  <span class="math">\\mathbf{InSec}_{\\mathsf{DVS}}^{\\mathsf{PR}}(RP_1,\\widehat{RP_1},RP_2) = 0</span>  holds for any computationally unbounded  <span class="math">\\mathsf{A}_2</span> , it is said to be perfect unconditional privacy. If privacy holds when  <span class="math">\\widehat{q_{s1}} = q_{s1}</span>  it is said to be complete privacy.</p>

    <p class="text-gray-300">We will present two UDVS schemes which are both extensions of the Schnorr [24] signature scheme (that is, the signer key-generation, signing and public-verification algorithms in both schemes are identical to those of the Schnorr signature). The first UDVS scheme SchUDVS&lt;sub&gt;1&lt;/sub&gt; has an efficient and deterministic designation algorithm and its unforgeability relies on the Strong Diffie-Hellman (SDH) assumption. The second UDVS scheme SchUDVS&lt;sub&gt;2&lt;/sub&gt; has a less efficient randomized designation algorithm, but its unforgeability follows from the weaker Discrete-Logarithm (DL) assumption (in the random-oracle model).</p>

    <p class="text-gray-300">Our first UDVS scheme SchUDVS&lt;sub&gt;1&lt;/sub&gt; is defined as follows. Let  <span class="math">\\{0,1\\}^{\\leq \\ell}</span>  denote the message space of all bit strings of length at most  <span class="math">\\ell</span>  bits. The scheme makes use of a cryptographic hash function  <span class="math">H:\\{0,1\\}^{\\leq \\ell}\\times\\{0,1\\}^{l_G}\\to\\{0,1\\}^{l_H}</span> , modelled as a random-oracle [2] in our security analysis. We assume that elements of the group G output by algorithm GC are represented by bit strings of length  <span class="math">l_G\\geq l_q</span>  bits, where  <span class="math">l_q\\stackrel{\\text{def}}{=}|\\log_2 q|+1</span>  is the bit length of q.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Parameter Generation GC. (Identical to Schnorr). Choose a group G of prime order  <span class="math">q &gt; 2^{l_H}</span>  with description string  <span class="math">D_G</span>  (e.g. if G is a subgroup of  <span class="math">\\mathbb{Z}_p^*</span> , the string  <span class="math">D_G</span>  would contain (p,q)), and let  <span class="math">g \\in G</span>  denote a generator for G. The common parameters are  <span class="math">cp = (D_G, g)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signer Key Generation GKS. (Identical to Schnorr). Given the common parameters cp, pick random  <span class="math">x_1 \\in \\mathbb{Z}_q^*</span>  and compute  <span class="math">y_1 = g^{x_1}</span> . The public key is  <span class="math">pk_1 = (cp, y_1)</span> . The secret key is  <span class="math">sk_1 = (cp, x_1)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifier Key Generation GKV. Given the common parameters cp, pick random  <span class="math">x_3 \\in \\mathbb{Z}_q^*</span>  and compute  <span class="math">y_3 = g^{x_3}</span> . The public key is  <span class="math">pk_3 = (cp, y_3)</span> . The secret key is  <span class="math">sk_3 = (cp, x_3)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signing S.</strong> (Identical to Schnorr). Given the signer's secret key  <span class="math">(cp, x_1)</span> , and message m, choose a random  <span class="math">k \\in \\mathbb{Z}_q</span>  and compute  <span class="math">u = g^k</span> , r = H(m, u) and  <span class="math">s = k + r \\cdot x_1 \\pmod{q}</span> . The PV signature is  <span class="math">\\sigma = (r, s)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Public Verification</strong> V. (Identical to Schnorr). Given the signer's public key  <span class="math">y_1</span>  and a message/PV sig. pair (m, (r, s)), accept if and only if H(m, u) = r, where  <span class="math">u = g^s \\cdot y_1^{-r}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designation</strong> CDV. Given the signer's public key  <span class="math">y_1</span> , a verifier's public key  <span class="math">y_3</span>  and a message/PV-signature pair (m, (r, s)), compute  <span class="math">u = g^s \\cdot y_1^{-r}</span>  and  <span class="math">K = y_3^s</span> . The DV signature is  <span class="math">\\widehat{\\sigma} = (u, K)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designated Verification VDV</strong>. Given a signer's public key  <span class="math">y_1</span> , a verifier's secret key  <span class="math">x_3</span> , and message/DV-sig. pair (m, (u, K)), accept if and only if  <span class="math">K = (u \\cdot y_1^r)^{x_3}</span> , where r = H(m, u).</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Unforgeability. The PV-Unforgeability of SchUDVS&lt;sub&gt;1&lt;/sub&gt; is equivalent to the unforgeability of the Schnorr signature, which in turn is equivalent to the Discrete-Logarithm (DL) assumption in G, assuming the random-oracle model for H(.) [20]. However, for the DV-Unforgeability of SchUDVS&lt;sub&gt;1&lt;/sub&gt;, it is clear that the stronger 'Computational Diffie-Hellman' (CDH) assumption in G is certainly necessary — an attacker can forge a DV signature (u, K) on a message m by choosing a random  <span class="math">u \\in G</span> , computing r = H(m, u) and then  <span class="math">K = \\text{CDH}_g(u \\cdot y_1^r, y_3)</span>  (indeed this is the idea behind the proof of the privacy of SchUDVS&lt;sub&gt;1&lt;/sub&gt; — see below). Moreover, in the strong DV-unforgeability attack setting, the even stronger 'Strong Diffie-Hellman' (SDH) assumption in G is necessary. This is because the forger's access to the verifier's VDV oracle allows him to simulate the fixed-input DDH oracle DDH&lt;sub&gt;x3&lt;/sub&gt;(w, K) which decides whether  <span class="math">K = w^{x_3}</span>  or not (see Sec. 2.2), namely we have DDH&lt;sub&gt;x3&lt;/sub&gt; <span class="math">(w, K) = \\text{VDV}(y_1&#x27;, x_3, m, (u, K))</span>  with  <span class="math">y_1&#x27; = (w \\cdot u^{-1})^{r-1} \\mod q</span>  and r = H(m, u). Note that this does not rule out the possibility that there may be another attack which even bypasses the need to break SDH. Fortunately, the following theorem shows that this is not the case and SDH is also a sufficient condition for Strong DV-Unforgeability of SchUDVS&lt;sub&gt;1&lt;/sub&gt;, assuming the random-oracle model for H(.). The proof uses the forking technique, as used in the proof in [20] of PV-Unforgeability of the Schnorr signature.</p>

    <p class="text-gray-300"><strong>Theorem 4.1 (Strong DV-Unforg. of SchUDVS&lt;sub&gt;1&lt;/sub&gt;).</strong> If the Strong Diffie-Hellman problem (SDH) is hard in groups generated by the common-parameter algorithm GC, then the scheme SchUDVS&lt;sub&gt;1&lt;/sub&gt; achieves</p>

    <p class="text-gray-300">Strong DV-unforgeability (ST-UF-DV notion) in the random-oracle model for H(.). Concretely, the following insecurity bound holds:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}_{\\mathsf{SchUDVS}_1}^{\\mathsf{ST-UF-DV}}(t,q_s,q_v,q_H) \\leq 2\\left[(q_H+q_v)\\mathbf{InSec}_{\\mathsf{SDH}}(t[S],q[S])\\right]^{1/2} + \\frac{q_s(q_H+q_s+q_v) + 2(q_H+q_v) + 1}{2^{l_H}}</span>$</p>

    <p class="text-gray-300">where  <span class="math">t[S] = 2t + 2(q_H + q_s + q_v + 1)(T_S + O(l_H)) + (q_s + 1)O(l_qT_g) + O(l_q^2)</span> , where  <span class="math">T_S = O(\\log_2(q_H + q_s + q_v) \\cdot (\\ell + l_G))</span>  and  <span class="math">q[S] = 2q_v</span> . Here we denote by  <span class="math">T_g</span>  the time needed to perform a group operation in G.</p>

    <p class="text-gray-300"><em>Privacy.</em> The privacy of SchUDVS&lt;sub&gt;1&lt;/sub&gt; follows from the existence of an algorithm for forging DV signatures (with identical probability distribution as that of real DV signatures) using the verifier's secret key, which is a trapdoor for solving the CDH problem on which the DV-Unforgeability relies.</p>

    <p class="text-gray-300"><strong>Theorem 4.2 (Privacy of SchUDVS&lt;sub&gt;1&lt;/sub&gt;).</strong> The scheme  <span class="math">SchUDVS_1</span>  achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}_{\\mathsf{SchUDVS}_{1}}^{\\mathsf{PR}}(RP_{1},\\widehat{RP}_{1},\\infty) = 0, \\tag{1}</span>$</p>

    <p class="text-gray-300">where  <span class="math">RP_1 = (t_1, q_{s1}, q_{c1}, q_{k1}, q_{d1})</span>  denotes  <span class="math">A_1</span> 's resource parameters and  <span class="math">\\widehat{RP}_1 = (\\widehat{t}_1, \\widehat{q}_{s1}, \\widehat{q}_{c1}, \\widehat{q}_{k1})</span>  denotes the forgery strategy  <span class="math">\\widehat{A}_1</span> 's resources, which are given by:  <span class="math">\\widehat{t}_1 = t_1 + q_{d1}O(l_qT_g + q_{d1}l_G) + q_{k1}O(l_qT_g)</span> ,  <span class="math">\\widehat{q}_{s1} = q_{s1}</span>  (complete privacy),  <span class="math">\\widehat{q}_{c1} = q_{c1}</span> ,  <span class="math">\\widehat{q}_{k1} = 0</span> .</p>

    <h3 id="sec-7" class="text-xl font-semibold mt-8">4.2 Second Scheme: SchUDVS&lt;sub&gt;2&lt;/sub&gt;</h3>

    <p class="text-gray-300">Our second UDVS scheme SchUDVS&lt;sub&gt;2&lt;/sub&gt; trades off efficiency for a better provable unforgeability security guarantee. Rather than using the Diffie-Hellman trapdoor function to achieve privacy, we instead get the designator to produce a Schnorr proof of knowledge of the PV signature (r, s). This proof of knowledge is made non-interactive in the random-oracle model using the Fiat-Shamir heuristic [11], but using a trapdoor hash function [16, 25]  <span class="math">F_{y_3}(.;.)</span>  composed with a random oracle J(.) in producing the 'verifier random challenge'  <span class="math">\\hat{r}</span>  for this proof of knowledge. The designated-verifier's secret key consists of the trapdoor for the hash function  <span class="math">F_{y_3}</span> , which suffices for forging the DV signatures, thus providing the privacy property. We remark that a similar technique was used by Jakobsson Sako and Impagliazzo [15], who used a trapdoor commitment scheme in constructing a designated-verifier undeniable signature scheme. Our scheme can use any secure trapdoor hash function.</p>

    <p class="text-gray-300">The resulting scheme is defined as follows. Let  <span class="math">\\{0,1\\}^{\\leq \\ell}</span>  denote the message space of all bit strings of length at most  <span class="math">\\ell</span>  bits. The scheme makes use of two cryptographic hash functions  <span class="math">H:\\{0,1\\}^{\\leq \\ell}\\times\\{0,1\\}^{l_G}\\to\\{0,1\\}^{l_H}</span>  and  <span class="math">J:\\{0,1\\}^{\\leq \\ell}\\times\\mathbb{Z}_{2^{l_H}}\\times\\{0,1\\}^{l_G}\\times\\{0,1\\}^{l_G}\\to\\{0,1\\}^{l_J}</span> , both modelled as randomoracles [2] in our security analysis. We also use a trapdoor hash function scheme  <span class="math">\\mathsf{TH}=(\\mathsf{GKF},F,\\mathsf{CSF})</span>  with  <span class="math">F_{y_3}:\\{0,1\\}^{l_G}\\times R_F\\to\\{0,1\\}^{l_F}</span>  (we refer the reader to Section 2 for a definition of trapdoor hash function schemes). We assume that elements of the group G output by algorithm  <span class="math">\\mathsf{GC}</span>  are represented by bit strings of length  <span class="math">l_G\\geq l_q</span>  bits, where  <span class="math">l_q\\stackrel{\\mathrm{def}}{=}\\lfloor\\log_2 q\\rfloor+1</span>  is the bit length of q.</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Parameter Generation GC. (Identical to Schnorr). Choose a group G of prime order q with description string  <span class="math">D_G</span>  (e.g. if G is a subgroup of  <span class="math">\\mathbb{Z}_p^*</span> , the string  <span class="math">D_G</span>  would contain (p,q)), and let  <span class="math">g \\in G</span>  denote a generator for G. The common parameters are  <span class="math">cp = (k, D_G, g)</span>  (k is the security parameter).</li>
    </ol>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signer Key Generation GKS. (Identical to Schnorr). Given the common parameters cp, pick random  <span class="math">x_1 \\in \\mathbb{Z}_q</span>  and compute  <span class="math">y_1 = g^{x_1}</span> . The public key is  <span class="math">pk_1 = (cp, y_1)</span> . The secret key is  <span class="math">sk_1 = (cp, x_1)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Verifier Key Generation GKV</strong>. Given the common parameters cp = k, run TH's key-gen. algorithm to compute  <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span> . The public key is  <span class="math">pk_3 = (cp, pk)</span> . The secret key is  <span class="math">sk_3 = (cp, sk, pk)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Signing S. (Identical to Schnorr). Given the signer's secret key  <span class="math">(cp, x_1)</span> , and message m, choose a random  <span class="math">k \\in \\mathbb{Z}_q</span>  and compute  <span class="math">u = g^k</span> , r = H(m, u) and  <span class="math">s = k + r \\cdot x_1 \\pmod{q}</span> . The PV signature is  <span class="math">\\sigma = (r, s)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Public Verification</strong> V. (Identical to Schnorr). Given the signer's public key  <span class="math">y_1</span>  and a message/PV sig. pair (m, (r, s)), accept if and only if H(m, u) = r, where  <span class="math">u = g^s \\cdot y_1^{-r}</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designation</strong> CDV. Given the signer's public key  <span class="math">y_1</span> , a verifier's public key  <span class="math">pk_3 = (cp, pk)</span>  and a message/PV-signature pair (m, (r, s)), compute  <span class="math">u = g^s \\cdot y_1^{-r}</span> ,  <span class="math">\\widehat{u} = g^{\\widehat{k}}</span>  for a random  <span class="math">\\widehat{k} \\in \\mathbb{Z}_q</span> ,  <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span>  for a random  <span class="math">\\widehat{r}_F \\in R_F</span> ,  <span class="math">\\widehat{r} = J(m, r, u, \\widehat{h})</span>  and  <span class="math">\\widehat{s} = \\widehat{k} + \\widehat{r} \\cdot s \\mod q</span> . The DV signature is  <span class="math">\\widehat{\\sigma} = (u, \\widehat{r}_F, \\widehat{r}, \\widehat{s})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designated Verification</strong> VDV. Given a signer's public key  <span class="math">y_1</span> , a verifier's secret key  <span class="math">sk_3 = (cp, sk, pk)</span> , and message/DV-sig. pair  <span class="math">(m, (u, \\widehat{r}_F, \\widehat{r}, \\widehat{s}))</span> , accept if and only if  <span class="math">J(m, r, u, \\widehat{h}) = \\widehat{r}</span> , where r = H(m, u),  <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span>  and  <span class="math">\\widehat{u} = g^{\\widehat{s}} \\cdot (u \\cdot y_1^r)^{-\\widehat{r}}</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Unforgeability. The idea behind the DV-Unforgeability of SchUDVS&lt;sub&gt;2&lt;/sub&gt;, is that the DV signature is effectively a proof of knowledge of the s portion of the PV Schnorr signature (r, s) by the signer on m. Namely, using the forking technique we can use a forger for SchUDVS&lt;sub&gt;2&lt;/sub&gt; to extract s and hence forge a Schnorr PV signature for some unsigned message m, or alternately to break the collision-resistance of the trapdoor hash scheme TH. We have the following concrete result. Note that we need only assume that J(.) is a random-oracle in proving this result, but we provide a count of H(.) queries to allow the use of our reduction bound in conjunction with known results on the unforgeability of the Schnorr signature which assume the random-oracle model for H(.).</p>

    <p class="text-gray-300">Theorem 4.3 (Strong DV-Unforg. of SchUDVS&lt;sub&gt;2&lt;/sub&gt;). If SchUDVS&lt;sub&gt;2&lt;/sub&gt; is PV-unforgeable (UF-PV notion) and TH is collision-resistant (CR notion) then SchUDVS&lt;sub&gt;2&lt;/sub&gt; achieves Strong DV-unforgeability (ST-UF-DV notion) in the random-oracle model for J(.). Concretely, the following insecurity bound holds:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{InSec}^{\\mathrm{ST-UF-DV}}_{\\mathsf{SchUDVS}_2}(t,q_s,q_v,q_J,q_H) \\leq \\\\ 2[(q_J+q_v)q_s]^{1/2} \\left[ \\mathbf{InSec}^{\\mathrm{UF-PV}}_{\\mathsf{SchUDVS}_2}(t[S],q_s[S],q_H[S]) + \\mathbf{InSec}^{\\mathrm{CR}}_{\\mathsf{TH}}(t[T]) \\right]^{1/2} + \\frac{2(q_J+q_v)q_s+1}{2^{l_J}}, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">t[S] = t[T] = 2t + O((q_J + q_v)(\\ell + l_F + l_G) + l_q T_g + l_q^2)</span> ,  <span class="math">q_s[S] = 2q_s</span>  and  <span class="math">q_H[S] = 2q_H</span> . Here we denote by  <span class="math">T_g</span>  the time needed to perform a group operation in G.</p>

    <p class="text-gray-300">Privacy. The privacy of SchUDVS&lt;sub&gt;2&lt;/sub&gt; follows from the existence of an algorithm for forging DV signatures (with identical probability distribution as that of real DV signatures) using the verifier's secret key, which is a trapdoor for solving collisions in TH. In particular we need here the perfectly-trapdoor property of TH. This result holds in the standard model (no random-oracle assumptions).</p>

    <p class="text-gray-300"><strong>Theorem 4.4 (Privacy of SchUDVS&lt;sub&gt;2&lt;/sub&gt;).</strong> If the scheme TH is perfectly-trapdoor then SchUDVS&lt;sub&gt;2&lt;/sub&gt; achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}_{\\mathsf{SchUDVS}_2}^{\\mathsf{PR}}(RP_1,\\widehat{RP}_1,\\infty) = 0, \\tag{2}</span>$</p>

    <p class="text-gray-300">where  <span class="math">RP_1 = (t_1, q_{s1}, q_{c1}, q_{k1}, q_{d1})</span>  denotes  <span class="math">A_1</span> 's resource parameters and  <span class="math">\\widehat{RP}_1 = (\\widehat{t}_1, \\widehat{q}_{s1}, \\widehat{q}_{c1}, \\widehat{q}_{k1})</span>  denotes the forgery strategy  <span class="math">\\widehat{A}_1</span> 's RPs, which are given by:  <span class="math">\\widehat{t}_1 = t_1 + q_{d1}O(l_qT_g + T_F + T_{CSF} + T_J + T_H + q_{d1}l_{pk}) + q_{k1}T_{GKF}</span> ,  <span class="math">\\widehat{q}_{s1} = q_{s1}</span>  (complete privacy),  <span class="math">\\widehat{q}_{c1} = q_{c1}</span> ,  <span class="math">\\widehat{q}_{k1} = 0</span> . Here we let  <span class="math">T_g, T_F, T_{GKF}, T_{CSF}, T_J, T_H</span>  denote the time to compute a group operation, and evaluate F, GKF, CSF, J and H respectively, and  <span class="math">l_{pk}</span>  denotes an upper-bound on the length of public keys for scheme TH.</p>

    <p class="text-gray-300">The idea for the construction of an RSA-based UDVS scheme is analogous to the second Schnorr-based scheme SchUDVS&lt;sub&gt;2&lt;/sub&gt;, and is described as follows. The PV RSA signature known to the designator is the eth root  <span class="math">\\sigma = h^{1/e} \\mod N</span>  of the message hash h, where (N,e) is the signer's RSA public key. To produce a DV signature on m, the designator computes a zero-knowledge proof of knowledge of the PV signature  <span class="math">\\sigma</span>  (made non-interactive using Fiat-Shamir method [11]), which is forgeable by the verifier. The Guilliou-Quisquater ID-based signature [14] is based on such a proof and is applied here for this purpose. To make the proof forgeable by the verifier, we use a trapdoor hash function in the computation of the challenge, as done in the SchUDVS&lt;sub&gt;2&lt;/sub&gt; scheme. We note that a restriction of the GQ proof that we use is that the random challenge r must be smaller than the public exponent e. To allow for small public exponents and achieve high security level, we apply  <span class="math">\\alpha</span>  proofs in 'parallel', where  <span class="math">\\alpha</span>  is chosen to achieve a sufficient security level — see security bound in our security analysis (a similar technique is used in the Fiat-Shamir signature scheme [11]).</p>

    <p class="text-gray-300">The resulting scheme is defined as follows. Let  <span class="math">\\{0,1\\}^{\\leq \\ell}</span>  denote the message space of all bit strings of length at most  <span class="math">\\ell</span>  bits. The scheme makes use of two cryptographic hash functions  <span class="math">H:\\{0,1\\}^{\\leq \\ell}\\times R_S\\to \\{0,1\\}^{l_H}</span>  and  <span class="math">J:\\{0,1\\}^{\\leq \\ell}\\times \\mathbb{Z}_{l_N}^\\alpha\\times \\{0,1\\}^{l_F}\\to \\mathbb{Z}_{2^{l_J/\\alpha}}^\\alpha</span> . Note that we only need to assume that J(.) is a random-oracle model in our security analysis, and that we allow randomized RSA signatures with hash generation h=H(m;s) for random s. The corresponding verification is to check if R(h,m)=Acc or not, where R(.) is a binary relation function that outputs Acc if h is a valid hash of message m and outputs Rej else. Thus by a suitable choice of H(.,.) and R(.,.) our scheme can instantiated with any of the standardised variants of RSA signatures such as RSASSA-PSS or RSASSA-PKCS1-v15, as specified in the PKCS1 standard [23]. We also use a trapdoor hash function scheme TH = (GKF, F, CSF) with  <span class="math">F_{y_3}:\\{0,1\\}^{l_G}\\times R_F\\to\\{0,1\\}^{l_F}</span>  (we refer the reader to Section 2 for a definition of trapdoor hash function schemes). Here  <span class="math">l_N</span>  denotes the length of RSA modulus N of the signer's public key.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Common Parameter Generation GC. (Identical to RSA). The comm. pars. are cp = k (k is the security parameter).</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signer Key Generation GKS</strong>. (Identical to RSA). Given the common parameters cp, choose a prime  <span class="math">e &gt; 2^{l_J/\\alpha}</span> . Pick random primes p and q such that N = pq has bit-length  <span class="math">l_N</span>  and  <span class="math">gcd(e, \\phi(N)) = 1</span> , where  <span class="math">\\phi(N) = (p-1)(q-1)</span> . Compute  <span class="math">d = e^{-1} \\mod \\phi(N)</span> . The public key is  <span class="math">pk_1 = (cp, N, e)</span> . The secret key is  <span class="math">sk_1 = (cp, N, e, d)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Verifier Key Generation GKV. Given the comm. pars. cp = k, run TH's key-gen. algorithm to compute  <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span> . The public key is  <span class="math">pk_3 = (cp, pk)</span> . The secret key is  <span class="math">sk_3 = (cp, sk, pk)</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Signing S.</strong> (Identical to RSA). Given the signer's secret key (cp, N, e, d), and message m, choose a random  <span class="math">s \\in R_S</span>  and compute h = H(m, s) and  <span class="math">\\sigma = h^d \\mod N</span> . The PV signature is  <span class="math">\\sigma</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Public Verification V.</strong> (Identical to RSA). Given the signer's public key (cp, N, e) and a message/PV sig. pair  <span class="math">(m, \\sigma)</span> , accept if and only if R(m, h) = Acc, where  <span class="math">h = \\sigma^e \\mod N</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designation</strong> CDV. Given the signer's public key (cp, N, e), a verifier's public key  <span class="math">pk_3 = (cp, pk)</span>  and a message/PV-signature pair  <span class="math">(m, \\sigma)</span> , choose  <span class="math">\\alpha</span>  random elements  <span class="math">k_i \\in \\mathbb{Z}_N^*</span>  and compute  <span class="math">\\widehat{u} = (\\widehat{u}_1, \\dots, \\widehat{u}_{\\alpha})</span> , where  <span class="math">\\widehat{u}_i = k_i^e \\mod N</span>  for  <span class="math">i = 1, \\dots, \\alpha</span> . Compute  <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span>  for random  <span class="math">\\widehat{r}_F \\in R_F</span> . Compute  <span class="math">\\widehat{r} = (\\widehat{r}_1, \\dots, \\widehat{r}_{\\alpha}) = J(m, h, \\widehat{h})</span> , where  <span class="math">h = \\sigma^e \\mod N</span>  and  <span class="math">\\widehat{r}_i \\in \\mathbb{Z}_{2^{l_J/\\alpha}}</span>  for  <span class="math">i = 1, \\dots, \\alpha</span> . Compute  <span class="math">\\widehat{s} = (\\widehat{s}_1, \\dots, \\widehat{s}_{\\alpha})</span> , where  <span class="math">\\widehat{s}_i = k_i \\cdot \\sigma^{\\widehat{r}_i} \\mod N</span>  for all  <span class="math">i = 1, \\dots, \\alpha</span> . The DV signature is  <span class="math">\\widehat{\\sigma} = (h, \\widehat{r}_F, \\widehat{r}, \\widehat{s})</span> .</li>
    </ol></li>
      <li><ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><strong>Designated Verification</strong> VDV. Given a signer's public key (cp, N, e), a verifier's secret key  <span class="math">sk_3 = (cp, sk, pk)</span> , and message/DV-sig. pair  <span class="math">(m, (h, \\widehat{r}_F, \\widehat{r}, \\widehat{s}))</span> , accept if and only if  <span class="math">J(m, h, \\widehat{h}) = \\widehat{r}</span>  and R(m, h) = Acc, where  <span class="math">\\widehat{h} = F_{pk}(\\widehat{u}; \\widehat{r}_F)</span>  with  <span class="math">\\widehat{u} = (\\widehat{u}_1, \\dots, \\widehat{u}_{\\alpha})</span>  and  <span class="math">\\widehat{u}_i = \\widehat{s}_i^e \\cdot h^{-\\widehat{r}_i} \\mod N</span>  for  <span class="math">i = 1, \\dots, \\alpha</span> .</li>
    </ol></li>
    </ul>

    <p class="text-gray-300">Unforgeability. Similar to the scheme  <span class="math">SchUDVS_2</span> , thanks to the soundness of the GQ proof of knowledge of RSA inverses, we can prove the DV unforgeability of RSAUDVS assuming the PV-unforgeability of RSAUDVS (i.e. the existential unforgeability under chosen-message attack of the underlying standard RSA signature (GKS, S, V)) and the collision-resistance of the trapdoor hash TH. The concrete result is the following.</p>

    <p class="text-gray-300">Theorem 5.1 (Strong DV-Unforg. of RSAUDVS). If RSAUDVS is PV-unforgeable (UF-PV notion) and TH is collision-resistant (CR notion) then RSAUDVS achieves  <span class="math">Strong\\ DV</span> -unforgeability (ST-UF-DV notion) in the random-oracle model for J(.). Concretely, the following insecurity bound holds:</p>

    <p class="text-gray-300"><span class="math">$\\begin{split} \\mathbf{InSec}^{\\mathrm{ST-UF-DV}}_{\\mathsf{RSAUDVS}}(t,q_s,q_v,q_J,q_H) \\leq \\\\ &amp; 2[(q_J+q_v)q_s]^{1/2} \\left[ \\mathbf{InSec}^{\\mathrm{UF-PV}}_{\\mathsf{RSAUDVS}}(t[S],q_s[S],q_H[S]) + \\mathbf{InSec}^{\\mathrm{CR}}_{\\mathsf{TH}}(t[T]) \\right]^{1/2} + \\frac{2(q_J+q_v)q_s+1}{2^{l_J}}, \\end{split}</span>$</p>

    <p class="text-gray-300">where  <span class="math">t[S] = t[T] = 2t + O((q_J + q_v)(l_F + l_N) + l_e^2 + l_e T_N)</span> ,  <span class="math">q_s[S] = 2q_s</span>  and  <span class="math">q_H[S] = 2q_H</span> . Here we denote by  <span class="math">T_N</span>  the time needed to perform a multiplication in  <span class="math">\\mathbb{Z}_N^*</span>  and  <span class="math">l_e = \\log_2(e)</span> .</p>

    <p class="text-gray-300"><em>Privacy.</em> The privacy of RSAUDVS is unconditional and complete, assuming the perfectly-trapdoor property of the trapdoor hash scheme TH.</p>

    <p class="text-gray-300"><strong>Theorem 5.2 (Privacy of RSAUDVS).</strong> If the scheme TH is perfectly-trapdoor then RSAUDVS achieves complete and perfect unconditional privacy (in the sense of the PR notion). Concretely:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{InSec}_{\\mathsf{RSAUDVS}}^{\\mathsf{PR}}(RP_1, \\widehat{RP}_1, \\infty) = 0, \\tag{3}</span>$</p>

    <p class="text-gray-300">where  <span class="math">RP_1=(t_1,q_{s1},q_{c1},q_{k1},q_{d1})</span>  denotes  <span class="math">A_1</span> 's resource parameters and  <span class="math">\\widehat{RP}_1=(\\widehat{t}_1,\\widehat{q}_{s1},\\widehat{q}_{c1},\\widehat{q}_{k1})</span>  denotes the forgery strategy  <span class="math">\\widehat{A_1}</span> 's RPs, which are given by:  <span class="math">\\widehat{t}_1=t_1+q_{d1}O(l_JT_N+T_F+T_{CSF}+T_J+T_H+q_{d1}l_{pk})+q_{k1}T_{GKF}</span> ,  <span class="math">\\widehat{q}_{s1}=q_{s1}</span>  (complete privacy),  <span class="math">\\widehat{q}_{c1}=q_{c1}</span> ,  <span class="math">\\widehat{q}_{k1}=0</span> . Here we let  <span class="math">T_N,T_F,T_{GKF},T_{CSF},T_J,T_H</span>  denote the time to compute a multiplication modulo N, and evaluate F, GKF, CSF, J and H respectively, and  <span class="math">l_{pk}</span>  denotes an upper-bound on the length of public keys for scheme TH.</p>

    <p class="text-gray-300">The following tables compare the security and performance features of the proposed schemes (also shown for comparison is an entry for the bilinear-based UDVS scheme DVSBM [26]. It is evident that SchUDVS&lt;sub&gt;1&lt;/sub&gt; is more computationally efficient than SchUDVS&lt;sub&gt;2&lt;/sub&gt; but its security relies on a stronger assumption and it also produces slightly longer DV signatures. The RSA-based scheme RSAUDVS has a disadvantage of long DV signature length (typically about 10 times the length of a standard RSA signature) assuming a low public exponent  <span class="math">e = 2^{16} + 1</span> . However, the computation is about the same as in the Schnorr-based schemes. This is because the  <span class="math">O(l_J/\\log_2(e))</span>  exponentiations for RSAUDVS shown in Table 2 use a low exponent e, so the total computation is only  <span class="math">O(l_J)</span>  modular multiplications.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Extended Sig.</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Hard Problem</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Det. Desig?</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">DV Sig. Length (typ)</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SchUDVS &lt;sub&gt;1&lt;/sub&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Schnorr</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SDH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2l_G (2.0 \\text{ kb})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">SchUDVS_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Schnorr</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DL</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">l_G + l_F + 2l_q \\ (1.5 \\text{ kb})</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RSAUDVS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RSA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RSA</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">No</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">l_N + l_F + l_J + \\lceil l_J / \\log_2(e) \\rceil l_N </span> (11.6 kb)</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DVSBM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BLS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">BDH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">Yes</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">l_{G_T} (1.0 \\text{ kb})</span></td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 1: Comparison of UDVS Schemes Features. See Secs. 4 and 5 for symbol definitions. The column 'Det Desig?' indicates if the schemes designation algorithm is deterministic or not. The 'DV Sig. Length (typ)' column entries give DV signature lengths for the following typical scheme parameter values. For SchUDVS&lt;sub&gt;1&lt;/sub&gt; and SchUDVS&lt;sub&gt;2&lt;/sub&gt;, we assume a subgroup G of order q in  <span class="math">\\mathbb{Z}_p^*</span>  for p prime, with  <span class="math">l_G = 1.024</span>  kb,  <span class="math">l_q = l_J = 0.16</span>  kb. For RSAUDVS, we assume  <span class="math">l_N = 1.024</span> ,  <span class="math">l_J = 0.16</span>  kb and  <span class="math">e = 2^{16} + 1</span> . For DVSBM we assume image group of length  <span class="math">l_{G_T} = 1.024</span>  kb.</p>

    <div class="overflow-x-auto my-4">
      <table class="min-w-full text-sm text-gray-300">
        <thead>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Scheme</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Desig. Time</th>
            <th class="px-3 py-2 border-b border-gray-600 font-semibold text-left">Ver. Time</th>
        </thead>
        <tbody>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">SchUDVS &lt;sub&gt;1&lt;/sub&gt;</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2  exp.</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 exp.</td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">SchUDVS_2</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">2  exp. + TH</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">1 \\exp. + TH</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">RSAUDVS</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">2(\\lceil l_J / \\log_2(e) \\rceil + 1) \\text{ exp. } + TH</span></td>
            <td class="px-3 py-2 border-b border-gray-700 text-left"><span class="math">\\lceil l_J / \\log_2(e) \\rceil + 1 \\text{ exp. } + TH</span></td>
          </tr>
          <tr>
            <td class="px-3 py-2 border-b border-gray-700 text-left">DVSBM</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1 pairing</td>
            <td class="px-3 py-2 border-b border-gray-700 text-left">1  pairing + 1  exp.</td>
          </tr>
        </tbody>
      </table>
    </div>

    <p class="text-gray-300">Table 2: Comparison of UDVS Schemes Approximate Computation Time. Here we count the cost of computing a product  <span class="math">a^x b^y c^z</span>  as equivalent to a single exponentiation (exp.) in the underlying group. For RSAUDVS exponent lengths are all  <span class="math">\\log_2(e)</span> . TH denotes the cost of evaluating the trapdoor hash function  <span class="math">F_{pk}</span>  (typ. 1 exp.).</p>

    <p class="text-gray-300">We have shown how to efficiently extend the standard Schnorr and RSA signature schemes into Universal Designated-Verifier Signature schemes, and provided a concrete security analysis of the resulting schemes. One problem of our RSA scheme is that the length of designated signatures is larger than standard RSA signatures by a factor roughly proportional to  <span class="math">k/\\log_2(e)</span> , where k is the security parameter and e is the public exponent. An interesting open problem is to find an RSA based UDVS scheme with designated signatures only a constant factor longer than standard RSA signatures, independent of e.</p>

    <h4 id="sec-8" class="text-lg font-semibold mt-6">References</h4>

    <p class="text-gray-300">[1] M. Abdalla, M. Bellare, and P. Rogaway. The Oracle Diffie-Hellman Assumptions and an Analysis of DHIES. In <em>Topics in Cryptology - CT-RSA 2001</em>, volume 2020 of <em>LNCS</em>, pages 143–158, Berlin, 2001. Springer-Verlag. See full paper available at www-cse.ucsd.edu/users/mihir.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li><p class="text-gray-300">[2] M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing efficient protocols. In Proc. 1-st ACM Conf. on Comp. and Comm. Security, pages 62–73, New York, November 1993. ACM.</p></li>
      <li><p class="text-gray-300">[3] D. Boneh and M. Franklin. Identity-Based Encryption from the Weil Pairing. In CRYPTO 2001, volume 2139 of LNCS, pages 213–229, Berlin, 2001. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[4] S. Brands. A technical overview of digital credentials, 1999. Available at http://www.xs4all.nl/∼brands/.</p></li>
      <li><p class="text-gray-300">[5] S. Brands. Rethinking Public Key Infrastructures and Digital Certificates. MIT Press, 2000.</p></li>
      <li><p class="text-gray-300">[6] J. Camenisch and M. Michels. Confirmer Signature Schemes Secure against Adaptive Adversaries. In Eurocrypt 2000, volume 1807 of LNCS, pages 243–258, Berlin, 2000. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[7] D. Chaum. Zero-Knowledge Undeniable Signatures. In Eurocrypt '90, volume 473 of LNCS, pages 458–464, Berlin, 1991. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[8] D. Chaum. Designated Confirmer Signatures. In Eurocrypt '94, volume 950 of LNCS, pages 86–91, Berlin, 1994. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[9] D. Chaum and H. van Antwerpen. Undeniable Signatures. In Crypto '89, volume 435 of LNCS, pages 212–216, Berlin, 1990. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[10] W. Diffie and M. Hellman. New Directions in Cryptography. IEEE Trans. on Information Theory, 22:644–654, 1976.</p></li>
      <li><p class="text-gray-300">[11] A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions of Identification and Signature Problems. In CRYPTO'86, volume 263 of LNCS, pages 186–194, Berlin, 1987. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[12] R. Gennaro and T. Rabin. RSA-Based Undeniable Signatures. J. of Cryptology, 13:397–416, 2000.</p></li>
      <li><p class="text-gray-300">[13] S. Goldwasser, S. Micali, and R. Rivest. A Digital Signature Scheme Secure against Adaptively Chosen Message Attacks. SIAM Journal on Computing, 17(2):281–308, 1988.</p></li>
      <li><p class="text-gray-300">[14] L.C. Guillou and J.J. Quisquater. A &quot;Paradoxical&quot; Identity-Based Signature Scheme Resulting from Zero-Knowledge. In CRYPTO '88, volume 403 of LNCS, pages 216–231, Berlin, 1990. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[15] M. Jakobsson, K. Sako, and R. Impagliazzo. Designated Verifier Proofs and Their Applications. In Eurocrypt '96, volume 1070 of LNCS, pages 143–154, Berlin, 1996. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[16] H. Krawczyk and T. Rabin. Chameleon Signatures. In NDSS 2000, 2000. Available at http://www.isoc.org/isoc/conferences/ndss/2000/proceedings/.</p></li>
      <li><p class="text-gray-300">[17] M. Michels and M. Stadler. Generic Constructions for Secure and Efficient Confirmer Signature Schemes. In Eurocrypt '98, volume 1403 of LNCS, pages 406–421, Berlin, 1998. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[18] T. Okamoto. Designated Confirmer Signatures and Public-Key Encryption are Equivalent. In Crypto '94, volume 839 of LNCS, pages 61–74, Berlin, 1994. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[19] T. Okamoto and D. Pointcheval. The Gap-Problems: A New Class of Problems for the Security of Cryptographic Schemes. In PKC2001, volume 1992 of LNCS, pages 104–118, Berlin, 2000. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[20] D. Pointcheval and J. Stern. Security Arguments for Digital Signatures and Blind Signatures. <em>J. of Cryptology</em>, 13(3):361–396, 2000.</p></li>
      <li><p class="text-gray-300">[21] R. Rivest, A. Shamir, and Y. Tauman. How to Leak a Secret. In <em>Asiacrypt 2001</em>, volume 2248 of <em>LNCS</em>, pages 552–565, Berlin, 2001. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[22] R. L. Rivest, A. Shamir, and L. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. <em>Communications of the ACM</em>, 21(2):120–128, 1978.</p></li>
      <li><p class="text-gray-300">[23] RSA Laboratories. PKCS$1 v. 2.1: RSA Cryptography Standard, 2002.</p></li>
      <li><p class="text-gray-300">[24] C. P. Schnorr. Efficient Identification and Signatures for Smart Cards. In <em>CRYPTO'89</em>, volume 435 of <em>LNCS</em>, pages 239–251, Berlin, 1990. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[25] A. Shamir and Y. Tauman. Improved Online/Offline Signature Schemes. In <em>CRYPTO 2001</em>, volume 2139 of <em>LNCS</em>, pages 355–367, Berlin, 2001. Springer-Verlag.</p></li>
      <li><p class="text-gray-300">[26] R. Steinfeld, L. Bull, H. Wang, and J. Pieprzyk. Universal Designated-Verifier Signatures. In <em>Asiacrypt 2003</em>, volume 2894 of <em>LNCS</em>, pages 523–542, Berlin, 2003. Springer-Verlag. Full version available at http://www.comp.mq.edu.au/~rons.</p></li>
      <li><p class="text-gray-300">[27] R. Steinfeld, L. Bull, and Y. Zheng. Content Extraction Signatures. In <em>International Conference on Information Security and Cryptology ICISC 2001</em>, volume 2288 of <em>LNCS</em>, pages 285–304, Berlin, 2001. Springer-Verlag.</p></li>
    </ul>

    <p class="text-gray-300">We show how to use any efficient forging attacker A for breaking scheme  <span class="math">SchUDVS_1</span>  in the sense of ST-UF-DV with non-negligible probability to construct an efficient attacker  <span class="math">A_S</span>  for breaking the Strong Diffie-Hellman problem (SDH) with non-negligible probability, thus contradicting the assumed hardness of SDH. More precisely, we show that:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{S}},\\mathsf{SDH}}(k) \\ge (1/4(q_H + q_v)) \\cdot \\left[ \\mathbf{Succ}_{\\mathsf{A},\\mathsf{SchUDVS}_1}^{\\mathsf{ST-UF-DV}}(k) - \\frac{q_s(q_H + q_s + q_v) + 2(q_H + q_v) + 1}{2^{l_H}} \\right]^2, \\quad (4)</span>$</p>

    <p class="text-gray-300">where  <span class="math">A_S</span>  has the run-time t[S] and makes q[S] DDH queries, as defined in the theorem statement. The theorem then follows immediately from (4), by taking maximums over all attackers  <span class="math">A_S</span>  with the given running time. It remains to construct the attacker  <span class="math">A_S</span>  and show that it satisfies (4).</p>

    <p class="text-gray-300">Overview. We convert A into  <span class="math">A_S</span>  in two stages. In the first stage, we modify the S oracle simulator  <span class="math">F^S</span>  so that it does not use  <span class="math">x_1</span>  (by outputting a random pair (r, s) as the signature for message m and modifying the H oracle to answer consistently r whenever  <span class="math">(m, g^s \\cdot y_1^{-r})</span>  is later queried to H). We also modify the VDV oracle simulator  <span class="math">F^{VDV}</span>  such that it does not use  <span class="math">x_3</span>  directly but only indirectly via queries to a  <span class="math">DDH_{x_3}(.,.)</span>  oracle. At the end of the first stage we obtain an efficient algorithm for the following primitive problem  <span class="math">P[q_o, q_d]</span> :</p>

    <ol class="list-decimal list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>Problem  <span class="math">P[q_o, q_d]</span> : Given  <span class="math">(D_G, g) = \\mathsf{GC}(k)</span> ,  <span class="math">y_1 = g^{x_1}</span>  and  <span class="math">y_3 = g^{x_3}</span>  for uniformly random  <span class="math">x_1, x_3 \\in \\mathbb{Z}_q</span> ,  <span class="math">q_o</span>  distinct queries  <span class="math">(u[1], \\ldots, u[q_o])</span>  to oracle O(.) (where r[i] = O(u[i]) is a uniformly random integer in  <span class="math">\\mathbb{Z}_{2^l H}</span> ), and  <span class="math">q_d</span>  queries to restricted DDH oracle  <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span> , (where  <span class="math">\\mathsf{DDH}_{x_1}(w,K)</span> ,</li>
    </ol>

    <p class="text-gray-300">returns 1 if  <span class="math">K = w^{x_1}</span>  and 0 else), compute  <span class="math">i^* \\in \\{1, ..., q_o\\}</span>  and  <span class="math">K^* \\in G</span>  such that  <span class="math">K^* = (u[i^*] \\cdot y_1^{r[i^*]})^{x_3}</span> .</p>

    <p class="text-gray-300">In the second stage we show how to convert any efficient algorithm for primitive problem  <span class="math">P[q_o, q_d]</span>  into an efficient algorithm for SDH. This reduction is an application of the forking technique [11, 20], which involves running the attacker for  <span class="math">P[q_o, q_d]</span>  twice, answering its  <span class="math">i^*</span> th O(.) query differently in the two runs to obtain two distinct solutions  <span class="math">(i^*, K_1^*)</span>  (with  <span class="math">K_1^* = (u[i^*] \\cdot y_1^{r_1[i^*]})^{x_3}</span> ) and  <span class="math">(i^*, K_2^*)</span>  (with  <span class="math">K_2^* = (u[i^*] \\cdot y_1^{r_2[i^*]})^{x_3}</span> ) for the  <span class="math">P[q_o, q_d]</span>  instance, from which the solution  <span class="math">g^{x_1x_3}</span>  to the SDH instance can be recovered.</p>

    <p class="text-gray-300">We begin with the details of the 'Stage 1' reduction.</p>

    <p class="text-gray-300"><span class="math">\\begin{array}{l} \\textbf{Lemma A.1 (Stage 1).} \\ \\ Any \\ ST\\text{-}UF\\text{-}DV \\ attacker \\ A \\ on \\ scheme \\ SchUDVS_1 \\ with \\ resources \\ (t,q_s,q_v,q_H) \\\\ and \\ success \\ probability \\ \\textbf{Succ}_{\\mathsf{A,SchUDVS}_1}^{\\mathrm{ST-}UF\\text{-}DV}(k) \\ can \\ be \\ converted \\ into \\ an \\ algorithm \\ \\mathsf{A_P} \\ for \\ problem \\ P[q_o,q_d] \\\\ with \\ run\\text{-}time \\ t[P] = t + (q_s + q_v + q_H + 1)(T_S + O(l_H)) + O(q_sl_qT_g) \\ (where \\ T_S = O(log_2(q_s + q_v + q_H)(\\ell + l_G))), \\ q_o = q_H + q_v \\ O \\ oracle \\ queries, \\ q_d = q_v \\ \\mathsf{DDH} \\ oracle \\ queries, \\ and \\ success \\ probability \\\\ \\mathbf{Succ}_{\\mathsf{A_P},P[q_o,q_d]}(k) \\geq \\mathbf{Succ}_{\\mathsf{A,SchUDVS}_1}^{\\mathrm{ST-}UF\\text{-}DV}(k) - [q_s(q_s + q_v + q_H) + 1]/2^{l_H}. \\end{array}</span></p>

    <p class="text-gray-300"><em>Proof. Modified Attacker</em>  <span class="math">\\widehat{A}</span> . We first define a modified attacker  <span class="math">\\widehat{A}</span>  which is obtained from the original attacker A in order to satisfy two properties (which may not be satisfied by A): (1) Each H-query  <span class="math">(m_i, u_i)</span>  of  <span class="math">\\widehat{\\mathsf{A}}</span>  is 'new' (i.e. unequal any earlier query  <span class="math">(m_i, u_i)</span>  to H(.), made either directly by  <span class="math">\\widehat{\\mathsf{A}}</span>  or indirectly by S), and (2) For each VDV-query  <span class="math">(y_{1,i}, m_i, u_i, K_i)</span>  of  <span class="math">\\widehat{A}</span> , the pair  <span class="math">(m_i, u_i)</span>  is not new (i.e. it is equal to an earlier query  <span class="math">(m_j, u_j)</span>  to H(.) by either  <span class="math">\\widehat{\\mathsf{A}}</span>  or  <span class="math">\\mathsf{S}</span>  oracle). We obtain  <span class="math">\\widehat{\\mathsf{A}}</span>  as follows:  <span class="math">\\widehat{\\mathsf{A}}</span> runs A and stores in a sorted table T the queries  <span class="math">(m_i, u_i)</span>  and corresponding responses  <span class="math">r_i = H(m_i, u_i)</span> to A's and S oracle's H-queries. When A makes an S-query, A forwards it to the S-oracle and returns the signature  <span class="math">(r_i, s_i)</span>  to A, adding query  <span class="math">(m_i, u_i)</span>  and response  <span class="math">r_i</span>  to table T, where  <span class="math">u_i = g^{s_i} \\cdot y_1^{-r_i}</span> . When A makes a H query  <span class="math">(m_i, u_i)</span> ,  <span class="math">\\widehat{A}</span>  first searches table T for a matching earlier query  <span class="math">(m_i, u_i)</span>  and if found, answers  <span class="math">r_i = r_i</span>  from the table without querying H(.) (if not found,  <span class="math">\\widehat{A}</span>  queries  <span class="math">(m_i, u_i)</span>  to Hanswers response  <span class="math">r_i</span>  to A, adding  <span class="math">(m_i, u_i)</span>  and response  <span class="math">r_i</span>  to T). This modification implies property (1). Similarly, when A makes a VDV oracle query  <span class="math">(y_{1,i}, m_i, u_i, K_i)</span> ,  <span class="math">\\hat{A}</span>  searches T for matching earlier query  <span class="math">(m_i, u_i) = (m_i, u_i)</span>  and if not found, it queries  <span class="math">(m_i, u_i)</span>  to H(.) and updates T. Then  <span class="math">\\widehat{A}</span>  forwards  <span class="math">(y_{1,i}, m_i, u_i, K_i)</span>  to VDV oracle and returns response to A. This modification implies property (2). It is clear that  <span class="math">\\widehat{A}</span>  has the same success probability as A (Succ <span class="math">_{\\widehat{A},SchUDVS_1}^{ST-UF-DV} = Succ_{A,Sch_UDVS_1}^{ST-UF-DV}</span> ) and also the same number of S- and VDV- queries  <span class="math">(q_s[\\widehat{\\mathsf{A}}] = q_s \\text{ and } q_v[\\widehat{\\mathsf{A}}] = q_v)</span> . However, the H-query bound of  <span class="math">\\widehat{\\mathsf{A}}</span> is larger due to modification (2)  <span class="math">(q_H[\\widehat{A}] = q_H + q_v)</span> , and the running-time of  <span class="math">\\widehat{A}</span>  is also larger due to modifications (1) and (2)  <span class="math">(t[A] = t + O((q_v + q_H) \\log_2(q_s + q_v + q_H) \\cdot (\\ell + l_G)) + O(l_q T_q q_s))</span> , assuming a binary search by  <span class="math">\\widehat{A}</span>  through the sorted list of past H-queries.</p>

    <p class="text-gray-300">We now consider several attack games, starting at the original attack  <span class="math">\\mathsf{Game}_0</span>  and modifying  <span class="math">\\widehat{\\mathsf{A}}</span> 's view simulators to obtain the game  <span class="math">\\mathsf{Game}_3</span>  where  <span class="math">\\widehat{\\mathsf{A}}</span>  and its view simulators constitute the desired algorithm  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  against  <span class="math">P[q_o, q_d]</span> .</p>

    <p class="text-gray-300"><strong>Game&lt;sub&gt;0&lt;/sub&gt;</strong>. This is the original forgery attack game UF-DV, where the view simulator  <span class="math">F = (F^S, F^H)</span>  for  <span class="math">\\widehat{A}</span>  consists of the actual scheme's S and H oracles respectively. The game  <span class="math">Game_0</span>  runs as follows on outcome I (we use bold letters to denote random variables which constitute the view of  <span class="math">\\widehat{A}</span> , i.e. the inputs, oracle queries and responses of  <span class="math">\\widehat{A}</span> , and output of  <span class="math">\\widehat{A}</span> ).</p>

    <p class="text-gray-300">Setup. We run  <span class="math">\\widehat{\\mathbf{A}}</span>  on input  <span class="math">\\mathbf{I}_A = (\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span> , where  <span class="math">(\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}) = \\mathsf{GC}(k), \\mathbf{y}_1 = \\mathbf{g}^{x_1}</span>  for uniformly random  <span class="math">x_1 \\in \\mathbb{Z}_q</span>  and  <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span>  for uniformly random  <span class="math">x_3 \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">Oracle Queries. When  <span class="math">\\widehat{A}</span>  makes its ith oracle query  <span class="math">\\mathbf{Q}_i</span> , F responds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) S-Query simulator  <span class="math">\\mathsf{F}^\\mathsf{S}</span> . If  <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span>  is an S-Query,  <span class="math">\\mathsf{F}^\\mathsf{S}</span>  responds with  <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span>  computed as follows:  <span class="math">\\mathbf{s}_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span>   <span class="math">\\mathbf{s}_i = k_i + \\mathbf{r}_i \\cdot x_1</span>  where  <span class="math">u_i = \\mathbf{g}^{k_i}</span>  for uniformly random  <span class="math">k_i \\in \\mathbb{Z}_q</span></li>
      <li>(2) <em>H</em>-Query simulator  <span class="math">F^H</span> . If  <span class="math">\\mathbf{Q}_i = (\\mathbf{m}_i, \\mathbf{u}_i)</span>  is a <em>H</em>-Query,  <span class="math">F^H</span>  responds with  <span class="math">\\mathbf{R}_i = \\mathbf{r}_i</span>  defined as follows:  <span class="math">\\mathbf{r}_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span></li>
      <li>(3) VDV-Query simulator  <span class="math">F^{V}</span> . If  <span class="math">\\mathbf{Q}_{i} = (\\mathbf{y}_{1,i}, \\mathbf{m}_{i}, (\\mathbf{u}_{i}, \\mathbf{K}_{i}))</span>  is a VDV-Query,  <span class="math">F^{V}</span>  responds with  <span class="math">\\mathbf{R}_{i} = \\mathbf{d}_{i} \\in \\{Acc, Rej\\}</span>  defined as follows:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{d}_i = Acc</span>$
if and only if  <span class="math">\\mathbf{K}_i = (\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i})^{x_3}</span>
where  <span class="math">r_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span></p>

    <p class="text-gray-300">Output. Eventually  <span class="math">\\widehat{A}</span>  outputs a forgery message/DV-sig. pair  <span class="math">(\\mathbf{m}^*, (\\mathbf{u}^*, \\mathbf{K}^*))</span> .</p>

    <p class="text-gray-300">This completes the description of Game&lt;sub&gt;0&lt;/sub&gt;.</p>

    <p class="text-gray-300">Let  <span class="math">S_0</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that  <span class="math">\\widehat{\\mathsf{A}}</span>  breaks  <span class="math">\\mathsf{SchUDVS}_1</span>  in the sense of ST-UF-DV. By definition, this means:</p>

    <p class="text-gray-300"><span class="math">$S_0 \\Rightarrow (a) \\mathbf{K}^* = (\\mathbf{u}^* \\cdot \\mathbf{y}_1^{r^*})^{x_3} \\text{ (where } r^* = H(\\mathbf{m}^*, \\mathbf{u}^*))</span>$</p>

    <p class="text-gray-300"><span class="math">$(b) \\mathbf{m}^* \\neq \\mathbf{m}_i \\text{ for all } i \\in \\mathbf{W}^S,</span>$</p>

    <p class="text-gray-300"><span class="math">$(5)</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{W}^S</span>  denotes the set of S-query indices.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{Bad}_0</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that  <span class="math">\\widehat{\\mathsf{A}}</span>  did not make a H-query  <span class="math">(\\mathbf{m}^*, \\mathbf{u}^*)</span>  during the attack.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Bad}_0 \\ \\Rightarrow \\ (\\mathbf{m}_i, \\mathbf{u}_i) \\neq (\\mathbf{m}^*, \\mathbf{u}^*) \\text{ for all } i \\in \\mathbf{W}^H, \\tag{6}</span>$</p>

    <p class="text-gray-300">where  <span class="math">\\mathbf{W}^H</span>  denotes the set of H-query indices.</p>

    <p class="text-gray-300">Thanks to the randomness of H(.), we get:</p>

    <h4 id="sec-9" class="text-lg font-semibold mt-6">Claim A.1.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}_0 \\wedge \\mathsf{Bad}_0] \\leq 1/2^{l_H}.</span>$</p>

    <p class="text-gray-300">Proof of Claim. If  <span class="math">\\mathsf{Bad}_0</span>  occurs, we know  <span class="math">(\\mathbf{m}^*, \\mathbf{u}^*)</span>  is not queried to H by  <span class="math">\\mathsf{A}</span>  and also (by property (2) of  <span class="math">\\widehat{\\mathsf{A}}</span>  - see definition of  <span class="math">\\widehat{\\mathsf{A}}</span> ) not queried to H by  <span class="math">\\mathsf{F}^\\mathsf{V}</span> . If  <span class="math">\\mathsf{S}_0</span>  also occurs, we know from (5)(b) that  <span class="math">(\\mathbf{m}^*, \\mathbf{u}^*)</span>  is not queried to H by  <span class="math">\\mathsf{F}^\\mathsf{S}</span>  either. Hence if  <span class="math">\\mathsf{S}_0 \\wedge \\mathsf{Bad}_0</span>  occurs, then  <span class="math">(\\mathbf{m}^*, \\mathbf{u}^*)</span>  is not queried to H during the game, and therefore  <span class="math">\\widehat{\\mathsf{A}}</span> 's view (and hence its output  <span class="math">(\\mathbf{K}^*, \\mathbf{u}^*)</span> ) is independent of  <span class="math">r^* = H(\\mathbf{m}^*, \\mathbf{u}^*)</span> , which is in turn uniformly distributed in  <span class="math">\\mathbb{Z}_{2^l H}</span> . Since the mapping  <span class="math">r^* \\mapsto (\\mathbf{u}^* \\mathbf{y}_1^{r^*})^{x_3}</span>  is one-to-one over  <span class="math">\\mathbb{Z}_{2^l H}</span>  (because  <span class="math">2^{l H} &lt; q</span>  and  <span class="math">x_1</span>  and  <span class="math">x_3</span>  are non-zero elements of  <span class="math">\\mathbb{Z}_q</span> ), there is only one outcome for  <span class="math">r^*</span>  (out of  <span class="math">2^{l H}</span>  equiprobable outcomes) such that  <span class="math">(\\mathbf{u}^* \\mathbf{y}_1^{r^*})^{x_3} = \\mathbf{K}^*</span>  is satisfied. The claim follows.  <span class="math">\\square</span></p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{Bad}_0^1</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that a  <span class="math">\\mathbf{u}_i = g^{k_i}</span>  used by S-oracle in answering an S-query matches a previous  <span class="math">\\mathbf{u}_i</span>  appearing in an earlier query to H by either  <span class="math">\\widehat{\\mathsf{A}}</span>  or S-oracle:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Bad}_0^1 \\ \\Rightarrow \\ \\mathsf{There} \\ \\mathsf{exists} \\ i \\in \\mathbf{W}^S \\ \\mathsf{such} \\ \\mathsf{that} \\ \\mathbf{u}_i = \\mathbf{u}_j \\ \\mathsf{for} \\ \\mathsf{some} \\ j &lt; i.</span>$
(7)</p>

    <p class="text-gray-300">Thanks to the randomness of the  <span class="math">k_i</span> 's we get:</p>

    <h4 id="sec-10" class="text-lg font-semibold mt-6">Claim A.2.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{Bad_0^1}] \\le q_s(q_s + q_v + q_H)/2^{l_H}.</span>$</p>

    <p class="text-gray-300">Proof of Claim. For each ith S-query, there are at most  <span class="math">q_s[\\widehat{\\mathsf{A}}] + q_H[\\widehat{\\mathsf{A}}] = q_s + q_v + q_H</span>  previous  <span class="math">\\mathbf{u}_j</span> 's that  <span class="math">\\mathbf{u}_i</span>  can collide with. Since  <span class="math">\\mathbf{u}_i = g^{k_i}</span>  is uniformly distributed in G which has order q,  <span class="math">\\mathbf{u}_i</span>  has probability at most  <span class="math">(q_s + q_v + q_H)/q &lt; (q_s + q_v + q_H)/2^{l_H}</span>  to collide with a previous  <span class="math">\\mathbf{u}_j</span> . Since there are  <span class="math">q_s[\\widehat{\\mathsf{A}}] = q_s</span>  S-queries overall, the claim follows.</p>

    <p class="text-gray-300">Let  <span class="math">S_0^2</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that  <span class="math">\\mathsf{S}_0</span>  occurs but neither  <span class="math">\\mathsf{Bad}_0</span>  nor  <span class="math">\\mathsf{Bad}_0^1</span>  occur. That is:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{S}_0^2 \\Rightarrow (a) \\text{ There exists } \\mathbf{i}^* \\in \\mathbf{W}^H \\text{ such that } \\mathbf{K}^* = (\\mathbf{u}_{\\mathbf{i}^*} \\cdot \\mathbf{y}_1^{\\mathbf{r}_{\\mathbf{i}^*}})^{x_3}</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{and } (\\mathbf{m}_{\\mathbf{i}^*}, \\mathbf{u}_{\\mathbf{i}^*}) = (\\mathbf{m}^*, \\mathbf{u}^*)</span>$</p>

    <p class="text-gray-300"><span class="math">$(b) \\mathbf{m}^* \\neq \\mathbf{m}_i \\text{ for all } i \\in \\mathbf{W}^S</span>$</p>

    <p class="text-gray-300"><span class="math">$(c) \\mathbf{u}_i \\neq \\mathbf{u}_j \\text{ for all } j &lt; i \\text{ and } i \\in \\mathbf{W}^S.</span>$</p>

    <p class="text-gray-300"><span class="math">$(8)</span>$</p>

    <p class="text-gray-300">The above results immediately give:</p>

    <h4 id="sec-11" class="text-lg font-semibold mt-6">Claim A.3.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[S_0^2] \\ge \\Pr[S_0] - \\frac{q_s(q_s + q_v + q_H) + 1}{2^{l_H}}.</span>$</p>

    <p class="text-gray-300"><em>Proof of Claim.</em> We have  <span class="math">\\Pr[S_0^2] = \\Pr[S_0 \\land \\neg \\mathsf{Bad}_0 \\land \\neg \\mathsf{Bad}_0^1] \\ge \\Pr[S_0 \\land \\neg \\mathsf{Bad}_0] - \\Pr[\\mathsf{Bad}_0^1] \\ge \\Pr[\\mathsf{S_0} \\land \\neg \\mathsf{Bad}_0] - \\Pr[\\mathsf{Bad}_0^1]</span> . The claim now follows from Claims A.1 and A.2. □</p>

    <p class="text-gray-300"><strong>Game&lt;sub&gt;1&lt;/sub&gt;</strong>. In this game we modify the S-oracle simulator  <span class="math">\\mathsf{F}^\\mathsf{S}</span>  for  <span class="math">\\widehat{\\mathsf{A}}</span> . The new simulator returns signatures  <span class="math">(r_i, s_i)</span>  where  <span class="math">r_i</span>  is just a uniformly random string  <span class="math">\\rho_i</span>  in  <span class="math">\\mathbb{Z}_{2^{l_H}}</span> , without querying  <span class="math">(m_i, u_i)</span>  to H. The game  <span class="math">\\mathsf{Game}_1</span>  runs as follows.</p>

    <p class="text-gray-300">Setup. We run  <span class="math">\\widehat{\\mathsf{A}}</span>  on input  <span class="math">\\mathbf{I}_A = (\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span> , where  <span class="math">(\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}) = \\mathsf{GC}(k)</span>  and  <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span>  for uniformly random  <span class="math">x_1 \\in \\mathbb{Z}_q</span>  and  <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span>  for uniformly random  <span class="math">x_3 \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">Oracle Queries. When  <span class="math">\\widehat{A}</span>  makes its ith oracle query  <span class="math">\\mathbf{Q}_i</span> , F responds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) S-Query simulator F&lt;sup&gt;S&lt;/sup&gt;. If  <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span>  is an S-Query, F&lt;sup&gt;S&lt;/sup&gt; responds with  <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span>  computed as follows:  <span class="math">\\mathbf{r}_i = \\rho_i</span>  for uniformly random  <span class="math">\\rho_i \\in \\mathbb{Z}_{2^l H}</span>   <span class="math">\\mathbf{s}_i = k_i + \\mathbf{r}_i \\cdot x_1</span>  where  <span class="math">u_i = \\mathbf{g}^{k_i}</span>  for uniformly random  <span class="math">k_i \\in \\mathbb{Z}_q</span></li>
      <li>(2) <em>H</em>-Query simulator F&lt;sup&gt;H&lt;/sup&gt;. As in Game&lt;sub&gt;0&lt;/sub&gt;.</li>
      <li>(3) VDV-Query simulator F&lt;sup&gt;V&lt;/sup&gt;. As in Game&lt;sub&gt;0&lt;/sub&gt;.</li>
    </ul>

    <p class="text-gray-300">Output. Eventually  <span class="math">\\widehat{\\mathsf{A}}</span>  outputs a forgery message/DV-sig. pair  <span class="math">(\\mathbf{m}^*, (\\mathbf{u}^*, \\mathbf{K}^*))</span> .</p>

    <p class="text-gray-300">This completes the description of  <span class="math">\\mathsf{Game}_1</span> . Let  <span class="math">\\mathsf{S}^2_1</span>  denote the event in  <span class="math">\\mathsf{Game}_1</span>  corresponding to  <span class="math">\\mathsf{S}^2_0</span>  in  <span class="math">\\mathsf{Game}_0</span>  (i.e.  <span class="math">\\mathsf{S}^2_1</span>  is also defined by (8) over the view of  <span class="math">\\widehat{\\mathsf{A}}</span> ).</p>

    <h4 id="sec-12" class="text-lg font-semibold mt-6">Claim A.4.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[S_1^2] \\geq \\Pr[S_0^2].</span>$</p>

    <p class="text-gray-300">Proof of Claim. For outcomes in  <span class="math">S_0^2</span>  in  <span class="math">\\mathsf{Game}_0</span> , the  <span class="math">\\mathbf{u}_i</span>  for each ith S-query is 'new' and hence by randomness of H(.) the responses  <span class="math">\\mathbf{r}_i = H(\\mathbf{m}_i, \\mathbf{u}_i)</span>  are uniform and independent in  <span class="math">\\mathbb{Z}_{2^l H}</span> . Furthermore, H(.) is never queried again at  <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span>  during the game. Thus for each outcome in  <span class="math">S_0^2</span>  in  <span class="math">\\mathsf{Game}_0</span>  there is a corresponding outcome in  <span class="math">S_1^2</span>  in  <span class="math">\\mathsf{Game}_1</span> , where the outcomes for  <span class="math">\\rho_i</span>  in  <span class="math">\\mathsf{Game}_1</span>  coincide with outcomes for  <span class="math">H(\\mathbf{m}_i, \\mathbf{u}_i)</span>  in  <span class="math">\\mathsf{Game}_0</span>  for all  <span class="math">i \\in \\mathbf{W}^S</span> , maintaining the view of A unchanged. Since the  <span class="math">\\rho_i</span> 's are uniform and independent in  <span class="math">\\mathbb{Z}_{2^l H}</span>  this outcome has the same probability in  <span class="math">\\mathsf{Game}_1</span>  as the original outcome in  <span class="math">\\mathsf{Game}_0</span> . The claim follows.</p>

    <p class="text-gray-300"><strong>Game&lt;sub&gt;2&lt;/sub&gt;</strong>. In this game we further modify the S-oracle simulator  <span class="math">\\mathsf{F}^\\mathsf{S}</span>  for  <span class="math">\\widehat{\\mathsf{A}}</span> . The new simulator returns signatures  <span class="math">(r_i, s_i)</span>  where  <span class="math">s_i</span>  set equal to a uniformly random element  <span class="math">\\zeta_i</span>  in  <span class="math">\\mathbb{Z}_q</span> , thus eliminating the use of  <span class="math">x_1</span>  by  <span class="math">\\mathsf{F}^\\mathsf{S}</span> .</p>

    <p class="text-gray-300">Setup. We run  <span class="math">\\widehat{\\mathsf{A}}</span>  on input  <span class="math">\\mathbf{I}_A = (\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span> , where  <span class="math">(\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}) = \\mathsf{GC}(k)</span>  and  <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span>  for uniformly random  <span class="math">x_1 \\in \\mathbb{Z}_q</span>  and  <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span>  for uniformly random  <span class="math">x_3 \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">Oracle Queries. When  <span class="math">\\widehat{A}</span>  makes its ith oracle query  <span class="math">\\mathbf{Q}_i</span> , F responds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) S-Query simulator  <span class="math">\\mathsf{F}^\\mathsf{S}</span> . If  <span class="math">\\mathbf{Q}_i = \\mathbf{m}_i</span>  is an S-Query,  <span class="math">\\mathsf{F}^\\mathsf{S}</span>  responds with  <span class="math">\\mathbf{R}_i = (\\mathbf{r}_i, \\mathbf{s}_i)</span>  computed as follows:  <span class="math">\\mathbf{r}_i = \\rho_i</span>  for uniformly random  <span class="math">\\rho_i \\in \\mathbb{Z}_{2^{l_H}}</span>   <span class="math">\\mathbf{s}_i = \\zeta_i</span>  for uniformly random  <span class="math">\\zeta_i \\in \\mathbb{Z}_q</span></li>
      <li>(2) H-Query simulator FH. As in Game&lt;sub&gt;0&lt;/sub&gt;.</li>
      <li>(3) VDV-Query simulator FV. As in Game&lt;sub&gt;0&lt;/sub&gt;.</li>
    </ul>

    <p class="text-gray-300">Output. Eventually  <span class="math">\\widehat{A}</span>  outputs a forgery message/DV-sig. pair  <span class="math">(\\mathbf{m}^*, (\\mathbf{u}^*, \\mathbf{K}^*))</span> .</p>

    <p class="text-gray-300">This completes the description of  <span class="math">\\mathsf{Game}_2</span> . Let  <span class="math">\\mathsf{S}_2^2</span>  denote the event in  <span class="math">\\mathsf{Game}_2</span>  corresponding to  <span class="math">\\mathsf{S}_1^2</span>  in  <span class="math">\\mathsf{Game}_1</span>  (i.e.  <span class="math">\\mathsf{S}_2^2</span>  is also defined by (8) over the view of  <span class="math">\\widehat{\\mathsf{A}}</span> ).</p>

    <h4 id="sec-13" class="text-lg font-semibold mt-6">Claim A.5.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}_2^2] \\ge \\Pr[\\mathsf{S}_1^2].</span>$</p>

    <p class="text-gray-300">Proof of Claim. In  <span class="math">\\mathbf{Game_1}</span> , the  <span class="math">\\mathbf{s}_i = k_i + \\mathbf{r}_i \\cdot x_1 \\mod q</span>  signature portions are uniformly random in  <span class="math">\\mathbb{Z}_q</span>  and independent of  <span class="math">\\mathbf{r}_i</span> , thanks to the uniformly random and independent choice of  <span class="math">k_i \\in \\mathbb{Z}_q</span>  and the fact that mapping  <span class="math">k_i \\mapsto k_i + \\mathbf{r}_i \\cdot x_1 \\mod q</span>  is a permutation of  <span class="math">\\mathbb{Z}_q</span> . Hence, in  <span class="math">\\mathbf{Game_2}</span> , setting  <span class="math">\\mathbf{s}_i = \\zeta_i</span>  for uniformly random and independent  <span class="math">\\zeta_i \\in \\mathbb{Z}_q</span>  leaves the view of  <span class="math">\\widehat{\\mathbf{A}}</span>  unchanged and immediately gives the claimed result.</p>

    <p class="text-gray-300"><strong>Game&lt;sub&gt;3&lt;/sub&gt;</strong>. In this game we modify the VDV-oracle simulator  <span class="math">\\mathsf{F}^\\mathsf{V}</span>  for  <span class="math">\\widehat{\\mathsf{A}}</span>  to use  <span class="math">x_3</span>  only indirectly via calls to a  <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span>  oracle. We also eliminate calls to H(.) by  <span class="math">\\mathsf{F}^\\mathsf{V}</span> , using the fact that  <span class="math">\\widehat{\\mathsf{A}}</span>  never makes 'new'  <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span>  queries to  <span class="math">\\mathsf{VDV}</span> .</p>

    <p class="text-gray-300">Setup. We run  <span class="math">\\widehat{\\mathsf{A}}</span>  on input  <span class="math">\\mathbf{I}_A = (\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}, \\mathbf{y}_1, \\mathbf{y}_3)</span> , where  <span class="math">(\\mathbf{D}_{\\mathbf{G}}, \\mathbf{g}) = \\mathsf{GC}(k)</span>  and  <span class="math">\\mathbf{y}_1 = \\mathbf{g}^{x_1}</span>  for uniformly random  <span class="math">x_1 \\in \\mathbb{Z}_q</span>  and  <span class="math">\\mathbf{y}_3 = \\mathbf{g}^{x_3}</span>  for uniformly random  <span class="math">x_3 \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">Oracle Queries. When  <span class="math">\\widehat{A}</span>  makes its ith oracle query  <span class="math">\\mathbf{Q}_i</span> , F responds as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) S-Query simulator FS. As in Game&lt;sub&gt;2&lt;/sub&gt;.</li>
      <li>(2) <em>H</em>-Query simulator F&lt;sup&gt;H&lt;/sup&gt;. As in Game&lt;sub&gt;0&lt;/sub&gt;.</li>
      <li>(3) VDV-Query simulator  <span class="math">F^V</span> . If  <span class="math">\\mathbf{Q}_i = (\\mathbf{y}_{1,i}, \\mathbf{m}_i, (\\mathbf{u}_i, \\mathbf{K}_i))</span>  is a VDV-Query,  <span class="math">F^V</span>  responds with  <span class="math">\\mathbf{R}_i = \\mathbf{d}_i \\in \\{Acc, Rej\\}</span>  defined as follows:</li>
    </ul>

    <p class="text-gray-300"><span class="math">$\\mathbf{d}_i = Acc</span>$
if and only if  <span class="math">\\mathsf{DDH}_{x_3}(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i}, \\mathbf{K}_i) = 1</span>
where  <span class="math">r_i = \\mathbf{r}_j</span>  and  <span class="math">j \\in \\mathbf{W}^S \\vee \\mathbf{W}^H</span>  is the index
of a previous matching query  <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i) = (\\mathbf{m}_i, \\mathbf{u}_i)</span></p>

    <p class="text-gray-300">Output. Eventually  <span class="math">\\widehat{A}</span>  outputs a forgery message/DV-sig. pair  <span class="math">(\\mathbf{m}^*, (\\mathbf{u}^*, \\mathbf{K}^*))</span> .</p>

    <p class="text-gray-300">This completes the description of  <span class="math">\\mathsf{Game}_3</span> . Let  <span class="math">\\mathsf{S}_3^2</span>  denote the event in  <span class="math">\\mathsf{Game}_3</span>  corresponding to  <span class="math">\\mathsf{S}_2^2</span>  in  <span class="math">\\mathsf{Game}_2</span>  (i.e.  <span class="math">\\mathsf{S}_3^2</span>  is also defined by (8) over the view of  <span class="math">\\widehat{\\mathsf{A}}</span> ).</p>

    <h4 id="sec-14" class="text-lg font-semibold mt-6">Claim A.6.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}_3^2] \\geq \\Pr[\\mathsf{S}_2^2].</span>$</p>

    <p class="text-gray-300"><em>Proof of Claim.</em> In  <span class="math">\\mathsf{Game}_2</span> , the test by  <span class="math">\\mathsf{F}^\\mathsf{V}</span>  if  <span class="math">(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i})^{x_3} = \\mathbf{K}_i</span>  or not, is equivalent to testing if  <span class="math">\\mathsf{DDH}_{x_3}(\\mathbf{u}_i \\cdot \\mathbf{y}_1^{r_i}, \\mathbf{K}_i) = 1</span> , as used in  <span class="math">\\mathsf{Game}_3</span> . The method of computing  <span class="math">\\mathbf{r}_i</span>  in  <span class="math">\\mathsf{Game}_3</span>  is equivalent to querying  <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span>  to H(.) because by construction of  <span class="math">\\widehat{\\mathsf{A}}</span> ,  <span class="math">(\\mathbf{m}_i, \\mathbf{u}_i)</span>  must have previously appeared in a H- or  <span class="math">\\mathsf{S}</span> - query.</p>

    <p class="text-gray-300">So in Game&lt;sub&gt;3&lt;/sub&gt;,  <span class="math">\\widehat{\\mathbf{A}}</span>  with its view simulators constitutes an algorithm  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  for problem  <span class="math">P[q_o, q_d]</span> , which on input  <span class="math">(D_G, g, y_1 = g^{x_1}, y_3 = g^{x_3})</span> , makes  <span class="math">q_o \\stackrel{\\text{def}}{=} q_H[\\widehat{\\mathsf{A}}] = q_H + q_v</span>  distinct queries  <span class="math">\\mathbf{u}_i</span>  to a random oracle O(.) (the H(.)-queries of  <span class="math">\\mathsf{F}^\\mathsf{H}</span> ) receiving answers  <span class="math">\\mathbf{r}_i</span>  uniform in  <span class="math">\\mathbb{Z}_{2^l H}</span> , and  <span class="math">q_d \\stackrel{\\text{def}}{=} q_v[\\widehat{\\mathsf{A}}] = q_v</span>  queries to the  <span class="math">\\mathsf{DDH}_{x_3}(.,.)</span>  oracle (the DDH queries of  <span class="math">\\mathsf{F}^\\mathsf{V}</span> ), and outputs  <span class="math">(\\mathbf{i}^*, \\mathbf{K}^*)</span>  such that  <span class="math">\\mathbf{K}^* = (\\mathbf{u}_{\\mathbf{i}^*} \\cdot \\mathbf{y}_1^{\\mathbf{r}_{\\mathbf{i}^*}})^{x_3}</span>  with probability at least  <span class="math">\\Pr[\\mathsf{S}_3^2] \\geq \\mathbf{Succ}_{\\mathsf{A},\\mathsf{SchUDVS}_1}^{\\mathsf{ST}-\\mathsf{UF}-\\mathsf{DV}}(k) - [q_s(q_s+q_v+q_H)+1]/2^{l_H}</span> , using claims  <span class="math">\\mathsf{A}.1</span>  to  <span class="math">\\mathsf{A}.6</span> . The run-time of  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  is the sum of the run-time  <span class="math">t[\\widehat{\\mathsf{A}}] = t + O((q_v+q_H)\\log_2(q_s+q_v+q_H)\\cdot(\\ell+l_G)) + O(l_qT_gq_s)</span>  of  <span class="math">\\widehat{\\mathsf{A}}</span> , the run-time  <span class="math">t[\\mathsf{F}^\\mathsf{V}] = O((q_v+q_H)\\log_2(q_s+q_v+q_H)\\cdot(\\ell+l_G)) + O(l_qT_gq_s)</span>  of  <span class="math">\\mathsf{F}^\\mathsf{V}</span>  (assuming a binary search is used as for obtaining  <span class="math">\\widehat{\\mathsf{A}}</span>  from  <span class="math">\\mathsf{A}</span> ), and the time  <span class="math">O(\\log_2(q_s+q_v+q_H)\\cdot(\\ell+l_G))</span>  for  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  to search for  <span class="math">\\mathbf{i}^*</span>  such that  <span class="math">(\\mathbf{m}^*, \\mathbf{u}^*) = (\\mathbf{m}_{\\mathbf{i}^*}, \\mathbf{u}_{\\mathbf{i}^*})</span> . This establishes the lemma.</p>

    <p class="text-gray-300">We will need the following lemma [20] in the analysis of the forking technique for the 'Stage 2' reduction. A proof can be found in [20] but we provide one here also for completeness.</p>

    <p class="text-gray-300"><strong>Lemma A.2 (Splitting Lemma[20]).</strong> Let a and b denote independent random variables over finite sets A and B, respectively, with probability mass functions  <span class="math">P_A(.)</span>  and  <span class="math">P_B(.)</span> , respectively. Let  <span class="math">S \\subseteq A \\times B</span>  be a set with  <span class="math">\\Pr[S] \\ge \\epsilon</span> . For each  <span class="math">a \\in A</span> , let  <span class="math">S(a) \\subseteq B</span>  denote the set of  <span class="math">b \\in B</span>  such that  <span class="math">(a,b) \\in S</span> . Then there exists a 'good' subset G of S such that:</p>

    <p class="text-gray-300"><span class="math">$\\Pr[G] \\ge \\epsilon/2</span>$</p>

    <p class="text-gray-300">and, for all  <span class="math">(a,b) \\in G</span> ,</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S(a)] \\ge \\epsilon/2.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> Let us define the good set G to be the set of all  <span class="math">(a,b) \\in S</span>  such that  <span class="math">\\Pr[S(a)] \\ge \\epsilon/2</span> . Then it is enough to show that  <span class="math">\\Pr[G] \\ge \\epsilon/2</span> .</p>

    <p class="text-gray-300">Suppose, towards a contradiction, that  <span class="math">\\Pr[G] &lt; \\epsilon/2</span> . Then  <span class="math">\\Pr[S] = \\Pr[G] + \\Pr[S \\land \\neg G] &lt; \\epsilon/2 + \\Pr[S \\land \\neg G]</span> . But  <span class="math">(a,b) \\in S \\land \\neg G</span>  means that  <span class="math">a \\in W_A</span> , where  <span class="math">W_A \\subseteq A</span>  is the set of  <span class="math">a \\in A</span>  such that  <span class="math">\\Pr[S(a)] &lt; \\epsilon/2</span> . So  <span class="math">\\Pr[S \\land \\neg G] = \\sum_{a \\in W_A} \\sum_{b \\in S(a)} P_A(a) P_B(b) = \\sum_{a \\in W_A} P_A(a) \\cdot \\Pr[S(a)] &lt; \\epsilon/2</span>  since  <span class="math">\\sum_{b \\in S(a)} P_B(b) = \\Pr[S(a)] &lt; \\epsilon/2</span>  for all  <span class="math">a \\in W_A</span> . It follows that  <span class="math">\\Pr[S] &lt; \\epsilon/2 + \\epsilon/2 = \\epsilon</span> , a contradiction. This shows that  <span class="math">\\Pr[G] \\ge \\epsilon/2</span> , which completes the proof.</p>

    <p class="text-gray-300">We will also use the following inequality.</p>

    <p class="text-gray-300"><strong>Lemma A.3.</strong> Let  <span class="math">p = \\sum_{j=1}^{q} p_j</span>  for some q real numbers  <span class="math">p_1, \\ldots, p_q</span>  and let  <span class="math">\\delta &gt; 0</span>  be given. If  <span class="math">p \\geq q \\cdot \\delta</span>  then the following inequality holds:</p>

    <p class="text-gray-300"><span class="math">$\\sum_{j=1}^{q} p_j \\cdot (p_j - \\delta) \\ge (1/q) \\cdot (p - q \\cdot \\delta)^2.</span>$</p>

    <p class="text-gray-300"><em>Proof.</em> We have  <span class="math">\\sum_{j=1}^q p_j \\cdot (p_j - \\delta) = \\sum_{j=1}^q p_j^2 - p \\cdot \\delta</span> . Using the Cauchy-Schwartz inequality we have  <span class="math">\\sum_{j=1}^q p_j^2 \\ge (1/q) \\cdot (\\sum_{j=1}^q p_j)^2 = (1/q) \\cdot p^2</span> , so  <span class="math">\\sum_{j=1}^q p_j \\cdot (p_j - \\delta) \\ge (1/q)(p^2 - q \\cdot \\delta \\cdot p)</span> . But from the</p>

    <p class="text-gray-300">assumption that  <span class="math">p \\ge q \\cdot \\delta</span> , we have  <span class="math">(q \\cdot \\delta)p \\ge (q \\cdot \\delta)^2</span>  and hence  <span class="math">p^2 - q \\cdot \\delta \\cdot p \\ge p^2 - 2(q \\cdot \\delta)p + (q \\cdot \\delta)^2 = (p - q \\cdot \\delta)^2</span> , which gives the claimed inequality.</p>

    <p class="text-gray-300"><strong>Lemma A.4 (Stage 2).</strong> Any algorithm  <span class="math">A_P</span>  for problem  <span class="math">P[q_o, q_d]</span>  with run-time t[P] and success probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A}_P, P[q_o, q_d]}(k) \\geq 2q_o/2^{l_H}</span>  can be converted into an algorithm  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  for SDH with run-time  <span class="math">t[S] = 2t[P] + O(l_q^2 + l_q T_g)</span>  which makes  <span class="math">q[S] = 2q_d</span>  DDH queries, and has success probability  <span class="math">\\mathbf{Succ}_{\\mathsf{A}_\\mathsf{S},\\mathsf{SDH}}(k) \\geq (1/q_o) \\cdot [\\mathbf{Succ}_{\\mathsf{A}_\\mathsf{P},P[q_o,q_d]}(k)/2 - q_o/2^{l_H}]^2</span> . Here  <span class="math">T_g</span>  denotes the time to perform a group operation in G.</p>

    <p class="text-gray-300"><em>Proof.</em> Given SDH input instance  <span class="math">(D_G, g, y_1 = g^{x_1}, y_2 = g^{x_2})</span> , our SDH algorithm A&lt;sub&gt;S&lt;/sub&gt; works as follows (we assume without loss of generality that A&lt;sub&gt;S&lt;/sub&gt;'s DDH oracle is DDH&lt;sub&gt;x2&lt;/sub&gt;(.,.)).</p>

    <p class="text-gray-300">Setup. As first sets up two random vectors  <span class="math">\\overrightarrow{r} = (r[1], \\ldots, r[q_o])</span>  and  <span class="math">\\overrightarrow{\\hat{r}} = (\\widehat{r}[1], \\ldots, \\widehat{r}[q_o])</span>  with r[i]'s and  <span class="math">\\widehat{r}[i]</span> 's chosen uniformly and independently at random from  <span class="math">\\mathbb{Z}_{2^{l_H}}</span>  (these vectors will be used to answer  <span class="math">A_P</span> 's O(.) queries).</p>

    <p class="text-gray-300">First Run.  <span class="math">A_S</span>  runs  <span class="math">A_P</span>  on input  <span class="math">(D_g, g, y_1, y_2; \\omega)</span> , where  <span class="math">\\omega</span>  is a random bit string used as the randomness input of  <span class="math">A_P</span>  (if  <span class="math">A_P</span>  is randomized), and answers its oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) O(.)-Query simulator  <span class="math">F^{O}</span> . When  <span class="math">A_{P}</span>  makes its ith O(.) query u[i],  <span class="math">A_{S}</span>  responds with r[i].</li>
      <li>(2)  <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span> -Query simulator  <span class="math">\\mathsf{F}^\\mathsf{D}</span> . When  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  makes its ith  <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span>  query (w[i],K[i]),  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  simply forwards the query to its  <span class="math">\\mathsf{DDH}_{x_2}(.,.)</span>  oracle and forwards the oracle's response d[i] to  <span class="math">\\mathsf{A}_\\mathsf{P}</span> .</li>
    </ul>

    <p class="text-gray-300">First Run Output. At the end of first run,  <span class="math">A_P</span>  outputs  <span class="math">(i^*, K^*)</span>  (note that if this run is successful then  <span class="math">K^* = (u[i^*] \\cdot y_1^{r[i^*]})^{x_2}</span> ).</p>

    <p class="text-gray-300">Second Run. As runs Ap again on the same input  <span class="math">(D_g, g, y_1, y_2; \\omega)</span>  as used in first run, but answers its oracle queries differently as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) O(.)-Query simulator  <span class="math">F^{O}</span> . When  <span class="math">A_{P}</span>  makes its ith O(.) query u[i],  <span class="math">A_{S}</span>  responds with r[i] for  <span class="math">i &lt; i^{*}</span>  and with  <span class="math">\\widehat{r}[i]</span>  for  <span class="math">i \\ge i^{*}</span> .</li>
      <li>(2)  <span class="math">DDH_{x_2}(.,.)</span> -Query simulator  <span class="math">F^D</span> . Answered as in first run.</li>
    </ul>

    <p class="text-gray-300">Second Run Output. At the end of second run,  <span class="math">A_P</span>  outputs  <span class="math">(\\hat{i}^*, \\widehat{K}^*)</span>  (note that if this run is successful and  <span class="math">\\hat{i}^* = i^*</span>  then  <span class="math">\\widehat{K}^* = (u[i^*] \\cdot y_1^{\\widehat{r}[i^*]})^{x_2}</span> ).</p>

    <p class="text-gray-300"><span class="math">\\mathsf{A}_\\mathsf{S}</span>  's output.  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  computes and returns an estimate  <span class="math">K \\stackrel{\\mathrm{def}}{=} (\\widehat{K^*}/K^*)^{(\\widehat{r}[i^*]-r[i^*])^{-1} \\mod q}</span>  for the SDH instance solution  <span class="math">g^{x_1x_2}</span>  (if  <span class="math">\\widehat{r}[i^*] = r[i^*]</span>  then  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  fails).</p>

    <p class="text-gray-300">This completes the description of  <span class="math">A_S</span> . The running-time of  <span class="math">A_S</span>  is twice the run-time of  <span class="math">A_P</span>  plus the time to compute K at the end, which can be done in time  <span class="math">O(l_q^2 + l_q \\cdot T_g)</span> . The number of  <span class="math">DDH_{x_2}(.,.)</span>  queries made by  <span class="math">A_S</span>  is up to twice the number of queries made by  <span class="math">A_P</span> . This establishes the claimed resources of  <span class="math">A_S</span> .</p>

    <p class="text-gray-300">We now lower bound the success probability of A&lt;sub&gt;S&lt;/sub&gt;. For  <span class="math">i \\in \\{1, \\ldots, q_o\\}</span> , we call a run of A&lt;sub&gt;P&lt;/sub&gt; <em>i</em>-successful if A&lt;sub&gt;P&lt;/sub&gt; succeeds and  <span class="math">i^* = i</span> . Note that if both first and second runs of A&lt;sub&gt;P&lt;/sub&gt; are <em>i</em>-successful for some i, then we have  <span class="math">i^* = \\widehat{i^*} = i</span> ,  <span class="math">K^* = (u[i] \\cdot y_1^{r[i]})^{x_2}</span>  and  <span class="math">\\widehat{K^*} = (u[i] \\cdot y_1^{\\widehat{r[i]}})^{x_2}</span>  (note that  <span class="math">u[1], \\ldots, u[i]</span>  are the same in both runs because the view of A&lt;sub&gt;P&lt;/sub&gt; is the same up to <em>i</em>th O(.) query response) and consequently A&lt;sub&gt;S&lt;/sub&gt;'s estimate K is correct (whenever  <span class="math">r[i] \\neq \\widehat{r}[i]</span>  so  <span class="math">(\\widehat{r}[i] - r[i])^{-1} \\mod q</span>  exists) because  <span class="math">K = [(u[i] \\cdot y_1^{r[i]})^{x_2}/(u[i] \\cdot y_1^{\\widehat{r}[i]})^{x_2}]^{(\\widehat{r}[i]-r[i])^{-1} \\mod q} = y_1^{x_2} = g^{x_1x_2}</span> .</p>

    <p class="text-gray-300">So it remains to lower bound the probability of the event  <span class="math">S^*</span>  that both runs of  <span class="math">A_P</span>  are <em>i</em>-successful for some  <span class="math">i \\in \\{1, \\ldots, q_o\\}</span>  and  <span class="math">\\hat{r}[i] \\neq r[i]</span> . To do this, we split  <span class="math">S^*</span>  into  <span class="math">q_o</span>  disjoint subevents  <span class="math">S_i^*</span>  according the</p>

    <p class="text-gray-300">value of i and bound each one. For each i, let  <span class="math">A_i</span>  denote the outcome space for the random variable  <span class="math">a_i = (D_g, g, y_1, y_2, \\omega, r[1], \\ldots, r[i-1])</span>  consisting of the view of  <span class="math">\\mathsf{A}^\\mathsf{P}</span>  up to the ith query to O(.), and let  <span class="math">B_i</span>  denote the outcome space for the independent random variable  <span class="math">b_i = (r[i], \\ldots, r[q_o])</span>  consisting of the view of  <span class="math">\\mathsf{A}^\\mathsf{P}</span>  after the ith query to O(.) (including the response r[i] to the ith query). Note that the event  <span class="math">\\mathsf{S}_i</span>  that a run of  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  is i-successful is a subset of  <span class="math">A_i \\times B_i</span>  with probability  <span class="math">p_i \\stackrel{\\text{def}}{=} \\Pr[(a_i, b_i) \\in \\mathsf{S}_i]</span> . Applying the Splitting Lemma A.2, we know that there exists a subevent  <span class="math">\\mathsf{G}_i</span>  of  <span class="math">\\mathsf{S}_i</span>  such that  <span class="math">\\Pr[(a_i, b_i) \\in \\mathsf{G}_i] \\geq p_i/2</span> , and for each  <span class="math">(a, b) \\in \\mathsf{G}_i</span> , the probability that  <span class="math">(a, \\hat{b}) \\in \\mathsf{S}_i</span>  over a random choice of  <span class="math">\\hat{b}</span>  in  <span class="math">B_i</span>  is also at least  <span class="math">p_i/2</span> . Hence, the probability that the outcome (a, b) of the first run of  <span class="math">\\mathsf{A}_\\mathsf{P}</span>  in our algorithm is in  <span class="math">\\mathsf{G}_i</span>  is at least  <span class="math">p_i/2</span> , and then for each of those outcomes, the probability over the random choice of  <span class="math">\\hat{b} = (\\hat{r}[i], \\ldots, \\hat{r}[q_o])</span>  that the second run outcome  <span class="math">(a, \\hat{b})</span>  is in  <span class="math">\\mathsf{S}_i</span>  is at least  <span class="math">p_i/2</span> . Since  <span class="math">\\hat{r}[i]</span>  is uniformly chosen in  <span class="math">\\mathsf{Z}_{2^l H}</span> , the chance that it collides with r[i] is  <span class="math">1/2^{l_H}</span> , so with probability at least  <span class="math">p_i/2 - 1/2^{l_H}</span>  over  <span class="math">\\hat{b}</span>  we know that  <span class="math">(a, \\hat{b}) \\in \\mathsf{S}_i</span>  and also  <span class="math">\\hat{r}[i] \\neq r[i]</span> . Summarizing, we have that the probability that  <span class="math">(1)(a,b) \\in \\mathsf{G}_i</span>  and  <span class="math">(2)(a,\\hat{b}) \\in \\mathsf{S}_i</span>  and  <span class="math">(3)\\hat{r}[i] \\neq r[i]</span>  all occur is at least  <span class="math">p_i/2(p_i/2-1/2^{l_H})</span> . This latter event implies that both runs are i-successful and  <span class="math">\\hat{r}[i] \\neq r[i]</span> , i.e. that event  <span class="math">\\mathsf{S}_i^*</span>  occurs. Hence</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_i^*] \\ge p_i / 2(p_i / 2 - 1/2^{l_H}) \\text{ for all } i \\in \\{1, \\dots, q_o\\},</span>$
(9)</p>

    <p class="text-gray-300">and since  <span class="math">p_i</span>  is the probability that a run of  <span class="math">A_P</span>  is i-successful, we know that  <span class="math">\\sum_{i=1}^{q_o} p_i = \\mathbf{Succ}_{A_P, P[q_o, q_d]}(k)</span> . Assuming that  <span class="math">\\mathbf{Succ}_{A_P, P[q_o, q_d]}(k) \\ge 2q_o/2^{l_H}</span> , we apply Lemma A.3 to (9) to get</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}^*] = \\sum_{i=1}^{q_o} \\Pr[\\mathsf{S}_i^*] \\ge (1/q_o) \\cdot \\left( \\mathbf{Succ}_{\\mathsf{A}_{\\mathsf{P}}, P[q_o, q_d]}(k) / 2 - q_o / 2^{l_H} \\right)^2, \\tag{10}</span>$</p>

    <p class="text-gray-300">which is the desired lower-bound on  <span class="math">A_S</span> 's success probability.</p>

    <p class="text-gray-300">To complete the proof of the theorem, we apply to A the Stage 1 reduction (Lemma A.1) followed by the Stage 2 reduction (Lemma A.4) and obtain an algorithm  <span class="math">A_S</span>  for SDH with the claimed success probability bound (4) and resources t[S] and q[S], as claimed.</p>

    <p class="text-gray-300">The proof is straightforward but we give the details for completeness. To show the perfect unconditional privacy, assuming the <em>direct</em> verifier key-reg. protocol is used, we show how to use construct the forgery strategy  <span class="math">\\widehat{\\mathsf{A}_1}</span>  which, for any given privacy attacker pair  <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> , will perfectly simulate the DV signature answers to  <span class="math">\\mathsf{A}_1</span> 's designation queries  <span class="math">y_{3,i}</span>  without the message  <span class="math">m^*</span>  being signed by the signer, using the corresponding secret key  <span class="math">x_{3,i}</span>  that  <span class="math">\\mathsf{A}_1</span>  registered with  <span class="math">y_{3,i}</span>  during a previous key-reg. query. This shows that the convincing measure  <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1, \\mathsf{A}_2)</span>  is zero for any  <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> , as required.</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which  <span class="math">A_1</span>  and  <span class="math">A_2</span>  interact.</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(A_1, A_2)</span>  is run on input  <span class="math">(D_G, g, y_1 = g^{x_1})</span> .  <span class="math">A_1</span> 's oracle queries are answered as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1, .)</span>  Queries. When  <span class="math">A_1</span>  makes ith S-query  <span class="math">m_i</span> , it is answered with  <span class="math">\\sigma_i = S(x_1, m_i)</span> .</li>
      <li>(2) KRA Queries. When A&lt;sub&gt;1&lt;/sub&gt; makes ith key-reg. query  <span class="math">(x_{3,i}, y_{3,i})</span>  it is answered Acc if  <span class="math">g^{x_{3,i}} = y_{3,i}</span>  and Rej else.</li>
      <li>(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  sends message  <span class="math">m_i</span>  to  <span class="math">A_2</span> ,  <span class="math">A_2</span>  responds with an answer  <span class="math">a_i</span> .</li>
    </ul>

    <p class="text-gray-300">End of Stage 1. A&lt;sub&gt;1&lt;/sub&gt; outputs a challenge message  <span class="math">m^*</span>  which is given to A&lt;sub&gt;2&lt;/sub&gt;. A PV signature  <span class="math">\\sigma_i = (r^*, s^*) = S(x_1, m^*)</span>  is generated, where  <span class="math">r^* = H(m^*, u^*)</span>  for  <span class="math">u^* = g^{k^*}</span>  for uniformly random  <span class="math">k^* \\in \\mathbb{Z}_q</span> , and  <span class="math">s^* = k^* + r^* \\cdot x_1 \\mod q</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When  <span class="math">A_1</span>  makes ith CDV-query  <span class="math">y_{3,i}</span> , it is answered with DV signature  <span class="math">\\widehat{\\sigma}_i = \\text{CDV}(y_1, y_{3,i}, m^*, \\sigma^*) = (\\widehat{u}_i, \\widehat{K}_i)</span> , where  <span class="math">\\widehat{u}_i = g^{s^*} \\cdot y_1^{-r^*}</span>  and  <span class="math">\\widehat{K}_i = y_{3,i}^{s^*}</span> .</p>

    <p class="text-gray-300">End of Stage 2.  <span class="math">A_2</span>  outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">Game no. We now describe the other game where  <span class="math">\\widehat{A_1}</span>  interacts with  <span class="math">A_2</span> .</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(\\widehat{A_1}, A_2)</span>  is run on input  <span class="math">(D_G, g, y_1 = g^{x_1})</span> , where  <span class="math">\\widehat{A_1}</span>  is also given the program for  <span class="math">A_1</span>  as input.  <span class="math">\\widehat{A_1}</span>  now runs  <span class="math">A_1</span>  on same input and answers  <span class="math">A_1</span> 's oracle queries as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1,.)</span>  Queries. When  <span class="math">A_1</span>  makes <em>i</em>th S-query  <span class="math">m_i</span> ,  <span class="math">\\widehat{A_1}</span>  forwards it to S oracle and forwards response  <span class="math">\\sigma_i = S(x_1, m_i)</span>  back to  <span class="math">A_1</span> .</li>
      <li>(2) KRA Queries. When  <span class="math">A_1</span>  makes <em>i</em>th key-reg. query  <span class="math">(x_{3,i}, y_{3,i})</span>   <span class="math">\\widehat{A_1}</span>  answers Acc if  <span class="math">g^{x_{3,i}} = y_{3,i}</span>  and stores  <span class="math">(x_{3,i}, y_{3,i}, Acc)</span>  in a table T, else it answers Rej.</li>
      <li>(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  outputs a message  <span class="math">m_i</span>  for  <span class="math">A_2</span> ,  <span class="math">\\widehat{A_1}</span>  forwards it to  <span class="math">A_2</span>  and forwards the answer  <span class="math">a_i</span>  back to  <span class="math">A_1</span> .</li>
    </ul>

    <p class="text-gray-300">End of Stage 1.  <span class="math">A_1</span>  outputs a challenge message  <span class="math">m^*</span> , which is also output by  <span class="math">\\widehat{A_1}</span>  and given to  <span class="math">A_2</span> .  <span class="math">\\widehat{A_1}</span>  computes  <span class="math">u^* = g^{k^*}</span>  and  <span class="math">r^* = H(m^*, u^*)</span> , for a uniformly random  <span class="math">k^* \\in \\mathbb{Z}_q</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries, answered by  <span class="math">\\widehat{A_1}</span>  as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When  <span class="math">A_1</span>  makes ith CDV-query  <span class="math">y_{3,i}</span> ,  <span class="math">\\widehat{A}_1</span>  searches table T for an entry  <span class="math">(x_{3,j}, y_{3,j}, Acc)</span>  with  <span class="math">y_{3,j} = y_{3,i}</span>  (note that this entry is guaranteed to exist in T due to the restriction on  <span class="math">A_1</span>  to only query CDV with public keys which have been answered with Acc by a previous KRA query) and answers with  <span class="math">\\widehat{\\sigma}_i = (\\widehat{u}_i, \\widehat{K}_i)</span> , where  <span class="math">\\widehat{u}_i = u^*</span>  and  <span class="math">\\widehat{K}_i = (u^* \\cdot y^{-r^*})^{x_{3,j}}</span> .</p>

    <p class="text-gray-300">End of Stage 2.  <span class="math">A_2</span>  outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">Note that A&lt;sub&gt;1&lt;/sub&gt;'s (and hence also A&lt;sub&gt;2&lt;/sub&gt;) view is perfectly simulated in Game no as in Game yes. This is because in both games  <span class="math">u^*</span>  and  <span class="math">r^*</span>  are computed identically and the DV signatures  <span class="math">(u_i, K_i)</span>  are also identical in both games because  <span class="math">\\widehat{u}_i = g^{s^*} \\cdot y_1^{-r^*} = u^*</span>  in Game yes and  <span class="math">u_i = u^*</span>  in Game no for all i, and  <span class="math">\\widehat{K}_i = y_{3,i}^{s^*} = g^{x_{3,i}s^*} = (u^*y^{-r^*})^{x_{3,i}}</span>  in Game yes and  <span class="math">\\widehat{K}_i = (u^* \\cdot y^{-r^*})^{x_{3,j}} = (u^* \\cdot y^{-r^*})^{x_{3,i}}</span>  in Game no. All other oracles are simulated identically in both games. So A&lt;sub&gt;2&lt;/sub&gt; outputs yes with same probability in both games and hence  <span class="math">C_{\\widehat{A_1}}(A_1, A_2) = 0</span> , as claimed. The run-time of  <span class="math">\\widehat{A_1}</span>  is the run-time of A&lt;sub&gt;1&lt;/sub&gt; plus the time  <span class="math">q_{d1}O(l_qT_g + q_{d1}l_G) + q_{k1}O(l_qT_g)</span>  to answer A&lt;sub&gt;1&lt;/sub&gt;'s CDV and KRA queries. Note that  <span class="math">\\widehat{q_{s1}} = q_{s1}</span> ,  <span class="math">\\widehat{q_{c1}} = q_{c1}</span> , and  <span class="math">\\widehat{q_{k1}} = 0</span> , as claimed.</p>

    <p class="text-gray-300">We show how to use any efficient forging attacker A for breaking scheme  <span class="math">SchUDVS_2</span>  in the sense of ST-UF-DV with non-negligible probability to construct (1) an efficient attacker  <span class="math">A_S</span>  for breaking the PV unforgeability of scheme  <span class="math">SchUDVS_2</span>  (i.e. the unforgeability of the Schnorr signature scheme), and (2) an efficient attacker  <span class="math">A_T</span>  for breaking the collision-resistance of the trapdoor hash scheme TH, such that at least one of  <span class="math">A_S</span>  or  <span class="math">A_T</span>  succeed with non-negligible probability. More precisely, we show that:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Succ}_{\\mathsf{A_{S}},\\mathsf{SchUDVS}_{2}}^{\\mathsf{UF}-\\mathsf{PV}}(k) + \\mathbf{Succ}_{\\mathsf{A_{T}},\\mathsf{TH}}^{\\mathsf{CR}}(k) \\geq \\frac{1}{4(q_{J}+q_{v})q_{s}} \\cdot \\left[\\mathbf{Succ}_{\\mathsf{A,SchUDVS}_{2}}^{\\mathsf{ST}-\\mathsf{UF}-\\mathsf{DV}}(k) - \\frac{2(q_{J}+q_{v})q_{s}+1}{2^{l_{J}}}\\right]^{2}, \\quad (11)</span>$</p>

    <p class="text-gray-300">where  <span class="math">A_S</span>  and  <span class="math">A_T</span>  have resources  <span class="math">(t[S], q_s[S], q_H[S])</span>  and (t[T]) respectively, as defined in the theorem statement. The theorem then follows immediately from (11), by taking maximums over all attackers  <span class="math">A_S</span>  with the given running time. It remains to construct  <span class="math">A_S</span>  and  <span class="math">A_T</span>  and show (11).</p>

    <p class="text-gray-300">Modified Attacker  <span class="math">\\widehat{A}</span> . Similar to the proof of Theorem 4.1, we first define a modified attacker  <span class="math">\\widehat{A}</span>  which is obtained from the original attacker A in order to satisfy two properties (which may not be satisfied by A): (1) Each J-query  <span class="math">(m_i, r_i, u_i, \\widehat{h}_i)</span>  of  <span class="math">\\widehat{A}</span>  is 'new' (i.e. unequal any earlier query to J(.) made by  <span class="math">\\widehat{A}</span> ), and (2)  <span class="math">\\widehat{A}</span>  does not make any VDV queries. Since the VDV oracle of A can be simulated knowing only the verifier's public key  <span class="math">pk_3</span> , and using one query to H(.) and J(.) per VDV query, we can easily transform A into  <span class="math">\\widehat{A}</span>  such that  <span class="math">\\widehat{A}</span> 's resources (denoted with hats) are related to A's resources as follows:  <span class="math">\\widehat{q}_s = q_s</span> ,  <span class="math">\\widehat{q}_v = 0</span> ,  <span class="math">\\widehat{q}_H = q_H + q_v</span> ,  <span class="math">\\widehat{q}_J = q_J + q_v</span> , and  <span class="math">\\widehat{t} = t + O((q_J + q_v) \\log_2(q_J + q_v) \\cdot (\\ell + l_G + l_F)) + O(l_q T_q q_v)</span> .</p>

    <p class="text-gray-300">Game&lt;sub&gt;0&lt;/sub&gt;. Let Game&lt;sub&gt;0&lt;/sub&gt; denote the original forgery attack game. In this game, let  <span class="math">(m_i, r_i, u_i, \\hat{h}_i)</span>  denote the ith J(.) query of  <span class="math">\\widehat{A}</span>  and  <span class="math">\\widehat{r}_i</span>  the corresponding answer, let  <span class="math">(m^*, u^*, \\widehat{r}_F^*, \\widehat{r}^*, \\widehat{s}^*)</span>  denote the output forgery of  <span class="math">\\widehat{A}</span> , and let  <span class="math">m_i&#x27;</span>  denote the ith S-query of  <span class="math">\\widehat{A}</span> . Let  <span class="math">S_0</span>  denote the event in Game&lt;sub&gt;0&lt;/sub&gt; that  <span class="math">\\widehat{A}</span>  breaks SchUDVS&lt;sub&gt;2&lt;/sub&gt; in the sense of ST-UF-DV. By definition, this means:</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{S}_{0} \\ \\Rightarrow \\ (\\mathrm{a}) \\ J(m^{*}, r^{*}, u^{*}, \\widehat{h}^{*}) = \\widehat{r}^{*}, \\text{ where } r^{*} = H(m^{*}, u^{*}), \\ \\widehat{h}^{*} = F_{pk}(\\widehat{u}^{*}; \\widehat{r}_{F}^{*}), \\ \\widehat{u}^{*} = g^{\\widehat{s}^{*}}(u^{*}y_{1}^{r^{*}})^{-\\widehat{r}^{*}}</span>$</p>

    <p class="text-gray-300"><span class="math">$(\\mathrm{b}) \\ m^{*} \\neq m&#x27;_{i} \\text{ for all } i \\in W^{S},</span>$</p>

    <p class="text-gray-300"><span class="math">$(12)</span>$</p>

    <p class="text-gray-300">where  <span class="math">W^S</span>  denotes the set  <span class="math">\\{1, \\ldots, q_s\\}</span>  of S-query indices.</p>

    <p class="text-gray-300">Let  <span class="math">\\mathsf{Bad}_0</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that  <span class="math">\\widehat{\\mathsf{A}}</span>  did not make a J-query  <span class="math">(m^*, r^*, u^*, \\widehat{h}^*)</span>  during the attack.</p>

    <p class="text-gray-300"><span class="math">$\\mathsf{Bad}_0 \\Rightarrow (m_i, r_i, u_i, \\widehat{h}_i) \\neq (m^*, r^*, u^*, \\widehat{h}^*) \\text{ for all } i \\in W^J, \\tag{13}</span>$</p>

    <p class="text-gray-300">where  <span class="math">W^J</span>  denotes the set  <span class="math">\\{1,...,q_J\\}</span>  of J-query indices.</p>

    <p class="text-gray-300">Thanks to the randomness of J(.), we get:</p>

    <h3 id="sec-15" class="text-xl font-semibold mt-8">Claim C.1.</h3>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}_0 \\wedge \\mathsf{Bad}_0] \\leq 1/2^{l_J}.</span>$</p>

    <p class="text-gray-300">Proof of Claim. If  <span class="math">\\mathsf{Bad_0}</span>  occurs, we know  <span class="math">(m^*, r^*, u^*, \\widehat{h}^*)</span>  is not queried to J(.) during the game, and therefore  <span class="math">\\widehat{\\mathsf{A}}</span> 's view (and hence its output  <span class="math">(m^*, u^*, \\widehat{r}_F^*, \\widehat{r}^*, \\widehat{s}^*)</span> ) is independent of  <span class="math">J(m^*, r^*, u^*, \\widehat{h}^*)</span> , which is in turn uniformly distributed in  <span class="math">\\mathbb{Z}_{2^{l_J}}</span> . Hence if  <span class="math">\\mathsf{Bad_0}</span>  occurs the chance that  <span class="math">\\widehat{r}^* = J(m^*, r^*, u^*, \\widehat{h}^*)</span>  (so  <span class="math">\\mathsf{S_0}</span>  also occurs) is  <span class="math">1/2^{l_J}</span> . The claim follows.</p>

    <p class="text-gray-300">Let  <span class="math">S_0^1</span>  denote the event in  <span class="math">\\mathsf{Game}_0</span>  that  <span class="math">\\mathsf{S}_0</span>  occurs but  <span class="math">\\mathsf{Bad}_0</span>  does not. That is:</p>

    <p class="text-gray-300"><span class="math">$S_0^1 \\Rightarrow \\text{ (a) There exists } i^* \\in W^J \\text{ such that } (m^*, r^*, u^*) = (m_{i^*}, r_{i^*}, u_{i^*})</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{and } F_{pk}(g^{\\widehat{s}^*} \\cdot (u_{i^*}y_1^{r_{i^*}})^{-\\widehat{r}_{i^*}}; \\widehat{r}_F^*) = \\widehat{h}_{i^*} \\text{ and } r_{i^*} = H(m_{i^*}, u_{i^*})</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{(b) } m^* \\neq m&#x27;_i \\text{ for all } i \\in W^S</span>$</p>

    <p class="text-gray-300"><span class="math">$(14)</span>$</p>

    <p class="text-gray-300">The above results immediately give:</p>

    <h4 id="sec-16" class="text-lg font-semibold mt-6">Claim C.2.</h4>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}_0^1] \\ge \\Pr[\\mathsf{S}_0] - \\frac{1}{2^{l_J}}.</span>$</p>

    <p class="text-gray-300"><span class="math">\\textit{Proof of Claim.} \\ \\ \\text{We have} \\ \\Pr[\\mathsf{S}_0^1] = \\Pr[\\mathsf{S}_0 \\land \\neg \\mathsf{Bad}_0] \\geq \\Pr[\\mathsf{S}_0] - \\Pr[\\mathsf{Bad}_0] \\geq \\Pr[\\mathsf{S}_0] - 1/2^{l_J} \\ \\ \\text{using Claim C.1.}</span></p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_1</span> . In  <span class="math">\\mathsf{Game}_1</span> , we construct the algorithm  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  against the PV-unforgeability of  <span class="math">\\mathsf{SchUDVS}_2</span> . On input  <span class="math">(k, D_G, g, y_1)</span>   <span class="math">\\mathsf{A}_\\mathsf{S}</span>  runs as follows.</p>

    <p class="text-gray-300">Setup. As first sets up two random vectors  <span class="math">\\overrightarrow{\\hat{r}}[1] = (\\widehat{r}_1[1], \\dots, \\widehat{r}_{\\widehat{q}_J}[1])</span>  and  <span class="math">\\overrightarrow{\\hat{r}}[2] = (\\widehat{r}_1[2], \\dots, \\widehat{r}_{\\widehat{q}_J}[2])</span>  with  <span class="math">\\widehat{r}_i[1]</span> 's and  <span class="math">\\widehat{r}_i[2]</span> 's chosen uniformly and independently at random from  <span class="math">\\mathbb{Z}_{2^{l_J}}</span>  (these vectors will be used to answer  <span class="math">A_P</span> 's J(.) queries). As also generates a TH key-pair  <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span> .</p>

    <p class="text-gray-300">First Run. As runs  <span class="math">\\widehat{A}</span>  on input  <span class="math">(D_G, g, y_1, pk; \\omega)</span> , where  <span class="math">\\omega</span>  is a random bit string used as the randomness input of  <span class="math">\\widehat{A}</span> , and answers  <span class="math">\\widehat{A}</span> 's oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) J(.)-Query simulator  <span class="math">\\mathsf{F}^{\\mathsf{J}}</span> . When  <span class="math">\\widehat{\\mathsf{A}}</span>  makes its ith J(.) query  <span class="math">(m_i[1], r_i[1], u_i[1], \\widehat{h}_i[1])</span> ,  <span class="math">\\mathsf{A}_{\\mathsf{S}}</span>  responds with  <span class="math">\\widehat{r}_i[1]</span> .</li>
      <li>(2) S-Query simulator  <span class="math">F^S</span> . When  <span class="math">\\widehat{A}</span>  makes its jth S query  <span class="math">m&#x27;_j[1]</span> ,  <span class="math">A_S</span>  simply forwards the query to its S oracle and forwards the oracle's response  <span class="math">\\sigma_j[1]</span>  back to  <span class="math">\\widehat{A}</span> .  <span class="math">A_S</span>  stores the query-answer pair  <span class="math">(m&#x27;_j[1], \\sigma_j[1])</span>  in a table T.</li>
    </ul>

    <p class="text-gray-300">First Run Output. At the end of first run,  <span class="math">\\widehat{A}</span>  outputs the forgery  <span class="math">(m^*[1], u^*[1], \\widehat{r}^*[1], \\widehat{r}^*[1], \\widehat{s}^*[1])</span> . Note that if this run is successful then there exists  <span class="math">i^* \\in W^J</span>  such that  <span class="math">\\widehat{A}</span> 's forgery satisfies (14). We also define  <span class="math">j^* \\in W^S</span>  as the number of S-queries made by  <span class="math">\\widehat{A}</span>  before issuing its  <span class="math">i^*</span> th J-query.  <span class="math">A_S</span>  finds  <span class="math">(i^*, j^*)</span>  from a table of  <span class="math">\\widehat{A}</span> 's queries in time  <span class="math">O(\\widehat{q}_J(\\ell + l_F + l_G) + l_g T_g)</span>  (if  <span class="math">i^*</span>  doesn't exist,  <span class="math">A_S</span>  fails).</p>

    <p class="text-gray-300">Second Run. As runs  <span class="math">\\widehat{A}</span>  again on the same input  <span class="math">(D_g, g, y_1, pk; \\omega)</span>  as used in first run, but answers its oracle queries differently as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) J(.)-Query simulator  <span class="math">\\mathsf{F}^\\mathsf{J}</span> . When  <span class="math">\\widehat{\\mathsf{A}}</span>  makes its ith J(.) query  <span class="math">(m_i[2], r_i[2], u_i[2], \\widehat{h}_i[2])</span> ,  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  responds with  <span class="math">\\widehat{r}_i[1]</span>  for  <span class="math">i &lt; i^*</span>  and with  <span class="math">\\widehat{r}_i[2]</span>  for  <span class="math">i \\ge i^*</span> .</li>
      <li>(2) S-Query simulator  <span class="math">F^S</span> . When  <span class="math">\\widehat{A}</span>  makes its jth S query  <span class="math">m&#x27;_j[2]</span> ,  <span class="math">A_S</span>  responds with  <span class="math">\\sigma_j[1]</span>  for  <span class="math">j \\leq j^*</span> . For  <span class="math">j &gt; j^*</span> ,  <span class="math">A_S</span>  forwards the query to its S oracle and forwards the oracle's response  <span class="math">\\sigma_j[2]</span>  back to  <span class="math">\\widehat{A}</span> .</li>
    </ul>

    <p class="text-gray-300">Second Run Output. At the end of second run,  <span class="math">\\widehat{\\mathsf{A}}</span>  outputs the forgery  <span class="math">(m^*[2], u^*[2], \\widehat{r}_F^*[2], \\widehat{r}^*[2], \\widehat{s}^*[2])</span> .</p>

    <p class="text-gray-300">As output. As computes and returns an estimate  <span class="math">(\\widehat{m}^*, (\\widehat{r}^*, \\widehat{s}^*))</span>  for a message/PV sig. forgery for SchUDVS&lt;sub&gt;2&lt;/sub&gt;, where  <span class="math">\\widehat{m}^* = m^*[1]</span> ,  <span class="math">\\widehat{r}^* = H(m^*[1], u^*[1])</span>  and  <span class="math">\\widehat{s}^* = (\\widehat{s}^*[1] - \\widehat{s}^*[2]) \\cdot (\\widehat{r}_{i^*}[2] - \\widehat{r}_{i^*}[1])^{-1} \\mod q</span>  (if  <span class="math">\\widehat{r}_{i^*}[1] = \\widehat{r}_{i^*}[2]</span>  then As fails).</p>

    <p class="text-gray-300">This completes the description of  <span class="math">A_S</span> . The running-time of  <span class="math">A_S</span>  is twice the run-time of  <span class="math">\\widehat{A}</span>  plus the time to compute  <span class="math">(i^*, j^*)</span>  and  <span class="math">\\widehat{s}^*</span>  at the end, which takes total time  <span class="math">O(\\widehat{q}_J(\\ell + l_F + l_G) + l_q T_g + l_q^2)</span> . The number of H- and S- queries made by  <span class="math">\\widehat{A}_S</span>  is up to twice the number of queries made by  <span class="math">\\widehat{A}_S</span> . This establishes the claimed resources of  <span class="math">A_S</span> .</p>

    <p class="text-gray-300">The collision-finder attacker  <span class="math">A_T</span>  runs  <span class="math">\\widehat{A}</span>  twice in the same way as  <span class="math">A_S</span> , and at the end computes the following collision estimate  <span class="math">(\\alpha[1], \\beta[1]), (\\alpha[2], \\beta[2]),</span>  where  <span class="math">\\alpha[\\rho] = (u_{i^*}[1] \\cdot y_1^{r_{i^*}[1]})^{-\\widehat{r}_{i^*}[\\rho]}</span>  and  <span class="math">\\beta[\\rho] = \\widehat{r}_F[\\rho]</span>  for  <span class="math">\\rho \\in \\{1, 2\\}</span> .</p>

    <p class="text-gray-300">We now lower bound the sum of success probabilities of  <span class="math">A_S</span>  and  <span class="math">A_T</span> . For each  <span class="math">(i,j) \\in W^J \\times W^S</span> , we call a run of  <span class="math">\\widehat{A}</span>  (i,j)-successful if  <span class="math">\\widehat{A}</span> 's output satisfies (14) and  <span class="math">(i^*,j^*)=(i,j)</span> . Let  <span class="math">S^*</span>  denote the event that both runs of  <span class="math">\\widehat{A}</span>  above are (i,j)-successful for some (i,j) and  <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span> . Note that if  <span class="math">S^*</span>  occurs then, defining  <span class="math">s^*</span>  as the discrete-log  <span class="math">u_i[1] \\cdot y_1^{r_i[1]}</span>  to base g in G, we have from (14) that</p>

    <p class="text-gray-300"><span class="math">$\\widehat{m}^* = m^*[1] = m_i[1] = m^*[2] = m_i[2]</span>$
has not been queried to S during either run of  <span class="math">\\widehat{A}</span>  (15)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$F_{pk}(g^{\\widehat{s}_i[1]} \\cdot (g^{s^*})^{-\\widehat{r}_i[1]}; \\widehat{r}_F^*[1]) = F_{pk}(g^{\\widehat{s}_i[1]} \\cdot (g^{s^*})^{-\\widehat{r}_i[2]}; \\widehat{r}_F^*[2])</span>$
(16)</p>

    <p class="text-gray-300">(note that  <span class="math">(m_i[1], r_i[1], u_i[1]) = (m_i[2], r_i[2], u_i[2])</span>  because the view of  <span class="math">\\widehat{A}</span>  is the same in both runs up to ith J(.) query response). We now split event  <span class="math">S^*</span>  into two disjoint subevents  <span class="math">S^*_{S}</span>  and  <span class="math">S^*_{T}</span> , depending on whether</p>

    <p class="text-gray-300"><span class="math">$g^{\\hat{s}_i[1]} \\cdot (g^{s^*})^{-\\hat{r}_i[1]} = g^{\\hat{s}_i[1]} \\cdot (g^{s^*})^{-\\hat{r}_i[2]}</span>$
(17)</p>

    <p class="text-gray-300">holds or not, respectively. If the subevent  <span class="math">S_S^*</span>  occurs, then (17) holds and hence  <span class="math">A_S</span> 's estimate  <span class="math">\\hat{s}^*</span>  is equal to the discrete-log  <span class="math">s^* = (\\hat{s}^*[1] - \\hat{s}^*[2]) \\cdot (\\hat{r}_{i^*}[2] - \\hat{r}_{i^*}[1])^{-1} \\mod q</span>  of  <span class="math">u_i[1]y_1^{r_i[1]}</span>  and  <span class="math">r_i[1] = H(m_i[1], u_i[1])</span> . Thus  <span class="math">S_S^*</span>  implies that  <span class="math">A_S</span> 's forgery is valid and coupled with (15) means that  <span class="math">A_S</span>  succeeds to break the PV unforgeability of SchUDVS&lt;sub&gt;2&lt;/sub&gt; in this case. In the other case that subevent  <span class="math">S_T^*</span>  occurs, (17) does not hold but (16) holds, meaning that  <span class="math">A_T</span> 's output is a valid collision for the trapdoor hash so  <span class="math">A_T</span>  succeeds.</p>

    <p class="text-gray-300">So we have shown that the sum of success probabilities of  <span class="math">A_S</span>  and  <span class="math">A_T</span>  is equal to the probability of the event  <span class="math">S^*</span>  that both runs of  <span class="math">\\widehat{A}</span>  are (i,j)-successful for some  <span class="math">(i,j) \\in W^J \\times W^S</span>  and  <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span> , and it remains to lower bound  <span class="math">\\Pr[S^*]</span> . To do this, we split  <span class="math">S^*</span>  into  <span class="math">|W_J \\times W^S| = \\widehat{q}_J q_s</span>  disjoint subevents  <span class="math">S^*_{i,j}</span>  according the value of (i,j) and bound each one. For each (i,j), let  <span class="math">A_{i,j}</span>  denote the outcome space for the random variable  <span class="math">a_{i,j} = (D_g, g, y_1, pk, \\omega, (r_1, \\ldots, r_{i-1}), (k_1, \\ldots, k_j))</span>  consisting of the view of  <span class="math">\\widehat{A}</span>  up to the ith query to O(.) and the random elements  <span class="math">k_i</span>  used by S oracle to answer first j signature queries, and let  <span class="math">B_{i,j}</span>  denote the outcome space for the independent random variable  <span class="math">b_{i,j} = ((r_i, \\ldots, r_{\\widehat{q}_J}), (k_{j+1}, \\ldots, k_{q_s}))</span>  consisting of the view of  <span class="math">A^P</span>  after the ith query to O(.) (including the response r[i] to the ith query and  <span class="math">k_i</span> 's used to answer all remaining signature queries. Note that the event  <span class="math">S_{i,j}</span>  that a run of  <span class="math">\\widehat{A}</span>  is (i,j)-successful is a subset of  <span class="math">A_{i,j} \\times B_{i,j}</span>  with probability  <span class="math">p_{i,j} \\stackrel{\\text{def}}{=} \\Pr[(a_{i,j},b_{i,j}) \\in S_{i,j}]</span> . Proceeding from this point analgously to the calculation in Lemma A.4, we apply the Splitting Lemma A.2 and obtain</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S^*_{i,j}] \\ge p_{i,j}/2(p_{i,j}/2 - 1/2^{l_J}) \\text{ for all } (i,j) \\in W^J \\times W^S,</span>$
(18)</p>

    <p class="text-gray-300">and hence applying Lemma A.3 to (18) noting that  <span class="math">\\sum_{i,j} p_{i,j} = \\Pr[S_0^1]</span>  we get</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}^*] = \\sum_{(i,j) \\in W^J \\times W^S} \\Pr[\\mathsf{S}^*_{i,j}] \\ge \\frac{1}{\\widehat{q}_J q_s} \\cdot \\left(\\Pr[\\mathsf{S}_0^1]/2 - \\widehat{q}_J q_s/2^{l_J}\\right)^2, \\tag{19}</span>$</p>

    <p class="text-gray-300">which using Claim C.2 gives the desired lower-bound (11) on  <span class="math">Pr[S^*]</span> . This completes the proof.</p>

    <p class="text-gray-300">To show the perfect unconditional privacy, assuming the direct verifier key-reg. protocol is used, we show how to construct the forgery strategy  <span class="math">\\widehat{\\mathsf{A}_1}</span>  which, for any given privacy attacker pair  <span class="math">(\\mathsf{A}_1, \\mathsf{A}_2)</span> , will perfectly simulate the DV signature answers to  <span class="math">\\mathsf{A}_1</span> 's designation queries  <span class="math">pk_i</span>  without the message  <span class="math">m^*</span>  being signed by the signer, using the corresponding secret key  <span class="math">sk_i</span>  that  <span class="math">\\mathsf{A}_1</span>  registered with  <span class="math">pk_i</span>  during a previous key-reg. query. This shows that the convincing measure  <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1,\\mathsf{A}_2)</span>  is zero for any  <span class="math">(\\mathsf{A}_1,\\mathsf{A}_2)</span> , as required.</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which  <span class="math">A_1</span>  and  <span class="math">A_2</span>  interact.</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(A_1, A_2)</span>  is run on input  <span class="math">(D_G, g, y_1 = g^{x_1})</span> .  <span class="math">A_1</span> 's oracle queries are answered as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1, .)</span>  Queries. When  <span class="math">A_1</span>  makes ith S-query  <span class="math">m_i</span> , it is answered with  <span class="math">\\sigma_i = S(x_1, m_i)</span> .</li>
      <li>(2) KRA Queries. When  <span class="math">A_1</span>  makes <em>i</em>th key-reg. query  <span class="math">(r_i, sk_i, pk_i)</span>  it is answered Acc if  <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span>  and Rej else.</li>
    </ul>

    <p class="text-gray-300">(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  sends message  <span class="math">m_i</span>  to  <span class="math">A_2</span> ,  <span class="math">A_2</span>  responds with an answer  <span class="math">a_i</span> .</p>

    <p class="text-gray-300">End of Stage 1. A&lt;sub&gt;1&lt;/sub&gt; outputs a challenge message  <span class="math">m^*</span>  which is also given to A&lt;sub&gt;2&lt;/sub&gt;. A PV signature  <span class="math">\\sigma_i = (r^*, s^*) = \\mathsf{S}(x_1, m^*)</span>  is generated, where  <span class="math">r^* = H(m^*, u^*)</span>  for  <span class="math">u^* = g^{k^*}</span>  for uniformly random  <span class="math">k^* \\in \\mathbb{Z}_q</span> , and  <span class="math">s^* = k^* + r^* \\cdot x_1 \\mod q</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When  <span class="math">A_1</span>  makes ith CDV-query  <span class="math">pk_i</span> , it is answered with DV signature  <span class="math">\\widehat{\\sigma}_i = \\text{CDV}(y_1, pk_i, m^*, \\sigma^*) = (u_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span> , where  <span class="math">\\widehat{u}_i = g^{s^*} \\cdot y_1^{-r^*}, \\widehat{r}_i = J(m^*, r^*, u^*, \\widehat{h}_i)</span>  and  <span class="math">\\widehat{s}_i = \\widehat{k}_i + \\widehat{r}_i \\cdot s^* \\mod q</span> , where  <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i})</span>  and  <span class="math">\\widehat{u}_i = g^{\\widehat{k}_i}</span>  for uniformly random  <span class="math">\\widehat{k}_i \\in \\mathbb{Z}_q</span> .</p>

    <p class="text-gray-300">End of Stage 2.  <span class="math">A_2</span>  outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">Game no. We now describe the other game where  <span class="math">\\widehat{A_1}</span>  interacts with  <span class="math">A_2</span> .</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(\\widehat{A_1}, A_2)</span>  is run on input  <span class="math">(D_G, g, y_1 = g^{x_1})</span> , where  <span class="math">\\widehat{A_1}</span>  is also given the program for  <span class="math">A_1</span>  as input.  <span class="math">\\widehat{A_1}</span>  runs  <span class="math">A_1</span>  on same input and answers  <span class="math">A_1</span> 's oracle queries as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1,.)</span>  Queries. When  <span class="math">A_1</span>  makes <em>i</em>th S-query  <span class="math">m_i</span> ,  <span class="math">\\widehat{A_1}</span>  forwards it to S oracle and forwards response  <span class="math">\\sigma_i = S(x_1, m_i)</span>  back to  <span class="math">A_1</span> .</li>
      <li>(2) KRA Queries. When  <span class="math">A_1</span>  makes ith key-reg. query  <span class="math">(r_i, sk_i, pk_i)</span> ,  <span class="math">\\widehat{A}_1</span>  answers Acc if  <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span>  and stores  <span class="math">(sk_i, pk_i, Acc)</span>  in a table T, else it answers Rej.</li>
      <li>(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  outputs a message  <span class="math">m_i</span>  for  <span class="math">A_2</span> ,  <span class="math">\\widehat{A_1}</span>  forwards it to  <span class="math">A_2</span>  and forwards the answer  <span class="math">a_i</span>  back to  <span class="math">A_1</span> .</li>
    </ul>

    <p class="text-gray-300">End of Stage 1.  <span class="math">A_1</span>  outputs a challenge message  <span class="math">m^*</span> , which is also output by  <span class="math">\\widehat{A_1}</span>  and given to  <span class="math">A_2</span> .  <span class="math">\\widehat{A_1}</span>  computes  <span class="math">u^* = g^{k^*}</span>  and  <span class="math">r^* = H(m^*, u^*)</span> , for a uniformly random independent  <span class="math">k^* \\in \\mathbb{Z}_q</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries, answered by  <span class="math">\\widehat{A_1}</span>  as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When  <span class="math">A_1</span>  makes ith CDV-query  <span class="math">pk_i</span> ,  <span class="math">\\widehat{A_1}</span>  searches table T for an entry  <span class="math">(sk_j, pk_j, Acc)</span>  with  <span class="math">pk_j = pk_i</span>  (note that this entry is guaranteed to exist in T due to the restriction on  <span class="math">A_1</span>  to only query CDV with public keys which have been answered with Acc by a previous KRA query) and answers with  <span class="math">\\widehat{\\sigma}_i = (u_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span> , where  <span class="math">\\widehat{u}_i = u^*</span> ,  <span class="math">\\widehat{r}_i = J(m^*, r^*, u^*, \\widehat{h}_i)</span> ,  <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}&#x27;; \\widehat{r}&#x27;_{F,i})</span>  for some fixed  <span class="math">\\widehat{u}&#x27; \\in G</span>  and uniformly random and independent  <span class="math">\\widehat{r}&#x27;_{F,i} \\in R_F</span> ,  <span class="math">\\widehat{s}_i</span>  is uniformly random and independent in  <span class="math">\\mathbb{Z}_q</span> , and  <span class="math">\\widehat{r}_{F,i} = \\mathsf{CSF}((sk_j, pk_j), (\\widehat{u}&#x27;, \\widehat{r}&#x27;_{F,i}), \\widehat{u}_i)</span> , with  <span class="math">\\widehat{u}_i = g^{\\widehat{s}_i}(u^*y_1^{r^*})^{-\\widehat{r}_i}</span> .</p>

    <p class="text-gray-300">End of Stage 2. A&lt;sub&gt;2&lt;/sub&gt; outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">We show that A&lt;sub&gt;1&lt;/sub&gt;'s (and hence also A&lt;sub&gt;2&lt;/sub&gt;) view is perfectly simulated in Game no as in Game yes. In particular, the DV signatures  <span class="math">(\\hat{\\sigma}_i = (u_i, \\hat{r}_{F,i}, \\hat{r}_i, \\hat{s}_i))</span>  are distributed identically in both games, for the following reasons. First, note that  <span class="math">u^*</span>  and  <span class="math">r^*</span>  are computed identically in both games. Second, observe that for each DV signature,  <span class="math">\\hat{r}_i</span>  and  <span class="math">\\hat{s}_i</span>  are determined uniquely by  <span class="math">(m^*, r^*, u^*, \\hat{u}_i, \\hat{r}_{F,i})</span>  in the same way in both games, namely</p>

    <p class="text-gray-300"><span class="math">$\\widehat{r}_i = J(m^*, r^*, u^*, F_{pk}(\\widehat{u}_i; \\widehat{r}_{F.i}))</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\widehat{s}_i</span>$
is the discrete-log in  <span class="math">G</span>  of  <span class="math">\\widehat{u}_i(u^*y_1^{r^*})^{\\widehat{r}_i}</span>  to base  <span class="math">g</span></p>

    <p class="text-gray-300">in both games. So it remains to show that (for each DV signature) the pair  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span>  is identically distributed in both games. In Game yes,  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span>  is uniform on  <span class="math">G \\times R_F</span>  by definition. In Game no, we</p>

    <p class="text-gray-300">have that  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i}) = G(\\widehat{s}_i, \\widehat{r}&#x27;_{F,i})</span>  for a function  <span class="math">G: \\mathbb{Z}_q \\times R_F \\to G \\times R_F</span>  defined by:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{u}_i = g^{\\widehat{s}_i} (u^* y_1^{r^*})^{-J(m^*, r^*, u^*, F_{pk}(\\widehat{u}&#x27;; \\widehat{r}&#x27;_{F,i}))}</span>$
(20)</p>

    <p class="text-gray-300"><span class="math">$\\widehat{r}_{F,i} = \\mathsf{CSF}((sk, pk), (\\widehat{u}&#x27;, \\widehat{r}&#x27;_{F,i}), \\widehat{u}_i). \\tag{21}</span>$</p>

    <p class="text-gray-300">From the perfectly-trapdoor property of TH we have that mapping  <span class="math">\\widehat{r}&#x27;_{F,i} \\mapsto \\mathsf{CSF}((sk,pk),(\\widehat{u}&#x27;,\\widehat{r}&#x27;_{F,i}),\\widehat{u}_i)</span>  is a permutation on  <span class="math">R_F</span> . This and the fact that g has order q immediately implies that function  <span class="math">G: \\mathbb{Z}_q \\times R_F \\to G \\times R_F</span>  is one-to-one. So since  <span class="math">(\\widehat{s}_i,\\widehat{r}&#x27;_{F,i})</span>  is uniform on  <span class="math">\\mathbb{Z}_q \\times R_F</span>  by definition, it follows that the image pair  <span class="math">(\\widehat{u}_i,\\widehat{r}_{F,i})</span>  is uniform on  <span class="math">G \\times R_F</span>  in Game no, as required. We conclude that  <span class="math">\\mathsf{A}_2</span>  outputs yes with same probability in both games and hence  <span class="math">C_{\\widehat{\\mathsf{A}}_1}(\\mathsf{A}_1,\\mathsf{A}_2) = 0</span> , as claimed. The run-time of  <span class="math">\\widehat{\\mathsf{A}}_1</span>  is the run-time of  <span class="math">\\mathsf{A}_1</span>  plus the time  <span class="math">q_{d1}O(l_qT_g + T_F + T_{CSF} + T_J + T_H + q_{d1}l_{pk}) + q_{k1}T_{GKF}</span>  to answer  <span class="math">\\mathsf{A}_1</span> 's CDV and KRA queries. Note that  <span class="math">\\widehat{q}_{s1} = q_{s1}</span> ,  <span class="math">\\widehat{q}_{c1} = q_{c1}</span> , and  <span class="math">\\widehat{q}_{k1} = 0</span> , as claimed.</p>

    <p class="text-gray-300">The proof is analogous to the proof of Theorem 4.1 so we don't provide all details. We show how to use any efficient forging attacker A for breaking scheme RSAUDVS in the sense of ST-UF-DV with non-negligible probability to construct (1) an efficient attacker  <span class="math">A_S</span>  for breaking the PV unforgeability of scheme RSAUDVS (i.e. the unforgeability of the standard RSA signature scheme), and (2) an efficient attacker  <span class="math">A_T</span>  for breaking the collision-resistance of the trapdoor hash scheme TH, such that at least one of  <span class="math">A_S</span>  or  <span class="math">A_T</span>  succeed with non-negligible probability. More precisely, we show that:</p>

    <p class="text-gray-300"><span class="math">$\\mathbf{Succ}_{\\mathsf{A_S},\\mathsf{RSAUDVS}}^{\\mathsf{UF-PV}}(k) + \\mathbf{Succ}_{\\mathsf{A_T},\\mathsf{TH}}^{\\mathsf{CR}}(k) \\geq \\frac{1}{4(q_J + q_v)q_s} \\cdot \\left[\\mathbf{Succ}_{\\mathsf{A},\\mathsf{RSAUDVS}}^{\\mathsf{ST-UF-DV}}(k) - \\frac{2(q_J + q_v)q_s + 1}{2^{l_J}}\\right]^2, \\quad (22)</span>$</p>

    <p class="text-gray-300">where  <span class="math">A_S</span>  and  <span class="math">A_T</span>  have resources  <span class="math">(t[S], q_s[S], q_H[S])</span>  and (t[T]) respectively, as defined in the theorem statement. The theorem then follows immediately from (22), by taking maximums over all attackers  <span class="math">A_S</span>  with the given running time. It remains to construct  <span class="math">A_S</span>  and  <span class="math">A_T</span>  and show (22).</p>

    <p class="text-gray-300">Modified Attacker  <span class="math">\\widehat{A}</span> . As in Theorem 4.3, we first define a modified attacker  <span class="math">\\widehat{A}</span>  which is obtained from the original attacker  <span class="math">\\widehat{A}</span>  in order to satisfy two properties (which may not be satisfied by  <span class="math">\\widehat{A}</span> ): (1) Each J-query of  <span class="math">\\widehat{A}</span>  is 'new' (i.e. unequal any earlier query to J(.) made by  <span class="math">\\widehat{A}</span> ), and (2)  <span class="math">\\widehat{A}</span>  does not make any VDV queries. The  <span class="math">\\widehat{A}</span> 's resources (denoted with hats) are related to  <span class="math">\\widehat{A}</span> 's resources as follows:  <span class="math">\\widehat{q}_s = q_s</span> ,  <span class="math">\\widehat{q}_v = 0</span> ,  <span class="math">\\widehat{q}_H = q_H + q_v</span> ,  <span class="math">\\widehat{q}_J = q_J + q_v</span> , and  <span class="math">\\widehat{t} = t + O((q_J + q_v) \\log_2(q_J + q_v) \\cdot (\\ell + l_G + l_F)) + O(l_q T_q q_v)</span> .</p>

    <p class="text-gray-300">Game&lt;sub&gt;0&lt;/sub&gt;. Let Game&lt;sub&gt;0&lt;/sub&gt; denote the original forgery attack game. In this game, let  <span class="math">(m_i, h_i, \\hat{h}_i)</span>  denote  <span class="math">\\widehat{\\mathsf{A}}</span> 's ith J-query, and  <span class="math">\\widehat{r}_i = (\\widehat{r}_{i,1}, \\dots, \\widehat{r}_{i,\\alpha})</span>  the response to this query. Let  <span class="math">(m^*, h^*, \\widehat{r}_F^*, \\widehat{r}^*, \\widehat{s}^*)</span>  denote  <span class="math">\\widehat{\\mathsf{A}}</span> 's output forgery, with  <span class="math">\\widehat{r}^* = (\\widehat{r}_1^*, \\dots, \\widehat{r}_{\\alpha}^*)</span> ,  <span class="math">\\widehat{s}^* = (\\widehat{s}_1^*, \\dots, \\widehat{s}_{\\alpha}^*)</span> ,  <span class="math">\\widehat{h}^* = F_{pk}(\\widehat{u}^*, \\alpha; \\widehat{r}_F^*)</span> ,  <span class="math">\\widehat{u}^* = (\\widehat{u}_1^*, \\dots, \\widehat{u}_{\\alpha}^*)</span>  and  <span class="math">\\widehat{u}_i^* = (\\widehat{s}_i^*)^e \\cdot (h^*)^{-\\widehat{r}_i^*}</span>  for  <span class="math">i = 1, \\dots, \\alpha</span> . Let  <span class="math">W_J = \\{1, \\dots, \\widehat{q}_J\\}</span>  and  <span class="math">W_S = \\{1, \\dots, \\widehat{q}_s\\}</span> , and let  <span class="math">m_i&#x27;</span>  denote the ith S query of  <span class="math">\\widehat{\\mathsf{A}}</span> . Analogously to Theorem 4.3, we define the event  <span class="math">S_0</span>  that  <span class="math">\\mathsf{A}</span>  succeeds and the event  <span class="math">S_0</span> :</p>

    <p class="text-gray-300"><span class="math">$S_0^1 \\Rightarrow (a) \\text{ There exists } i^* \\in W^J \\text{ such that } (m^*, h^*, \\widehat{h}^*) = (m_i, h_{i^*}, \\widehat{h}_{i^*})</span>$</p>

    <p class="text-gray-300"><span class="math">$\\text{and } F_{pk}(\\widehat{u}_{i^*,1}, \\dots, \\widehat{u}_{i^*,\\alpha}; \\widehat{r}_F^*) = \\widehat{h}_{i^*} \\text{ with } \\widehat{u}_{i^*,l} = (\\widehat{s}_l^*)^e \\cdot h_{i^*}^{-\\widehat{r}_{i^*,l}} \\text{ mod } N</span>$</p>

    <p class="text-gray-300"><span class="math">$(b) \\ m^* \\neq m&#x27;_i \\text{ for all } i \\in W^S \\text{ and } R(m^*, h^*) = Acc</span>$</p>

    <p class="text-gray-300"><span class="math">$(23)</span>$</p>

    <p class="text-gray-300">and due to the randomness of J(.) we get</p>

    <p class="text-gray-300"><span class="math">$\\Pr[S_0^1] \\ge \\Pr[S_0] - \\frac{1}{2^{l_J}}.</span>$
(24)</p>

    <p class="text-gray-300"><span class="math">\\mathsf{Game}_1</span> . In  <span class="math">\\mathsf{Game}_1</span> , we construct the algorithm  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  against the PV-unforgeability of  <span class="math">\\mathsf{RSAUDVS}_2</span> . On input (k, N, e)  <span class="math">\\mathsf{A}_\\mathsf{S}</span>  runs as follows.</p>

    <p class="text-gray-300">Setup. As first sets up two random vectors  <span class="math">\\overrightarrow{\\widehat{r}}[1] = (\\widehat{r}_1[1], \\dots, \\widehat{r}_{\\widehat{q}_J}[1])</span>  and  <span class="math">\\overrightarrow{\\widehat{r}}[2] = (\\widehat{r}_1[2], \\dots, \\widehat{r}_{\\widehat{q}_J}[2])</span>  with  <span class="math">\\widehat{r}_i[k] = (\\widehat{r}_{i,1}[k], \\dots, \\widehat{r}_{i,\\alpha}[k])</span>  chosen uniformly and independently at random from  <span class="math">\\mathbb{Z}_{2^{l_J/\\alpha}}^{\\alpha}</span>  for  <span class="math">k \\in \\{1, 2\\}</span> .</p>

    <p class="text-gray-300">First Run. As generates a TH key-pair  <span class="math">(sk, pk) = \\mathsf{GKF}(k)</span>  and runs  <span class="math">\\widehat{\\mathsf{A}}</span>  on input  <span class="math">(N, e, pk; \\omega)</span> , where  <span class="math">\\omega</span>  is a random bit string used as the randomness input of  <span class="math">\\widehat{\\mathsf{A}}</span> , and answers  <span class="math">\\widehat{\\mathsf{A}}</span> 's oracle queries as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) J(.)-Query simulator  <span class="math">F^J</span> . When  <span class="math">\\widehat{A}</span>  makes its <em>i</em>th J(.) query  <span class="math">(m_i[1], h_i[1], \\widehat{h}_i[1])</span> ,  <span class="math">A_S</span>  responds with  <span class="math">\\widehat{r}_i[1]</span> .</li>
      <li>(2) S-Query simulator  <span class="math">F^S</span> . When  <span class="math">\\widehat{A}</span>  makes its jth S query  <span class="math">m&#x27;_j[1]</span> ,  <span class="math">A_S</span>  simply forwards the query to its S oracle and forwards the oracle's response  <span class="math">\\sigma_j[1]</span>  back to  <span class="math">\\widehat{A}</span> .  <span class="math">A_S</span>  stores the query-answer pair  <span class="math">(m&#x27;_j[1], \\sigma_j[1])</span>  in a table T.</li>
    </ul>

    <p class="text-gray-300">First Run Output. At the end of first run,  <span class="math">\\widehat{A}</span>  outputs the forgery  <span class="math">(m^*[1], h^*[1], \\widehat{r}^*[1], \\widehat{r}^*[1], \\widehat{s}^*[1])</span> . Note that if this run is successful then there exists  <span class="math">i^* \\in W^J</span>  such that  <span class="math">\\widehat{A}</span> 's forgery satisfies (23). We also define  <span class="math">j^* \\in W^S</span>  as the number of S-queries made by  <span class="math">\\widehat{A}</span>  before issuing its  <span class="math">i^*</span> th J-query.  <span class="math">A_S</span>  finds  <span class="math">(i^*, j^*)</span>  from a table of  <span class="math">\\widehat{A}</span> 's queries in time  <span class="math">O(\\widehat{q}_J(l_F + l_N))</span>  (if  <span class="math">i^*</span>  doesn't exist,  <span class="math">A_S</span>  fails).</p>

    <p class="text-gray-300">Second Run. As runs  <span class="math">\\widehat{A}</span>  again on the same input  <span class="math">(N, e, pk; \\omega)</span>  as used in first run, but answers its oracle queries differently as follows:</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1) J(.)-Query simulator  <span class="math">F^J</span> . When  <span class="math">\\widehat{A}</span>  makes its ith J(.) query  <span class="math">(m_i[2], h_i[2], \\widehat{h}_i[2])</span> ,  <span class="math">A_S</span>  responds with  <span class="math">\\widehat{r}_i[1]</span>  for  <span class="math">i &lt; i^*</span>  and with  <span class="math">\\widehat{r}_i[2]</span>  for  <span class="math">i \\ge i^*</span> .</li>
      <li>(2) S-Query simulator F&lt;sup&gt;S&lt;/sup&gt;. When  <span class="math">\\widehat{A}</span>  makes its jth S query  <span class="math">m&#x27;_{j}[2]</span> ,  <span class="math">A_{S}</span>  responds with  <span class="math">\\sigma_{j}[1]</span>  for  <span class="math">j \\leq j^{*}</span> . For  <span class="math">j &gt; j^{*}</span> ,  <span class="math">A_{S}</span>  forwards the query to its S oracle and forwards the oracle's response  <span class="math">\\sigma_{j}[2]</span>  back to  <span class="math">\\widehat{A}</span> .</li>
    </ul>

    <p class="text-gray-300">Second Run Output. At the end of second run,  <span class="math">\\widehat{\\mathsf{A}}</span>  outputs the forgery  <span class="math">(m^*[2], h^*[2], \\widehat{r}^*[2], \\widehat{r}^*[2], \\widehat{s}^*[2])</span> .</p>

    <p class="text-gray-300">As output. As computes and returns an estimate  <span class="math">(\\widehat{m}^*, \\widehat{\\sigma}^*)</span>  for a message/PV sig. forgery for RSAUDVS as follows. First, As tries to find  <span class="math">l^* \\in \\{1, \\ldots, \\alpha\\}</span>  such that the integer  <span class="math">\\delta_r = \\widehat{r}_{i^*, l^*}[1] - \\widehat{r}_{i^*, l^*}[2]</span>  is non-zero (otherwise, if  <span class="math">\\widehat{r}_{i^*}[1] = \\widehat{r}_{i^*}[2]</span> , then As fails). Because  <span class="math">\\widehat{r}_{i, l^*}^*[1]</span>  and  <span class="math">\\widehat{r}_{i, l^*}^*[2]</span>  are in  <span class="math">\\mathbb{Z}_{2^{l_J/\\alpha}}</span>  we know that  <span class="math">|\\delta_r| &lt; 2^{l_J/\\alpha} &lt; e</span>  and hence  <span class="math">\\gcd(\\delta_r, e) = 1</span> , since e is prime. So there exist integers  <span class="math">c_r &lt; e</span>  and  <span class="math">c_e &lt; e</span>  such that  <span class="math">c_r \\cdot \\delta_r + c_e \\cdot e = 1</span>  and As can compute them in time  <span class="math">O(l_e^2)</span> . Then As computes the PV sig. estimate  <span class="math">\\widehat{\\sigma}^* = (\\widehat{s}_{l^*}^*[1]/\\widehat{s}_{l^*}^*[2])^{c_r} \\cdot (h^*[1])^{c_e} \\mod N</span>  on message  <span class="math">\\widehat{m}^* = m^*[1]</span> .</p>

    <p class="text-gray-300">This completes the description of  <span class="math">A_S</span> . The running-time of  <span class="math">A_S</span>  is twice the run-time of  <span class="math">\\widehat{A}</span>  plus the time to compute  <span class="math">(i^*, j^*)</span>  and  <span class="math">\\widehat{\\sigma}^*</span>  at the end, which takes total time  <span class="math">O(\\widehat{q}_J(l_F + l_N) + l_e^2 + l_e T_N)</span> . The number of H- and S- queries made by  <span class="math">\\widehat{A}_S</span>  is up to twice the number of queries made by  <span class="math">\\widehat{A}_S</span> . This establishes the claimed resources of  <span class="math">A_S</span> .</p>

    <p class="text-gray-300">The collision-finder attacker  <span class="math">A_T</span>  runs  <span class="math">\\widehat{A}</span>  twice in the same way as  <span class="math">A_S</span>  (except that it receives the hash function public key pk as input, and generates a signature key pair  <span class="math">(N, e, d) = \\mathsf{GKS}(k)</span>  by itself, with which it answers  <span class="math">\\widehat{A}</span> 's signing queries - note that the hash function secret key sk is not needed by  <span class="math">A_T</span> ), and at the end computes the following collision estimate  <span class="math">(\\beta[1], \\gamma[1]), (\\beta[2], \\gamma[2])</span> , where  <span class="math">\\beta[\\rho] = (\\widehat{u}_1^*[\\rho], \\ldots, \\widehat{u}_{\\alpha}^*[\\rho])</span>  and  <span class="math">\\gamma[\\rho] = \\widehat{r}_F[\\rho]</span>  for  <span class="math">\\rho \\in \\{1, 2\\}</span>  with  <span class="math">\\widehat{u}_l^*[\\rho] = \\widehat{s}_l^*[\\rho]^e \\cdot (h_{i^*})^{-\\widehat{r}_{i^*,l}[\\rho]}</span>  for  <span class="math">l \\in \\{1, \\ldots, \\alpha\\}</span> .</p>

    <p class="text-gray-300">We now lower bound the sum of success probabilities of  <span class="math">A_S</span>  and  <span class="math">A_T</span> . For each  <span class="math">(i, j) \\in W^J \\times W^S</span> , we call a run of  <span class="math">\\widehat{A}</span>  (i, j)-successful if  <span class="math">\\widehat{A}</span> 's output satisfies (23) and  <span class="math">(i^*, j^*) = (i, j)</span> . Let  <span class="math">S^*</span>  denote the event</p>

    <p class="text-gray-300">that both runs of  <span class="math">\\widehat{A}</span>  above are (i, j)-successful for some (i, j) and  <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span> . Note that if  <span class="math">S^*</span>  occurs then, defining  <span class="math">\\sigma^* = (h_i[1])^{1/e} \\mod N</span> , we have from (23) that</p>

    <p class="text-gray-300"><span class="math">\\widehat{m}^* = m_i[1] = m_i[2]</span>  has not been queried to S during either run of  <span class="math">\\widehat{A}</span>  and  <span class="math">R(m_i[1], h_i[1]) = Acc</span>  (25)</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$F_{pk}(\\widehat{u}_{i,1}[1], \\dots, \\widehat{u}_{i,\\alpha}[1]; \\widehat{r}_F^*[1]) = F_{pk}(\\widehat{u}_{i,1}[2], \\dots, \\widehat{u}_{i,\\alpha}[2]; \\widehat{r}_F^*[2])</span>$
with  <span class="math">\\widehat{u}_{i,l}[\\rho] = (\\widehat{s}_l^*[\\rho])^e \\cdot h_i[\\rho]^{-\\widehat{r}_{i,l}[\\rho]} \\mod N \\text{ for } \\rho \\in \\{1,2\\} \\text{ and } l \\in \\{1,\\dots,\\alpha\\}</span>  (26)</p>

    <p class="text-gray-300">(note that  <span class="math">(m_i[1], h_i[1], \\widehat{h}_i[1]) = (m_i[2], h_i[2], \\widehat{h}_i[2])</span>  because the view of  <span class="math">\\widehat{A}</span>  is the same in both runs up to ith J(.) query response). We now split event  <span class="math">S^*</span>  into two disjoint subevents  <span class="math">S^*_{S}</span>  and  <span class="math">S^*_{T}</span> , depending on whether</p>

    <p class="text-gray-300"><span class="math">$\\widehat{u}_{i,l}[1] = \\widehat{u}_{i,l}[2] \\text{ for all } l \\in \\{1, \\dots, \\alpha\\}</span>$</p>

    <p class="text-gray-300"><span class="math">$(27)</span>$</p>

    <p class="text-gray-300">holds or not, respectively. If the subevent  <span class="math">S_{S}^{*}</span>  occurs, then (27) holds. This means in particular that there exists  <span class="math">l^{*}</span>  such that  <span class="math">\\widehat{u}_{i,l^{*}}[1] = \\widehat{u}_{i,l^{*}}[2]</span>  but  <span class="math">\\widehat{r}_{i,l^{*}}[1] \\neq \\widehat{r}_{i,l^{*}}[2]</span> , which leads to  <span class="math">(\\widehat{s}_{l^{*}}^{*}[1]/\\widehat{s}_{l^{*}}^{*}[2]) \\equiv (\\sigma^{*})^{\\delta_{r}} \\mod N</span>  and hence  <span class="math">A_{S}</span> 's estimate  <span class="math">\\widehat{\\sigma}^{*} = (\\sigma^{*})^{c_{r}\\delta_{r}} \\cdot (\\sigma^{*})^{c_{e}e} \\mod N = \\sigma^{*} = h_{i}[1]^{1/e} \\mod N</span> , which coupled with (25) means that  <span class="math">R(m_{i}[1], h_{i}[1]) = Acc</span>  and  <span class="math">m_{i}[1]</span>  has not been queried to S, so  <span class="math">A_{S}</span>  succeeds to break the PV unforgeability of RSAUDVS when  <span class="math">S_{S}^{*}</span>  occurs. In the other case that subevent  <span class="math">S_{T}^{*}</span>  occurs, (27) does not hold but (26) holds, meaning that  <span class="math">A_{T}</span> 's output is a valid collision for the trapdoor hash so  <span class="math">A_{T}</span>  succeeds.</p>

    <p class="text-gray-300">So we have shown that the sum of success probabilities of  <span class="math">A_S</span>  and  <span class="math">A_T</span>  is equal to the probability of the event  <span class="math">S^*</span>  that both runs of  <span class="math">\\widehat{A}</span>  are (i,j)-successful for some  <span class="math">(i,j) \\in W^J \\times W^S</span>  and  <span class="math">\\widehat{r}_i[1] \\neq \\widehat{r}_i[2]</span> , and it remains to lower bound  <span class="math">\\Pr[S^*]</span> . Using the same calculation used to bound  <span class="math">\\Pr[S^*]</span>  in the proof of Theorem 4.3, we get</p>

    <p class="text-gray-300"><span class="math">$\\Pr[\\mathsf{S}^*] \\ge \\frac{1}{\\widehat{q}_I q_s} \\cdot \\left( \\Pr[\\mathsf{S}_0^1]/2 - \\widehat{q}_J q_s/2^{l_J} \\right)^2, \\tag{28}</span>$</p>

    <p class="text-gray-300">which using (24) gives the desired lower-bound (22) on  <span class="math">Pr[S^*]</span> . This completes the proof.</p>

    <p class="text-gray-300">Analogously to the proof of Theorem 4.4, we assume the <em>direct</em> verifier key-reg. protocol is used and we show how to construct the forgery strategy  <span class="math">\\widehat{A_1}</span> .</p>

    <p class="text-gray-300">Game yes. We recall first the original attack Game yes in which  <span class="math">A_1</span>  and  <span class="math">A_2</span>  interact.</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(A_1, A_2)</span>  is run on input (N, e).  <span class="math">A_1</span> 's oracle queries are answered as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1,.)</span>  Queries. When  <span class="math">A_1</span>  makes ith S-query  <span class="math">m_i</span> , it is answered with  <span class="math">\\sigma_i = S(x_1, m_i)</span> .</li>
      <li>(2) KRA Queries. When  <span class="math">A_1</span>  makes <em>i</em>th key-reg. query  <span class="math">(r_i, sk_i, pk_i)</span>  it is answered Acc if  <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span>  and Rej else.</li>
      <li>(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  sends message  <span class="math">m_i</span>  to  <span class="math">A_2</span> ,  <span class="math">A_2</span>  responds with an answer  <span class="math">a_i</span> .</li>
    </ul>

    <p class="text-gray-300">End of Stage 1. A&lt;sub&gt;1&lt;/sub&gt; outputs a challenge message  <span class="math">m^*</span> , which is given to A&lt;sub&gt;2&lt;/sub&gt;. A PV signature  <span class="math">\\sigma^* = S(x_1, m^*)</span>  is generated, where  <span class="math">\\sigma^* = (h^*)^{1/e} \\mod N</span>  and  <span class="math">h^* = H(m^*, s^*)</span>  for uniformly random  <span class="math">s^* \\in R_S</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries as in Stage 1 but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When A&lt;sub&gt;1&lt;/sub&gt; makes <em>i</em>th CDV-query  <span class="math">pk_i</span> , it is answered with DV signature  <span class="math">\\widehat{\\sigma}_i = (h_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{r}_i)</span> , where  <span class="math">h_i = h^*, \\widehat{r}_{F,i}</span>  is uniformly random in  <span class="math">R_F, \\widehat{r}_i = (\\widehat{r}_{i,1}, \\dots, \\widehat{r}_{i,\\alpha}) = J(m^*, h^*, \\widehat{h}_i), \\widehat{s}_i = (\\widehat{s}_{i,1}, \\dots, \\widehat{s}_{i,\\alpha})</span>  with  <span class="math">\\widehat{s}_{i,l} = k_{i,l} \\cdot (\\sigma^*)^{\\widehat{r}_{i,l}} \\mod N</span> ,  <span class="math">\\alpha</span>  random elements  <span class="math">k_i \\in \\mathbb{Z}_N^*</span> , and  <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}_i; \\widehat{r}_{F,i})</span>  with  <span class="math">\\widehat{u}_i = (\\widehat{u}_{i,1}, \\dots, \\widehat{u}_{i,\\alpha}), \\widehat{u}_{i,l} = k_{i,l}^e \\mod N</span>  for  <span class="math">l = 1, \\dots, \\alpha</span> .</p>

    <p class="text-gray-300">End of Stage 2.  <span class="math">A_2</span>  outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">Game no. We now describe the other game where  <span class="math">\\widehat{A_1}</span>  interacts with  <span class="math">A_2</span> .</p>

    <p class="text-gray-300">Stage 1. The pair  <span class="math">(\\widehat{A_1}, A_2)</span>  is run on input (N, e),, where  <span class="math">\\widehat{A_1}</span>  is also given the program for  <span class="math">A_1</span>  as input.  <span class="math">\\widehat{A_1}</span>  runs  <span class="math">A_1</span>  on same input and answers  <span class="math">A_1</span> 's oracle queries as follows.</p>

    <ul class="list-disc list-inside space-y-1 text-gray-300 my-2 ml-4">
      <li>(1)  <span class="math">S(x_1,.)</span>  Queries. When  <span class="math">A_1</span>  makes <em>i</em>th S-query  <span class="math">m_i</span> ,  <span class="math">\\widehat{A_1}</span>  forwards it to S oracle and forwards response  <span class="math">\\sigma_i = S(x_1, m_i)</span>  back to  <span class="math">A_1</span> .</li>
      <li>(2) KRA Queries. When  <span class="math">A_1</span>  makes ith key-reg. query  <span class="math">(r_i, sk_i, pk_i)</span> ,  <span class="math">\\widehat{A}_1</span>  answers Acc if  <span class="math">(sk_i, pk_i) = \\mathsf{GKF}(k; r_i)</span>  and stores  <span class="math">(sk_i, pk_i, Acc)</span>  in a table T, else it answers Rej.</li>
      <li>(3)  <span class="math">A_2</span>  Queries. When  <span class="math">A_1</span>  outputs a message  <span class="math">m_i</span>  for  <span class="math">A_2</span> ,  <span class="math">A_1</span>  forwards it to  <span class="math">A_2</span>  and forwards the answer  <span class="math">a_i</span>  back to  <span class="math">A_1</span> .</li>
    </ul>

    <p class="text-gray-300">End of Stage 1. A&lt;sub&gt;1&lt;/sub&gt; outputs a challenge message  <span class="math">m^*</span> , which is also output by  <span class="math">\\widehat{A}_1</span>  and given to A&lt;sub&gt;2&lt;/sub&gt;.  <span class="math">\\widehat{A}_1</span>  computes  <span class="math">h^* = H(m^*, s^*)</span> , for a uniformly random independent  <span class="math">s^* \\in R_S</span> . Stage 2 begins.</p>

    <p class="text-gray-300">Stage 2.  <span class="math">A_1</span>  continues to make S,KRA and  <span class="math">A_2</span>  queries, answered by  <span class="math">\\widehat{A_1}</span>  as in Stage 1, but can also make designation queries which are answered as follows:</p>

    <p class="text-gray-300">(1) CDV Queries. When  <span class="math">A_1</span>  makes ith CDV-query  <span class="math">pk_i</span> ,  <span class="math">\\widehat{A_1}</span>  searches table T for an entry  <span class="math">(sk_j, pk_j, Acc)</span>  with  <span class="math">pk_j = pk_i</span>  (note that this entry is guaranteed to exist in T due to the restriction on  <span class="math">A_1</span>  to only query CDV with public keys which have been answered with Acc by a previous KRA query) and answers with  <span class="math">\\widehat{\\sigma}_i = (h_i, \\widehat{r}_{F,i}, \\widehat{r}_i, \\widehat{s}_i)</span> , where  <span class="math">h_i = h^*</span> ,  <span class="math">\\widehat{r}_i = J(m^*, h^*, \\widehat{h}_i) = (\\widehat{r}_{i,1}, \\dots, \\widehat{r}_{i,\\alpha})</span> ,  <span class="math">\\widehat{h}_i = F_{pk}(\\widehat{u}&#x27;; \\widehat{r}&#x27;_{F,i})</span>  for some fixed  <span class="math">\\widehat{u}&#x27; = (\\widehat{u}&#x27;_1, \\dots, \\widehat{u}&#x27;_{\\alpha}) \\in (\\mathbb{Z}_N^*)^{\\alpha}</span>  and uniformly random and independent  <span class="math">\\widehat{r}&#x27;_{F,i} \\in R_F</span> ,  <span class="math">\\widehat{s}_i = (\\widehat{s}_{i,1}, \\dots, \\widehat{s}_{i,\\alpha})</span>  uniformly random and independent in  <span class="math">(\\mathbb{Z}_N^*)^{\\alpha}</span> , and  <span class="math">\\widehat{r}_{F,i} = \\mathsf{CSF}((sk_j, pk_j), (\\widehat{u}&#x27;, \\widehat{r}&#x27;_{F,i}), \\widehat{u}_i)</span> , with  <span class="math">\\widehat{u}_i = (\\widehat{u}_{i,1}, \\dots, \\widehat{u}_{i,\\alpha})</span> , where  <span class="math">\\widehat{u}_{i,l} = \\widehat{s}_{i,l}^{\\varepsilon} \\cdot (h^*)^{-\\widehat{r}_{i,l}} \\mod N</span> .</p>

    <p class="text-gray-300">End of Stage 2. A&lt;sub&gt;2&lt;/sub&gt; outputs a decision  <span class="math">d \\in \\{\\text{yes}, \\text{no}\\}</span> .</p>

    <p class="text-gray-300">We show that  <span class="math">A_1</span> 's (and hence also  <span class="math">A_2</span> 's) view is perfectly simulated in Game no as in Game yes. In particular, the DV signatures  <span class="math">(\\hat{\\sigma}_i = (h_i, \\hat{r}_{F,i}, \\hat{r}_i, \\hat{s}_i)</span>  are distributed identically in both games, for the following reasons. First, note that  <span class="math">h^*</span>  is computed identically in both games. Second, observe that for each DV signature,  <span class="math">\\hat{r}_i</span>  and  <span class="math">\\hat{s}_i</span>  are determined uniquely by  <span class="math">(m^*, h^*, \\hat{u}_i, \\hat{r}_{F,i})</span>  in the same way in both games, namely</p>

    <p class="text-gray-300"><span class="math">$\\widehat{r}_i = J(h^*, F_{nk}(\\widehat{u}_i; \\widehat{r}_{F,i}))</span>$</p>

    <p class="text-gray-300">and</p>

    <p class="text-gray-300"><span class="math">$\\widehat{s}_{i,l}</span>$
are the  <span class="math">e\\text{th}</span>  roots of  <span class="math">\\widehat{u}_i(h^*)^{\\widehat{r}_{i,l}} \\bmod N</span></p>

    <p class="text-gray-300">in both games. So it remains to show that (for each DV signature) the pair  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span>  is identically distributed in both games. In Game yes,  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i})</span>  is uniform on  <span class="math">G \\times R_F</span>  by definition. In Game no, we have that  <span class="math">(\\widehat{u}_i, \\widehat{r}_{F,i}) = G(\\widehat{s}_i, \\widehat{r}&#x27;_{F,i})</span>  for a function  <span class="math">G : (\\mathbb{Z}_N^*)^{\\alpha} \\times R_F \\to (\\mathbb{Z}_N^*)^{\\alpha} \\times R_F</span>  defined by:</p>

    <p class="text-gray-300"><span class="math">$\\widehat{u}_{i,l} = \\widehat{s}_{i,l}^e \\cdot (h^*)^{-J(h^*, F_{pk}(\\widehat{u}&#x27;; \\widehat{r}&#x27;_{F,i}))} \\mod N</span>$
(29)</p>

    <p class="text-gray-300"><span class="math">$\\widehat{r}_{F,i} = \\mathsf{CSF}((sk, pk), (\\widehat{u}&#x27;, \\widehat{r}&#x27;_{F,i}), \\widehat{u}_i). \\tag{30}</span>$</p>

    <p class="text-gray-300">From the perfectly-trapdoor property of TH we have that mapping  <span class="math">\\widehat{r}&#x27;_{F,i} \\mapsto \\mathsf{CSF}((sk,pk),(\\widehat{u}&#x27;,\\widehat{r}&#x27;_{F,i}),\\widehat{u}_i)</span>  is a permutation on  <span class="math">R_F</span> . This and the fact that  <span class="math">\\widehat{s}_{i,l} \\mapsto \\widehat{s}^e_{i,l} \\mod N</span>  is a permutation of  <span class="math">\\mathbb{Z}_N^*</span>  implies that G is permutation on  <span class="math">(\\mathbb{Z}_N^*)^{\\alpha} \\times R_F</span> . So since  <span class="math">(\\widehat{s}_i,\\widehat{r}&#x27;_{F,i})</span>  is uniform on  <span class="math">(\\mathbb{Z}_N^*)^{\\alpha} \\times R_F</span>  by definition, it follows</p>

    <p class="text-gray-300">that so is the image pair  <span class="math">(\\widehat{u}_i,\\widehat{r}_{F,i})</span> , as required. We conclude that  <span class="math">\\mathsf{A}_2</span>  outputs yes with same probability in both games and hence  <span class="math">C_{\\widehat{\\mathsf{A}_1}}(\\mathsf{A}_1,\\mathsf{A}_2)=0</span> , as claimed. The run-time of  <span class="math">\\widehat{\\mathsf{A}_1}</span>  is the run-time of  <span class="math">\\mathsf{A}_1</span>  plus the time  <span class="math">q_{d1}O(l_JT_N+T_F+T_{CSF}+T_J+T_H+q_{d1}l_{pk}+q_{k1}T_{GKF})</span>  to answer  <span class="math">\\mathsf{A}_1</span> 's CDV and KRA queries. Note that  <span class="math">\\widehat{q_{s1}}=q_{s1},\\ \\widehat{q_{c1}}=q_{c1},\\ \\mathrm{and}\\ \\widehat{q_{k1}}=0</span> , as claimed.</p>

`;
---

<BaseLayout title="Efficient Extension of Standard Schnorr/RSA signatures into ... (2003/193)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4"
        set:html={TITLE_HTML} />
      <p class="text-gray-400 mb-2"
        set:html={AUTHORS_HTML} />
      <p class="text-gray-500 text-sm mb-4">
        2003 &middot; eprint 2003/193
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <PaperDisclaimer eprintUrl={EPRINT_URL} />
      <p class="mt-1 text-xs text-gray-600">
        Converted with: {CRAWLER} &middot; {CONVERTED_DATE}
      </p>
    </header>

    <Fragment set:html={CONTENT} />

    <PaperHistory slug="efficient-extension-of-standard-schnorr-rsa-signatures-into-2003" />
  </article>
</BaseLayout>
