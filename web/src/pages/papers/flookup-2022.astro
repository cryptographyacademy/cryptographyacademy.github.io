---
import BaseLayout from '../../layouts/BaseLayout.astro';

const EPRINT_URL = 'https://eprint.iacr.org/2022/1447';
---

<BaseLayout title="flookup: Fractional decomposition-based lookups (2022/1447)">
  <article class="max-w-4xl mx-auto article-prose">
    <nav class="mb-8">
      <a href="/papers" class="text-blue-400 hover:text-blue-300">
        &larr; Back to Papers
      </a>
    </nav>

    <!-- ============================================================ -->
    <!-- HEADER                                                       -->
    <!-- ============================================================ -->

    <header class="mb-12">
      <h1 class="text-3xl font-bold mb-4">
        flookup: Fractional Decomposition-Based Lookups in
        Quasi-Linear Time Independent of Table Size
      </h1>
      <p class="text-gray-400 mb-2">
        Ariel Gabizon, Dmitry Khovratovich
      </p>
      <p class="text-gray-500 text-sm mb-4">
        2022 &middot; Full Version &middot; eprint 2022/1447
      </p>
      <div class="flex gap-4 text-sm">
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >
          Paper (eprint) &rarr;
        </a>
      </div>
      <p class="mt-4 text-xs text-gray-500">
        All content below belongs to the original authors. This page
        reproduces the paper for educational purposes. Always
        <a
          href={EPRINT_URL}
          target="_blank"
          rel="noopener noreferrer"
          class="text-blue-400 hover:text-blue-300"
        >cite the original</a>.
      </p>
    </header>

    <!-- ============================================================ -->
    <!-- TABLE OF CONTENTS                                            -->
    <!-- ============================================================ -->

    <nav id="toc" class="mb-10 p-6 rounded-lg"
      style="background: rgba(255,255,255,0.03);
             border: 1px solid rgba(255,255,255,0.06);">
      <h2 class="text-lg font-bold mb-4">Table of Contents</h2>
      <ol class="space-y-1 text-sm text-gray-300
        list-decimal list-inside">
        <li>
          <a href="#abstract"
            class="hover:text-white">Abstract</a>
        </li>
        <li>
          <a href="#sec-1"
            class="hover:text-white">Introduction</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-1.1"
                class="hover:text-white">
                Usefulness of the Result</a>
            </li>
            <li>
              <a href="#sec-1.2"
                class="hover:text-white">
                Organization of the Paper</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-2"
            class="hover:text-white">
            Terminology and Conventions</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-2.1"
                class="hover:text-white">
                Analysis in the AGM Model</a>
            </li>
            <li>
              <a href="#sec-2.2"
                class="hover:text-white">
                KZG-like Polynomial Commitment Schemes</a>
            </li>
            <li>
              <a href="#sec-2.3"
                class="hover:text-white">
                Other Notational Conventions</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-3"
            class="hover:text-white">
            Bi-linear Polynomial IOPs</a>
          <ol class="ml-6 mt-1 space-y-1 list-decimal
            list-inside text-gray-400">
            <li>
              <a href="#sec-3.1"
                class="hover:text-white">
                From BLIOPs to Protocols Against Algebraic
                Adversaries</a>
            </li>
            <li>
              <a href="#sec-3.2"
                class="hover:text-white">
                Conventions for Describing BLIOPs and PIOPs</a>
            </li>
          </ol>
        </li>
        <li>
          <a href="#sec-4"
            class="hover:text-white">
            Protocol for Subtable Extraction</a>
        </li>
        <li>
          <a href="#sec-5"
            class="hover:text-white">
            A PIOP for Lookups in Vanishing Form</a>
        </li>
        <li>
          <a href="#sec-6"
            class="hover:text-white">
            Putting It All Together</a>
        </li>
      </ol>
      <p class="text-xs text-gray-500 mt-4 mb-1 font-semibold">
        Additional
      </p>
      <ul class="space-y-1 text-sm text-gray-400 list-disc
        list-inside">
        <li>
          <a href="#acknowledgements"
            class="hover:text-white">Acknowledgements</a>
        </li>
        <li>
          <a href="#references"
            class="hover:text-white">References</a>
        </li>
      </ul>
    </nav>

    <!-- ============================================================ -->
    <!-- ABSTRACT                                                     -->
    <!-- ============================================================ -->

    <section id="abstract" class="mb-10">
      <h2 class="text-2xl font-bold">Abstract</h2>
      <p class="text-gray-300">
        We present a protocol for checking the values of a committed
        polynomial
        <span class="math">\phi(X) \in \mathbb&#123;F&#125;_&#123;\leq m&#125;[X]</span>
        over a multiplicative subgroup
        <span class="math">\mathbb&#123;H&#125; \subset \mathbb&#123;F&#125;</span>
        of size <span class="math">m</span> are contained in a table
        <span class="math">T \in \mathbb&#123;F&#125;^N</span>. After
        an
        <span class="math">O(N \log^2 N)</span> preprocessing step,
        the prover algorithm runs in quasi-linear time
        <span class="math">O(m \log^2 m)</span>. We improve upon the
        recent breakthrough results Caulk [ZBK+22] and Caulk+ [PK22],
        which were the first to achieve the complexity sublinear in the
        full table size
        <span class="math">N</span> with prover time being
        <span class="math">O(m^2 + m \log N)</span> and
        <span class="math">O(m^2)</span>, respectively. We pose
        further improving this complexity to
        <span class="math">O(m \log m)</span> as the next important
        milestone for efficient zk-SNARK lookups.
      </p>
      <p class="text-gray-300">
        <strong>Keywords:</strong> lookup arguments, zk-SNARKs,
        polynomial commitments, pairings
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 1. INTRODUCTION                                              -->
    <!-- ============================================================ -->

    <section id="sec-1" class="mb-10">
      <h2 class="text-2xl font-bold">1. Introduction</h2>

      <p class="text-gray-300">
        The lookup problem is fundamental to the efficiency of modern
        zk-SNARKs. Somewhat informally, it asks for a protocol to
        prove the values of a committed polynomial
        <span class="math">\phi(X) \in \mathbb&#123;F&#125;_&#123;\leq m&#125;[X]</span>
        are contained in a table
        <span class="math">T</span> of size
        <span class="math">N</span> of predefined legal values. When
        the table <span class="math">T</span> corresponds to an
        operation without an efficient low-degree arithmetization in
        <span class="math">\mathbb&#123;F&#125;</span>, such a
        protocol produces significant savings in proof construction
        time for programs containing the operation. Building on
        previous work of [BCG+18], plookup [GW20] was the first to
        explicitly describe a solution to this problem in the
        polynomial-IOP context. plookup described a protocol with
        prover complexity quasilinear in both
        <span class="math">m</span> and
        <span class="math">N</span>. This left the intriguing question
        of whether the dependence on
        <span class="math">N</span> could be made sublinear after
        performing a preprocessing step for the table
        <span class="math">T</span>. Caulk [ZBK+22] answered this
        question in the affirmative by leveraging bi-linear pairings,
        achieving a run time of
        <span class="math">O(m^2 + m \log N)</span>. Caulk+ [PK22]
        improved this to <span class="math">O(m^2)</span> getting rid
        of the dependence on table size completely.
      </p>

      <p class="text-gray-300">
        However, the quadratic dependence on
        <span class="math">m</span> of these works makes them
        impractical for a circuit with many lookup gates. We resolve
        this issue by giving a protocol called
        <strong>flookup</strong> that is quasi-linear in
        <span class="math">m</span> and has no dependence on
        <span class="math">N</span> after the preprocessing step.
      </p>

      <h3 id="sec-1.1" class="text-xl font-semibold mt-8 mb-3">
        1.1 Usefulness of the Result
      </h3>
      <p class="text-gray-300">
        When is it worth it to use Flookup instead of plookup? The
        plookup prover runs in time
        <span class="math">O(N \log N)</span> and the Flookup prover
        requires time
        <span class="math">O(m \log^2 m)</span> with small constants
        in the <span class="math">O()</span>. Hence, Flookup is worth
        it roughly when the table is larger than the number of lookups
        by a logarithmic factor; i.e. when
        <span class="math">m \ll N / \log N</span>.
      </p>

      <p class="text-gray-300">
        The authors note several trade-offs. Verification requires a
        pairing with a prover-defined
        <span class="math">\mathbb&#123;G&#125;_2</span> point (as do
        Caulk and Caulk+), which makes recursive aggregation of proofs
        less smooth. Another inconvenience is that Flookup does not
        have the nice linearity properties of plookup or Caulk, and so
        reducing a tuple lookup to a single element lookup is less
        efficient. For &ldquo;simple&rdquo; tables like
        <span class="math">T = 0, \ldots, 2^t - 1</span> for a range
        check, one can decompose into limbs and use a much smaller
        table. A better use case involves complex
        &ldquo;SNARK-unfriendly&rdquo; operations on large ranges,
        such as those arising inside SHA-256.
      </p>

      <h3 id="sec-1.2" class="text-xl font-semibold mt-8 mb-3">
        1.2 Organization of the Paper
      </h3>
      <p class="text-gray-300">
        Section 2 covers required preliminaries. Section 3 defines the
        notion of a bi-linear polynomial IOP which models protocols
        that use pairings in addition to polynomial commitment schemes.
        Section 4 reviews a method of [PK22] to extract a commitment
        to the vanishing polynomial of a subtable using pairings,
        extended to work with arbitrary sets. Section 5 gives a lookup
        protocol given a commitment to the vanishing polynomial of the
        table. Section 6 combines the table extraction and subtable
        lookup protocols to give the final result.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 2. TERMINOLOGY AND CONVENTIONS                               -->
    <!-- ============================================================ -->

    <section id="sec-2" class="mb-10">
      <h2 class="text-2xl font-bold">
        2. Terminology and Conventions
      </h2>

      <p class="text-gray-300">
        We assume our field
        <span class="math">\mathbb&#123;F&#125;</span> is of prime
        order. We denote by
        <span class="math">\mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>
        the set of univariate polynomials over
        <span class="math">\mathbb&#123;F&#125;</span> of degree
        smaller than <span class="math">d</span>. All algorithms
        receive the security parameter
        <span class="math">\lambda</span> as an implicit parameter.
      </p>

      <p class="text-gray-300">
        An &ldquo;object generator&rdquo;
        <span class="math">\mathcal&#123;O&#125;</span> is run with
        input <span class="math">\lambda</span> before all protocols,
        and returns all fields and groups used. Specifically,
        <span class="math">\mathcal&#123;O&#125;(\lambda) = (\mathbb&#123;F&#125;, \mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t, e, g_1, g_2, g_t)</span>
        where:
      </p>
      <ul class="list-disc list-inside text-gray-300 space-y-1 ml-4">
        <li>
          <span class="math">\mathbb&#123;F&#125;</span> is a prime
          field of super-polynomial size
          <span class="math">r = \lambda^&#123;\omega(1)&#125;</span>.
        </li>
        <li>
          <span class="math">\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2, \mathbb&#123;G&#125;_t</span>
          are groups of size
          <span class="math">r</span>, and
          <span class="math">e</span> is an efficiently computable
          non-degenerate pairing
          <span class="math">e : \mathbb&#123;G&#125;_1 \times \mathbb&#123;G&#125;_2 \to \mathbb&#123;G&#125;_t</span>.
        </li>
        <li>
          <span class="math">g_1, g_2</span> are uniformly chosen
          generators such that
          <span class="math">e(g_1, g_2) = g_t</span>.
        </li>
      </ul>

      <p class="text-gray-300">
        We write
        <span class="math">\mathbb&#123;G&#125;_1</span> and
        <span class="math">\mathbb&#123;G&#125;_2</span> additively.
        We use the notations
        <span class="math">[x]_1 := x \cdot g_1</span> and
        <span class="math">[x]_2 := x \cdot g_2</span>. We often
        denote by <span class="math">[n]</span> the integers
        <span class="math">\&#123;1, \ldots, n\&#125;</span>. We use
        the acronym e.w.p for &ldquo;except with
        probability&rdquo;.
      </p>

      <p class="text-gray-300">
        Protocols are public-coin interactive protocols between a
        prover and verifier. The SRS can be derived from an
        &ldquo;SRS of monomials&rdquo; of the form
        <span class="math">\&#123;[x^i]_1\&#125;_&#123;a \leq i \leq b&#125;, \&#123;[x^i]_2\&#125;_&#123;c \leq i \leq d&#125;</span>
        for uniform
        <span class="math">x \in \mathbb&#123;F&#125;</span>. It
        follows from Bowe et al. [BGM17] that the required SRS can be
        derived in a universal and updatable setup requiring only one
        honest participant.
      </p>

      <h3 id="sec-2.1" class="text-xl font-semibold mt-8 mb-3">
        2.1 Analysis in the AGM Model
      </h3>
      <p class="text-gray-300">
        For security analysis the authors use the Algebraic Group
        Model of Fuchsbauer, Kiltz and Loss [FKL18]. An algebraic
        adversary
        <span class="math">\mathcal&#123;A&#125;</span> in an
        SRS-based protocol is a
        <span class="math">\mathsf&#123;poly&#125;(\lambda)</span>-time
        algorithm which, for
        <span class="math">i \in \&#123;1, 2\&#125;</span>, whenever
        it outputs an element
        <span class="math">A \in \mathbb&#123;G&#125;_i</span>, also
        outputs a vector
        <span class="math">v</span> over
        <span class="math">\mathbb&#123;F&#125;</span> such that
        <span class="math">A = \langle v, \mathsf&#123;srs&#125;_i \rangle</span>.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.1 (Q-DLOG Assumption)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Fix integer <span class="math">Q</span>. The
            <span class="math">Q</span>-DLOG assumption for
            <span class="math">(\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2)</span>
            states that given
          </p>
          <div class="math-block">
            [1]_1, [x]_1, \ldots, [x^Q]_1, [1]_2, [x]_2, \ldots, [x^Q]_2
          </div>
          <p class="text-gray-300">
            for uniformly chosen
            <span class="math">x \in \mathbb&#123;F&#125;</span>, the
            probability of an efficient
            <span class="math">\mathcal&#123;A&#125;</span> outputting
            <span class="math">x</span> is
            <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>.
          </p>
        </div>
      </div>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 2.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Assume the <span class="math">Q</span>-DLOG for
            <span class="math">(\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2)</span>.
            Given an algebraic adversary
            <span class="math">\mathcal&#123;A&#125;</span>
            participating in a protocol with a degree
            <span class="math">Q</span> SRS, the probability of any
            real pairing check passing is larger by at most an additive
            <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>
            factor than the probability the corresponding ideal check
            holds.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Let
        <span class="math">\gamma</span> be the difference between
        the satisfiability of the real and ideal check. An adversary
        <span class="math">\mathcal&#123;A&#125;^*</span> for the
        <span class="math">Q</span>-DLOG problem is described that
        succeeds with probability
        <span class="math">\gamma</span>, implying
        <span class="math">\gamma = \mathsf&#123;negl&#125;(\lambda)</span>.
        <span class="math">\mathcal&#123;A&#125;^*</span> receives the
        challenge, constructs the SRS, runs the protocol with
        <span class="math">\mathcal&#123;A&#125;</span>, and if the
        real check passes but the ideal check fails, computes
        <span class="math">R := (R_1 \cdot T_1)(T_2 \cdot R_2)</span>.
        Since
        <span class="math">R \in \mathbb&#123;F&#125;_&#123;&lt; 2Q&#125;[X]</span>
        is a non-zero polynomial with
        <span class="math">R(x) = 0</span>,
        <span class="math">\mathcal&#123;A&#125;^*</span> can factor
        <span class="math">R</span> and find
        <span class="math">x</span>.
      </p>

      <p class="text-gray-300">
        The paper then defines <em>Knowledge Soundness in the
        Algebraic Group Model</em>: a protocol
        <span class="math">\mathscr&#123;P&#125;</span> has this
        property if there exists an efficient extractor
        <span class="math">E</span> such that the probability of any
        algebraic adversary winning a game where it chooses input
        <span class="math">x</span>, plays the prover role, and
        <span class="math">E</span> outputs
        <span class="math">\omega</span> with
        <span class="math">(x, \omega) \notin \mathcal&#123;R&#125;</span>
        while the verifier accepts, is
        <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>.
      </p>

      <h3 id="sec-2.2" class="text-xl font-semibold mt-8 mb-3">
        2.2 KZG-like Polynomial Commitment Schemes
      </h3>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 2.3 (d-Polynomial Commitment Scheme)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            A <span class="math">d</span>-polynomial commitment
            scheme (<span class="math">d</span>-PCS) over a field
            <span class="math">\mathbb&#123;F&#125;</span> consists
            of:
          </p>
          <ul class="list-disc list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              <span class="math">\mathsf&#123;gen&#125;(d)</span>: a
              randomized algorithm that outputs an SRS containing as a
              substring
              <span class="math">[1]_1, [x]_1, \ldots, [x^&#123;d-1&#125;]_1</span>
              for uniformly chosen
              <span class="math">x \in \mathbb&#123;F&#125;</span>
              and no other
              <span class="math">\mathbb&#123;G&#125;_1</span>
              elements.
            </li>
            <li>
              <span class="math">\mathsf&#123;com&#125;(f, \mathsf&#123;srs&#125;)</span>:
              given
              <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>,
              returns the commitment
              <span class="math">\mathsf&#123;cm&#125; := [f(x)]_1</span>.
            </li>
            <li>
              A public coin protocol
              <span class="math">\mathsf&#123;open&#125;</span>
              between parties
              <span class="math">P_&#123;PC&#125;</span> and
              <span class="math">V_&#123;PC&#125;</span>.
              <span class="math">P_&#123;PC&#125;</span> is given
              <span class="math">f_1, \ldots, f_t \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>.
              Both parties are given
              <span class="math">\mathsf&#123;cm&#125;_1, \ldots, \mathsf&#123;cm&#125;_t</span>,
              points
              <span class="math">z_1, \ldots, z_t \in \mathbb&#123;F&#125;</span>,
              and alleged openings
              <span class="math">s_1, \ldots, s_t \in \mathbb&#123;F&#125;</span>.
              At the end,
              <span class="math">V_&#123;PC&#125;</span> outputs
              <span class="math">\mathsf&#123;acc&#125;</span> or
              <span class="math">\mathsf&#123;rej&#125;</span>.
            </li>
          </ul>
          <p class="text-gray-300">
            satisfying completeness and binding knowledge soundness in
            the algebraic group model.
          </p>
        </div>
      </div>

      <h3 id="sec-2.3" class="text-xl font-semibold mt-8 mb-3">
        2.3 Other Notational Conventions
      </h3>
      <p class="text-gray-300">
        Given a polynomial
        <span class="math">f \in \mathbb&#123;F&#125;[X]</span> and a
        subset
        <span class="math">I \subset \mathbb&#123;F&#125;</span>, we
        define
        <span class="math">f|_I</span> to be the set
        <span class="math">\&#123;f(v)\&#125;_&#123;v \in I&#125;</span>.
        Given a set
        <span class="math">T \subset \mathbb&#123;F&#125;</span>, the
        vanishing polynomial of
        <span class="math">T</span> is:
      </p>
      <div class="math-block">
        Z_T(X) := \prod_&#123;i \in T&#125; (X - i)
      </div>
    </section>

    <!-- ============================================================ -->
    <!-- 3. BI-LINEAR POLYNOMIAL IOPS                                 -->
    <!-- ============================================================ -->

    <section id="sec-3" class="mb-10">
      <h2 class="text-2xl font-bold">
        3. Bi-linear Polynomial IOPs
      </h2>

      <p class="text-gray-300">
        While most recent works on zk-SNARKs have leveraged the power
        of polynomial commitment schemes [KZG10], [ZBK+22] has
        additionally leveraged the power of pairings to essentially
        take products of commitments. This enables checking degree two
        identities between polynomials without needing to compute the
        polynomials themselves, but only their commitments &mdash;
        which can be much faster when they are a small linear
        combination of preprocessed polynomials.
      </p>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3.1 (d-BLIOP)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Fix positive integer <span class="math">d</span> and
            field <span class="math">\mathbb&#123;F&#125;</span>. A
            <span class="math">d</span>-bi-linear polynomial IOP over
            <span class="math">\mathbb&#123;F&#125;</span>
            (<span class="math">d</span>-BLIOP) is a multiround
            protocol between a prover
            <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>,
            verifier
            <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>,
            and trusted party
            <span class="math">\mathcal&#123;I&#125;</span> that
            proceeds as follows:
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              The protocol includes two sets of preprocessed
              polynomials
              <span class="math">P_1, P_2 \subset \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>.
            </li>
            <li>
              The messages of
              <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
              are sent to
              <span class="math">\mathcal&#123;I&#125;</span> and are
              of the form
              <span class="math">(f, i)</span> for
              <span class="math">f \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>
              and
              <span class="math">i \in \&#123;1, 2\&#125;</span>.
            </li>
            <li>
              The messages of
              <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
              to
              <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
              are always random coins.
            </li>
            <li>
              At the end,
              <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
              may ask
              <span class="math">\mathcal&#123;I&#125;</span>
              evaluation queries
              <span class="math">(f, x)</span> for
              <span class="math">f \in A_1, x \in \mathbb&#123;F&#125;</span>,
              and bi-linear identity queries of the form
              <span class="math">\sum_&#123;j \in [k]&#125; c_j f_j(X) h_j(X) \stackrel&#123;?&#125;&#123;=&#125; 0</span>
              where
              <span class="math">f_j \in A_1, h_j \in A_2</span>.
            </li>
          </ol>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3.2 (d-BLIOP for a Relation)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given a relation
            <span class="math">\mathcal&#123;R&#125;</span>, a
            <span class="math">d</span>-BLIOP for
            <span class="math">\mathcal&#123;R&#125;</span> has:
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              Both parties are given input
              <span class="math">\mathsf&#123;x&#125;</span>; the
              prover possesses
              <span class="math">\omega</span> with
              <span class="math">(\mathsf&#123;x&#125;, \omega) \in \mathcal&#123;R&#125;</span>.
            </li>
            <li>
              <strong>Completeness:</strong> If
              <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
              follows the protocol correctly,
              <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
              accepts with probability one.
            </li>
            <li>
              <strong>Knowledge Soundness:</strong> There exists an
              efficient <span class="math">E</span> that, given access
              to the prover&rsquo;s messages and verifier randomness,
              outputs <span class="math">\omega</span> such that for
              any prover strategy, the probability that the verifier
              accepts yet
              <span class="math">(\mathsf&#123;x&#125;, \omega) \notin \mathcal&#123;R&#125;</span>
              is
              <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>.
            </li>
          </ol>
        </div>
      </div>

      <div class="formal-block formal-block-definition">
        <div class="formal-block-title text-blue-400">
          Definition 3.3 (d-BLIOP for a Language)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given a language
            <span class="math">\mathcal&#123;L&#125;</span>, a
            <span class="math">d</span>-BLIOP for
            <span class="math">\mathcal&#123;L&#125;</span> has:
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              Both parties are given input
              <span class="math">\mathsf&#123;x&#125;</span>.
            </li>
            <li>
              <strong>Completeness:</strong> If
              <span class="math">\mathsf&#123;x&#125; \in \mathcal&#123;L&#125;</span>
              and the prover follows the protocol correctly, the
              verifier accepts with probability one.
            </li>
            <li>
              <strong>Soundness:</strong> If
              <span class="math">\mathsf&#123;x&#125; \notin \mathcal&#123;L&#125;</span>,
              any prover strategy results in the verifier rejecting
              e.w.p
              <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>.
            </li>
          </ol>
        </div>
      </div>

      <h3 id="sec-3.1" class="text-xl font-semibold mt-8 mb-3">
        3.1 From BLIOPs to Protocols Against Algebraic Adversaries
      </h3>

      <p class="text-gray-300">
        We wish to &ldquo;compile&rdquo; BLIOPs to protocols against
        algebraic adversaries. Several terms are defined to track
        compilation efficiency:
        <span class="math">D_1(\mathscr&#123;P&#125;, \mathsf&#123;x&#125;, \omega)</span>
        counts the total degree contribution of prover polynomials sent
        to
        <span class="math">\mathbb&#123;G&#125;_1</span>;
        <span class="math">D_2</span> counts
        <span class="math">\mathbb&#123;G&#125;_2</span> scalar
        multiplications; and
        <span class="math">E(\mathscr&#123;P&#125;, \mathsf&#123;x&#125;, \omega)</span>
        is the total number of summands in all bi-linear queries.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 3.4 (Compilation Lemma)
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Assume the <span class="math">d</span>-DLOG assumption
            holds for
            <span class="math">(\mathbb&#123;G&#125;_1, \mathbb&#123;G&#125;_2)</span>.
            Given a <span class="math">d</span>-BLIOP
            <span class="math">\mathscr&#123;P&#125;</span> over
            <span class="math">\mathbb&#123;F&#125;</span> and a
            <span class="math">d</span>-PCS
            <span class="math">\mathscr&#123;S&#125;</span>, we can
            construct a protocol
            <span class="math">\mathscr&#123;P&#125;^*</span> for
            <span class="math">\mathcal&#123;R&#125;</span> with
            knowledge soundness against algebraic adversaries such
            that:
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              <strong>Preprocessing time:</strong> For
              <span class="math">i = 1, 2</span>,
              <span class="math">C_i(\mathscr&#123;P&#125;)</span>
              <span class="math">\mathbb&#123;G&#125;_i</span> scalar
              multiplications.
            </li>
            <li>
              <strong>Prover efficiency:</strong>
              <span class="math">D_i(\mathscr&#123;P&#125;, \mathsf&#123;x&#125;, \omega)</span>
              <span class="math">\mathbb&#123;G&#125;_i</span> scalar
              multiplications for
              <span class="math">i \in \&#123;1, 2\&#125;</span> plus
              running the prover of
              <span class="math">\mathscr&#123;S&#125;</span>.
            </li>
            <li>
              <strong>Verifier efficiency:</strong>
              <span class="math">E(\mathscr&#123;P&#125;, \mathsf&#123;x&#125;, \omega)</span>
              pairings and
              <span class="math">\mathbb&#123;G&#125;_t</span>
              exponentiations, plus the verifier of
              <span class="math">\mathscr&#123;S&#125;</span>.
            </li>
            <li>
              <strong>Proof size:</strong>
              <span class="math">B_i(\mathscr&#123;P&#125;)</span>
              <span class="math">\mathbb&#123;G&#125;_i</span>-elements
              plus a proof of
              <span class="math">\mathscr&#123;S&#125;</span>.
            </li>
          </ol>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof sketch.</em> The SRS of
        <span class="math">\mathscr&#123;P&#125;^*</span> consists of
        <span class="math">[1]_1, \ldots, [x^&#123;d-1&#125;]_1, [1]_2, \ldots, [x^&#123;d-1&#125;]_2</span>
        plus commitments to preprocessed polynomials. When
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        sends a message
        <span class="math">(f, i)</span> to
        <span class="math">\mathcal&#123;I&#125;</span>, the compiled
        prover sends
        <span class="math">[f]_i</span> to the verifier. Evaluation
        queries use the PCS opening protocol, and bi-linear queries
        become pairing checks
        <span class="math">\prod_&#123;i \in [k]&#125; e([f_i(x)]_1, [h_i(x)]_2)^&#123;c_i&#125; = 1</span>.
        Knowledge soundness follows by defining three events
        <span class="math">A, B, C</span> corresponding to PCS
        failure, pairing failure, and extraction failure, each shown to
        have
        <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>
        probability.
      </p>

      <h3 id="sec-3.2" class="text-xl font-semibold mt-8 mb-3">
        3.2 Conventions for Describing BLIOPs and PIOPs
      </h3>
      <p class="text-gray-300">
        Several shorthand conventions are established: (1) A BLIOP
        without bi-linear checks is called a PIOP; (2) &ldquo;Checks
        the identity
        <span class="math">P(f_1(X), \ldots, f_k(X))</span>&rdquo;
        means querying at random
        <span class="math">\alpha</span> and checking the evaluation;
        (3) &ldquo;Checks the identity on
        <span class="math">\mathbb&#123;H&#125;</span>&rdquo; means
        checking divisibility by
        <span class="math">Z_&#123;\mathbb&#123;H&#125;&#125;(X)</span>;
        (4) Efficiency descriptions implicitly use the compilation
        lemma; (5) Input polynomials are added to
        <span class="math">A_1</span> like preprocessed polynomials.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 4. PROTOCOL FOR SUBTABLE EXTRACTION                          -->
    <!-- ============================================================ -->

    <section id="sec-4" class="mb-10">
      <h2 class="text-2xl font-bold">
        4. Protocol for Subtable Extraction
      </h2>

      <p class="text-gray-300">
        The protocol in this section is similar to one implicit in
        Caulk+ [PK22]. Based on the innovation of Caulk, Caulk+ uses
        fractional decomposition to efficiently &ldquo;extract&rdquo;
        a vanishing polynomial
        <span class="math">Z_I</span> of a subset
        <span class="math">I \subset T</span> from
        <span class="math">Z_T</span>. In [PK22], the large set
        <span class="math">T</span> is always a multiplicative
        subgroup. The main innovation in this section is an algorithm
        that computes all subtable commitments of size
        <span class="math">|T| - 1</span> efficiently, ensuring that
        when <span class="math">T</span> is an arbitrary set, the
        preprocessing remains quasilinear rather than quadratic.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Given
            <span class="math">T \subset \mathbb&#123;F&#125;</span>
            of size <span class="math">N</span> and
            <span class="math">\&#123;[x^i]_2\&#125;_&#123;i \in \&#123;0, \ldots, N-1\&#125;\&#125;</span>,
            there is an algorithm using
            <span class="math">O(N \log^2 N)</span>
            <span class="math">\mathbb&#123;G&#125;_2</span>-scalar
            multiplications and
            <span class="math">\mathbb&#123;F&#125;</span>-operations
            for computing the set of elements
          </p>
          <div class="math-block">
            \mathcal&#123;T&#125; = \left\&#123; \left[ Z_&#123;T \setminus \&#123;i\&#125;&#125;(x) \right]_2 \right\&#125;_&#123;i \in T&#125;
          </div>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The proof uses a divide-and-conquer approach.
        The key idea is to express the matrix of subtable polynomial
        coefficients
        <span class="math">Z_&#123;T \setminus *&#125;</span>
        in terms of halves
        <span class="math">T_1, T_2</span> of
        <span class="math">T</span>:
      </p>
      <div class="math-block">
        Z_&#123;T \setminus *&#125; \times SRS = \begin&#123;bmatrix&#125; Z_&#123;T_1 \setminus *&#125; \times A_&#123;Z_&#123;T_2&#125;&#125; \times SRS \\ Z_&#123;T_2 \setminus *&#125; \times A_&#123;Z_&#123;T_1&#125;&#125; \times SRS \end&#123;bmatrix&#125;
      </div>

      <p class="text-gray-300">
        The algorithm proceeds as follows: (1) Compute coefficients of
        <span class="math">Z_T(X)</span> and its tree of subproducts
        in <span class="math">O(N \log^2 N)</span> time. (2) Split
        <span class="math">T</span> into halves and retrieve
        <span class="math">Z_&#123;T_1&#125;, Z_&#123;T_2&#125;</span>.
        (3) Compute Toeplitz matrix-vector products in
        <span class="math">O(N \log N)</span> time. (4) Apply
        recursively. This yields the recurrence
        <span class="math">C_1(N) = 2C_1(N/2) + O(N \log N)</span>,
        giving
        <span class="math">C_1(N) = O(N \log^2 N)</span>.
      </p>

      <p class="text-gray-300">
        The paper then describes the
        <strong>IsVanishingSubtable</strong> protocol.
      </p>

      <p class="text-gray-300">
        <strong>IsVanishingSubtable<span class="math">_T(g(X))</span></strong>
      </p>
      <p class="text-gray-300">
        Preprocessed polynomials: Let
        <span class="math">P_1 = \&#123;Z_T\&#125;</span>. For each
        <span class="math">i \in T</span> insert into
        <span class="math">P_2</span> the polynomial
        <span class="math">Z_&#123;T \setminus \&#123;i\&#125;&#125;</span>.
      </p>
      <p class="text-gray-300">
        Inputs:
        <span class="math">g(X) \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>.
        The prover also has the
        <span class="math">S \subset T</span> such that
        <span class="math">g(X) = Z_S(X)</span>.
      </p>
      <p class="text-gray-300">
        Protocol:
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        sends
        <span class="math">(Z_&#123;T \setminus S&#125;, 2)</span> to
        <span class="math">\mathcal&#123;I&#125;</span>.
        <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
        makes the bi-linear query
        <span class="math">g \cdot Z_&#123;T \setminus S&#125; \stackrel&#123;?&#125;&#123;=&#125; Z_T</span>
        and outputs
        <span class="math">\mathsf&#123;acc&#125;</span> iff it
        returns true.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 4.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            IsVanishingSubtable<span class="math">_T</span> is a
            <span class="math">d</span>-BLIOP for the language
            <span class="math">\mathcal&#123;L&#125; := \&#123;g(X) \in \mathbb&#123;F&#125;_&#123;\leq d&#125;[X] \mid g(X) = Z_S(X) \text&#123; for some &#125; S \subseteq T\&#125;</span>.
            On input
            <span class="math">g = Z_S</span>, the prover complexity
            is
            <span class="math">O(m \log^2 m)</span>
            <span class="math">\mathbb&#123;F&#125;</span>-operations
            and <span class="math">O(m)</span>
            <span class="math">\mathbb&#123;G&#125;_1</span> and
            <span class="math">\mathbb&#123;G&#125;_2</span>-scalar
            multiplications, where
            <span class="math">m = |S|</span>. Denoting
            <span class="math">|T| = N</span>, preprocessing takes
            <span class="math">O(N \log^2 N)</span>
            <span class="math">\mathbb&#123;G&#125;_2</span>-scalar
            multiplications and
            <span class="math">\mathbb&#123;F&#125;</span>-operations.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Correctness and soundness are immediate: the
        check passes if and only if
        <span class="math">g</span> divides
        <span class="math">Z_T</span>, which happens if and only if
        <span class="math">g = Z_S</span> for some
        <span class="math">S \subseteq T</span>. For efficiency, the
        key observation is that
      </p>
      <div class="math-block">
        Z_&#123;T \setminus S&#125;(X) = \sum_&#123;i \in S&#125; c_i Z_&#123;T \setminus \&#123;i\&#125;&#125;(X)
      </div>
      <p class="text-gray-300">
        where coefficients
        <span class="math">c_i = 1 / Z'_S(i)</span> are computed via
        the derivative
        <span class="math">Z'_S(X)</span> in
        <span class="math">O(m \log^2 m)</span> time. Thus
        <span class="math">[Z_&#123;T \setminus S&#125;(x)]_2</span>
        can be computed with
        <span class="math">m</span>
        <span class="math">\mathbb&#123;G&#125;_2</span> scalar
        multiplications from the preprocessed elements.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 5. A PIOP FOR LOOKUPS IN VANISHING FORM                      -->
    <!-- ============================================================ -->

    <section id="sec-5" class="mb-10">
      <h2 class="text-2xl font-bold">
        5. A PIOP for Lookups When Given the Table in Vanishing Form
      </h2>

      <p class="text-gray-300">
        The previous section gives a way to extract the vanishing
        polynomial of the subtable. Rather than converting to
        evaluation form and using plookup, the authors give a protocol
        that works directly with the vanishing form of the table. It
        requires roughly
        <span class="math">3m</span>
        <span class="math">\mathbb&#123;G&#125;_1</span>-scalar
        multiplications when both witness and table are of size
        <span class="math">m</span>, compared to plookup&rsquo;s
        <span class="math">5m</span>.
      </p>

      <p class="text-gray-300">
        <strong>Unnormalized rational Lagrange functions.</strong>
        Fix a set
        <span class="math">T \subset \mathbb&#123;F&#125;</span>. For
        <span class="math">v \in \mathbb&#123;F&#125;</span>, define
        the rational function:
      </p>
      <div class="math-block">
        \Gamma_v^T(X) := \frac&#123;Z_T(X)&#125;&#123;X - v&#125;
      </div>
      <p class="text-gray-300">
        Note that
        <span class="math">\Gamma_v^T</span> is a polynomial exactly
        when <span class="math">v \in T</span>.
      </p>

      <div class="formal-block formal-block-lemma">
        <div class="formal-block-title text-amber-400">
          Lemma 5.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Fix any vectors
            <span class="math">v, a \in \mathbb&#123;F&#125;^m</span>,
            and any subset
            <span class="math">T \subset \mathbb&#123;F&#125;</span>.
            Define the rational function
            <span class="math">R(X) := \sum_&#123;j \in [m]&#125; a_j \Gamma_&#123;v_j&#125;^T(X)</span>.
          </p>
          <ol class="list-decimal list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              If for all
              <span class="math">j \in [m]</span>,
              <span class="math">v_j \in T</span>, then
              <span class="math">R(X) \in \mathbb&#123;F&#125;[X]</span>.
            </li>
            <li>
              Let
              <span class="math">S \subset [m]</span> be the set of
              <span class="math">j \in [m]</span> such that
              <span class="math">v_j \notin T</span>. Assume
              <span class="math">S \neq \emptyset</span>. Then if
              <span class="math">\sum_&#123;j \in S&#125; a_j \neq 0</span>,
              <span class="math">R(X) \notin \mathbb&#123;F&#125;[X]</span>.
              In particular, assuming
              <span class="math">|\mathrm&#123;char&#125;(\mathbb&#123;F&#125;)| &gt; m</span>,
              <span class="math">R(X) \notin \mathbb&#123;F&#125;[X]</span>
              when taking
              <span class="math">a_j = 1</span> for all
              <span class="math">j \in [m]</span>.
            </li>
          </ol>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The first item is obvious. For the second,
        write
        <span class="math">R(X) = R_1(X) + R_2(X)</span> where
        <span class="math">R_1</span> sums over polynomial terms
        (indices outside <span class="math">S</span>) and
        <span class="math">R_2</span> sums over potentially
        non-polynomial terms. If
        <span class="math">R_2 \in \mathbb&#123;F&#125;[X]</span>,
        then multiplying denominators yields
        <span class="math">Z_T(X) Q'(X) = R_2(X) Q(X)</span> where
        <span class="math">Q(X) = \prod_&#123;j \in S&#125; (X - v_j)</span>
        and
        <span class="math">Q'(X) = \sum_&#123;j \in S&#125; a_j \prod_&#123;i \in S \setminus \&#123;j\&#125;&#125; (X - v_i)</span>.
        The case
        <span class="math">R_2 \equiv 0</span> is ruled out since the
        leading coefficient of
        <span class="math">Q'</span> is
        <span class="math">\sum_&#123;j \in S&#125; a_j \neq 0</span>.
        For
        <span class="math">R_2 \not\equiv 0</span>, since no factor
        of <span class="math">Q</span> divides
        <span class="math">Z_T</span>, we need
        <span class="math">Q | Q'</span>, but
        <span class="math">\deg(Q') &lt; \deg(Q)</span>, a
        contradiction.
      </p>

      <p class="text-gray-300">
        The above lemma suggests the following protocol. Let
        <span class="math">\mathbb&#123;H&#125; = \&#123;\mathbf&#123;g&#125;, \mathbf&#123;g&#125;^2, \ldots, \mathbf&#123;g&#125;^m = 1\&#125; \subset \mathbb&#123;F&#125;</span>
        be a multiplicative subgroup of size
        <span class="math">m</span> with generator
        <span class="math">\mathbf&#123;g&#125;</span>. Given
        <span class="math">\phi(X)</span>, define
        <span class="math">R_&#123;T, \phi&#125;(X) := \sum_&#123;v \in \mathbb&#123;H&#125;&#125; \Gamma_&#123;\phi(v)&#125;^T(X)</span>.
        The protocol commits to
        <span class="math">R_&#123;T, \phi&#125;(X)</span> and proves
        correctness, showing it is a polynomial and therefore
        <span class="math">\phi|_&#123;\mathbb&#123;H&#125;&#125; \subset T</span>.
      </p>

      <p class="text-gray-300">
        <strong>IsInVanishing<span class="math">_&#123;\mathbb&#123;H&#125;, T&#125;(\phi)</span></strong>
      </p>
      <p class="text-gray-300">
        Preprocessed polynomials:
        <span class="math">P_1 = \&#123;Z_T\&#125;</span>.
        Input:
        <span class="math">\phi \in \mathbb&#123;F&#125;_&#123;\leq d&#125;[X]</span>.
      </p>
      <p class="text-gray-300">
        Protocol: (1)
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        sends the polynomial
        <span class="math">g(X) := R_&#123;T, \phi&#125;(X)</span>.
        (2)
        <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
        chooses random
        <span class="math">\beta</span> and queries
        <span class="math">z := g(\beta)</span>. (3)
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        computes and sends
        <span class="math">Z(X) \in \mathbb&#123;F&#125;_&#123;\leq m&#125;[X]</span>
        defined by
        <span class="math">Z(\mathbf&#123;g&#125;^i) = \sum_&#123;j=1&#125;^&#123;i&#125; \Gamma_&#123;\phi(\mathbf&#123;g&#125;^j)&#125;^T(\beta)</span>
        for each
        <span class="math">i \in [m]</span>. (4)
        <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
        queries
        <span class="math">Z_T(\beta)</span>. (5)
        <span class="math">V_&#123;\mathsf&#123;poly&#125;&#125;</span>
        checks on
        <span class="math">\mathbb&#123;H&#125;</span> the
        identities:
      </p>
      <div class="math-block">
        \text&#123;(a)&#125; \quad L_1(X)(Z(X)(\beta - \phi(X)) - Z_T(\beta)) = 0
      </div>
      <div class="math-block">
        \text&#123;(b)&#125; \quad (X - \mathbf&#123;g&#125;)\left(Z(X) - Z(X/\mathbf&#123;g&#125;) - \frac&#123;Z_T(\beta)&#125;&#123;\beta - \phi(X)&#125;\right) = 0
      </div>
      <div class="math-block">
        \text&#123;(c)&#125; \quad L_m(X)(Z(X) - z) = 0
      </div>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 5.2
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            IsInVanishing<span class="math">_&#123;\mathbb&#123;H&#125;, T&#125;</span>
            is a <span class="math">d</span>-PIOP for the language
            <span class="math">\mathcal&#123;L&#125; := \&#123;\phi(X) \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X] \mid \phi|_&#123;\mathbb&#123;H&#125;&#125; \subset T\&#125;</span>.
            When
            <span class="math">\deg(\phi), |T| = O(m)</span>, the
            prover runs in time
            <span class="math">O(m \log^2 m)</span>.
          </p>
          <p class="text-gray-300">
            Additionally, after a preprocessing phase depending on
            <span class="math">T</span> consisting of
            <span class="math">O(m \log^2 m)</span>
            <span class="math">\mathbb&#123;G&#125;_1</span>-scalar
            multiplications, the prover only requires
            <span class="math">O(m \log m)</span>
            <span class="math">\mathbb&#123;F&#125;</span>-operations
            and <span class="math">O(m)</span>
            <span class="math">\mathbb&#123;G&#125;_1</span>-scalar
            multiplications.
          </p>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> Assume
        <span class="math">\phi \notin \mathcal&#123;L&#125;</span>.
        Let <span class="math">E</span> be the event that
        <span class="math">g(\beta) = R_&#123;T, \phi&#125;(\beta)</span>.
        When
        <span class="math">\phi(X) \notin \mathcal&#123;L&#125;</span>,
        Lemma 5.1 implies
        <span class="math">R_&#123;T, \phi(X)&#125; \notin \mathbb&#123;F&#125;[X]</span>.
        As
        <span class="math">g \in \mathbb&#123;F&#125;_&#123;\leq d&#125;[X]</span>,
        <span class="math">E</span> has probability
        <span class="math">\mathsf&#123;negl&#125;(\lambda)</span>.
      </p>
      <p class="text-gray-300">
        The checks in step 5 imply that
        <span class="math">R_&#123;T, \phi&#125;(\beta) = g(\beta)</span>:
        check (a) establishes the base case
        <span class="math">Z(\mathbf&#123;g&#125;) = \Gamma_&#123;\phi(\mathbf&#123;g&#125;)&#125;^T(\beta)</span>;
        check (b) establishes the inductive step; and check (c)
        connects
        <span class="math">Z(\mathbf&#123;g&#125;^m) = z = g(\beta)</span>.
        For prover runtime, the heaviest component is computing
        <span class="math">R_&#123;T, \phi&#125;</span>&rsquo;s values
        on <span class="math">T</span> in time
        <span class="math">O(m \log^2 m)</span>. The key identity is
      </p>
      <div class="math-block">
        R_&#123;T, \phi&#125;(X) = \sum_&#123;v \in T&#125; a_v \Gamma_v^T(X) = \sum_&#123;v \in T&#125; a_v c_v \tau_v(X)
      </div>
      <p class="text-gray-300">
        where
        <span class="math">a_v</span> counts the multiplicity of
        <span class="math">v</span> in
        <span class="math">\phi|_&#123;\mathbb&#123;H&#125;&#125;</span>,
        <span class="math">c_v = \prod_&#123;v \neq i \in T&#125;(v - i)</span>,
        and
        <span class="math">\tau_v</span> is the Lagrange basis of
        <span class="math">T</span>. The constants
        <span class="math">\&#123;c_v\&#125;</span> are evaluations of
        <span class="math">Z'_T(X)</span> at
        <span class="math">T</span>, computable in the required time.
        The &ldquo;additionally&rdquo; part follows by precomputing
        <span class="math">S_v := [\Gamma_v^T(x)]_1</span> for all
        <span class="math">v \in T</span> using Lemma 4.1.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- 6. PUTTING IT ALL TOGETHER                                   -->
    <!-- ============================================================ -->

    <section id="sec-6" class="mb-10">
      <h2 class="text-2xl font-bold">
        6. Putting It All Together
      </h2>

      <p class="text-gray-300">
        <strong>IsInVanishingTable<span class="math">_&#123;\mathbb&#123;H&#125;, T&#125;(\phi)</span></strong>
      </p>
      <p class="text-gray-300">
        Preprocessed polynomials:
        <span class="math">P_1 = \&#123;Z_T\&#125;</span>.
        Input:
        <span class="math">\phi \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X]</span>.
      </p>
      <p class="text-gray-300">
        Protocol: (1)
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        computes the set
        <span class="math">I \subseteq T</span> such that
        <span class="math">I = \phi|_&#123;\mathbb&#123;H&#125;&#125;</span>.
        (2)
        <span class="math">P_&#123;\mathsf&#123;poly&#125;&#125;</span>
        computes and sends
        <span class="math">Z_I</span>. (3) Run
        IsVanishingSubtable<span class="math">_T(Z_I)</span>. (4) Run
        IsInVanishing<span class="math">_&#123;\mathbb&#123;H&#125;, Z_I&#125;(\phi)</span>.
      </p>

      <div class="formal-block formal-block-theorem">
        <div class="formal-block-title text-green-400">
          Theorem 6.1
        </div>
        <div class="formal-block-content">
          <p class="text-gray-300">
            Let <span class="math">N = |T|</span>.
            IsInVanishingTable<span class="math">_&#123;\mathbb&#123;H&#125;, T&#125;</span>
            is a <span class="math">d</span>-BLIOP for the language
            <span class="math">\&#123;\phi \in \mathbb&#123;F&#125;_&#123;&lt; d&#125;[X] \mid \phi|_&#123;\mathbb&#123;H&#125;&#125; \subset T\&#125;</span>
            such that:
          </p>
          <ul class="list-disc list-inside text-gray-300
            space-y-1 ml-4">
            <li>
              <span class="math">O(N \log^2 N)</span>
              <span class="math">\mathbb&#123;G&#125;_2</span>-scalar
              multiplications and
              <span class="math">\mathbb&#123;F&#125;</span>-operations
              are required in preprocessing.
            </li>
            <li>
              The prover requires
              <span class="math">O(m \log^2 m)</span>
              <span class="math">\mathbb&#123;F&#125;</span>-operations
              and <span class="math">O(m)</span>
              <span class="math">\mathbb&#123;G&#125;_1</span> and
              <span class="math">\mathbb&#123;G&#125;_2</span>-scalar
              multiplications.
            </li>
          </ul>
        </div>
      </div>

      <p class="text-gray-300">
        <em>Proof.</em> The only thing left to address is that the
        computation of
        <span class="math">Z_I</span> in the second step can be done
        in time
        <span class="math">O(m \log^2 m)</span>. This follows from
        algorithm 10.3 in [vzGG].
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- ACKNOWLEDGEMENTS                                             -->
    <!-- ============================================================ -->

    <section id="acknowledgements" class="mb-10">
      <h2 class="text-2xl font-bold">Acknowledgements</h2>
      <p class="text-gray-300">
        The first author thanks Aztec Network for support of this
        work. The authors thank Mary Maller and Arantxa Zapico for
        helpful discussions. The construction in Section 5 is inspired
        by a construction of Carla R&agrave;fols and Arantxa Zapico
        for a similar problem. They also thank Piotr
        Miko&lstrok;ajczyk and Yuncong Zhang for corrections.
      </p>
    </section>

    <!-- ============================================================ -->
    <!-- REFERENCES                                                   -->
    <!-- ============================================================ -->

    <section id="references" class="mb-10">
      <h2 class="text-2xl font-bold">References</h2>
      <ol class="list-decimal list-inside space-y-2 text-gray-400
        text-sm">
        <li>
          [BCG+18] J. Bootle, A. Cerulli, J. Groth, S. K. Jakobsen,
          and M. Maller. &ldquo;Arya: Nearly Linear-Time
          Zero-Knowledge Proofs for Correct Program Execution&rdquo;.
          In: <em>ASIACRYPT 2018, Part I</em>. Vol. 11272. LNCS.
          Springer, 2018, pp. 595&ndash;626.
        </li>
        <li>
          [BGM17] S. Bowe, A. Gabizon, and I. Miers. &ldquo;Scalable
          Multi-Party Computation for zk-SNARK Parameters in the
          Random Beacon Model&rdquo;. Cryptology ePrint Archive,
          Report 2017/1050, 2017.
          <a
            href="https://eprint.iacr.org/2017/1050"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >eprint.iacr.org/2017/1050</a>.
        </li>
        <li>
          [Dra] J. Drake. Talk recording.
          <a
            href="https://youtu.be/tbnaud5wgxm?t=2251"
            target="_blank"
            rel="noopener noreferrer"
            class="text-blue-400 hover:text-blue-300"
          >youtu.be/tbnaud5wgxm?t=2251</a>.
        </li>
        <li>
          [FKL18] G. Fuchsbauer, E. Kiltz, and J. Loss. &ldquo;The
          Algebraic Group Model and Its Applications&rdquo;. In:
          <em>CRYPTO 2018, Part II</em>. 2018, pp. 33&ndash;62.
        </li>
        <li>
          [Gro16] J. Groth. &ldquo;On the Size of Pairing-Based
          Non-Interactive Arguments&rdquo;. In: <em>EUROCRYPT 2016,
          Part II</em>. 2016, pp. 305&ndash;326.
        </li>
        <li>
          [GVL13] Gene H. Golub and Charles F. Van Loan.
          <em>Matrix Computations</em>. JHU Press, 2013.
        </li>
        <li>
          [GW20] A. Gabizon and Z. J. Williamson.
          &ldquo;plookup: A Simplified Polynomial Protocol for Lookup
          Tables&rdquo;. IACR Cryptol. ePrint Arch., page 315, 2020.
        </li>
        <li>
          [GWC19] A. Gabizon, Z. J. Williamson, and O. Ciobotaru.
          &ldquo;PLONK: Permutations over Lagrange-Bases for
          Oecumenical Noninteractive Arguments of Knowledge&rdquo;.
          IACR Cryptology ePrint Archive, 2019:953, 2019.
        </li>
        <li>
          [KZG10] A. Kate, G. M. Zaverucha, and I. Goldberg.
          &ldquo;Constant-Size Commitments to Polynomials and Their
          Applications&rdquo;. 2010, pp. 177&ndash;194.
        </li>
        <li>
          [PK22] J. Posen and A. A. Kattis. &ldquo;Caulk+:
          Table-Independent Lookup Arguments&rdquo;. 2022.
        </li>
        <li>
          [TAB+20] A. Tomescu, I. Abraham, V. Buterin, J. Drake,
          D. Feist, and D. Khovratovich. &ldquo;Aggregatable
          Subvector Commitments for Stateless
          Cryptocurrencies&rdquo;. In: <em>SCN 2020</em>. Vol. 12238.
          LNCS. Springer, 2020, pp. 45&ndash;64.
        </li>
        <li>
          [vzGG] J. von zur Gathen and J. Gerhard. &ldquo;Fast
          Polynomial Evaluation and Interpolation&rdquo;.
          <em>Modern Computer Algebra</em>, chapter 10,
          pp. 295&ndash;310.
        </li>
        <li>
          [ZBK+22] A. Zapico, V. Buterin, D. Khovratovich,
          M. Maller, A. Nitulescu, and M. Simkin. &ldquo;Caulk:
          Lookup Arguments in Sublinear Time&rdquo;. IACR Cryptol.
          ePrint Arch., page 621, 2022.
        </li>
      </ol>
    </section>

  </article>
</BaseLayout>
